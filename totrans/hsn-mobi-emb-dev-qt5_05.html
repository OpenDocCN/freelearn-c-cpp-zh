<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Input and Touch</h1>
                </header>
            
            <article>
                
<p class="mce-root">Not all devices have a readily available keyboard. With a touchscreen device, users can easily use buttons and other <strong>User Interface</strong> (<strong>UI</strong>) features. What do you do when there is no keyboard or mouse, like on<span> a kiosk or interactive signage</span>? Virtual keyboards and touch interaction define mobile and embedded applications these days.</p>
<p class="mce-root">In this chapter, we will cover the following topics:</p>
<ul>
<li class="mce-root">We will discover Qt's graphical solutions to incorporating user input.</li>
<li class="mce-root">The reference Qt Virtual Keyboard will be examined.</li>
<li class="mce-root">We will demonstrate Touch components, such as <kbd>TouchPoints</kbd>, <kbd>Flickable</kbd>, and <kbd>PinchArea</kbd>.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What to do when there's no keyboard</h1>
                </header>
            
            <article>
                
<p class="mce-root">Dude, where's my keyboard?</p>
<p>Computer information kiosks and cars do not usually come with keyboard inputs. They use virtual inputs, such as a virtual keyboard, voice inputs, or even gesture recognition.</p>
<p>People at the Qt Company have created a virtual input method they named <strong>Qt Virtual Keyboard</strong> (<strong>QtVK</strong>). It's more than just an onscreen keyboard, as it also has handwriting recognition. It is available under a commercial license as well as the open source GPL version 3.</p>
<p>There are other virtual keyboards that will work with Qt apps. On a desktop computer that also has a touchscreen, such as a two-in-one laptop, the system might already have a virtual keyboard. These should work as an input method for Qt apps, although they may or may not automatically pop up when the user wants to input into a text area. </p>
<p>There are two ways to integrate Qt's Virtual Keyboard:</p>
<table style="border-collapse: collapse;width: 100%">
<tbody>
<tr style="height: 36.9688px">
<td style="height: 36.9688px;width: 23.0028%"><span>Desktop system</span></td>
<td style="height: 36.9688px;width: 76.1708%"><span>Fully integrated into applications</span></td>
</tr>
<tr style="height: 32px">
<td style="height: 32px;width: 23.0028%"><span>Application</span></td>
<td style="height: 32px;width: 76.1708%">
<p class="mce-root"><span><span>Qt Widget apps: </span></span>Set environmental <kbd>QT_IM_MODULE=qtvirtualkeyboard</kbd> variable</p>
<p><span>Qt Quick: </span><span>Use</span><span> </span><kbd>InputPanel</kbd><span> </span><span>in your application</span></p>
</td>
</tr>
</tbody>
</table>
<p>I have a Raspberry Pi setup here for Boot to Qt, which is fully integrated into the Qt Creator, so I can build and run Qt apps on the Raspberry Pi from the Qt Creator. You can also grab the sources and build it yourself from <kbd>git://code.qt.io/qt/qtvirtualkeyboard.git</kbd>.</p>
<p>To build the QtVK, download the following source:</p>
<p><kbd>git clone git://code.qt.io/qt/qtvirtualkeyboard.git</kbd></p>
<p>QtVK build can be configured by <kbd>qmake</kbd>, using <kbd>CONFIG+=&lt;configuration&gt;</kbd> and the following configuration options:</p>
<ul>
<li><kbd>lang &lt;code&gt;</kbd>
<ul>
<li><kbd>form of language_country</kbd>
<ul>
<li>Language is lowercase, a two-letter language code</li>
<li>Country is uppercase, a two-letter country code</li>
</ul>
</li>
</ul>
</li>
<li><kbd>lang-all</kbd></li>
<li><kbd>handwriting</kbd><br/>
<ul>
<li>Handles custom engines</li>
</ul>
</li>
<li>Arrow-key navigation</li>
</ul>
<div class="packt_infobox">For example, to configure only Australian-English and add handwriting support, you would run <kbd>qmake CONFIG+=lang-en_AU CONFIG+=handwriting</kbd> and then <kbd>make &amp;&amp; make install</kbd>.</div>
<p>There are many other configurations available. You can disable layouts for creating a custom layout and <span>desktop integration, </span>among other configurations.</p>
<p>QtVK can be used in C++ or QML. Let's start by using Qt Quick by ticking the <span class="packt_screen">Use Qt Virtual Keyboard</span> in the Qt Creator project wizard when creating a new <span class="packt_screen">Qt Quick Application</span> from a template:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3a8ba860-c0ee-4071-a651-76cb98a33e95.png" style="width:44.25em;height:18.75em;"/></p>
<p><span>This is the boiler plate code you get when you use Boot to Qt for Device Creation:</span></p>
<pre><span>    </span><span>InputPanel</span><span> </span>{<br/><span>        </span><span>id</span>:<span> </span><span>inputPanel<br/></span><span>        </span><span>z</span>:<span> </span>99<br/><span>        </span><span>x</span>:<span> </span>0<br/><span>        </span><span>y</span>:<span> </span><span>window</span>.height<br/><span>        </span><span>width</span>:<span> </span><span>window</span>.width<br/>        <span>states</span><span>:</span><span> </span><span>State</span><span> </span><span>{<br/></span><span>            </span><span>name</span>:<span> </span><span>"visible"<br/></span><span>            </span><span>when</span>:<span> </span><span>inputPanel</span>.active<br/><span>            </span><span>PropertyChanges</span><span> </span>{<br/><span>                </span><span>target</span>:<span> </span><span>inputPanel<br/></span><span>                </span><span>y</span>:<span> </span><span>window</span>.height<span> </span>-<span> </span><span>inputPanel</span>.height<br/><span>            </span>}<br/><span>        </span>}<br/><span>        </span><span>transitions</span>:<span> </span><span>Transition</span><span> </span>{<br/><span>            </span><span>from</span>:<span> </span><span>""<br/></span><span>            </span><span>to</span>:<span> </span><span>"visible"<br/></span><span>            </span><span>reversible</span>:<span> </span>true<br/><span>            </span><span>ParallelAnimation</span><span> </span>{<br/><span>                </span><span>NumberAnimation</span><span> </span>{<br/><span>                    </span><span>properties</span>:<span> </span><span>"y"<br/></span><span>                    </span><span>duration</span>:<span> </span>250<br/><span>                    </span><span>easing.type</span>:<span> </span><span>Easing</span>.InOutQuad<br/><span>                </span>}<br/><span>            </span>}<br/><span>        </span>}<br/><span>    </span>}</pre>
<div class="packt_infobox">The source code can be found on the Git repository under the <kbd><span>Chapter0</span>4-1</kbd> directory, in the <kbd>cp4</kbd> branch.</div>
<p>Let's add something that takes text as input, such as a <kbd>TextField</kbd> element:</p>
<pre><span>    </span><span>TextField</span><span> </span>{<br/><span>        </span><span>anchors</span><span> </span>{<br/><span>            </span><span>bottom</span>:<span> </span><span>inputPanel</span>.top<br/><span>            </span><span>top</span>:<span> </span>parent.top<br/><span>            </span><span>right</span>:<span> </span>parent.right<br/><span>            </span><span>left</span>:<span> </span>parent.left<br/><span>        </span>}<br/>        <span>placeholderText</span><span>:</span><span> </span><span>"Enter</span><span> </span><span>something"</span><span><br/></span><span>    </span>}<br/><br/></pre>
<p>The <kbd>anchors</kbd> here are used to resize this <kbd>TextField</kbd> element when QtVK is opened <span>automatically </span>when the user taps on <kbd>TextField</kbd>. </p>
<p>Here is what this should look like:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8ace3bbe-11dc-4241-8646-63059ba98f12.png" style="width:39.00em;height:29.25em;"/></p>
<p class="CDPAlignCenter CDPAlign"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Implementing a touch screen can have many benefits, which we can do by using the Qt event loop. Let's look in detail at using touch screens as an input.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using touch input</h1>
                </header>
            
            <article>
                
<p>Touch screens are ubiquitous these days. They are everywhere. While essential in a mobile phone or tablet, you can also get a laptop or desktop computer with one. Refrigerators and cars also commonly have touchscreens. Knowing how to utilize these in your Qt app is also essential.</p>
<p>On mobile phone and tablet platforms, touchscreen support comes from the system and is often built-in. If you are creating your own embedded device, you will most likely need to tell Qt how to use the touchscreen. Qt has support for various touchscreen systems on embedded devices.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QEvent</h1>
                </header>
            
            <article>
                
<p><kbd>QEvent</kbd> is the way to get access to the touch input events in C++. It comes through an event filter you can add to your application. There are a few different ways to access this data.</p>
<p>We can use an event filter or an event loop. We will start by looking at an event filter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Event filter</h1>
                </header>
            
            <article>
                
<p>One way you can access the event loop is by using an event filter. You first need to call the following function: </p>
<pre><span>qApp-&gt;installEventFilter(this);</span></pre>
<div class="packt_infobox"><span>The source code can be found on the Git repository under the </span><kbd>Chapter04-2</kbd><span> directory in the</span> <kbd>cp4</kbd> <span>branch.</span></div>
<div><span>You then need to override the function named </span><kbd>eventFilter(<span>QObject* obj, QEvent* event</span>)</kbd><span>, which returns a </span><kbd>bool </kbd><span>value:</span></div>
<pre><span>bool</span><span> </span><span>MainWindow</span>::<span>eventFilter</span>(<span>QObject</span>*<span> </span>obj,<span> </span><span>QEvent</span>*<span> </span>event);</pre>
<p class="mce-root"/>
<p>You will then receive any and all events. You can also handle these touch events by using the following: </p>
<ul>
<li><kbd><span>QEvent::TouchBegin</span></kbd></li>
<li><kbd>QEvent::TouchCancel</kbd></li>
<li><kbd>QEvent::TouchEnd</kbd></li>
<li><kbd>QEvent::<span>TouchUpdate</span></kbd></li>
</ul>
<p>Using a <kbd>switch</kbd> statement in a <kbd>eventFilter</kbd> is an effective way to go through different options:</p>
<pre><span>bool</span><span> </span><span>MainWindow</span>::eventFilter(QObject*<span> </span>obj,<span> </span>QEvent*<span> </span>event)<br/>{<br/><span>    </span><span>switch</span>(event-&gt;type())<span> </span>{<br/><span>        </span><span>case</span><span> </span>QEvent::TouchBegin:<br/><span>        </span><span>case</span><span> </span>QEvent::TouchCancel:<br/><span>        </span><span>case</span><span> </span>QEvent::TouchEnd:<br/><span>        </span><span>case</span><span> </span>QEvent::TouchUpdate:<br/><span>            </span>qWarning(<span>"Touch</span><span> </span><span>event</span><span> </span><span>%d"</span>,<span> </span>event-&gt;type());<br/><span>            </span><span>break</span>;<br/><span>        </span><span>default</span>:<br/><span>            </span><span>break</span>;<br/><span>    </span>};<br/><span>    </span><span>return</span><span> false</span>;<br/>}</pre>
<p>Be sure to pass these events on to the parent class unless you need to intercept them. To not pass these on, return <kbd>true</kbd>. Using an event loop is another way to access events. Let's take a look.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Event loop</h1>
                </header>
            
            <article>
                
<p>To use the event loop, you need to override <kbd>event(QEvent *ev)</kbd>:</p>
<pre><span>bool</span><span> </span><span>MainWindow</span>::event(QEvent<span> </span>*ev)<br/>{<br/><span>  </span><span>switch</span><span> </span>(ev-&gt;type())<span> </span>{<br/><span>    </span><span>case</span><span> </span>QEvent::TouchBegin:<br/><span>      </span>qWarning(<span>"TouchBegin</span><span> </span><span>event</span><span> </span><span>%d"</span>,<span> </span>ev-&gt;type());<br/><span>        </span><span>break</span>;<br/><span>    </span><span>case</span><span> </span>QEvent::TouchEnd:<br/><span>      </span>qWarning(<span>"TouchEnd</span><span> </span><span>event</span><span> </span><span>%d"</span>,<span> </span>ev-&gt;type());<br/><span>        </span><span>break</span>;<br/><span>    </span><span>case</span><span> </span>QEvent::TouchUpdate:<br/><span>      </span>qWarning(<span>"TouchUpdate</span><span> </span><span>event</span><span> </span><span>%d"</span>,<span> </span>ev-&gt;type());<br/><span>        </span><span>break</span>;<br/>};}</pre>
<p>You also need to add <kbd>setAttribute(Qt::WA_AcceptTouchEvents,<span> </span><span>true</span>);</kbd> to the class constructor, otherwise your application will not receive touch events.</p>
<p>Let's take a look at how touchscreen support is handled in Qt and how you can use Qt to access a lower level of the touchscreen input stack.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Touchscreen support</h1>
                </header>
            
            <article>
                
<p>Touchscreen support for Qt is done through the <strong>Qt Platform Abstraction</strong> (<span><strong>QPA)</strong> </span>platform plugins. </p>
<p><span>Qt configure will auto-detect the correct platform and determine whether or not the development files are installed. If it finds the development files, it will use them.</span></p>
<p>Let's see how touchscreens work for various operating systems, starting out with mobile phones.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Windows, iOS and Android</h1>
                </header>
            
            <article>
                
<p>On Windows, iOS and Android, touchscreens are supported through the Qt Event system.</p>
<p><span>Using the Qt event system and allowing the platform plugins to do the scanning and reading, we can use </span><kbd>QEvent</kbd><span> if we need access to those events.</span></p>
<p>Let's look at how we can access a low level of the input system using Qt on embedded Linux.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Linux</h1>
                </header>
            
            <article>
                
<p>On the Linux operating system there are a variety of input systems that can be used with Qt.</p>
<p class="mce-root"/>
<p>Qt has built-in support for these types of touchscreen interfaces:</p>
<ul>
<li><kbd>evdev</kbd>: an event device interface</li>
<li><kbd>libinput</kbd>: a library to handle input devices</li>
<li><kbd>tslib</kbd>: a typescript runtime library</li>
</ul>
<p class="mce-root"/>
<p>We will start by learning about the Linux <kbd>evdev</kbd> system to read the device files directly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">evdev</h1>
                </header>
            
            <article>
                
<p>Qt has built-in support for the <kbd>evdev</kbd> standard event-handling system for L<span>inux and embedded Linux </span>. This is what you will get by default if no other system is configured or detected. It handles keyboard, mouse, and touch. You can then use Qt as normal with respect to keyboard, touch, and mouse events.</p>
<p>You can assign startup parameters, such as device file path and default rotation of the screen, like this: </p>
<p><kbd><span>QT_QPA_EVDEV_TOUCHSCREEN_PARAMETERS=/dev/input/input2:rotate=90</span></kbd></p>
<p>Other parameters available are<span> </span><kbd>invertx</kbd><span> </span>and<span> </span><kbd>inverty</kbd>. Of course, you do not need to reply on Qt for these input events, and can access them directly in the stack below Qt. I call them raw events, but they are really just reading the special Linux kernel device files.</p>
<p>Let's take a look at handling these <kbd>evdev</kbd> input events yourself while using Qt. This is low-level system file access, so you might need root or administrator permissions to run the applications that use it this way.</p>
<p>Input events on Linux are accessed through the kernel's <kbd>dev</kbd> nodes, typically found at <kbd>/dev/input</kbd>, but they could be anywhere under the <kbd>/dev</kbd> directory tree, depending on the driver. <kbd>QFile</kbd> should not be used for actually reading from these special device node files.</p>
<div class="packt_tip packt_infobox"><kbd>QFile</kbd> is not suited for reading Unix device node files. This is because <kbd>QFile</kbd> has no signals and the device node files report a size of zero and only have data when you read them.</div>
<div>The main <kbd>include</kbd> file to read input nodes is as follows:</div>
<div>
<pre>#<span>include</span><span> </span>&lt;<span>linux</span>/<span>input</span>.<span>h</span>&gt;</pre></div>
<div class="packt_infobox"><span>The source code can be found on the Git repository under the </span><kbd>Chapter04-3</kbd><span> directory in the</span><span> <kbd>cp4</kbd> </span><span>branch.</span></div>
<p>You will want to scan the device files to detect which file the touchscreen produces. In Linux, these device nodes are named dynamically, so you need to use some other method to discern the correct file other than just the filename. So, you have to open the file and ask it to tell you its name.</p>
<p>We can use <kbd>QDir</kbd> and its filters to at least filter out some of the files we know are not what we are looking for:</p>
<pre><span>     </span>QDir<span> </span>inputDir<span> </span>=<span> </span>QDir(<span>"/dev/input"</span>);<br/><span>     </span>QStringList<span> </span>filters;<br/><span>     </span>filters<span> </span>&lt;&lt;<span> </span><span>"event*"</span>;<br/>     <span>QStringList</span><span> </span><span>eventFiles</span><span> </span><span>=</span><span> </span><span>inputDir.entryList(filters,<br/></span><span>QDir::System);<br/></span><span>     </span><span>int</span><span> </span>fd<span> </span>=<span> </span>-<span>1</span>;<br/><span>     </span><span>char</span><span> </span>name[<span>256</span>];<br/><span>     </span><span>for</span><span> </span>(QString<span> </span>file<span> </span>:<span> </span>eventFiles)<span> </span>{<br/><span>         </span>file.prepend(inputDir.absolutePath());<br/>         <span>fd</span><span> </span><span>=</span><span> </span><span>::open(file.toLocal8Bit().constData(),</span><span> </span><span>O_RDONLY</span>|O_NONBLOCK<span>);<br/></span><span> </span><span>if</span><span> </span>(fd<span> </span>&gt;=<span> </span><span>0</span>)<span> </span>{<br/><span> </span>ioctl(fd,<span> </span>EVIOCGNAME(<span>sizeof</span>(name)),<span> </span>name);<br/><span> </span>::close(fd);<br/><span> </span>}<br/>}</pre>
<p>Be sure to include the <kbd>O_NONBLOCK</kbd> argument for <kbd>open</kbd>.</p>
<p>At this point, we have a list of the names for the different input devices. You might have to just guess which name to use and then do a <kbd>String</kbd> compare to find the correct device. Sometimes, the driver will have correct <kbd>id</kbd> information, which can be obtained using <span><kbd>EVIOCGID</kbd> </span>like this:</p>
<pre><span>unsigned</span><span> </span><span>short</span><span> </span><span>id[4];<br/></span><span>ioctl(fd,</span><span> </span><span>EVIOCGID,</span><span> &amp;</span><span>id);</span></pre>
<p>Sometimes, you can detect certain features using <span><kbd>EVIOCGBIT</kbd>. This will tell us which buttons or keys the hardware driver supports. The touchscreen driver outputs a keycode of </span><kbd>0x14a (BTN_TOUCH)</kbd> <span>when you touch it, so we can use this to detect which input event will be our touchscreen:</span></p>
<pre><span>bool</span><span> </span><span>MainWindow</span>::isTouchDevice(<span>int</span><span> </span>fd)<br/>{<br/><span>    </span><span>unsigned</span><span> </span><span>short</span><span> </span>id[<span>4</span>];<br/><span>    </span><span>long</span><span> </span>bitsKey[<span>LONG_FIELD_SIZE</span>(KEY_CNT)];<br/>    <span>memset(bitsKey,</span><span> </span><span>0</span><span>,</span><span> </span><span>sizeof</span><span>(bitsKey));<br/></span>    <span>ioctl(fd,</span><span> </span><span>EVIOCGBIT(EV_KEY,</span><span> </span><span>sizeof</span><span>(bitsKey)),</span><span> </span><span>bitsKey);<br/></span>    <span>if</span><span> </span><span>(testBit(</span><span>BTN_TOUCH</span><span>,</span><span> </span><span>bitsKey))</span><span> </span><span>{<br/></span><span>        </span><span>return</span><span> </span><span>true</span>;<br/><span>    </span>}<br/>    <span>return</span><span> </span><span>false</span><span>;<br/></span>}</pre>
<p>We can now be fairly certain that we have the proper device file. Now, we<span> can set up a </span><kbd>QSocketNotifier</kbd> object to notify us when that file is activated, and then we can read it to <span>get the <kbd>X</kbd> and <kbd>Y</kbd> values of the touch. We use the <kbd>QSocketNotifier</kbd> class because we cannot use <kbd>QFile</kbd>, as it doesn't have any signals to tell us when the Linux device files get changed, so this makes it much easier:</span></p>
<pre><span>int</span><span> </span><span>MainWindow</span>::doScan(<span>int</span><span> </span>fd)<br/>{<br/><span>    </span>QSocketNotifier<span> </span>*notifier<br/><span>        </span>=<span> </span><span>new</span><span> </span>QSocketNotifier(fd,<span> </span>QSocketNotifier::Read,<br/><span>         this</span>);<br/>        <span>auto</span><span> </span><span>c</span><span> </span><span>=</span><span> </span><span>connect(notifier,</span><span>  </span><span>&amp;QSocketNotifier::activated,<br/></span><span>                     </span>[=](<span> </span><span>int</span><span> </span><span>/*socket*/</span><span> </span>)<span> </span>{<br/>        <span>struct</span><span> </span><span>input_event</span><span> </span><span>ev;<br/></span><span>        </span><span>unsigned</span><span> </span><span>int</span><span> </span>size;<br/>        <span>size</span><span> </span><span>=</span><span> </span><span>read(fd,</span><span> </span><span>&amp;ev,</span><span> </span><span>sizeof</span><span>(</span><span>struct</span><span> </span><span>input_event));<br/></span>        <span>if</span><span> </span><span>(size</span><span> </span><span>&lt;</span><span> </span><span>sizeof</span><span>(</span><span>struct</span><span> </span><span>input_event))</span><span> </span><span>{<br/></span><span>            </span>qWarning(<span>"expected</span><span> </span><span>%u</span><span> </span><span>bytes,</span><span> </span><span>got</span><span> </span><span>%u\n"</span>,<span> </span><span>sizeof</span>(<span>struct<br/></span>            input_event),<span> </span>size);<br/><span>            </span>perror(<span>"\nerror</span><span> </span><span>reading"</span>);<br/><span>            </span><span>return</span><span> </span>EXIT_FAILURE;<br/><span>        </span>}<br/>        <span>if</span><span> </span><span>(ev.type</span><span> </span><span>==</span><span> </span><span>EV_KEY</span><span> </span><span>&amp;&amp;</span><span> </span><span>ev.code</span><span> </span><span>==</span><span> </span><span>BTN_TOUCH</span><span>)<br/></span><span>            </span>qWarning(<span>"Touchscreen</span><span> </span><span>value:</span><span> </span><span>%i\n"</span>,<span> </span>ev.value);<br/><span>        </span><span>if</span><span> </span>(ev.type<span> </span>==<span> </span>EV_ABS<span> </span>&amp;&amp;<span> </span>ev.code<span> </span>== <span>ABS_MT_POSITION_X</span>)<br/><span>             </span>qWarning(<span>"X</span><span> </span><span>value:</span><span> </span><span>%i\n"</span>,<span> </span>ev.value);<br/><span>         </span><span>if</span><span> </span>(ev.type<span> </span>==<span> </span>EV_ABS<span> </span>&amp;&amp;<span> </span>ev.code<span> </span>== <span>ABS_MT_POSITION_Y</span>)<br/><span>             </span>qWarning(<span>"Y</span><span> </span><span>value:</span><span> </span><span>%i\n"</span>,<span> </span>ev.value);<br/>          <span>return</span><span> </span><span>0</span><span>;<br/></span><span>     </span>});<br/> <span>return</span><span> </span><span>true</span><span>;<br/></span>}</pre>
<p>We also use the standard <kbd>read()</kbd> function instead of <kbd>QFile</kbd> to read this. </p>
<p>The <kbd>BTN_TOUCH</kbd> event value tells us when the touchscreen was pressed or released.</p>
<p>The <span><kbd>ABS_MT_POSITION_X</kbd> value will be the touchscreen's <kbd>X</kbd> position, and the </span><span><kbd>ABS_MT_POSITION_Y</kbd> value will be the <kbd>Y</kbd> position.</span></p>
<p>There is a library that can be used to do the very same thing, which might be a little easier.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">libevdev </h1>
                </header>
            
            <article>
                
<p>When you use the library <kbd>libevdev</kbd>, you won't have to access such low level filesystem functions like a <kbd>QSocketNotifier</kbd> and read files yourself.</p>
<p>To use <kbd>libevdev</kbd>, we start by adding to the <kbd>LIBS</kbd> entry in our projects <kbd>.pro</kbd> file.</p>
<pre><span>LIBS</span><span> </span>+=<span> </span>-levdev</pre>
<div class="packt_infobox"><span>The source code can be found on the Git repository under the </span><kbd>Chapter04-4</kbd><span> directory in the</span><span> <kbd>cp4</kbd> </span><span>branch.</span></div>
<p>This allows <kbd>qmake</kbd> to set up proper linker arguments. The <kbd>include</kbd> header would be as follows: </p>
<pre>#<span>include </span>&lt;<span>libevdev</span>-<span>1.0</span>/<span>libevdev</span>/<span>libevdev</span>.<span>h</span>&gt;</pre>
<p>We can borrow the initial code to scan the directory for device files from the preceding code, but the <kbd>isTouchDevice</kbd> function gets cleaner code:</p>
<pre><span>bool</span><span> </span><span>MainWindow</span>::isTouchDevice(<span>int</span><span> </span>fd)<br/>{<br/><span>    </span><span>int</span><span> </span>rc<span> </span>=<span> </span><span>1</span>;<br/><span>    </span>rc<span> </span>=<span> </span>libevdev_new_from_fd(fd,<span> </span>&amp;dev);<br/><span>    </span><span>if</span><span> </span>(rc<span> </span>&lt;<span> </span><span>0</span>)<span> </span>{<br/><span>        </span>qWarning(<span>"Failed</span><span> </span><span>to</span><span> </span><span>init</span><span> </span><span>libevdev</span><span> </span><span>(%s)\n"</span>,<span> </span>strerror(-rc));<br/><span>        </span><span>return</span><span> </span><span>false</span>;<br/><span>    </span>}<br/><span>    </span><span>if</span><span> </span>(libevdev_has_event_code(dev,<span> </span>EV_KEY,<span> </span>BTN_TOUCH))<span> </span>{<br/><span>        </span>qWarning(<span>"Device:</span><span> </span><span>%s\n"</span>,<span> </span>libevdev_get_name(dev));<br/><span>        </span><span>return</span><span> </span><span>true</span>;<br/><span>    </span>}<br/><span>    </span>libevdev_free(dev);<br/><span>    </span><span>return</span><span> </span><span>false</span>;<br/>}</pre>
<p><kbd>Libevdev</kbd> has the nice <kbd>libevdev_has_event_code</kbd> <span>function </span>that can be used to easily detect whether or not the device has a certain event code. This is just what we needed to identify the touchscreen! Notice the <kbd>libevdev_free</kbd> function, which will free the memory being used that we do not need.</p>
<p>The <kbd>doScan</kbd> function loses the call to read, but substitutes a call to <kbd>libevdev_next_event</kbd> instead. It can also output a nice message with the actual name of the event code by calling <kbd>libevdev_event_code_get_name</kbd>: </p>
<pre><span>int</span><span> </span><span>MainWindow</span>::doScan(<span>int</span><span> </span>fd)<br/>{<br/><span>    </span>QSocketNotifier<span> </span>*notifier<br/><span>            </span>=<span> </span><span>new</span><span> </span>QSocketNotifier(fd,<span> </span>QSocketNotifier::Read,<br/><span>this</span>);<br/><span>    </span><span>auto</span><span> </span>c<span> </span>=<span> </span>connect(notifier,<span>  </span>&amp;QSocketNotifier::activated,<br/><span>                     </span>[=](<span> </span><span>int</span><span> </span><span>/*socket*/</span><span> </span>)<span> </span>{<br/><span>        </span><span>int</span><span> </span>rc<span> </span>=<span> </span>-<span>1</span>;<br/><span>        </span><span>do</span><span> </span>{<span>            </span><span>struct</span><span> </span>input_event<span> </span>ev;<br/>            <span>rc</span><span> </span><span>=</span><span> </span><span>libevdev_next_event(dev,<br/></span><span>LIBEVDEV_READ_FLAG_NORMAL,</span><span> </span><span>&amp;ev);<br/></span>            <span>if</span><span> </span><span>(rc</span><span> </span><span>==</span><span> </span><span>LIBEVDEV_READ_STATUS_SYNC)</span><span> </span><span>{<br/></span><span>                </span><span>while</span><span> </span>(rc<span> </span>==<span> </span>LIBEVDEV_READ_STATUS_SYNC)<span> </span>{<br/><span>                    </span>rc<span> </span>=<span> </span>libevdev_next_event(dev,<span> </span>LIBEVDEV_READ_FLAG_SYNC,<span> </span>&amp;ev);<br/><span>                </span>}<br/><span>            </span>}<span> </span><span>else</span><span> </span><span>if</span><span> </span>(rc<span> </span>==<span> </span>LIBEVDEV_READ_STATUS_SUCCESS)<span> </span>{<br/><span>                </span><span>if</span><span> </span>((ev.type<span> </span>==<span> </span>EV_KEY<span> </span>&amp;&amp;<span> </span>ev.code<span> </span>==<span> </span>BTN_TOUCH)<span> </span>||<br/><span>                        </span>(ev.type<span> </span>==<span> </span>EV_ABS<span> </span>&amp;&amp;<span> </span>ev.code<span> </span>==<br/>ABS_MT_POSITION_X)<span> </span>||<br/><span>                        </span>(ev.type<span> </span>==<span> </span>EV_ABS<span> </span>&amp;&amp;<span> </span>ev.code<span> </span>==<br/>ABS_MT_POSITION_Y))<span> </span>{<br/><span>                    </span>qWarning(<span>"%s</span><span> </span><span>value:</span><span> </span><span>%i\n"</span>,<br/>libevdev_event_code_get_name(ev.type,<span> </span>ev.code),<span> </span>ev.value);<br/><span>                </span>}<br/><span>            </span>}<br/><span>        </span>}<span> </span><span>while</span><span> </span>(rc<span> </span>==<span> </span><span>1</span><span> </span>||<span> </span>rc<span> </span>==<span> </span><span>0</span><span> </span>||<span> </span>rc<span> </span>==<span> </span>-EAGAIN);<br/><span>        </span><span>return</span><span> </span><span>0</span>;<br/><span>    </span>});<br/>    <span>return</span><span> </span><span>0</span><span>;<br/></span>}</pre>
<p>The library <kbd>libinput</kbd> also uses <kbd>evdev</kbd>, and is a bit more up to date than the others.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">libinput </h1>
                </header>
            
            <article>
                
<p>The <kbd>libinput</kbd> library is the input handling for Wayland compositors and X.Org window system. Wayland is a display server protocol a bit like a newer version of the ancient Unix standard X11. <kbd>Libinput</kbd> depends on <span><kbd>libudev</kbd> and </span>supports the following input types:</p>
<ul>
<li><kbd>Keyboard</kbd>: Standard hardware keyboard</li>
<li><kbd>Gesture</kbd>: Touch gestures</li>
<li><kbd>Pointer</kbd>: Mouse events</li>
<li><kbd>Touch</kbd>: Touchscreen events</li>
<li><kbd>Switch</kbd>: Laptop lid switch events</li>
<li><kbd>Tablet</kbd>: Tablet tool events</li>
<li><kbd>Tablet pad:</kbd> Tablet pad events</li>
</ul>
<p><span>The <kbd>libinput</kbd> library has a build-time dependency upon <kbd>libudev </kbd> ; therefore, </span>to configure Qt, you will need <kbd><span>libudev</span></kbd> as well as the <kbd>libinput</kbd> development files or packages installed. If you need hardware keyboard support, the <kbd>xcbcommon</kbd> package is also needed.</p>
<p>Yet another touch library is <kbd>tslib</kbd>, which is specifically used in embedded devices, as it has a small filesystem footprint and minimal dependencies.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Tslib</h1>
                </header>
            
            <article>
                
<p class="mce-root"><kbd>Tslib</kbd> is a library used to access and filter touchscreen events on Linux devices; it supports multi-touch and Qt has support for using it. You will need to have the <kbd>tslib</kbd> development files installed. Qt will auto-detect this, or you can explicitly configure Qt with the following:</p>
<pre><span class="pln">configure</span> <span class="operator"><span class="pun">-</span></span><span class="pln">qt</span><span class="operator"><span class="pun">-</span></span><span class="pln">mouse</span><span class="operator"><span class="pun">-</span></span><span class="pln">tslib</span></pre>
<p>It can then be enabled by setting <kbd>QT_QPA_EGLFS_TSLIB</kbd> or <kbd>QT_QPA FB_TSLIB</kbd> to <kbd>1</kbd>. You can change the actual device file path by setting the environmental variable called <kbd>TSLIB_TSDEVICE</kbd> to the path of the device node like this:</p>
<pre class="apf"> export TSLIB_TSDEVICE=/dev/input/event4</pre>
<p>Let's now move on to see how we can use higher level APIs in Qt to utilize the touchscreen.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using the touchscreen</h1>
                </header>
            
            <article>
                
<p>There are two ways the Qt backend uses the touchscreen. The events come in as a mouse using a point with <kbd>click</kbd> and <kbd>drag</kbd> events, or as multi-point touch-to-handle gestures, such as <kbd>pinch</kbd> and <kbd>swipe</kbd>. Let's get a better understanding about multi-point touch.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">MultiPointTouchArea</h1>
                </header>
            
            <article>
                
<p>As I have mentioned earlier, to use multi-point touchscreens in QML, there is the <kbd>MultiPointTouchArea</kbd> type. If you want to use gestures in QML, you either have to use<strong> </strong><kbd>MultiPointTouchArea</kbd> <span>and do it yourself, or use <kbd>QGesture</kbd> in your C++ and handle custom signals in your QML components.</span></p>
<div class="packt_infobox">The source code can be found on the Git repository under the <kbd>/Chapter04-5</kbd> directory in the cp4 branch.</div>
<pre><span>    MultiPointTouchArea { <br/>          anchors.fill: parent <br/>          touchPoints: [ <br/>              TouchPoint { id: finger1 }, <br/>              TouchPoint { id: finger2 }, <br/>              TouchPoint { id: finger3 }, <br/>              TouchPoint { id: finger4 }, <br/>              TouchPoint { id: finger5 } <br/>          ] <br/>      } <br/><br/></span></pre>
<p>You declare the <kbd>touchPoints</kbd> property of <span><kbd>MultiPointTouchArea</kbd> </span>with a <kbd>TouchPoint</kbd> element for each finger you want to deal with. Here, we are using five-finger points. </p>
<p>You can use the <kbd>x</kbd> and <kbd>y</kbd> properties to move things around:</p>
<pre><span>      Rectangle { <br/>          width: 30; height: 30 <br/>          color: "green" <br/>          radius: 50 <br/>          x: finger1.x <br/>          y: finger1.y <br/>      }<br/></span></pre>
<p>You can also use touchscreen gestures in your app. </p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Qt Gestures</h1>
                </header>
            
            <article>
                
<p>Gestures are a great way of utilizing user input. As I mentioned gestures in <a href="ab2105ed-232b-4c99-8fd8-4ca295f6f5f9.xhtml">Chapter 2</a>, <em>Fluid UI with Qt Quick</em><span class="cdp-organizer-chapter-title"><span class="cdp-organize-title-label">, </span></span>I will mention the C++ API here, which is much more feature-rich than gestures in QML. Keep in mind that these are touchscreen gestures and not device or sensor gestures, which I will examine in a later chapter. <kbd>QGesture</kbd> supports the following built-in gestures:</p>
<ul>
<li><kbd>QPanGesture</kbd></li>
<li><kbd>QPinch<span>Gesture</span></kbd></li>
<li><kbd>QSwipe<span>Gesture</span></kbd></li>
<li><kbd>QTap<span>Gesture</span></kbd></li>
<li><kbd>QTapAndHold<span>Gesture</span></kbd></li>
</ul>
<p>QGesture is an event-based API, so it will come through the event filter, which means you need to re-implement your <kbd>event(QEvent *event)</kbd> widgets as the gesture will target your widget. It also supports custom gestures by subclassing <kbd>QGestureRecognizer</kbd> and re-implementing <kbd>recognize</kbd><span class="packt_screen">.</span></p>
<p>To use gestures in your app, you need to first tell Qt that you want to receive touch events. If you are using built-in gestures, this is done internally by Qt, but if you have custom gestures, you need to do this:</p>
<div>
<pre><span>setAttribute</span><span>(Qt::WA_AcceptTouchEvents);</span></pre></div>
<p class="fn">To accept touch events, you then need to call <kbd>QGraphicsItem::setAcceptTouchEvent(bool)</kbd> with <kbd>true</kbd> as the argument.</p>
<p class="mce-root">If you want to use unhandled mouse events for touch events, you can also set the <kbd>Qt::WA_SynthesizeTouchEventsForUnhandledMouseEvents</kbd> attribute.</p>
<p class="mce-root">You then need to define to Qt that you want to use certain gestures by calling the <kbd>grabGesture</kbd> function of your <kbd>QWidget</kbd> or <kbd>QGraphicsObject</kbd>class:</p>
<pre>grabGesture(<span>Qt::SwipeGesture);</span></pre>
<div class="packt_tip"><kbd>QGesture</kbd> events are delivered to a specific <kbd>QWidget</kbd> class and not the current <kbd>QWidget</kbd> class that holds the focus like a mouse event would.</div>
<div>In your <kbd>QWidget</kbd> derived class, you need to re-implement the <kbd>event</kbd> function and then handle the <kbd>gesture</kbd> event when it happens:</div>
<div>
<pre>b<span>ool</span><span> My</span><span>Widget::event</span><span>(QEvent </span><span>*</span><span>event)<br/></span>{<br/>    if<span> (event-&gt;</span><span>type</span><span>() </span><span>==</span><span> QEvent::Gesture)<br/></span>        handleSwipe();<br/>    <span>return QWidget::event</span><span>(event);<br/></span>}</pre></div>
<p>Since we are handling only one <kbd>QGesture</kbd> type, we know it is our target gesture. You can check whether or not this event is caused by a certain gesture by checking for its <kbd>pointer</kbd> using the <kbd>gesture</kbd> function that is defined as follows: </p>
<p class="fn"><kbd><span class="type">QGesture</span><span> </span>* QGestureEvent::<span class="name">gesture</span>(<span class="type">Qt::GestureType</span><span> </span>type) const</kbd></p>
<p>This can be implemented by the following:</p>
<div>
<pre><span>if</span><span> (QGesture </span><span>*</span><span>swipe </span><span>=</span><span> event-&gt;</span><span>gesture</span><span>(Qt::SwipeGesture))</span></pre></div>
<p>If the <kbd>QGesture</kbd> object called <kbd>swipe</kbd> is <kbd>nullptr</kbd>, then this event is not our target gesture.</p>
<p>It is also a good idea to check on the gesture's <kbd>state()</kbd>, which can be one of the following:</p>
<ul>
<li><kbd>Qt::NoGesture</kbd></li>
<li><kbd><span>Qt::</span>GestureStarted</kbd></li>
<li><kbd>Qt::GestureUpdated</kbd> </li>
<li><kbd><span>Qt::</span>GestureFinished</kbd></li>
<li><kbd><span>Qt::</span>GestureCanceled</kbd></li>
</ul>
<p>You can create your own gesture using <kbd>QGestureRecognizer</kbd> by sub-classing <kbd>QGestureRecognizer</kbd> and re-implementing <kbd>recognize()</kbd>. This is where most of the work will be, as you will need to detect your gesture and are more likely detect what is not your gesture. Your <kbd>recognize()</kbd> function will need to return one of the values of the <kbd>enum</kbd> value, <kbd>QGestureRecognizer::Result</kbd><span class="name">, which can be any of the following:</span></p>
<ul>
<li><kbd>QGestureRecognizer::Ignore</kbd></li>
<li><kbd>QGestureRecognizer::MayBeGesture</kbd></li>
<li><kbd>QGestureRecognizer::TriggerGesture</kbd></li>
<li><kbd>QGestureRecognizer::FinishGesture</kbd></li>
<li><kbd>QGestureRecognizer::CancelGesture</kbd></li>
<li><kbd>QGestureRecognizer::ConsumeEventHint</kbd></li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<p>There are heaps of edge cases you need to handle here to discern exactly what is and what is not your gesture. Do not be afraid if this function is complicated or long.</p>
<p>Another form of input that is becoming more popular is using your voice. Let's look at that next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Voice as input</h1>
                </header>
            
            <article>
                
<p>Voice recognition and Qt has been around for a while now. IBM's ViaVoice was ported to KDE and was being ported to Trolltech's phone software suite Qtopia at the time that I became the Qtopia Community Liaison in 2003. Consequently, it was worked on by the same developer who later dreamed-up what became Qt Quick. While the concept has essentially stayed the same, the technology has gotten better, and now you can find voice control in many different devices, including automobiles.</p>
<p><span>There are many competing systems, such as Alexa, Google Voice, Cortana, and Siri, as well as some open source APIs. Combined with voice search, voice input is an invaluable tool.</span></p>
<p>At the time of writing, Qt Company and one of its partners, <strong>Integrated Computer Solutions</strong> (<strong>ICS</strong>), have announced that they are working together on integrating the Amazon Alexa system with Qt. I have been told that it will be called <kbd>QtAlexaAuto</kbd> and be released under the lgpl v3 license. Since this has not been released at the time of writing, I <span>cannot go into very much detail about </span>how to use this implementation just yet. I am sure that, if or when it gets released, the API will be quite easy to use.</p>
<p>Amazon's <strong>Alexa Voice Service</strong> (<strong>AVS</strong>) <strong>Software Development Kit</strong> (<strong>SDK</strong>) works on Windows, Linux, Android and MacOS. You can even use a mic array component, such as the MATRIX creator with the Raspberry Pi.  Siri works on iOS and MacOS. Cortana works on Windows.</p>
<p>While none of these voice systems are integrated into Qt, they can be used with a custom integration. It is worth looking into them, depending on what your application will be doing and what device it will run on.</p>
<p>Alexa, Google <span>Assistant</span>, and Cortana have C++ APIs, and Siri can be used as well with its Objective-C API:</p>
<ul>
<li>Alexa: <a href="https://github.com/alexa/avs-device-sdk.git">https://github.com/alexa/avs-device-sdk.git</a></li>
<li>Google Assistant: <a href="https://developers.google.com/assistant/sdk/guides/library/python/embed/install-sample">https://developers.google.com/assistant/sdk/guides/library/python/embed/install-sample</a></li>
</ul>
<ul>
<li>Cortana: <a href="https://developer.microsoft.com/en-us/cortana">https://developer.microsoft.com/en-us/cortana</a></li>
<li>Siri: <a href="https://developer.apple.com/sirikit/">https://developer.apple.com/sirikit/<br/></a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QtAlexaAuto</h1>
                </header>
            
            <article>
                
<p>QtAlexaAuto is a module created by Integrated Computer Solutions (ICS) and the Qt Company to enable the use of Amazon's Alexa Voice Service (AVS) from within Qt and QtQuick applications. You can use Raspberry Pi, Linux, Android, or other machines to prototype an application that uses voice as input.</p>
<p>At the time of writing this book, QtAlexaAuto is yet to be released, so you will need to search the internet for the url to download the source code. Some things may have changed in the official release from what it written in this book.</p>
<p>You will need to download, build and install the following SDKs from Amazon:</p>
<ul>
<li>AVS Device SDK: git clone -b v1.9 <a href="https://github.com/alexa/avs-device-sdk">https://github.com/alexa/avs-device-sdk</a></li>
<li>Alexa Auto SDK: git clone -b 1.2.0 <a href="https://github.com/alexa/aac-sdk">https://github.com/alexa/aac-sdk</a></li>
</ul>
<p>To build these you should follow instructions for your platform from this URL:</p>
<p><a href="https://github.com/alexa/avs-device-sdk/wiki">https://github.com/alexa/avs-device-sdk/wiki</a></p>
<p>The basic steps for building QtAlexaAuto are the following:</p>
<ol>
<li>Sign-up for an Amazon developer account, and register a product. <a href="https://developer.amazon.com/docs/alexa-voice-service/register-a-product.html">https://developer.amazon.com/docs/alexa-voice-service/register-a-product.html</a></li>
<li>Add your clientID and productID</li>
<li>Install the requirements mentioned in the Alexa wiki</li>
<li>Apply patches as detailed in install_aac_sdk.md</li>
<li>Build and install AVS Device SDK</li>
<li>Build and install Alexa Auto SDK</li>
<li>Edit AlexaSamplerConfig.json</li>
<li>Build QtAlexaAuto</li>
</ol>
<p>There are a few patches you need to apply. Luckily there are instructions in install_aac_sdk.md, which instruct you on how to apply the patches from aac-sdk to the avs-device-sdk.</p>
<p class="mce-root"/>
<p>The file AlexaSamplerConfig.json needs to be edited and renamed to  AlexaClientSDKConfig_new_version_linux.json</p>
<p>The file then needs to be put into the directory where you are running the example from.</p>
<p>The QtAlexaAuto main QML component is named alexaApp, which corresponds to the QtAlexaAuto class.</p>
<p>When you run the example app, you will need to sign in to your Amazon developer account and link this application by entering a code the application gives you when you start it for the first time. These can be provided to the user by calling acctLinkUrl() and acctLinkCode(), or in QML by the alexaApp properties named accountLinkCode and accountLinkUrl.</p>
<p>Once this is linked to an account, you use voice input and the Alexa Voice Service by tapping on the button.</p>
<p>The function that runs when the user presses the talk button is tapToTalk(), and the startTapToTalk signal gets emitted.</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2267a64d-0f9e-4de9-86fd-0edb84f65ade.png" style="width:29.75em;height:22.25em;"/></p>
<p>AVS has a notion of a RenderTemplate, which gets passed from the service so the application will be able to show the user visual information about the response. QtAlexaAuto handles Weather, media player templates, as well as some generic multipurpose templates. The RenderTemplate gets emitted as JSON documents and shown in the example application using QML components, which then parse and display the data.</p>
<p>This was just a quick look at QtAlexaAuto, as I did not have enough time to really dig into this new API before the publication of this book.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>User input is important, and there are various ways for users to interact with applications. If you are creating your own embedded device, you will need to decide what input methods to use. Touchscreens can increase usability because touching things is a very natural thing to do. Babies and even cats can use touchscreen devices! Gestures are a fantastic way to use touch input and you can even develop custom gestures for your application. Voice input is taking off right now. Whilst adding support for it might take a little work, it can be the right thing to do on some devices that require hands-free usage.</p>
<p>In the following chapter, we will learn about networking and its features.</p>


            </article>

            
        </section>
    </body></html>