["```cpp\n    auto i = 42;          // int\n    auto d = 42.5;        // double\n    auto s = \"text\";      // char const *\n    auto v = { 1, 2, 3 }; // std::initializer_list<int> \n    ```", "```cpp\n    auto b  = new char[10]{ 0 };            // char*\n    auto s1 = std::string {\"text\"};         // std::string\n    auto v1 = std::vector<int> { 1, 2, 3 }; // std::vector<int>\n    auto p  = std::make_shared<int>(42);    // std::shared_ptr<int> \n    ```", "```cpp\n    auto upper = [](char const c) {return toupper(c); }; \n    ```", "```cpp\n    auto add = [](auto const a, auto const b) {return a + b;}; \n    ```", "```cpp\n    template <typename F, typename T>\n    auto apply(F&& f, T value)\n    {\n      return f(value);\n    } \n    ```", "```cpp\n    auto v = std::vector<int>{ 1, 2, 3 };\n    // implicit conversion, possible loss of data\n    int size1 = v.size();\n    // OK\n    auto size2 = v.size();\n    // ill-formed (warning in gcc, error in clang & VC++)\n    auto size3 = int{ v.size() }; \n    ```", "```cpp\n    std::map<int, std::string> m;\n    for (std::map<int, std::string>::const_iterator\n      it = m.cbegin();\n      it != m.cend(); ++it)\n    { /*...*/ }\n    for (auto it = m.cbegin(); it != m.cend(); ++it)\n    { /*...*/ } \n    ```", "```cpp\n    class foo {\n      int x;\n    public:\n      foo(int const value = 0) :x{ value } {}\n      int& get() { return x; }\n    };\n    foo f(42);\n    auto x = f.get();\n    x = 100;\n    std::cout << f.get() << '\\n'; // prints 42 \n    ```", "```cpp\n    auto ai = std::atomic<int>(42); // error \n    ```", "```cpp\n    auto l1 = long long{ 42 }; // error\n    using llong = long long;\n    auto l2 = llong{ 42 };     // OK\n    auto l3 = 42LL;            // OK\n    auto l4 = (long long){ 42 }; // OK with gcc/clang \n    ```", "```cpp\n// C++11\nauto func1(int const i) -> int\n{ return 2*i; }\n// C++14\nauto func2(int const i)\n{ return 2*i; } \n```", "```cpp\nclass foo\n{\n  int x_;\npublic:\n  foo(int const x = 0) :x_{ x } {}\n  int& get() { return x_; }\n};\nauto proxy_get(foo& f) { return f.get(); }\nauto f = foo{ 42 };\nauto& x = proxy_get(f); // cannot convert from 'int' to 'int &' \n```", "```cpp\ndecltype(auto) proxy_get(foo& f) \n{ return f.get(); }\nauto f = foo{ 42 };\ndecltype(auto) x = proxy_get(f); \n```", "```cpp\nauto ladd = [] (auto const a, auto const b) { return a + b; }; \n```", "```cpp\nstruct\n{\n  template<typename T, typename U>\n auto operator () (T const a, U const b) const { return a+b; }\n} L; \n```", "```cpp\nauto i = ladd(40, 2);            // 42\nauto s = ladd(\"forty\"s, \"two\"s); // \"fortytwo\"s \n```", "```cpp\n    using byte     = unsigned char;\n    using byte_ptr = unsigned char *;\n    using array_t  = int[10];\n    using fn       = void(byte, double);\n    void func(byte b, double d) { /*...*/ }\n    byte b{42};\n    byte_ptr pb = new byte[10] {0};\n    array_t a{0,1,2,3,4,5,6,7,8,9};\n    fn* f = func; \n    ```", "```cpp\n    template <class T>\n    class custom_allocator { /* ... */ };\n    template <typename T>\n    using vec_t = std::vector<T, custom_allocator<T>>;\n    vec_t<int>           vi;\n    vec_t<std::string>   vs; \n    ```", "```cpp\ntypedef unsigned char   byte;\ntypedef unsigned char * byte_ptr;\ntypedef int array_t[10];\ntypedef void(*fn)(byte, double);\ntemplate<typename T>\nclass foo {\n  typedef T value_type;\n};\ntypedef std::vector<int> vint_t;\ntypedef int INTEGER;\nINTEGER x = 10;\ntypedef int INTEGER; // redeclaration of same type\nINTEGER y = 20; \n```", "```cpp\nstd::string s1(\"test\");   // direct initialization\nstd::string s2 = \"test\";  // copy initialization \n```", "```cpp\nT object {other};   // direct-list-initialization\nT object = {other}; // copy-list-initialization \n```", "```cpp\n    std::vector<int> v { 1, 2, 3 };\n    std::map<int, std::string> m { {1, \"one\"}, { 2, \"two\" }}; \n    ```", "```cpp\n    int* arr2 = new int[3]{ 1, 2, 3 }; \n    ```", "```cpp\n    int arr1[3] { 1, 2, 3 }; \n    ```", "```cpp\n    int i { 42 };\n    double d { 1.2 }; \n    ```", "```cpp\n    class foo\n    {\n      int a_;\n      double b_;\n    public:\n      foo():a_(0), b_(0) {}\n      foo(int a, double b = 0.0):a_(a), b_(b) {}\n    };\n    foo f1{};\n    foo f2{ 42, 1.2 };\n    foo f3{ 42 }; \n    ```", "```cpp\n    struct bar { int a_; double b_;};\n    bar b{ 42, 1.2 }; \n    ```", "```cpp\n    int a = 42;\n    double b = 1.2; \n    ```", "```cpp\n    class foo\n    {\n      int a_;\n    public:\n      foo(int a):a_(a) {}\n    };\n    foo f1 = 42; \n    ```", "```cpp\n    foo f1;           // default initialization\n    foo f2(42, 1.2);\n    foo f3(42);\n    foo f4();         // function declaration \n    ```", "```cpp\n    bar b = {42, 1.2};\n    int a[] = {1, 2, 3, 4, 5}; \n    ```", "```cpp\nclass foo\n{\n  int a_;\n  int b_;\npublic:\n  foo() :a_(0), b_(0) {}\n  foo(int a, int b = 0) :a_(a), b_(b) {}\n  foo(std::initializer_list<int> l) {}\n};\nfoo f{ 1, 2 }; // calls constructor with initializer_list<int> \n```", "```cpp\nvoid func(int const a, int const b, int const c)\n{\n  std::cout << a << b << c << '\\n';\n}\nvoid func(std::initializer_list<int> const list)\n{\n  for (auto const & e : list)\n    std::cout << e << '\\n';\n}\nfunc({ 1,2,3 }); // calls second overload \n```", "```cpp\nstd::vector<int> v {5}; \n```", "```cpp\nstd::vector<int> v (5); \n```", "```cpp\nint i{ 1.2 };           // error\ndouble d = 47 / 13;\nfloat f1{ d };          // error, only warning in gcc \n```", "```cpp\nint i{ static_cast<int>(1.2) };\ndouble d = 47 / 13;\nfloat f1{ static_cast<float>(d) }; \n```", "```cpp\nfloat f2{47/13};        // OK, f2=3 \n```", "```cpp\nauto a = {42};   // std::initializer_list<int>\nauto b {42};     // std::initializer_list<int>\nauto c = {4, 2}; // std::initializer_list<int>\nauto d {4, 2};   // std::initializer_list<int> \n```", "```cpp\nauto a = {42};   // std::initializer_list<int>\nauto b {42};     // int\nauto c = {4, 2}; // std::initializer_list<int>\nauto d {4, 2};   // error, too many \n```", "```cpp\nstruct Control\n{\n  const int DefaultHeight = 14;                                // [1]\nconst int DefaultWidth  = 80;                                // [2]\n  std::string text;\n  TextVerticalAlignment valign = TextVerticalAlignment::Middle;   // [3]\n  TextHorizontalAlignment halign = TextHorizontalAlignment::Left; // [4]\nControl(std::string const & t) : text(t)      // [5]\n  {}\n  Control(std::string const & t,\n    TextVerticalAlignment const va,\n    TextHorizontalAlignment const ha):\n    text(t), valign(va), halign(ha)             // [6]\n  {}\n}; \n```", "```cpp\nstruct Point\n{\n  double x, y;\n  Point(double const x = 0.0, double const y = 0.0) : x(x), y(y)  {}\n}; \n```", "```cpp\nstruct foo\n{\n  foo()\n  { std::cout << \"default constructor\\n\"; }\n  foo(std::string const & text)\n  { std::cout << \"constructor '\" << text << \"\\n\"; }\n  foo(foo const & other)\n  { std::cout << \"copy constructor\\n\"; }\n  foo(foo&& other)\n  { std::cout << \"move constructor\\n\"; };\n  foo& operator=(foo const & other)\n  { std::cout << \"assignment\\n\"; return *this; }\n  foo& operator=(foo&& other)\n  { std::cout << \"move assignment\\n\"; return *this;}\n  ~foo()\n  { std::cout << \"destructor\\n\"; }\n};\nstruct bar\n{\n  foo f;\n  bar(foo const & value)\n  {\n    f = value;\n  }\n};\nfoo f;\nbar b(f); \n```", "```cpp\ndefault constructor\ndefault constructor\nassignment\ndestructor\ndestructor \n```", "```cpp\nbar(foo const & value) : f(value) { } \n```", "```cpp\ndefault constructor\ncopy constructor\ndestructor\ndestructor \n```", "```cpp\nenum class TextFlow { LeftToRight, RightToLeft };\nstruct Control\n{\n  const int DefaultHeight = 20;\n  const int DefaultWidth = 100;\n  TextFlow textFlow = TextFlow::LeftToRight;\n  std::string text;\n  Control(std::string const & t) : text(t)\n  {}\n}; \n```", "```cpp\nstruct bar\n{\n  foo f{\"default value\"};\n  bar() : f{\"constructor initializer\"}\n  {\n  }\n};\nbar b; \n```", "```cpp\nconstructor 'constructor initializer'\ndestructor \n```", "```cpp\n    struct alignas(4) foo\n    {\n      char a;\n      char b;\n    };\n    struct bar\n    {\n      alignas(2) char a;\n      alignas(8) int  b;\n    };\n    alignas(8)   int a;\n    alignas(256) long b[4]; \n    ```", "```cpp\n    auto align = alignof(foo); \n    ```", "```cpp\nstruct foo1 // size = 1, alignment = 1\n{              // foo1:    +-+\nchar a;      // members: |a|\n};\nstruct foo2 // size = 2, alignment = 1\n{              // foo2:    +-+-+\nchar a;      // members  |a|b|\nchar b;\n};\nstruct foo3 // size = 8, alignment = 4\n{              // foo3:    +----+----+\nchar a;      // members: |a...|bbbb|\nint  b;      // . represents a byte of padding\n}; \n```", "```cpp\nstruct foo3_\n{\n  char a;        // 1 byte\nchar _pad0[3]; // 3 bytes padding to put b on a 4-byte boundary\nint  b;        // 4 bytes\n}; \n```", "```cpp\nstruct foo4 // size = 24, alignment = 8\n{               // foo4:    +--------+--------+--------+--------+\nint a;        // members: |aaaab...|cccc....|dddddddd|e.......|\nchar b;       // . represents a byte of padding\nfloat c;\n  double d;\n  bool e;\n}; \n```", "```cpp\nstruct foo4_\n{\n  int a;         // 4 bytes\nchar b;        // 1 byte\nchar _pad0[3]; // 3 bytes padding to put c on a 8-byte boundary\nfloat c;       // 4 bytes\nchar _pad1[4]; // 4 bytes padding to put d on a 8-byte boundary\ndouble d;      // 8 bytes\nbool e;        // 1 byte\nchar _pad2[7]; // 7 bytes padding to make sizeof struct multiple of 8\n}; \n```", "```cpp\nstruct alignas(4) foo\n{\n  char a;\n  char b;\n}; \n```", "```cpp\nstruct foo\n{\n  char a;\n  char b;\n  char _pad0[2];\n}; \n```", "```cpp\nstruct alignas(4) foo\n{\n  alignas(2) char a;\n  alignas(8) int  b;\n}; \n```", "```cpp\nstruct foo\n{\n  char a;\n  char _pad0[7];\n  int b;\n  char _pad1[4];\n}; \n```", "```cpp\nalignas(8)   int a;\nalignas(256) long b[4];\nprintf(\"%p\\n\", &a); // eg. 0000006C0D9EF908\nprintf(\"%p\\n\", &b); // eg. 0000006C0D9EFA00 \n```", "```cpp\n    enum class Status { Unknown, Created, Connected };\n    Status s = Status::Created; \n    ```", "```cpp\n    int main()\n    {\n      using Status::Unknown;\n      Status s = Unknown;\n    } \n    ```", "```cpp\n    struct foo\n    {\n      enum class Status { Unknown, Created, Connected };\n      using enum Status;\n    };\n    foo::Status s = foo::Created; // instead of\n    // foo::Status::Created \n    ```", "```cpp\n    void process(Status const s)\n    {\n      switch (s)\n      {\n        using enum Status;\n        case Unknown:   /*â€¦*/ break;\n        case Created:   /*...*/ break;\n        case Connected: /*...*/ break;\n      }\n    } \n    ```", "```cpp\nvoid old_api(unsigned flag);\nenum class user_rights : unsigned\n{\n    None, Read = 1, Write = 2, Delete = 4\n};\nold_api(std::to_underlying(user_rights::Read)); \n```", "```cpp\n        enum Status {Unknown, Created, Connected};\n        enum Codes {OK, Failure, Unknown};   // error\n        auto status = Status::Created;       // error \n        ```", "```cpp\n    enum Codes { OK, Failure };\n    void include_offset(int pixels) {/*...*/}\n    include_offset(Failure); \n    ```", "```cpp\n    enum class Status { Unknown, Created, Connected };\n    enum class Codes { OK, Failure, Unknown }; // OK\n    Codes code = Codes::Unknown;               // OK \n    ```", "```cpp\n    enum class Codes : unsigned int;\n    void print_code(Codes const code) {}\n    enum class Codes : unsigned int\n    {\n      OK = 0,\n      Failure = 1,\n      Unknown = 0xFFFF0000U\n    }; \n    ```", "```cpp\n    Codes c1 = Codes::OK;                       // OK\n    int c2 = Codes::Failure;                    // error\n    int c3 = static_cast<int>(Codes::Failure);  // OK \n    ```", "```cpp\nstd::string_view to_string(Status const s)\n{\n  switch (s)\n  {\n    case Status::Unknown:   return \"Unknown\";\n    case Status::Created:   return \"Created\";\n    case Status::Connected: return \"Connected\";\n  }\n} \n```", "```cpp\nstd::string_view to_string(Status const s)\n{\n  switch (s)\n  {\n    using enum Status;\n    case Unknown:   return \"Unknown\";\n    case Created:   return \"Created\";\n    case Connected: return \"Connected\";\n  }\n} \n```", "```cpp\nvoid old_api(unsigned flag)\n{\n    if ((flag & 0x01) == 0x01) { /* can read */ }\n    if ((flag & 0x02) == 0x02) { /* can write */ }\n    if ((flag & 0x04) == 0x04) { /* can delete */ }\n} \n```", "```cpp\nold_api(1); // read only\nold_api(3); // read & write \n```", "```cpp\nenum class user_rights : unsigned\n{\n    None,\n    Read = 1,\n    Write = 2,\n    Delete = 4\n}; \n```", "```cpp\nold_api(static_cast<int>(user_rights::Read)); // read only\nold_api(static_cast<int>(user_rights::Read) | \n        static_cast<int>(user_rights::Write)); // read & write \n```", "```cpp\nold_api(std::to_underlying(user_rights::Read));\nold_api(std::to_underlying(user_rights::Read) | \n        std::to_underlying(user_rights::Write)); \n```", "```cpp\nenum A {};\nenum class B {};\nint main()\n{\n   std::cout << std::is_scoped_enum_v<A> << '\\n';\n   std::cout << std::is_scoped_enum_v<B> << '\\n';\n} \n```", "```cpp\n    class Base\n    {\n      virtual void foo() = 0;\n      virtual void bar() {}\n      virtual void foobar() = 0;\n    };\n    void Base::foobar() {}\n    class Derived1 : public Base\n    {\n      virtual void foo() override = 0;\n      virtual void bar() override {}\n      virtual void foobar() override {}\n    };\n    class Derived2 : public Derived1\n    {\n      virtual void foo() override {}\n    }; \n    ```", "```cpp\n    class Derived2 : public Derived1\n    {\n      virtual void foo() final {}\n    }; \n    ```", "```cpp\n    class Derived4 final : public Derived1\n    {\n      virtual void foo() override {}\n    }; \n    ```", "```cpp\nclass Base\n{\npublic:\n  virtual void foo() {}\n  virtual void bar() {}\n};\nclass Derived1 : public Base\n{\npublic:\n  void foo() override {}\n  // for readability use the virtual keyword\nvirtual void bar(char const c) override {}\n  // error, no Base::bar(char const)\n}; \n```", "```cpp\nclass Derived2 : public Derived1\n{\n  virtual void foo() final {}\n};\nclass Derived3 : public Derived2\n{\n  virtual void foo() override {} // error\n}; \n```", "```cpp\nclass Derived4 final : public Derived1\n{\n  virtual void foo() override {}\n};\nclass Derived5 : public Derived4 // error\n{\n}; \n```", "```cpp\nclass foo\n{\n  int final = 0;\n  void override() {}\n}; \n```", "```cpp\nfor ( range_declaration : range_expression ) loop_statement \n```", "```cpp\nfor(init-statement range-declaration : range-expression)\nloop-statement \n```", "```cpp\nstd::vector<int> getRates()\n{\n  return std::vector<int> {1, 1, 2, 3, 5, 8, 13};\n}\nstd::multimap<int, bool> getRates2()\n{\n  return std::multimap<int, bool> {\n    { 1, true },\n    { 1, true },\n    { 2, false },\n    { 3, true },\n    { 5, true },\n    { 8, false },\n    { 13, true }\n  };\n} \n```", "```cpp\n    auto rates = getRates();\n    for (int rate : rates)\n      std::cout << rate << '\\n';\n    for (int& rate : rates)\n      rate *= 2; \n    ```", "```cpp\n    for (auto&& rate : getRates())\n      std::cout << rate << '\\n';\n    for (auto & rate : rates)\n      rate *= 2;\n    for (auto const & rate : rates)\n      std::cout << rate << '\\n'; \n    ```", "```cpp\n    for (auto&& [rate, flag] : getRates2())\n      std::cout << rate << '\\n'; \n    ```", "```cpp\n{\n  auto && __range = range_expression;\n  for (auto __begin = begin_expr, __end = end_expr;\n  __begin != __end; ++__begin) {\n    range_declaration = *__begin;\n    loop_statement\n  }\n} \n```", "```cpp\n{\n  auto && __range = range_expression;\n  auto __begin = begin_expr;\n  auto __end = end_expr;\n  for (; __begin != __end; ++__begin) {\n    range_declaration = *__begin;\n    loop_statement\n  }\n} \n```", "```cpp\n{\n  init-statement\n  auto && __range = range_expression;\n  auto __begin = begin_expr;\n  auto __end = end_expr;\n  for (; __begin != __end; ++__begin) {\n    range_declaration = *__begin;\n    loop_statement\n  }\n} \n```", "```cpp\nfor (auto rates = getRates(); int rate : rates)\n{\n   std::cout << rate << '\\n';\n} \n```", "```cpp\nstruct item\n{\n   std::vector<int> getRates()\n {\n      return std::vector<int> {1, 1, 2, 3, 5, 8, 13};\n   }\n};\nitem make_item()\n{\n   return item{};\n}\n// undefined behavior, until C++23\nfor (int rate : make_item().getRates())\n{\n   std::cout << rate << '\\n';\n} \n```", "```cpp\nfor (auto item = make_item(); int rate : item.getRates())\n{\n   std::cout << rate << '\\n';\n} \n```", "```cpp\ntemplate <typename T, size_t const Size>\nclass dummy_array\n{\n  T data[Size] = {};\npublic:\n  T const & GetAt(size_t const index) const\n {\n    if (index < Size) return data[index];\n    throw std::out_of_range(\"index out of range\");\n  }\n  void SetAt(size_t const index, T const & value)\n {\n    if (index < Size) data[index] = value;\n    else throw std::out_of_range(\"index out of range\");\n  }\n  size_t GetSize() const { return Size; }\n}; \n```", "```cpp\ndummy_array<int, 3> arr;\narr.SetAt(0, 1);\narr.SetAt(1, 2);\narr.SetAt(2, 3);\nfor(auto&& e : arr)\n{\n  std::cout << e << '\\n';\n} \n```", "```cpp\n    template <typename T, typename C, size_t const Size>\n    class dummy_array_iterator_type\n    {\n    public:\n      dummy_array_iterator_type(C& collection,\n                                size_t const index) :\n      index(index), collection(collection)\n      { }\n      bool operator!= (dummy_array_iterator_type const & other) const\n      {\n        return index != other.index;\n      }\n      T const & operator* () const\n      {\n        return collection.GetAt(index);\n      }\n      dummy_array_iterator_type& operator++()\n      {\n        ++index;\n        return *this;\n      }\n      dummy_array_iterator_type operator++(int)\n      {\n        auto temp = *this;\n        ++*this;\n        return temp;\n      }\n    private:\n      size_t   index;\n      C&       collection;\n    }; \n    ```", "```cpp\n    template <typename T, size_t const Size>\n    using dummy_array_iterator =\n      dummy_array_iterator_type<\n        T, dummy_array<T, Size>, Size>;\n    template <typename T, size_t const Size>\n    using dummy_array_const_iterator =\n      dummy_array_iterator_type<\n        T, dummy_array<T, Size> const, Size>; \n    ```", "```cpp\n    template <typename T, size_t const Size>\n    inline dummy_array_iterator<T, Size> begin(\n      dummy_array<T, Size>& collection)\n    {\n      return dummy_array_iterator<T, Size>(collection, 0);\n    }\n    template <typename T, size_t const Size>\n    inline dummy_array_iterator<T, Size> end(\n      dummy_array<T, Size>& collection)\n    {\n      return dummy_array_iterator<T, Size>(\n        collection, collection.GetSize());\n    }\n    template <typename T, size_t const Size>\n    inline dummy_array_const_iterator<T, Size> begin(\n      dummy_array<T, Size> const & collection)\n    {\n      return dummy_array_const_iterator<T, Size>(\n        collection, 0);\n    }\n    template <typename T, size_t const Size>\n    inline dummy_array_const_iterator<T, Size> end(\n      dummy_array<T, Size> const & collection)\n    {\n      return dummy_array_const_iterator<T, Size>(\n        collection, collection.GetSize());\n    } \n    ```", "```cpp\ntemplate <typename T, const size_t Size>\nvoid print_dummy_array(dummy_array<T, Size> const & arr)\n{\n  for (auto && e : arr)\n  {\n    std::cout << e << '\\n';\n  }\n} \n```", "```cpp\nstruct handle_t\n{\n  explicit handle_t(int const h) : handle(h) {}\n  explicit operator bool() const { return handle != 0; };\nprivate:\n  int handle;\n}; \n```", "```cpp\nstruct foo\n{\n  foo()\n  { std::cout << \"foo\" << '\\n'; }\n  foo(int const a)\n  { std::cout << \"foo(a)\" << '\\n'; }\n  foo(int const a, double const b)\n  { std::cout << \"foo(a, b)\" << '\\n'; }\n  operator bool() const { return true; }\n}; \n```", "```cpp\nfoo f1;              // foo()\nfoo f2 {};           // foo()\nfoo f3(1);           // foo(a)\nfoo f4 = 1;          // foo(a)\nfoo f5 { 1 };        // foo(a)\nfoo f6 = { 1 };      // foo(a)\nfoo f7(1, 2.0);      // foo(a, b)\nfoo f8 { 1, 2.0 };   // foo(a, b)\nfoo f9 = { 1, 2.0 }; // foo(a, b) \n```", "```cpp\nfoo(std::initializer_list<int> l)\n{ std::cout << \"foo(l)\" << '\\n'; } \n```", "```cpp\nvoid bar(foo const f)\n{\n}\nbar({});             // foo()\nbar(1);              // foo(a)\nbar({ 1, 2.0 });     // foo(a, b) \n```", "```cpp\nbool flag = f1;                // OK, expect bool conversion\nif(f2) { /* do something */ }  // OK, expect bool conversion\nstd::cout << f3 + f4 << '\\n';  // wrong, expect foo addition\nif(f5 == f6) { /* do more */ } // wrong, expect comparing foos \n```", "```cpp\nclass string_buffer\n{\npublic:\n  string_buffer() {}\n  string_buffer(size_t const size) { data.resize(size); }\n  string_buffer(char const * const ptr) : data(ptr) {}\n  size_t size() const { return data.size(); }\n  operator bool() const { return !data.empty(); }\n  operator char const * () const { return data.c_str(); }\nprivate:\n   std::string data;\n}; \n```", "```cpp\nstd::shared_ptr<char> str;\nstring_buffer b1;            // calls string_buffer()\nstring_buffer b2(20);        // calls string_buffer(size_t const)\nstring_buffer b3(str.get()); // calls string_buffer(char const*) \n```", "```cpp\nenum ItemSizes {DefaultHeight, Large, MaxSize};\nstring_buffer b4 = 'a';\nstring_buffer b5 = MaxSize; \n```", "```cpp\nclass string_buffer\n{\npublic:\n  explicit string_buffer() {}\n  explicit string_buffer(size_t const size) { data.resize(size); }\n  explicit string_buffer(char const * const ptr) :data(ptr) {}\n  size_t size() const { return data.size(); }\n  explicit operator bool() const { return !data.empty(); }\n  explicit operator char const * () const { return data.c_str(); }\nprivate:\n   std::string data;\n}; \n```", "```cpp\nstring_buffer b4 = string_buffer('a');\nstring_buffer b5 = static_cast<string_buffer>(MaxSize);\nstring_buffer b6 = string_buffer{ \"a\" }; \n```", "```cpp\nstring_buffer b7{ 'a' };\nstring_buffer b8('a'); \n```", "```cpp\nstd::cout << b4 + b5 << '\\n'; // error\nif(b4 == b5) {}               // error \n```", "```cpp\nstd::cout << static_cast<bool>(b4) + static_cast<bool>(b5);\nif(static_cast<bool>(b4) == static_cast<bool>(b5)) {} \n```", "```cpp\n// file1.cpp\nnamespace\n{\n  void print(std::string const & message)\n {\n    std::cout << \"[file1] \" << message << '\\n';\n  }\n}\nvoid file1_run()\n{\n  print(\"run\");\n}\n// file2.cpp\nnamespace\n{\n  void print(std::string const & message)\n {\n    std::cout << \"[file2] \" << message << '\\n';\n  }\n}\nvoid file2_run()\n{\n  print(\"run\");\n} \n```", "```cpp\n// file1.cpp\nnamespace _unique_name_ {}\nusing namespace _unique_name_;\nnamespace _unique_name_\n{\n  void print(std::string message)\n {\n    std::cout << \"[file1] \" << message << '\\n';\n  }\n}\nvoid file1_run()\n{\n  print(\"run\");\n} \n```", "```cpp\ntemplate <int const& Size>\nclass test {};\nstatic int Size1 = 10;\nnamespace\n{\n  int Size2 = 10;\n}\ntest<Size1> t1;\ntest<Size2> t2; \nt1 variable produces a compiler error because the non-type argument expression, Size1, has internal linkage. Conversely, the declaration of the t2 variable is correct because Size2 has an external linkage. (Note that compiling this snippet with Clang and GCC does not produce an error.)\n```", "```cpp\nnamespace modernlib\n{\n  #ifndef LIB_VERSION_2\ninline namespace version_1\n  {\n    template<typename T>\n int test(T value) { return 1; }\n  }\n  #endif\n#ifdef LIB_VERSION_2\ninline namespace version_2\n  {\n    template<typename T>\n int test(T value) { return 2; }\n  }\n  #endif\n} \n```", "```cpp\nnamespace modernlib\n{\n  template<typename T>\n int test(T value) { return 1; }\n} \n```", "```cpp\nauto x = modernlib::test(42); \n```", "```cpp\nstruct foo { int a; };\nnamespace modernlib\n{\n  template<>\n  int test(foo value) { return value.a; }\n}\nauto y = modernlib::test(foo{ 42 }); \n```", "```cpp\nnamespace modernlib\n{\n  namespace version_1\n  {\n    template<typename T>\n int test(T value) { return 1; }\n  }\n  #ifndef LIB_VERSION_2\nusing namespace version_1;\n  #endif\nnamespace version_2\n  {\n    template<typename T>\n int test(T value) { return 2; }\n  }\n  #ifdef LIB_VERSION_2\nusing namespace version_2;\n  #endif\n} \n```", "```cpp\n#define LIB_VERSION_2\n#include \"modernlib.h\"\nstruct foo { int a; };\nnamespace modernlib\n{\n  namespace version_2\n  {\n    template<>\n    int test(foo value) { return value.a; }\n  }\n} \n```", "```cpp\n    std::tuple<int, std::string, double> find()\n    {\n      return {1, \"marius\", 1234.5};\n    } \n    ```", "```cpp\n    auto [id, name, score] = find(); \n    ```", "```cpp\n    if (auto [id, name, score] = find(); score > 1000)\n    {\n      std::cout << name << '\\n';\n    } \n    ```", "```cpp\nstd::map<int, std::string> m;\nauto result = m.insert({ 1, \"one\" });\nstd::cout << \"inserted = \" << result.second << '\\n'\n          << \"value = \" << result.first->second << '\\n'; \n```", "```cpp\nstd::map<int, std::string> m;\nstd::map<int, std::string>::iterator it;\nbool inserted;\nstd::tie(it, inserted) = m.insert({ 1, \"one\" });\nstd::cout << \"inserted = \" << inserted << '\\n'\n          << \"value = \" << it->second << '\\n';\nstd::tie(it, inserted) = m.insert({ 1, \"two\" });\nstd::cout << \"inserted = \" << inserted << '\\n'\n          << \"value = \" << it->second << '\\n'; \n```", "```cpp\nstd::map<int, std::string> m;\n{\n  auto [it, inserted] = m.insert({ 1, \"one\" });\n  std::cout << \"inserted = \" << inserted << '\\n'\n            << \"value = \" << it->second << '\\n';\n}\n{\n  auto [it, inserted] = m.insert({ 1, \"two\" });\n  std::cout << \"inserted = \" << inserted << '\\n'\n            << \"value = \" << it->second << '\\n';\n} \n```", "```cpp\nif(auto [it, inserted] = m.insert({ 1, \"two\" }); inserted)\n{ std::cout << it->second << '\\n'; } \nit and inserted, defined in the scope of the if statement in the initialization part. Then, the condition of the if statement is evaluated from the value of the inserted variable.\n```", "```cpp\nint arr[] = { 1,2 };\nauto [a, b] = arr;\nauto& [x, y] = arr;\narr[0] += 10;\narr[1] += 10;\nstd::cout << arr[0] << ' ' << arr[1] << '\\n'; // 11 12\nstd::cout << a << ' ' << b << '\\n';           // 1 2\nstd::cout << x << ' ' << y << '\\n';           // 11 12 \n```", "```cpp\nstruct foo\n{\n   int         id;\n   std::string name;\n};\nfoo f{ 42, \"john\" };\nauto [i, n] = f;\nauto& [ri, rn] = f;\nf.id = 43;\nstd::cout << f.id << ' ' << f.name << '\\n';   // 43 john\nstd::cout << i <<'''' << n <<''\\'';           // 42 john\nstd::cout << ri <<'''' << rn <<''\\'';         // 43 john \n```", "```cpp\nfoo f{ 42,\"john\" };\nauto [i, n] = f;\nauto l1 = [i] {std::cout << i; };\nauto l2 = [=] {std::cout << i; };\nauto l3 = [&i] {std::cout << i; };\nauto l4 = [&] {std::cout << i; }; \n```", "```cpp\nfoo f{ 42,\"john\" };\nauto [_, n] = f; \n```", "```cpp\n    std::pair   p{ 42, \"demo\" };  // deduces std::pair<int, char const*>\n    std::vector v{ 1, 2 };        // deduces std::vector<int>\n    std::less   l;                // deduces std::less<void> \n    ```", "```cpp\n    template <class T>\n    struct foo\n    {\n       foo(T v) :data(v) {}\n    private:\n       T data;\n    };\n    auto f = new foo(42); \n    ```", "```cpp\n    std::mutex mx;\n    // deduces std::lock_guard<std::mutex>\n    auto lock = std::lock_guard(mx);\n    std::vector<int> v;\n    // deduces std::back_insert_iterator<std::vector<int>>\n    std::fill_n(std::back_insert_iterator(v), 5, 42); \n    ```", "```cpp\nstd::pair<int, char const*> p{ 42, \"demo\" };\nstd::vector<int>            v{ 1, 2 };\nfoo<int>                    f{ 42 }; \n```", "```cpp\nauto p = std::make_pair(42, \"demo\"); \n```", "```cpp\ntemplate <typename T>\nconstexpr foo<T> make_foo(T&& value)\n{\n   return foo{ value };\n}\nauto f = make_foo(42); \n```", "```cpp\nstd::pair p{ 42, \"demo\" }; \n```", "```cpp\ntemplate <class T1, class T2>\nstd::pair<T1, T2> F();\ntemplate <class T1, class T2>\nstd::pair<T1, T2> F(T1 const& x, T2 const& y);\ntemplate <class T1, class T2, class U1, class U2>\nstd::pair<T1, T2> F(U1&& x, U2&& y); \n```", "```cpp\nstd::pair p{ 42, \"demo\" }; \n```", "```cpp\nnamespace std {\n   template <class T>\n   pair(T&&, char const*)->pair<T, std::string>;\n   template <class T>\n   pair(char const*, T&&)->pair<std::string, T>;\n   pair(char const*, char const*)->pair<std::string, std::string>;\n} \n```", "```cpp\nstd::pair  p1{ 42, \"demo\" };    // std::pair<int, std::string>\nstd::pair  p2{ \"demo\", 42 };    // std::pair<std::string, int>\nstd::pair  p3{ \"42\", \"demo\" };  // std::pair<std::string, std::string> \n```", "```cpp\nstd::pair<>    p1 { 42, \"demo\" };\nstd::pair<int> p2 { 42, \"demo\" }; \n```", "```cpp\n    template<class T>\n    struct Point3D { T x; T y; T z; }; \n\n    Point3D p{1, 2, 2};   // error, requires Point3D<int> \n    ```", "```cpp\n    template <typename T>\n    using my_vector = std::vector<T>;\n    std::vector v{1,2,3}; // OK\n    my_vector mv{1,2,3};  // error \n    ```", "```cpp\n    template <typename T> \n    struct box\n    {\n       box(T&& t) : content(std::forward<T>(t)) {}\n       virtual void unwrap()\n     { std::cout << \"unwrapping \" << content << '\\n'; }\n       T content;\n    };\n    template <typename T>\n    struct magic_box : public box<T>\n    {\n       using box<T>::box;\n       virtual void unwrap() override\n     { std::cout << \"unwrapping \" << box<T>::content << '\\n'; }\n    };\n    int main()\n    {\n       box b(42);        // OK\n       b.unwrap();\n       magic_box m(21);  // error, requires magic_box<int>\n       m.unwrap();\n    } \n    ```", "```cpp\n    template <typename T>\n    struct some_buffer\n    {\n       some_buffer(size_t const size):data(size)\n       {}\n       size_t size() const { return data.size(); }\n       T const& operator[](size_t const index) const\n       {\n          if(index >= data.size())\n             std::runtime_error(\"invalid index\");\n          return data[index];\n       }\n       T & operator[](size_t const index)\n       {\n          if (index >= data.size())\n             std::runtime_error(\"invalid index\");\n          return data[index];\n       }\n    private:\n       std::vector<T> data;\n    }; \n    ```", "```cpp\n    template <typename T, size_t ROWS, size_t COLS>\n    struct matrix\n    {\n       T& operator[](size_t const row, size_t const col)\n       {\n          if(row >= ROWS || col >= COLS)\n             throw std::runtime_error(\"invalid index\");\n          return data[row * COLS + col];\n       }\n       T const & operator[](size_t const row,                         size_t const col) const\n       {\n          if (row >= ROWS || col >= COLS)\n             throw std::runtime_error(\"invalid index\");\n          return data[row * COLS + col];\n       }\n    private:\n       std::array<T, ROWS* COLS> data;\n    }; \n    ```", "```cpp\nstd::vector<int> v {1, 2, 3};\nv[2] = v[1] + v[0]; \n```", "```cpp\ntemplate <typename T, size_t ROWS, size_t COLS>\nstruct matrix\n{\n   T& operator()(size_t const row, size_t const col)\n {\n      if(row >= ROWS || col >= COLS)\n         throw std::runtime_error(\"invalid index\");\n      return data[row * COLS + col];\n   }\n   T const & operator()(size_t const row, size_t const col) const\n {\n      if (row >= ROWS || col >= COLS)\n         throw std::runtime_error(\"invalid index\");\n      return data[row * COLS + col];\n   }\nprivate:\n   std::array<T, ROWS* COLS> data;\n};\nmatrix<int, 2, 3> m;\nm(0, 0) = 1; \n```", "```cpp\ntemplate <typename T, size_t ROWS, size_t COLS>\nstruct matrix\n{\n   T& operator[](std::initializer_list<size_t> index)\n   {\n      size_t row = *index.begin();\n      size_t col = *(index.begin() + 1);\n      if (row >= ROWS || col >= COLS)\n         throw std::runtime_error(\"invalid index\");\n      return data[row * COLS + col];\n   }\n   T const & operator[](std::initializer_list<size_t> index) const\n   {\n      size_t row = *index.begin();\n      size_t col = *(index.begin() + 1);\n      if (row >= ROWS || col >= COLS)\n         throw std::runtime_error(\"invalid index\");\n      return data[row * COLS + col];\n   }\nprivate:\n   std::array<T, ROWS* COLS> data;\n};\nmatrix<int, 2, 3> m;\nm[{0, 0}] = 1; \n```", "```cpp\ntemplate <typename T, size_t ROWS, size_t COLS>\nstruct matrix\n{\n   T& operator[](size_t const row, size_t const col)\n   {\n      if(row >= ROWS || col >= COLS)\n         throw std::runtime_error(\"invalid index\");\n      return data[row * COLS + col];\n   }\n   T const & operator[](size_t const row, size_t const col) const\n   {\n      if (row >= ROWS || col >= COLS)\n         throw std::runtime_error(\"invalid index\");\n      return data[row * COLS + col];\n   }\nprivate:\n   std::array<T, ROWS* COLS> data;\n};\nmatrix<int, 2, 3> m;\nm[0, 0] = 1; \n```", "```cpp\nint data[2*3] = {};\nauto m = std::mdspan<int, std::extents<2, 3>> (data);\nm[0, 0] = 1; \n```"]