<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer201">
<h1 class="chapter-number" id="_idParaDest-127"><a id="_idTextAnchor154"/>7</h1>
<h1 id="_idParaDest-128"><a id="_idTextAnchor155"/>Working with UE5 Utilities</h1>
<p>In the previous chapter, we learned about the remaining collision-related concepts in UE5, such as collision events, object types, physics simulation, and collision components. We learned how to have objects collide against one another, changing their responses to different collision channels, as well as how to create collision presets, spawn actors, and use timers.</p>
<p>In this chapter, we will look at several UE5 utilities that will allow you to easily move logic from one project to another and keep your project well-structured and organized, which will make life much easier for you in the long run and also make it easier for other people in your team to understand your work and modify it in the future. Game development is a tremendously hard task and is rarely done individually, but rather in teams, so it’s important to take these things into account when building your projects.</p>
<p>We’ll cover the following topics in this chapter:</p>
<ul>
<li>Good practices – loose coupling</li>
<li>Blueprint Function Libraries</li>
<li>Actor components</li>
<li>Exploring interfaces</li>
<li>Blueprint native events</li>
</ul>
<h1 id="_idParaDest-129"><a id="_idTextAnchor156"/>Technical requirements</h1>
<p>The project for this chapter can be found in the Chapter07 folder of the code bundle for this book, which can be downloaded here: <a href="https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition">https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition</a>.</p>
<h1 id="_idParaDest-130"><a id="_idTextAnchor157"/>Good practices – loose coupling</h1>
<p>We can use Blueprint <a id="_idIndexMarker518"/>Function Libraries to move some generic functions in our project from a specific actor to a Blueprint Function Library so that they can be used in other parts of our project’s logic.</p>
<p>We will use Actor components to move part of some actor classes’ source code into an Actor component so that we can easily use that logic in other projects. This will keep our project loosely coupled. Loose coupling is a software engineering concept that refers to having your <a id="_idIndexMarker519"/>project structured in such a way that you can easily remove and add things as you need. The reason you should strive for loose coupling is if you want to reuse parts of one of your projects for another project. As a game developer, loose coupling will allow you to do that much more easily.</p>
<p>A practical example of how you could apply loose coupling is if you had a player character class that was able to fly and also had an inventory that contained several usable items. Instead <a id="_idIndexMarker520"/>of implementing the code responsible for both of those things in that player character class, you would implement the logic for each of them in separate Actor components, which you would then add to the class. This will not only make it easier to add and remove things that this class will do, by simply adding and removing the Actor components responsible for those things, but also allow you to reuse those Actor components in other projects where you have a character that has an inventory or can fly. This is one of the main purposes of Actor components.</p>
<p>Interfaces, much like Actor components, make our project better structured and organized.</p>
<p>Let’s start by talking about Blueprint Function Libraries.</p>
<h1 id="_idParaDest-131"><a id="_idTextAnchor158"/>Blueprint Function Libraries</h1>
<p>In UE5, there’s a class called <strong class="source-inline">BlueprintFunctionLibary</strong> that is meant to contain a collection <a id="_idIndexMarker521"/>of static functions that don’t belong to any specific actor and can be used in multiple parts of your project.</p>
<p>For instance, some of the objects that we used previously, such as the <strong class="source-inline">GameplayStatics</strong> object and <strong class="source-inline">Kismet</strong> libraries such as <strong class="source-inline">KismetMathLibrary</strong> and <strong class="source-inline">KismetSystemLibrary</strong>, are Blueprint Function Libraries. These contain functions that can be used in any part of your project.</p>
<p>There is at least one function in our project that’s been created by us that can be moved to a Blueprint Function Library: the <strong class="source-inline">CanSeeActor</strong> function defined in the <strong class="source-inline">EnemyCharacter</strong> class.</p>
<p>In the first exercise of this chapter, we will create a Blueprint Function Library so that we can move the <strong class="source-inline">CanSeeActor</strong> function from the <strong class="source-inline">EnemyCharacter</strong> class to the <strong class="source-inline">BlueprintFunctionLibrary</strong> class.</p>
<h2 id="_idParaDest-132"><a id="_idTextAnchor159"/>Exercise 7.01 – moving the CanSeeActor function to the Blueprint Function Library</h2>
<p>In this exercise, we <a id="_idIndexMarker522"/>will be <a id="_idIndexMarker523"/>moving the <strong class="source-inline">CanSeeActor</strong> function that we created for the <strong class="source-inline">EnemyCharacter</strong> class to a Blueprint Function Library. </p>
<p>The following steps will help you complete this exercise:</p>
<ol>
<li>Open Unreal Editor.</li>
<li><em class="italic">Right-click</em> inside the <strong class="bold">Content Browser</strong> area and select <strong class="bold">New C++ Class</strong>.</li>
<li>Choose <strong class="bold">BlueprintFunctionLibrary</strong> as the parent class of this C++ class (you’ll find it by scrolling to the end of the panel).</li>
<li>Name the new C++ class <strong class="source-inline">DodgeballFunctionLibrary</strong>.</li>
<li>After the class’s files have been generated in Visual Studio, open them and close the editor.</li>
<li>In the header file of <strong class="source-inline">DodgeballFunctionLibrary</strong>, add a declaration for a <strong class="source-inline">public</strong> function called <strong class="source-inline">CanSeeActor</strong>. This function will be similar to the one we created in the <strong class="source-inline">EnemyCharacter</strong> class; however, there will be some differences. </li>
</ol>
<p>The new <strong class="source-inline">CanSeeActor</strong> function will be <strong class="source-inline">static</strong>, will return a <strong class="source-inline">bool</strong>, and will receive the following parameters:</p>
<ul>
<li>A <strong class="source-inline">const UWorld* World</strong> property, which we will use to access the <strong class="source-inline">Line Trace</strong> functions.</li>
<li>An <strong class="source-inline">FVector Location</strong> property, which we will use as the location of the actor that is checking whether it can see the target actor.</li>
<li>A <strong class="source-inline">const AActor* TargetActor</strong> property, which will be the actor we’re checking visibility for.</li>
<li>A <strong class="source-inline">TArray&lt;const AActor*&gt; IgnoreActors</strong> property, which will specify the actors that should be ignored during the <strong class="source-inline">Line Trace</strong> functions. This property can have an empty array as a default argument:<p class="source-code">public:</p><p class="source-code">// Can we see the given actor</p><p class="source-code">static bool CanSeeActor(</p><p class="source-code">const UWorld* World,</p><p class="source-code">FVector Location,</p><p class="source-code">const AActor* TargetActor,</p><p class="source-code">TArray&lt;const AActor*&gt; IgnoreActors = TArray&lt;const AActor*&gt;());</p></li>
</ul>
<ol>
<li value="7">Create <a id="_idIndexMarker524"/>the implementation <a id="_idIndexMarker525"/>of this function in the class’s source file and copy the implementation of the <strong class="source-inline">EnemyCharacter</strong> class’s version into this new class. Once you’ve done that, make the following modifications to the implementation:<ul><li>Change the value of the <strong class="source-inline">Start</strong> location of the <strong class="source-inline">Line Trace</strong> to the <strong class="source-inline">Location</strong> parameter:<p class="source-code">// Where the Line Trace starts and ends</p><p class="source-code">FVector Start = Location;</p></li><li>Instead of ignoring this actor (using the <strong class="source-inline">this</strong> pointer) and <strong class="source-inline">TargetActor</strong>, ignore the entire <strong class="source-inline">IgnoreActors</strong> array using the <strong class="source-inline">AddIgnoredActors</strong> function of <strong class="source-inline">FCollisionQueryParams</strong> and send that array as a parameter:<p class="source-code">FCollisionQueryParams QueryParams;</p><p class="source-code">// Ignore the actors specified</p><p class="source-code">QueryParams.AddIgnoredActors(IgnoreActors);</p></li><li>Replace both calls to the <strong class="source-inline">GetWorld</strong> function with the received <strong class="source-inline">World</strong> parameter:<p class="source-code">// Execute the Line Trace</p><p class="source-code">World-&gt;LineTraceSingleByChannel(Hit, Start, End, Channel, </p><p class="source-code">  QueryParams);</p><p class="source-code">// Show the Line Trace inside the game</p><p class="source-code">DrawDebugLine(World, Start, End, FColor::Red);</p></li><li>Add <a id="_idIndexMarker526"/>the necessary <a id="_idIndexMarker527"/>includes to the top of the <strong class="source-inline">DodgeballFunctionLibrary</strong> class, as shown in the following code snippet:<p class="source-code">#include "Engine/World.h"</p><p class="source-code">#include "DrawDebugHelpers.h"</p><p class="source-code">#include "CollisionQueryParams.h"</p></li></ul></li>
<li>Once you’ve created the new version of the <strong class="source-inline">CanSeeActor</strong> function inside <strong class="source-inline">DodgeballFunctionLibrary</strong>, head to our <strong class="source-inline">EnemyCharacter</strong> class and make the following changes:<ul><li>Remove the declaration and implementation of the <strong class="source-inline">CanSeeActor</strong> function, inside its header and source file, respectively.</li><li>Remove the <strong class="source-inline">DrawDebugHelpers</strong> include, given that we will no longer need that file:<p class="source-code">// Remove this line</p><p class="source-code">#include "DrawDebugHelpers.h"</p></li><li>Add an include for <strong class="source-inline">DodgeballFunctionLibrary</strong>:<p class="source-code">#include "DodgeballFunctionLibrary.h"</p></li><li>Inside the class’s <strong class="source-inline">LookAtActor</strong> function, just before the <strong class="source-inline">if</strong> statement that calls the <strong class="source-inline">CanSeeActor</strong> function, declare a <strong class="source-inline">const TArray&lt;const AActor*&gt; IgnoreActors</strong> variable and set it to both the <strong class="source-inline">this</strong> pointer and the <strong class="source-inline">TargetActor</strong> parameter:<p class="source-code">const TArray&lt;const AActor*&gt; IgnoreActors = {this, </p><p class="source-code">  TargetActor};</p></li></ul></li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">Introducing the preceding code snippet may give you an IntelliSense error in Visual Studio. You can safely ignore it, as your code should compile with no issues regardless.</p>
<ol>
<li value="9">Replace <a id="_idIndexMarker528"/>the existing <a id="_idIndexMarker529"/>call to the <strong class="source-inline">CanSeeActor</strong> function with the one we just created by sending the following as parameters:<ul><li>The current world, through the <strong class="source-inline">GetWorld</strong> function</li><li>The <strong class="source-inline">SightSource</strong> component’s location, using its <strong class="source-inline">GetComponentLocation</strong> function</li><li>The <strong class="source-inline">TargetActor</strong> parameter</li><li>The <strong class="source-inline">IgnoreActors</strong> array we just created:<p class="source-code">if (UDodgeballFunctionLibrary::CanSeeActor(</p><p class="source-code">  GetWorld(),</p><p class="source-code">  SightSource-&gt;GetComponentLocation(),</p><p class="source-code">  TargetActor,</p><p class="source-code">  IgnoreActors))</p></li></ul></li>
</ol>
<p>Now that you’ve made all those changes, compile your code, open your project, and verify that the <strong class="source-inline">EnemyCharacter</strong> class still looks at the player as it walks around, so long as it’s in the enemy character’s sight, as shown in the following screenshot:</p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
<div>
<div class="IMG---Figure" id="_idContainer195">
<img alt="Figure 7.1 – The enemy character still looking at the player character " height="368" src="image/Figure_7.01_B18531.jpg" width="311"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – The enemy character still looking at the player character</p>
<p>And that <a id="_idIndexMarker530"/>concludes our exercise. We’ve <a id="_idIndexMarker531"/>put our <strong class="source-inline">CanSeeActor</strong> function inside a Blueprint Function Library and can now reuse it for other actors that require the same type of functionality.</p>
<p>The next step in our project is going to be learning more about Actor components and how we can use them to our advantage. Let’s take a look.</p>
<h1 id="_idParaDest-133"><a id="_idTextAnchor160"/>Actor components</h1>
<p>As we saw in <a id="_idIndexMarker532"/>the first few chapters of this book, Actors are the main way to create logic in UE5. However, we’ve also seen that Actors can contain several Actor components.</p>
<p>Actor components are objects that can be added to an Actor and can have multiple types of functionality, such as being responsible for a character’s inventory or making a character fly. Actor components must <a id="_idIndexMarker533"/>always belong to and live inside an Actor, which <a id="_idIndexMarker534"/>is referred to as their <strong class="bold">Owner</strong>. </p>
<p>There are several different types of existing Actor components. Some of these are as follows:</p>
<ul>
<li>Code-only Actor components, which act as their own class inside an actor. They have their own <a id="_idIndexMarker535"/>properties and functions and can both interact with the Actor they belong to and be interacted with by it.</li>
<li>Mesh components, which <a id="_idIndexMarker536"/>are used to draw several types of Mesh objects (Static Meshes, Skeletal Meshes, and so on).</li>
<li>Collision components, which are <a id="_idIndexMarker537"/>used to receive <a id="_idIndexMarker538"/>and generate collision events.</li>
<li>Camera components.</li>
</ul>
<p>This leaves us with two main ways to add logic to our Actors: directly in the <strong class="source-inline">Actor</strong> class or through <strong class="source-inline">Actor</strong> components. To follow good software development practices, namely loose coupling (mentioned previously), you should strive to use Actor components instead <a id="_idIndexMarker539"/>of placing logic directly inside an Actor whenever possible. Let’s take a look at a practical example to understand the usefulness of Actor components.</p>
<p>Let’s say you’re making a game where you have the player character and enemy characters, both of which have health, and where the player character must fight enemies, who can also fight back. If you had to implement the health logic, which includes gaining health, losing health, and tracking the character’s health, you’d have two options:</p>
<ul>
<li>You can implement the health logic in a base character class, from which both the player character class and the enemy character class would inherit.</li>
<li>You can implement the health logic in an Actor component and add that component to both the player character and enemy character classes separately.</li>
</ul>
<p>There are a few reasons why the first option is not a good option, but the main one is this: if you wanted to add another piece of logic to both character classes (for example, stamina, which would limit the strength and frequency of the characters’ attacks), doing so using the same <a id="_idIndexMarker540"/>approach of a base class wouldn’t be a viable option. Given that, in UE5, C++ classes can only inherit from one class and there’s no such thing as multiple inheritance, that would be very hard to manage. It would also only get more complicated and unmanageable the more logic you decided to add to your project.</p>
<p>With that said, when adding logic to your project that can be encapsulated in a separate component, allowing you to achieve loose coupling, you should always do so.</p>
<p>Now, let’s create a new Actor component that will be responsible for keeping track of an actor’s health, as well as gaining and losing that health.</p>
<h2 id="_idParaDest-134"><a id="_idTextAnchor161"/>Exercise 7.02 – creating the HealthComponent Actor component</h2>
<p>In this <a id="_idIndexMarker541"/>exercise, we will be creating a new actor component responsible for gaining, losing, and keeping track of an actor’s health (its Owner).</p>
<p>For the player to lose, we’ll have to make the player character lose health and then end the game when it runs out of health. We’ll want to put this logic inside an actor component so that we can easily add all this health-related logic to other actors if we need to.</p>
<p>The following steps will help you complete the exercise:</p>
<ol>
<li value="1">Open the editor and create a new C++ class, whose parent class will be the <strong class="source-inline">ActorComponent</strong> class. Its name will be <strong class="source-inline">HealthComponent</strong>.</li>
<li>Once this class has been created and its files have been opened in Visual Studio, go to its header file and add a protected <strong class="source-inline">float</strong> property called <strong class="source-inline">Health</strong>, which will keep track of the Owner’s current health points. Its default value can be set to the number of health points its Owner will start the game with. In this case, we’ll initialize it with a value of <strong class="source-inline">100</strong> health points:<p class="source-code">// The Owner's initial and current amount health </p><p class="source-code">// points</p><p class="source-code">UPROPERTY(EditDefaultsOnly, Category = Health)</p><p class="source-code">float Health = 100.f;</p></li>
<li>Create a declaration for the function that’s responsible for taking health away from <a id="_idIndexMarker542"/>its Owner. This function should be <strong class="source-inline">public</strong>; return nothing; receive a <strong class="source-inline">float Amount</strong> property as input, which indicates how many health points its Owner should lose; and be called <strong class="source-inline">LoseHealth</strong>:<p class="source-code">// Take health points from its Owner</p><p class="source-code">void LoseHealth(float Amount);</p></li>
</ol>
<p>Now, in the class’s source file, let’s start by notifying it that it should never use the <strong class="source-inline">Tick</strong> event so that its performance can be slightly improved. </p>
<ol>
<li value="4">Change the <strong class="source-inline">bCanEverTick</strong> property’s value to <strong class="source-inline">false</strong> inside the class’s constructor:<p class="source-code">PrimaryComponentTick.bCanEverTick = false;</p></li>
<li>Create the implementation for our <strong class="source-inline">LoseHealth</strong> function, where we’ll start by removing the <strong class="source-inline">Amount</strong> parameter’s value from our <strong class="source-inline">Health</strong> property:<p class="source-code">void UHealthComponent::LoseHealth(float Amount)</p><p class="source-code">{</p><p class="source-code">  Health -= Amount;</p><p class="source-code">}</p></li>
<li>Now, in that same function, we’ll check whether the current amount of health is less than or equal to <strong class="source-inline">0</strong>, which means that it has run out of health points (<em class="italic">has died or been destroyed</em>):<p class="source-code">if (Health &lt;= 0.f)</p><p class="source-code">{</p><p class="source-code">}</p></li>
<li>If the <strong class="source-inline">if</strong> statement <a id="_idIndexMarker543"/>is true, we’ll do the following things:<ul><li>Set the <strong class="source-inline">Health</strong> property to <strong class="source-inline">0</strong> to make sure that our Owner doesn’t have negative health points:<p class="source-code">Health = 0.f;</p></li><li>Quit the game, the same way we did in <a href="B18531_06.xhtml#_idTextAnchor134"><em class="italic">Chapter 6</em></a>, <em class="italic">Setting Up</em> <em class="italic">Collision Objects</em>, when creating the <strong class="source-inline">VictoryBox</strong> class:<p class="source-code">UKismetSystemLibrary::QuitGame(this,</p><p class="source-code">                              nullptr,</p><p class="source-code">                              EQuitPreference::Quit,</p><p class="source-code">                              true);</p></li><li>Don’t forget to include the <strong class="source-inline">KismetSystemLibrary</strong> object:<p class="source-code">#include "Kismet/KismetSystemLibrary.h"</p></li></ul></li>
</ol>
<p>With this logic done, whenever any actor that has <strong class="source-inline">HealthComponent</strong> runs out of health, the game will end. This isn’t exactly the behavior we want in our <strong class="bold">Dodgeball</strong> game. However, we’ll change it when we talk about interfaces later in this chapter.</p>
<p>In the next exercise, we’ll be making the necessary modifications to some classes in our project to accommodate our newly created <strong class="source-inline">HealthComponent</strong>.</p>
<h2 id="_idParaDest-135"><a id="_idTextAnchor162"/>Exercise 7.03 – integrating the HealthComponent Actor component</h2>
<p>In this exercise, we <a id="_idIndexMarker544"/>will be modifying our <strong class="source-inline">DodgeballProjectile</strong> class so that it damages the player’s character when it comes into contact with it, as well as the <strong class="source-inline">DodgeballCharacter</strong> class so that it has a <strong class="source-inline">HealthComponent</strong>.</p>
<p>Open the <strong class="source-inline">DodgeballProjectile</strong> class’s files in Visual Studio and make the following modifications:</p>
<ol>
<li value="1">In the class’s header file, add a protected <strong class="source-inline">float</strong> property called <strong class="source-inline">Damage</strong> and set its default value to <strong class="source-inline">34</strong> so that our player character will lose all of its health points after being hit three times. This property should be a <strong class="source-inline">UPROPERTY</strong> and have the <strong class="source-inline">EditAnywhere</strong> tag so that you can easily change its value in its Blueprint class:<p class="source-code">// The damage the dodgeball will deal to the player's </p><p class="source-code">  character</p><p class="source-code">UPROPERTY(EditAnywhere, Category = Damage)</p><p class="source-code">float Damage = 34.f;</p></li>
</ol>
<p>In the class’s source file, we’ll have to make some modifications to the <strong class="source-inline">OnHit</strong> function.</p>
<ol>
<li value="2">Since we’ll be using the <strong class="source-inline">HealthComponent</strong> class, we’ll have to add the <strong class="source-inline">include</strong> statement for it:<p class="source-code">#include "HealthComponent.h"</p></li>
<li>The existing cast that is being done for <strong class="source-inline">DodgeballCharacter</strong> from the <strong class="source-inline">OtherActor</strong> property, which we did in <em class="italic">s</em><em class="italic">tep 17</em> of <em class="italic">Exercise 6.01 – creating the Dodgeball class</em>, and is inside the <strong class="source-inline">if</strong> statement, should be done before that <strong class="source-inline">if</strong> statement and be saved inside a variable. Then, you should check whether that variable is <strong class="source-inline">nullptr</strong>. We are doing this to access the player character’s <strong class="source-inline">HealthComponent</strong> inside the <strong class="source-inline">if</strong> statement:<p class="source-code">ADodgeballCharacter* Player = </p><p class="source-code">  Cast&lt;ADodgeballCharacter&gt;(OtherActor);</p><p class="source-code">if (Player != nullptr)</p><p class="source-code">{</p><p class="source-code">}</p></li>
<li>If the <strong class="source-inline">if</strong> statement is true (that is, if the actor we hit is the player’s character), we <a id="_idIndexMarker545"/>want to access that character’s <strong class="source-inline">HealthComponent</strong> and reduce the character’s health. To access <strong class="source-inline">HealthComponent</strong>, we must call the character’s <strong class="source-inline">FindComponentByClass</strong> function and send the <strong class="source-inline">UHealthComponent</strong> class as a template parameter (to indicate the class of the component we want to access):<p class="source-code">UHealthComponent* HealthComponent = Player-&gt;</p><p class="source-code">FindComponentByClass&lt;UHealthComponent&gt;();</p></li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">The <strong class="source-inline">FindComponentByClass</strong> function, included in the <strong class="source-inline">Actor</strong> class, will return a reference(s) to <a id="_idIndexMarker546"/>the actor component(s) of a specific class that the actor contains. If the function returns <strong class="source-inline">nullptr</strong>, that means the actor doesn’t have an Actor component of that class.</p>
<p class="callout">You may also find the <strong class="source-inline">GetComponents</strong> function inside the <strong class="source-inline">Actor</strong> class useful, which will return a list of all the Actor components inside that actor.</p>
<ol>
<li value="5">After that, check whether <strong class="source-inline">HealthComponent</strong> is <strong class="source-inline">nullptr</strong>. If it isn’t, we’ll call its <strong class="source-inline">LoseHealth</strong> function and send the <strong class="source-inline">Damage</strong> property as a parameter:<p class="source-code">if (HealthComponent != nullptr)</p><p class="source-code">{</p><p class="source-code">  HealthComponent-&gt;LoseHealth(Damage);</p><p class="source-code">}</p><p class="source-code">Destroy();</p></li>
<li>Make sure the existing <strong class="source-inline">Destroy</strong> function is called after doing the null check for <strong class="source-inline">HealthComponent</strong>, as shown in the previous code snippet.</li>
</ol>
<p>Before we finish this exercise, we’ll need to make some modifications to our <strong class="source-inline">DodgeballCharacter</strong> class. Open the class’s files in Visual Studio.</p>
<ol>
<li value="7">In the <a id="_idIndexMarker547"/>class’s header file, add a <strong class="source-inline">private</strong> property of the <strong class="source-inline">class UhealthComponent*</strong> type called <strong class="source-inline">HealthComponent</strong>:<p class="source-code">class UHealthComponent* HealthComponent;</p></li>
<li>In the class’s source file, add an <strong class="source-inline">include</strong> statement to the <strong class="source-inline">HealthComponent</strong> class:<p class="source-code">#include "HealthComponent.h"</p></li>
<li>At the end of the class’s constructor, create <strong class="source-inline">HealthComponent</strong> by using the <strong class="source-inline">CreateDefaultSubobject</strong> function and name it <strong class="source-inline">HealthComponent</strong>:<p class="source-code">HealthComponent = </p><p class="source-code">  CreateDefaultSubobject&lt;UHealthComponent&gt;(</p><p class="source-code">  TEXT("Health </p><p class="source-code">  Component"));</p></li>
</ol>
<p>Once you’ve made all these changes, compile your code and open the editor. When you play the game, if you let your player character get hit by a dodgeball three times, you’ll notice that the game abruptly stops, as intended:</p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
<div>
<div class="IMG---Figure" id="_idContainer196">
<img alt="Figure 7.2 – The enemy character throwing dodgeballs at the player character " height="467" src="image/Figure_7.02_B18531.jpg" width="493"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – The enemy character throwing dodgeballs at the player character</p>
<p>Once <a id="_idIndexMarker548"/>the game is stopped, it will look as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer197">
<img alt="Figure 7.3 – The editor after the player character runs out of health points and the game stops " height="619" src="image/Figure_7.03_B18531.jpg" width="1100"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – The editor after the player character runs out of health points and the game stops</p>
<p>And that completes this exercise. You now know how to create Actor components and how to <a id="_idIndexMarker549"/>access an actor’s Actor components. This is a very important step toward making your game projects more understandable and better structured, so good job.</p>
<p>Now that we’ve learned about Actor components, let’s learn about another way to make our projects better structured and organized: by using interfaces.</p>
<h1 id="_idParaDest-136"><a id="_idTextAnchor163"/>Exploring interfaces</h1>
<p>There’s a chance that you may already know about interfaces, given that other programming <a id="_idIndexMarker550"/>languages, such as Java, already have them. If you do, they work pretty similarly in UE5, but if you don’t, let’s see how they work, taking the example of the <strong class="source-inline">HealthComponent</strong> class we created.</p>
<p>As you saw in the previous exercise, when the <strong class="source-inline">Health</strong> property of the <strong class="source-inline">HealthComponent</strong> class reaches <strong class="source-inline">0</strong>, that component will simply end the game. However, we don’t want that to happen every time an actor’s health points run out: some actors may simply be destroyed, some may notify another actor that they have run out of health points, and so on. We want each actor to be able to determine what happens to them when they run out of health points. But how can we handle this?</p>
<p>Ideally, we would simply call a specific function that belongs to Owner of the <strong class="source-inline">HealthComponent</strong> class, which would then choose how to handle the fact that Owner has run out of health points. But in which class should you implement that function, given that our Owner can be of any class, so long as it inherits from the Actor class? As we discussed at the beginning of this chapter, having a class that’s responsible just for this would quickly become unmanageable. Luckily for us, interfaces solve this problem.</p>
<p>Interfaces are classes that contain a collection of functions that an object must have if it implements <a id="_idIndexMarker551"/>that interface. It essentially works as a contract that the object signs, saying that it will implement all the functions present on that interface. Then, you can simply check whether an object implements a specific interface and call the object’s implementation of the function defined in the interface.</p>
<p>In our specific case, we’ll want to have an interface that has a function that will be called when an object runs out of health points so that our <strong class="source-inline">HealthComponent</strong> class can check whether its Owner implements that interface and then call that function from the interface. This will make it easy for us to specify how each actor behaves when running out of health <a id="_idIndexMarker552"/>points: some actors may simply be destroyed, others may trigger an in-game event, and others may simply end the game (which is the case with our player character).</p>
<p>However, before we create our first interface, we should talk a bit about Blueprint native events.</p>
<h1 id="_idParaDest-137"><a id="_idTextAnchor164"/>Blueprint native events</h1>
<p>When using <a id="_idIndexMarker553"/>the <strong class="source-inline">UFUNCTION</strong> macro in C++, you can turn a function into a Blueprint native event by simply adding the <strong class="source-inline">BlueprintNativeEvent</strong> tag to that macro. </p>
<p>So, what is a Blueprint native event? It’s an event that is declared in C++ that can have a default behavior, which is also defined in C++, but that can be overridden in Blueprint. Let’s declare a Blueprint native event called <strong class="source-inline">MyEvent</strong> by declaring a <strong class="source-inline">MyEvent</strong> function using the <strong class="source-inline">UFUNCTION</strong> macro with the <strong class="source-inline">BlueprintNativeEvent</strong> tag, followed by the virtual <strong class="source-inline">MyEvent_Implementation</strong> function:</p>
<p class="source-code">UFUNCTION(BlueprintNativeEvent)</p>
<p class="source-code">void MyEvent();</p>
<p class="source-code">virtual void MyEvent_Implementation();</p>
<p>The reason why you have to declare these two functions is that the first one is the Blueprint signature, which allows you to override the event in Blueprint, while the second one is the C++ signature, which allows you to override the event in C++. </p>
<p>The C++ signature is simply the name of the event followed by <strong class="source-inline">_Implementation</strong>, and it should always be a <strong class="source-inline">virtual</strong> function. Given that you declared this event in C++, to implement its default behavior, you must implement the <strong class="source-inline">MyEvent_Implementation</strong> function, not the <strong class="source-inline">MyEvent</strong> function (that one should remain untouched). To call a Blueprint native event, you can simply call the normal function without the <strong class="source-inline">_Implementation</strong> suffix; in this case, <strong class="source-inline">MyEvent()</strong>.</p>
<p>In the next exercise, we’ll learn how to use Blueprint native events in practice, where we’ll create a new interface.</p>
<h2 id="_idParaDest-138"><a id="_idTextAnchor165"/>Exercise 7.04 – creating the HealthInterface class</h2>
<p>In this <a id="_idIndexMarker554"/>exercise, we will be creating an interface that’s responsible <a id="_idIndexMarker555"/>for handling how an object behaves when it runs out of health points.</p>
<p>To do this, follow these steps:</p>
<ol>
<li value="1">Open the editor and create a new C++ class that inherits from <strong class="source-inline">Interface</strong> (called <strong class="source-inline">Unreal Interface</strong> in the scrollable menu) and call it <strong class="source-inline">HealthInterface</strong>.</li>
<li>Once the class’s files have been generated and opened in Visual Studio, go to the newly created class’s header file. You’ll notice that the generated file has two classes – <strong class="source-inline">UHealthInterface</strong> and <strong class="source-inline">IHealthInterface</strong>. </li>
<li>These will be used in combination when checking whether an object implements the interface and calls its functions. However, you should only add function declarations in the class prefixed with <strong class="source-inline">I</strong> – in this case, <strong class="source-inline">IHealthInterface</strong>. Add a <strong class="source-inline">public</strong> Blueprint native event called <strong class="source-inline">OnDeath</strong> that returns nothing and receives no parameters. This function will be called when an object runs out of health points:<p class="source-code">UFUNCTION(BlueprintNativeEvent, Category = Health)</p><p class="source-code">void OnDeath();</p><p class="source-code">virtual void OnDeath_Implementation() = 0;</p></li>
</ol>
<p>Note that the <strong class="source-inline">OnDeath_Implementation</strong> function declaration needs its own implementation. However, there is no need for the interface to implement that function because it would simply be empty. To notify the compiler that this function has no implementation in this class, we added <strong class="source-inline">= 0</strong> to the end of its declaration.</p>
<ol>
<li value="4">Go to the <strong class="source-inline">DodgeballCharacter</strong> class’s header file. We’ll want this class to implement our newly created <strong class="source-inline">HealthInterface</strong>, but how do we do that? The first thing we have to do is include the <strong class="source-inline">HealthInterface</strong> class. Make sure you include it before the <strong class="source-inline">.generated.h</strong> <strong class="source-inline">include</strong> statement:<p class="source-code">// Add this include</p><p class="source-code">#include "HealthInterface.h"</p><p class="source-code">#include "DodgeballCharacter.generated.h"</p></li>
<li>Then, replace <a id="_idIndexMarker556"/>the line in the header file that <a id="_idIndexMarker557"/>makes the <strong class="source-inline">DodgeballCharacter</strong> class inherit from the <strong class="source-inline">Character</strong> class with the following line, which will make this class implement <strong class="source-inline">HealthInterface</strong>:<p class="source-code">class ADodgeballCharacter : public ACharacter, public </p><p class="source-code">  IHealthInterface</p></li>
<li>The next thing we have to do is implement the <strong class="source-inline">OnDeath</strong> function in the <strong class="source-inline">DodgeballCharacter</strong> class. To do this, add a declaration for the <strong class="source-inline">OnDeath_Implementation</strong> function that overrides the interface’s C++ signature. This function should be <strong class="source-inline">public</strong>. To override a <strong class="source-inline">virtual</strong> function, you must add the <strong class="source-inline">override</strong> keyword to the end of its declaration:<p class="source-code">virtual void OnDeath_Implementation() override;</p></li>
<li>In this function’s implementation, within the class’s source file, simply quit the game, the same way that is being done in the <strong class="source-inline">HealthComponent</strong> class:<p class="source-code">void ADodgeballCharacter::OnDeath_Implementation()</p><p class="source-code">{</p><p class="source-code">  UKismetSystemLibrary::QuitGame(this,</p><p class="source-code">                                nullptr,</p><p class="source-code">                                EQuitPreference::Quit,</p><p class="source-code">                                true);</p><p class="source-code">}</p></li>
<li>Because we’re now using <strong class="source-inline">KismetSystemLibrary</strong>, we’ll have to include it:<p class="source-code">#include "Kismet/KismetSystemLibrary.h"</p></li>
<li>Now, we must go to our <strong class="source-inline">HealthComponent</strong> class’s source file. Because we’ll no <a id="_idIndexMarker558"/>longer be using <strong class="source-inline">KistemSystemLibrary</strong> and will be using the <strong class="source-inline">HealthInterface</strong> instead, replace <a id="_idIndexMarker559"/>the <strong class="source-inline">include</strong> statement for the first class with an <strong class="source-inline">include</strong> statement for the second one:<p class="source-code">// Replace this line</p><p class="source-code">#include "Kismet/KismetSystemLibrary.h"</p><p class="source-code">// With this line</p><p class="source-code">#include "HealthInterface.h"</p></li>
<li>Then, change the logic that is responsible for quitting the game when Owner runs out of health points. Instead of doing this, we’ll want to check whether Owner implements <strong class="source-inline">HealthInterface</strong> and, if it does, call its implementation of the <strong class="source-inline">OnDeath</strong> function. Remove the existing call to the <strong class="source-inline">QuitGame</strong> function:<p class="source-code">// Remove this</p><p class="source-code">UKismetSystemLibrary::QuitGame(this,</p><p class="source-code">                              nullptr,</p><p class="source-code">                              EQuitPreference::Quit,</p><p class="source-code">                              true);</p></li>
<li>To check whether an object implements a specific interface, we can call that object’s <strong class="source-inline">Implements</strong> function, using the interface’s class as a template parameter. The class of the interface that you should use in this function is the one that is prefixed with <strong class="source-inline">U</strong>:<p class="source-code">if (GetOwner()-&gt;Implements&lt;UHealthInterface&gt;())</p><p class="source-code">{</p><p class="source-code">}</p></li>
<li>Because we’ll be using methods that belong to the <strong class="source-inline">Actor</strong> class, we’ll also need to include it:<p class="source-code">#include "GameFramework/Actor.h"</p></li>
</ol>
<p>If this <strong class="source-inline">if</strong> statement <a id="_idIndexMarker560"/>is true, that means that <a id="_idIndexMarker561"/>our Owner implements <strong class="source-inline">HealthInterface</strong>. In this case, we’ll want to call its implementation of the <strong class="source-inline">OnDeath</strong> function.</p>
<ol>
<li value="13">To do this, call it through the interface’s class (this time, the one that is prefixed with <strong class="source-inline">I</strong>). The function inside the interface that you’ll want to call is <strong class="source-inline">Execute_OnDeath</strong> (note that the function you should call inside the interface will always be its normal name prefixed with <strong class="source-inline">Execute_</strong>). This function must receive at least one parameter, which is the object that the function will be called on and that implements that interface; in this case, Owner:<p class="source-code">if (GetOwner()-&gt;Implements&lt;UHealthInterface&gt;())</p><p class="source-code">{</p><p class="source-code">  IHealthInterface::Execute_OnDeath(GetOwner());</p><p class="source-code">}</p></li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">If your interface’s function receives parameters, you can send them in the function call after the first parameter mentioned in the preceding step. For instance, if our <strong class="source-inline">OnDeath</strong> function received an <strong class="source-inline">int</strong> property as a parameter, you would call it with <strong class="source-inline">IHealthInterface::Execute_OnDeath(GetOwner(), 5)</strong>.</p>
<p class="callout">The first time you try to compile your code after adding a new function to an interface and then calling <strong class="source-inline">Execute_ version</strong>, you may get an <strong class="source-inline">Intellisense</strong> error. You can safely ignore this error.</p>
<p>Once you’ve made all these changes, compile your code and open the editor. When you play the game, try letting the character get hit by three dodgeballs:</p>
<div>
<div class="IMG---Figure" id="_idContainer198">
<img alt="Figure 7.4 – The enemy character throwing dodgeballs at the player character " height="467" src="image/Figure_7.04_B18531.jpg" width="493"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4 – The enemy character throwing dodgeballs at the player character</p>
<p>If the game ends after that, then that means that all our changes worked and the game’s logic remains the same:</p>
<div>
<div class="IMG---Figure" id="_idContainer199">
<img alt="Figure 7.5 – The editor after the player character runs out of health points and the game stops " height="743" src="image/Figure_7.05_B18531.jpg" width="1320"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5 – The editor after the player character runs out of health points and the game stops</p>
<p>And with that, we conclude this exercise. You now know how to use interfaces. The benefit of the change that we just made is that we can now have other actors that lose health, as well as specify what happens when they run out of health points by using the <strong class="source-inline">Health</strong> interface.</p>
<p>Now, we <a id="_idIndexMarker562"/>will complete an activity where we’ll move all of the <a id="_idIndexMarker563"/>logic related to the <strong class="source-inline">LookAtActor</strong> function to its own Actor component and use it to replace the <strong class="source-inline">SightSource</strong> component we created.</p>
<h2 id="_idParaDest-139"><a id="_idTextAnchor166"/>Activity 7.01 – moving the LookAtActor logic to an Actor component</h2>
<p>In this <a id="_idIndexMarker564"/>activity, we’ll be moving all of the logic <a id="_idIndexMarker565"/>related to the <strong class="source-inline">LookAtActor</strong> function, inside <a id="_idIndexMarker566"/>the <strong class="source-inline">EnemyCharacter</strong> class, to its own Actor component (similarly to how we moved the <strong class="source-inline">CanSeeActor</strong> function to a Blueprint Function Library). This way, if we want an actor (that isn’t an <strong class="source-inline">EnemyCharacter</strong>) to look at another actor, we will simply be able to add this component to it.</p>
<p>Follow these steps to complete this activity:</p>
<ol>
<li value="1">Open the editor and create a new C++ class that inherits from <strong class="source-inline">SceneComponent</strong>, called <strong class="source-inline">LookAtActorComponent</strong>.</li>
</ol>
<p>Head to the class’s files, which are open in Visual Studio.</p>
<ol>
<li value="2">Go to its header file and add a declaration for the <strong class="source-inline">LookAtActor</strong> function, which should be <strong class="source-inline">protected</strong>, return a <strong class="source-inline">bool</strong>, and receive no parameters.</li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">While the <strong class="source-inline">LookAtActor</strong> function of <strong class="source-inline">EnemyCharacter</strong> received the <strong class="source-inline">AActor* TargetActor</strong> parameter, this Actor component will have its <strong class="source-inline">TargetActor</strong> as a class property, which is why we won’t need to receive it as a parameter.</p>
<ol>
<li value="3">Add a protected <strong class="source-inline">AActor*</strong> property called <strong class="source-inline">TargetActor</strong>. This property will represent the actor we want to look at.</li>
<li>Add a protected <strong class="source-inline">bool</strong> property called <strong class="source-inline">bCanSeeTarget</strong>, with a default value of <strong class="source-inline">false</strong>, which will indicate whether <strong class="source-inline">TargetActor</strong> can be seen.</li>
<li>Add a declaration for a public <strong class="source-inline">FORCEINLINE</strong> function, as covered in <a href="B18531_06.xhtml#_idTextAnchor134"><em class="italic">Chapter 6</em></a>, <em class="italic">Setting Up Collision Objects</em>, called <strong class="source-inline">SetTarget</strong>, which will return nothing and receive <strong class="source-inline">AActor* NewTarget</strong> as a parameter. The implementation of this function will simply set the <strong class="source-inline">TargetActor</strong> property to the value of the <strong class="source-inline">NewTarget</strong> property.</li>
<li>Add a <a id="_idIndexMarker567"/>declaration for a public <strong class="source-inline">FORCEINLINE</strong> function <a id="_idIndexMarker568"/>called <strong class="source-inline">CanSeeTarget</strong>, which will be <strong class="source-inline">const</strong>, return a <strong class="source-inline">bool</strong>, and receive <a id="_idIndexMarker569"/>no parameters. The implementation of this function will simply return the value of the <strong class="source-inline">bCanSeeTarget</strong> property.</li>
</ol>
<p>Now, go to the class’s source file.</p>
<ol>
<li value="7">In the class’s <strong class="source-inline">TickComponent</strong> function, set the value of the <strong class="source-inline">bCanSeeTarget</strong> property to the return value of the <strong class="source-inline">LookAtActor</strong> function call.</li>
<li>Add an empty implementation of the <strong class="source-inline">LookAtActor</strong> function and copy the <strong class="source-inline">EnemyCharacter</strong> class’s implementation of the <strong class="source-inline">LookAtActor</strong> function into the implementation of <strong class="source-inline">LookAtActorComponent</strong>.</li>
<li>Make the following modifications to the <strong class="source-inline">LookAtActorComponent</strong> class’s implementation of the <strong class="source-inline">LookAtActor</strong> function:<ol><li>Change the first element of the <strong class="source-inline">IgnoreActors</strong> array to the Actor’s component’s Owner.</li><li>Change the second parameter of the <strong class="source-inline">CanSeeActor</strong> function call to this component’s location.</li><li>Change the value of the <strong class="source-inline">Start</strong> property to the location of Owner.</li></ol></li>
</ol>
<p>Finally, replace the call to the <strong class="source-inline">SetActorRotation</strong> function with a call to the <strong class="source-inline">SetActorRotation</strong> function of Owner.</p>
<ol>
<li value="10">Because of <a id="_idIndexMarker570"/>the modifications <a id="_idIndexMarker571"/>we’ve made <a id="_idIndexMarker572"/>to the implementation of the <strong class="source-inline">LookAtActor</strong> function, we’ll need to add some includes to our <strong class="source-inline">LookAtActorComponent</strong> class and remove some includes from our <strong class="source-inline">EnemyCharacter</strong> class. Remove the includes to <strong class="source-inline">KismetMathLibrary</strong> and <strong class="source-inline">DodgeballFunctionLibrary</strong> from the <strong class="source-inline">EnemyCharacter</strong> class and add them to the <strong class="source-inline">LookAtActorComponent</strong> class.</li>
</ol>
<p>We’ll also need to add an include to the <strong class="source-inline">Actor</strong> class since we’ll be accessing several functions belonging to that class.</p>
<p>Now, let’s make some further modifications to our <strong class="source-inline">EnemyCharacter</strong> class:</p>
<ol>
<li value="1">In its header file, remove the declaration of the <strong class="source-inline">LookAtActor</strong> function.</li>
<li>Replace the <strong class="source-inline">SightSource</strong> property with a property of the <strong class="source-inline">UlookAtActorComponent*</strong> type called <strong class="source-inline">LookAtActorComponent</strong>.</li>
<li>In the class’s source file, add an include to the <strong class="source-inline">LookAtActorComponent</strong> class.</li>
<li>Inside the class’s constructor, replace the references to the <strong class="source-inline">SightSource</strong> property with a reference to the <strong class="source-inline">LookAtActorComponent</strong> property. Additionally, the <strong class="source-inline">CreateDefaultSubobject</strong> function’s template parameter should be the <strong class="source-inline">ULookAtActorComponent</strong> class and its parameter should be <strong class="source-inline">“Look At Actor Component”</strong>.</li>
<li>Remove the class’s implementation of the <strong class="source-inline">LookAtActor</strong> function.</li>
<li>In the class’s <strong class="source-inline">Tick</strong> function, remove the line of code where you create the <strong class="source-inline">PlayerCharacter</strong> property, and add that exact line of code to the end of the class’s <strong class="source-inline">BeginPlay</strong> function.</li>
<li>After this line, call the <strong class="source-inline">SetTarget</strong> function of <strong class="source-inline">LookAtActorComponent</strong> and send the <strong class="source-inline">PlayerCharacter</strong> property as a parameter.</li>
<li>Inside the class’s <strong class="source-inline">Tick</strong> function, set the <strong class="source-inline">bCanSeePlayer</strong> property’s value to the return value of the <strong class="source-inline">CanSeeTarget</strong> function call of <strong class="source-inline">LookAtActorComponent</strong>, instead of the return value of the <strong class="source-inline">LookAtActor</strong> function call.</li>
</ol>
<p>Now, there’s only one last step we have to do before this activity is completed. </p>
<ol>
<li value="9">Close the <a id="_idIndexMarker573"/>editor (if you have it opened), compile <a id="_idIndexMarker574"/>your changes <a id="_idIndexMarker575"/>in Visual Studio, open the editor, and open the <strong class="source-inline">BP_EnemyCharacter</strong> Blueprint. Find <strong class="source-inline">LookAtActorComponent</strong> and change its location to <strong class="source-inline">(10, 0, 80)</strong>.</li>
</ol>
<p><strong class="bold">Expected output</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer200">
<img alt="Figure 7.6 – The enemy character looking at the player character remains functional " height="514" src="image/Figure_7.06_B18531.jpg" width="722"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.6 – The enemy character looking at the player character remains functional</p>
<p>And with that, we <a id="_idIndexMarker576"/>conclude our activity. You have <a id="_idIndexMarker577"/>applied your knowledge of <a id="_idIndexMarker578"/>refactoring part of an actor’s logic into an Actor component so that you can reuse it in other parts of your project, or even in other projects of your own.</p>
<p class="callout-heading">Note</p>
<p class="callout">The solution for this activity can be found on <a href="https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions">https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions</a>.</p>
<h1 id="_idParaDest-140"><a id="_idTextAnchor167"/>Summary</h1>
<p>You now know about several utilities that will help you keep your projects more organized and allow you to reuse the things that you make.</p>
<p>You learned how to create a Blueprint Function Library, create Actor components and use them to refactor the existing logic in your project, and create interfaces and call functions from an object that implements a specific interface. Altogether, these new topics will allow you to refactor and reuse all the code that you write in a project in that same project or another project.</p>
<p>In the next chapter, we’ll look at UMG, UE5’s system for creating user interfaces, and learn how to create user interfaces.</p>
</div>
</div></body></html>