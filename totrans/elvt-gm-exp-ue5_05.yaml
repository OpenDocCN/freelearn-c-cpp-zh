- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Query with Line Traces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we learned about how we can reproduce the Third Person
    template project offered to us by the Unreal Engine team in order to understand
    some of the basic concepts of UE5’s workflow and framework.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will start creating another game from scratch. In this
    game, the player will control a character from a top-down point of view (similar
    to games such as Metal Gear Solid 1, 2, and 3). A top-down perspective implies
    that the player controls a character that is seen as if it was being looked down
    upon, usually with the camera rotation being fixed (the camera doesn’t rotate).
    In our game, the player character must go from point A to point B without being
    hit by dodgeballs, which are being thrown at the player by the enemies that are
    spread throughout the level. The levels in this game will be maze-like in nature,
    and the player will have multiple paths to choose from, all of which will have
    enemies trying to throw dodgeballs at them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to collision
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding and visualizing Line Traces (Single and Multi)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sweep Traces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trace Channels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trace Responses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the first section, we begin by getting to know what collision is in the world
    of video games.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The project for this chapter can be found in the Chapter05 folder of the code
    bundle for this book, which can be downloaded here: [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition).'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to collision
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A collision is basically a point at which two objects come into contact with
    each other (for example, two objects colliding, an object hitting a character,
    a character walking into a wall, and so on). Most game development tools have
    their own set of features that allow for collision and physics to exist inside
    the game. This set of features is called a physics engine, which is responsible
    for everything related to collisions. It is responsible for executing Line Traces,
    checking whether two objects are overlapping each other, blocking each other’s
    movement, or bouncing off of a wall, and much more. When we ask the game to execute
    or notify us of these collision events, the game is essentially asking the physics
    engine to execute it and then show us the results of these collision events.
  prefs: []
  type: TYPE_NORMAL
- en: In the **Dodgeball** game you will be building, examples of where collision
    needs to be taken into account include checking whether enemies are able to see
    the player (which will be achieved using a Line Trace, which is covered in this
    chapter), simulating physics on an object that will behave just like a dodgeball,
    checking whether anything is blocking the player character’s movement, and much
    more.
  prefs: []
  type: TYPE_NORMAL
- en: Collision is one of the most important aspects of most games, so understanding
    it is crucial in order to get started with game development.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start building our collision-based features, we will first need to
    set up our new **Dodgeball** project in order to support the game mechanics we
    will be implementing. This process starts with the steps described in the following
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up your project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s begin by creating our Unreal Engine project:'
  prefs: []
  type: TYPE_NORMAL
- en: Launch UE5\. Select the **Games** project category, then click on **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Third Person template**, then click on **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure the first option is set to **C++** and not **Blueprint**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the location of the project according to your preference and name your
    project `Dodgeball`, then click on **Create Project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When the project is done being generated, you should see the following on your
    screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Dodgeball project loaded up](img/Figure_5.01_B18531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Dodgeball project loaded up
  prefs: []
  type: TYPE_NORMAL
- en: After the code has been generated and the project opens up, enable the Enhanced
    Input plugin, just like we did in steps 1-3 of the *Understanding input actions
    and contexts* section in [*Chapter 4*](B18531_04.xhtml#_idTextAnchor099)*, Getting
    Started with Player Input*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After that, close the UE5 editor and open the files of the generated third-person
    `Character` class, `DodgeballCharacter`, in Visual Studio, as shown in the following
    figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Files generated in Visual Studio ](img/Figure_5.02_B18531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Files generated in Visual Studio
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, your project is going to have a top-down perspective.
    Given that we’re starting this project from the Third Person template, we’ll have
    to change a few things before we turn this into a top-down game. This will mainly
    involve changing some lines of code in the existing `Character` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.01: Converting DodgeballCharacter to a top-down perspective'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, you’ll be performing the necessary changes to your generated
    `DodgeballCharacter` class. Remember, it currently features a third-person perspective
    where the rotation of the character is dictated by the player’s input (*namely
    the mouse or right analog stick*).
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you will change this to a top-down perspective, which remains
    the same regardless of the player’s input and the camera always follows the character
    from above.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Head to the `DodgeballCharacter` class’s constructor and update the `CameraBoom`
    properties, as mentioned in the following steps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change `TargetArmLength`, which is a property of `CameraBoom`, to `900.0f`
    in order to add some distance between the camera and the player as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add a line that sets the relative pitch to `-70`º using the `SetRelativeRotation`
    function so that the camera looks down at the player. The `FRotator` constructor’s
    parameters are `pitch`, `yaw`, and `roll`, respectively, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change `bUsePawnControlRotation` to `false` so that the camera’s rotation isn’t
    changed by the player’s movement input as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a line that sets `bInheritPitch`, `bInheritYaw`, and `bInheritRoll` to
    `false` so that the camera’s rotation isn’t changed by the character’s orientation
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After we’ve made these modifications, we’re going to remove the character’s
    ability to jump (we don’t want the player to escape from the dodgeballs that easily)
    and to rotate the camera from the player’s rotation input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the `SetupPlayerInputComponent` function in the `DodgeballCharacter`’s
    source file and remove the following lines of code in order to remove the ability
    to jump:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add the following lines in order to remove the player’s rotation input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This step is optional, but in order to keep your code clean, you should remove
    the declarations and implementations of the `TurnAtRate` and `LookUpAtRate` functions.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we’ll have to adapt this project to use the Enhanced Input system
    instead of the Legacy Input system. Go to this class’s header file and add a property
    for the Character’s Input Context as well as the Move Input Action, just like
    we did in steps 2 and 3 of *Exercise 4.02*. Add a declaration for the `Move` function,
    just like we did in step 14 of *Exercise 4.02*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the logic for adding the Character’s Input Context as well as binding the
    Move Input Action, just like we did in steps 4-10 of *Exercise 4.02*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the implementation to the `Move` function, just like we did in steps 14-18
    of *Exercise 4.02*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the Enhanced Input dependency, just like we did in steps 19 and 20 of *Exercise
    4.02*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, after you’ve made these changes, run your project from Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the editor has loaded, go to `EnhancedPlayerInput` and the `EnhancedInputComponent`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After this, create the `IA_Move` Input Action asset and set it up just like
    we did in steps 1-3 of *Exercise 4.01*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, create the `IC_Character` Input Context asset and add a mapping for the
    `IA_Move` Input Action, just like we did in steps 4-14 of *Exercise 4.01*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last thing you need to do to complete the Enhanced Input setup is to open
    the `IC_Character` and `IA_Move` properties, just like we did in step 22 of *Exercise
    4.01*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After that, play the level. The camera’s perspective should look like the following
    and should not rotate based on the player’s input or the character’s rotation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Locked camera rotation to a top-down perspective ](img/Figure_5.03_B18531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – Locked camera rotation to a top-down perspective
  prefs: []
  type: TYPE_NORMAL
- en: That concludes the first exercise of this chapter and the first step of your
    new project, **Dodgeball**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you will be creating the `EnemyCharacter` class. This character will
    be the enemy that throws dodgeballs at the player while the player is in view.
    But the question that arises here is this: how will the enemy know whether it
    can see the player character or not?'
  prefs: []
  type: TYPE_NORMAL
- en: That will be achieved with the power of **Line Traces** (also known as **Raycasts**
    or **Raytraces**), which you will be looking at in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Line Traces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important features of any game development tool is its ability
    to execute Line Traces. These are available through the physics engine that the
    tool is using.
  prefs: []
  type: TYPE_NORMAL
- en: Line Traces are a way of asking the game to tell you whether anything stands
    between two points in the game world. The game will *shoot a ray* between those
    two points, specified by you, and return the objects that were hit (if any), where
    they were hit, at what angle, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 5.4*, you can see a representation of a Line Trace where we assume
    object **1** is ignored and object **2** is detected,due to their Trace Channel
    properties (further explained in the following paragraphs):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – A Line Trace being executed from point A to point B ](img/Figure_5.04_B18531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – A Line Trace being executed from point A to point B
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5.4* is explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The dashed line represents the Line Trace before it hits an object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The arrows represent the direction of the Line Trace.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dotted line represents the Line Trace after it hits an object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The striped circle represents the Line Trace’s impact point.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The big squares represent two objects that are in the path of the Line Trace
    (objects **1** and **2**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We notice that only object **2** was hit by the Line Trace and not object **1**,
    even though it is also in the path of the Line Trace. This is due to assumptions
    made about object **1**’s Trace Channel properties, which are discussed later
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Line Traces are used for many game features, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Checking whether a weapon hits an object when it fires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Highlighting an item that the player can interact with when the character looks
    at it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rotating the camera around the player character automatically as it goes around
    corners
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A common and important feature of Line Traces is **Trace Channels**. When you
    execute a Line Trace, you may want to check only specific types of objects, which
    is what Trace Channels are for. They allow you to specify filters to be used when
    executing a Line Trace so that it doesn’t get blocked by unwanted objects. Check
    the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: You may want to execute a Line Trace only to check for objects that are visible.
    These objects would block the `Visibility` Trace Channel. For instance, invisible
    walls, which are invisible pieces of geometry used in games to block the player’s
    movement, would not be visible and therefore would not block the `Visibility`
    Trace Channel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may want to execute a Line Trace only to check for objects that can be interacted
    with. These objects would block the `Interaction` Trace Channel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may want to execute a Line Trace only to check for pawns that can move around
    the game world. These objects would block the `Pawn` Trace Channel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can specify how different objects react to different Trace Channels so that
    only some objects block specific Trace Channels and others ignore them. In our
    case, we want to know whether anything stands between the enemy and the player
    character so that we know whether the enemy can see the player. We will be using
    Line Traces for this purpose by checking for anything that blocks the enemy’s
    line of sight of the player character, using a `Tick` event.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will be creating the `EnemyCharacter` class using C++.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the EnemyCharacter C++ class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our `EnemyCharacter` class will constantly be looking at the player character
    if they’re within view. This is the same class that will later throw dodgeballs
    at the player; however, we’ll leave that for the following chapter. In this chapter,
    we will be focusing on the logic that allows our enemy character to look at the
    player.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s get started as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the **Content Browser** inside the editor and select **New C++
    Class**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the `Character` class as the parent class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new class `EnemyCharacter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After you’ve created the class and opened its files in Visual Studio, let’s
    add the `LookAtActor` function declaration in its `header` file. This function
    should be `public` and not return anything, only receiving the `AActor* TargetActor`
    parameter, which will be the Actor it should be facing. Have a look at the following
    code snippet, which shows this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Even though we only want the enemy to look at the player character, in order
    to execute good software development practices, we’re going to abstract this function
    a bit more and allow `EnemyCharacter` to look at any Actor. This is because the
    logic that allows an Actor to look at another Actor or the player character will
    be exactly the same.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, you should not create unnecessary restrictions when writing code.
    If you can write similar code and simultaneously allow more possibilities, you
    should do so if that doesn’t overcomplicate the logic of your program.
  prefs: []
  type: TYPE_NORMAL
- en: Moving on ahead, if `EnemyCharacter` can’t see the `Target` `Actor`, it shouldn’t
    be looking at it. In order to check whether the enemy can see the Actor, it should
    be looking at the `LookAtActor` function that will call another function, which
    is the `CanSeeActor` function. This is what you’ll be doing in the following exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.02: Creating the CanSeeActor function that executes Line Traces'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will create the `CanSeeActor` function, which will return
    whether the enemy character can see the given Actor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the declaration for a `public` `CanSeeActor` function in the header
    file of the `EnemyCharacter` class; it will return `bool` and receive a `const
    Actor* TargetActor` parameter, which is the Actor we want to look at. This function
    will be a `const` function, because it doesn’t change any of the class’s attributes,
    and the parameter will also be `const` because we won’t need to modify any of
    its properties, we’ll only need to access them, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, let’s get to the fun part, which is executing the Line Trace.
  prefs: []
  type: TYPE_NORMAL
- en: In order to call functions related to line tracing, we’ll have to fetch the
    enemy’s current world with the `GetWorld` function. However, we haven’t included
    the `World` class in this file, so let’s do so in the following step.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `GetWorld` function is accessible to any Actor and will return the `World`
    object that the Actor belongs to. Remember, the world is necessary in order to
    execute the Line Trace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `EnemyCharacter` source file and find the following code line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following line right after the preceding line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create the implementation of the `CanSeeActor` function in the `EnemyCharacter`
    source file where you’ll start by checking whether our `TargetActor` is `nullptr`.
    If it is, then we return `false`, given that we have no valid Actor to check our
    sight o,f as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, before we add our `Line Trace` function call, we need to set up some necessary
    parameters; we will be implementing these in the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the preceding `if` statement, create a variable to store all of the necessary
    data relative to the results of the Line Trace. Unreal Engine already has a built-in
    type for this called the `FHitResult` type, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is the variable we will send to our Line Trace function, which will populate
    it with the relevant info of the executed Line Trace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create two `FVector` variables for the `Start` and `End` locations of our Line
    Trace and set them to our enemy’s current location and our target’s current location,
    respectively, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, set the Trace Channel we wish to compare against. In our case, we want
    to have a `Visibility` Trace Channel specifically designated to indicate whether
    an object blocks another object’s view. Luckily for us, such a Trace Channel already
    exists in UE5, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `ECollisionChannel` `enum` represents all of the possible Trace Channels
    available to compare against. We will be using the `ECC_Visibility` value, which
    represents the `Visibility` Trace Channel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve set up all our necessary parameters, we can finally call the
    `LineTrace` function, `LineTraceSingleByChannel`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This function will consider the parameters we send it, execute the Line Trace,
    and return its results by modifying our `Hit` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Before we continue, there are still a couple more things we need to consider.
  prefs: []
  type: TYPE_NORMAL
- en: If the Line Trace starts from within our enemy character, which is what will
    happen in our case, that means it’s very likely that the Line Trace will simply
    hit our enemy character immediately and just stop there because our character
    might block the `Visibility` Trace Channel. In order to fix that, we need to tell
    the Line Trace to ignore it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the built-in `FCollisionQueryParams` type, which allows us to give even
    more options to our Line Trace, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, update the `Line Trace` to ignore our enemy by adding itself to the list
    of Actors to ignore, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We should also add our target to our list of Actors to ignore because we don’t
    want to know whether it blocks the `EnemySight` channel; we simply want to know
    whether something between the enemy and the player character blocks that channel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `Target Actor` to the list of Actors to be ignored, as shown in the
    following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, send our `FCollisionQueryParams` to the Line Trace by adding it as the
    last parameter of the `LineTraceSingleByChannel` function as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finalize our `CanSeeActor` function by returning whether the Line Trace hits
    anything or not. We can do that by accessing our `Hit` variable and checking whether
    there was a blocking hit, using the `bBlockingHit` property. If there was a blocking
    hit, that means we can’t see our `TargetActor`. This can be achieved with the
    following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Although we won’t need any more information from the `Hit` result other than
    whether there was a blocking hit, the `Hit` variable can give us much more information
    on the Line Trace, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Information on the Actor that was hit by the Line Trace (`nullptr` if no Actor
    was hit) by accessing the `Hit.GetActor()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Information on the Actor component that was hit by the Line Trace (`nullptr`
    if no Actor component was hit) by accessing the `Hit.GetComponent()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Information on the location of the hit by accessing the `Hit.Location` variable.
  prefs: []
  type: TYPE_NORMAL
- en: The distance of the hit can be found by accessing the `Hit.Distance` variable.
  prefs: []
  type: TYPE_NORMAL
- en: The angle at which the Line Trace hit the object, which can be found by accessing
    the `Hit.ImpactNormal` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, our `CanSeeActor` function is complete. We now know how to execute
    a Line Trace and we can use it for our enemy’s logic.
  prefs: []
  type: TYPE_NORMAL
- en: By completing this exercise, we have finished the `CanSeeActor` function; we
    can now get back to the `LookAtActor` function. However, there is something we
    should look at first, which is visualizing our Line Trace.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing the Line Trace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When creating new logic that makes use of Line Traces, it is very useful to
    actually visualize the Line Trace while it’s being executed, which is something
    that the Line Trace function doesn’t allow you to do. In order to do that, we
    must use a set of helper debug functions that can draw objects dynamically at
    runtime, such as lines, cubes, spheres, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s then add a visualization of our Line Trace. The first thing we must do
    in order to use the debug functions is to add the following `include` line of
    code under our last `include` line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We will want to call the `DrawDebugLine` function in order to visualize the
    Line Trace, which needs the following inputs (that are very similar to the ones
    received by the Line Trace function):'
  prefs: []
  type: TYPE_NORMAL
- en: The current `World`, which we will supply with the `GetWorld` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Start` and `End` points of the line, which will be the same as the `LineTraceSingleByChannel`
    function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The desired color of the line in the game, which can be set to `Red`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, we can add the `DrawDebugLine` function call under our Line Trace function
    call, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This will allow you to visualize the Line Trace as it is being executed, which
    is very useful.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you feel the need for it, you can also specify more of the visual Line Trace’s
    properties, such as its lifetime and thickness.
  prefs: []
  type: TYPE_NORMAL
- en: There are many `DrawDebug` functions available that will draw cubes, spheres,
    cones, donuts, and even custom meshes.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we can both execute and visualize our Line Trace, let’s use the `CanSeeActor`
    function, which we created in the last exercise, inside the `LookAtActor` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.03: Creating the LookAtActor function'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will be creating the definition of our `LookAtActor` function,
    which will change the enemy’s rotation so that it faces the given Actor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the `LookAtActor` function definition in the `EnemyCharacter` source
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start by checking whether our `TargetActor` is `nullptr` and returns nothing
    immediately if it is (because it’s not valid), as shown in the following code
    snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we want to check whether we can see our `Target Actor`, using our `CanSeeActor`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If this `if` statement is `true`, that means we can see the Actor, and we will
    set our rotation in such a way that we are facing that Actor. Luckily for us,
    there’s already a function within UE5 that allows us to do that: the `FindLookAtRotation`
    function. This function will receive as input two points in the level, point A
    (the `Start` point) and point B (the `End` point), and return the rotation that
    the object at the start point must have in order to face the object at the end
    point. Perform the following steps in order to use this function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Include `KismetMathLibrary` as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `FindLookAtRotation` function must receive a `Start` and `End` points,
    which will be our enemy’s location and our Target Actor’s location, respectively,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, set your enemy character’s rotation to the same value as our `LookAtRotation`,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: And that’s it for the `LookAtActor` function.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the last step is to call the `LookAtActor` function inside the `Tick` event
    and send the player character as the `TargetActor`, as in the Actor that we want
    to look at.
  prefs: []
  type: TYPE_NORMAL
- en: 'For us to fetch the character that is currently being controlled by the player,
    we use the `GameplayStatics` object. As with other UE5 objects, we must first
    include them as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, head to your `Tick` function’s body and call the `GetPlayerCharacter`
    function from `GameplayStatics`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This function receives the following as input:'
  prefs: []
  type: TYPE_NORMAL
- en: A `World` context object, which is, essentially, an object that belongs to our
    current world and is used to let the function know which `World` object to access.
    This `World` context object can simply be the `this` pointer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A player index, which, given that our game is supposed to be a single-player
    game, we can safely assume to be `0` (the first player).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, call the `LookAtActor` function, sending the player character that we
    just fetched, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The last step of this exercise is to compile your changes in Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that you’ve completed this exercise, your `EnemyCharacter` class has all
    of the necessary logic to face the player character, if it’s within view, and
    we can start creating the `EnemyCharacter` Blueprint Class.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the EnemyCharacter Blueprint Class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have finished the logic for our `EnemyCharacter` C++ class, we
    must create our Blueprint Class that derives from it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Open our project in the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the `Blueprints` folder inside the `ThirdPersonCPP` folder in the `Content
    Browser`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click and select the option to create a new Blueprint Class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the `EnemyCharacter` C++ class, and select it as the Parent Class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the Blueprint Class `BP_EnemyCharacter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Blueprint Class, select the `SKM_Quinn_Simple` and its `ABP_Quinn`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the `-90º` (on the *z-axis*) and its position on the *z-axis* to `-83`
    units.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After you’ve set up the Blueprint Class, its mesh setup should look very similar
    to that of our **DodgeballCharacter** Blueprint Class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag an instance of the `BP_EnemyCharacter` class to your level in a location
    near an object that can block its line of sight, such as following location (the
    selected character is `EnemyCharacter`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Dragging the BP_EnemyCharacter class into the level ](img/Figure_5.05_B18531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – Dragging the BP_EnemyCharacter class into the level
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can finally play the game and verify that our enemy does look at our
    player character whenever it’s within view, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – The enemy character with a clear view of the player using a
    Line Trace ](img/Figure_5.06_B18531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – The enemy character with a clear view of the player using a Line
    Trace
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also see that the enemy stops seeing the player whenever it’s not within
    view, as shown in *Figure 5.7*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.7 – The enemy losing sight of the player ](img/Figure_5.07_B18531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – The enemy losing sight of the player
  prefs: []
  type: TYPE_NORMAL
- en: And that concludes our `EnemyCharacter`’s logic. In the following section, we
    will be looking at Sweep Traces.
  prefs: []
  type: TYPE_NORMAL
- en: Sweep Traces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we continue with our project, it is important to know about a variant
    of the Line Trace, which is the **Sweep Trace**. Although we won’t be using these
    in our project, it is important to know about them and how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: While the Line Trace basically *shoots a ray* between two points, the Sweep
    Trace will simulate *throwing an object* between two points in a straight line.
    The object that is being *thrown* is simulated (it doesn’t actually exist in the
    game) and can have various shapes. In the Sweep Trace, the `Hit` location will
    be the first point at which the virtual object (which we will call **shape**)
    hits another object if it were thrown from the start point to the end point. The
    shapes of the Sweep Trace can be either a box, a sphere, or a capsule.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a representation of a Sweep Trace from point A to point B,
    where we assume that object `1` is ignored due to its Trace Channel properties,
    using a box shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – Representation of a Sweep Trace ](img/Figure_5.08_B18531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – Representation of a Sweep Trace
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 5.8*, we notice the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A Sweep Trace, using a box shape, being executed from point A to point B.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dashed boxes represent the Sweep Trace before it hits an object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dotted boxes represent the Sweep Trace after it hits an object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The striped circle represents the Sweep Trace’s impact point with object **2**,
    which is the point at which the Sweep Trace box shape’s surface and object **2**’s
    surface collide with each other.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The big squares represent two objects that are in the path of the Line Sweep
    Trace (objects **1** and **2**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object **1** is ignored in the Sweep Trace due to assumptions based on its Trace
    Channel properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sweep Traces are more useful than regular Line Traces in a few situations. Let’s
    take the example of our enemy character, which can throw dodgeballs. If we wanted
    to add a way for the player to constantly visualize where the next dodgeball that
    the enemy throws will land, that could be better achieved with a Sweep Trace.
    We would do a Sweep Trace with the shape of our dodgeball (a sphere) toward our
    player, check the impact point, and show a sphere on that impact point, which
    would be visible to the player. If the Sweep Trace hits a wall or a corner somewhere,
    the player would know that if the enemy were to throw a dodgeball at that moment,
    that’s where it would hit first. You could use a simple Line Trace for the same
    purpose, but the setup would have to be rather complex in order to achieve the
    same quality of results, which is why Sweep Traces are a better solution in this
    case.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now take a quick look at how we can do a Sweep Trace in code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.04: Executing a Sweep Trace'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will implement a Sweep Trace in code. Although we won’t
    be using it for our project, by performing this exercise you will become familiar
    with such an operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the end of the `CanSeeActor` function created in the preceding sections
    and perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The function responsible for the Sweep Trace is `SweepSingleByChannel`, which
    is available within UE5 and requires the following parameters as inputs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'An `FHitResult` type to store the results of the sweep (we already have one
    of these, so there’s no need to create another variable of this type) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`Start` and `End` points of the sweep (we already have both of these, so there’s
    no need to create another variable of this type) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the intended rotation of the shape, which is in the form of an `FQuat`
    type (representing a quaternion). In this case, it’s set to a rotation of `0`
    on all axes, by accessing the `FQuat`’s `Identity` property as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, use the intended Trace Channel to compare it against (we already have
    one of these, so there’s no need to create another variable of this type) as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, use the shape of a box for the Sweep Trace by calling the `FcollisionShape`
    `MakeBox` function and supplying it with the radius (on all three axes) of the
    box shape we want. This is shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, call the `SweepSingleByChannel` function as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With these steps completed, we finish our exercise on Sweep Traces. Given that
    we won’t be using Sweep Traces in our project, you should comment out the `SweepSingleByChannel`
    function so that our `Hit` variable doesn’t get modified and lose the results
    from our Line Trace.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve concluded the section on Sweep Traces, let’s get back to our
    **Dodgeball** project and learn how to change an object’s response to a Trace
    Channel.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the Visibility Trace Response
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our current setup, every object that is visible blocks the `Visibility`
    Trace Channel; however, what if we wanted to change whether an object blocks that
    channel completely? In order to do this, we must change a component’s response
    to that channel. Have a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We select the cube that we’ve been using to block the enemy’s sight in our
    level as shown in *Figure 5.9*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.9 – Default spawn of the character ](img/Figure_5.09_B18531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.9 – Default spawn of the character
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you go to the **Collision** section of this object’s **Details Panel**
    (its default place in the **Editor**’s interface) as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.10 – Collision tab in the Details Panel in Unreal Engine ](img/Figure_5.10_B18531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.10 – Collision tab in the Details Panel in Unreal Engine
  prefs: []
  type: TYPE_NORMAL
- en: Here, you’ll find several collision-related options. The one we want to pay
    attention to right now is the **Collision Presets** option. Its current value
    is **Default**; however, we want to change it according to our own preferences,
    so we will click on the drop-down box and change its value to **Custom**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you do this, you’ll notice a whole group of new options pop up as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.11 – Collision Presets set to Custom ](img/Figure_5.11_B18531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.11 – Collision Presets set to Custom
  prefs: []
  type: TYPE_NORMAL
- en: This group of options allows you to specify how this object responds to Line
    Traces and object collision, and the type of collision object it is.
  prefs: []
  type: TYPE_NORMAL
- en: The option you should be paying attention to is **Visibility**. You’ll notice
    it’s set to **Block**, but you can also set it to **Overlap** and **Ignore**.
  prefs: []
  type: TYPE_NORMAL
- en: Right now, the cube is blocking the **Visibility** channel, which is why our
    enemy can’t see the character when it’s behind this cube. However, if we change
    the object’s response to the **Visibility** channel to either **Overlap** or **Ignore**,
    the object will no longer block Line Traces that check for **Visibility** (which
    is the case for the Line Trace you’ve just written in C++).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change the cube’s response to the **Visibility** channel to **Ignore**,
    and then play the game. You’ll notice that the enemy is still looking toward the
    player character, even when it’s behind the cube:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.12 – The enemy character looking through an object at the player
    ](img/Figure_5.12_B18531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.12 – The enemy character looking through an object at the player
  prefs: []
  type: TYPE_NORMAL
- en: This is because the cube no longer blocks the **Visibility** channel, and so
    the Line Trace the enemy is executing no longer hits anything when trying to reach
    the player character.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve seen how we can change an object’s response to a specific Trace
    Channel, let’s change the cube’s response to the **Visibility** channel back to
    **Block**.
  prefs: []
  type: TYPE_NORMAL
- en: However, there’s one thing that’s worth mentioning. If we were to set the cube’s
    response to the **Visibility** channel to **Overlap** instead of **Ignore**, the
    result would be the same. But why is that, and what is the purpose of having these
    two responses? In order to explain that, we’ll look at Multi Line Traces.
  prefs: []
  type: TYPE_NORMAL
- en: Multi Line Traces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When using the `CanSeeActor` function in *Exercise 5.02*, *Creating the CanSeeActor
    function that executes Line Traces*, you might have wondered to yourself about
    the name of the Line Trace function we used, `LineTraceSingleByChannel`, specifically
    about why it used the word *Single*. The reason for that is that you can also
    execute `LineTraceMultiByChannel`.
  prefs: []
  type: TYPE_NORMAL
- en: But how do these two Line Traces differ?
  prefs: []
  type: TYPE_NORMAL
- en: While the Single Line Trace will stop checking for objects that block it after
    it hits an object and tell us that was the object that it hit, the Multi Line
    Trace can check for any objects that are hit by the same Line Trace.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Single Line Trace will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Ignore the objects that have their response set to either `Ignore` or `Overlap`
    on the Trace Channel being used by the Line Trace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stop when it finds an object that has its response set to `Block`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, instead of ignoring objects that have their response set to `Overlap`,
    the Multi Line Trace will add them as objects that were found during the Line
    Trace and only stop when it finds an object that blocks the desired Trace Channel
    (*or when it reaches the end point*). In the next figure, you’ll find an illustration
    of a Multi Line Trace being executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13 – A Multi Line Trace being executed from point A to point B ](img/Figure_5.13_B18531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.13 – A Multi Line Trace being executed from point A to point B
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 5.13*, we notice the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The dashed line represents the Line Trace before it hits an object that blocks
    it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dotted line represents the Line Trace after it hits an object that blocks
    it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The striped circles represent the Line Trace’s impact points, and only the last
    one of which is a blocking hit in this case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The only difference between the `LineTraceSingleByChannel` and the `LineTraceMultiByChannel`
    functions, when it comes to their inputs, is that the latter must receive a `TArray<FHitResult>`
    input instead of a single `FHitResult`. All other inputs are the same.
  prefs: []
  type: TYPE_NORMAL
- en: Multi Line Traces are very useful when simulating the behavior of bullets with
    strong penetration that can go through several objects before stopping completely.
    Keep in mind that you can also do Multi Sweep Traces by calling the `SweepMultiByChannel`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Another thing about the `LineTraceSingleByChannel` function that you might be
    wondering about is the `ByChannel` portion. This distinction has to do with using
    a Trace Channel, as opposed to the alternative, which is an Object Type. You can
    do a Line Trace that uses Object Types instead of Trace Channels by calling the
    `LineTraceSingleByObjectType` function, also available from the `World` object.
    Object Types are related to topics we will be covering in the following chapter,
    so we won’t be going into detail on this function just yet.
  prefs: []
  type: TYPE_NORMAL
- en: The Camera Trace Channel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When changing our cube’s response to the `Visibility` Trace Channel, you may
    have noticed the other out-of-the-box Trace Channel: **Camera**.'
  prefs: []
  type: TYPE_NORMAL
- en: This channel is used to specify whether an object blocks the line of sight between
    the camera’s spring arm and the character it’s associated with. In order to see
    this in action, we can drag an object to our level and place it in such a way
    that it will stay between the camera and our player character.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: We duplicate the `floor` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can easily duplicate an object in the level by holding the *Alt* key and
    dragging one of the *Move Tool*’s arrows in any direction.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14 – Floor object being selected ](img/Figure_5.14_B18531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.14 – Floor object being selected
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we change its **Transform** values as shown in the following figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.15 – Updating the Transform values ](img/Figure_5.15_B18531_B18531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.15 – Updating the Transform values
  prefs: []
  type: TYPE_NORMAL
- en: 'Now when you play your game, you’ll notice that when the character goes under
    our duplicated `floor` object, you won’t lose sight of the player character, but;
    the spring arm will cause the camera to move down until you can see the character,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.16 – Changes in the camera angle ](img/Figure_5.16_B18531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.16 – Changes in the camera angle
  prefs: []
  type: TYPE_NORMAL
- en: In order to see how the spring arm’s behavior differs when an object isn’t blocking
    the `Camera` Trace Channel, change our duplicated floor’s response to the `Camera`
    channel to `Ignore` and play the level again. What will happen is that when our
    character goes under the duplicated floor, we will lose sight of the character.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After you’ve done these steps, you can see that the `Camera` channel is used
    to specify whether an object will cause the spring arm to move the camera closer
    to the player when it intersects that object.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to use the existing Trace Channels, what if we wanted to
    create our own Trace Channels?
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.05: Creating a custom EnemySight Trace Channel'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we’ve discussed before, UE5 comes with two out-of-the-box Trace Channels:
    `Visibility` and `Camera`. The first one is a general-use channel that we can
    use to specify which objects block the line of sight of an object, whereas the
    second one allows us to specify whether an object blocks the line of sight between
    the camera’s spring arm and the character it’s associated with.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But how can we create our own Trace Channels? That’s what we’ll be looking
    into in this exercise. We will create a new `EnemySight` Trace Channel and use
    it to check whether the enemy can see the player character, instead of the built-in
    `Visibility` channel, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Open **Project Settings** by pressing the **Edit** button at the top-left corner
    of the editor and go to the **Collision** section. There you’ll find the **Trace
    Channels** section. It’s currently empty because we haven’t yet created any of
    our own Trace Channels.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `EnemySight` and set its default response to `Block`, because we
    want most objects to do exactly that.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After you’ve created the new Trace Channel, we must go back to our `EnemyCharacter`
    C++ class and change the trace we’re comparing against in our Line Trace, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Given that we are no longer using the `Visibility` channel, we must reference
    our new channel. But how do we do that?
  prefs: []
  type: TYPE_NORMAL
- en: In your project’s directory, you’ll find the `Config` folder. This folder contains
    several `ini` files related to your project, such as `DefaultGame.ini`, `DefaultEditor.ini`,
    `DefaultEngine.ini`, and so on. Each of these contains several properties that
    will be initialized when the project is loaded. The properties are set by name-value
    pairs (`property=value`), and you can change their values as desired.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we created our `EnemySight` channel, the project’s `DefaultEngine.ini`
    file was updated with our new Trace Channel. Somewhere in that file, you’ll find
    the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code line can be found highlighted at the following link: [https://packt.live/3eFpz5r](https://packt.live/3eFpz5r).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding line says that there is a custom Trace Channel called `EnemySight`
    that has a default response of `Block` and, most importantly, is available in
    C++ using the `ECC_GameTraceChannel1` value of the collision `enum` we mentioned
    earlier, `ECollisionChannel`. This is the channel we’ll be referencing in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Verify that our enemy’s behavior remains the same after all of the changes we’ve
    made. This means that the enemy must still face the player character, as long
    as it’s within view of said enemy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By completing this exercise, we now know how to make our own Trace Channels
    for any desired purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Going back to our enemy character, there are still ways that we can improve
    its logic. Right now, when we fetch our enemy’s location as the start point of
    the Line Trace, that point is somewhere around the enemy’s hip, because that’s
    where the origin of the Actor is. However, that’s not usually where people’s eyes
    are, and it wouldn’t make much sense to have a humanoid character looking from
    its hip instead of its head.
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s change that and have our enemy character check whether it sees the
    player character starting from its eyes, instead of its hip.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 5.01: Creating the SightSource property'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, we will be improving our enemy’s logic to determine whether
    it should look at the player. Currently, the Line Trace that’s being done to determine
    that is being *shot* from around our character’s hips, (`0,0,0`) in our `BP_EnemyCharacter`
    blueprint. We want this to make a bit more sense, so we’ll make it so that the
    Line Trace starts somewhere close to our enemy’s eyes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Declare a new `SceneComponent` in our `EnemyCharacter` C++ class called `SightSource`.
    Make sure to declare this as a `UPROPERTY` with the `VisibleAnywhere`, `BlueprintReadOnly`,
    `Category = LookAt`, and `meta = (AllowPrivateAccess = “true”)` tags.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create this component in the `EnemyCharacter` constructor by using the `CreateDefaultSubobject`
    function, and attach it to `RootComponent`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the start location of the Line Trace in the `CanSeeActor` function to
    the `SightSource` component’s location, instead of the Actor’s location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `BP_EnemyCharacter` Blueprint Class and change the `SightSource` component’s
    location to the location of the enemy’s head, `10, 0, 80`, as was done in the
    *Creating the EnemyCharacter Blueprint Class* section to the `SkeletalMeshComponent`
    property of `BP_EnemyCharacter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Hint**: This can be achieved from the **Transform** tab in the **Editor panel**
    as shown in *Figure 5.17*.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.17 – Updating the SightSource component’s values ](img/Figure_5.17_B18531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.17 – Updating the SightSource component’s values
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.18 – The expected output showing the updated Line Trace from the
    hip to the eye ](img/Figure_5.18_B18531.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.18 – The expected output showing the updated Line Trace from the hip
    to the eye
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution for this activity can be found on GitHub here: [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions).'
  prefs: []
  type: TYPE_NORMAL
- en: By completing this activity, we have updated our `SightSource` property for
    our `EnemyCharacter`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By completing this chapter, you have added a new tool to your belt: Line Traces.
    You now know how to execute Line Traces and Sweep Traces, both Single and Multi,
    how to change an object’s response to a specific Trace Channel, and how to create
    your own Trace Channels.'
  prefs: []
  type: TYPE_NORMAL
- en: You will quickly realize in the following chapters that these are essential
    skills when it comes to game development, and you will make good use of them on
    your future projects.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to use Line Traces, we’re ready for the next step, which
    is Object Collision. In the following chapter, you will learn how to set up collisions
    between objects and how to use collision events to create your own game logic.
    You will create the Dodgeball Actor, which will be affected by real-time physics
    simulation, the Wall Actors, which will block both the characters’ movements and
    the dodgeball, and the Actor responsible for ending the game when the player comes
    into contact with it.
  prefs: []
  type: TYPE_NORMAL
