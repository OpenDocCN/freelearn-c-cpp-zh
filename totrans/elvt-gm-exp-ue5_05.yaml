- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Query with Line Traces
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用线迹查询
- en: In previous chapters, we learned about how we can reproduce the Third Person
    template project offered to us by the Unreal Engine team in order to understand
    some of the basic concepts of UE5’s workflow and framework.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了如何重现由虚幻引擎团队提供的第三人称模板项目，以便理解UE5工作流程和框架的一些基本概念。
- en: In this chapter, you will start creating another game from scratch. In this
    game, the player will control a character from a top-down point of view (similar
    to games such as Metal Gear Solid 1, 2, and 3). A top-down perspective implies
    that the player controls a character that is seen as if it was being looked down
    upon, usually with the camera rotation being fixed (the camera doesn’t rotate).
    In our game, the player character must go from point A to point B without being
    hit by dodgeballs, which are being thrown at the player by the enemies that are
    spread throughout the level. The levels in this game will be maze-like in nature,
    and the player will have multiple paths to choose from, all of which will have
    enemies trying to throw dodgeballs at them.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将从头开始创建另一个游戏。在这个游戏中，玩家将从俯视角度控制一个角色（类似于金属Gear Solid 1、2和3等游戏）。俯视视角意味着玩家控制的角色看起来就像是从上方俯瞰的，通常相机旋转是固定的（相机不旋转）。在我们的游戏中，玩家角色必须从点A移动到点B，而不被敌人投掷的躲避球击中，这些敌人散布在关卡中。这个游戏中的关卡将具有迷宫般的性质，玩家将有多个路径可供选择，所有路径上都有敌人试图向他们投掷躲避球。
- en: 'In this chapter, we’ll cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introduction to collision
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碰撞简介
- en: Understanding and visualizing Line Traces (Single and Multi)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解和可视化线迹（单线和多线）
- en: Sweep Traces
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扫描跟踪
- en: Trace Channels
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪通道
- en: Trace Responses
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪响应
- en: In the first section, we begin by getting to know what collision is in the world
    of video games.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分，我们首先了解在视频游戏世界中碰撞是什么。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The project for this chapter can be found in the Chapter05 folder of the code
    bundle for this book, which can be downloaded here: [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的项目可以在本书代码包的Chapter05文件夹中找到，该代码包可以在此处下载：[https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition)。
- en: Introduction to collision
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞简介
- en: A collision is basically a point at which two objects come into contact with
    each other (for example, two objects colliding, an object hitting a character,
    a character walking into a wall, and so on). Most game development tools have
    their own set of features that allow for collision and physics to exist inside
    the game. This set of features is called a physics engine, which is responsible
    for everything related to collisions. It is responsible for executing Line Traces,
    checking whether two objects are overlapping each other, blocking each other’s
    movement, or bouncing off of a wall, and much more. When we ask the game to execute
    or notify us of these collision events, the game is essentially asking the physics
    engine to execute it and then show us the results of these collision events.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 碰撞基本上是指两个物体相互接触的点（例如，两个物体相撞，一个物体击中角色，角色撞到墙上，等等）。大多数游戏开发工具都有自己的功能集，允许在游戏中存在碰撞和物理。这个功能集被称为物理引擎，它负责所有与碰撞相关的事情。它负责执行线迹，检查两个物体是否重叠，阻止彼此的移动，或者从墙上弹回，以及更多。当我们要求游戏执行或通知我们这些碰撞事件时，游戏实际上是在要求物理引擎执行它，然后向我们展示这些碰撞事件的结果。
- en: In the **Dodgeball** game you will be building, examples of where collision
    needs to be taken into account include checking whether enemies are able to see
    the player (which will be achieved using a Line Trace, which is covered in this
    chapter), simulating physics on an object that will behave just like a dodgeball,
    checking whether anything is blocking the player character’s movement, and much
    more.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在你将要构建的**躲避球**游戏中，需要考虑碰撞的例子包括检查敌人是否能看到玩家（这将通过本章介绍的使用线迹来实现），模拟一个将表现得像躲避球的对象的物理行为，检查是否有任何东西阻挡了玩家角色的移动，以及更多。
- en: Collision is one of the most important aspects of most games, so understanding
    it is crucial in order to get started with game development.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 碰撞是大多数游戏最重要的方面之一，因此理解它是开始游戏开发的关键。
- en: Before we start building our collision-based features, we will first need to
    set up our new **Dodgeball** project in order to support the game mechanics we
    will be implementing. This process starts with the steps described in the following
    section.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始构建基于碰撞的功能之前，我们首先需要设置我们的新**Dodgeball**项目，以便支持我们将要实现的游戏机制。这个过程从以下章节中描述的步骤开始。
- en: Setting up your project
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置您的项目
- en: 'Let’s begin by creating our Unreal Engine project:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建我们的Unreal Engine项目：
- en: Launch UE5\. Select the **Games** project category, then click on **Next**.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动UE5。选择**游戏**项目类别，然后点击**下一步**。
- en: Select the **Third Person template**, then click on **Next**.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**第三人称模板**，然后点击**下一步**。
- en: Make sure the first option is set to **C++** and not **Blueprint**.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保第一个选项设置为**C++**而不是**蓝图**。
- en: Select the location of the project according to your preference and name your
    project `Dodgeball`, then click on **Create Project**.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据您的偏好选择项目位置，并将项目命名为`Dodgeball`，然后点击**创建项目**。
- en: 'When the project is done being generated, you should see the following on your
    screen:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当项目生成完成后，您应该在屏幕上看到以下内容：
- en: '![Figure 5.1 – Dodgeball project loaded up](img/Figure_5.01_B18531.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1 – Dodgeball项目已加载](img/Figure_5.01_B18531.jpg)'
- en: Figure 5.1 – Dodgeball project loaded up
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – Dodgeball项目已加载
- en: After the code has been generated and the project opens up, enable the Enhanced
    Input plugin, just like we did in steps 1-3 of the *Understanding input actions
    and contexts* section in [*Chapter 4*](B18531_04.xhtml#_idTextAnchor099)*, Getting
    Started with Player Input*.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码生成并项目打开后，启用增强输入插件，就像我们在[*第4章*](B18531_04.xhtml#_idTextAnchor099)*“理解输入动作和上下文”部分的步骤1-3中做的那样，*开始使用玩家输入*。
- en: 'After that, close the UE5 editor and open the files of the generated third-person
    `Character` class, `DodgeballCharacter`, in Visual Studio, as shown in the following
    figure:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，关闭UE5编辑器并打开如图所示的生成的第三人称`Character`类`DodgeballCharacter`的文件，在Visual Studio中，如下所示：
- en: '![Figure 5.2 – Files generated in Visual Studio ](img/Figure_5.02_B18531.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2 – Visual Studio中生成的文件](img/Figure_5.02_B18531.jpg)'
- en: Figure 5.2 – Files generated in Visual Studio
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – Visual Studio中生成的文件
- en: As mentioned earlier, your project is going to have a top-down perspective.
    Given that we’re starting this project from the Third Person template, we’ll have
    to change a few things before we turn this into a top-down game. This will mainly
    involve changing some lines of code in the existing `Character` class.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，您的项目将具有俯视视角。鉴于我们从第三人称模板开始此项目，我们将在将其转换为俯视游戏之前更改一些事情。这主要涉及在现有的`Character`类中更改一些代码行。
- en: 'Exercise 5.01: Converting DodgeballCharacter to a top-down perspective'
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.01：将DodgeballCharacter转换为俯视视角
- en: In this exercise, you’ll be performing the necessary changes to your generated
    `DodgeballCharacter` class. Remember, it currently features a third-person perspective
    where the rotation of the character is dictated by the player’s input (*namely
    the mouse or right analog stick*).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将对生成的`DodgeballCharacter`类进行必要的更改。记住，它目前具有第三人称视角，角色的旋转由玩家的输入（即鼠标或右模拟摇杆）决定。
- en: In this exercise, you will change this to a top-down perspective, which remains
    the same regardless of the player’s input and the camera always follows the character
    from above.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将将其更改为俯视视角，这不受玩家输入的影响，并且摄像机始终从上方跟随角色。
- en: 'The following steps will help you complete this exercise:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成此练习：
- en: Head to the `DodgeballCharacter` class’s constructor and update the `CameraBoom`
    properties, as mentioned in the following steps.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`DodgeballCharacter`类的构造函数并更新`CameraBoom`属性，如以下步骤所述。
- en: 'Change `TargetArmLength`, which is a property of `CameraBoom`, to `900.0f`
    in order to add some distance between the camera and the player as follows:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`CameraBoom`的属性`TargetArmLength`更改为`900.0f`，以便在摄像机和玩家之间添加一些距离，如下所示：
- en: '[PRE0]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, add a line that sets the relative pitch to `-70`º using the `SetRelativeRotation`
    function so that the camera looks down at the player. The `FRotator` constructor’s
    parameters are `pitch`, `yaw`, and `roll`, respectively, as follows:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加一行代码，使用`SetRelativeRotation`函数将相对俯仰设置为`-70`°，以便摄像机向下看玩家。`FRotator`构造函数的参数分别是俯仰、偏航和翻滚，如下所示：
- en: '[PRE1]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Change `bUsePawnControlRotation` to `false` so that the camera’s rotation isn’t
    changed by the player’s movement input as follows:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`bUsePawnControlRotation`更改为`false`，这样相机的旋转就不会被玩家的移动输入改变，如下所示：
- en: '[PRE2]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add a line that sets `bInheritPitch`, `bInheritYaw`, and `bInheritRoll` to
    `false` so that the camera’s rotation isn’t changed by the character’s orientation
    as follows:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一行代码，将`bInheritPitch`、`bInheritYaw`和`bInheritRoll`设置为`false`，这样相机的旋转就不会被角色的方向改变，如下所示：
- en: '[PRE3]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After we’ve made these modifications, we’re going to remove the character’s
    ability to jump (we don’t want the player to escape from the dodgeballs that easily)
    and to rotate the camera from the player’s rotation input.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进行了这些修改之后，我们将移除角色跳跃的能力（我们不希望玩家那么容易从躲避球中逃脱）以及从玩家的旋转输入中旋转相机。
- en: 'Go to the `SetupPlayerInputComponent` function in the `DodgeballCharacter`’s
    source file and remove the following lines of code in order to remove the ability
    to jump:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DodgeballCharacter`的源文件中转到`SetupPlayerInputComponent`函数，并移除以下代码行以移除跳跃能力：
- en: '[PRE4]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, add the following lines in order to remove the player’s rotation input:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，按照以下顺序添加以下行，以移除玩家的旋转输入：
- en: '[PRE5]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This step is optional, but in order to keep your code clean, you should remove
    the declarations and implementations of the `TurnAtRate` and `LookUpAtRate` functions.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此步骤是可选的，但为了保持代码整洁，你应该移除`TurnAtRate`和`LookUpAtRate`函数的声明和实现。
- en: After that, we’ll have to adapt this project to use the Enhanced Input system
    instead of the Legacy Input system. Go to this class’s header file and add a property
    for the Character’s Input Context as well as the Move Input Action, just like
    we did in steps 2 and 3 of *Exercise 4.02*. Add a declaration for the `Move` function,
    just like we did in step 14 of *Exercise 4.02*.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们必须将此项目调整为使用增强输入系统而不是旧输入系统。转到此类的头文件，并为角色的输入上下文以及移动输入动作添加属性，就像我们在*练习4.02*的第2和第3步中所做的那样。添加对`Move`函数的声明，就像我们在*练习4.02*的第14步中所做的那样。
- en: Add the logic for adding the Character’s Input Context as well as binding the
    Move Input Action, just like we did in steps 4-10 of *Exercise 4.02*.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加添加角色的输入上下文以及绑定移动输入动作的逻辑，就像我们在*练习4.02*的第4-10步中所做的那样。
- en: Add the implementation to the `Move` function, just like we did in steps 14-18
    of *Exercise 4.02*.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将实现添加到`Move`函数中，就像我们在*练习4.02*的第14-18步中所做的那样。
- en: Add the Enhanced Input dependency, just like we did in steps 19 and 20 of *Exercise
    4.02*.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加增强输入依赖项，就像我们在*练习4.02*的第19和第20步中所做的那样。
- en: Finally, after you’ve made these changes, run your project from Visual Studio.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在你做了这些更改之后，从Visual Studio运行你的项目。
- en: When the editor has loaded, go to `EnhancedPlayerInput` and the `EnhancedInputComponent`.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当编辑器加载完成后，转到`EnhancedPlayerInput`和`EnhancedInputComponent`。
- en: After this, create the `IA_Move` Input Action asset and set it up just like
    we did in steps 1-3 of *Exercise 4.01*.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`IA_Move`输入动作资产，并按照我们在*练习4.01*的第1-3步中所做的那样进行设置。
- en: Then, create the `IC_Character` Input Context asset and add a mapping for the
    `IA_Move` Input Action, just like we did in steps 4-14 of *Exercise 4.01*.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建`IC_Character`输入上下文资产，并为`IA_Move`输入动作添加映射，就像我们在*练习4.01*的第4-14步中所做的那样。
- en: The last thing you need to do to complete the Enhanced Input setup is to open
    the `IC_Character` and `IA_Move` properties, just like we did in step 22 of *Exercise
    4.01*.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成增强输入的设置，你需要做的最后一件事是打开`IC_Character`和`IA_Move`属性，就像我们在*练习4.01*的第22步中所做的那样。
- en: 'After that, play the level. The camera’s perspective should look like the following
    and should not rotate based on the player’s input or the character’s rotation:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，播放关卡。相机的视角应该看起来像以下这样，并且不应基于玩家的输入或角色的旋转进行旋转：
- en: '![Figure 5.3 – Locked camera rotation to a top-down perspective ](img/Figure_5.03_B18531.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图5.3 – 锁定相机旋转到俯视视角](img/Figure_5.03_B18531.jpg)'
- en: Figure 5.3 – Locked camera rotation to a top-down perspective
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 – 锁定相机旋转到俯视视角
- en: That concludes the first exercise of this chapter and the first step of your
    new project, **Dodgeball**.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了本章的第一个练习和你的新项目**躲避球**的第一个步骤。
- en: 'Next, you will be creating the `EnemyCharacter` class. This character will
    be the enemy that throws dodgeballs at the player while the player is in view.
    But the question that arises here is this: how will the enemy know whether it
    can see the player character or not?'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将创建`EnemyCharacter`类。这个角色将在玩家在视图中时向玩家投掷躲避球。但这里出现的问题是：敌人将如何知道它是否可以看到玩家角色？
- en: That will be achieved with the power of **Line Traces** (also known as **Raycasts**
    or **Raytraces**), which you will be looking at in the following section.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这将通过**线迹**（也称为**射线**或**光线追踪**）的力量来实现，你将在下一节中看到。
- en: Understanding Line Traces
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解线迹
- en: One of the most important features of any game development tool is its ability
    to execute Line Traces. These are available through the physics engine that the
    tool is using.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 任何游戏开发工具最重要的特性之一是它执行线迹的能力。这些通过工具使用的物理引擎提供。
- en: Line Traces are a way of asking the game to tell you whether anything stands
    between two points in the game world. The game will *shoot a ray* between those
    two points, specified by you, and return the objects that were hit (if any), where
    they were hit, at what angle, and much more.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 线迹是一种询问游戏是否在游戏世界中两点之间有任何障碍的方法。游戏将在你指定的两点之间发射一条射线，并返回被击中的对象（如果有），击中的位置，击中的角度以及更多信息。
- en: 'In *Figure 5.4*, you can see a representation of a Line Trace where we assume
    object **1** is ignored and object **2** is detected,due to their Trace Channel
    properties (further explained in the following paragraphs):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在**图 5.4**中，你可以看到一个线迹的表示，我们假设由于对象的跟踪通道属性，对象**1**被忽略，而对象**2**被检测到（以下段落将进一步解释）：
- en: '![Figure 5.4 – A Line Trace being executed from point A to point B ](img/Figure_5.04_B18531.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4 – 从点 A 到点 B 执行的线迹](img/Figure_5.04_B18531.jpg)'
- en: Figure 5.4 – A Line Trace being executed from point A to point B
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – 从点 A 到点 B 执行的线迹
- en: '*Figure 5.4* is explained as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 5.4**的解释如下：'
- en: The dashed line represents the Line Trace before it hits an object.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚线代表击中对象之前的线迹。
- en: The arrows represent the direction of the Line Trace.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箭头代表线迹的方向。
- en: The dotted line represents the Line Trace after it hits an object.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点线代表击中对象之后的线迹。
- en: The striped circle represents the Line Trace’s impact point.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条纹圆圈代表线迹的击中点。
- en: The big squares represent two objects that are in the path of the Line Trace
    (objects **1** and **2**).
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大方块代表两个位于线迹路径上的对象（对象**1**和**2**）。
- en: We notice that only object **2** was hit by the Line Trace and not object **1**,
    even though it is also in the path of the Line Trace. This is due to assumptions
    made about object **1**’s Trace Channel properties, which are discussed later
    in this chapter.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到只有对象**2**被线迹击中，而对象**1**没有被击中，尽管它也在线迹的路径上。这是由于对对象**1**的跟踪通道属性所做的假设，这些假设将在本章后面讨论。
- en: 'Line Traces are used for many game features, such as the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 线迹被用于许多游戏特性，例如以下内容：
- en: Checking whether a weapon hits an object when it fires
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查武器发射时是否击中对象
- en: Highlighting an item that the player can interact with when the character looks
    at it
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当角色看向它时突出显示玩家可以与之交互的项目
- en: Rotating the camera around the player character automatically as it goes around
    corners
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当角色绕角落移动时自动旋转摄像机
- en: 'A common and important feature of Line Traces is **Trace Channels**. When you
    execute a Line Trace, you may want to check only specific types of objects, which
    is what Trace Channels are for. They allow you to specify filters to be used when
    executing a Line Trace so that it doesn’t get blocked by unwanted objects. Check
    the following examples:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 线迹的一个常见且重要的特性是**跟踪通道**。当你执行线迹时，你可能只想检查特定类型的对象，这就是跟踪通道的作用。它们允许你在执行线迹时指定过滤器，以便它不会被不需要的对象阻挡。查看以下示例：
- en: You may want to execute a Line Trace only to check for objects that are visible.
    These objects would block the `Visibility` Trace Channel. For instance, invisible
    walls, which are invisible pieces of geometry used in games to block the player’s
    movement, would not be visible and therefore would not block the `Visibility`
    Trace Channel.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能只想执行线迹来检查可见的对象。这些对象会阻挡`可见性`跟踪通道。例如，不可见的墙壁，在游戏中用作阻止玩家移动的不可见几何形状，将不可见，因此不会阻挡`可见性`跟踪通道。
- en: You may want to execute a Line Trace only to check for objects that can be interacted
    with. These objects would block the `Interaction` Trace Channel.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能只想执行线迹来检查可以与之交互的对象。这些对象会阻挡`交互`跟踪通道。
- en: You may want to execute a Line Trace only to check for pawns that can move around
    the game world. These objects would block the `Pawn` Trace Channel.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能只想执行线迹来检查可以在游戏世界中移动的NPC。这些对象会阻挡`NPC`跟踪通道。
- en: You can specify how different objects react to different Trace Channels so that
    only some objects block specific Trace Channels and others ignore them. In our
    case, we want to know whether anything stands between the enemy and the player
    character so that we know whether the enemy can see the player. We will be using
    Line Traces for this purpose by checking for anything that blocks the enemy’s
    line of sight of the player character, using a `Tick` event.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以指定不同的对象如何对不同 Trace Channels 做出反应，以便只有某些对象会阻塞特定的 Trace Channels，而其他对象则忽略它们。在我们的例子中，我们想知道是否有任何东西站在敌人和玩家角色之间，这样我们就可以知道敌人是否可以看到玩家。我们将通过检查是否有任何东西阻挡敌人对玩家角色的视线，使用
    `Tick` 事件来实现这一目的。
- en: In the next section, we will be creating the `EnemyCharacter` class using C++.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用 C++ 创建 `EnemyCharacter` 类。
- en: Creating the EnemyCharacter C++ class
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 EnemyCharacter C++ 类
- en: In our `EnemyCharacter` class will constantly be looking at the player character
    if they’re within view. This is the same class that will later throw dodgeballs
    at the player; however, we’ll leave that for the following chapter. In this chapter,
    we will be focusing on the logic that allows our enemy character to look at the
    player.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `EnemyCharacter` 类中，如果它们在视野范围内，将不断看向玩家角色。这就是那个将后来向玩家投掷躲避球的类；然而，我们将把这个内容留到下一章。在这一章中，我们将专注于允许我们的敌人角色看向玩家的逻辑。
- en: 'So, let’s get started as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们按照以下步骤开始：
- en: Right-click on the **Content Browser** inside the editor and select **New C++
    Class**.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器内的 **内容浏览器** 上右键单击并选择 **新建 C++ 类**。
- en: Choose the `Character` class as the parent class.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `Character` 类作为父类。
- en: Name the new class `EnemyCharacter`.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新类命名为 `EnemyCharacter`。
- en: 'After you’ve created the class and opened its files in Visual Studio, let’s
    add the `LookAtActor` function declaration in its `header` file. This function
    should be `public` and not return anything, only receiving the `AActor* TargetActor`
    parameter, which will be the Actor it should be facing. Have a look at the following
    code snippet, which shows this function:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在你创建了类并打开其文件在 Visual Studio 中后，让我们在其 `header` 文件中添加 `LookAtActor` 函数声明。这个函数应该是
    `public` 的，并且不返回任何内容，只接收 `AActor* TargetActor` 参数，这将是要面对的 Actor。看看下面的代码片段，它展示了这个函数：
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Even though we only want the enemy to look at the player character, in order
    to execute good software development practices, we’re going to abstract this function
    a bit more and allow `EnemyCharacter` to look at any Actor. This is because the
    logic that allows an Actor to look at another Actor or the player character will
    be exactly the same.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们只想让敌人看向玩家角色，但为了执行良好的软件开发实践，我们将对这个函数进行更多的抽象，并允许 `EnemyCharacter` 向任何 Actor
    看去。这是因为允许一个 Actor 看向另一个 Actor 或玩家角色的逻辑将是完全相同的。
- en: Remember, you should not create unnecessary restrictions when writing code.
    If you can write similar code and simultaneously allow more possibilities, you
    should do so if that doesn’t overcomplicate the logic of your program.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在编写代码时，你不应该创建不必要的限制。如果你可以编写类似的代码并同时允许更多的可能性，你应该这样做，前提是不使你的程序逻辑过于复杂。
- en: Moving on ahead, if `EnemyCharacter` can’t see the `Target` `Actor`, it shouldn’t
    be looking at it. In order to check whether the enemy can see the Actor, it should
    be looking at the `LookAtActor` function that will call another function, which
    is the `CanSeeActor` function. This is what you’ll be doing in the following exercise.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如果 `EnemyCharacter` 看不见 `Target` `Actor`，它就不应该看向它。为了检查敌人是否可以看到 Actor，它应该看向
    `LookAtActor` 函数，该函数将调用另一个函数，即 `CanSeeActor` 函数。这就是你将在下面的练习中要做的。
- en: 'Exercise 5.02: Creating the CanSeeActor function that executes Line Traces'
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.02：创建 CanSeeActor 函数以执行 Line Traces
- en: In this exercise, we will create the `CanSeeActor` function, which will return
    whether the enemy character can see the given Actor.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建 `CanSeeActor` 函数，该函数将返回敌人角色是否可以看到给定的 Actor。
- en: 'The following steps will help you complete this exercise:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你完成这个练习：
- en: 'Create the declaration for a `public` `CanSeeActor` function in the header
    file of the `EnemyCharacter` class; it will return `bool` and receive a `const
    Actor* TargetActor` parameter, which is the Actor we want to look at. This function
    will be a `const` function, because it doesn’t change any of the class’s attributes,
    and the parameter will also be `const` because we won’t need to modify any of
    its properties, we’ll only need to access them, as follows:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`EnemyCharacter`类的头文件中创建一个`public`的`CanSeeActor`函数声明；它将返回`bool`类型，并接收一个`const
    Actor* TargetActor`参数，这是我们想要观察的Actor。这个函数将是一个`const`函数，因为它不会改变类的任何属性，参数也将是`const`的，因为我们不需要修改它的任何属性，我们只需要访问它们，如下所示：
- en: '[PRE7]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, let’s get to the fun part, which is executing the Line Trace.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们进入有趣的部分，即执行线迹。
- en: In order to call functions related to line tracing, we’ll have to fetch the
    enemy’s current world with the `GetWorld` function. However, we haven’t included
    the `World` class in this file, so let’s do so in the following step.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调用与线迹相关的函数，我们必须使用`GetWorld`函数获取敌人的当前世界。然而，我们还没有将`World`类包含在这个文件中，所以让我们在以下步骤中这样做。
- en: Note
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `GetWorld` function is accessible to any Actor and will return the `World`
    object that the Actor belongs to. Remember, the world is necessary in order to
    execute the Line Trace.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetWorld`函数对任何Actor都是可访问的，并将返回Actor所属的`World`对象。记住，世界是执行线迹所必需的。'
- en: 'Open the `EnemyCharacter` source file and find the following code line:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`EnemyCharacter`源文件，找到以下代码行：
- en: '[PRE8]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Add the following line right after the preceding line of code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码行之后添加以下行：
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, create the implementation of the `CanSeeActor` function in the `EnemyCharacter`
    source file where you’ll start by checking whether our `TargetActor` is `nullptr`.
    If it is, then we return `false`, given that we have no valid Actor to check our
    sight o,f as follows:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`EnemyCharacter`源文件中创建`CanSeeActor`函数的实现；你将首先检查我们的`TargetActor`是否为`nullptr`。如果是，则返回`false`，因为我们没有有效的Actor来检查我们的视线，如下所示：
- en: '[PRE10]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Next, before we add our `Line Trace` function call, we need to set up some necessary
    parameters; we will be implementing these in the following steps.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们添加`Line Trace`函数调用之前，我们需要设置一些必要的参数；我们将在以下步骤中实现这些参数。
- en: 'After the preceding `if` statement, create a variable to store all of the necessary
    data relative to the results of the Line Trace. Unreal Engine already has a built-in
    type for this called the `FHitResult` type, as follows:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的`if`语句之后，创建一个变量来存储与线迹结果相关的所有必要数据。虚幻引擎已经有一个内置类型用于此，称为`FHitResult`类型，如下所示：
- en: '[PRE11]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is the variable we will send to our Line Trace function, which will populate
    it with the relevant info of the executed Line Trace.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将发送给线迹函数的变量，该函数将填充执行线迹的相关信息。
- en: 'Create two `FVector` variables for the `Start` and `End` locations of our Line
    Trace and set them to our enemy’s current location and our target’s current location,
    respectively, as follows:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为线迹的`Start`和`End`位置创建两个`FVector`变量，并将它们分别设置为敌人的当前位置和目标对象的当前位置，如下所示：
- en: '[PRE12]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, set the Trace Channel we wish to compare against. In our case, we want
    to have a `Visibility` Trace Channel specifically designated to indicate whether
    an object blocks another object’s view. Luckily for us, such a Trace Channel already
    exists in UE5, as shown in the following code snippet:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，设置我们希望比较的追踪通道。在我们的例子中，我们想要一个专门的`Visibility`追踪通道，用来指示一个对象是否阻挡了另一个对象的视线。幸运的是，UE5中已经存在这样的追踪通道，如下面的代码片段所示：
- en: '[PRE13]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `ECollisionChannel` `enum` represents all of the possible Trace Channels
    available to compare against. We will be using the `ECC_Visibility` value, which
    represents the `Visibility` Trace Channel.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`ECollisionChannel`枚举代表所有可比较的追踪通道。我们将使用`ECC_Visibility`值，它代表`Visibility`追踪通道。'
- en: 'Now that we’ve set up all our necessary parameters, we can finally call the
    `LineTrace` function, `LineTraceSingleByChannel`, as follows:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经设置了所有必要的参数，我们终于可以调用`LineTrace`函数，即`LineTraceSingleByChannel`，如下所示：
- en: '[PRE14]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This function will consider the parameters we send it, execute the Line Trace,
    and return its results by modifying our `Hit` variable.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将考虑我们发送给它的参数，执行线迹，并通过修改我们的`Hit`变量来返回其结果。
- en: Before we continue, there are still a couple more things we need to consider.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，还有一些事情需要我们考虑。
- en: If the Line Trace starts from within our enemy character, which is what will
    happen in our case, that means it’s very likely that the Line Trace will simply
    hit our enemy character immediately and just stop there because our character
    might block the `Visibility` Trace Channel. In order to fix that, we need to tell
    the Line Trace to ignore it.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Line Trace从我们的敌人角色内部开始，正如我们的情况，这意味着Line Trace很可能立即击中我们的敌人角色并停止在那里，因为我们的角色可能阻止了`Visibility`
    Trace通道。为了解决这个问题，我们需要告诉Line Trace忽略它。
- en: 'Use the built-in `FCollisionQueryParams` type, which allows us to give even
    more options to our Line Trace, as follows:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用内置的`FCollisionQueryParams`类型，这允许我们为我们的Line Trace提供更多的选项，如下所示：
- en: '[PRE15]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, update the `Line Trace` to ignore our enemy by adding itself to the list
    of Actors to ignore, as follows:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过将其添加到要忽略的Actors列表中，更新`Line Trace`以忽略我们的敌人，如下所示：
- en: '[PRE16]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We should also add our target to our list of Actors to ignore because we don’t
    want to know whether it blocks the `EnemySight` channel; we simply want to know
    whether something between the enemy and the player character blocks that channel.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该将我们的目标添加到要忽略的Actors列表中，因为我们不想知道它是否阻止了`EnemySight`通道；我们只想知道敌人和玩家角色之间是否有东西阻止了该通道。
- en: 'Add the `Target Actor` to the list of Actors to be ignored, as shown in the
    following code snippet:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如以下代码片段所示，将`Target Actor`添加到要忽略的Actors列表中：
- en: '[PRE17]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, send our `FCollisionQueryParams` to the Line Trace by adding it as the
    last parameter of the `LineTraceSingleByChannel` function as follows:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过将`FCollisionQueryParams`作为`LineTraceSingleByChannel`函数的最后一个参数添加，将其发送到Line
    Trace，如下所示：
- en: '[PRE18]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finalize our `CanSeeActor` function by returning whether the Line Trace hits
    anything or not. We can do that by accessing our `Hit` variable and checking whether
    there was a blocking hit, using the `bBlockingHit` property. If there was a blocking
    hit, that means we can’t see our `TargetActor`. This can be achieved with the
    following code snippet:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过返回Line Trace是否击中任何东西来最终化我们的`CanSeeActor`函数。我们可以通过访问我们的`Hit`变量并检查是否有阻挡击中，使用`bBlockingHit`属性来实现。如果有阻挡击中，这意味着我们看不到我们的`TargetActor`。这可以通过以下代码片段实现：
- en: '[PRE19]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Although we won’t need any more information from the `Hit` result other than
    whether there was a blocking hit, the `Hit` variable can give us much more information
    on the Line Trace, such as the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们不需要从`Hit`结果中获取更多除了是否有阻挡击中的信息，但`Hit`变量可以给我们关于Line Trace的更多信息，如下所示：
- en: Information on the Actor that was hit by the Line Trace (`nullptr` if no Actor
    was hit) by accessing the `Hit.GetActor()` function.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 通过访问`Hit.GetActor()`函数获取被Line Trace击中的Actor的信息（如果没有击中Actor，则为`nullptr`）。
- en: Information on the Actor component that was hit by the Line Trace (`nullptr`
    if no Actor component was hit) by accessing the `Hit.GetComponent()` function.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通过访问`Hit.GetComponent()`函数获取被Line Trace击中的Actor组件的信息（如果没有击中Actor组件，则为`nullptr`）。
- en: Information on the location of the hit by accessing the `Hit.Location` variable.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通过访问`Hit.Location`变量获取击中位置的信息。
- en: The distance of the hit can be found by accessing the `Hit.Distance` variable.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通过访问`Hit.Distance`变量可以找到击中的距离。
- en: The angle at which the Line Trace hit the object, which can be found by accessing
    the `Hit.ImpactNormal` variable.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Line Trace击中物体的角度，可以通过访问`Hit.ImpactNormal`变量找到。
- en: Finally, our `CanSeeActor` function is complete. We now know how to execute
    a Line Trace and we can use it for our enemy’s logic.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的`CanSeeActor`函数已经完成。我们现在知道如何执行Line Trace，并且可以使用它来处理敌人的逻辑。
- en: By completing this exercise, we have finished the `CanSeeActor` function; we
    can now get back to the `LookAtActor` function. However, there is something we
    should look at first, which is visualizing our Line Trace.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，我们已经完成了`CanSeeActor`函数；现在我们可以回到`LookAtActor`函数。然而，我们首先应该看看的是可视化我们的Line
    Trace。
- en: Visualizing the Line Trace
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可视化Line Trace
- en: When creating new logic that makes use of Line Traces, it is very useful to
    actually visualize the Line Trace while it’s being executed, which is something
    that the Line Trace function doesn’t allow you to do. In order to do that, we
    must use a set of helper debug functions that can draw objects dynamically at
    runtime, such as lines, cubes, spheres, and so on.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建使用Line Traces的新逻辑时，在执行时实际可视化Line Trace非常有用，这是Line Trace函数不允许你做的事情。为了做到这一点，我们必须使用一组可以在运行时动态绘制对象的辅助调试函数，例如线条、立方体、球体等。
- en: 'Let’s then add a visualization of our Line Trace. The first thing we must do
    in order to use the debug functions is to add the following `include` line of
    code under our last `include` line:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们添加我们的线迹的可视化。为了使用调试函数，我们必须首先在我们的最后一个`include`行下面添加以下代码行：
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We will want to call the `DrawDebugLine` function in order to visualize the
    Line Trace, which needs the following inputs (that are very similar to the ones
    received by the Line Trace function):'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将想要调用`DrawDebugLine`函数来可视化线迹，这需要以下输入（与线迹函数接收的输入非常相似）：
- en: The current `World`, which we will supply with the `GetWorld` function
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前的`World`，我们将通过`GetWorld`函数提供
- en: The `Start` and `End` points of the line, which will be the same as the `LineTraceSingleByChannel`
    function
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线的`Start`和`End`点，它们将与`LineTraceSingleByChannel`函数相同
- en: The desired color of the line in the game, which can be set to `Red`
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏中线的期望颜色，可以设置为`Red`
- en: 'Then, we can add the `DrawDebugLine` function call under our Line Trace function
    call, as shown in the following code snippet:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在我们的线迹函数调用下添加`DrawDebugLine`函数调用，如下面的代码片段所示：
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This will allow you to visualize the Line Trace as it is being executed, which
    is very useful.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许你在执行过程中可视化线迹，这非常有用。
- en: Note
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you feel the need for it, you can also specify more of the visual Line Trace’s
    properties, such as its lifetime and thickness.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要，你也可以指定更多视觉线迹的属性，例如其寿命和粗细。
- en: There are many `DrawDebug` functions available that will draw cubes, spheres,
    cones, donuts, and even custom meshes.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多`DrawDebug`函数可用于绘制立方体、球体、圆锥体、甜甜圈，甚至自定义网格。
- en: Now that we can both execute and visualize our Line Trace, let’s use the `CanSeeActor`
    function, which we created in the last exercise, inside the `LookAtActor` function.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们既能执行又能可视化我们的线迹，让我们在`LookAtActor`函数内部使用我们上一次练习中创建的`CanSeeActor`函数。
- en: 'Exercise 5.03: Creating the LookAtActor function'
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.03：创建LookAtActor函数
- en: In this exercise, we will be creating the definition of our `LookAtActor` function,
    which will change the enemy’s rotation so that it faces the given Actor.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建我们的`LookAtActor`函数的定义，这将改变敌人的旋转，使其面对给定的演员。
- en: 'The following steps will help you complete the exercise:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你完成练习：
- en: Create the `LookAtActor` function definition in the `EnemyCharacter` source
    file.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`EnemyCharacter`源文件中创建`LookAtActor`函数定义。
- en: 'Start by checking whether our `TargetActor` is `nullptr` and returns nothing
    immediately if it is (because it’s not valid), as shown in the following code
    snippet:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，检查我们的`TargetActor`是否为`nullptr`，如果是，则立即返回（因为它不是有效的），如下面的代码片段所示：
- en: '[PRE22]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we want to check whether we can see our `Target Actor`, using our `CanSeeActor`
    function:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们想要检查我们是否可以看到我们的`Target Actor`，使用我们的`CanSeeActor`函数：
- en: '[PRE23]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If this `if` statement is `true`, that means we can see the Actor, and we will
    set our rotation in such a way that we are facing that Actor. Luckily for us,
    there’s already a function within UE5 that allows us to do that: the `FindLookAtRotation`
    function. This function will receive as input two points in the level, point A
    (the `Start` point) and point B (the `End` point), and return the rotation that
    the object at the start point must have in order to face the object at the end
    point. Perform the following steps in order to use this function.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个`if`语句为`true`，这意味着我们可以看到该演员，我们将设置我们的旋转，以便我们面对该演员。幸运的是，UE5中已经有一个函数可以做到这一点：`FindLookAtRotation`函数。此函数将接收两个水平面上的点作为输入，点A（`Start`点）和点B（`End`点），并返回起点对象必须具有的旋转，以便面对终点对象。按照以下步骤使用此函数。
- en: 'Include `KismetMathLibrary` as shown in the following code snippet:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下代码片段所示，包含`KismetMathLibrary`：
- en: '[PRE24]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `FindLookAtRotation` function must receive a `Start` and `End` points,
    which will be our enemy’s location and our Target Actor’s location, respectively,
    as follows:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FindLookAtRotation`函数必须接收一个`Start`和`End`点，分别对应我们的敌人位置和目标演员的位置，如下所示：'
- en: '[PRE25]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, set your enemy character’s rotation to the same value as our `LookAtRotation`,
    as follows:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将你的敌人角色的旋转设置为与我们的`LookAtRotation`相同，如下所示：
- en: '[PRE26]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: And that’s it for the `LookAtActor` function.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`LookAtActor`函数就到这里。'
- en: Now, the last step is to call the `LookAtActor` function inside the `Tick` event
    and send the player character as the `TargetActor`, as in the Actor that we want
    to look at.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，最后一步是在`Tick`事件中调用`LookAtActor`函数，并将玩家角色作为`TargetActor`发送，就像我们想要看的演员一样。
- en: 'For us to fetch the character that is currently being controlled by the player,
    we use the `GameplayStatics` object. As with other UE5 objects, we must first
    include them as follows:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了获取玩家当前控制的角色，我们使用 `GameplayStatics` 对象。与其他 UE5 对象一样，我们必须首先按照以下方式将其包含在内：
- en: '[PRE27]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, head to your `Tick` function’s body and call the `GetPlayerCharacter`
    function from `GameplayStatics`, as follows:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，前往您的 `Tick` 函数体并从 `GameplayStatics` 调用 `GetPlayerCharacter` 函数，如下所示：
- en: '[PRE28]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This function receives the following as input:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接收以下输入：
- en: A `World` context object, which is, essentially, an object that belongs to our
    current world and is used to let the function know which `World` object to access.
    This `World` context object can simply be the `this` pointer.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `World` 上下文对象，这实际上是一个属于我们当前世界的对象，用于让函数知道要访问哪个 `World` 对象。这个 `World` 上下文对象可以是简单的
    `this` 指针。
- en: A player index, which, given that our game is supposed to be a single-player
    game, we can safely assume to be `0` (the first player).
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个玩家索引，鉴于我们的游戏应该是一个单人游戏，我们可以安全地假设它是 `0`（第一个玩家）。
- en: 'Next, call the `LookAtActor` function, sending the player character that we
    just fetched, as follows:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，调用 `LookAtActor` 函数，发送我们刚刚获取的玩家角色，如下所示：
- en: '[PRE29]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The last step of this exercise is to compile your changes in Visual Studio.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本练习的最后一个步骤是在 Visual Studio 中编译您的更改。
- en: Now that you’ve completed this exercise, your `EnemyCharacter` class has all
    of the necessary logic to face the player character, if it’s within view, and
    we can start creating the `EnemyCharacter` Blueprint Class.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经完成了这个练习，您的 `EnemyCharacter` 类已经拥有了面对玩家角色的所有必要逻辑，如果它在视线范围内，我们可以开始创建 `EnemyCharacter`
    蓝图类。
- en: Creating the EnemyCharacter Blueprint Class
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 EnemyCharacter 蓝图类
- en: 'Now that we have finished the logic for our `EnemyCharacter` C++ class, we
    must create our Blueprint Class that derives from it, as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了 `EnemyCharacter` C++ 类的逻辑，我们必须创建从它派生的蓝图类，如下所示：
- en: Open our project in the editor.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中打开我们的项目。
- en: Go to the `Blueprints` folder inside the `ThirdPersonCPP` folder in the `Content
    Browser`.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 `Content Browser` 中的 `ThirdPersonCPP` 文件夹内的 `Blueprints` 文件夹。
- en: Right-click and select the option to create a new Blueprint Class.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击并选择创建新的蓝图类选项。
- en: Expand the `EnemyCharacter` C++ class, and select it as the Parent Class.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开并选择 `EnemyCharacter` C++ 类作为父类。
- en: Name the Blueprint Class `BP_EnemyCharacter`.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将蓝图类命名为 `BP_EnemyCharacter`。
- en: Open the Blueprint Class, select the `SKM_Quinn_Simple` and its `ABP_Quinn`.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开蓝图类，选择 `SKM_Quinn_Simple` 及其 `ABP_Quinn`。
- en: Change the `-90º` (on the *z-axis*) and its position on the *z-axis* to `-83`
    units.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `-90º`（在 *z 轴上*）及其在 *z 轴上的位置更改为 `-83` 单位。
- en: After you’ve set up the Blueprint Class, its mesh setup should look very similar
    to that of our **DodgeballCharacter** Blueprint Class.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您设置了蓝图类之后，其网格设置应该与我们自己的 **DodgeballCharacter** 蓝图类非常相似。
- en: 'Drag an instance of the `BP_EnemyCharacter` class to your level in a location
    near an object that can block its line of sight, such as following location (the
    selected character is `EnemyCharacter`):'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `BP_EnemyCharacter` 类的一个实例拖动到您的关卡中，位置靠近一个可以阻挡其视线的对象，例如以下位置（选定的角色是 `EnemyCharacter`）：
- en: '![Figure 5.5 – Dragging the BP_EnemyCharacter class into the level ](img/Figure_5.05_B18531.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.5 – 将 BP_EnemyCharacter 类拖动到关卡中](img/Figure_5.05_B18531.jpg)'
- en: Figure 5.5 – Dragging the BP_EnemyCharacter class into the level
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – 将 BP_EnemyCharacter 类拖动到关卡中
- en: 'Now we can finally play the game and verify that our enemy does look at our
    player character whenever it’s within view, as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以最终玩游戏并验证我们的敌人是否在视线范围内时始终看向我们的玩家角色，如下所示：
- en: '![Figure 5.6 – The enemy character with a clear view of the player using a
    Line Trace ](img/Figure_5.06_B18531.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6 – 敌人角色使用线迹清晰地看到玩家](img/Figure_5.06_B18531.jpg)'
- en: Figure 5.6 – The enemy character with a clear view of the player using a Line
    Trace
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – 敌人角色使用线迹清晰地看到玩家
- en: 'We can also see that the enemy stops seeing the player whenever it’s not within
    view, as shown in *Figure 5.7*:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以看到，当敌人不在视线范围内时，它会停止看到玩家，如图 *5.7* 所示：
- en: '![Figure 5.7 – The enemy losing sight of the player ](img/Figure_5.07_B18531.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.7 – 敌人失去对玩家的视线](img/Figure_5.07_B18531.jpg)'
- en: Figure 5.7 – The enemy losing sight of the player
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7 – 敌人失去对玩家的视线
- en: And that concludes our `EnemyCharacter`’s logic. In the following section, we
    will be looking at Sweep Traces.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就完成了 `EnemyCharacter` 的逻辑。在下一节中，我们将探讨扫描线迹。
- en: Sweep Traces
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扫描线迹
- en: Before we continue with our project, it is important to know about a variant
    of the Line Trace, which is the **Sweep Trace**. Although we won’t be using these
    in our project, it is important to know about them and how to use them.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续我们的项目之前，了解 Line Trace 的一个变体——Sweep Trace，是很重要的。尽管我们不会在我们的项目中使用这些，但了解它们以及如何使用它们是很重要的。
- en: While the Line Trace basically *shoots a ray* between two points, the Sweep
    Trace will simulate *throwing an object* between two points in a straight line.
    The object that is being *thrown* is simulated (it doesn’t actually exist in the
    game) and can have various shapes. In the Sweep Trace, the `Hit` location will
    be the first point at which the virtual object (which we will call **shape**)
    hits another object if it were thrown from the start point to the end point. The
    shapes of the Sweep Trace can be either a box, a sphere, or a capsule.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Line Trace 基本上是在两点之间“发射一条射线”，但 Sweep Trace 将在两点之间模拟“投掷一个物体”。被“投掷”的物体是模拟的（它实际上并不存在于游戏中）并且可以有多种形状。在
    Sweep Trace 中，`Hit` 位置将是虚拟物体（我们将称之为 **shape**）从起点投掷到终点时第一次击中另一个物体的点。Sweep Trace
    的形状可以是矩形、球体或胶囊。
- en: 'The following is a representation of a Sweep Trace from point A to point B,
    where we assume that object `1` is ignored due to its Trace Channel properties,
    using a box shape:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从点 A 到点 B 的 Sweep Trace 的表示，我们假设由于对象 `1` 的 Trace Channel 属性，它被忽略，使用的是矩形形状：
- en: '![Figure 5.8 – Representation of a Sweep Trace ](img/Figure_5.08_B18531.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.8 – Sweep Trace 的表示](img/Figure_5.08_B18531.jpg)'
- en: Figure 5.8 – Representation of a Sweep Trace
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8 – Sweep Trace 的表示
- en: 'In *Figure 5.8*, we notice the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 5.8* 中，我们注意到以下内容：
- en: A Sweep Trace, using a box shape, being executed from point A to point B.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行从点 A 到点 B 的 Sweep Trace，使用的是矩形形状。
- en: The dashed boxes represent the Sweep Trace before it hits an object.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚线框代表碰撞前的 Sweep Trace。
- en: The dotted boxes represent the Sweep Trace after it hits an object.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点线框代表碰撞后的 Sweep Trace。
- en: The striped circle represents the Sweep Trace’s impact point with object **2**,
    which is the point at which the Sweep Trace box shape’s surface and object **2**’s
    surface collide with each other.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 斜纹圆圈代表 Sweep Trace 与对象 **2** 的碰撞点，即 Sweep Trace 矩形形状的表面与对象 **2** 的表面碰撞的点。
- en: The big squares represent two objects that are in the path of the Line Sweep
    Trace (objects **1** and **2**).
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大的正方形代表两条在 Line Sweep Trace 路径上的对象（对象 **1** 和 **2**）。
- en: Object **1** is ignored in the Sweep Trace due to assumptions based on its Trace
    Channel properties.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象 **1** 由于基于其 Trace Channel 属性的假设，在 Sweep Trace 中被忽略。
- en: Sweep Traces are more useful than regular Line Traces in a few situations. Let’s
    take the example of our enemy character, which can throw dodgeballs. If we wanted
    to add a way for the player to constantly visualize where the next dodgeball that
    the enemy throws will land, that could be better achieved with a Sweep Trace.
    We would do a Sweep Trace with the shape of our dodgeball (a sphere) toward our
    player, check the impact point, and show a sphere on that impact point, which
    would be visible to the player. If the Sweep Trace hits a wall or a corner somewhere,
    the player would know that if the enemy were to throw a dodgeball at that moment,
    that’s where it would hit first. You could use a simple Line Trace for the same
    purpose, but the setup would have to be rather complex in order to achieve the
    same quality of results, which is why Sweep Traces are a better solution in this
    case.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，Sweep Trace 比常规 Line Trace 更有用。让我们以我们的敌人角色为例，它可以投掷躲避球。如果我们想为玩家添加一种方法，让他们能够持续可视化敌人即将投掷的下一个躲避球落点，那么使用
    Sweep Trace 可能会更好。我们会用躲避球（一个球体）的形状对玩家进行 Sweep Trace，检查碰撞点，并在该碰撞点上显示一个球体，这样玩家就能看到。如果
    Sweep Trace 在某处击中墙壁或角落，玩家就会知道如果敌人此时投掷躲避球，它将首先击中那里。你可以用简单的 Line Trace 达到相同的目的，但为了达到相同的质量，设置必须相当复杂，这就是为什么在这种情况下
    Sweep Trace 是更好的解决方案。
- en: Let’s now take a quick look at how we can do a Sweep Trace in code.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在快速看一下我们如何在代码中执行 Sweep Trace。
- en: 'Exercise 5.04: Executing a Sweep Trace'
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.04：执行 Sweep Trace
- en: In this exercise, we will implement a Sweep Trace in code. Although we won’t
    be using it for our project, by performing this exercise you will become familiar
    with such an operation.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将通过代码实现 Sweep Trace。尽管我们不会在我们的项目中使用它，但通过执行这个练习，你将熟悉这种操作。
- en: 'Go to the end of the `CanSeeActor` function created in the preceding sections
    and perform the following steps:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的章节中创建的`CanSeeActor`函数的末尾，执行以下步骤：
- en: 'The function responsible for the Sweep Trace is `SweepSingleByChannel`, which
    is available within UE5 and requires the following parameters as inputs:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 负责扫描跟踪的函数是`SweepSingleByChannel`，它可在UE5中使用，并需要以下参数作为输入：
- en: 'An `FHitResult` type to store the results of the sweep (we already have one
    of these, so there’s no need to create another variable of this type) as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 一个用于存储扫描结果的`FHitResult`类型（我们已经有了一个这样的变量，因此不需要创建另一个此类变量），如下所示：
- en: '[PRE30]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`Start` and `End` points of the sweep (we already have both of these, so there’s
    no need to create another variable of this type) as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描的`Start`和`End`点（我们已经有这两个，因此不需要创建另一个此类变量），如下所示：
- en: '[PRE31]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Use the intended rotation of the shape, which is in the form of an `FQuat`
    type (representing a quaternion). In this case, it’s set to a rotation of `0`
    on all axes, by accessing the `FQuat`’s `Identity` property as follows:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用形状的预期旋转，该旋转以`FQuat`类型（表示四元数）的形式存在。在这种情况下，它被设置为所有轴上的旋转`0`，如下通过访问`FQuat`的`Identity`属性：
- en: '[PRE32]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, use the intended Trace Channel to compare it against (we already have
    one of these, so there’s no need to create another variable of this type) as follows:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用预期的跟踪通道进行比较（我们已经有了一个这样的变量，因此不需要创建另一个此类变量），如下所示：
- en: '[PRE33]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, use the shape of a box for the Sweep Trace by calling the `FcollisionShape`
    `MakeBox` function and supplying it with the radius (on all three axes) of the
    box shape we want. This is shown in the following code snippet:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过调用`FcollisionShape`的`MakeBox`函数并为其提供我们想要的盒子形状的半径（在所有三个轴上）来使用盒子形状进行扫描跟踪。这在上面的代码片段中显示：
- en: '[PRE34]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, call the `SweepSingleByChannel` function as follows:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，按照以下方式调用`SweepSingleByChannel`函数：
- en: '[PRE35]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: With these steps completed, we finish our exercise on Sweep Traces. Given that
    we won’t be using Sweep Traces in our project, you should comment out the `SweepSingleByChannel`
    function so that our `Hit` variable doesn’t get modified and lose the results
    from our Line Trace.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些步骤后，我们完成了关于扫描跟踪的练习。鉴于我们不会在我们的项目中使用扫描跟踪，你应该注释掉`SweepSingleByChannel`函数，这样我们的`Hit`变量就不会被修改，从而不会丢失我们的线跟踪的结果。
- en: Now that we’ve concluded the section on Sweep Traces, let’s get back to our
    **Dodgeball** project and learn how to change an object’s response to a Trace
    Channel.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了关于扫描跟踪的部分，让我们回到我们的**躲避球**项目，学习如何更改对象对跟踪通道的响应。
- en: Changing the Visibility Trace Response
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改可见性跟踪响应
- en: 'In our current setup, every object that is visible blocks the `Visibility`
    Trace Channel; however, what if we wanted to change whether an object blocks that
    channel completely? In order to do this, we must change a component’s response
    to that channel. Have a look at the following example:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们当前的设置中，每个可见的对象都会阻挡`Visibility`跟踪通道；但是，如果我们想改变一个对象是否完全阻挡该通道，我们应该如何操作？为了做到这一点，我们必须改变一个组件对该通道的响应。看看以下示例：
- en: 'We select the cube that we’ve been using to block the enemy’s sight in our
    level as shown in *Figure 5.9*:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们选择我们在我们的关卡中用来阻挡敌人视线的立方体，如*图5.9*所示：
- en: '![Figure 5.9 – Default spawn of the character ](img/Figure_5.09_B18531.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![图5.9 – 角色的默认生成](img/Figure_5.09_B18531.jpg)'
- en: Figure 5.9 – Default spawn of the character
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9 – 角色的默认生成
- en: 'Then, you go to the **Collision** section of this object’s **Details Panel**
    (its default place in the **Editor**’s interface) as follows:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你进入此对象的**碰撞**部分（在**编辑器**界面中的默认位置）的**详细信息面板**，如下所示：
- en: '![Figure 5.10 – Collision tab in the Details Panel in Unreal Engine ](img/Figure_5.10_B18531.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![图5.10 – Unreal Engine中详细信息面板的碰撞选项卡](img/Figure_5.10_B18531.jpg)'
- en: Figure 5.10 – Collision tab in the Details Panel in Unreal Engine
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.10 – Unreal Engine中详细信息面板的碰撞选项卡
- en: Here, you’ll find several collision-related options. The one we want to pay
    attention to right now is the **Collision Presets** option. Its current value
    is **Default**; however, we want to change it according to our own preferences,
    so we will click on the drop-down box and change its value to **Custom**.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，你可以找到几个与碰撞相关的选项。我们现在需要关注的是**碰撞预设**选项。它的当前值是**默认**；然而，我们希望根据自己的偏好进行更改，因此我们将点击下拉框并将其值更改为**自定义**。
- en: 'Once you do this, you’ll notice a whole group of new options pop up as follows:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成此操作后，你会注意到一组新的选项如下弹出：
- en: '![Figure 5.11 – Collision Presets set to Custom ](img/Figure_5.11_B18531.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![图5.11 – 碰撞预设设置为自定义](img/Figure_5.11_B18531.jpg)'
- en: Figure 5.11 – Collision Presets set to Custom
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.11 – 碰撞预设设置为自定义
- en: This group of options allows you to specify how this object responds to Line
    Traces and object collision, and the type of collision object it is.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这组选项允许你指定这个物体如何响应线迹和物体碰撞，以及它是什么类型的碰撞物体。
- en: The option you should be paying attention to is **Visibility**. You’ll notice
    it’s set to **Block**, but you can also set it to **Overlap** and **Ignore**.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该注意的选项是**可见性**。你会注意到它被设置为**阻挡**，但你也可以将其设置为**重叠**和**忽略**。
- en: Right now, the cube is blocking the **Visibility** channel, which is why our
    enemy can’t see the character when it’s behind this cube. However, if we change
    the object’s response to the **Visibility** channel to either **Overlap** or **Ignore**,
    the object will no longer block Line Traces that check for **Visibility** (which
    is the case for the Line Trace you’ve just written in C++).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，立方体阻挡了**可见性**通道，这就是为什么我们的敌人看不到角色，当它躲在立方体后面时。然而，如果我们把物体的响应改为**重叠**或**忽略**，物体将不再阻挡检查**可见性**的线迹（这是你刚刚在C++中编写的线迹的情况）。
- en: 'Let’s change the cube’s response to the **Visibility** channel to **Ignore**,
    and then play the game. You’ll notice that the enemy is still looking toward the
    player character, even when it’s behind the cube:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将立方体对**可见性**通道的响应改为**忽略**，然后玩游戏。你会发现，即使敌人躲在立方体后面，它仍然朝向玩家角色：
- en: '![Figure 5.12 – The enemy character looking through an object at the player
    ](img/Figure_5.12_B18531.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![图5.12 – 敌人角色通过一个物体看向玩家](img/Figure_5.12_B18531.jpg)'
- en: Figure 5.12 – The enemy character looking through an object at the player
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.12 – 敌人角色通过一个物体看向玩家
- en: This is because the cube no longer blocks the **Visibility** channel, and so
    the Line Trace the enemy is executing no longer hits anything when trying to reach
    the player character.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为立方体不再阻挡**可见性**通道，因此当敌人尝试到达玩家角色时，执行中的线迹不再击中任何东西。
- en: Now that we’ve seen how we can change an object’s response to a specific Trace
    Channel, let’s change the cube’s response to the **Visibility** channel back to
    **Block**.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到我们可以如何改变一个对象对特定线迹通道的响应，让我们将立方体对**可见性**通道的响应改回**阻挡**。
- en: However, there’s one thing that’s worth mentioning. If we were to set the cube’s
    response to the **Visibility** channel to **Overlap** instead of **Ignore**, the
    result would be the same. But why is that, and what is the purpose of having these
    two responses? In order to explain that, we’ll look at Multi Line Traces.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一件事值得提及。如果我们把立方体对**可见性**通道的响应设置为**重叠**而不是**忽略**，结果将会相同。但为什么是这样，这两个响应的目的又是什么？为了解释这一点，我们将查看多线迹。
- en: Multi Line Traces
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多线迹
- en: When using the `CanSeeActor` function in *Exercise 5.02*, *Creating the CanSeeActor
    function that executes Line Traces*, you might have wondered to yourself about
    the name of the Line Trace function we used, `LineTraceSingleByChannel`, specifically
    about why it used the word *Single*. The reason for that is that you can also
    execute `LineTraceMultiByChannel`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在*练习5.02*中使用`CanSeeActor`函数，即*创建执行线迹的CanSeeActor函数*时，你可能对自己使用的线迹函数`LineTraceSingleByChannel`的名字感到好奇，特别是关于为什么它使用了单词*Single*。这样做的原因是你也可以执行`LineTraceMultiByChannel`。
- en: But how do these two Line Traces differ?
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 但这两条线迹有何不同？
- en: While the Single Line Trace will stop checking for objects that block it after
    it hits an object and tell us that was the object that it hit, the Multi Line
    Trace can check for any objects that are hit by the same Line Trace.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当单线迹击中一个物体后，它将停止检查被它阻挡的物体，并告诉我们它击中的是那个物体，而多线迹可以检查被同一线迹击中的任何物体。
- en: 'The Single Line Trace will do the following:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 单线迹将执行以下操作：
- en: Ignore the objects that have their response set to either `Ignore` or `Overlap`
    on the Trace Channel being used by the Line Trace
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忽略响应设置为`忽略`或`重叠`的物体在由线迹使用的线迹通道上的响应
- en: Stop when it finds an object that has its response set to `Block`
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当它找到一个响应设置为`阻挡`的物体时停止
- en: 'However, instead of ignoring objects that have their response set to `Overlap`,
    the Multi Line Trace will add them as objects that were found during the Line
    Trace and only stop when it finds an object that blocks the desired Trace Channel
    (*or when it reaches the end point*). In the next figure, you’ll find an illustration
    of a Multi Line Trace being executed:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与将响应设置为`Overlap`的对象不同，多行轨迹会将它们添加为在行轨迹中找到的对象，并且只有当它找到阻挡所需轨迹通道的对象时才会停止（或者当它达到终点时）。在下一图中，您将看到一个多行轨迹执行的示例：
- en: '![Figure 5.13 – A Multi Line Trace being executed from point A to point B ](img/Figure_5.13_B18531.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.13 – 从点 A 到点 B 执行的多行轨迹](img/Figure_5.13_B18531.jpg)'
- en: Figure 5.13 – A Multi Line Trace being executed from point A to point B
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.13 – 从点 A 到点 B 执行的多行轨迹
- en: 'In *Figure 5.13*, we notice the following:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图 5.13*中，我们注意到以下内容：
- en: The dashed line represents the Line Trace before it hits an object that blocks
    it.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚线代表行轨迹撞击阻挡它的对象之前的轨迹。
- en: The dotted line represents the Line Trace after it hits an object that blocks
    it.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点划线代表行轨迹撞击阻挡它的对象后的轨迹。
- en: The striped circles represent the Line Trace’s impact points, and only the last
    one of which is a blocking hit in this case.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 斜线圆圈代表行轨迹的撞击点，在这种情况下，只有最后一个撞击点是阻挡击中。
- en: The only difference between the `LineTraceSingleByChannel` and the `LineTraceMultiByChannel`
    functions, when it comes to their inputs, is that the latter must receive a `TArray<FHitResult>`
    input instead of a single `FHitResult`. All other inputs are the same.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`LineTraceSingleByChannel`函数与`LineTraceMultiByChannel`函数在输入方面的唯一区别是，后者必须接收一个`TArray<FHitResult>`输入，而不是单个`FHitResult`。所有其他输入都是相同的。'
- en: Multi Line Traces are very useful when simulating the behavior of bullets with
    strong penetration that can go through several objects before stopping completely.
    Keep in mind that you can also do Multi Sweep Traces by calling the `SweepMultiByChannel`
    function.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 多行轨迹在模拟具有强穿透力的子弹行为时非常有用，这些子弹可以在完全停止之前穿过几个对象。请记住，您也可以通过调用`SweepMultiByChannel`函数来进行多扫描轨迹。
- en: Note
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Another thing about the `LineTraceSingleByChannel` function that you might be
    wondering about is the `ByChannel` portion. This distinction has to do with using
    a Trace Channel, as opposed to the alternative, which is an Object Type. You can
    do a Line Trace that uses Object Types instead of Trace Channels by calling the
    `LineTraceSingleByObjectType` function, also available from the `World` object.
    Object Types are related to topics we will be covering in the following chapter,
    so we won’t be going into detail on this function just yet.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`LineTraceSingleByChannel`函数，您可能还想知道的另一件事是`ByChannel`部分。这种区别与使用轨迹通道有关，而不是替代方案，即对象类型。您可以通过调用`LineTraceSingleByObjectType`函数（也来自`World`对象）来进行使用对象类型而不是轨迹通道的行轨迹。对象类型与我们将在下一章中讨论的主题相关，所以我们现在不会详细介绍此函数。
- en: The Camera Trace Channel
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摄像机轨迹通道
- en: 'When changing our cube’s response to the `Visibility` Trace Channel, you may
    have noticed the other out-of-the-box Trace Channel: **Camera**.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 当更改我们的立方体对`Visibility`轨迹通道的响应时，您可能已经注意到了另一个现成的轨迹通道：**摄像机**。
- en: This channel is used to specify whether an object blocks the line of sight between
    the camera’s spring arm and the character it’s associated with. In order to see
    this in action, we can drag an object to our level and place it in such a way
    that it will stay between the camera and our player character.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 此通道用于指定一个对象是否阻挡了摄像机弹簧臂与其关联角色的视线。为了观察这一效果，我们可以将一个对象拖动到我们的关卡中，并放置在摄像机和我们的玩家角色之间。
- en: 'Have a look at the following example:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的例子：
- en: We duplicate the `floor` object.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们复制了`floor`对象。
- en: Note
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can easily duplicate an object in the level by holding the *Alt* key and
    dragging one of the *Move Tool*’s arrows in any direction.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过按住*Alt*键并拖动*移动工具*的任意方向箭头来轻松复制关卡中的对象。
- en: '![Figure 5.14 – Floor object being selected ](img/Figure_5.14_B18531.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.14 – 选择地板对象](img/Figure_5.14_B18531.jpg)'
- en: Figure 5.14 – Floor object being selected
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.14 – 选择地板对象
- en: 'Next, we change its **Transform** values as shown in the following figure:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们按照以下图示更改其**变换**值：
- en: '![Figure 5.15 – Updating the Transform values ](img/Figure_5.15_B18531_B18531.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.15 – 更新变换值](img/Figure_5.15_B18531_B18531.jpg)'
- en: Figure 5.15 – Updating the Transform values
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.15 – 更新变换值
- en: 'Now when you play your game, you’ll notice that when the character goes under
    our duplicated `floor` object, you won’t lose sight of the player character, but;
    the spring arm will cause the camera to move down until you can see the character,
    as follows:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你玩游戏时，你会注意到当角色穿过我们的复制`floor`对象时，你不会失去对玩家角色的视线；但是弹簧臂将导致摄像机向下移动，直到你可以看到角色，如下所示：
- en: '![Figure 5.16 – Changes in the camera angle ](img/Figure_5.16_B18531.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![图5.16 – 摄像机角度的变化](img/Figure_5.16_B18531.jpg)'
- en: Figure 5.16 – Changes in the camera angle
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.16 – 摄像机角度的变化
- en: In order to see how the spring arm’s behavior differs when an object isn’t blocking
    the `Camera` Trace Channel, change our duplicated floor’s response to the `Camera`
    channel to `Ignore` and play the level again. What will happen is that when our
    character goes under the duplicated floor, we will lose sight of the character.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了看到当对象没有阻挡`Camera`跟踪通道时弹簧臂的行为如何不同，将我们的复制地板对`Camera`通道的响应更改为`忽略`并再次播放关卡。会发生的事情是，当我们的角色穿过复制地板时，我们将失去对角色的视线。
- en: After you’ve done these steps, you can see that the `Camera` channel is used
    to specify whether an object will cause the spring arm to move the camera closer
    to the player when it intersects that object.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这些步骤之后，你可以看到`Camera`通道被用来指定一个对象是否会在与该对象相交时使弹簧臂将摄像机移动到玩家更近的位置。
- en: Now that we know how to use the existing Trace Channels, what if we wanted to
    create our own Trace Channels?
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何使用现有的跟踪通道，如果我们想创建自己的跟踪通道怎么办？
- en: 'Exercise 5.05: Creating a custom EnemySight Trace Channel'
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.05：创建自定义的EnemySight跟踪通道
- en: 'As we’ve discussed before, UE5 comes with two out-of-the-box Trace Channels:
    `Visibility` and `Camera`. The first one is a general-use channel that we can
    use to specify which objects block the line of sight of an object, whereas the
    second one allows us to specify whether an object blocks the line of sight between
    the camera’s spring arm and the character it’s associated with.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前讨论的，UE5自带两个现成的跟踪通道：`Visibility`和`Camera`。第一个是一个通用通道，我们可以用它来指定哪些对象会阻挡一个对象的视线，而第二个允许我们指定一个对象是否阻挡了摄像机弹簧臂和与之关联的角色之间的视线。
- en: 'But how can we create our own Trace Channels? That’s what we’ll be looking
    into in this exercise. We will create a new `EnemySight` Trace Channel and use
    it to check whether the enemy can see the player character, instead of the built-in
    `Visibility` channel, as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们如何创建自己的跟踪通道呢？这正是我们将在这个练习中探讨的。我们将创建一个新的`EnemySight`跟踪通道，并使用它来检查敌人是否可以看到玩家角色，而不是使用内置的`Visibility`通道，如下所示：
- en: Open **Project Settings** by pressing the **Edit** button at the top-left corner
    of the editor and go to the **Collision** section. There you’ll find the **Trace
    Channels** section. It’s currently empty because we haven’t yet created any of
    our own Trace Channels.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按编辑器左上角的**编辑**按钮打开**项目设置**，然后转到**碰撞**部分。在那里你会找到**跟踪通道**部分。目前它是空的，因为我们还没有创建任何自己的跟踪通道。
- en: Select the `EnemySight` and set its default response to `Block`, because we
    want most objects to do exactly that.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`EnemySight`并将其默认响应设置为`Block`，因为我们希望大多数对象都这样做。
- en: 'After you’ve created the new Trace Channel, we must go back to our `EnemyCharacter`
    C++ class and change the trace we’re comparing against in our Line Trace, as follows:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你创建了新的跟踪通道之后，我们必须回到我们的`EnemyCharacter` C++类，并更改我们在线跟踪中比较的跟踪，如下所示：
- en: '[PRE36]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Given that we are no longer using the `Visibility` channel, we must reference
    our new channel. But how do we do that?
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不再使用`Visibility`通道，我们必须引用我们新的通道。但我们应该怎么做呢？
- en: In your project’s directory, you’ll find the `Config` folder. This folder contains
    several `ini` files related to your project, such as `DefaultGame.ini`, `DefaultEditor.ini`,
    `DefaultEngine.ini`, and so on. Each of these contains several properties that
    will be initialized when the project is loaded. The properties are set by name-value
    pairs (`property=value`), and you can change their values as desired.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的项目目录中，你会找到名为`Config`的文件夹。这个文件夹包含与你的项目相关的多个`ini`文件，例如`DefaultGame.ini`、`DefaultEditor.ini`、`DefaultEngine.ini`等等。每个文件都包含一些属性，这些属性将在项目加载时被初始化。属性通过名称-值对（`property=value`）设置，你可以根据需要更改它们的值。
- en: 'When we created our `EnemySight` channel, the project’s `DefaultEngine.ini`
    file was updated with our new Trace Channel. Somewhere in that file, you’ll find
    the following line:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们创建我们的`EnemySight`通道时，项目的`DefaultEngine.ini`文件被更新以包含我们的新跟踪通道。在该文件中的某个地方，你会找到以下行：
- en: '[PRE37]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The preceding code line can be found highlighted at the following link: [https://packt.live/3eFpz5r](https://packt.live/3eFpz5r).'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码行可以在以下链接中找到并高亮显示：[https://packt.live/3eFpz5r](https://packt.live/3eFpz5r)。
- en: 'The preceding line says that there is a custom Trace Channel called `EnemySight`
    that has a default response of `Block` and, most importantly, is available in
    C++ using the `ECC_GameTraceChannel1` value of the collision `enum` we mentioned
    earlier, `ECollisionChannel`. This is the channel we’ll be referencing in the
    following code:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 前一行提到存在一个名为 `EnemySight` 的自定义跟踪通道，其默认响应为 `Block`，并且最重要的是，在 C++ 中可以通过我们之前提到的碰撞
    `enum` 值 `ECC_GameTraceChannel1`，即 `ECollisionChannel` 来访问。这是我们将在以下代码中引用的通道：
- en: '[PRE38]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Verify that our enemy’s behavior remains the same after all of the changes we’ve
    made. This means that the enemy must still face the player character, as long
    as it’s within view of said enemy.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认在所有更改之后，敌人的行为保持不变。这意味着只要在敌人的视野范围内，敌人必须继续面向玩家角色。
- en: By completing this exercise, we now know how to make our own Trace Channels
    for any desired purpose.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，我们现在知道如何为任何所需目的创建自己的跟踪通道。
- en: Going back to our enemy character, there are still ways that we can improve
    its logic. Right now, when we fetch our enemy’s location as the start point of
    the Line Trace, that point is somewhere around the enemy’s hip, because that’s
    where the origin of the Actor is. However, that’s not usually where people’s eyes
    are, and it wouldn’t make much sense to have a humanoid character looking from
    its hip instead of its head.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的敌人角色，我们仍然有方法可以改进其逻辑。目前，当我们获取敌人的位置作为线迹的起始点时，该点位于敌人的臀部附近，因为那是角色的原点。然而，通常人们的眼睛并不在那里，让一个类人角色从臀部而不是头部看向是不合逻辑的。
- en: So, let’s change that and have our enemy character check whether it sees the
    player character starting from its eyes, instead of its hip.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们改变这一点，让我们的敌人角色从眼睛而不是臀部开始检查它是否看到玩家角色。
- en: 'Activity 5.01: Creating the SightSource property'
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 5.01：创建 SightSource 属性
- en: In this activity, we will be improving our enemy’s logic to determine whether
    it should look at the player. Currently, the Line Trace that’s being done to determine
    that is being *shot* from around our character’s hips, (`0,0,0`) in our `BP_EnemyCharacter`
    blueprint. We want this to make a bit more sense, so we’ll make it so that the
    Line Trace starts somewhere close to our enemy’s eyes.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在此活动中，我们将改进敌人的逻辑，以确定它是否应该看向玩家。目前，用于确定这一点的线迹是从我们 `BP_EnemyCharacter` 蓝图中的角色臀部（`0,0,0`）发出的，我们希望这能更有意义，因此我们将使其从敌人的眼睛附近开始。
- en: 'The following steps will help you complete the activity:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成活动：
- en: Declare a new `SceneComponent` in our `EnemyCharacter` C++ class called `SightSource`.
    Make sure to declare this as a `UPROPERTY` with the `VisibleAnywhere`, `BlueprintReadOnly`,
    `Category = LookAt`, and `meta = (AllowPrivateAccess = “true”)` tags.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 `EnemyCharacter` C++ 类中声明一个新的 `SceneComponent`，命名为 `SightSource`。请确保将其声明为
    `UPROPERTY`，并带有 `VisibleAnywhere`、`BlueprintReadOnly`、`Category = LookAt` 和 `meta
    = (AllowPrivateAccess = “true”)` 标签。
- en: Create this component in the `EnemyCharacter` constructor by using the `CreateDefaultSubobject`
    function, and attach it to `RootComponent`.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `EnemyCharacter` 构造函数中通过使用 `CreateDefaultSubobject` 函数创建此组件，并将其附加到 `RootComponent`。
- en: Change the start location of the Line Trace in the `CanSeeActor` function to
    the `SightSource` component’s location, instead of the Actor’s location.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `CanSeeActor` 函数中线迹的起始位置更改为 `SightSource` 组件的位置，而不是角色的位置。
- en: Open the `BP_EnemyCharacter` Blueprint Class and change the `SightSource` component’s
    location to the location of the enemy’s head, `10, 0, 80`, as was done in the
    *Creating the EnemyCharacter Blueprint Class* section to the `SkeletalMeshComponent`
    property of `BP_EnemyCharacter`.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `BP_EnemyCharacter` 蓝图类，并将 `SightSource` 组件的位置更改为敌人的头部位置，`10, 0, 80`，正如在
    *创建 EnemyCharacter 蓝图类* 部分中对 `BP_EnemyCharacter` 的 `SkeletalMeshComponent` 属性所做的那样。
- en: '**Hint**: This can be achieved from the **Transform** tab in the **Editor panel**
    as shown in *Figure 5.17*.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**：这可以通过如图 5.17 所示的 **编辑器面板** 中的 **变换** 选项卡来实现。'
- en: '![Figure 5.17 – Updating the SightSource component’s values ](img/Figure_5.17_B18531.jpg)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.17 – 更新 SightSource 组件的值](img/Figure_5.17_B18531.jpg)'
- en: Figure 5.17 – Updating the SightSource component’s values
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.17 – 更新 SightSource 组件的值
- en: 'The following is the expected output:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为预期输出：
- en: '![Figure 5.18 – The expected output showing the updated Line Trace from the
    hip to the eye ](img/Figure_5.18_B18531.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.18 – 显示从臀部到眼睛的更新后的线迹的预期输出](img/Figure_5.18_B18531.jpg)'
- en: Figure 5.18 – The expected output showing the updated Line Trace from the hip
    to the eye
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.18 – 显示从臀部到眼睛的更新后的线迹的预期输出
- en: Note
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution for this activity can be found on GitHub here: [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions).'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在 GitHub 上找到：[https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions)。
- en: By completing this activity, we have updated our `SightSource` property for
    our `EnemyCharacter`.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个活动，我们已经更新了我们的 `SightSource` 属性，用于我们的 `EnemyCharacter`。
- en: Summary
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'By completing this chapter, you have added a new tool to your belt: Line Traces.
    You now know how to execute Line Traces and Sweep Traces, both Single and Multi,
    how to change an object’s response to a specific Trace Channel, and how to create
    your own Trace Channels.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这一章节，你已经在你的工具箱中增加了一个新工具：线迹。你现在知道如何执行单线和多线迹，如何改变对象对特定迹通道的响应，以及如何创建你自己的迹通道。
- en: You will quickly realize in the following chapters that these are essential
    skills when it comes to game development, and you will make good use of them on
    your future projects.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，你将很快意识到这些是游戏开发中的基本技能，你将在未来的项目中很好地利用它们。
- en: Now that we know how to use Line Traces, we’re ready for the next step, which
    is Object Collision. In the following chapter, you will learn how to set up collisions
    between objects and how to use collision events to create your own game logic.
    You will create the Dodgeball Actor, which will be affected by real-time physics
    simulation, the Wall Actors, which will block both the characters’ movements and
    the dodgeball, and the Actor responsible for ending the game when the player comes
    into contact with it.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何使用线迹，我们就可以进入下一步，也就是物体碰撞。在接下来的章节中，你将学习如何设置物体之间的碰撞，以及如何使用碰撞事件来创建你自己的游戏逻辑。你将创建躲避球演员，它将受到实时物理模拟的影响，墙壁演员将阻止角色和躲避球的活动，以及负责在玩家与之接触时结束游戏的演员。
