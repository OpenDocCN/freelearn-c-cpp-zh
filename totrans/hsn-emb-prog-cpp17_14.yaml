- en: Developing for Hybrid SoC/FPGA Systems
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为混合SoC/FPGA系统开发
- en: In addition to standard CPU-based embedded systems, an increasingly common approach
    has been to combine CPUs in the form of SoCs with **Field Programmable Gate Arrays**
    (**FGPAs**). This allows CPU-intensive algorithms and processing, including DSP
    and image processing, to be implemented on the FPGA part of the system, with the
    CPU side handling less intensive tasks, such as user interaction, storage, and
    networking.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基于标准CPU的嵌入式系统之外，一种越来越常见的做法是将SoC形式的CPU与**现场可编程门阵列**（**FGPAs**）相结合。这允许在系统的FPGA部分实现CPU密集型算法和处理，包括DSP和图像处理，而CPU端处理较不密集的任务，如用户交互、存储和网络。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: How to communicate with the FPGA side of a hybrid FPGA/SoC system
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何与混合FPGA/SoC系统的FPGA端进行通信
- en: Learning how a variety of algorithms are implemented in FPGA and used from the
    SoC side
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何在FPGA中实现各种算法，并从SoC端使用它们
- en: How to implement a basic oscilloscope on a hybrid FPGA/SoC system
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在混合FPGA/SoC系统上实现基本示波器
- en: Going extremely parallel
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 极度并行化
- en: When it comes to performance, executing a single instruction at a time on a
    single-core processor is essentially the slowest way you can implement an algorithm
    or other functionality. From here, you can scale this singular execution flow
    to multiple flows using simultaneous scheduling on a single processor core's individual
    functional units.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到性能时，在单核处理器上一次执行一条指令基本上是您可以实施算法或其他功能的最慢方式。从这里，您可以通过在单个处理器核心的各个功能单元上同时调度来将这种单一执行流程扩展到多个流程。
- en: The next step to increase performance is to add more cores, which of course
    complicates the scheduling even more, and introduces potential latency issues
    with critical tasks being postponed because less critical tasks are blocking resources.
    The use of general purpose processors is also very limiting for certain tasks,
    especially those that are embarrassingly parallel.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 提高性能的下一步是添加更多核心，这当然会使调度更加复杂，并引入潜在的延迟问题，因为次要任务阻塞资源，导致关键任务被推迟。对于某些任务，特别是那些令人尴尬的并行任务，使用通用处理器也非常有限。
- en: For tasks where a single large dataset has to be processed using the same algorithm
    applied to each element in the set, the use of **general-purpose graphical processor
    unit-based** processing (**GPGPU**) has become very popular, along with the use
    of **Digital Signal Processors** (**DSPs**) to massively speed up a range of operations
    by using specialized hardware.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于必须使用对集合中每个元素应用相同算法的单个大数据集进行处理的任务，基于**通用图形处理器单元**（**GPGPU**）的处理以及使用**数字信号处理器**（**DSPs**）通过使用专用硬件大幅加快一系列操作的使用变得非常流行。
- en: On the other side of this issue are the tasks, which are massively parallel,
    but involve many dissimilar operations being performed on incoming data, internal
    data, or both. This is level of complexity that it would be extremely hard to
    get any reasonable performance for if implemented purely in software for a range
    of microprocessor cores.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题的另一边是任务，这些任务是高度并行的，但涉及在传入数据、内部数据或两者上执行许多不同的操作。这种复杂程度，如果仅用软件在一系列微处理器核心上实现，将非常难以获得任何合理的性能。
- en: The use of expensive DSP hardware might help here, but even that would not be
    optimized for the task. Traditionally, this would be the point where a company
    might consider having a custom **integrated circuit** (**IC**) designed and produced
    as an **application-specific integrated circuit** (**ASIC**). The costs for this
    are, however, extremely high, and only realistic for large-volume production where
    it could compete with other options.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 使用昂贵的DSP硬件可能有所帮助，但即使那样，也不会针对该任务进行优化。传统上，这可能是公司考虑设计并生产定制**集成电路**（**IC**）作为**专用集成电路**（**ASIC**）的点。然而，这种成本非常高，只有在大规模生产中才是现实的，这样它才能与其他选项竞争。
- en: Over time, different solutions were invented to make such custom hardware implementations
    more realistic, one of which was the development of the programmable logic chip.
    A system like the Commodore 64, for example, contained a **PLA** (short for **Programmable
    Logic Array**, originally a Signetics 82S100) chip, which was a one-time programmable
    array of combinatorial logic elements. It allowed the processor to reconfigure
    the on-board routing of the address bus to change what parts of the DRAM memory
    chips, ROM chips, and other peripherals were in the active addressing space.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，发明了不同的解决方案，以使这种定制硬件实现更加现实，其中之一是可编程逻辑芯片的发展。例如，Commodore 64这样的系统包含一个**PLA**（可编程逻辑阵列的简称，最初是Signetics
    82S100）芯片，这是一个一次性可编程的组合逻辑元件阵列。它允许处理器重新配置地址总线上的板载路由，以改变哪些部分DRAM内存芯片、ROM芯片和其他外围设备处于活动寻址空间中。
- en: After programming the PLA, it functioned in essentially the same way as a large
    number of 74-logic chips (discrete logic chips), but in a fraction of the space
    required for such a discrete solution. This approach essentially gave Commodore
    their very own custom ASIC, but without having to invest money in having to design
    and produce it. Instead, they used an off-the-shelf part, and were free to make
    improvements to the logic burned into the PLA chip during the lifetime of the
    Commodore 64.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 编程PLA后，它基本上以与大量74逻辑芯片（离散逻辑芯片）相同的方式工作，但所需的离散解决方案空间仅为其一小部分。这种方法实际上为Commodore提供了他们自己的定制ASIC，但无需投资设计和生产。相反，他们使用现成的部件，并且可以在Commodore
    64的整个生命周期内对烧录到PLA芯片中的逻辑进行改进。
- en: Over time, PLAs (also referred to as PAL**s**) became more advanced, developing
    into **Complex Programmable Logic Devices** (**CPLDs**), which are based around
    macrocells, which allow for the implementation of more advanced features instead
    of just simple combinatorial logic. These eventually evolved into FPGAs, which
    again add more advanced features and peripherals.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，，PLA（也称为PALs）变得更加先进，发展成为**复杂可编程逻辑器件**（CPLDs），它们基于宏单元，允许实现比简单的组合逻辑更高级的功能。这些最终演变成了FPGA，它们再次增加了更多高级功能和外围设备。
- en: These days, FPGAs are found almost everywhere where some kind of advanced processing
    or control is required. Video and audio-processing equipment often use FPGAs alongside
    DSPs, with an MCU or SoC handling the user interface and other low-priority functionality.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些天，FPGA几乎无处不在，只要有某种高级处理或控制需求。视频和音频处理设备通常与DSP一起使用FPGA，由微控制器（MCU）或片上系统（SoC）处理用户界面和其他低优先级功能。
- en: Today, devices such as oscilloscopes are implemented with an analog (and digital,
    if supported) frontend, with DSPs doing the raw converting of data and the initial
    processing of this data prior to handing it over to one or more FPGAs , which
    perform further processing and analysis of the data. After processing, this data
    can be stored in a buffer (the "digital storage" part of a **digital storage oscilloscope**
    (**DSO**) as well as handed over to the frontend, where the software running on
    the SoC will render it in the user interface and allow the user to input commands
    manipulation the displayed data.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，示波器等设备采用模拟（如果支持，则包括数字）前端，由数字信号处理器（DSPs）进行原始数据转换和该数据的初步处理，然后将数据传递给一个或多个现场可编程门阵列（FPGAs），这些FPGAs对数据进行进一步的处理和分析。处理完毕后，这些数据可以存储在缓冲区中（数字存储示波器（DSO）的“数字存储”部分）以及传递到前端，在那里运行在片上系统（SoC）上的软件将在用户界面中渲染它，并允许用户输入命令来操作显示的数据。
- en: In this chapter, we will look at a basic oscilloscope project that will be implemented
    using simple hardware and an FPGA programmed using VHDL code.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨一个基本的示波器项目，该项目将使用简单的硬件和VHDL代码编程的FPGA来实现。
- en: Hardware description languages
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 硬件描述语言
- en: As the complexity of **Very Large Scale Integrated** (**VLSI**) circuits increased
    over the past decades, it became more and more crucial to find ways to improve
    the development process, including the ability to verify the design. This led
    to the development of **hardware description languages** (**HDL****s**), of which
    today VHDL and Verilog are the two most commonly used ones.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 随着过去几十年中**超大规模集成电路**（VLSI）的复杂性增加，找到改进开发过程的方法变得越来越重要，包括验证设计的能力。这导致了**硬件描述语言**（HDLs）的发展，其中VHDL和Verilog是目前最常用的两种。
- en: The main purpose of HDLs is to allow a developer to easily describe hardware
    circuits of the type that would be integrated into ASICs or used to program FPGAs
    with. In addition, these HDLs also make it possible to simulate the design and
    to validate its functional correctness.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: HDLs（硬件描述语言）的主要目的是允许开发者轻松描述那些将被集成到ASICs中或用于编程FPGAs的硬件电路。此外，这些HDLs还使得设计模拟和验证其功能正确性成为可能。
- en: In this chapter, we will look at an example that uses VHDL for the side of the
    programming that is implemented on the FPGA. **VHSIC Hardware Description Language**
    (**VHDL**) as a language first appeared in 1983, when it was developed by the
    US Department of Defense. It was intended to act as a way to document the behavior
    of ASICs that suppliers would provide with equipment.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨一个使用VHDL实现FPGA编程侧的示例。**VHSIC硬件描述语言**（**VHDL**）作为一种语言首次出现在1983年，当时由美国国防部开发。它的目的是作为一种方式来记录供应商提供的与设备一起提供的ASICs的行为。
- en: Over time, the idea was broached that these documentation files could be used
    to simulate the behavior of the ASICs. This development was soon followed by the
    development of synthesis tools, to create a functional hardware implementation
    that could be used to create ASICs.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，有人提出这些文档文件可以用来模拟ASICs的行为。这一发展很快就被合成工具的开发所跟随，以创建一个功能硬件实现，可以用来创建ASICs。
- en: VHDL is heavily based on the Ada programming language, which itself also has
    its roots in the US military. Although VHDL is primarily used as an HDL, it can
    also be used as a generic programming language, much like Ada and its kin.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: VHDL语言在很大程度上基于Ada编程语言，而Ada编程语言本身也起源于美国军事。尽管VHDL主要用作HDL，但它也可以用作通用编程语言，类似于Ada及其同类语言。
- en: FPGA architecture
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FPGA架构
- en: 'Though not every FPGA is structured the same way, the general principle remains
    the same: they are arrays of logic elements that can be configured to form specific
    circuits. The complexity of these **logic elements** (**LEs**) therefore determines
    what kind of logic circuits can be formed, which has to be taken into account
    when writing VHDL code for a specific FPGA architecture.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不是每个FPGA的结构都相同，但一般原则是相同的：它们是由逻辑元素组成的阵列，可以配置成特定的电路。因此，这些**逻辑元素**（**LEs**）的复杂性决定了可以形成哪种逻辑电路，这在为特定FPGA架构编写VHDL代码时必须考虑。
- en: The terms **logic elements** (**LEs**) and **logic cells** (**LCs**) are used
    interchangeably. An LE consists of one or more **look-up tables** (**LUTs**),
    with an LUT usually having between four and six inputs. Regardless of the exact
    configuration, each LE is surrounded by interconnection logic, which allows different
    LEs to be connected to each other, and the LE itself is programmed to a specific
    configuration, thus forming the intended circuit.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**逻辑元素**（**LEs**）和**逻辑单元**（**LCs**）这两个术语可以互换使用。一个LE由一个或多个**查找表**（**LUTs**）组成，一个LUT通常有四个到六个输入。无论具体配置如何，每个LE都由互连逻辑包围，这允许不同的LE相互连接，并且LE本身被编程到特定的配置，从而形成预期的电路。'
- en: This potential pitfalls of developing for FPGAs include the strong assumption
    by FPGA manufacturers that FPGAs will be used with clocked designs (using a central
    clock source and clock domains), instead of combinatorial (unclocked) logic. In
    general, it's a good idea to familiarize yourself with a target FPGA system prior
    to including it in a new project to see how well it can support the features that
    you need.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为FPGA开发可能存在的潜在问题包括FPGA制造商强烈假设FPGA将用于带时钟的设计（使用中央时钟源和时钟域），而不是组合逻辑（无时钟）。一般来说，在将目标FPGA系统包含在新项目之前熟悉它是一个好主意，以了解它如何支持你所需要的特性。
- en: Hybrid FPGA/SoC chips
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合FPGA/SoC芯片
- en: Although systems that include both an FPGA and SoC have been very common for
    years, a more recent addition has been hybrid FPGA/SoC chips, which include the
    dies for both an FPGA and an SoC (usually ARM based) in the same package. These
    are then linked together with a bus so that both can efficiently communicate with
    each other using memory-mapped I/O and similar.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管包含FPGA和SoC的系统多年来一直非常普遍，但最近的一个新加入的是混合FPGA/SoC芯片，这些芯片在同一封装中包含FPGA和SoC（通常是基于ARM）的晶圆。然后通过总线将它们连接起来，以便两者可以高效地通过内存映射I/O和类似方式相互通信。
- en: 'Common examples of such FPGAs currently include Altera (now Intel), Cyclone
    V SoC, and Xilinx Zynq. The Cyclone V SoC''s block diagram from the official datasheet
    gives a good overview of how such a system works:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 目前此类FPGA的常见例子包括Altera（现在是英特尔）、Cyclone V SoC和Xilinx Zynq。Cyclone V SoC的官方数据手册中的框图给出了此类系统工作原理的良好概述：
- en: '![](img/00dec7ee-3feb-4111-97b6-898f96f9b83c.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00dec7ee-3feb-4111-97b6-898f96f9b83c.png)'
- en: Here, we can see that there are a number of ways that the **Hard Processor System**
    (**HPS**) and FPGA sides can communicate with each other, such as via a shared
    SDRAM controller, two point-to-point links, and a number of other interfaces.
    For the Cyclone V SoC, either the FPGA or SoC side can be the first side that
    boots when the system starts, allowing for a wide range of system configuration
    options.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到**硬处理器系统**（**HPS**）和FPGA侧之间有多种通信方式，例如通过共享SDRAM控制器、两个点对点链路和多个其他接口。对于Cyclone
    V SoC，系统启动时可以是FPGA或SoC侧的第一个启动侧，从而提供广泛的系统配置选项。
- en: Example – basic oscilloscope
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 – 基本示波器
- en: This example gives a basic overview of how one could use an FPGA in an embedded
    project. It uses the FPGA to sample an input and measure a voltage or similar,
    the way an oscilloscope would. The resulting ADC data is then sent over a serial
    link to a C++/Qt-based application, which displays the data.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 本例提供了一个基本概述，说明如何在嵌入式项目中使用FPGA。它使用FPGA来采样输入并测量电压或类似内容，就像示波器一样。然后，将生成的ADC数据通过串行链路发送到基于C++/Qt的应用程序，该程序显示数据。
- en: The hardware
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 硬件
- en: 'For the project, we will use a Fleasystems FleaFPGA Ohm board ([http://fleasystems.com/fleaFPGA_Ohm.html](http://fleasystems.com/fleaFPGA_Ohm.html)).
    This is a small, sub-$50, sub-€40 FPGA development board in a Raspberry Pi Zero
    form factor:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于该项目，我们将使用Fleasystems FleaFPGA Ohm板([http://fleasystems.com/fleaFPGA_Ohm.html](http://fleasystems.com/fleaFPGA_Ohm.html))。这是一款小型、低于50美元、低于40欧元的FPGA开发板，采用树莓派Zero外形：
- en: '![](img/0fb4d23c-b3e9-437b-8891-ac36d9abeb84.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0fb4d23c-b3e9-437b-8891-ac36d9abeb84.png)'
- en: 'It has the following specifications:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 它具有以下规格：
- en: '**Lattice ECP5 FPGA** with 24K LUT elements and 112KB Block RAM.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Lattice ECP5 FPGA**，具有24K LUT元素和112KB块RAM。'
- en: '**256-Mbit SDRAM**, 16 bits wide and 167 MHz clock.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**256-Mbit SDRAM**，16位宽，167 MHz时钟。'
- en: '**8-Mbit SPI Flash ROM** for FPGA configuration storage.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**8-Mbit SPI闪存**用于FPGA配置存储。'
- en: 25 MHz Crystal oscillator.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 25 MHz晶振振荡器。
- en: '**HDMI video** out (up to 1080p30 or 720p60 screen modes possible).'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HDMI视频输出**（支持高达1080p30或720p60的屏幕模式）。'
- en: '**μSD card slot**.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**μSD卡槽**。'
- en: Two micro USB host ports with alternate PS/2 host port functionality.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个微USB主机端口，具有备用PS/2主机端口功能。
- en: 29 user GPIO, including 4 x medium-speed ADC inputs and 12 x LVDS signal pairs
    available from the (Raspberry Pi compatible) 40-pin expansion, and 2-pin reset
    headers, respectively.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 29个用户GPIO，包括来自（与树莓派兼容的）40引脚扩展的4个中等速度ADC输入和12个LVDS信号对，以及2引脚复位引脚。
- en: One micro USB slave port. Provides +5V supply feed to the Ohm, serial console/UART
    communications, as well as access to the on-board JTAG programming interface (for
    configuring the ECP5 FPGA).
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个微USB从端口。为Ohm提供+5V电源馈电，串行控制台/UART通信，以及访问板上的JTAG编程接口（用于配置ECP5 FPGA）。
- en: Provision for an external JTAG programming pod to allow real-time debugging.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供外部JTAG编程模块，以便进行实时调试。
- en: 'To this board, we connect circuit which will allow us to connect an oscilloscope
    probe:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将电路连接到该板，以便我们可以连接示波器探头：
- en: '![](img/be8609a6-c88d-4c76-95aa-3bfdebfdb919.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/be8609a6-c88d-4c76-95aa-3bfdebfdb919.png)'
- en: This circuit will be connected to pin number 29 on the Ohm board's GPIO header,
    corresponding to GPIO 5\. It allows us to measure 0 to 3V DC signals, and 1.5V
    AC (RMS), in 1 x probe measurement mode. Bandwidth is a little over 10 MHz.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 该电路将连接到Ohm板GPIO引脚的29号引脚，对应GPIO 5。它允许我们测量0到3V直流信号，以及1.5V交流（均方根值），在1 x探头测量模式下。带宽略超过10
    MHz。
- en: The VHDL code
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VHDL代码
- en: 'In this section, we will take a look at the top-level entity in the VHDL project,
    to get an idea of what it does. This starts with the standard library includes
    for VHDL as shown:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看VHDL项目中的顶层实体，以了解其功能。这从VHDL的标准库包含开始，如下所示：
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This maps to the underlying FPGA''s system clock and reset line. We can also
    see the way that port mapping works, defining the direction of the entity port
    and the type. Here, the type is `std_logic`, which is a standard logic signal
    of either a binary one or zero:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这对应于底层FPGA的系统时钟和复位线。我们还可以看到端口映射的方式，定义了实体端口的方向和类型。在这里，类型是`std_logic`，它是一个标准的逻辑信号，可以是二进制的一位或零：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We also use the status LED on the board, map the HDMI's video pins (LVDS signaling),
    and the UART interface, which uses the FDTI USB-UART chip on the board. The latter
    is what we will be using to send the data from the FPGA to the C++ application.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用板上的状态LED，映射HDMI的视频引脚（LVDS信号），以及UART接口，该接口使用板上的FDTI USB-UART芯片。后者是我们将用于从FPGA向C++应用程序发送数据的方式。
- en: 'Next, the Raspberry Pi compatible header mapping, as shown in the following
    code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，是Raspberry Pi兼容的引脚映射，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The reason that GPIO 5 is commented out is because we want to use it for the
    ADC functionality and not general-purpose input/output.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO 5被注释掉的原因是我们想用它来实现ADC功能，而不是通用输入/输出。
- en: 'Instead, we enable the sigma-delta-capable ADC3 peripheral to work on that
    pin as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们使具有sigma-delta功能的ADC3外设在该引脚上工作如下：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here, we see that we have another three ADC peripherals that we could use if
    we wanted to add additional channels to the oscilloscope , as shown in the following
    code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到我们还有另外三个ADC外设，如果我们想为示波器添加更多通道，可以使用它们，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The entity definition for the top-level ends with the MMC (SD card) and PS2
    interfaces.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 顶层实体定义以MMC（SD卡）和PS2接口结束。
- en: 'Next is the architecture definition of the module. This part is akin to the
    source file of a C++ application, with the entity definition functioning like
    a header as shown:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是模块的架构定义。这部分类似于C++应用程序的源文件，实体定义的作用类似于头文件，如下所示：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: A number of signals are defined here. These allow us to connect the ports, entities,
    processes, and other elements of a VHDL module with each other.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里定义了多个信号。这些信号使我们能够将VHDL模块的端口、实体、进程和其他元素相互连接。
- en: 'We can see that some signals are defined here for VGA support. This allows
    compatibility with VGA-enabled FPGA boards, but parts of it are also compatible
    with the HDMI (or a DVI) peripheral, as we will see in a moment. Let''s look at
    the following code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，这里定义了一些信号以支持VGA。这允许与启用VGA的FPGA板兼容，但其中一部分也与HDMI（或DVI）外设兼容，正如我们稍后将看到的。让我们看看下面的代码：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With the `begin` keyword, we indicate that this is the point where we want to
    start executing the commands in the architecture definition. Everything after
    this keyword and the terminating keyword (`end architecture`) will be executed
    simultaneously, unless a block of instructions is encapsulated within a `process`
    (not shown in this code).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`begin`关键字，我们表明这是我们要开始执行架构定义中命令的点。除非一个指令块被封装在一个`process`（在此代码中未显示）中，否则此关键字之后以及终止关键字（`end
    architecture`）之后的所有内容都将同时执行。
- en: 'We disable a number of hardware features by writing to the appropriate pins.
    We omitted the DRAM (external memory) section in the earlier entity definition
    for brevity''s sake. The DRAM and SD card functionality are disabled, while PS2
    (keyboard, mouse) functionality is enabled. This allows us to connect a PS2 input
    device if we wanted to:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过写入适当的引脚来禁用多个硬件功能。为了简洁起见，我们在早期的实体定义中省略了DRAM（外部内存）部分。禁用了DRAM和SD卡功能，同时启用了PS2（键盘、鼠标）功能。这允许我们在需要时连接PS2输入设备：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we define that we will be using an instance of the FleaFPGA Digital Storage
    Oscilloscope module. Only the first channel is mapped, though the module could
    support four channels. This simplification helps to demonstrate the principle
    of operation.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义我们将使用FleaFPGA数字存储示波器模块的一个实例。尽管该模块可以支持四个通道，但只有第一个通道被映射。这种简化有助于演示操作原理。
- en: 'The DSO module is responsible for reading out the data from the ADC as it samples
    the signal we''re measuring with the probe, and both renders it to a local cache
    for display on a local (HDMI or VGA) monitor and send it over the serial interface
    to the UART module (shown at the end of this section). . Let''s look at the following
    code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: DSO模块负责读取ADC的数据，同时它采样我们用探针测量的信号，并将它渲染到本地缓存以在本地（HDMI或VGA）显示器上显示，并通过串行接口发送到UART模块（在本节末尾显示）。让我们看看下面的代码：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here, the final colors for the display output are determined with the HDMI
    output signal:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，最终显示输出颜色由HDMI输出信号确定：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This whole section serves to output the video signal that gets generated by
    the DSO module, allowing us to also use the FPGA board as a standalone oscilloscope
    unit:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 整个这一部分用于输出由DSO模块生成的视频信号，使我们也能将FPGA板作为独立的示波器单元使用：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Finally, the simple UART implementation that allows the DSO module to communicate
    with our C++ application.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，简单的UART实现允许DSO模块与我们的C++应用程序通信。
- en: The UART is configured to work at a baud rate of 19,200, 8 bits, 1 stop bit,
    and no parity. After building this VHDL project and programming the FPGA board
    with it, we can connect to it over this serial connection.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: UART配置为以19,200波特率、8位、1停止位和无奇偶校验位工作。在构建此VHDL项目并用它编程FPGA板之后，我们可以通过这个串行连接连接到它。
- en: The C++ code
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++代码
- en: While the VHDL code implements a simple display output with basic input options,
    if we want to have a large (high-resolution) display, perform signal analysis,
    make recordings of multiple minutes or even hours, and so on, it will be very
    convenient to be able to do this on an SBC.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然VHDL代码实现了简单的显示输出和基本输入选项，但如果我们要有一个大（高分辨率）的显示，进行信号分析，记录几分钟甚至几小时的数据等，那么在SBC上执行这些操作将非常方便。
- en: The following code is written as a C++/Qt graphical application that takes in
    the raw ADC data from the FPGA board and displays it in a graph. While barebones,
    it provides the framework for a full-featured, SoC-based system.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是一个C++/Qt图形应用程序，它从FPGA板接收原始ADC数据并在图表中显示。虽然基础，但它为功能齐全、基于SoC的系统提供了框架。
- en: 'First, the header is shown, as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，展示头文件如下：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we can see that we will be using the serial port implementation in Qt,
    along with the QChart module, for the visualization part.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们将使用Qt中的串行端口实现以及QChart模块来进行可视化部分。
- en: 'The implementation is shown in the following code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 实现如下所示：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the constructor, we create the connections with the menu options in the GUI,
    which allow us to quit the application, connect to a serial port, disconnect from
    a serial port if we are connected, or get information about the application.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们创建与GUI中的菜单选项的连接，这些选项允许我们退出应用程序、连接到串行端口、如果我们已连接则断开与串行端口的连接，或获取有关应用程序的信息。
- en: We connect the serial port instance to a slot that will be called whenever new
    data is ready to be read.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将串行端口实例连接到一个槽位，每当有新数据准备好读取时，该槽位会被调用。
- en: 'Finally, we configure the chart view in the GUI, obtaining a reference to the
    QChart instance inside the QChartView widget. On this reference, we set a theme
    for the chart, add default axes, and finally, add an empty series, which we will
    be filling up with the incoming data from the FPGA , as shown in the following
    code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在GUI中配置图表视图，获取QChartView小部件内QChart实例的引用。在这个引用上，我们为图表设置主题，添加默认轴，并最终添加一个空序列，我们将用从FPGA接收到的数据填充它，如下所示：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When the user wishes to connect to the FPGA via the UART, the serial connection
    on which the FPGA is connected has to be selected, after which a connection will
    be established, with the 19,200 baud, 8N1 settings we established previously in
    the VHDL section of the project.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户希望通过UART连接到FPGA时，必须选择连接FPGA的串行连接，之后将建立连接，使用我们在项目VHDL部分之前设置的19,200波特率、8N1设置。
- en: 'For a fixed configuration where the serial port is always the same, one could
    consider automating the following part when the system boots:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于串行端口始终相同的固定配置，当系统启动时可以考虑自动化以下部分：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Disconnecting from the serial port is quite straightforward:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 断开与串行端口的连接相当直接：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When the UART receives new data from the FPGA board, this slot gets called.
    In it, we read all of the data from the UART buffer, appending it to the series
    that we added to the graph widget, which updates the displayed trace. The counter
    variable is used to provide an increasing time base for the graph. This functions
    as a simplistic timestamp here.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当UART从FPGA板接收到新数据时，这个槽位会被调用。在其中，我们读取UART缓冲区中的所有数据，将其附加到我们添加到图形小部件的序列中，从而更新显示的轨迹。计数器变量用于为图表提供递增的时间基准。这里它作为一个简单的时间戳。
- en: 'At some point, we should start removing data from the series to prevent it
    from getting too large, along with the ability to search through it and save the
    data. The counter-based timestamp could report the actual time at which we received
    the signal, though ideally this should be part of the data that we received from
    the FPGA:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时候，我们应该开始从序列中删除数据，以防止它变得太大，同时具备搜索和保存数据的能力。基于计数的时间戳可以报告我们接收信号的实际时间，尽管理想情况下这应该是我们从FPGA接收到的数据的一部分：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We end with a few simple slots. For the information dialog, we simply show the
    standard Qt information dialog. This could be replaced with a custom help or information
    dialog.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以几个简单的槽位结束。对于信息对话框，我们简单地显示标准的 Qt 信息对话框。这可以被自定义的帮助或信息对话框所替代。
- en: Building the project
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建项目
- en: The VHDL project can be built and programmed onto the Ohm FPGA board using the
    free Lattice Semiconductor Diamond IDE software ([http://www.latticesemi.com/latticediamond](http://www.latticesemi.com/latticediamond)).
    Programming the board requires that the FleaFPGA JTAG utility from [https://github.com/Basman74/FleaFPGA-Ohm](https://github.com/Basman74/FleaFPGA-Ohm)
    is installed so that Diamond can use it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用免费的 Lattice Semiconductor Diamond IDE 软件 ([http://www.latticesemi.com/latticediamond](http://www.latticesemi.com/latticediamond))，可以将
    VHDL 项目构建并编程到 Ohm FPGA 板上。编程该板需要安装来自 [https://github.com/Basman74/FleaFPGA-Ohm](https://github.com/Basman74/FleaFPGA-Ohm)
    的 FleaFPGA JTAG 工具，以便 Diamond 可以使用它。
- en: By following the instructions for the FleaFPGA Ohm board as described in the
    quick start guide, it should be relatively easy to get that part of the project
    up and running. For the C++ side, one has to make sure that the FPGA board and
    SBC (or equivalent) are connected so that the latter can access the UART on the
    former.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 按照快速入门指南中描述的 FleaFPGA Ohm 板的说明，应该相对容易使该项目的这部分运行起来。对于 C++ 方面，必须确保 FPGA 板和 SBC（或等效）连接，以便后者可以访问前者的
    UART。
- en: With this in place, simply compiling the C++ project with the Qt framework (directly
    on the SBC or preferably cross-compiling on a desktop system) suffices. After
    this, one can run the application with the flashed FPGA board active, connect
    to the UART, and observe the trace being drawn on the application window.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，只需使用 Qt 框架编译 C++ 项目（直接在 SBC 上或在桌面系统上交叉编译）就足够了。之后，可以在激活了闪存 FPGA 板的情况下运行应用程序，连接到
    UART，并观察在应用程序窗口中绘制的跟踪。
- en: Summary
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at what role FPGAs play in embedded development,
    how they have changed in importance over the past decades, and how they are now
    being used. We looked at a simple implementation of an oscilloscope that uses
    both an FPGA and an SBC-based component. Having read through this chapter, you
    should now know when to pick an FPGA for a new embedded project and understand
    how one can use and communicate with such a device.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 FPGA 在嵌入式开发中的作用，以及它们在过去几十年中重要性的变化，以及它们现在的应用。我们查看了一个简单的示波器实现，它使用了一个
    FPGA 和基于 SBC 的组件。阅读完本章后，你现在应该知道何时为新的嵌入式项目选择 FPGA，以及如何使用和与这样的设备进行通信。
