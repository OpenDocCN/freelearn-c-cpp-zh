- en: Developing for Hybrid SoC/FPGA Systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to standard CPU-based embedded systems, an increasingly common approach
    has been to combine CPUs in the form of SoCs with **Field Programmable Gate Arrays**
    (**FGPAs**). This allows CPU-intensive algorithms and processing, including DSP
    and image processing, to be implemented on the FPGA part of the system, with the
    CPU side handling less intensive tasks, such as user interaction, storage, and
    networking.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to communicate with the FPGA side of a hybrid FPGA/SoC system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how a variety of algorithms are implemented in FPGA and used from the
    SoC side
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement a basic oscilloscope on a hybrid FPGA/SoC system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Going extremely parallel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to performance, executing a single instruction at a time on a
    single-core processor is essentially the slowest way you can implement an algorithm
    or other functionality. From here, you can scale this singular execution flow
    to multiple flows using simultaneous scheduling on a single processor core's individual
    functional units.
  prefs: []
  type: TYPE_NORMAL
- en: The next step to increase performance is to add more cores, which of course
    complicates the scheduling even more, and introduces potential latency issues
    with critical tasks being postponed because less critical tasks are blocking resources.
    The use of general purpose processors is also very limiting for certain tasks,
    especially those that are embarrassingly parallel.
  prefs: []
  type: TYPE_NORMAL
- en: For tasks where a single large dataset has to be processed using the same algorithm
    applied to each element in the set, the use of **general-purpose graphical processor
    unit-based** processing (**GPGPU**) has become very popular, along with the use
    of **Digital Signal Processors** (**DSPs**) to massively speed up a range of operations
    by using specialized hardware.
  prefs: []
  type: TYPE_NORMAL
- en: On the other side of this issue are the tasks, which are massively parallel,
    but involve many dissimilar operations being performed on incoming data, internal
    data, or both. This is level of complexity that it would be extremely hard to
    get any reasonable performance for if implemented purely in software for a range
    of microprocessor cores.
  prefs: []
  type: TYPE_NORMAL
- en: The use of expensive DSP hardware might help here, but even that would not be
    optimized for the task. Traditionally, this would be the point where a company
    might consider having a custom **integrated circuit** (**IC**) designed and produced
    as an **application-specific integrated circuit** (**ASIC**). The costs for this
    are, however, extremely high, and only realistic for large-volume production where
    it could compete with other options.
  prefs: []
  type: TYPE_NORMAL
- en: Over time, different solutions were invented to make such custom hardware implementations
    more realistic, one of which was the development of the programmable logic chip.
    A system like the Commodore 64, for example, contained a **PLA** (short for **Programmable
    Logic Array**, originally a Signetics 82S100) chip, which was a one-time programmable
    array of combinatorial logic elements. It allowed the processor to reconfigure
    the on-board routing of the address bus to change what parts of the DRAM memory
    chips, ROM chips, and other peripherals were in the active addressing space.
  prefs: []
  type: TYPE_NORMAL
- en: After programming the PLA, it functioned in essentially the same way as a large
    number of 74-logic chips (discrete logic chips), but in a fraction of the space
    required for such a discrete solution. This approach essentially gave Commodore
    their very own custom ASIC, but without having to invest money in having to design
    and produce it. Instead, they used an off-the-shelf part, and were free to make
    improvements to the logic burned into the PLA chip during the lifetime of the
    Commodore 64.
  prefs: []
  type: TYPE_NORMAL
- en: Over time, PLAs (also referred to as PAL**s**) became more advanced, developing
    into **Complex Programmable Logic Devices** (**CPLDs**), which are based around
    macrocells, which allow for the implementation of more advanced features instead
    of just simple combinatorial logic. These eventually evolved into FPGAs, which
    again add more advanced features and peripherals.
  prefs: []
  type: TYPE_NORMAL
- en: These days, FPGAs are found almost everywhere where some kind of advanced processing
    or control is required. Video and audio-processing equipment often use FPGAs alongside
    DSPs, with an MCU or SoC handling the user interface and other low-priority functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Today, devices such as oscilloscopes are implemented with an analog (and digital,
    if supported) frontend, with DSPs doing the raw converting of data and the initial
    processing of this data prior to handing it over to one or more FPGAs , which
    perform further processing and analysis of the data. After processing, this data
    can be stored in a buffer (the "digital storage" part of a **digital storage oscilloscope**
    (**DSO**) as well as handed over to the frontend, where the software running on
    the SoC will render it in the user interface and allow the user to input commands
    manipulation the displayed data.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at a basic oscilloscope project that will be implemented
    using simple hardware and an FPGA programmed using VHDL code.
  prefs: []
  type: TYPE_NORMAL
- en: Hardware description languages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the complexity of **Very Large Scale Integrated** (**VLSI**) circuits increased
    over the past decades, it became more and more crucial to find ways to improve
    the development process, including the ability to verify the design. This led
    to the development of **hardware description languages** (**HDL****s**), of which
    today VHDL and Verilog are the two most commonly used ones.
  prefs: []
  type: TYPE_NORMAL
- en: The main purpose of HDLs is to allow a developer to easily describe hardware
    circuits of the type that would be integrated into ASICs or used to program FPGAs
    with. In addition, these HDLs also make it possible to simulate the design and
    to validate its functional correctness.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at an example that uses VHDL for the side of the
    programming that is implemented on the FPGA. **VHSIC Hardware Description Language**
    (**VHDL**) as a language first appeared in 1983, when it was developed by the
    US Department of Defense. It was intended to act as a way to document the behavior
    of ASICs that suppliers would provide with equipment.
  prefs: []
  type: TYPE_NORMAL
- en: Over time, the idea was broached that these documentation files could be used
    to simulate the behavior of the ASICs. This development was soon followed by the
    development of synthesis tools, to create a functional hardware implementation
    that could be used to create ASICs.
  prefs: []
  type: TYPE_NORMAL
- en: VHDL is heavily based on the Ada programming language, which itself also has
    its roots in the US military. Although VHDL is primarily used as an HDL, it can
    also be used as a generic programming language, much like Ada and its kin.
  prefs: []
  type: TYPE_NORMAL
- en: FPGA architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Though not every FPGA is structured the same way, the general principle remains
    the same: they are arrays of logic elements that can be configured to form specific
    circuits. The complexity of these **logic elements** (**LEs**) therefore determines
    what kind of logic circuits can be formed, which has to be taken into account
    when writing VHDL code for a specific FPGA architecture.'
  prefs: []
  type: TYPE_NORMAL
- en: The terms **logic elements** (**LEs**) and **logic cells** (**LCs**) are used
    interchangeably. An LE consists of one or more **look-up tables** (**LUTs**),
    with an LUT usually having between four and six inputs. Regardless of the exact
    configuration, each LE is surrounded by interconnection logic, which allows different
    LEs to be connected to each other, and the LE itself is programmed to a specific
    configuration, thus forming the intended circuit.
  prefs: []
  type: TYPE_NORMAL
- en: This potential pitfalls of developing for FPGAs include the strong assumption
    by FPGA manufacturers that FPGAs will be used with clocked designs (using a central
    clock source and clock domains), instead of combinatorial (unclocked) logic. In
    general, it's a good idea to familiarize yourself with a target FPGA system prior
    to including it in a new project to see how well it can support the features that
    you need.
  prefs: []
  type: TYPE_NORMAL
- en: Hybrid FPGA/SoC chips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although systems that include both an FPGA and SoC have been very common for
    years, a more recent addition has been hybrid FPGA/SoC chips, which include the
    dies for both an FPGA and an SoC (usually ARM based) in the same package. These
    are then linked together with a bus so that both can efficiently communicate with
    each other using memory-mapped I/O and similar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Common examples of such FPGAs currently include Altera (now Intel), Cyclone
    V SoC, and Xilinx Zynq. The Cyclone V SoC''s block diagram from the official datasheet
    gives a good overview of how such a system works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00dec7ee-3feb-4111-97b6-898f96f9b83c.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we can see that there are a number of ways that the **Hard Processor System**
    (**HPS**) and FPGA sides can communicate with each other, such as via a shared
    SDRAM controller, two point-to-point links, and a number of other interfaces.
    For the Cyclone V SoC, either the FPGA or SoC side can be the first side that
    boots when the system starts, allowing for a wide range of system configuration
    options.
  prefs: []
  type: TYPE_NORMAL
- en: Example – basic oscilloscope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This example gives a basic overview of how one could use an FPGA in an embedded
    project. It uses the FPGA to sample an input and measure a voltage or similar,
    the way an oscilloscope would. The resulting ADC data is then sent over a serial
    link to a C++/Qt-based application, which displays the data.
  prefs: []
  type: TYPE_NORMAL
- en: The hardware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the project, we will use a Fleasystems FleaFPGA Ohm board ([http://fleasystems.com/fleaFPGA_Ohm.html](http://fleasystems.com/fleaFPGA_Ohm.html)).
    This is a small, sub-$50, sub-€40 FPGA development board in a Raspberry Pi Zero
    form factor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0fb4d23c-b3e9-437b-8891-ac36d9abeb84.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It has the following specifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lattice ECP5 FPGA** with 24K LUT elements and 112KB Block RAM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**256-Mbit SDRAM**, 16 bits wide and 167 MHz clock.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**8-Mbit SPI Flash ROM** for FPGA configuration storage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 25 MHz Crystal oscillator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HDMI video** out (up to 1080p30 or 720p60 screen modes possible).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**μSD card slot**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two micro USB host ports with alternate PS/2 host port functionality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 29 user GPIO, including 4 x medium-speed ADC inputs and 12 x LVDS signal pairs
    available from the (Raspberry Pi compatible) 40-pin expansion, and 2-pin reset
    headers, respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One micro USB slave port. Provides +5V supply feed to the Ohm, serial console/UART
    communications, as well as access to the on-board JTAG programming interface (for
    configuring the ECP5 FPGA).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provision for an external JTAG programming pod to allow real-time debugging.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To this board, we connect circuit which will allow us to connect an oscilloscope
    probe:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/be8609a6-c88d-4c76-95aa-3bfdebfdb919.png)'
  prefs: []
  type: TYPE_IMG
- en: This circuit will be connected to pin number 29 on the Ohm board's GPIO header,
    corresponding to GPIO 5\. It allows us to measure 0 to 3V DC signals, and 1.5V
    AC (RMS), in 1 x probe measurement mode. Bandwidth is a little over 10 MHz.
  prefs: []
  type: TYPE_NORMAL
- en: The VHDL code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will take a look at the top-level entity in the VHDL project,
    to get an idea of what it does. This starts with the standard library includes
    for VHDL as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This maps to the underlying FPGA''s system clock and reset line. We can also
    see the way that port mapping works, defining the direction of the entity port
    and the type. Here, the type is `std_logic`, which is a standard logic signal
    of either a binary one or zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We also use the status LED on the board, map the HDMI's video pins (LVDS signaling),
    and the UART interface, which uses the FDTI USB-UART chip on the board. The latter
    is what we will be using to send the data from the FPGA to the C++ application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the Raspberry Pi compatible header mapping, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The reason that GPIO 5 is commented out is because we want to use it for the
    ADC functionality and not general-purpose input/output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, we enable the sigma-delta-capable ADC3 peripheral to work on that
    pin as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we see that we have another three ADC peripherals that we could use if
    we wanted to add additional channels to the oscilloscope , as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The entity definition for the top-level ends with the MMC (SD card) and PS2
    interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next is the architecture definition of the module. This part is akin to the
    source file of a C++ application, with the entity definition functioning like
    a header as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: A number of signals are defined here. These allow us to connect the ports, entities,
    processes, and other elements of a VHDL module with each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that some signals are defined here for VGA support. This allows
    compatibility with VGA-enabled FPGA boards, but parts of it are also compatible
    with the HDMI (or a DVI) peripheral, as we will see in a moment. Let''s look at
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With the `begin` keyword, we indicate that this is the point where we want to
    start executing the commands in the architecture definition. Everything after
    this keyword and the terminating keyword (`end architecture`) will be executed
    simultaneously, unless a block of instructions is encapsulated within a `process`
    (not shown in this code).
  prefs: []
  type: TYPE_NORMAL
- en: 'We disable a number of hardware features by writing to the appropriate pins.
    We omitted the DRAM (external memory) section in the earlier entity definition
    for brevity''s sake. The DRAM and SD card functionality are disabled, while PS2
    (keyboard, mouse) functionality is enabled. This allows us to connect a PS2 input
    device if we wanted to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we define that we will be using an instance of the FleaFPGA Digital Storage
    Oscilloscope module. Only the first channel is mapped, though the module could
    support four channels. This simplification helps to demonstrate the principle
    of operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The DSO module is responsible for reading out the data from the ADC as it samples
    the signal we''re measuring with the probe, and both renders it to a local cache
    for display on a local (HDMI or VGA) monitor and send it over the serial interface
    to the UART module (shown at the end of this section). . Let''s look at the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the final colors for the display output are determined with the HDMI
    output signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This whole section serves to output the video signal that gets generated by
    the DSO module, allowing us to also use the FPGA board as a standalone oscilloscope
    unit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the simple UART implementation that allows the DSO module to communicate
    with our C++ application.
  prefs: []
  type: TYPE_NORMAL
- en: The UART is configured to work at a baud rate of 19,200, 8 bits, 1 stop bit,
    and no parity. After building this VHDL project and programming the FPGA board
    with it, we can connect to it over this serial connection.
  prefs: []
  type: TYPE_NORMAL
- en: The C++ code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the VHDL code implements a simple display output with basic input options,
    if we want to have a large (high-resolution) display, perform signal analysis,
    make recordings of multiple minutes or even hours, and so on, it will be very
    convenient to be able to do this on an SBC.
  prefs: []
  type: TYPE_NORMAL
- en: The following code is written as a C++/Qt graphical application that takes in
    the raw ADC data from the FPGA board and displays it in a graph. While barebones,
    it provides the framework for a full-featured, SoC-based system.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the header is shown, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that we will be using the serial port implementation in Qt,
    along with the QChart module, for the visualization part.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the constructor, we create the connections with the menu options in the GUI,
    which allow us to quit the application, connect to a serial port, disconnect from
    a serial port if we are connected, or get information about the application.
  prefs: []
  type: TYPE_NORMAL
- en: We connect the serial port instance to a slot that will be called whenever new
    data is ready to be read.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we configure the chart view in the GUI, obtaining a reference to the
    QChart instance inside the QChartView widget. On this reference, we set a theme
    for the chart, add default axes, and finally, add an empty series, which we will
    be filling up with the incoming data from the FPGA , as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When the user wishes to connect to the FPGA via the UART, the serial connection
    on which the FPGA is connected has to be selected, after which a connection will
    be established, with the 19,200 baud, 8N1 settings we established previously in
    the VHDL section of the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a fixed configuration where the serial port is always the same, one could
    consider automating the following part when the system boots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Disconnecting from the serial port is quite straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: When the UART receives new data from the FPGA board, this slot gets called.
    In it, we read all of the data from the UART buffer, appending it to the series
    that we added to the graph widget, which updates the displayed trace. The counter
    variable is used to provide an increasing time base for the graph. This functions
    as a simplistic timestamp here.
  prefs: []
  type: TYPE_NORMAL
- en: 'At some point, we should start removing data from the series to prevent it
    from getting too large, along with the ability to search through it and save the
    data. The counter-based timestamp could report the actual time at which we received
    the signal, though ideally this should be part of the data that we received from
    the FPGA:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We end with a few simple slots. For the information dialog, we simply show the
    standard Qt information dialog. This could be replaced with a custom help or information
    dialog.
  prefs: []
  type: TYPE_NORMAL
- en: Building the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The VHDL project can be built and programmed onto the Ohm FPGA board using the
    free Lattice Semiconductor Diamond IDE software ([http://www.latticesemi.com/latticediamond](http://www.latticesemi.com/latticediamond)).
    Programming the board requires that the FleaFPGA JTAG utility from [https://github.com/Basman74/FleaFPGA-Ohm](https://github.com/Basman74/FleaFPGA-Ohm)
    is installed so that Diamond can use it.
  prefs: []
  type: TYPE_NORMAL
- en: By following the instructions for the FleaFPGA Ohm board as described in the
    quick start guide, it should be relatively easy to get that part of the project
    up and running. For the C++ side, one has to make sure that the FPGA board and
    SBC (or equivalent) are connected so that the latter can access the UART on the
    former.
  prefs: []
  type: TYPE_NORMAL
- en: With this in place, simply compiling the C++ project with the Qt framework (directly
    on the SBC or preferably cross-compiling on a desktop system) suffices. After
    this, one can run the application with the flashed FPGA board active, connect
    to the UART, and observe the trace being drawn on the application window.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at what role FPGAs play in embedded development,
    how they have changed in importance over the past decades, and how they are now
    being used. We looked at a simple implementation of an oscilloscope that uses
    both an FPGA and an SBC-based component. Having read through this chapter, you
    should now know when to pick an FPGA for a new embedded project and understand
    how one can use and communicate with such a device.
  prefs: []
  type: TYPE_NORMAL
