<html><head></head><body>
<div id="_idContainer018">
<h1 class="chapter-number" id="_idParaDest-78"><a id="_idTextAnchor199"/><span class="koboSpan" id="kobo.1.1">5</span></h1>
<h1 id="_idParaDest-79"><a id="_idTextAnchor200"/><span class="koboSpan" id="kobo.2.1">A Comprehensive Look at RAII</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Resource management is probably the second most frequent thing a program does, after computing. </span><span class="koboSpan" id="kobo.3.2">But just because it’s frequently done does not mean it’s visible—some languages hide most, or all, resource management from the user. </span><span class="koboSpan" id="kobo.3.3">And just because it is hidden, does not mean it’s </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">not there.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">Every program needs to use some memory, and memory is a resource. </span><span class="koboSpan" id="kobo.5.2">A program would be of no use if it never interacted with the outside world in some way, at least to print the result, and input and output channels (files, sockets, and so on) </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">are resources.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">In this chapter, we will start by answering the </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">following questions:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.9.1">What is considered a resource in a </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">C++ program?</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">What are the key concerns for managing resources </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">in C++?</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.13.1">Then, we will introduce </span><strong class="bold"><span class="koboSpan" id="kobo.14.1">Resource Acquisition is Initialization</span></strong><span class="koboSpan" id="kobo.15.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.16.1">RAII</span></strong><span class="koboSpan" id="kobo.17.1">) and explain how it helps in efficient</span><a id="_idIndexMarker212"/><span class="koboSpan" id="kobo.18.1"> resource management in C++ by answering </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">these questions:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.20.1">What is the standard approach for managing resources in </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">C++ (RAII)?</span></span></li>
<li><span class="koboSpan" id="kobo.22.1">How does RAII solve the problems of </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">resource management?</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.24.1">We will end the chapter with a discussion about the implications and possible concerns of using RAII by providing the answers to </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">these questions:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.26.1">What are the precautions that must be taken when writing </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">RAII objects?</span></span></li>
<li><span class="koboSpan" id="kobo.28.1">What are the consequences of using RAII for </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">resource management?</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.30.1">C++, with its zero-overhead abstraction philosophy, does not hide resources or their management at the core language level. </span><span class="koboSpan" id="kobo.30.2">But we would do well to not confuse hiding resources with </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">managing them.</span></span><a id="_idTextAnchor201"/><a id="_idTextAnchor202"/></p>
<h1 id="_idParaDest-80"><a id="_idTextAnchor203"/><span class="koboSpan" id="kobo.32.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.33.1">Here are some </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">useful links:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.35.1">Google Test unit testing </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">framework: </span></span><a href="https://github.com/google/googletest"><span class="No-Break"><span class="koboSpan" id="kobo.37.1">https://github.com/google/googletest</span></span></a></li>
<li><span class="koboSpan" id="kobo.38.1">Google Benchmark </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">library: </span></span><a href="https://github.com/google/benchmark"><span class="No-Break"><span class="koboSpan" id="kobo.40.1">https://github.com/google/benchmark</span></span></a></li>
<li><span class="koboSpan" id="kobo.41.1">Example </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">code: </span></span><a href="https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter05"><span class="No-Break"><span class="koboSpan" id="kobo.43.1">https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter05</span></span><span id="_idTextAnchor204"/><span id="_idTextAnchor205"/></a></li>
</ul>
<h1 id="_idParaDest-81"><a id="_idTextAnchor206"/><span class="koboSpan" id="kobo.44.1">Resource management in C++</span></h1>
<p><span class="koboSpan" id="kobo.45.1">Every program operates on resources and needs to manage them. </span><span class="koboSpan" id="kobo.45.2">The most commonly used resource is memory, of course. </span><span class="koboSpan" id="kobo.45.3">Hence, you</span><a id="_idIndexMarker213"/><span class="koboSpan" id="kobo.46.1"> often read about </span><strong class="bold"><span class="koboSpan" id="kobo.47.1">memory</span></strong> <strong class="bold"><span class="koboSpan" id="kobo.48.1">management</span></strong><span class="koboSpan" id="kobo.49.1"> in C++. </span><span class="koboSpan" id="kobo.49.2">But really, resources can be just about anything. </span><span class="koboSpan" id="kobo.49.3">Many</span><a id="_idIndexMarker214"/><span class="koboSpan" id="kobo.50.1"> programs exist specifically to manage real, tangible physical resources, or the more ephemeral (but no less valuable) digital ones. </span><span class="koboSpan" id="kobo.50.2">Money in bank accounts, airline seats, car parts and assembled cars, or even crates of milk—in today’s world, if it is something that needs to be counted and</span><a id="_idIndexMarker215"/><span class="koboSpan" id="kobo.51.1"> tracked, there is a piece of software somewhere that is doing it. </span><span class="koboSpan" id="kobo.51.2">But even in a program that does pure computations, there may be varied and complex resources, unless the program also eschews abstractions and operates at the level of bare numbers. </span><span class="koboSpan" id="kobo.51.3">For example, a physics simulation program may have particles </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">as resources.</span></span></p>
<p><span class="koboSpan" id="kobo.53.1">All of these resources have one thing in common—they need to be accounted for. </span><span class="koboSpan" id="kobo.53.2">They should not vanish without a trace, and a program should not just make up resources that don’t really exist. </span><span class="koboSpan" id="kobo.53.3">Often, a specific instance of a resource is needed—you would not want someone else’s purchase to be debited from your bank account; the specific instance of the resource matters. </span><span class="koboSpan" id="kobo.53.4">Thus, the most important consideration when evaluating different approaches to resource management is correctness—how well does the design ensure that resources are managed properly, how easy is it to make a mistake, and how hard would it be to find such a mistake? </span><span class="koboSpan" id="kobo.53.5">It should come as no surprise, then, that we use a testing framework to present the coding examples of resource management in </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">this chapt</span><a id="_idTextAnchor207"/><a id="_idTextAnchor208"/><a id="_idTextAnchor209"/><span class="koboSpan" id="kobo.55.1">er.</span></span></p>
<h2 id="_idParaDest-82"><a id="_idTextAnchor210"/><span class="koboSpan" id="kobo.56.1">Installing the microbenchmark library</span></h2>
<p><span class="koboSpan" id="kobo.57.1">In our case, we are interested in the efficiency of memory allocations and small fragments of code that may contain such allocations. </span><span class="koboSpan" id="kobo.57.2">The appropriate tool for measuring the performance of small fragments of code is a</span><a id="_idIndexMarker216"/><span class="koboSpan" id="kobo.58.1"> microbenchmark. </span><span class="koboSpan" id="kobo.58.2">There are many microbenchmark libraries and tools out there; in this book, we will use the Google Benchmark library. </span><span class="koboSpan" id="kobo.58.3">To follow along with the examples in this chapter, you must first download and install the library (follow the instructions in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.59.1">Readme.md</span></strong><span class="koboSpan" id="kobo.60.1"> file). </span><span class="koboSpan" id="kobo.60.2">Then you can compile and run the examples. </span><span class="koboSpan" id="kobo.60.3">You can build the sample files included with the library to see how to build a benchmark on your particular system; you can also use the example benchmark from this </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">chapter’s repository:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.62.1">
// Example 01
#include &lt;stdlib.h&gt;
#include "benchmark/benchmark.h"
void BM_malloc(benchmark::State&amp; state) {
  constexpr size_t size = 1024;
  for (auto _ : state) {
    void* p = malloc(size);
    benchmark::DoNotOptimize(p);
    free(p);
  }
  state.SetItemsProcessed(state.iterations());
}
BENCHMARK(BM_malloc);
BENCHMARK_MAIN();</span></pre>
<p><span class="koboSpan" id="kobo.63.1">Note the call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.64.1">DoNotOptimize()</span></strong><span class="koboSpan" id="kobo.65.1">: it’s a special function that doesn’t generate any code but tricks the compiler into thinking that its argument is necessary and cannot be optimized away. </span><span class="koboSpan" id="kobo.65.2">Without this, the compiler will probably figure out that the entire benchmark loop has no observable effect and can be optimized </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">to nothing.</span></span></p>
<p><span class="koboSpan" id="kobo.67.1">On a Linux machine, the command to build and run a benchmark program called </span><strong class="source-inline"><span class="koboSpan" id="kobo.68.1">01_benchmark.C</span></strong><span class="koboSpan" id="kobo.69.1"> might look something </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">like this:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.71.1">
$CXX 01_benchmark.C -I. </span><span class="koboSpan" id="kobo.71.2">-I$GBENCH_DIR/include –O3 \
  --std=c++17 $GBENCH_DIR/lib/libbenchmark.a -lpthread \
  -o 01_benchmark &amp;&amp; ./01_benchmark</span></pre>
<p><span class="koboSpan" id="kobo.72.1">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">$CXX</span></strong><span class="koboSpan" id="kobo.74.1"> is your C++ compiler, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">g++</span></strong><span class="koboSpan" id="kobo.76.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">clang++</span></strong><span class="koboSpan" id="kobo.78.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.79.1">$GBENCH_DIR</span></strong><span class="koboSpan" id="kobo.80.1"> is the direc</span><a id="_idTextAnchor211"/><span class="koboSpan" id="kobo.81.1">tory where the </span><a id="_idIndexMarker217"/><span class="koboSpan" id="kobo.82.1">benchmark </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">is installed.</span></span></p>
<p><span class="koboSpan" id="kobo.84.1">The preceding example should print something </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">like this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer016">
<span class="koboSpan" id="kobo.86.1"><img alt="" src="image/Figure_5.1_B19262.jpg"/></span>
</div>
</div>
<p><span class="koboSpan" id="kobo.87.1">On this particular machine, a single iteration (one pair of calls to </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">malloc()</span></strong><span class="koboSpan" id="kobo.89.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">free()</span></strong><span class="koboSpan" id="kobo.91.1">) takes 6.37 nanoseconds, which translates into 157 million memory allocations </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">per second.</span></span></p>
<p><span class="koboSpan" id="kobo.93.1">Sometimes we have to benchmark very </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">short operations:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.95.1">
void BM_increment(benchmark::State&amp; state) {
  size_t i = 0;
  for (auto _ : state) {
    ++i;
    benchmark::DoNotOptimize(i);
  }
  state.SetItemsProcessed(state.iterations());
}</span></pre>
<p><span class="koboSpan" id="kobo.96.1">We may be reasonably concerned about the overhead of the benchmark loop itself. </span><span class="koboSpan" id="kobo.96.2">In such cases, we can execute multiple copies of the benchmarked operation within the body of the loop. </span><span class="koboSpan" id="kobo.96.3">We can even get the C++ preprocessor to make copies </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">for us:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.98.1">
// Example 02
#define REPEAT2(x) x x
#define REPEAT4(x) REPEAT2(x) REPEAT2(x)
#define REPEAT8(x) REPEAT4(x) REPEAT4(x)
#define REPEAT16(x) REPEAT8(x) REPEAT8(x)
#define REPEAT32(x) REPEAT16(x) REPEAT16(x)
#define REPEAT(x) REPEAT32(x)
void BM_increment32(benchmark::State&amp; state) {
  size_t i = 0;
  for (auto _ : state) {
    REPEAT(
      ++i;
      benchmark::DoNotOptimize(i);
    )
  }
  state.SetItemsProcessed(32*state.iterations());
}</span></pre>
<p><span class="koboSpan" id="kobo.99.1">The time of a “</span><em class="italic"><span class="koboSpan" id="kobo.100.1">single</span></em><span class="koboSpan" id="kobo.101.1">” iteration</span><a id="_idIndexMarker218"/><span class="koboSpan" id="kobo.102.1"> now includes 32 iterations, so it is much easier to use the items per second value. </span><span class="koboSpan" id="kobo.102.2">Remember to include repeat count in the number of </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">items processed:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer017">
<span class="koboSpan" id="kobo.104.1"><img alt="" src="image/Figure_5.2_B19262.jpg"/></span>
</div>
</div>
<p><span class="koboSpan" id="kobo.105.1">Writing fast programs is all well and good, but they have to be correct first. </span><span class="koboSpan" id="kobo.105.2">To that end, we need to write tests, so we also need a </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">testing framew</span><a id="_idTextAnchor212"/><span class="koboSpan" id="kobo.107.1">ork.</span></span></p>
<h2 id="_idParaDest-83"><a id="_idTextAnchor213"/><span class="koboSpan" id="kobo.108.1">Installing Google Test</span></h2>
<p><span class="koboSpan" id="kobo.109.1">We will be testing very small fragments of code for correctness. </span><span class="koboSpan" id="kobo.109.2">On the one hand, this is simply because each fragment illustrates a specific concept or idea. </span><span class="koboSpan" id="kobo.109.3">On the other hand, even in a large-scale </span><a id="_idIndexMarker219"/><span class="koboSpan" id="kobo.110.1">software system, resource management is done by small building blocks of code. </span><span class="koboSpan" id="kobo.110.2">They may combine to form a quite complex resource manager, but each block performs a specific function and is testable. </span><span class="koboSpan" id="kobo.110.3">The appropriate testing system for this situation is a unit testing framework. </span><span class="koboSpan" id="kobo.110.4">There are many such frameworks to choose from; in this book, we will use the Google Test unit testing framework. </span><span class="koboSpan" id="kobo.110.5">To follow along with the examples in this chapter, you must first download and install the framework (follow the instructions in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.111.1">README</span></strong><span class="koboSpan" id="kobo.112.1"> file). </span><span class="koboSpan" id="kobo.112.2">Once installed, you can compile and run the examples. </span><span class="koboSpan" id="kobo.112.3">You can build the sample tests included with the library to see how to build and link with Google Test on your particular system; you can also use the example from this </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">chapter’s repository:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.114.1">
#include &lt;vector&gt;
#include "gtest/gtest.h"
TEST(Memory, Vector) {
  std::vector&lt;int&gt; v(10);
  EXPECT_EQ(10u, v.size());
  EXPECT_LE(10u, v.capacity());
}</span></pre>
<p><span class="koboSpan" id="kobo.115.1">On a Linux machine, the command to build and run a </span><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">02_test.C</span></strong><span class="koboSpan" id="kobo.117.1"> test might look something </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">like this:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.119.1">
$CXX 02_test.C -I. </span><span class="koboSpan" id="kobo.119.2">-I$GTEST_DIR/include -g -O0 -I. </span><span class="koboSpan" id="kobo.119.3">\
  -Wall -Wextra -Werror -pedantic --std=c++17 \
  $GTEST_DIR/lib/libgtest.a $GTEST_DIR/lib/libgtest_main.a\
  -lpthread -lrt -lm -o -2_test &amp;&amp; ./02_test</span></pre>
<p><span class="koboSpan" id="kobo.120.1">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">$CXX</span></strong><span class="koboSpan" id="kobo.122.1"> is your C++ compiler, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">g++</span></strong><span class="koboSpan" id="kobo.124.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">clang++</span></strong><span class="koboSpan" id="kobo.126.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">$GTEST_DIR</span></strong><span class="koboSpan" id="kobo.128.1"> is the directory where Google Test is installed. </span><span class="koboSpan" id="kobo.128.2">If all tests pass, you should get </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">this output:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.130.1">
Running main() from gtest_main.cc
[==========] Running 1 test from 1 test case.
</span><span class="koboSpan" id="kobo.130.2">[----------] Global test environment set-up.
</span><span class="koboSpan" id="kobo.130.3">[----------] 1 test from Memory
[ RUN      ] Memory.Vector
[       OK ] Memory.Vector (0 ms)
[----------] 1 test from Memory (0 ms total)
[----------] Global test environment tear-down
[==========] 1 test from 1 test case ran. </span><span class="koboSpan" id="kobo.130.4">(0 ms total)
[  PASSED  ] 1 test.</span></pre>
<p><span class="koboSpan" id="kobo.131.1">Writing good tests is an art. </span><span class="koboSpan" id="kobo.131.2">We have to identify the aspects of our code that need to be validated and come up with ways to observe these aspects. </span><span class="koboSpan" id="kobo.131.3">In this chapter, we are interested in resource management, so let us see how we can test the utilization and release </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">of resou</span><a id="_idTextAnchor214"/><a id="_idTextAnchor215"/><a id="_idTextAnchor216"/><span class="koboSpan" id="kobo.133.1">rces.</span></span></p>
<h2 id="_idParaDest-84"><a id="_idTextAnchor217"/><span class="koboSpan" id="kobo.134.1">Counting resources</span></h2>
<p><span class="koboSpan" id="kobo.135.1">A unit testing </span><a id="_idIndexMarker220"/><span class="koboSpan" id="kobo.136.1">framework, such as Google Test, allows us to execute some code and verify that the results are what they should be. </span><span class="koboSpan" id="kobo.136.2">The results that we can look at include any variable or expression that we can access from the test program. </span><span class="koboSpan" id="kobo.136.3">That definition does not extend, for example, to the amount of memory that is currently in use. </span><span class="koboSpan" id="kobo.136.4">So, if we want to verify that resources are not disappearing, we have to </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">count them.</span></span></p>
<p><span class="koboSpan" id="kobo.138.1">In the following simple test fixture, we use a special resource class instead of, say, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">int</span></strong><span class="koboSpan" id="kobo.140.1"> keyword. </span><span class="koboSpan" id="kobo.140.2">This class is instrumented to count how many objects of this type have been created, and how many are </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">currently alive:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.142.1">
// Example 03
struct object_counter {
  static int count;
  static int all_count;
  object_counter() { ++count; ++all_count; }
  ~object_counter() { --count; }
};
int object_counter::count = 0;
int object_counter::all_count = 0;</span></pre>
<p><span class="koboSpan" id="kobo.143.1">Now we can test that our program manages resources correctly, </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.145.1">
// Example 03
#include "gtest/gtest.h"
TEST(Memory, NewDelete) {
  object_counter::all_count = object_counter::count = 0;
  object_counter* p = new object_counter;
  EXPECT_EQ(1, object_counter::count);
  EXPECT_EQ(1, object_counter::all_count);
  delete p;
  EXPECT_EQ(0, object_counter::count);
  EXPECT_EQ(1, object_counter::all_count);
}</span></pre>
<p><span class="koboSpan" id="kobo.146.1">In Google Test, every test is implemented </span><a id="_idIndexMarker221"/><span class="koboSpan" id="kobo.147.1">as a </span><strong class="bold"><span class="koboSpan" id="kobo.148.1">test fixture</span></strong><span class="koboSpan" id="kobo.149.1">. </span><span class="koboSpan" id="kobo.149.2">There are several types; the simplest one is a standalone</span><a id="_idIndexMarker222"/><span class="koboSpan" id="kobo.150.1"> test function, such as the one we use here. </span><span class="koboSpan" id="kobo.150.2">Running this simple test program tells us that the test has passed, </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">as follows:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.152.1">
[----------] 1 test from Memory
[ RUN      ] Memory.NewDelete
[       OK ] Memory.NewDelete (0 ms)
[----------] 1 test from Memory (0 ms total)
[  PASSED  ]</span><a id="_idTextAnchor218"/><span class="koboSpan" id="kobo.153.1"> 1 test.</span></pre>
<p><span class="koboSpan" id="kobo.154.1">The expected results are verified using one of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">EXPECT_*</span></strong><span class="koboSpan" id="kobo.156.1"> macros and any test failures will be reported. </span><span class="koboSpan" id="kobo.156.2">This test verifies that, after creating and deleting an instance of the type </span><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">object_counter</span></strong><span class="koboSpan" id="kobo.158.1">, there are no </span><a id="_idIndexMarker223"/><span class="koboSpan" id="kobo.159.1">such objects left, and that exactly one </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">was con</span><a id="_idTextAnchor219"/><a id="_idTextAnchor220"/><span class="koboSpan" id="kobo.161.1">structed.</span></span></p>
<h1 id="_idParaDest-85"><a id="_idTextAnchor221"/><span class="koboSpan" id="kobo.162.1">Dangers of manual resource management</span></h1>
<p><span class="koboSpan" id="kobo.163.1">C++ allows us to manage</span><a id="_idIndexMarker224"/><span class="koboSpan" id="kobo.164.1"> resources almost at the hardware level, and someone, somewhere, must indeed manage them at this level. </span><span class="koboSpan" id="kobo.164.2">The latter is actually true for every language, even the high-level ones that do not expose such details to the programmers. </span><span class="koboSpan" id="kobo.164.3">But </span><em class="italic"><span class="koboSpan" id="kobo.165.1">somewhere </span></em><span class="koboSpan" id="kobo.166.1">does not have to be in your program! </span><span class="koboSpan" id="kobo.166.2">Before we learn the C++ solutions and tools for resource management, let’s first understand the problems that arise from not</span><a id="_idTextAnchor222"/><span class="koboSpan" id="kobo.167.1"> using any </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">s</span><a id="_idTextAnchor223"/><span class="koboSpan" id="kobo.169.1">uch tools.</span></span></p>
<h2 id="_idParaDest-86"><a id="_idTextAnchor224"/><span class="koboSpan" id="kobo.170.1">Manual resource management is error-prone</span></h2>
<p><span class="koboSpan" id="kobo.171.1">The first and most</span><a id="_idIndexMarker225"/><span class="koboSpan" id="kobo.172.1"> obvious danger of managing every resource manually, with explicit calls to acquire and release each one, is that it is easy to forget the latter. </span><span class="koboSpan" id="kobo.172.2">For example, see </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.174.1">
{
  object_counter* p = new object_counter;
  ... </span><span class="koboSpan" id="kobo.174.2">many more lines of code ...
</span><span class="koboSpan" id="kobo.174.3">  // Were we supposed to do something here?
</span><span class="koboSpan" id="kobo.174.4">  // Can't remember now...
</span><span class="koboSpan" id="kobo.174.5">}</span></pre>
<p><span class="koboSpan" id="kobo.175.1">We are now leaking a resource (the </span><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">object_counter</span></strong><span class="koboSpan" id="kobo.177.1"> objects, in this case). </span><span class="koboSpan" id="kobo.177.2">If we did this in a unit test, it would fail, </span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.179.1">
// Example 04
TEST(Memory, Leak1) {
  object_counter::all_count = object_counter::count = 0;
  object_counter* p = new object_counter;
  EXPECT_EQ(1, object_counter::count);
  EXPECT_EQ(1, object_counter::all_count);
  //delete p;  // Forgot that
  EXPECT_EQ(0, object_counter::count); // This test fails!
</span><span class="koboSpan" id="kobo.179.2">  EXPECT_EQ(1, object_counter::al</span><a id="_idTextAnchor225"/><span class="koboSpan" id="kobo.180.1">l_count);
}</span></pre>
<p><span class="koboSpan" id="kobo.181.1">You can see the failing tests, and the location of the failures, as reported by the unit </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">test framework:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.183.1">
[ RUN      ] Memory.Leak1
04_memory.C:31: Failure
Expected equality of these values:
  0
  object_counter::count
    Which is: 1
[  FAILED  ] Memory.Leak1 (0 ms)</span></pre>
<p><span class="koboSpan" id="kobo.184.1">In a real program, finding such errors is much harder. </span><span class="koboSpan" id="kobo.184.2">Memory debuggers and sanitizers can help with memory leaks, but they require that the program actually execute the buggy code, so they depend on the </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">test</span></span><span class="No-Break"><a id="_idIndexMarker226"/></span><span class="No-Break"><span class="koboSpan" id="kobo.186.1"> coverage.</span></span></p>
<p><span class="koboSpan" id="kobo.187.1">The resource leaks can be much subtler and harder to find, too. </span><span class="koboSpan" id="kobo.187.2">Consider this code, where we did not forget to release </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">the resource:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.189.1">
bool process(... </span><span class="koboSpan" id="kobo.189.2">some parameters ... </span><span class="koboSpan" id="kobo.189.3">) {
  object_counter* p = new object_counter;
  ... </span><span class="koboSpan" id="kobo.189.4">many more lines of code ...
</span><span class="koboSpan" id="kobo.189.5">  delete p;    // A-ha, we remembered!
</span><span class="koboSpan" id="kobo.189.6">  return true;    // Success
}</span></pre>
<p><span class="koboSpan" id="kobo.190.1">During subsequent maintenance, a possible failure condition was discovered, and the appropriate test </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">was added:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.192.1">
bool process(... </span><span class="koboSpan" id="kobo.192.2">some parameters ... </span><span class="koboSpan" id="kobo.192.3">) {
  object_counter* p = new object_counter;
  ... </span><span class="koboSpan" id="kobo.192.4">many more lines of code ...
</span><span class="koboSpan" id="kobo.192.5">  if (!success) return false;   // Failure, cannot continue
  ... </span><span class="koboSpan" id="kobo.192.6">even more lines of code ...
</span><span class="koboSpan" id="kobo.192.7">  delete p;    // Still here
  return true;    // Success
}</span></pre>
<p><span class="koboSpan" id="kobo.193.1">This change introduced a subtle bug—now, resources are leaked only if the intermediate computation has failed and triggered the early return. </span><span class="koboSpan" id="kobo.193.2">If the failure is rare enough, this mistake may</span><a id="_idIndexMarker227"/><span class="koboSpan" id="kobo.194.1"> escape all tests, even if the testing process employs regular memory sanitizer runs. </span><span class="koboSpan" id="kobo.194.2">This mistake is also all too easy to make since the edit could be made in a place far removed from both the construction and deletion of the object, and nothing in the immediate context gives the programmer a hint that a resource needs to</span><a id="_idTextAnchor226"/> <span class="No-Break"><span class="koboSpan" id="kobo.195.1">be released.</span></span></p>
<p><span class="koboSpan" id="kobo.196.1">The alternative to leaking a resource, in this case, is to release it. </span><span class="koboSpan" id="kobo.196.2">Note that this leads to some </span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">code duplication:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.198.1">
bool process(... </span><span class="koboSpan" id="kobo.198.2">some parameters ... </span><span class="koboSpan" id="kobo.198.3">) {
  object_counter* p = new object_counter;
  ... </span><span class="koboSpan" id="kobo.198.4">many more lines of code ...
</span><span class="koboSpan" id="kobo.198.5">  if (!success) {
    delete p;
    return false;    // Failure, cannot continue
  }
  ... </span><span class="koboSpan" id="kobo.198.6">even more lines of code ...
</span><span class="koboSpan" id="kobo.198.7">  delete p;    // Still here
  return true;    // Success
}</span></pre>
<p><span class="koboSpan" id="kobo.199.1">As with any code duplication, there comes the danger of code divergence. </span><span class="koboSpan" id="kobo.199.2">Let’s say that the next round of code enhancements required more than one </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">object_counter</span></strong><span class="koboSpan" id="kobo.201.1">, and an array of them is now allocated </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.203.1">
bool process(... </span><span class="koboSpan" id="kobo.203.2">some parameters ... </span><span class="koboSpan" id="kobo.203.3">) {
  object_counter* p = new object_counter[10]; // Array now
  ... </span><span class="koboSpan" id="kobo.203.4">many more lines of code ...
</span><span class="koboSpan" id="kobo.203.5">  if (!success) {
    delete p;
    return false;     // Old scalar delete
  }
  ... </span><span class="koboSpan" id="kobo.203.6">even more lines of code ...
</span><span class="koboSpan" id="kobo.203.7">  delete [] p;    // Matching array delete
  return true;    // Success
}</span></pre>
<p><span class="koboSpan" id="kobo.204.1">If we change </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">new</span></strong><span class="koboSpan" id="kobo.206.1"> to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">new</span></strong><span class="koboSpan" id="kobo.208.1"> array, we must change </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">delete</span></strong><span class="koboSpan" id="kobo.210.1"> as well; the thought goes, there is probably one at the end of the function. </span><span class="koboSpan" id="kobo.210.2">Who knew that there was one more in the middle? </span><span class="koboSpan" id="kobo.210.3">Even if the programmer had not forgotten about the resources, manual resource management gets disproportionately more error-prone as the program becomes more complex. </span><span class="koboSpan" id="kobo.210.4">And not all resources are as forgiving as a counter object. </span><span class="koboSpan" id="kobo.210.5">Consider the following code that performs some concurrent computation, and must acquire and release mutex locks. </span><span class="koboSpan" id="kobo.210.6">Note the very words </span><strong class="bold"><span class="koboSpan" id="kobo.211.1">acquire </span></strong><span class="koboSpan" id="kobo.212.1">and </span><strong class="bold"><span class="koboSpan" id="kobo.213.1">release</span></strong><span class="koboSpan" id="kobo.214.1">, the common terminology for locks, suggest that locks are treated as a kind of resource (the resource here is exclusive access to the data protected by </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">the lock):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.216.1">
std::mutex m1, m2, m3;
bool process_concurrently(... </span><span class="koboSpan" id="kobo.216.2">some parameters ... </span><span class="koboSpan" id="kobo.216.3">) {
  m1.lock();
  m2.lock();
  ... </span><span class="koboSpan" id="kobo.216.4">need both locks in this section ...
</span><span class="koboSpan" id="kobo.216.5">  if (!success) {
    m1.unlock();
    m2.unlock();
    return false;
  } // Both locks unlocked
  ... </span><a id="_idTextAnchor227"/><span class="koboSpan" id="kobo.217.1">more code ...
</span><span class="koboSpan" id="kobo.217.2">  m2.unlock();    // Don't need access to m1-guarded data
                // Still need m1
  m3.lock();
  if (!success) {
    m1.unlock();
    return false;
  } // No need to unlock m2 here
  ... </span><span class="koboSpan" id="kobo.217.3">more code ...
</span><span class="koboSpan" id="kobo.217.4">  m1.unlock();
  m3.unlock();
  return true;
}</span></pre>
<p><span class="koboSpan" id="kobo.218.1">This code has both duplication and divergence. </span><span class="koboSpan" id="kobo.218.2">It also</span><a id="_idIndexMarker228"/><span class="koboSpan" id="kobo.219.1"> has a bug—see if you can find it (hint—count how many times </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">m3</span></strong><span class="koboSpan" id="kobo.221.1"> is unlocked, versus how many </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">return</span></strong><span class="koboSpan" id="kobo.223.1"> statements there are after it’s locked). </span><span class="koboSpan" id="kobo.223.2">As the resources become more numerous </span><a id="_idTextAnchor228"/><span class="koboSpan" id="kobo.224.1">and complex to manage, such bugs are going to creep </span><a id="_idTextAnchor229"/><span class="koboSpan" id="kobo.225.1">up </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">more often.</span></span></p>
<h2 id="_idParaDest-87"><a id="_idTextAnchor230"/><span class="koboSpan" id="kobo.227.1">Resource management and exception safety</span></h2>
<p><span class="koboSpan" id="kobo.228.1">Remember the code at the</span><a id="_idIndexMarker229"/><span class="koboSpan" id="kobo.229.1"> beginning of the previous section—the one we said is correct, where we did not forget to release the resource? </span><span class="koboSpan" id="kobo.229.2">Consider the </span><span class="No-Break"><span class="koboSpan" id="kobo.230.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.231.1">
bool process(... </span><span class="koboSpan" id="kobo.231.2">some parameters ... </span><span class="koboSpan" id="kobo.231.3">) {
  object_counter* p = new object_counter;
  ... </span><span class="koboSpan" id="kobo.231.4">many more lines of code ...
</span><span class="koboSpan" id="kobo.231.5">  delete p;
  return true;    // Success
}</span></pre>
<p><span class="koboSpan" id="kobo.232.1">I have bad news for you—this code probably wasn’t correct either. </span><span class="koboSpan" id="kobo.232.2">If any of the many more lines of code can throw an exception, then </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">delete p</span></strong><span class="koboSpan" id="kobo.234.1"> is never going to </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">be executed:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.236.1">
bool process(... </span><span class="koboSpan" id="kobo.236.2">some parameters ... </span><span class="koboSpan" id="kobo.236.3">) {
  object_counter* p = new object_counter;
  ... </span><span class="koboSpan" id="kobo.236.4">many more lines of code ...
</span><span class="koboSpan" id="kobo.236.5">  if (!success) // Cannot continue
    throw process_exception();
  ... </span><span class="koboSpan" id="kobo.236.6">even more lines of code ...
</span><span class="koboSpan" id="kobo.236.7">  // Won't do anything if an exception is thrown!
</span><span class="koboSpan" id="kobo.236.8">  delete p;
  return true;
}</span></pre>
<p><span class="koboSpan" id="kobo.237.1">This looks very similar to the early </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">return</span></strong><span class="koboSpan" id="kobo.239.1"> problem, only worse—the exception can be thrown by any code that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">process()</span></strong><span class="koboSpan" id="kobo.241.1"> function calls. </span><span class="koboSpan" id="kobo.241.2">The exception can even be added later to some code that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">process()</span></strong><span class="koboSpan" id="kobo.243.1"> function calls, without any changes in the function itself. </span><span class="koboSpan" id="kobo.243.2">It used to work fine, then one day it </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">does not.</span></span></p>
<p><span class="koboSpan" id="kobo.245.1">Unless we change our approach to resource management, the only solution is to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">try … </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">catch</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.248.1"> blocks:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.249.1">
bool process(... </span><span class="koboSpan" id="kobo.249.2">some parameters ... </span><span class="koboSpan" id="kobo.249.3">) {
  object_counter* p = new object_counter;
  try {
    ... </span><span class="koboSpan" id="kobo.249.4">many more lines of code ...
</span><span class="koboSpan" id="kobo.249.5">    if (!success) // Cannot continue
      throw process_exception();
      ... </span><span class="koboSpan" id="kobo.249.6">even more lines of code ...
</span><span class="koboSpan" id="kobo.249.7">  } catch ( ... </span><span class="koboSpan" id="kobo.249.8">) {
    delete p;    // For exceptional case
  }
  delete p;    // For normal case return true;
}</span></pre>
<p><span class="koboSpan" id="kobo.250.1">The obvious problem here is code duplication again, as well as the proliferation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">try … catch</span></strong><span class="koboSpan" id="kobo.252.1"> blocks literally everywhere. </span><span class="koboSpan" id="kobo.252.2">Worse than that, this approach does not scale should we need to </span><a id="_idIndexMarker230"/><span class="koboSpan" id="kobo.253.1">manage multiple resources, or even just manage anything more complex than a single acquisition with a </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">corresponding release:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.255.1">
std::mutex m;
bool process(... </span><span class="koboSpan" id="kobo.255.2">some parameters ... </span><span class="koboSpan" id="kobo.255.3">) {
  m.lock(); // Critical section starts here
  object_counter* p = new object_counter;
  // Problem #1: constructor can throw
  try {
    ... </span><span class="koboSpan" id="kobo.255.4">many more lines of code ...
</span><span class="koboSpan" id="kobo.255.5">    m.unlock();    // Critical section ends here
    ... </span><span class="koboSpan" id="kobo.255.6">even more lines of code ...
</span><span class="koboSpan" id="kobo.255.7">  } catch ( ... </span><span class="koboSpan" id="kobo.255.8">) {
    delete p;    // OK, always needed
    m.unlock();    // Do we need this? </span><span class="koboSpan" id="kobo.255.9">Maybe…
    throw;    // Rethrow the exception for the client to handle
  }
  delete p;    // For normal case, no need to unlock mutex
</span><a id="_idTextAnchor231"/><span class="koboSpan" id="kobo.256.1">  return true;
}</span></pre>
<p><span class="koboSpan" id="kobo.257.1">Now, we can’t even decide</span><a id="_idIndexMarker231"/><span class="koboSpan" id="kobo.258.1"> whether the catch block should release the mutex or not—it depends on whether the exception was thrown before or after the </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">unlock()</span></strong><span class="koboSpan" id="kobo.260.1"> operation that happens in the normal, non-exceptional control flow. </span><span class="koboSpan" id="kobo.260.2">Also, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">object_counter</span></strong><span class="koboSpan" id="kobo.262.1"> constructor could throw an exception (not the simple one we had so far, but a more complex one that ours could evolve into). </span><span class="koboSpan" id="kobo.262.2">That would happen outside of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">try … catch</span></strong><span class="koboSpan" id="kobo.264.1"> block, and the mutex would never </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">get unlocked.</span></span></p>
<p><span class="koboSpan" id="kobo.266.1">It should be clear to us by now that we need an entirely different solution for the resource management problem, not some patchwork. </span><span class="koboSpan" id="kobo.266.2">In the next section, we will di</span><a id="_idTextAnchor232"/><span class="koboSpan" id="kobo.267.1">scuss the pattern that became the golden standard of resource m</span><a id="_idTextAnchor233"/><span class="koboSpan" id="kobo.268.1">anagement </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">in C++.</span></span></p>
<h1 id="_idParaDest-88"><a id="_idTextAnchor234"/><span class="koboSpan" id="kobo.270.1">The RAII idiom</span></h1>
<p><span class="koboSpan" id="kobo.271.1">We have seen in the previous section </span><a id="_idIndexMarker232"/><span class="koboSpan" id="kobo.272.1">how ad hoc attempts to manage resources become unreliable, then error-prone, and eventually fail. </span><span class="koboSpan" id="kobo.272.2">What we need is to make sure that resource acquisition is always paired up with resource release, and that these two actions happen before and after the section of code that uses the resource respectively. </span><span class="koboSpan" id="kobo.272.3">In C++, this kind of bracketing of a code sequence by a pair of actions is known as the Execute Around </span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">design pattern.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.274.1">Tip</span></p>
<p class="callout"><span class="koboSpan" id="kobo.275.1">For more information, see the article </span><em class="italic"><span class="koboSpan" id="kobo.276.1">C++ Patterns – Executing Around Sequences</span></em><span class="koboSpan" id="kobo.277.1"> by Kevlin Henney, available </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">at </span></span><a href="http://www.two-sdg.demon.co.uk/curbralan/papers/europlop/ExecutingAroundSequences.pdf"><span class="No-Break"><span class="koboSpan" id="kobo.279.1">http://www.two-sdg.demon.co.uk/curbralan/papers/europlop/ExecutingAroundSequences.pdf</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.280.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.281.1">When specifically applied to resource management, this pattern i</span><a id="_idTextAnchor235"/><span class="koboSpan" id="kobo.282.1">s much more widely known as </span><strong class="bold"><span class="koboSpan" id="kobo.283.1">Resource Acquisition is </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.284.1">Init</span><a id="_idTextAnchor236"/><span class="koboSpan" id="kobo.285.1">ialization</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.286.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.287.1">RAII</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">).</span></span></p>
<h2 id="_idParaDest-89"><a id="_idTextAnchor237"/><span class="koboSpan" id="kobo.289.1">RAII in a nutshell</span></h2>
<p><span class="koboSpan" id="kobo.290.1">The basic idea behind </span><a id="_idIndexMarker233"/><span class="koboSpan" id="kobo.291.1">RAII is very simple—there is one kind of function in C++ that is guaranteed to be called automatically, and that is the destructor of an object created on the stack, or the destructor of an object that is a data member of another object (in the latter case, the guarantee holds only if the containing class itself is destroyed). </span><span class="koboSpan" id="kobo.291.2">If we could hook up the release of the resource to the destructor of such an object, then the release could not be forgotten or skipped. </span><span class="koboSpan" id="kobo.291.3">It stands to reason that if releasing the resource is handled by the destructor, acquiring it should be handled by the constructor during the initialization of the object. </span><span class="koboSpan" id="kobo.291.4">Hence the full meaning of RAII as introduced in the title of this chapter—</span><em class="italic"><span class="koboSpan" id="kobo.292.1">A Comprehe</span><a id="_idTextAnchor238"/><span class="koboSpan" id="kobo.293.1">nsive Look </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.294.1">at RAII</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.296.1">Let’s see how this works in the simplest case of memory allocation, via </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">operator new</span></strong><span class="koboSpan" id="kobo.298.1">. </span><span class="koboSpan" id="kobo.298.2">First, we need a class that can be initialized from a pointer to the newly allocated object, and whose destructor will delete </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">that object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.300.1">
// Example 05
template &lt;typename T&gt; class raii {
  public:
  explicit raii(T* p) : p_(p) {}
  ~raii() { delete p_; }
  private:
  T* p_;
};</span></pre>
<p><span class="koboSpan" id="kobo.301.1">Now it is very easy to make sure that deletion is never omitted, and we can verify that it works as expected with a test that </span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">uses </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">object_counter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.305.1">
// Example 05
TEST(RAII, AcquireRelease) {
  object_counter::all_count = object_counter::count = 0;
  {
    raii&lt;object_counter&gt; p(new object_counter);
    EXPECT_EQ(1, object_counter::count);
    EXPECT_EQ(1, object_counter::all_count);
  } // No need to delete p, it's automatic
  EXPECT_EQ(0, object_counter::count);
  EXPECT_EQ(1, object_counter::all_count);
}</span></pre>
<p><span class="koboSpan" id="kobo.306.1">Note that in C++17, the class</span><a id="_idIndexMarker234"/><span class="koboSpan" id="kobo.307.1"> template type is deduced from the constructor and we can simply write </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.309.1">
raii p(new object_counter);</span></pre>
<p><span class="koboSpan" id="kobo.310.1">The RAII resource release happens when the owning object is destroyed for any reason; thus, the cleanup after an exception is thrown and automatically taken </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">care of:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.312.1">
// Example 05
struct my_exception {};
TEST(Memory, NoLeak) {
  object_counter::all_count = object_counter::count = 0;
  try {
    raii p(new object_counter);
    throw my_exception();
  } catch ( my_exception&amp; e ) {
  }
  EXPECT_EQ(0, object_counter::count);
  EXPECT_EQ(1, object_counter::all_count);
}</span></pre>
<p><span class="koboSpan" id="kobo.313.1">Of course, we probably want to use the new object for more than just creating and deleting it, so it would be</span><a id="_idIndexMarker235"/><span class="koboSpan" id="kobo.314.1"> nice to have access to the pointer stored inside the RAII object. </span><span class="koboSpan" id="kobo.314.2">There is no reason to grant such access in any way other than the standard pointer syntax, which makes our RAII object a kind of </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">pointer itself:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.316.1">
// Example 06
template &lt;typename T&gt; class scoped_ptr {
  public:
  explicit scoped_ptr(T* p) : p_(p) {}
  ~scoped_ptr() { delete p_; }
  T* operator-&gt;() { return p_; }
  const T* operator-&gt;() const { return p_; }
  T&amp; operator*() { return *p_; }
  const T&amp; operator*() const { return *p_; }
  private:
  T* p_;
};</span></pre>
<p><span class="koboSpan" id="kobo.317.1">This pointer can be used to automatically delete, at the end of the scope, the object that it points to (hence </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">the name):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.319.1">
// Example 06
TEST(Scoped_ptr, AcquireRelease) {
  object_counter::all_count = object_counter::count = 0;
  {
    scoped_ptr p(new object_counter);
    EXPECT_EQ(1, object_counter::count);
    EXPECT_EQ(1, object_counter::all_count);
  }
  EXPECT_EQ(0, object_counter::count);
  EXPECT_EQ(1, object_counter::all_count);
}</span></pre>
<p><span class="koboSpan" id="kobo.320.1">The destructor is called when the </span><a id="_idIndexMarker236"/><span class="koboSpan" id="kobo.321.1">scope containing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">scoped_ptr</span></strong><span class="koboSpan" id="kobo.323.1"> object is exited. </span><span class="koboSpan" id="kobo.323.2">It does not matter how it is exited—an early </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">return</span></strong><span class="koboSpan" id="kobo.325.1"> from a function, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">break</span></strong><span class="koboSpan" id="kobo.327.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">continue</span></strong><span class="koboSpan" id="kobo.329.1"> statement in the loop, or an exception being thrown are all handled in exactly the same way, and without leaks. </span><span class="koboSpan" id="kobo.329.2">We can verify this with tests, </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">of course:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.331.1">
// Example 06
TEST(Scoped_ptr, EarlyReturnNoLeak) {
  object_counter::all_count = object_counter::count = 0;
  do {
    scoped_ptr p(new object_counter);
    break;
  } while (false);
  EXPECT_EQ(0, object_counter::count);
  EXPECT_EQ(1, object_counter::all_count);
}
TEST(Scoped_ptr, ThrowNoLeak) {
  object_counter::all_count = object_counter::count = 0;
  try {
    scoped_ptr p(new object_counter);
   throw 1;
  } catch ( ... </span><span class="koboSpan" id="kobo.331.2">) {}
  EXPECT_EQ(0, object_counter::count);
  EXPECT_EQ(1, object_</span><a id="_idTextAnchor239"/><span class="koboSpan" id="kobo.332.1">counter::all_count);
}</span></pre>
<p><span class="koboSpan" id="kobo.333.1">All tests pass, confirming</span><a id="_idIndexMarker237"/><span class="koboSpan" id="kobo.334.1"> that there is </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">no leak:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.336.1">
[----------] 6 tests from Scoped_ptr
[ RUN      ] Scoped_ptr.AcquireRelease
[       OK ] Scoped_ptr.AcquireRelease (0 ms)
[ RUN      ] Scoped_ptr.EarlyReturnNoLeak
[       OK ] Scoped_ptr.EarlyReturnNoLeak (0 ms)
[ RUN      ] Scoped_ptr.ThrowNoLeak
[       OK ] Scoped_ptr.ThrowNoLeak (0 ms)
[ RUN      ] Scoped_ptr.DataMember
[       OK ] Scoped_ptr.DataMember (0 ms)
[ RUN      ] Scoped_ptr.Reset
[       OK ] Scoped_ptr.Reset (0 ms)
[ RUN      ] Scoped_ptr.Reseat
[       OK ] Scoped_ptr.Reseat (0 ms)
[----------] 6 tests from Scoped_ptr (0 ms total)</span></pre>
<p><span class="koboSpan" id="kobo.337.1">Similarly, we can use a scoped pointer as a data member in another class—a class that has secondary storage and must release it </span><span class="No-Break"><span class="koboSpan" id="kobo.338.1">upon destruction:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.339.1">
class A {
  public:
  A(object_counter* p) : p_(p) {}
  private:
  scoped_ptr&lt;object_counter&gt; p_;
};</span></pre>
<p><span class="koboSpan" id="kobo.340.1">This way, we don’t have to delete the object manually in the destructor of class </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">A</span></strong><span class="koboSpan" id="kobo.342.1">, and, in fact, if every data member of class </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">A</span></strong><span class="koboSpan" id="kobo.344.1"> takes care of itself in a similar fashion, class </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">A</span></strong><span class="koboSpan" id="kobo.346.1"> may not even need an </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">explicit destructor.</span></span></p>
<p><span class="koboSpan" id="kobo.348.1">Anyone familiar with C++11 should recognize our </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">scoped_ptr</span></strong><span class="koboSpan" id="kobo.350.1"> as a very rudimentary version of </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">std::unique_ptr</span></strong><span class="koboSpan" id="kobo.352.1">, which can be used for the same purpose. </span><span class="koboSpan" id="kobo.352.2">As you might expect, the standard unique pointer’s implementation has a lot more to it, and for good reasons. </span><span class="koboSpan" id="kobo.352.3">We will review some of these reasons later in this chapter, but, to be clear: you should use </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">std::unique_ptr</span></strong><span class="koboSpan" id="kobo.354.1"> in your code and the only reason we implemented our own </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">scoped_ptr</span></strong><span class="koboSpan" id="kobo.356.1"> here is to understand how an RAII </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">pointer works.</span></span></p>
<p><span class="koboSpan" id="kobo.358.1">One last issue to consider is that of performance. </span><span class="koboSpan" id="kobo.358.2">C++ strives for zero-overhead abstractions whenever possible. </span><span class="koboSpan" id="kobo.358.3">In this case, we are wrapping a raw pointer into a smart pointer object. </span><span class="koboSpan" id="kobo.358.4">However, the compiler does not need to generate any additional machine instructions; the wrapper only forces the compiler to generate the code that, in a correct program, it would have done anyway. </span><span class="koboSpan" id="kobo.358.5">We can confirm with a simple benchmark that both the construction/deletion and the dereference of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">scoped_ptr</span></strong><span class="koboSpan" id="kobo.360.1"> (or </span><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">std::unique_ptr</span></strong><span class="koboSpan" id="kobo.362.1">, for that matter) take exactly the same time as the corresponding operations on a raw pointer. </span><span class="koboSpan" id="kobo.362.2">For example, the following microbenchmark (using the Google benchmark library) compares the performance of all three pointer types </span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">for dereferencing:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.364.1">
// Example 07
void BM_rawptr_dereference(benchmark::State&amp; state) {
  int* p = new int;
  for (auto _ : state) {
    REPEAT(benchmark::DoNotOptimiz</span><a id="_idTextAnchor240"/><span class="koboSpan" id="kobo.365.1">e(*p);)
  }
  delete p;
  state.SetItemsProcessed(32*state.iterations());
}
void BM_scoped_ptr_dereference(benchmark::State&amp; state) {
  scoped_ptr&lt;int&gt; p(new int);
  for (auto _ : state) {
    REPEAT(benchmark::DoNotOptimize(*p);)
  }
  state.SetItemsProcessed(32*state.iterations());
}
void BM_unique_ptr_dereference(benchmark::State&amp; state) {
  std::unique_ptr&lt;int&gt; p(new int);
  for (auto _ : state) {
     REPEAT(benchmark::DoNotOptimize(*p);)
  }
  state.SetItemsProcessed(32*state.iterations());
}
BENCHMARK(BM_rawptr_dereference);
BENCHMARK(BM_scoped_ptr_ dereference);
BENCHMARK(BM_unique_ptr_dereference);
BENCHMARK_MAIN();</span></pre>
<p><span class="koboSpan" id="kobo.366.1">The benchmark shows that the </span><a id="_idIndexMarker238"/><span class="koboSpan" id="kobo.367.1">smart pointers indeed incur </span><span class="No-Break"><span class="koboSpan" id="kobo.368.1">no overhead:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.369.1">
----------------------------------------------------------------------
Benchmark                   Time        CPU Iterations UserCounters...
</span><span class="koboSpan" id="kobo.369.2">BM_rawptr_dereference      3.42 ns  3.42 ns  817698667 items_per_second=9.35646G/s
BM_scoped_ptr_dereference  3.37 ns  3.37 ns  826869427 items_per_second=9.48656G/s
BM_unique_ptr_dereference  3.42 ns  3.42 ns  827030287 items_per_second=9.36446G/s</span></pre>
<p><span class="koboSpan" id="kobo.370.1">We have covered in enough detail the applications of RAII for managing memory. </span><span class="koboSpan" id="kobo.370.2">But there are other resources that a C++ program needs to manage </span><a id="_idTextAnchor241"/><span class="koboSpan" id="kobo.371.1">and keep track of, so we have to expa</span><a id="_idTextAnchor242"/><span class="koboSpan" id="kobo.372.1">nd our view of </span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">RAII now.</span></span></p>
<h2 id="_idParaDest-90"><a id="_idTextAnchor243"/><span class="koboSpan" id="kobo.374.1">RAII for other resources</span></h2>
<p><span class="koboSpan" id="kobo.375.1">The name, RAII, refers to </span><em class="italic"><span class="koboSpan" id="kobo.376.1">resources </span></em><span class="koboSpan" id="kobo.377.1">and not </span><em class="italic"><span class="koboSpan" id="kobo.378.1">memory</span></em><span class="koboSpan" id="kobo.379.1">, and indeed the same approach is applicable to other resources. </span><span class="koboSpan" id="kobo.379.2">For each resource type, we need a special object, although generic programming and lambda expressions may help us to write less code (we will learn more about this in </span><a href="B19262_11.xhtml#_idTextAnchor509"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.380.1">Chapter 11</span></em></span></a><span class="koboSpan" id="kobo.381.1">, </span><em class="italic"><span class="koboSpan" id="kobo.382.1">ScopeGuard</span></em><span class="koboSpan" id="kobo.383.1">). </span><span class="koboSpan" id="kobo.383.2">The resource is acquired in the constructor and released in the destructor. </span><span class="koboSpan" id="kobo.383.3">Note that there are two slightly different flavors of RAII. </span><span class="koboSpan" id="kobo.383.4">The first option is the one we have already seen—the actual acquisition of the resource is at initialization, but outside of the constructor of the </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">RAII object.</span></span></p>
<p><span class="koboSpan" id="kobo.385.1">The constructor merely captures the handle (such as a pointer) that resulted from this acquisition. </span><span class="koboSpan" id="kobo.385.2">This was the case with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">scoped_ptr</span></strong><span class="koboSpan" id="kobo.387.1"> object that we just saw—memory allocation and object construction were both done outside of the constructor of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">scoped_ptr</span></strong><span class="koboSpan" id="kobo.389.1"> object, but still during its initialization. </span><span class="koboSpan" id="kobo.389.2">The second option is for the constructor of the RAII object to actually acquire the resource. </span><span class="koboSpan" id="kobo.389.3">Let’s see how this works, with the example of an RAII object that manages </span><span class="No-Break"><span class="koboSpan" id="kobo.390.1">mutex locks:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.391.1">
// Example 08
class mutex_guard {
  public:
  explicit mutex_guard(std::mutex&amp; m) : m_(m) {
    m_.lock();
  }
  ~mutex_guard() { m_.unlock(); }
  private:
  std::mutex&amp; m_;
};</span></pre>
<p><span class="koboSpan" id="kobo.392.1">Here, the constructor of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">mutex_guard</span></strong><span class="koboSpan" id="kobo.394.1"> class itself acquires the resource; in this case, exclusive access to the shared data protected by the mutex. </span><span class="koboSpan" id="kobo.394.2">The destructor releases that resource. </span><span class="koboSpan" id="kobo.394.3">Again, this</span><a id="_idIndexMarker239"/><span class="koboSpan" id="kobo.395.1"> pattern completely removes the possibility of </span><em class="italic"><span class="koboSpan" id="kobo.396.1">leaking </span></em><span class="koboSpan" id="kobo.397.1">a lock (that is, exiting a scope without releasing the lock), for example, when an exception </span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">is thrown:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.399.1">
// Example 08
std::mutex m;
TEST(MutexGuard, ThrowNoLeak) {
  try {
    mutex_guard lg(m);
    EXPECT_FALSE(m.try_lock());    // Expect to be locked
    throw 1;
  } catch ( ... </span><span class="koboSpan" id="kobo.399.2">) {}
  EXPECT_TRUE(m.try_lock());    // Expect to be unlocked
  m.unlock();    // try_lock() will lock, undo it
}</span></pre>
<p><span class="koboSpan" id="kobo.400.1">In this test, we check whether the mutex is locked or not by calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">std::mutex::try_lock()</span></strong><span class="koboSpan" id="kobo.402.1">—we cannot call </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">lock()</span></strong><span class="koboSpan" id="kobo.404.1"> if the mutex is already locked, as it will deadlock. </span><span class="koboSpan" id="kobo.404.2">By calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">try_lock()</span></strong><span class="koboSpan" id="kobo.406.1">, we can check the state of the mutex without the risk of deadlock (but remember to unlock the mutex if </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">try_lock()</span></strong><span class="koboSpan" id="kobo.408.1"> succeeds since we’re using </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">try_lock()</span></strong><span class="koboSpan" id="kobo.410.1"> just to test and don’t want to lock the </span><span class="No-Break"><span class="koboSpan" id="kobo.411.1">mutex again).</span></span></p>
<p><span class="koboSpan" id="kobo.412.1">Again, the standard provides an RAII object for mutex locking, </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">std::lock_guard</span></strong><span class="koboSpan" id="kobo.414.1">. </span><span class="koboSpan" id="kobo.414.2">It is used in a similar manner but can be applied to any mutex type that has the </span><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">lock()</span></strong><span class="koboSpan" id="kobo.416.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">unlock()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.418.1">member functions:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.419.1">
  try {
    std::lock_guard lg(m);        // C++17 constructor
    EXPECT_FALSE(m.try_lock());    // Expect to be locked
    throw 1;
  } catch ( ... </span><span class="koboSpan" id="kobo.419.2">) {}
  EXPECT_TRUE(m.try_lock());    // Expect to be unlocked</span></pre>
<p><span class="koboSpan" id="kobo.420.1">In C++17, we have a similar RAII object for locking multiple mutexes – </span><strong class="source-inline"><span class="koboSpan" id="kobo.421.1">std::scoped_lock</span></strong><span class="koboSpan" id="kobo.422.1">. </span><span class="koboSpan" id="kobo.422.2">In addition to the RAII release, it offers a deadlock avoidance algorithm when locking several</span><a id="_idIndexMarker240"/><span class="koboSpan" id="kobo.423.1"> mutexes at once. </span><span class="koboSpan" id="kobo.423.2">Of course, there are many more kinds of resources that a C++ program may have to manage, so we often end up writing our own RAII objects. </span><span class="koboSpan" id="kobo.423.3">Sometimes, the standard helps out, such as the addition of </span><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">std::jthread</span></strong><span class="koboSpan" id="kobo.425.1"> in C++20 (a thread is also a resource, and “</span><em class="italic"><span class="koboSpan" id="kobo.426.1">releasing</span></em><span class="koboSpan" id="kobo.427.1">” it usually means joining the thread, which is what </span><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">std::jthread</span></strong><span class="koboSpan" id="kobo.429.1"> does in its destructor). </span><span class="koboSpan" id="kobo.429.2">With the wide variety of resources that can be managed with RAII techniques, sometimes we have needs that go beyond automatically releasing resource</span><a id="_idTextAnchor244"/><a id="_idTextAnchor245"/><a id="_idTextAnchor246"/><span class="koboSpan" id="kobo.430.1">s at the end of </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">the scope.</span></span></p>
<h2 id="_idParaDest-91"><a id="_idTextAnchor247"/><span class="koboSpan" id="kobo.432.1">Releasing early</span></h2>
<p><span class="koboSpan" id="kobo.433.1">The scope of a function or a loop</span><a id="_idIndexMarker241"/><span class="koboSpan" id="kobo.434.1"> body does not always match the desired duration of the holding of the resource. </span><span class="koboSpan" id="kobo.434.2">If we do not want to acquire the resource at the very beginning of the scope, this is easy—the RAII object can be created anywhere, not just at the beginning of the scope. </span><span class="koboSpan" id="kobo.434.3">Resources are not acquired until the RAII object is constructed, </span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.436.1">
void process(...) {
  ... </span><span class="koboSpan" id="kobo.436.2">do work that does not need exclusive access ...
</span><span class="koboSpan" id="kobo.436.3">  mutex_guard lg(m);    // Now we lock
  ... </span><span class="koboSpan" id="kobo.436.4">work on shared data, now protected by mutex ...
</span><span class="koboSpan" id="kobo.436.5">} // lock is released here</span></pre>
<p><span class="koboSpan" id="kobo.437.1">However, the release still happens at the end of the function body scope. </span><span class="koboSpan" id="kobo.437.2">What if we only want to lock a short portion of code inside the function? </span><span class="koboSpan" id="kobo.437.3">The simplest answer is to create an </span><span class="No-Break"><span class="koboSpan" id="kobo.438.1">additional scope:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.439.1">
void process(...) {
  ... </span><span class="koboSpan" id="kobo.439.2">do work that does not need exclusive access ...
</span><span class="koboSpan" id="kobo.439.3">  {
    mutex_guard lg(m);    // Now we lock
    ... </span><span class="koboSpan" id="kobo.439.4">work on shared data, now protected by mutex ...
</span><span class="koboSpan" id="kobo.439.5">  } // lock is released here
  ... </span><span class="koboSpan" id="kobo.439.6">more non-exclusive work ...
</span><span class="koboSpan" id="kobo.439.7">}</span></pre>
<p><span class="koboSpan" id="kobo.440.1">It may be surprising if you have never seen it before, but in C++, any sequence of statements can be enclosed in the curly braces, as </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">{ ... </span><span class="koboSpan" id="kobo.441.2">}</span></strong><span class="koboSpan" id="kobo.442.1">. </span><span class="koboSpan" id="kobo.442.2">Doing so creates a new scope with its own local variables. </span><span class="koboSpan" id="kobo.442.3">Unlike the curly braces that come after loops or conditional statements, the only purpose of this scope is to control the lifetime of these local variables. </span><span class="koboSpan" id="kobo.442.4">A program </span><a id="_idIndexMarker242"/><span class="koboSpan" id="kobo.443.1">that uses RAII extensively often has many such scopes, enclosing variables with different lifetimes that are shorter than the overall function or loop body. </span><span class="koboSpan" id="kobo.443.2">This practice also improves readability by making it clear that some variables will not be used after a certain point, so the reader does not need to scan the rest of the code looking for possible references to these variables. </span><span class="koboSpan" id="kobo.443.3">Also, the user cannot accidentally add such a reference by mistake if the intent is to </span><em class="italic"><span class="koboSpan" id="kobo.444.1">expire</span></em><span class="koboSpan" id="kobo.445.1"> a variable and never use </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">it again.</span></span></p>
<p><span class="koboSpan" id="kobo.447.1">And what if a resource may be released early, but only if certain conditions are met? </span><span class="koboSpan" id="kobo.447.2">One possibility is, again, to contain the use of the resource in a scope, and exit that scope when the resource is no longer needed. </span><span class="koboSpan" id="kobo.447.3">It would be convenient to be able to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">break</span></strong><span class="koboSpan" id="kobo.449.1"> to get out of a scope. </span><span class="koboSpan" id="kobo.449.2">A common way to do just that is to write a </span><em class="italic"><span class="koboSpan" id="kobo.450.1">do </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.451.1">once</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.452.1"> loop:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.453.1">
// Example 08
void process(...) {
  ... </span><span class="koboSpan" id="kobo.453.2">do work that does not need exclusive access ...
</span><span class="koboSpan" id="kobo.453.3">  </span><a id="_idTextAnchor248"/><span class="koboSpan" id="kobo.454.1">do {    // Not really a loop
    mutex_guard lg(m);    // Now we lock
    ... </span><span class="koboSpan" id="kobo.454.2">work on shared data, now protected by mutex ...
</span><span class="koboSpan" id="kobo.454.3">    if (work_done) break;    // Exit the scope
    ... </span><span class="koboSpan" id="kobo.454.4">work on the shared data some more ...
</span><span class="koboSpan" id="kobo.454.5">  } while (false);        // lock is released here
  ... </span><span class="koboSpan" id="kobo.454.6">more non-exclusive work ...
</span><span class="koboSpan" id="kobo.454.7">}</span></pre>
<p><span class="koboSpan" id="kobo.455.1">However, this approach does not always work (we may want to release the resources, but not other local variables we defined in the same scope), and the readability of the code suffers as the </span><a id="_idIndexMarker243"/><span class="koboSpan" id="kobo.456.1">control flow gets more complex. </span><span class="koboSpan" id="kobo.456.2">Resist the impulse to accomplish this by allocating the RAII object dynamically, with </span><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">operator new</span></strong><span class="koboSpan" id="kobo.458.1">! </span><span class="koboSpan" id="kobo.458.2">This completely defeats the whole point of RAII, since you now must remember to invoke </span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">operator delete</span></strong><span class="koboSpan" id="kobo.460.1">. </span><span class="koboSpan" id="kobo.460.2">We can enhance our resource-managing objects by adding a client-triggered release, in addition to the automatic release by the destructor. </span><span class="koboSpan" id="kobo.460.3">We just have to make sure that the same resource is not released twice. </span><span class="koboSpan" id="kobo.460.4">Consider the following example, </span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">scoped_ptr</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.463.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.464.1">
// Example 06
template &lt;typename T&gt; class scoped_ptr {
  public:
  explicit scoped_ptr(T* p) : p_(p) {}
  ~scoped_ptr() { delete p_; }
  ...
</span><span class="koboSpan" id="kobo.464.2">  void reset() {
    delete p_;
    p_ = nullptr;     // Releases resource early private:
  }
  T* p_;
};</span></pre>
<p><span class="koboSpan" id="kobo.465.1">After calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">reset()</span></strong><span class="koboSpan" id="kobo.467.1">, the object managed by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">scoped_ptr</span></strong><span class="koboSpan" id="kobo.469.1"> object is deleted, and the pointer data member of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.470.1">scoped_ptr</span></strong><span class="koboSpan" id="kobo.471.1"> object is reset to null. </span><span class="koboSpan" id="kobo.471.2">Note that we did not need to add a condition check to the destructor, because calling delete on a null pointer is allowed by the standard—it does nothing. </span><span class="koboSpan" id="kobo.471.3">The resource is released only once, either explicitly by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">reset()</span></strong><span class="koboSpan" id="kobo.473.1"> call, or implicitly at the end of the scope containing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">scoped_ptr</span></strong><span class="koboSpan" id="kobo.475.1"> object. </span><span class="koboSpan" id="kobo.475.2">As we already noted, you do not need to write your own </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">scoped_ptr</span></strong><span class="koboSpan" id="kobo.477.1"> except to learn how RAII pointers work: </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">std::unique_ptr</span></strong><span class="koboSpan" id="kobo.479.1"> can be </span><span class="No-Break"><span class="koboSpan" id="kobo.480.1">reset too.</span></span></p>
<p><span class="koboSpan" id="kobo.481.1">For the </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">mutex_guard</span></strong><span class="koboSpan" id="kobo.483.1"> class, we can’t deduce from just the lock whether an early release was called or not, and we</span><a id="_idIndexMarker244"/><span class="koboSpan" id="kobo.484.1"> need an additional data member to keep track </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">of that:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.486.1">
// Example 08
class mutex_guard {
  public:
  explicit mutex_guard(std::mutex&amp; m) :
    m_(m), must_unlock_(true) { m_.lock(); }
  ~mutex_guard() { if (must_unlock_) m_.unlock(); }
   void reset() { m_.unlock(); must_unlock_ = false; }
  private:
  std::mutex&amp; m_;
  bool must_unlock_;
};</span></pre>
<p><span class="koboSpan" id="kobo.487.1">Now we can verify that the mutex is released only once, at the right time, with </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">this test:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.489.1">
TEST(MutexGuard, Reset) {
  {
    mutex_guard lg(m);
    EXPECT_FALSE(m.try_lock());
    lg.reset();
    EXPECT_TRUE(m.try_lock()); m.unlock();
  }
  EXPECT_TRUE(m.try_lock()); m.unlock();
}</span></pre>
<p><span class="koboSpan" id="kobo.490.1">The standard </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">std::unique_ptr</span></strong><span class="koboSpan" id="kobo.492.1"> pointer supports </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">reset()</span></strong><span class="koboSpan" id="kobo.494.1">, whereas </span><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">std::lock_guard</span></strong><span class="koboSpan" id="kobo.496.1"> does not, so if you need to release a mutex early, you need to use a different standard RAII </span><span class="No-Break"><span class="koboSpan" id="kobo.497.1">object, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">std::unique_lock</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.499.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.500.1">
// Example 08
TEST(LockGuard, Reset) {
  {
    std::unique_lock lg(m);
    EXPECT_FALSE(m.try_lock());
    lg.unlock();
    EXPECT_TRUE(m.try_lock()); m.unlock();
  }
  EXPECT_TRUE(m.try_lock()); m.unlock();
}</span></pre>
<p><span class="koboSpan" id="kobo.501.1">For other resources, you may have to write your own RAII object, which is usually a pretty simple class, but finish reading this chapter before you start writing, as there are a few </span><em class="italic"><span class="koboSpan" id="kobo.502.1">gotchas</span></em><span class="koboSpan" id="kobo.503.1"> to keep </span><span class="No-Break"><span class="koboSpan" id="kobo.504.1">in mind.</span></span></p>
<p><span class="koboSpan" id="kobo.505.1">Note that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">reset()</span></strong><span class="koboSpan" id="kobo.507.1"> method of </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">std::unique_ptr</span></strong><span class="koboSpan" id="kobo.509.1"> actually does more than just delete the object prematurely. </span><span class="koboSpan" id="kobo.509.2">It can also be used to </span><strong class="bold"><span class="koboSpan" id="kobo.510.1">reset</span></strong><span class="koboSpan" id="kobo.511.1"> the pointer by making it point to a new object while the </span><a id="_idIndexMarker245"/><span class="koboSpan" id="kobo.512.1">old one is deleted. </span><span class="koboSpan" id="kobo.512.2">It works something like this (the actual implementation in the standard is a bit more complex, because of the additional functionality the unique </span><span class="No-Break"><span class="koboSpan" id="kobo.513.1">pointer has):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.514.1">
template &lt;typename T&gt; class scoped_ptr {
  public:
  explicit scoped_ptr(T* p) : p_(p) {}
  ~scoped_ptr() { delete p_; }
  ...
</span><span class="koboSpan" id="kobo.514.2">  void reset(T* p = nullptr) {
    delete p_; p_ = p;    // Reseat the pointer
  }
  private:
  T* p_;
};</span></pre>
<p><span class="koboSpan" id="kobo.515.1">Note that this code breaks if</span><a id="_idIndexMarker246"/><span class="koboSpan" id="kobo.516.1"> a scoped pointer is reset to itself (for example, if </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">reset()</span></strong><span class="koboSpan" id="kobo.518.1"> is called with the same value as that stored in </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">p_</span></strong><span class="koboSpan" id="kobo.520.1">). </span><span class="koboSpan" id="kobo.520.2">We could check for this condition and do nothing; it is worth noting that the standard does not require s</span><a id="_idTextAnchor249"/><a id="_idTextAnchor250"/><a id="_idTextAnchor251"/><span class="koboSpan" id="kobo.521.1">uch a check </span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">std::unique_ptr</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">.</span></span></p>
<h2 id="_idParaDest-92"><a id="_idTextAnchor252"/><span class="koboSpan" id="kobo.525.1">Careful implementation of Resource Acquisition is Initialization objects</span></h2>
<p><span class="koboSpan" id="kobo.526.1">It is obviously very important </span><a id="_idIndexMarker247"/><span class="koboSpan" id="kobo.527.1">that the resource management objects do not mismanage the resources they are entrusted to guard. </span><span class="koboSpan" id="kobo.527.2">Unfortunately, the simple RAII objects we have been writing so far have several </span><span class="No-Break"><span class="koboSpan" id="kobo.528.1">glaring holes.</span></span></p>
<p><span class="koboSpan" id="kobo.529.1">The first problem arises when someone tries to copy these objects. </span><span class="koboSpan" id="kobo.529.2">Each of the RAII objects we have considered in this chapter is responsible for managing a unique instance of its resource, and yet, nothing prevents us from copying </span><span class="No-Break"><span class="koboSpan" id="kobo.530.1">this object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.531.1">
scoped_ptr&lt;object_counter&gt; p(new object_counter);
scoped_ptr&lt;object_counter&gt; p1(p);</span></pre>
<p><span class="koboSpan" id="kobo.532.1">This code invokes the default copy constructor, which simply copies the bits inside the object; in our case, the pointer is copied to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">object_counter</span></strong><span class="koboSpan" id="kobo.534.1">. </span><span class="koboSpan" id="kobo.534.2">Now we have two RAII objects that both control the same resource. </span><span class="koboSpan" id="kobo.534.3">Two destructors will be called, eventually, and both will attempt to delete the same object. </span><span class="koboSpan" id="kobo.534.4">The second deletion is undefined behavior (if we are very fortunate, the program will crash at </span><span class="No-Break"><span class="koboSpan" id="kobo.535.1">that point).</span></span></p>
<p><span class="koboSpan" id="kobo.536.1">Assignment of RAII objects is </span><span class="No-Break"><span class="koboSpan" id="kobo.537.1">similarly problematic:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.538.1">
scoped_ptr&lt;object_counter&gt; p(new object_counter);
scoped_ptr&lt;object_counter&gt; p1(new object_counter);
p = p1;</span></pre>
<p><span class="koboSpan" id="kobo.539.1">The default assignment operator also copies the bits of the object. </span><span class="koboSpan" id="kobo.539.2">Again, we have two RAII objects that will delete the same managed object. </span><span class="koboSpan" id="kobo.539.3">Equally troublesome are the facts that we have no RAII objects that manage the second </span><strong class="source-inline"><span class="koboSpan" id="kobo.540.1">object_counter</span></strong><span class="koboSpan" id="kobo.541.1">, the old pointer inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.542.1">p1</span></strong><span class="koboSpan" id="kobo.543.1"> is gone, and there is no other reference to this object, so we have no way to </span><span class="No-Break"><span class="koboSpan" id="kobo.544.1">delete it.</span></span></p>
<p><span class="koboSpan" id="kobo.545.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">mutex_guard</span></strong><span class="koboSpan" id="kobo.547.1"> does no better—an attempt to copy it results in two mutex guards that will unlock the same mutex. </span><span class="koboSpan" id="kobo.547.2">The second unlock will be done on a mutex that is not locked (at least not by the calling thread), which, according to the standard, is undefined behavior. </span><span class="koboSpan" id="kobo.547.3">Assignment of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">mutex_guard</span></strong><span class="koboSpan" id="kobo.549.1"> object is not possible, though, because the default assignment operator is not generated for obj</span><a id="_idTextAnchor253"/><span class="koboSpan" id="kobo.550.1">ects with reference </span><span class="No-Break"><span class="koboSpan" id="kobo.551.1">data members.</span></span></p>
<p><span class="koboSpan" id="kobo.552.1">As you may have probably noticed, the </span><a id="_idIndexMarker248"/><span class="koboSpan" id="kobo.553.1">problem is created by the </span><strong class="bold"><span class="koboSpan" id="kobo.554.1">default</span></strong><span class="koboSpan" id="kobo.555.1"> copy constructor and default assignment operator. </span><span class="koboSpan" id="kobo.555.2">Does it mean that we should have implemented our own? </span><span class="koboSpan" id="kobo.555.3">What would they do? </span><span class="koboSpan" id="kobo.555.4">Only one destructor should be called for each object that was constructed; a mutex can only be unlocked once after it was locked. </span><span class="koboSpan" id="kobo.555.5">This suggests that an RAII object should not be copied at all, and we should disallow both copying </span><span class="No-Break"><span class="koboSpan" id="kobo.556.1">and assignment:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.557.1">
template &lt;typename T&gt; class scoped_ptr {
  public:
  explicit scoped_ptr(T* p) : p_(p) {}
  ~scoped_ptr() { delete p_; }
  ...
</span><span class="koboSpan" id="kobo.557.2">  private:
  T* p_;
  scoped_ptr(const scoped_ptr&amp;) = delete;
  scoped_ptr&amp; operator=(const scoped_ptr&amp;) = delete;
};</span></pre>
<p><span class="koboSpan" id="kobo.558.1">There are some RAII objects that can be copied. </span><span class="koboSpan" id="kobo.558.2">These are reference-counted resource management objects; they keep track of how many copies of the RAII object exist for the same instance of the managed resource. </span><span class="koboSpan" id="kobo.558.3">The last of the RAII objects has to release the resource when it is deleted. </span><span class="koboSpan" id="kobo.558.4">We discuss shared management of resources in more detail in </span><a href="B19262_03.xhtml#_idTextAnchor110"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.559.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.560.1">, </span><em class="italic"><span class="koboSpan" id="kobo.561.1">Memory </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.562.1">and Ownership</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.563.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.564.1">A different set of considerations exist for move constructor and assignment. </span><span class="koboSpan" id="kobo.564.2">Moving the object does not violate the assumption that there is only one RAII object that owns a particular resource. </span><span class="koboSpan" id="kobo.564.3">It merely changes which RAII object that is. </span><span class="koboSpan" id="kobo.564.4">In many cases, such as mutex guards, it does not make sense to move an RAII object (indeed, the standard does not make </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">std::lock_guard</span></strong><span class="koboSpan" id="kobo.566.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">std::scoped_lock</span></strong><span class="koboSpan" id="kobo.568.1"> movable, but </span><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">std::unique_lock</span></strong><span class="koboSpan" id="kobo.570.1"> is movable and can be used to transfer ownership of a mutex). </span><span class="koboSpan" id="kobo.570.2">Moving a unique pointer is possible and makes sense in some contexts, which we also explore in </span><a href="B19262_03.xhtml#_idTextAnchor110"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.571.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.572.1">, </span><em class="italic"><span class="koboSpan" id="kobo.573.1">Memory </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.574.1">and Ownership</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.575.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.576.1">However, for a scoped</span><a id="_idIndexMarker249"/><span class="koboSpan" id="kobo.577.1"> pointer, moving would be undesirable, as it allows the extension of the lifetime of the managed object beyond the scope where it was created. </span><span class="koboSpan" id="kobo.577.2">Note that we do not need to delete the move constructor or move assignment operators if we already deleted the copying ones (although doing so does no harm). </span><span class="koboSpan" id="kobo.577.3">On the other hand, </span><strong class="source-inline"><span class="koboSpan" id="kobo.578.1">std::unique_ptr</span></strong><span class="koboSpan" id="kobo.579.1"> is a movable object, which means using it as a scope-guarding smart pointer does not offer the same protection because the resource could be moved out. </span><span class="koboSpan" id="kobo.579.2">However, if you need a scoped pointer, there is a very simple way to make </span><strong class="source-inline"><span class="koboSpan" id="kobo.580.1">std::unique_ptr</span></strong><span class="koboSpan" id="kobo.581.1"> do this job perfectly—all you have to do is to declare a </span><strong class="source-inline"><span class="koboSpan" id="kobo.582.1">const </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">std::unique_ptr</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.584.1"> object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.585.1">
std::unique_ptr&lt;int&gt; p;
{
  // Can be moved out of the scope
  std::unique_ptr&lt;int&gt; q(new int);
  q = std::move(p);    // and here it happens
  // True scoped pointer, cannot be moved anywhere
  const std::unique_ptr&lt;int&gt; r(new int);
  q = std::move(r);    // Does not compile
}</span></pre>
<p><span class="koboSpan" id="kobo.586.1">So far, we have protected our RAII objects against duplicating or losing resources. </span><span class="koboSpan" id="kobo.586.2">But there is one more kind of resource management mistake that we have not yet considered. </span><span class="koboSpan" id="kobo.586.3">It seems obvious that a resource should be released in a way that matches its acquisition. </span><span class="koboSpan" id="kobo.586.4">And yet, nothing protects our </span><strong class="source-inline"><span class="koboSpan" id="kobo.587.1">scoped_ptr</span></strong><span class="koboSpan" id="kobo.588.1"> object from such a mismatch between construction </span><span class="No-Break"><span class="koboSpan" id="kobo.589.1">and deletion:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.590.1">
scoped_ptr&lt;int&gt; p(new int[10]);</span></pre>
<p><span class="koboSpan" id="kobo.591.1">The problem here is that we have allocated multiple objects using an array version of </span><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">operator new</span></strong><span class="koboSpan" id="kobo.593.1">; it should be deleted with the array version of </span><strong class="source-inline"><span class="koboSpan" id="kobo.594.1">operator delete </span></strong><span class="koboSpan" id="kobo.595.1">- </span><strong class="source-inline"><span class="koboSpan" id="kobo.596.1">delete [] p_</span></strong><span class="koboSpan" id="kobo.597.1"> must be called inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.598.1">scoped_ptr</span></strong><span class="koboSpan" id="kobo.599.1"> destructor, instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.600.1">delete p_</span></strong><span class="koboSpan" id="kobo.601.1"> that we have </span><span class="No-Break"><span class="koboSpan" id="kobo.602.1">there now.</span></span></p>
<p><span class="koboSpan" id="kobo.603.1">More generally, an RAII object that accepts a resource handle during initialization, instead of acquiring the resource itself (like the </span><strong class="source-inline"><span class="koboSpan" id="kobo.604.1">mutex_guard</span></strong><span class="koboSpan" id="kobo.605.1"> does) must somehow ensure that the resource </span><a id="_idIndexMarker250"/><span class="koboSpan" id="kobo.606.1">is released in the right way that matches the way it was acquired. </span><span class="koboSpan" id="kobo.606.2">Obviously, this is not possible, in general. </span><span class="koboSpan" id="kobo.606.3">In fact, it is impossible to do automatically, even for the simple case of a mismatched </span><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">new</span></strong><span class="koboSpan" id="kobo.608.1"> array and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">delete</span></strong><span class="koboSpan" id="kobo.610.1"> scalar (</span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">std::unique_ptr</span></strong><span class="koboSpan" id="kobo.612.1"> does no better than our </span><strong class="source-inline"><span class="koboSpan" id="kobo.613.1">scoped_ptr</span></strong><span class="koboSpan" id="kobo.614.1"> here, although facilities such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">std::make_unique</span></strong><span class="koboSpan" id="kobo.616.1"> make </span><a id="_idTextAnchor254"/><span class="koboSpan" id="kobo.617.1">writing such code </span><span class="No-Break"><span class="koboSpan" id="kobo.618.1">less error-prone).</span></span></p>
<p><span class="koboSpan" id="kobo.619.1">In general, either the RAII class is designed to release resources in one particular way, or the caller must specify how the resource must be released. </span><span class="koboSpan" id="kobo.619.2">The former is certainly easier, and in many cases is quite sufficient. </span><span class="koboSpan" id="kobo.619.3">In particular, if the RAII class also acquires a resource, such as our </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">mutex_guard</span></strong><span class="koboSpan" id="kobo.621.1">, it certainly knows how to release it. </span><span class="koboSpan" id="kobo.621.2">Even for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.622.1">scoped_ptr</span></strong><span class="koboSpan" id="kobo.623.1">, it would not be too hard to create two versions, </span><strong class="source-inline"><span class="koboSpan" id="kobo.624.1">scoped_ptr</span></strong><span class="koboSpan" id="kobo.625.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.626.1">scoped_array</span></strong><span class="koboSpan" id="kobo.627.1">; the second one is for objects allocated by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.628.1">operator new</span></strong><span class="koboSpan" id="kobo.629.1"> array. </span><span class="koboSpan" id="kobo.629.2">The standard handles it by specializing the unique pointer for arrays: you can write </span><strong class="source-inline"><span class="koboSpan" id="kobo.630.1">std::unique_ptr&lt;int[]&gt;</span></strong><span class="koboSpan" id="kobo.631.1"> and the array </span><strong class="source-inline"><span class="koboSpan" id="kobo.632.1">delete</span></strong><span class="koboSpan" id="kobo.633.1"> will be used (it is still up to the programmer to make sure that arrays allocated by </span><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">new[]</span></strong><span class="koboSpan" id="kobo.635.1"> are owned by the correct instantiation of </span><span class="No-Break"><span class="koboSpan" id="kobo.636.1">the pointer).</span></span></p>
<p><span class="koboSpan" id="kobo.637.1">A more general version of an RAII class is parameterized not just by the resource type, but also by a callable object used to release this type, usually known as the deleter. </span><span class="koboSpan" id="kobo.637.2">The deleter can be a function pointer, a member function pointer, or an object with </span><strong class="source-inline"><span class="koboSpan" id="kobo.638.1">operator()</span></strong><span class="koboSpan" id="kobo.639.1"> defined—basically, anything that can be called like a function. </span><span class="koboSpan" id="kobo.639.2">Note that the deleter has to be passed to the RAII object in its constructor, and stored inside the RAII object, which makes the object larger. </span><span class="koboSpan" id="kobo.639.3">Also, the type of the deleter is a template parameter of the RAII clas</span><a id="_idTextAnchor255"/><span class="koboSpan" id="kobo.640.1">s, unless it is erased from the RAII type (this will be covered in </span><a href="B19262_06.xhtml#_idTextAnchor266"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.641.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.642.1">, </span><em class="italic"><span class="koboSpan" id="kobo.643.1">Understanding Type Erasure</span></em><span class="koboSpan" id="kobo.644.1">). </span><span class="koboSpan" id="kobo.644.2">The standard gives us examples of both: </span><strong class="source-inline"><span class="koboSpan" id="kobo.645.1">std::unique_ptr</span></strong><span class="koboSpan" id="kobo.646.1"> has the deleter template parameter, whil</span><a id="_idTextAnchor256"/><span class="koboSpan" id="kobo.647.1">e </span><strong class="source-inline"><span class="koboSpan" id="kobo.648.1">std::shared_ptr</span></strong><span class="koboSpan" id="kobo.649.1"> uses </span><span class="No-Break"><span class="koboSpan" id="kobo.650.1">type erasure.</span></span></p>
<h2 id="_idParaDest-93"><a id="_idTextAnchor257"/><span class="koboSpan" id="kobo.651.1">Downsides of RAII</span></h2>
<p><span class="koboSpan" id="kobo.652.1">Honestly, there aren’t any significant downsides to RAII. </span><span class="koboSpan" id="kobo.652.2">It is by far the most widely used idiom for resource management in C++. </span><span class="koboSpan" id="kobo.652.3">The only issue of significance to be aware of has to do with exceptions. </span><span class="koboSpan" id="kobo.652.4">Releasing </span><a id="_idIndexMarker251"/><span class="koboSpan" id="kobo.653.1">a resource can fail, like anything else. </span><span class="koboSpan" id="kobo.653.2">The usual way in C++ to signal a failure is to throw an exception. </span><span class="koboSpan" id="kobo.653.3">When that is undesirable, we fall back on returning error codes from functions. </span><span class="koboSpan" id="kobo.653.4">With RAII, we can do neither of </span><span class="No-Break"><span class="koboSpan" id="kobo.654.1">these things.</span></span></p>
<p><span class="koboSpan" id="kobo.655.1">It is easy to understand why error codes are not an option—the destructor does not return anything. </span><span class="koboSpan" id="kobo.655.2">Also, we cannot write the error code into some status data member of the object, since the object is being destroyed and its data members are gone, as are the other local variables from the scope containing the RAII object. </span><span class="koboSpan" id="kobo.655.3">The only way to save an error code for future examination would be to write it into some sort of a global status variable, or at least a variable from the containing scope. </span><span class="koboSpan" id="kobo.655.4">This is possible in a bind, but such a solution is very inelegant and error-prone. </span><span class="koboSpan" id="kobo.655.5">This is exactly the problem that C++ was trying to solve when exceptions were introduced: manually-propagated error codes are error-prone </span><span class="No-Break"><span class="koboSpan" id="kobo.656.1">and unreliable.</span></span></p>
<p><span class="koboSpan" id="kobo.657.1">So, if the exceptions are the answer to error reporting in C++, why not use them here? </span><span class="koboSpan" id="kobo.657.2">The usual answer is </span><em class="italic"><span class="koboSpan" id="kobo.658.1">that the destructors in C++ cannot throw</span></em><span class="koboSpan" id="kobo.659.1">. </span><span class="koboSpan" id="kobo.659.2">This captures the gist of it, but the real restriction is a bit more nuanced. </span><span class="koboSpan" id="kobo.659.3">First of all, prior to C++11, the destructors technically could throw, but the exception would propagate and (hopefully) eventually get caught and processed. </span><span class="koboSpan" id="kobo.659.4">In C++11, all destructors are, by default, </span><strong class="source-inline"><span class="koboSpan" id="kobo.660.1">noexcept</span></strong><span class="koboSpan" id="kobo.661.1">, unless explicitly specified as </span><strong class="source-inline"><span class="koboSpan" id="kobo.662.1">noexcept(false)</span></strong><span class="koboSpan" id="kobo.663.1">. </span><span class="koboSpan" id="kobo.663.2">If a </span><strong class="source-inline"><span class="koboSpan" id="kobo.664.1">noexcept</span></strong><span class="koboSpan" id="kobo.665.1"> function throws</span><a id="_idTextAnchor258"/><span class="koboSpan" id="kobo.666.1">, the program </span><span class="No-Break"><span class="koboSpan" id="kobo.667.1">immediately terminates.</span></span></p>
<p><span class="koboSpan" id="kobo.668.1">So indeed, in C++11, destructors cannot throw unless you specifically allow them to do so. </span><span class="koboSpan" id="kobo.668.2">But what’s wrong with throwing an exception in the destructor? </span><span class="koboSpan" id="kobo.668.3">If the destructor is executed because the object was deleted, or because the control reached the end of the scope for a stack object, then nothing is wrong. </span><span class="koboSpan" id="kobo.668.4">The </span><em class="italic"><span class="koboSpan" id="kobo.669.1">wrong</span></em><span class="koboSpan" id="kobo.670.1"> happens if the control did not reach the end of the scope normally and the destructor is executed because an exception was already thrown. </span><span class="koboSpan" id="kobo.670.2">In C++, two exceptions cannot propagate at the same time. </span><span class="koboSpan" id="kobo.670.3">If this happens, the program will immediately terminate (note that a destructor can throw and catch an exception, there is no problem with that, as long as that exception does not propagate out of the destructor). </span><span class="koboSpan" id="kobo.670.4">Of course, when writing a program, there is no way to know when some function called from something in a particular scope, could throw. </span><span class="koboSpan" id="kobo.670.5">If the resource release throws and the RAII object allows that exception to propagate out of its destructor, the program is going to terminate if that destructor was called during exception handling. </span><span class="koboSpan" id="kobo.670.6">The only safe way is never to allow exceptions to propagate from </span><span class="No-Break"><span class="koboSpan" id="kobo.671.1">a destructor.</span></span></p>
<p><span class="koboSpan" id="kobo.672.1">This does not mean that the function that releases the resource itself cannot throw, but, if it does, an RAII destructor has to catch </span><span class="No-Break"><span class="koboSpan" id="kobo.673.1">that exception:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.674.1">
class raii {
  ...
</span><span class="koboSpan" id="kobo.674.2">  ~raii() {
    try {
      release_resource();    // Might throw
    } catch ( ... </span><span class="koboSpan" id="kobo.674.3">) {
      ... </span><span class="koboSpan" id="kobo.674.4">handle the exception, do NOT rethrow ...
</span><span class="koboSpan" id="kobo.674.5">    }
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.675.1">This still leaves us with no way to signal that an error happened during resource release—an exception was thrown, and we had to catch it and not let </span><span class="No-Break"><span class="koboSpan" id="kobo.676.1">it escape.</span></span></p>
<p><span class="koboSpan" id="kobo.677.1">How much of a problem is this? </span><span class="koboSpan" id="kobo.677.2">Not that much, really. </span><span class="koboSpan" id="kobo.677.3">First of all, releasing memory—the most frequently managed resource—does not throw an exception. </span><span class="koboSpan" id="kobo.677.4">Usually, the memory is released not as just memory, but by deleting an object. </span><span class="koboSpan" id="kobo.677.5">But remember that the destructors should not throw an exception in order that the entire process of releasing memory by deleting an object doesn’t throw an exception either. </span><span class="koboSpan" id="kobo.677.6">At this point, the reader might, in search of a counter-example, look up in the standard what happens if unlocking a mutex fails (that would force the destructor of </span><strong class="source-inline"><span class="koboSpan" id="kobo.678.1">std::lock_guard</span></strong><span class="koboSpan" id="kobo.679.1"> to deal with the error). </span><span class="koboSpan" id="kobo.679.2">The answer is both surprising and enlightening—unlocking a mutex cannot throw, but if it fails, undefined behavior results instead. </span><span class="koboSpan" id="kobo.679.3">This is no accident; the mutex was intended to work with an RAII object. </span><span class="koboSpan" id="kobo.679.4">Such is, in general, the C++ approach to releasing the resources: an exception should not be thrown if the release fails, or at least not allowed to propagate. </span><span class="koboSpan" id="kobo.679.5">It can be caught and logged, for example, but the calling program will, in general, remain unaware of the failure, possibly at the cost of </span><span class="No-Break"><span class="koboSpan" id="kobo.680.1">undefined behavior.</span></span></p>
<p><span class="koboSpan" id="kobo.681.1">RAII is a really successful technique that has evolved very little even as the language changes significantly from pre-C++11 all the way to C++20 (aside from minor syntactic conveniences such as constructor argument deduction). </span><span class="koboSpan" id="kobo.681.2">That is because it really doesn’t have any downsides of note. </span><span class="koboSpan" id="kobo.681.3">But, as the language gets new capabilities, sometimes we find ways to improve even the best and most </span><a id="_idIndexMarker252"/><span class="koboSpan" id="kobo.682.1">established patterns, and here is one of </span><span class="No-Break"><span class="koboSpan" id="kobo.683.1">those cases.</span></span></p>
<h1 id="_idParaDest-94"><a id="_idTextAnchor259"/><span class="koboSpan" id="kobo.684.1">Very modern RAII</span></h1>
<p><span class="koboSpan" id="kobo.685.1">If we really want to be picky, we</span><a id="_idIndexMarker253"/><span class="koboSpan" id="kobo.686.1"> can make another complaint about RAII; realistically, this is only a downside when the acquisition or release code is long and complex. </span><span class="koboSpan" id="kobo.686.2">The acquisition and release are done in the constructor and the destructor of an RAII object, respectively, and this code can be quite removed from the place in the code where the resource is acquired (so we have to jump around the program a bit to figure out what </span><span class="No-Break"><span class="koboSpan" id="kobo.687.1">it does).</span></span></p>
<p><span class="koboSpan" id="kobo.688.1">Similarly, if the resource handling requires a lot of state (such as the appropriate actions depending on several factors and conditions), we have to capture all this state in the RAII object. </span><span class="koboSpan" id="kobo.688.2">An example that truly challenges the readability of RAII would also be completely unreadable on a book page, so we will have to condense it. </span><span class="koboSpan" id="kobo.688.3">Let us say that we want to have an RAII lock guard that performs several actions when locking and unlocking the mutex, and even the way it handles the resource depends on some </span><span class="No-Break"><span class="koboSpan" id="kobo.689.1">external parameters:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.690.1">
// Example 09a
class lock_guard {
  std::mutex&amp; m_;
  const bool log_;
  const bool mt_;
  public:
  lock_guard(std::mutex&amp; m, bool log, bool mt);
  ~lock_guard();
};
lock_guard ::lock_guard(std::mutex&amp; m, bool log, bool mt)
  : m_(m), log_(log), mt_(mt) {
  if (log_) std::cout &lt;&lt; "Before locking" &lt;&lt; std::endl;
  if (mt_) m.lock();
}
lock_guard::~lock_guard() {
  if (mt_) m.unlock();
  if (log_) std::cout &lt;&lt; "After locking" &lt;&lt; std::endl;
}</span></pre>
<p><span class="koboSpan" id="kobo.691.1">And here is how this guard </span><a id="_idIndexMarker254"/><span class="koboSpan" id="kobo.692.1">object might </span><span class="No-Break"><span class="koboSpan" id="kobo.693.1">be used:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.694.1">
#include &lt;mutex&gt;
std::mutex m;
const bool mt_run = true;
void work() {
  try {
    lock_guard lg(m, true, mt_run);
    … this code might throw …
    std::cout &lt;&lt; "Work is happening" &lt;&lt; std::endl;
  } catch (...) {}
}</span></pre>
<p><span class="koboSpan" id="kobo.695.1">Here we perform only one possible action in addition to locking and unlocking – we can optionally log these events; you can already see that the implementations of the constructor and the destructor, the two sections of code that must be closely matched, are somewhat separated from each other. </span><span class="koboSpan" id="kobo.695.2">Also, tracking the state (do we need to log the events? </span><span class="koboSpan" id="kobo.695.3">Are we running in a multi-threaded or single-threaded context?) is becoming somewhat verbose. </span><span class="koboSpan" id="kobo.695.4">Again, you have to remember that this is a simplified example: in a real program, this is still a fine RAII object. </span><span class="koboSpan" id="kobo.695.5">But, if the code gets even longer, you may wish for a </span><span class="No-Break"><span class="koboSpan" id="kobo.696.1">better way.</span></span></p>
<p><span class="koboSpan" id="kobo.697.1">In this case, the better way is borrowed from Python (specifically, from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.698.1">contextmanager</span></strong><span class="koboSpan" id="kobo.699.1"> decorator). </span><span class="koboSpan" id="kobo.699.2">This technique used coroutines and, thus, requires C++20 (so we managed to couple one of the oldest tools in C++ with the most cutting-edge one). </span><span class="koboSpan" id="kobo.699.3">The detailed explanation</span><a id="_idIndexMarker255"/><span class="koboSpan" id="kobo.700.1"> of the coroutines in general and the C++ coroutine machinery in particular lies outside of the scope of this book (you can find it, for example, in my book “</span><em class="italic"><span class="koboSpan" id="kobo.701.1">The Art of Writing Efficient </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.702.1">Programs</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.703.1">”, (</span></span><a href="https://www.packtpub.com/product/the-art-of-writing-efficient-programs/9781800208117"><span class="No-Break"><span class="koboSpan" id="kobo.704.1">https://www.packtpub.com/product/the-art-of-writing-efficient-programs/9781800208117</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.705.1">)).</span></span></p>
<p><span class="koboSpan" id="kobo.706.1">For now, it is sufficient to remember </span><span class="No-Break"><span class="koboSpan" id="kobo.707.1">two things:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.708.1">First, C++ coroutines are, essentially, regular functions except they suspend themselves at any time and return the control to the caller. </span><span class="koboSpan" id="kobo.708.2">The caller can resume the coroutine, and it continues to execute from the suspension point as if </span><span class="No-Break"><span class="koboSpan" id="kobo.709.1">nothing happened.</span></span></li>
<li><span class="koboSpan" id="kobo.710.1">Second, C++ coroutines require a lot of standard boilerplate code. </span><span class="koboSpan" id="kobo.710.2">In the example that follows, we will highlight the important fragments; you can safely assume that the rest of the code is required by the standard to make the coroutine </span><span class="No-Break"><span class="koboSpan" id="kobo.711.1">machinery work.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.712.1">Let us first see what the code for a lock guard looks like with this new coroutine-based </span><span class="No-Break"><span class="koboSpan" id="kobo.713.1">RAII approach:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.714.1">
#include &lt;mutex&gt;
std::mutex m;
const bool mt_run = true;
co_resource&lt;std::mutex&gt; make_guard(std::mutex&amp; m, bool log)
{
  if (log) std::cout &lt;&lt; "Before locking" &lt;&lt; std::endl;
  if (mt_run) m.lock();
  co_yield m;
  if (mt_run) m.unlock();
  if (log) std::cout &lt;&lt; "After locking" &lt;&lt; std::endl;
}
void work () {
  try {
    co_resource&lt;std::mutex&gt; lg { make_guard(m, true) };
    … this code might throw …
    std::cout &lt;&lt; "Work is happening" &lt;&lt; std::endl;
  } catch (...) {}
}</span></pre>
<p><span class="koboSpan" id="kobo.715.1">Instead of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.716.1">lock_guard</span></strong><span class="koboSpan" id="kobo.717.1"> object, we have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.718.1">make_guard</span></strong><span class="koboSpan" id="kobo.719.1"> function. </span><span class="koboSpan" id="kobo.719.2">This function is a coroutine; you can tell because it has the </span><strong class="source-inline"><span class="koboSpan" id="kobo.720.1">co_yield</span></strong><span class="koboSpan" id="kobo.721.1"> operator – this is one of several ways C++ coroutines return values to the caller. </span><span class="koboSpan" id="kobo.721.2">The code before </span><strong class="source-inline"><span class="koboSpan" id="kobo.722.1">co_yield</span></strong><span class="koboSpan" id="kobo.723.1"> is resource acquisition, it is </span><a id="_idIndexMarker256"/><span class="koboSpan" id="kobo.724.1">executed when the resource is acquired and is equivalent to the constructor of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.725.1">lock_guard</span></strong><span class="koboSpan" id="kobo.726.1"> object. </span><span class="koboSpan" id="kobo.726.2">The code after </span><strong class="source-inline"><span class="koboSpan" id="kobo.727.1">co_yield</span></strong><span class="koboSpan" id="kobo.728.1"> is the same as the destructor of </span><strong class="source-inline"><span class="koboSpan" id="kobo.729.1">lock_guard</span></strong><span class="koboSpan" id="kobo.730.1">. </span><span class="koboSpan" id="kobo.730.2">Arguably, this is easier to read and maintain (at least after you stop staring at the coroutine syntax) because all the code is in the same place you can think of </span><strong class="source-inline"><span class="koboSpan" id="kobo.731.1">co_yield</span></strong><span class="koboSpan" id="kobo.732.1"> as a placeholder for the work the caller is going to do while owning the resource (the mutex, in our case). </span><span class="koboSpan" id="kobo.732.2">Also, there are no class members and member initialization to write – the function parameters are accessible throughout the execution of </span><span class="No-Break"><span class="koboSpan" id="kobo.733.1">the coroutine.</span></span></p>
<p><span class="koboSpan" id="kobo.734.1">The coroutine returns an object of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.735.1">co_resource&lt;std::mutex&gt;</span></strong><span class="koboSpan" id="kobo.736.1">: that is our modern RAII type is implemented as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.737.1">co_resource</span></strong><span class="koboSpan" id="kobo.738.1"> class template; it is implemented </span><span class="No-Break"><span class="koboSpan" id="kobo.739.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.740.1">
// Example 09
#include &lt;cassert&gt;
#include &lt;coroutine&gt;
#include &lt;cstddef&gt;
#include &lt;memory&gt;
#include &lt;utility&gt;
template &lt;typename T&gt; class co_resource {
  public:
  using promise_type = struct promise_type&lt;T&gt;;
  using handle_type = std::coroutine_handle&lt;promise_type&gt;;
  co_resource(handle_type coro) : coro_(coro) {}
  co_resource(const co_resource&amp;) = delete;
  co_resource&amp; operator=(const co_resource&amp;) = delete;
  co_resource(co_resource&amp;&amp; from)
     : coro_(std::exchange(from.coro_, nullptr)) {}
  co_resource&amp; operator=(co_resource&amp;&amp; from) {
    std::destroy_at(this);
    std::construct_at(this, std::move(from));
    return *this;
  }
  ~co_resource() {
    if (!coro_) return;
    coro_.resume();     // Resume from the co_yield point
    coro_.destroy();    // Clean up
  }
  private:
  handle_type coro_;
};</span></pre>
<p><span class="koboSpan" id="kobo.741.1">This is the object that owns the resource, but you don’t see the resource or its type </span><strong class="source-inline"><span class="koboSpan" id="kobo.742.1">T</span></strong><span class="koboSpan" id="kobo.743.1"> directly: it is hidden inside the coroutine handle </span><strong class="source-inline"><span class="koboSpan" id="kobo.744.1">coro_</span></strong><span class="koboSpan" id="kobo.745.1">. </span><span class="koboSpan" id="kobo.745.2">This handle acts like a pointer to the state of the coroutine. </span><span class="koboSpan" id="kobo.745.3">If you focus on the handle as a resource for the moment, we have a fairly routine resource-owning object. </span><span class="koboSpan" id="kobo.745.4">It acquires the resource in the constructor and maintains the exclusive ownership: the handle is destroyed in the destructor of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.746.1">co_resource</span></strong><span class="koboSpan" id="kobo.747.1"> object unless the ownership is transferred via move, and copying the resource is </span><span class="No-Break"><span class="koboSpan" id="kobo.748.1">not allowed.</span></span></p>
<p><span class="koboSpan" id="kobo.749.1">This resource-owning object is going to be returned by a coroutine function; every such object must contain a nested type named </span><strong class="source-inline"><span class="koboSpan" id="kobo.750.1">promise_type</span></strong><span class="koboSpan" id="kobo.751.1">. </span><span class="koboSpan" id="kobo.751.2">Often, it is a nested class, but it can also be a separate type (in this example, we made it such largely to avoid a single very long code fragment). </span><span class="koboSpan" id="kobo.751.3">The standard imposes several requirements on the interface of the promise type, and here is the type that meets these requirements for </span><span class="No-Break"><span class="koboSpan" id="kobo.752.1">our purposes:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.753.1">
template &lt;typename T&gt; struct promise_type {
  const T* yielded_value_p = nullptr;
  std::suspend_never initial_suspend() noexcept {
    return {};
  }
  std::suspend_always final_suspend() noexcept {
    return {};
  }
  void return_void() noexcept {}
  void unhandled_exception() { throw; }
  std::suspend_always yield_value(const T&amp; val) noexcept {
    yielded_value_p = &amp;val;
    return {};
  }
  using handle_type = std::coroutine_handle&lt;promise_type&gt;;
  handle_type get_return_object() {
    return handle_type::from_promise(*this);
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.754.1">Our promise type contains a pointer to the value returned by the coroutine. </span><span class="koboSpan" id="kobo.754.2">How does the value get there? </span><span class="koboSpan" id="kobo.754.3">When the coroutine returns the result via </span><strong class="source-inline"><span class="koboSpan" id="kobo.755.1">co_yield</span></strong><span class="koboSpan" id="kobo.756.1">, the member function </span><strong class="source-inline"><span class="koboSpan" id="kobo.757.1">yield_value()</span></strong><span class="koboSpan" id="kobo.758.1"> is called (the compiler generates this call). </span><span class="koboSpan" id="kobo.758.2">The value returned by </span><strong class="source-inline"><span class="koboSpan" id="kobo.759.1">co_yield</span></strong><span class="koboSpan" id="kobo.760.1"> is passed to this function, which, in turn, captures its address (the lifetime of the </span><a id="_idIndexMarker257"/><span class="koboSpan" id="kobo.761.1">value is the same as that of the coroutine itself). </span><span class="koboSpan" id="kobo.761.2">The other important member function of the promise type is </span><strong class="source-inline"><span class="koboSpan" id="kobo.762.1">get_return_object()</span></strong><span class="koboSpan" id="kobo.763.1">: it is invoked by the compiler to return the </span><strong class="source-inline"><span class="koboSpan" id="kobo.764.1">co_resource</span></strong><span class="koboSpan" id="kobo.765.1"> object itself to the caller of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.766.1">make_guard()</span></strong><span class="koboSpan" id="kobo.767.1"> coroutine. </span><span class="koboSpan" id="kobo.767.2">Note that it does not return a </span><strong class="source-inline"><span class="koboSpan" id="kobo.768.1">co_resource</span></strong><span class="koboSpan" id="kobo.769.1"> object, but a handle that is implicitly convertible to </span><strong class="source-inline"><span class="koboSpan" id="kobo.770.1">co_resource</span></strong><span class="koboSpan" id="kobo.771.1"> (it has an implicit constructor from </span><strong class="source-inline"><span class="koboSpan" id="kobo.772.1">handle_type</span></strong><span class="koboSpan" id="kobo.773.1">). </span><span class="koboSpan" id="kobo.773.2">The rest of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.774.1">promise_type</span></strong><span class="koboSpan" id="kobo.775.1"> interface is, for our purposes, the boilerplate code required by </span><span class="No-Break"><span class="koboSpan" id="kobo.776.1">the standard.</span></span></p>
<p><span class="koboSpan" id="kobo.777.1">Here is how the </span><strong class="source-inline"><span class="koboSpan" id="kobo.778.1">co_resource</span></strong><span class="koboSpan" id="kobo.779.1"> RAII works: first, we call the </span><span class="No-Break"><span class="koboSpan" id="kobo.780.1">function </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.781.1">make_guard()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.782.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.783.1">
co_resource&lt;std::mutex&gt; make_guard(std::mutex&amp; m, bool log)
{
  if (log) std::cout &lt;&lt; "Before locking" &lt;&lt; std::endl;
  if (mt_run) m.lock();
  co_yield m;
  if (mt_run) m.unlock();
  if (log) std::cout &lt;&lt; "After locking" &lt;&lt; std::endl;
}</span></pre>
<p><span class="koboSpan" id="kobo.784.1">From the caller’s point of view, it starts executing like any other function, although the internal details are quite different. </span><span class="koboSpan" id="kobo.784.2">All the code we wrote before </span><strong class="source-inline"><span class="koboSpan" id="kobo.785.1">co_yield</span></strong><span class="koboSpan" id="kobo.786.1"> is executed, then the coroutine is suspended and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.787.1">co_resource&lt;std::mutex&gt;</span></strong><span class="koboSpan" id="kobo.788.1"> object is constructed and returned to the caller, where it is moved into a </span><span class="No-Break"><span class="koboSpan" id="kobo.789.1">stack variable:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.790.1">
co_resource&lt;std::mutex&gt; lg { make_guard(m, true) };</span></pre>
<p><span class="koboSpan" id="kobo.791.1">The execution proceeds as usual, protected by the locked mutex. </span><span class="koboSpan" id="kobo.791.2">At the end of the scope, the object </span><strong class="source-inline"><span class="koboSpan" id="kobo.792.1">lg</span></strong><span class="koboSpan" id="kobo.793.1"> is destroyed; this happens no matter whether we exit the scope normally or by throwing an exception. </span><span class="koboSpan" id="kobo.793.2">In the destructor of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.794.1">co_resource</span></strong><span class="koboSpan" id="kobo.795.1"> object, the coroutine is resumed via the call to the member function </span><strong class="source-inline"><span class="koboSpan" id="kobo.796.1">resume()</span></strong><span class="koboSpan" id="kobo.797.1"> of the coroutine handle </span><strong class="source-inline"><span class="koboSpan" id="kobo.798.1">coro_</span></strong><span class="koboSpan" id="kobo.799.1">. </span><span class="koboSpan" id="kobo.799.2">This causes the coroutine to resume execution right after the point where stopped before, so the control jumps to the next line after </span><strong class="source-inline"><span class="koboSpan" id="kobo.800.1">co_yield</span></strong><span class="koboSpan" id="kobo.801.1">. </span><span class="koboSpan" id="kobo.801.2">The resource release code we wrote there is executed, and the coroutine exits through the bottom of the scope, now for the last time. </span><span class="koboSpan" id="kobo.801.3">The destructor of </span><strong class="source-inline"><span class="koboSpan" id="kobo.802.1">co_resource</span></strong><span class="koboSpan" id="kobo.803.1"> has some cleanup to do, but, otherwise, we are (</span><span class="No-Break"><span class="koboSpan" id="kobo.804.1">mostly) done.</span></span></p>
<p><span class="koboSpan" id="kobo.805.1">There are a few things we have left out to avoid overly extending the example. </span><span class="koboSpan" id="kobo.805.2">First of all, as written, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.806.1">co_resource</span></strong><span class="koboSpan" id="kobo.807.1"> template does not work if the resource type </span><strong class="source-inline"><span class="koboSpan" id="kobo.808.1">T</span></strong><span class="koboSpan" id="kobo.809.1"> is a reference. </span><span class="koboSpan" id="kobo.809.2">This may be perfectly acceptable: handling references by RAII is not that common. </span><span class="koboSpan" id="kobo.809.3">In this case, a static assert or a concept check is sufficient. </span><span class="koboSpan" id="kobo.809.4">Otherwise, we have to carefully handle dependent </span><a id="_idIndexMarker258"/><span class="koboSpan" id="kobo.810.1">types inside the template. </span><span class="koboSpan" id="kobo.810.2">Second, the implicit requirement on the coroutine such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.811.1">make_guard()</span></strong><span class="koboSpan" id="kobo.812.1"> is that it returns a value via </span><strong class="source-inline"><span class="koboSpan" id="kobo.813.1">co_yield</span></strong><span class="koboSpan" id="kobo.814.1"> exactly once (you can have more than one </span><strong class="source-inline"><span class="koboSpan" id="kobo.815.1">co_yield</span></strong><span class="koboSpan" id="kobo.816.1"> in the body of the coroutine, but only one can be executed for a particular call). </span><span class="koboSpan" id="kobo.816.2">To make the code robust, we have to verify that this requirement has been met using </span><span class="No-Break"><span class="koboSpan" id="kobo.817.1">run-time asserts.</span></span></p>
<p><span class="koboSpan" id="kobo.818.1">We now have the acquisition and release code right next to each other and we don’t need to convert function arguments into data members like we did when constructors and destructors handled RAII. </span><span class="koboSpan" id="kobo.818.2">The only thing that might make it even better would be if we didn’t have to write a separate </span><strong class="source-inline"><span class="koboSpan" id="kobo.819.1">make_guard()</span></strong><span class="koboSpan" id="kobo.820.1"> function, at least in cases where we have only one call to it. </span><span class="koboSpan" id="kobo.820.2">Turns out that we can combine coroutines and lambdas to just such </span><span class="No-Break"><span class="koboSpan" id="kobo.821.1">a result:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.822.1">
void work(){
  try {
    auto lg { [&amp;](bool log)-&gt;co_resource&lt;std::mutex&gt; {
      if (log) std::cout &lt;&lt; "Before locking" &lt;&lt; std::endl;
      if (mt_run) m.lock();
      co_yield m;
      if (mt_run) m.unlock();
      if (log) std::cout &lt;&lt; "After locking" &lt;&lt; std::endl;
    }(true) };
    … this code might throw …
    std::cout &lt;&lt; "Work is happening" &lt;&lt; std::endl;
  } catch (...) {}
}</span></pre>
<p><span class="koboSpan" id="kobo.823.1">Here the coroutine is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.824.1">operator()</span></strong><span class="koboSpan" id="kobo.825.1"> of a lambda expression; note that we have to specify the return type explicitly. </span><span class="koboSpan" id="kobo.825.2">The lambda is invoked immediately; and; as usual in such cases, the use of captures or parameters boils down to what is more convenient in </span><span class="No-Break"><span class="koboSpan" id="kobo.826.1">each case.</span></span></p>
<p><span class="koboSpan" id="kobo.827.1">With the coroutine-based RAII resource management, we were able to keep all the relevant code portions very close to each other. </span><span class="koboSpan" id="kobo.827.2">Of course, there is a price: launching, suspending, and resuming coroutines takes time (and a bit of memory). </span><span class="koboSpan" id="kobo.827.3">The basic RAII object is always going to be faster, so don’t try to replace </span><strong class="source-inline"><span class="koboSpan" id="kobo.828.1">std::unique_pointer</span></strong><span class="koboSpan" id="kobo.829.1"> with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.830.1">co_resource</span></strong><span class="koboSpan" id="kobo.831.1"> class. </span><span class="koboSpan" id="kobo.831.2">But keep in mind that our original dissatisfaction with RAII started with the observation that when the code executed for the acquisition or release of resources is long, complex, and uses a lot of state variables, an RAII class might be hard to read. </span><span class="koboSpan" id="kobo.831.3">It is likely that in such cases the overhead of the coroutines is less important (we should also point out that the “scope guard” pattern described later in </span><a href="B19262_11.xhtml#_idTextAnchor509"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.832.1">Chapter 11</span></em></span></a><span class="koboSpan" id="kobo.833.1">, </span><em class="italic"><span class="koboSpan" id="kobo.834.1">ScopeGuard</span></em><span class="koboSpan" id="kobo.835.1">, addresses some of the same concerns and sometimes is a </span><span class="No-Break"><span class="koboSpan" id="kobo.836.1">better option).</span></span></p>
<p><span class="koboSpan" id="kobo.837.1">The RAII techniques we have learned are some of the most enduring C++ patterns; they were in use from the first day of C++ and continue to evolve and benefit from the latest language features. </span><span class="koboSpan" id="kobo.837.2">Throughout this book, we will casually and without a second thought use classes such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.838.1">std::unique_ptr</span></strong><span class="koboSpan" id="kobo.839.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.840.1">std::lock_guard</span></strong><span class="koboSpan" id="kobo.841.1">. </span><span class="koboSpan" id="kobo.841.2">For </span><a id="_idTextAnchor260"/><a id="_idTextAnchor261"/><span class="koboSpan" id="kobo.842.1">now, we leave you with these </span><span class="No-Break"><span class="koboSpan" id="kobo.843.1">final thoughts.</span></span></p>
<h1 id="_idParaDest-95"><a id="_idTextAnchor262"/><span class="koboSpan" id="kobo.844.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.845.1">After this chapter, you should be well aware of the dangers of an ad-hoc approach to resource management. </span><span class="koboSpan" id="kobo.845.2">Fortunately, we have learned the most widely used idiom for resource management in C++; the RAII idiom. </span><span class="koboSpan" id="kobo.845.3">With this idiom, each resource is owned by an object. </span><span class="koboSpan" id="kobo.845.4">Constructing (or initializing) the object acquires the resource, and deleting the object releases it. </span><span class="koboSpan" id="kobo.845.5">We saw how using RAII addresses the problems of resource management, such as leaking resources, accidentally sharing resources, and releasing resources incorrectly. </span><span class="koboSpan" id="kobo.845.6">We have also learned the basics of writing exception-safe code, at least as far as the leaking or otherwise mishandling of resources is concerned. </span><span class="koboSpan" id="kobo.845.7">Writing RAII objects is simple enough, but there are several caveats to keep in mind. </span><span class="koboSpan" id="kobo.845.8">Finally, we reviewed the complications that arise when error handling has to be combined </span><span class="No-Break"><span class="koboSpan" id="kobo.846.1">with RAII.</span></span></p>
<p><span class="koboSpan" id="kobo.847.1">RAII is a resource management idiom, but it can also be viewed as an abstraction technique: the complex resources are hidden behind simple resource handles. </span><span class="koboSpan" id="kobo.847.2">The next chapter introduces another kind of abstraction idiom, type erasure: instead of complex objects, we will now hide </span><span class="No-Break"><span class="koboSpan" id="kobo.848.1">complex types.</span></span></p>
<h1 id="_idParaDest-96"><a id="_idTextAnchor263"/><span class="koboSpan" id="kobo.849.1">Questions</span></h1>
<ol>
<li><span class="koboSpan" id="kobo.850.1">What are the resources that a program </span><span class="No-Break"><span class="koboSpan" id="kobo.851.1">can manage?</span></span></li>
<li><span class="koboSpan" id="kobo.852.1">What are the main considerations when managing resources in a </span><span class="No-Break"><span class="koboSpan" id="kobo.853.1">C++ program?</span></span></li>
<li><span class="koboSpan" id="kobo.854.1">What </span><span class="No-Break"><span class="koboSpan" id="kobo.855.1">is RAII?</span></span></li>
<li><span class="koboSpan" id="kobo.856.1">How does RAII address the problem of </span><span class="No-Break"><span class="koboSpan" id="kobo.857.1">leaking resources?</span></span></li>
<li><span class="koboSpan" id="kobo.858.1">How does RAII address the problem of dangling </span><span class="No-Break"><span class="koboSpan" id="kobo.859.1">resource handles?</span></span></li>
<li><span class="koboSpan" id="kobo.860.1">What RAII objects are provided by the C++ </span><span class="No-Break"><span class="koboSpan" id="kobo.861.1">standard library?</span></span></li>
<li><span class="koboSpan" id="kobo.862.1">What precautions must be taken when writing </span><span class="No-Break"><span class="koboSpan" id="kobo.863.1">RAII objects?</span></span><a id="_idTextAnchor264"/></li>
<li><span class="koboSpan" id="kobo.864.1">What happens if releasing a </span><span class="No-Break"><span class="koboSpan" id="kobo.865.1">resource fails?</span></span></li>
</ol>
<h1 id="_idParaDest-97"><a id="_idTextAnchor265"/><span class="koboSpan" id="kobo.866.1">Further reading</span></h1>
<ul>
<li><a href="https://www.packtpub.com/application-development/expert-c-programming"><span class="No-Break"><span class="koboSpan" id="kobo.867.1">https://www.packtpub.com/application-development/expert-c-programming</span></span></a></li>
<li><a href="https://www.packtpub.com/application-development/c-data-structures-and-algorithms"><span class="No-Break"><span class="koboSpan" id="kobo.868.1">https://www.packtpub.com/application-development/c-data-structures-and-algorithms</span></span></a></li>
<li><a href="https://www.packtpub.com/application-development/rapid-c-video"><span class="No-Break"><span class="koboSpan" id="kobo.869.1">https://www.packtpub.com/application-development/rapid-c-video</span></span></a></li>
</ul>
</div>
</body></html>