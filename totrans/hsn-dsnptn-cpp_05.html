<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-78"><a id="_idTextAnchor199"/>5</h1>
<h1 id="_idParaDest-79"><a id="_idTextAnchor200"/>A Comprehensive Look at RAII</h1>
<p>Resource management is probably the second most frequent thing a program does, after computing. But just because it’s frequently done does not mean it’s visible—some languages hide most, or all, resource management from the user. And just because it is hidden, does not mean it’s not there.</p>
<p>Every program needs to use some memory, and memory is a resource. A program would be of no use if it never interacted with the outside world in some way, at least to print the result, and input and output channels (files, sockets, and so on) are resources.</p>
<p>In this chapter, we will start by answering the following questions:</p>
<ul>
<li>What is considered a resource in a C++ program?</li>
<li>What are the key concerns for managing resources in C++?</li>
</ul>
<p>Then, we will introduce <strong class="bold">Resource Acquisition is Initialization</strong> (<strong class="bold">RAII</strong>) and explain how it helps in efficient<a id="_idIndexMarker212"/> resource management in C++ by answering these questions:</p>
<ul>
<li>What is the standard approach for managing resources in C++ (RAII)?</li>
<li>How does RAII solve the problems of resource management?</li>
</ul>
<p>We will end the chapter with a discussion about the implications and possible concerns of using RAII by providing the answers to these questions:</p>
<ul>
<li>What are the precautions that must be taken when writing RAII objects?</li>
<li>What are the consequences of using RAII for resource management?</li>
</ul>
<p>C++, with its zero-overhead abstraction philosophy, does not hide resources or their management at the core language level. But we would do well to not confuse hiding resources with managing them.<a id="_idTextAnchor201"/><a id="_idTextAnchor202"/></p>
<h1 id="_idParaDest-80"><a id="_idTextAnchor203"/>Technical requirements</h1>
<p>Here are some useful links:</p>
<ul>
<li>Google Test unit testing framework: <a href="https://github.com/google/googletest">https://github.com/google/googletest</a></li>
<li>Google Benchmark library: <a href="https://github.com/google/benchmark">https://github.com/google/benchmark</a></li>
<li>Example code: <a href="https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter05">https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter05</a></li>
</ul>
<h1 id="_idParaDest-81"><a id="_idTextAnchor206"/>Resource management in C++</h1>
<p>Every program operates on resources and needs to manage them. The most commonly used resource is memory, of course. Hence, you<a id="_idIndexMarker213"/> often read about <strong class="bold">memory</strong> <strong class="bold">management</strong> in C++. But really, resources can be just about anything. Many<a id="_idIndexMarker214"/> programs exist specifically to manage real, tangible physical resources, or the more ephemeral (but no less valuable) digital ones. Money in bank accounts, airline seats, car parts and assembled cars, or even crates of milk—in today’s world, if it is something that needs to be counted and<a id="_idIndexMarker215"/> tracked, there is a piece of software somewhere that is doing it. But even in a program that does pure computations, there may be varied and complex resources, unless the program also eschews abstractions and operates at the level of bare numbers. For example, a physics simulation program may have particles as resources.</p>
<p>All of these resources have one thing in common—they need to be accounted for. They should not vanish without a trace, and a program should not just make up resources that don’t really exist. Often, a specific instance of a resource is needed—you would not want someone else’s purchase to be debited from your bank account; the specific instance of the resource matters. Thus, the most important consideration when evaluating different approaches to resource management is correctness—how well does the design ensure that resources are managed properly, how easy is it to make a mistake, and how hard would it be to find such a mistake? It should come as no surprise, then, that we use a testing framework to present the coding examples of resource management in this chapt<a id="_idTextAnchor207"/><a id="_idTextAnchor208"/><a id="_idTextAnchor209"/>er.</p>
<h2 id="_idParaDest-82"><a id="_idTextAnchor210"/>Installing the microbenchmark library</h2>
<p>In our case, we are interested in the efficiency of memory allocations and small fragments of code that may contain such allocations. The appropriate tool for measuring the performance of small fragments of code is a<a id="_idIndexMarker216"/> microbenchmark. There are many microbenchmark libraries and tools out there; in this book, we will use the Google Benchmark library. To follow along with the examples in this chapter, you must first download and install the library (follow the instructions in the <code>Readme.md</code> file). Then you can compile and run the examples. You can build the sample files included with the library to see how to build a benchmark on your particular system; you can also use the example benchmark from this chapter’s repository:</p>
<pre class="source-code">
// Example 01
#include &lt;stdlib.h&gt;
#include "benchmark/benchmark.h"
void BM_malloc(benchmark::State&amp; state) {
  constexpr size_t size = 1024;
  for (auto _ : state) {
    void* p = malloc(size);
    benchmark::DoNotOptimize(p);
    free(p);
  }
  state.SetItemsProcessed(state.iterations());
}
BENCHMARK(BM_malloc);
BENCHMARK_MAIN();</pre>
<p>Note the call to <code>DoNotOptimize()</code>: it’s a special function that doesn’t generate any code but tricks the compiler into thinking that its argument is necessary and cannot be optimized away. Without this, the compiler will probably figure out that the entire benchmark loop has no observable effect and can be optimized to nothing.</p>
<p>On a Linux machine, the command to build and run a benchmark program called <code>01_benchmark.C</code> might look something like this:</p>
<pre class="console">
$CXX 01_benchmark.C -I. -I$GBENCH_DIR/include –O3 \
  --std=c++17 $GBENCH_DIR/lib/libbenchmark.a -lpthread \
  -o 01_benchmark &amp;&amp; ./01_benchmark</pre>
<p>Here, <code>$CXX</code> is your C++ compiler, such as <code>g++</code> or <code>clang++</code>, and <code>$GBENCH_DIR</code> is the direc<a id="_idTextAnchor211"/>tory where the <a id="_idIndexMarker217"/>benchmark is installed.</p>
<p>The preceding example should print something like this:</p>
<div><div><img alt="" src="img/Figure_5.1_B19262.jpg"/>
</div>
</div>
<p>On this particular machine, a single iteration (one pair of calls to <code>malloc()</code> and <code>free()</code>) takes 6.37 nanoseconds, which translates into 157 million memory allocations per second.</p>
<p>Sometimes we have to benchmark very short operations:</p>
<pre class="source-code">
void BM_increment(benchmark::State&amp; state) {
  size_t i = 0;
  for (auto _ : state) {
    ++i;
    benchmark::DoNotOptimize(i);
  }
  state.SetItemsProcessed(state.iterations());
}</pre>
<p>We may be reasonably concerned about the overhead of the benchmark loop itself. In such cases, we can execute multiple copies of the benchmarked operation within the body of the loop. We can even get the C++ preprocessor to make copies for us:</p>
<pre class="source-code">
// Example 02
#define REPEAT2(x) x x
#define REPEAT4(x) REPEAT2(x) REPEAT2(x)
#define REPEAT8(x) REPEAT4(x) REPEAT4(x)
#define REPEAT16(x) REPEAT8(x) REPEAT8(x)
#define REPEAT32(x) REPEAT16(x) REPEAT16(x)
#define REPEAT(x) REPEAT32(x)
void BM_increment32(benchmark::State&amp; state) {
  size_t i = 0;
  for (auto _ : state) {
    REPEAT(
      ++i;
      benchmark::DoNotOptimize(i);
    )
  }
  state.SetItemsProcessed(32*state.iterations());
}</pre>
<p>The time of a “<em class="italic">single</em>” iteration<a id="_idIndexMarker218"/> now includes 32 iterations, so it is much easier to use the items per second value. Remember to include repeat count in the number of items processed:</p>
<div><div><img alt="" src="img/Figure_5.2_B19262.jpg"/>
</div>
</div>
<p>Writing fast programs is all well and good, but they have to be correct first. To that end, we need to write tests, so we also need a testing framew<a id="_idTextAnchor212"/>ork.</p>
<h2 id="_idParaDest-83"><a id="_idTextAnchor213"/>Installing Google Test</h2>
<p>We will be testing very small fragments of code for correctness. On the one hand, this is simply because each fragment illustrates a specific concept or idea. On the other hand, even in a large-scale <a id="_idIndexMarker219"/>software system, resource management is done by small building blocks of code. They may combine to form a quite complex resource manager, but each block performs a specific function and is testable. The appropriate testing system for this situation is a unit testing framework. There are many such frameworks to choose from; in this book, we will use the Google Test unit testing framework. To follow along with the examples in this chapter, you must first download and install the framework (follow the instructions in the <code>README</code> file). Once installed, you can compile and run the examples. You can build the sample tests included with the library to see how to build and link with Google Test on your particular system; you can also use the example from this chapter’s repository:</p>
<pre class="source-code">
#include &lt;vector&gt;
#include "gtest/gtest.h"
TEST(Memory, Vector) {
  std::vector&lt;int&gt; v(10);
  EXPECT_EQ(10u, v.size());
  EXPECT_LE(10u, v.capacity());
}</pre>
<p>On a Linux machine, the command to build and run a <code>02_test.C</code> test might look something like this:</p>
<pre class="console">
$CXX 02_test.C -I. -I$GTEST_DIR/include -g -O0 -I. \
  -Wall -Wextra -Werror -pedantic --std=c++17 \
  $GTEST_DIR/lib/libgtest.a $GTEST_DIR/lib/libgtest_main.a\
  -lpthread -lrt -lm -o -2_test &amp;&amp; ./02_test</pre>
<p>Here, <code>$CXX</code> is your C++ compiler, such as <code>g++</code> or <code>clang++</code>, and <code>$GTEST_DIR</code> is the directory where Google Test is installed. If all tests pass, you should get this output:</p>
<pre class="console">
Running main() from gtest_main.cc
[==========] Running 1 test from 1 test case.
[----------] Global test environment set-up.
[----------] 1 test from Memory
[ RUN      ] Memory.Vector
[       OK ] Memory.Vector (0 ms)
[----------] 1 test from Memory (0 ms total)
[----------] Global test environment tear-down
[==========] 1 test from 1 test case ran. (0 ms total)
[  PASSED  ] 1 test.</pre>
<p>Writing good tests is an art. We have to identify the aspects of our code that need to be validated and come up with ways to observe these aspects. In this chapter, we are interested in resource management, so let us see how we can test the utilization and release of resou<a id="_idTextAnchor214"/><a id="_idTextAnchor215"/><a id="_idTextAnchor216"/>rces.</p>
<h2 id="_idParaDest-84"><a id="_idTextAnchor217"/>Counting resources</h2>
<p>A unit testing <a id="_idIndexMarker220"/>framework, such as Google Test, allows us to execute some code and verify that the results are what they should be. The results that we can look at include any variable or expression that we can access from the test program. That definition does not extend, for example, to the amount of memory that is currently in use. So, if we want to verify that resources are not disappearing, we have to count them.</p>
<p>In the following simple test fixture, we use a special resource class instead of, say, the <code>int</code> keyword. This class is instrumented to count how many objects of this type have been created, and how many are currently alive:</p>
<pre class="source-code">
// Example 03
struct object_counter {
  static int count;
  static int all_count;
  object_counter() { ++count; ++all_count; }
  ~object_counter() { --count; }
};
int object_counter::count = 0;
int object_counter::all_count = 0;</pre>
<p>Now we can test that our program manages resources correctly, as follows:</p>
<pre class="source-code">
// Example 03
#include "gtest/gtest.h"
TEST(Memory, NewDelete) {
  object_counter::all_count = object_counter::count = 0;
  object_counter* p = new object_counter;
  EXPECT_EQ(1, object_counter::count);
  EXPECT_EQ(1, object_counter::all_count);
  delete p;
  EXPECT_EQ(0, object_counter::count);
  EXPECT_EQ(1, object_counter::all_count);
}</pre>
<p>In Google Test, every test is implemented <a id="_idIndexMarker221"/>as a <strong class="bold">test fixture</strong>. There are several types; the simplest one is a standalone<a id="_idIndexMarker222"/> test function, such as the one we use here. Running this simple test program tells us that the test has passed, as follows:</p>
<pre class="console">
[----------] 1 test from Memory
[ RUN      ] Memory.NewDelete
[       OK ] Memory.NewDelete (0 ms)
[----------] 1 test from Memory (0 ms total)
[  PASSED  ]<a id="_idTextAnchor218"/> 1 test.</pre>
<p>The expected results are verified using one of the <code>EXPECT_*</code> macros and any test failures will be reported. This test verifies that, after creating and deleting an instance of the type <code>object_counter</code>, there are no <a id="_idIndexMarker223"/>such objects left, and that exactly one was con<a id="_idTextAnchor219"/><a id="_idTextAnchor220"/>structed.</p>
<h1 id="_idParaDest-85"><a id="_idTextAnchor221"/>Dangers of manual resource management</h1>
<p>C++ allows us to manage<a id="_idIndexMarker224"/> resources almost at the hardware level, and someone, somewhere, must indeed manage them at this level. The latter is actually true for every language, even the high-level ones that do not expose such details to the programmers. But <em class="italic">somewhere </em>does not have to be in your program! Before we learn the C++ solutions and tools for resource management, let’s first understand the problems that arise from not<a id="_idTextAnchor222"/> using any s<a id="_idTextAnchor223"/>uch tools.</p>
<h2 id="_idParaDest-86"><a id="_idTextAnchor224"/>Manual resource management is error-prone</h2>
<p>The first and most<a id="_idIndexMarker225"/> obvious danger of managing every resource manually, with explicit calls to acquire and release each one, is that it is easy to forget the latter. For example, see the following:</p>
<pre class="source-code">
{
  object_counter* p = new object_counter;
  ... many more lines of code ...
  // Were we supposed to do something here?
  // Can't remember now...
}</pre>
<p>We are now leaking a resource (the <code>object_counter</code> objects, in this case). If we did this in a unit test, it would fail, as follows:</p>
<pre class="source-code">
// Example 04
TEST(Memory, Leak1) {
  object_counter::all_count = object_counter::count = 0;
  object_counter* p = new object_counter;
  EXPECT_EQ(1, object_counter::count);
  EXPECT_EQ(1, object_counter::all_count);
  //delete p;  // Forgot that
  EXPECT_EQ(0, object_counter::count); // This test fails!
  EXPECT_EQ(1, object_counter::al<a id="_idTextAnchor225"/>l_count);
}</pre>
<p>You can see the failing tests, and the location of the failures, as reported by the unit test framework:</p>
<pre class="console">
[ RUN      ] Memory.Leak1
04_memory.C:31: Failure
Expected equality of these values:
  0
  object_counter::count
    Which is: 1
[  FAILED  ] Memory.Leak1 (0 ms)</pre>
<p>In a real program, finding such errors is much harder. Memory debuggers and sanitizers can help with memory leaks, but they require that the program actually execute the buggy code, so they depend on the test<a id="_idIndexMarker226"/> coverage.</p>
<p>The resource leaks can be much subtler and harder to find, too. Consider this code, where we did not forget to release the resource:</p>
<pre class="source-code">
bool process(... some parameters ... ) {
  object_counter* p = new object_counter;
  ... many more lines of code ...
  delete p;    // A-ha, we remembered!
  return true;    // Success
}</pre>
<p>During subsequent maintenance, a possible failure condition was discovered, and the appropriate test was added:</p>
<pre class="source-code">
bool process(... some parameters ... ) {
  object_counter* p = new object_counter;
  ... many more lines of code ...
  if (!success) return false;   // Failure, cannot continue
  ... even more lines of code ...
  delete p;    // Still here
  return true;    // Success
}</pre>
<p>This change introduced a subtle bug—now, resources are leaked only if the intermediate computation has failed and triggered the early return. If the failure is rare enough, this mistake may<a id="_idIndexMarker227"/> escape all tests, even if the testing process employs regular memory sanitizer runs. This mistake is also all too easy to make since the edit could be made in a place far removed from both the construction and deletion of the object, and nothing in the immediate context gives the programmer a hint that a resource needs to<a id="_idTextAnchor226"/> be released.</p>
<p>The alternative to leaking a resource, in this case, is to release it. Note that this leads to some code duplication:</p>
<pre class="source-code">
bool process(... some parameters ... ) {
  object_counter* p = new object_counter;
  ... many more lines of code ...
  if (!success) {
    delete p;
    return false;    // Failure, cannot continue
  }
  ... even more lines of code ...
  delete p;    // Still here
  return true;    // Success
}</pre>
<p>As with any code duplication, there comes the danger of code divergence. Let’s say that the next round of code enhancements required more than one <code>object_counter</code>, and an array of them is now allocated as follows:</p>
<pre class="source-code">
bool process(... some parameters ... ) {
  object_counter* p = new object_counter[10]; // Array now
  ... many more lines of code ...
  if (!success) {
    delete p;
    return false;     // Old scalar delete
  }
  ... even more lines of code ...
  delete [] p;    // Matching array delete
  return true;    // Success
}</pre>
<p>If we change <code>new</code> to the <code>new</code> array, we must change <code>delete</code> as well; the thought goes, there is probably one at the end of the function. Who knew that there was one more in the middle? Even if the programmer had not forgotten about the resources, manual resource management gets disproportionately more error-prone as the program becomes more complex. And not all resources are as forgiving as a counter object. Consider the following code that performs some concurrent computation, and must acquire and release mutex locks. Note the very words <strong class="bold">acquire </strong>and <strong class="bold">release</strong>, the common terminology for locks, suggest that locks are treated as a kind of resource (the resource here is exclusive access to the data protected by the lock):</p>
<pre class="source-code">
std::mutex m1, m2, m3;
bool process_concurrently(... some parameters ... ) {
  m1.lock();
  m2.lock();
  ... need both locks in this section ...
  if (!success) {
    m1.unlock();
    m2.unlock();
    return false;
  } // Both locks unlocked
  ... <a id="_idTextAnchor227"/>more code ...
  m2.unlock();    // Don't need access to m1-guarded data
                // Still need m1
  m3.lock();
  if (!success) {
    m1.unlock();
    return false;
  } // No need to unlock m2 here
  ... more code ...
  m1.unlock();
  m3.unlock();
  return true;
}</pre>
<p>This code has both duplication and divergence. It also<a id="_idIndexMarker228"/> has a bug—see if you can find it (hint—count how many times <code>m3</code> is unlocked, versus how many <code>return</code> statements there are after it’s locked). As the resources become more numerous <a id="_idTextAnchor228"/>and complex to manage, such bugs are going to creep <a id="_idTextAnchor229"/>up more often.</p>
<h2 id="_idParaDest-87"><a id="_idTextAnchor230"/>Resource management and exception safety</h2>
<p>Remember the code at the<a id="_idIndexMarker229"/> beginning of the previous section—the one we said is correct, where we did not forget to release the resource? Consider the following code:</p>
<pre class="source-code">
bool process(... some parameters ... ) {
  object_counter* p = new object_counter;
  ... many more lines of code ...
  delete p;
  return true;    // Success
}</pre>
<p>I have bad news for you—this code probably wasn’t correct either. If any of the many more lines of code can throw an exception, then <code>delete p</code> is never going to be executed:</p>
<pre class="source-code">
bool process(... some parameters ... ) {
  object_counter* p = new object_counter;
  ... many more lines of code ...
  if (!success) // Cannot continue
    throw process_exception();
  ... even more lines of code ...
  // Won't do anything if an exception is thrown!
  delete p;
  return true;
}</pre>
<p>This looks very similar to the early <code>return</code> problem, only worse—the exception can be thrown by any code that the <code>process()</code> function calls. The exception can even be added later to some code that the <code>process()</code> function calls, without any changes in the function itself. It used to work fine, then one day it does not.</p>
<p>Unless we change our approach to resource management, the only solution is to use the <code>try … </code><code>catch</code> blocks:</p>
<pre class="source-code">
bool process(... some parameters ... ) {
  object_counter* p = new object_counter;
  try {
    ... many more lines of code ...
    if (!success) // Cannot continue
      throw process_exception();
      ... even more lines of code ...
  } catch ( ... ) {
    delete p;    // For exceptional case
  }
  delete p;    // For normal case return true;
}</pre>
<p>The obvious problem here is code duplication again, as well as the proliferation of the <code>try … catch</code> blocks literally everywhere. Worse than that, this approach does not scale should we need to <a id="_idIndexMarker230"/>manage multiple resources, or even just manage anything more complex than a single acquisition with a corresponding release:</p>
<pre class="source-code">
std::mutex m;
bool process(... some parameters ... ) {
  m.lock(); // Critical section starts here
  object_counter* p = new object_counter;
  // Problem #1: constructor can throw
  try {
    ... many more lines of code ...
    m.unlock();    // Critical section ends here
    ... even more lines of code ...
  } catch ( ... ) {
    delete p;    // OK, always needed
    m.unlock();    // Do we need this? Maybe…
    throw;    // Rethrow the exception for the client to handle
  }
  delete p;    // For normal case, no need to unlock mutex
<a id="_idTextAnchor231"/>  return true;
}</pre>
<p>Now, we can’t even decide<a id="_idIndexMarker231"/> whether the catch block should release the mutex or not—it depends on whether the exception was thrown before or after the <code>unlock()</code> operation that happens in the normal, non-exceptional control flow. Also, the <code>object_counter</code> constructor could throw an exception (not the simple one we had so far, but a more complex one that ours could evolve into). That would happen outside of the <code>try … catch</code> block, and the mutex would never get unlocked.</p>
<p>It should be clear to us by now that we need an entirely different solution for the resource management problem, not some patchwork. In the next section, we will di<a id="_idTextAnchor232"/>scuss the pattern that became the golden standard of resource m<a id="_idTextAnchor233"/>anagement in C++.</p>
<h1 id="_idParaDest-88"><a id="_idTextAnchor234"/>The RAII idiom</h1>
<p>We have seen in the previous section <a id="_idIndexMarker232"/>how ad hoc attempts to manage resources become unreliable, then error-prone, and eventually fail. What we need is to make sure that resource acquisition is always paired up with resource release, and that these two actions happen before and after the section of code that uses the resource respectively. In C++, this kind of bracketing of a code sequence by a pair of actions is known as the Execute Around design pattern.</p>
<p class="callout-heading">Tip</p>
<p class="callout">For more information, see the article <em class="italic">C++ Patterns – Executing Around Sequences</em> by Kevlin Henney, available at <a href="http://www.two-sdg.demon.co.uk/curbralan/papers/europlop/ExecutingAroundSequences.pdf">http://www.two-sdg.demon.co.uk/curbralan/papers/europlop/ExecutingAroundSequences.pdf</a>.</p>
<p>When specifically applied to resource management, this pattern i<a id="_idTextAnchor235"/>s much more widely known as <strong class="bold">Resource Acquisition is </strong><strong class="bold">Init<a id="_idTextAnchor236"/>ialization</strong> (<strong class="bold">RAII</strong>).</p>
<h2 id="_idParaDest-89"><a id="_idTextAnchor237"/>RAII in a nutshell</h2>
<p>The basic idea behind <a id="_idIndexMarker233"/>RAII is very simple—there is one kind of function in C++ that is guaranteed to be called automatically, and that is the destructor of an object created on the stack, or the destructor of an object that is a data member of another object (in the latter case, the guarantee holds only if the containing class itself is destroyed). If we could hook up the release of the resource to the destructor of such an object, then the release could not be forgotten or skipped. It stands to reason that if releasing the resource is handled by the destructor, acquiring it should be handled by the constructor during the initialization of the object. Hence the full meaning of RAII as introduced in the title of this chapter—<em class="italic">A Comprehe<a id="_idTextAnchor238"/>nsive Look </em><em class="italic">at RAII</em>.</p>
<p>Let’s see how this works in the simplest case of memory allocation, via <code>operator new</code>. First, we need a class that can be initialized from a pointer to the newly allocated object, and whose destructor will delete that object:</p>
<pre class="source-code">
// Example 05
template &lt;typename T&gt; class raii {
  public:
  explicit raii(T* p) : p_(p) {}
  ~raii() { delete p_; }
  private:
  T* p_;
};</pre>
<p>Now it is very easy to make sure that deletion is never omitted, and we can verify that it works as expected with a test that uses <code>object_counter</code>:</p>
<pre class="source-code">
// Example 05
TEST(RAII, AcquireRelease) {
  object_counter::all_count = object_counter::count = 0;
  {
    raii&lt;object_counter&gt; p(new object_counter);
    EXPECT_EQ(1, object_counter::count);
    EXPECT_EQ(1, object_counter::all_count);
  } // No need to delete p, it's automatic
  EXPECT_EQ(0, object_counter::count);
  EXPECT_EQ(1, object_counter::all_count);
}</pre>
<p>Note that in C++17, the class<a id="_idIndexMarker234"/> template type is deduced from the constructor and we can simply write the following:</p>
<pre class="source-code">
raii p(new object_counter);</pre>
<p>The RAII resource release happens when the owning object is destroyed for any reason; thus, the cleanup after an exception is thrown and automatically taken care of:</p>
<pre class="source-code">
// Example 05
struct my_exception {};
TEST(Memory, NoLeak) {
  object_counter::all_count = object_counter::count = 0;
  try {
    raii p(new object_counter);
    throw my_exception();
  } catch ( my_exception&amp; e ) {
  }
  EXPECT_EQ(0, object_counter::count);
  EXPECT_EQ(1, object_counter::all_count);
}</pre>
<p>Of course, we probably want to use the new object for more than just creating and deleting it, so it would be<a id="_idIndexMarker235"/> nice to have access to the pointer stored inside the RAII object. There is no reason to grant such access in any way other than the standard pointer syntax, which makes our RAII object a kind of pointer itself:</p>
<pre class="source-code">
// Example 06
template &lt;typename T&gt; class scoped_ptr {
  public:
  explicit scoped_ptr(T* p) : p_(p) {}
  ~scoped_ptr() { delete p_; }
  T* operator-&gt;() { return p_; }
  const T* operator-&gt;() const { return p_; }
  T&amp; operator*() { return *p_; }
  const T&amp; operator*() const { return *p_; }
  private:
  T* p_;
};</pre>
<p>This pointer can be used to automatically delete, at the end of the scope, the object that it points to (hence the name):</p>
<pre class="source-code">
// Example 06
TEST(Scoped_ptr, AcquireRelease) {
  object_counter::all_count = object_counter::count = 0;
  {
    scoped_ptr p(new object_counter);
    EXPECT_EQ(1, object_counter::count);
    EXPECT_EQ(1, object_counter::all_count);
  }
  EXPECT_EQ(0, object_counter::count);
  EXPECT_EQ(1, object_counter::all_count);
}</pre>
<p>The destructor is called when the <a id="_idIndexMarker236"/>scope containing the <code>scoped_ptr</code> object is exited. It does not matter how it is exited—an early <code>return</code> from a function, a <code>break</code> or <code>continue</code> statement in the loop, or an exception being thrown are all handled in exactly the same way, and without leaks. We can verify this with tests, of course:</p>
<pre class="source-code">
// Example 06
TEST(Scoped_ptr, EarlyReturnNoLeak) {
  object_counter::all_count = object_counter::count = 0;
  do {
    scoped_ptr p(new object_counter);
    break;
  } while (false);
  EXPECT_EQ(0, object_counter::count);
  EXPECT_EQ(1, object_counter::all_count);
}
TEST(Scoped_ptr, ThrowNoLeak) {
  object_counter::all_count = object_counter::count = 0;
  try {
    scoped_ptr p(new object_counter);
   throw 1;
  } catch ( ... ) {}
  EXPECT_EQ(0, object_counter::count);
  EXPECT_EQ(1, object_<a id="_idTextAnchor239"/>counter::all_count);
}</pre>
<p>All tests pass, confirming<a id="_idIndexMarker237"/> that there is no leak:</p>
<pre class="console">
[----------] 6 tests from Scoped_ptr
[ RUN      ] Scoped_ptr.AcquireRelease
[       OK ] Scoped_ptr.AcquireRelease (0 ms)
[ RUN      ] Scoped_ptr.EarlyReturnNoLeak
[       OK ] Scoped_ptr.EarlyReturnNoLeak (0 ms)
[ RUN      ] Scoped_ptr.ThrowNoLeak
[       OK ] Scoped_ptr.ThrowNoLeak (0 ms)
[ RUN      ] Scoped_ptr.DataMember
[       OK ] Scoped_ptr.DataMember (0 ms)
[ RUN      ] Scoped_ptr.Reset
[       OK ] Scoped_ptr.Reset (0 ms)
[ RUN      ] Scoped_ptr.Reseat
[       OK ] Scoped_ptr.Reseat (0 ms)
[----------] 6 tests from Scoped_ptr (0 ms total)</pre>
<p>Similarly, we can use a scoped pointer as a data member in another class—a class that has secondary storage and must release it upon destruction:</p>
<pre class="source-code">
class A {
  public:
  A(object_counter* p) : p_(p) {}
  private:
  scoped_ptr&lt;object_counter&gt; p_;
};</pre>
<p>This way, we don’t have to delete the object manually in the destructor of class <code>A</code>, and, in fact, if every data member of class <code>A</code> takes care of itself in a similar fashion, class <code>A</code> may not even need an explicit destructor.</p>
<p>Anyone familiar with C++11 should recognize our <code>scoped_ptr</code> as a very rudimentary version of <code>std::unique_ptr</code>, which can be used for the same purpose. As you might expect, the standard unique pointer’s implementation has a lot more to it, and for good reasons. We will review some of these reasons later in this chapter, but, to be clear: you should use <code>std::unique_ptr</code> in your code and the only reason we implemented our own <code>scoped_ptr</code> here is to understand how an RAII pointer works.</p>
<p>One last issue to consider is that of performance. C++ strives for zero-overhead abstractions whenever possible. In this case, we are wrapping a raw pointer into a smart pointer object. However, the compiler does not need to generate any additional machine instructions; the wrapper only forces the compiler to generate the code that, in a correct program, it would have done anyway. We can confirm with a simple benchmark that both the construction/deletion and the dereference of our <code>scoped_ptr</code> (or <code>std::unique_ptr</code>, for that matter) take exactly the same time as the corresponding operations on a raw pointer. For example, the following microbenchmark (using the Google benchmark library) compares the performance of all three pointer types for dereferencing:</p>
<pre class="source-code">
// Example 07
void BM_rawptr_dereference(benchmark::State&amp; state) {
  int* p = new int;
  for (auto _ : state) {
    REPEAT(benchmark::DoNotOptimiz<a id="_idTextAnchor240"/>e(*p);)
  }
  delete p;
  state.SetItemsProcessed(32*state.iterations());
}
void BM_scoped_ptr_dereference(benchmark::State&amp; state) {
  scoped_ptr&lt;int&gt; p(new int);
  for (auto _ : state) {
    REPEAT(benchmark::DoNotOptimize(*p);)
  }
  state.SetItemsProcessed(32*state.iterations());
}
void BM_unique_ptr_dereference(benchmark::State&amp; state) {
  std::unique_ptr&lt;int&gt; p(new int);
  for (auto _ : state) {
     REPEAT(benchmark::DoNotOptimize(*p);)
  }
  state.SetItemsProcessed(32*state.iterations());
}
BENCHMARK(BM_rawptr_dereference);
BENCHMARK(BM_scoped_ptr_ dereference);
BENCHMARK(BM_unique_ptr_dereference);
BENCHMARK_MAIN();</pre>
<p>The benchmark shows that the <a id="_idIndexMarker238"/>smart pointers indeed incur no overhead:</p>
<pre class="console">
----------------------------------------------------------------------
Benchmark                   Time        CPU Iterations UserCounters...
BM_rawptr_dereference      3.42 ns  3.42 ns  817698667 items_per_second=9.35646G/s
BM_scoped_ptr_dereference  3.37 ns  3.37 ns  826869427 items_per_second=9.48656G/s
BM_unique_ptr_dereference  3.42 ns  3.42 ns  827030287 items_per_second=9.36446G/s</pre>
<p>We have covered in enough detail the applications of RAII for managing memory. But there are other resources that a C++ program needs to manage <a id="_idTextAnchor241"/>and keep track of, so we have to expa<a id="_idTextAnchor242"/>nd our view of RAII now.</p>
<h2 id="_idParaDest-90"><a id="_idTextAnchor243"/>RAII for other resources</h2>
<p>The name, RAII, refers to <em class="italic">resources </em>and not <em class="italic">memory</em>, and indeed the same approach is applicable to other resources. For each resource type, we need a special object, although generic programming and lambda expressions may help us to write less code (we will learn more about this in <a href="B19262_11.xhtml#_idTextAnchor509"><em class="italic">Chapter 11</em></a>, <em class="italic">ScopeGuard</em>). The resource is acquired in the constructor and released in the destructor. Note that there are two slightly different flavors of RAII. The first option is the one we have already seen—the actual acquisition of the resource is at initialization, but outside of the constructor of the RAII object.</p>
<p>The constructor merely captures the handle (such as a pointer) that resulted from this acquisition. This was the case with the <code>scoped_ptr</code> object that we just saw—memory allocation and object construction were both done outside of the constructor of the <code>scoped_ptr</code> object, but still during its initialization. The second option is for the constructor of the RAII object to actually acquire the resource. Let’s see how this works, with the example of an RAII object that manages mutex locks:</p>
<pre class="source-code">
// Example 08
class mutex_guard {
  public:
  explicit mutex_guard(std::mutex&amp; m) : m_(m) {
    m_.lock();
  }
  ~mutex_guard() { m_.unlock(); }
  private:
  std::mutex&amp; m_;
};</pre>
<p>Here, the constructor of the <code>mutex_guard</code> class itself acquires the resource; in this case, exclusive access to the shared data protected by the mutex. The destructor releases that resource. Again, this<a id="_idIndexMarker239"/> pattern completely removes the possibility of <em class="italic">leaking </em>a lock (that is, exiting a scope without releasing the lock), for example, when an exception is thrown:</p>
<pre class="source-code">
// Example 08
std::mutex m;
TEST(MutexGuard, ThrowNoLeak) {
  try {
    mutex_guard lg(m);
    EXPECT_FALSE(m.try_lock());    // Expect to be locked
    throw 1;
  } catch ( ... ) {}
  EXPECT_TRUE(m.try_lock());    // Expect to be unlocked
  m.unlock();    // try_lock() will lock, undo it
}</pre>
<p>In this test, we check whether the mutex is locked or not by calling <code>std::mutex::try_lock()</code>—we cannot call <code>lock()</code> if the mutex is already locked, as it will deadlock. By calling <code>try_lock()</code>, we can check the state of the mutex without the risk of deadlock (but remember to unlock the mutex if <code>try_lock()</code> succeeds since we’re using <code>try_lock()</code> just to test and don’t want to lock the mutex again).</p>
<p>Again, the standard provides an RAII object for mutex locking, <code>std::lock_guard</code>. It is used in a similar manner but can be applied to any mutex type that has the <code>lock()</code> and <code>unlock()</code> member functions:</p>
<pre class="source-code">
  try {
    std::lock_guard lg(m);        // C++17 constructor
    EXPECT_FALSE(m.try_lock());    // Expect to be locked
    throw 1;
  } catch ( ... ) {}
  EXPECT_TRUE(m.try_lock());    // Expect to be unlocked</pre>
<p>In C++17, we have a similar RAII object for locking multiple mutexes – <code>std::scoped_lock</code>. In addition to the RAII release, it offers a deadlock avoidance algorithm when locking several<a id="_idIndexMarker240"/> mutexes at once. Of course, there are many more kinds of resources that a C++ program may have to manage, so we often end up writing our own RAII objects. Sometimes, the standard helps out, such as the addition of <code>std::jthread</code> in C++20 (a thread is also a resource, and “<em class="italic">releasing</em>” it usually means joining the thread, which is what <code>std::jthread</code> does in its destructor). With the wide variety of resources that can be managed with RAII techniques, sometimes we have needs that go beyond automatically releasing resource<a id="_idTextAnchor244"/><a id="_idTextAnchor245"/><a id="_idTextAnchor246"/>s at the end of the scope.</p>
<h2 id="_idParaDest-91"><a id="_idTextAnchor247"/>Releasing early</h2>
<p>The scope of a function or a loop<a id="_idIndexMarker241"/> body does not always match the desired duration of the holding of the resource. If we do not want to acquire the resource at the very beginning of the scope, this is easy—the RAII object can be created anywhere, not just at the beginning of the scope. Resources are not acquired until the RAII object is constructed, as follows:</p>
<pre class="source-code">
void process(...) {
  ... do work that does not need exclusive access ...
  mutex_guard lg(m);    // Now we lock
  ... work on shared data, now protected by mutex ...
} // lock is released here</pre>
<p>However, the release still happens at the end of the function body scope. What if we only want to lock a short portion of code inside the function? The simplest answer is to create an additional scope:</p>
<pre class="source-code">
void process(...) {
  ... do work that does not need exclusive access ...
  {
    mutex_guard lg(m);    // Now we lock
    ... work on shared data, now protected by mutex ...
  } // lock is released here
  ... more non-exclusive work ...
}</pre>
<p>It may be surprising if you have never seen it before, but in C++, any sequence of statements can be enclosed in the curly braces, as <code>{ ... }</code>. Doing so creates a new scope with its own local variables. Unlike the curly braces that come after loops or conditional statements, the only purpose of this scope is to control the lifetime of these local variables. A program <a id="_idIndexMarker242"/>that uses RAII extensively often has many such scopes, enclosing variables with different lifetimes that are shorter than the overall function or loop body. This practice also improves readability by making it clear that some variables will not be used after a certain point, so the reader does not need to scan the rest of the code looking for possible references to these variables. Also, the user cannot accidentally add such a reference by mistake if the intent is to <em class="italic">expire</em> a variable and never use it again.</p>
<p>And what if a resource may be released early, but only if certain conditions are met? One possibility is, again, to contain the use of the resource in a scope, and exit that scope when the resource is no longer needed. It would be convenient to be able to use <code>break</code> to get out of a scope. A common way to do just that is to write a <em class="italic">do </em><em class="italic">once</em> loop:</p>
<pre class="source-code">
// Example 08
void process(...) {
  ... do work that does not need exclusive access ...
  <a id="_idTextAnchor248"/>do {    // Not really a loop
    mutex_guard lg(m);    // Now we lock
    ... work on shared data, now protected by mutex ...
    if (work_done) break;    // Exit the scope
    ... work on the shared data some more ...
  } while (false);        // lock is released here
  ... more non-exclusive work ...
}</pre>
<p>However, this approach does not always work (we may want to release the resources, but not other local variables we defined in the same scope), and the readability of the code suffers as the <a id="_idIndexMarker243"/>control flow gets more complex. Resist the impulse to accomplish this by allocating the RAII object dynamically, with <code>operator new</code>! This completely defeats the whole point of RAII, since you now must remember to invoke <code>operator delete</code>. We can enhance our resource-managing objects by adding a client-triggered release, in addition to the automatic release by the destructor. We just have to make sure that the same resource is not released twice. Consider the following example, using <code>scoped_ptr</code>:</p>
<pre class="source-code">
// Example 06
template &lt;typename T&gt; class scoped_ptr {
  public:
  explicit scoped_ptr(T* p) : p_(p) {}
  ~scoped_ptr() { delete p_; }
  ...
  void reset() {
    delete p_;
    p_ = nullptr;     // Releases resource early private:
  }
  T* p_;
};</pre>
<p>After calling <code>reset()</code>, the object managed by the <code>scoped_ptr</code> object is deleted, and the pointer data member of the <code>scoped_ptr</code> object is reset to null. Note that we did not need to add a condition check to the destructor, because calling delete on a null pointer is allowed by the standard—it does nothing. The resource is released only once, either explicitly by the <code>reset()</code> call, or implicitly at the end of the scope containing the <code>scoped_ptr</code> object. As we already noted, you do not need to write your own <code>scoped_ptr</code> except to learn how RAII pointers work: <code>std::unique_ptr</code> can be reset too.</p>
<p>For the <code>mutex_guard</code> class, we can’t deduce from just the lock whether an early release was called or not, and we<a id="_idIndexMarker244"/> need an additional data member to keep track of that:</p>
<pre class="source-code">
// Example 08
class mutex_guard {
  public:
  explicit mutex_guard(std::mutex&amp; m) :
    m_(m), must_unlock_(true) { m_.lock(); }
  ~mutex_guard() { if (must_unlock_) m_.unlock(); }
   void reset() { m_.unlock(); must_unlock_ = false; }
  private:
  std::mutex&amp; m_;
  bool must_unlock_;
};</pre>
<p>Now we can verify that the mutex is released only once, at the right time, with this test:</p>
<pre class="source-code">
TEST(MutexGuard, Reset) {
  {
    mutex_guard lg(m);
    EXPECT_FALSE(m.try_lock());
    lg.reset();
    EXPECT_TRUE(m.try_lock()); m.unlock();
  }
  EXPECT_TRUE(m.try_lock()); m.unlock();
}</pre>
<p>The standard <code>std::unique_ptr</code> pointer supports <code>reset()</code>, whereas <code>std::lock_guard</code> does not, so if you need to release a mutex early, you need to use a different standard RAII object, <code>std::unique_lock</code>:</p>
<pre class="source-code">
// Example 08
TEST(LockGuard, Reset) {
  {
    std::unique_lock lg(m);
    EXPECT_FALSE(m.try_lock());
    lg.unlock();
    EXPECT_TRUE(m.try_lock()); m.unlock();
  }
  EXPECT_TRUE(m.try_lock()); m.unlock();
}</pre>
<p>For other resources, you may have to write your own RAII object, which is usually a pretty simple class, but finish reading this chapter before you start writing, as there are a few <em class="italic">gotchas</em> to keep in mind.</p>
<p>Note that the <code>reset()</code> method of <code>std::unique_ptr</code> actually does more than just delete the object prematurely. It can also be used to <strong class="bold">reset</strong> the pointer by making it point to a new object while the <a id="_idIndexMarker245"/>old one is deleted. It works something like this (the actual implementation in the standard is a bit more complex, because of the additional functionality the unique pointer has):</p>
<pre class="source-code">
template &lt;typename T&gt; class scoped_ptr {
  public:
  explicit scoped_ptr(T* p) : p_(p) {}
  ~scoped_ptr() { delete p_; }
  ...
  void reset(T* p = nullptr) {
    delete p_; p_ = p;    // Reseat the pointer
  }
  private:
  T* p_;
};</pre>
<p>Note that this code breaks if<a id="_idIndexMarker246"/> a scoped pointer is reset to itself (for example, if <code>reset()</code> is called with the same value as that stored in <code>p_</code>). We could check for this condition and do nothing; it is worth noting that the standard does not require s<a id="_idTextAnchor249"/><a id="_idTextAnchor250"/><a id="_idTextAnchor251"/>uch a check for <code>std::unique_ptr</code>.</p>
<h2 id="_idParaDest-92"><a id="_idTextAnchor252"/>Careful implementation of Resource Acquisition is Initialization objects</h2>
<p>It is obviously very important <a id="_idIndexMarker247"/>that the resource management objects do not mismanage the resources they are entrusted to guard. Unfortunately, the simple RAII objects we have been writing so far have several glaring holes.</p>
<p>The first problem arises when someone tries to copy these objects. Each of the RAII objects we have considered in this chapter is responsible for managing a unique instance of its resource, and yet, nothing prevents us from copying this object:</p>
<pre class="source-code">
scoped_ptr&lt;object_counter&gt; p(new object_counter);
scoped_ptr&lt;object_counter&gt; p1(p);</pre>
<p>This code invokes the default copy constructor, which simply copies the bits inside the object; in our case, the pointer is copied to the <code>object_counter</code>. Now we have two RAII objects that both control the same resource. Two destructors will be called, eventually, and both will attempt to delete the same object. The second deletion is undefined behavior (if we are very fortunate, the program will crash at that point).</p>
<p>Assignment of RAII objects is similarly problematic:</p>
<pre class="source-code">
scoped_ptr&lt;object_counter&gt; p(new object_counter);
scoped_ptr&lt;object_counter&gt; p1(new object_counter);
p = p1;</pre>
<p>The default assignment operator also copies the bits of the object. Again, we have two RAII objects that will delete the same managed object. Equally troublesome are the facts that we have no RAII objects that manage the second <code>object_counter</code>, the old pointer inside <code>p1</code> is gone, and there is no other reference to this object, so we have no way to delete it.</p>
<p>The <code>mutex_guard</code> does no better—an attempt to copy it results in two mutex guards that will unlock the same mutex. The second unlock will be done on a mutex that is not locked (at least not by the calling thread), which, according to the standard, is undefined behavior. Assignment of the <code>mutex_guard</code> object is not possible, though, because the default assignment operator is not generated for obj<a id="_idTextAnchor253"/>ects with reference data members.</p>
<p>As you may have probably noticed, the <a id="_idIndexMarker248"/>problem is created by the <strong class="bold">default</strong> copy constructor and default assignment operator. Does it mean that we should have implemented our own? What would they do? Only one destructor should be called for each object that was constructed; a mutex can only be unlocked once after it was locked. This suggests that an RAII object should not be copied at all, and we should disallow both copying and assignment:</p>
<pre class="source-code">
template &lt;typename T&gt; class scoped_ptr {
  public:
  explicit scoped_ptr(T* p) : p_(p) {}
  ~scoped_ptr() { delete p_; }
  ...
  private:
  T* p_;
  scoped_ptr(const scoped_ptr&amp;) = delete;
  scoped_ptr&amp; operator=(const scoped_ptr&amp;) = delete;
};</pre>
<p>There are some RAII objects that can be copied. These are reference-counted resource management objects; they keep track of how many copies of the RAII object exist for the same instance of the managed resource. The last of the RAII objects has to release the resource when it is deleted. We discuss shared management of resources in more detail in <a href="B19262_03.xhtml#_idTextAnchor110"><em class="italic">Chapter 3</em></a>, <em class="italic">Memory </em><em class="italic">and Ownership</em>.</p>
<p>A different set of considerations exist for move constructor and assignment. Moving the object does not violate the assumption that there is only one RAII object that owns a particular resource. It merely changes which RAII object that is. In many cases, such as mutex guards, it does not make sense to move an RAII object (indeed, the standard does not make <code>std::lock_guard</code> or <code>std::scoped_lock</code> movable, but <code>std::unique_lock</code> is movable and can be used to transfer ownership of a mutex). Moving a unique pointer is possible and makes sense in some contexts, which we also explore in <a href="B19262_03.xhtml#_idTextAnchor110"><em class="italic">Chapter 3</em></a>, <em class="italic">Memory </em><em class="italic">and Ownership</em>.</p>
<p>However, for a scoped<a id="_idIndexMarker249"/> pointer, moving would be undesirable, as it allows the extension of the lifetime of the managed object beyond the scope where it was created. Note that we do not need to delete the move constructor or move assignment operators if we already deleted the copying ones (although doing so does no harm). On the other hand, <code>std::unique_ptr</code> is a movable object, which means using it as a scope-guarding smart pointer does not offer the same protection because the resource could be moved out. However, if you need a scoped pointer, there is a very simple way to make <code>std::unique_ptr</code> do this job perfectly—all you have to do is to declare a <code>const </code><code>std::unique_ptr</code> object:</p>
<pre class="source-code">
std::unique_ptr&lt;int&gt; p;
{
  // Can be moved out of the scope
  std::unique_ptr&lt;int&gt; q(new int);
  q = std::move(p);    // and here it happens
  // True scoped pointer, cannot be moved anywhere
  const std::unique_ptr&lt;int&gt; r(new int);
  q = std::move(r);    // Does not compile
}</pre>
<p>So far, we have protected our RAII objects against duplicating or losing resources. But there is one more kind of resource management mistake that we have not yet considered. It seems obvious that a resource should be released in a way that matches its acquisition. And yet, nothing protects our <code>scoped_ptr</code> object from such a mismatch between construction and deletion:</p>
<pre class="source-code">
scoped_ptr&lt;int&gt; p(new int[10]);</pre>
<p>The problem here is that we have allocated multiple objects using an array version of <code>operator new</code>; it should be deleted with the array version of <code>operator delete </code>- <code>delete [] p_</code> must be called inside the <code>scoped_ptr</code> destructor, instead of <code>delete p_</code> that we have there now.</p>
<p>More generally, an RAII object that accepts a resource handle during initialization, instead of acquiring the resource itself (like the <code>mutex_guard</code> does) must somehow ensure that the resource <a id="_idIndexMarker250"/>is released in the right way that matches the way it was acquired. Obviously, this is not possible, in general. In fact, it is impossible to do automatically, even for the simple case of a mismatched <code>new</code> array and the <code>delete</code> scalar (<code>std::unique_ptr</code> does no better than our <code>scoped_ptr</code> here, although facilities such as <code>std::make_unique</code> make <a id="_idTextAnchor254"/>writing such code less error-prone).</p>
<p>In general, either the RAII class is designed to release resources in one particular way, or the caller must specify how the resource must be released. The former is certainly easier, and in many cases is quite sufficient. In particular, if the RAII class also acquires a resource, such as our <code>mutex_guard</code>, it certainly knows how to release it. Even for the <code>scoped_ptr</code>, it would not be too hard to create two versions, <code>scoped_ptr</code> and <code>scoped_array</code>; the second one is for objects allocated by the <code>operator new</code> array. The standard handles it by specializing the unique pointer for arrays: you can write <code>std::unique_ptr&lt;int[]&gt;</code> and the array <code>delete</code> will be used (it is still up to the programmer to make sure that arrays allocated by <code>new[]</code> are owned by the correct instantiation of the pointer).</p>
<p>A more general version of an RAII class is parameterized not just by the resource type, but also by a callable object used to release this type, usually known as the deleter. The deleter can be a function pointer, a member function pointer, or an object with <code>operator()</code> defined—basically, anything that can be called like a function. Note that the deleter has to be passed to the RAII object in its constructor, and stored inside the RAII object, which makes the object larger. Also, the type of the deleter is a template parameter of the RAII clas<a id="_idTextAnchor255"/>s, unless it is erased from the RAII type (this will be covered in <a href="B19262_06.xhtml#_idTextAnchor266"><em class="italic">Chapter 6</em></a>, <em class="italic">Understanding Type Erasure</em>). The standard gives us examples of both: <code>std::unique_ptr</code> has the deleter template parameter, whil<a id="_idTextAnchor256"/>e <code>std::shared_ptr</code> uses type erasure.</p>
<h2 id="_idParaDest-93"><a id="_idTextAnchor257"/>Downsides of RAII</h2>
<p>Honestly, there aren’t any significant downsides to RAII. It is by far the most widely used idiom for resource management in C++. The only issue of significance to be aware of has to do with exceptions. Releasing <a id="_idIndexMarker251"/>a resource can fail, like anything else. The usual way in C++ to signal a failure is to throw an exception. When that is undesirable, we fall back on returning error codes from functions. With RAII, we can do neither of these things.</p>
<p>It is easy to understand why error codes are not an option—the destructor does not return anything. Also, we cannot write the error code into some status data member of the object, since the object is being destroyed and its data members are gone, as are the other local variables from the scope containing the RAII object. The only way to save an error code for future examination would be to write it into some sort of a global status variable, or at least a variable from the containing scope. This is possible in a bind, but such a solution is very inelegant and error-prone. This is exactly the problem that C++ was trying to solve when exceptions were introduced: manually-propagated error codes are error-prone and unreliable.</p>
<p>So, if the exceptions are the answer to error reporting in C++, why not use them here? The usual answer is <em class="italic">that the destructors in C++ cannot throw</em>. This captures the gist of it, but the real restriction is a bit more nuanced. First of all, prior to C++11, the destructors technically could throw, but the exception would propagate and (hopefully) eventually get caught and processed. In C++11, all destructors are, by default, <code>noexcept</code>, unless explicitly specified as <code>noexcept(false)</code>. If a <code>noexcept</code> function throws<a id="_idTextAnchor258"/>, the program immediately terminates.</p>
<p>So indeed, in C++11, destructors cannot throw unless you specifically allow them to do so. But what’s wrong with throwing an exception in the destructor? If the destructor is executed because the object was deleted, or because the control reached the end of the scope for a stack object, then nothing is wrong. The <em class="italic">wrong</em> happens if the control did not reach the end of the scope normally and the destructor is executed because an exception was already thrown. In C++, two exceptions cannot propagate at the same time. If this happens, the program will immediately terminate (note that a destructor can throw and catch an exception, there is no problem with that, as long as that exception does not propagate out of the destructor). Of course, when writing a program, there is no way to know when some function called from something in a particular scope, could throw. If the resource release throws and the RAII object allows that exception to propagate out of its destructor, the program is going to terminate if that destructor was called during exception handling. The only safe way is never to allow exceptions to propagate from a destructor.</p>
<p>This does not mean that the function that releases the resource itself cannot throw, but, if it does, an RAII destructor has to catch that exception:</p>
<pre class="source-code">
class raii {
  ...
  ~raii() {
    try {
      release_resource();    // Might throw
    } catch ( ... ) {
      ... handle the exception, do NOT rethrow ...
    }
  }
};</pre>
<p>This still leaves us with no way to signal that an error happened during resource release—an exception was thrown, and we had to catch it and not let it escape.</p>
<p>How much of a problem is this? Not that much, really. First of all, releasing memory—the most frequently managed resource—does not throw an exception. Usually, the memory is released not as just memory, but by deleting an object. But remember that the destructors should not throw an exception in order that the entire process of releasing memory by deleting an object doesn’t throw an exception either. At this point, the reader might, in search of a counter-example, look up in the standard what happens if unlocking a mutex fails (that would force the destructor of <code>std::lock_guard</code> to deal with the error). The answer is both surprising and enlightening—unlocking a mutex cannot throw, but if it fails, undefined behavior results instead. This is no accident; the mutex was intended to work with an RAII object. Such is, in general, the C++ approach to releasing the resources: an exception should not be thrown if the release fails, or at least not allowed to propagate. It can be caught and logged, for example, but the calling program will, in general, remain unaware of the failure, possibly at the cost of undefined behavior.</p>
<p>RAII is a really successful technique that has evolved very little even as the language changes significantly from pre-C++11 all the way to C++20 (aside from minor syntactic conveniences such as constructor argument deduction). That is because it really doesn’t have any downsides of note. But, as the language gets new capabilities, sometimes we find ways to improve even the best and most <a id="_idIndexMarker252"/>established patterns, and here is one of those cases.</p>
<h1 id="_idParaDest-94"><a id="_idTextAnchor259"/>Very modern RAII</h1>
<p>If we really want to be picky, we<a id="_idIndexMarker253"/> can make another complaint about RAII; realistically, this is only a downside when the acquisition or release code is long and complex. The acquisition and release are done in the constructor and the destructor of an RAII object, respectively, and this code can be quite removed from the place in the code where the resource is acquired (so we have to jump around the program a bit to figure out what it does).</p>
<p>Similarly, if the resource handling requires a lot of state (such as the appropriate actions depending on several factors and conditions), we have to capture all this state in the RAII object. An example that truly challenges the readability of RAII would also be completely unreadable on a book page, so we will have to condense it. Let us say that we want to have an RAII lock guard that performs several actions when locking and unlocking the mutex, and even the way it handles the resource depends on some external parameters:</p>
<pre class="source-code">
// Example 09a
class lock_guard {
  std::mutex&amp; m_;
  const bool log_;
  const bool mt_;
  public:
  lock_guard(std::mutex&amp; m, bool log, bool mt);
  ~lock_guard();
};
lock_guard ::lock_guard(std::mutex&amp; m, bool log, bool mt)
  : m_(m), log_(log), mt_(mt) {
  if (log_) std::cout &lt;&lt; "Before locking" &lt;&lt; std::endl;
  if (mt_) m.lock();
}
lock_guard::~lock_guard() {
  if (mt_) m.unlock();
  if (log_) std::cout &lt;&lt; "After locking" &lt;&lt; std::endl;
}</pre>
<p>And here is how this guard <a id="_idIndexMarker254"/>object might be used:</p>
<pre class="source-code">
#include &lt;mutex&gt;
std::mutex m;
const bool mt_run = true;
void work() {
  try {
    lock_guard lg(m, true, mt_run);
    … this code might throw …
    std::cout &lt;&lt; "Work is happening" &lt;&lt; std::endl;
  } catch (...) {}
}</pre>
<p>Here we perform only one possible action in addition to locking and unlocking – we can optionally log these events; you can already see that the implementations of the constructor and the destructor, the two sections of code that must be closely matched, are somewhat separated from each other. Also, tracking the state (do we need to log the events? Are we running in a multi-threaded or single-threaded context?) is becoming somewhat verbose. Again, you have to remember that this is a simplified example: in a real program, this is still a fine RAII object. But, if the code gets even longer, you may wish for a better way.</p>
<p>In this case, the better way is borrowed from Python (specifically, from the <code>contextmanager</code> decorator). This technique used coroutines and, thus, requires C++20 (so we managed to couple one of the oldest tools in C++ with the most cutting-edge one). The detailed explanation<a id="_idIndexMarker255"/> of the coroutines in general and the C++ coroutine machinery in particular lies outside of the scope of this book (you can find it, for example, in my book “<em class="italic">The Art of Writing Efficient </em><em class="italic">Programs</em>”, (<a href="https://www.packtpub.com/product/the-art-of-writing-efficient-programs/9781800208117">https://www.packtpub.com/product/the-art-of-writing-efficient-programs/9781800208117</a>)).</p>
<p>For now, it is sufficient to remember two things:</p>
<ul>
<li>First, C++ coroutines are, essentially, regular functions except they suspend themselves at any time and return the control to the caller. The caller can resume the coroutine, and it continues to execute from the suspension point as if nothing happened.</li>
<li>Second, C++ coroutines require a lot of standard boilerplate code. In the example that follows, we will highlight the important fragments; you can safely assume that the rest of the code is required by the standard to make the coroutine machinery work.</li>
</ul>
<p>Let us first see what the code for a lock guard looks like with this new coroutine-based RAII approach:</p>
<pre class="source-code">
#include &lt;mutex&gt;
std::mutex m;
const bool mt_run = true;
co_resource&lt;std::mutex&gt; make_guard(std::mutex&amp; m, bool log)
{
  if (log) std::cout &lt;&lt; "Before locking" &lt;&lt; std::endl;
  if (mt_run) m.lock();
  co_yield m;
  if (mt_run) m.unlock();
  if (log) std::cout &lt;&lt; "After locking" &lt;&lt; std::endl;
}
void work () {
  try {
    co_resource&lt;std::mutex&gt; lg { make_guard(m, true) };
    … this code might throw …
    std::cout &lt;&lt; "Work is happening" &lt;&lt; std::endl;
  } catch (...) {}
}</pre>
<p>Instead of the <code>lock_guard</code> object, we have the <code>make_guard</code> function. This function is a coroutine; you can tell because it has the <code>co_yield</code> operator – this is one of several ways C++ coroutines return values to the caller. The code before <code>co_yield</code> is resource acquisition, it is <a id="_idIndexMarker256"/>executed when the resource is acquired and is equivalent to the constructor of our <code>lock_guard</code> object. The code after <code>co_yield</code> is the same as the destructor of <code>lock_guard</code>. Arguably, this is easier to read and maintain (at least after you stop staring at the coroutine syntax) because all the code is in the same place you can think of <code>co_yield</code> as a placeholder for the work the caller is going to do while owning the resource (the mutex, in our case). Also, there are no class members and member initialization to write – the function parameters are accessible throughout the execution of the coroutine.</p>
<p>The coroutine returns an object of type <code>co_resource&lt;std::mutex&gt;</code>: that is our modern RAII type is implemented as the <code>co_resource</code> class template; it is implemented as follows:</p>
<pre class="source-code">
// Example 09
#include &lt;cassert&gt;
#include &lt;coroutine&gt;
#include &lt;cstddef&gt;
#include &lt;memory&gt;
#include &lt;utility&gt;
template &lt;typename T&gt; class co_resource {
  public:
  using promise_type = struct promise_type&lt;T&gt;;
  using handle_type = std::coroutine_handle&lt;promise_type&gt;;
  co_resource(handle_type coro) : coro_(coro) {}
  co_resource(const co_resource&amp;) = delete;
  co_resource&amp; operator=(const co_resource&amp;) = delete;
  co_resource(co_resource&amp;&amp; from)
     : coro_(std::exchange(from.coro_, nullptr)) {}
  co_resource&amp; operator=(co_resource&amp;&amp; from) {
    std::destroy_at(this);
    std::construct_at(this, std::move(from));
    return *this;
  }
  ~co_resource() {
    if (!coro_) return;
    coro_.resume();     // Resume from the co_yield point
    coro_.destroy();    // Clean up
  }
  private:
  handle_type coro_;
};</pre>
<p>This is the object that owns the resource, but you don’t see the resource or its type <code>T</code> directly: it is hidden inside the coroutine handle <code>coro_</code>. This handle acts like a pointer to the state of the coroutine. If you focus on the handle as a resource for the moment, we have a fairly routine resource-owning object. It acquires the resource in the constructor and maintains the exclusive ownership: the handle is destroyed in the destructor of the <code>co_resource</code> object unless the ownership is transferred via move, and copying the resource is not allowed.</p>
<p>This resource-owning object is going to be returned by a coroutine function; every such object must contain a nested type named <code>promise_type</code>. Often, it is a nested class, but it can also be a separate type (in this example, we made it such largely to avoid a single very long code fragment). The standard imposes several requirements on the interface of the promise type, and here is the type that meets these requirements for our purposes:</p>
<pre class="source-code">
template &lt;typename T&gt; struct promise_type {
  const T* yielded_value_p = nullptr;
  std::suspend_never initial_suspend() noexcept {
    return {};
  }
  std::suspend_always final_suspend() noexcept {
    return {};
  }
  void return_void() noexcept {}
  void unhandled_exception() { throw; }
  std::suspend_always yield_value(const T&amp; val) noexcept {
    yielded_value_p = &amp;val;
    return {};
  }
  using handle_type = std::coroutine_handle&lt;promise_type&gt;;
  handle_type get_return_object() {
    return handle_type::from_promise(*this);
  }
};</pre>
<p>Our promise type contains a pointer to the value returned by the coroutine. How does the value get there? When the coroutine returns the result via <code>co_yield</code>, the member function <code>yield_value()</code> is called (the compiler generates this call). The value returned by <code>co_yield</code> is passed to this function, which, in turn, captures its address (the lifetime of the <a id="_idIndexMarker257"/>value is the same as that of the coroutine itself). The other important member function of the promise type is <code>get_return_object()</code>: it is invoked by the compiler to return the <code>co_resource</code> object itself to the caller of the <code>make_guard()</code> coroutine. Note that it does not return a <code>co_resource</code> object, but a handle that is implicitly convertible to <code>co_resource</code> (it has an implicit constructor from <code>handle_type</code>). The rest of the <code>promise_type</code> interface is, for our purposes, the boilerplate code required by the standard.</p>
<p>Here is how the <code>co_resource</code> RAII works: first, we call the function <code>make_guard()</code>:</p>
<pre class="source-code">
co_resource&lt;std::mutex&gt; make_guard(std::mutex&amp; m, bool log)
{
  if (log) std::cout &lt;&lt; "Before locking" &lt;&lt; std::endl;
  if (mt_run) m.lock();
  co_yield m;
  if (mt_run) m.unlock();
  if (log) std::cout &lt;&lt; "After locking" &lt;&lt; std::endl;
}</pre>
<p>From the caller’s point of view, it starts executing like any other function, although the internal details are quite different. All the code we wrote before <code>co_yield</code> is executed, then the coroutine is suspended and the <code>co_resource&lt;std::mutex&gt;</code> object is constructed and returned to the caller, where it is moved into a stack variable:</p>
<pre class="source-code">
co_resource&lt;std::mutex&gt; lg { make_guard(m, true) };</pre>
<p>The execution proceeds as usual, protected by the locked mutex. At the end of the scope, the object <code>lg</code> is destroyed; this happens no matter whether we exit the scope normally or by throwing an exception. In the destructor of the <code>co_resource</code> object, the coroutine is resumed via the call to the member function <code>resume()</code> of the coroutine handle <code>coro_</code>. This causes the coroutine to resume execution right after the point where stopped before, so the control jumps to the next line after <code>co_yield</code>. The resource release code we wrote there is executed, and the coroutine exits through the bottom of the scope, now for the last time. The destructor of <code>co_resource</code> has some cleanup to do, but, otherwise, we are (mostly) done.</p>
<p>There are a few things we have left out to avoid overly extending the example. First of all, as written, the <code>co_resource</code> template does not work if the resource type <code>T</code> is a reference. This may be perfectly acceptable: handling references by RAII is not that common. In this case, a static assert or a concept check is sufficient. Otherwise, we have to carefully handle dependent <a id="_idIndexMarker258"/>types inside the template. Second, the implicit requirement on the coroutine such as <code>make_guard()</code> is that it returns a value via <code>co_yield</code> exactly once (you can have more than one <code>co_yield</code> in the body of the coroutine, but only one can be executed for a particular call). To make the code robust, we have to verify that this requirement has been met using run-time asserts.</p>
<p>We now have the acquisition and release code right next to each other and we don’t need to convert function arguments into data members like we did when constructors and destructors handled RAII. The only thing that might make it even better would be if we didn’t have to write a separate <code>make_guard()</code> function, at least in cases where we have only one call to it. Turns out that we can combine coroutines and lambdas to just such a result:</p>
<pre class="source-code">
void work(){
  try {
    auto lg { [&amp;](bool log)-&gt;co_resource&lt;std::mutex&gt; {
      if (log) std::cout &lt;&lt; "Before locking" &lt;&lt; std::endl;
      if (mt_run) m.lock();
      co_yield m;
      if (mt_run) m.unlock();
      if (log) std::cout &lt;&lt; "After locking" &lt;&lt; std::endl;
    }(true) };
    … this code might throw …
    std::cout &lt;&lt; "Work is happening" &lt;&lt; std::endl;
  } catch (...) {}
}</pre>
<p>Here the coroutine is the <code>operator()</code> of a lambda expression; note that we have to specify the return type explicitly. The lambda is invoked immediately; and; as usual in such cases, the use of captures or parameters boils down to what is more convenient in each case.</p>
<p>With the coroutine-based RAII resource management, we were able to keep all the relevant code portions very close to each other. Of course, there is a price: launching, suspending, and resuming coroutines takes time (and a bit of memory). The basic RAII object is always going to be faster, so don’t try to replace <code>std::unique_pointer</code> with a <code>co_resource</code> class. But keep in mind that our original dissatisfaction with RAII started with the observation that when the code executed for the acquisition or release of resources is long, complex, and uses a lot of state variables, an RAII class might be hard to read. It is likely that in such cases the overhead of the coroutines is less important (we should also point out that the “scope guard” pattern described later in <a href="B19262_11.xhtml#_idTextAnchor509"><em class="italic">Chapter 11</em></a>, <em class="italic">ScopeGuard</em>, addresses some of the same concerns and sometimes is a better option).</p>
<p>The RAII techniques we have learned are some of the most enduring C++ patterns; they were in use from the first day of C++ and continue to evolve and benefit from the latest language features. Throughout this book, we will casually and without a second thought use classes such as <code>std::unique_ptr</code> or <code>std::lock_guard</code>. For <a id="_idTextAnchor260"/><a id="_idTextAnchor261"/>now, we leave you with these final thoughts.</p>
<h1 id="_idParaDest-95"><a id="_idTextAnchor262"/>Summary</h1>
<p>After this chapter, you should be well aware of the dangers of an ad-hoc approach to resource management. Fortunately, we have learned the most widely used idiom for resource management in C++; the RAII idiom. With this idiom, each resource is owned by an object. Constructing (or initializing) the object acquires the resource, and deleting the object releases it. We saw how using RAII addresses the problems of resource management, such as leaking resources, accidentally sharing resources, and releasing resources incorrectly. We have also learned the basics of writing exception-safe code, at least as far as the leaking or otherwise mishandling of resources is concerned. Writing RAII objects is simple enough, but there are several caveats to keep in mind. Finally, we reviewed the complications that arise when error handling has to be combined with RAII.</p>
<p>RAII is a resource management idiom, but it can also be viewed as an abstraction technique: the complex resources are hidden behind simple resource handles. The next chapter introduces another kind of abstraction idiom, type erasure: instead of complex objects, we will now hide complex types.</p>
<h1 id="_idParaDest-96"><a id="_idTextAnchor263"/>Questions</h1>
<ol>
<li>What are the resources that a program can manage?</li>
<li>What are the main considerations when managing resources in a C++ program?</li>
<li>What is RAII?</li>
<li>How does RAII address the problem of leaking resources?</li>
<li>How does RAII address the problem of dangling resource handles?</li>
<li>What RAII objects are provided by the C++ standard library?</li>
<li>What precautions must be taken when writing RAII objects?<a id="_idTextAnchor264"/></li>
<li>What happens if releasing a resource fails?</li>
</ol>
<h1 id="_idParaDest-97"><a id="_idTextAnchor265"/>Further reading</h1>
<ul>
<li><a href="https://www.packtpub.com/application-development/expert-c-programming">https://www.packtpub.com/application-development/expert-c-programming</a></li>
<li><a href="https://www.packtpub.com/application-development/c-data-structures-and-algorithms">https://www.packtpub.com/application-development/c-data-structures-and-algorithms</a></li>
<li><a href="https://www.packtpub.com/application-development/rapid-c-video">https://www.packtpub.com/application-development/rapid-c-video</a></li>
</ul>
</div>
</body></html>