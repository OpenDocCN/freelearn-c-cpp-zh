["```cpp\nvoid wait_for_data(int timeout_seconds) {\n    sleep(timeout_seconds); // Sleeps for timeout_seconds seconds\n}\n```", "```cpp\n#include <chrono>\n#include <thread>\nvoid wait_for_data(std::chrono::seconds timeout) {\n    std::this_thread::sleep_for(timeout); // Sleeps for the specified timeout\n}\n```", "```cpp\nwait_for_data(std::chrono::milliseconds(150));\n```", "```cpp\n#include <gsl/gsl>\nvoid process_data(gsl::not_null<int*> data) {\n    // Data is guaranteed not to be null here\n}\n```", "```cpp\nint main() {\n    int* p = nullptr;\n    process_data(p); // this will terminate the program\n    return 0;\n}\n```", "```cpp\nsource>: In function 'int main()':\n<source>:9:16: error: use of deleted function 'gsl::not_null<T>::not_null(std::nullptr_t) [with T = int*; std::nullptr_t = std::nullptr_t]'\n    9 |     process_data(nullptr);\n      |     ~~~~~~~~~~~^~~~~~~~~\nIn file included from <source>:1:\n/opt/compiler-explorer/libs/GSL/trunk/include/gsl/pointers:131:5: note: declared here\n  131 |     not_null(std::nullptr_t) = delete;\n      |     ^~~~~~~~\n```", "```cpp\n#include <gsl/gsl>\n#include <memory>\nvoid process_data(gsl::not_null<std::unique_ptr<int>> data) {\n    // Data is guaranteed not to be null here\n}\nint main() {\n    auto data = std::make_unique<int>(42);\n    process_data(std::move(data)); // Safely passed to the function\n}\n```", "```cpp\n#include <gsl/gsl>\n#include <memory>\nvoid process_data(gsl::not_null<std::shared_ptr<int>> data) {\n    // Data is guaranteed not to be null here\n}\nint main() {\n    auto data = std::make_shared<int>(42);\n    process_data(data); // Safely passed to the function\n}\n```", "```cpp\n#include <optional>\nstd::optional<int> fetch_data() {\n    if (/* some condition */)\n        return 42;\n    else\n        return std::nullopt;\n}\n```", "```cpp\nint* findValue() {\n    // ...\n    return nullptr; // No value found\n}\n```", "```cpp\nenum class NetworkError {\n    Timeout,\n    ConnectionLost,\n    UnknownError\n};\n```", "```cpp\n#include <expected>\n#include <iostream>\nstd::expected<int, NetworkError> fetch_data_from_network() {\n    // Simulating network operation...\n    if (/* network timeout */) {\n        return std::unexpected(NetworkError::Timeout);\n    }\n    if (/* connection lost */) {\n        return std::unexpected(NetworkError::ConnectionLost);\n    }\n    return 42; // Successfully retrieved value\n}\nint main() {\n    auto result = fetch_data_from_network();\n    if (result) {\n        std::cout << \"Value retrieved: \" << *result << '\\n';\n    } else {\n        std::cout << \"Network error: \";\n        switch(result.error()) {\n            case NetworkError::Timeout:\n                std::cout << \"Timeout\\n\";\n                break;\n            case NetworkError::ConnectionLost:\n                std::cout << \"Connection Lost\\n\";\n                break;\n            case NetworkError::UnknownError:\n                std::cout << \"Unknown Error\\n\";\n                break;\n        }\n    }\n}\n```", "```cpp\n// Traditional enum\nenum ColorOld { RED, GREEN, BLUE };\nint color = RED; // Implicit conversion to int\n// Scoped enum (enum class)\nenum class Color { Red, Green, Blue };\n// int anotherColor = Color::Red; // Compilation error: no implicit conversion\n```", "```cpp\n    enum class StatusCode : uint8_t { Ok, Error, Pending };\n    ```", "```cpp\n    enum class NetworkStatus { Connected, Disconnected, Error };\n    ```", "```cpp\n    NetworkStatus check_connection() {\n    ```", "```cpp\n        // Implementation\n    ```", "```cpp\n    }\n    ```", "```cpp\n#include <variant>\n#include <iostream>\nstd::variant<int, double, std::string> value = 42;\n// Using std::get with an index:\nint intValue = std::get<0>(value); // Retrieves the int value\n// Using std::get with a type:\ntry {\n    double doubleValue = std::get<double>(value); // Throws std::bad_variant_access\n} catch (const std::bad_variant_access& e) {\n    std::cerr << \"Bad variant access: \" << e.what() << '\\n';\n}\n// Using std::holds_alternative:\nif (std::holds_alternative<int>(value)) {\n    std::cout << \"Holding int\\n\";\n} else {\n    std::cout << \"Not holding int\\n\";\n}\n```", "```cpp\n#include <any>\n#include <iostream>\n#include <stdexcept>\nstd::any value = 42;\ntry {\n    std::cout << std::any_cast<int>(value); // Outputs 42\n    std::cout << std::any_cast<double>(value); // Throws std::bad_any_cast\n} catch(const std::bad_any_cast& e) {\n    std::cerr << \"Bad any_cast: \" << e.what();\n}\n```", "```cpp\ntemplate <typename T>\nT find_max(const std::vector<T>& arr) {\n    // generic implementation\n    return *std::max_element(arr.begin(), arr.end());\n}\n```", "```cpp\ntemplate <>\nstd::string find_max(const std::vector<std::string>& arr) {\n    return *std::max_element(arr.begin(), arr.end(),\n                              [](const std::string& a, const std::string& b) {\n                                  return strcasecmp(a.c_str(), b.c_str()) < 0;\n                              });\n}\n```", "```cpp\ntemplate <typename T, typename = void>\nstruct has_custom_method : std::false_type {};\ntemplate <typename T>\nstruct has_custom_method<T, std::void_t<decltype(&T::customMethod)>> : std::true_type {};\n```", "```cpp\nstatic_assert(has_custom_method<MyClass>::value, \"MyClass must have a customMethod\");\n```", "```cpp\nusing StringToIntVectorMap = std::unordered_map<std::string, std::vector<int>>;\n```", "```cpp\nStringToIntVectorMap myMap;\n```", "```cpp\ntemplate <typename Value>\nusing StringToValueMap = std::unordered_map<std::string, Value>;\n```", "```cpp\n#include <type_traits>\ntemplate <typename T>\nvoid foo(T value) {\n    static_assert(std::is_unsigned<T>::value, \"foo() requires an unsigned integral type\");\n    // ... function body\n}\n```", "```cpp\ntemplate <typename T>\nvoid bar(T value) {\n    if constexpr (std::is_floating_point<T>::value) {\n        // Handle floating-point types\n    } else if constexpr (std::is_integral<T>::value) {\n        // Handle integral types\n    }\n}\n```", "```cpp\nstruct Length { int value; };\nstruct Index { int value; };\nvoid process(Length l, Index i);\n```", "```cpp\n#include <iostream>\nclass File {\npublic:\n    File(const std::string& path) : path_{path} {\n        auto file = fopen(path_.c_str(), \"w\");\n        // check if file is valid\n        // handle errors, etc\n        std::cout << \"File ctor\\n\";\n    }\n    auto& path() const {\n        return path_;\n    }\n    // other ctors, dtor, etc\nprivate:\n    FILE* file_ = nullptr;\n    std::string path_;\n};\nvoid clean(const File& file) {\n    std::cout << \"Removing the file: \" << file.path() << std::endl;\n}\nint main() {\n    auto random_string = std::string{\"blabla\"};\n    clean(random_string);\n}\n```", "```cpp\nFile ctor\nRemoving the file: blabla\n```", "```cpp\nclass File {\npublic:\n    explicit File(const std::string& path) : path_{path} {\n        auto file = fopen(path_.c_str(), \"w\");\n        // check if file is valid\n        // handle errors, etc\n        std::cout << \"File ctor\\n\";\n    }\n    // ... rest of the class\n};\n```"]