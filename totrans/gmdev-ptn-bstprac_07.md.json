["```cpp\nclass GameObject \n{ \nprivate: \n  // Character's health \n  int currentHealth; \n  int maxHealth; \n\n  // Character's name \n  std::string name; \n\npublic: \n  GameObject(); \n  void Initialize(std::string _name = \"Unnamed\", \n     int _maxHealth = -1); \n  std::string GetInfo(); \n\n};\n\n```", "```cpp\n/*************************************************************************/ \n/*! \nConstructor that initializes the class' data \n*/ \n/*************************************************************************/ \nGameObject::GameObject() \n{ \n  Initialize(); \n} \n\n/*************************************************************************/ \n/*! \nInitializes or resets the values of the class \n*/ \n/*************************************************************************/ \nvoid GameObject::Initialize(std::string _name, int _maxHealth) \n{ \n  name = _name; \n  maxHealth = _maxHealth; \n  currentHealth = maxHealth; \n} \n\n/*************************************************************************/ \n/*! \nPrints out information about the class \n*/ \n/*************************************************************************/ \nstd::string GameObject::GetInfo() \n{ \n  return name + \": \" + std::to_string(currentHealth) + \"/\" + \n     std::to_string(maxHealth); \n} \n\n```", "```cpp\nclass GameObject; \n\nclass ObjectPool \n{ \nprivate: \n  std::list<GameObject*> pool; \n  static ObjectPool* instance; \n\n  // Private constructor so users are unable to create without \n  // GetInstance \n  ObjectPool() {} \n\npublic: \n\n  static ObjectPool* GetInstance(); \n  GameObject* AcquireObject(); \n  void ReleaseObject(GameObject* object); \n  void ClearPool(); \n\n};\n\n```", "```cpp\nObjectPool* ObjectPool::GetInstance() \n{ \n  if (instance == nullptr) \n  { \n    instance = new ObjectPool(); \n  } \n  return instance; \n}\n\n```", "```cpp\n/*************************************************************************/ \n/*! \nReturns the first available object if it exists. If not, it will create a new \none for us \n*/ \n/*************************************************************************/ \n\nGameObject* ObjectPool::AcquireObject() \n{ \n  // Check if we have any objects available \n  if (!pool.empty()) \n  { \n    // Get reference to an avaliable object \n    GameObject* object = pool.back(); \n\n    // Since we are going to use it, it's no longer available, \n    // so we need to remove the last element from our list \n    pool.pop_back(); \n\n    // Finally, return the reference \n    return object; \n  } \n  else \n  { \n    // If none are available, create a new one \n    return new GameObject() \n  } \n} \n\n/*************************************************************************/ \n/*! \nMarks an object as being available again \n\n\\param \nThe object to be made available again \n*/ \n/*************************************************************************/ \nvoid ObjectPool::ReleaseObject(GameObject* object) \n{ \n  // Reset the object \n  object->Initialize(); \n\n  // Add it to our avaliable list \n  pool.push_back(object); \n} \n\n/*************************************************************************/ \n/*! \nTakes care of removing all of the objects from the pool whenever we're finished \nworking with it. \n*/ \n/*************************************************************************/ \nvoid ObjectPool::ClearPool() \n{ \n  while (!pool.empty()) \n  { \n    GameObject * object = pool.back(); \n    pool.pop_back(); \n    delete object; \n  } \n}\n\n```", "```cpp\nObjectPool* ObjectPool::instance = 0;\n\n```", "```cpp\n  ObjectPool* pool = ObjectPool::GetInstance(); \n  GameObject * slime = pool->AcquireObject(); \n\n  std::cout << \"Initial: \" << slime->GetInfo() << std::endl; \n\n  slime->Initialize(\"Slime\", 10); \n\n  std::cout << \"After Assignment: \" << slime->GetInfo() << \nstd::endl; \n\n  pool->ReleaseObject(slime); \n\n  slime = pool->AcquireObject(); \n\n  std::cout << \"Reused: \" << slime->GetInfo() << std::endl; \n\n  pool->ClearPool(); \n  delete pool;\n\n```", "```cpp\nclass GameObject \n{ \nprivate: \n  // Character's health \n  int currentHealth; \n  int maxHealth; \n\n  // Character's name \n  std::string name; \n\npublic: \n  GameObject(); \n  void Initialize(std::string _name = \"Unnamed\", \n     int _maxHealth = -1); \n  std::string GetInfo(); \n\n void* operator new(size_t); void operator delete(void* obj); \n\n};\n\n```", "```cpp\nvoid* GameObject::operator new(size_t) \n{ \n  return ObjectPool::GetInstance()->AcquireObject(); \n} \n\nvoid GameObject::operator delete(void* obj) \n{ \n  ObjectPool::GetInstance()->ReleaseObject(static_cast<GameObject*>(obj)); \n}\n\n```", "```cpp\n  ObjectPool* pool = ObjectPool::GetInstance(); \n GameObject * slime = new GameObject(); \n\n  std::cout << \"Initial: \" << slime->GetInfo() << std::endl; \n\n  slime->Initialize(\"Slime\", 10); \n\n  std::cout << \"After Assignment: \" \n     << slime->GetInfo() << std::endl; \n\n delete slime; slime = new GameObject(); \n\n  std::cout << \"Reused: \" << slime->GetInfo() << std::endl; \n\n  pool->ClearPool(); \n  delete pool; \n\n  return 0;\n\n```", "```cpp\n/*************************************************************************/ \n/*! \nReturns the first available object if it exists. If not, it will create a new \none for us \n*/ \n/*************************************************************************/ \n\nGameObject* ObjectPool::AcquireObject() \n{ \n  // Check if we have any objects available \n  if (!pool.empty()) \n  { \n    // Get reference to an avaliable object \n    GameObject* object = pool.back(); \n\n    // Since we are going to use it, it's no longer available, so \n    // we need to remove the last element from our list \n    pool.pop_back(); \n\n    // Finally, return the reference \n    return object; \n  } \n  else \n  { \n    // If none are avaliable, create a new one \n return static_cast<GameObject*>(malloc(sizeof(GameObject))); \n  } \n} \n\n/*************************************************************************/ \n/*! \nTakes care of removing all of the objects from the pool whenever we're finished \nworking with it. \n*/ \n/*************************************************************************/ \nvoid ObjectPool::ClearPool() \n{ \n  while (!pool.empty()) \n  { \n    GameObject * object = pool.back(); \n    pool.pop_back(); \n free(object); \n  } \n}\n\n```", "```cpp\nposX = 0\nposY = 0\nvelX = 0\nvelY = 0\nscaleX = 2.5\nscaleY = 2.5\nrot = 0\nrotVel = 0\ncomponents = GfxComponent ColliderComponent OutsideViewKillComponent\n\n[GfxComponent]\ntexture = bullet.tga\ndrawSpace = world\ntexScaleX = 1\ntexScaleY = 1\ntexTransX = 0\ntexTransY = 0\n\n[ColliderComponent]\nradius = 1.25\n\n```", "```cpp\n/*************************************************************************/ \n/*! \n\\file   M5ObjectPool.h \n\\author John P. Doran \n\\par    email: john\\@johnpdoran.com \n\\par    Mach5 Game Engine \n\\date   2016/11/19 \n\nGlobally accessible static class for object caching to avoid creating new objects \nif we already have one not being used. \n\n*/ \n/*************************************************************************/ \n#ifndef M5OBJECT_POOL_H \n#define M5OBJECT_POOL_H \n\n#include <vector> \n#include <queue> \n\n#include \"EngineTest\\Source\\Core\\M5Object.h\" \n\ntemplate <M5ArcheTypes T> \nclass M5ObjectPool \n{ \npublic: \n  // Gives to us the first available object, creating a new one if none is available \n  static M5Object * AcquireObject(); \n\n  // Returns the object to the pool making it available for reuse \n  static void ReleaseObject(M5Object* object); \n\n  // Removes all of the objects in the pool and removes references\n  // as needed \n  static void ClearPool(); \n\nprivate: \n  // All of the objects in the object pool \n  static std::vector<M5Object*>  pool; \n\n  // All of the objects that are currently available \n  static std::deque<M5Object*> available; \n}; \n\n#endif //M5OBJECT_POOL_H\n\n```", "```cpp\n/*************************************************************************/ \n/*! \n\\file   M5ObjectPool.cpp \n\\author John P. Doran \n\\par    email: john\\@johnpdoran.com \n\\par    Mach5 Game Engine \n\\date   2016/11/19 \n\nGlobally accessible static class for object caching to avoid creating new objects \nif we already have one not being used. \n\n*/ \n/*************************************************************************/ \n#include \"M5ObjectPool.h\" \n#include \"Source\\Core\\M5ObjectManager.h\" \n\ntemplate class M5ObjectPool<AT_Bullet>;// explicit instantiation     \n\n/*************************************************************************/ \n/*! \nReturns the first available object if it exists. If not, it will create a new \none for us \n*/ \n/*************************************************************************/ \n\ntemplate <M5ArcheTypes T> \nM5Object * M5ObjectPool<T>::AcquireObject() \n{ \n  // Check if we have any available \n  if (!available.empty()) \n  { \n    // Get reference to an available object \n    M5Object * object = available.back(); \n\n    // Since we are going to use it, it's no longer available, \n    // so we need to remove the last element from our list \n    available.pop_back(); \n\n    // Finally, return the reference \n    return object; \n  } \n  else \n  { \n    M5Object * object = M5ObjectManager::CreateObject(T); \n\n    pool.push_back(object); \n\n    return object; \n  } \n}\n\n```", "```cpp\n/*************************************************************************/ \n/*! \nMarks an object as being available again \n\n\\param \nThe object to be made available again \n*/ \n/*************************************************************************/ \ntemplate <M5ArcheTypes T> \nvoid M5ObjectPool<T>::ReleaseObject(M5Object * object) \n{ \n  // If it's valid, move this object into our available list \n  if ((object->GetType() == T) && \n    (std::find(pool.begin(), pool.end(), object) != pool.end())) \n  { \n    //Make sure we haven't already been added already \n    if(std::find(available.begin(), available.end(), object) == available.end()) \n    { \n      available.push_back(object); \n    } \n  } \n\n}\n\n```", "```cpp\n/*************************************************************************/ \n/*! \nTakes care of removing all of the objects from the pool whenever we're finished working with it. \n*/ \n/*************************************************************************/ \ntemplate<M5ArcheTypes T> \nvoid M5ObjectPool<T>::ClearPool() \n{   \n  //  Go through each of our objects and destroy them \n  for (int i = pool.size() - 1; i >= 0; --i) \n  { \n    M5ObjectManager::DestroyObject(pool[i]); \n    pool.pop_back(); \n  } \n\n  // Now clear out the available queue \n  available.clear(); \n}\n\n```", "```cpp\ntemplate<M5ArcheTypes T> \nstd::vector<M5Object*>  M5ObjectPool<T>::pool; \n\ntemplate<M5ArcheTypes T> \nstd::deque<M5Object*>  M5ObjectPool<T>::available;\n\n```", "```cpp\n#ifndef BULLET_COMPONENT_H \n#define BULLET_COMPONENT_H \n\n#include \"Core\\M5Component.h\" \n\n//!< Removes The parent Game Object if it is outside the view port \nclass BulletComponent : public M5Component \n{ \npublic: \n  BulletComponent(); \n  virtual void Update(float dt); \n  virtual M5Component* Clone(void); \n}; \n\n#endif // !BULLET_COMPONENT_H\n\n```", "```cpp\n#include \"BulletComponent.h\" \n#include \"Core\\M5Gfx.h\" \n#include \"Core\\M5Math.h\" \n#include \"Core\\M5Object.h\"   \n#include \"EngineTest\\M5ObjectPool.h\" \n\nBulletComponent::BulletComponent(): \nM5Component(CT_BulletComponent) \n{ \n} \n\nvoid BulletComponent::Update(float /*dt*/) \n{ \n  M5Vec2 pos = m_pObj->pos; \n  M5Vec2 scale = m_pObj->scale; \n  scale *= .5f; \n  M5Vec2 botLeft; \n  M5Vec2 topRight; \n  M5Gfx::GetWorldBotLeft(botLeft); \n  M5Gfx::GetWorldTopRight(topRight); \n\n  if (pos.x + scale.x > topRight.x || pos.x - \n     scale.x < botLeft.x || \n    pos.y + scale.y > topRight.y || pos.y - scale.y < botLeft.y) \n  { \n    M5ObjectPool<AT_Bullet>::ReleaseObject(m_pObj); \n  } \n\n} \n\nM5Component * BulletComponent::Clone(void) \n{ \n  BulletComponent * pNew = new BulletComponent; \n  pNew->m_pObj = m_pObj; \n  return pNew; \n}\n\n```", "```cpp\n//then check for bullets \n if (M5Input::IsTriggered(M5_SPACE) || M5Input::IsTriggered(M5_GAMEPAD_A))\n {\n\n M5Object* bullet1 = M5ObjectPool<AT_Bullet>::AcquireObject();\n M5Object* bullet2 = M5ObjectPool<AT_Bullet>::AcquireObject();\n bullet2->rotation = bullet1->rotation = m_pObj->rotation;\n\n M5Vec2 bulletDir(std::cos(bullet1->rotation), std::sin(bullet1->rotation));\n M5Vec2 perp(bulletDir.y, -bulletDir.x);\n bullet1->pos = m_pObj->pos + perp * .5f * m_pObj->scale.y;\n bullet2->pos = m_pObj->pos - perp * .5f * m_pObj->scale.y;\n\n M5Vec2::Scale(bulletDir, bulletDir, m_bulletSpeed * dt);\n\n bullet1->vel = m_pObj->vel + bulletDir;\n bullet2->vel = m_pObj->vel + bulletDir;\n\n }\n\n```", "```cpp\nvoid BulletComponent::Update(float /*dt*/) \n{ \n  M5Vec2 pos = m_pObj->pos; \n  M5Vec2 scale = m_pObj->scale; \n  scale *= .5f; \n  M5Vec2 botLeft; \n  M5Vec2 topRight; \n  M5Gfx::GetWorldBotLeft(botLeft); \n  M5Gfx::GetWorldTopRight(topRight); \n\n  if (pos.x + scale.x > topRight.x || pos.x - scale.x < botLeft.x || \n    pos.y + scale.y > topRight.y || pos.y - scale.y < botLeft.y) \n  { \n\n m_pObj->scale = M5Vec2(1.5f, 1.5f); \n    M5ObjectPool<AT_Bullet>::ReleaseObject(m_pObj); \n  } \n\n}\n\n```"]