<html><head></head><body>
		<div id="_idContainer044">
			<h1 id="_idParaDest-292"><em class="italic"><a id="_idTextAnchor291"/>Chapter 9</em>: Concurrency and Parallelism</h1>
			<p>Concurrency and parallelism refer to the ability to run code in separate <em class="italic">threads of execution</em>.</p>
			<p>More specifically, <em class="italic">concurrency</em> is the ability to run threads<a id="_idIndexMarker787"/> in the background, and <em class="italic">parallelism</em> is the ability to run threads<a id="_idIndexMarker788"/> simultaneously in separate cores of a processor. The run-time library, along with the host operating system, will choose between concurrent and parallel execution models for a given thread on a given hardware environment.</p>
			<p>In a modern multi-tasking operating system, the <strong class="source-inline">main()</strong> function already represents a thread of execution. When a new thread is started, it's said to be <em class="italic">spawned</em> by an existing thread. A group<a id="_idIndexMarker789"/> of threads may be called a <em class="italic">swarm</em>.</p>
			<p>In the C++ standard library, the <strong class="source-inline">std::thread</strong> class provides the basic unit of threaded execution. Other classes build upon <strong class="source-inline">thread</strong> to provide <em class="italic">locks</em>, <em class="italic">mutexes</em>, and other concurrency patterns. Depending on system architecture, execution threads may run concurrently on one processor, or in parallel on separate cores.</p>
			<p>In this chapter, we will cover these tools and more in the following recipes:</p>
			<ul>
				<li>Sleep for a specific amount of time</li>
				<li>Use <strong class="source-inline">std::thread</strong> for concurrency</li>
				<li>Use <strong class="source-inline">std::async</strong> for concurrency</li>
				<li>Run STL algorithms in parallel with execution policies</li>
				<li>Share data safely with mutex and locks</li>
				<li>Share flags and values with <strong class="source-inline">std::atomic</strong></li>
				<li>Initialize threads with <strong class="source-inline">std::call_once</strong></li>
				<li>Use <strong class="source-inline">std::condition_variable</strong> to resolve the producer-consumer problem</li>
				<li>Implement multiple producers and consumers</li>
			</ul>
			<h1 id="_idParaDest-293"><a id="_idTextAnchor292"/>Technical requirements</h1>
			<p>You can find the code files for this chapter on GitHub at <a href="https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap09">https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap09</a>.</p>
			<h1 id="_idParaDest-294"><a id="_idTextAnchor293"/>Sleep for a specific amount of time</h1>
			<p>The <strong class="source-inline">&lt;thread&gt;</strong> header provides two functions for putting a thread to sleep, <strong class="source-inline">sleep_for()</strong> and <strong class="source-inline">sleep_until()</strong>. Both functions are in the <strong class="source-inline">std::this_thread</strong> namespace.</p>
			<p>This recipe explores<a id="_idIndexMarker790"/> the use of these functions, as we will be using<a id="_idIndexMarker791"/> them later in this chapter.</p>
			<h2 id="_idParaDest-295"><a id="_idTextAnchor294"/>How to do it…</h2>
			<p>Let's look at how to use the <strong class="source-inline">sleep_for()</strong> and <strong class="source-inline">sleep_until()</strong> functions:</p>
			<ul>
				<li>The sleep-related functions are in the <strong class="source-inline">std::this_thread</strong> namespace. Because it has just a few symbols, we'll go ahead and issue <strong class="source-inline">using</strong> directives for <strong class="source-inline">std::this_thread</strong> and <strong class="source-inline">std::chrono_literals</strong>:<p class="source-code">using namespace std::this_thread;</p><p class="source-code">using namespace std::chrono_literals;</p></li>
			</ul>
			<p>The <strong class="source-inline">chrono_literals</strong> namespace has symbols for representing durations, such as <strong class="source-inline">1s</strong> for one second, or <strong class="source-inline">100ms</strong> for 100 milliseconds.</p>
			<ul>
				<li>In <strong class="source-inline">main()</strong>, we'll mark a point in time with <strong class="source-inline">steady_clock::now()</strong>, so we can time our test:<p class="source-code">int main() {</p><p class="source-code">    auto t1 = <strong class="bold">steady_clock::now()</strong>;</p><p class="source-code">    cout &lt;&lt; "sleep for 1.3 seconds\n";</p><p class="source-code">    <strong class="bold">sleep_for(1s + 300ms);</strong></p><p class="source-code">    cout &lt;&lt; "sleep for 2 seconds\n";</p><p class="source-code">    <strong class="bold">sleep_until(steady_clock::now() + 2s);</strong></p><p class="source-code">    duration&lt;double&gt; dur1 = <strong class="bold">steady_clock::now() - t1</strong>;</p><p class="source-code">    cout &lt;&lt; format("total duration: {:.5}s\n", </p><p class="source-code">      dur1.count());</p><p class="source-code">}</p></li>
			</ul>
			<p>The <strong class="source-inline">sleep_for()</strong> function<a id="_idIndexMarker792"/> takes a <strong class="source-inline">duration</strong> object to specify<a id="_idIndexMarker793"/> the amount of time to sleep. The argument <strong class="source-inline">(1s + 300ms)</strong> uses <strong class="source-inline">chrono_literal</strong> operators to return a <strong class="source-inline">duration</strong> object representing 1.3 seconds.</p>
			<p>The <strong class="source-inline">sleep_until()</strong> function takes a <strong class="source-inline">time_point</strong> object to specify a specific time to resume from sleep. In this case, the <strong class="source-inline">chrono_literal</strong> operators are used to modify the <strong class="source-inline">time_point</strong> object returned from <strong class="source-inline">steady_clock::now()</strong>.</p>
			<p>This is our output:</p>
			<p class="source-code"><strong class="bold">sleep for 1.3 seconds</strong></p>
			<p class="source-code"><strong class="bold">sleep for 2 seconds</strong></p>
			<p class="source-code"><strong class="bold">total duration: 3.3005s</strong></p>
			<h2 id="_idParaDest-296"><a id="_idTextAnchor295"/>How it works…</h2>
			<p>The <strong class="source-inline">sleep_for(duration)</strong> and <strong class="source-inline">sleep_until(time_point)</strong> functions suspend execution of the current thread for the specified <strong class="source-inline">duration</strong>, or until the <strong class="source-inline">time_point</strong> is reached.</p>
			<p>The <strong class="source-inline">sleep_for()</strong> function will use the <strong class="source-inline">steady_clock</strong> implementation, if supported. Otherwise, the duration may be subject to time adjustments. Both functions may block for longer due to scheduling or resource delays.</p>
			<h2 id="_idParaDest-297"><a id="_idTextAnchor296"/>There's more…</h2>
			<p>Some systems support<a id="_idIndexMarker794"/> a POSIX function, <strong class="source-inline">sleep()</strong>, which suspends execution for the number of seconds specified:</p>
			<p class="source-code">unsigned int sleep(unsigned int seconds);</p>
			<p>The <strong class="source-inline">sleep()</strong> function is part of the POSIX standard and is not part of the C++ standard.</p>
			<h1 id="_idParaDest-298"><a id="_idTextAnchor297"/>Use std::thread for concurrency</h1>
			<p>A <em class="italic">thread</em> is a unit of<a id="_idIndexMarker795"/> concurrency. The <strong class="source-inline">main()</strong> function may be thought of as the <em class="italic">main thread of execution</em>. Within the context<a id="_idIndexMarker796"/> of the operating<a id="_idIndexMarker797"/> system, the main thread runs concurrently with other threads owned by other processes.</p>
			<p>The <strong class="source-inline">std::thread</strong> class is the root of concurrency in the STL. All other concurrency features are built on the foundation of the <strong class="source-inline">thread</strong> class.</p>
			<p>In this recipe, we will examine the basics of <strong class="source-inline">std::thread</strong> and how <strong class="source-inline">join()</strong> and <strong class="source-inline">detach()</strong> determine its execution context.</p>
			<h2 id="_idParaDest-299"><a id="_idTextAnchor298"/>How to do it…</h2>
			<p>In this recipe, we create some <strong class="source-inline">std::thread</strong> objects and experiment with their execution options.</p>
			<ul>
				<li>We start with a convenience function for sleeping a thread, in milliseconds:<p class="source-code">void <strong class="bold">sleepms</strong>(const unsigned <strong class="bold">ms</strong>) {</p><p class="source-code">    using std::chrono::milliseconds;</p><p class="source-code">    std::this_thread::<strong class="bold">sleep_for</strong>(milliseconds(<strong class="bold">ms</strong>));</p><p class="source-code">}</p></li>
			</ul>
			<p>The <strong class="source-inline">sleep_for()</strong> function takes a <strong class="source-inline">duration</strong> object and blocks execution of the current thread for the specified duration. This <strong class="source-inline">sleepms()</strong> function serves as a convenience wrapper that takes an <strong class="source-inline">unsigned</strong> value for the number of milliseconds to sleep.</p>
			<ul>
				<li>Now, we need a function<a id="_idIndexMarker798"/> for our thread. This function sleeps<a id="_idIndexMarker799"/> for a variable number of milliseconds, based on an integer parameter:<p class="source-code">void <strong class="bold">fthread</strong>(const int <strong class="bold">n</strong>) {</p><p class="source-code">    cout &lt;&lt; format("This is t{}\n", n);</p><p class="source-code">    </p><p class="source-code">    for(size_t i{}; i &lt; 5; ++i) {</p><p class="source-code">        <strong class="bold">sleepms</strong>(100 * <strong class="bold">n</strong>);</p><p class="source-code">        cout &lt;&lt; format("t{}: {}\n", n, i + 1);</p><p class="source-code">    }</p><p class="source-code">    cout &lt;&lt; format("Finishing t{}\n", n);</p><p class="source-code">}</p></li>
			</ul>
			<p><strong class="source-inline">fthread()</strong> calls <strong class="source-inline">sleepms()</strong> five times, sleeping each time for <strong class="source-inline">100 * n</strong> milliseconds.</p>
			<ul>
				<li>We can run this in a separate thread with <strong class="source-inline">std::thread</strong> from <strong class="source-inline">main()</strong>:<p class="source-code">int main() {</p><p class="source-code">    <strong class="bold">thread</strong> t1(<strong class="bold">fthread</strong>, 1);</p><p class="source-code">    cout &lt;&lt; "end of main()\n";</p><p class="source-code">}</p></li>
			</ul>
			<p>It compiles but we get this error when we run it:</p>
			<p class="source-code"><strong class="bold">terminate called without an active exception</strong></p>
			<p class="source-code"><strong class="bold">Aborted</strong></p>
			<p>(Your error message will vary. This is the error message on Debian with GCC.)</p>
			<p>The problem is that the operating system doesn't know what to do with the thread object when it goes out of scope. We must specify if the caller waits for the thread, or if it's detached and runs independently.</p>
			<ul>
				<li>We use the <strong class="source-inline">join()</strong> method to indicate<a id="_idIndexMarker800"/> that the caller will wait<a id="_idIndexMarker801"/> for the thread to finish:<p class="source-code">int main() {</p><p class="source-code">    thread t1(fthread, 1);</p><p class="source-code">    t1.<strong class="bold">join</strong>();</p><p class="source-code">    cout &lt;&lt; "end of main()\n";</p><p class="source-code">}</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">This is t1</strong></p>
			<p class="source-code"><strong class="bold">t1: 1</strong></p>
			<p class="source-code"><strong class="bold">t1: 2</strong></p>
			<p class="source-code"><strong class="bold">t1: 3</strong></p>
			<p class="source-code"><strong class="bold">t1: 4</strong></p>
			<p class="source-code"><strong class="bold">t1: 5</strong></p>
			<p class="source-code"><strong class="bold">Finishing t1</strong></p>
			<p class="source-code"><strong class="bold">end of main()</strong></p>
			<p>Now, <strong class="source-inline">main()</strong> waits for the thread to finish.</p>
			<ul>
				<li>If we call <strong class="source-inline">detach()</strong> instead of <strong class="source-inline">join()</strong>, then <strong class="source-inline">main()</strong> doesn't wait, and the program ends before the thread can run:<p class="source-code">thread t1(fthread, 1);</p><p class="source-code">t1.detach();</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">end of main()</strong></p>
			<ul>
				<li>When the thread<a id="_idIndexMarker802"/> is detached, we need to give it time<a id="_idIndexMarker803"/> to run:<p class="source-code">thread t1(fthread, 1);</p><p class="source-code">t1.<strong class="bold">detach</strong>();</p><p class="source-code">cout &lt;&lt; "main() sleep 2 sec\n";</p><p class="source-code"><strong class="bold">sleepms</strong>(2000);</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">main() sleep 2 sec</strong></p>
			<p class="source-code"><strong class="bold">This is t1</strong></p>
			<p class="source-code"><strong class="bold">t1: 1</strong></p>
			<p class="source-code"><strong class="bold">t1: 2</strong></p>
			<p class="source-code"><strong class="bold">t1: 3</strong></p>
			<p class="source-code"><strong class="bold">t1: 4</strong></p>
			<p class="source-code"><strong class="bold">t1: 5</strong></p>
			<p class="source-code"><strong class="bold">Finishing t1</strong></p>
			<p class="source-code"><strong class="bold">end of main()</strong></p>
			<ul>
				<li>Let's start and detach a second thread and see what happens:<p class="source-code">int main() {</p><p class="source-code">    thread t1(fthread, 1);</p><p class="source-code">    thread t2(fthread, 2);</p><p class="source-code">    t1.detach();</p><p class="source-code">    t2.detach();</p><p class="source-code">    cout &lt;&lt; "main() sleep 2 sec\n";</p><p class="source-code">    sleepms(2000);</p><p class="source-code">    cout &lt;&lt; "end of main()\n";</p><p class="source-code">}</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">main() sleep 2 sec</strong></p>
			<p class="source-code"><strong class="bold">This is t1</strong></p>
			<p class="source-code"><strong class="bold">This is t2</strong></p>
			<p class="source-code"><strong class="bold">t1: 1</strong></p>
			<p class="source-code"><strong class="bold">t2: 1</strong></p>
			<p class="source-code"><strong class="bold">t1: 2</strong></p>
			<p class="source-code"><strong class="bold">t1: 3</strong></p>
			<p class="source-code"><strong class="bold">t2: 2</strong></p>
			<p class="source-code"><strong class="bold">t1: 4</strong></p>
			<p class="source-code"><strong class="bold">t1: 5</strong></p>
			<p class="source-code"><strong class="bold">Finishing t1</strong></p>
			<p class="source-code"><strong class="bold">t2: 3</strong></p>
			<p class="source-code"><strong class="bold">t2: 4</strong></p>
			<p class="source-code"><strong class="bold">t2: 5</strong></p>
			<p class="source-code"><strong class="bold">Finishing t2</strong></p>
			<p class="source-code"><strong class="bold">end of main()</strong></p>
			<p>Because our <strong class="source-inline">fthread()</strong> function uses<a id="_idIndexMarker804"/> its parameter as a multiplier for <strong class="source-inline">sleepms()</strong>, the second thread<a id="_idIndexMarker805"/> runs a bit slower than the first. We can see the timers interlaced in the output.</p>
			<ul>
				<li>If we do this with <strong class="source-inline">join()</strong> instead of <strong class="source-inline">detatch()</strong>, we get a similar result:<p class="source-code">int main() {</p><p class="source-code">    thread t1(fthread, 1);</p><p class="source-code">    thread t2(fthread, 2);</p><p class="source-code">    t1.join();</p><p class="source-code">    t2.join();</p><p class="source-code">    cout &lt;&lt; "end of main()\n";</p><p class="source-code">}</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">This is t1</strong></p>
			<p class="source-code"><strong class="bold">This is t2</strong></p>
			<p class="source-code"><strong class="bold">t1: 1</strong></p>
			<p class="source-code"><strong class="bold">t2: 1</strong></p>
			<p class="source-code"><strong class="bold">t1: 2</strong></p>
			<p class="source-code"><strong class="bold">t1: 3</strong></p>
			<p class="source-code"><strong class="bold">t2: 2</strong></p>
			<p class="source-code"><strong class="bold">t1: 4</strong></p>
			<p class="source-code"><strong class="bold">t1: 5</strong></p>
			<p class="source-code"><strong class="bold">Finishing t1</strong></p>
			<p class="source-code"><strong class="bold">t2: 3</strong></p>
			<p class="source-code"><strong class="bold">t2: 4</strong></p>
			<p class="source-code"><strong class="bold">t2: 5</strong></p>
			<p class="source-code"><strong class="bold">Finishing t2</strong></p>
			<p class="source-code"><strong class="bold">end of main()</strong></p>
			<p>Because <strong class="source-inline">join()</strong> waits for the thread<a id="_idIndexMarker806"/> to finish, we no longer<a id="_idIndexMarker807"/> need the 2-second <strong class="source-inline">sleepms()</strong> in <strong class="source-inline">main()</strong> to wait for the threads to finish.</p>
			<h2 id="_idParaDest-300"><a id="_idTextAnchor299"/>How it works…</h2>
			<p>A <strong class="source-inline">std::thread</strong> object represents a thread of execution. There is a one-to-one relationship between object and thread. One <strong class="source-inline">thread</strong> object represents one thread, and one thread is represented by one <strong class="source-inline">thread</strong> object. A <strong class="source-inline">thread</strong> object cannot be copied or assigned, but it can be moved.</p>
			<p>The <strong class="source-inline">thread</strong> constructor looks like this:</p>
			<p class="source-code">explicit thread( Function&amp;&amp; f, Args&amp;&amp;… args );</p>
			<p>A thread is constructed with a function pointer and zero or more arguments. The function is called immediately with the arguments provided:</p>
			<p class="source-code">thread t1(fthread, 1);</p>
			<p>This creates the object <strong class="source-inline">t1</strong> and immediately calls the function <strong class="source-inline">fthread(int)</strong> with the literal value <strong class="source-inline">1</strong> as the argument.</p>
			<p>After creating the thread, we must use either <strong class="source-inline">join()</strong> or <strong class="source-inline">detach()</strong> on the thread:</p>
			<p class="source-code">t1.join();</p>
			<p>The <strong class="source-inline">join()</strong> method blocks execution of the calling thread until the <strong class="source-inline">t1</strong> thread has completed:</p>
			<p class="source-code">t1.detach();</p>
			<p>The <strong class="source-inline">detach()</strong> method allows the calling thread to continue independently of the <strong class="source-inline">t1</strong> thread.</p>
			<h2 id="_idParaDest-301"><a id="_idTextAnchor300"/>There's more…</h2>
			<p>C++20 provides <strong class="source-inline">std::jthread</strong>, which automatically joins<a id="_idIndexMarker808"/> the caller at the end of its scope:</p>
			<p class="source-code">int main() {</p>
			<p class="source-code">    std::jthread t1(fthread, 1);</p>
			<p class="source-code">    cout "&lt; "end of main("\n";</p>
			<p class="source-code">}</p>
			<p>Output:</p>
			<p class="source-code">end of main()</p>
			<p class="source-code">This is t1</p>
			<p class="source-code">t1: 1</p>
			<p class="source-code">t1: 2</p>
			<p class="source-code">t1: 3</p>
			<p class="source-code">t1: 4</p>
			<p class="source-code">t1: 5</p>
			<p class="source-code">Finishing t1</p>
			<p>This allows the <strong class="source-inline">t1</strong> thread to execute<a id="_idIndexMarker809"/> independently and then automatically join the <strong class="source-inline">main()</strong> thread at the end of its scope.</p>
			<h1 id="_idParaDest-302"><a id="_idTextAnchor301"/>Use std::async for concurrency</h1>
			<p><strong class="source-inline">std::async()</strong> runs a target function<a id="_idIndexMarker810"/> asynchronously and returns a <strong class="source-inline">std::future</strong> object to carry<a id="_idIndexMarker811"/> the target function's return value. In this way, <strong class="source-inline">async()</strong> operates much like <strong class="source-inline">std::thread</strong> but allows return values.</p>
			<p>Let's consider the use of <strong class="source-inline">std::async()</strong> with a few examples.</p>
			<h2 id="_idParaDest-303"><a id="_idTextAnchor302"/>How to do it…</h2>
			<p>In its simplest forms, the <strong class="source-inline">std::async()</strong> function performs much the same task as <strong class="source-inline">std::thread</strong>, without the need to call <strong class="source-inline">join()</strong> or <strong class="source-inline">detach()</strong> and while also allowing return values via a <strong class="source-inline">std::future</strong> object. </p>
			<p>In this recipe, we'll use a function that counts the number of primes in a range. We'll use <strong class="source-inline">chrono::steady_clock</strong> to time the execution of each thread.</p>
			<ul>
				<li>We'll start with a couple of convenience aliases:<p class="source-code">using launch = std::launch;</p><p class="source-code">using secs = std::chrono::duration&lt;double&gt;;</p></li>
			</ul>
			<p><strong class="source-inline">std::launch</strong> has launch policy constants, for use with the <strong class="source-inline">async()</strong> call. The <strong class="source-inline">secs</strong> alias is a <strong class="source-inline">duration</strong> class, for timing our prime number calculations.</p>
			<ul>
				<li>Our target function <a id="_idIndexMarker812"/>counts prime numbers in a range. This is essentially<a id="_idIndexMarker813"/> a way to understand the execution policies by eating some clock cycles:<p class="source-code">struct <strong class="bold">prime_time</strong> {</p><p class="source-code">    secs dur{};</p><p class="source-code">    uint64_t count{};</p><p class="source-code">};</p><p class="source-code"><strong class="bold">prime_time</strong> count_primes(const uint64_t&amp; max) {</p><p class="source-code">    <strong class="bold">prime_time</strong> <strong class="bold">ret</strong>{};</p><p class="source-code">    constexpr auto <strong class="bold">isprime</strong> = [](const uint64_t&amp; n) {</p><p class="source-code">        for(uint64_t i{ 2 }; i &lt; n / 2; ++i) {</p><p class="source-code">            if(n % i == 0) return false;</p><p class="source-code">        }</p><p class="source-code">        return true;</p><p class="source-code">    };</p><p class="source-code">    uint64_t start{ 2 };</p><p class="source-code">    uint64_t end{ max };</p><p class="source-code">    auto t1 = <strong class="bold">steady_clock::now()</strong>;</p><p class="source-code">    for(uint64_t i{ start }; i &lt;= end ; ++i) {</p><p class="source-code">        if(isprime(i)) <strong class="bold">++ret.count</strong>;</p><p class="source-code">    }</p><p class="source-code">    <strong class="bold">ret.dur</strong> = <strong class="bold">steady_clock::now() - t1</strong>;</p><p class="source-code">    return <strong class="bold">ret</strong>;</p><p class="source-code">}</p></li>
			</ul>
			<p>The <strong class="source-inline">prime_time</strong> structure is for the return<a id="_idIndexMarker814"/> value, with elements for duration and count. This allows<a id="_idIndexMarker815"/> us to time the loop itself. The <strong class="source-inline">isprime</strong> lambda returns <strong class="source-inline">true</strong> if a value is prime. We use <strong class="source-inline">steady_clock</strong> to calculate the duration of the loop that counts primes.</p>
			<ul>
				<li>In <strong class="source-inline">main()</strong>, we call our function and report its timing:<p class="source-code">int main() {</p><p class="source-code">    constexpr uint64_t MAX_PRIME{ 0x1FFFF };</p><p class="source-code">    auto pt = <strong class="bold">count_primes(MAX_PRIME)</strong>;</p><p class="source-code">    cout &lt;&lt; format("primes: {} {:.3}\n", <strong class="bold">pt.count</strong>, </p><p class="source-code">      <strong class="bold">pt.dur</strong>);</p><p class="source-code">}</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">primes: 12252 1.88008s</strong></p>
			<ul>
				<li>Now, we can run <strong class="source-inline">count_primes()</strong> asynchronously with <strong class="source-inline">std::async()</strong>:<p class="source-code">int main() {</p><p class="source-code">    constexpr uint64_t MAX_PRIME{ 0x1FFFF };</p><p class="source-code">    <strong class="bold">auto primes1</strong> = <strong class="bold">async</strong>(count_primes, MAX_PRIME);</p><p class="source-code">    auto <strong class="bold">pt</strong> = <strong class="bold">primes1.get()</strong>;</p><p class="source-code">    cout &lt;&lt; format("primes: {} {:.3}\n", <strong class="bold">pt.count</strong>, </p><p class="source-code">      <strong class="bold">pt.dur</strong>);</p><p class="source-code">}</p></li>
			</ul>
			<p>Here, we call <strong class="source-inline">async()</strong> with our <strong class="source-inline">count_primes</strong> function and the <strong class="source-inline">MAX_PRIME</strong> parameter. This runs <strong class="source-inline">count_primes()</strong> in the background.</p>
			<p><strong class="source-inline">async()</strong> returns a <strong class="source-inline">std::future</strong> object, which carries the return value of an asynchronous operation. The <strong class="source-inline">future</strong> object's <strong class="source-inline">get()</strong> method blocks until the asynchronous function<a id="_idIndexMarker816"/> has completed and then returns the return<a id="_idIndexMarker817"/> object from the function.</p>
			<p>This runs with almost the same timing as we got without <strong class="source-inline">async()</strong>:</p>
			<p class="source-code"><strong class="bold">primes: 12252 1.97245s</strong></p>
			<ul>
				<li>The <strong class="source-inline">async()</strong> function optionally takes execution policy flags as its first parameter:<p class="source-code">auto primes1 = async(<strong class="bold">launch::async</strong>, count_primes, MAX_PRIME);</p></li>
			</ul>
			<p>The choices are <strong class="source-inline">async</strong> or <strong class="source-inline">deferred</strong>. These flags are in the <strong class="source-inline">std::launch</strong> namespace.</p>
			<p>The <strong class="source-inline">async</strong> flag enables asynchronous operation, and the <strong class="source-inline">deferred</strong> flag enables lazy evaluation. These flags are bitmapped and may be combined with the bitwise or <strong class="source-inline">|</strong> operator.</p>
			<p>The default is for both bits to be set, as if <strong class="source-inline">async | deferred</strong> was specified.</p>
			<ul>
				<li>We can run several instances of our function simultaneously with <strong class="source-inline">async()</strong>:<p class="source-code">int main() {</p><p class="source-code">    constexpr uint64_t MAX_PRIME{ 0x1FFFF };</p><p class="source-code">    <strong class="bold">list&lt;std::future&lt;prime_time&gt;&gt; swarm</strong>;</p><p class="source-code">    cout &lt;&lt; "start parallel primes\n";</p><p class="source-code">    auto t1{ <strong class="bold">steady_clock::now()</strong> };</p><p class="source-code">    for(size_t i{}; i &lt; 15; ++i) {</p><p class="source-code">        swarm.emplace_back(</p><p class="source-code">            <strong class="bold">async(launch::async, count_primes, </strong></p><p class="source-code"><strong class="bold">              MAX_PRIME)</strong></p><p class="source-code">        );</p><p class="source-code">    }</p><p class="source-code">    for(auto&amp; f : swarm) {</p><p class="source-code">        static size_t i{};</p><p class="source-code">        auto pt = <strong class="bold">f.get()</strong>;</p><p class="source-code">        cout &lt;&lt; format("primes({:02}): {} {:.5}\n",</p><p class="source-code">            ++i, pt.count, pt.dur);</p><p class="source-code">    }</p><p class="source-code">    secs dur_total{ <strong class="bold">steady_clock::now() - t1</strong> };</p><p class="source-code">    cout &lt;&lt; format("total duration: {:.5}s\n", </p><p class="source-code">        dur_total.count());</p><p class="source-code">}</p></li>
			</ul>
			<p>We know that <strong class="source-inline">async</strong> returns a <strong class="source-inline">future</strong> object. So, we can<a id="_idIndexMarker818"/> run 15 threads by storing the <strong class="source-inline">future</strong> objects<a id="_idIndexMarker819"/> in a container. Here's our output on a 6-core i7 running Windows:</p>
			<p class="source-code"><strong class="bold">start parallel primes</strong></p>
			<p class="source-code"><strong class="bold">primes(01): 12252 4.1696s</strong></p>
			<p class="source-code"><strong class="bold">primes(02): 12252 3.7754s</strong></p>
			<p class="source-code"><strong class="bold">primes(03): 12252 3.78089s</strong></p>
			<p class="source-code"><strong class="bold">primes(04): 12252 3.72149s</strong></p>
			<p class="source-code"><strong class="bold">primes(05): 12252 3.72006s</strong></p>
			<p class="source-code"><strong class="bold">primes(06): 12252 4.1306s</strong></p>
			<p class="source-code"><strong class="bold">primes(07): 12252 4.26015s</strong></p>
			<p class="source-code"><strong class="bold">primes(08): 12252 3.77283s</strong></p>
			<p class="source-code"><strong class="bold">primes(09): 12252 3.77176s</strong></p>
			<p class="source-code"><strong class="bold">primes(10): 12252 3.72038s</strong></p>
			<p class="source-code"><strong class="bold">primes(11): 12252 3.72416s</strong></p>
			<p class="source-code"><strong class="bold">primes(12): 12252 4.18738s</strong></p>
			<p class="source-code"><strong class="bold">primes(13): 12252 4.07128s</strong></p>
			<p class="source-code"><strong class="bold">primes(14): 12252 2.1967s</strong></p>
			<p class="source-code"><strong class="bold">primes(15): 12252 2.22414s</strong></p>
			<p class="source-code"><strong class="bold">total duration: 5.9461s</strong></p>
			<p>Even though the 6-core i7 is not able to run<a id="_idIndexMarker820"/> all the processes in separate<a id="_idIndexMarker821"/> cores, it still completes 15 instances in under 6 seconds.</p>
			<p>It looks like it finishes the first 13 threads in about 4 seconds, and then takes another 2 seconds to finish the last 2 threads. It appears to take advantage of Intel's Hyper-Threading technology that allows 2 threads to run in one core under some circumstances.</p>
			<p>When we run the same code on a 12-core Xeon, we get this result:</p>
			<p class="source-code"><strong class="bold">start parallel primes</strong></p>
			<p class="source-code"><strong class="bold">primes(01): 12252 0.96221s</strong></p>
			<p class="source-code"><strong class="bold">primes(02): 12252 0.97346s</strong></p>
			<p class="source-code"><strong class="bold">primes(03): 12252 0.92189s</strong></p>
			<p class="source-code"><strong class="bold">primes(04): 12252 0.97499s</strong></p>
			<p class="source-code"><strong class="bold">primes(05): 12252 0.98135s</strong></p>
			<p class="source-code"><strong class="bold">primes(06): 12252 0.93426s</strong></p>
			<p class="source-code"><strong class="bold">primes(07): 12252 0.90294s</strong></p>
			<p class="source-code"><strong class="bold">primes(08): 12252 0.96307s</strong></p>
			<p class="source-code"><strong class="bold">primes(09): 12252 0.95015s</strong></p>
			<p class="source-code"><strong class="bold">primes(10): 12252 0.94255s</strong></p>
			<p class="source-code"><strong class="bold">primes(11): 12252 0.94971s</strong></p>
			<p class="source-code"><strong class="bold">primes(12): 12252 0.95639s</strong></p>
			<p class="source-code"><strong class="bold">primes(13): 12252 0.95938s</strong></p>
			<p class="source-code"><strong class="bold">primes(14): 12252 0.92115s</strong></p>
			<p class="source-code"><strong class="bold">primes(15): 12252 0.94122s</strong></p>
			<p class="source-code"><strong class="bold">total duration: 0.98166s</strong></p>
			<p>The 12-core Xeon gets<a id="_idIndexMarker822"/> through all 15 processes in under<a id="_idIndexMarker823"/> a second.</p>
			<h2 id="_idParaDest-304"><a id="_idTextAnchor303"/>How it works…</h2>
			<p>The key to understanding <strong class="source-inline">std::async</strong> is in its use of <strong class="source-inline">std::promise</strong> and <strong class="source-inline">std::future</strong>.</p>
			<p>The <strong class="source-inline">promise</strong> class allows a <strong class="source-inline">thread</strong> to store an object that may later be retrieved asynchronously by a <strong class="source-inline">future</strong> object.</p>
			<p>For example, let's say we have a function like this:</p>
			<p class="source-code">void f() {</p>
			<p class="source-code">    cout &lt;&lt; "this is f()\n";</p>
			<p class="source-code">}</p>
			<p>We can run it with <strong class="source-inline">std::thread</strong>, like this:</p>
			<p class="source-code">int main() {</p>
			<p class="source-code">    std::thread t1(f);</p>
			<p class="source-code">    t1.join();</p>
			<p class="source-code">    cout &lt;&lt; "end of main()\n";</p>
			<p class="source-code">}</p>
			<p>That works fine for a simple<a id="_idIndexMarker824"/> function with no return value. When we want<a id="_idIndexMarker825"/> to return a value from <strong class="source-inline">f()</strong>, we can use <strong class="source-inline">promise</strong> and <strong class="source-inline">future</strong>.</p>
			<p>We set up the promise and future objects in the <strong class="source-inline">main()</strong> thread:</p>
			<p class="source-code">int main() {</p>
			<p class="source-code">    <strong class="bold">std::promise&lt;int&gt; value_promise</strong>;</p>
			<p class="source-code">    <strong class="bold">std::future&lt;int&gt; value_future</strong> = </p>
			<p class="source-code">      value_promise.<strong class="bold">get_future()</strong>;</p>
			<p class="source-code">    std::thread t1(f, <strong class="bold">std::move(value_promise)</strong>);</p>
			<p class="source-code">    t1.detach();</p>
			<p class="source-code">    cout &lt;&lt; format("value is {}\n", <strong class="bold">value_future.get()</strong>);</p>
			<p class="source-code">    cout &lt;&lt; "end of main()\n";</p>
			<p class="source-code">}</p>
			<p>And we pass the <strong class="source-inline">promise</strong> object to our function:</p>
			<p class="source-code">void f(<strong class="bold">std::promise&lt;int&gt; value</strong>) {</p>
			<p class="source-code">    cout &lt;&lt; "this is f()\n";</p>
			<p class="source-code">    <strong class="bold">value.set_value(47)</strong>;</p>
			<p class="source-code">}</p>
			<p>Note that a <strong class="source-inline">promise</strong> object cannot be copied, so we need to use <strong class="source-inline">std::move</strong> to pass it to the function.</p>
			<p>The <strong class="source-inline">promise</strong> object serves as a bridge to a <strong class="source-inline">future</strong> object, which allows us to retrieve the value when it becomes available.</p>
			<p><strong class="source-inline">std::async()</strong> is just a helper function to simplify the creation of the <strong class="source-inline">promise</strong> and <strong class="source-inline">future</strong> objects. With <strong class="source-inline">async()</strong>, we can do all of that like this:</p>
			<p class="source-code">int f() {</p>
			<p class="source-code">    cout &lt;&lt; "this is f()\n";</p>
			<p class="source-code">    return 47;</p>
			<p class="source-code">}</p>
			<p class="source-code">int main() {</p>
			<p class="source-code">    auto <strong class="bold">value_future = std::async(f)</strong>;</p>
			<p class="source-code">    cout &lt;&lt; format("value is {}\n", <strong class="bold">value_future.get()</strong>);</p>
			<p class="source-code">    cout &lt;&lt; "end of main()\n";</p>
			<p class="source-code">}</p>
			<p>That's the value<a id="_idIndexMarker826"/> of <strong class="source-inline">async()</strong>. For many purposes, it makes<a id="_idIndexMarker827"/> the use of <strong class="source-inline">promise</strong> and <strong class="source-inline">future</strong> much easier.</p>
			<h1 id="_idParaDest-305"><a id="_idTextAnchor304"/>Run STL algorithms in parallel with execution policies</h1>
			<p>Beginning with C++17, many of the standard STL algorithms can run with <em class="italic">parallel execution</em>. This feature allows an algorithm<a id="_idIndexMarker828"/> to split its work into sub-tasks to run<a id="_idIndexMarker829"/> simultaneously on multiple cores. These algorithms accept an execution policy object that specifies the kind of parallelism applied to the algorithm. This feature requires hardware support.</p>
			<h2 id="_idParaDest-306"><a id="_idTextAnchor305"/>How to do it…</h2>
			<p>Execution policies are defined in the <strong class="source-inline">&lt;execution&gt;</strong> header and in the <strong class="source-inline">std::execution</strong> namespace. In this recipe, we will test the available policies using the <strong class="source-inline">std::transform()</strong> algorithm:</p>
			<ul>
				<li>For timing purposes, we'll use the <strong class="source-inline">duration</strong> object with the <strong class="source-inline">std::milli</strong> ratio so that we can measure in milliseconds:<p class="source-code">using dur_t = duration&lt;double, std::milli&gt;;</p></li>
				<li>For demonstration<a id="_idIndexMarker830"/> purposes, we'll start<a id="_idIndexMarker831"/> with a <strong class="source-inline">vector</strong> of <strong class="source-inline">int</strong> with 10 million random values:<p class="source-code">int main() {</p><p class="source-code">    std::vector&lt;unsigned&gt; v(10 * 1000 * 1000);</p><p class="source-code">    std::random_device rng;</p><p class="source-code">    for(auto &amp;i : v) i = rng() % 0xFFFF;</p><p class="source-code">    ...</p></li>
				<li>Now, we apply a simple transformation:<p class="source-code">auto mul2 = [](int n){ return n * 2; };</p><p class="source-code">auto t1 = steady_clock::now();</p><p class="source-code">std::transform(v.begin(), v.end(), v.begin(), mul2);</p><p class="source-code">dur_t dur1 = steady_clock::now() - t1;</p><p class="source-code">cout &lt;&lt; format("no policy: {:.3}ms\n", dur1.count());</p></li>
			</ul>
			<p>The <strong class="source-inline">mul2</strong> lambda simply multiplies a value by 2. The <strong class="source-inline">transform()</strong> algorithm applies <strong class="source-inline">mul2</strong> to every member of the vector.</p>
			<p>This transformation does not specify an execution policy.</p>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">no policy: 4.71ms</strong></p>
			<ul>
				<li>We can specify an execution policy in the first argument of the algorithm:<p class="source-code">std::transform(<strong class="bold">execution::seq</strong>,</p><p class="source-code">    v.begin(), v.end(), v.begin(), mul2);</p></li>
			</ul>
			<p>The <strong class="source-inline">seq</strong> policy means that the algorithm shall not be parallelized. This is the same as no execution policy.</p>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">execution::seq: 4.91ms</strong></p>
			<p>Notice that the duration<a id="_idIndexMarker832"/> is roughly the same as without<a id="_idIndexMarker833"/> a policy. It will never be exact because it varies each time it's run.</p>
			<ul>
				<li>The <strong class="source-inline">execution::par</strong> policy allows the algorithm to parallelize its workload:<p class="source-code">std::transform(<strong class="bold">execution::par</strong>,</p><p class="source-code">    v.begin(), v.end(), v.begin(), mul2);</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">execution::par: 3.22ms</strong></p>
			<p>Notice that the algorithm runs somewhat faster with the parallel execution policy.</p>
			<ul>
				<li>The <strong class="source-inline">execution::par_unseq</strong> policy allows unsequenced parallel execution of the workload:<p class="source-code">std::transform(<strong class="bold">execution::par_unseq</strong>,</p><p class="source-code">    v.begin(), v.end(), v.begin(), mul2);</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">execution::par_unseq: 2.93ms</strong></p>
			<p>Here, we notice another increase in performance with this policy.</p>
			<p>The <strong class="source-inline">execution::par_unseq</strong> policy has tighter requirements of the algorithm. The algorithm must not perform operations that require concurrent or sequential operation.</p>
			<h2 id="_idParaDest-307"><a id="_idTextAnchor306"/>How it works…</h2>
			<p>The execution policies interface doesn't specify how the algorithm workloads are parallelized. It's designed<a id="_idIndexMarker834"/> to work with a diverse set of hardware<a id="_idIndexMarker835"/> and processors under varying loads and circumstances. It may be implemented entirely in the library or rely on compiler or hardware support.</p>
			<p>Parallelization will show the most improvement on algorithms that do more than <em class="italic">O(n)</em> work. For example, <strong class="source-inline">sort()</strong> shows a dramatic improvement. Here's a <strong class="source-inline">sort()</strong> with no parallelization:</p>
			<p class="source-code">auto t0 = steady_clock::now();</p>
			<p class="source-code">std::sort(v.begin(), v.end());</p>
			<p class="source-code">dur_t dur0 = steady_clock::now() - t0;</p>
			<p class="source-code">cout &lt;&lt; format("sort: {:.3}ms\n", dur0.count());</p>
			<p>Output:</p>
			<p class="source-code">sort: 751ms</p>
			<p>With <strong class="source-inline">execution::par</strong>, we see significant performance gains:</p>
			<p class="source-code">std::sort(<strong class="bold">execution::par</strong>, v.begin(), v.end());</p>
			<p>Output:</p>
			<p class="source-code">sort: 163ms</p>
			<p>The improvement with <strong class="source-inline">execution::par_unseq</strong> is better still:</p>
			<p class="source-code">std::sort(<strong class="bold">execution::par_unseq</strong>, v.begin(), v.end());</p>
			<p>Output:</p>
			<p class="source-code">sort: 152ms</p>
			<p>It's a good idea to do a lot of testing when using the parallelized algorithms. If your algorithm or predicates do not lend themselves well to parallelization, you may end up with minimal performance gains or unintended side effects.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">At the time of writing, execution policies are poorly supported in GCC and not yet supported by LLVM/Clang. This recipe was tested on a 6-core i7 running Windows 10 and a preview release of Visual C++.</p>
			<h1 id="_idParaDest-308"><a id="_idTextAnchor307"/>Share data safely with mutex and locks</h1>
			<p>The term <em class="italic">mutex</em> refers to <em class="italic">mutually exclusive</em> access to shared<a id="_idIndexMarker836"/> resources. A mutex<a id="_idIndexMarker837"/> is commonly used to avoid<a id="_idIndexMarker838"/> data corruption<a id="_idIndexMarker839"/> and race conditions, due to multiple threads<a id="_idIndexMarker840"/> of execution attempting to access<a id="_idIndexMarker841"/> the same data. A mutex will typically use <em class="italic">locks</em> to restrict access to one thread at a time.</p>
			<p>The STL provides <em class="italic">mutex</em> and <em class="italic">lock</em> classes in the <strong class="source-inline">&lt;mutex&gt;</strong> header.</p>
			<h2 id="_idParaDest-309"><a id="_idTextAnchor308"/>How to do it…</h2>
			<p>In this recipe, we will use a simple <strong class="source-inline">Animal</strong> class to experiment with <em class="italic">locking</em> and <em class="italic">unlocking</em> a <strong class="source-inline">mutex</strong>:</p>
			<ul>
				<li>We start by creating a <strong class="source-inline">mutex</strong> object:<p class="source-code">std::mutex animal_mutex;</p></li>
			</ul>
			<p>The <strong class="source-inline">mutex</strong> is declared in the global scope, so it's accessible to all the relevant objects.</p>
			<ul>
				<li>Our <strong class="source-inline">Animal</strong> class has a name and a list of friends:<p class="source-code">class Animal {</p><p class="source-code">    using friend_t = list&lt;Animal&gt;;</p><p class="source-code">    string_view s_name{ "unk" };</p><p class="source-code">    friend_t l_friends{};</p><p class="source-code">public:</p><p class="source-code">    Animal() = delete;</p><p class="source-code">    Animal(const string_view n) : s_name{n} {}</p><p class="source-code">    ...</p><p class="source-code">}</p></li>
			</ul>
			<p>Adding and deleting<a id="_idIndexMarker842"/> friends will<a id="_idIndexMarker843"/> be a useful<a id="_idIndexMarker844"/> test case<a id="_idIndexMarker845"/> for our <strong class="source-inline">mutex</strong>.</p>
			<ul>
				<li>The equality operator is the only operator we'll need:<p class="source-code">bool operator==(const Animal&amp; o) const {</p><p class="source-code">    return s_name.data() == o.s_name.data();</p><p class="source-code">}</p></li>
			</ul>
			<p>The <strong class="source-inline">s_name</strong> member is a <strong class="source-inline">string_view</strong> object, so we can test the address of its data store for equality.</p>
			<ul>
				<li>The <strong class="source-inline">is_friend()</strong> method tests if another <strong class="source-inline">Animal</strong> is in the <strong class="source-inline">l_friends</strong> list:<p class="source-code">bool is_friend(const Animal&amp; o) const {</p><p class="source-code">    for(const auto&amp; a : l_friends) {</p><p class="source-code">        if(a == o) return true;</p><p class="source-code">    }</p><p class="source-code">    return false;</p><p class="source-code">}</p></li>
				<li>The <strong class="source-inline">find_friend()</strong> method returns an <strong class="source-inline">optional</strong>, with an iterator to the <strong class="source-inline">Animal</strong> if found:<p class="source-code">optional&lt;friend_t::iterator&gt;</p><p class="source-code">find_friend(const Animal&amp; o) noexcept {</p><p class="source-code">    for(auto it{l_friends.begin()};</p><p class="source-code">            it != l_friends.end(); ++it) {</p><p class="source-code">        if(*it == o) return it;</p><p class="source-code">    }</p><p class="source-code">    return {};</p><p class="source-code">}</p></li>
				<li>The <strong class="source-inline">print()</strong> method<a id="_idIndexMarker846"/> prints <strong class="source-inline">s_name</strong> along<a id="_idIndexMarker847"/> with names<a id="_idIndexMarker848"/> of each of the <strong class="source-inline">Animal</strong> objects<a id="_idIndexMarker849"/> in the <strong class="source-inline">l_friends</strong> list:<p class="source-code">void print() const noexcept {</p><p class="source-code">    auto n_animals{ l_friends.size() };</p><p class="source-code">    cout &lt;&lt; format("Animal: {}, friends: ", s_name);</p><p class="source-code">    if(!n_animals) cout &lt;&lt; "none";</p><p class="source-code">    else {</p><p class="source-code">        for(auto n : l_friends) {</p><p class="source-code">            cout &lt;&lt; n.s_name;</p><p class="source-code">            if(--n_animals) cout &lt;&lt; ", ";</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">    cout &lt;&lt; '\n';</p><p class="source-code">}</p></li>
				<li>The <strong class="source-inline">add_friend()</strong> method adds an <strong class="source-inline">Animal</strong> object to the <strong class="source-inline">l_friends</strong> list:<p class="source-code">bool add_friend(Animal&amp; o) noexcept {</p><p class="source-code">    cout &lt;&lt; format("add_friend {} -&gt; {}\n", s_name, </p><p class="source-code">      o.s_name);</p><p class="source-code">    if(*this == o) return false;</p><p class="source-code">    std::lock_guard&lt;std::mutex&gt; l(animal_mutex);</p><p class="source-code">    if(!is_friend(o)) l_friends.emplace_back(o);</p><p class="source-code">    if(!o.is_friend(*this))</p><p class="source-code">      o.l_friends.emplace_back(*this);</p><p class="source-code">    return true;</p><p class="source-code">}</p></li>
				<li>The <strong class="source-inline">delete_friend()</strong> method<a id="_idIndexMarker850"/> removes<a id="_idIndexMarker851"/> an <strong class="source-inline">Animal</strong> object<a id="_idIndexMarker852"/> from<a id="_idIndexMarker853"/> the <strong class="source-inline">l_friends</strong> list:<p class="source-code">bool delete_friend(Animal&amp; o) noexcept {</p><p class="source-code">    cout &lt;&lt; format("delete_friend {} -&gt; {}\n",</p><p class="source-code">        s_name, o.s_name);</p><p class="source-code">    if(*this == o) return false;</p><p class="source-code">    if(auto it = find_friend(o)) </p><p class="source-code">      l_friends.erase(it.value());</p><p class="source-code">    if(auto it = o.find_friend(*this))</p><p class="source-code">        o.l_friends.erase(it.value());</p><p class="source-code">    return true;</p><p class="source-code">}</p></li>
				<li>In the <strong class="source-inline">main()</strong> function, we create some <strong class="source-inline">Animal</strong> objects:<p class="source-code">int main() {</p><p class="source-code">    auto cat1 = std::make_unique&lt;Animal&gt;("Felix");</p><p class="source-code">    auto tiger1 = std::make_unique&lt;Animal&gt;("Hobbes");</p><p class="source-code">    auto dog1 = std::make_unique&lt;Animal&gt;("Astro");</p><p class="source-code">    auto rabbit1 = std::make_unique&lt;Animal&gt;("Bugs");</p><p class="source-code">    ...</p></li>
				<li>We call <strong class="source-inline">add_friends()</strong> on our objects with <strong class="source-inline">async()</strong>, to run them in separate threads:<p class="source-code">auto a1 = std::async([&amp;]{ cat1-&gt;add_friend(*tiger1); });</p><p class="source-code">auto a2 = std::async([&amp;]{ cat1-&gt;add_friend(*rabbit1); });</p><p class="source-code">auto a3 = std::async([&amp;]{ rabbit1-&gt;add_friend(*dog1); });</p><p class="source-code">auto a4 = std::async([&amp;]{ rabbit1-&gt;add_friend(*cat1); });</p><p class="source-code">a1.wait();</p><p class="source-code">a2.wait();</p><p class="source-code">a3.wait();</p><p class="source-code">a4.wait();</p></li>
			</ul>
			<p>We call <strong class="source-inline">wait()</strong> to allow<a id="_idIndexMarker854"/> our threads<a id="_idIndexMarker855"/> to complete <a id="_idIndexMarker856"/>before<a id="_idIndexMarker857"/> continuing.</p>
			<ul>
				<li>We call <strong class="source-inline">print()</strong> to see our <strong class="source-inline">Animals</strong> and their relationships:<p class="source-code">auto p1 = std::async([&amp;]{ cat1-&gt;print(); });</p><p class="source-code">auto p2 = std::async([&amp;]{ tiger1-&gt;print(); });</p><p class="source-code">auto p3 = std::async([&amp;]{ dog1-&gt;print(); });</p><p class="source-code">auto p4 = std::async([&amp;]{ rabbit1-&gt;print(); });</p><p class="source-code">p1.wait();</p><p class="source-code">p2.wait();</p><p class="source-code">p3.wait();</p><p class="source-code">p4.wait();</p></li>
				<li>And finally, we call <strong class="source-inline">delete_friend()</strong> to remove one of our relationships:<p class="source-code">auto a5 = std::async([&amp;]{ cat1-&gt;delete_friend(*rabbit1); });</p><p class="source-code">a5.wait();</p><p class="source-code">auto p5 = std::async([&amp;]{ cat1-&gt;print(); });</p><p class="source-code">auto p6 = std::async([&amp;]{ rabbit1-&gt;print(); });</p></li>
				<li>At this<a id="_idIndexMarker858"/> point, our<a id="_idIndexMarker859"/> output<a id="_idIndexMarker860"/> looks like<a id="_idIndexMarker861"/> this:<p class="source-code">add_friend Bugs -&gt; Felix</p><p class="source-code">add_friend Felix -&gt; Hobbes</p><p class="source-code">add_friend Felix -&gt; Bugs</p><p class="source-code">add_friend Bugs -&gt; Astro</p><p class="source-code">Animal: Felix, friends: Bugs, Hobbes</p><p class="source-code">Animal: Hobbes, friends: Animal: Bugs, friends: FelixAnimal: Astro, friends: Felix</p><p class="source-code">, Astro</p><p class="source-code">Bugs</p><p class="source-code">delete_friend Felix -&gt; Bugs</p><p class="source-code">Animal: Felix, friends: Hobbes</p><p class="source-code">Animal: Bugs, friends: Astro</p></li>
			</ul>
			<p>This output is somewhat scrambled. It will be different each time you run it. It may be fine sometimes, but don't let that fool you. We need to add some mutex locks to control access to the data.</p>
			<ul>
				<li>One way to use <strong class="source-inline">mutex</strong> is with its <strong class="source-inline">lock()</strong> and <strong class="source-inline">unlock()</strong> methods. Let's add them to the <strong class="source-inline">add_friend()</strong> function:<p class="source-code">bool add_friend(Animal&amp; o) noexcept {</p><p class="source-code">    cout &lt;&lt; format("add_friend {} -&gt; {}\n", s_name, o.s_name);</p><p class="source-code">    if(*this == o) return false;</p><p class="source-code">    <strong class="bold">animal_mutex.lock()</strong>;</p><p class="source-code">    if(!is_friend(o)) l_friends.emplace_back(o);</p><p class="source-code">    if(!o.is_friend(*this)) o.l_friends.emplace_back(*this);</p><p class="source-code">    <strong class="bold">animal_mutex.unlock()</strong>;</p><p class="source-code">    return true;</p><p class="source-code">}</p></li>
			</ul>
			<p>The <strong class="source-inline">lock()</strong> method<a id="_idIndexMarker862"/> attempts<a id="_idIndexMarker863"/> to acquire a lock on the <strong class="source-inline">mutex</strong>. If the mutex<a id="_idIndexMarker864"/> is already locked, it will wait (block execution) until<a id="_idIndexMarker865"/> the <strong class="source-inline">mutex</strong> is unlocked.</p>
			<ul>
				<li>We also need to add a lock to <strong class="source-inline">delete_friend()</strong>:<p class="source-code">bool delete_friend(Animal&amp; o) noexcept {</p><p class="source-code">    cout &lt;&lt; format("delete_friend {} -&gt; {}\n",</p><p class="source-code">        s_name, o.s_name);</p><p class="source-code">    if(*this == o) return false;</p><p class="source-code">    <strong class="bold">animal_mutex.lock()</strong>;</p><p class="source-code">    if(auto it = find_friend(o)) </p><p class="source-code">      l_friends.erase(it.value());</p><p class="source-code">    if(auto it = o.find_friend(*this))</p><p class="source-code">        o.l_friends.erase(it.value());</p><p class="source-code">    <strong class="bold">animal_mutex.unlock()</strong>;</p><p class="source-code">    return true;</p><p class="source-code">}</p></li>
				<li>Now, we need<a id="_idIndexMarker866"/> to add a lock to <strong class="source-inline">print()</strong> so that<a id="_idIndexMarker867"/> data<a id="_idIndexMarker868"/> is not changed<a id="_idIndexMarker869"/> while printing:<p class="source-code">void print() const noexcept {</p><p class="source-code">    <strong class="bold">animal_mutex.lock()</strong>;</p><p class="source-code">    auto n_animals{ l_friends.size() };</p><p class="source-code">    cout &lt;&lt; format("Animal: {}, friends: ", s_name);</p><p class="source-code">    if(!n_animals) cout &lt;&lt; "none";</p><p class="source-code">    else {</p><p class="source-code">        for(auto n : l_friends) {</p><p class="source-code">            cout &lt;&lt; n.s_name;</p><p class="source-code">            if(--n_animals) cout &lt;&lt; ", ";</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">    cout &lt;&lt; '\n';</p><p class="source-code">    <strong class="bold">animal_mutex.unlock()</strong>;</p><p class="source-code">}</p></li>
			</ul>
			<p>Now, our output is sensible:</p>
			<p class="source-code"><strong class="bold">add_friend Bugs -&gt; Felix</strong></p>
			<p class="source-code"><strong class="bold">add_friend Bugs -&gt; Astro</strong></p>
			<p class="source-code"><strong class="bold">add_friend Felix -&gt; Hobbes</strong></p>
			<p class="source-code"><strong class="bold">add_friend Felix -&gt; Bugs</strong></p>
			<p class="source-code"><strong class="bold">Animal: Felix, friends: Bugs, Hobbes</strong></p>
			<p class="source-code"><strong class="bold">Animal: Hobbes, friends: Felix</strong></p>
			<p class="source-code"><strong class="bold">Animal: Astro, friends: Bugs</strong></p>
			<p class="source-code"><strong class="bold">Animal: Bugs, friends: Felix, Astro</strong></p>
			<p class="source-code"><strong class="bold">delete_friend Felix -&gt; Bugs</strong></p>
			<p class="source-code"><strong class="bold">Animal: Felix, friends: Hobbes</strong></p>
			<p class="source-code"><strong class="bold">Animal: Bugs, friends: Astro</strong></p>
			<p>Your output<a id="_idIndexMarker870"/> may have the lines <a id="_idIndexMarker871"/>in a different order<a id="_idIndexMarker872"/> due to asynchronous<a id="_idIndexMarker873"/> operation.</p>
			<ul>
				<li>The <strong class="source-inline">lock()</strong> and <strong class="source-inline">unlock()</strong> methods are rarely called directly. The <strong class="source-inline">std::lock_guard</strong> class manages<a id="_idIndexMarker874"/> locks with a proper <strong class="bold">Resource Acquisition Is Initialization</strong> (<strong class="bold">RAII</strong>) pattern that automatically releases the lock upon destruction. Here's the <strong class="source-inline">add_friend()</strong> method with <strong class="source-inline">lock_guard</strong>:<p class="source-code">bool add_friend(Animal&amp; o) noexcept {</p><p class="source-code">    cout &lt;&lt; format("add_friend {} -&gt; {}\n", s_name, o.s_name);</p><p class="source-code">    if(*this == o) return false;</p><p class="source-code">    <strong class="bold">std::lock_guard&lt;std::mutex&gt; l(animal_mutex)</strong>;</p><p class="source-code">    if(!is_friend(o)) l_friends.emplace_back(o);</p><p class="source-code">    if(!o.is_friend(*this)) </p><p class="source-code">      o.l_friends.emplace_back(*this);</p><p class="source-code">    return true;</p><p class="source-code">}</p></li>
			</ul>
			<p>The <strong class="source-inline">lock_guard</strong> object is created and holds a lock until it is destroyed. Like the <strong class="source-inline">lock()</strong> method, <strong class="source-inline">lock_guard</strong> also blocks until a lock is available.</p>
			<ul>
				<li>Let's<a id="_idIndexMarker875"/> apply <strong class="source-inline">lock_guard</strong> to<a id="_idIndexMarker876"/> the <strong class="source-inline">delete_friend()</strong> and <strong class="source-inline">print()</strong> methods.</li>
			</ul>
			<p>Here is <strong class="source-inline">delete_friend()</strong>:</p>
			<p class="source-code">bool delete_friend(Animal&amp; o) noexcept {</p>
			<p class="source-code">    cout &lt;&lt; format("delete_friend {} -&gt; {}\n",</p>
			<p class="source-code">        s_name, o.s_name);</p>
			<p class="source-code">    if(*this == o) return false;</p>
			<p class="source-code">    <strong class="bold">std::lock_guard&lt;std::mutex&gt; l(animal_mutex)</strong>;</p>
			<p class="source-code">    if(auto it = find_friend(o)) </p>
			<p class="source-code">      l_friends.erase(it.value());</p>
			<p class="source-code">    if(auto it = o.find_friend(*this))</p>
			<p class="source-code">        o.l_friends.erase(it.value());</p>
			<p class="source-code">    return true;</p>
			<p class="source-code">}</p>
			<p>And<a id="_idIndexMarker877"/> here<a id="_idIndexMarker878"/> is <strong class="source-inline">print()</strong>:</p>
			<p class="source-code">void print() const noexcept {</p>
			<p class="source-code">    <strong class="bold">std::lock_guard&lt;std::mutex&gt; l(animal_mutex)</strong>;</p>
			<p class="source-code">    auto n_animals{ l_friends.size() };</p>
			<p class="source-code">    cout &lt;&lt; format("Animal: {}, friends: ", s_name);</p>
			<p class="source-code">    if(!n_animals) cout &lt;&lt; "none";</p>
			<p class="source-code">    else {</p>
			<p class="source-code">        for(auto n : l_friends) {</p>
			<p class="source-code">            cout &lt;&lt; n.s_name;</p>
			<p class="source-code">            if(--n_animals) cout &lt;&lt; ", ";</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    cout &lt;&lt; '\n';</p>
			<p class="source-code">}</p>
			<p>Our output remains coherent:</p>
			<p class="source-code"><strong class="bold">add_friend Felix -&gt; Hobbes</strong></p>
			<p class="source-code"><strong class="bold">add_friend Bugs -&gt; Astro</strong></p>
			<p class="source-code"><strong class="bold">add_friend Felix -&gt; Bugs</strong></p>
			<p class="source-code"><strong class="bold">add_friend Bugs -&gt; Felix</strong></p>
			<p class="source-code"><strong class="bold">Animal: Felix, friends: Bugs, Hobbes</strong></p>
			<p class="source-code"><strong class="bold">Animal: Astro, friends: Bugs</strong></p>
			<p class="source-code"><strong class="bold">Animal: Hobbes, friends: Felix</strong></p>
			<p class="source-code"><strong class="bold">Animal: Bugs, friends: Astro, Felix</strong></p>
			<p class="source-code"><strong class="bold">delete_friend Felix -&gt; Bugs</strong></p>
			<p class="source-code"><strong class="bold">Animal: Felix, friends: Hobbes</strong></p>
			<p class="source-code"><strong class="bold">Animal: Bugs, friends: Astro</strong></p>
			<p>As before, your<a id="_idIndexMarker879"/> output may have<a id="_idIndexMarker880"/> the lines in a different<a id="_idIndexMarker881"/> order due to asynchronous<a id="_idIndexMarker882"/> operation.</p>
			<h2 id="_idParaDest-310"><a id="_idTextAnchor309"/>How it works…</h2>
			<p>It's important to understand<a id="_idIndexMarker883"/> that a <strong class="source-inline">mutex</strong> does not lock data; it blocks execution. As shown<a id="_idIndexMarker884"/> in this recipe, when a <strong class="source-inline">mutex</strong> is applied in object<a id="_idIndexMarker885"/> methods, it can be used to enforce mutually exclusive<a id="_idIndexMarker886"/> access to data.</p>
			<p>When one thread locks a <strong class="source-inline">mutex</strong>, with either <strong class="source-inline">lock()</strong> or <strong class="source-inline">lock_guard</strong>, that thread is said to <em class="italic">own</em> the <strong class="source-inline">mutex</strong>. Any other thread that tries to lock the same <strong class="source-inline">mutex</strong> will be blocked until it's unlocked by the owner.</p>
			<p>The <strong class="source-inline">mutex</strong> object must not be destroyed while it's owned by any thread. Likewise, a thread must not be destroyed while it owns a <strong class="source-inline">mutex</strong>. An RAII-compliant wrapper, such as <strong class="source-inline">lock_guard</strong>, will help ensure this doesn't happen.</p>
			<h2 id="_idParaDest-311"><a id="_idTextAnchor310"/>There's more…</h2>
			<p>While <strong class="source-inline">std::mutex</strong> provides an exclusive mutex suitable for many purposes, the STL does provide a few other choices:</p>
			<ul>
				<li><strong class="source-inline">shared_mutex</strong> allows more than one thread<a id="_idIndexMarker887"/> to simultaneously own a mutex.</li>
				<li><strong class="source-inline">recursive_mutex</strong> allows one thread to stack multiple<a id="_idIndexMarker888"/> locks on a single mutex.</li>
				<li><strong class="source-inline">timed_mutex</strong> provides a timeout for mutex<a id="_idIndexMarker889"/> blocks. Both <strong class="source-inline">shared_mutex</strong> and <strong class="source-inline">recursive_mutex</strong> also have timed versions available.</li>
			</ul>
			<h1 id="_idParaDest-312"><a id="_idTextAnchor311"/>Share flags and values with std::atomic</h1>
			<p>The <strong class="source-inline">std::atomic</strong> class encapsulates<a id="_idIndexMarker890"/> a single object and guarantees<a id="_idIndexMarker891"/> it to be <em class="italic">atomic</em>. Writing to the <em class="italic">atomic object</em> is controlled by memory-order<a id="_idIndexMarker892"/> policies and reads<a id="_idIndexMarker893"/> may occur simultaneously. It's typically used to synchronize access among different threads.</p>
			<p><strong class="source-inline">std::atomic</strong> defines an <em class="italic">atomic type</em> from its template type. The type must be <em class="italic">trivial</em>. A type is trivial if it occupies contiguous memory, has no user-defined constructor, and has no virtual member functions. All primitive types are trivial.</p>
			<p>While it is possible to construct a trivial type, <strong class="source-inline">std::atomic</strong> is most often used with simple primitive types, such as <strong class="source-inline">bool</strong>, <strong class="source-inline">int</strong>, <strong class="source-inline">long</strong>, <strong class="source-inline">float</strong>, and <strong class="source-inline">double</strong>.</p>
			<h2 id="_idParaDest-313"><a id="_idTextAnchor312"/>How to do it…</h2>
			<p>This recipe uses a simple function<a id="_idIndexMarker894"/> that loops over a counter to demonstrate sharing<a id="_idIndexMarker895"/> atomic objects. We will spawn<a id="_idIndexMarker896"/> a swarm of these loops as threads<a id="_idIndexMarker897"/> that share atomic values:</p>
			<ul>
				<li>Atomic objects are often placed in a global namespace. They must be accessible to all the threads that need to share its value:<p class="source-code">std::<strong class="bold">atomic&lt;bool&gt; ready</strong>{};</p><p class="source-code">std::<strong class="bold">atomic&lt;uint64_t&gt; g_count</strong>{};</p><p class="source-code">std::<strong class="bold">atomic_flag winner</strong>{};</p></li>
			</ul>
			<p>The <strong class="source-inline">ready</strong> object is a <strong class="source-inline">bool</strong> type that gets set to <strong class="source-inline">true</strong> when all the threads are ready to start counting.</p>
			<p>The <strong class="source-inline">g_count</strong> object is a global counter. It is incremented by each of the threads.</p>
			<p>The <strong class="source-inline">winner</strong> object is a special <strong class="source-inline">atomic_flag</strong> type. It is used to indicate which thread finishes first.</p>
			<ul>
				<li>We use a couple of constants to control the number of threads and the number of loops for each thread:<p class="source-code">constexpr int <strong class="bold">max_count</strong>{1000 * 1000};</p><p class="source-code">constexpr int <strong class="bold">max_threads</strong>{100};</p></li>
			</ul>
			<p>I've set it to run 100 threads and count 1,000,000 iterations in each thread.</p>
			<ul>
				<li>The <strong class="source-inline">countem()</strong> function is spawned for each thread. It loops <strong class="source-inline">max_count</strong> times and increments <strong class="source-inline">g_count</strong> for each iteration of the loop. This is where we use our atomic values:<p class="source-code">void countem (int <strong class="bold">id</strong>) {</p><p class="source-code">    while(<strong class="bold">!ready</strong>) std::this_thread::<strong class="bold">yield()</strong>;</p><p class="source-code">    for(int i{}; i &lt; <strong class="bold">max_count</strong>; ++i) <strong class="bold">++g_count</strong>;</p><p class="source-code">    if(!<strong class="bold">winner.test_and_set()</strong>) {</p><p class="source-code">        std::cout &lt;&lt; format("thread {:02} won!\n", </p><p class="source-code">          <strong class="bold">id</strong>);</p><p class="source-code">    }</p><p class="source-code">};</p></li>
			</ul>
			<p>The <strong class="source-inline">ready</strong> atomic<a id="_idIndexMarker898"/> value is used to synchronize<a id="_idIndexMarker899"/> the threads. Each thread<a id="_idIndexMarker900"/> will call <strong class="source-inline">yield()</strong> until <a id="_idIndexMarker901"/>the <strong class="source-inline">ready</strong> value is set <strong class="source-inline">true</strong>. The <strong class="source-inline">yield()</strong> function yields execution to other threads.</p>
			<p>Each iteration of the <strong class="source-inline">for</strong> loop increments the <strong class="source-inline">g_count</strong> atomic value. The final value should be equal to <strong class="source-inline">max_count * max_threads</strong>.</p>
			<p>After the loop is complete, the <strong class="source-inline">test_and_set()</strong> method of the <strong class="source-inline">winner</strong> object is used to report the winning thread. <strong class="source-inline">test_and_set()</strong> is a method of the <strong class="source-inline">atomic_flag</strong> class. It sets the flag and returns the <strong class="source-inline">bool</strong> value from before it is set.</p>
			<ul>
				<li>We've used the <strong class="source-inline">make_commas()</strong> function before. It displays a number with thousands of separators:<p class="source-code">string make_commas(const uint64_t&amp; num) {</p><p class="source-code">    string s{ std::to_string(num) };</p><p class="source-code">    for(long l = s.length() - 3; l &gt; 0; l -= 3) {</p><p class="source-code">        s.insert(l, ",");</p><p class="source-code">    }</p><p class="source-code">    return s;</p><p class="source-code">}</p></li>
				<li>The <strong class="source-inline">main()</strong> function<a id="_idIndexMarker902"/> spawns<a id="_idIndexMarker903"/> the threads<a id="_idIndexMarker904"/> and reports<a id="_idIndexMarker905"/> the results:<p class="source-code">int main() {</p><p class="source-code">    <strong class="bold">vector&lt;std::thread&gt; swarm</strong>;</p><p class="source-code">    cout &lt;&lt; format("spawn {} threads\n", <strong class="bold">max_threads</strong>);</p><p class="source-code">    for(int i{}; i &lt; <strong class="bold">max_threads</strong>; ++i) {</p><p class="source-code">        <strong class="bold">swarm.emplace_back(countem, i)</strong>;</p><p class="source-code">    }</p><p class="source-code">    <strong class="bold">ready = true</strong>;</p><p class="source-code">    for(auto&amp; t : <strong class="bold">swarm</strong>) <strong class="bold">t.join()</strong>;</p><p class="source-code">    cout &lt;&lt; format("global count: {}\n",</p><p class="source-code">        <strong class="bold">make_commas(g_count)</strong>);</p><p class="source-code">    return 0;</p><p class="source-code">}</p></li>
			</ul>
			<p>Here, we create a <strong class="source-inline">vector&lt;std::thread&gt;</strong> object to hold the threads.</p>
			<p>In the <strong class="source-inline">for</strong> loop, we use <strong class="source-inline">emplace_back()</strong> to create each <strong class="source-inline">thread</strong> in the <strong class="source-inline">vector</strong>.</p>
			<p>Once the threads have been spawned, we set the <strong class="source-inline">ready</strong> flag so that the threads may start their loops.</p>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">spawn 100 threads</strong></p>
			<p class="source-code"><strong class="bold">thread 67 won!</strong></p>
			<p class="source-code"><strong class="bold">global count: 100,000,000</strong></p>
			<p>Every time you run it, a different thread will win.</p>
			<h2 id="_idParaDest-314"><a id="_idTextAnchor313"/>How it works…</h2>
			<p>The <strong class="source-inline">std::atomic</strong> class encapsulates<a id="_idIndexMarker906"/> an object<a id="_idIndexMarker907"/> to synchronize<a id="_idIndexMarker908"/> access among multiple<a id="_idIndexMarker909"/> threads.</p>
			<p>The encapsulated object<a id="_idIndexMarker910"/> must be a <em class="italic">trivial type</em>, which means it occupies contiguous memory, has no user-defined constructor, and has no virtual member functions. All primitive types are trivial.</p>
			<p>It is possible to use a simple struct with <strong class="source-inline">atomic</strong>:</p>
			<p class="source-code">struct Trivial {</p>
			<p class="source-code">    int a;</p>
			<p class="source-code">    int b;</p>
			<p class="source-code">};</p>
			<p class="source-code">std::atomic&lt;Trivial&gt; triv1;</p>
			<p>While this usage is possible, it's not practical. Anything beyond setting and retrieving compound values loses the benefits of the atomicity and ends up requiring a <em class="italic">mutex</em>. The atomic class is best suited for <em class="italic">scalar</em> values.</p>
			<h3>Specializations</h3>
			<p>There are specializations<a id="_idIndexMarker911"/> of the <strong class="source-inline">atomic</strong> class for a few different purposes:</p>
			<ul>
				<li><strong class="bold">Pointers and smart pointers</strong>: The <strong class="source-inline">std::atomic&lt;U*&gt;</strong> specialization includes support for atomic pointer arithmetic operations, including <strong class="source-inline">fetch_add()</strong> for addition and <strong class="source-inline">fetch_sub()</strong> for subtraction.</li>
				<li><strong class="bold">Floating-point types</strong>: When used with the floating-point types <strong class="source-inline">float</strong>, <strong class="source-inline">double</strong>, and <strong class="source-inline">long double</strong>, <strong class="source-inline">std::atomic</strong> includes support for atomic floating-point arithmetic operations, including <strong class="source-inline">fetch_add()</strong> for addition and <strong class="source-inline">fetch_sub()</strong> for subtraction.</li>
				<li><strong class="bold">Integral types</strong>: When used <a id="_idIndexMarker912"/>with one of the integral types, <strong class="source-inline">std::atomic</strong> provides support for additional atomic operations, including <strong class="source-inline">fetch_add()</strong>, <strong class="source-inline">fetch_sub()</strong>, <strong class="source-inline">fetch_and()</strong>, <strong class="source-inline">fetch_or()</strong>, and <strong class="source-inline">fetch_xor()</strong>.</li>
			</ul>
			<h3>Standard aliases</h3>
			<p>The STL provides type aliases<a id="_idIndexMarker913"/> for all the standard scalar integral types. This means that instead of these declarations in our code:</p>
			<p class="source-code">std::atomic&lt;bool&gt; ready{};</p>
			<p class="source-code">std::atomic&lt;uint64_t&gt; g_count{};</p>
			<p>We could use:</p>
			<p class="source-code">std::atomic_bool ready{};</p>
			<p class="source-code">std::atomic_uint64_t g_count{};</p>
			<p>There are 46 standard aliases, one for each of the standard integral types:</p>
			<div>
				<div id="_idContainer043" class="IMG---Figure">
					<img src="image/B18267_table_9.1.jpg" alt=""/>
				</div>
			</div>
			<h3>Lock-free variations</h3>
			<p>Most modern architectures<a id="_idIndexMarker914"/> provide <em class="italic">atomic CPU instructions</em> for performing<a id="_idIndexMarker915"/> atomic operations. <strong class="source-inline">std::atomic</strong> should use hardware support for atomic instructions where supported by your hardware. Some atomic types may not be supported on some hardware. <strong class="source-inline">std::atomic</strong> may use a <em class="italic">mutex</em> to ensure thread-safe operations for those specializations, causing threads to block while waiting for other threads to complete<a id="_idIndexMarker916"/> operations. Specializations that use hardware support are said to be <em class="italic">lock-free</em> because they don't require a mutex.</p>
			<p>The <strong class="source-inline">is_lock_free()</strong> method checks whether a specialization is lock-free:</p>
			<p class="source-code">cout &lt;&lt; format("is g_count lock-free? {}\n", </p>
			<p class="source-code">    g_count.is_lock_free());</p>
			<p>Output:</p>
			<p class="source-code">is g_count lock-free? true</p>
			<p>This result will be <strong class="source-inline">true</strong> for most modern architectures.</p>
			<p>There are a few guaranteed lock-free variations<a id="_idIndexMarker917"/> of <strong class="source-inline">std::atomic</strong> available. These specializations guarantee the use of the most efficient hardware atomic operations for each purpose:</p>
			<ul>
				<li><strong class="source-inline">std::atomic_signed_lock_free</strong> is an alias for the most efficient lock-free specialization of a signed integral type.</li>
				<li><strong class="source-inline">std::atomic_unsigned_lock_free</strong> is an alias for the most efficient lock-free specialization of an unsigned integral type.</li>
				<li>The <strong class="source-inline">std::atomic_flag</strong> class provides a lock-free atomic Boolean type.<p class="callout-heading">Important Note</p><p class="callout">Current Windows systems don't support 64-bit hardware integers, even on 64-bit systems. When testing this code on one of these systems in my lab, replacing <strong class="source-inline">std::atomic&lt;uint64_t&gt;</strong> with <strong class="source-inline">std::atomic_unsigned_lock_free</strong> resulted in a <em class="italic">3x</em> performance improvement. Performance was unchanged on 64-bit Linux and Mac systems.</p></li>
			</ul>
			<h2 id="_idParaDest-315"><a id="_idTextAnchor314"/>There's more…</h2>
			<p>When multiple threads read and write variables simultaneously, one thread may observe the changes in a different order than they were written. <strong class="source-inline">std::memory_order</strong> specifies how memory accesses are ordered around an atomic operation.</p>
			<p><strong class="source-inline">std::atomic</strong> provides methods for accessing and changing its managed value. Unlike the associated operators, these access methods provide arguments for <strong class="source-inline">memory_order</strong> to be specified. For example:</p>
			<p class="source-code">g_count.fetch_add(1, std::memory_order_seq_cst);</p>
			<p>In this case, <strong class="source-inline">memory_order_seq_cst</strong> specifies <em class="italic">sequentially consistent</em> ordering. So, this call to <strong class="source-inline">fetch_add()</strong> will add 1 to the value of <strong class="source-inline">g_count</strong> with sequentially consistent ordering.</p>
			<p>The possible <strong class="source-inline">memory_order</strong> constants are:</p>
			<ul>
				<li><strong class="source-inline">memory_order_relaxed</strong>: This is a <em class="italic">relaxed operation</em>. No synchronization or ordering<a id="_idIndexMarker918"/> constraints are imposed; only the operation's atomicity is guaranteed.</li>
				<li><strong class="source-inline">memory_order_consume</strong>: This is a <em class="italic">consume operation</em>. Access in the current thread<a id="_idIndexMarker919"/> that is dependent on the value cannot be reordered before this load. This only affects compiler optimization.</li>
				<li><strong class="source-inline">memory_order_acquire</strong>: This is an <em class="italic">acquire operation</em>. Access cannot<a id="_idIndexMarker920"/> be reordered before this load.</li>
				<li><strong class="source-inline">memory_order_release</strong>: This is a <em class="italic">store operation</em>. Access in the current thread<a id="_idIndexMarker921"/> cannot be reordered after this store.</li>
				<li><strong class="source-inline">memory_order_acq_rel</strong>: This is both <em class="italic">acquire</em> and <em class="italic">release</em>. Access in the current thread<a id="_idIndexMarker922"/> cannot be reordered before or after this store.</li>
				<li><strong class="source-inline">memory_order_seq_cst</strong>: This is <em class="italic">sequentially consistent</em> ordering, either <em class="italic">acquire</em> or <em class="italic">release</em>, depending on the context. A load<a id="_idIndexMarker923"/> performs acquire, a store performs release, and a read/write/modify performs both. All threads observe all modifications in the same order.</li>
			</ul>
			<p>If no <strong class="source-inline">memory_order</strong> is specified, <strong class="source-inline">memory_order_seq_cst</strong> is the default.</p>
			<h1 id="_idParaDest-316"><a id="_idTextAnchor315"/>Initialize threads with std::call_once</h1>
			<p>You may need to run<a id="_idIndexMarker924"/> the same code in many threads but must initialize<a id="_idIndexMarker925"/> that code only once.</p>
			<p>One solution would be to call the initialization code before running the threads. This approach can work but has some drawbacks. By separating the initialization, it may be called when unnecessary, or it may be missed when necessary.</p>
			<p>The <strong class="source-inline">std::call_once</strong> function provides a more robust solution. <strong class="source-inline">call_once</strong> is in the <strong class="source-inline">&lt;mutex&gt;</strong> header.</p>
			<h2 id="_idParaDest-317"><a id="_idTextAnchor316"/>How to do it…</h2>
			<p>In this recipe, we use a print function for the initialization, so we can clearly see when it's called:</p>
			<ul>
				<li>We'll use a constant for the number of threads to spawn:<p class="source-code">constexpr size_t max_threads{ 25 };</p></li>
			</ul>
			<p>We also need a <strong class="source-inline">std::once_flag</strong> to synchronize the <strong class="source-inline">std::call_once</strong> function:</p>
			<p class="source-code">std::once_flag <strong class="bold">init_flag</strong>;</p>
			<ul>
				<li>Our initialization function simply prints a string to let us know it's been called:<p class="source-code">void do_init(size_t <strong class="bold">id</strong>) {</p><p class="source-code">    cout &lt;&lt; format("do_init ({}): ", <strong class="bold">id</strong>);</p><p class="source-code">}</p></li>
				<li>Our worker function, <strong class="source-inline">do_print()</strong>, uses <strong class="source-inline">std::call_once</strong> to call the initialization function then prints its own <strong class="source-inline">id</strong>:<p class="source-code">void do_print(size_t <strong class="bold">id</strong>) {</p><p class="source-code">    <strong class="bold">std::call_once(init_flag, do_init, id)</strong>;</p><p class="source-code">    cout &lt;&lt; format("{} ", <strong class="bold">id</strong>);</p><p class="source-code">}</p></li>
				<li>In <strong class="source-inline">main()</strong>, we use a <strong class="source-inline">list</strong> container<a id="_idIndexMarker926"/> to manage<a id="_idIndexMarker927"/> the <strong class="source-inline">thread</strong> objects:<p class="source-code">int main() {</p><p class="source-code">    <strong class="bold">list&lt;thread&gt; spawn</strong>;</p><p class="source-code">    for (size_t id{}; id &lt; max_threads; ++id) {</p><p class="source-code">        <strong class="bold">spawn.emplace_back(do_print, id)</strong>;</p><p class="source-code">    }</p><p class="source-code">    for (auto&amp; t : spawn) <strong class="bold">t.join()</strong>;</p><p class="source-code">    cout &lt;&lt; '\n';</p><p class="source-code">}</p></li>
			</ul>
			<p>Our output shows the initialization happens first, and only once:</p>
			<p class="source-code"><strong class="bold">do_init (8): 12 0 2 1 9 6 13 10 11 5 16 3 4 17 7 15 8 14 18 19 20 21 22 23 24</strong> </p>
			<p>Notice that it's not always the first spawned thread (<strong class="source-inline">0</strong>) that ends up calling the initialization function, but it is always called first. If you run this repeatedly, you'll see thread <strong class="source-inline">0</strong> gets the initialization often, but not every time. You'll see thread <strong class="source-inline">0</strong> in the initialization more often on a system with fewer cores.</p>
			<h2 id="_idParaDest-318"><a id="_idTextAnchor317"/>How it works…</h2>
			<p><strong class="source-inline">std::call_once</strong> is a template function that takes a flag, a <em class="italic">callable</em> (function or functor), and a parameter pack of arguments:</p>
			<p class="source-code">template&lt;class Callable, class... Args&gt;</p>
			<p class="source-code">void call_once(once_flag&amp; flag, Callable&amp;&amp; f, Args&amp;&amp;... args);</p>
			<p>The callable <strong class="source-inline">f</strong> is called exactly one time. Even if <strong class="source-inline">call_once</strong> is called concurrently from several threads, <strong class="source-inline">f</strong> is still called once and only once.</p>
			<p>This requires a <strong class="source-inline">std::once_flag</strong> object for coordination. The <strong class="source-inline">once_flag</strong> constructor sets its state to indicate that the callable has not yet been called.</p>
			<p>When <strong class="source-inline">call_once</strong> invokes<a id="_idIndexMarker928"/> the callable, any other calls<a id="_idIndexMarker929"/> on the same <strong class="source-inline">once_flag</strong> are blocked until the callable returns. After the callable returns, the <strong class="source-inline">once_flag</strong> is set, and any subsequent calls to <strong class="source-inline">call_once</strong> return without invoking <strong class="source-inline">f</strong>.</p>
			<h1 id="_idParaDest-319"><a id="_idTextAnchor318"/>Use std::condition_variable to resolve the producer-consumer problem</h1>
			<p>The simplest version<a id="_idIndexMarker930"/> of the <em class="italic">producer-consumer problem</em> is where you have one<a id="_idIndexMarker931"/> process that <em class="italic">produces</em> data and another that <em class="italic">consumes</em> data, using one <em class="italic">buffer</em> or container to hold the data. This requires coordination between the producer and consumer to manage the buffer and prevent unwanted side effects.</p>
			<h2 id="_idParaDest-320"><a id="_idTextAnchor319"/>How to do it…</h2>
			<p>In this recipe, we consider a simple solution to the producer-consumer problem using <strong class="source-inline">std::condition_variable</strong> to coordinate the processes:</p>
			<ul>
				<li>We begin with some namespace and alias declarations for convenience:<p class="source-code">using namespace std::chrono_literals;</p><p class="source-code">namespace this_thread = std::this_thread;</p><p class="source-code">using <strong class="bold">guard_t</strong> = std::lock_guard&lt;std::mutex&gt;;</p><p class="source-code">using <strong class="bold">lock_t</strong> = std::unique_lock&lt;std::mutex&gt;;</p></li>
			</ul>
			<p>The <strong class="source-inline">lock_guard</strong> and <strong class="source-inline">unique_lock</strong> aliases make it easier to use these types without error.</p>
			<ul>
				<li>We use a couple of constants:<p class="source-code">constexpr size_t num_items{ 10 };</p><p class="source-code">constexpr auto delay_time{ 200ms };</p></li>
			</ul>
			<p>Keeping these in one place makes it safer and easier to experiment with different values.</p>
			<ul>
				<li>We're using these global<a id="_idIndexMarker932"/> variables for coordinating<a id="_idIndexMarker933"/> the data store:<p class="source-code">std::deque&lt;size_t&gt; q{};</p><p class="source-code">std::mutex mtx{};</p><p class="source-code"><strong class="bold">std::condition_variable</strong> cond{};</p><p class="source-code">bool finished{};</p></li>
			</ul>
			<p>We're using <strong class="source-inline">deque</strong> to hold<a id="_idIndexMarker934"/> the data as a <strong class="bold">First-In-First-Out</strong> (<strong class="bold">FIFO</strong>) queue.</p>
			<p><strong class="source-inline">mutex</strong> is used with the <strong class="source-inline">condition_variable</strong> to coordinate the movement of data from producer to consumer.</p>
			<p>The <strong class="source-inline">finished</strong> flag indicates that there is no more data.</p>
			<ul>
				<li>The producer thread will use this function:<p class="source-code">void producer() {</p><p class="source-code">    for(size_t i{}; i &lt; <strong class="bold">num_items</strong>; ++i) {</p><p class="source-code">        this_thread::<strong class="bold">sleep_for</strong>(delay_time);</p><p class="source-code">        <strong class="bold">guard_t x{ mtx }</strong>;</p><p class="source-code">        q.push_back(i);</p><p class="source-code">        <strong class="bold">cond.notify_all()</strong>;</p><p class="source-code">    }</p><p class="source-code">    <strong class="bold">guard_t x{ mtx }</strong>;</p><p class="source-code">    finished = true;</p><p class="source-code">    <strong class="bold">cond.notify_all()</strong>;</p><p class="source-code">}</p></li>
			</ul>
			<p>The <strong class="source-inline">producer()</strong> function loops <strong class="source-inline">num_items</strong> iterations and pushes a number onto the <strong class="source-inline">deque</strong> each time through the loop.</p>
			<p>We include a <strong class="source-inline">sleep_for()</strong> call to simulate<a id="_idIndexMarker935"/> a delay in producing<a id="_idIndexMarker936"/> each value.</p>
			<p>The <strong class="source-inline">conditional_variable</strong> requires a <strong class="source-inline">mutex</strong> lock to operate. We use <strong class="source-inline">lock_guard</strong> (via the <strong class="source-inline">guard_t</strong> alias) to obtain the lock, then push the value onto the <strong class="source-inline">deque</strong>, and then call <strong class="source-inline">notify_all()</strong> on the <strong class="source-inline">conditional_variable</strong>. This tells the consumer thread that there is a new value available.</p>
			<p>When the loop completes, we set the <strong class="source-inline">finished</strong> flag and notify the consumer thread that the producer is completed.</p>
			<ul>
				<li>The consumer thread waits for each value from the producer, displays it on the console, and waits for the <strong class="source-inline">finished</strong> flag:<p class="source-code">void consumer() {</p><p class="source-code">    while(<strong class="bold">!finished</strong>) {</p><p class="source-code">        lock_t lck{ mtx };</p><p class="source-code">        <strong class="bold">cond.wait(lck, [] { return !q.empty() || </strong></p><p class="source-code"><strong class="bold">          finished; })</strong>;</p><p class="source-code">        while(!q.empty()) {</p><p class="source-code">            cout &lt;&lt; format("Got {} from the queue\n",</p><p class="source-code">                q.front());</p><p class="source-code">            q.pop_front();</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ul>
			<p>The <strong class="source-inline">wait()</strong> method waits to be notified by the producer. It uses the lambda as a predicate to continue waiting until the <strong class="source-inline">deque</strong> is <em class="italic">not empty</em> or the <strong class="source-inline">finished</strong> flag is set.</p>
			<p>When we get<a id="_idIndexMarker937"/> a value, we display<a id="_idIndexMarker938"/> it and then pop it from the <strong class="source-inline">deque</strong>.</p>
			<ul>
				<li>We run this in <strong class="source-inline">main()</strong> with simple <strong class="source-inline">thread</strong> objects:<p class="source-code">int main() {</p><p class="source-code">    thread t1{ producer };</p><p class="source-code">    thread t2{ consumer };</p><p class="source-code">    t1.join();</p><p class="source-code">    t2.join();</p><p class="source-code">    cout &lt;&lt; "finished!\n";</p><p class="source-code">}</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">Got 0 from the queue</strong></p>
			<p class="source-code"><strong class="bold">Got 1 from the queue</strong></p>
			<p class="source-code"><strong class="bold">Got 2 from the queue</strong></p>
			<p class="source-code"><strong class="bold">Got 3 from the queue</strong></p>
			<p class="source-code"><strong class="bold">Got 4 from the queue</strong></p>
			<p class="source-code"><strong class="bold">Got 5 from the queue</strong></p>
			<p class="source-code"><strong class="bold">Got 6 from the queue</strong></p>
			<p class="source-code"><strong class="bold">Got 7 from the queue</strong></p>
			<p class="source-code"><strong class="bold">Got 8 from the queue</strong></p>
			<p class="source-code"><strong class="bold">Got 9 from the queue</strong></p>
			<p class="source-code"><strong class="bold">finished!</strong></p>
			<p>Notice that there's a 200 ms delay between<a id="_idIndexMarker939"/> each line. This tells<a id="_idIndexMarker940"/> us that the producer-consumer coordination is working as expected.</p>
			<h2 id="_idParaDest-321"><a id="_idTextAnchor320"/>How it works…</h2>
			<p>The producer-consumer problem requires coordination between writing and reading a buffer or container. In this example, our container is a <strong class="source-inline">deque&lt;size_t&gt;</strong>:</p>
			<p class="source-code">std::deque&lt;size_t&gt; q{};</p>
			<p>The <strong class="source-inline">condition_variable</strong> class can block a thread, or multiple threads, while a shared variable is modified. It may then notify other threads that the value is available.</p>
			<p><strong class="source-inline">condition_variable</strong> requires a <strong class="source-inline">mutex</strong> to perform the lock:</p>
			<p class="source-code"><strong class="bold">std::lock_guard</strong> x{ mtx };</p>
			<p class="source-code">q.push_back(i);</p>
			<p class="source-code">cond.<strong class="bold">notify_all()</strong>;</p>
			<p>The <strong class="source-inline">std::lock_guard</strong> acquires a lock, so we can push a value onto our <strong class="source-inline">deque</strong>.</p>
			<p>The <strong class="source-inline">wait()</strong> method on <strong class="source-inline">condition_variable</strong> is used to block the current thread until it receives a notification:</p>
			<p class="source-code">void wait( std::unique_lock&lt;std::mutex&gt;&amp; lock );</p>
			<p class="source-code">void wait( std::unique_lock&lt;std::mutex&gt;&amp; lock,</p>
			<p class="source-code">    Pred stop_waiting );</p>
			<p>The predicate form of <strong class="source-inline">wait()</strong> is equivalent to:</p>
			<p class="source-code">while (!stop_waiting()) {</p>
			<p class="source-code">    wait(lock);</p>
			<p class="source-code">}</p>
			<p>The predicate form is used to prevent spurious waking while waiting for a specific condition. We use it with a lambda in our example:</p>
			<p class="source-code">cond.wait(lck, []{ return !q.empty() || finished; });</p>
			<p>This prevents our consumer<a id="_idIndexMarker941"/> from waking until the <strong class="source-inline">deque</strong> has data<a id="_idIndexMarker942"/> or the <strong class="source-inline">finished</strong> flag is set.</p>
			<p>The <strong class="source-inline">condition_variable</strong> class has two notification methods:</p>
			<ul>
				<li><strong class="source-inline">notify_one()</strong> unblocks one waiting thread</li>
				<li><strong class="source-inline">notify_all()</strong> unblocks all waiting threads</li>
			</ul>
			<p>We used <strong class="source-inline">notify_all()</strong> in our example. Because there is only one consumer thread, either notification method would work the same.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Note that <strong class="source-inline">unique_lock</strong> is the <em class="italic">only</em> form of lock<a id="_idIndexMarker943"/> that supports the <strong class="source-inline">wait()</strong> method on a <strong class="source-inline">condition_variable</strong> object.</p>
			<h1 id="_idParaDest-322"><a id="_idTextAnchor321"/>Implement multiple producers and consumers</h1>
			<p>The <em class="italic">producer-consumer problem</em> is really a set<a id="_idIndexMarker944"/> of problems. Solutions will differ if the buffer<a id="_idIndexMarker945"/> is bounded or unbounded, or if there are multiple<a id="_idIndexMarker946"/> producers, multiple consumers, or both.</p>
			<p>Let's consider a case with multiple producers, multiple consumers, and a bounded (limited capacity) buffer. This is a common condition.</p>
			<h2 id="_idParaDest-323"><a id="_idTextAnchor322"/>How to do it…</h2>
			<p>In this recipe, we'll look at a case with multiple producers and consumers<a id="_idIndexMarker947"/> and a <em class="italic">bounded buffer</em>, using a variety of techniques we've covered in this chapter:</p>
			<ul>
				<li>We'll start with some constants for convenience and reliability:<p class="source-code">constexpr auto <strong class="bold">delay_time</strong>{ 50ms };</p><p class="source-code">constexpr auto <strong class="bold">consumer_wait</strong>{ 100ms };</p><p class="source-code">constexpr size_t <strong class="bold">queue_limit</strong>{ 5 };</p><p class="source-code">constexpr size_t <strong class="bold">num_items</strong>{ 15 };</p><p class="source-code">constexpr size_t <strong class="bold">num_producers</strong>{ 3 };</p><p class="source-code">constexpr size_t <strong class="bold">num_consumers</strong>{ 5 };</p><ul><li><strong class="source-inline">delay_time</strong> is a <strong class="source-inline">duration</strong> object, used with <strong class="source-inline">sleep_for()</strong>.</li><li><strong class="source-inline">consumer_wait</strong> is a <strong class="source-inline">duration</strong> object, used with the <strong class="source-inline">consumer</strong> condition variable.</li><li><strong class="source-inline">queue_limt</strong> is the buffer limit – the maximum number of items in the <strong class="source-inline">deque</strong>.</li><li><strong class="source-inline">num_items</strong> is the maximum number of items produced per <strong class="source-inline">producer</strong>.</li><li><strong class="source-inline">num_producers</strong> is the number of spawned producers.</li><li><strong class="source-inline">num_producers</strong> is the number of spawned consumers.</li></ul></li>
				<li>Now, we need some objects<a id="_idIndexMarker948"/> to control<a id="_idIndexMarker949"/> the process:<p class="source-code">deque&lt;string&gt; <strong class="bold">qs</strong>{};</p><p class="source-code">mutex <strong class="bold">q_mutex</strong>{};</p><p class="source-code">condition_variable <strong class="bold">cv_producer</strong>{};</p><p class="source-code">condition_variable <strong class="bold">cv_consumer</strong>{};</p><p class="source-code">bool <strong class="bold">production_complete</strong>{};</p><ul><li><strong class="source-inline">qs</strong> is a <strong class="source-inline">deque</strong> of <strong class="source-inline">string</strong> that holds the produced objects.</li><li><strong class="source-inline">q_mutex</strong> controls access to <strong class="source-inline">deque</strong>.</li><li><strong class="source-inline">cv_producer</strong> is a condition variable that coordinates producers.</li><li><strong class="source-inline">cv_consumer</strong> is a condition variable that coordinates consumers.</li><li><strong class="source-inline">production_complete</strong> is set <strong class="source-inline">true</strong> when all producer threads have finished.</li></ul></li>
				<li>The <strong class="source-inline">producer()</strong> threads<a id="_idIndexMarker950"/> run this<a id="_idIndexMarker951"/> function:<p class="source-code">void <strong class="bold">producer</strong>(const size_t <strong class="bold">id</strong>) {</p><p class="source-code">    for(size_t i{}; i &lt; <strong class="bold">num_items</strong>; ++i) {</p><p class="source-code">        this_thread::<strong class="bold">sleep_for</strong>(<strong class="bold">delay_time</strong> * id);</p><p class="source-code">        unique_lock&lt;mutex&gt; <strong class="bold">lock</strong>(<strong class="bold">q_mutex</strong>);</p><p class="source-code">        cv_producer.wait(<strong class="bold">lock</strong>,</p><p class="source-code">            [&amp;]{ return qs.size() &lt; <strong class="bold">queue_limit</strong>; });</p><p class="source-code">        qs.<strong class="bold">push_back</strong>(format("pid {}, qs {}, </p><p class="source-code">          item {:02}\n", id, qs.size(), i + 1));</p><p class="source-code">        cv_consumer.<strong class="bold">notify_all</strong>();</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ul>
			<p>The passed value <strong class="source-inline">id</strong> is a sequential number used to identify the producer.</p>
			<p>The main <strong class="source-inline">for</strong> loop repeats <strong class="source-inline">num_item</strong> times. The <strong class="source-inline">sleep_for()</strong> function is used to simulate some work required to produce an item.</p>
			<p>Then we obtain a <strong class="source-inline">unique_lock</strong> from <strong class="source-inline">q_mutex</strong> and invoke <strong class="source-inline">wait()</strong> on <strong class="source-inline">cv_producer</strong>, using a lambda that checks the size of the <strong class="source-inline">deque</strong> against the <strong class="source-inline">queue_limit</strong> constant. If the <strong class="source-inline">deque</strong> has reached maximum size, the <strong class="source-inline">producer</strong> waits for <strong class="source-inline">consumer</strong> threads to reduce the size of the <strong class="source-inline">deque</strong>. This represents the <em class="italic">bounded buffer</em> limit<a id="_idIndexMarker952"/> on the producer.</p>
			<p>Once the condition is satisfied, we push an <em class="italic">item</em> onto the <strong class="source-inline">deque</strong>. The item is a formatted string with the producer's <strong class="source-inline">id</strong>, the size of <strong class="source-inline">qs</strong>, and an item number (<strong class="source-inline">i + 1</strong>) from the loop control variable.</p>
			<p>Finally, we notify the consumers that new data is available, with <strong class="source-inline">notify_all()</strong> on the <strong class="source-inline">cv_consumer</strong> condition variable.</p>
			<ul>
				<li>The <strong class="source-inline">consumer()</strong> threads<a id="_idIndexMarker953"/> run this<a id="_idIndexMarker954"/> function:<p class="source-code">void consumer(const size_t <strong class="bold">id</strong>) {</p><p class="source-code">    while(!<strong class="bold">production_complete</strong>) {</p><p class="source-code">        unique_lock&lt;mutex&gt; lock(<strong class="bold">q_mutex</strong>);</p><p class="source-code">        cv_consumer.<strong class="bold">wait_for</strong>(lock, <strong class="bold">consumer_wait</strong>,</p><p class="source-code">            [&amp;]{ return !qs.empty(); });</p><p class="source-code">        if(!qs.empty()){</p><p class="source-code">            cout &lt;&lt; format("cid {}: {}", id, </p><p class="source-code">              <strong class="bold">qs.front</strong>());</p><p class="source-code">            qs.<strong class="bold">pop_front</strong>();</p><p class="source-code">        }</p><p class="source-code">        cv_producer.<strong class="bold">notify_all</strong>();</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ul>
			<p>The passed <strong class="source-inline">id</strong> value is a sequential number used to identify the consumer.</p>
			<p>The main <strong class="source-inline">while()</strong> loop continues until <strong class="source-inline">production_complete</strong> is set.</p>
			<p>We obtain <strong class="source-inline">unique_lock</strong> from <strong class="source-inline">q_mutex</strong> and invoke <strong class="source-inline">wait_for()</strong> on <strong class="source-inline">cv_consumer</strong>, with a timeout and a lambda that tests if the <strong class="source-inline">deque</strong> is empty. We need the timeout because it's possible for the <strong class="source-inline">producer</strong> threads to finish while some of the <strong class="source-inline">consumer</strong> threads are still running, leaving the <strong class="source-inline">deque</strong> empty.</p>
			<p>Once we have a non-empty <strong class="source-inline">deque</strong>, we can print (<em class="italic">consume</em>) an <em class="italic">item</em> and pop it off the <strong class="source-inline">deque</strong>.</p>
			<ul>
				<li>In <strong class="source-inline">main()</strong>, we use <strong class="source-inline">async()</strong> to spawn the <strong class="source-inline">producer</strong> and <strong class="source-inline">consumer</strong> threads. <strong class="source-inline">async()</strong> conforms to the RAII<a id="_idIndexMarker955"/> pattern, so I'll usually prefer<a id="_idIndexMarker956"/> it over <strong class="source-inline">thread</strong>, where possible. <strong class="source-inline">async()</strong> returns a <strong class="source-inline">future</strong> object, so we'll keep a list of <strong class="source-inline">future&lt;void&gt;</strong> objects for process management:<p class="source-code">int main() {</p><p class="source-code">    list&lt;<strong class="bold">future&lt;void&gt;</strong>&gt; <strong class="bold">producers</strong>;</p><p class="source-code">    list&lt;<strong class="bold">future&lt;void&gt;</strong>&gt; <strong class="bold">consumers</strong>;</p><p class="source-code">    for(size_t i{}; i &lt; <strong class="bold">num_producers</strong>; ++i) {</p><p class="source-code">        <strong class="bold">producers</strong>.emplace_back(<strong class="bold">async(producer, i)</strong>);</p><p class="source-code">    }</p><p class="source-code">    for(size_t i{}; i &lt; <strong class="bold">num_consumers</strong>; ++i) {</p><p class="source-code">        <strong class="bold">consumers</strong>.emplace_back(<strong class="bold">async(consumer, i)</strong>);</p><p class="source-code">    }</p><p class="source-code">    ...</p></li>
			</ul>
			<p>We use <strong class="source-inline">for</strong> loops to create <strong class="source-inline">producer</strong> and <strong class="source-inline">consumer</strong> threads.</p>
			<ul>
				<li>Finally, we use <strong class="source-inline">list</strong> of <strong class="source-inline">future</strong> objects to determine when our <strong class="source-inline">producer</strong> and <strong class="source-inline">consumer</strong> threads are complete:<p class="source-code">for(auto&amp; f : <strong class="bold">producers</strong>) f.<strong class="bold">wait()</strong>;</p><p class="source-code"><strong class="bold">production_complete = true</strong>;</p><p class="source-code">cout &lt;&lt; "producers done.\n";</p><p class="source-code">for(auto&amp; f : <strong class="bold">consumers</strong>) f.<strong class="bold">wait()</strong>;</p><p class="source-code">cout &lt;&lt; "consumers done.\n";</p></li>
			</ul>
			<p>We loop through our <strong class="source-inline">producers</strong> container, calling <strong class="source-inline">wait()</strong> to allow the <strong class="source-inline">producer</strong> threads to complete. Then, we can set the <strong class="source-inline">production_complete</strong> flag. We likewise loop through the <strong class="source-inline">consumers</strong> container, calling <strong class="source-inline">wait()</strong> to allow the <strong class="source-inline">consumer</strong> threads to complete. We could perform<a id="_idIndexMarker957"/> any final analysis or completion<a id="_idIndexMarker958"/> processes here.</p>
			<ul>
				<li>The output is a bit long to show in its entirety:<p class="source-code"><strong class="bold">cid 0: pid 0, qs  0, item 01</strong></p><p class="source-code"><strong class="bold">cid 0: pid 0, qs  1, item 02</strong></p><p class="source-code"><strong class="bold">cid 0: pid 0, qs  2, item 03</strong></p><p class="source-code"><strong class="bold">cid 0: pid 0, qs  3, item 04</strong></p><p class="source-code"><strong class="bold">cid 0: pid 0, qs  4, item 05</strong></p><p class="source-code"><strong class="bold">...</strong></p><p class="source-code"><strong class="bold">cid 4: pid 2, qs  0, item 12</strong></p><p class="source-code"><strong class="bold">cid 4: pid 2, qs  </strong><strong class="bold">0, item 13</strong></p><p class="source-code"><strong class="bold">cid 3: pid 2, qs  0, item 14</strong></p><p class="source-code"><strong class="bold">cid 0: pid 2, qs  0, item 15</strong></p><p class="source-code"><strong class="bold">producers done.</strong></p><p class="source-code"><strong class="bold">consumers done.</strong></p></li>
			</ul>
			<h2 id="_idParaDest-324"><a id="_idTextAnchor323"/>How it works…</h2>
			<p>The heart of this recipe is in the use of two <strong class="source-inline">condition_variable</strong> objects to control the <strong class="source-inline">producer</strong> and <strong class="source-inline">consumer</strong> threads asynchronously:</p>
			<p class="source-code">condition_variable cv_producer{};</p>
			<p class="source-code">condition_variable cv_consumer{};</p>
			<p>In the <strong class="source-inline">producer()</strong> function, the <strong class="source-inline">cv_producer</strong> object obtains a <strong class="source-inline">unique_lock</strong>, waits for the <strong class="source-inline">deque</strong> to be available, and notifies the <strong class="source-inline">cv_consumer</strong> object when an item has been produced:</p>
			<p class="source-code">void producer(const size_t id) {</p>
			<p class="source-code">    for(size_t i{}; i &lt; num_items; ++i) {</p>
			<p class="source-code">        this_thread::sleep_for(delay_time * id);</p>
			<p class="source-code">        <strong class="bold">unique_lock</strong>&lt;mutex&gt; lock(q_mutex);</p>
			<p class="source-code">        <strong class="bold">cv_producer.wait</strong>(lock,</p>
			<p class="source-code">            [&amp;]{ return qs.size() &lt; queue_limit; });</p>
			<p class="source-code">        qs.push_back(format("pid {}, qs  {}, item {:02}\n",</p>
			<p class="source-code">            id, qs.size(), i + 1));</p>
			<p class="source-code">        <strong class="bold">cv_consumer.notify_all</strong>();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Conversely, in the <strong class="source-inline">consumer()</strong> function, the <strong class="source-inline">cv_consumer</strong> object obtains a <strong class="source-inline">unique_lock</strong>, waits<a id="_idIndexMarker959"/> for the <strong class="source-inline">deque</strong> to have items, and notifies<a id="_idIndexMarker960"/> the <strong class="source-inline">cv_producer</strong> object when an item has been consumed:</p>
			<p class="source-code">void consumer(const size_t id) {</p>
			<p class="source-code">    while(!production_complete) {</p>
			<p class="source-code">        <strong class="bold">unique_lock</strong>&lt;mutex&gt; lock(q_mutex);</p>
			<p class="source-code">        <strong class="bold">cv_consumer.wait_for</strong>(lock, consumer_wait,</p>
			<p class="source-code">            [&amp;]{ return !qs.empty(); });</p>
			<p class="source-code">        if(!qs.empty()) {</p>
			<p class="source-code">            cout &lt;&lt; format("cid {}: {}", id, qs.front());</p>
			<p class="source-code">            qs.pop_front();</p>
			<p class="source-code">        }</p>
			<p class="source-code">        <strong class="bold">cv_producer.notify_all</strong>();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>These complementary<a id="_idIndexMarker961"/> locks, waits, and notifications constitute the balance <a id="_idIndexMarker962"/>of coordination between multiple producers and consumers.</p>
		</div>
	</body></html>