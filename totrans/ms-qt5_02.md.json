["```cpp\n// In SysInfo.h \nclass SysInfo \n{ \npublic: \n    SysInfo(); \n    virtual ~SysInfo(); \n\n    virtual void init() = 0; \n    virtual double cpuLoadAverage() = 0; \n    virtual double memoryUsed() = 0; \n}; \n\n// In SysInfo.cpp \n#include \"SysInfo.h\" \n\nSysInfo::SysInfo() \n{ \n} \n\nSysInfo::~SysInfo() \n{ \n} \n\n```", "```cpp\n#include \"SysInfo.h\" \n\nclass SysInfoWindowsImpl : public SysInfo \n{ \npublic: \n    SysInfoWindowsImpl(); \n\n    void init() override; \n    double cpuLoadAverage() override; \n    double memoryUsed() override; \n}; \n\n```", "```cpp\n#include \"SysInfoWindowsImpl.h\" \n\n#include <windows.h> \n\nSysInfoWindowsImpl::SysInfoWindowsImpl() : \n    SysInfo(), \n{ \n} \n\ndouble SysInfoWindowsImpl::memoryUsed() \n{ \n    MEMORYSTATUSEX memoryStatus; \n    memoryStatus.dwLength = sizeof(MEMORYSTATUSEX); \n    GlobalMemoryStatusEx(&memoryStatus); \n    qulonglong memoryPhysicalUsed = \n        memoryStatus.ullTotalPhys - memoryStatus.ullAvailPhys; \n    return (double)memoryPhysicalUsed / \n        (double)memoryStatus.ullTotalPhys * 100.0; \n} \n\n```", "```cpp\n#include <QtGlobal> \n#include <QVector> \n\n#include \"SysInfo.h\" \n\ntypedef struct _FILETIME FILETIME; \n\nclass SysInfoWindowsImpl : public SysInfo \n{ \npublic: \n    SysInfoWindowsImpl(); \n\n    void init() override; \n    double cpuLoadAverage() override; \n    double memoryUsed() override; \n\nprivate: \n    QVector<qulonglong> cpuRawData(); \n    qulonglong convertFileTime(const FILETIME& filetime) const; \n\nprivate: \n    QVector<qulonglong> mCpuLoadLastValues; \n}; \n\n```", "```cpp\n#include \"SysInfoWindowsImpl.h\" \n\n#include <windows.h> \n\nSysInfoWindowsImpl::SysInfoWindowsImpl() : \n    SysInfo(), \n    mCpuLoadLastValues() \n{ \n} \n\nvoid SysInfoWindowsImpl::init() \n{ \n    mCpuLoadLastValues = cpuRawData(); \n} \n\n```", "```cpp\nQVector<qulonglong> SysInfoWindowsImpl::cpuRawData() \n{ \n    FILETIME idleTime; \n    FILETIME kernelTime; \n    FILETIME userTime; \n\n    GetSystemTimes(&idleTime, &kernelTime, &userTime); \n\n    QVector<qulonglong> rawData; \n\n    rawData.append(convertFileTime(idleTime)); \n    rawData.append(convertFileTime(kernelTime)); \n    rawData.append(convertFileTime(userTime)); \n    return rawData; \n} \n\n```", "```cpp\nqulonglong SysInfoWindowsImpl::convertFileTime(const FILETIME& filetime) const \n{ \n    ULARGE_INTEGER largeInteger; \n    largeInteger.LowPart = filetime.dwLowDateTime; \n    largeInteger.HighPart = filetime.dwHighDateTime; \n    return largeInteger.QuadPart; \n} \n\n```", "```cpp\ndouble SysInfoWindowsImpl::cpuLoadAverage() \n{ \n    QVector<qulonglong> firstSample = mCpuLoadLastValues; \n    QVector<qulonglong> secondSample = cpuRawData(); \n    mCpuLoadLastValues = secondSample; \n\n    qulonglong currentIdle = secondSample[0] - firstSample[0]; \n    qulonglong currentKernel = secondSample[1] - firstSample[1]; \n    qulonglong currentUser = secondSample[2] - firstSample[2]; \n    qulonglong currentSystem = currentKernel + currentUser; \n\n    double percent = (currentSystem - currentIdle) * 100.0 / \n        currentSystem ; \n    return qBound(0.0, percent, 100.0); \n} \n\n```", "```cpp\nQT       += core gui \nCONFIG   += C++14 \n\ngreaterThan(QT_MAJOR_VERSION, 4): QT += widgets \n\nTARGET = ch02-sysinfo \nTEMPLATE = app \n\nSOURCES += main.cpp \\ \n    MainWindow.cpp \\ \n    SysInfo.cpp \n\nHEADERS += MainWindow.h \\ \n    SysInfo.h \n\nwindows { \n    SOURCES += SysInfoWindowsImpl.cpp \n    HEADERS += SysInfoWindowsImpl.h \n} \n\nFORMS    += MainWindow.ui \n\n```", "```cpp\n#include \"SysInfo.h\" \n\nclass SysInfoLinuxImpl : public SysInfo \n{ \npublic: \n    SysInfoLinuxImpl(); \n\n    void init() override; \n    double cpuLoadAverage() override; \n    double memoryUsed() override; \n}; \n\n```", "```cpp\n#include \"SysInfoLinuxImpl.h\" \n\n#include <sys/types.h> \n#include <sys/sysinfo.h> \n\nSysInfoLinuxImpl::SysInfoLinuxImpl() : \n    SysInfo(), \n{ \n} \n\ndouble SysInfoLinuxImpl::memoryUsed() \n{ \n    struct sysinfo memInfo; \n    sysinfo(&memInfo); \n\n    qulonglong totalMemory = memInfo.totalram; \n    totalMemory += memInfo.totalswap; \n    totalMemory *= memInfo.mem_unit; \n\n    qulonglong totalMemoryUsed = memInfo.totalram - memInfo.freeram; \n    totalMemoryUsed += memInfo.totalswap - memInfo.freeswap; \n    totalMemoryUsed *= memInfo.mem_unit; \n\n    double percent = (double)totalMemoryUsed / \n        (double)totalMemory * 100.0; \n    return qBound(0.0, percent, 100.0); \n} \n\n```", "```cpp\n#include <QtGlobal> \n#include <QVector> \n\n#include \"SysInfo.h\" \n\nclass SysInfoLinuxImpl : public SysInfo \n{ \npublic: \n    SysInfoLinuxImpl(); \n\n    void init() override; \n    double cpuLoadAverage() override; \n    double memoryUsed() override; \n\nprivate: \n    QVector<qulonglong> cpuRawData(); \n\nprivate: \n    QVector<qulonglong> mCpuLoadLastValues; \n}; \n\n```", "```cpp\n#include \"SysInfoLinuxImpl.h\" \n\n#include <sys/types.h> \n#include <sys/sysinfo.h> \n\n#include <QFile> \n\nSysInfoLinuxImpl::SysInfoLinuxImpl() : \n    SysInfo(), \n    mCpuLoadLastValues() \n{ \n} \n\nvoid SysInfoLinuxImpl::init() \n{ \n    mCpuLoadLastValues = cpuRawData(); \n} \n\n```", "```cpp\nQVector<qulonglong> SysInfoLinuxImpl::cpuRawData() \n{ \n    QFile file(\"/proc/stat\"); \n    file.open(QIODevice::ReadOnly); \n\n    QByteArray line = file.readLine(); \n    file.close(); \n    qulonglong totalUser = 0, totalUserNice = 0, \n        totalSystem = 0, totalIdle = 0; \n    std::sscanf(line.data(), \"cpu %llu %llu %llu %llu\", \n        &totalUser, &totalUserNice, &totalSystem, \n        &totalIdle); \n\n    QVector<qulonglong> rawData; \n    rawData.append(totalUser); \n    rawData.append(totalUserNice); \n    rawData.append(totalSystem); \n    rawData.append(totalIdle); \n\n    return rawData; \n} \n\n```", "```cpp\ndouble SysInfoLinuxImpl::cpuLoadAverage() \n{ \n    QVector<qulonglong> firstSample = mCpuLoadLastValues; \n    QVector<qulonglong> secondSample = cpuRawData(); \n    mCpuLoadLastValues = secondSample; \n\n    double overall = (secondSample[0] - firstSample[0]) \n        + (secondSample[1] - firstSample[1]) \n        + (secondSample[2] - firstSample[2]); \n\n    double total = overall + (secondSample[3] - firstSample[3]); \n    double percent = (overall / total) * 100.0; \n    return qBound(0.0, percent, 100.0); \n} \n\n```", "```cpp\nQT       += core gui \nCONFIG   += C++14 \n\ngreaterThan(QT_MAJOR_VERSION, 4): QT += widgets \n\nTARGET = ch02-sysinfo \nTEMPLATE = app \n\nSOURCES += main.cpp \\ \n    MainWindow.cpp \\ \n    SysInfo.cpp \\ \n    CpuWidget.cpp \\ \n    MemoryWidget.cpp \\ \n    SysInfoWidget.cpp \n\nHEADERS += MainWindow.h \\ \n    SysInfo.h \\ \n    CpuWidget.h \\ \n    MemoryWidget.h \\ \n    SysInfoWidget.h \n\nwindows { \n    SOURCES += SysInfoWindowsImpl.cpp \n    HEADERS += SysInfoWindowsImpl.h \n} \n\nlinux { \n    SOURCES += SysInfoLinuxImpl.cpp \n    HEADERS += SysInfoLinuxImpl.h \n} \n\nFORMS    += MainWindow.ui \n\n```", "```cpp\n#include \"SysInfo.h\" \n\n#include <QtGlobal> \n#include <QVector> \n\nclass SysInfoMacImpl : public SysInfo \n{ \npublic: \n    SysInfoMacImpl(); \n\n    void init() override; \n    double cpuLoadAverage() override; \n    double memoryUsed() override; \n}; \n\n```", "```cpp\n#include <mach/vm_statistics.h> \n#include <mach/mach_types.h> \n#include <mach/mach_init.h> \n#include <mach/mach_host.h> \n#include <mach/vm_map.h> \n\nSysInfoMacImpl::SysInfoMacImpl() : \n    SysInfo() \n{ \n\n} \n\ndouble SysInfoMacImpl::memoryUsed() \n{ \n    vm_size_t pageSize; \n    vm_statistics64_data_t vmStats; \n\n    mach_port_t machPort = mach_host_self(); \n    mach_msg_type_number_t count = sizeof(vmStats)  \n                                  / sizeof(natural_t); \n    host_page_size(machPort, &pageSize); \n\n    host_statistics64(machPort, \n                      HOST_VM_INFO, \n                      (host_info64_t)&vmStats, \n                      &count); \n\n    qulonglong freeMemory = (int64_t)vmStats.free_count  \n                            * (int64_t)pageSize; \n\n    qulonglong totalMemoryUsed = ((int64_t)vmStats.active_count + \n                             (int64_t)vmStats.inactive_count + \n                             (int64_t)vmStats.wire_count)  \n                             * (int64_t)pageSize; \n\n    qulonglong totalMemory = freeMemory + totalMemoryUsed; \n\n    double percent = (double)totalMemoryUsed  \n                     / (double)totalMemory * 100.0; \n    return qBound(0.0, percent, 100.0); \n} \n\n```", "```cpp\n// In SysInfoMacImpl.h \n#include \"SysInfo.h\" \n\n#include <QtGlobal> \n#include <QVector> \n\n... \n\nprivate: \n    QVector<qulonglong> cpuRawData(); \n\nprivate: \n    QVector<qulonglong> mCpuLoadLastValues; \n}; \n\n// In SysInfoMacImpl.cpp \nvoid SysInfoMacImpl::init() \n{ \n    mCpuLoadLastValues =  cpuRawData(); \n} \n\nQVector<qulonglong> SysInfoMacImpl::cpuRawData() \n{ \n    host_cpu_load_info_data_t cpuInfo; \n    mach_msg_type_number_t cpuCount = HOST_CPU_LOAD_INFO_COUNT; \n    QVector<qulonglong> rawData; \n    qulonglong totalUser = 0, totalUserNice = 0, totalSystem = 0,           totalIdle = 0; \n    host_statistics(mach_host_self(), \n                    HOST_CPU_LOAD_INFO, \n                    (host_info_t)&cpuInfo, \n                    &cpuCount); \n\n    for(unsigned int i = 0; i < cpuCount; i++) { \n        unsigned int maxTicks = CPU_STATE_MAX * i; \n        totalUser += cpuInfo.cpu_ticks[maxTicks + CPU_STATE_USER]; \n        totalUserNice += cpuInfo.cpu_ticks[maxTicks  \n                                           + CPU_STATE_SYSTEM]; \n        totalSystem += cpuInfo.cpu_ticks[maxTicks  \n                                           + CPU_STATE_NICE]; \n        totalIdle += cpuInfo.cpu_ticks[maxTicks + CPU_STATE_IDLE]; \n    } \n\n    rawData.append(totalUser); \n    rawData.append(totalUserNice); \n    rawData.append(totalSystem); \n    rawData.append(totalIdle); \n    return rawData; \n} \n\n```", "```cpp\n... \n\nlinux { \n    SOURCES += SysInfoLinuxImpl.cpp \n    HEADERS += SysInfoLinuxImpl.h \n} \n\nmacx { \n    SOURCES += SysInfoMacImpl.cpp \n    HEADERS += SysInfoMacImpl.h \n} \n\nFORMS    += MainWindow.ui \n\n```", "```cpp\nclass SysInfo \n{ \npublic: \n    static SysInfo& instance(); \n    virtual ~SysInfo(); \n\n    virtual void init() = 0; \n    virtual double cpuLoadAverage() = 0; \n    virtual double memoryUsed() = 0; \n\nprotected: \n    explicit SysInfo(); \n\nprivate: \n    SysInfo(const SysInfo& rhs); \n    SysInfo& operator=(const SysInfo& rhs); \n}; \n\n```", "```cpp\n#include <QtGlobal> \n\n#ifdef Q_OS_WIN \n    #include \"SysInfoWindowsImpl.h\" \n#elif defined(Q_OS_MAC) \n    #include \"SysInfoMacImpl.h\" \n#elif defined(Q_OS_LINUX) \n    #include \"SysInfoLinuxImpl.h\" \n#endif \n\nSysInfo& SysInfo::instance() \n{ \n    #ifdef Q_OS_WIN \n        static SysInfoWindowsImpl singleton; \n    #elif defined(Q_OS_MAC) \n        static SysInfoMacImpl singleton; \n    #elif defined(Q_OS_LINUX) \n        static SysInfoLinuxImpl singleton; \n    #endif \n\n    return singleton; \n} \n\nSysInfo::SysInfo() \n{ \n} \n\nSysInfo::~SysInfo() \n{ \n} \n\n```", "```cpp\n#include <QWidget> \n#include <QTimer> \n#include <QtCharts/QChartView> \n\nclass SysInfoWidget : public QWidget \n{ \n    Q_OBJECT \npublic: \n    explicit SysInfoWidget(QWidget *parent = 0, \n                           int startDelayMs = 500, \n                           int updateSeriesDelayMs = 500); \n\nprotected: \n    QtCharts::QChartView& chartView(); \n\nprotected slots: \n    virtual void updateSeries() = 0; \n\nprivate: \n    QTimer mRefreshTimer; \n    QtCharts::QChartView mChartView; \n}; \n\n```", "```cpp\n#include <QVBoxLayout> \n\nusing namespace QtCharts; \n\nSysInfoWidget::SysInfoWidget(QWidget *parent, \n                             int startDelayMs, \n                             int updateSeriesDelayMs) : \n    QWidget(parent), \n    mChartView(this) \n{ \n    mRefreshTimer.setInterval(updateSeriesDelayMs); \n    connect(&mRefreshTimer, &QTimer::timeout, \n            this, &SysInfoWidget::updateSeries); \n    QTimer::singleShot(startDelayMs,  \n        [this] { mRefreshTimer.start(); }); \n\n    mChartView.setRenderHint(QPainter::Antialiasing); \n    mChartView.chart()->legend()->setVisible(false); \n\n    QVBoxLayout* layout = new QVBoxLayout(this); \n    layout->addWidget(&mChartView); \n    setLayout(layout); \n} \n\nQChartView& SysInfoWidget::chartView() \n{ \n    return mChartView; \n} \n\n```", "```cpp\n#include \"SysInfoWidget.h\" \n\nclass CpuWidget : public SysInfoWidget \n{ \npublic: \n    explicit CpuWidget(QWidget* parent = 0); \n}; \n\n```", "```cpp\n#include <QtCharts/QpieSeries> \n\n#include \"SysInfoWidget.h\" \n\nclass CpuWidget : public SysInfoWidget \n{ \n    Q_OBJECT \npublic: \n    explicit CpuWidget(QWidget* parent = 0); \n\nprotected slots: \n    void updateSeries() override; \n\nprivate: \n    QtCharts::QPieSeries* mSeries; \n}; \n\n```", "```cpp\nusing namespace QtCharts; \n\nCpuWidget::CpuWidget(QWidget* parent) : \n    SysInfoWidget(parent), \n    mSeries(new QPieSeries(this)) \n{ \n    mSeries->setHoleSize(0.35); \n    mSeries->append(\"CPU Load\", 30.0); \n    mSeries->append(\"CPU Free\", 70.0); \n\n    QChart* chart = chartView().chart(); \n    chart->addSeries(mSeries); \n    chart->setTitle(\"CPU average load\"); \n} \n\n```", "```cpp\n// In MainWindow.h \n#include \"CpuWidget.h\" \n\n... \n\nprivate: \n    Ui::MainWindow *ui; \n    CpuWidget mCpuWidget; \n}; \n\n// In MainWindow.cpp \nMainWindow::MainWindow(QWidget *parent) : \n    QMainWindow(parent), \n    ui(new Ui::MainWindow), \n    mCpuWidget(this) \n{ \n    ui->setupUi(this); \n    SysInfo::instance().init(); \n    ui->centralWidget->layout()->addWidget(&mCpuWidget); \n} \n\n```", "```cpp\nvoid CpuWidget::updateSeries() \n{ \n    double cpuLoadAverage = SysInfo::instance().cpuLoadAverage(); \n    mSeries->clear(); \n    mSeries->append(\"Load\", cpuLoadAverage); \n    mSeries->append(\"Free\", 100.0 - cpuLoadAverage); \n} \n\n```", "```cpp\n#include <QtCharts/QLineSeries> \n\n#include \"SysInfoWidget.h\" \n\nclass MemoryWidget : public SysInfoWidget \n{ \n    Q_OBJECT \npublic: \n    explicit MemoryWidget(QWidget *parent = 0); \n\nprotected slots: \n    void updateSeries() override; \n\nprivate: \n    QtCharts::QLineSeries* mSeries; \n    qint64 mPointPositionX; \n}; \n\n```", "```cpp\n#include \"MemoryWidget.h\" \n#include <QtCharts/QAreaSeries> \n\nusing namespace QtCharts; \n\nconst int CHART_X_RANGE_COUNT = 50; \nconst int CHART_X_RANGE_MAX = CHART_X_RANGE_COUNT - 1; \n\nMemoryWidget::MemoryWidget(QWidget *parent) : \n    SysInfoWidget(parent), \n    mSeries(new QlineSeries(this)), \n    mPointPositionX(0) \n{ \n    QAreaSeries* areaSeries = new QAreaSeries(mSeries); \n\n    QChart* chart = chartView().chart(); \n    chart->addSeries(areaSeries); \n    chart->setTitle(\"Memory used\"); \n    chart->createDefaultAxes(); \n    chart->axisX()->setVisible(false); \n    chart->axisX()->setRange(0, CHART_X_RANGE_MAX); \n    chart->axisY()->setRange(0, 100); \n} \n\nvoid MemoryWidget::updateSeries() \n{ \n} \n\n```", "```cpp\nvoid MemoryWidget::updateSeries() \n{ \n    double memoryUsed = SysInfo::instance().memoryUsed(); \n    mSeries->append(mPointPositionX++, memoryUsed); \n    if (mSeries->count() > CHART_X_RANGE_COUNT) { \n        QChart* chart = chartView().chart(); \n        chart->scroll(chart->plotArea().width()  \n                      / CHART_X_RANGE_MAX, 0); \n        mSeries->remove(0); \n    } \n} \n\n```", "```cpp\n// In MainWindow.h \n#include \"CpuWidget.h\" \n#include \"MemoryWidget.h\" \n\n... \n\nprivate: \n    Ui::MainWindow *ui; \n    CpuWidget mCpuWidget; \n    MemoryWidget mMemoryWidget; \n}; \n\n// In MainWindow.cpp \nMainWindow::MainWindow(QWidget *parent) : \n    QMainWindow(parent), \n    ui(new Ui::MainWindow), \n    mCpuWidget(this), \n    mMemoryWidget(this) \n{ \n    ui->setupUi(this); \n    SysInfo::instance().init(); \n    ui->centralWidget->layout()->addWidget(&mCpuWidget); \n    ui->centralWidget->layout()->addWidget(&mMemoryWidget); \n} \n\n```", "```cpp\n#include <QtCharts/QAreaSeries> \n#include <QLinearGradient> \n#include <QPen> \n\n#include \"SysInfo.h\" \n\nusing namespace QtCharts; \n\nconst int CHART_X_RANGE_MAX = 50; \nconst int COLOR_DARK_BLUE = 0x209fdf; \nconst int COLOR_LIGHT_BLUE = 0xbfdfef; \nconst int PEN_WIDTH = 3; \n\nMemoryWidget::MemoryWidget(QWidget *parent) : \n    SysInfoWidget(parent), \n    mSeries(new QLineSeries(this)) \n{ \n    QPen pen(COLOR_DARK_BLUE); \n    pen.setWidth(PEN_WIDTH); \n\n    QLinearGradient gradient(QPointF(0, 0), QPointF(0, 1)); \n    gradient.setColorAt(1.0, COLOR_DARK_BLUE); \n    gradient.setColorAt(0.0, COLOR_LIGHT_BLUE); \n    gradient.setCoordinateMode(QGradient::ObjectBoundingMode); \n\n    QAreaSeries* areaSeries = new QAreaSeries(mSeries); \n    areaSeries->setPen(pen); \n    areaSeries->setBrush(gradient); \n\n    QChart* chart = chartView().chart(); \n    ... \n} \n\n```", "```cpp\n#------------------------------------------------- \n# \n# Project created by QtCreator 2016-03-24T16:25:01 \n# \n#------------------------------------------------- \nQT += core gui charts \nCONFIG += C++14 \n\ngreaterThan(QT_MAJOR_VERSION, 4): QT += widgets \n\nTARGET = ch02-sysinfo \nTEMPLATE = app \n\n```", "```cpp\nwindows { \n    SOURCES += SysInfoWindowsImpl.cpp \n    HEADERS += SysInfoWindowsImpl.h \n} \n\n```", "```cpp\nwindows { \n    SOURCES += SysInfoWindowsImpl.cpp \n    HEADERS += SysInfoWindowsImpl.h \n\n    debug { \n        SOURCES += DebugClass.cpp \n        HEADERS += DebugClass.h \n    } \n} \n\n```", "```cpp\nwindows|unix { \n  SOURCES += SysInfoWindowsAndLinux.cpp \n} \n\n```", "```cpp\nwindows|unix { \n  SOURCES += SysInfoWindowsAndLinux.cpp \n} else:macx { \n  SOURCES += SysInfoMacImpl.cpp \n} else { \n  SOURCES += UltimateGenericSources.cpp \n} \n\n```", "```cpp\nCOMPILE_MSG = \"Compiling on\" \n\nwindows { \n    SOURCES += SysInfoWindowsImpl.cpp \n    HEADERS += SysInfoWindowsImpl.h \n    message($$COMPILE_MSG windows) \n} \n\nlinux { \n    SOURCES += SysInfoLinuxImpl.cpp \n    HEADERS += SysInfoLinuxImpl.h \n    message($$COMPILE_MSG linux) \n} \n\nmacx { \n    SOURCES += SysInfoMacImpl.cpp \n    HEADERS += SysInfoMacImpl.h \n    message($$COMPILE_MSG mac) \n} \n\n```", "```cpp\nwindows:message($$COMPILE_MSG windows) \n\n```", "```cpp\n/path/to/qt/installation/5.7/gcc_64/bin/qmake -makefile -o Makefile /path/to/sysinfoproject/ch02-sysinfo.pro\n\n```", "```cpp\n$ ls -1\nch02-sysinfo\nCpuWidget.o\nmain.o\nMainWindow.o\nMakefile\nMemoryWidget.o\nmoc_CpuWidget.cpp\nmoc_CpuWidget.o\nmoc_MainWindow.cpp\nmoc_MainWindow.o\nmoc_MemoryWidget.cpp\nmoc_MemoryWidget.o\nmoc_SysInfoWidget.cpp\nmoc_SysInfoWidget.o\nSysInfoLinuxImpl.o\nSysInfo.o\nSysInfoWidget.o\nui_MainWindow.h\n\n```", "```cpp\n#define Q_OBJECT \\ \npublic: \\ \n    // skipped details \n    static const QMetaObject staticMetaObject; \\ \n    virtual const QMetaObject *metaObject() const; \\ \n    virtual void *qt_metacast(const char *); \\ \n    virtual int qt_metacall(QMetaObject::Call, int, void **); \\ \n    QT_TR_FUNCTIONS \\ \nprivate: \\ \n    // skipped details  \nqt_static_metacall(QObject *, QMetaObject::Call, int, void **); \n\n```", "```cpp\n#     define slots \n#     define signals public \n\n```", "```cpp\n# define emit \n\n```", "```cpp\nstruct Connection \n    { \n        QObject *sender; \n        QObject *receiver; \n        union { \n            StaticMetaCallFunction callFunction; \n            QtPrivate::QSlotObjectBase *slotObj; \n        }; \n        // The next pointer for the singly-linked ConnectionList \n        Connection *nextConnectionList; \n        //senders linked list \n        Connection *next; \n        Connection **prev; \n        ... \n    }; \n\n```"]