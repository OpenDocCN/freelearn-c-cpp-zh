- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rendering Many Lights with Clustered Deferred Rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, our scene has been lit by a single point light. While this has worked
    fine so far as we focused our attention more on laying the foundations of our
    rendering engine, it’s not a very compelling and realistic use case. Modern games
    can have hundreds of lights in a given scene, and it’s important that the lighting
    stage is performed efficiently and within the budget of a frame.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will first describe the most common techniques that are
    used both in deferred and forward shading. We will highlight the pros and cons
    of each technique so that you can determine which one best fits your needs.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are going to provide an overview of our G-buffer setup. While the G-buffer
    has been in place from the very beginning, we haven’t covered its implementation
    in detail. This is a good time to go into more detail, as the choice of a deferred
    renderer will inform our strategy for clustered lighting.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we are going to describe our clustering algorithm in detail and highlight
    the relevant sections of the code. While the algorithm itself is not too complex,
    there are a lot of details that are important to get a stable solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: A brief history of clustered lighting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our G-buffer setup and implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing clustered lighting using screen tiles and Z-binning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By the end of the chapter you will have a solid understanding of our G-buffer
    implementation. You will also learn how to implement a state of the art light
    clustering solution that can handle hundreds of lights.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for this chapter can be found at the following URL: [https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan/tree/main/source/chapter7](https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan/tree/main/source/chapter7).'
  prefs: []
  type: TYPE_NORMAL
- en: A brief history of clustered lighting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to explore the background of how clustered lighting
    came to be and how it has evolved over the years.
  prefs: []
  type: TYPE_NORMAL
- en: In real-time applications, until the early 2000s, the most common way to handle
    lighting was by using the so-called **forward rendering**, a technique that renders
    each object on the screen with all the information needed, including light information.
    The problem with this approach is that it would limit the number of lights that
    could be processed to a low number, such as 4 or 8, a number that in the early
    2000s would be enough.
  prefs: []
  type: TYPE_NORMAL
- en: 'The concept of Deferred Rendering, and more specifically, shading the same
    pixel only once, was already pioneered by Michael Deering and colleagues in a
    seminal paper called *The triangle processor and normal vector shader: a VLSI
    system for high performance graphics* in 1988, even though the term *deferred*
    was still not used.'
  prefs: []
  type: TYPE_NORMAL
- en: Another key concept, the **G-buffer**, or **geometric buffer**, was pioneered
    by Takafumi Saito and Tokiichiro Takahashi in another pioneering paper, *Comprehensible
    Rendering of 3D Shapes*. In this paper, the authors cache depth and normals for
    each pixel to post-process the image – in this case, to add visual aids and comprehensibility
    to the image.
  prefs: []
  type: TYPE_NORMAL
- en: Although the first commercial game with a deferred renderer was *Shrek* in 2001
    on the original Xbox, it became increasingly popular with the game *Stalker* and
    its accompanying paper, *Deferred Shading in Stalker* ([https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-9-deferred-shading-stalker](https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-9-deferred-shading-stalker)),
    and exploded in popularity with the CryEngine presentation at Siggraph 2010 called
    *Reaching the Speed of* *Light* ([http://advances.realtimerendering.com/s2010/Kaplanyan-CryEngine3%28SIGGRAPH%202010%20Advanced%20RealTime%20Rendering%20Course%29.pdf](http://advances.realtimerendering.com/s2010/Kaplanyan-CryEngine3%28SIGGRAPH%202010%20Advanced%20RealTime%20Rendering%20Course%29.pdf)).
  prefs: []
  type: TYPE_NORMAL
- en: In the late 2000s/early 2010s, Deferred Rendering was all the rage, and basically,
    all engines were implementing some variations of it.
  prefs: []
  type: TYPE_NORMAL
- en: Forward rendering made a comeback in 2012 when AMD launched a demo called *Leo*
    in which, thanks to the new *Compute Shaders* technology, they introduced the
    light list for each screen space tile and created *Forward+*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The AMD Leo paper can be found here: [https://takahiroharada.files.wordpress.com/2015/04/forward_plus.pdf](https://takahiroharada.files.wordpress.com/2015/04/forward_plus.pdf).'
  prefs: []
  type: TYPE_NORMAL
- en: 'A few weeks after that paper, the first commercial game to use Forward+ was
    *Dirt Showdown*, but only the PC version, as consoles still did not have support
    for APIs that would help in that area: [https://web.archive.org/web/20210621112015/https://www.rage3d.com/articles/gaming/codemaster_dirt_showdown_tech_review/](https://web.archive.org/web/20210621112015/https://www.rage3d.com/articles/gaming/codemaster_dirt_showdown_tech_review/).'
  prefs: []
  type: TYPE_NORMAL
- en: With this, the Forward+ technology came back into usage, as the light limitations
    were gone, and it added a lot of algorithmic exploration in different areas (such
    as post-process anti-aliasing for a deferred depth prepass).
  prefs: []
  type: TYPE_NORMAL
- en: In the following years, more refined subdivision algorithms were developed,
    with tiles becoming clusters and moving from simple 2D screen space tiles to fully
    frustum-shaped 3D clusters.
  prefs: []
  type: TYPE_NORMAL
- en: This became famous with the *Just Cause 3* paper by Emil Persson, [https://www.humus.name/Articles/PracticalClusteredShading.pdf](https://www.humus.name/Articles/PracticalClusteredShading.pdf),
    and the concept was further enhanced by others for both deferred and forward rendering
    ([https://www.cse.chalmers.se/~uffe/clustered_shading_preprint.pdf](https://www.cse.chalmers.se/~uffe/clustered_shading_preprint.pdf)).
  prefs: []
  type: TYPE_NORMAL
- en: Clustering has been a great idea, but the memory consumption of having a 3D
    grid can be big, especially with the increasing rendering resolutions.
  prefs: []
  type: TYPE_NORMAL
- en: The current state of the art of clustering comes from Activision, which is our
    chosen solution, and we will see it in detail in the *Implementing light clusters*
    section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have provided a brief historical overview of real-time light rendering
    techniques, we are going to go into more depth about the differences between forward
    and Deferred Rendering in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Differences between forward and deferred techniques
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After talking about the history of forward and Deferred Rendering techniques,
    we want to highlight the key differences and talk about their common problem:
    **light assignment**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The main advantages of forward rendering are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Total freedom when rendering materials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Same rendering path for opaque and transparent objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for **Multi Sampled** **Anti-Aliasing** (**MSAA**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lower memory bandwidth within the GPU
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The main disadvantages of forward rendering are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A depth prepass could be necessary to reduce the number of fragments shaded.
    Without this preprocessing step, scenes that contain a large number of objects
    could waste a lot of processing time by shading fragments for objects that are
    not visible. For this reason, a pass that only writes to the depth buffer is executed
    at the beginning of a frame.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `depth-test` function is then set to equal so that only the fragments for
    the visible objects will be shaded. Depending on the complexity of your scene,
    this pre-pass could be expensive, and in some cases, simplified geometry is used
    to reduce the cost of this pass at the expense of slightly less accurate results.
    You must also be careful and ensure that the Early-Z test is not disabled in the
    graphics pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: This happens when writing to the depth buffer from a fragment shader or when
    a fragment shader contains a discard instruction.
  prefs: []
  type: TYPE_NORMAL
- en: The complexity of shading a scene is the number of objects (*N*) multiplied
    by the number of lights (*L*). All the lights must be processed for each object
    as we don’t know in advance which lights affect a given fragment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shaders become increasingly more complex, having to do a lot of operations and
    thus having a very high GPU register pressure (number of registers used), impacting
    performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deferred Rendering (sometimes referred to as **deferred shading**) was introduced
    primarily to decouple the rendering of the geometry and the light computations.
    In Deferred Rendering, we create multiple render targets. Usually, we have a render
    target for albedo, normals, PBR parameters (roughness, metalness, and occlusion
    – see [*Chapter 2*](B18395_02.xhtml#_idTextAnchor030), *Improving Resources Management,*
    for more details), and depth.
  prefs: []
  type: TYPE_NORMAL
- en: Once these render targets have been created, for each fragment we process the
    lights in the scene. We still have the same problem as before, since we still
    don’t know which lights affect a given shader; however, our scene complexity has
    gone from *N x L* to *N +* *L*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main advantages of deferred shading are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Decreased shading complexity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No need for a depth pre-pass
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Less complex shaders, as writing information on the G-buffer and processing
    lights are separate operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, there are some disadvantages to this approach, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**High memory usage**: We listed three render targets that have to be stored
    in memory. With increasing resolutions of modern games, these start to add up,
    especially when more render targets are needed for other techniques – for example,
    motion vectors for **Temporal Anti-Aliasing** (**TAA**), which will be discussed
    in a later chapter. For this reason, developers tend to compress some of this
    data, which helps to reduce the amount of memory required by the G-buffer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Loss of normals precision**: Normals are usually encoded as full floats (or
    possibly as 16-bit floats) as part of the geometry. To save memory when writing
    the normals render target, these values get compressed to 8 bits, significantly
    reducing the accuracy of these values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To further reduce memory usage, developers take advantage of the fact that normals
    are normalized. This allows us to store only two values and reconstruct the third.
    There are other techniques that can be used to compress normals, which will be
    referenced in the *Further reading* section. We will explain in detail the one
    we use in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Transparent objects need a separate pass and need to be shaded using a forward
    technique.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special materials need to have all their parameters packed into the G-buffer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you probably noticed, one problem is common to both techniques: we have
    to go through all the lights when processing an individual object or fragment.
    We are now going to describe the two most common techniques that are used to solve
    this issue: tiles and clusters.'
  prefs: []
  type: TYPE_NORMAL
- en: Light tiles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One approach to reducing the number of lights processed for a given fragment
    is to create a grid in screen space and determine which lights affect a given
    tile. When rendering the scene, we determine which tile the fragment we are shading
    belongs to and we iterate only over the lights that cover that tile.
  prefs: []
  type: TYPE_NORMAL
- en: The following figure shows the debug visualization for a light in the scene
    (the green sphere) and the screen area that it covers (in yellow). We will use
    this data to determine which tiles are affected by a given light.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – The area covered by a point light in screen space](img/B8395_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – The area covered by a point light in screen space
  prefs: []
  type: TYPE_NORMAL
- en: Building the tiles can be done on the CPU or with a compute shader on the GPU.
    Tile data can be stored in a flat array; we will explain this data structure in
    more detail later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Traditional light tiles require a depth pre-pass to determine the minimum and
    maximum *Z* values. This approach can suffer from depth discontinuities; however,
    the final data structure is usually densely packed, meaning we are not wasting
    memory.
  prefs: []
  type: TYPE_NORMAL
- en: Light clusters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Light clusters subdivide the frustum in a 3D grid. As for tiles, lights are
    assigned to each cell, and at render time, we only iterate over the lights that
    a given fragment belongs to.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure illustrates the shape of the clusters for one of the camera
    axes. Each cluster is composed of a smaller frustum:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – The frustum clusters covered by a point light](img/B8395_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – The frustum clusters covered by a point light
  prefs: []
  type: TYPE_NORMAL
- en: Lights can be stored in a 3D grid (a 3D texture, for instance) or more complex
    data structures – for example, a **Bounded Volume Hierarchy** (**BVH**) or octree.
  prefs: []
  type: TYPE_NORMAL
- en: To build light clusters, we don’t need a depth pre-pass. Most implementations
    build **Axis Aligned Bounding Boxes** (**AABBs**) for each light and project them
    into clip space. This approach allows easy 3D lookups and, depending on the amount
    of memory that can be allocated for the data structure, it’s possible to achieve
    quite accurate results.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have highlighted the advantages and disadvantages of both
    forward and Deferred Rendering. We have introduced tiling and clustering techniques
    that can help reduce the number of lights that need to be processed for each fragment.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to provide an overview of our G-buffer implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a G-buffer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From the beginning of this project, we decided we would implement a deferred
    renderer. It’s one of the more common approaches, and some of the render targets
    will be needed in later chapters for other techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: The first step in setting up multiple render targets in Vulkan is to create
    the framebuffers – the textures that will store the G-buffer data – and the render
    pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This step is automated, thanks to the frame graph (see [*Chapter 4*](B18395_04.xhtml#_idTextAnchor064)*,
    Implementing a Frame Graph*, for details); however, we want to highlight our use
    of a new Vulkan extension that simplifies render pass and framebuffer creation.
    The extension is `VK_KHR_dynamic_rendering`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This extension has become part of the core specification in Vulkan 1.3, so it’s
    possible to omit the `KHR` suffix on the data structures and API calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this extension, we don’t have to worry about creating the render pass
    and framebuffers ahead of time. We’ll start by analyzing the changes required
    when creating a pipeline:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have to populate a `VkPipelineRenderingCreateInfoKHR` structure with the
    number of attachments we are going to use and their format. We also need to specify
    the depth and stencil formats, if used.
  prefs: []
  type: TYPE_NORMAL
- en: Once this structure has been filled, we chain it to the `VkGraphicsPipelineCreateInfo`
    structure. When using this extension we don’t populate the `VkGraphicsPipelineCreateInfo::renderPass`
    member.
  prefs: []
  type: TYPE_NORMAL
- en: 'At render time, instead of calling `vkCmdBeginRenderPass`, we call a new API,
    `vkCmdBeginRenderingKHR`. We start by creating an array to hold our `attachments`
    details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we populate each entry with the details of each attachment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have to fill a similar data structure for the `depth` attachment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we fill the `VkRenderingInfoKHR` structure that will be passed to
    `vkCmdBeginRenderingKHR`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once we are done rendering, we are going to call `vkCmdEndRenderingKHR` instead
    of `vkCmdEndRenderPass`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have set up our render targets, we are going to describe how they
    are used in our G-buffer shader. Our G-buffer has four render targets plus the
    depth buffer. As we mentioned in the previous section, there is no need for a
    depth pre-pass, although you might notice this was enabled in some of the earlier
    chapters for testing purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to declare multiple outputs in the fragment shader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The location index must correspond to the order in which the attachments have
    been specified when calling `vkCmdBeginRenderingKHR` (or when creating the render
    pass and framebuffer objects). Writing to a given render target is done simply
    by writing to one of the variables we just declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: As we mentioned in the previous section, we must be conscious of memory usage.
    As you might have noticed, we only store two channels for normals. We use an octahedral
    encoding that allows storing only two values. We can reconstruct the full normal
    in the lighting pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the encoding function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the decoding function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table illustrates the data arrangement of our G-buffer pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 7.1 – G-buffer memory layout](img/B18395_07_Table_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 7.1 – G-buffer memory layout
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the screenshots for our render targets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – From top to bottom: albedo, normals, and combined occlusion
    (red), roughness (green), and metalness (blue)](img/B8395_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.3 – From top to bottom: albedo, normals, and combined occlusion (red),
    roughness (green), and metalness (blue)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We could probably reduce the number of render targets further: we know that
    in the G-buffer pass, we are only shading opaque objects, so we don’t need the
    alpha channel. Also, nothing prevents us from mixing data for different render
    targets – for instance, we could have something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`r`, `g`, `b`, and `normal_1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`normal_2`, `roughness`, `metalness`, and `occlusion`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`emissive`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can also try to use different texture formats (**R11G11B10**, for example)
    to increase the accuracy of our data. We encourage you to experiment with different
    solutions and find the one that works best for your use case!
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have introduced a new Vulkan extension that simplifies the
    creation and use of the render pass and framebuffer. We also provided details
    on the implementation of our G-buffer and highlighted potential optimizations.
    In the next section, we are going to look at the light clustering solution that
    we have implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing light clusters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to describe our implementation of the light clustering
    algorithm. It’s based on this presentation: [https://www.activision.com/cdn/research/2017_Sig_Improved_Culling_final.pdf](https://www.activision.com/cdn/research/2017_Sig_Improved_Culling_final.pdf).
    The main (and very smart) idea is to separate the *XY* plane from the *Z* range,
    combining the advantages of both tiling and clustering approaches. The algorithms
    are organized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We sort the lights by their depth value in camera space.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then divide the depth range into bins of equal size, although a logarithmic
    subdivision might work better depending on your depth range.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we assign the lights to each bin if their bounding box falls within the
    bin range. We only store the minimum and maximum light index for a given bin,
    so we only need 16 bits for each bin, unless you need more than 65,535 lights!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then divide the screen into tiles (8x8 pixels, in our case) and determine
    which lights cover a given tile. Each tile will store a bitfield representation
    for the active lights.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Given a fragment that we want to shade, we determine the depth of the fragment
    and read the bin index.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we iterate from the minimum to the maximum light index in that bin
    and read the corresponding tile to see whether the light is visible, this time
    using *x* and *y* coordinates to retrieve the tile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This solution provides a very efficient way to loop through the active lights
    for a given fragment.
  prefs: []
  type: TYPE_NORMAL
- en: CPU lights assignment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll now look at the implementation. During each frame, we perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by sorting the lights by their depth value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We compute the minimum and maximum point of the light sphere from the camera’s
    point of view. Notice that we use a closer `far` depth plane to gain precision
    in the depth range.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid having to sort the light list, we only sort the light indices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This optimization allows us to upload the light array only once, while we only
    need to update the light indices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we proceed with the tile assignment. We start by defining our bitfield
    array and some helper variables that will be used to compute the index within
    the array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE133]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then transform the light position in camera space:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE135]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE137]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE138]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE139]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE140]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE141]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE142]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE143]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE144]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE145]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE146]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE147]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE148]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE149]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the light is behind the camera, we don’t do any further processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we compute the corners of the AABB projected to clip space:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE151]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE152]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE153]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE154]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE155]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE156]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE157]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE158]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE159]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE160]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE161]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE162]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE163]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE164]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE165]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE166]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE167]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE168]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE169]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE170]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE171]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE172]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then proceed to determine the size of the quad in screen space:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE174]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE175]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE176]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE177]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE178]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE179]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE180]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE181]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE182]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE183]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE184]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE185]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE186]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE187]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE188]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE189]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE190]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE191]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE192]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE193]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE194]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE195]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE196]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the light is not visible on the screen, we move to the next light.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final step is to set the bit for the light we are processing on all the
    tiles it covers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE198]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE199]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE200]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE201]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE202]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE203]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE204]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE205]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE206]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE207]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE208]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE209]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE210]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE211]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE212]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE213]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE214]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE215]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE216]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We then upload all the light tiles and bin data to the GPU.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of this computation, we will have a bin table containing the minimum
    and maximum light ID for each depth slice. The following table illustrates an
    example of the values for the first few slices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 7.2 – Example of the data contained in the depth bins](img/B18395_07_Table_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 7.2 – Example of the data contained in the depth bins
  prefs: []
  type: TYPE_NORMAL
- en: 'The other data structure we computed is a 2D array, where each entry contains
    a bitfield tracking the active lights for the corresponding screen tile. The following
    table presents an example of the content of this array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 7.3 – Example of the bitfield values tracking the active lights per
    tile](img/B18395_07_Table_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 7.3 – Example of the bitfield values tracking the active lights per tile
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we have divided the screen into a 4x4 grid, and each
    tile entry has a bit set for every light that covers that tile. Note that each
    tile entry can be composed of multiple 32-bit values depending on the number of
    lights in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we provided an overview of the algorithm we have implemented
    to assign lights to a given cluster. We then detailed the steps to implement the
    algorithm. In the next section, we are going to use the data we have just obtained
    to process lights on the GPU.
  prefs: []
  type: TYPE_NORMAL
- en: GPU light processing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have all the data we need on the GPU, we can use it in our lighting
    computation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by determining which depth bin our fragment belongs to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE218]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE219]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE220]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE221]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE222]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE223]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE224]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE225]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We extract the minimum and maximum light index, as they are going to be used
    in the light computation loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE227]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE228]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE229]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE230]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We first determine the address in the tile bitfield array. Next, we check whether
    there are any lights in this depth bin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE232]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE233]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If `max_light_id` is `0`, it means we didn’t store any lights in this bin,
    so no lights will affect this fragment. Next, we loop over the lights for this
    depth bin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE235]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE236]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE237]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After we compute the word and bit index, we determine which lights from the
    depth bin also cover the screen tile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE239]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE240]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE241]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE242]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE243]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE244]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE245]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE246]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE247]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE248]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE249]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE250]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE251]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This concludes our light clustering algorithm. The shader code also contains
    an optimized version that makes use of the subgroup instructions to improve register
    utilization. There are plenty of comments to explain how it works.
  prefs: []
  type: TYPE_NORMAL
- en: We covered a fair amount of code in this section, so don’t worry if some things
    were not clear on the first read. We started by describing the steps of the algorithm.
    We then explained how the lights are sorted in depth bins and how we determine
    the lights that cover a given tile on the screen. Finally, we showed how these
    data structures are used in the lighting shader to determine which lights affect
    a given fragment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that this technique can be used both in forward and Deferred Rendering.
    Now that we have a performant lighting solution, one element is sorely missing
    from our scene: shadows! This will be the topic for the next chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have implemented a light clustering solution. We started
    by explaining forward and Deferred Rendering techniques and their main advantages
    and shortcomings. Next, we described two approaches to group lights to reduce
    the computation needed to shade a single fragment.
  prefs: []
  type: TYPE_NORMAL
- en: We then outlined our G-buffer implementation by listing the render targets that
    we use. We detailed our use of the `VK_KHR_dynamic_rendering` extension, which
    allows us to simplify the render pass and framebuffer use. We also highlighted
    the relevant code in the G-buffer shader to write to multiple render targets,
    and we provided the implementation for our normal encoding and decoding. In closing,
    we suggested some optimizations to further reduce the memory used by our G-buffer
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: In the last section, we described the algorithm we selected to implement light
    clustering. We started by sorting the lights by their depth value into depth bins.
    We then proceeded to store the lights that affect a given screen tile using a
    bitfield array. Finally, we made use of these two data structures in our lighting
    shader to reduce the number of lights that need to be evaluated for each fragment.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing the lighting stage of any game or application is paramount to maintaining
    interactive frame rates. We described one possible solution, but other options
    are available, and we suggest you experiment with them to find the one that best
    suits your use case!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have added many lights, the scene still looks flat as there''s
    one important element missing: shadows. That''s the topic for the next chapter!'
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some history about the first Deferred Rendering in the *Shrek* game, 2001:
    [https://sites.google.com/site/richgel99/the-early-history-of-deferred-shading-and-lighting](https://sites.google.com/site/richgel99/the-early-history-of-deferred-shading-and-lighting)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Stalker Deferred Rendering paper: [https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-9-deferred-shading-stalker](https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-9-deferred-shading-stalker)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is one of the first papers that introduced the concept of clustered shading:
    [http://www.cse.chalmers.se/~uffe/clustered_shading_preprint.pdf](http://www.cse.chalmers.se/~uffe/clustered_shading_preprint.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These two presentations are often cited as the inspiration for many implementations:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.activision.com/cdn/research/2017_Sig_Improved_Culling_final.pdf](https://www.activision.com/cdn/research/2017_Sig_Improved_Culling_final.pdf)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.humus.name/Articles/PracticalClusteredShading.pdf](http://www.humus.name/Articles/PracticalClusteredShading.pdf)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, we only covered point lights, but in practice, many other
    types of lights are used (spotlights, area lights, polygonal lights, and a few
    others). This article describes a way to determine the visibility of a spotlight
    approximated by a cone:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://bartwronski.com/2017/04/13/cull-that-cone/](https://bartwronski.com/2017/04/13/cull-that-cone/)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These presentations describe variants of the clustering techniques we described
    in this chapter:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.intel.com/content/dam/develop/external/us/en/documents/lauritzen-deferred-shading-siggraph-2010-181241.pdf](https://www.intel.com/content/dam/develop/external/us/en/documents/lauritzen-deferred-shading-siggraph-2010-181241.pdf)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://advances.realtimerendering.com/s2016/Siggraph2016_idTech6.pdf](https://advances.realtimerendering.com/s2016/Siggraph2016_idTech6.pdf)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.ea.com/frostbite/news/parallel-graphics-in-frostbite-current-future](https://www.ea.com/frostbite/news/parallel-graphics-in-frostbite-current-future)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
