- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Atomic Operations
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原子操作
- en: In [*Chapter 4*](B22219_04.xhtml#_idTextAnchor074) , we learned about lock-based
    thread synchronization. We learned about mutexes, condition variables, and other
    thread synchronization primitives, which are all based on acquiring and releasing
    locks. Those synchronization mechanisms are built on top of *atomic types and
    operations* , this chapter’s topic.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](B22219_04.xhtml#_idTextAnchor074)中，我们学习了基于锁的线程同步。我们学习了互斥锁、条件变量以及其他基于锁的线程同步原语，这些都是基于获取和释放锁的。这些同步机制建立在*原子类型和操作*之上，这是本章的主题。
- en: We will study what atomic operations are and how they differ from lock-based
    synchronization primitives. After reading this chapter, you will have a basic
    knowledge of atomic operations and some of their applications. Lock-free (not
    using locks) synchronization based on atomic operations is a very complex subject
    requiring years to master, but we will give you what we hope will be a good introduction
    to the subject.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将研究原子操作是什么，以及它们与基于锁的同步原语有何不同。阅读完本章后，你将具备原子操作的基本知识以及它们的一些应用。基于原子操作的锁免费（不使用锁）同步是一个非常复杂的话题，需要多年的时间来掌握，但我们将为你提供一个我们希望对主题有良好介绍的入门。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: What are atomic operations?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是原子操作？
- en: An introduction to the C++ memory model
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++内存模型简介
- en: What atomic types and operations are provided by the C++ Standard Library?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++标准库提供了哪些原子类型和操作？
- en: Some examples of atomic operations, from a simple counter to be used to gather
    statistics and a basic mutex-like lock to a full **single-producer-single-consumer**
    ( **SPSC** ) lock-free bounded queue
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些原子操作的示例，从用于收集统计信息的简单计数器到一个基本的类似互斥锁的全**单生产者单消费者**（**SPSC**）无锁有界队列
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will need a recent C++ compiler with C++20 support. Some short code examples
    will be provided as links to the very useful godbolt website ( [https://godbolt.org](https://godbolt.org)
    ). For full code examples, we will use the book repo, which is available at [https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP](https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP)
    .
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一个支持C++20的较新版本的C++编译器。一些简短的代码示例将通过链接到非常有用的godbolt网站（[https://godbolt.org](https://godbolt.org)）提供。对于完整的代码示例，我们将使用书籍仓库，该仓库可在[https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP](https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP)找到。
- en: The examples can be compiled and run locally. We have tested the code on an
    Intel CPU computer running Linux (Ubuntu 24.04 LTS). For atomic operations and
    especially for memory ordering (more on this later in this chapter), Intel CPUs
    are different from Arm CPUs.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 示例可以在本地编译和运行。我们已经在运行Linux（Ubuntu 24.04 LTS）的Intel CPU计算机上测试了代码。对于原子操作，尤其是内存排序（关于这一点将在本章后面详细说明），Intel
    CPU与Arm CPU不同。
- en: Please note here that code performance and profiling will be the subject of
    [*Chapter 13*](B22219_13.xhtml#_idTextAnchor267) . We will just make some remarks
    on performance in this chapter to avoid making it unnecessarily long.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此处代码性能和性能分析将是[第13章](B22219_13.xhtml#_idTextAnchor267)的主题。我们将在本章中仅对性能做一些简要说明，以避免使内容过于冗长。
- en: Introduction to atomic operations
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原子操作简介
- en: Atomic operations are indivisible (hence the word atomic, from the Greek *ἄτομος*
    , *atomos* , indivisible).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 原子操作是不可分割的（因此得名原子，源自希腊语*ἄτομος*，*atomos*，不可分割）。
- en: In this section, we will introduce atomic operations, what they are, and some
    reasons to use (and not to use!) them.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍原子操作，它们是什么，以及使用（以及不使用！）它们的一些原因。
- en: Atomic operations versus non-atomic operations – an example
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原子操作与非原子操作——示例
- en: 'If you remember the simple counter example from [*Chapter 4*](B22219_04.xhtml#_idTextAnchor074)
    , we needed to use a synchronization mechanism (we used a mutex) for modifying
    the counter variable from different threads to avoid race conditions. The cause
    of the race condition was that incrementing the counter required three operations:
    reading the counter value, incrementing it, and writing the modified counter value
    back to memory. If only we could do that in one go, there would be no race condition.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得[第4章](B22219_04.xhtml#_idTextAnchor074)中的简单计数器示例，我们需要使用同步机制（我们使用了互斥锁）来修改计数器变量，以避免竞态条件。竞态条件的原因是增加计数器需要三个操作：读取计数器值，增加它，并将修改后的计数器值写回内存。如果我们能一次性完成这些操作，就不会有竞态条件。
- en: 'This is exactly what could be achieved with an atomic operation: if we had
    some kind of **atomic_increment** operation, each thread would read, increment,
    and write the counter in a single instruction, avoiding the race condition because
    at any time, incrementing the counter would be fully done. By fully done we mean
    that each thread would either increment the counter or do nothing at all, making
    interruptions in the middle of a counter increment operation impossible.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是原子操作所能实现的效果：如果我们有一种**atomic_increment**操作，每个线程都会在一个指令中读取、增加并写入计数器，从而避免竞争条件，因为在任何时刻，增加计数器都会被完全完成。当我们说完全完成时，意味着每个线程要么增加计数器，要么什么都不做，使得在计数器增加操作中途的中断成为不可能。
- en: The following two examples are for illustration purposes only and are not multithreaded.
    We focus here on just the operations, whether atomic or non-atomic.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个示例仅用于说明目的，并且不是多线程的。我们在这里只关注操作，无论是原子的还是非原子的。
- en: 'Let’s see this in the code. For the C++ code and the generated assembly language
    shown in the following example, refer to [https://godbolt.org/z/f4dTacsKW](https://godbolt.org/z/f4dTacsKW)
    :'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在代码中看看这个。对于以下示例中的C++代码和生成的汇编语言，请参考[https://godbolt.org/z/f4dTacsKW](https://godbolt.org/z/f4dTacsKW)
    ：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The code increments a global counter. Now let’s see the assembly code generated
    by the compiler and what instructions the CPU executes (the full assembly can
    be found in the previous link):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 代码增加了一个全局计数器。现在让我们看看编译器生成的汇编代码以及CPU执行了哪些指令（完整的汇编代码可以在之前的链接中找到）：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**[1]** copies the value stored in **counter** to the **eax** register, **[2]**
    adds **1** to the value stored in **eax** , and finally, **[3]** copies back the
    content of the **eax** register to the **counter** variable. So, a thread could
    execute **[1]** and then be scheduled out, and another thread execute all three
    instructions after that. When the first thread finishes incrementing the result,
    the counter will be incremented just once and thus the result will be incorrect.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**[1]** 将存储在**counter**中的值复制到**eax**寄存器，**[2]** 将存储在**eax**中的值增加**1**，最后，**[3]**
    将**eax**寄存器的内容复制回**counter**变量。因此，一个线程可以执行**[1]**然后被调度出去，而另一个线程在之后执行所有三个指令。当第一个线程完成增加结果后，计数器只会增加一次，因此结果将是错误的。'
- en: 'The following code does the same: it increments a global counter. This time,
    though, it uses atomic types and operations. To get the code and the generated
    assembly in the following example, refer to [https://godbolt.org/z/9hrbo31vx](https://godbolt.org/z/9hrbo31vx)
    :'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码执行相同的操作：它增加了一个全局计数器。不过，这次它使用了原子类型和操作。要获取以下示例中的代码和生成的汇编代码，请参考[https://godbolt.org/z/9hrbo31vx](https://godbolt.org/z/9hrbo31vx)：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We will explain the **std::atomic<int>** type and the atomic increment operation
    later.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面解释**std::atomic<int>**类型和原子增加操作。
- en: 'The generated assembly code is the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的汇编代码如下：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Just one instruction has been generated to add **1** to the value stored in
    the **counter** variable. The **lock** prefix here means that the following instruction
    (in this case **add** ) is going to be executed atomically. Hence, in this second
    example, a thread cannot be interrupted in the middle of incrementing the counter.
    As a side note, some Intel x64 instructions execute atomically and don’t use the
    **lock** prefix.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 只生成了一条指令来将**counter**变量中的值增加**1**。这里的**lock**前缀意味着接下来的指令（在这种情况下是**add**）将被原子执行。因此，在这个第二个示例中，一个线程在增加计数器过程中不能被中断。作为旁注，一些Intel
    x64指令是原子执行的，并且不使用**lock**前缀。
- en: Atomic operations allow threads to read, modify (for example, increase a value),
    and write indivisibly, and can also be used as synchronization primitives (similar
    to the mutexes we saw in [*Chapter 4*](B22219_04.xhtml#_idTextAnchor074) ). In
    fact, all the lock-based synchronization primitives we have seen so far in this
    book are implemented using atomic operations. Atomic operations must be provided
    by the CPU (as in the **lock** **add** instruction).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 原子操作允许线程以不可分割的方式读取、修改（例如，增加一个值）和写入，也可以用作同步原语（类似于我们在[*第4章*](B22219_04.xhtml#_idTextAnchor074)中看到的互斥锁）。实际上，我们在这本书中看到的所有基于锁的同步原语都是使用原子操作实现的。原子操作必须由CPU提供（如**lock**
    **add**指令）。
- en: In this section, we have introduced atomic operations, defined what they are,
    and studied a very simple example of how they are implemented by looking at the
    assembly instructions that the compiler generates. In the next section, we will
    look at some of the advantages and disadvantages of atomic operations.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了原子操作，定义了它们是什么，并研究了通过查看编译器生成的汇编指令来实现的非常简单的例子。在下一节中，我们将探讨原子操作的一些优缺点。
- en: When to use (and when not to use) atomic operations
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用（以及何时不使用）原子操作
- en: Using atomic operations is a complex subject and it can be very difficult (or
    at least quite tricky) to master. It requires a lot of experience, and we have
    attended some courses on this very subject where we were advised not to do it!
    Anyway, you can always learn the basics and experiment as you do so. We hope this
    book will help you progress in your learning journey.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用原子操作是一个复杂的话题，它可能非常困难（或者至少相当棘手）要掌握。这需要大量的经验，我们参加了一些关于这个主题的课程，并被建议不要这样做！无论如何，您总是可以学习基础知识并在实践中进行实验。我们希望这本书能帮助您在学习之旅中取得进步。
- en: 'Atomic operations can be used in the following cases:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 原子操作可以在以下情况下使用：
- en: '**If multiple threads share a mutable state** : The need to synchronize threads
    is the most common case. Of course, it is possible to use locks such as mutexes,
    but atomic operations, in some cases, will provide better performance. Please
    note, however, that the use of atomic operations *does not* guarantee better performance.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如果多个线程共享可变状态**：需要同步线程的情况最为常见。当然，可以使用互斥锁等锁，但在某些情况下，原子操作将提供更好的性能。请注意，然而，使用原子操作*并不*保证更好的性能。'
- en: '**If synchronized access to shared state is fine-grained** : If the data we
    must synchronize is an integer or a pointer or any other variable of a C++ intrinsic
    type, then using atomic operations may be better than using locks.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如果对共享状态的同步访问是细粒度的**：如果我们必须同步的数据是一个整数、指针或任何其他C++内建类型的变量，那么使用原子操作可能比使用锁更好。'
- en: '**To improve performance** : If you want to achieve maximum performance, then
    atomic operations can help reduce thread context switches (see [*Chapter 2*](B22219_02.xhtml#_idTextAnchor035)
    ) and reduce the overhead introduced by locks, thus lowering latency. Remember
    to always profile your code to be sure that performance is improved (we will see
    this in depth in [*Chapter 13*](B22219_13.xhtml#_idTextAnchor267) ).'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**为了提高性能**：如果您想达到最大性能，那么原子操作可以帮助减少线程上下文切换（参见[*第2章*](B22219_02.xhtml#_idTextAnchor035)）并减少锁引入的开销，从而降低延迟。请记住，始终对代码进行性能分析以确保性能得到提升（我们将在[*第13章*](B22219_13.xhtml#_idTextAnchor267)中深入探讨）。'
- en: 'Locks can be used in the following cases:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 锁可以在以下情况下使用：
- en: '**If the protected data is not fine-grained** : For example, we are synchronizing
    access to a data structure or an object bigger than 8 bytes (in modern CPUs).'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如果受保护的数据不是细粒度的**：例如，我们正在同步访问一个大于8字节（在现代CPU上）的数据结构或对象。'
- en: '**If performance is not an issue** : Locks are much simpler to use and reason
    about (in some cases using locks gives better performance than using atomic operations).'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如果性能不是问题**：锁的使用和推理要简单得多（在某些情况下，使用锁比使用原子操作性能更好）。'
- en: '**To avoid the need to acquire low-level knowledge** : To get the maximum performance
    out of atomic operations, a lot of low-level knowledge is required. We will introduce
    some of it in the section, *The C++* *memory model* .'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**为了避免需要获取底层知识**：要从原子操作中获得最大性能，需要大量的底层知识。我们将在“*C++内存模型*”部分介绍其中的一些内容。'
- en: We have just learned when to use and when not to use atomic operations. Some
    applications such as low-latency/high-frequency trading systems require maximum
    performance and use atomic operations to achieve the lowest latency possible.
    Most applications will work just fine synchronizing with locks.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚学习了何时使用原子操作以及何时不使用。一些应用程序，如低延迟/高频交易系统，需要最大性能并使用原子操作以实现最低的延迟。大多数应用程序通过锁同步将正常工作。
- en: In the next section, we will study the differences between blocking and non-blocking
    data structures and some related concept definitions.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将研究阻塞和非阻塞数据结构之间的差异以及一些相关概念的定义。
- en: Non-blocking data structures
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非阻塞数据结构
- en: In [*Chapter 4*](B22219_04.xhtml#_idTextAnchor074) we studied the implementation
    of a synchronized queue. We used mutexes and condition variables as synchronization
    primitives. Data structures synchronized with locks are called **blocking data
    structures** because threads are *blocked* (by the operating system), waiting
    until the locks become available.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第4章*](B22219_04.xhtml#_idTextAnchor074)中，我们研究了同步队列的实现。我们使用了互斥锁和条件变量作为同步原语。与锁同步的数据结构被称为**阻塞数据结构**，因为线程会被操作系统*阻塞*（等待锁变为可用）。
- en: Data structures that don’t use locks are called **non-blocking data structures**
    . Most (but not all) of them are lock-free.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 不使用锁的数据结构被称为**非阻塞数据结构**。大多数（但并非所有）都是无锁的。
- en: A data structure or algorithm is considered lock-free if each synchronized action
    completes in a finite number of steps, not allowing indefinite waiting for a condition
    to become true or false.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每个同步操作都在有限步骤内完成，不允许无限期等待条件变为真或假，则数据结构或算法被认为是无锁的。
- en: 'The types of lock-free data structures are the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 无锁数据结构的类型如下：
- en: '**Obstruction-free** : A thread will complete its operation in a bounded number
    of steps if all other threads are suspended'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无阻塞**：如果所有其他线程都处于挂起状态，则线程将在有限步骤内完成其操作。'
- en: '**Lock-free** : A thread will complete its operation in a bounded number of
    steps while multiple threads are working on the data structure'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无锁**：在多个线程同时工作在数据结构上时，线程将在有限步骤内完成其操作。'
- en: '**Wait-free** : All the threads will complete their operations in a bounded
    number of steps while multiple threads are working on the data structure'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无等待**：在多个线程同时工作在数据结构上时，所有线程将在有限步骤内完成其操作。'
- en: 'Implementing lock-free data structures is very complicated and before doing
    it, we need to be sure it’s necessary. The reasons to use lock-free data structures
    are the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 实现无锁数据结构非常复杂，在实施之前，我们需要确保这是必要的。使用无锁数据结构的原因如下：
- en: '**Achieving maximum concurrency** : As we saw earlier, atomic operations are
    a good choice when the data access synchronization involves fine-grained data
    (such as native-type variables). From the preceding definitions, a lock-free data
    structure will allow at least one of the threads accessing the data structure
    to make some progress in a bounded number of steps. A wait-free structure will
    allow all the threads accessing the data structure to make some progress.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现最大并发性**：如我们之前所看到的，当数据访问同步涉及细粒度数据（如原生类型变量）时，原子操作是一个很好的选择。根据前面的定义，无锁数据结构将允许至少一个访问数据结构的线程在有限步骤内取得一些进展。无等待结构将允许所有访问数据结构的线程在有限步骤内取得一些进展。'
- en: When we use locks, however, a thread owns the lock while the rest of the threads
    are just waiting for the lock to be available, so the concurrency achievable with
    lock-free data structures can be much better.
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，当我们使用锁时，一个线程会拥有锁，而其他线程则只是在等待锁变为可用，因此无锁数据结构可实现的并发性可以更好。
- en: '**No deadlocks** : Because there are no locks involved, it is impossible to
    have any deadlocks in our code.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无死锁**：因为没有涉及锁，所以我们的代码中不可能有任何死锁。'
- en: '**Performance** : Some applications must achieve the lowest latency possible
    and so waiting for a lock can be unacceptable. When a thread tries to acquire
    the lock, and it is not available, then the operating system blocks the thread.
    While the thread is blocked, there is a context switch for the scheduler to be
    able to schedule another thread for execution. These context switches take time,
    and that time may be too much in a low-latency application such as a high-performance
    network packet receiver/processor.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：某些应用程序必须实现尽可能低的延迟，因此等待锁可能是不可以接受的。当线程尝试获取锁，而锁不可用时，操作系统会阻塞该线程。在线程被阻塞期间，调度器需要进行上下文切换以能够调度另一个线程进行执行。这些上下文切换需要时间，而在低延迟应用程序（如高性能网络数据包接收/处理器）中，这些时间可能太多。'
- en: We have now looked at what blocking and non-blocking data structures are and
    what lock-free code is. We will introduce the C++ memory model in the next section.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经了解了阻塞和非阻塞数据结构是什么，以及无锁代码是什么。在下一节中，我们将介绍C++内存模型。
- en: The C++ memory model
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++内存模型
- en: 'This section explains the C++ memory model and how it deals with concurrency.
    The C++ memory model comes with C++11, and defines the two main features of memory
    in C++:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了C++内存模型及其如何处理并发。C++内存模型从C++11开始引入，并定义了C++内存的两大主要特性：
- en: How objects are laid out in memory (that is, structural aspects). This subject
    won’t be covered in this book, which is about asynchronous programming.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象在内存中的布局（即结构方面）。这个主题不会在本书中介绍，因为本书是关于异步编程的。
- en: Memory modification order (that is, concurrency aspects). We will see the different
    memory modification orders specified in the memory model.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存修改顺序（即并发方面）。我们将看到内存模型中指定的不同内存修改顺序。
- en: Memory access order
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存访问顺序
- en: 'Before we explain the C++ memory model and the different memory orderings it
    supports, let’s clarify what we mean by memory order. Memory order refers to the
    order in which memory (that is, the variables in a program) is accessed. Memory
    access can be either read or write (load and store). But what is the actual order
    in which the variables of a program are accessed? For the following code, there
    are three points of view: the written code order, the compiler-generated instructions
    order, and finally, the order in which the instructions are executed by the CPU.
    These three orderings can all be the same or (more likely) different.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们解释C++内存模型及其支持的不同的内存排序之前，让我们明确我们所说的内存排序是什么。内存排序指的是内存（即程序中的变量）被访问的顺序。内存访问可以是读取或写入（加载和存储）。但是，程序变量的实际访问顺序是什么？对于以下代码，有三个观点：所写的代码顺序、编译器生成的指令顺序，最后是CPU执行指令的顺序。这三个排序都可以相同，或者（更可能）不同。
- en: 'The first and obvious ordering is the one in the code. An example of this is
    in the following code snippet:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种和最明显的排序是代码中的排序。以下代码片段是一个例子：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The **func_a** function first adds 1 to variable **a** , then adds 10 to variable
    **b** , and finally, adds 2 to variable **a** . This is our intention and the
    order in which we define the statements to be executed.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**func_a**函数首先将1加到变量**a**上，然后加10到变量**b**上，最后将2加到变量**a**上。这是我们想要的方式，也是我们定义要执行语句的顺序。'
- en: The compiler will transform the preceding code into assembly instructions. The
    compiler can change the order of our statements to make the generated code more
    efficient if the outcome of the code execution is unchanged. For example, with
    the preceding code, the compiler could either do the two additions with variable
    **a** first and then the addition with variable **b** , or it could simply add
    3 to **a** and then 10 to **b** . As we mentioned previously, the compiler can
    do whatever it wants to optimize the code if the result is the same.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器将前面的代码转换为汇编指令。如果代码执行的结果不变，编译器可以改变我们语句的顺序，以使生成的代码更高效。例如，对于前面的代码，编译器可以首先对变量**a**执行两个加法操作，然后对变量**b**执行加法操作，或者它可以直接将3加到**a**上，然后加10到**b**上。正如我们之前提到的，如果结果是相同的，编译器可以执行任何操作来优化代码。
- en: 'Let’s now consider the following code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑以下代码：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this case, the operation on **b** depends on the previous operation on **a**
    , so the compiler cannot reorder the statements, and the generated code will be
    like the code we write (same order of operations).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，对**b**的操作依赖于对**a**的先前操作，因此编译器不能重新排序语句，生成的代码将与我们所写的代码（操作顺序相同）一样。
- en: The CPU (which used in this book is a modern Intel x64 CPU) will run the generated
    code. It can execute the compiler-generated instructions in a different order.
    This is called out-of-order execution. The CPU can do this, again, if the result
    is correct.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: CPU（本书中使用的CPU是现代的Intel x64 CPU）将运行生成的代码。它可以以不同的顺序执行编译器生成的指令。这被称为乱序执行。如果结果是正确的，CPU可以再次这样做。
- en: 'See this link for the generated code shown in the preceding example: [https://godbolt.org/z/Mhrcnsr9e](https://godbolt.org/z/Mhrcnsr9e)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 有关前例中显示的生成代码的链接：[https://godbolt.org/z/Mhrcnsr9e](https://godbolt.org/z/Mhrcnsr9e)
- en: 'First, the generated instructions for **func_1** show an optimization: the
    compiler combined both additions into one by adding 3 to variable **a** in one
    instruction. Second, the generated instructions for **func_2** are in the same
    order as the C++ statements we wrote. In this case, the CPU could execute the
    instructions out of order, as there is no dependency among the operations.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为**func_1**生成的指令显示了优化：编译器通过在一个指令中将3加到变量**a**上，将两个加法操作合并为一个。其次，为**func_2**生成的指令与我们所写的C++语句的顺序相同。在这种情况下，CPU可以执行指令的乱序执行，因为操作之间没有依赖关系。
- en: To conclude, we can say that the code that the CPU will run can be different
    from the code we wrote (again, given that the result of the execution is the same
    as we intended in the program we wrote).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们可以这样说，CPU将要运行的代码可能与我们所写的代码不同（再次强调，前提是执行结果与我们在程序中预期的相同）。
- en: All the examples we have shown are fine for code that runs in a single thread.
    The code instructions may be executed in different order depending on the compiler
    optimizations and the CPU out-of-order execution and the result will still be
    correct.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所展示的所有示例都适用于单线程运行的代码。代码指令的执行顺序可能因编译器优化和CPU的乱序执行而不同，但结果仍然正确。
- en: 'See the following code for an example of out-of-order execution:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了乱序执行的示例：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The CPU could execute the instructions in the order shown in the preceding
    code, that is, **load var1 [1]** . Then, while the variable is being read, it
    could issue some of the later instructions, such as **[4]** and **[5]** , and
    then, once **var1** has been read, execute **[2]** , then **[3]** , and, finally,
    **[6]** . The instructions were executed in a different order, but the result
    is still the same. This is a typical example of out-of-order execution: the CPU
    issues a load instruction and instead of waiting for the data to become available,
    it executes some other instructions, if possible, to avoid being idle and to maximize
    performance.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: CPU可能会按照前面代码中显示的顺序执行指令，即**load var1 [1]**。然后，在变量被读取的同时，它可能会执行一些后续指令，例如**[4]**和**[5]**，然后，一旦**var1**被读取，执行**[2]**，然后**[3]**，最后，**[6]**。指令的执行顺序不同，但结果仍然是相同的。这是一个典型的乱序执行示例：CPU发出一个加载指令，而不是等待数据可用，它会执行一些其他指令，如果可能的话，以避免空闲并最大化性能。
- en: All the optimizations we have mentioned (both compiler and CPU) are always done
    without considering the interactions between threads. Neither the compiler nor
    the CPU knows about different threads. In these cases, we need to tell the compiler
    what it can and cannot do. Atomic operations and locks are the way to do this.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所提到的所有优化（包括编译器和CPU）都是在不考虑线程间交互的情况下进行的。编译器和CPU都不知道不同的线程。在这些情况下，我们需要告诉编译器它可以做什么，不可以做什么。原子操作和锁是实现这一点的途径。
- en: 'When, for example, we use atomic variables, we may not only require the operations
    to be atomic but also to follow a certain order for the code to work properly
    when running multiple threads. This cannot be done by just the compiler or the
    CPU because neither has any information involving multiple threads. To specify
    what order we want to use, the C++ memory model offers different options:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当例如我们使用原子变量时，我们可能不仅需要操作是原子的，还需要在多线程运行时遵循一定的顺序以确保代码能够正确工作。这不能仅仅通过编译器或CPU来完成，因为它们都没有涉及多个线程的信息。为了指定我们想要使用的顺序，C++内存模型提供了不同的选项：
- en: '**Relaxed** **ordering** : **std::memory_order_relaxed**'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**宽松** **排序** : **std::memory_order_relaxed**'
- en: '**Acquire and release ordering** : **std::memory_order_acquire** , **std::memory_order_release**
    , **std::memory_order_acq_rel** , and **std::memory_order_consume**'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**获取和释放排序** : **std::memory_order_acquire** , **std::memory_order_release**
    , **std::memory_order_acq_rel** , 和 **std::memory_order_consume**'
- en: '**Sequential consistency** **ordering** : **std::memory_order_seq_cst**'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顺序一致性** **排序** : **std::memory_order_seq_cst**'
- en: The C++ memory model defines an abstract machine to achieve independence from
    any specific CPU. However, the CPU is still there and the features available in
    the memory model may not be available to a specific CPU. For example, the Intel
    x64 architecture is quite restrictive and enforces quite a strong memory order.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: C++内存模型定义了一个抽象机以实现与任何特定CPU的独立性。然而，CPU仍然存在，内存模型中可用的功能可能不会适用于特定的CPU。例如，Intel x64架构相当限制性，并强制执行相当强的内存顺序。
- en: 'The Intel x64 architecture uses a processor-ordered memory-ordering model that
    can be defined as being *write-ordered with store-buffer forwarding* . In a single-processor
    system, the memory-ordering model respects the following principles:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Intel x64架构使用一个处理器排序的内存排序模型，可以定义为*写入排序并带有存储缓冲区转发*。在单处理器系统中，内存排序模型遵循以下原则：
- en: Reads are not reordered with any reads
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取不会与任何读取操作重排
- en: Writes are not reordered with any writes
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入不会与任何写入操作重排
- en: Writes are not reordered with older reads
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入不会与较旧的读取操作重排
- en: Reads may be reordered with older writes (if the read and write to be reordered
    refer to different memory locations)
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取可能与较旧的写入操作重排（如果要重排的读取和写入操作涉及不同的内存位置）
- en: Reads and writes are not reordered with locked ( atomic) instructions
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取和写入操作不会与锁定（原子）指令重新排序
- en: There are more details in the Intel manuals (see the references at the end of
    the chapter), but the preceding principles are the most relevant.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 更多详细信息请参阅英特尔手册（见本章末尾的参考文献），但前面的原则是最相关的。
- en: 'In a multi-processor system, the following principles apply:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在多处理器系统中，以下原则适用：
- en: Each of the individual processors uses the same ordering principles as in a
    single-processor system
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个单独的处理器使用与单处理器系统相同的序原则
- en: Writes by a single processor are observed in the same order by all processors
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个处理器的写入操作被所有处理器以相同的顺序观察到
- en: Writes from an individual processor are not ordered with respect to the writes
    from other processors
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自单个处理器的写入操作不会与其他处理器的写入操作进行排序
- en: Memory ordering obeys causality
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存序遵循因果关系
- en: Any two stores are seen in a consistent order by processors other than those
    performing the store
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了执行写入操作的处理器之外，任何两个存储操作都以一致的顺序被其他处理器观察到
- en: Locked (atomic) instructions have total order
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁定（原子）指令具有总序
- en: The Intel architecture is strongly ordered; the store operations (write instructions)
    for each processor are observed by other processors in the same order they were
    performed, and each processor executes the stores in the same order as they appear
    in the program. This is called **Total Store** **Ordering** ( **TSO** ).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔架构是强序的；每个处理器的存储操作（写指令）按照它们执行时的顺序被其他处理器观察到，并且每个处理器按照程序中出现的顺序执行存储操作。这被称为**总存储序**（**TSO**）。
- en: 'The ARM architecture supports **Weak Ordering** ( **WO** ). These are the main
    principles:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ARM架构支持**弱序**（**WO**）。以下是主要原则：
- en: Reads and writes can be performed out of order. In contrast to TSO where, as
    we have seen, there is no local reordering except of reads after writes to different
    addresses, the ARM architecture allows local reordering (unless otherwise specified
    using special instructions).
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取和写入可以无序执行。与TSO不同，正如我们所看到的，除了写入不同地址后的读取外，没有局部重新排序，ARM架构允许局部重新排序（除非使用特殊指令另行指定）。
- en: A write is not guaranteed to be visible to all threads at the same time as it
    was in the Intel architecture.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入操作不一定能像在英特尔架构中那样同时被所有线程看到。
- en: In general, this relatively non-restrictive memory ordering allows the cores
    to reorder instructions more freely, potentially increasing multicore performance.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，这种相对非限制性的内存序允许核心更自由地重新排序指令，从而可能提高多核性能。
- en: We must say here that the more relaxed the memory order is, the more difficult
    it is to reason about the executed code, and the more challenging it becomes to
    correctly synchronize multiple threads with atomic operations. Also, you should
    bear in mind that the atomicity is always guaranteed irrespective of the memory
    order.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在这里说明，内存序越宽松，对执行代码的推理就越困难，正确同步多个线程使用原子操作就变得更加具有挑战性。此外，您应该记住，无论内存序如何，原子性总是得到保证。
- en: In this section, we have seen what is meant by order when accessing memory and
    how the ordering we specify in the code may not be the same order in which the
    CPU executes the code. In the next section, we will see how to enforce some ordering
    using atomic types and operations.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经了解了访问内存时序的含义以及我们在代码中指定的序可能与CPU执行代码的序不同。在下一节中，我们将看到如何使用原子类型和操作强制某些序。
- en: Enforcing ordering
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 强制序
- en: We have seen already in [*Chapter 4*](B22219_04.xhtml#_idTextAnchor074) and
    earlier in this chapter that non-atomic operations on the same memory addresses
    executed from different threads may cause data races and undefined behavior. To
    enforce the ordering of the operations between threads, we will use atomic types
    and their operations. This section will explore what the use of atomics achieves
    in multithreaded code.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[*第4章*](B22219_04.xhtml#_idTextAnchor074)以及本章前面的内容中看到，来自不同线程的同一内存地址上的非原子操作可能会导致数据竞争和未定义的行为。为了强制线程间操作的序，我们将使用原子类型及其操作。本节将探讨原子在多线程代码中的使用所达到的效果。
- en: 'The following simple example will help us to see what can be done with atomic
    operations:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下简单的示例将帮助我们了解可以使用原子操作做什么：
- en: '[PRE7]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, **reader()** waits until the **ready** variable is **true**
    and then prints a message set by **writer()** . The **writer()** function sets
    the message and then sets the **store** variable to **true** .
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，**reader()** 等待直到 **ready** 变量变为 **true**，然后打印由 **writer()** 设置的消息。**writer()**
    函数设置消息并将 **store** 变量设置为 **true**。
- en: 'Atomic operations provide us with two features for enforcing a certain order
    of execution in multithreaded code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 原子操作为我们提供了两个特性，用于在多线程代码中强制执行特定的执行顺序：
- en: '**Happens before** : In the preceding code, **[1]** (setting the **message**
    variable) happens before **[2]** (setting the atomic **ready** variable to **true**
    ). Also, **[3]** , reading the **ready** variable in a loop until it is **true**
    , happens before **[4]** , printing the message. In this case, we are using sequential
    consistency memory order (the default memory order).'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发生之前**：在先前的代码中，**[1]**（设置**message**变量）发生在**[2]**（将原子**ready**变量设置为**true**）之前。同样，**[3]**（在循环中读取**ready**变量直到其为**true**）发生在**[4]**（打印消息）之前。在这种情况下，我们使用顺序一致性内存顺序（默认内存顺序）。'
- en: '**Synchronizes with** : This only happens between atomic operations. In the
    preceding example, this means that when **ready** is set by **[1]** the value
    will be visible for subsequent reads (or writes) in different threads (of course,
    it is visible in the current thread), and when **ready** is read by **[3]** ,
    the changed value will be visible.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同步于**：这仅在原子操作之间发生。在先前的例子中，这意味着当**ready**由**[1]**设置时，其值将对后续不同线程中的读取（或写入）可见（当然，它对当前线程也是可见的），当**ready**由**[3]**读取时，更改后的值将可见。'
- en: Now that we have seen how atomic operations enforce memory access order from
    different threads, let’s see in detail each of the memory order options provided
    by the C++ memory model.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了原子操作如何强制从不同线程执行内存访问顺序，让我们详细看看C++内存模型提供的每个内存顺序选项。
- en: Before we start, let’s remember here that the Intel x64 architecture (Intel
    and AMD desktop processors) is quite restrictive in relation to memory order,
    that there is no need for any additional instructions for acquire/release, and
    sequential consistency is cheap in terms of performance cost.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，让我们在这里记住，英特尔x64架构（英特尔和AMD的桌面处理器）在内存顺序方面相当严格，不需要任何额外的acquire/release指令，并且顺序一致性在性能成本方面是低廉的。
- en: Sequential consistency
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 顺序一致性
- en: Sequential consistency guarantees the execution of the program in the way you
    wrote it. In 1979 Leslie Lamport defined sequential consistency as being “ *the
    result of an execution is the same as if the reads and writes occurred in some
    order, and the operations of each individual processor appear in this sequence
    in the order specified by* *its program.* ”
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 顺序一致性保证了程序按你编写的方式执行。在1979年，莱斯利·兰波特将顺序一致性定义为“*执行的结果与读取和写入发生某种顺序的结果相同，并且每个处理器的操作以*
    *其程序指定的顺序* *出现在这个序列中。*”
- en: In C++, sequential consistency is specified with the **std::memory_order_seq_cst**
    option. This is the most stringent memory order and it’s also the default one.
    If no ordering option is specified, then sequential consistency will be used.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，顺序一致性通过**std::memory_order_seq_cst**选项指定。这是最严格的内存顺序，也是默认的。如果没有指定顺序选项，则将使用顺序一致性。
- en: 'The C++ memory model by default ensures sequential consistency in the absence
    of race conditions within your code. Consider it a pact: if we properly synchronize
    our program to prevent race conditions, C++ will maintain the appearance that
    the program executes in the sequence it was written.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: C++的内存模型默认确保在代码中不存在竞态条件时保持顺序一致性。将其视为一种协议：如果我们正确同步我们的程序以防止竞态条件，C++将保持程序按编写顺序执行的表象。
- en: 'In this model, all threads must see the same order of operations. Operations
    can still be reordered as far as the visible result of the computation has the
    same result as the result of the unordered code. The instructions and operations
    can be reordered if the reads and writes are performed in the same order as in
    the compiled code. The CPU is free to reorder any other instructions between the
    reads and writes if the dependencies are satisfied. Because of the consistent
    ordering it defines, sequential consistency is the most intuitive form of ordering.
    To illustrate sequential consistency, let’s consider the following example:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在此模型中，所有线程必须看到相同的操作顺序。只要计算的可见结果与无序代码的结果相同，操作仍然可以重新排序。如果读取和写入的顺序与编译代码中的顺序相同，则指令和操作可以重新排序。如果满足依赖关系，CPU可以在读取和写入之间自由重新排序任何其他指令。由于它定义了一致的顺序，顺序一致性是最直观的排序形式。为了说明顺序一致性，让我们考虑以下示例：
- en: '[PRE8]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Because we are using **std::memory_order_seq_cst** when running the code, we
    should note the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在运行代码时使用 **std::memory_order_seq_cst**，我们应该注意以下事项：
- en: Operations in each thread are executed in the given order (no reordering of
    atomic operations).
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个线程中的操作按给定顺序执行（不重新排序原子操作）。
- en: '**t1** and **t2** update **x** and **y** in order, and **t3** and **t4** see
    the same order. Without this property, **t3** could see **x** and **y** change
    in order, but **t4** could see the opposite.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**t1** 和 **t2** 按顺序更新 **x** 和 **y**，而 **t3** 和 **t4** 看到相同的顺序。如果没有这个属性，**t3**
    可能会看到 **x** 和 **y** 的顺序变化，但 **t4** 可能会看到相反的顺序。'
- en: Any other ordering may print **This will never happen** because **t3** and **t4**
    could see the changes to **x** and **y** in the opposite order. We will see an
    example of this in the next section.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何其他排序都可能打印 **This will never happen**，因为 **t3** 和 **t4** 可能会看到 **x** 和 **y**
    的变化顺序相反。我们将在下一节中看到这个示例。
- en: 'The sequential consistency in this example means that the following two things
    will happen:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此例中的顺序一致性意味着以下两个事情将会发生：
- en: Each store is seen by all the threads; that is, each store operation synchronizes
    with all the load operations for each variable, and all the threads see these
    changes in the same order they are made
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个存储操作都被所有线程看到；也就是说，每个存储操作与每个变量的所有加载操作同步，所有线程以相同的顺序看到这些变化。
- en: The operations happen in the same order for each thread (operations run in the
    same order as in the code)
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个线程的操作顺序相同（操作顺序与代码中的顺序相同）
- en: Please note that the order between operations in different threads is not guaranteed
    and instructions from different threads may be executed in any order because the
    threads may be scheduled.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，不同线程中操作的顺序没有保证，并且来自不同线程的指令可能以任何顺序执行，因为线程可能被调度。
- en: Acquire-release ordering
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取-释放排序
- en: '**Acquire-release ordering** is less stringent than sequential consistency
    ordering. We don’t get the total ordering of operations we had with sequential
    consistency ordering, but some synchronization is still possible. In general,
    as we add more freedom to the memory ordering we may see a performance gain, but
    it will get more difficult to reason about the execution order of our code.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**获取-释放排序** 比顺序一致性排序更宽松。我们不会得到与顺序一致性排序相同的操作总顺序，但仍然可以进行一些同步。一般来说，随着我们增加内存排序的自由度，我们可能会看到性能提升，但推理代码的执行顺序将变得更加困难。'
- en: In this ordering model, the atomic load operations are the **std::memory_order_acquire**
    operations, the atomic store operations are the **std::memory_order_release**
    operations, and the atomic read-modify-write operations may be the **std::memory_order_acquire**
    , **std::memory_order_release** or **std::memory_order_acq_rel** operations.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在此排序模型中，原子加载操作是 **std::memory_order_acquire** 操作，原子存储操作是 **std::memory_order_release**
    操作，原子读-改-写操作可能是 **std::memory_order_acquire**、**std::memory_order_release** 或
    **std::memory_order_acq_rel** 操作。
- en: '**Acquire semantics** (used with **std::memory_order_acquire** ) ensure that
    all of the read or write operations in one thread that appear *after* the acquire
    operation in the source code happen after the acquire operation. This prevents
    the memory from reordering the reads and writes that follow the acquire operation.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**获取语义**（与 **std::memory_order_acquire** 一起使用）确保源代码中出现在获取操作之后的线程中的所有读取或写入操作都在获取操作之后发生。这防止内存重新排序获取操作之后的读取和写入。'
- en: '**Release semantics** (used with **std::memory_order_release** ) ensure that
    the read or write operations in one thread that appear *before* the release operation
    in the source code are completed before the release operation. This prevents the
    memory reordering of the reads and writes that follow the release operation.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**释放语义**（与**std::memory_order_release**一起使用）确保在源代码中的释放操作之前完成的读取或写入操作在释放操作之前完成。这防止了释放操作之后的读取和写入的内存重排。'
- en: 'The following example shows the same code as that shown in the previous section
    about sequential consistency, but in this case, we use the acquire-release memory
    order for the atomic operations:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了与上一节关于顺序一致性的示例相同的代码，但在此情况下，我们使用原子操作的获取-释放内存顺序：
- en: '[PRE9]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this case, it is possible for the value of **z** to be 0. Because we don’t
    have sequential consistency anymore after **t1** sets **x** to **true** and **t2**
    sets **y** to **true** , **t3** and **t4** may have different views of how memory
    access is being performed. Because of the use of the acquire-release memory ordering,
    **t3** may see **x** as **true** and **y** as **false** (remember, there is no
    enforce ordering) and **t4** may see **x** as **false** and **y** as **true**
    . When this happens, the value of **z** will be 0.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，**z**的值可能是0。因为我们不再具有顺序一致性，在**t1**将**x**设置为**true**和**t2**将**y**设置为**true**之后，**t3**和**t4**可能对内存访问的不同看法。由于使用了获取-释放内存排序，**t3**可能看到**x**为**true**和**y**为**false**（记住，没有强制排序），而**t4**可能看到**x**为**false**和**y**为**true**。当这种情况发生时，**z**的值将是0。
- en: Besides **std::memory_order_acquire** , **std::memory_order_release** , and
    **std::memory_order_acq_rel** , the acquire-release memory ordering also includes
    the **std::memory_order_consume** option. We won’t be describing it because according
    to the online C++ reference, “ *the specification of release-consume ordering
    is being revised, and the use of std::memory_order_consume is* *temporarily discouraged*
    .”
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 除了**std::memory_order_acquire**、**std::memory_order_release**和**std::memory_order_acq_rel**之外，获取-释放内存排序还包括**std::memory_order_consume**选项。我们不会对其进行描述，因为根据在线C++参考，“*释放-消费排序的规范正在修订，std::memory_order_consume的使用*
    *暂时不鼓励*。”
- en: Relaxed memory ordering
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 松弛内存排序
- en: To perform the atomic operation with **relaxed memory ordering** , we specify
    **std::memory_order_relaxed** as the memory order option.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行具有**松弛内存排序**的原子操作，我们将**std::memory_order_relaxed**指定为内存顺序选项。
- en: 'Relaxed memory ordering is the weakest form of synchronization. It offers two
    guarantees:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 松弛内存排序是最弱形式的同步。它提供两个保证：
- en: Atomicity of the operations.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作的原子性。
- en: Atomic operations on the same atomic variable in a single thread are not reordered.
    This is called **modification order consistency** . There is no guarantee, however,
    that the other threads will see these operations in the same order.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个线程中同一原子变量的原子操作不会被重排。这被称为**修改顺序一致性**。然而，没有保证其他线程将以相同的顺序看到这些操作。
- en: 'Let’s consider the following scenario: one thread ( **th1** ) stores values
    into an atomic variable. After a certain random interval of time, the variable
    will be overwritten with a new random value. We should assume for the sake of
    this example, that the sequence written is 2, 12, 23, 4, 6. Another thread, **th2**
    , reads the same variable periodically. The first time the variable is read, **th2**
    gets the value 23. Remember that the variable is atomic and that both load and
    store operations are done using the relaxed memory order.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下场景：一个线程（**th1**）将值存储到一个原子变量中。在一定的随机时间间隔后，该变量将被新的随机值覆盖。为了这个示例的目的，我们应该假设写入的顺序是2、12、23、4、6。另一个线程，**th2**，定期读取相同的变量。第一次读取变量时，**th2**得到值23。记住，该变量是原子的，并且加载和存储操作都是使用松弛内存顺序完成的。
- en: If **th2** reads the variable again, it can get the same value or any value
    written *after* the previously read value. It cannot read any value written before
    because the modification order consistency property would be violated. In the
    current example, the second read may get 23, 4, or 6 but not 2 or 12. If we get
    4, th1 will go on to write 8, 19, and 7. Now th2 may get 4, 6, 8, 19, or 7 but
    not any number before 4 and so on.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果**th2**再次读取该变量，它可以获取与之前读取的相同值或任何在之前读取值之后写入的值。它不能读取任何在之前写入的值，因为这会违反修改顺序一致性属性。在当前示例中，第二次读取可能得到23、4或6，但不能得到2或12。如果我们得到4，th1将继续写入8、19和7。现在th2可能得到4、6、8、19或7，但不能得到4之前的任何数字等等。
- en: Between two or more threads, there is no guarantee of any order, but once a
    value is read, a previously written value cannot be read.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个或多个线程之间，没有保证任何顺序，但一旦读取了一个值，就不能再读取之前写入的值。
- en: The relaxed model cannot be used to synchronize threads, because there is no
    visibility order guarantee, but it is useful in scenarios where operations do
    not need to be coordinated tightly between threads, which can lead to performance
    improvements.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 松弛模型不能用于线程同步，因为没有可见性顺序保证，但在操作不需要在线程之间紧密协调的场景中很有用，这可以提高性能。
- en: It is generally safe to use when the order of execution does not affect the
    correctness of the program, such as incrementing counters used for statistics
    or reference counters where the exact order of increment is not important.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行顺序不影响程序的正确性时，通常可以安全使用，例如用于统计的计数器或引用计数器，其中增量顺序的精确性并不重要。
- en: In this section, we learned about the C++ memory model and how it allows the
    order and synchronization of atomic operations with different memory order constraints.
    In the next section, we will see the atomic types and operations provided by the
    C++ Standard Library.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了 C++ 内存模型以及它是如何允许具有不同内存顺序约束的原子操作进行顺序和同步的。在下一节中，我们将看到 C++ 标准库提供的原子类型和操作。
- en: C++ Standard Library atomic types and operations
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++ 标准库原子类型和操作
- en: We will now introduce the data types and functions provided by the C++ Standard
    Library to support atomic types and operations. As we have already seen, an atomic
    operation is an indivisible operation. To be able to perform atomic operations
    in C++, we need to use the atomic types provided by the C++ Standard Library.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将介绍 C++ 标准库提供的支持原子类型和操作的数据类型和函数。正如我们已经看到的，原子操作是一个不可分割的操作。要在 C++ 中执行原子操作，我们需要使用
    C++ 标准库提供的原子类型。
- en: C++ Standard Library atomic types
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++ 标准库原子类型
- en: The atomic types provided by the C++ Standard Library are defined in the **<atomic>**
    header file.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 标准库提供的原子类型定义在 **<atomic>** 头文件中。
- en: You can see the documentation for all the atomic types defined in the **<atomic>**
    header in the online C++ reference, which you can access at [https://en.cppreference.com/w/cpp/atomic/atomic](https://en.cppreference.com/w/cpp/atomic/atomic)
    . We won’t include all the content in this reference here (that’s what the reference
    is for!), but we will introduce the main concepts and use examples to further
    elaborate our explanations.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在在线 C++ 参考中查看定义在 **<atomic>** 头文件中的所有原子类型的文档，你可以通过 [https://en.cppreference.com/w/cpp/atomic/atomic](https://en.cppreference.com/w/cpp/atomic/atomic)
    访问。我们不会在这里包含所有内容（这就是参考的作用！），但我们将介绍主要概念和使用示例，以进一步阐述我们的解释。
- en: 'The atomic types provided by the C++ Standard Library are the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 标准库提供的原子类型如下：
- en: '**std::atomic_flag** : Atomic Boolean type (but different from **std::atomic<bool>**
    ). It is the only atomic type that is guaranteed to be lock-free. It does not
    provide load or store operations. It is the most basic atomic type of all. We
    will use it to implement a very simple mutex-like lock.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**std::atomic_flag**：原子布尔类型（但与 **std::atomic<bool>** 不同）。它是唯一保证无锁的原子类型。它不提供加载或存储操作。它是所有原子类型中最基本的。我们将用它来实现一个非常简单的类似互斥锁的功能。'
- en: '**std::atomic<T>** : This is a template for defining atomic types. All the
    intrinsic types have their own corresponding atomic type defined using this template.
    The following are some examples of these types:'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**std::atomic<T>**：这是一个用于定义原子类型的模板。所有内建类型都使用此模板定义了自己的原子类型。以下是一些这些类型的示例：'
- en: '**std::atomic<bool>** (and its alias **atomic_bool** ): We will use this atomic
    type to implement the lazy one-time initialization of a variable from several
    threads.'
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**std::atomic<bool>**（及其别名 **atomic_bool**）：我们将使用此原子类型来实现从多个线程中懒加载变量的一次性初始化。'
- en: '**std::atomic<int>** (and its alias **atomic_int** ): We have seen this atomic
    type already in the simple counter example. We will use it again in an example
    to gather statistics (very similar to the counter example).'
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**std::atomic<int>**（及其别名 **atomic_int**）：我们已经在简单的计数器示例中看到了这个原子类型。我们将在另一个示例中使用它来收集统计数据（与计数器示例非常相似）。'
- en: '**std::atomic<intptr_t>** (and its alias **atomic_intptr_t** ).'
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**std::atomic<intptr_t>**（及其别名 **atomic_intptr_t**）。'
- en: 'C++20 introduced atomic smart pointers: **std::atomic<std::shared_ptr<U>>**
    and **std::atomic<std::weak_ptr<U>>** .'
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++20 引入了原子智能指针：**std::atomic<std::shared_ptr<U>>** 和 **std::atomic<std::weak_ptr<U>>**。
- en: Since the release of C++20, there is a new atomic type, **std::atomic_ref<T>**
    .
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自从 C++20 发布以来，出现了一种新的原子类型，**std::atomic_ref<T>** 。
- en: In this chapter, we will focus on **std::atomic_flag** and some of the **std::atomic**
    types. For the other atomic types we have mentioned here, you can access the online
    C++ reference using the previous link.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注 **std::atomic_flag** 和一些 **std::atomic** 类型。对于这里提到的其他原子类型，您可以使用之前的链接访问在线
    C++ 参考。
- en: 'Before any further explanation of some of these types, there is a very important
    clarification to be made: just because a type is *atomic* , that doesn’t guarantee
    it is *lock-free* . By atomic here, we mean indivisible operation, and by lock-free,
    we mean with special CPU atomic instructions support. If there is no hardware
    support for certain atomic operations, they will be implemented using locks by
    the C++ Standard Library.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在进一步解释这些类型之前，有一个非常重要的澄清需要做出：仅仅因为一个类型是 *原子* 的，并不能保证它是 *无锁* 的。在这里，我们所说的原子意味着不可分割的操作，而所说的无锁意味着有特殊的
    CPU 原子指令支持。如果没有硬件支持某些原子操作，C++ 标准库将使用锁来实现这些操作。
- en: 'To check whether an atomic type is lock-free we can use the following member
    function of any of the **std::atomic<T>** types:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查原子类型是否无锁，我们可以使用任何 **std::atomic<T>** 类型下的以下成员函数：
- en: '**bool is_lock_free() const noexcept** : This returns **true** if all the atomic
    operations of this type are lock-free, and **false** otherwise (except for **std::atomic_flag**
    , which is guaranteed to always be lock-free). The rest of the atomic types can
    be implemented using locks such as mutexes to guarantee the atomicity of the operations.
    Also, some atomic types may be lock-free only sometimes. If only aligned memory
    access can be lock-free in a certain CPU, then the misaligned objects of that
    same atomic type will be implemented using locks.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**bool is_lock_free() const noexcept**：如果此类型的所有原子操作都是无锁的，则返回 **true**，否则返回
    **false**（除了 **std::atomic_flag**，它保证始终是无锁的）。其余的原子类型可以使用锁（如互斥量）来实现以保证操作的原子性。此外，某些原子类型可能只在某些情况下是无锁的。如果某个
    CPU 只能无锁地访问对齐的内存，那么该原子类型的未对齐对象将使用锁来实现。'
- en: 'There is also a constant used to indicate whether an atomic type is always
    lock-free:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 也有一个常量用来指示原子类型是否始终无锁：
- en: '**static constexpr bool is_always_lock_free = /* implementation defined */**
    : The value of this constant will be **true** if the atomic type is always lock-free
    (even for misaligned objects, for example)'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态常量 bool is_always_lock_free = /* 实现定义 */**：如果原子类型始终是无锁的（例如，即使是未对齐的对象），则此常量的值将为
    **true**'
- en: 'It is important to be aware of this: an atomic type is not guaranteed to be
    lock-free. The **std::atomic<T>** template is not a magic mechanism that can turn
    all atomic types into lock-free atomic types.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要意识到这一点：原子类型不保证是无锁的。**std::atomic<T>** 模板不是一个可以将所有原子类型转换为无锁原子类型的魔法机制。
- en: C++ Standard Library atomic operations
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++ 标准库原子操作
- en: 'There are two main types of atomic operations:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 原子操作主要有两种类型：
- en: '**Member functions of atomic types** : For example, **std::atomic<int>** has
    the **load()** member function to atomically read its value'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原子类型的成员函数**：例如，**std::atomic<int>** 有一个 **load()** 成员函数用于原子地读取其值'
- en: '**Free functions** : The **const std::atomic_load(const std::atomic<T>* obj)**
    function does exactly the same as the previous one'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自由函数**：**const std::atomic_load(const std::atomic<T>* obj)** 函数与之前的函数完全相同'
- en: 'You can access the following code (and the generated assembly code, if you
    are interested) at [https://godbolt.org/z/Yhdr3Y1Y8](https://godbolt.org/z/Yhdr3Y1Y8)
    . This code shows the use of both member functions and free functions:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以访问以下代码（如果您感兴趣，还可以访问生成的汇编代码）在 [https://godbolt.org/z/Yhdr3Y1Y8](https://godbolt.org/z/Yhdr3Y1Y8)
    。此代码展示了成员函数和自由函数的使用：
- en: '[PRE10]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Most of the atomic operation functions have a parameter to indicate the memory
    order. We have already explained what the memory order is, and what memory ordering
    types are provided by C++ in the section about the C++ memory model.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数原子操作函数都有一个参数来指示内存顺序。我们已经在关于 C++ 内存模型的章节中解释了内存顺序是什么，以及 C++ 提供了哪些内存排序类型。
- en: Example – simple spin-lock implemented using the C++ atomic flag
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 - 使用 C++ 原子标志实现的简单自旋锁
- en: 'The **std::atomic_flag** atomic type is the most basic standard atomic type.
    It only has two states: set and not set (which we can also call true and false).
    It is always lock-free, in contrast to any other standard atomic type. Because
    it is so simple, it is mainly used as a building block.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**std::atomic_flag** 原子类型是最基本的标准原子类型。它只有两种状态：设置和未设置（我们也可以称之为 true 和 false）。它总是无锁的，与任何其他标准原子类型形成对比。因为它如此简单，所以主要用作构建块。'
- en: 'This is the code for the atomic flag example:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这是原子标志示例的代码：
- en: '[PRE11]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We need to initialize **std::atomic_flag** before using it. The following code
    shows how to do that:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用之前，我们需要初始化 **std::atomic_flag**。以下代码展示了如何进行初始化：
- en: '[PRE12]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is the only way to initialize **std::atomic_flag** to a definite value.
    The value of **ATOMIC_FLAG_INIT** is implementation defined.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这是初始化 **std::atomic_flag** 为确定值的唯一方法。**ATOMIC_FLAG_INIT** 的值是实现定义的。
- en: 'Once the flag is initialized, we can perform two atomic operations on it:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦标志被初始化，我们就可以对其执行两个原子操作：
- en: '**clear** : This atomically sets the flag to **false**'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**clear**：这个操作原子地将标志设置为 **false**'
- en: '**test_and_set** : This atomically sets the flag to **true** and obtains its
    previous value'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**test_and_set**：这个操作原子地将标志设置为 **true** 并获取其前一个值'
- en: The **clear** function can only be called with a relaxed, release, or sequential
    consistency memory order. The **test_and_set** function can only be called with
    relaxed, acquire, or sequential consistency. Using any other memory order will
    result in undefined behavior.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**clear** 函数只能使用松散、释放或顺序一致性内存顺序调用。**test_and_set** 函数只能使用松散、获取或顺序一致性调用。使用任何其他内存顺序将导致未定义行为。'
- en: Now let’s see how we can implement a simple spinlock using **std::atomic_flag**
    . First, we know that the operations are atomic, so the thread either clears the
    flag or it doesn’t, and if a thread clears the flag, it is fully cleared. It is
    not possible for the thread to *half-clear* the flag (remember this would be possible
    for some non-atomic flags). The **test_and_set** function is atomic too, so the
    flag is set to **true** , and we get the previous state in just one go.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何使用 **std::atomic_flag** 实现一个简单的自旋锁。首先，我们知道操作是原子的，所以线程要么清除标志，要么不清除，如果一个线程清除了标志，它就会被完全清除。线程不可能只
    *半清除* 标志（记住，对于某些非原子标志这是可能的）。**test_and_set** 函数也是原子的，所以标志被设置为 **true**，并且我们一次性获得其前一个状态。
- en: 'To implement the basic spinlock, we need an atomic flag to atomically handle
    the lock status and two functions: **lock()** to acquire the lock (as we have
    for a mutex) and **unlock()** to release the lock.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现基本的自旋锁，我们需要一个原子标志来原子地处理锁状态，以及两个函数：**lock()** 用于获取锁（就像我们为互斥量所做的那样）和 **unlock()**
    用于释放锁。
- en: Simple spin lock unlock() function
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简单自旋锁 unlock() 函数
- en: 'We will begin with **unlock()** , the simplest function. It will only reset
    the flag (by making it false) and nothing more:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 **unlock()** 开始，这是最简单的函数。它只会重置标志（通过将其设置为 false）而不再做其他操作：
- en: '[PRE13]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The code is straightforward. If we leave out the **std::memory_order_seq_cst**
    parameter, the strictest memory order option, sequential consistency, will be
    applied.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 代码很简单。如果我们省略了 **std::memory_order_seq_cst** 参数，将应用最严格的内存顺序选项，即顺序一致性。
- en: Simple spin lock lock() function
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简单的自旋锁 lock() 函数
- en: 'The lock function has more steps. First, let’s explain what it does: **lock()**
    must see whether the atomic flag is on. If it is off, then turn it on and finish.
    If the flag is on, then keep on looking until another thread turns it off. We
    will use **test_and_set()** to make this function work:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 锁函数有更多步骤。首先，让我们解释一下它做什么：**lock()** 必须检查原子标志是否开启。如果它是关闭的，那么就将其开启并完成。如果标志是开启的，那么就持续检查，直到另一个线程将其关闭。我们将使用
    **test_and_set()** 使这个函数工作：
- en: '[PRE14]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding code works in the following way: inside a **while** loop, **test_and_set**
    sets the flag to **true** and returns the previous value. If the flag is already
    set, setting it again doesn’t change anything and the function returns **true**
    , so the loop keeps on setting the flag. When, eventually, **test_and_set** returns
    **false** , this means that the flag was cleared and we can exit the loop.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的工作方式如下：在一个 **while** 循环中，**test_and_set** 将标志设置为 **true** 并返回前一个值。如果标志已经设置，再次设置它不会改变任何东西，函数返回
    **true**，所以循环会持续设置标志。当最终 **test_and_set** 返回 **false** 时，这意味着标志已被清除，我们可以退出循环。
- en: Simple spin lock issues
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简单自旋锁问题
- en: 'The simple spin lock implementation has been included in this chapter to introduce
    the use of atomic types ( **std::atomic_flag** , the simplest standard atomic
    type) and operations ( **clear** and **test_and_set** ), but it has some serious
    issues:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的自旋锁实现已包含在本章中，以介绍原子类型（**std::atomic_flag**，最简单的标准原子类型）和操作（**clear**和**test_and_set**）的使用，但它存在一些严重问题：
- en: The first of these is its bad performance. The code in the repo will let you
    experiment. Expect the spinlock performance to be much worse than that of the
    mutex.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其中第一个问题是其性能不佳。仓库中的代码将让您进行实验。预期自旋锁的性能将远低于互斥锁。
- en: The thread is spinning all the time waiting for the flag to be cleared. This
    busy wait is something to avoid, especially if there is thread contention.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程一直在自旋等待标志被清除。这种忙等待是应该避免的，尤其是在存在线程竞争的情况下。
- en: You can try out the preceding code for this example. We got these results, shown
    in *Table 5.1* , when we ran it. The code adds 1 to a counter 200 million times
    in each thread.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以尝试运行此示例的前述代码。当我们运行它时，我们得到了这些结果，如*表5.1*所示。每个线程将计数器加1 2亿次。
- en: '|  | **std::mutex** | **spinlock** | **atomic counter** |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '|  | **std::mutex** | **自旋锁** | **原子计数器** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| One thread | 1.03 s | 1.33 s | 0.82 s |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| 一个线程 | 1.03 s | 1.33 s | 0.82 s |'
- en: '| Two threads | 10.15 s | 39.14 s | 4.52 s |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| 两个线程 | 10.15 s | 39.14 s | 4.52 s |'
- en: '| Four threads | 24.61 s | 128.84 s | 9.13 s |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| 四个线程 | 24.61 s | 128.84 s | 9.13 s |'
- en: 'Table 5.1: Synchronization primitives profiling results'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.1：同步原语分析结果
- en: We can see from the preceding table how poorly the simple spinlock works and
    how it worsens with the addition of threads. Note that this simple example is
    only for learning and that both the simple **std::mutex** spinlock and the atomic
    counter can be improved so that the atomic type performs better.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述表中，我们可以看到简单的自旋锁工作得有多差，以及它如何随着线程的增加而恶化。请注意，这个简单的示例只是为了学习，简单的**std::mutex**自旋锁和原子计数器都可以得到改进，以便原子类型表现更好。
- en: In this section, we have looked at **std::atomic_flag** , the most basic atomic
    type provided by the C++ Standard Library. For further information about this
    type and about the new functionality added in C++20 please refer to the online
    C++ reference, which is available at [https://en.cppreference.com/w/cpp/atomic/atomic_flag](https://en.cppreference.com/w/cpp/atomic/atomic_flag)
    .
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了C++标准库提供的最基本原子类型**std::atomic_flag**。有关此类型和C++20中添加的新功能的信息，请参阅在线C++参考，可在[https://en.cppreference.com/w/cpp/atomic/atomic_flag](https://en.cppreference.com/w/cpp/atomic/atomic_flag)找到。
- en: In the following section, we will look at how to create a simple way for a thread
    to tell the main thread how many items it has processed.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何创建一种简单的方法，让线程告诉主线程它已处理了多少个项目。
- en: Example – thread progress reporting
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 - 线程进度报告
- en: 'Sometimes we want to check the progress of a thread or be notified when it
    finishes. This can be done in different ways, for example, using a mutex and a
    condition variable, or a shared variable synchronized by a mutex, as we have seen
    in [*Chapter 4*](B22219_04.xhtml#_idTextAnchor074) . We also saw how to use atomic
    operations to synchronize a counter in this chapter. We will use a similar counter
    in the following example:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们想检查线程的进度或在其完成时收到通知。这可以通过不同的方式完成，例如，使用互斥锁和条件变量，或者使用由互斥锁同步的共享变量，正如我们在[*第4章*](B22219_04.xhtml#_idTextAnchor074)中看到的。我们还在本章中看到了如何使用原子操作同步计数器。在以下示例中，我们将使用类似的计数器：
- en: '[PRE15]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding code implements a thread ( **worker** ) that handles a certain
    number of items (here the handling is simulated just by making the thread sleep).
    Every time the thread handles an item, it increments the variable progress. The
    main thread executes a **while** loop and, in each iteration, it accesses the
    **progress** variable and writes a report of the progress (number of items handled).
    Once all the items are handled, the loop is finished.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码实现了一个线程（**工作线程**），它处理一定数量的项目（在这里，处理是通过使线程休眠来模拟的）。每当线程处理一个项目时，它都会增加**进度**变量。主线程执行一个**while**循环，并在每次迭代中访问**进度**变量并写入进度报告（处理的项目数量）。一旦所有项目都处理完毕，循环结束。
- en: 'In this example, we use the **std::atomic<int>** atomic type (an atomic integer)
    and two atomic operations:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们使用了**std::atomic<int>**原子类型（一个原子整数）和两个原子操作：
- en: '**load()** : This atomically retrieves the value of the **progress** variable'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**load()** : 该原子操作检索**进度**变量的值'
- en: '**store()** : This atomically modifies the value of the **progress** variable'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**store()**：这个原子操作修改 **progress** 变量的值'
- en: The **worker** thread processing **progress** is read and written atomically,
    so no race conditions occur when two threads access the **progress** variable.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 处理 **progress** 的 **worker** 线程以原子方式读取和写入，因此当两个线程访问 **progress** 变量时不会发生竞争条件。
- en: 'The **load()** and **store()** atomic operations have an extra parameter to
    indicate the memory order. In this example, we have used **std::memory_order_relaxed**
    . This is a typical example of the use of the relaxed memory order: one thread
    increases a counter, and another reads it. The only ordering we need is reading
    increasing values and for that, the relaxed memory order is enough.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**load()** 和 **store()** 原子操作有一个额外的参数来指示内存顺序。在这个例子中，我们使用了 **std::memory_order_relaxed**。这是一个使用松散内存顺序的典型例子：一个线程增加一个计数器，另一个线程读取它。我们需要的唯一顺序是读取递增的值，而对于这一点，松散内存顺序就足够了。'
- en: Having introduced the **load()** and **store()** atomic operations to atomically
    read and write a variable, let’s see another example of a simple statistic-gathering
    application.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍了 **load()** 和 **store()** 原子操作用于原子地读写变量之后，让我们看看另一个简单的统计收集应用的例子。
- en: Example – simple statistics
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 - 简单统计
- en: 'This example builds on the same idea as the previous one: a thread can use
    atomic operations to communicate progress (for example, the number of items processed)
    to another thread. In this new example, one thread will produce some data that
    another thread will read. We need to synchronize memory access because we have
    two threads sharing the same memory and at least one of them is changing the memory.
    As in the previous example, we will use atomic operations for this purpose.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子与上一个例子有相同的思想：一个线程可以使用原子操作将进度（例如，处理的项目数量）传递给另一个线程。在这个新的例子中，一个线程将生成一些数据，另一个线程将读取这些数据。我们需要同步内存访问，因为我们有两个线程共享相同的内存，并且至少有一个线程正在更改内存。与上一个例子一样，我们将使用原子操作来实现这一点。
- en: 'The following code declares the atomic variables we are going to use to gather
    statistics – one for the number of items processed and two more (for the total
    processing time and average processing time for each item, respectively):'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码声明了我们将要使用的原子变量，用于收集统计信息——一个用于处理的项目数量，另外两个（分别用于总处理时间和每个项目的平均处理时间）：
- en: '[PRE16]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We use atomic float and double for total time and average time. In the full
    example code, we make sure both types are lock-free, which means they use atomic
    instructions from the CPU (all modern CPUs should have that).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用原子浮点数和双精度浮点数来表示总时间和平均时间。在完整的示例代码中，我们确保这两种类型都是无锁的，这意味着它们使用CPU的原子指令（所有现代CPU都应该有这些）。
- en: 'Now let’s see how the worker thread uses the variables:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看工作线程如何使用这些变量：
- en: '[PRE17]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The first line increments the processed items by 1 in an atomic way. The **fetch_add**
    function adds **1** to the variable value and gives back the old value (we are
    not using it in this case).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行以原子方式将处理的项目数增加1。**fetch_add** 函数将 **1** 添加到变量值，并返回旧值（我们在这个例子中没有使用它）。
- en: The second line adds **elapsed_s** (the time it took to process one item in
    seconds) to the **total_time** variable, which we use to keep track of the time
    it takes to process all the items.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行将 **elapsed_s**（处理一个项目所需的时间，以秒为单位）加到 **total_time** 变量上，我们使用这个变量来跟踪处理所有项目所需的时间。
- en: Then, the third line computes the mean time for each item by atomically reading
    **total_time** and **processed_items** and atomically writing the result in **average_time**
    . Alternatively, we could use the values from the **fetch_add()** calls to calculate
    the mean time, but they don’t include the last item that was processed. We could
    also do the calculation of **average_time** in the main thread, but we do it in
    the worker thread here, just as an example and to practice using atomic operations.
    Keep in mind that our aim (at least in this chapter) is not so much speed but
    learning how to use atomic operations.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，第三行通过原子地读取 **total_time** 和 **processed_items** 并将结果原子地写入 **average_time**
    来计算每个项目的平均时间。或者，我们也可以使用 **fetch_add()** 调用的值来计算平均时间，但它们不包括最后处理的项目。我们也可以在主线程中计算
    **average_time**，但在这里我们选择在工作线程中这样做，仅作为一个示例并练习使用原子操作。记住，我们的目标（至少在本章中）并不是速度，而是学习如何使用原子操作。
- en: 'The following is the full code for the statistics example:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码是统计示例的完整代码：
- en: '[PRE18]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let’s summarize what we have seen up to this point in the current section:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下在本节中到目前为止我们所看到的内容：
- en: 'C++ standard atomic types: we used **std::atomic_flag** to implement a simple
    spinlock and we have used some of the **std::atomic<T>** types to implement communication
    of simple data between threads. All the atomic types that we have seen are lock-free.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++标准原子类型：我们使用 **std::atomic_flag** 实现了一个简单的自旋锁，并且我们已经使用了一些 **std::atomic<T>**
    类型来实现线程间简单数据的通信。我们看到的所有原子类型都是无锁的。
- en: The **load()** atomic operation to atomically read the value of an atomic variable.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**load()** 原子操作用于原子地读取原子变量的值。'
- en: The **store()** atomic operation to atomically write a new value to an atomic
    variable.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**store()** 原子操作用于原子地将新值写入原子变量。'
- en: '**clear()** and **test_and_set()** , the special atomic operations provided
    by **std::atomic_flag** .'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**clear()** 和 **test_and_set()** 是由 **std::atomic_flag** 提供的特殊原子操作。'
- en: '**fetch_add()** , to atomically add some value to an atomic variable and get
    its previous value. Integral and floating-point types also implement **fetch_sub()**
    , to subtract a certain value from an atomic variable and return its previous
    value. Some functions for performing bitwise logic operations have been implemented
    just for integral types: **fetch_and()** , **fetch_or()** , and **fetch_xor()**
    .'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**fetch_add()**，用于原子地将某个值添加到原子变量中并获取其之前的值。整数和浮点类型还实现了**fetch_sub()**，用于从原子变量中减去一定值并返回其之前的值。一些用于执行位逻辑操作的函数仅针对整数类型实现：**fetch_and()**，**fetch_or()**，和**fetch_xor()**。'
- en: 'The following table summarizes atomic types and operations. For an exhaustive
    description, please refer to the online C++ reference: [https://en.cppreference.com/w/cpp/atomic/atomic](https://en.cppreference.com/w/cpp/atomic/atomic)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格总结了原子类型和操作。对于详尽的描述，请参考在线C++参考：[https://en.cppreference.com/w/cpp/atomic/atomic](https://en.cppreference.com/w/cpp/atomic/atomic)
- en: 'The table shows three new operations: **exchange** , **compare_exchange_weak**
    , and **compare_exchange_strong** . We will explain them using an example later.
    Most of the operations (that is, the functions, not the operators) have another
    parameter for the memory order.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 表格显示了三种新的操作：**exchange**，**compare_exchange_weak**，和**compare_exchange_strong**。我们将在稍后的示例中解释它们。大多数操作（即函数，而不是运算符）都有一个用于内存顺序的另一个参数。
- en: '| **Operation** | **atomic_****flag** | **atomic <bool>** | **atomic <integral>**
    | **atomic <floating-point>** | **atomic <other>** |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **atomic_flag** | **atomic<bool>** | **atomic<integral>** | **atomic<floating-point>**
    | **atomic<other>** |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| **test_and_set** | YES |  |  |  |  |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| **test_and_set** | YES |  |  |  |  |'
- en: '| **Clear** | YES |  |  |  |  |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| **Clear** | YES |  |  |  |  |'
- en: '| **Load** |  | YES | YES | YES | YES |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| **Load** |  | YES | YES | YES | YES |'
- en: '| **Store** |  | YES | YES | YES | YES |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| **Store** |  | YES | YES | YES | YES |'
- en: '| **fetch_add, +=** |  |  | YES | YES |  |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| **fetch_add, +=** |  |  | YES | YES |  |'
- en: '| **fetch_sub, -=** |  |  | YES | YES |  |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| **fetch_sub, -=** |  |  | YES | YES |  |'
- en: '| **fetch_and, &=** |  |  | YES |  |  |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| **fetch_and, &=** |  |  | YES |  |  |'
- en: '| **fetch_or, &#124;=** |  |  | YES |  |  |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| **fetch_or, |=** |  |  | YES |  |  |'
- en: '| **fetch_xor, ^=** |  |  | YES |  |  |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| **fetch_xor, ^=** |  |  | YES |  |  |'
- en: '| **++, --** |  |  | YES |  |  |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| **++, --** |  |  | YES |  |  |'
- en: '| **Exchange** |  | YES | YES | YES | YES |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| **Exchange** |  | YES | YES | YES | YES |'
- en: '| **compare_exchange_weak,****compare_exchange_strong** |  | YES | YES | YES
    | YES |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| **compare_exchange_weak, compare_exchange_strong** |  | YES | YES | YES |
    YES |'
- en: 'Table 5.2: Atomic types and operations'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.2：原子类型和操作
- en: Let’s review the **is_lock_free()** function and the **is_always_lock_free**
    constant. We saw that if **is_lock_free()** is true, then the atomic type has
    lock-free operations with special CPU instructions. An atomic type can be lock-free
    only sometimes, so the **is_always_lock_free** constant tells us if the type is
    always lock-free. So far, all the types we have seen are lock-free. Let’s see
    what happens when an atomic type is non-lock-free.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下 **is_lock_free()** 函数和 **is_always_lock_free** 常量。我们看到了如果 **is_lock_free()**
    为真，则原子类型具有具有特殊CPU指令的无锁操作。原子类型可能只在某些时候是无锁的，因此 **is_always_lock_free** 常量告诉我们类型是否始终无锁。到目前为止，我们看到的所有类型都是无锁的。让我们看看当原子类型非无锁时会发生什么。
- en: 'The following shows the code for the non-lock-free atomic type:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 以下展示了非无锁原子类型的代码：
- en: '[PRE19]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When you execute the code, you will notice that the **std::atomic<no_lock_free>**
    type is not lock-free. Its size, 512 bytes, is the cause of this. When we assign
    a value to the atomic variable, that value is written *atomically* , but this
    operation does not use CPU atomic instructions, that is, it is not lock-free.
    The implementation of this operation depends on the compiler but, in general,
    it uses either a mutex or a special spinlock (such as Microsoft Visual C++).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行代码时，你会注意到**std::atomic<no_lock_free>**类型不是无锁的。它的大小，512字节，是导致这种情况的原因。当我们向原子变量赋值时，该值是*原子地*写入的，但这个操作没有使用CPU原子指令，也就是说它不是无锁的。这个操作的实现取决于编译器，但一般来说，它使用互斥锁或特殊的自旋锁（例如Microsoft
    Visual C++）。
- en: The lesson here is that all atomic types have atomic operations, but they are
    not all magically lock-free. If an atomic type is not lock-free, it is always
    better to implement it using locks.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的教训是，所有原子类型都有原子操作，但它们并不都是无锁的。如果一个原子类型不是无锁的，那么最好使用锁来实现它。
- en: 'We learned that some atomic types are not lock-free. Now we will look at another
    example that shows the atomic operations we have not covered yet: the **exchange**
    and **compare_exchange** operations.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到一些原子类型不是无锁的。现在我们将看看另一个例子，展示我们尚未覆盖的原子操作：**exchange**和**compare_exchange**操作。
- en: Example – lazy one-time initialization
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 – 延迟一次性初始化
- en: Sometimes initializing an object can be costly. For example, a given object
    may need to connect to a database or a server, and establishing this connection
    can take a long time. In these cases, we should initialize the object just before
    its use, and not when we define it in our program. This is called **lazy initialization**
    . Now let’s assume that more than one thread needs to use the object for the first
    time. If more than one thread initializes the object, then different connections
    would be created, and that would be wrong because the object opens and closes
    only one connection. For this reason, multiple initializations must be avoided.
    To ensure the object is initialized only once, we will utilize a method known
    as lazy one-time initialization.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 有时初始化一个对象可能会很昂贵。例如，一个特定的对象可能需要连接到数据库或服务器，建立这种连接可能需要很长时间。在这些情况下，我们应该在对象使用之前而不是在程序中定义它时初始化对象。这被称为**延迟初始化**。现在假设多个线程需要首次使用该对象。如果有多个线程初始化对象，那么将创建不同的连接，这是错误的，因为对象只打开和关闭一个连接。因此，必须避免多次初始化。为了确保对象只初始化一次，我们将利用一种称为延迟一次性初始化的方法。
- en: 'The following shows the code for lazy one-time initialization:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码展示了延迟一次性初始化的示例：
- en: '[PRE20]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: There are some operations in the atomic type operations table that we saw earlier
    in this chapter that we have not yet discussed. We will now explain **compare_exchange_strong**
    using an example. In the example, we have a variable that starts with a value
    of 0. Several threads are running, each with a unique integer ID (1, 2, 3, and
    so on). We want to set the variable’s value to the ID of the thread that sets
    it first and initialize the variable only once. In [*Chapter 4*](B22219_04.xhtml#_idTextAnchor074)
    , we learned about **std::once_flag** and **std::call_once** , which we could
    use to implement this one-time initialization, but this chapter is about atomic
    types and operations, so we will use those to achieve our goal.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面我们看到的原子类型操作表中，有一些操作我们还没有讨论。现在我们将通过一个例子来解释**compare_exchange_strong**。在例子中，我们有一个初始值为0的变量。有多个线程正在运行，每个线程都有一个唯一的整数ID（1、2、3等等）。我们希望将变量的值设置为第一个设置它的线程的ID，并且只初始化变量一次。在[*第4章*](B22219_04.xhtml#_idTextAnchor074)中，我们学习了**std::once_flag**和**std::call_once**，我们可以使用它们来实现这种一次性初始化，但本章是关于原子类型和操作的，所以我们将使用这些来实现我们的目标。
- en: To be sure that the initialization of the **init_thread** variable is done only
    once and to avoid race conditions due to write access from more than one thread,
    we use an atomic **int** . Line **[1]** atomically reads the content of **init_thread**
    . If the value is not 0, then that means it has been already initialized and the
    worker thread does nothing else.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保**init_thread**变量的初始化只进行一次，并且避免由于多个线程的写访问导致的竞态条件，我们使用了一个原子的**int**。第**[1**]行原子地读取了**init_thread**的内容。如果值不是0，那么这意味着它已经被初始化，并且工作线程不再做其他操作。
- en: 'The current value of **init_thread** is stored in the **expected** variable,
    which represents the value we expect **init_thread** will have when we try to
    initialize it. Now line **[2]** performs the following steps:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**init_thread** 的当前值存储在 **expected** 变量中，它代表当我们尝试初始化它时，我们期望 **init_thread**
    将具有的值。现在行 **[2]** 执行以下步骤：'
- en: Compare the **init_thread** current value to the **expected** value (which,
    again, is equal to 0).
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **init_thread** 的当前值与 **expected** 值（再次强调，等于 0）进行比较。
- en: If the comparison is not successful, copy the **init_thread** current value
    into **expected** and return **false** .
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果比较不成功，将 **init_thread** 的当前值复制到 **expected** 中，然后返回 **false**。
- en: If the comparison is successful, copy the **init_thread** current value into
    **expected** , then set the **init_thread** current value to **i** and return
    **true** .
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果比较成功，将 **init_thread** 的当前值复制到 **expected** 中，然后将 **init_thread** 的当前值设置为
    **i** 并返回 **true**。
- en: The current thread will have initialized **init_thread** only if **compare_exchange_strong**
    returns **true** . Also, note that we need to perform a comparison again (even
    if line **[1]** returned 0 as the current value of **init_thread** ) because it
    is possible that another thread has already initialized the variable.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当 **compare_exchange_strong** 返回 **true** 时，当前线程才会初始化 **init_thread**。此外，请注意，我们需要再次执行比较（即使行
    **[1]** 返回 0 作为 **init_thread** 的当前值）因为有可能另一个线程已经初始化了该变量。
- en: It is very important to note that if **compare_exchange_strong** returns **false**
    , then the comparison has failed, and if it returns **true** , then the comparison
    was successful. This is always true of **compare_exchange_strong** . On the other
    hand, **compare_exchange_weak** can fail (i.e., return **false** ) even if the
    comparison is successful. The reason for using it is that in some platforms it
    gives better performance when it is called inside a loop.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是要注意，如果 **compare_exchange_strong** 返回 **false**，则比较失败；如果它返回 **true**，则比较成功。这对于
    **compare_exchange_strong** 总是成立的。另一方面，**compare_exchange_weak** 即使比较成功也可能失败（即返回
    **false**）。使用它的原因是在某些平台上，当它在循环内部调用时，它提供了更好的性能。
- en: 'For more information on these two functions, please refer to the online C++
    reference: [https://en.cppreference.com/w/cpp/atomic/atomic/compare_exchange](https://en.cppreference.com/w/cpp/atomic/atomic/compare_exchange)'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这两个函数的更多信息，请参考在线 C++ 参考文档：[https://en.cppreference.com/w/cpp/atomic/atomic/compare_exchange](https://en.cppreference.com/w/cpp/atomic/atomic/compare_exchange)
- en: 'In this section about the C++ Standard Library atomic types and operations,
    we have seen the following:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节关于 C++ 标准库原子类型和操作的讨论中，我们看到了以下内容：
- en: The most commonly used standard atomic types, such as **std::atomic_flag** and
    **std::atomic<int>**
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最常用的标准原子类型，例如 **std::atomic_flag** 和 **std::atomic<int>**
- en: 'The most-used atomic operations: **load()** , **store()** , and **exchange_compare_strong()**
    / **exchange_compare_weak()**'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最常用的原子操作：**load()**、**store()** 和 **exchange_compare_strong()**/ **exchange_compare_weak()**
- en: Basic examples incorporating these atomic types and operations, including lazy
    one-time initialization and thread progress communication
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含这些原子类型和操作的基本示例，包括懒加载一次性初始化和线程进度通信
- en: 'We have mentioned several times that most of the atomic operations (functions)
    let us pick the memory order we want to use. In the next section, we will implement
    a lock-free programming example: an SPSC lock-free queue.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经多次提到，大多数原子操作（函数）允许我们选择我们想要使用的内存顺序。在下一节中，我们将实现一个无锁编程示例：一个 SPSC 无锁队列。
- en: SPSC lock-free queue
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SPSC 无锁队列
- en: We have already looked at the C++ Standard Library’s features for atomics, such
    as atomic types and operations and the memory model and orderings. Now we will
    see a complete example of using atomics to implement an SPSC lock-free queue.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了 C++ 标准库的原子特性，例如原子类型和操作以及内存模型和排序。现在我们将看到一个使用原子实现 SPSC 无锁队列的完整示例。
- en: 'The main features of this queue are the following:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 此队列的主要特性如下：
- en: '**SPSC** : This queue is designed to work with two threads, one pushing elements
    to the queue and another getting elements from the queue.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SPSC**：此队列设计用于与两个线程一起工作，一个线程将元素推入队列，另一个线程从队列中获取元素。'
- en: '**Bounded** : This queue has a fixed size. We need a method for checking when
    the queue reaches its capacity and when it has no elements).'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有界**：此队列具有固定大小。我们需要一种方法来检查队列何时达到其容量以及何时没有元素）。'
- en: '**Lock-free** : This queue uses atomic types that are always lock-free on modern
    Intel x64 CPUs.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无锁**：此队列使用在现代 Intel x64 CPU 上始终无锁的原子类型。'
- en: Before you begin to develop the queue, keep in mind that lock-free is not the
    same as wait-free (also keep in mind that wait-free does not eliminate waiting
    entirely; it just ensures that there is a limit to the number of steps required
    for each queue push/pop). Some aspects that mostly affect performance will be
    discussed in [*Chapter 13*](B22219_13.xhtml#_idTextAnchor267) . In that chapter,
    we will also optimize the queue’s performance. For now, in this chapter, we will
    build an SPSC lock-free queue that is correct and performs adequately – we will
    show how its performance can be improved later.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始开发队列之前，请记住，无锁不等于无等待（也要记住，无等待并不完全消除等待；它只是确保每个队列push/pop所需的步骤数有一个限制）。一些主要影响性能的方面将在[*第13章*](B22219_13.xhtml#_idTextAnchor267)中讨论。在第13章中，我们还将优化队列的性能。现在，在本章中，我们将构建一个正确且性能良好的SPSC无锁队列——我们将在稍后展示如何提高其性能。
- en: We used mutex and condition variables to make an SPSC queue in [*Chapter 4*](B22219_04.xhtml#_idTextAnchor074)
    that consumer and producer threads could access safely. This chapter will use
    atomic operations to achieve the same goal.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第4章*](B22219_04.xhtml#_idTextAnchor074)中使用了互斥锁和条件变量来创建一个SPSC队列，消费者和生产线程可以安全地访问。本章将使用原子操作达到相同的目标。
- en: 'We will store the items in the queue using the same data structure: **std::vector<T>**
    with a fixed size, that is, a power of 2. This way, we can improve performance
    and find the next head and tail indices quickly without using the modulo operator
    that needs a division instruction. When using lock-free atomic types for better
    performance, we need to pay attention to everything that affects performance.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在队列中使用相同的数据结构来存储项目：**std::vector<T>**，具有固定大小，即2的幂。这样，我们可以提高性能并快速找到下一个头和尾索引，而无需使用需要除法指令的模运算符。当使用无锁原子类型以获得更好的性能时，我们需要注意影响性能的每一件事。
- en: Why do we use a power of 2 buffer size?
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么我们使用2的幂作为缓冲区大小？
- en: 'We will use a vector to hold the queue items. The vector will have a fixed
    size, say **N** . We will make the vector act similarly to a ring buffer, meaning
    that the index for accessing an element in the vector will loop back to the start
    after the end. The first element will follow the last one. As we learned in [*Chapter
    4*](B22219_04.xhtml#_idTextAnchor074) , we can do this with the modulo operator:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个向量来保存队列项目。该向量将具有固定大小，比如说**N**。我们将使向量表现得像环形缓冲区，这意味着在向量中访问元素的索引将在到达末尾后循环回起点。第一个元素将跟随最后一个元素。正如我们在[*第4章*](B22219_04.xhtml#_idTextAnchor074)中学到的，我们可以用模运算符做到这一点：
- en: '[PRE21]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If the size is, for example, four elements, the index to the next element will
    be calculated as in the preceding code. For the last index, we have the following
    code:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果大小是，例如，四个元素，下一个元素的索引将按照前面的代码计算。对于最后一个索引，我们有以下代码：
- en: '[PRE22]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Therefore, as we said, the vector will be a ring buffer because, after the last
    element, we will go back to the first one, then the second one, and so on.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如我们所说的，向量将是一个环形缓冲区，因为，在最后一个元素之后，我们将回到第一个，然后是第二个，依此类推。
- en: 'We can use this method to get the next index for any buffer size **N** . But
    why do we only use sizes that are powers of 2? The answer is easy: performance.
    The modulo ( **%** ) operator requires a division instruction, which is expensive.
    When the size **N** is a power of 2, we can just do the following:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这种方法为任何缓冲区大小**N**获取下一个索引。但我们为什么只使用2的幂的大小？答案是简单的：性能。模（**%**）运算符需要除法指令，这是昂贵的。当**N**是2的幂时，我们只需做以下操作：
- en: '[PRE23]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is much faster than using the modulo operator.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这比使用模运算符要快得多。
- en: Buffer access synchronization
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓冲区访问同步
- en: 'To access the queue buffer, we need two indices:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问队列缓冲区，我们需要两个索引：
- en: '**head** : The index of the current element to be read'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**head**：当前要读取的元素的索引'
- en: '**tail** : The index of the next element to be written'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**tail**：下一个要写入的元素的索引'
- en: 'The consumer thread will use the head index to read and write. The producer
    thread will use the tail index to read and write. We need to synchronize access
    to these variables because of this:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者线程将使用头索引进行读写。生产线程将使用尾索引进行读写。由于这个原因，我们需要同步对这些变量的访问：
- en: Only one thread (the consumer) writes **head** , meaning that it can read it
    with relaxed memory ordering because it always sees its own changes. Reading **tail**
    is done by the reader thread and it needs to synchronize with the producer’s writing
    of **tail** , so it needs acquire memory ordering. We could use sequential consistency
    for everything, but we want the best performance. When the consumer thread writes
    **head** , it needs to synchronize with the producer’s read of it, so it needs
    release memory ordering.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有一个线程（消费者）写入 **head**，这意味着它可以以松散的内存顺序读取它，因为它总是看到自己的更改。读取 **tail** 由读取器线程完成，并且它需要与生产者写入
    **tail** 进行同步，因此它需要获取内存顺序。我们可以为一切使用顺序一致性，但我们希望获得最佳性能。当消费者线程写入 **head** 时，它需要与生产者读取它的操作同步，因此它需要释放内存顺序。
- en: For **tail** , only the producer thread writes it, so we can use relaxed memory
    ordering to read it, but we need release memory ordering to write it and synchronize
    it with the consumer thread’s reading. To synchronize with the consumer thread’s
    writing, we need acquire memory ordering to read **head** .
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 **tail**，只有生产者线程写入它，因此我们可以使用松散的内存顺序来读取它，但我们需要释放内存顺序来写入它并与消费者线程的读取同步。为了与消费者线程的写入同步，我们需要获取内存顺序来读取
    **head**。
- en: 'The queue class member variables are the following:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 队列类的成员变量如下：
- en: '[PRE24]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this section, we have seen how to synchronize access to queue buffer.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了如何同步对队列缓冲区的访问。
- en: Pushing elements into the queue
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将元素推入队列
- en: 'Once we have decided on the data representation of the queue and how to synchronize
    access to its elements, let’s implement the function for pushing elements into
    the queue:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们决定了队列的数据表示以及如何同步对其元素的访问，让我们实现将元素推入队列的函数：
- en: '[PRE25]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The current tail index, which is the buffer slot where the data item is to be
    pushed (if possible) into the queue, is atomically read in line **[1]** . As we
    mentioned earlier, this read can use **std::memory_order_relaxed** because only
    the producer thread changes this variable, and it is the only thread that calls
    push.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 当前尾索引，即数据项（如果可能）要推入队列的缓冲区槽位，在行 **[1]** 中原子地读取。正如我们之前提到的，这个读取可以使用 **std::memory_order_relaxed**，因为只有生产者线程更改此变量，并且它是唯一调用
    push 的线程。
- en: Line **[2]** calculates the next index modulo capacity (remember that the buffer
    is a ring). We need to do this to check whether the queue is full.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 行 **[2]** 计算下一个索引对容量取模（记住缓冲区是一个环形）。我们需要这样做来检查队列是否已满。
- en: We perform the check in line **[3]** . We first atomically read the current
    value of the head using **std::memory_order_acquire** because we want the producer
    thread to observe the modifications that the consumer thread has made to this
    variable. Then we compare its value with the next head index.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在行 **[3]** 中执行检查。我们首先使用 **std::memory_order_acquire** 原子地读取当前头值，因为我们希望生产者线程观察到消费者线程对此变量所做的修改。然后我们将其值与下一个头索引进行比较。
- en: If the next tail value is equal to the current head value, then (as per our
    convention) the queue is full, and we return **false** .
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 如果下一个尾值等于当前头值，那么（根据我们的约定）队列已满，我们返回 **false**。
- en: If the queue is not full, line **[4]** copies the data item to the queue buffer.
    It is worth commenting here that the data copy is not atomic.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如果队列未满，行 **[4]** 将数据项复制到队列缓冲区。这里值得指出的是，数据复制不是原子的。
- en: Line **[5]** atomically writes the new tail index value into **tail_** . Then,
    **std::memory_order_release** is used to make the changes visible to the consumer
    thread that atomically reads this variable with **std::memory_order_acquire**
    .
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 行 **[5]** 原子地将新的尾索引值写入 **tail_**。然后，使用 **std::memory_order_release** 使更改对使用
    **std::memory_order_acquire** 原子读取此变量的消费者线程可见。
- en: Popping elements from the queue
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从队列中弹出元素
- en: 'Let’s now see how the **pop** function is implemented:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下 **pop** 函数是如何实现的：
- en: '[PRE26]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Line **[1]** atomically reads the current value of **head_** (index for the
    next item to be read). We use **std::memory_order_relaxed** because no order enforcement
    is required due to the **head_** variable being modified only by the consumer
    thread, which is the only thread calling **pop** .
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 行 **[1]** 原子地读取 **head_**（下一个要读取的项目索引）的当前值。我们使用 **std::memory_order_relaxed**，因为不需要执行顺序强制，因为
    **head_** 变量只由消费者线程修改，它是唯一调用 **pop** 的线程。
- en: Line **[2]** checks whether the queue is empty. If the current value of **head_**
    is the same as the current value of **tail_** , then the queue is empty, and the
    function just returns **false** . We atomically read the value of **tail_** with
    **std::memory_order_acquire** to see the latest change done to **tail_** by the
    producer thread.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 行 **[2]** 检查队列是否为空。如果当前 **head_** 的值与当前 **tail_** 的值相同，则队列为空，函数仅返回 **false**。我们使用
    **std::memory_order_acquire** 原子地读取 **tail_** 的值，以查看生产者线程对 **tail_** 的最新更改。
- en: Line **[3]** copies the data from the queue to the item reference passed as
    an argument to **pop** . Again, this copy is not atomic.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 行 **[3]** 将队列中的数据复制到作为 **pop** 参数传递的项目引用中。再次强调，这个复制不是原子的。
- en: Finally, line **[4]** updates the value of **head_** . Again, we atomically
    write the value using **std::memory order_release** for the consumer thread to
    see the changes made to **head_** by the consumer thread.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，行 **[4]** 更新 **head_** 的值。同样，我们使用 **std::memory_order_release** 原子地写入值，以便消费者线程可以看到消费者线程对
    **head_** 的更改。
- en: 'The code for the SPSC lock-free queue implementation is the following:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: SPSC 无锁队列实现的代码如下：
- en: '[PRE27]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The code for the full example can be found in the following book repo: [https://github.com/PacktPublishing/Asynchronous-Programming-in-CPP/blob/main/Chapter_05/5x09-SPSC_lock_free_queue.cpp](https://github.com/PacktPublishing/Asynchronous-Programming-in-CPP/blob/main/Chapter_05/5x09-SPSC_lock_free_queue.cpp)'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例的代码可以在以下书籍仓库中找到：[https://github.com/PacktPublishing/Asynchronous-Programming-in-CPP/blob/main/Chapter_05/5x09-SPSC_lock_free_queue.cpp](https://github.com/PacktPublishing/Asynchronous-Programming-in-CPP/blob/main/Chapter_05/5x09-SPSC_lock_free_queue.cpp)
- en: In this section, we have implemented an SPSC lock-free queue as an application
    of atomic types and operations. In [*Chapter 13*](B22219_13.xhtml#_idTextAnchor267)
    , we will revisit this implementation and improve its performance.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将 SPSC 无锁队列作为原子类型和操作的示例实现。在第 [*第 13 章*](B22219_13.xhtml#_idTextAnchor267)中，我们将重新审视这个实现并提高其性能。
- en: Summary
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has introduced atomic types and operations, the C++ memory model,
    and a basic implementation of an SPSC lock-free queue.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了原子类型和操作、C++ 内存模型以及 SPSC 无锁队列的基本实现。
- en: 'The following is a summary of what we have looked at:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们所查看内容的摘要：
- en: The C++ Standard Library atomic types and operations, what they are, and how
    to use them with some examples.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++ 标准库原子类型和操作，它们是什么，以及如何使用一些示例。
- en: The C++ memory model, and especially the different memory orderings it defines.
    Bear in mind that this is a very complex subject and that this section was just
    a basic introduction to it.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++ 内存模型，特别是它定义的不同内存排序。请记住，这是一个非常复杂的话题，本节只是对其进行了基本介绍。
- en: How to implement a basic SPSC lock-free queue. As we mentioned previously, we
    will demonstrate how to improve its performance in [*Chapter 13*](B22219_13.xhtml#_idTextAnchor267)
    . Examples of performance-improving actions include eliminating false sharing
    (what happens when two variables are in the same cache line and each variable
    is just modified by one thread) and reducing true sharing. Don’t worry if you
    don’t understand any of this now. We will cover it later and demonstrate how to
    run performance tests.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何实现一个基本的 SPSC 无锁队列。正如我们之前提到的，我们将在[*第 13 章*](B22219_13.xhtml#_idTextAnchor267)中展示如何提高其性能。性能提升的措施包括消除虚假共享（当两个变量位于同一缓存行中，并且每个变量仅被一个线程修改时发生的情况）和减少真实共享。如果你现在不理解这些内容，请不要担心。我们将在稍后进行讲解，并演示如何运行性能测试。
- en: This is a basic introduction to atomic operations to synchronize memory access
    from different threads. In some cases, the use of atomic operations is quite easy,
    similar to gathering statistics and simple counters. More involved applications,
    such as the implementation of an SPSC lock-free queue, require a deeper knowledge
    of atomic operations. The material we have seen in this chapter helps build an
    understanding of the basics and builds a foundation for further study of this
    complex subject.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对原子操作的基本介绍，用于同步不同线程之间的内存访问。在某些情况下，使用原子操作相当简单，类似于收集统计数据和简单的计数器。更复杂的应用，如 SPSC
    无锁队列的实现，需要更深入地了解原子操作。本章我们所看到的内容有助于理解基础知识，并为进一步研究这个复杂主题打下基础。
- en: In the next chapter, we will look at promises and futures, two fundamental building
    blocks of asynchronous programming in C++.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨承诺和未来，这是 C++ 异步编程的两个基本构建块。
- en: Further reading
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '[Butenhof, 1997] David R. Butenhof, Programming with POSIX Threads, Addison
    Wesley, 1997.'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Butenhof, 1997] David R. Butenhof，使用POSIX线程进行编程，Addison Wesley，1997。'
- en: '[Williams, 2019] Anthony Williams, C++ Concurrency in Action, Second Edition,
    Manning, 2019.'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Williams, 2019] Anthony Williams，C++并发实战，第2版，Manning，2019。'
- en: 'Memory Model: Get Your Shared Data Under Control, Jana Machutová, [https://www.youtube.com/watch?v=L5RCGDAan2Y](https://www.youtube.com/watch?v=L5RCGDAan2Y)
    .'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存模型：控制你的共享数据，Jana Machutová，[https://www.youtube.com/watch?v=L5RCGDAan2Y](https://www.youtube.com/watch?v=L5RCGDAan2Y)
    .
- en: '*C++ Atomics: From Basic To Advanced* , Fedor Pikus, [https://www.youtube.com/watch?v=ZQFzMfHIxng](https://www.youtube.com/watch?v=ZQFzMfHIxng)
    .'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C++原子操作：从基础到高级*，Fedor Pikus，[https://www.youtube.com/watch?v=ZQFzMfHIxng](https://www.youtube.com/watch?v=ZQFzMfHIxng)
    .'
- en: '*Intel 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A: System
    Programming Guide, Part 1* , Intel Corporation, [https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-3a-part-1-manual.pdf](https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-3a-part-1-manual.pdf)
    .'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Intel 64和IA-32架构软件开发者手册，第3A卷：系统编程指南，第1部分*，英特尔公司，[https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-3a-part-1-manual.pdf](https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-3a-part-1-manual.pdf)
    .'
- en: 'Part 3: Asynchronous Programming with Promises, Futures, and Coroutines'
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3部分：使用承诺（Promises）、未来（Futures）和协程进行异步编程
- en: In this part, we shift our focus to the core subject of this book, asynchronous
    programming, a critical aspect of building responsive, high-performance applications.
    We will learn how to execute tasks concurrently without blocking the main execution
    flow by utilizing tools such as promises, futures, packaged tasks, the **std::async**
    function, and coroutines, a revolutionary feature enabling asynchronous programming
    without the overhead of creating threads. We will also cover advanced techniques
    for sharing futures and examine real-world scenarios where these concepts are
    essential. These powerful mechanisms allow us to develop efficient, scalable,
    and maintainable asynchronous software needed for modern software systems.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，我们将焦点转向本书的核心主题，即异步编程，这是构建响应式、高性能应用程序的关键方面。我们将学习如何通过使用诸如承诺（promises）、未来（futures）、打包任务（packaged
    tasks）、`std::async`函数和协程（coroutines）等工具来并发执行任务，而不会阻塞主执行流程。协程是一种革命性的特性，它允许在不创建线程的开销下进行异步编程。我们还将介绍高级技术，用于共享未来（futures），并探讨这些概念在现实世界场景中的必要性。这些强大的机制使我们能够开发出适用于现代软件系统的有效、可扩展和可维护的异步软件。
- en: 'This part has the following chapters:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 6*](B22219_06.xhtml#_idTextAnchor125) , *Promises and Futures*'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B22219_06.xhtml#_idTextAnchor125) ，*承诺（Promises）和未来（Futures）*'
- en: '[*Chapter 7*](B22219_07.xhtml#_idTextAnchor143) , *The Async Function*'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B22219_07.xhtml#_idTextAnchor143) ，*异步函数*'
- en: '[*Chapter 8*](B22219_08.xhtml#_idTextAnchor164) , *Asynchronous Programming
    Using Coroutines*'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B22219_08.xhtml#_idTextAnchor164) ，*使用协程进行异步编程*'
