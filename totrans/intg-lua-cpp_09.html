<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-193"><a id="_idTextAnchor195"/>9</h1>
<h1 id="_idParaDest-194"><a id="_idTextAnchor196"/>Recapping Lua-C++ Communication Mechanisms</h1>
<p>In <em class="italic">Part 2</em> of this book, we learned how to call Lua from C++. In <em class="italic">Part 3</em>, we learned how to call C++ from Lua. In the course of this book, we have explored many examples, some of which depend on advanced C++ techniques.</p>
<p>This chapter will summarize all the communication mechanisms between Lua and C++, stripping away most of the C++ details. We will also dig deeper into some of the topics that we have not demonstrated in the examples yet.</p>
<p>You can use this chapter to recap what you have learned. For each topic, we will list some important Lua library functions. You can check the Lua reference manual for more related functions.</p>
<p>In the future, as you progress in your programming journey, you might adopt different C++ techniques in your projects. In such cases, this chapter will be a useful source for quick reference.</p>
<p>We will cover the following topics:</p>
<ul>
<li>The stack</li>
<li>Calling Lua from C++</li>
<li>Calling C++ from Lua</li>
<li>Implementing standalone C++ modules</li>
<li>Storing state in Lua</li>
<li>Userdata</li>
</ul>
<h1 id="_idParaDest-195"><a id="_idTextAnchor197"/>Technical requirements</h1>
<p>You can access the source code for this chapter at <a href="https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter09">https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter09</a>.</p>
<p>You can access the Lua reference manual and develop the habit of frequently checking for API details at <a href="https://www.lua.org/manual/5.4/">https://www.lua.org/manual/5.4/</a>.</p>
<h1 id="_idParaDest-196"><a id="_idTextAnchor198"/>The stack</h1>
<p>The Lua stack can serve two purposes:</p>
<ul>
<li><em class="italic">Exchange data between C++ and Lua.</em> Passing function arguments and retrieving function<a id="_idIndexMarker400"/> return values fit into this usage.</li>
<li><em class="italic">Keep intermediate results.</em> For example, we can keep a table reference in the stack until we are done with the table; we can push some values onto the stack and then pop and use them as upvalues.</li>
</ul>
<p>The Lua stack comes in two forms:</p>
<ul>
<li><em class="italic">The public stack that comes with the Lua state.</em> Once a Lua state is created via <code>luaL_newstate</code> or <code>lua_newstate</code>, you can pass the state around and the same Lua stack is<a id="_idIndexMarker401"/> accessible<a id="_idIndexMarker402"/> to all functions that can access the Lua state.</li>
<li><em class="italic">The private stack for each </em><code>lua_CFunction</code><em class="italic"> call.</em> The stack is only accessible to a<a id="_idIndexMarker403"/> function call. Calling<a id="_idIndexMarker404"/> the same <code>lua_CFunction</code> multiple times will not share the same stack. So, the stack that is passed to a <code>lua_CFunction</code> call is private to the function call.</li>
</ul>
<h2 id="_idParaDest-197"><a id="_idTextAnchor199"/>Pushing onto the stack</h2>
<p>You can<a id="_idIndexMarker405"/> use <code>lua_pushXXX</code> functions to push a value or an object reference onto the stack – for example, <code>lua_pushstring</code>.</p>
<p>Check the Lua reference manual for a list of such functions.</p>
<h2 id="_idParaDest-198"><a id="_idTextAnchor200"/>Querying the stack</h2>
<p>You can use <code>lua_isXXX</code> functions to check if a given stack position holds an item of a certain type.</p>
<p>You can use <code>lua_toXXX</code> functions to convert a given stack position into a certain type. Those functions will always succeed, although the resulting values might be a surprise if the stack position is<a id="_idIndexMarker406"/> holding an item of a different type.</p>
<p>You can check the Lua reference manual for a list of such functions.</p>
<h2 id="_idParaDest-199"><a id="_idTextAnchor201"/>Other stack operations</h2>
<p>There are some other<a id="_idIndexMarker407"/> frequently used stack operations.</p>
<h3>Ensuring stack size</h3>
<p>The Lua stack is created<a id="_idIndexMarker408"/> with a predefined size that should be big enough for most operations. If you need to push a lot of items onto the stack, you can ensure that the stack size can meet your needs by calling the following function:</p>
<pre class="source-code">
int lua_checkstack (lua_State *L, int n);</pre>
<p><code>n</code> is the required size.</p>
<h3>Counting items</h3>
<p>To check the <a id="_idIndexMarker409"/>number of items in the stack, use <code>lua_gettop</code>. The return value is the count.</p>
<h3>Resetting the stack top</h3>
<p>To set the top of the<a id="_idIndexMarker410"/> stack to a certain index, use the <code>lua_settop</code> function, whose declaration is as follows:</p>
<pre class="source-code">
void lua_settop (lua_State *L, int index);</pre>
<p>This can either clear some items from the top of the stack or pad the stack with nils. We can use it to clear temporary items from the stack efficiently, as can be seen in <code>LuaModuleExporter::luaNew</code> from our examples:</p>
<pre class="source-code">
    T *obj = luaModuleDef.createInstance(L);
    lua_settop(L, 0);</pre>
<p>In <code>luaNew</code>, we passed the Lua state, thus the Lua stack, to an external factory method. Because we do not know <a id="_idIndexMarker411"/>how the factory method will use the Lua stack, we cleared the stack after the factory method returned to get rid of any possible side effects.</p>
<h3>Copying another item</h3>
<p>If an item is<a id="_idIndexMarker412"/> already in the stack, you can push a copy of it onto the top of the stack quickly by calling this function:</p>
<pre class="source-code">
void lua_pushvalue (lua_State *L, int index);</pre>
<p>This can save you some trouble if the value or object backing the item is hard to get.</p>
<p>Some other stack operations are supported by the Lua library, but they are used infrequently to achieve complex effects. You can check them out in the reference manual.</p>
<h1 id="_idParaDest-200"><a id="_idTextAnchor202"/>Calling Lua from C++</h1>
<p>To call Lua code from C++, we can use <code>lua_pcall</code>, which is declared as<a id="_idIndexMarker413"/> follows:</p>
<pre class="source-code">
int lua_pcall(
    lua_State *L, int nargs, int nresults, int msgh);</pre>
<p>This will call a Lua callable, which can be a function or a chunk. You can push the Lua function to be called onto the stack, or compile a file or a string into a chunk and then place it onto the stack. <code>nargs</code> is the number of arguments for the callable. The arguments are pushed onto the stack above the callable. <code>nresults</code> is the count of return values the callable would return. Use <code>LUA_MULTRET</code> to indicate that you expect a variable count of return values. <code>msgh</code> is the stack index for an error message handler.</p>
<p><code>lua_pcall</code> calls the callable in <em class="italic">protected mode</em>, which means that any error that may have occurred in the call chain is not propagated. Instead, an error status code is returned from <code>lua_pcall</code>.</p>
<p>In the <code>LuaExecutor</code> class that we have implemented, you can find many examples of calling Lua from C++.</p>
<p>In the Lua reference <a id="_idIndexMarker414"/>manual, you can find other library functions similar to <code>lua_pcall</code>, although <code>lua_pcall</code> is the most frequently used one.</p>
<h1 id="_idParaDest-201"><a id="_idTextAnchor203"/>Calling C++ from Lua</h1>
<p>To call C++ code <a id="_idIndexMarker415"/>from Lua, the C++ code needs to be exported via a <code>lua_CFunction</code> implementation, which is defined as follows:</p>
<pre class="source-code">
typedef int (*lua_CFunction) (lua_State *L);</pre>
<p>For example, in <code>LuaExecutor</code>, we implemented a function:</p>
<pre class="source-code">
int luaGetExecutorVersionCode(lua_State *L)
{
   lua_pushinteger(L, LuaExecutor::versionCode);
   return 1;
}</pre>
<p>This returns a single integer value to the Lua code. A simple way to export this function to the global table can be implemented as follows:</p>
<pre class="source-code">
void registerHostFunctions(lua_State *L)
{
    lua_pushcfunction(L, luaGetExecutorVersionCode);
    lua_setglobal(L, "host_version");
}</pre>
<p>You can use <code>lua_pushcfunction</code> to push <code>lua_CFunction</code> onto the stack and then assign it to a variable of your choice.</p>
<p>However, more than likely, you should export a group of functions as a module.</p>
<h2 id="_idParaDest-202"><a id="_idTextAnchor204"/>Exporting C++ modules</h2>
<p>To export a C++ module, you simply need to export a table of functions to Lua. In <code>LuaExecutor</code>, we have<a id="_idIndexMarker416"/> implemented it as follows:</p>
<pre class="source-code">
void LuaExecutor::registerModule(LuaModule &amp;module)
{
    lua_createtable(L, 0, module.luaRegs().size() - 1);
    int nUpvalues = module.pushLuaUpvalues(L);
    luaL_setfuncs(L, module.luaRegs().data(), nUpvalues);
    lua_setglobal(L, module.luaName().c_str());
}</pre>
<p>The process is to first create a table and push the reference onto the stack with <code>lua_createtable</code>. Then, you can push <em class="italic">shared upvalues</em> (we will recap upvalues later in this chapter), and finally add the list of functions to the table with <code>luaL_setfuncs</code>.</p>
<p>If you do not need upvalues, there is a shortcut that you can use:</p>
<pre class="source-code">
void luaL_newlib (lua_State *L, const luaL_Reg l[]);</pre>
<p>Both <code>luaL_newlib</code> and <code>luaL_setfuncs</code> take a list of the following structure to describe the functions:</p>
<pre class="source-code">
typedef struct luaL_Reg {
    const char *name;
    lua_CFunction func;
} luaL_Reg;</pre>
<p>The structure provides <code>lua_CFunction</code> with a <code>name</code> value, which is used as the table entry key.</p>
<h1 id="_idParaDest-203"><a id="_idTextAnchor205"/>Implementing standalone C++ modules</h1>
<p>So far in this book, we have only explicitly registered C++ modules to Lua in C++ code. However, there is another way to provide a C++ module to Lua.</p>
<p>You can produce a shared library<a id="_idIndexMarker417"/> for a module and place it in Lua’s search path. When the Lua code <em class="italic">requires</em> the module, Lua will load the shared library automatically.</p>
<p>By reusing our <code>Destinations</code> class, this is simple to implement. Create a file named <code>DestinationsModule.cpp</code> and fill it exactly as follows:</p>
<pre class="source-code">
#include "Destinations.h"
#include "LuaModuleExporter.hpp"
#include &lt;lua.hpp&gt;
namespace {
    LuaModuleExporter module =
        LuaModuleExporter&lt;Destinations&gt;::make(
            DestinationsLuaModuleDef::def);
}
extern "C" {
int luaopen_destinations(lua_State *L)
{
    lua_createtable(L, 0, module.luaRegs().size() - 1);
    int nUpvalues = module.pushLuaUpvalues(L);
    luaL_setfuncs(L, module.luaRegs().data(), nUpvalues);
    return 1;
}
}</pre>
<p>The module that’s been implemented is called <code>destinations</code>. The code-level contract Lua requires is as follows:</p>
<ul>
<li>You need to provide <code>lua_CFunction</code>, whose name must begin with <code>luaopen_</code>, and then have the module name appended</li>
<li><code>lua_CFunction</code> needs to leave what it creates in the stack</li>
</ul>
<p>The code for <code>luaopen_destinations</code> is <a id="_idIndexMarker418"/>almost identical to that of <code>LuaExecutor::registerModule</code>, which we explained in the previous section. The only difference is that we have left the table reference in the stack because the Lua <code>require</code> function will pop it.</p>
<p class="callout-heading">extern “C”</p>
<p class="callout">By default, the C++ compiler will mangle the C++ function name. This means that after the function is compiled, the function will have a symbol name more complex than what it declares to be in the source code. To prevent this from happening, you can place the function declaration inside an <code>extern "C"</code> block. Otherwise, Lua won’t be able to find the function as the contract is broken after compilation.</p>
<h2 id="_idParaDest-204"><a id="_idTextAnchor206"/>Compiling the standalone module</h2>
<p>To compile the<a id="_idIndexMarker419"/> shared library, add the following lines to your <code>Makefile</code>:</p>
<pre class="source-code">
DESTINATIONS_O = Destinations.o DestinationsModule.o
DESTINATIONS_SO = destinations.so
destinations: ${DESTINATIONS_O}
    $(CXX) $(CXXFLAGS) $(CPPFLAGS) $(LDFLAGS) -shared \
        -o $(DESTINATIONS_SO) ${DESTINATIONS_O} -llua</pre>
<p>In a Terminal, execute <code>make destinations</code> to create the shared library. You will get a file named <code>destinations.so</code>, which is the binary file Lua will load.</p>
<h2 id="_idParaDest-205"><a id="_idTextAnchor207"/>Testing the standalone module</h2>
<p>To test the standalone<a id="_idIndexMarker420"/> module, in the folder where <code>destinations.so</code> resides, start a Lua interactive interpreter and execute the following statements:</p>
<pre class="source-code">
Chapter09 % ../lua/src/lua
Lua 5.4.6 Copyright (C) 1994-2023 Lua.org, PUC-Rio
&gt; <strong class="bold">Destinations = require "destinations"</strong>
&gt; dst = Destinations.new("Shanghai", "Tokyo")
Destinations instance created: 0x155a04210
&gt; dst:wish("London", "Paris", "Amsterdam")
&gt; dst:went("Paris")
&gt; print("Visited:", dst:list_visited())
Visited: Paris
&gt; print("Unvisited:", dst:list_unvisited())
Unvisited: Amsterdam London Shanghai Tokyo
&gt; os.exit()
Destinations instance destroyed: 0x155a04210</pre>
<p>The most important statement is the <code>require</code> statement. This loads <code>destinations.so</code> and assigns the module to the <code>Destinations</code> global variable.</p>
<p>We started the Lua interactive interpreter in the same folder where the module binary resides because <code>require</code> will search the current working directory for modules. Alternatively, you can put the library in a system search path. You can check the reference manual to learn more about <code>require</code> and its behaviors.</p>
<p>A standalone C++ module is useful when you need to reuse the module in the binary form across multiple projects or enforce code isolation on the C++ side, but this is just a design choice.</p>
<h1 id="_idParaDest-206"><a id="_idTextAnchor208"/>Storing state in Lua</h1>
<p>There are two ways to store state in Lua for <code>lua_CFunction</code>: <em class="italic">upvalues</em> and <em class="italic">the registry</em>. Let’s recap them<a id="_idIndexMarker421"/> and dig deeper into upvalues.</p>
<h2 id="_idParaDest-207"><a id="_idTextAnchor209"/>Upvalues</h2>
<p>To<a id="_idIndexMarker422"/> introduce the complete<a id="_idIndexMarker423"/> definition for upvalues, we need to introduce <strong class="bold">Lua C closures</strong> at the same time. To<a id="_idIndexMarker424"/> quote the Lua reference manual:</p>
<p class="author-quote">When a C function is created, it is possible to associate some values with it, thus creating a C closure; these values are called upvalues and are accessible to the function whenever it is called.</p>
<p>To put it simply, the <a id="_idIndexMarker425"/>closure is still our old friend <code>lua_CFunction</code>. When you associate some values with it, it becomes a closure, and the values become upvalues.</p>
<p>It is important to note that Lua C closures and upvalues are inseparable.</p>
<p>To create a closure, use the following library function:</p>
<pre class="source-code">
void lua_pushcclosure(
    lua_State *L, lua_CFunction fn, int n);</pre>
<p>This creates a closure from <code>lua_CFunction</code> and associates <code>n</code> values with it.</p>
<p>To see it in action, let’s solve the design problem from the previous chapter:</p>
<p class="author-quote">We are creating objects in <code>LuaModuleDef</code> but destroying them in <code>LuaModuleExporter</code>. For a better design, the same class should destroy the objects it creates.</p>
<h3>Implementing a Lua C closure</h3>
<p>The following feature is a<a id="_idIndexMarker426"/> continuation of the previous chapter. You can revisit the previous chapter to get a better understanding if you need to.</p>
<p>To do this, we can implement a <code>destroyInstance</code> member variable for <code>LuaModuleDef</code>, as follows:</p>
<pre class="source-code">
struct LuaModuleDef
{
    ...
    const std::function&lt;void(T *)&gt; destroyInstance =
        [](T *obj) { delete obj; };
    ...
};</pre>
<p>Now, objects will be created<a id="_idIndexMarker427"/> and destroyed in the same <code>LuaModuleDef</code> entity. To use <code>destroyInstance</code>, modify <code>LuaModuleExporter::luaDelete</code>, as follows:</p>
<pre class="source-code">
static int luaDelete(lua_State *L)
{
    auto luaModuleDef = getExporter(L)-&gt;luaModuleDef;
    T *obj = *reinterpret_cast&lt;T **&gt;(
        lua_touserdata(L, 1));
    luaModuleDef.destroyInstance(obj);
    return 0;
}</pre>
<p>Recall that <code>getExporter</code> is used to retrieve the first upvalue, which is a pointer to the exporter:</p>
<pre class="source-code">
static LuaModuleExporter&lt;T&gt; *getExporter(lua_State *L)
{
    return reinterpret_cast&lt;LuaModuleExporter&lt;T&gt; *&gt;(
        lua_touserdata(L, lua_upvalueindex(1)));
}</pre>
<p>This works for <code>luaNew</code> because <code>LuaModuleExporter</code> is inherited from <code>LuaModule</code>, which<a id="_idIndexMarker428"/> pushes <code>this</code> as an upvalue in its default implementation:</p>
<pre class="source-code">
class LuaModule
{
public:
    virtual int pushLuaUpvalues(lua_State *L)
    {
        lua_pushlightuserdata(L, this);
        return 1;
    }
};</pre>
<p>Then, the pushed upvalue is used as shared upvalues for all exported functions in <code>LuaExecutor::registerModule</code>:</p>
<pre class="source-code">
void LuaExecutor::registerModule(LuaModule &amp;module)
{
    lua_createtable(L, 0, module.luaRegs().size() - 1);
    <strong class="bold">int nUpvalues = module.pushLuaUpvalues(L);</strong>
    <strong class="bold">luaL_setfuncs(L, module.luaRegs().data(), nUpvalues);</strong>
    lua_setglobal(L, module.luaName().c_str());
}</pre>
<p>Shared upvalues are pushed onto the stack once and get associated with all the functions provided to <code>luaL_setfuncs</code>.</p>
<p class="callout-heading">Shared upvalues are not really shared</p>
<p class="callout">The so-called shared upvalues are copied for each function during setup. Afterward, the functions access their own copies of the upvalues. In the Lua reference manual, these are called shared upvalues because they are<a id="_idIndexMarker429"/> only pushed onto the stack once and used for all functions to be registered, which is only relevant to API invocations. I think this term is misleading. You should think of these as just plain upvalues.</p>
<p>However, <code>getExporter</code> will not <a id="_idIndexMarker430"/>work for <code>luaDelete</code> because <code>luaDelete</code> is not an exported function and is not passed to <code>luaL_setfuncs</code>. To support <code>luaDelete</code>, modify <code>luaNew</code>, as follows:</p>
<pre class="source-code">
static int luaNew(lua_State *L)
{
    auto exporter = getExporter(L);
    auto luaModuleDef = exporter-&gt;luaModuleDef;
    ...
    if (type == LUA_TNIL)
    {
        ...
        <strong class="bold">lua_pushlightuserdata(L, exporter);</strong>
        <strong class="bold">lua_pushcclosure(L, luaDelete, 1);</strong>
        lua_setfield(L, -2, "__gc");
    }
    ...
}</pre>
<p>We only need to push <code>exporter</code> as an upvalue for <code>luaDelete</code> and make <code>luaDelete</code> a closure.</p>
<p>Now, <code>LuaModuleExporter</code> has a better design as it delegates both object construction and object destruction to <code>LuaModuleDef</code>. Also, it utilizes both upvalues (for <code>luaDelete</code>) and shared upvalues (for <code>luaNew</code>) at the same time in the <code>getExporter</code> helper function. This shows that shared upvalues are no different from upvalues after they are<a id="_idIndexMarker431"/> set up.</p>
<h2 id="_idParaDest-208"><a id="_idTextAnchor210"/>The registry</h2>
<p>The registry is a<a id="_idIndexMarker432"/> predefined Lua table that is only accessible to C/C++ code. For a Lua state, the registry is shared for all C/C++ functions, so table key names should be selected carefully to avoid collision.</p>
<p>Notably, by convention, <em class="italic">full userdata</em> places its metatable in the registry via <code>luaL_newmetatable</code>.</p>
<p><em class="italic">Put simply, the registry is a Lua table that the Lua language treats specially and provides a few helper </em><em class="italic">functions for.</em></p>
<h1 id="_idParaDest-209"><a id="_idTextAnchor211"/>Userdata</h1>
<p>The Lua userdata <a id="_idIndexMarker433"/>can be categorized into <em class="italic">light userdata</em> and <em class="italic">full userdata</em>.</p>
<p>It is important to note that they are different things. In the Lua library, conventionally, light userdata is named lightuserdata, while full userdata is named userdata.</p>
<h2 id="_idParaDest-210"><a id="_idTextAnchor212"/>Light userdata</h2>
<p>Light userdata represents a C/C++ pointer. It is <a id="_idIndexMarker434"/>a value type and the value is passed <a id="_idIndexMarker435"/>around. You push a pointer in C/C++ code onto the stack with <code>lua_pushlightuserdata</code>. You cannot create light userdata with the Lua library.</p>
<h2 id="_idParaDest-211"><a id="_idTextAnchor213"/>Full userdata</h2>
<p>Full userdata is a raw memory area<a id="_idIndexMarker436"/> allocated by the Lua library with a call to <code>lua_newuserdatauv</code>. It is an object type <a id="_idIndexMarker437"/>and only its reference is passed around.</p>
<p>Because full userdata is created by Lua in the heap, Lua garbage collection comes into the picture. On the C++ side, you can provide a <em class="italic">finalizer</em> by providing the <code>__gc</code> metamethod.</p>
<p>For a complete example of how to utilize full userdata to access C++ objects in Lua, check <code>LuaModuleExporter</code>.</p>
<h1 id="_idParaDest-212"><a id="_idTextAnchor214"/>Summary</h1>
<p>In this chapter, we briefly recapped all communication mechanisms between Lua and C++. This should have sufficiently reinforced your learnings so far.</p>
<p>We also learned how to produce a standalone C++ module as a shared library. This opens new ways for you to organize your projects.</p>
<p>In the next chapter, we will talk more about resource management.</p>
</div>
</div></body></html>