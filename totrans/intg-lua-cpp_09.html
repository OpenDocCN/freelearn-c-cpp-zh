<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer065">
<h1 class="chapter-number" id="_idParaDest-193"><a id="_idTextAnchor195"/>9</h1>
<h1 id="_idParaDest-194"><a id="_idTextAnchor196"/>Recapping Lua-C++ Communication Mechanisms</h1>
<p>In <em class="italic">Part 2</em> of this book, we learned how to call Lua from C++. In <em class="italic">Part 3</em>, we learned how to call C++ from Lua. In the course of this book, we have explored many examples, some of which depend on advanced <span class="No-Break">C++ techniques.</span></p>
<p>This chapter will summarize all the communication mechanisms between Lua and C++, stripping away most of the C++ details. We will also dig deeper into some of the topics that we have not demonstrated in the <span class="No-Break">examples yet.</span></p>
<p>You can use this chapter to recap what you have learned. For each topic, we will list some important Lua library functions. You can check the Lua reference manual for more <span class="No-Break">related functions.</span></p>
<p>In the future, as you progress in your programming journey, you might adopt different C++ techniques in your projects. In such cases, this chapter will be a useful source for <span class="No-Break">quick reference.</span></p>
<p>We will cover the <span class="No-Break">following topics:</span></p>
<ul>
<li><span class="No-Break">The stack</span></li>
<li>Calling Lua <span class="No-Break">from C++</span></li>
<li>Calling C++ <span class="No-Break">from Lua</span></li>
<li>Implementing standalone <span class="No-Break">C++ modules</span></li>
<li>Storing state <span class="No-Break">in Lua</span></li>
<li><span class="No-Break">Userdata</span></li>
</ul>
<h1 id="_idParaDest-195"><a id="_idTextAnchor197"/>Technical requirements</h1>
<p>You can access the source code for this chapter <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter09"><span class="No-Break">https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter09</span></a><span class="No-Break">.</span></p>
<p>You can access the Lua reference manual and develop the habit of frequently checking for API details <span class="No-Break">at </span><a href="https://www.lua.org/manual/5.4/"><span class="No-Break">https://www.lua.org/manual/5.4/</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-196"><a id="_idTextAnchor198"/>The stack</h1>
<p>The Lua stack can serve <span class="No-Break">two purposes:</span></p>
<ul>
<li><em class="italic">Exchange data between C++ and Lua.</em> Passing function arguments and retrieving function<a id="_idIndexMarker400"/> return values fit into <span class="No-Break">this usage.</span></li>
<li><em class="italic">Keep intermediate results.</em> For example, we can keep a table reference in the stack until we are done with the table; we can push some values onto the stack and then pop and use them <span class="No-Break">as upvalues.</span></li>
</ul>
<p>The Lua stack comes in <span class="No-Break">two forms:</span></p>
<ul>
<li><em class="italic">The public stack that comes with the Lua state.</em> Once a Lua state is created via <strong class="source-inline">luaL_newstate</strong> or <strong class="source-inline">lua_newstate</strong>, you can pass the state around and the same Lua stack is<a id="_idIndexMarker401"/> accessible<a id="_idIndexMarker402"/> to all functions that can access the <span class="No-Break">Lua state.</span></li>
<li><em class="italic">The private stack for each </em><strong class="source-inline">lua_CFunction</strong><em class="italic"> call.</em> The stack is only accessible to a<a id="_idIndexMarker403"/> function call. Calling<a id="_idIndexMarker404"/> the same <strong class="source-inline">lua_CFunction</strong> multiple times will not share the same stack. So, the stack that is passed to a <strong class="source-inline">lua_CFunction</strong> call is private to the <span class="No-Break">function call.</span></li>
</ul>
<h2 id="_idParaDest-197"><a id="_idTextAnchor199"/>Pushing onto the stack</h2>
<p>You can<a id="_idIndexMarker405"/> use <strong class="source-inline">lua_pushXXX</strong> functions to push a value or an object reference onto the stack – for <span class="No-Break">example, </span><span class="No-Break"><strong class="source-inline">lua_pushstring</strong></span><span class="No-Break">.</span></p>
<p>Check the Lua reference manual for a list of <span class="No-Break">such functions.</span></p>
<h2 id="_idParaDest-198"><a id="_idTextAnchor200"/>Querying the stack</h2>
<p>You can use <strong class="source-inline">lua_isXXX</strong> functions to check if a given stack position holds an item of a <span class="No-Break">certain type.</span></p>
<p>You can use <strong class="source-inline">lua_toXXX</strong> functions to convert a given stack position into a certain type. Those functions will always succeed, although the resulting values might be a surprise if the stack position is<a id="_idIndexMarker406"/> holding an item of a <span class="No-Break">different type.</span></p>
<p>You can check the Lua reference manual for a list of <span class="No-Break">such functions.</span></p>
<h2 id="_idParaDest-199"><a id="_idTextAnchor201"/>Other stack operations</h2>
<p>There are some other<a id="_idIndexMarker407"/> frequently used <span class="No-Break">stack operations.</span></p>
<h3>Ensuring stack size</h3>
<p>The Lua stack is created<a id="_idIndexMarker408"/> with a predefined size that should be big enough for most operations. If you need to push a lot of items onto the stack, you can ensure that the stack size can meet your needs by calling the <span class="No-Break">following function:</span></p>
<pre class="source-code">
int lua_checkstack (lua_State *L, int n);</pre>
<p><strong class="source-inline">n</strong> is the <span class="No-Break">required size.</span></p>
<h3>Counting items</h3>
<p>To check the <a id="_idIndexMarker409"/>number of items in the stack, use <strong class="source-inline">lua_gettop</strong>. The return value is <span class="No-Break">the count.</span></p>
<h3>Resetting the stack top</h3>
<p>To set the top of the<a id="_idIndexMarker410"/> stack to a certain index, use the <strong class="source-inline">lua_settop</strong> function, whose declaration is <span class="No-Break">as follows:</span></p>
<pre class="source-code">
void lua_settop (lua_State *L, int index);</pre>
<p>This can either clear some items from the top of the stack or pad the stack with nils. We can use it to clear temporary items from the stack efficiently, as can be seen in <strong class="source-inline">LuaModuleExporter::luaNew</strong> from <span class="No-Break">our examples:</span></p>
<pre class="source-code">
    T *obj = luaModuleDef.createInstance(L);
    lua_settop(L, 0);</pre>
<p>In <strong class="source-inline">luaNew</strong>, we passed the Lua state, thus the Lua stack, to an external factory method. Because we do not know <a id="_idIndexMarker411"/>how the factory method will use the Lua stack, we cleared the stack after the factory method returned to get rid of any possible <span class="No-Break">side effects.</span></p>
<h3>Copying another item</h3>
<p>If an item is<a id="_idIndexMarker412"/> already in the stack, you can push a copy of it onto the top of the stack quickly by calling <span class="No-Break">this function:</span></p>
<pre class="source-code">
void lua_pushvalue (lua_State *L, int index);</pre>
<p>This can save you some trouble if the value or object backing the item is hard <span class="No-Break">to get.</span></p>
<p>Some other stack operations are supported by the Lua library, but they are used infrequently to achieve complex effects. You can check them out in the <span class="No-Break">reference manual.</span></p>
<h1 id="_idParaDest-200"><a id="_idTextAnchor202"/>Calling Lua from C++</h1>
<p>To call Lua code from C++, we can use <strong class="source-inline">lua_pcall</strong>, which is declared <span class="No-Break">as</span><span class="No-Break"><a id="_idIndexMarker413"/></span><span class="No-Break"> follows:</span></p>
<pre class="source-code">
int lua_pcall(
    lua_State *L, int nargs, int nresults, int msgh);</pre>
<p>This will call a Lua callable, which can be a function or a chunk. You can push the Lua function to be called onto the stack, or compile a file or a string into a chunk and then place it onto the stack. <strong class="source-inline">nargs</strong> is the number of arguments for the callable. The arguments are pushed onto the stack above the callable. <strong class="source-inline">nresults</strong> is the count of return values the callable would return. Use <strong class="source-inline">LUA_MULTRET</strong> to indicate that you expect a variable count of return values. <strong class="source-inline">msgh</strong> is the stack index for an error <span class="No-Break">message handler.</span></p>
<p><strong class="source-inline">lua_pcall</strong> calls the callable in <em class="italic">protected mode</em>, which means that any error that may have occurred in the call chain is not propagated. Instead, an error status code is returned <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">lua_pcall</strong></span><span class="No-Break">.</span></p>
<p>In the <strong class="source-inline">LuaExecutor</strong> class that we have implemented, you can find many examples of calling Lua <span class="No-Break">from C++.</span></p>
<p>In the Lua reference <a id="_idIndexMarker414"/>manual, you can find other library functions similar to <strong class="source-inline">lua_pcall</strong>, although <strong class="source-inline">lua_pcall</strong> is the most frequently <span class="No-Break">used one.</span></p>
<h1 id="_idParaDest-201"><a id="_idTextAnchor203"/>Calling C++ from Lua</h1>
<p>To call C++ code <a id="_idIndexMarker415"/>from Lua, the C++ code needs to be exported via a <strong class="source-inline">lua_CFunction</strong> implementation, which is defined <span class="No-Break">as follows:</span></p>
<pre class="source-code">
typedef int (*lua_CFunction) (lua_State *L);</pre>
<p>For example, in <strong class="source-inline">LuaExecutor</strong>, we implemented <span class="No-Break">a function:</span></p>
<pre class="source-code">
int luaGetExecutorVersionCode(lua_State *L)
{
   lua_pushinteger(L, LuaExecutor::versionCode);
   return 1;
}</pre>
<p>This returns a single integer value to the Lua code. A simple way to export this function to the global table can be implemented <span class="No-Break">as follows:</span></p>
<pre class="source-code">
void registerHostFunctions(lua_State *L)
{
    lua_pushcfunction(L, luaGetExecutorVersionCode);
    lua_setglobal(L, "host_version");
}</pre>
<p>You can use <strong class="source-inline">lua_pushcfunction</strong> to push <strong class="source-inline">lua_CFunction</strong> onto the stack and then assign it to a variable of <span class="No-Break">your choice.</span></p>
<p>However, more than likely, you should export a group of functions as <span class="No-Break">a module.</span></p>
<h2 id="_idParaDest-202"><a id="_idTextAnchor204"/>Exporting C++ modules</h2>
<p>To export a C++ module, you simply need to export a table of functions to Lua. In <strong class="source-inline">LuaExecutor</strong>, we have<a id="_idIndexMarker416"/> implemented it <span class="No-Break">as follows:</span></p>
<pre class="source-code">
void LuaExecutor::registerModule(LuaModule &amp;module)
{
    lua_createtable(L, 0, module.luaRegs().size() - 1);
    int nUpvalues = module.pushLuaUpvalues(L);
    luaL_setfuncs(L, module.luaRegs().data(), nUpvalues);
    lua_setglobal(L, module.luaName().c_str());
}</pre>
<p>The process is to first create a table and push the reference onto the stack with <strong class="source-inline">lua_createtable</strong>. Then, you can push <em class="italic">shared upvalues</em> (we will recap upvalues later in this chapter), and finally add the list of functions to the table <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">luaL_setfuncs</strong></span><span class="No-Break">.</span></p>
<p>If you do not need upvalues, there is a shortcut that you <span class="No-Break">can use:</span></p>
<pre class="source-code">
void luaL_newlib (lua_State *L, const luaL_Reg l[]);</pre>
<p>Both <strong class="source-inline">luaL_newlib</strong> and <strong class="source-inline">luaL_setfuncs</strong> take a list of the following structure to describe <span class="No-Break">the functions:</span></p>
<pre class="source-code">
typedef struct luaL_Reg {
    const char *name;
    lua_CFunction func;
} luaL_Reg;</pre>
<p>The structure provides <strong class="source-inline">lua_CFunction</strong> with a <strong class="source-inline">name</strong> value, which is used as the table <span class="No-Break">entry key.</span></p>
<h1 id="_idParaDest-203"><a id="_idTextAnchor205"/>Implementing standalone C++ modules</h1>
<p>So far in this book, we have only explicitly registered C++ modules to Lua in C++ code. However, there is another way to provide a C++ module <span class="No-Break">to Lua.</span></p>
<p>You can produce a shared library<a id="_idIndexMarker417"/> for a module and place it in Lua’s search path. When the Lua code <em class="italic">requires</em> the module, Lua will load the shared <span class="No-Break">library automatically.</span></p>
<p>By reusing our <strong class="source-inline">Destinations</strong> class, this is simple to implement. Create a file named <strong class="source-inline">DestinationsModule.cpp</strong> and fill it exactly <span class="No-Break">as follows:</span></p>
<pre class="source-code">
#include "Destinations.h"
#include "LuaModuleExporter.hpp"
#include &lt;lua.hpp&gt;
namespace {
    LuaModuleExporter module =
        LuaModuleExporter&lt;Destinations&gt;::make(
            DestinationsLuaModuleDef::def);
}
extern "C" {
int luaopen_destinations(lua_State *L)
{
    lua_createtable(L, 0, module.luaRegs().size() - 1);
    int nUpvalues = module.pushLuaUpvalues(L);
    luaL_setfuncs(L, module.luaRegs().data(), nUpvalues);
    return 1;
}
}</pre>
<p>The module that’s been implemented is called <strong class="source-inline">destinations</strong>. The code-level contract Lua requires is <span class="No-Break">as follows:</span></p>
<ul>
<li>You need to provide <strong class="source-inline">lua_CFunction</strong>, whose name must begin with <strong class="source-inline">luaopen_</strong>, and then have the module <span class="No-Break">name appended</span></li>
<li><strong class="source-inline">lua_CFunction</strong> needs to leave what it creates in <span class="No-Break">the stack</span></li>
</ul>
<p>The code for <strong class="source-inline">luaopen_destinations</strong> is <a id="_idIndexMarker418"/>almost identical to that of <strong class="source-inline">LuaExecutor::registerModule</strong>, which we explained in the previous section. The only difference is that we have left the table reference in the stack because the Lua <strong class="source-inline">require</strong> function will <span class="No-Break">pop it.</span></p>
<p class="callout-heading">extern “C”</p>
<p class="callout">By default, the C++ compiler will mangle the C++ function name. This means that after the function is compiled, the function will have a symbol name more complex than what it declares to be in the source code. To prevent this from happening, you can place the function declaration inside an <strong class="source-inline">extern "C"</strong> block. Otherwise, Lua won’t be able to find the function as the contract is broken <span class="No-Break">after compilation.</span></p>
<h2 id="_idParaDest-204"><a id="_idTextAnchor206"/>Compiling the standalone module</h2>
<p>To compile the<a id="_idIndexMarker419"/> shared library, add the following lines to <span class="No-Break">your </span><span class="No-Break"><strong class="source-inline">Makefile</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
DESTINATIONS_O = Destinations.o DestinationsModule.o
DESTINATIONS_SO = destinations.so
destinations: ${DESTINATIONS_O}
    $(CXX) $(CXXFLAGS) $(CPPFLAGS) $(LDFLAGS) -shared \
        -o $(DESTINATIONS_SO) ${DESTINATIONS_O} -llua</pre>
<p>In a Terminal, execute <strong class="source-inline">make destinations</strong> to create the shared library. You will get a file named <strong class="source-inline">destinations.so</strong>, which is the binary file Lua <span class="No-Break">will load.</span></p>
<h2 id="_idParaDest-205"><a id="_idTextAnchor207"/>Testing the standalone module</h2>
<p>To test the standalone<a id="_idIndexMarker420"/> module, in the folder where <strong class="source-inline">destinations.so</strong> resides, start a Lua interactive interpreter and execute the <span class="No-Break">following statements:</span></p>
<pre class="source-code">
Chapter09 % ../lua/src/lua
Lua 5.4.6 Copyright (C) 1994-2023 Lua.org, PUC-Rio
&gt; <strong class="bold">Destinations = require "destinations"</strong>
&gt; dst = Destinations.new("Shanghai", "Tokyo")
Destinations instance created: 0x155a04210
&gt; dst:wish("London", "Paris", "Amsterdam")
&gt; dst:went("Paris")
&gt; print("Visited:", dst:list_visited())
Visited: Paris
&gt; print("Unvisited:", dst:list_unvisited())
Unvisited: Amsterdam London Shanghai Tokyo
&gt; os.exit()
Destinations instance destroyed: 0x155a04210</pre>
<p>The most important statement is the <strong class="source-inline">require</strong> statement. This loads <strong class="source-inline">destinations.so</strong> and assigns the module to the <strong class="source-inline">Destinations</strong> <span class="No-Break">global variable.</span></p>
<p>We started the Lua interactive interpreter in the same folder where the module binary resides because <strong class="source-inline">require</strong> will search the current working directory for modules. Alternatively, you can put the library in a system search path. You can check the reference manual to learn more about <strong class="source-inline">require</strong> and <span class="No-Break">its behaviors.</span></p>
<p>A standalone C++ module is useful when you need to reuse the module in the binary form across multiple projects or enforce code isolation on the C++ side, but this is just a <span class="No-Break">design choice.</span></p>
<h1 id="_idParaDest-206"><a id="_idTextAnchor208"/>Storing state in Lua</h1>
<p>There are two ways to store state in Lua for <strong class="source-inline">lua_CFunction</strong>: <em class="italic">upvalues</em> and <em class="italic">the registry</em>. Let’s recap them<a id="_idIndexMarker421"/> and dig deeper <span class="No-Break">into upvalues.</span></p>
<h2 id="_idParaDest-207"><a id="_idTextAnchor209"/>Upvalues</h2>
<p>To<a id="_idIndexMarker422"/> introduce the complete<a id="_idIndexMarker423"/> definition for upvalues, we need to introduce <strong class="bold">Lua C closures</strong> at the same time. To<a id="_idIndexMarker424"/> quote the Lua <span class="No-Break">reference manual:</span></p>
<p class="author-quote">When a C function is created, it is possible to associate some values with it, thus creating a C closure; these values are called upvalues and are accessible to the function whenever it is called.</p>
<p>To put it simply, the <a id="_idIndexMarker425"/>closure is still our old friend <strong class="source-inline">lua_CFunction</strong>. When you associate some values with it, it becomes a closure, and the values <span class="No-Break">become upvalues.</span></p>
<p>It is important to note that Lua C closures and upvalues <span class="No-Break">are inseparable.</span></p>
<p>To create a closure, use the following <span class="No-Break">library function:</span></p>
<pre class="source-code">
void lua_pushcclosure(
    lua_State *L, lua_CFunction fn, int n);</pre>
<p>This creates a closure from <strong class="source-inline">lua_CFunction</strong> and associates <strong class="source-inline">n</strong> values <span class="No-Break">with it.</span></p>
<p>To see it in action, let’s solve the design problem from the <span class="No-Break">previous chapter:</span></p>
<p class="author-quote">We are creating objects in <strong class="source-inline">LuaModuleDef</strong> but destroying them in <strong class="source-inline">LuaModuleExporter</strong>. For a better design, the same class should destroy the objects it creates.</p>
<h3>Implementing a Lua C closure</h3>
<p>The following feature is a<a id="_idIndexMarker426"/> continuation of the previous chapter. You can revisit the previous chapter to get a better understanding if you <span class="No-Break">need to.</span></p>
<p>To do this, we can implement a <strong class="source-inline">destroyInstance</strong> member variable for <strong class="source-inline">LuaModuleDef</strong>, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
struct LuaModuleDef
{
    ...
    const std::function&lt;void(T *)&gt; destroyInstance =
        [](T *obj) { delete obj; };
    ...
};</pre>
<p>Now, objects will be created<a id="_idIndexMarker427"/> and destroyed in the same <strong class="source-inline">LuaModuleDef</strong> entity. To use <strong class="source-inline">destroyInstance</strong>, modify <strong class="source-inline">LuaModuleExporter::luaDelete</strong>, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
static int luaDelete(lua_State *L)
{
    auto luaModuleDef = getExporter(L)-&gt;luaModuleDef;
    T *obj = *reinterpret_cast&lt;T **&gt;(
        lua_touserdata(L, 1));
    luaModuleDef.destroyInstance(obj);
    return 0;
}</pre>
<p>Recall that <strong class="source-inline">getExporter</strong> is used to retrieve the first upvalue, which is a pointer to <span class="No-Break">the exporter:</span></p>
<pre class="source-code">
static LuaModuleExporter&lt;T&gt; *getExporter(lua_State *L)
{
    return reinterpret_cast&lt;LuaModuleExporter&lt;T&gt; *&gt;(
        lua_touserdata(L, lua_upvalueindex(1)));
}</pre>
<p>This works for <strong class="source-inline">luaNew</strong> because <strong class="source-inline">LuaModuleExporter</strong> is inherited from <strong class="source-inline">LuaModule</strong>, which<a id="_idIndexMarker428"/> pushes <strong class="source-inline">this</strong> as an upvalue in its <span class="No-Break">default implementation:</span></p>
<pre class="source-code">
class LuaModule
{
public:
    virtual int pushLuaUpvalues(lua_State *L)
    {
        lua_pushlightuserdata(L, this);
        return 1;
    }
};</pre>
<p>Then, the pushed upvalue is used as shared upvalues for all exported functions <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">LuaExecutor::registerModule</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
void LuaExecutor::registerModule(LuaModule &amp;module)
{
    lua_createtable(L, 0, module.luaRegs().size() - 1);
    <strong class="bold">int nUpvalues = module.pushLuaUpvalues(L);</strong>
    <strong class="bold">luaL_setfuncs(L, module.luaRegs().data(), nUpvalues);</strong>
    lua_setglobal(L, module.luaName().c_str());
}</pre>
<p>Shared upvalues are pushed onto the stack once and get associated with all the functions provided <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">luaL_setfuncs</strong></span><span class="No-Break">.</span></p>
<p class="callout-heading">Shared upvalues are not really shared</p>
<p class="callout">The so-called shared upvalues are copied for each function during setup. Afterward, the functions access their own copies of the upvalues. In the Lua reference manual, these are called shared upvalues because they are<a id="_idIndexMarker429"/> only pushed onto the stack once and used for all functions to be registered, which is only relevant to API invocations. I think this term is misleading. You should think of these as just <span class="No-Break">plain upvalues.</span></p>
<p>However, <strong class="source-inline">getExporter</strong> will not <a id="_idIndexMarker430"/>work for <strong class="source-inline">luaDelete</strong> because <strong class="source-inline">luaDelete</strong> is not an exported function and is not passed to <strong class="source-inline">luaL_setfuncs</strong>. To support <strong class="source-inline">luaDelete</strong>, modify <strong class="source-inline">luaNew</strong>, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
static int luaNew(lua_State *L)
{
    auto exporter = getExporter(L);
    auto luaModuleDef = exporter-&gt;luaModuleDef;
    ...
    if (type == LUA_TNIL)
    {
        ...
        <strong class="bold">lua_pushlightuserdata(L, exporter);</strong>
        <strong class="bold">lua_pushcclosure(L, luaDelete, 1);</strong>
        lua_setfield(L, -2, "__gc");
    }
    ...
}</pre>
<p>We only need to push <strong class="source-inline">exporter</strong> as an upvalue for <strong class="source-inline">luaDelete</strong> and make <strong class="source-inline">luaDelete</strong> <span class="No-Break">a closure.</span></p>
<p>Now, <strong class="source-inline">LuaModuleExporter</strong> has a better design as it delegates both object construction and object destruction to <strong class="source-inline">LuaModuleDef</strong>. Also, it utilizes both upvalues (for <strong class="source-inline">luaDelete</strong>) and shared upvalues (for <strong class="source-inline">luaNew</strong>) at the same time in the <strong class="source-inline">getExporter</strong> helper function. This shows that shared upvalues are no different from upvalues after they are<a id="_idIndexMarker431"/> <span class="No-Break">set up.</span></p>
<h2 id="_idParaDest-208"><a id="_idTextAnchor210"/>The registry</h2>
<p>The registry is a<a id="_idIndexMarker432"/> predefined Lua table that is only accessible to C/C++ code. For a Lua state, the registry is shared for all C/C++ functions, so table key names should be selected carefully to <span class="No-Break">avoid collision.</span></p>
<p>Notably, by convention, <em class="italic">full userdata</em> places its metatable in the registry <span class="No-Break">via </span><span class="No-Break"><strong class="source-inline">luaL_newmetatable</strong></span><span class="No-Break">.</span></p>
<p><em class="italic">Put simply, the registry is a Lua table that the Lua language treats specially and provides a few helper </em><span class="No-Break"><em class="italic">functions for.</em></span></p>
<h1 id="_idParaDest-209"><a id="_idTextAnchor211"/>Userdata</h1>
<p>The Lua userdata <a id="_idIndexMarker433"/>can be categorized into <em class="italic">light userdata</em> and <span class="No-Break"><em class="italic">full userdata</em></span><span class="No-Break">.</span></p>
<p>It is important to note that they are different things. In the Lua library, conventionally, light userdata is named lightuserdata, while full userdata is <span class="No-Break">named userdata.</span></p>
<h2 id="_idParaDest-210"><a id="_idTextAnchor212"/>Light userdata</h2>
<p>Light userdata represents a C/C++ pointer. It is <a id="_idIndexMarker434"/>a value type and the value is passed <a id="_idIndexMarker435"/>around. You push a pointer in C/C++ code onto the stack with <strong class="source-inline">lua_pushlightuserdata</strong>. You cannot create light userdata with the <span class="No-Break">Lua library.</span></p>
<h2 id="_idParaDest-211"><a id="_idTextAnchor213"/>Full userdata</h2>
<p>Full userdata is a raw memory area<a id="_idIndexMarker436"/> allocated by the Lua library with a call to <strong class="source-inline">lua_newuserdatauv</strong>. It is an object type <a id="_idIndexMarker437"/>and only its reference is <span class="No-Break">passed around.</span></p>
<p>Because full userdata is created by Lua in the heap, Lua garbage collection comes into the picture. On the C++ side, you can provide a <em class="italic">finalizer</em> by providing the <span class="No-Break"><strong class="source-inline">__gc</strong></span><span class="No-Break"> metamethod.</span></p>
<p>For a complete example of how to utilize full userdata to access C++ objects in Lua, <span class="No-Break">check </span><span class="No-Break"><strong class="source-inline">LuaModuleExporter</strong></span><span class="No-Break">.</span></p>
<h1 id="_idParaDest-212"><a id="_idTextAnchor214"/>Summary</h1>
<p>In this chapter, we briefly recapped all communication mechanisms between Lua and C++. This should have sufficiently reinforced your learnings <span class="No-Break">so far.</span></p>
<p>We also learned how to produce a standalone C++ module as a shared library. This opens new ways for you to organize <span class="No-Break">your projects.</span></p>
<p>In the next chapter, we will talk more about <span class="No-Break">resource management.</span></p>
</div>
</div></body></html>