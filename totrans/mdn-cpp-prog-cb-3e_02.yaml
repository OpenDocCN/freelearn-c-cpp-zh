- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with Numbers and Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Numbers and strings are the fundamental types of any programming language; all
    other types are based on or composed of these. Developers are confronted all the
    time with tasks such as converting between numbers and strings, parsing and formatting
    strings, and generating random numbers. This chapter is focused on providing useful
    recipes for these common tasks using modern C++ language and library features.
  prefs: []
  type: TYPE_NORMAL
- en: 'The recipes included in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the various numeric types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limits and other properties of numeric types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting between numeric and string types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the various character and string types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Printing Unicode characters to the output console
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating pseudo-random numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Properly initializing a pseudo-random number generator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating cooked user-defined literals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating raw user-defined literals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using raw string literals to avoid escaping characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a library of string helpers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying the format of a string using regular expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing the content of a string using regular expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replacing the content of a string using regular expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `std::string_view` instead of constant string references
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formatting and printing text with `std::format` and `std::print`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `std::format` with user-defined types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start this chapter by looking at the different numeric types that exist
    in the C++ programming language.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the various numeric types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C++ programming language defines a multitude of arithmetic types; these
    are types on which arithmetic operations (addition, subtraction, multiplication,
    division, modulo) can be performed. This category includes character, integral,
    and floating-point types. Many of these types are inherited from the C programming
    languages, while some have been added to C++ in recent versions of the standard.
    A typical problem with the arithmetic types is that, unlike many other programming
    languages, most of them don’t have a fixed size. The size varies with the target
    platform and the standard only guarantees a minimum one. In this recipe, we will
    learn about the various integral and floating-point types.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use one of the available numeric types depending on the kind of value you need
    to represent:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To represent an integral value (when the range doesn’t really matter), use
    the `int` type. This is the default basic (signed) integer type, typically with
    a size of 32 bits, but not guaranteed. You can use it for values such as the age
    of a person, the day, month, and year in a date, the rating of a movie or book,
    the number of items in a collection, and countless other things:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use signedness (`signed`/`unsigned`) and size (`short`/`long`/`long long`)
    modifiers when you need to impose restrictions on the range of possible values
    or the memory representation. For instance, you may want to use unsigned integers
    to represent values that cannot have negative values. Mixing signed and unsigned
    integers should be avoided. On the other hand, you may want to optimize the memory
    used for storing some values, such as those representing a date, in which case
    you could use a `short int`, guaranteed to be at least 16 bits. If you need to
    represent large values, such as the size of a file, you can use `unsigned long
    long int`, which is guaranteed to be at least 64 bits:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To represent `std::array` indexes (which cannot be negative), the number of
    elements in a collection (such as standard containers), or the result of the `sizeof`
    operator, use `std::size_t`. This is an unsigned integer type of at least 16 bits.
    The standard containers defined a member type alias called `size_type` for size
    and indexing the container, and this type is typically a synonym for `std::size_t`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To store the result of a pointer arithmetic operation, or present a C-like array
    index (which can be negative), use `std::ptrdiff_t`. The C++ standard containers
    define a member type alias called `difference_type` to store differences between
    iterators, and this is typically defined as a synonym for `std::ptrdiff_t`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you need to store a value that needs a guaranteed range, use one of the
    `std::int8_t`, `std::int16_t`, `std::int32_t`, or `std::int64_t` types. Although
    these are optional, they are defined for all modern architectures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you need to store non-negative values or perform bit manipulations on values
    of a guaranteed range, use one of the `std::uint8_t`, `std::uint16_t`, `std::uint32_t`,
    or `std::uint64_t` types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you need to store a value that needs a guaranteed range and, at the same
    time, you want to optimize for fastest access, use one of the `std::int_fast8_t`,
    `std::int_fast16_t`, `std::int_fast32_t`, or `std::int_fast64_t` types (or their
    unsigned counterparts). These are guaranteed to be available on all target architectures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you need to store a value that needs a guaranteed range and, at the same
    time, you want to optimize the memory usage, use one of `std::int_least8_t`, `std::int_last16_t`,
    `std::int_least32_t`, or `std::int_least64_t` (or their unsigned counterparts).
    These are also guaranteed to be available on all target architectures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To represent a real number, use the type `double`. This is the default floating-point
    type, with a size of 64 bits. The name indicates a double precision type, as opposed
    to a single precision type (using 32 bits), implemented with the `float` type.
    An extended precision type, called `long double`, is also available. The standard
    does not specify its actual precision but requires that it’s at least the same
    as the `double` type. On some compilers, this can be a quadruple precision (using
    128 bits), although some, such as VC++, treat it as equal to `double`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The C++ language has one basic integral type, `int`, and several modifiers
    that can be applied to it, for signedness and size. The type `int` is a signed
    one, so `int` and `signed int` are the same type. The use of `int` is actually
    optional when using a modifier. Therefore, the following types are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Equivalent to** |'
  prefs: []
  type: TYPE_TB
- en: '| `signed` | `int` |'
  prefs: []
  type: TYPE_TB
- en: '| `unsigned` | `unsigned int` |'
  prefs: []
  type: TYPE_TB
- en: '| `short` | `short int` |'
  prefs: []
  type: TYPE_TB
- en: '| `signed short` | `short int` |'
  prefs: []
  type: TYPE_TB
- en: '| `signed short int` | `short int` |'
  prefs: []
  type: TYPE_TB
- en: '| `long` | `long int` |'
  prefs: []
  type: TYPE_TB
- en: '| `long long` | `long long int` |'
  prefs: []
  type: TYPE_TB
- en: '| `unsigned short` | `unsigned short int` |'
  prefs: []
  type: TYPE_TB
- en: '| `unsigned long` | `unsigned long int` |'
  prefs: []
  type: TYPE_TB
- en: '| `unsigned long long` | `unsigned long long int` |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2.1: Integral type equivalence'
  prefs: []
  type: TYPE_NORMAL
- en: 'This table does not list all the possible combinations, only several examples.
    The order of the type modifiers is not specified; therefore, any order is permitted.
    The following table lists several types that represent the same type:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Equivalent type** |'
  prefs: []
  type: TYPE_TB
- en: '| `long long unsigned int` | `unsigned long long int` |'
  prefs: []
  type: TYPE_TB
- en: '| `long unsigned long int` |'
  prefs: []
  type: TYPE_TB
- en: '| `int long long unsigned` |'
  prefs: []
  type: TYPE_TB
- en: '| `unsigned long long int` |'
  prefs: []
  type: TYPE_TB
- en: '| `int long unsigned long` |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2.2: Integral type equivalence with modifiers'
  prefs: []
  type: TYPE_NORMAL
- en: Even though the order is undefined, it is a common practice to start with the
    signedness modifier, then the size modifier, and finally the `int` type. Therefore,
    the canonical form for the types on the left column in the previous table is `unsigned
    long long int`.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of the signedness or size of an integral type, a process called *overflow*
    or *underflow* can occur. Overflow occurs when an attempt to store a value greater
    than the maximum value of the data type happens. Underflow occurs in the opposite
    case, when an attempt to store a value smaller than the minimum value of the data
    type happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider the case of the `short` type. This is a signed integer type
    that can store values in the range of -32,768 to 32,767\. What happens if we want
    to store 32,768? Since this is greater than the maximum, an overflow occurs. The
    decimal 32,767 is 01111111 11111111 in binary and the next value is 10000000 00000000,
    which, on a 16-bit representation, is -32,768 in decimal. The following table
    shows overflows and underflows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Value to store** | **Stored value** |'
  prefs: []
  type: TYPE_TB
- en: '| -32771 | 32765 |'
  prefs: []
  type: TYPE_TB
- en: '| -32770 | 32766 |'
  prefs: []
  type: TYPE_TB
- en: '| -32769 | 32767 |'
  prefs: []
  type: TYPE_TB
- en: '| -32768 | -32768 |'
  prefs: []
  type: TYPE_TB
- en: '| … | … |'
  prefs: []
  type: TYPE_TB
- en: '| 32767 | 32767 |'
  prefs: []
  type: TYPE_TB
- en: '| 32768 | -32768 |'
  prefs: []
  type: TYPE_TB
- en: '| 32769 | -32767 |'
  prefs: []
  type: TYPE_TB
- en: '| 32770 | -32765 |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2.3: Examples of short int values with overflow and underflow'
  prefs: []
  type: TYPE_NORMAL
- en: 'The same examples are shown in a different form in the following image, which
    you might find simpler to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21549_02_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: Example of short int values with overflow and underflow'
  prefs: []
  type: TYPE_NORMAL
- en: 'If, instead of `short`, we consider the `unsigned short` type, the same problems
    occur, although they might be easier to understand. The range for `unsigned short`
    is 0 to 65,535\. Attempting to store 65,536 will result in the value 0 being stored.
    Similarly, attempting to store 65,537 will result in the value 1 being stored
    instead. This is the result of the modulo operation between the value to be stored
    and the number of values that can be stored by the data type. In the case of `unsigned
    short`, this is 2^16 or 62,536\. For underflow, the result happens in a similar
    way. The value -1 becomes 65,535, -2 becomes 65,534, and so forth. This is the
    same as adding the negative value to 65,536 and then performing the modulo 65,536
    operation. The overflows and underflows are shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Value to store** | **Stored value** |'
  prefs: []
  type: TYPE_TB
- en: '| -2 | 65534 |'
  prefs: []
  type: TYPE_TB
- en: '| -1 | 65535 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| … | … |'
  prefs: []
  type: TYPE_TB
- en: '| 65535 | 65535 |'
  prefs: []
  type: TYPE_TB
- en: '| 65536 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 65537 | 1 |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2.4: Examples of unsigned short int with overflow and underflow'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the same values are exemplified in the next image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21549_02_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: Examples of unsigned short int with overflow and underflow'
  prefs: []
  type: TYPE_NORMAL
- en: 'A significant problem with integral types in C++ is the lack of specification
    for their size. The only well-defined size is for the `char` type (and its `signed`
    and `unsigned` modifiers), which must be 1\. For the rest, the following relation
    applies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In practice, on most platforms, `short` is 16-bit, `int` and `long` are both
    32-bit, and `long long` is 64-bit. However, there are platforms where `long` and
    `long long` are both 64-bit or where `int` is 16-bit. To overcome this heterogeneity,
    the C++11 standard introduced a series of fixed-width integer types. These are
    defined in the `<cstdint>` header and are grouped into two categories:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A category of types that are optional and might not be available on some platforms.
    These types have an exact number of bits, as specified by their name:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int8_t` and `uint8_t` are 8-bit'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int16_t` and `uint16_t` are 16-bit'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int32_t` and `uint32_t` are 32-bit'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int64_t` and `uint64_t` are 64-bit'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: There are also `intptr_t` and `uintptr_t` that have a size large enough to store
    a pointer to void
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A category of types that are mandatory and, therefore, available on all platforms.
    These, in turn, are grouped into two categories:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One that is optimized for fast access; these are called `int_fastX_t` and `uint_fastX_t`,
    where `X` is 8, 16, 32, or 64, representing the number of bits. These types provide
    the integral type that is fastest to access on a particular architecture that
    also has a width at least the size `X`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: One that is optimized for memory consumption; these are called `int_leastX_t`
    and `uint_leastX_t`, where `X` is 8, 16, 32, or 64, representing the number of
    bits. These types provide the integral type that is the smallest to represent
    on a particular architecture but that also has a width of at least the size `X`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In practice, most compilers treat the 8-bit types (`int8_t`, `uint8_t`, `int_least8_t`,
    `uint_least8_t`, `int_fast8_t`, and `uint_fast8_t`) as identical to `signed char`
    and `unsigned char`. This means that on different systems, a program using them
    may behave differently from a program using the other fixed-width integer types.
    Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Both `x` and `y` are of fixed-width integer types and both are assigned the
    value 42\. However, when printing their value to the console, `x` will be printed
    as `*` instead of 42\. Keep in mind, though, that this is not a guarantee as the
    behavior is system-dependent.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, you might want to avoid using the 8-bit fixed-width integer types
    and prefer `int16_t`/`uint16_t` or one of the fast/least variants.
  prefs: []
  type: TYPE_NORMAL
- en: 'When writing numerical literals, you can use the single quotation mark (`''`)
    as a digit separator. This makes it easier to read large numbers, and perhaps
    compare them visually. It can be used for decimal, hexadecimal, octal, and binary
    numbers, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The digit separators are ignored when determining the numerical value, so their
    position is irrelevant. This means you can write numbers in formats that have
    no practical meaning without producing an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Understanding the various character and string types*, to learn about the
    different character and string types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limits and other properties of numeric types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, it is necessary to know and use the minimum and maximum values that
    can be represented with a numeric type, such as `char`, `int`, or `double`. Many
    developers use standard C macros for this, such as `CHAR_MIN`/`CHAR_MAX`, `INT_MIN`/`INT_MAX`,
    and `DBL_MIN`/`DBL_MAX`. C++ provides a class template called `numeric_limits`
    with specializations for every numeric type, which enables you to query the minimum
    and maximum value of a type. However, `numeric_limits` is not limited to that
    functionality and offers additional constants for type property querying, such
    as whether a type is signed or not, how many bits it needs for representing its
    values, whether it can represent infinity for floating-point types, and many others.
    Prior to C++11, the use of `numeric_limits<T>` was limited because it could not
    be used in places where constants were needed (examples include the size of arrays
    and switch cases). Due to that, developers preferred to use C macros throughout
    their code. In C++11, that is no longer the case, as all the static members of
    `numeric_limits<T>` are now `constexpr`, which means they can be used everywhere
    a constant expression is expected.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `numeric_limits<T>` class template is available in the namespace `std` in
    the `<limits>` header.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use `std::numeric_limits<T>` to query various properties of a numeric type
    `T`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `min()` and `max()` static methods to get the smallest and largest
    finite numbers of a type. The following are examples of how these could be used:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use other static methods and static constants to retrieve other properties
    of a numeric type. In the following example, the `bits` variable is an `std::bitset`
    object that contains a sequence of bits that are necessary to represent the numerical
    value represented by the variable `n` (which is an integer):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In C++11, there is no limitation to where `std::numeric_limits<T>` can be used;
    therefore, preferably, use it over C macros in your modern C++ code.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `std::numeric_limits<T>` class template enables developers to query properties
    of numeric types. Actual values are available through specializations, and the
    standard library provides specializations for all the built-in numeric types (`char`,
    `short`, `int`, `long`, `float`, `double`, and so on). In addition, third parties
    may provide additional implementations for other types. An example could be a
    numeric library that implements a `bigint` type and a `decimal` type and provides
    specializations of `numeric_limits` for these types (such as `numeric_limits<bigint>`
    and `numeric_limits<decimal>`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following specializations of numeric types are available in the `<limits>`
    header. Note that specializations for `char16_t` and `char32_t` are new in C++11;
    the others were available previously. Apart from the specializations listed ahead,
    the library also includes specializations for every `cv-qualified` version of
    these numeric types, and they are identical to the unqualified specialization.
    For example, consider the type `int`; there are four actual specializations (and
    they are identical): `numeric_limits<int>`, `numeric_limits<const int>`, `numeric_limits<volatile
    int>`, and `numeric_limits<const volatile int>`. You can find the entire list
    of specializations at [https://en.cppreference.com/w/cpp/types/numeric_limits](https://en.cppreference.com/w/cpp/types/numeric_limits).'
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned earlier, in C++11, all static members of `std::numeric_limits`
    are `constexpr`, which means they can be used in all the places where constant
    expressions are needed. These have several major advantages over C++ macros:'
  prefs: []
  type: TYPE_NORMAL
- en: They are easier to remember, as the only thing you need to know is the name
    of the type, which you should know anyway, and not countless names of macros.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They support types that are not available in C, such as `char16_t` and `char32_t`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are the only possible solutions for templates where you don’t know the
    type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`min` and `max` are only two of the various properties of types it provides;
    therefore, its actual use is beyond the numeric limits shown. As a side note,
    for this reason, the class should have been perhaps called *numeric_properties*,
    instead of `numeric_limits`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following function template, `print_type_properties()`, prints the minimum
    and maximum finite values of the type, as well as other information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If we call the `print_type_properties()` function for `unsigned` `short`, `int`,
    and `double`, we will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **unsigned short** | **int** | **double** |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 2.5: The output of print_type_properties() for unsigned short, int, and
    double'
  prefs: []
  type: TYPE_NORMAL
- en: 'Please note that there is a difference between the `digits` and `digits10`
    constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '`digits` represents the number of bits (excluding the sign bit if present)
    and padding bits (if any) for integral types and the number of bits of the mantissa
    for floating-point types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`digits10` is the number of decimal digits that can be represented by a type
    without a change. To understand this better, let’s consider the case of `unsigned
    short`. This is a 16-bit integral type. It can represent numbers between 0 and
    65,536\. It can represent numbers up to five decimal digits, 10,000 to 65,536,
    but it cannot represent all five decimal digit numbers, as numbers from 65,537
    to 99,999 require more bits. Therefore, the largest numbers that it can represent
    without requiring more bits have four decimal digits (numbers from 1,000 to 9,999).
    This is the value indicated by `digits10`. For integral types, it has a direct
    relationship to constant `digits`; for an integral type, `T`, the value of `digits10`
    is `std::numeric_limits<T>::digits * std::log10(2)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s worth mentioning that the standard library types that are aliases of arithmetic
    types (such as `std::size_t`) may also be inspected with `std::numeric_limits`.
    On the other hand, other standard types that are not arithmetic types, such as
    `std::complex<T>` or `std::nullptr_t`, do not have `std::numeric_limits` specializations.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Converting between numeric and string types*, to learn how to convert between
    numbers and strings'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting between numeric and string types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Converting between number and string types is a ubiquitous operation. Prior
    to C++11, there was little support for converting numbers to strings and back,
    so developers had to resort mostly to type-unsafe functions, and they usually
    wrote their own utility functions in order to avoid writing the same code over
    and over again. With C++11, the standard library provides utility functions for
    converting between numbers and strings. In this recipe, you will learn how to
    convert between numbers and strings and the other way around using modern C++
    standard functions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All the utility functions mentioned in this recipe are available in the `<string>`
    header.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the following standard conversion functions when you need to convert between
    numbers and strings:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To convert from an integer or floating-point type to a string type, use `std::to_string()`
    or `std::to_wstring()`, as shown in the following code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To convert from a string type to an integer type, use `std::stoi()`, `std::stol()`,
    `std::stoll()`, `std::stoul()`, or `std::stoull()`, as shown in the following
    code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To convert from a string type to a floating-point type, use `std::stof()`,
    `std::stod()`, or `std::stold()`, as shown in the following code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In addition to `int`, these two functions have overloads for `long`, `long long`,
    `unsigned int`, `unsigned long`, `unsigned long long`, `float`, `double`, and
    `long double`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to the opposite conversion, there is an entire set of functions
    that have a name with the format **sto***n* (**string to number**), where *n*
    stands for **i** (`integer`), **l** (`long`), **ll** (`long long`), **ul** (`unsigned
    long`), or **ull** (`unsigned long long`). The following list shows the `stoi`
    function with its two overloads—one that takes an `std::string` and one that takes
    an `std::wstring` as the first parameter. In addition, there are similar functions
    called `stol`, `stoll`, `stoul`, `stoull`, `stof`, `stod`, and `stold`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The way the string to integral type functions work is by discarding all white
    spaces before a non-whitespace character, then taking as many characters as possible
    to form a signed or unsigned number (depending on the case), and then converting
    that to the requested integral type (`stoi()` will return an `integer`, `stoul()`
    will return an `unsigned long`, and so on). In all the following examples, the
    result is the integer `42`, except for the last example, where the result is `-42`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'A valid integral number may consist of the following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: A sign, plus (`+`) or minus (`-`) (optional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The prefix `0` to indicate an octal base (optional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The prefix `0x` or `0X` to indicate a hexadecimal base (optional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A sequence of digits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The optional prefix `0` (for octal) is applied only when the specified base
    is `8` or `0`. Similarly, the optional prefix `0x` or `0X` (for hexadecimal) is
    applied only when the specified base is `16` or `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The functions that convert a string to an integer have three parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The input string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pointer that, when not null, will receive the number of characters that were
    processed. This can include any leading white spaces that were discarded, the
    sign, and the base prefix, so it should not be confused with the number of digits
    the integral value has.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A number indicating the base; by default, this is `10`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The valid digits in the input string depend on the base. For base `2`, the only
    valid digits are `0` and `1`; for base `5`, they are `01234`. For base `11`, the
    valid digits are `0`-`9` and the characters `A` and `a`. This continues until
    we reach base `36`, which has the valid characters `0`-`9`, `A`-`Z`, and `a`-`z`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are additional examples of strings with numbers in various bases
    converted to decimal integers. Again, in all cases, the result is either `42`
    or `-42`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'An important thing to note is that these conversion functions throw an exception
    if the conversion fails. There are two exceptions that can be thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::invalid_argument` if the conversion cannot be performed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`std::out_of_range` if the converted value is outside the range of the result
    type (or if the underlying function sets `errno` to `ERANGE`):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The other set of functions that convert a string to a floating-point type are
    very similar, except that they don’t have a parameter for the numeric base. A
    valid floating-point value can have different representations in the input string:'
  prefs: []
  type: TYPE_NORMAL
- en: Decimal floating-point expression (optional sign, sequence of decimal digits
    with optional point, optional `e` or `E`, followed by exponent with optional sign)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binary floating-point expression (optional sign, `0x` or `0X` prefix, sequence
    of hexadecimal digits with optional point, optional `p` or `P`, followed by exponent
    with optional sign)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Infinity expression (optional sign followed by case-insensitive `INF` or `INFINITY`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A non-number expression (optional sign followed by case-insensitive `NAN` and
    possibly other alphanumeric characters)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apart from these formats, additional ones supported by the currently installed
    C locale may also be supported.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are various examples of converting strings to doubles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The floating-point base 2 scientific notation, seen earlier in the form `0xF.6E6666p3`,
    is not the topic of this recipe. However, for a clear understanding, a short description
    is provided, but it is recommended that you look at additional references for
    details (such as [https://en.cppreference.com/w/cpp/language/floating_literal](https://en.cppreference.com/w/cpp/language/floating_literal)).
    A floating-point constant in the base 2 scientific notation is composed of several
    parts:'
  prefs: []
  type: TYPE_NORMAL
- en: The hexadecimal prefix `0x`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An integer part; in this example, it was `F`, which in decimal is 15.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A fractional part, which, in this example, was `6E6666`, or `011011100110011001100110`
    in binary. To convert that into decimal, we need to add inverse powers of two:
    `1/4 + 1/8 + 1/32 + 1/64 + 1/128 + ...`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A suffix, representing a power of 2; in this example, `p3` means 2 at the power
    of 3.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value of the decimal equivalent is determined by multiplying the significant
    (composed of the integer and fractional parts) and the base at the power of the
    exponent.
  prefs: []
  type: TYPE_NORMAL
- en: For the given hexadecimal base 2 floating-point literal, the significant is
    `15.4312499...` (please note that digits after the seventh one are not shown),
    the base is 2, and the exponent is 3\. Therefore, the result is `15.4212499...
    * 8`, which is `123.44999980926514`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Limits and other properties of numeric types*, to learn about the minimum
    and maximum values, as well as the other properties of numerical types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the various character and string types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous recipe, we looked at the variety of integral and floating-point
    types. Another category of types, character types, is often a source of misunderstanding
    and confusion. As of C++20, there are five character data types in the C++ language:
    `char`, `wchar_t`, `char8_t`, `char16_t`, and `char32_t`. In this recipe, we will
    look at how these types differ and how they are meant to be used.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the available character types as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `char` type to store ASCII characters, Latin character sets (defined in
    the ISO-8859 standard), or even individual bytes of UTF-8 encoded characters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `wchar_t` type with the Windows API to store and manipulate UTF-16LE encoded
    characters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `char8_t` type to store individual bytes of UTF-8 encoded code points:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `char16_t` type to store UTF-16 encoded characters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `char32_t` type to store UTF-32 encoded characters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The built-in data type for storing characters from the early days of the C++
    language was the `char` type. This is an 8-bit data type that is different from
    both `signed char` and `unsigned char`. It is not a `typedef` of any of these
    two data types. You can test that using the `std::is_same` type trait:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Both of these lines will print 0\. This means you can have function overloads
    for all these three data types, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The standard does not specify whether `char` is a `signed` or `unsigned` type.
    Therefore, its signedness depends on the compiler or target platform. The type
    `char` is a `signed` type on x86 and x64 systems and `unsigned` on ARM.
  prefs: []
  type: TYPE_NORMAL
- en: The `char` data type can be used to store the characters from the ASCII character
    set and other 8-bit Latin character sets such as Latin-1, Latin-2, Latin/Cyrillic,
    Latin Nordic, and so on. It can also be used to store individual bytes of multi-byte
    character sets, the most widely used being the UTF-8 encoding of the Unicode set.
  prefs: []
  type: TYPE_NORMAL
- en: 'For dealing with fixed-width multi-byte character sets, the `wchar_t` type
    was introduced in C++98\. This is also a unique data type (not a `typedef` of
    some integral type). Its size is not specified and, therefore, also varies: it
    is 2 bytes on Windows and typically 4 bytes on Unix systems.'
  prefs: []
  type: TYPE_NORMAL
- en: This means that `wchar_t` should not be used when writing portable code. The
    `wchar_t` type is mostly used on Windows where it was adopted for storing 16-bit
    characters of the UTF-16LE encoding of the Unicode character set. This is the
    native character set of the Windows operating system.
  prefs: []
  type: TYPE_NORMAL
- en: In newer versions of the standard, three new character data types have been
    introduced. In C++11, `char32_t` and `char16_t` were added to represent 32-bit
    and 16-bit wide characters. They are intended to represent UTF-32 and UTF-16 encoded
    Unicode characters. Although they are each distinctive types, they are equal in
    size, signedness, and alignment with `uint_least32_t` and `uint_least16_t`, respectively.
    In C++20, the `char8_t` data type was added. This is intended to store UTF-8 code
    units (which are 8-bit). The `char8_t` type is a distinctive 8-bit type and has
    the same size, signedness, and alignment as `unsigned char`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can summarize all this information in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **C++ Standard** | **Size (bytes)** | **Sign** |'
  prefs: []
  type: TYPE_TB
- en: '| `char` | All versions | 1 | unspecified |'
  prefs: []
  type: TYPE_TB
- en: '| `wchar_t` | C++98 | Unspecified(typically, 2 or 4) | unspecified |'
  prefs: []
  type: TYPE_TB
- en: '| `char8_t` | C++20 | 1 | unsigned |'
  prefs: []
  type: TYPE_TB
- en: '| `char16_t` | C++11 | 2 | unsigned |'
  prefs: []
  type: TYPE_TB
- en: '| `char32_t` | C++11 | 4 | unsigned |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2.6: Summary of size and signedness of the C++ character types'
  prefs: []
  type: TYPE_NORMAL
- en: 'Strings of the `char` and `char8_t` types are called *narrow strings*, and
    strings of the `wchar_t`, `char16_t`, and `char32_t` types are called *wide strings*.
    The C++ standard provides a container for storing and manipulating sequences of
    characters. This is a class template that has several type aliases defined to
    simplify usage, as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Definition** | **C++ Standard** |'
  prefs: []
  type: TYPE_TB
- en: '| `std::string` | `std::basic_string<char>` | C++98 |'
  prefs: []
  type: TYPE_TB
- en: '| `std::wstring` | `std::basic_string<wchar_t>` | C++98 |'
  prefs: []
  type: TYPE_TB
- en: '| `std::u8string` | `std::basic_string<char8_t>` | C++20 |'
  prefs: []
  type: TYPE_TB
- en: '| `std::u16string` | `std::basic_string<char16_t>` | C++11 |'
  prefs: []
  type: TYPE_TB
- en: '| `std::u32string` | `std::basic_string<char32_t>` | C++11 |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2.7: The various type aliases for std::basic_string'
  prefs: []
  type: TYPE_NORMAL
- en: Like the other standard containers, `std::basic_string` provides a multitude
    of member functions to construct, access elements, iterate, search, or perform
    various operations with the contained sequence of characters. A particular mention
    needs to be made about how data is stored in a `basic_string`. In C++11, it is
    guaranteed to be contiguous, like in an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, it may be a bit confusing how it handles string termination.
    Let’s take an example to explain it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The elements stored in the `basic_string` object are the characters `''d` `''`,
    `''e` `''`, `''m` `''`, and `''o` `''`. This is what you get if you iterate over
    the object (e.g., `for (auto c : s)`). The `size()` member will return 4\. However,
    both the `c_str()` and `data()` member functions will return a null terminator.
    That means that it’s guaranteed that `s[s.size()]` is 0.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Characters and strings are often provided as literals in source code. There
    are different prefixes for the different character types, as listed in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Literal** | **C++ Standard** | **Character type** | **String type** |'
  prefs: []
  type: TYPE_TB
- en: '| none | All versions | `char` | `const char*` |'
  prefs: []
  type: TYPE_TB
- en: '| `L` | C++98 | `wchar_t` | `const wchar_t*` |'
  prefs: []
  type: TYPE_TB
- en: '| `u8` | C++11 | `char` (until C++20)`char8_t` (since C++20) | `const char*`
    (until C++20)`const char8_t*` (since C++20) |'
  prefs: []
  type: TYPE_TB
- en: '| `u` | C++11 | `char16_t` | `const char16_t*` |'
  prefs: []
  type: TYPE_TB
- en: '| `U` | C++11 | `char32_t` | `const char32_t*` |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2.8: Prefixes for the different character and string types'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In the first part, because single quotes are used, character types are deduced
    for variables `c1` to `c5`, depending on the literal prefix (the deduced type
    is mentioned on the right side in the comments). In the second part, because double
    quotes are used, string types are deduced for variables `sa1` to `sa5`, again,
    depending on the literal prefix.
  prefs: []
  type: TYPE_NORMAL
- en: 'The deduced type for `"a"` is not `std::string` but `const char*`. If you want
    to use any of the `basic_string` typedefs, such as `std::string`, you must either
    define the type explicitly (and not use `auto`) or use a standard user-defined
    literal suffix, available in the `std::string_literals` namespace. This is shown
    in the next snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To avoid confusion, the following table explains the meaning of various pointer
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Meaning** |'
  prefs: []
  type: TYPE_TB
- en: '| `char*` | A mutable pointer to a mutable character. Both the pointer and
    the pointed character can be modified. |'
  prefs: []
  type: TYPE_TB
- en: '| `const char*` | A mutable pointer to a constant character. The pointer can
    be modified, but not the content of the location it points to. |'
  prefs: []
  type: TYPE_TB
- en: '| `char * const` | A constant pointer to a mutable character. The pointer cannot
    be modified, but the content of the location it points to can be. |'
  prefs: []
  type: TYPE_TB
- en: '| `const char * const` | A constant pointer to a constant character. Neither
    the pointer nor the content of the location it points to can be modified. |'
  prefs: []
  type: TYPE_TB
- en: '| `char[]` | An array of characters. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2.9: The meaning of various pointer types'
  prefs: []
  type: TYPE_NORMAL
- en: 'You must have noticed that, in the previous table, the prefix `u8` had different
    behavior with different standards:'
  prefs: []
  type: TYPE_NORMAL
- en: Since C++11, when it was introduced, until C++20, it defined a `char` literal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since C++20, when it was repurposed with the introduction of `char8_t`, it defines
    a `char8_t` literal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This C++20 change is a breaking change. It was preferred over the introduction
    of yet another literal prefix that could have the potential of complicating things
    even further.
  prefs: []
  type: TYPE_NORMAL
- en: 'A character or string literal may contain code point values instead of actual
    characters. These must be escaped with either `\u` (for 4 hexadecimal digit code
    points) or `\U` (for 8 hexadecimal digit code points). Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In C++23, it is possible to use Unicode instead of code point values. That
    is done using the `\N{xxx}` escape sequence, where `xxx` is the Unicode assigned
    name. Therefore, the snippet above can also be written as follows in C++23:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, in C++23, it is possible to use code point values with an arbitrary number
    of hexadecimal digits. In the previous example, the string containing Egyptian
    hieroglyphs contained the codepoint 13000, which has 5 hexadecimal digits. However,
    since the `\U` escape sequence requires 8 hexadecimal digits, we had to include
    three leading zeros `(\U00013000`). This is no longer necessary in C++23, but
    it requires the syntax `\u{n…}` (with lowercase `u`), where `n…` is an arbitrary
    number of hexadecimal digits. Therefore, this string can also be written as follows
    in C++23:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing characters and strings to the console can be done in multiple ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `std::cout` and `std::wcout` global objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `printf` family of functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `std::print` family of functions in C++23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a third-party text processing library, such as the widely-used **fmt**
    library (which was the source for the `std::format` and `std::print` standard
    utilities included in C++20 and C++23)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `std::cout` and `std::wcout` global objects can be used to print `char`/`const
    char*`/`std::string` values and, respectively, `wchar_t`/`const wchar_t*`/`std::wstring`
    values to the standard output console. Printing ASCII characters does not pose
    problems but the handling of other character sets and encodings, such as UTF-8,
    is more problematic, as there is no standard support and different platforms require
    different solutions. You can learn more about this topic in the next recipe, *Printing
    Unicode characters to the output console*.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Understanding the various numeric types*, to learn about the available integral
    and floating-point types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Formatting and printing text with std::format and std::print*, to learn about
    how to format and print text using modern utilities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Printing Unicode characters to the output console
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, *Understanding the various character and string types*,
    we looked at the various data types for storing characters and strings of characters.
    This multitude of types was necessary because there are a multitude of character
    sets that have been developed over time.
  prefs: []
  type: TYPE_NORMAL
- en: The most widely used character sets are ASCII and Unicode. Although support
    for the former has been available on all compilers and target platforms since
    the creation of the language, the support for the latter has evolved at a different
    pace and in different forms for Windows and Unix/Linux systems. In this recipe,
    we will look at how to print texts in different encodings to the standard output
    console.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To write text to the standard output console, you can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For writing ASCII characters, use `std::cout`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For writing UTF-8 encoded Unicode characters on Linux, also use `std::cout`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For UTF-8 strings stored using the `char8_t` data type, you can still use `std::cout`
    but must reinterpret the underlying type as an array of chars:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For writing UTF-8 encoded Unicode characters on a Windows system, use `char8_t`
    characters, and respectively, `std::u8string` strings in C++20\. In prior versions,
    you can use `char` and `std::string`. Make sure to call the Windows API `SetConsoleOutputCP(CP_UTF8)`
    before writing to the standard output:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![](img/B21549_02_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: Output of the previous snippet'
  prefs: []
  type: TYPE_NORMAL
- en: 'For writing UTF-16 encoded Unicode characters on a Windows system, use `wchar_t`
    characters and `std::wstring` strings. Make sure to call `_setmode(_fileno(stdout),
    _O_U16TEXT)` before writing to the standard output:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![](img/B21549_02_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.4: Output of the previous snippet'
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ASCII encoding has been the most common character encoding format for half
    a century. It contains 128 characters including the lower and uppercase letters
    of the English language, the 10 decimal digits, and symbols. The first 32 characters
    of the set are non-printable and are called *control characters*. The C++ language
    has full support for the ASCII character set. You can use `std::cout` to print
    ASCII characters to the standard output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the ASCII encoding only includes the letters of the English alphabet,
    various attempts have been made to support other languages and alphabets. One
    approach is the concept of *code pages*. The ASCII encoding requires only 7 bits
    for encoding the 128 characters. Therefore, an additional 128 characters are available
    to encode using an 8-bit data type. That means that the characters in the index
    128–255 can be mapped to other languages or alphabets. Such a mapping is called
    a code page. There are a variety of code pages, such as IBM code pages, DOS code
    pages, Windows code pages, and others. You can read more about this at [https://en.wikipedia.org/wiki/Code_page](https://en.wikipedia.org/wiki/Code_page).
    The following table lists several Windows code pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Code page** | **Name** | **Languages supported** |'
  prefs: []
  type: TYPE_TB
- en: '| 1250 | Windows Central Europe | Czech, Polish, Slovak, Hungarian, Slovene,
    Serbo-Croatian, Romanian, Albanian |'
  prefs: []
  type: TYPE_TB
- en: '| 1251 | Windows Cyrillic | Russian, Belarusian, Ukrainian, Bulgarian, Macedonian,
    Serbian |'
  prefs: []
  type: TYPE_TB
- en: '| 1252 | Windows Western | Spanish, Portuguese, French, German, Danish, Norwegian,
    Swedish, Finnish, Icelandic, Faroese, etc. |'
  prefs: []
  type: TYPE_TB
- en: '| 1253 | Windows Greek | Greek |'
  prefs: []
  type: TYPE_TB
- en: '| 1254 | Windows Turkish | Turkish |'
  prefs: []
  type: TYPE_TB
- en: '| 1255 | Windows Hebrew | Hebrew |'
  prefs: []
  type: TYPE_TB
- en: '| 1256 | Windows Arabic | Arabic, Persian, Urdu, English, French |'
  prefs: []
  type: TYPE_TB
- en: '| 1257 | Windows Baltic | Estonian, Latvian, Lithuanian |'
  prefs: []
  type: TYPE_TB
- en: '| 1258 | Windows Vietnamese | Vietnamese |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2.10: A listing of a subset of Windows code pages'
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand how this works, let’s exemplify with a code snippet. The index
    224 or 0xE0 (in hexadecimal) is mapped to different characters in different code
    pages, as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **1250** | **1251** | **1252** | **1253** | **1254** | **1255** | **1256**
    | **1257** | **1258** |'
  prefs: []
  type: TYPE_TB
- en: '| ŕ | а | à | ΰ | à | ![](img/1.png) | à | ą | à |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2.11: The character corresponding to index 224 in the several Windows
    code pages'
  prefs: []
  type: TYPE_NORMAL
- en: In encoding terminology, the numerical value to which a character is mapped
    is called a *code point* (or *codepoint*). In our example, 224 is a code point,
    and *a*, *à*, or *ą* are specific characters mapped to this code point in different
    code pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Windows, you can activate one code page for the console associated with
    the running process by calling the `SetConsoleOutputCP()` API. An example is shown
    in the following snippet, where we print the character mapped to the 224 code
    point for all the code pages from 1250 to 1258 (the ones listed earlier):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The output from running this program is shown in the next image. You can see
    here that the printed characters are the ones expected according to *Table 2.9*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21549_02_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.5: Printing of code point 224 with different code pages'
  prefs: []
  type: TYPE_NORMAL
- en: Although code pages provide a simple approach to switching between different
    scripts, it is not a solution that can support languages or writing systems that
    include hundreds or thousands of characters or pictograms, such as Chinese or
    Egyptian hieroglyphs. For this purpose, another standard was developed, called
    **Unicode**. This encoding standard is meant to represent most of the world’s
    writing scripts, both present and from the past, as well as other symbols, such
    as emojis, which have become extremely popular for texting in recent times. Currently,
    the Unicode standard defines almost 150,000 characters.
  prefs: []
  type: TYPE_NORMAL
- en: Unicode characters can be stored in several encodings, the most popular being
    UTF-8 and UTF-16\. There is also UTF-32 and GB18030; the latter one is not part
    of the Unicode specification but it’s used in China and fully implements Unicode.
  prefs: []
  type: TYPE_NORMAL
- en: 'UTF-8 is a variable-length character encoding standard, compatible with ASCII.
    UTF-8 uses 1, 2, 3, or 4 bytes to encode all the representable code points. The
    more used a code point is, the fewer bytes are used for its encoding. The 128
    code points of the ASCII encoding are represented by a single byte. As a result,
    UTF-8 is fully “backward” compatible with ASCII. All the other Unicode code points
    are encoded using multiple bytes: code points in the range 128–2047 using 2 bytes,
    code points in the range 2048–65535 using 3 bytes, and code points in the range
    65536–1114111 using 4 bytes. The first byte in the encoding is called a *lead
    byte* and provides information about how many bytes are used to encode the code
    point. Because of this, UTF-8 is a very efficient encoding system and is the preferred
    choice for the World Wide Web, where virtually almost all web pages use this encoding.'
  prefs: []
  type: TYPE_NORMAL
- en: UTF-16 is also a variable-length character encoding that can encode all the
    Unicode code points. For this, it uses either one or two 16-bit code units, which
    makes it incompatible with ASCII. UTF-16 is the encoding used by the Windows operating
    system, as well as by the Java and JavaScript programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: UTF-32 is a less common encoding system. It’s a fixed-length encoding that uses
    32 bits for each code point. Since all the Unicode code points require at most
    21 bits, the leading 11 bits are always 0\. This makes it space-inefficient, which
    is its main disadvantage. Its primary advantage is that it takes constant time
    to find the Nth code point in a sequence, as opposed to a linear time for variable-length
    encodings such as UTF-8 and UTF-16.
  prefs: []
  type: TYPE_NORMAL
- en: Compilers typically assume UTF-8 encoding for source files. This is the case
    for GCC, Clang, and MSVC.
  prefs: []
  type: TYPE_NORMAL
- en: 'Linux distributions have native support for UTF-8\. This means that writing
    string literals to the output console such as `"Στέφανος Τσιτσιπάς"` will produce
    the expected result since the terminal supports UTF-8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, writing wide strings such as `L"Στέφανος Τσιτσιπάς"` does
    not work out of the box. To get the expected result, you need to set up a locale
    object. The default C locale does not know how to convert from wide characters
    to UTF-8\. For this to happen, you need to use a locale that is able to do that.
    You have two options:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialize a locale object to match the environment’s configuration, which
    should typically be a locale that supports UTF-8:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize a locale object with a specific locale, such as English (United
    States):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Locales are discussed in detail in *Chapter 7*, *Using localized settings for
    streams*.
  prefs: []
  type: TYPE_NORMAL
- en: 'On a Windows system, things are different. The Windows Command Prompt (`cmd.exe`)
    does not have support for UTF-8\. Although Windows 10 added support for a beta
    feature called “*Use Unicode UTF-8 for worldwide language support*,” this is deeply
    hidden in the *Regional Settings* and is currently reported to prevent some applications
    from working correctly. To write UTF-8 content to the Command Prompt, you must
    first set the correct code page by calling `SetConsoleOutputCP()` and passing
    `CP_UTF8` as an argument (or 65001, its numerical value):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: To write UTF-16, you need to call `_setmode()` (from `<io.h>`) to set the translation
    mode for a file (in this case, the standard output console) to UTF-16\. For this,
    you have to pass the `_O_U16TEXT` argument. The function returns the previous
    translation mode that you can use to restore the translation mode after writing
    the desired content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Passing `_O_TEXT` sets the text mode (in which CR-LF combinations are translated
    into a single LF on input, and LF characters are translated into CR-LF on output):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: For this to work, however, it is also important that the Command Prompt application
    uses a True Type font, such as Lucinda Console or Consolas, and not a Raster font
    that only supports ASCII.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with Windows 10, a new terminal application is available for Windows.
    This is called **Windows Terminal,** and it has built-in support for UTF-8\. This
    means that the following code prints the expected result without having to call
    `SetConsoleOutputCP()` first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Unlike other programming languages, support for Unicode has not been a strong
    point of C++. This recipe provides the basics for working with Unicode in console
    applications. However, in practice, matters can get more complex and require additional
    support. To further your understanding of this topic, it is recommended that you
    consult additional sources, with many being available online.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Understanding the various character and string types* to learn about the available
    character and string types in C++'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Formatting and printing text with std::format and std::print* to learn about
    how to format and print text using modern utilities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 7*, *Using localized settings for streams*, to learn about locales
    and how to control the behavior of input/output streams'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating pseudo-random numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generating random numbers is necessary for a large variety of applications,
    from games to cryptography, from sampling to forecasting. However, the term *random
    numbers* is not actually correct, as the generation of numbers through mathematical
    formulas is deterministic and does not produce true random numbers, but rather,
    numbers that look random and are called *pseudo-random*. True randomness can only
    be achieved through hardware devices, based on physical processes, and even that
    can be challenged as we may consider even the universe to be actually deterministic.
  prefs: []
  type: TYPE_NORMAL
- en: Modern C++ provides support for generating pseudo-random numbers through a pseudo-random
    number library containing number generators and distributions. Theoretically,
    it can also produce true random numbers but, in practice, those could actually
    be only pseudo-random.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we’ll discuss the standard support for generating pseudo-random
    numbers. Understanding the difference between random and pseudo-random numbers
    is key. True random numbers are numbers that cannot be predicted better than by
    random chance and are produced with the help of hardware-based random number generators.
    Pseudo-random numbers are numbers produced with the help of algorithms that generate
    sequences with properties that approximate the ones of true random numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, being familiar with various statistical distributions is a plus.
    It is mandatory, though, that you know what a uniform distribution is because
    all engines in the library produce numbers that are uniformly distributed. Without
    going into any details, we will just mention that uniform distribution is a probability
    distribution that is concerned with events that are equally likely to occur (within
    certain bounds).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To generate pseudo-random numbers in your application, you should perform the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the header `<random>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use an `std::random_device` generator to seed a pseudo-random engine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use one of the available engines to generate numbers and initialize it with
    a random seed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use one of the available distributions to convert the output of the engine
    to one of the desired statistical distributions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Generate the pseudo-random numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The pseudo-random number library contains two types of components:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Engines*, which are generators of random numbers; these can produce either
    pseudo-random numbers with a uniform distribution or, if available, actual random
    numbers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Distributions* that convert the output of an engine to a statistical distribution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All engines (except for `random_device`) produce integer numbers in a uniform
    distribution, and all engines implement the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`min()`: This is a static method that returns the minimum value that can be
    produced by the generator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max()`: This is a static method that returns the maximum value that can be
    produced by the generator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`seed()`: This initializes the algorithm with a start value (except for `random_device`,
    which cannot be seeded).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`operator()`: This generates a new number uniformly distributed between `min()`
    and `max()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`discard()`: This generates and discards a given number of pseudo-random numbers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following engines are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`linear_congruential_engine`: This is a linear congruential generator that
    produces numbers using the following formula:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*x*(*i*) = (*A* * *x*(i – *1*) + *C*) mod *M*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`mersenne_twister_engine`: This is a Mersenne Twister generator that keeps
    a value on *W* * (*N* – 1) * *R* bits. Each time a number needs to be generated,
    it extracts *W* bits. When all the bits have been used, it twists the large value
    by shifting and mixing the bits so that it has a new set of bits to extract from.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subtract_with_carry_engine`: This is a generator that implements a *subtract
    with carry* algorithm based on the following formula:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*x*(*i*) = (*x*(*i* – *R*) – *x*(*i* – *S*) – *cy*(*i* – 1)) mod *M*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the preceding formula, *cy* is defined as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B21549_02_001.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'In addition, the library provides engine adapters that are also engines wrapping
    another engine and producing numbers based on the output of the base engine. Engine
    adapters implement the same methods mentioned earlier for the base engines. The
    following engine adapters are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`discard_block_engine`: A generator that, from every block of *P* numbers generated
    by the base engine, keeps only *R* numbers, discarding the rest.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`independent_bits_engine`: A generator that produces numbers with a different
    number of bits than the base engine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shuffle_order_engine`: A generator that keeps a shuffled table of *K* numbers
    produced by the base engine and returns numbers from this table, replacing them
    with numbers generated by the base engine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing a pseudo-random number generator should be done based on the specific
    requirements of your application. The linear congruential engine is medium-fast
    but has very small storage requirements for its internal state. The subtract with
    carry engine is very fast, including on machines that don’t have a processor with
    advanced arithmetic instruction sets. However, it requires larger storage for
    its internal state and the sequence of generated numbers has fewer desirable characteristics.
    The Mersenne Twister is the slowest of these engines and has the greatest storage
    durations but produces the longest non-repeating sequences of pseudo-numbers.
  prefs: []
  type: TYPE_NORMAL
- en: All these engines and engine adaptors produce pseudo-random numbers. The library,
    however, provides another engine called `random_device` that is supposed to produce
    non-deterministic numbers, but this is not an actual constraint as physical sources
    of random entropy might not be available. Therefore, implementations of `random_device`
    could actually be based on a pseudo-random engine. The `random_device` class cannot
    be seeded like the other engines and has an additional method called `entropy()`
    that returns the random device entropy, which is 0 for a deterministic generator
    and nonzero for a non-deterministic generator.
  prefs: []
  type: TYPE_NORMAL
- en: However, this is not a reliable method for determining whether the device is
    actually deterministic or non-deterministic. For instance, both GNU `libstdc++`
    and LLVM `libc++` implement a non-deterministic device but return `0` for entropy.
    On the other hand, `VC++` and `boost.random` return `32` and `10`, respectively,
    for entropy.
  prefs: []
  type: TYPE_NORMAL
- en: All these generators produce integers in a uniform distribution. This is, however,
    only one of the many possible statistical distributions where random numbers are
    needed in most applications. To be able to produce numbers (either integer or
    real) in other distributions, the library provides several classes called *distributions*.
  prefs: []
  type: TYPE_NORMAL
- en: 'These convert the output of an engine according to the statistical distribution
    it implements. The following distributions are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Class name** | **Numbers** | **Statistical distribution** |'
  prefs: []
  type: TYPE_TB
- en: '| Uniform | `uniform_int_distribution` | Integer | Uniform |'
  prefs: []
  type: TYPE_TB
- en: '| `uniform_real_distribution` | Real | Uniform |'
  prefs: []
  type: TYPE_TB
- en: '| Bernoulli | `bernoulli_distribution` | Boolean | Bernoulli |'
  prefs: []
  type: TYPE_TB
- en: '| `binomial_distribution` | Integer | Binomial |'
  prefs: []
  type: TYPE_TB
- en: '| `negative_binomial_distribution` | Integer | Negative binomial |'
  prefs: []
  type: TYPE_TB
- en: '| `geometric_distribution` | Integer | Geometric |'
  prefs: []
  type: TYPE_TB
- en: '| Poisson | `poisson_distribution` | Integer | Poisson |'
  prefs: []
  type: TYPE_TB
- en: '| `exponential_distribution` | Real | Exponential |'
  prefs: []
  type: TYPE_TB
- en: '| `gamma_distribution` | Real | Gamma |'
  prefs: []
  type: TYPE_TB
- en: '| `weibull_distribution` | Real | Weibull |'
  prefs: []
  type: TYPE_TB
- en: '| `extreme_value_distribution` | Real | Extreme value |'
  prefs: []
  type: TYPE_TB
- en: '| Normal | `normal_distribution` | Real | Standard normal (Gaussian) |'
  prefs: []
  type: TYPE_TB
- en: '| `lognormal_distribution` | Real | Lognormal |'
  prefs: []
  type: TYPE_TB
- en: '| `chi_squared_distribution` | Real | Chi-squared |'
  prefs: []
  type: TYPE_TB
- en: '| `cauchy_distribution` | Real | Cauchy |'
  prefs: []
  type: TYPE_TB
- en: '| `fisher_f_distribution` | Real | Fisher’s F-distribution |'
  prefs: []
  type: TYPE_TB
- en: '| `student_t_distribution` | Real | Student’s t-distribution |'
  prefs: []
  type: TYPE_TB
- en: '| Sampling | `discrete_distribution` | Integer | Discrete |'
  prefs: []
  type: TYPE_TB
- en: '| `piecewise_constant_distribution` | Real | Values distributed on constant
    subintervals |'
  prefs: []
  type: TYPE_TB
- en: '| `piecewise_linear_distribution` | Real | Values distributed on defined subintervals
    |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2.12: The list of standard distributions from the <random> header'
  prefs: []
  type: TYPE_NORMAL
- en: Each of the engines provided by the library has advantages and disadvantages,
    as mentioned earlier. When initialized appropriately, the Mersenne Twister, although
    the slowest and one that has the largest internal state, can produce the longest
    non-repeating sequence of numbers. In the following examples, we will use `std::mt19937`,
    a 32-bit Mersenne Twister with 19,937 bits of internal state. There is also a
    64-bit Mersenne Twister, `std::mt19937_64`. Both `std::mt19937` and `std::mt19937_64`
    are aliases for `std::mersenne_twister_engine`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way to generate random numbers looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `mtgen` is `std::mt19937` for the Mersenne Twister. To generate
    numbers, you only need to use the call operator that advances the internal state
    and returns the next pseudo-random number. However, this code is flawed, as the
    engine is not seeded. As a result, it always produces the same sequence of numbers,
    which is probably not what you want in most cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different approaches to initializing the engine. One approach, common
    with the C `random` library, is to use the current time. In modern C++, it should
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `seed` is a number representing the number of ticks from the
    clock’s epoch until the present moment. This number is then used to seed the engine.
    The problem with this approach is that the value of that `seed` is actually deterministic,
    and in some classes of applications, it could be prone to attacks. A more reliable
    approach is to seed the generator with actual random numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `std::random_device` class is an engine that is supposed to return true
    random numbers, though implementations could actually be based on a pseudo-random
    generator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Numbers produced by all engines follow a uniform distribution. To convert the
    result to another statistical distribution, we have to use a distribution class.
    To show how generated numbers are distributed according to the selected distribution,
    we will use the following function. This function generates a specified number
    of pseudo-random numbers and counts their repetition in a map. The values from
    the map are then used to produce a bar-like diagram showing how often each number
    occurred:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code generates random numbers using the `std::mt19937` engine
    with a uniform distribution in the range `[1, 6]`; this is basically what you
    get when you throw a die:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the program looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a computer screen  Description automatically generated](img/B21549_02_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.6: Uniform distribution of the range [1,6]'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next and final example, we’re changing the distribution to a normal
    distribution with a mean of `5` and a standard deviation of `2`. This distribution
    produces real numbers; therefore, in order to use the previous `generate_and_print()`
    function, the numbers must be rounded to integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21549_02_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.7: Normal distribution with mean 5 and standard variance 2'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can see that, based on the graphical representation, the distribution
    has changed from a uniform one to a normal one with the mean at value 5.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Properly initializing a pseudo-random number generator*, to learn how to properly
    initialize random number engines'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Properly initializing a pseudo-random number generator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we looked at the pseudo-random number library, along
    with its components, and how it can be used to produce numbers in different statistical
    distributions. One important factor that was overlooked in that recipe is the
    proper initialization of the pseudo-random number generators.
  prefs: []
  type: TYPE_NORMAL
- en: With careful analysis (which is beyond the purpose of this recipe or this book),
    it can be shown that the Mersenne Twister engine has a bias toward producing some
    values repeatedly and omitting others, thus generating numbers not in a uniform
    distribution, but rather in a binomial or Poisson distribution. In this recipe,
    you will learn how to initialize a generator in order to produce pseudo-random
    numbers with a true uniform distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should read the previous recipe, *Generating pseudo-random numbers*, to
    get an overview of what the pseudo-random number library offers.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To properly initialize a pseudo-random number generator to produce a uniformly
    distributed sequence of pseudo-random numbers, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use an `std::random_device` to produce random numbers to be used as seeding
    values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Generate random data for all internal bits of the engine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an `std::seed_seq` object from the previously generated pseudo-random
    data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an engine object and initialize all the bits representing the internal
    state of the engine; for example, an `mt19937` has 19,937 bits of internal state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the appropriate distribution based on the requirements of the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In all the examples shown in the previous recipe, we used the `std::mt19937`
    engine to produce pseudo-random numbers. Though the Mersenne Twister is slower
    than the other engines, it can produce the longest sequences of non-repeating
    numbers with the best spectral characteristics. However, initializing the engine
    in the manner shown in the previous recipe will not have this effect. The problem
    is that the internal state of `mt19937` has 624 32-bit integers, and in the examples
    from the previous recipe, we have only initialized one of them.
  prefs: []
  type: TYPE_NORMAL
- en: When working with the pseudo-random number library, remember the following rule
    of thumb (shown in the information box).
  prefs: []
  type: TYPE_NORMAL
- en: In order to produce the best results, engines must have their entire internal
    state properly initialized before generating numbers.
  prefs: []
  type: TYPE_NORMAL
- en: The pseudo-random number library provides a class for this particular purpose,
    called `std::seed_seq`. This is a generator that can be seeded with any number
    of 32-bit integers and produces the requested number of integers evenly distributed
    in the 32-bit space.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code from the *How to do it...* section, we defined an array
    called `seed_data` with a number of 32-bit integers equal to the internal state
    of the `mt19937` generator – that is, 624 integers. Then, we initialized the array
    with random numbers produced by `std::random_device`. The array was later used
    to seed `std::seed_seq`, which, in turn, was used to seed the `mt19937` generator.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Generating pseudo-random numbers*, to familiarize yourself with the capabilities
    of the standard numeric library for generating pseudo-random numbers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating cooked user-defined literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Literals are constants of built-in types (numerical, Boolean, character, character
    string, and pointer) that cannot be altered in a program. The language defines
    a series of prefixes and suffixes to specify literals (and the prefix/suffix is
    actually part of the literal). C++11 allows us to create user-defined literals
    by defining functions called *literal operators*, which introduce suffixes for
    specifying literals. These work only with numerical character and character string
    types.
  prefs: []
  type: TYPE_NORMAL
- en: This opens the possibility of defining both standard literals in future versions
    and allows developers to create their own literals. In this recipe, we will learn
    how to create our own cooked literals.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'User-defined literals can have two forms: *raw* and *cooked*. Raw literals
    are not processed by the compiler, whereas cooked literals are values processed
    by the compiler (examples include handling escape sequences in a character string
    or identifying numerical values such as integer 2898 from literal 0xBAD). Raw
    literals are only available for integral and floating-point types, whereas cooked
    literals are also available for character and character string literals.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create cooked user-defined literals, you should follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Define your literals in a separate namespace to avoid name clashes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Always prefix the user-defined suffix with an underscore (`_`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define a literal operator of one of the following forms for cooked literals
    (the forms using `char8_t` are only available since C++20). Notice that in the
    following listing, `T` is not a type template parameter, but only a placeholder
    for the return type of the operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following example creates a user-defined literal for specifying kilobytes:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the compiler encounters a user-defined literal with a user-defined suffix,
    `_X` (it always has a leading underscore for third-party suffixes, as suffixes
    without a leading underscore are reserved for the standard library), it does an
    unqualified name lookup in order to identify a function with the name `operator
    "" _X`. If it finds one, then it calls it according to the type of the literal
    and the type of the literal operator. Otherwise, the compiler will yield an error.
  prefs: []
  type: TYPE_NORMAL
- en: In the example shown in the *How to do it...* section, the literal operator
    is called `operator "" _KB` and has an argument of type `unsigned long long int`.
    This is the only integral type possible for literal operators to handle integral
    types. Similarly, for floating-point user-defined literals, the parameter type
    must be `long double` since, for numeric types, the literal operators must be
    able to handle the largest possible values. This literal operator returns a `constexpr`
    value so that it can be used where compile-time values are expected, such as specifying
    the size of an array, as shown in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the compiler identifies a user-defined literal and has to call the appropriate
    user-defined literal operator, it will pick the overload from the overload set
    according to the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '**For integral literals**: It calls in the following order: the operator that
    takes an `unsigned long long`, the raw literal operator that takes a `const char*`,
    or the literal operator template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**For floating-point literals**: It calls in the following order: the operator
    that takes a `long double`, the raw literal operator that takes a `const char*`,
    or the literal operator template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**For character literals**: It calls the appropriate operator, depending on
    the character type (`char`, `wchar_t`, `char16_t`, and `char32_t`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**For string literals**: It calls the appropriate operator, depending on the
    string type, that takes a pointer to the string of characters and the size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following example, we’re defining a system of units and quantities. We
    want to operate with kilograms, pieces, liters, and other types of units. This
    could be useful in a system that can process orders and you need to specify the
    amount and unit for each article.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are defined in the `units` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A scoped enumeration for the possible types of units (kilogram, meter, liter,
    and pieces):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A class template to specify quantities of a particular unit (such as 3.5 kilograms
    or 42 pieces):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `operator+` and `operator-` functions for the `quantity` class template
    in order to be able to add and subtract quantities:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Literal operators to create `quantity` literals, defined in an inner namespace
    called `unit_literals`. The purpose of this is to avoid possible name clashes
    with literals from other namespaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If such collisions do happen, developers could select the ones that they should
    use using the appropriate namespace in the scope where the literals need to be
    defined:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'By looking carefully, you can note that the literal operators defined earlier
    are not the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '`_kg` is defined for both integral and floating-point literals; that enables
    us to create both integral and floating-point values such as `1_kg` and `1.0_kg`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_l` and `_m` are defined only for floating-point literals; this means we can
    only define quantity literals for these units with floating points, such as `4.5_l`
    and `10.0_m`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_pcs` is only defined for integral literals; this means we can only define
    quantities of an integer number of pieces, such as `42_pcs`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Having these literal operators available, we can operate with various quantities.
    The following examples show both valid and invalid operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '`q1` is a quantity of 1 kg; this is an integer value. Since an overloaded `operator
    "" _kg(unsigned long long const)` exists, the literal can be correctly created
    from the integer 1\. Similarly, `q2` is a quantity of 4.5 kilograms; this is a
    real value. Since an overloaded `operator "" _kg(long double)` exists, the literal
    can be created from the double floating-point value 4.5.'
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, `q6` is a quantity of 1 liter. Since there is no overloaded
    `operator "" _l(unsigned long long)`, the literal cannot be created. It would
    require an overload that takes an `unsigned long long`, but such an overload does
    not exist. Similarly, `q7` is a quantity of 2.0 pieces, but piece literals can
    only be created from integer values and, therefore, this generates another compiler
    error.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Though user-defined literals are available from C++11, standard literal operators
    have been available only from C++14\. Further standard user-defined literals have
    been added to the next versions of the standard. The following is a list of these
    standard literal operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '`operator""s` for defining `std::basic_string` literals and `operator""sv`
    (in C++17) for defining `std::basic_string_view` literals:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`operator""h`, `operator""min`, `operator""s`, `operator""ms`, `operator""us`,
    and `operator""ns` for creating an `std::chrono::duration` value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`operator""y` for creating an `std::chrono::year` literal and `operator""d`
    for creating an `std::chrono::day` literal that represents a day of a month, both
    added to C++20:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`operator""if`, `operator""i`, and `operator""il` for creating an `std::complex<float>`,
    `std::complex<double>`, and `std::complex<long double>` value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The standard user-defined literals are available in multiple namespaces. For
    instance, the `""s` and `""sv` literals for strings are defined in the namespace
    `std::literals::string_literals`.
  prefs: []
  type: TYPE_NORMAL
- en: However, both `literals` and `string_literals` are inlined namespaces. Therefore,
    you can access the literals with `using namespace std::literals`, `using namespace
    std::string_literals`, or `using namespace std::literals::string_literals`. In
    the previous examples, the second form was preferred.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Using raw string literals to avoid escaping characters*, to learn how to define
    string literals without the need to escape special characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating raw user-defined literals*, to understand how to provide a custom
    interpretation of an input sequence so that it changes the normal behavior of
    the compiler'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 1*, *Using inline namespaces for symbol versioning,* to learn how
    to version your source code using inline namespaces and conditional compilation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating raw user-defined literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous recipe, we looked at the way C++11 allows library implementers
    and developers to create user-defined literals and the user-defined literals available
    in the C++14 standard. However, user-defined literals have two forms: a cooked
    form, where the literal value is processed by the compiler before being supplied
    to the literal operator, and a raw form, in which the literal is not processed
    by the compiler before being supplied to the literal operator. The latter is only
    available for integral and floating-point types. Raw literals are useful for altering
    the compiler’s normal behavior. For instance, a sequence such as 3.1415926 is
    interpreted by the compiler as a floating-point value, but with the use of a raw
    user-defined literal, it could be interpreted as a user-defined decimal value.
    In this recipe, we will look at creating raw user-defined literals.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before continuing with this recipe, it is strongly recommended that you go through
    the previous one, *Creating cooked user-defined literals*, as general details
    about user-defined literals will not be reiterated here.
  prefs: []
  type: TYPE_NORMAL
- en: To exemplify the way raw user-defined literals can be created, we will define
    binary literals. These binary literals can be of 8-bit, 16-bit, and 32-bit (unsigned)
    types. These types will be called `byte8`, `byte16`, and `byte32`, and the literals
    we will create will be called `_b8`, `_b16`, and `_b32`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create raw user-defined literals, you should follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Define your literals in a separate namespace to avoid name clashes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Always prefix the used-defined suffix with an underscore (`_`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define a literal operator or literal operator template of the following form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following example shows a possible implementation of 8-bit, 16-bit, and
    32-bit binary literals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, we define everything inside a namespace called `binary` and start
    by introducing several type aliases: `byte8`, `byte16`, and `byte32`. These represent
    integral types of 8 bits, 16 bits, and 32 bits, as the names imply.'
  prefs: []
  type: TYPE_NORMAL
- en: The implementation in the previous section enables us to define binary literals
    of the form `1010_b8` (a `byte8` value of decimal 10) or `000010101100_b16` (a
    `byte16` value of decimal 2130496). However, we want to make sure that we do not
    exceed the number of digits for each type. In other words, values such as `111100001_b8`
    should be illegal and the compiler should yield an error.
  prefs: []
  type: TYPE_NORMAL
- en: The literal operator templates are defined in a nested namespace called `binary_literal_internals`.
    This is a good practice in order to avoid name collisions with other literal operators
    from other namespaces. Should something like that happen, you can choose to use
    the appropriate namespace in the right scope (such as one namespace in a function
    or block and another namespace in another function or block).
  prefs: []
  type: TYPE_NORMAL
- en: The three literal operator templates are very similar. The only things that
    are different are their names (`_b8`, `_16`, and `_b32`), return type (`byte8`,
    `byte16`, and `byte32`), and the condition in the static assert that checks the
    number of digits.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will explore the details of variadic templates and template recursion in
    a later recipe; however, for a better understanding, this is how this particular
    implementation works: `bits` is a template parameter pack that is not a single
    value, but all the values the template could be instantiated with. For example,
    if we consider the literal `1010_b8`, then the literal operator template would
    be instantiated as `operator"" _b8<''1'', ''0'', ''1'', ''0''>()`. Before proceeding
    with computing the binary value, we check the number of digits in the literal.
    For `_b8`, this must not exceed eight (including any trailing zeros). Similarly,
    it should be up to 16 digits for `_b16` and 32 for `_b32`. For this, we use the
    `sizeof...` operator, which returns the number of elements in a parameter pack
    (in this case, `bits`).'
  prefs: []
  type: TYPE_NORMAL
- en: If the number of digits is correct, we can proceed to expand the parameter pack
    and recursively compute the decimal value represented by the binary literal. This
    is done with the help of an additional class template and its specializations.
    These templates are defined in yet another nested namespace, called `binary_literals_internals`.
    This is also a good practice because it hides (without proper qualification) the
    implementation details from the client (unless an explicit `using namespace` directive
    makes them available to the current namespace).
  prefs: []
  type: TYPE_NORMAL
- en: Even though this looks like recursion, it is not a true runtime recursion. This
    is because, after the compiler expands and generates the code from templates,
    what we end up with is basically calls to overloaded functions with a different
    number of parameters. This is explained in *Chapter 3* in the *Writing a function
    template with a variable number of arguments* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `binary_struct` class template has a template type of `CharT` for the return
    type of the function (we need this because our literal operator templates should
    return either `byte8`, `byte16`, or `byte32`) and a parameter pack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Several specializations of this class template are available with parameter
    pack decomposition (of which you can read more in *Chapter 3* in the *Writing
    a function template with a variable number of arguments*) recipe. When the first
    digit of the pack is `''0''`, the computed value remains the same, and we continue
    expanding the rest of the pack. If the first digit of the pack is `''1''`, then
    the new value is 1, shifted to the left with the number of digits in the remainder
    of the pack bit, or the value of the rest of the pack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The last specialization covers the case where the pack is empty; in this case,
    we return 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'After defining these helper classes, we could implement the `byte8`, `byte16`,
    and `byte32` binary literals as intended. Note that we need to bring the content
    of the namespace `binary_literals` into the current namespace in order to use
    the literal operator templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'The following definitions trigger compiler errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The reason for this is that the condition in `static_assert` is not met. The
    length of the sequence of characters preceding the literal operator is greater
    than expected, in all cases.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Using raw string literals to avoid escaping characters*, to learn how to define
    string literals without the need to escape special characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating cooked user-defined literals*, to learn how to create literals of
    user-defined types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 3*, *Writing a function template with a variable number of arguments*,
    to see how variadic templates enable us to write functions that can take any number
    of arguments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 1*, *Creating type aliases and alias templates*, to learn about aliases
    for types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using raw string literals to avoid escaping characters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Strings may contain special characters, such as non-printable characters (newline,
    horizontal and vertical tab, and so on), string and character delimiters (double
    and single quotes), or arbitrary octal, hexadecimal, or Unicode values. These
    special characters are introduced with an escape sequence that starts with a backslash,
    followed by either the character (examples include `'` and `"`), its designated
    letter (examples include `n` for a new line, and `t` for a horizontal tab), or
    its value (examples include octal 050, hexadecimal XF7, or Unicode U16F0). As
    a result, the backslash character itself has to be escaped with another backslash
    character. This leads to more complicated literal strings that can be hard to
    read.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid escaping characters, C++11 introduced raw string literals that do not
    process escape sequences. In this recipe, you will learn how to use the various
    forms of raw string literals.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, and throughout the rest of this book, I will use the `s` suffix
    to define `basic_string` literals. This was covered earlier in this chapter in
    the *Creating cooked user-defined literals* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To avoid escaping characters, define the string literals with one of the following
    forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '`R"( literal )"` as the default form:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`R"delimiter( literal )delimiter"`, where `delimiter` is any sequence of characters
    excluding parentheses, backslash, and spaces, and `literal` is any sequence of
    characters with the limitation that it cannot include the closing sequence `)delimiter"`.
    Here is an example with `!!` as a delimiter:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When string literals are used, escapes are not processed, and the actual content
    of the string is written between the delimiter (in other words, what you see is
    what you get). The following example shows what appears as the same raw literal
    string; however, the second one still contains escaped characters. Since these
    are not processed in the case of string literals, they will be printed as they
    are in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'If the text has to contain the `)"` sequence, then a different delimiter must
    be used, in the `R"delimiter( literal )delimiter"` form. According to the standard,
    the possible characters in a delimiter can be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Any member of the basic source character set except: space, the left parenthesis
    (the right parenthesis ), the backslash \, and the control characters representing
    horizontal tab, vertical tab, form feed, and newline.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Raw string literals can be prefixed by one of `L`, `u8`, `u`, and `U` to indicate
    a wide, UTF-8, UTF-16, or UTF-32 string literal, respectively. The following are
    examples of such string literals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Note that the presence of the suffix `""s` at the end of the string makes the
    compiler deduce the type as various string classes and not character arrays.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Creating cooked user-defined literals*, to learn how to create literals of
    user-defined types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Understanding the various character and string types*, to learn more about
    character and string types, literal prefixes, and the changes in C++20 concerning
    the `u8` prefix'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a library of string helpers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The string types from the standard library are a general-purpose implementation
    that lacks many helpful methods, such as changing the case, trimming, splitting,
    and others that may address different developer needs. Third-party libraries that
    provide rich sets of string functionalities exist. However, in this recipe, we
    will look at implementing several simple, yet helpful, methods you may often need
    in practice. The purpose is to see how string methods and standard general algorithms
    can be used for manipulating strings but also to have a reference to reusable
    code that can be used in your applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we will implement a small library of string utilities that
    will provide functions for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Changing a string into lowercase or uppercase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reversing a string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trimming white spaces from the beginning and/or the end of the string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trimming a specific set of characters from the beginning and/or the end of the
    string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing occurrences of a character anywhere in the string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tokenizing a string using a specific delimiter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we start with the implementation, let’s look at some prerequisites.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The string library we will be implementing should work with all the standard
    string types – that is, `std::string`, `std::wstring`, `std::u16string`, and `std::u32string`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid specifying long names such as `std::basic_string<CharT, std::char_traits<CharT>,
    std::allocator<CharT>>`, we will use the following alias templates for strings
    and string streams:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: To implement these string helper functions, we need to include the header `<string>`
    for strings and `<algorithm>` for the general standard algorithms we will use.
  prefs: []
  type: TYPE_NORMAL
- en: In all the examples in this recipe, we will use the standard user-defined literal
    operators for strings from C++14, for which we need to explicitly use the `std::string_literals`
    namespace.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To convert a string to lowercase or uppercase, apply the `tolower()` or `toupper()`
    functions to the characters of a string using the general-purpose algorithm `std::transform()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To reverse a string, use the general-purpose algorithm `std::reverse()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To trim a string at the beginning, end, or both, use the `std::basic_string`
    methods `find_first_not_of()` and `find_last_not_of()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To trim characters in a given set from a string, use overloads of the `std::basic_string`
    methods `find_first_not_of()` and `find_last_not_of()`, which take a string parameter
    that defines the set of characters to look for:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To remove characters from a string, use `std::remove_if()` and `std::basic_string::erase()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To split a string based on a specified delimiter, use `std::getline()` to read
    from an `std::basic_stringstream` initialized with the content of the string.
    The tokens extracted from the stream are pushed into a vector of strings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To implement the utility functions from the library, we have two options:'
  prefs: []
  type: TYPE_NORMAL
- en: Functions will modify a string passed by a reference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions will not alter the original string but, instead, return a new string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second option has the advantage that it preserves the original string, which
    may be helpful in many cases. Otherwise, in those cases, you would first have
    to make a copy of the string and alter the copy. The implementation provided in
    this recipe takes the second approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first functions we implemented in the *How to do it...* section were `to_upper()`
    and `to_lower()`. These functions change the content of a string either to uppercase
    or lowercase. The simplest way to implement this is by using the `std::transform()`
    standard algorithm. This is a general-purpose algorithm that applies a function
    to every element of a range (defined by a begin and end iterator) and stores the
    result in another range for which only the begin iterator needs to be specified.
    The output range can be the same as the input range, which is exactly what we
    did to transform the string. The applied function is `toupper()` or `tolower()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'The next function we considered was `reverse()`, which, as the name implies,
    reverses the content of a string. For this, we used the `std::reverse()` standard
    algorithm. This general-purpose algorithm reverses the elements of a range defined
    by a begin and end iterator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'When it comes to trimming, a string can be trimmed at the beginning, end, or
    both sides. For that reason, we implemented three different functions: `trim()`
    for trimming at both ends, `trimleft()` for trimming at the beginning of a string,
    and `trimright()` for trimming at the end of a string. The first version of the
    function trims only spaces. In order to find the right part to trim, we use the
    `find_first_not_of()` and `find_last_not_of()` methods of `std::basic_string`.
    These return the first and last characters in the string that are not of the specified
    character. Subsequently, a call to the `substr()` method of `std::basic_string`
    returns a new string. The `substr()` method takes an index in the string and a
    number of elements to copy to the new string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, it can be useful to trim other characters and then spaces from a
    string. In order to do that, we provided overloads for the trimming functions
    that specify a set of characters to be removed. That set is also specified as
    a string. The implementation is very similar to the previous one because both
    `find_first_not_of()` and `find_last_not_of()` have overloads that take a string
    containing the characters to be excluded from the search:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: If removing characters from any part of the string is necessary, the trimming
    methods are not helpful because they only treat a contiguous sequence of characters
    at the start and end of a string. For that, however, we implemented a simple `remove()`
    method. This uses the `std:remove_if()` standard algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both `std::remove()` and `std::remove_if()` work in a way that may not be very
    intuitive at first. They remove elements that satisfy the criteria from a range
    defined by a first and last iterator by rearranging the content of the range (using
    move assignment). The elements that need to be removed are placed at the end of
    the range, and the function returns an iterator to the first element in the range
    that represents the removed elements. This iterator basically defines the new
    end of the range that was modified. If no element was removed, the returned iterator
    is the end iterator of the original range. The value of this returned iterator
    is then used to call the `std::basic_string::erase()` method, which actually erases
    the content of the string defined by two iterators. The two iterators in our case
    are the iterator returned by `std::remove_if()` and the end of the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: The last method we implemented, `split()`, splits the content of a string based
    on a specified delimiter. There are various ways to implement this. In this implementation,
    we used `std::getline()`. This function reads characters from an input stream
    until a specified delimiter is found and places the characters in a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before starting to read from the input buffer, it calls `erase()` on the output
    string to clear its content. Calling this method in a loop produces tokens that
    are placed in a vector. In our implementation, empty tokens were skipped from
    the result set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Two examples of text splitting are shown here. In the first example, the text
    from the `text5` variable is split into words and, as mentioned earlier, empty
    tokens are ignored. In the second example, splitting an empty string produces
    an empty vector of `token`.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Several helper methods have been added to the `std::basic_string` class template
    in recent versions of the standard to help users avoid defining some widely used
    functions. These are listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **C++ version** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `starts_with` | C++20 | Checks whether the string starts with the specified
    prefix |'
  prefs: []
  type: TYPE_TB
- en: '| `ends_with` | C++20 | Checks whether the string ends with the specified suffix
    |'
  prefs: []
  type: TYPE_TB
- en: '| `contains` | C++23 | Checks whether the string contains the specified substring
    |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2.13: Newer basic_string member functions for widely-used string operations'
  prefs: []
  type: TYPE_NORMAL
- en: 'The use of these member functions is exemplified in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Creating cooked user-defined literals*, to learn how to create literals of
    user-defined types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 1*, *Creating type aliases and alias templates*, to learn about aliases
    for types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying the format of a string using regular expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Regular expressions are a language intended for performing pattern matching
    and replacements in texts. C++11 provides support for regular expressions within
    the standard library through a set of classes, algorithms, and iterators available
    in the `<regex>` header. In this recipe, we will learn how regular expressions
    can be used to verify that a string matches a pattern (examples include verifying
    an email or IP address format).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Throughout this recipe, we will explain, whenever necessary, the details of
    the regular expressions that we use. However, you should have at least some basic
    knowledge of regular expressions in order to use the C++ standard library for
    regular expressions. A description of regular expression syntax and standards
    is beyond the purpose of this book; if you are not familiar with regular expressions,
    it is recommended that you read more about them before continuing with this, and
    the other recipes that focus on regular expressions. Good online resources for
    learning, building, and debugging regular expressions can be found at [https://regexr.com](https://regexr.com)
    and [https://regex101.com](https://regex101.com).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to verify that a string matches a regular expression, perform the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the `<regex>` and `<string>` headers and the `std::string_literals`
    namespace for standard user-defined literals for strings (added in C++14):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use raw string literals to specify the regular expression to avoid escaping
    backslashes (which can occur frequently). The following regular expression validates
    most email formats:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an `std::regex`/`std::wregex` object (depending on the character set
    that is used) to encapsulate the regular expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To ignore casing or specify other parsing options, use an overloaded constructor
    that has an extra parameter for regular expression flags:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `std::regex_match()` to match the regular expression with an entire string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Considering the problem of verifying the format of email addresses, even though
    this may look like a trivial problem, in practice, it is hard to find a simple
    regular expression that covers all the possible cases for valid email formats.
    In this recipe, we will not try to find that ultimate regular expression but,
    rather, apply a regular expression that is good enough for most cases. The regular
    expression we will use for this purpose is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table explains the structure of the regular expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Part** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `^` | Start of string |'
  prefs: []
  type: TYPE_TB
- en: '| `[A-Z0-9._%+-]+` | At least one character that is an uppercase letter, `A-Z`,
    a digit `0-9`, or one of `.`, `%`, `+`, or `-`, which represents the local part
    of the email address |'
  prefs: []
  type: TYPE_TB
- en: '| `@` | The character `@` |'
  prefs: []
  type: TYPE_TB
- en: '| `[A-Z0-9.-]+` | At least one character that is an uppercase letter `A-Z`,
    a digit `0-9`, or one of the symbols `.` or `-`, which represents the hostname
    of the domain part |'
  prefs: []
  type: TYPE_TB
- en: '| `\.` | A dot that separates the domain hostname and label |'
  prefs: []
  type: TYPE_TB
- en: '| `[A-Z]{2,}` | The DNS label of a domain, which can have between 2 and 63
    characters |'
  prefs: []
  type: TYPE_TB
- en: '| `$` | End of the string |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2.14: The structure of the previously defined regular expression'
  prefs: []
  type: TYPE_NORMAL
- en: Bear in mind that, in practice, a domain name is composed of a hostname followed
    by a dot-separated list of DNS labels. Examples include `localhost`, `gmail.com`,
    and `yahoo.co.uk`. This regular expression we are using does not match domains
    without DNS labels, such as `localhost` (an email address such as `root@localhost`
    is a valid email address). The domain name can also be an IP address specified
    in brackets, such as `[192.168.100.11]` (as in `john.doe@[192.168.100.11]`). Email
    addresses containing such domains will not match the regular expression defined
    previously. Even though these rather rare formats will not be matched, the regular
    expression can cover most email formats.
  prefs: []
  type: TYPE_NORMAL
- en: The regular expression for the example in this chapter is provided for didactical
    purposes only and is not intended to be used as it is in production code. As explained
    earlier, this sample does not cover all possible email formats.
  prefs: []
  type: TYPE_NORMAL
- en: We began by including the necessary headers – that is, `<regex>` for regular
    expressions and `<string>` for strings. The `is_valid_email()` function, shown
    in the following code (which basically contains the samples from the *How to do
    it...* section), takes a string representing an email address and returns a Boolean
    indicating whether the email has a valid format or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first construct an `std::regex` object to encapsulate the regular expression
    indicated with the raw string literal. Using raw string literals is helpful because
    it avoids escaping backslashes, which are used for escape characters in regular
    expressions too. The function then calls `std::regex_match()`, passing the input
    text and the regular expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'The `std::regex_match()` method tries to match the regular expression against
    the entire string. If successful, it returns `true`; otherwise, it returns `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: In this simple test, the only emails that do not match the regular expression
    are `ROOT@LOCALHOST` and `john.doe@domain.com`. The first contains a domain name
    without a dot-prefixed DNS label, and that case is not covered in the regular
    expression. The second contains only lowercase letters, and in the regular expression,
    the valid set of characters for both the local part and the domain name was uppercase
    letters, A to Z.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of complicating the regular expression with additional valid characters
    (such as `[A-Za-z0-9._%+-]`), we can specify that the match can ignore this case.
    This can be done with an additional parameter to the constructor of the `std::basic_regex`
    class. The available constants for this purpose are defined in the `regex_constants`
    namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following slight change to `is_valid_email_format()` will make it ignore
    the case and allow email addresses with both lowercase and uppercase letters to
    correctly match the regular expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'This `is_valid_email_format()` function is pretty simple, and if the regular
    expression was provided as a parameter, along with the text to match, it could
    be used for matching anything. However, it would be nice to be able to handle
    not only multi-byte strings (`std::string`) but also wide strings (`std::wstring`),
    with a single function. This can be achieved by creating a function template where
    the character type is provided as a template parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by creating an alias template for `std::basic_string` in order to
    simplify its use. The new `is_valid_format()` function is a function template
    very similar to our implementation of `is_valid_email()`. However, we now use
    `std::basic_regex<CharT>` instead of the typedef `std::regex`, which is `std::basic_regex<char>`,
    and the pattern is provided as the first argument. We now implement a new function
    called `is_valid_email_format_w()` for wide strings that relies on this function
    template. The function template, however, can be reused for implementing other
    validations, such as whether a license plate has a particular format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Of all the examples shown here, the only one that does not match is `ROOT@LOCALHOST`,
    as expected.
  prefs: []
  type: TYPE_NORMAL
- en: The `std::regex_match()` method has, in fact, several overloads, and some of
    them have a parameter that is a reference to an `std::match_results` object to
    store the result of the match. If there is no match, then `std::match_results`
    is empty and its size is 0\. Otherwise, if there is a match, the `std::match_results`
    object is not empty and its size is 1, plus the number of matched subexpressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following version of the function uses the mentioned overloads and returns
    the matched subexpressions in an `std::smatch` object. Note that the regular expression
    is changed as three caption groups are defined – one for the local part, one for
    the hostname part of the domain, and one for the DNS label. If the match is successful,
    then the `std::smatch` object will contain four submatch objects: the first (index
    0) to match the entire string, the second (index 1) for the first capture group
    (the local part), the third (index 2) for the second capture group (the hostname),
    and the fourth (index 3) for the third and last capture group (the DNS label).
    The result is returned in a tuple, where the first item actually indicates success
    or failure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Following the preceding code, we use C++17 structured bindings to unpack the
    content of the tuple into named variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the program will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21549_02_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.8: Output of tests'
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are multiple versions of regular expressions, and the C++ standard library
    supports six of them: ECMAScript, basic POSIX, extended POSIX, awk, grep, and
    egrep (grep with the option `-E`). The default grammar used is ECMAScript, and
    in order to use another, you have to explicitly specify the grammar when defining
    the regular expression. You can learn more about the supported grammar options
    at [https://en.cppreference.com/w/cpp/regex/syntax_option_type](https://en.cppreference.com/w/cpp/regex/syntax_option_type).
    In addition to specifying the grammar, you can also specify parsing options, such
    as matching by ignoring the case.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The standard library provides more classes and algorithms than we have seen
    so far. The main classes available in the library are as follows (all of them
    are class templates and, for convenience, typedefs are provided for different
    character types):'
  prefs: []
  type: TYPE_NORMAL
- en: 'The class template `std::basic_regex` defines the regular expression object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The class template `std::sub_match` represents a sequence of characters that
    matches a capture group; this class is actually derived from `std::pair`, and
    its `first` and `second` members represent iterators to the first and the one-past-the-end
    characters in the match sequence. If there is no match sequence, the two iterators
    are equal:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The class template `std::match_results` is a collection of matches; the first
    element is always a full match in the target, while the other elements are matches
    of subexpressions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The algorithms available in the regular expressions standard library are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::regex_match()`: This tries to match a regular expression (represented
    by an `std::basic_regex` instance) to an entire string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::regex_search()`: This tries to match a regular expression (represented
    by an `std::basic_regex` instance) to a part of a string (including the entire
    string).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::regex_replace()`: This replaces matches from a regular expression according
    to a specified format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The iterators available in the regular expressions standard library are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::regex_interator`: A constant forward iterator used to iterate through
    the occurrences of a pattern in a string. It has a pointer to an `std::basic_regex`
    that must live until the iterator is destroyed. Upon creation and when incremented,
    the iterator calls `std::regex_search()` and stores a copy of the `std::match_results`
    object returned by the algorithm.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::regex_token_iterator`: A constant forward iterator used to iterate through
    the submatches of every match of a regular expression in a string. Internally,
    it uses a `std::regex_iterator` to step through the submatches. Since it stores
    a pointer to an `std::basic_regex` instance, the regular expression object must
    live until the iterator is destroyed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be mentioned that the standard regex library has poorer performance
    compared to other implementations (such as Boost.Regex) and does not support Unicode.
    Moreover, it could be argued that the API itself is cumbersome to use. However,
    using the standard library has the benefit of avoiding additional dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Parsing the content of a string using regular expressions*, to learn how to
    perform multiple matches of a pattern in a text'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Replacing the content of a string using regular expressions*, to see how to
    perform text replacements with the help of regular expressions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 1*, *Using structured bindings to handle multi-return values*, to
    learn how to bind variables to subobjects or elements from the initializing expressions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing the content of a string using regular expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we looked at how to use `std::regex_match()` to verify
    that the content of a string matches a particular format. The library provides
    another algorithm called `std::regex_search()` that matches a regular expression
    against any part of a string, and not the entire string, as `regex_match()` does.
    This function, however, does not allow us to search through all the occurrences
    of a regular expression in an input string. For this purpose, we need to use one
    of the iterator classes available in the library.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, you will learn how to parse the content of a string using regular
    expressions. For this purpose, we will consider the problem of parsing a text
    file containing name-value pairs. Each such pair is defined on a different line
    and has the format `name = value`, but lines starting with a `#` represent comments
    and must be ignored. The following is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: Before looking at the implementation details, let’s consider some prerequisites.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For general information about regular expression support in C++11, refer to
    the *Verifying the format of a string using regular expressions* recipe earlier
    in this chapter. Basic knowledge of regular expressions is required to proceed
    with this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following examples, `text` is a variable that’s defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: The sole purpose of this is to simplify our snippets, although, in a real-world
    example, you will probably be reading the text from a file or other source.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to search for occurrences of a regular expression through a string,
    you should do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the headers `<regex>` and `<string>` and the namespace `std::string_literals`
    for standard user-defined literals for strings (added in C++14):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use raw string literals (or raw wide string literals for `std::wregex`) to
    specify a regular expression in order to avoid escaping backslashes (which can
    occur frequently). The following regular expression validates the file format
    proposed earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an `std::regex`/`std::wregex` object (depending on the character set
    that is used) to encapsulate the regular expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To search for the first occurrence of a regular expression in a given text,
    use the general-purpose algorithm `std::regex_search()` (example 1):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To find all the occurrences of a regular expression in a given text, use the
    iterator `std::regex_iterator` (example 2):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To iterate through all the subexpressions of a match, use the iterator `std::regex_token_iterator`
    (example 3):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A simple regular expression that can parse the input file shown earlier may
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'This regular expression is supposed to ignore all lines that start with a `#`;
    for those that do not start with `#`, match a name followed by the equals sign
    and then a value, which can be composed of alphanumeric characters and several
    other characters (underscore, dot, comma, and so on). The exact meaning of this
    regular expression is explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Part** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `^` | Start of line |'
  prefs: []
  type: TYPE_TB
- en: '| `(?!#)` | A negative lookahead that makes sure that it is not possible to
    match the `#` character |'
  prefs: []
  type: TYPE_TB
- en: '| `(\w)+` | A capturing group representing an identifier of at least a one-word
    character |'
  prefs: []
  type: TYPE_TB
- en: '| `\s*` | Any white spaces |'
  prefs: []
  type: TYPE_TB
- en: '| `=` | Equals sign |'
  prefs: []
  type: TYPE_TB
- en: '| `\s*` | Any white spaces |'
  prefs: []
  type: TYPE_TB
- en: '| `([\w\d]+[\w\d._,\-:]*)` | A capturing group representing a value that starts
    with an alphanumeric character, but can also contain a dot, comma, backslash,
    hyphen, colon, or underscore |'
  prefs: []
  type: TYPE_TB
- en: '| `$` | End of line |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2.15: Breaking down the regular expression'
  prefs: []
  type: TYPE_NORMAL
- en: We can use `std::regex_search()` to search for a match anywhere in the input
    text. This algorithm has several overloads, but in general, they work in the same
    way. You must specify the range of characters to work through, an output `std::match_results`
    object that will contain the result of the match, and an `std::basic_regex` object
    representing the regular expression and matching flags (which define the way the
    search is done). The function returns `true` if a match was found or `false` otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: In the first example from the previous section (see the fourth list item), `match`
    is an instance of `std::smatch` that is a typedef of `std::match_results` with
    `string::const_iterator` as the template type. If a match is found, this object
    will contain the matching information in a sequence of values for all matched
    subexpressions. The submatch at index 0 is always the entire match.
  prefs: []
  type: TYPE_NORMAL
- en: 'The submatch at index 1 is the first subexpression that was matched, the submatch
    at index 2 is the second subexpression that was matched, and so on. Since we have
    two capturing groups (which are subexpressions) in our regular expression, the
    `std::match_results` will have three submatches in the event of success. The identifier
    representing the name is at index 1, and the value after the equals sign is at
    index 2\. Therefore, this code only prints the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21549_02_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.9: Output of the first example'
  prefs: []
  type: TYPE_NORMAL
- en: The `std::regex_search()` algorithm is not able to iterate through all the possible
    matches in a piece of text. To do that, we need to use an iterator. `std::regex_iterator`
    is intended for this purpose. It allows not only iterating through all the matches
    but also accessing all the submatches of a match.
  prefs: []
  type: TYPE_NORMAL
- en: The iterator actually calls `std::regex_search()` upon construction and on each
    increment, and it remembers the resulting `std::match_results` from the call.
    The default constructor creates an iterator that represents the end of the sequence
    and can be used to test when the loop through the matches should stop.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second example from the previous section (see the fifth list item),
    we first create an end-of-sequence iterator, and then we start iterating through
    all the possible matches. When constructed, it will call `std::regex_match()`,
    and if a match is found, we can access its results through the current iterator.
    This will continue until no match is found (the end of the sequence). This code
    will print the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21549_02_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.10: Output of the second example'
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative to `std::regex_iterator` is `std::regex_token_iterator`. This
    works similarly to the way `std::regex_iterator` works and, in fact, it contains
    such an iterator internally, except that it enables us to access a particular
    subexpression from a match. This is shown in the third example in the *How to
    do it...* section (see the sixth list item). We start by creating an end-of-sequence
    iterator and then loop through the matches until the end-of-sequence is reached.
    In the constructor we used, we did not specify the index of the subexpression
    to access through the iterator; therefore, the default value of 0 is used. This
    means this program will print all the matches:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21549_02_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.11: Output of the third example'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted to access only the first subexpression (this means the names in
    our case), all we had to do was specify the index of the subexpression in the
    constructor of the token iterator, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the output that we get contains only the names. This is shown in
    the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21549_02_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.12: Output containing only the names'
  prefs: []
  type: TYPE_NORMAL
- en: 'An interesting thing about the token iterator is that it can return the unmatched
    parts of the string if the index of the subexpressions is `-1`, in which case
    it returns an `std::match_results` object that corresponds to the sequence of
    characters between the last match and the end of the sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'This program will output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21549_02_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.13: Output including empty lines'
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the empty lines in the output correspond to empty tokens.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Verifying the format of a string using regular expressions*, to familiarize
    yourself with the C++ library support for working with regular expressions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Replacing the content of a string using regular expressions*, to learn how
    to perform multiple matches of a pattern in a text'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replacing the content of a string using regular expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous two recipes, we looked at how to match a regular expression
    on a string or a part of a string and iterate through matches and submatches.
    The regular expression library also supports text replacement based on regular
    expressions. In this recipe, we will learn how to use `std::regex_replace()` to
    perform such text transformations.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For general information about regular expression support in C++11, refer to
    the *Verifying the format of a string using regular expressions* recipe earlier
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to perform text transformations using regular expressions, you should
    perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Include `<regex>` and `<string>` and the namespace `std::string_literals` for
    C++14 standard user-defined literals for strings:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `std::regex_replace()` algorithm with a replacement string as the third
    argument. Consider the following example. Replace all words composed of exactly
    three characters that are either `a`, `b`, or `c` with three hyphens:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `std::regex_replace()` algorithm with match identifiers prefixed with
    a `$` for the third argument. For example, replace names in the format “lastname,
    firstname” with names in the format “firstname lastname”, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `std::regex_replace()` algorithm has several overloads with different types
    of parameters, but the meaning of the parameters is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The input string on which the replacement is performed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `std::basic_regex` object that encapsulates the regular expression used to
    identify the parts of the strings to be replaced
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The string format used for replacement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional matching flags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The return value is, depending on the overload used, either a string or a copy
    of the output iterator provided as an argument. The string format used for replacement
    can either be a simple string or a match identifier, indicated with a `$` prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$&` indicates the entire match.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$1`, `$2`, `$3`, and so on indicate the first, second, and third submatches,
    and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`` $` `` indicates the part of the string before the first match.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$''` indicates the part of the string after the last match.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the first example shown in the *How to do it...* section, the initial text
    contains two words made of exactly three `a`, `b`, and `c` characters: `abc` and
    `bca`. The regular expression indicates an expression of exactly three characters
    between word boundaries. This means a subtext, such as `bbbb`, will not match
    the expression. The result of the replacement is that the string text will be
    `--- aa --- ca bbbb`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Additional flags for the match can be specified for the `std::regex_replace()`
    algorithm. By default, the matching flag is `std::regex_constants::match_default`,
    which basically specifies ECMAScript as the grammar used for constructing the
    regular expression. If we want, for instance, to replace only the first occurrence,
    then we can specify `std::regex_constants::format_first_only`. In the following
    example, the result is `--- aa bca ca bbbb` as the replacement stops after the
    first match is found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: The replacement string, however, can contain special indicators for the whole
    match, a particular submatch, or the parts that were not matched, as explained
    earlier. In the second example shown in the *How to do it...* section, the regular
    expression identifies a word of at least one character, followed by a comma and
    possible white spaces, and then another word of at least one character. The first
    word is supposed to be the last name, while the second word is supposed to be
    the first name. The replacement string is in the `$2 $1` format. This is an instruction
    that’s used to replace the matched expression (in this example, the entire original
    string) with another string formed of the second submatch, followed by a space,
    and then the first submatch.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the entire string was a match. In the following example, there
    will be multiple matches inside the string, and they will all be replaced with
    the indicated string. In this example, we are replacing the indefinite article
    *a* when preceding a word that starts with a vowel (this, of course, does not
    cover words that start with a vowel sound) with the indefinite article *an*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: The regular expression identifies the letter *a* as a single word (`\b` indicates
    a word boundary, so `\ba` means a word with a single letter, *a*), followed by
    a space and a word of at least two characters starting with a vowel. When such
    a match is identified, it is replaced with a string formed of the fixed string
    *an*, followed by a space and the first subexpression of the match, which is the
    word itself. In this example, the `newtext` string will be `this is an example
    with an error`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from the identifiers of the subexpressions (`$1`, `$2`, and so on), there
    are other identifiers for the entire match (`$&`), the part of the string before
    the first match (`` $` ``), and the part of the string after the last match (`$''`).
    In the last example, we change the format of a date from `dd.mm.yyyy` to `yyyy.mm.dd`,
    but also show the matched parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: The regular expression matches a one- or two-digit number followed by a dot,
    hyphen, or slash; followed by another one- or two-digit number; then a dot, hyphen,
    or slash; and lastly, a four-digit number. Keep in mind this is only an example,
    and there are better expressions for parsing a date.
  prefs: []
  type: TYPE_NORMAL
- en: For `newtext1`, the replacement string is `$5$4$3$2$1`; this means year, followed
    by the second separator, then month, the first separator, and finally, day. Therefore,
    for the input string `today is 1.06.2023!`, the result is `today is 2023.06.1!!`.
  prefs: []
  type: TYPE_NORMAL
- en: For `newtext2`, the replacement string is ``[$`][$&][$']``; this means the part
    before the first match, followed by the entire match, and finally, the part after
    the last match are in square brackets. However, the result is not `[!!][1.06.2023][today
    is ]` as you perhaps might expect at first glance, but `today is [today is ][1.06.2023][!!]!!`.
    The reason for this is that what is replaced is the matched expression, and, in
    this case, that is only the date (`1.06.2023`). This substring is replaced with
    another string formed of all the parts of the initial string.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Verifying the format of a string using regular expressions*, to familiarize
    yourself with the C++ library support for working with regular expressions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Parsing the content of a string using regular expressions*, to learn how to
    perform multiple matches of a pattern in a text'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using std::string_view instead of constant string references
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with strings, temporary objects are created all the time, even
    if you might not be really aware of it. Many times, these temporary objects are
    irrelevant and only serve the purpose of copying data from one place to another
    (for example, from a function to its caller). This represents a performance issue
    because they require memory allocation and data copying, which should be avoided.
    For this purpose, the C++17 standard provides a new string class template called
    `std::basic_string_view`, which represents a non-owning constant reference to
    a string (that is, a sequence of characters). In this recipe, you will learn when
    and how you should use this class.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `string_view` class is available in the namespace `std` in the `string_view`
    header.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You should use `std::string_view` to pass a parameter to a function (or return
    a value from a function), instead of `std::string const &`, unless your code needs
    to call other functions that take `std::string` parameters (in which case, conversions
    would be necessary):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we look at how the new string type works, let’s consider the following
    example of a function that is supposed to extract the name of a file without its
    extension. This is basically how you would write the function from the previous
    section before C++17:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: Note that, in this example, the file separator is `\` (backslash), as in Windows.
    For Linux-based systems, it has to be changed to `/` (slash).
  prefs: []
  type: TYPE_NORMAL
- en: The `get_filename()` function is relatively simple. It takes a constant reference
    to an `std::string` and identifies a substring bounded by the last file separator
    and the last dot, which basically represents a filename without an extension (and
    without folder names).
  prefs: []
  type: TYPE_NORMAL
- en: The problem with this code, however, is that it creates one, two, or possibly
    even more temporaries, depending on the compiler optimizations. The function parameter
    is a constant `std::string` reference, but the function is called with a string
    literal, which means `std::string` needs to be constructed from the literal. These
    temporaries need to allocate and copy data, which is both time- and resource-consuming.
    In the last example, all we want to do is check whether the first character of
    the filename is an underscore, but we create at least two temporary string objects
    for that purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `std::basic_string_view` class template is intended to solve this problem.
    This class template is very similar to `std::basic_string`, with the two having
    almost the same interface. The reason for this is that `std::basic_string_view`
    is intended to be used instead of a constant reference to an `std::basic_string`
    without further code changes. Just like with `std::basic_string`, there are specializations
    for all types of standard characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: The `std::basic_string_view` class template defines a reference to a constant
    contiguous sequence of characters. As the name implies, it represents a view and
    cannot be used to modify the reference sequence of characters. An `std::basic_string_view`
    object has a relatively small size because all it needs is a pointer to the first
    character in the sequence and the length. It can be constructed not only from
    an `std::basic_string` object but also from a pointer and a length, or from a
    null-terminated sequence of characters (in which case, it will require an initial
    traversal of the string in order to find the length). Therefore, the `std::basic_string_view`
    class template can also be used as a common interface for multiple types of strings
    (as long as data only needs to be read). On the other hand, converting from an
    `std::basic_string_view` to an `std::basic_string` is not possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'You must explicitly construct an `std::basic_string` object from a `std::basic_string_view`,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: Passing `std::basic_string_view` to functions and returning `std::basic_string_view`
    still creates temporaries of this type, but these are small-sized objects on the
    stack (a pointer and a size could be 16 bytes for 64-bit platforms); therefore,
    they should incur fewer performance costs than allocating heap space and copying
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Note that all major compilers provide an implementation of `std::basic_string`,
    which includes a small string optimization. Although the implementation details
    are different, they typically rely on having a statically allocated buffer of
    a number of characters (16 for VC++ and GCC 5 or newer) that does not involve
    heap operations, which are only required when the size of the string exceeds that
    number of characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the methods that are identical to those available in `std::basic_string`,
    the `std::basic_string_view` has two more:'
  prefs: []
  type: TYPE_NORMAL
- en: '`remove_prefix()`: Shrinks the view by incrementing the start with *N* characters
    and decrementing the length with *N* characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remove_suffix()`: Shrinks the view by decrementing the length with *N* characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The two member functions are used in the following example to trim spaces from
    an `std::string_view`, both at the beginning and the end. The implementation of
    the function first looks for the first element that is not a space and then for
    the last element that is not a space. Then, it removes from the end everything
    after the last non-space character, and from the beginning, everything until the
    first non-space character. The function returns the new view, trimmed at both
    ends:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'When using `std::basic_string_view`, you must be aware of two things: you cannot
    change the underlying data referred to by a view and you must manage the lifetime
    of the data, as the view is a non-owning reference.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Creating a library of string helpers*, to see how to create useful text utilities
    that are not directly available in the standard library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formatting and printing text with std::format and std::print
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The C++ language has two ways of formatting text: the `printf` family of functions
    and the I/O streams library. The `printf` functions are inherited from C and provide
    a separation of the formatting text and the arguments. The streams library provides
    safety and extensibility and is usually recommended over `printf` functions, but
    is, in general, slower. The C++20 standard proposes a new formatting library alternative
    for output formatting, which is similar in form to `printf` but safe and extensible
    and is intended to complement the existing streams library. In this recipe, we
    will learn how to use the new functionalities instead of the `printf` functions
    or the streams library.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The new formatting library is available in the `<format>` header. You must include
    this header for the following samples to work.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `std::format()` function formats its arguments according to the provided
    formatting string. You can use it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Provide empty replacement fields, represented by `{}`, in the format string
    for each argument:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Specify the 0-based index of each argument in the argument list inside the
    replacement field, such as `{0}`, `{1}`, and so on. The order of the arguments
    is not important, but the index must be valid:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Control the output text with format specifiers provided in the replacement
    field after a colon (`:`). For basic and string types, this is a standard format
    specification. For chrono types, this is a chrono format specification:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can also write the arguments in an out format using an iterator with either
    `std::format_to()` or `std::format_to_n()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write to a buffer, such as an `std::string` or `std::vector<char>`, using `std::format_n()`
    and using the `std::back_inserter()` helper function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `std::formatted_size()` to retrieve the number of characters necessary
    to store the formatted representation of the arguments:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To limit the number of characters written to the output buffer, you can use
    `std::format_to_n()`, which is similar to `std::format_to()` but writes, at most,
    `n` characters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In C++23, you can write formatted text directly to a file stream, such as the
    standard output console, using the following functions from the new `<print>`
    header:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::print`, to write the arguments according to the format string:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`std::println`, to write the arguments according to the format string followed
    by a new line character (`''\n''`):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `std::format()` function has multiple overloads. You can specify the format
    string either as a string view or a wide string view, with the function returning
    either an `std::string` or an `std::wstring`. You can also specify, as the first
    argument, an `std::locale`, which is used for locale-specific formatting. The
    function overloads are all variadic function templates, which means you can specify
    any number of arguments after the format.
  prefs: []
  type: TYPE_NORMAL
- en: The format string consists of ordinary characters, replacement fields, and escape
    sequences. The escape sequences are `{{` and `}}` and are replaced with `{` and
    `}` in the output. A replacement field is provided within curly brackets `{}`.
    It can optionally contain a non-negative number, representing the 0-based index
    of the argument to be formatted, and a colon (`:`), followed by a format specifier.
    If the format specifier is invalid, an exception of the type `std::format_error`
    is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: In a similar manner, `std::format_to()` has multiple overloads, just like `std::format()`.
    The difference between these two is that `std::format_to()` always takes an iterator
    to the output buffer as the first argument and returns an iterator past the end
    of the output range (and not a string as `std::format()` does). On the other hand,
    `std::format_to_n()` has one more parameter than `std::format_to()`. Its second
    parameter is a number representing the maximum number of characters to be written
    to the buffer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following listing shows the signature of the simplest overload of each
    of these three function templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: When you provide the format string, you can supply argument identifiers (their
    0-based index) or omit them. However, it is illegal to use both. If the indexes
    are omitted in the replacement fields, the arguments are processed in the provided
    order, and the number of replacement fields must not be greater than the number
    of supplied arguments. If indexes are provided, they must be valid for the format
    string to be valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a format specification is used, then:'
  prefs: []
  type: TYPE_NORMAL
- en: For basic types and string types, it is considered to be a standard format specification.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For chrono types, it is considered to be a chrono format specification.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For user-defined types, it is defined by a user-defined specialization of the
    `std::formatter` class for the desired type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The standard format specification is based on the format specification in Python
    and has the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: These syntax parts are briefly described here.
  prefs: []
  type: TYPE_NORMAL
- en: '`fill-and-align` is an optional fill character, followed by one of the align
    options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<`: Forces the field to be left-aligned with the available space.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`>`: Forces the field to be right-aligned with the available space.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`^`: Forces the field to be centered with the available space. To do so, it
    will insert n/2 characters to the left and n/2 characters to the right:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`sign`, `#`, and `0` are only valid when a number (either an integer or a floating-point)
    is used. The sign can be one of:'
  prefs: []
  type: TYPE_NORMAL
- en: '`+`: Specifies that the sign must be used for both negative and positive numbers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-`: Specifies that the sign must be used only for negative numbers (which
    is the implicit behavior)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A space: Specifies that the sign must be used for negative numbers and that
    a leading space must be used for non-negative numbers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `#` symbol causes the alternate form to be used. This can be one of the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: For integral types, when binary, octal, or hexadecimal representation is specified,
    the alternate form adds the prefix `0b`, `0`, or `0x` to the output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For floating-point types, the alternate form causes a decimal-point character
    to always be present in the formatted value, even if no digits follow it. In addition,
    when `g` or `G` are used, the trailing zeros are not removed from the output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The digit `0` specifies that leading zeros should be outputted to the field
    width, except when the value of a floating-point type is infinity or `NaN`. When
    present alongside an align option, the specifier `0` is ignored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '`width` specifies the minimum field width and can be either a positive decimal
    number or a nested replacement field. The `precision` field indicates the precision
    for floating-point types or, for string types, how many characters will be used
    from the string. It is specified with a dot (`.`), followed by a non-negative
    decimal number or a nested replacement field.'
  prefs: []
  type: TYPE_NORMAL
- en: Locale-specific formatting is specified with the uppercase `L` and causes the
    locale-specific form to be used. This option is only available for arithmetic
    types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The optional `type` determines how the data will be presented in the output.
    The available string presentation types are shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Presentation type** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Strings | none, `s` | Copies the string to the output. |'
  prefs: []
  type: TYPE_TB
- en: '| Integral types | `b` | Binary format with 0b as a prefix. |'
  prefs: []
  type: TYPE_TB
- en: '| `B` | Binary format with 0B as a prefix. |'
  prefs: []
  type: TYPE_TB
- en: '| `C` | Character format. Copies the value to the output as it was a character
    type. |'
  prefs: []
  type: TYPE_TB
- en: '| none or `d` | Decimal format. |'
  prefs: []
  type: TYPE_TB
- en: '| `O` | Octal format with 0 as a prefix (unless the value is 0). |'
  prefs: []
  type: TYPE_TB
- en: '| `x` | Hexadecimal format with 0x as a prefix. |'
  prefs: []
  type: TYPE_TB
- en: '| `X` | Hexadecimal format with 0X as a prefix. |'
  prefs: []
  type: TYPE_TB
- en: '| `char` and `wchar_t` | none or `c` | Copies the character to the output.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `b`, `B`, `c`, `d`, `o`, `x`, `X` | Integer presentation types. |'
  prefs: []
  type: TYPE_TB
- en: '| `bool` | none or `s` | Copies true or false as a textual representation (or
    their local-specific form) to the output. |'
  prefs: []
  type: TYPE_TB
- en: '| `b`, `B`, `c`, `d`, `o`, `x`, `X` | Integer presentation types. |'
  prefs: []
  type: TYPE_TB
- en: '| Floating-point | `a` | Hexadecimal representation. Same as if calling `std::to_chars(first,
    last, value, std::chars_format::hex, precision)` or `std::to_chars(first, last,
    value, std::chars_format::hex)`, depending on whether precision is specified or
    not. |'
  prefs: []
  type: TYPE_TB
- en: '| `A` | Same as `a` except that it uses uppercase letters for digits above
    9 and uses P to indicate the exponent. |'
  prefs: []
  type: TYPE_TB
- en: '| `e` | Scientific representation. Produces the output as if calling `std::to_chars(first,
    last, value, std::chars_format::scientific, precision)`. |'
  prefs: []
  type: TYPE_TB
- en: '| `E` | Similar to `e` except that it uses `E` to indicate the exponent. |'
  prefs: []
  type: TYPE_TB
- en: '| `f`, `F` | Fixed representation. Produces the output as if by calling `std::to_chars(first,
    last, value, std::chars_format::fixed, precision)`. When no precision is specified,
    the default is 6. |'
  prefs: []
  type: TYPE_TB
- en: '| `g` | General floating-point representation. Produces the output as if by
    calling `std::to_chars(first, last, value, std::chars_format::general, precision)`.
    When no precision is specified, the default is 6. |'
  prefs: []
  type: TYPE_TB
- en: '| `G` | Same as `g` except that it uses `E` to indicate the exponent. |'
  prefs: []
  type: TYPE_TB
- en: '| Pointer | none or `p` | Pointer representation. Produces the output as if
    by calling `std::to_chars(first, last, reinterpret_cast<std::uintptr_t>(value),
    16)` with the prefix `0x` added to the output. This is available only when `std::uintptr_t`
    is defined; otherwise, the output is implementation-defined. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2.16: The list of available presentation types'
  prefs: []
  type: TYPE_NORMAL
- en: 'The chrono format specification has the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: The `fill-and-align`, `width`, and `precision` fields have the same meaning
    as in the standard format specification, described previously. The precision is
    only valid for `std::chrono::duration` types when the representation type is a
    floating-point type. Using it in other cases throws an `std::format_error` exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'The chrono specification can be empty, in which case the argument is formatted
    as if by streaming it to an `std::stringstream` and copying the result string.
    Alternatively, it can consist of a series of conversion specifiers and ordinary
    characters. Some of these format specifiers are presented in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Conversion specifier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `%%` | Writes a literal `%` character. |'
  prefs: []
  type: TYPE_TB
- en: '| `%n` | Writes a newline character. |'
  prefs: []
  type: TYPE_TB
- en: '| `%t` | Writes a horizontal tab character. |'
  prefs: []
  type: TYPE_TB
- en: '| `%Y` | Writes the year as a decimal number. If the result is less than four
    digits, it is left-padded with `0` to four digits. |'
  prefs: []
  type: TYPE_TB
- en: '| `%m` | Writes the month as a decimal number (January is `01`). If the result
    is a single digit, it is prefixed with `0`. |'
  prefs: []
  type: TYPE_TB
- en: '| `%d` | Writes the day of the month as a decimal number. If the result is
    a single decimal digit, it is prefixed with `0`. |'
  prefs: []
  type: TYPE_TB
- en: '| `%w` | Writes the weekday as a decimal number (`0`-`6`), where Sunday is
    `0`. |'
  prefs: []
  type: TYPE_TB
- en: '| `%D` | Equivalent to `%m/%d/%y`. |'
  prefs: []
  type: TYPE_TB
- en: '| `%F` | Equivalent to `%Y-%m-%d`. |'
  prefs: []
  type: TYPE_TB
- en: '| `%H` | Writes the hour (24-hour clock) as a decimal number. If the result
    is a single digit, it is prefixed with `0`. |'
  prefs: []
  type: TYPE_TB
- en: '| `%I` | Writes the hour (12-hour clock) as a decimal number. If the result
    is a single digit, it is prefixed with `0`. |'
  prefs: []
  type: TYPE_TB
- en: '| `%M` | Writes the minute as a decimal number. If the result is a single digit,
    it is prefixed with `0`. |'
  prefs: []
  type: TYPE_TB
- en: '| `%S` | Writes the second as a decimal number. If the number of seconds is
    less than 10, the result is prefixed with `0`. |'
  prefs: []
  type: TYPE_TB
- en: '| `%R` | Equivalent to `%H:%M`. |'
  prefs: []
  type: TYPE_TB
- en: '| `%T` | Equivalent to `%H:%M:%S`. |'
  prefs: []
  type: TYPE_TB
- en: '| `%X` | Writes the locale’s time representation. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2.17: A list of the most commonly used chrono specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: The complete list of format specifiers for the chrono library can be consulted
    at [https://en.cppreference.com/w/cpp/chrono/system_clock/formatter](https://en.cppreference.com/w/cpp/chrono/system_clock/formatter).
  prefs: []
  type: TYPE_NORMAL
- en: Because writing formatted text to the console or a file stream requires two
    operations (formatting text into a string or a vector of characters and then writing
    that buffer to the output stream), the C++23 standard introduced a couple of new
    functions to simplify this process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new `std::print` and `std::println` functions are very similar. The only
    difference is that `std::println` appends a `\n` character (new line) after the
    formatted text. These two functions have two overloads each:'
  prefs: []
  type: TYPE_NORMAL
- en: One that takes an `std::FILE*` as the first argument, representing the output
    file stream
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One that does not have such an argument, and uses the C output stream stdout
    implicitly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Because of this, the following two calls to `std::println` are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, the following two calls to `std::print` and `std::println` have the same
    result on the standard output stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: The format string specification is the same as for `std::format` and was presented
    previously.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Using std::format with user-defined types*, to learn how to create custom
    formatting specialization for user-defined types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Converting between numeric and string types*, to learn how to convert between
    numbers and strings'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using std::format with user-defined types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C++20 formatting library is a modern alternative to using `printf`-like
    functions or the I/O streams library, which it actually complements. Although
    the standard provides default formatting for basic types, such as integral and
    floating-point types, `bool`, character types, strings, and chrono types, the
    user can create custom specializations for user-defined types. In this recipe,
    we will learn how to do that.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should read the previous recipe, *Formatting and printing text with std::format
    and std::print*, to familiarize yourself with the formatting library.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the examples that we’ll be showing here, we will use the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we’ll introduce the necessary steps to implement to enable
    text formatting using `std::format()` for user-defined types.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To enable formatting using the new formatting library for user-defined types,
    you must do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a specialization of the `std::formatter<T, CharT>` class in the `std`
    namespace.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement the `parse()` method to parse the portion of the format string corresponding
    to the current argument. If the class inherits from another formatter, then this
    method can be omitted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement the `format()` method to format the argument and write the output
    via `format_context`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the `employee` class listed here, a formatter that formats `employee` to
    the form `[42]` `John Doe` (that is, `[id] firstName lastName`) can be implemented
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The formatting library uses the `std::formatter<T, CharT>` class template to
    define formatting rules for a given type. Built-in types, string types, and chrono
    types have formatters provided by the library. These are implemented as specializations
    of the `std::formatter<T, CharT>` class template.
  prefs: []
  type: TYPE_NORMAL
- en: 'This class has two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`parse()`, which takes a single argument of the type `std::basic_format_parse_context<CharT>`
    and parses the format’s specification for the type `T`, provided by the parse
    context. The result of the parsing is supposed to be stored in member fields of
    the class. If the parsing succeeds, this function should return a value of the
    type `std::basic_format_parse_context<CharT>::iterator`, which represents the
    end of the format specification. If the parsing fails, the function should throw
    an exception of the type `std::format_error` to provide details about the error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`format()`, which takes two arguments, with the first being the object of the
    type `T` to format and the second being a formatting context object of the type
    `std::basic_format_context<OutputIt, CharT>`. This function should write the output
    to `ctx.out()` according to the desired specifiers (which could be something implicit
    or the result of parsing the format specification). The function must return a
    value of the type `std::basic_format_context<OutputIt, CharT>::iterator`, representing
    the end of the output.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the implementation shown in the previous section, the `parse()` function
    does not do anything other than return an iterator representing the beginning
    of the format specification. The formatting is always done by printing the employee
    identifier between square brackets, followed by the first name and the last name,
    such as in `[42] John Doe`. An attempt to use a format specifier would result
    in a compile-time error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want your user-defined types to support format specifiers, then you
    must properly implement the `parse()` method. To show how this can be done, we
    will support the several specifiers for the `employee` class, as defined in the
    following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Specifier** | **Description** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| `L` | Lexicographic order | [42] Doe, John |'
  prefs: []
  type: TYPE_TB
- en: '| `l` | Lowercase | [42] john doe |'
  prefs: []
  type: TYPE_TB
- en: '| `u` | Uppercase | [42] JOHN DOE |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2.18: Specifiers supported for the user-defined employee class'
  prefs: []
  type: TYPE_NORMAL
- en: When the `L` specifier is used, the `employee` is formatted with the identifier
    in square brackets, followed by the last name, a comma, and then the first name,
    such as in *[42] Doe, John*. A combination of these specifiers is also possible.
    For instance `{:Ll}` would produce *[42] doe, john*, while `{:uL}` would produce
    *[42] DOE, JOHN*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The specialization of the `std::formatter` class for the employee class that
    implements the defined requirements may look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'The `parse()` function receives the parsing context that includes the format
    string. The `begin()` iterator points to the first element of the format string
    after the format delimiter (`:`). An example is provided in the next table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Format** | **begin() iterator** | **Range** |'
  prefs: []
  type: TYPE_TB
- en: '| `"{}"` | Equal to `end()` | Empty |'
  prefs: []
  type: TYPE_TB
- en: '| `"{0}"` | Equal to `end()` | Empty |'
  prefs: []
  type: TYPE_TB
- en: '| `"{0:L}"` | Points to `''L''` | `L}` |'
  prefs: []
  type: TYPE_TB
- en: '| `"{:L}"` | Points to `''L''` | `L}` |'
  prefs: []
  type: TYPE_TB
- en: '| `"{:Lul}"` | Points to `''L''` | `Lul}` |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2.19: Examples of the content of the parsing context'
  prefs: []
  type: TYPE_NORMAL
- en: 'With this defined, the preceding sample code (using the `{:L}` format argument)
    would work. Moreover, various combinations of the `L`, `u`, and `l` specifiers
    can be used, as exemplified next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiple usage of the same argument is also possible, as in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'However, using other format specifiers (such as `A`, for example) would not
    work; the specifier is simply ignored and the default formatting is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'If you do not need to parse the format specifier in order to support various
    options, you could entirely omit the `parse()` method. However, in order to do
    so, your `std::formatter` specialization must derive from another `std::formatter`
    class. An implementation is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: This specialization for the `employee` class is equivalent to the first implementation
    shown earlier in the *How to do it...* section.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The C++23 standard introduces a new concept called `std::formattable` (also
    in the `<format>` header), which specifies that a type is formattable. That means
    that a specialization of `std::format` is available for a type `T` and that it
    defines the `parse()` and `format()` member functions, as described in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Formatting text with std::format*, to get a good introduction to the new C++20
    text formatting library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://discord.gg/7xRaTCeEhx](Chapter_02.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code2659294082093549796.png)'
  prefs: []
  type: TYPE_IMG
