- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Working with Numbers and Strings
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理数字和字符串
- en: Numbers and strings are the fundamental types of any programming language; all
    other types are based on or composed of these. Developers are confronted all the
    time with tasks such as converting between numbers and strings, parsing and formatting
    strings, and generating random numbers. This chapter is focused on providing useful
    recipes for these common tasks using modern C++ language and library features.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 数字和字符串是任何编程语言的基本类型；所有其他类型都是基于或由这些类型构成的。开发者经常面临诸如在数字和字符串之间转换、解析和格式化字符串、生成随机数等任务。本章专注于提供使用现代
    C++ 语言和库功能解决这些常见任务的有用配方。
- en: 'The recipes included in this chapter are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含的配方如下：
- en: Understanding the various numeric types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解各种数值类型
- en: Limits and other properties of numeric types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数值类型的限制和其他属性
- en: Converting between numeric and string types
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数值类型和字符串类型之间进行转换
- en: Understanding the various character and string types
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解各种字符和字符串类型
- en: Printing Unicode characters to the output console
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Unicode 字符打印到输出控制台
- en: Generating pseudo-random numbers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成伪随机数
- en: Properly initializing a pseudo-random number generator
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确初始化伪随机数生成器
- en: Creating cooked user-defined literals
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建熟成的用户定义文字
- en: Creating raw user-defined literals
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建原始用户定义文字
- en: Using raw string literals to avoid escaping characters
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原始字符串文字避免转义字符
- en: Creating a library of string helpers
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建字符串辅助库
- en: Verifying the format of a string using regular expressions
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用正则表达式验证字符串的格式
- en: Parsing the content of a string using regular expressions
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用正则表达式解析字符串内容
- en: Replacing the content of a string using regular expressions
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用正则表达式替换字符串内容
- en: Using `std::string_view` instead of constant string references
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::string_view` 而不是常量字符串引用
- en: Formatting and printing text with `std::format` and `std::print`
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::format` 和 `std::print` 格式化和打印文本
- en: Using `std::format` with user-defined types
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::format` 与用户定义类型
- en: Let’s start this chapter by looking at the different numeric types that exist
    in the C++ programming language.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看 C++ 编程语言中存在的不同数值类型开始这一章。
- en: Understanding the various numeric types
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解各种数值类型
- en: The C++ programming language defines a multitude of arithmetic types; these
    are types on which arithmetic operations (addition, subtraction, multiplication,
    division, modulo) can be performed. This category includes character, integral,
    and floating-point types. Many of these types are inherited from the C programming
    languages, while some have been added to C++ in recent versions of the standard.
    A typical problem with the arithmetic types is that, unlike many other programming
    languages, most of them don’t have a fixed size. The size varies with the target
    platform and the standard only guarantees a minimum one. In this recipe, we will
    learn about the various integral and floating-point types.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 编程语言定义了大量的算术类型；这些类型是可以在其上执行算术运算（加法、减法、乘法、除法、取模）的类型。这个类别包括字符、整数和浮点类型。许多这些类型是从
    C 编程语言继承的，而有些是在标准最近版本中添加到 C++ 中的。算术类型的一个典型问题是，与许多其他编程语言不同，它们中的大多数没有固定的大小。大小随目标平台而变化，标准只保证最小值。在本配方中，我们将了解各种整数和浮点类型。
- en: How to do it…
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Use one of the available numeric types depending on the kind of value you need
    to represent:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 根据需要表示的值类型，使用可用的数值类型之一：
- en: 'To represent an integral value (when the range doesn’t really matter), use
    the `int` type. This is the default basic (signed) integer type, typically with
    a size of 32 bits, but not guaranteed. You can use it for values such as the age
    of a person, the day, month, and year in a date, the rating of a movie or book,
    the number of items in a collection, and countless other things:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要表示一个整数值（当范围不是特别重要时），使用 `int` 类型。这是默认的基本（有符号）整数类型，通常大小为 32 位，但不保证。你可以用它表示诸如人的年龄、日期中的日、月、年、电影或书籍的评分、集合中的项目数量以及无数其他事物：
- en: '[PRE0]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Use signedness (`signed`/`unsigned`) and size (`short`/`long`/`long long`)
    modifiers when you need to impose restrictions on the range of possible values
    or the memory representation. For instance, you may want to use unsigned integers
    to represent values that cannot have negative values. Mixing signed and unsigned
    integers should be avoided. On the other hand, you may want to optimize the memory
    used for storing some values, such as those representing a date, in which case
    you could use a `short int`, guaranteed to be at least 16 bits. If you need to
    represent large values, such as the size of a file, you can use `unsigned long
    long int`, which is guaranteed to be at least 64 bits:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你需要对可能值的范围或内存表示施加限制时，请使用有符号性（`signed`/`unsigned`）和大小（`short`/`long`/`long long`）修饰符。例如，你可能想使用无符号整数来表示不能有负值的值。应避免混合有符号和无符号整数。另一方面，你可能想优化存储某些值的内存使用，例如表示日期的值，在这种情况下，你可以使用至少16位的`short
    int`。如果你需要表示大值，例如文件的大小，你可以使用`unsigned long long int`，它保证至少有64位：
- en: '[PRE1]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To represent `std::array` indexes (which cannot be negative), the number of
    elements in a collection (such as standard containers), or the result of the `sizeof`
    operator, use `std::size_t`. This is an unsigned integer type of at least 16 bits.
    The standard containers defined a member type alias called `size_type` for size
    and indexing the container, and this type is typically a synonym for `std::size_t`:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要表示`std::array`索引（不能是负数）、集合（如标准容器）中的元素数量或`sizeof`运算符的结果，请使用`std::size_t`。这是一个至少16位的无符号整数类型。标准容器定义了一个成员类型别名`size_type`用于大小和容器的索引，这个类型通常与`std::size_t`同义：
- en: '[PRE2]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To store the result of a pointer arithmetic operation, or present a C-like array
    index (which can be negative), use `std::ptrdiff_t`. The C++ standard containers
    define a member type alias called `difference_type` to store differences between
    iterators, and this is typically defined as a synonym for `std::ptrdiff_t`.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要存储指针算术运算的结果，或表示类似于C语言的数组索引（可以是负数），请使用`std::ptrdiff_t`。C++标准容器定义了一个成员类型别名`difference_type`来存储迭代器之间的差异，这通常被定义为`std::ptrdiff_t`的同义词。
- en: When you need to store a value that needs a guaranteed range, use one of the
    `std::int8_t`, `std::int16_t`, `std::int32_t`, or `std::int64_t` types. Although
    these are optional, they are defined for all modern architectures.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你需要存储一个需要保证范围的值时，请使用`std::int8_t`、`std::int16_t`、`std::int32_t`或`std::int64_t`类型之一。尽管这些是可选的，但它们在所有现代架构上都是定义好的。
- en: When you need to store non-negative values or perform bit manipulations on values
    of a guaranteed range, use one of the `std::uint8_t`, `std::uint16_t`, `std::uint32_t`,
    or `std::uint64_t` types.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你需要存储非负值或对保证范围内的值执行位操作时，请使用`std::uint8_t`、`std::uint16_t`、`std::uint32_t`或`std::uint64_t`类型之一。
- en: When you need to store a value that needs a guaranteed range and, at the same
    time, you want to optimize for fastest access, use one of the `std::int_fast8_t`,
    `std::int_fast16_t`, `std::int_fast32_t`, or `std::int_fast64_t` types (or their
    unsigned counterparts). These are guaranteed to be available on all target architectures.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你需要存储一个需要保证范围且同时希望优化访问速度的值时，请使用`std::int_fast8_t`、`std::int_fast16_t`、`std::int_fast32_t`或`std::int_fast64_t`类型（或它们的无符号对应类型）。这些类型在所有目标架构上都是可用的。
- en: When you need to store a value that needs a guaranteed range and, at the same
    time, you want to optimize the memory usage, use one of `std::int_least8_t`, `std::int_last16_t`,
    `std::int_least32_t`, or `std::int_least64_t` (or their unsigned counterparts).
    These are also guaranteed to be available on all target architectures.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你需要存储一个需要保证范围且同时希望优化内存使用的值时，请使用`std::int_least8_t`、`std::int_least16_t`、`std::int_least32_t`或`std::int_least64_t`（或它们的无符号对应类型）。这些类型在所有目标架构上都是可用的。
- en: 'To represent a real number, use the type `double`. This is the default floating-point
    type, with a size of 64 bits. The name indicates a double precision type, as opposed
    to a single precision type (using 32 bits), implemented with the `float` type.
    An extended precision type, called `long double`, is also available. The standard
    does not specify its actual precision but requires that it’s at least the same
    as the `double` type. On some compilers, this can be a quadruple precision (using
    128 bits), although some, such as VC++, treat it as equal to `double`:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要表示实数，请使用类型 `double`。这是默认的浮点类型，大小为 64 位。名称表明这是一个双精度类型，与单精度类型（使用 32 位）相对，后者通过
    `float` 类型实现。还有一个扩展精度类型，称为 `long double`。标准没有指定其实际精度，但要求它至少与 `double` 类型相同。在某些编译器中，这可以是四倍精度（使用
    128 位），尽管一些编译器，如 VC++，将其视为等于 `double`：
- en: '[PRE3]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works…
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The C++ language has one basic integral type, `int`, and several modifiers
    that can be applied to it, for signedness and size. The type `int` is a signed
    one, so `int` and `signed int` are the same type. The use of `int` is actually
    optional when using a modifier. Therefore, the following types are equivalent:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 语言有一个基本整型 `int`，以及可以应用于它的几个修饰符，用于表示符号和大小。类型 `int` 是一个有符号类型，因此 `int` 和 `signed
    int` 是同一类型。使用 `int` 实际上是可选的，当使用修饰符时。因此，以下类型是等效的：
- en: '| **Type** | **Equivalent to** |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **等效类型** |'
- en: '| `signed` | `int` |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `signed` | `int` |'
- en: '| `unsigned` | `unsigned int` |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `unsigned` | `unsigned int` |'
- en: '| `short` | `short int` |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `short` | `short int` |'
- en: '| `signed short` | `short int` |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `signed short` | `short int` |'
- en: '| `signed short int` | `short int` |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `signed short int` | `short int` |'
- en: '| `long` | `long int` |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `long` | `long int` |'
- en: '| `long long` | `long long int` |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `long long` | `long long int` |'
- en: '| `unsigned short` | `unsigned short int` |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `unsigned short` | `unsigned short int` |'
- en: '| `unsigned long` | `unsigned long int` |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `unsigned long` | `unsigned long int` |'
- en: '| `unsigned long long` | `unsigned long long int` |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `unsigned long long` | `unsigned long long int` |'
- en: 'Table 2.1: Integral type equivalence'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.1：整型等效
- en: 'This table does not list all the possible combinations, only several examples.
    The order of the type modifiers is not specified; therefore, any order is permitted.
    The following table lists several types that represent the same type:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此表未列出所有可能的组合，仅列出几个示例。类型修饰符的顺序未指定；因此，任何顺序都是允许的。以下表列出了表示相同类型的几个类型：
- en: '| **Type** | **Equivalent type** |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **等效类型** |'
- en: '| `long long unsigned int` | `unsigned long long int` |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `long long unsigned int` | `unsigned long long int` |'
- en: '| `long unsigned long int` |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `long unsigned long int` |'
- en: '| `int long long unsigned` |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `int long long unsigned` |'
- en: '| `unsigned long long int` |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `unsigned long long int` |'
- en: '| `int long unsigned long` |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `int long unsigned long` |'
- en: 'Table 2.2: Integral type equivalence with modifiers'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.2：带有修饰符的整型等效
- en: Even though the order is undefined, it is a common practice to start with the
    signedness modifier, then the size modifier, and finally the `int` type. Therefore,
    the canonical form for the types on the left column in the previous table is `unsigned
    long long int`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管顺序未定义，但通常的做法是先使用符号修饰符，然后是大小修饰符，最后是 `int` 类型。因此，前表中左侧列的类型规范形式是 `unsigned long
    long int`。
- en: Regardless of the signedness or size of an integral type, a process called *overflow*
    or *underflow* can occur. Overflow occurs when an attempt to store a value greater
    than the maximum value of the data type happens. Underflow occurs in the opposite
    case, when an attempt to store a value smaller than the minimum value of the data
    type happens.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 无论整型的符号或大小如何，都可能发生称为 *溢出* 或 *下溢* 的过程。溢出发生在尝试存储一个大于该数据类型最大值的值时。下溢发生在相反的情况下，即尝试存储一个小于该数据类型最小值的值时。
- en: 'Let’s consider the case of the `short` type. This is a signed integer type
    that can store values in the range of -32,768 to 32,767\. What happens if we want
    to store 32,768? Since this is greater than the maximum, an overflow occurs. The
    decimal 32,767 is 01111111 11111111 in binary and the next value is 10000000 00000000,
    which, on a 16-bit representation, is -32,768 in decimal. The following table
    shows overflows and underflows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑 `short` 类型的例子。这是一个可以存储 -32,768 到 32,767 范围内值的有符号整型。如果我们想存储 32,768 会发生什么？由于这个值大于最大值，会发生溢出。十进制的
    32,767 在二进制中表示为 01111111 11111111，下一个值是 10000000 00000000，在 16 位表示中是十进制的 -32,768。以下表显示了溢出和下溢的情况：
- en: '| **Value to store** | **Stored value** |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| **存储的值** | **存储的值** |'
- en: '| -32771 | 32765 |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| -32771 | 32765 |'
- en: '| -32770 | 32766 |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| -32770 | 32766 |'
- en: '| -32769 | 32767 |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| -32769 | 32767 |'
- en: '| -32768 | -32768 |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| -32768 | -32768 |'
- en: '| … | … |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| … | … |'
- en: '| 32767 | 32767 |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 32767 | 32767 |'
- en: '| 32768 | -32768 |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 32768 | -32768 |'
- en: '| 32769 | -32767 |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 32769 | -32767 |'
- en: '| 32770 | -32765 |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 32770 | -32765 |'
- en: 'Table 2.3: Examples of short int values with overflow and underflow'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.3：短整型值溢出和下溢的示例
- en: 'The same examples are shown in a different form in the following image, which
    you might find simpler to understand:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图像中以不同的形式展示了相同的示例，您可能会觉得更容易理解：
- en: '![](img/B21549_02_01.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21549_02_01.png)'
- en: 'Figure 2.1: Example of short int values with overflow and underflow'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1：短整型值溢出和下溢的示例
- en: 'If, instead of `short`, we consider the `unsigned short` type, the same problems
    occur, although they might be easier to understand. The range for `unsigned short`
    is 0 to 65,535\. Attempting to store 65,536 will result in the value 0 being stored.
    Similarly, attempting to store 65,537 will result in the value 1 being stored
    instead. This is the result of the modulo operation between the value to be stored
    and the number of values that can be stored by the data type. In the case of `unsigned
    short`, this is 2^16 or 62,536\. For underflow, the result happens in a similar
    way. The value -1 becomes 65,535, -2 becomes 65,534, and so forth. This is the
    same as adding the negative value to 65,536 and then performing the modulo 65,536
    operation. The overflows and underflows are shown in the following table:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们考虑的是 `unsigned short` 类型而不是 `short`，同样的问题会发生，尽管它们可能更容易理解。`unsigned short`
    的范围是0到65,535。尝试存储65,536将导致存储的值为0。同样，尝试存储65,537将导致存储的值为1。这是存储值与数据类型可以存储的值的数量之间的模运算的结果。对于
    `unsigned short`，这是 2^16 或 62,536。对于下溢，结果以类似的方式发生。-1变为65,535，-2变为65,534，依此类推。这与将负值加到65,536然后执行模65,536运算相同。溢出和下溢在以下表中显示：
- en: '| **Value to store** | **Stored value** |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| **要存储的值** | **存储的值** |'
- en: '| -2 | 65534 |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| -2 | 65534 |'
- en: '| -1 | 65535 |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| -1 | 65535 |'
- en: '| 0 | 0 |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 |'
- en: '| … | … |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| … | … |'
- en: '| 65535 | 65535 |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 65535 | 65535 |'
- en: '| 65536 | 0 |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 65536 | 0 |'
- en: '| 65537 | 1 |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 65537 | 1 |'
- en: 'Table 2.4: Examples of unsigned short int with overflow and underflow'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.4：无符号短整型溢出和下溢的示例
- en: 'Similarly, the same values are exemplified in the next image:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，下一个图像展示了相同的价值：
- en: '![](img/B21549_02_02.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21549_02_02.png)'
- en: 'Figure 2.2: Examples of unsigned short int with overflow and underflow'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2：无符号短整型溢出和下溢的示例
- en: 'A significant problem with integral types in C++ is the lack of specification
    for their size. The only well-defined size is for the `char` type (and its `signed`
    and `unsigned` modifiers), which must be 1\. For the rest, the following relation
    applies:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: C++中整型类型的一个重大问题是它们的大小没有明确规定。唯一明确定义的大小是 `char` 类型（及其 `signed` 和 `unsigned` 修饰符），它必须是1。对于其余部分，以下关系适用：
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In practice, on most platforms, `short` is 16-bit, `int` and `long` are both
    32-bit, and `long long` is 64-bit. However, there are platforms where `long` and
    `long long` are both 64-bit or where `int` is 16-bit. To overcome this heterogeneity,
    the C++11 standard introduced a series of fixed-width integer types. These are
    defined in the `<cstdint>` header and are grouped into two categories:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在大多数平台上，`short` 是16位的，`int` 和 `long` 都是32位的，而 `long long` 是64位的。然而，有些平台
    `long` 和 `long long` 都是64位的，或者 `int` 是16位的。为了克服这种异质性，C++11标准引入了一系列固定宽度的整型类型。这些类型在
    `<cstdint>` 头文件中定义，并分为两类：
- en: 'A category of types that are optional and might not be available on some platforms.
    These types have an exact number of bits, as specified by their name:'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一类可选的类型，可能在某些平台上不可用。这些类型具有它们名称指定的确切位数：
- en: '`int8_t` and `uint8_t` are 8-bit'
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int8_t` 和 `uint8_t` 是8位的'
- en: '`int16_t` and `uint16_t` are 16-bit'
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int16_t` 和 `uint16_t` 是16位的'
- en: '`int32_t` and `uint32_t` are 32-bit'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int32_t` 和 `uint32_t` 是32位的'
- en: '`int64_t` and `uint64_t` are 64-bit'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int64_t` 和 `uint64_t` 是64位的'
- en: There are also `intptr_t` and `uintptr_t` that have a size large enough to store
    a pointer to void
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，还有 `intptr_t` 和 `uintptr_t`，它们的大小足以存储指向void的指针
- en: 'A category of types that are mandatory and, therefore, available on all platforms.
    These, in turn, are grouped into two categories:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一类强制类型，因此可在所有平台上使用。这些类型又分为两类：
- en: One that is optimized for fast access; these are called `int_fastX_t` and `uint_fastX_t`,
    where `X` is 8, 16, 32, or 64, representing the number of bits. These types provide
    the integral type that is fastest to access on a particular architecture that
    also has a width at least the size `X`.
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种针对快速访问进行优化的类型；这些被称为 `int_fastX_t` 和 `uint_fastX_t`，其中 `X` 是8、16、32或64，表示位数。这些类型提供了在特定架构上访问速度最快且宽度至少为
    `X` 的整型类型。
- en: One that is optimized for memory consumption; these are called `int_leastX_t`
    and `uint_leastX_t`, where `X` is 8, 16, 32, or 64, representing the number of
    bits. These types provide the integral type that is the smallest to represent
    on a particular architecture but that also has a width of at least the size `X`.
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种优化内存消耗的；这些被称为 `int_leastX_t` 和 `uint_leastX_t`，其中 `X` 是 8、16、32 或 64，表示位数。这些类型提供了在特定架构上表示的最小整数类型，但宽度至少为
    `X`。
- en: 'In practice, most compilers treat the 8-bit types (`int8_t`, `uint8_t`, `int_least8_t`,
    `uint_least8_t`, `int_fast8_t`, and `uint_fast8_t`) as identical to `signed char`
    and `unsigned char`. This means that on different systems, a program using them
    may behave differently from a program using the other fixed-width integer types.
    Here is an example to demonstrate this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，大多数编译器将 8 位类型（`int8_t`、`uint8_t`、`int_least8_t`、`uint_least8_t`、`int_fast8_t`
    和 `uint_fast8_t`）视为与 `signed char` 和 `unsigned char` 相同。这意味着在不同的系统上，使用它们的程序可能与其他固定宽度整数类型的程序表现不同。以下是一个示例，以演示这一点：
- en: '[PRE5]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Both `x` and `y` are of fixed-width integer types and both are assigned the
    value 42\. However, when printing their value to the console, `x` will be printed
    as `*` instead of 42\. Keep in mind, though, that this is not a guarantee as the
    behavior is system-dependent.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`x` 和 `y` 都是固定宽度整数类型，并且都被分配了值 42。然而，当将它们的值打印到控制台时，`x` 将被打印为 `*` 而不是 42。但请注意，这并不是一个保证，因为行为是系统相关的。'
- en: Therefore, you might want to avoid using the 8-bit fixed-width integer types
    and prefer `int16_t`/`uint16_t` or one of the fast/least variants.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可能想要避免使用 8 位固定宽度整数类型，并优先考虑 `int16_t`/`uint16_t` 或快速/最小变体之一。
- en: 'When writing numerical literals, you can use the single quotation mark (`''`)
    as a digit separator. This makes it easier to read large numbers, and perhaps
    compare them visually. It can be used for decimal, hexadecimal, octal, and binary
    numbers, as shown in the following snippet:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写数值字面量时，您可以使用单引号（`'`）作为数字分隔符。这使得阅读大数字变得更容易，也许可以直观地比较它们。它可以用于十进制、十六进制、八进制和二进制数字，如下面的代码片段所示：
- en: '[PRE6]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The digit separators are ignored when determining the numerical value, so their
    position is irrelevant. This means you can write numbers in formats that have
    no practical meaning without producing an error:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定数值时，数字分隔符被忽略，因此它们的位置无关紧要。这意味着您可以在没有产生错误的情况下以没有实际意义的格式编写数字：
- en: '[PRE7]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: See also
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Understanding the various character and string types*, to learn about the
    different character and string types'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*理解各种字符和字符串类型*，了解不同的字符和字符串类型'
- en: Limits and other properties of numeric types
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数值类型的限制和其他属性
- en: Sometimes, it is necessary to know and use the minimum and maximum values that
    can be represented with a numeric type, such as `char`, `int`, or `double`. Many
    developers use standard C macros for this, such as `CHAR_MIN`/`CHAR_MAX`, `INT_MIN`/`INT_MAX`,
    and `DBL_MIN`/`DBL_MAX`. C++ provides a class template called `numeric_limits`
    with specializations for every numeric type, which enables you to query the minimum
    and maximum value of a type. However, `numeric_limits` is not limited to that
    functionality and offers additional constants for type property querying, such
    as whether a type is signed or not, how many bits it needs for representing its
    values, whether it can represent infinity for floating-point types, and many others.
    Prior to C++11, the use of `numeric_limits<T>` was limited because it could not
    be used in places where constants were needed (examples include the size of arrays
    and switch cases). Due to that, developers preferred to use C macros throughout
    their code. In C++11, that is no longer the case, as all the static members of
    `numeric_limits<T>` are now `constexpr`, which means they can be used everywhere
    a constant expression is expected.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，有必要知道并使用数值类型（如 `char`、`int` 或 `double`）可以表示的最小和最大值。许多开发者使用标准 C 宏来完成此操作，例如
    `CHAR_MIN`/`CHAR_MAX`、`INT_MIN`/`INT_MAX` 和 `DBL_MIN`/`DBL_MAX`。C++ 提供了一个名为 `numeric_limits`
    的类模板，它为每个数值类型提供了特化，这使得您可以查询类型的最大和最小值。然而，`numeric_limits` 不仅限于该功能，还提供了用于类型属性查询的附加常量，例如类型是否为有符号，它需要多少位来表示其值，是否可以表示浮点类型的无穷大，以及其他许多内容。在
    C++11 之前，`numeric_limits<T>` 的使用受到限制，因为它不能用于需要常量的地方（例如数组的大小和 switch 语句）。因此，开发者更喜欢在其代码中使用
    C 宏。在 C++11 中，这种情况不再存在，因为 `numeric_limits<T>` 的所有静态成员现在都是 `constexpr`，这意味着它们可以在需要常量表达式的任何地方使用。
- en: Getting ready
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `numeric_limits<T>` class template is available in the namespace `std` in
    the `<limits>` header.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`numeric_limits<T>`类模板在`<limits>`头文件中的`std`命名空间中可用。'
- en: How to do it...
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Use `std::numeric_limits<T>` to query various properties of a numeric type
    `T`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`std::numeric_limits<T>`查询数值类型`T`的各种属性：
- en: 'Use the `min()` and `max()` static methods to get the smallest and largest
    finite numbers of a type. The following are examples of how these could be used:'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`min()`和`max()`静态方法获取一个类型的最小和最大有限数值。以下是如何使用这些方法的示例：
- en: '[PRE8]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Use other static methods and static constants to retrieve other properties
    of a numeric type. In the following example, the `bits` variable is an `std::bitset`
    object that contains a sequence of bits that are necessary to represent the numerical
    value represented by the variable `n` (which is an integer):'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用其他静态方法和静态常量来检索数值类型的其他属性。在以下示例中，`bits`变量是一个`std::bitset`对象，它包含表示变量`n`（它是一个整数）所表示数值所需的位序列：
- en: '[PRE9]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In C++11, there is no limitation to where `std::numeric_limits<T>` can be used;
    therefore, preferably, use it over C macros in your modern C++ code.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++11中，`std::numeric_limits<T>`的使用没有限制；因此，在您的现代C++代码中，最好使用它而不是C宏。
- en: How it works...
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `std::numeric_limits<T>` class template enables developers to query properties
    of numeric types. Actual values are available through specializations, and the
    standard library provides specializations for all the built-in numeric types (`char`,
    `short`, `int`, `long`, `float`, `double`, and so on). In addition, third parties
    may provide additional implementations for other types. An example could be a
    numeric library that implements a `bigint` type and a `decimal` type and provides
    specializations of `numeric_limits` for these types (such as `numeric_limits<bigint>`
    and `numeric_limits<decimal>`).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::numeric_limits<T>`类模板允许开发者查询数值类型的属性。实际值通过特化提供，标准库为所有内置数值类型（`char`、`short`、`int`、`long`、`float`、`double`等）提供了特化。此外，第三方可能为其他类型提供额外的实现。一个例子是一个实现`bigint`类型和`decimal`类型并为此类提供`numeric_limits`特化的数值库（例如`numeric_limits<bigint>`和`numeric_limits<decimal>`）。'
- en: 'The following specializations of numeric types are available in the `<limits>`
    header. Note that specializations for `char16_t` and `char32_t` are new in C++11;
    the others were available previously. Apart from the specializations listed ahead,
    the library also includes specializations for every `cv-qualified` version of
    these numeric types, and they are identical to the unqualified specialization.
    For example, consider the type `int`; there are four actual specializations (and
    they are identical): `numeric_limits<int>`, `numeric_limits<const int>`, `numeric_limits<volatile
    int>`, and `numeric_limits<const volatile int>`. You can find the entire list
    of specializations at [https://en.cppreference.com/w/cpp/types/numeric_limits](https://en.cppreference.com/w/cpp/types/numeric_limits).'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`<limits>`头文件中提供了以下数值类型的特化。请注意，`char16_t`和`char32_t`的特化是C++11中新增的；其他特化之前就已经可用。除了前面列出的特化之外，库还包括这些数值类型每个`cv-qualified`版本的特化，并且它们与无修饰特化相同。例如，考虑类型`int`；有四个实际特化（它们是相同的）：`numeric_limits<int>`、`numeric_limits<const
    int>`、`numeric_limits<volatile int>`和`numeric_limits<const volatile int>`。您可以在[https://en.cppreference.com/w/cpp/types/numeric_limits](https://en.cppreference.com/w/cpp/types/numeric_limits)找到特化的完整列表。'
- en: 'As mentioned earlier, in C++11, all static members of `std::numeric_limits`
    are `constexpr`, which means they can be used in all the places where constant
    expressions are needed. These have several major advantages over C++ macros:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在C++11中，`std::numeric_limits`的所有静态成员都是`constexpr`，这意味着它们可以在需要常量表达式的所有地方使用。这相对于C宏有几个主要优点：
- en: They are easier to remember, as the only thing you need to know is the name
    of the type, which you should know anyway, and not countless names of macros.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们更容易记住，因为你只需要知道类型的名称，而这通常是你应该知道的，而不是无数宏的名称。
- en: They support types that are not available in C, such as `char16_t` and `char32_t`.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们支持C语言中不可用的类型，例如`char16_t`和`char32_t`。
- en: They are the only possible solutions for templates where you don’t know the
    type.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是唯一可能的解决方案，用于不知道类型的模板。
- en: '`min` and `max` are only two of the various properties of types it provides;
    therefore, its actual use is beyond the numeric limits shown. As a side note,
    for this reason, the class should have been perhaps called *numeric_properties*,
    instead of `numeric_limits`.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`min` 和 `max` 只是它提供的各种类型属性中的两种；因此，其实际用途超出了显示的数值限制。作为旁注，因此，这个类可能应该被命名为 *numeric_properties*，而不是
    `numeric_limits`。'
- en: 'The following function template, `print_type_properties()`, prints the minimum
    and maximum finite values of the type, as well as other information:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数模板 `print_type_properties()` 打印出类型的最小和最大有限值，以及其他信息：
- en: '[PRE10]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If we call the `print_type_properties()` function for `unsigned` `short`, `int`,
    and `double`, we will get the following output:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为 `unsigned` `short`、`int` 和 `double` 调用 `print_type_properties()` 函数，我们将得到以下输出：
- en: '| **unsigned short** | **int** | **double** |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| **unsigned short** | **int** | **double** |'
- en: '|'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE11]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '|'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE12]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '|'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE13]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '|'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Table 2.5: The output of print_type_properties() for unsigned short, int, and
    double'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.5：`print_type_properties()` 对于 `unsigned short`、`int` 和 `double` 的输出
- en: 'Please note that there is a difference between the `digits` and `digits10`
    constants:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`digits` 和 `digits10` 常量之间存在差异：
- en: '`digits` represents the number of bits (excluding the sign bit if present)
    and padding bits (if any) for integral types and the number of bits of the mantissa
    for floating-point types.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`digits` 代表整数类型（如果存在符号位则不包括）和填充位（如果有）的位数，以及浮点类型尾数的位数。'
- en: '`digits10` is the number of decimal digits that can be represented by a type
    without a change. To understand this better, let’s consider the case of `unsigned
    short`. This is a 16-bit integral type. It can represent numbers between 0 and
    65,536\. It can represent numbers up to five decimal digits, 10,000 to 65,536,
    but it cannot represent all five decimal digit numbers, as numbers from 65,537
    to 99,999 require more bits. Therefore, the largest numbers that it can represent
    without requiring more bits have four decimal digits (numbers from 1,000 to 9,999).
    This is the value indicated by `digits10`. For integral types, it has a direct
    relationship to constant `digits`; for an integral type, `T`, the value of `digits10`
    is `std::numeric_limits<T>::digits * std::log10(2)`.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`digits10` 是一个类型可以表示而不改变的小数位数。为了更好地理解这一点，让我们考虑 `unsigned short` 的例子。这是一个16位的整数类型。它可以表示从0到65,536的数字。它可以表示最多五位小数的数字，即从10,000到65,536，但它不能表示所有五位小数的数字，因为从65,537到99,999的数字需要更多的位。因此，它在不需要更多位的情况下可以表示的最大数字有四位小数（从1,000到9,999）。这就是
    `digits10` 所指示的值。对于整数类型，它与常量 `digits` 有直接关系；对于一个整数类型 `T`，`digits10` 的值是 `std::numeric_limits<T>::digits
    * std::log10(2)`。'
- en: It’s worth mentioning that the standard library types that are aliases of arithmetic
    types (such as `std::size_t`) may also be inspected with `std::numeric_limits`.
    On the other hand, other standard types that are not arithmetic types, such as
    `std::complex<T>` or `std::nullptr_t`, do not have `std::numeric_limits` specializations.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，标准库中那些是算术类型别名的类型（例如 `std::size_t`）也可以使用 `std::numeric_limits` 进行检查。另一方面，其他不是算术类型的标准类型，例如
    `std::complex<T>` 或 `std::nullptr_t`，并没有 `std::numeric_limits` 特化。
- en: See also
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: '*Converting between numeric and string types*, to learn how to convert between
    numbers and strings'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在数字和字符串类型之间转换*，了解如何将数字和字符串之间进行转换'
- en: Converting between numeric and string types
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在数字和字符串类型之间转换
- en: Converting between number and string types is a ubiquitous operation. Prior
    to C++11, there was little support for converting numbers to strings and back,
    so developers had to resort mostly to type-unsafe functions, and they usually
    wrote their own utility functions in order to avoid writing the same code over
    and over again. With C++11, the standard library provides utility functions for
    converting between numbers and strings. In this recipe, you will learn how to
    convert between numbers and strings and the other way around using modern C++
    standard functions.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 数字和字符串类型之间的转换是一种普遍的操作。在C++11之前，对将数字转换为字符串以及反向转换的支持很少，因此开发者主要不得不求助于不安全的类型函数，并且他们通常编写自己的实用函数以避免重复编写相同的代码。随着C++11的推出，标准库提供了在数字和字符串之间进行转换的实用函数。在本配方中，你将学习如何使用现代C++标准函数在数字和字符串之间以及相反方向进行转换。
- en: Getting ready
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: All the utility functions mentioned in this recipe are available in the `<string>`
    header.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方中提到的所有实用函数都包含在 `<string>` 头文件中。
- en: How to do it...
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Use the following standard conversion functions when you need to convert between
    numbers and strings:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要在不同数字和字符串之间进行转换时，请使用以下标准转换函数：
- en: 'To convert from an integer or floating-point type to a string type, use `std::to_string()`
    or `std::to_wstring()`, as shown in the following code snippet:'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将整数或浮点类型转换为字符串类型，请使用`std::to_string()`或`std::to_wstring()`，如下面的代码片段所示：
- en: '[PRE14]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To convert from a string type to an integer type, use `std::stoi()`, `std::stol()`,
    `std::stoll()`, `std::stoul()`, or `std::stoull()`, as shown in the following
    code snippet:'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将字符串类型转换为整型类型，请使用`std::stoi()`、`std::stol()`、`std::stoll()`、`std::stoul()`或`std::stoull()`，如下面的代码片段所示：
- en: '[PRE15]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To convert from a string type to a floating-point type, use `std::stof()`,
    `std::stod()`, or `std::stold()`, as shown in the following code snippet:'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将字符串类型转换为浮点类型，请使用`std::stof()`、`std::stod()`或`std::stold()`，如下面的代码片段所示：
- en: '[PRE16]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '[PRE17]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In addition to `int`, these two functions have overloads for `long`, `long long`,
    `unsigned int`, `unsigned long`, `unsigned long long`, `float`, `double`, and
    `long double`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`int`之外，这两个函数还为`long`、`long long`、`unsigned int`、`unsigned long`、`unsigned
    long long`、`float`、`double`和`long double`提供了重载。
- en: 'When it comes to the opposite conversion, there is an entire set of functions
    that have a name with the format **sto***n* (**string to number**), where *n*
    stands for **i** (`integer`), **l** (`long`), **ll** (`long long`), **ul** (`unsigned
    long`), or **ull** (`unsigned long long`). The following list shows the `stoi`
    function with its two overloads—one that takes an `std::string` and one that takes
    an `std::wstring` as the first parameter. In addition, there are similar functions
    called `stol`, `stoll`, `stoul`, `stoull`, `stof`, `stod`, and `stold`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到相反的转换时，有一整套具有**sto***n*（**字符串到数字**）格式的函数名称，其中*n*代表**i**（`integer`）、**l**（`long`）、**ll**（`long
    long`）、**ul**（`unsigned long`）或**ull**（`unsigned long long`）。以下列表显示了`stoi`函数及其两个重载——一个接受`std::string`作为第一个参数，另一个接受`std::wstring`作为第一个参数。此外，还有类似的函数称为`stol`、`stoll`、`stoul`、`stoull`、`stof`、`stod`和`stold`：
- en: '[PRE19]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The way the string to integral type functions work is by discarding all white
    spaces before a non-whitespace character, then taking as many characters as possible
    to form a signed or unsigned number (depending on the case), and then converting
    that to the requested integral type (`stoi()` will return an `integer`, `stoul()`
    will return an `unsigned long`, and so on). In all the following examples, the
    result is the integer `42`, except for the last example, where the result is `-42`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串到整型函数的工作方式是丢弃非空白字符之前的所有空白字符，然后尽可能多地取字符以形成一个有符号或无符号数（根据情况而定），然后将该数转换为请求的整型（`stoi()`将返回`整数`，`stoul()`将返回`unsigned
    long`，等等）。在所有以下示例中，结果都是整数`42`，除了最后一个示例，其结果是`-42`：
- en: '[PRE20]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'A valid integral number may consist of the following parts:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有效的整数值可能由以下部分组成：
- en: A sign, plus (`+`) or minus (`-`) (optional)
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 符号，加号（`+`）或减号（`-`）（可选）
- en: The prefix `0` to indicate an octal base (optional)
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前缀`0`表示八进制基数（可选）
- en: The prefix `0x` or `0X` to indicate a hexadecimal base (optional)
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前缀`0x`或`0X`表示十六进制基数（可选）
- en: A sequence of digits
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一系列数字
- en: The optional prefix `0` (for octal) is applied only when the specified base
    is `8` or `0`. Similarly, the optional prefix `0x` or `0X` (for hexadecimal) is
    applied only when the specified base is `16` or `0`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的前缀`0`（表示八进制）仅在指定的基数为`8`或`0`时应用。同样，可选的前缀`0x`或`0X`（表示十六进制）仅在指定的基数为`16`或`0`时应用。
- en: 'The functions that convert a string to an integer have three parameters:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 将字符串转换为整数的函数有三个参数：
- en: The input string.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入字符串。
- en: A pointer that, when not null, will receive the number of characters that were
    processed. This can include any leading white spaces that were discarded, the
    sign, and the base prefix, so it should not be confused with the number of digits
    the integral value has.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指针，当它不为空时，将接收已处理的字符数。这可能包括被丢弃的所有前导空白字符、符号和基数前缀，因此不应与整数值的位数混淆。
- en: A number indicating the base; by default, this is `10`.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示基数的数字；默认情况下，这是`10`。
- en: The valid digits in the input string depend on the base. For base `2`, the only
    valid digits are `0` and `1`; for base `5`, they are `01234`. For base `11`, the
    valid digits are `0`-`9` and the characters `A` and `a`. This continues until
    we reach base `36`, which has the valid characters `0`-`9`, `A`-`Z`, and `a`-`z`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 输入字符串中的有效数字取决于基。对于基 `2`，唯一的有效数字是 `0` 和 `1`；对于基 `5`，它们是 `01234`。对于基 `11`，有效数字是
    `0`-`9` 和字符 `A` 和 `a`。这继续到基 `36`，它有有效字符 `0`-`9`、`A`-`Z` 和 `a`-`z`。
- en: 'The following are additional examples of strings with numbers in various bases
    converted to decimal integers. Again, in all cases, the result is either `42`
    or `-42`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将具有各种基数数字的字符串转换为十进制整数的额外示例。在所有情况下，结果要么是 `42`，要么是 `-42`：
- en: '[PRE21]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'An important thing to note is that these conversion functions throw an exception
    if the conversion fails. There are two exceptions that can be thrown:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一个重要事项是，如果转换失败，这些转换函数会抛出异常。可以抛出的有两个异常：
- en: '`std::invalid_argument` if the conversion cannot be performed:'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果转换无法执行，将抛出 `std::invalid_argument`：
- en: '[PRE22]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`std::out_of_range` if the converted value is outside the range of the result
    type (or if the underlying function sets `errno` to `ERANGE`):'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果转换的值超出了结果类型的范围（或者如果底层函数将 `errno` 设置为 `ERANGE`），将抛出 `std::out_of_range`：
- en: '[PRE23]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The other set of functions that convert a string to a floating-point type are
    very similar, except that they don’t have a parameter for the numeric base. A
    valid floating-point value can have different representations in the input string:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 另一组将字符串转换为浮点型的函数与它们非常相似，只是它们没有用于数值基的参数。有效的浮点值在输入字符串中可能有不同的表示形式：
- en: Decimal floating-point expression (optional sign, sequence of decimal digits
    with optional point, optional `e` or `E`, followed by exponent with optional sign)
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 十进制浮点表达式（可选的符号，一串十进制数字，可选的点，可选的 `e` 或 `E`，后跟可选符号的指数）
- en: Binary floating-point expression (optional sign, `0x` or `0X` prefix, sequence
    of hexadecimal digits with optional point, optional `p` or `P`, followed by exponent
    with optional sign)
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制浮点表达式（可选的符号，`0x` 或 `0X` 前缀，一串十六进制数字，可选的点，可选的 `p` 或 `P`，后跟可选符号的指数）
- en: Infinity expression (optional sign followed by case-insensitive `INF` or `INFINITY`)
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无穷大表达式（可选的符号后跟不区分大小写的 `INF` 或 `INFINITY`）
- en: A non-number expression (optional sign followed by case-insensitive `NAN` and
    possibly other alphanumeric characters)
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个非数字表达式（可选的符号后跟不区分大小写的 `NAN` 和可能的其他字母数字字符）
- en: Apart from these formats, additional ones supported by the currently installed
    C locale may also be supported.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些格式之外，当前安装的 C 区域设置支持的额外格式也可能被支持。
- en: 'The following are various examples of converting strings to doubles:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将字符串转换为双精度浮点数的各种示例：
- en: '[PRE24]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The floating-point base 2 scientific notation, seen earlier in the form `0xF.6E6666p3`,
    is not the topic of this recipe. However, for a clear understanding, a short description
    is provided, but it is recommended that you look at additional references for
    details (such as [https://en.cppreference.com/w/cpp/language/floating_literal](https://en.cppreference.com/w/cpp/language/floating_literal)).
    A floating-point constant in the base 2 scientific notation is composed of several
    parts:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面以 `0xF.6E6666p3` 的形式看到的浮点基 2 科学记数法不是本食谱的主题。然而，为了清晰理解，这里提供了一个简短的描述，但建议您查阅额外的参考资料以获取详细信息（例如
    [https://en.cppreference.com/w/cpp/language/floating_literal](https://en.cppreference.com/w/cpp/language/floating_literal)）。基
    2 科学记数法中的浮点常数由几个部分组成：
- en: The hexadecimal prefix `0x`.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 十六进制前缀 `0x`。
- en: An integer part; in this example, it was `F`, which in decimal is 15.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个整数部分；在这个例子中，它是 `F`，在十进制中是 15。
- en: 'A fractional part, which, in this example, was `6E6666`, or `011011100110011001100110`
    in binary. To convert that into decimal, we need to add inverse powers of two:
    `1/4 + 1/8 + 1/32 + 1/64 + 1/128 + ...`.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个分数部分，在这个例子中是 `6E6666`，或者以二进制形式表示为 `011011100110011001100110`。要将它转换为十进制，我们需要加上二的反幂：`1/4
    + 1/8 + 1/32 + 1/64 + 1/128 + ...`。
- en: A suffix, representing a power of 2; in this example, `p3` means 2 at the power
    of 3.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个后缀，表示 2 的幂；在这个例子中，`p3` 表示 2 的 3 次幂。
- en: The value of the decimal equivalent is determined by multiplying the significant
    (composed of the integer and fractional parts) and the base at the power of the
    exponent.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 十进制等值的值是通过将有效数字（由整数部分和分数部分组成）与基的指数幂相乘得到的。
- en: For the given hexadecimal base 2 floating-point literal, the significant is
    `15.4312499...` (please note that digits after the seventh one are not shown),
    the base is 2, and the exponent is 3\. Therefore, the result is `15.4212499...
    * 8`, which is `123.44999980926514`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定的十六进制基数 2 浮点字面量，有效数字是 `15.4312499...`（请注意，第七位之后的数字没有显示），基数是 2，指数是 3。因此，结果是
    `15.4212499... * 8`，即 `123.44999980926514`。
- en: See also
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Limits and other properties of numeric types*, to learn about the minimum
    and maximum values, as well as the other properties of numerical types'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数值类型的限制和其他属性*，了解最小值和最大值，以及数值类型的其他属性'
- en: Understanding the various character and string types
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解各种字符和字符串类型
- en: 'In the previous recipe, we looked at the variety of integral and floating-point
    types. Another category of types, character types, is often a source of misunderstanding
    and confusion. As of C++20, there are five character data types in the C++ language:
    `char`, `wchar_t`, `char8_t`, `char16_t`, and `char32_t`. In this recipe, we will
    look at how these types differ and how they are meant to be used.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的菜谱中，我们探讨了各种整型和浮点类型。另一类类型，字符类型，通常是误解和混淆的来源。截至 C++20，C++ 语言中有五种字符数据类型：`char`、`wchar_t`、`char8_t`、`char16_t`
    和 `char32_t`。在本菜谱中，我们将探讨这些类型之间的差异以及它们的使用方式。
- en: How to do it…
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Use the available character types as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式使用可用的字符类型：
- en: 'The `char` type to store ASCII characters, Latin character sets (defined in
    the ISO-8859 standard), or even individual bytes of UTF-8 encoded characters:'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于存储 ASCII 字符、拉丁字符集（在 ISO-8859 标准中定义）或 UTF-8 编码字符的单个字节的 `char` 类型：
- en: '[PRE25]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `wchar_t` type with the Windows API to store and manipulate UTF-16LE encoded
    characters:'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Windows API 存储和操作 UTF-16LE 编码字符的 `wchar_t` 类型：
- en: '[PRE26]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `char8_t` type to store individual bytes of UTF-8 encoded code points:'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于存储 UTF-8 编码码点的单个字节的 `char8_t` 类型：
- en: '[PRE27]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `char16_t` type to store UTF-16 encoded characters:'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于存储 UTF-16 编码字符的 `char16_t` 类型：
- en: '[PRE28]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `char32_t` type to store UTF-32 encoded characters:'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于存储 UTF-32 编码字符的 `char32_t` 类型：
- en: '[PRE29]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How it works…
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The built-in data type for storing characters from the early days of the C++
    language was the `char` type. This is an 8-bit data type that is different from
    both `signed char` and `unsigned char`. It is not a `typedef` of any of these
    two data types. You can test that using the `std::is_same` type trait:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: C++语言早期用于存储字符的内建数据类型是 `char` 类型。这是一个 8 位数据类型，与 `signed char` 和 `unsigned char`
    都不同。它不是这两个数据类型中的任何一个的 `typedef`。您可以使用 `std::is_same` 类型特性来测试这一点：
- en: '[PRE30]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Both of these lines will print 0\. This means you can have function overloads
    for all these three data types, as shown in the following snippet:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这两行都会打印 0。这意味着您可以对这些三种数据类型中的所有这些进行函数重载，如下面的代码片段所示：
- en: '[PRE31]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The standard does not specify whether `char` is a `signed` or `unsigned` type.
    Therefore, its signedness depends on the compiler or target platform. The type
    `char` is a `signed` type on x86 and x64 systems and `unsigned` on ARM.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 标准没有指定 `char` 是有符号类型还是无符号类型。因此，其符号性取决于编译器或目标平台。在 x86 和 x64 系统上，`char` 类型是有符号类型，而在
    ARM 上是无符号类型。
- en: The `char` data type can be used to store the characters from the ASCII character
    set and other 8-bit Latin character sets such as Latin-1, Latin-2, Latin/Cyrillic,
    Latin Nordic, and so on. It can also be used to store individual bytes of multi-byte
    character sets, the most widely used being the UTF-8 encoding of the Unicode set.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`char` 数据类型可以用来存储 ASCII 字符集和其他 8 位拉丁字符集，如 Latin-1、Latin-2、Latin/Cyrillic、Latin
    Nordic 等。它也可以用来存储多字节字符集的单个字节，最常用的是 Unicode 集的 UTF-8 编码。'
- en: 'For dealing with fixed-width multi-byte character sets, the `wchar_t` type
    was introduced in C++98\. This is also a unique data type (not a `typedef` of
    some integral type). Its size is not specified and, therefore, also varies: it
    is 2 bytes on Windows and typically 4 bytes on Unix systems.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理固定宽度的多字节字符集，`wchar_t` 类型在 C++98 中被引入。这也是一个独特的数据类型（不是某些整型类型的 `typedef`）。其大小没有指定，因此也各不相同：在
    Windows 上是 2 字节，在 Unix 系统上通常是 4 字节。
- en: This means that `wchar_t` should not be used when writing portable code. The
    `wchar_t` type is mostly used on Windows where it was adopted for storing 16-bit
    characters of the UTF-16LE encoding of the Unicode character set. This is the
    native character set of the Windows operating system.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在编写可移植代码时不应使用 `wchar_t`。`wchar_t` 类型主要在 Windows 上使用，它被用于存储 Unicode 字符集的
    UTF-16LE 编码的 16 位字符。这是 Windows 操作系统的本地字符集。
- en: In newer versions of the standard, three new character data types have been
    introduced. In C++11, `char32_t` and `char16_t` were added to represent 32-bit
    and 16-bit wide characters. They are intended to represent UTF-32 and UTF-16 encoded
    Unicode characters. Although they are each distinctive types, they are equal in
    size, signedness, and alignment with `uint_least32_t` and `uint_least16_t`, respectively.
    In C++20, the `char8_t` data type was added. This is intended to store UTF-8 code
    units (which are 8-bit). The `char8_t` type is a distinctive 8-bit type and has
    the same size, signedness, and alignment as `unsigned char`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准的较新版本中，引入了三种新的字符数据类型。在 C++11 中，`char32_t` 和 `char16_t` 被添加来表示 32 位和 16 位宽字符。它们旨在表示
    UTF-32 和 UTF-16 编码的 Unicode 字符。尽管它们是各自独特的类型，但它们与 `uint_least32_t` 和 `uint_least16_t`
    分别具有相同的大小、符号和对齐。在 C++20 中，添加了 `char8_t` 数据类型。这是旨在存储 UTF-8 代码单元（它们是 8 位的）。`char8_t`
    类型是一个独特的 8 位类型，它具有与 `unsigned char` 相同的大小、符号和对齐。
- en: 'We can summarize all this information in the following table:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将所有这些信息总结在以下表格中：
- en: '| **Type** | **C++ Standard** | **Size (bytes)** | **Sign** |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **C++ 标准** | **尺寸（字节）** | **符号** |'
- en: '| `char` | All versions | 1 | unspecified |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| `char` | 所有版本 | 1 | 未指定 |'
- en: '| `wchar_t` | C++98 | Unspecified(typically, 2 or 4) | unspecified |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| `wchar_t` | C++98 | 未指定（通常是 2 或 4） | 未指定 |'
- en: '| `char8_t` | C++20 | 1 | unsigned |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| `char8_t` | C++20 | 1 | 无符号 |'
- en: '| `char16_t` | C++11 | 2 | unsigned |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| `char16_t` | C++11 | 2 | 无符号 |'
- en: '| `char32_t` | C++11 | 4 | unsigned |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| `char32_t` | C++11 | 4 | 无符号 |'
- en: 'Table 2.6: Summary of size and signedness of the C++ character types'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.6：C++ 字符类型的尺寸和符号总结
- en: 'Strings of the `char` and `char8_t` types are called *narrow strings*, and
    strings of the `wchar_t`, `char16_t`, and `char32_t` types are called *wide strings*.
    The C++ standard provides a container for storing and manipulating sequences of
    characters. This is a class template that has several type aliases defined to
    simplify usage, as shown in the following table:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`char` 和 `char8_t` 类型的字符串被称为 *窄字符串*，而 `wchar_t`、`char16_t` 和 `char32_t` 类型的字符串被称为
    *宽字符串*。C++ 标准提供了一个用于存储和操作字符序列的容器。这是一个类模板，它定义了几个类型别名以简化使用，如下表所示：'
- en: '| **Type** | **Definition** | **C++ Standard** |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **定义** | **C++ 标准** |'
- en: '| `std::string` | `std::basic_string<char>` | C++98 |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| `std::string` | `std::basic_string<char>` | C++98 |'
- en: '| `std::wstring` | `std::basic_string<wchar_t>` | C++98 |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| `std::wstring` | `std::basic_string<wchar_t>` | C++98 |'
- en: '| `std::u8string` | `std::basic_string<char8_t>` | C++20 |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| `std::u8string` | `std::basic_string<char8_t>` | C++20 |'
- en: '| `std::u16string` | `std::basic_string<char16_t>` | C++11 |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| `std::u16string` | `std::basic_string<char16_t>` | C++11 |'
- en: '| `std::u32string` | `std::basic_string<char32_t>` | C++11 |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| `std::u32string` | `std::basic_string<char32_t>` | C++11 |'
- en: 'Table 2.7: The various type aliases for std::basic_string'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.7：std::basic_string 的各种类型别名
- en: Like the other standard containers, `std::basic_string` provides a multitude
    of member functions to construct, access elements, iterate, search, or perform
    various operations with the contained sequence of characters. A particular mention
    needs to be made about how data is stored in a `basic_string`. In C++11, it is
    guaranteed to be contiguous, like in an array.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他标准容器一样，`std::basic_string` 提供了多种成员函数来构建、访问元素、迭代、搜索或对包含的字符序列执行各种操作。特别需要提及的是
    `basic_string` 中数据是如何存储的。在 C++11 中，它保证是连续的，就像数组一样。
- en: 'On the other hand, it may be a bit confusing how it handles string termination.
    Let’s take an example to explain it:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，它如何处理字符串终止可能有点令人困惑。让我们通过一个例子来解释它：
- en: '[PRE32]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The elements stored in the `basic_string` object are the characters `''d` `''`,
    `''e` `''`, `''m` `''`, and `''o` `''`. This is what you get if you iterate over
    the object (e.g., `for (auto c : s)`). The `size()` member will return 4\. However,
    both the `c_str()` and `data()` member functions will return a null terminator.
    That means that it’s guaranteed that `s[s.size()]` is 0.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '存储在 `basic_string` 对象中的元素是字符 `''d''` `''`，`''e''` `''`，`''m''` `''` 和 `''o''`
    `''`。这是如果你遍历对象（例如，`for (auto c : s)`）时得到的结果。`size()` 成员将返回 4。然而，`c_str()` 和 `data()`
    成员函数都将返回一个空终止符。这意味着 `s[s.size()]` 保证是 0。'
- en: 'Characters and strings are often provided as literals in source code. There
    are different prefixes for the different character types, as listed in the following
    table:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串通常以文字形式在源代码中提供。不同的字符类型有不同的前缀，如下表所示：
- en: '| **Literal** | **C++ Standard** | **Character type** | **String type** |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| **文字** | **C++ 标准** | **字符类型** | **字符串类型** |'
- en: '| none | All versions | `char` | `const char*` |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| 无 | 所有版本 | `char` | `const char*` |'
- en: '| `L` | C++98 | `wchar_t` | `const wchar_t*` |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| `L` | C++98 | `wchar_t` | `const wchar_t*` |'
- en: '| `u8` | C++11 | `char` (until C++20)`char8_t` (since C++20) | `const char*`
    (until C++20)`const char8_t*` (since C++20) |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| `u8` | C++11 | `char`（直到 C++20）`char8_t`（自 C++20） | `const char*`（直到 C++20）`const
    char8_t*`（自 C++20）|'
- en: '| `u` | C++11 | `char16_t` | `const char16_t*` |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| `u` | C++11 | `char16_t` | `const char16_t*` |'
- en: '| `U` | C++11 | `char32_t` | `const char32_t*` |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| `U` | C++11 | `char32_t` | `const char32_t*` |'
- en: 'Table 2.8: Prefixes for the different character and string types'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.8：不同字符和字符串类型的前缀
- en: '[PRE33]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the first part, because single quotes are used, character types are deduced
    for variables `c1` to `c5`, depending on the literal prefix (the deduced type
    is mentioned on the right side in the comments). In the second part, because double
    quotes are used, string types are deduced for variables `sa1` to `sa5`, again,
    depending on the literal prefix.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分，由于使用了单引号，变量 `c1` 到 `c5` 的字符类型根据字面量前缀（在注释的右侧提到推断出的类型）。在第二部分，由于使用了双引号，变量
    `sa1` 到 `sa5` 的类型被推断为字符串类型，同样地，这也取决于字面量前缀。
- en: 'The deduced type for `"a"` is not `std::string` but `const char*`. If you want
    to use any of the `basic_string` typedefs, such as `std::string`, you must either
    define the type explicitly (and not use `auto`) or use a standard user-defined
    literal suffix, available in the `std::string_literals` namespace. This is shown
    in the next snippet:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `"a"` 的推断类型不是 `std::string`，而是 `const char*`。如果您想使用任何 `basic_string` 类型别名，例如
    `std::string`，您必须显式定义类型（不要使用 `auto`）或使用在 `std::string_literals` 命名空间中可用的标准用户定义字面量后缀。这将在下一个代码片段中展示：
- en: '[PRE35]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To avoid confusion, the following table explains the meaning of various pointer
    types:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免混淆，以下表格解释了各种指针类型的含义：
- en: '| **Type** | **Meaning** |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **含义** |'
- en: '| `char*` | A mutable pointer to a mutable character. Both the pointer and
    the pointed character can be modified. |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| `char*` | 一个指向可变字符的可变指针。指针和指向的字符都可以被修改。|'
- en: '| `const char*` | A mutable pointer to a constant character. The pointer can
    be modified, but not the content of the location it points to. |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| `const char*` | 一个可变指针指向一个常量字符。指针可以被修改，但指向的位置的内容不能被修改。|'
- en: '| `char * const` | A constant pointer to a mutable character. The pointer cannot
    be modified, but the content of the location it points to can be. |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| `char * const` | 一个指向可变字符的常量指针。指针不能被修改，但指向的位置的内容可以被修改。|'
- en: '| `const char * const` | A constant pointer to a constant character. Neither
    the pointer nor the content of the location it points to can be modified. |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| `const char * const` | 一个指向常量字符的常量指针。指针和指向的位置的内容都不能被修改。|'
- en: '| `char[]` | An array of characters. |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| `char[]` | 字符数组。|'
- en: 'Table 2.9: The meaning of various pointer types'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.9：各种指针类型的含义
- en: 'You must have noticed that, in the previous table, the prefix `u8` had different
    behavior with different standards:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须已经注意到，在前面的表格中，前缀 `u8` 在不同的标准中有不同的行为：
- en: Since C++11, when it was introduced, until C++20, it defined a `char` literal.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自 C++11 引入以来，直到 C++20，它定义了一个 `char` 字面量。
- en: Since C++20, when it was repurposed with the introduction of `char8_t`, it defines
    a `char8_t` literal.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自 C++20 以来，当它通过引入 `char8_t` 被重新定义时，它定义了一个 `char8_t` 字面量。
- en: This C++20 change is a breaking change. It was preferred over the introduction
    of yet another literal prefix that could have the potential of complicating things
    even further.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 C++20 的变化是一个破坏性变化。它被优先考虑，而不是引入另一个可能使事情更加复杂的字面量前缀。
- en: 'A character or string literal may contain code point values instead of actual
    characters. These must be escaped with either `\u` (for 4 hexadecimal digit code
    points) or `\U` (for 8 hexadecimal digit code points). Here is an example:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 字符或字符串字面量可以包含代码点值而不是实际字符。这些必须使用 `\u`（用于 4 个十六进制数字的代码点）或 `\U`（用于 8 个十六进制数字的代码点）进行转义。以下是一个示例：
- en: '[PRE36]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In C++23, it is possible to use Unicode instead of code point values. That
    is done using the `\N{xxx}` escape sequence, where `xxx` is the Unicode assigned
    name. Therefore, the snippet above can also be written as follows in C++23:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++23 中，可以使用 Unicode 而不是代码点值。这是通过使用 `\N{xxx}` 转义序列来完成的，其中 `xxx` 是 Unicode
    分配的名称。因此，上述代码片段在 C++23 中也可以写成以下形式：
- en: '[PRE37]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Also, in C++23, it is possible to use code point values with an arbitrary number
    of hexadecimal digits. In the previous example, the string containing Egyptian
    hieroglyphs contained the codepoint 13000, which has 5 hexadecimal digits. However,
    since the `\U` escape sequence requires 8 hexadecimal digits, we had to include
    three leading zeros `(\U00013000`). This is no longer necessary in C++23, but
    it requires the syntax `\u{n…}` (with lowercase `u`), where `n…` is an arbitrary
    number of hexadecimal digits. Therefore, this string can also be written as follows
    in C++23:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在 C++23 中，可以使用具有任意数量十六进制数字的代码点值。在先前的示例中，包含埃及象形文字的字符串包含代码点 13000，它有 5 个十六进制数字。然而，由于
    `\U` 转义序列需要 8 个十六进制数字，我们不得不包含三个前导零 `(\U00013000)`。在 C++23 中，这不再必要，但需要语法 `\u{n…}`（小写
    `u`），其中 `n…` 是任意数量的十六进制数字。因此，此字符串也可以在 C++23 中按以下方式编写：
- en: '[PRE38]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Printing characters and strings to the console can be done in multiple ways:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 以多种方式将字符和字符串打印到控制台：
- en: Using the `std::cout` and `std::wcout` global objects
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::cout` 和 `std::wcout` 全局对象
- en: Using the `printf` family of functions
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `printf` 函数族
- en: Using the `std::print` family of functions in C++23
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 C++23 中使用 `std::print` 函数族
- en: Using a third-party text processing library, such as the widely-used **fmt**
    library (which was the source for the `std::format` and `std::print` standard
    utilities included in C++20 and C++23)
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用第三方文本处理库，例如广泛使用的 **fmt** 库（它是 C++20 和 C++23 中包含的 `std::format` 和 `std::print`
    标准工具的来源）
- en: The `std::cout` and `std::wcout` global objects can be used to print `char`/`const
    char*`/`std::string` values and, respectively, `wchar_t`/`const wchar_t*`/`std::wstring`
    values to the standard output console. Printing ASCII characters does not pose
    problems but the handling of other character sets and encodings, such as UTF-8,
    is more problematic, as there is no standard support and different platforms require
    different solutions. You can learn more about this topic in the next recipe, *Printing
    Unicode characters to the output console*.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::cout` 和 `std::wcout` 全局对象可用于将 `char`/`const char*`/`std::string` 值和，分别，`wchar_t`/`const
    wchar_t*`/`std::wstring` 值打印到标准输出控制台。打印 ASCII 字符不会引起问题，但处理其他字符集和编码，如 UTF-8，则更为复杂，因为没有标准支持，不同的平台需要不同的解决方案。你可以在下一配方
    *将 Unicode 字符打印到输出控制台* 中了解更多关于这个主题的信息。'
- en: See also
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Understanding the various numeric types*, to learn about the available integral
    and floating-point types'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*理解各种数值类型*，了解可用的整数和浮点类型'
- en: '*Formatting and printing text with std::format and std::print*, to learn about
    how to format and print text using modern utilities'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 std::format 和 std::print 格式化和打印文本*，了解如何使用现代工具格式化和打印文本'
- en: Printing Unicode characters to the output console
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Unicode 字符打印到输出控制台
- en: In the previous recipe, *Understanding the various character and string types*,
    we looked at the various data types for storing characters and strings of characters.
    This multitude of types was necessary because there are a multitude of character
    sets that have been developed over time.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的配方中，*理解各种字符和字符串类型*，我们探讨了用于存储字符和字符串字符的各种数据类型。这种类型的多重性是必要的，因为随着时间的推移，已经开发出了多种字符集。
- en: The most widely used character sets are ASCII and Unicode. Although support
    for the former has been available on all compilers and target platforms since
    the creation of the language, the support for the latter has evolved at a different
    pace and in different forms for Windows and Unix/Linux systems. In this recipe,
    we will look at how to print texts in different encodings to the standard output
    console.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 最广泛使用的字符集是 ASCII 和 Unicode。尽管对前者的支持自语言创建以来一直存在于所有编译器和目标平台上，但后者在 Windows 和 Unix/Linux
    系统上的支持以不同的速度和形式发展。在本配方中，我们将探讨如何以不同的编码将文本打印到标准输出控制台。
- en: How to do it…
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'To write text to the standard output console, you can use the following:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 要将文本写入标准输出控制台，你可以使用以下方法：
- en: 'For writing ASCII characters, use `std::cout`:'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 ASCII 字符的写入，使用 `std::cout`：
- en: '[PRE39]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'For writing UTF-8 encoded Unicode characters on Linux, also use `std::cout`:'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于在 Linux 上写入 UTF-8 编码的 Unicode 字符，也使用 `std::cout`：
- en: '[PRE40]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'For UTF-8 strings stored using the `char8_t` data type, you can still use `std::cout`
    but must reinterpret the underlying type as an array of chars:'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于使用 `char8_t` 数据类型存储的 UTF-8 字符串，你仍然可以使用 `std::cout`，但必须将底层类型重新解释为字符数组：
- en: '[PRE41]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'For writing UTF-8 encoded Unicode characters on a Windows system, use `char8_t`
    characters, and respectively, `std::u8string` strings in C++20\. In prior versions,
    you can use `char` and `std::string`. Make sure to call the Windows API `SetConsoleOutputCP(CP_UTF8)`
    before writing to the standard output:'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Windows系统上写入UTF-8编码的Unicode字符时，使用`char8_t`字符，在C++20中相应地使用`std::u8string`字符串。在早期版本中，您可以使用`char`和`std::string`。在写入标准输出之前，请确保调用Windows
    API `SetConsoleOutputCP(CP_UTF8)`：
- en: '[PRE42]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '![](img/B21549_02_03.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![图片B21549_02_03](img/B21549_02_03.png)'
- en: 'Figure 2.3: Output of the previous snippet'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3：前一个代码片段的输出
- en: 'For writing UTF-16 encoded Unicode characters on a Windows system, use `wchar_t`
    characters and `std::wstring` strings. Make sure to call `_setmode(_fileno(stdout),
    _O_U16TEXT)` before writing to the standard output:'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Windows系统上写入UTF-16编码的Unicode字符时，使用`wchar_t`字符和`std::wstring`字符串。在写入标准输出之前，请确保调用`_setmode(_fileno(stdout),
    _O_U16TEXT)`：
- en: '[PRE43]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '![](img/B21549_02_04.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![图片B21549_02_04](img/B21549_02_04.png)'
- en: 'Figure 2.4: Output of the previous snippet'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4：前一个代码片段的输出
- en: How it works…
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The ASCII encoding has been the most common character encoding format for half
    a century. It contains 128 characters including the lower and uppercase letters
    of the English language, the 10 decimal digits, and symbols. The first 32 characters
    of the set are non-printable and are called *control characters*. The C++ language
    has full support for the ASCII character set. You can use `std::cout` to print
    ASCII characters to the standard output.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: ASCII编码在过去半个世纪中一直是最常见的字符编码格式。它包含128个字符，包括英语的大写和小写字母、10个十进制数字和符号。该集合的前32个字符是不可打印的，被称为*控制字符*。C++语言完全支持ASCII字符集。您可以使用`std::cout`将ASCII字符打印到标准输出。
- en: 'Since the ASCII encoding only includes the letters of the English alphabet,
    various attempts have been made to support other languages and alphabets. One
    approach is the concept of *code pages*. The ASCII encoding requires only 7 bits
    for encoding the 128 characters. Therefore, an additional 128 characters are available
    to encode using an 8-bit data type. That means that the characters in the index
    128–255 can be mapped to other languages or alphabets. Such a mapping is called
    a code page. There are a variety of code pages, such as IBM code pages, DOS code
    pages, Windows code pages, and others. You can read more about this at [https://en.wikipedia.org/wiki/Code_page](https://en.wikipedia.org/wiki/Code_page).
    The following table lists several Windows code pages:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 由于ASCII编码仅包括英语字母表中的字母，因此已经尝试了各种方法来支持其他语言和字母表。一种方法是*代码页*的概念。ASCII编码只需要7位来编码128个字符。因此，可以使用8位数据类型来编码额外的128个字符。这意味着索引128-255中的字符可以映射到其他语言或字母表。这种映射称为代码页。有各种各样的代码页，如IBM代码页、DOS代码页、Windows代码页等。您可以在[https://en.wikipedia.org/wiki/Code_page](https://en.wikipedia.org/wiki/Code_page)上了解更多信息。以下表格列出了几个Windows代码页：
- en: '| **Code page** | **Name** | **Languages supported** |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| **Code page** | **Name** | **Languages supported** |'
- en: '| 1250 | Windows Central Europe | Czech, Polish, Slovak, Hungarian, Slovene,
    Serbo-Croatian, Romanian, Albanian |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| 1250 | Windows Central Europe | Czech, Polish, Slovak, Hungarian, Slovene,
    Serbo-Croatian, Romanian, Albanian |'
- en: '| 1251 | Windows Cyrillic | Russian, Belarusian, Ukrainian, Bulgarian, Macedonian,
    Serbian |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| 1251 | Windows Cyrillic | Russian, Belarusian, Ukrainian, Bulgarian, Macedonian,
    Serbian |'
- en: '| 1252 | Windows Western | Spanish, Portuguese, French, German, Danish, Norwegian,
    Swedish, Finnish, Icelandic, Faroese, etc. |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| 1252 | Windows Western | Spanish, Portuguese, French, German, Danish, Norwegian,
    Swedish, Finnish, Icelandic, Faroese, etc. |'
- en: '| 1253 | Windows Greek | Greek |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| 1253 | Windows Greek | Greek |'
- en: '| 1254 | Windows Turkish | Turkish |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| 1254 | Windows Turkish | Turkish |'
- en: '| 1255 | Windows Hebrew | Hebrew |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| 1255 | Windows Hebrew | Hebrew |'
- en: '| 1256 | Windows Arabic | Arabic, Persian, Urdu, English, French |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| 1256 | Windows Arabic | Arabic, Persian, Urdu, English, French |'
- en: '| 1257 | Windows Baltic | Estonian, Latvian, Lithuanian |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| 1257 | Windows Baltic | Estonian, Latvian, Lithuanian |'
- en: '| 1258 | Windows Vietnamese | Vietnamese |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| 1258 | Windows Vietnamese | Vietnamese |'
- en: 'Table 2.10: A listing of a subset of Windows code pages'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.10：Windows代码页的子集列表
- en: 'To understand how this works, let’s exemplify with a code snippet. The index
    224 or 0xE0 (in hexadecimal) is mapped to different characters in different code
    pages, as shown in the following table:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解它是如何工作的，让我们用一个代码片段来举例。索引224或0xE0（十六进制）在不同的代码页中映射到不同的字符，如下表所示：
- en: '| **1250** | **1251** | **1252** | **1253** | **1254** | **1255** | **1256**
    | **1257** | **1258** |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| **1250** | **1251** | **1252** | **1253** | **1254** | **1255** | **1256**
    | **1257** | **1258** |'
- en: '| ŕ | а | à | ΰ | à | ![](img/1.png) | à | ą | à |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| ŕ | а | à | ΰ | à | ![图片1](img/1.png) | à | ą | à |'
- en: 'Table 2.11: The character corresponding to index 224 in the several Windows
    code pages'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.11：几个Windows代码页中索引为224的字符
- en: In encoding terminology, the numerical value to which a character is mapped
    is called a *code point* (or *codepoint*). In our example, 224 is a code point,
    and *a*, *à*, or *ą* are specific characters mapped to this code point in different
    code pages.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在编码术语中，将字符映射到的数值称为*码点*（或*码点*）。在我们的例子中，224是一个码点，而*a*、*à*或*ą*是不同代码页中映射到这个码点的特定字符。
- en: 'In Windows, you can activate one code page for the console associated with
    the running process by calling the `SetConsoleOutputCP()` API. An example is shown
    in the following snippet, where we print the character mapped to the 224 code
    point for all the code pages from 1250 to 1258 (the ones listed earlier):'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中，你可以通过调用`SetConsoleOutputCP()` API来激活与运行进程关联的控制台的一个代码页。以下是一个示例片段，其中我们打印了从1250到1258（前面列出的那些）所有代码页中映射到224码点的字符：
- en: '[PRE44]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The output from running this program is shown in the next image. You can see
    here that the printed characters are the ones expected according to *Table 2.9*.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此程序的结果显示在下一张图片中。你可以看到，打印的字符是按照*表2.9*中预期的字符。
- en: '![](img/B21549_02_05.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21549_02_05.png)'
- en: 'Figure 2.5: Printing of code point 224 with different code pages'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5：使用不同代码页打印码点224
- en: Although code pages provide a simple approach to switching between different
    scripts, it is not a solution that can support languages or writing systems that
    include hundreds or thousands of characters or pictograms, such as Chinese or
    Egyptian hieroglyphs. For this purpose, another standard was developed, called
    **Unicode**. This encoding standard is meant to represent most of the world’s
    writing scripts, both present and from the past, as well as other symbols, such
    as emojis, which have become extremely popular for texting in recent times. Currently,
    the Unicode standard defines almost 150,000 characters.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然代码页提供了一种简单的方法来在不同的脚本之间切换，但它并不是一个可以支持包含数百或数千个字符或象形文字的语言或书写系统（如中文或埃及象形文字）的解决方案。为此，开发了另一个标准，称为**Unicode**。这个编码标准旨在表示世界上大多数的书写脚本，无论是现在的还是过去的，以及其他符号，如近年来在短信中变得极为流行的表情符号。目前，Unicode标准定义了大约150,000个字符。
- en: Unicode characters can be stored in several encodings, the most popular being
    UTF-8 and UTF-16\. There is also UTF-32 and GB18030; the latter one is not part
    of the Unicode specification but it’s used in China and fully implements Unicode.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode字符可以存储在几种编码中，最流行的是UTF-8和UTF-16。还有UTF-32和GB18030；后者不是Unicode规范的一部分，但在中国使用，并完全实现了Unicode。
- en: 'UTF-8 is a variable-length character encoding standard, compatible with ASCII.
    UTF-8 uses 1, 2, 3, or 4 bytes to encode all the representable code points. The
    more used a code point is, the fewer bytes are used for its encoding. The 128
    code points of the ASCII encoding are represented by a single byte. As a result,
    UTF-8 is fully “backward” compatible with ASCII. All the other Unicode code points
    are encoded using multiple bytes: code points in the range 128–2047 using 2 bytes,
    code points in the range 2048–65535 using 3 bytes, and code points in the range
    65536–1114111 using 4 bytes. The first byte in the encoding is called a *lead
    byte* and provides information about how many bytes are used to encode the code
    point. Because of this, UTF-8 is a very efficient encoding system and is the preferred
    choice for the World Wide Web, where virtually almost all web pages use this encoding.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: UTF-8是一种可变长度的字符编码标准，与ASCII兼容。UTF-8使用1、2、3或4个字节来编码所有可表示的码点。一个码点使用得越多，其编码使用的字节就越少。ASCII编码的128个码点由一个字节表示。因此，UTF-8完全与ASCII向后兼容。所有其他的Unicode码点都使用多个字节进行编码：范围在128-2047的码点使用2个字节，范围在2048-65535的码点使用3个字节，范围在65536-1114111的码点使用4个字节。编码中的第一个字节称为*引导字节*，它提供了关于用于编码码点的字节数的信息。正因为如此，UTF-8是一个非常高效的编码系统，并且是万维网的首选选择，几乎所有的网页都使用这种编码。
- en: UTF-16 is also a variable-length character encoding that can encode all the
    Unicode code points. For this, it uses either one or two 16-bit code units, which
    makes it incompatible with ASCII. UTF-16 is the encoding used by the Windows operating
    system, as well as by the Java and JavaScript programming languages.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: UTF-16也是一种可变长度的字符编码，可以编码所有的Unicode码点。为此，它使用一个或两个16位码单元，这使得它与ASCII不兼容。UTF-16是Windows操作系统以及Java和JavaScript编程语言使用的编码。
- en: UTF-32 is a less common encoding system. It’s a fixed-length encoding that uses
    32 bits for each code point. Since all the Unicode code points require at most
    21 bits, the leading 11 bits are always 0\. This makes it space-inefficient, which
    is its main disadvantage. Its primary advantage is that it takes constant time
    to find the Nth code point in a sequence, as opposed to a linear time for variable-length
    encodings such as UTF-8 and UTF-16.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: UTF-32是一种不太常见的编码系统。它是一种固定长度的编码，每个代码点使用32位。由于所有Unicode代码点最多需要21位，所以前11位总是0。这使得它空间效率低下，这是其主要缺点。其主要优点是，在序列中查找第N个代码点所需的时间是常数，而UTF-8和UTF-16这样的可变长度编码则需要线性时间。
- en: Compilers typically assume UTF-8 encoding for source files. This is the case
    for GCC, Clang, and MSVC.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器通常假定源文件使用UTF-8编码。GCC、Clang和MSVC都是如此。
- en: 'Linux distributions have native support for UTF-8\. This means that writing
    string literals to the output console such as `"Στέφανος Τσιτσιπάς"` will produce
    the expected result since the terminal supports UTF-8:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: Linux发行版对UTF-8有原生支持。这意味着将字符串字面量写入输出控制台，如`"Στέφανος Τσιτσιπάς"`，将产生预期的结果，因为终端支持UTF-8：
- en: '[PRE45]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'On the other hand, writing wide strings such as `L"Στέφανος Τσιτσιπάς"` does
    not work out of the box. To get the expected result, you need to set up a locale
    object. The default C locale does not know how to convert from wide characters
    to UTF-8\. For this to happen, you need to use a locale that is able to do that.
    You have two options:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，直接写入宽字符串，如`L"Στέφανος Τσιτσιπάς"`，不会按预期工作。要得到预期的结果，您需要设置一个区域对象。默认的C区域不知道如何将宽字符转换为UTF-8。为了实现这一点，您需要使用能够做到这一点的区域。您有两个选择：
- en: 'Initialize a locale object to match the environment’s configuration, which
    should typically be a locale that supports UTF-8:'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化一个与环境配置匹配的区域对象，通常应该是一个支持UTF-8的区域：
- en: '[PRE46]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Initialize a locale object with a specific locale, such as English (United
    States):'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用特定的区域初始化一个区域对象，例如英语（美国）：
- en: '[PRE47]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Locales are discussed in detail in *Chapter 7*, *Using localized settings for
    streams*.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 区域在*第7章*中详细讨论，*使用区域化设置进行流操作*。
- en: 'On a Windows system, things are different. The Windows Command Prompt (`cmd.exe`)
    does not have support for UTF-8\. Although Windows 10 added support for a beta
    feature called “*Use Unicode UTF-8 for worldwide language support*,” this is deeply
    hidden in the *Regional Settings* and is currently reported to prevent some applications
    from working correctly. To write UTF-8 content to the Command Prompt, you must
    first set the correct code page by calling `SetConsoleOutputCP()` and passing
    `CP_UTF8` as an argument (or 65001, its numerical value):'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows系统上，情况不同。Windows命令提示符(`cmd.exe`)不支持UTF-8。尽管Windows 10添加了对名为“*使用Unicode
    UTF-8进行全球语言支持*”的beta功能的支持，但这在*区域设置*中隐藏得很深，并且目前报告说这可能会阻止某些应用程序正确运行。要将UTF-8内容写入命令提示符，您必须首先通过调用`SetConsoleOutputCP()`并将`CP_UTF8`作为参数（或其数值65001）传递来设置正确的代码页：
- en: '[PRE48]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: To write UTF-16, you need to call `_setmode()` (from `<io.h>`) to set the translation
    mode for a file (in this case, the standard output console) to UTF-16\. For this,
    you have to pass the `_O_U16TEXT` argument. The function returns the previous
    translation mode that you can use to restore the translation mode after writing
    the desired content.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 要写入UTF-16，您需要调用`_setmode()`（来自`<io.h>`）来设置文件的翻译模式（在这种情况下，是标准输出控制台）为UTF-16。为此，您必须传递`_O_U16TEXT`参数。该函数返回之前的翻译模式，您可以在写入所需内容后使用它来恢复翻译模式。
- en: 'Passing `_O_TEXT` sets the text mode (in which CR-LF combinations are translated
    into a single LF on input, and LF characters are translated into CR-LF on output):'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 传递`_O_TEXT`设置文本模式（在此模式下，输入时的CR-LF组合被转换为单个LF，而输出时的LF字符被转换为CR-LF）：
- en: '[PRE49]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: For this to work, however, it is also important that the Command Prompt application
    uses a True Type font, such as Lucinda Console or Consolas, and not a Raster font
    that only supports ASCII.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了使这可行，也很重要的是命令提示符应用程序使用的是True Type字体，例如Lucinda Console或Consolas，而不是仅支持ASCII的Raster字体。
- en: 'Starting with Windows 10, a new terminal application is available for Windows.
    This is called **Windows Terminal,** and it has built-in support for UTF-8\. This
    means that the following code prints the expected result without having to call
    `SetConsoleOutputCP()` first:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 从Windows 10开始，Windows提供了一种新的终端应用程序。这被称为**Windows Terminal**，它内置了对UTF-8的支持。这意味着以下代码无需先调用`SetConsoleOutputCP()`即可打印出预期的结果：
- en: '[PRE50]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Unlike other programming languages, support for Unicode has not been a strong
    point of C++. This recipe provides the basics for working with Unicode in console
    applications. However, in practice, matters can get more complex and require additional
    support. To further your understanding of this topic, it is recommended that you
    consult additional sources, with many being available online.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他编程语言不同，C++对Unicode的支持并不是一个强项。本食谱提供了在控制台应用程序中处理Unicode的基础。然而，在实践中，事情可能会变得更加复杂，需要额外的支持。为了进一步了解这个主题，建议您查阅额外的资料，其中许多资料可在网上找到。
- en: See also
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Understanding the various character and string types* to learn about the available
    character and string types in C++'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*理解各种字符和字符串类型*，了解C++中可用的字符和字符串类型'
- en: '*Formatting and printing text with std::format and std::print* to learn about
    how to format and print text using modern utilities'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用std::format和std::print格式化和打印文本*，了解如何使用现代工具格式化和打印文本'
- en: '*Chapter 7*, *Using localized settings for streams*, to learn about locales
    and how to control the behavior of input/output streams'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第7章*，*使用本地化设置进行流操作*，了解区域设置以及如何控制输入/输出流的行为'
- en: Generating pseudo-random numbers
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成伪随机数
- en: Generating random numbers is necessary for a large variety of applications,
    from games to cryptography, from sampling to forecasting. However, the term *random
    numbers* is not actually correct, as the generation of numbers through mathematical
    formulas is deterministic and does not produce true random numbers, but rather,
    numbers that look random and are called *pseudo-random*. True randomness can only
    be achieved through hardware devices, based on physical processes, and even that
    can be challenged as we may consider even the universe to be actually deterministic.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 生成随机数对于各种应用程序都是必要的，从游戏到密码学，从抽样到预测。然而，“随机数”这个术语实际上并不准确，因为通过数学公式生成数字是确定性的，并不产生真正的随机数，而是产生看起来随机的数字，称为“伪随机数”。真正的随机性只能通过基于物理过程的硬件设备实现，即使这样也可能受到挑战，因为我们甚至可能认为整个宇宙实际上是确定性的。
- en: Modern C++ provides support for generating pseudo-random numbers through a pseudo-random
    number library containing number generators and distributions. Theoretically,
    it can also produce true random numbers but, in practice, those could actually
    be only pseudo-random.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 现代C++提供了通过伪随机数库生成伪随机数的支持，该库包含数字生成器和分布。理论上，它也可以生成真正的随机数，但在实践中，这些可能实际上只是伪随机数。
- en: Getting ready
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we’ll discuss the standard support for generating pseudo-random
    numbers. Understanding the difference between random and pseudo-random numbers
    is key. True random numbers are numbers that cannot be predicted better than by
    random chance and are produced with the help of hardware-based random number generators.
    Pseudo-random numbers are numbers produced with the help of algorithms that generate
    sequences with properties that approximate the ones of true random numbers.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将讨论生成伪随机数的标准支持。理解随机数和伪随机数之间的区别是关键。真正的随机数是无法比随机机会预测得更好的数字，并且通过基于硬件的随机数生成器生成。伪随机数是通过生成具有近似真正随机数特性的序列的算法生成的数字。
- en: Furthermore, being familiar with various statistical distributions is a plus.
    It is mandatory, though, that you know what a uniform distribution is because
    all engines in the library produce numbers that are uniformly distributed. Without
    going into any details, we will just mention that uniform distribution is a probability
    distribution that is concerned with events that are equally likely to occur (within
    certain bounds).
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，熟悉各种统计分布也是一个加分项。然而，了解均匀分布是强制性的，因为库中的所有引擎生成的数字都是均匀分布的。不深入细节，我们只提一下，均匀分布是一种概率分布，它关注的是等可能性发生的事件（在特定范围内）。
- en: How to do it...
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'To generate pseudo-random numbers in your application, you should perform the
    following steps:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的应用程序中生成伪随机数，您应执行以下步骤：
- en: 'Include the header `<random>`:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '包含头文件 `<random>`:'
- en: '[PRE51]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Use an `std::random_device` generator to seed a pseudo-random engine:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `std::random_device` 生成器为一个伪随机引擎设置种子：
- en: '[PRE52]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Use one of the available engines to generate numbers and initialize it with
    a random seed:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用可用的一个引擎生成数字，并用随机种子初始化它：
- en: '[PRE53]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Use one of the available distributions to convert the output of the engine
    to one of the desired statistical distributions:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用可用的分布之一将引擎的输出转换为所需的统计分布之一：
- en: '[PRE54]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Generate the pseudo-random numbers:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成伪随机数：
- en: '[PRE55]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: How it works...
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The pseudo-random number library contains two types of components:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 伪随机数库包含两种类型的组件：
- en: '*Engines*, which are generators of random numbers; these can produce either
    pseudo-random numbers with a uniform distribution or, if available, actual random
    numbers.'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Engines*，这些是随机数生成器；这些可以生成具有均匀分布的伪随机数，或者如果可用，实际随机数。'
- en: '*Distributions* that convert the output of an engine to a statistical distribution.'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Distributions*，这些将引擎的输出转换为统计分布。'
- en: 'All engines (except for `random_device`) produce integer numbers in a uniform
    distribution, and all engines implement the following methods:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 所有引擎（除了 `random_device`）都产生在均匀分布中的整数数，并且所有引擎都实现了以下方法：
- en: '`min()`: This is a static method that returns the minimum value that can be
    produced by the generator.'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`min()`：这是一个静态方法，返回生成器可以生成的最小值。'
- en: '`max()`: This is a static method that returns the maximum value that can be
    produced by the generator.'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max()`：这是一个静态方法，返回生成器可以生成的最大值。'
- en: '`seed()`: This initializes the algorithm with a start value (except for `random_device`,
    which cannot be seeded).'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`seed()`：这使用起始值初始化算法（除了 `random_device`，它不能被初始化）。'
- en: '`operator()`: This generates a new number uniformly distributed between `min()`
    and `max()`.'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`operator()`：这生成一个在 `min()` 和 `max()` 之间均匀分布的新数字。'
- en: '`discard()`: This generates and discards a given number of pseudo-random numbers.'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`discard()`：生成并丢弃指定数量的伪随机数。'
- en: 'The following engines are available:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 以下引擎可用：
- en: '`linear_congruential_engine`: This is a linear congruential generator that
    produces numbers using the following formula:'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`linear_congruential_engine`：这是一个线性同余发生器，使用以下公式生成数字：'
- en: '*x*(*i*) = (*A* * *x*(i – *1*) + *C*) mod *M*'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*x*(*i*) = (*A* * *x*(i – *1*) + *C*) mod *M*'
- en: '`mersenne_twister_engine`: This is a Mersenne Twister generator that keeps
    a value on *W* * (*N* – 1) * *R* bits. Each time a number needs to be generated,
    it extracts *W* bits. When all the bits have been used, it twists the large value
    by shifting and mixing the bits so that it has a new set of bits to extract from.'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mersenne_twister_engine`：这是一个梅森旋转发生器，它在 *W* * (*N* – 1) * *R* 位上保持一个值。每次需要生成一个数字时，它提取
    *W* 位。当所有位都已被使用时，它通过移位和混合位来扭曲大值，以便它有一个新的位集可以从中提取。'
- en: '`subtract_with_carry_engine`: This is a generator that implements a *subtract
    with carry* algorithm based on the following formula:'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subtract_with_carry_engine`：这是一个实现基于以下公式的 *subtract with carry* 算法的生成器：'
- en: '*x*(*i*) = (*x*(*i* – *R*) – *x*(*i* – *S*) – *cy*(*i* – 1)) mod *M*'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*x*(*i*) = (*x*(*i* – *R*) – *x*(*i* – *S*) – *cy*(*i* – 1)) mod *M*'
- en: 'In the preceding formula, *cy* is defined as:'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的公式中，*cy*定义为：
- en: '![](img/B21549_02_001.png)'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/B21549_02_001.png)'
- en: 'In addition, the library provides engine adapters that are also engines wrapping
    another engine and producing numbers based on the output of the base engine. Engine
    adapters implement the same methods mentioned earlier for the base engines. The
    following engine adapters are available:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，库还提供了引擎适配器，这些适配器也是包装另一个引擎并基于基本引擎的输出生成数字的引擎。引擎适配器实现了前面提到的基本引擎的相同方法。以下可用的引擎适配器有：
- en: '`discard_block_engine`: A generator that, from every block of *P* numbers generated
    by the base engine, keeps only *R* numbers, discarding the rest.'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`discard_block_engine`：一个生成器，从基本引擎生成的每个 *P* 个数字块中，只保留 *R* 个数字，丢弃其余的数字。'
- en: '`independent_bits_engine`: A generator that produces numbers with a different
    number of bits than the base engine.'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`independent_bits_engine`：一个生成器，它产生与基本引擎不同数量的位数的数字。'
- en: '`shuffle_order_engine`: A generator that keeps a shuffled table of *K* numbers
    produced by the base engine and returns numbers from this table, replacing them
    with numbers generated by the base engine.'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shuffle_order_engine`：一个生成器，它保持由基本引擎生成的 *K* 个数字的随机顺序表，并从该表中返回数字，用基本引擎生成的数字替换它们。'
- en: Choosing a pseudo-random number generator should be done based on the specific
    requirements of your application. The linear congruential engine is medium-fast
    but has very small storage requirements for its internal state. The subtract with
    carry engine is very fast, including on machines that don’t have a processor with
    advanced arithmetic instruction sets. However, it requires larger storage for
    its internal state and the sequence of generated numbers has fewer desirable characteristics.
    The Mersenne Twister is the slowest of these engines and has the greatest storage
    durations but produces the longest non-repeating sequences of pseudo-numbers.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 选择伪随机数生成器应根据您应用程序的具体要求进行。线性同余引擎中等快速，但其内部状态存储需求非常小。减法进位引擎非常快，包括在那些没有高级算术指令集处理器的机器上。然而，它需要更大的内部状态存储，并且生成的数字序列具有较少的期望特征。梅森旋转器是这些引擎中最慢的，具有最长的存储持续时间，但产生最长的非重复伪数字序列。
- en: All these engines and engine adaptors produce pseudo-random numbers. The library,
    however, provides another engine called `random_device` that is supposed to produce
    non-deterministic numbers, but this is not an actual constraint as physical sources
    of random entropy might not be available. Therefore, implementations of `random_device`
    could actually be based on a pseudo-random engine. The `random_device` class cannot
    be seeded like the other engines and has an additional method called `entropy()`
    that returns the random device entropy, which is 0 for a deterministic generator
    and nonzero for a non-deterministic generator.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些引擎和引擎适配器都产生伪随机数。然而，库还提供了一个称为 `random_device` 的另一个引擎，它应该产生非确定性数字，但这不是一个实际约束，因为可能没有可用的物理随机熵源。因此，`random_device`
    的实现实际上可能基于伪随机引擎。`random_device` 类不能像其他引擎那样进行播种，并且有一个名为 `entropy()` 的附加方法，它返回随机设备的熵，对于确定性生成器为
    0，对于非确定性生成器为非零。
- en: However, this is not a reliable method for determining whether the device is
    actually deterministic or non-deterministic. For instance, both GNU `libstdc++`
    and LLVM `libc++` implement a non-deterministic device but return `0` for entropy.
    On the other hand, `VC++` and `boost.random` return `32` and `10`, respectively,
    for entropy.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这不是确定设备是否真正确定性的可靠方法。例如，GNU `libstdc++` 和 LLVM `libc++` 实现了一个非确定性设备，但熵返回 `0`。另一方面，`VC++`
    和 `boost.random` 分别返回 `32` 和 `10` 作为熵。
- en: All these generators produce integers in a uniform distribution. This is, however,
    only one of the many possible statistical distributions where random numbers are
    needed in most applications. To be able to produce numbers (either integer or
    real) in other distributions, the library provides several classes called *distributions*.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些生成器都产生均匀分布的整数。然而，这只是在大多数应用中需要随机数的大多数可能统计分布之一。为了能够产生其他分布中的数字（无论是整数还是实数），库提供了几个称为
    *分布* 的类。
- en: 'These convert the output of an engine according to the statistical distribution
    it implements. The following distributions are available:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 这些将根据其实施的统计分布转换引擎的输出。以下分布可用：
- en: '| **Type** | **Class name** | **Numbers** | **Statistical distribution** |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **类名** | **数字** | **统计分布** |'
- en: '| Uniform | `uniform_int_distribution` | Integer | Uniform |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
  zh: '| 均匀分布 | `uniform_int_distribution` | 整数 | 均匀分布 |'
- en: '| `uniform_real_distribution` | Real | Uniform |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '| `uniform_real_distribution` | 实数 | 均匀 |'
- en: '| Bernoulli | `bernoulli_distribution` | Boolean | Bernoulli |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '| 伯努利 | `bernoulli_distribution` | 布尔 | 伯努利 |'
- en: '| `binomial_distribution` | Integer | Binomial |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
  zh: '| `binomial_distribution` | 整数 | 二项式 |'
- en: '| `negative_binomial_distribution` | Integer | Negative binomial |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
  zh: '| `negative_binomial_distribution` | 整数 | 负二项式 |'
- en: '| `geometric_distribution` | Integer | Geometric |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
  zh: '| `geometric_distribution` | 整数 | 几何 |'
- en: '| Poisson | `poisson_distribution` | Integer | Poisson |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
  zh: '| 泊松 | `poisson_distribution` | 整数 | 泊松 |'
- en: '| `exponential_distribution` | Real | Exponential |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
  zh: '| `exponential_distribution` | 实数 | 指数 |'
- en: '| `gamma_distribution` | Real | Gamma |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
  zh: '| `gamma_distribution` | 实数 |伽马 |'
- en: '| `weibull_distribution` | Real | Weibull |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
  zh: '| `weibull_distribution` | 实数 | Weibull |'
- en: '| `extreme_value_distribution` | Real | Extreme value |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
  zh: '| `extreme_value_distribution` | 实数 | 极值 |'
- en: '| Normal | `normal_distribution` | Real | Standard normal (Gaussian) |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
  zh: '| 正态 | `normal_distribution` | 实数 | 标准正态（高斯） |'
- en: '| `lognormal_distribution` | Real | Lognormal |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
  zh: '| `lognormal_distribution` | 实数 | 对数正态 |'
- en: '| `chi_squared_distribution` | Real | Chi-squared |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
  zh: '| `chi_squared_distribution` | 实数 | 卡方 |'
- en: '| `cauchy_distribution` | Real | Cauchy |'
  id: totrans-419
  prefs: []
  type: TYPE_TB
  zh: '| `cauchy_distribution` | 实数 | 柯西 |'
- en: '| `fisher_f_distribution` | Real | Fisher’s F-distribution |'
  id: totrans-420
  prefs: []
  type: TYPE_TB
  zh: '| `fisher_f_distribution` | 实数 | 费舍尔F分布 |'
- en: '| `student_t_distribution` | Real | Student’s t-distribution |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
  zh: '| `student_t_distribution` | 实数 | 学生t分布 |'
- en: '| Sampling | `discrete_distribution` | Integer | Discrete |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
  zh: '| 抽样 | `discrete_distribution` | 整数 | 离散 |'
- en: '| `piecewise_constant_distribution` | Real | Values distributed on constant
    subintervals |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
  zh: '| `piecewise_constant_distribution` | 实数 | 在常数子区间上分布的值 |'
- en: '| `piecewise_linear_distribution` | Real | Values distributed on defined subintervals
    |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
  zh: '| `piecewise_linear_distribution` | 实数 | 在定义的子区间上分布的值 |'
- en: 'Table 2.12: The list of standard distributions from the <random> header'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.12：来自<random>头文件的标准化分布列表
- en: Each of the engines provided by the library has advantages and disadvantages,
    as mentioned earlier. When initialized appropriately, the Mersenne Twister, although
    the slowest and one that has the largest internal state, can produce the longest
    non-repeating sequence of numbers. In the following examples, we will use `std::mt19937`,
    a 32-bit Mersenne Twister with 19,937 bits of internal state. There is also a
    64-bit Mersenne Twister, `std::mt19937_64`. Both `std::mt19937` and `std::mt19937_64`
    are aliases for `std::mersenne_twister_engine`.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，库提供的每个引擎都有其优缺点。当适当地初始化时，梅森旋转器，尽管速度最慢且内部状态最大，可以产生最长的非重复数字序列。在以下示例中，我们将使用`std::mt19937`，这是一个具有19,937位内部状态的32位梅森旋转器。还有一个64位的梅森旋转器，`std::mt19937_64`。`std::mt19937`和`std::mt19937_64`都是`std::mersenne_twister_engine`的别名。
- en: 'The simplest way to generate random numbers looks like this:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 生成随机数的最简单方法如下：
- en: '[PRE56]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In this example, `mtgen` is `std::mt19937` for the Mersenne Twister. To generate
    numbers, you only need to use the call operator that advances the internal state
    and returns the next pseudo-random number. However, this code is flawed, as the
    engine is not seeded. As a result, it always produces the same sequence of numbers,
    which is probably not what you want in most cases.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`mtgen`是梅森旋转器的`std::mt19937`。要生成数字，你只需要使用调用操作符，它会推进内部状态并返回下一个伪随机数。然而，这段代码有缺陷，因为引擎没有被初始化。结果，它总是产生相同的数字序列，这在大多数情况下可能不是你想要的。
- en: 'There are different approaches to initializing the engine. One approach, common
    with the C `random` library, is to use the current time. In modern C++, it should
    look like this:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化引擎的方法有很多种。其中一种方法，与C语言的`random`库类似，是使用当前时间。在现代C++中，它应该看起来像这样：
- en: '[PRE57]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In this example, `seed` is a number representing the number of ticks from the
    clock’s epoch until the present moment. This number is then used to seed the engine.
    The problem with this approach is that the value of that `seed` is actually deterministic,
    and in some classes of applications, it could be prone to attacks. A more reliable
    approach is to seed the generator with actual random numbers.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`seed`是一个表示从时钟的纪元到当前时刻的滴答数的数字。然后使用这个数字来初始化引擎。这种方法的问题在于，那个`seed`的值实际上是确定的，在某些类别的应用中，它可能容易受到攻击。一个更可靠的方法是用实际的随机数来初始化生成器。
- en: 'The `std::random_device` class is an engine that is supposed to return true
    random numbers, though implementations could actually be based on a pseudo-random
    generator:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::random_device`类是一个应该返回真随机数的引擎，尽管实现可能实际上基于伪随机数生成器：'
- en: '[PRE58]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Numbers produced by all engines follow a uniform distribution. To convert the
    result to another statistical distribution, we have to use a distribution class.
    To show how generated numbers are distributed according to the selected distribution,
    we will use the following function. This function generates a specified number
    of pseudo-random numbers and counts their repetition in a map. The values from
    the map are then used to produce a bar-like diagram showing how often each number
    occurred:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 所有引擎产生的数字都遵循均匀分布。要将结果转换为另一个统计分布，我们必须使用一个分布类。为了展示生成的数字是如何根据所选分布分布的，我们将使用以下函数。这个函数生成指定数量的伪随机数，并计算它们在映射中的重复次数。然后使用映射中的值来生成一个条形图，显示每个数字出现的频率：
- en: '[PRE59]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The following code generates random numbers using the `std::mt19937` engine
    with a uniform distribution in the range `[1, 6]`; this is basically what you
    get when you throw a die:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用`std::mt19937`引擎在范围`[1, 6]`内生成随机数；这基本上是你掷骰子时得到的结果：
- en: '[PRE60]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The output of the program looks like this:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出如下：
- en: '![A screenshot of a computer screen  Description automatically generated](img/B21549_02_06.png)'
  id: totrans-440
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成的描述](img/B21549_02_06.png)'
- en: 'Figure 2.6: Uniform distribution of the range [1,6]'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6：范围[1,6]的均匀分布
- en: 'In the next and final example, we’re changing the distribution to a normal
    distribution with a mean of `5` and a standard deviation of `2`. This distribution
    produces real numbers; therefore, in order to use the previous `generate_and_print()`
    function, the numbers must be rounded to integers:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个和最后一个示例中，我们将分布更改为均值为`5`和标准差为`2`的正态分布。这种分布产生实数；因此，为了使用之前的`generate_and_print()`函数，必须将数字四舍五入为整数：
- en: '[PRE61]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The following will be the output of the preceding code:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 以下将是前面代码的输出：
- en: '![](img/B21549_02_07.png)'
  id: totrans-445
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21549_02_07.png)'
- en: 'Figure 2.7: Normal distribution with mean 5 and standard variance 2'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7：均值为5和标准方差为2的正态分布
- en: Here, we can see that, based on the graphical representation, the distribution
    has changed from a uniform one to a normal one with the mean at value 5.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到，基于图形表示，分布已从均匀分布变为均值为5的正态分布。
- en: See also
  id: totrans-448
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Properly initializing a pseudo-random number generator*, to learn how to properly
    initialize random number engines'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*正确初始化伪随机数生成器*，了解如何正确初始化随机数生成器'
- en: Properly initializing a pseudo-random number generator
  id: totrans-450
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正确初始化伪随机数生成器
- en: In the previous recipe, we looked at the pseudo-random number library, along
    with its components, and how it can be used to produce numbers in different statistical
    distributions. One important factor that was overlooked in that recipe is the
    proper initialization of the pseudo-random number generators.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的配方中，我们探讨了伪随机数库及其组件，以及如何使用它来生成不同统计分布的数字。在那个配方中，被忽视的一个重要因素是伪随机数生成器的正确初始化。
- en: With careful analysis (which is beyond the purpose of this recipe or this book),
    it can be shown that the Mersenne Twister engine has a bias toward producing some
    values repeatedly and omitting others, thus generating numbers not in a uniform
    distribution, but rather in a binomial or Poisson distribution. In this recipe,
    you will learn how to initialize a generator in order to produce pseudo-random
    numbers with a true uniform distribution.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 通过仔细分析（这超出了本配方或本书的目的），可以证明梅森旋转器引擎倾向于重复产生某些值并省略其他值，从而生成不是均匀分布的数字，而是二项式或泊松分布的数字。在本配方中，您将学习如何初始化生成器以生成具有真正均匀分布的伪随机数。
- en: Getting ready
  id: totrans-453
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You should read the previous recipe, *Generating pseudo-random numbers*, to
    get an overview of what the pseudo-random number library offers.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该阅读之前的配方，*生成伪随机数*，以了解伪随机数库提供的概述。
- en: How to do it...
  id: totrans-455
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To properly initialize a pseudo-random number generator to produce a uniformly
    distributed sequence of pseudo-random numbers, perform the following steps:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确初始化伪随机数生成器以生成均匀分布的伪随机数序列，执行以下步骤：
- en: 'Use an `std::random_device` to produce random numbers to be used as seeding
    values:'
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`std::random_device`生成随机数作为种子值：
- en: '[PRE62]'
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Generate random data for all internal bits of the engine:'
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为引擎的所有内部位生成随机数据：
- en: '[PRE63]'
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Create an `std::seed_seq` object from the previously generated pseudo-random
    data:'
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从之前生成的伪随机数据创建一个`std::seed_seq`对象：
- en: '[PRE64]'
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Create an engine object and initialize all the bits representing the internal
    state of the engine; for example, an `mt19937` has 19,937 bits of internal state:'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个引擎对象并初始化表示引擎内部状态的位；例如，`mt19937`有19,937位的内部状态：
- en: '[PRE65]'
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Use the appropriate distribution based on the requirements of the application:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据应用程序的要求使用适当的分布：
- en: '[PRE66]'
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: How it works...
  id: totrans-467
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In all the examples shown in the previous recipe, we used the `std::mt19937`
    engine to produce pseudo-random numbers. Though the Mersenne Twister is slower
    than the other engines, it can produce the longest sequences of non-repeating
    numbers with the best spectral characteristics. However, initializing the engine
    in the manner shown in the previous recipe will not have this effect. The problem
    is that the internal state of `mt19937` has 624 32-bit integers, and in the examples
    from the previous recipe, we have only initialized one of them.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前配方中展示的所有示例中，我们使用了`std::mt19937`引擎来生成伪随机数。尽管梅森旋转器比其他引擎慢，但它可以产生最长的非重复数字序列，并具有最佳的频谱特性。然而，按照之前配方中所示的方式初始化引擎将不会产生这种效果。问题是`mt19937`的内部状态有624个32位整数，而在之前配方的示例中，我们只初始化了其中之一。
- en: When working with the pseudo-random number library, remember the following rule
    of thumb (shown in the information box).
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用伪随机数库时，请记住以下经验法则（如信息框所示）。
- en: In order to produce the best results, engines must have their entire internal
    state properly initialized before generating numbers.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 为了产生最佳结果，在生成数字之前，必须正确初始化引擎的整个内部状态。
- en: The pseudo-random number library provides a class for this particular purpose,
    called `std::seed_seq`. This is a generator that can be seeded with any number
    of 32-bit integers and produces the requested number of integers evenly distributed
    in the 32-bit space.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 伪随机数库提供了一个用于此特定目的的类，称为 `std::seed_seq`。这是一个可以以任意数量的32位整数进行初始化的生成器，并在32位空间内均匀地产生所需数量的整数。
- en: In the preceding code from the *How to do it...* section, we defined an array
    called `seed_data` with a number of 32-bit integers equal to the internal state
    of the `mt19937` generator – that is, 624 integers. Then, we initialized the array
    with random numbers produced by `std::random_device`. The array was later used
    to seed `std::seed_seq`, which, in turn, was used to seed the `mt19937` generator.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *如何做...* 部分的先前代码中，我们定义了一个名为 `seed_data` 的数组，其中包含与 `mt19937` 生成器内部状态相等的32位整数——即624个整数。然后，我们使用
    `std::random_device` 生成的随机数初始化该数组。该数组后来被用来初始化 `std::seed_seq`，而 `std::seed_seq`
    又被用来初始化 `mt19937` 生成器。
- en: See also
  id: totrans-473
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Generating pseudo-random numbers*, to familiarize yourself with the capabilities
    of the standard numeric library for generating pseudo-random numbers'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*生成伪随机数*，以便熟悉标准数值库生成伪随机数的能力'
- en: Creating cooked user-defined literals
  id: totrans-475
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建烹饪用户定义字面量
- en: Literals are constants of built-in types (numerical, Boolean, character, character
    string, and pointer) that cannot be altered in a program. The language defines
    a series of prefixes and suffixes to specify literals (and the prefix/suffix is
    actually part of the literal). C++11 allows us to create user-defined literals
    by defining functions called *literal operators*, which introduce suffixes for
    specifying literals. These work only with numerical character and character string
    types.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 字面量是内置类型（数值、布尔、字符、字符字符串和指针）的常量，在程序中不能被更改。语言定义了一系列前缀和后缀来指定字面量（前缀/后缀实际上是字面量的一部分）。C++11允许我们通过定义称为*字面量运算符*的函数来创建用户定义的字面量，这些运算符引入了用于指定字面量的后缀。这些运算符仅与数值字符和字符字符串类型一起使用。
- en: This opens the possibility of defining both standard literals in future versions
    and allows developers to create their own literals. In this recipe, we will learn
    how to create our own cooked literals.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 这为在未来的版本中定义标准字面量和允许开发者创建自己的字面量打开了可能性。在本食谱中，我们将学习如何创建自己的烹饪字面量。
- en: Getting ready
  id: totrans-478
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'User-defined literals can have two forms: *raw* and *cooked*. Raw literals
    are not processed by the compiler, whereas cooked literals are values processed
    by the compiler (examples include handling escape sequences in a character string
    or identifying numerical values such as integer 2898 from literal 0xBAD). Raw
    literals are only available for integral and floating-point types, whereas cooked
    literals are also available for character and character string literals.'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 用户定义的字面量可以有两种形式：*原始*和*烹饪*。原始字面量不会被编译器处理，而烹饪字面量则是被编译器处理的值（例如，处理字符字符串中的转义序列或识别字面量中的数值，如整数2898来自字面量0xBAD）。原始字面量仅适用于整数和浮点类型，而烹饪字面量也适用于字符和字符字符串字面量。
- en: How to do it...
  id: totrans-480
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To create cooked user-defined literals, you should follow these steps:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建烹饪用户定义字面量，你应该遵循以下步骤：
- en: Define your literals in a separate namespace to avoid name clashes.
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在单独的命名空间中定义你的字面量以避免名称冲突。
- en: Always prefix the user-defined suffix with an underscore (`_`).
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 总是用下划线（`_`）作为用户定义后缀的前缀。
- en: 'Define a literal operator of one of the following forms for cooked literals
    (the forms using `char8_t` are only available since C++20). Notice that in the
    following listing, `T` is not a type template parameter, but only a placeholder
    for the return type of the operator:'
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为烹饪字面量定义以下形式之一的字面量运算符（使用 `char8_t` 的形式仅从C++20开始可用）。注意，在以下列表中，`T` 不是一个类型模板参数，而只是运算符返回类型的占位符：
- en: '[PRE67]'
  id: totrans-485
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The following example creates a user-defined literal for specifying kilobytes:'
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下示例创建了一个用于指定千字节的用户定义字面量：
- en: '[PRE68]'
  id: totrans-487
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: How it works...
  id: totrans-488
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When the compiler encounters a user-defined literal with a user-defined suffix,
    `_X` (it always has a leading underscore for third-party suffixes, as suffixes
    without a leading underscore are reserved for the standard library), it does an
    unqualified name lookup in order to identify a function with the name `operator
    "" _X`. If it finds one, then it calls it according to the type of the literal
    and the type of the literal operator. Otherwise, the compiler will yield an error.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器遇到一个具有用户定义后缀`_X`（它总是以下划线开头，因为不带前导下划线的后缀是为标准库保留的）的用户定义字面量时，它将执行无限定名称查找以识别名为`operator
    "" _X`的函数。如果找到了，则根据字面量和字面量运算符的类型调用它。否则，编译器将产生错误。
- en: In the example shown in the *How to do it...* section, the literal operator
    is called `operator "" _KB` and has an argument of type `unsigned long long int`.
    This is the only integral type possible for literal operators to handle integral
    types. Similarly, for floating-point user-defined literals, the parameter type
    must be `long double` since, for numeric types, the literal operators must be
    able to handle the largest possible values. This literal operator returns a `constexpr`
    value so that it can be used where compile-time values are expected, such as specifying
    the size of an array, as shown in the preceding example.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 在“如何做...”部分的示例中，字面量运算符被调用为`operator "" _KB`，其参数类型为`unsigned long long int`。这是字面量运算符可以处理的唯一整数类型。同样，对于浮点用户定义字面量，参数类型必须是`long
    double`，因为对于数值类型，字面量运算符必须能够处理可能的最大值。此字面量运算符返回一个`constexpr`值，因此它可以在需要编译时值的上下文中使用，例如指定数组的大小，如前例所示。
- en: 'When the compiler identifies a user-defined literal and has to call the appropriate
    user-defined literal operator, it will pick the overload from the overload set
    according to the following rules:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器识别出一个用户定义字面量并需要调用适当的用户定义字面量运算符时，它将根据以下规则从重载集中选择重载：
- en: '**For integral literals**: It calls in the following order: the operator that
    takes an `unsigned long long`, the raw literal operator that takes a `const char*`,
    or the literal operator template.'
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于整数字面量**：它按以下顺序调用：接受`unsigned long long`的运算符，接受`const char*`的原始字面量运算符，或字面量运算符模板。'
- en: '**For floating-point literals**: It calls in the following order: the operator
    that takes a `long double`, the raw literal operator that takes a `const char*`,
    or the literal operator template.'
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于浮点字面量**：它按以下顺序调用：接受`long double`的运算符，接受`const char*`的原始字面量运算符，或字面量运算符模板。'
- en: '**For character literals**: It calls the appropriate operator, depending on
    the character type (`char`, `wchar_t`, `char16_t`, and `char32_t`).'
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于字符字面量**：它根据字符类型（`char`、`wchar_t`、`char16_t`和`char32_t`）调用适当的运算符。'
- en: '**For string literals**: It calls the appropriate operator, depending on the
    string type, that takes a pointer to the string of characters and the size.'
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于字符串字面量**：它调用适当的运算符，根据字符串类型，该运算符接受一个指向字符字符串的指针和大小。'
- en: In the following example, we’re defining a system of units and quantities. We
    want to operate with kilograms, pieces, liters, and other types of units. This
    could be useful in a system that can process orders and you need to specify the
    amount and unit for each article.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们正在定义一个单位和数量的系统。我们希望使用千克、件、升和其他类型的单位。这在可以处理订单的系统中有用，您需要指定每件商品的量和单位。
- en: 'The following are defined in the `units` namespace:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 在`units`命名空间中定义了以下内容：
- en: 'A scoped enumeration for the possible types of units (kilogram, meter, liter,
    and pieces):'
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个作用域枚举，用于可能的单位类型（如千克、米、升和件）：
- en: '[PRE69]'
  id: totrans-499
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'A class template to specify quantities of a particular unit (such as 3.5 kilograms
    or 42 pieces):'
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类模板，用于指定特定单位的数量（例如3.5千克或42件）：
- en: '[PRE70]'
  id: totrans-501
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The `operator+` and `operator-` functions for the `quantity` class template
    in order to be able to add and subtract quantities:'
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了能够对`quantity`类模板进行加法和减法操作，定义了`operator+`和`operator-`函数：
- en: '[PRE71]'
  id: totrans-503
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Literal operators to create `quantity` literals, defined in an inner namespace
    called `unit_literals`. The purpose of this is to avoid possible name clashes
    with literals from other namespaces.
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建`quantity`字面量的字面量运算符，定义在名为`unit_literals`的内部命名空间中。这样做是为了避免与其他命名空间中的字面量发生名称冲突。
- en: 'If such collisions do happen, developers could select the ones that they should
    use using the appropriate namespace in the scope where the literals need to be
    defined:'
  id: totrans-505
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果确实发生了这样的冲突，开发者可以使用适当的命名空间在需要定义字面量的作用域中选择它们：
- en: '[PRE72]'
  id: totrans-506
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'By looking carefully, you can note that the literal operators defined earlier
    are not the same:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察可以发现，之前定义的字面量运算符并不相同：
- en: '`_kg` is defined for both integral and floating-point literals; that enables
    us to create both integral and floating-point values such as `1_kg` and `1.0_kg`.'
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_kg` 定义了整数和浮点字面量；这使得我们能够创建整数和浮点值，例如 `1_kg` 和 `1.0_kg`。'
- en: '`_l` and `_m` are defined only for floating-point literals; this means we can
    only define quantity literals for these units with floating points, such as `4.5_l`
    and `10.0_m`.'
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_l` 和 `_m` 仅适用于浮点字面量；这意味着我们只能使用浮点数定义这些单位的量值字面量，例如 `4.5_l` 和 `10.0_m`。'
- en: '`_pcs` is only defined for integral literals; this means we can only define
    quantities of an integer number of pieces, such as `42_pcs`.'
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_pcs` 仅适用于整数字面量；这意味着我们只能定义整数数量的件量，例如 `42_pcs`。'
- en: 'Having these literal operators available, we can operate with various quantities.
    The following examples show both valid and invalid operations:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 有这些字面量运算符可用，我们可以操作各种量。以下示例显示了有效和无效操作：
- en: '[PRE73]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '`q1` is a quantity of 1 kg; this is an integer value. Since an overloaded `operator
    "" _kg(unsigned long long const)` exists, the literal can be correctly created
    from the integer 1\. Similarly, `q2` is a quantity of 4.5 kilograms; this is a
    real value. Since an overloaded `operator "" _kg(long double)` exists, the literal
    can be created from the double floating-point value 4.5.'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '`q1` 是 1 千克的量；这是一个整数值。由于存在重载的 `operator "" _kg(unsigned long long const)`，字面量可以从整数
    1 正确创建。同样，`q2` 是 4.5 千克的量；这是一个实数值。由于存在重载的 `operator "" _kg(long double)`，字面量可以从双精度浮点值
    4.5 创建。'
- en: On the other hand, `q6` is a quantity of 1 liter. Since there is no overloaded
    `operator "" _l(unsigned long long)`, the literal cannot be created. It would
    require an overload that takes an `unsigned long long`, but such an overload does
    not exist. Similarly, `q7` is a quantity of 2.0 pieces, but piece literals can
    only be created from integer values and, therefore, this generates another compiler
    error.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`q6` 是 1 升的量。由于没有重载的 `operator "" _l(unsigned long long)`，字面量无法创建。它需要一个接受
    `unsigned long long` 的重载，但这样的重载不存在。同样，`q7` 是 2.0 件，但件字面量只能从整数值创建，因此这会生成另一个编译器错误。
- en: There’s more...
  id: totrans-515
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'Though user-defined literals are available from C++11, standard literal operators
    have been available only from C++14\. Further standard user-defined literals have
    been added to the next versions of the standard. The following is a list of these
    standard literal operators:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管用户定义的字面量从 C++11 开始可用，但标准字面量运算符仅在 C++14 中可用。后续标准用户定义的字面量已添加到标准的下一个版本中。以下是一个这些标准字面量运算符的列表：
- en: '`operator""s` for defining `std::basic_string` literals and `operator""sv`
    (in C++17) for defining `std::basic_string_view` literals:'
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于定义 `std::basic_string` 字面量的 `operator""s` 和在 C++17 中用于定义 `std::basic_string_view`
    字面量的 `operator""sv`：
- en: '[PRE74]'
  id: totrans-518
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '`operator""h`, `operator""min`, `operator""s`, `operator""ms`, `operator""us`,
    and `operator""ns` for creating an `std::chrono::duration` value:'
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于创建 `std::chrono::duration` 值的 `operator""h`、`operator""min`、`operator""s`、`operator""ms`、`operator""us`
    和 `operator""ns`：
- en: '[PRE75]'
  id: totrans-520
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '`operator""y` for creating an `std::chrono::year` literal and `operator""d`
    for creating an `std::chrono::day` literal that represents a day of a month, both
    added to C++20:'
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于创建 `std::chrono::year` 字面量的 `operator""y` 和用于创建表示月份一天的 `std::chrono::day`
    字面量的 `operator""d`，两者都添加到 C++20：
- en: '[PRE76]'
  id: totrans-522
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '`operator""if`, `operator""i`, and `operator""il` for creating an `std::complex<float>`,
    `std::complex<double>`, and `std::complex<long double>` value:'
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于创建 `std::complex<float>`、`std::complex<double>` 和 `std::complex<long double>`
    值的 `operator""if`、`operator""i` 和 `operator""il`：
- en: '[PRE77]'
  id: totrans-524
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The standard user-defined literals are available in multiple namespaces. For
    instance, the `""s` and `""sv` literals for strings are defined in the namespace
    `std::literals::string_literals`.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 标准用户定义的字面量存在于多个命名空间中。例如，字符串的 `""s` 和 `""sv` 字面量定义在命名空间 `std::literals::string_literals`
    中。
- en: However, both `literals` and `string_literals` are inlined namespaces. Therefore,
    you can access the literals with `using namespace std::literals`, `using namespace
    std::string_literals`, or `using namespace std::literals::string_literals`. In
    the previous examples, the second form was preferred.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`literals` 和 `string_literals` 都是内联命名空间。因此，你可以使用 `using namespace std::literals`、`using
    namespace std::string_literals` 或 `using namespace std::literals::string_literals`
    来访问字面量。在之前的示例中，第二种形式被首选。
- en: See also
  id: totrans-527
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Using raw string literals to avoid escaping characters*, to learn how to define
    string literals without the need to escape special characters'
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用原始字符串字面量来避免转义字符*，了解如何定义不需要转义特殊字符的字符串字面量'
- en: '*Creating raw user-defined literals*, to understand how to provide a custom
    interpretation of an input sequence so that it changes the normal behavior of
    the compiler'
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建原始用户定义字面量*，了解如何提供对输入序列的定制解释，以便改变编译器的正常行为'
- en: '*Chapter 1*, *Using inline namespaces for symbol versioning,* to learn how
    to version your source code using inline namespaces and conditional compilation'
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第一章*，*使用内联命名空间进行符号版本控制*，了解如何使用内联命名空间和条件编译来对源代码进行版本控制'
- en: Creating raw user-defined literals
  id: totrans-531
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建原始用户定义字面量
- en: 'In the previous recipe, we looked at the way C++11 allows library implementers
    and developers to create user-defined literals and the user-defined literals available
    in the C++14 standard. However, user-defined literals have two forms: a cooked
    form, where the literal value is processed by the compiler before being supplied
    to the literal operator, and a raw form, in which the literal is not processed
    by the compiler before being supplied to the literal operator. The latter is only
    available for integral and floating-point types. Raw literals are useful for altering
    the compiler’s normal behavior. For instance, a sequence such as 3.1415926 is
    interpreted by the compiler as a floating-point value, but with the use of a raw
    user-defined literal, it could be interpreted as a user-defined decimal value.
    In this recipe, we will look at creating raw user-defined literals.'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的配方中，我们探讨了C++11允许库实现者和开发者创建用户定义字面量以及C++14标准中可用的用户定义字面量。然而，用户定义字面量有两种形式：一种是被烹饪的形式，其中字面量值在提供给字面量操作符之前由编译器处理；另一种是原始形式，其中字面量在提供给字面量操作符之前不会被编译器处理。后者仅适用于整型和浮点型。原始字面量对于改变编译器的正常行为很有用。例如，一个如3.1415926的序列被编译器解释为浮点值，但使用原始用户定义字面量，它可以被解释为用户定义的十进制值。在本配方中，我们将探讨创建原始用户定义字面量。
- en: Getting ready
  id: totrans-533
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before continuing with this recipe, it is strongly recommended that you go through
    the previous one, *Creating cooked user-defined literals*, as general details
    about user-defined literals will not be reiterated here.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续本配方之前，强烈建议您先完成前面的配方，*创建烹饪用户定义字面量*，因为这里不会重复用户定义字面量的通用细节。
- en: To exemplify the way raw user-defined literals can be created, we will define
    binary literals. These binary literals can be of 8-bit, 16-bit, and 32-bit (unsigned)
    types. These types will be called `byte8`, `byte16`, and `byte32`, and the literals
    we will create will be called `_b8`, `_b16`, and `_b32`.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明如何创建原始用户定义字面量，我们将定义二进制字面量。这些二进制字面量可以是8位、16位和32位（无符号）类型。这些类型将被称为 `byte8`、`byte16`
    和 `byte32`，我们将创建的字面量将被称为 `_b8`、`_b16` 和 `_b32`。
- en: How to do it...
  id: totrans-536
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To create raw user-defined literals, you should follow these steps:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建原始用户定义字面量，您应该遵循以下步骤：
- en: Define your literals in a separate namespace to avoid name clashes.
  id: totrans-538
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在单独的命名空间中定义您的字面量以避免名称冲突。
- en: Always prefix the used-defined suffix with an underscore (`_`).
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 总是以下划线（`_`）作为用户定义后缀的前缀。
- en: 'Define a literal operator or literal operator template of the following form:'
  id: totrans-540
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义以下形式的字面量操作符或字面量操作符模板：
- en: '[PRE78]'
  id: totrans-541
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The following example shows a possible implementation of 8-bit, 16-bit, and
    32-bit binary literals:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了8位、16位和32位二进制字面量的可能实现：
- en: '[PRE79]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: How it works...
  id: totrans-544
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'First of all, we define everything inside a namespace called `binary` and start
    by introducing several type aliases: `byte8`, `byte16`, and `byte32`. These represent
    integral types of 8 bits, 16 bits, and 32 bits, as the names imply.'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在名为 `binary` 的命名空间内定义一切，并首先介绍几个类型别名：`byte8`、`byte16` 和 `byte32`。这些代表8位、16位和32位的整型，正如其名称所暗示的。
- en: The implementation in the previous section enables us to define binary literals
    of the form `1010_b8` (a `byte8` value of decimal 10) or `000010101100_b16` (a
    `byte16` value of decimal 2130496). However, we want to make sure that we do not
    exceed the number of digits for each type. In other words, values such as `111100001_b8`
    should be illegal and the compiler should yield an error.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个章节中的实现使我们能够定义形式为 `1010_b8`（十进制值为10的 `byte8` 值）或 `000010101100_b16`（十进制值为2130496的
    `byte16` 值）的二进制字面量。然而，我们想确保我们不会超过每种类型的数字数量。换句话说，如 `111100001_b8` 这样的值应该是非法的，并且编译器应该产生错误。
- en: The literal operator templates are defined in a nested namespace called `binary_literal_internals`.
    This is a good practice in order to avoid name collisions with other literal operators
    from other namespaces. Should something like that happen, you can choose to use
    the appropriate namespace in the right scope (such as one namespace in a function
    or block and another namespace in another function or block).
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 字面量运算符模板定义在一个嵌套的命名空间中，称为 `binary_literal_internals`。这是一种良好的实践，以避免与其他命名空间中的其他字面量运算符发生名称冲突。如果发生类似情况，您可以选择在适当的范围内使用适当的命名空间（例如，一个函数或块中的一个命名空间和另一个函数或块中的另一个命名空间）。
- en: The three literal operator templates are very similar. The only things that
    are different are their names (`_b8`, `_16`, and `_b32`), return type (`byte8`,
    `byte16`, and `byte32`), and the condition in the static assert that checks the
    number of digits.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 三个字面量运算符模板非常相似。唯一不同的是它们的名称（`_b8`、`_16` 和 `_b32`）、返回类型（`byte8`、`byte16` 和 `byte32`）以及在静态断言中的条件，该断言检查数字的位数。
- en: 'We will explore the details of variadic templates and template recursion in
    a later recipe; however, for a better understanding, this is how this particular
    implementation works: `bits` is a template parameter pack that is not a single
    value, but all the values the template could be instantiated with. For example,
    if we consider the literal `1010_b8`, then the literal operator template would
    be instantiated as `operator"" _b8<''1'', ''0'', ''1'', ''0''>()`. Before proceeding
    with computing the binary value, we check the number of digits in the literal.
    For `_b8`, this must not exceed eight (including any trailing zeros). Similarly,
    it should be up to 16 digits for `_b16` and 32 for `_b32`. For this, we use the
    `sizeof...` operator, which returns the number of elements in a parameter pack
    (in this case, `bits`).'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后续的菜谱中探讨变长模板和模板递归的细节；然而，为了更好地理解，以下是这种特定实现的工作原理：`bits` 是一个模板参数包，它不是一个单一值，而是模板可以实例化的所有值。例如，如果我们考虑字面量
    `1010_b8`，那么字面量运算符模板将被实例化为 `operator"" _b8<'1', '0', '1', '0'>()`。在计算二进制值之前，我们检查字面量的位数。对于
    `_b8`，位数不得超过八个（包括任何尾随零）。同样，对于 `_b16` 应该是16位，对于 `_b32` 应该是32位。为此，我们使用 `sizeof...`
    操作符，它返回参数包中的元素数量（在这种情况下，`bits`）。
- en: If the number of digits is correct, we can proceed to expand the parameter pack
    and recursively compute the decimal value represented by the binary literal. This
    is done with the help of an additional class template and its specializations.
    These templates are defined in yet another nested namespace, called `binary_literals_internals`.
    This is also a good practice because it hides (without proper qualification) the
    implementation details from the client (unless an explicit `using namespace` directive
    makes them available to the current namespace).
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数字位数正确，我们可以继续展开参数包，并递归地计算二进制字面量表示的十进制值。这是通过一个额外的类模板及其特化来完成的。这些模板定义在另一个嵌套的命名空间中，称为
    `binary_literals_internals`。这也是一种良好的实践，因为它隐藏（除非通过适当的限定符）了从客户端隐藏实现细节（除非显式使用 `using
    namespace` 指令使它们对当前命名空间可用）。
- en: Even though this looks like recursion, it is not a true runtime recursion. This
    is because, after the compiler expands and generates the code from templates,
    what we end up with is basically calls to overloaded functions with a different
    number of parameters. This is explained in *Chapter 3* in the *Writing a function
    template with a variable number of arguments* recipe.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这看起来像是递归，但这并不是真正的运行时递归。这是因为，在编译器展开并从模板生成代码之后，我们最终得到的是对具有不同参数数量的重载函数的调用。这在上面的菜谱“编写具有可变数量参数的函数模板”的
    *第3章* 中有解释。
- en: 'The `binary_struct` class template has a template type of `CharT` for the return
    type of the function (we need this because our literal operator templates should
    return either `byte8`, `byte16`, or `byte32`) and a parameter pack:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: '`binary_struct` 类模板有一个模板类型 `CharT` 用于函数的返回类型（我们需要这个，因为我们的字面量运算符模板应该返回 `byte8`、`byte16`
    或 `byte32`），以及一个参数包：'
- en: '[PRE80]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Several specializations of this class template are available with parameter
    pack decomposition (of which you can read more in *Chapter 3* in the *Writing
    a function template with a variable number of arguments*) recipe. When the first
    digit of the pack is `''0''`, the computed value remains the same, and we continue
    expanding the rest of the pack. If the first digit of the pack is `''1''`, then
    the new value is 1, shifted to the left with the number of digits in the remainder
    of the pack bit, or the value of the rest of the pack:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 该类模板有几种特化可用，带有参数包分解（你可以在*第3章*的*编写具有可变参数数量的函数模板*食谱中了解更多）。当包的第一个数字是`'0'`时，计算值保持不变，我们继续展开包的其余部分。如果包的第一个数字是`'1'`，则新值是1，左移包剩余部分的位数，或者包剩余部分的值：
- en: '[PRE81]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The last specialization covers the case where the pack is empty; in this case,
    we return 0:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个特化处理了包为空的情况；在这种情况下，我们返回0：
- en: '[PRE82]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'After defining these helper classes, we could implement the `byte8`, `byte16`,
    and `byte32` binary literals as intended. Note that we need to bring the content
    of the namespace `binary_literals` into the current namespace in order to use
    the literal operator templates:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了这些辅助类之后，我们可以按照预期实现`byte8`、`byte16`和`byte32`二进制字面量。请注意，我们需要将`binary_literals`命名空间的内容引入当前命名空间，以便使用字面量操作符模板：
- en: '[PRE83]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The following definitions trigger compiler errors:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 以下定义会触发编译器错误：
- en: '[PRE84]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The reason for this is that the condition in `static_assert` is not met. The
    length of the sequence of characters preceding the literal operator is greater
    than expected, in all cases.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是`static_assert`中的条件未满足。在字面量操作符之前的字符序列长度大于预期，在所有情况下都是如此。
- en: See also
  id: totrans-563
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: '*Using raw string literals to avoid escaping characters*, to learn how to define
    string literals without the need to escape special characters'
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用原始字符串字面量来避免转义字符*，了解如何定义不需要转义特殊字符的字符串字面量'
- en: '*Creating cooked user-defined literals*, to learn how to create literals of
    user-defined types'
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建烹饪用户定义字面量*，了解如何创建用户定义类型的字面量'
- en: '*Chapter 3*, *Writing a function template with a variable number of arguments*,
    to see how variadic templates enable us to write functions that can take any number
    of arguments'
  id: totrans-566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第3章*，*编写具有可变参数数量的函数模板*，了解变长模板如何使我们能够编写可以接受任意数量参数的函数'
- en: '*Chapter 1*, *Creating type aliases and alias templates*, to learn about aliases
    for types'
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第1章*，*创建类型别名和别名模板*，了解类型别名'
- en: Using raw string literals to avoid escaping characters
  id: totrans-568
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用原始字符串字面量来避免转义字符
- en: Strings may contain special characters, such as non-printable characters (newline,
    horizontal and vertical tab, and so on), string and character delimiters (double
    and single quotes), or arbitrary octal, hexadecimal, or Unicode values. These
    special characters are introduced with an escape sequence that starts with a backslash,
    followed by either the character (examples include `'` and `"`), its designated
    letter (examples include `n` for a new line, and `t` for a horizontal tab), or
    its value (examples include octal 050, hexadecimal XF7, or Unicode U16F0). As
    a result, the backslash character itself has to be escaped with another backslash
    character. This leads to more complicated literal strings that can be hard to
    read.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串可能包含特殊字符，例如不可打印字符（换行符、水平制表符和垂直制表符等）、字符串和字符分隔符（双引号和单引号），或者任意的八进制、十六进制或Unicode值。这些特殊字符通过以反斜杠开头的转义序列引入，后跟字符（例如
    `'` 和 `"`）、其指定的字母（例如 `n` 表示换行，`t` 表示水平制表符），或其值（例如八进制050、十六进制XF7或Unicode U16F0）。因此，反斜杠字符本身必须通过另一个反斜杠字符进行转义。这导致了一些更复杂的字面量字符串，这些字符串可能难以阅读。
- en: To avoid escaping characters, C++11 introduced raw string literals that do not
    process escape sequences. In this recipe, you will learn how to use the various
    forms of raw string literals.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免转义字符，C++11引入了原始字符串字面量，它不处理转义序列。在本食谱中，你将学习如何使用原始字符串字面量的各种形式。
- en: Getting ready
  id: totrans-571
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, and throughout the rest of this book, I will use the `s` suffix
    to define `basic_string` literals. This was covered earlier in this chapter in
    the *Creating cooked user-defined literals* recipe.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，以及本书的其余部分，我将使用`s`后缀来定义`basic_string`字面量。这在本章的*创建烹饪用户定义字面量*食谱中已有介绍。
- en: How to do it...
  id: totrans-573
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'To avoid escaping characters, define the string literals with one of the following
    forms:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免转义字符，可以使用以下形式之一定义字符串字面量：
- en: '`R"( literal )"` as the default form:'
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`R"( literal )"`作为默认形式：'
- en: '[PRE85]'
  id: totrans-576
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '`R"delimiter( literal )delimiter"`, where `delimiter` is any sequence of characters
    excluding parentheses, backslash, and spaces, and `literal` is any sequence of
    characters with the limitation that it cannot include the closing sequence `)delimiter"`.
    Here is an example with `!!` as a delimiter:'
  id: totrans-577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`R"delimiter( literal )delimiter"`，其中 `delimiter` 是任何不包括括号、反斜杠和空格的字符序列，而 `literal`
    是任何字符序列，限制是不能包含关闭序列 `)delimiter"`。以下是一个以 `!!` 作为分隔符的示例：'
- en: '[PRE86]'
  id: totrans-578
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: How it works...
  id: totrans-579
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'When string literals are used, escapes are not processed, and the actual content
    of the string is written between the delimiter (in other words, what you see is
    what you get). The following example shows what appears as the same raw literal
    string; however, the second one still contains escaped characters. Since these
    are not processed in the case of string literals, they will be printed as they
    are in the output:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用字符串文本文本时，不会处理转义，实际字符串内容将写入分隔符之间（换句话说，所见即所得）。以下示例显示了看起来相同的原始文本文本；然而，第二个仍然包含转义字符。由于在字符串文本文本的情况下不会处理这些转义字符，它们将以原样打印到输出中：
- en: '[PRE87]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'If the text has to contain the `)"` sequence, then a different delimiter must
    be used, in the `R"delimiter( literal )delimiter"` form. According to the standard,
    the possible characters in a delimiter can be as follows:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文本必须包含 `)"` 序列，则必须使用不同的分隔符，在 `R"delimiter( literal )delimiter"` 形式中。根据标准，分隔符中可能包含的字符可以如下所示：
- en: 'Any member of the basic source character set except: space, the left parenthesis
    (the right parenthesis ), the backslash \, and the control characters representing
    horizontal tab, vertical tab, form feed, and newline.'
  id: totrans-583
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 基本源字符集的任何成员，除了：空格、左括号（右括号），反斜杠 \，以及代表水平制表符、垂直制表符、换页符和换行符的控制字符。
- en: 'Raw string literals can be prefixed by one of `L`, `u8`, `u`, and `U` to indicate
    a wide, UTF-8, UTF-16, or UTF-32 string literal, respectively. The following are
    examples of such string literals:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 原始字符串文本文本可以由 `L`、`u8`、`u` 和 `U` 之一前缀，分别表示宽字符串、UTF-8、UTF-16 或 UTF-32 字符串文本文本。以下是一些此类字符串文本文本的示例：
- en: '[PRE88]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Note that the presence of the suffix `""s` at the end of the string makes the
    compiler deduce the type as various string classes and not character arrays.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，字符串末尾存在后缀 `""s` 会使编译器推断类型为各种字符串类，而不是字符数组。
- en: See also
  id: totrans-587
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Creating cooked user-defined literals*, to learn how to create literals of
    user-defined types'
  id: totrans-588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建用户定义的文本文本*，以了解如何创建用户定义类型的文本文本'
- en: '*Understanding the various character and string types*, to learn more about
    character and string types, literal prefixes, and the changes in C++20 concerning
    the `u8` prefix'
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*了解各种字符和字符串类型*，以了解更多关于字符和字符串类型、文本文本前缀以及 C++20 中对 `u8` 前缀的更改'
- en: Creating a library of string helpers
  id: totrans-590
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建字符串辅助库
- en: The string types from the standard library are a general-purpose implementation
    that lacks many helpful methods, such as changing the case, trimming, splitting,
    and others that may address different developer needs. Third-party libraries that
    provide rich sets of string functionalities exist. However, in this recipe, we
    will look at implementing several simple, yet helpful, methods you may often need
    in practice. The purpose is to see how string methods and standard general algorithms
    can be used for manipulating strings but also to have a reference to reusable
    code that can be used in your applications.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中的字符串类型是一般用途的实现，缺乏许多有用的方法，例如更改大小写、修剪、分割等，这些可能满足不同开发者的需求。存在提供丰富字符串功能的第三方库。然而，在本配方中，我们将查看实现几个简单但有用的方法，这些方法你可能在实践中经常需要。目的是了解字符串方法和标准通用算法如何用于字符串操作，同时也是为了有一个可重用的代码库，可以在你的应用程序中使用。
- en: 'In this recipe, we will implement a small library of string utilities that
    will provide functions for the following:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将实现一个小型字符串实用程序库，它将提供以下功能的函数：
- en: Changing a string into lowercase or uppercase
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将字符串转换为小写或大写
- en: Reversing a string
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反转字符串
- en: Trimming white spaces from the beginning and/or the end of the string
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从字符串的开始和/或末尾修剪空白字符
- en: Trimming a specific set of characters from the beginning and/or the end of the
    string
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从字符串的开始和/或末尾删除特定的字符集
- en: Removing occurrences of a character anywhere in the string
  id: totrans-597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从字符串中删除任何位置的字符出现
- en: Tokenizing a string using a specific delimiter
  id: totrans-598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用特定分隔符对字符串进行标记化
- en: Before we start with the implementation, let’s look at some prerequisites.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始实现之前，让我们看看一些先决条件。
- en: Getting ready
  id: totrans-600
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The string library we will be implementing should work with all the standard
    string types – that is, `std::string`, `std::wstring`, `std::u16string`, and `std::u32string`.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要实现的字符串库应该与所有标准字符串类型一起工作——也就是说，`std::string`、`std::wstring`、`std::u16string`
    和 `std::u32string`。
- en: 'To avoid specifying long names such as `std::basic_string<CharT, std::char_traits<CharT>,
    std::allocator<CharT>>`, we will use the following alias templates for strings
    and string streams:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免指定像 `std::basic_string<CharT, std::char_traits<CharT>, std::allocator<CharT>>`
    这样长的名称，我们将使用以下别名模板来表示字符串和字符串流：
- en: '[PRE89]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: To implement these string helper functions, we need to include the header `<string>`
    for strings and `<algorithm>` for the general standard algorithms we will use.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这些字符串辅助函数，我们需要包含 `<string>` 头文件以使用字符串，以及 `<algorithm>` 头文件以使用我们将使用的通用标准算法。
- en: In all the examples in this recipe, we will use the standard user-defined literal
    operators for strings from C++14, for which we need to explicitly use the `std::string_literals`
    namespace.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱的所有示例中，我们将使用 C++14 的标准用户定义字面量运算符，对于字符串，我们需要显式使用 `std::string_literals` 命名空间。
- en: How to do it...
  id: totrans-606
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To convert a string to lowercase or uppercase, apply the `tolower()` or `toupper()`
    functions to the characters of a string using the general-purpose algorithm `std::transform()`:'
  id: totrans-607
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将字符串转换为小写或大写，请使用通用算法 `std::transform()` 将 `tolower()` 或 `toupper()` 函数应用于字符串中的字符：
- en: '[PRE90]'
  id: totrans-608
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'To reverse a string, use the general-purpose algorithm `std::reverse()`:'
  id: totrans-609
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要反转字符串，请使用通用算法 `std::reverse()`：
- en: '[PRE91]'
  id: totrans-610
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'To trim a string at the beginning, end, or both, use the `std::basic_string`
    methods `find_first_not_of()` and `find_last_not_of()`:'
  id: totrans-611
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在字符串的开始、结束或两者之间修剪，请使用 `std::basic_string` 方法 `find_first_not_of()` 和 `find_last_not_of()`：
- en: '[PRE92]'
  id: totrans-612
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'To trim characters in a given set from a string, use overloads of the `std::basic_string`
    methods `find_first_not_of()` and `find_last_not_of()`, which take a string parameter
    that defines the set of characters to look for:'
  id: totrans-613
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要从字符串中修剪给定集合中的字符，请使用 `std::basic_string` 方法的重载 `find_first_not_of()` 和 `find_last_not_of()`，这些方法接受一个字符串参数，该参数定义了要查找的字符集：
- en: '[PRE93]'
  id: totrans-614
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'To remove characters from a string, use `std::remove_if()` and `std::basic_string::erase()`:'
  id: totrans-615
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要从字符串中删除字符，请使用 `std::remove_if()` 和 `std::basic_string::erase()`：
- en: '[PRE94]'
  id: totrans-616
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'To split a string based on a specified delimiter, use `std::getline()` to read
    from an `std::basic_stringstream` initialized with the content of the string.
    The tokens extracted from the stream are pushed into a vector of strings:'
  id: totrans-617
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要根据指定的分隔符拆分字符串，请使用 `std::getline()` 从初始化为字符串内容的 `std::basic_stringstream` 中读取。从流中提取的标记被推入字符串的向量中：
- en: '[PRE95]'
  id: totrans-618
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: How it works...
  id: totrans-619
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To implement the utility functions from the library, we have two options:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现库中的实用函数，我们有两种选择：
- en: Functions will modify a string passed by a reference
  id: totrans-621
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数将修改通过引用传递的字符串
- en: Functions will not alter the original string but, instead, return a new string
  id: totrans-622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数将不会修改原始字符串，而是返回一个新的字符串
- en: The second option has the advantage that it preserves the original string, which
    may be helpful in many cases. Otherwise, in those cases, you would first have
    to make a copy of the string and alter the copy. The implementation provided in
    this recipe takes the second approach.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选择的优势在于它保留了原始字符串，这在许多情况下可能很有用。否则，在这些情况下，你首先必须复制字符串并修改副本。本食谱中提供的实现采用了第二种方法。
- en: 'The first functions we implemented in the *How to do it...* section were `to_upper()`
    and `to_lower()`. These functions change the content of a string either to uppercase
    or lowercase. The simplest way to implement this is by using the `std::transform()`
    standard algorithm. This is a general-purpose algorithm that applies a function
    to every element of a range (defined by a begin and end iterator) and stores the
    result in another range for which only the begin iterator needs to be specified.
    The output range can be the same as the input range, which is exactly what we
    did to transform the string. The applied function is `toupper()` or `tolower()`:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *如何做...* 部分中，我们首先实现的函数是 `to_upper()` 和 `to_lower()`。这些函数将字符串的内容更改为大写或小写。实现这一点最简单的方法是使用
    `std::transform()` 标准算法。这是一个通用算法，它将一个函数应用于范围（由开始和结束迭代器定义）中的每个元素，并将结果存储在另一个范围中，其中只需指定开始迭代器。输出范围可以是输入范围，这正是我们用来转换字符串的方法。应用的功能是
    `toupper()` 或 `tolower()`：
- en: '[PRE96]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The next function we considered was `reverse()`, which, as the name implies,
    reverses the content of a string. For this, we used the `std::reverse()` standard
    algorithm. This general-purpose algorithm reverses the elements of a range defined
    by a begin and end iterator:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 我们考虑的下一个函数是`reverse()`，正如其名称所暗示的，它反转字符串的内容。为此，我们使用了`std::reverse()`标准算法。这个通用算法反转由开始和结束迭代器定义的范围中的元素：
- en: '[PRE97]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'When it comes to trimming, a string can be trimmed at the beginning, end, or
    both sides. For that reason, we implemented three different functions: `trim()`
    for trimming at both ends, `trimleft()` for trimming at the beginning of a string,
    and `trimright()` for trimming at the end of a string. The first version of the
    function trims only spaces. In order to find the right part to trim, we use the
    `find_first_not_of()` and `find_last_not_of()` methods of `std::basic_string`.
    These return the first and last characters in the string that are not of the specified
    character. Subsequently, a call to the `substr()` method of `std::basic_string`
    returns a new string. The `substr()` method takes an index in the string and a
    number of elements to copy to the new string:'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到修剪时，字符串可以在开头、结尾或两边进行修剪。因此，我们实现了三个不同的函数：`trim()`用于修剪两端，`trimleft()`用于修剪字符串的开头，`trimright()`用于修剪字符串的结尾。函数的第一个版本只修剪空格。为了找到正确的修剪部分，我们使用了`std::basic_string`的`find_first_not_of()`和`find_last_not_of()`方法。这些方法返回字符串中不是指定字符的第一个和最后一个字符。随后，对`std::basic_string`的`substr()`方法的调用返回一个新的字符串。`substr()`方法接受字符串中的索引和要复制到新字符串中的元素数量：
- en: '[PRE98]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Sometimes, it can be useful to trim other characters and then spaces from a
    string. In order to do that, we provided overloads for the trimming functions
    that specify a set of characters to be removed. That set is also specified as
    a string. The implementation is very similar to the previous one because both
    `find_first_not_of()` and `find_last_not_of()` have overloads that take a string
    containing the characters to be excluded from the search:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，从字符串中删除其他字符和空格可能很有用。为了做到这一点，我们为修剪函数提供了重载，这些重载指定了要删除的字符集。该集合也指定为一个字符串。实现与之前的一个非常相似，因为`find_first_not_of()`和`find_last_not_of()`都有接受包含要排除搜索的字符的字符串的重载：
- en: '[PRE99]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: If removing characters from any part of the string is necessary, the trimming
    methods are not helpful because they only treat a contiguous sequence of characters
    at the start and end of a string. For that, however, we implemented a simple `remove()`
    method. This uses the `std:remove_if()` standard algorithm.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要从字符串的任何部分删除字符，修剪方法就无济于事，因为它们只处理字符串开头和结尾的连续字符序列。然而，为了实现这一点，我们实现了一个简单的`remove()`方法。这个方法使用了`std::remove_if()`标准算法。
- en: 'Both `std::remove()` and `std::remove_if()` work in a way that may not be very
    intuitive at first. They remove elements that satisfy the criteria from a range
    defined by a first and last iterator by rearranging the content of the range (using
    move assignment). The elements that need to be removed are placed at the end of
    the range, and the function returns an iterator to the first element in the range
    that represents the removed elements. This iterator basically defines the new
    end of the range that was modified. If no element was removed, the returned iterator
    is the end iterator of the original range. The value of this returned iterator
    is then used to call the `std::basic_string::erase()` method, which actually erases
    the content of the string defined by two iterators. The two iterators in our case
    are the iterator returned by `std::remove_if()` and the end of the string:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::remove()`和`std::remove_if()`的工作方式可能一开始并不直观。它们通过重新排列范围的内容（使用移动赋值）从由第一个和最后一个迭代器定义的范围中删除满足条件的元素。需要删除的元素被放置在范围的末尾，函数返回一个指向表示已删除元素的范围内第一个元素的迭代器。这个迭代器基本上定义了修改后的范围的新末尾。如果没有元素被删除，则返回的迭代器是原始范围的末尾迭代器。然后使用此返回迭代器的值调用`std::basic_string::erase()`方法，该方法实际上删除由两个迭代器定义的字符串的内容。在我们的情况下，这两个迭代器是`std::remove_if()`返回的迭代器和字符串的末尾：'
- en: '[PRE100]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: The last method we implemented, `split()`, splits the content of a string based
    on a specified delimiter. There are various ways to implement this. In this implementation,
    we used `std::getline()`. This function reads characters from an input stream
    until a specified delimiter is found and places the characters in a string.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后实现的 `split()` 方法，根据指定的分隔符将字符串的内容分割。有各种实现这种功能的方法。在我们的实现中，我们使用了 `std::getline()`。这个函数从输入流中读取字符，直到找到指定的分隔符，并将字符放入字符串中。
- en: 'Before starting to read from the input buffer, it calls `erase()` on the output
    string to clear its content. Calling this method in a loop produces tokens that
    are placed in a vector. In our implementation, empty tokens were skipped from
    the result set:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始从输入缓冲区读取之前，它会在输出字符串上调用 `erase()` 来清除其内容。在循环中调用此方法会产生放置在向量中的标记。在我们的实现中，从结果集中跳过了空标记：
- en: '[PRE101]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Two examples of text splitting are shown here. In the first example, the text
    from the `text5` variable is split into words and, as mentioned earlier, empty
    tokens are ignored. In the second example, splitting an empty string produces
    an empty vector of `token`.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了两个文本分割的示例。在第一个示例中，`text5` 变量的文本被分割成单词，如前所述，空标记被忽略。在第二个示例中，分割空字符串会产生一个空的
    `token` 向量。
- en: There’s more…
  id: totrans-639
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容…
- en: 'Several helper methods have been added to the `std::basic_string` class template
    in recent versions of the standard to help users avoid defining some widely used
    functions. These are listed in the following table:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准库的最近版本中，为 `std::basic_string` 类模板添加了几个辅助方法，以帮助用户避免定义一些广泛使用的函数。这些方法在以下表中列出：
- en: '| **Function** | **C++ version** | **Description** |'
  id: totrans-641
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **C++版本** | **描述** |'
- en: '| `starts_with` | C++20 | Checks whether the string starts with the specified
    prefix |'
  id: totrans-642
  prefs: []
  type: TYPE_TB
  zh: '| `starts_with` | C++20 | 检查字符串是否以指定的前缀开头 |'
- en: '| `ends_with` | C++20 | Checks whether the string ends with the specified suffix
    |'
  id: totrans-643
  prefs: []
  type: TYPE_TB
  zh: '| `ends_with` | C++20 | 检查字符串是否以指定的后缀结尾 |'
- en: '| `contains` | C++23 | Checks whether the string contains the specified substring
    |'
  id: totrans-644
  prefs: []
  type: TYPE_TB
  zh: '| `contains` | C++23 | 检查字符串是否包含指定的子字符串 |'
- en: 'Table 2.13: Newer basic_string member functions for widely-used string operations'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.13：广泛使用的字符串操作的新基本_string成员函数
- en: 'The use of these member functions is exemplified in the following snippet:'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 这些成员函数的使用在以下代码片段中得到了示例：
- en: '[PRE102]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: See also
  id: totrans-648
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: '*Creating cooked user-defined literals*, to learn how to create literals of
    user-defined types'
  id: totrans-649
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建用户定义的 cooked 文本字面量*，以了解如何创建用户定义类型的字面量'
- en: '*Chapter 1*, *Creating type aliases and alias templates*, to learn about aliases
    for types'
  id: totrans-650
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第一章*，*创建类型别名和别名模板*，了解类型别名的知识'
- en: Verifying the format of a string using regular expressions
  id: totrans-651
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用正则表达式验证字符串的格式
- en: Regular expressions are a language intended for performing pattern matching
    and replacements in texts. C++11 provides support for regular expressions within
    the standard library through a set of classes, algorithms, and iterators available
    in the `<regex>` header. In this recipe, we will learn how regular expressions
    can be used to verify that a string matches a pattern (examples include verifying
    an email or IP address format).
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式是一种用于在文本中进行模式匹配和替换的语言。C++11通过 `<regex>` 头文件中提供的一组类、算法和迭代器，在标准库中提供了对正则表达式的支持。在本食谱中，我们将学习如何使用正则表达式来验证字符串是否与某个模式匹配（例如验证电子邮件或IP地址格式）。
- en: Getting ready
  id: totrans-653
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Throughout this recipe, we will explain, whenever necessary, the details of
    the regular expressions that we use. However, you should have at least some basic
    knowledge of regular expressions in order to use the C++ standard library for
    regular expressions. A description of regular expression syntax and standards
    is beyond the purpose of this book; if you are not familiar with regular expressions,
    it is recommended that you read more about them before continuing with this, and
    the other recipes that focus on regular expressions. Good online resources for
    learning, building, and debugging regular expressions can be found at [https://regexr.com](https://regexr.com)
    and [https://regex101.com](https://regex101.com).
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将在必要时解释我们所使用的正则表达式的细节。然而，您至少应该对正则表达式有一些基本了解，以便使用C++标准库中的正则表达式。正则表达式语法和标准的描述超出了本书的目的；如果您不熟悉正则表达式，建议在继续阅读本食谱和其他专注于正则表达式的食谱之前，了解更多关于正则表达式的信息。学习、构建和调试正则表达式的良好在线资源可以在[https://regexr.com](https://regexr.com)和[https://regex101.com](https://regex101.com)找到。
- en: How to do it...
  id: totrans-655
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In order to verify that a string matches a regular expression, perform the
    following steps:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证一个字符串是否与正则表达式匹配，执行以下步骤：
- en: 'Include the `<regex>` and `<string>` headers and the `std::string_literals`
    namespace for standard user-defined literals for strings (added in C++14):'
  id: totrans-657
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含 `<regex>` 和 `<string>` 头文件以及 `std::string_literals` 命名空间，用于字符串的标准用户定义文字（自
    C++14 开始添加）：
- en: '[PRE103]'
  id: totrans-658
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Use raw string literals to specify the regular expression to avoid escaping
    backslashes (which can occur frequently). The following regular expression validates
    most email formats:'
  id: totrans-659
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用原始字符串文字来指定正则表达式，以避免转义反斜杠（这可能会频繁发生）。以下正则表达式验证大多数电子邮件格式：
- en: '[PRE104]'
  id: totrans-660
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Create an `std::regex`/`std::wregex` object (depending on the character set
    that is used) to encapsulate the regular expression:'
  id: totrans-661
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `std::regex`/`std::wregex` 对象（取决于所使用的字符集）来封装正则表达式：
- en: '[PRE105]'
  id: totrans-662
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'To ignore casing or specify other parsing options, use an overloaded constructor
    that has an extra parameter for regular expression flags:'
  id: totrans-663
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要忽略大小写或指定其他解析选项，请使用具有额外正则表达式标志参数的重载构造函数：
- en: '[PRE106]'
  id: totrans-664
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Use `std::regex_match()` to match the regular expression with an entire string:'
  id: totrans-665
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `std::regex_match()` 将正则表达式与整个字符串匹配：
- en: '[PRE107]'
  id: totrans-666
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: How it works...
  id: totrans-667
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Considering the problem of verifying the format of email addresses, even though
    this may look like a trivial problem, in practice, it is hard to find a simple
    regular expression that covers all the possible cases for valid email formats.
    In this recipe, we will not try to find that ultimate regular expression but,
    rather, apply a regular expression that is good enough for most cases. The regular
    expression we will use for this purpose is this:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到验证电子邮件地址格式的难题，尽管这看起来可能是一个简单的问题，但在实践中，很难找到一个简单的正则表达式来涵盖所有有效的电子邮件格式可能的情况。在这个菜谱中，我们不会尝试找到那个终极的正则表达式，而是应用一个足够大多数情况的正则表达式。我们将用于此目的的正则表达式如下：
- en: '[PRE108]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The following table explains the structure of the regular expression:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格解释了正则表达式的结构：
- en: '| **Part** | **Description** |'
  id: totrans-671
  prefs: []
  type: TYPE_TB
  zh: '| **部分** | **描述** |'
- en: '| `^` | Start of string |'
  id: totrans-672
  prefs: []
  type: TYPE_TB
  zh: '| `^` | 字符串的开始 |'
- en: '| `[A-Z0-9._%+-]+` | At least one character that is an uppercase letter, `A-Z`,
    a digit `0-9`, or one of `.`, `%`, `+`, or `-`, which represents the local part
    of the email address |'
  id: totrans-673
  prefs: []
  type: TYPE_TB
  zh: '| `[A-Z0-9._%+-]+` | 至少一个字符是 uppercase letter `A-Z`，digit `0-9`，或者是 `.`, `%`,
    `+`, 或 `-`，这代表电子邮件地址的本地部分 |'
- en: '| `@` | The character `@` |'
  id: totrans-674
  prefs: []
  type: TYPE_TB
  zh: '| `@` | 字符 `@` |'
- en: '| `[A-Z0-9.-]+` | At least one character that is an uppercase letter `A-Z`,
    a digit `0-9`, or one of the symbols `.` or `-`, which represents the hostname
    of the domain part |'
  id: totrans-675
  prefs: []
  type: TYPE_TB
  zh: '| `[A-Z0-9.-]+` | 至少一个字符是 uppercase letter `A-Z`，digit `0-9`，或者是符号 `.` 或 `-`，这代表域名部分的主机名
    |'
- en: '| `\.` | A dot that separates the domain hostname and label |'
  id: totrans-676
  prefs: []
  type: TYPE_TB
  zh: '| `\.` | 分隔域名主机名和标签的点 |'
- en: '| `[A-Z]{2,}` | The DNS label of a domain, which can have between 2 and 63
    characters |'
  id: totrans-677
  prefs: []
  type: TYPE_TB
  zh: '| `[A-Z]{2,}` | 域名的 DNS 标签，可以包含 2 到 63 个字符 |'
- en: '| `$` | End of the string |'
  id: totrans-678
  prefs: []
  type: TYPE_TB
  zh: '| `$` | 字符串的结束 |'
- en: 'Table 2.14: The structure of the previously defined regular expression'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.14：之前定义的正则表达式的结构
- en: Bear in mind that, in practice, a domain name is composed of a hostname followed
    by a dot-separated list of DNS labels. Examples include `localhost`, `gmail.com`,
    and `yahoo.co.uk`. This regular expression we are using does not match domains
    without DNS labels, such as `localhost` (an email address such as `root@localhost`
    is a valid email address). The domain name can also be an IP address specified
    in brackets, such as `[192.168.100.11]` (as in `john.doe@[192.168.100.11]`). Email
    addresses containing such domains will not match the regular expression defined
    previously. Even though these rather rare formats will not be matched, the regular
    expression can cover most email formats.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在实践中，域名由一个主机名后跟一个点分隔的 DNS 标签列表组成。例如，`localhost`，`gmail.com` 和 `yahoo.co.uk`。我们正在使用的这个正则表达式不匹配没有
    DNS 标签的域名，如 `localhost`（例如，`root@localhost` 是一个有效的电子邮件地址）。域名也可以是一个括号中指定的 IP 地址，如
    `[192.168.100.11]`（如 `john.doe@[192.168.100.11]`）。包含此类域名的电子邮件地址将不会匹配之前定义的正则表达式。尽管这些相当罕见的格式不会匹配，但正则表达式可以涵盖大多数电子邮件格式。
- en: The regular expression for the example in this chapter is provided for didactical
    purposes only and is not intended to be used as it is in production code. As explained
    earlier, this sample does not cover all possible email formats.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 本章示例中的正则表达式仅用于教学目的，并不打算在生产代码中直接使用。如前所述，此示例并不涵盖所有可能的电子邮件格式。
- en: We began by including the necessary headers – that is, `<regex>` for regular
    expressions and `<string>` for strings. The `is_valid_email()` function, shown
    in the following code (which basically contains the samples from the *How to do
    it...* section), takes a string representing an email address and returns a Boolean
    indicating whether the email has a valid format or not.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先包含了必要的头文件——即 `<regex>` 用于正则表达式和 `<string>` 用于字符串。下面的 `is_valid_email()`
    函数（基本上包含 *How to do it...* 部分的示例），接受一个表示电子邮件地址的字符串，并返回一个布尔值，指示电子邮件是否有有效的格式。
- en: 'We first construct an `std::regex` object to encapsulate the regular expression
    indicated with the raw string literal. Using raw string literals is helpful because
    it avoids escaping backslashes, which are used for escape characters in regular
    expressions too. The function then calls `std::regex_match()`, passing the input
    text and the regular expression:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先构造一个 `std::regex` 对象来封装由原始字符串字面量指示的正则表达式。使用原始字符串字面量是有帮助的，因为它避免了转义反斜杠，这在正则表达式中也被用作转义字符。然后函数调用
    `std::regex_match()`，传递输入文本和正则表达式：
- en: '[PRE109]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'The `std::regex_match()` method tries to match the regular expression against
    the entire string. If successful, it returns `true`; otherwise, it returns `false`:'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::regex_match()` 方法尝试将正则表达式与整个字符串进行匹配。如果成功，它返回 `true`；否则，它返回 `false`：'
- en: '[PRE110]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: In this simple test, the only emails that do not match the regular expression
    are `ROOT@LOCALHOST` and `john.doe@domain.com`. The first contains a domain name
    without a dot-prefixed DNS label, and that case is not covered in the regular
    expression. The second contains only lowercase letters, and in the regular expression,
    the valid set of characters for both the local part and the domain name was uppercase
    letters, A to Z.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的测试中，唯一不匹配正则表达式的电子邮件是 `ROOT@LOCALHOST` 和 `john.doe@domain.com`。第一个包含没有点前缀的
    DNS 标签的域名，这种情况在正则表达式中没有涵盖。第二个只包含小写字母，而在正则表达式中，本地部分和域名有效的字符集是 uppercase 字母，A 到
    Z。
- en: Instead of complicating the regular expression with additional valid characters
    (such as `[A-Za-z0-9._%+-]`), we can specify that the match can ignore this case.
    This can be done with an additional parameter to the constructor of the `std::basic_regex`
    class. The available constants for this purpose are defined in the `regex_constants`
    namespace.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以不通过添加额外的有效字符（如 `[A-Za-z0-9._%+-]`）来复杂化正则表达式，而是指定匹配可以忽略大小写。这可以通过向 `std::basic_regex`
    类的构造函数添加一个额外的参数来实现。为此目的而定义的可用常量位于 `regex_constants` 命名空间中。
- en: 'The following slight change to `is_valid_email_format()` will make it ignore
    the case and allow email addresses with both lowercase and uppercase letters to
    correctly match the regular expression:'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 以下对 `is_valid_email_format()` 的微小更改将使其忽略大小写，并允许电子邮件地址包含大小写字母都能正确匹配正则表达式：
- en: '[PRE111]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'This `is_valid_email_format()` function is pretty simple, and if the regular
    expression was provided as a parameter, along with the text to match, it could
    be used for matching anything. However, it would be nice to be able to handle
    not only multi-byte strings (`std::string`) but also wide strings (`std::wstring`),
    with a single function. This can be achieved by creating a function template where
    the character type is provided as a template parameter:'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `is_valid_email_format()` 函数相当简单，如果将正则表达式作为参数提供，并附带要匹配的文本，它可以用于匹配任何内容。然而，如果能通过一个函数处理不仅多字节字符串（`std::string`），而且宽字符串（`std::wstring`），那就更好了。这可以通过创建一个函数模板来实现，其中字符类型作为模板参数提供：
- en: '[PRE112]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'We start by creating an alias template for `std::basic_string` in order to
    simplify its use. The new `is_valid_format()` function is a function template
    very similar to our implementation of `is_valid_email()`. However, we now use
    `std::basic_regex<CharT>` instead of the typedef `std::regex`, which is `std::basic_regex<char>`,
    and the pattern is provided as the first argument. We now implement a new function
    called `is_valid_email_format_w()` for wide strings that relies on this function
    template. The function template, however, can be reused for implementing other
    validations, such as whether a license plate has a particular format:'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先为 `std::basic_string` 创建一个别名模板，以简化其使用。新的 `is_valid_format()` 函数是一个与我们的 `is_valid_email()`
    实现非常相似的函数模板。然而，我们现在使用 `std::basic_regex<CharT>` 而不是 `std::regex` 的 typedef，后者是
    `std::basic_regex<char>`，模式作为第一个参数提供。我们现在实现了一个名为 `is_valid_email_format_w()` 的新函数，用于宽字符串，它依赖于这个函数模板。然而，这个函数模板可以被重用于实现其他验证，例如，检查车牌号是否有特定的格式：
- en: '[PRE113]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Of all the examples shown here, the only one that does not match is `ROOT@LOCALHOST`,
    as expected.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里展示的所有示例中，唯一不符合预期的是 `ROOT@LOCALHOST`。
- en: The `std::regex_match()` method has, in fact, several overloads, and some of
    them have a parameter that is a reference to an `std::match_results` object to
    store the result of the match. If there is no match, then `std::match_results`
    is empty and its size is 0\. Otherwise, if there is a match, the `std::match_results`
    object is not empty and its size is 1, plus the number of matched subexpressions.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::regex_match()` 方法实际上有几个重载版本，其中一些版本有一个参数是 `std::match_results` 对象的引用，用于存储匹配结果。如果没有匹配，则
    `std::match_results` 为空，其大小为0。否则，如果存在匹配，则 `std::match_results` 对象不为空，其大小为1，加上匹配的子表达式数量。'
- en: 'The following version of the function uses the mentioned overloads and returns
    the matched subexpressions in an `std::smatch` object. Note that the regular expression
    is changed as three caption groups are defined – one for the local part, one for
    the hostname part of the domain, and one for the DNS label. If the match is successful,
    then the `std::smatch` object will contain four submatch objects: the first (index
    0) to match the entire string, the second (index 1) for the first capture group
    (the local part), the third (index 2) for the second capture group (the hostname),
    and the fourth (index 3) for the third and last capture group (the DNS label).
    The result is returned in a tuple, where the first item actually indicates success
    or failure:'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 以下版本的函数使用了提到的重载，并将匹配的子表达式返回在一个 `std::smatch` 对象中。请注意，正则表达式已更改，因为定义了三个捕获组——一个用于本地部分，一个用于域名的主机部分，一个用于DNS标签。如果匹配成功，则
    `std::smatch` 对象将包含四个子匹配对象：第一个（索引0）匹配整个字符串，第二个（索引1）匹配第一个捕获组（本地部分），第三个（索引2）匹配第二个捕获组（主机名），第四个（索引3）匹配第三个也是最后一个捕获组（DNS标签）。结果以元组形式返回，其中第一个项目实际上表示成功或失败：
- en: '[PRE114]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Following the preceding code, we use C++17 structured bindings to unpack the
    content of the tuple into named variables:'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码之后，我们使用C++17结构化绑定将元组的内容解包到命名变量中：
- en: '[PRE115]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'The output of the program will be as follows:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出将如下所示：
- en: '![](img/B21549_02_08.png)'
  id: totrans-702
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21549_02_08.png)'
- en: 'Figure 2.8: Output of tests'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8：测试输出
- en: There’s more...
  id: totrans-704
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There are multiple versions of regular expressions, and the C++ standard library
    supports six of them: ECMAScript, basic POSIX, extended POSIX, awk, grep, and
    egrep (grep with the option `-E`). The default grammar used is ECMAScript, and
    in order to use another, you have to explicitly specify the grammar when defining
    the regular expression. You can learn more about the supported grammar options
    at [https://en.cppreference.com/w/cpp/regex/syntax_option_type](https://en.cppreference.com/w/cpp/regex/syntax_option_type).
    In addition to specifying the grammar, you can also specify parsing options, such
    as matching by ignoring the case.'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式有多种版本，C++标准库支持其中的六种：ECMAScript、基本POSIX、扩展POSIX、awk、grep和egrep（带有 `-E` 选项的grep）。默认使用的语法是ECMAScript，若要使用其他语法，必须在定义正则表达式时显式指定语法。您可以在[https://en.cppreference.com/w/cpp/regex/syntax_option_type](https://en.cppreference.com/w/cpp/regex/syntax_option_type)了解更多支持的语法选项。除了指定语法外，还可以指定解析选项，例如忽略大小写进行匹配。
- en: 'The standard library provides more classes and algorithms than we have seen
    so far. The main classes available in the library are as follows (all of them
    are class templates and, for convenience, typedefs are provided for different
    character types):'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库提供的类和算法比我们之前看到的要多。库中可用的主要类如下（所有这些都是类模板，并且为了方便，为不同的字符类型提供了typedefs）：
- en: 'The class template `std::basic_regex` defines the regular expression object:'
  id: totrans-707
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类模板 `std::basic_regex` 定义了正则表达式对象：
- en: '[PRE116]'
  id: totrans-708
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'The class template `std::sub_match` represents a sequence of characters that
    matches a capture group; this class is actually derived from `std::pair`, and
    its `first` and `second` members represent iterators to the first and the one-past-the-end
    characters in the match sequence. If there is no match sequence, the two iterators
    are equal:'
  id: totrans-709
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类模板 `std::sub_match` 表示匹配捕获组的字符序列；这个类实际上是 `std::pair` 的派生类，其 `first` 和 `second`
    成员表示匹配序列中第一个和最后一个字符的迭代器。如果没有匹配序列，则两个迭代器相等：
- en: '[PRE117]'
  id: totrans-710
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'The class template `std::match_results` is a collection of matches; the first
    element is always a full match in the target, while the other elements are matches
    of subexpressions:'
  id: totrans-711
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类模板 `std::match_results` 是匹配结果的集合；第一个元素始终是目标中的完整匹配，而其他元素是子表达式的匹配：
- en: '[PRE118]'
  id: totrans-712
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'The algorithms available in the regular expressions standard library are as
    follows:'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式标准库中可用的算法如下：
- en: '`std::regex_match()`: This tries to match a regular expression (represented
    by an `std::basic_regex` instance) to an entire string.'
  id: totrans-714
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::regex_match()`: 这尝试将一个正则表达式（由一个`std::basic_regex`实例表示）与整个字符串进行匹配。'
- en: '`std::regex_search()`: This tries to match a regular expression (represented
    by an `std::basic_regex` instance) to a part of a string (including the entire
    string).'
  id: totrans-715
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::regex_search()`: 这尝试将一个正则表达式（由一个`std::basic_regex`实例表示）与字符串的一部分（包括整个字符串）进行匹配。'
- en: '`std::regex_replace()`: This replaces matches from a regular expression according
    to a specified format.'
  id: totrans-716
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::regex_replace()`: 这根据指定的格式替换正则表达式中的匹配项。'
- en: 'The iterators available in the regular expressions standard library are as
    follows:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式标准库中可用的迭代器如下：
- en: '`std::regex_interator`: A constant forward iterator used to iterate through
    the occurrences of a pattern in a string. It has a pointer to an `std::basic_regex`
    that must live until the iterator is destroyed. Upon creation and when incremented,
    the iterator calls `std::regex_search()` and stores a copy of the `std::match_results`
    object returned by the algorithm.'
  id: totrans-718
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::regex_iterator`: 一个常量前向迭代器，用于遍历字符串中模式的匹配项。它有一个指向`std::basic_regex`的指针，该指针必须存在于迭代器被销毁之前。在创建和递增时，迭代器调用`std::regex_search()`并存储算法返回的`std::match_results`对象的副本。'
- en: '`std::regex_token_iterator`: A constant forward iterator used to iterate through
    the submatches of every match of a regular expression in a string. Internally,
    it uses a `std::regex_iterator` to step through the submatches. Since it stores
    a pointer to an `std::basic_regex` instance, the regular expression object must
    live until the iterator is destroyed.'
  id: totrans-719
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::regex_token_iterator`: 一个常量前向迭代器，用于遍历字符串中每个正则表达式匹配项的子匹配。内部，它使用`std::regex_iterator`来遍历子匹配。由于它存储了一个指向`std::basic_regex`实例的指针，因此正则表达式对象必须存在于迭代器被销毁之前。'
- en: It should be mentioned that the standard regex library has poorer performance
    compared to other implementations (such as Boost.Regex) and does not support Unicode.
    Moreover, it could be argued that the API itself is cumbersome to use. However,
    using the standard library has the benefit of avoiding additional dependencies.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 应该指出的是，标准正则表达式库的性能比其他实现（如Boost.Regex）较差，并且不支持Unicode。此外，可以争论说API本身使用起来比较繁琐。然而，使用标准库的好处是避免了额外的依赖。
- en: See also
  id: totrans-721
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Parsing the content of a string using regular expressions*, to learn how to
    perform multiple matches of a pattern in a text'
  id: totrans-722
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用正则表达式解析字符串内容*，学习如何在文本中执行多个模式的匹配'
- en: '*Replacing the content of a string using regular expressions*, to see how to
    perform text replacements with the help of regular expressions'
  id: totrans-723
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用正则表达式替换字符串内容*，以了解如何使用正则表达式执行文本替换'
- en: '*Chapter 1*, *Using structured bindings to handle multi-return values*, to
    learn how to bind variables to subobjects or elements from the initializing expressions'
  id: totrans-724
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第一章*，*使用结构化绑定处理多返回值*，学习如何将变量绑定到初始化表达式中的子对象或元素'
- en: Parsing the content of a string using regular expressions
  id: totrans-725
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用正则表达式解析字符串内容
- en: In the previous recipe, we looked at how to use `std::regex_match()` to verify
    that the content of a string matches a particular format. The library provides
    another algorithm called `std::regex_search()` that matches a regular expression
    against any part of a string, and not the entire string, as `regex_match()` does.
    This function, however, does not allow us to search through all the occurrences
    of a regular expression in an input string. For this purpose, we need to use one
    of the iterator classes available in the library.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的菜谱中，我们探讨了如何使用`std::regex_match()`来验证字符串内容是否与特定格式匹配。该库提供了一个名为`std::regex_search()`的另一个算法，它将正则表达式与字符串的任何部分（而不是整个字符串）进行匹配，正如`regex_match()`所做的那样。然而，这个函数不允许我们在输入字符串中搜索正则表达式的所有出现。为此，我们需要使用库中可用的一个迭代器类。
- en: 'In this recipe, you will learn how to parse the content of a string using regular
    expressions. For this purpose, we will consider the problem of parsing a text
    file containing name-value pairs. Each such pair is defined on a different line
    and has the format `name = value`, but lines starting with a `#` represent comments
    and must be ignored. The following is an example:'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习如何使用正则表达式解析字符串的内容。为此，我们将考虑解析包含名称-值对的文本文件的问题。每个这样的对都在不同的行上定义，格式为 `name
    = value`，但以 `#` 开头的行代表注释，必须忽略。以下是一个示例：
- en: '[PRE119]'
  id: totrans-728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Before looking at the implementation details, let’s consider some prerequisites.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看实现细节之前，让我们考虑一些先决条件。
- en: Getting ready
  id: totrans-730
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For general information about regular expression support in C++11, refer to
    the *Verifying the format of a string using regular expressions* recipe earlier
    in this chapter. Basic knowledge of regular expressions is required to proceed
    with this recipe.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 C++11 中正则表达式支持的详细信息，请参阅本章前面提到的 *使用正则表达式验证字符串格式* 菜谱。进行此菜谱需要基本了解正则表达式。
- en: 'In the following examples, `text` is a variable that’s defined as follows:'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，`text` 是一个定义为以下内容的变量：
- en: '[PRE120]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: The sole purpose of this is to simplify our snippets, although, in a real-world
    example, you will probably be reading the text from a file or other source.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 这唯一的目的是为了简化我们的代码片段，尽管在现实世界的例子中，你可能会从文件或其他来源读取文本。
- en: How to do it...
  id: totrans-735
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In order to search for occurrences of a regular expression through a string,
    you should do the following:'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过字符串搜索正则表达式的出现，你应该这样做：
- en: 'Include the headers `<regex>` and `<string>` and the namespace `std::string_literals`
    for standard user-defined literals for strings (added in C++14):'
  id: totrans-737
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含头文件 `<regex>` 和 `<string>` 以及命名空间 `std::string_literals` 以支持字符串的标准用户定义字面量（自
    C++14 开始添加）：
- en: '[PRE121]'
  id: totrans-738
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Use raw string literals (or raw wide string literals for `std::wregex`) to
    specify a regular expression in order to avoid escaping backslashes (which can
    occur frequently). The following regular expression validates the file format
    proposed earlier:'
  id: totrans-739
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用原始字符串字面量（或对于 `std::wregex` 使用原始宽字符串字面量）来指定正则表达式，以避免转义反斜杠（这可能会频繁发生）。以下正则表达式验证了之前提出的文件格式：
- en: '[PRE122]'
  id: totrans-740
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Create an `std::regex`/`std::wregex` object (depending on the character set
    that is used) to encapsulate the regular expression:'
  id: totrans-741
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `std::regex`/`std::wregex` 对象（根据使用的字符集而定）来封装正则表达式：
- en: '[PRE123]'
  id: totrans-742
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'To search for the first occurrence of a regular expression in a given text,
    use the general-purpose algorithm `std::regex_search()` (example 1):'
  id: totrans-743
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在给定的文本中搜索正则表达式的第一个出现，请使用通用算法 `std::regex_search()`（示例 1）：
- en: '[PRE124]'
  id: totrans-744
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'To find all the occurrences of a regular expression in a given text, use the
    iterator `std::regex_iterator` (example 2):'
  id: totrans-745
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在给定的文本中找到所有正则表达式的出现，请使用迭代器 `std::regex_iterator`（示例 2）：
- en: '[PRE125]'
  id: totrans-746
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'To iterate through all the subexpressions of a match, use the iterator `std::regex_token_iterator`
    (example 3):'
  id: totrans-747
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要迭代通过一个匹配的所有子表达式，请使用迭代器 `std::regex_token_iterator`（示例 3）：
- en: '[PRE126]'
  id: totrans-748
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: How it works...
  id: totrans-749
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'A simple regular expression that can parse the input file shown earlier may
    look like this:'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可以解析前面显示的输入文件的简单正则表达式可能看起来像这样：
- en: '[PRE127]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'This regular expression is supposed to ignore all lines that start with a `#`;
    for those that do not start with `#`, match a name followed by the equals sign
    and then a value, which can be composed of alphanumeric characters and several
    other characters (underscore, dot, comma, and so on). The exact meaning of this
    regular expression is explained as follows:'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 这个正则表达式旨在忽略所有以 `#` 开头的行；对于不以 `#` 开头的行，匹配一个名称后跟等号，然后是一个值，该值可以由字母数字字符和几个其他字符（下划线、点、逗号等）组成。这个正则表达式的确切含义如下所述：
- en: '| **Part** | **Description** |'
  id: totrans-753
  prefs: []
  type: TYPE_TB
  zh: '| **部分** | **描述** |'
- en: '| `^` | Start of line |'
  id: totrans-754
  prefs: []
  type: TYPE_TB
  zh: '| `^` | 行首 |'
- en: '| `(?!#)` | A negative lookahead that makes sure that it is not possible to
    match the `#` character |'
  id: totrans-755
  prefs: []
  type: TYPE_TB
  zh: '| `(?!#)` | 一个负向前瞻，确保不可能匹配 `#` 字符 |'
- en: '| `(\w)+` | A capturing group representing an identifier of at least a one-word
    character |'
  id: totrans-756
  prefs: []
  type: TYPE_TB
  zh: '| `(\w)+` | 表示至少一个单词字符的标识符的捕获组 |'
- en: '| `\s*` | Any white spaces |'
  id: totrans-757
  prefs: []
  type: TYPE_TB
  zh: '| `\s*` | 任意空白字符 |'
- en: '| `=` | Equals sign |'
  id: totrans-758
  prefs: []
  type: TYPE_TB
  zh: '| `=` | 等号 |'
- en: '| `\s*` | Any white spaces |'
  id: totrans-759
  prefs: []
  type: TYPE_TB
  zh: '| `\s*` | 任意空白字符 |'
- en: '| `([\w\d]+[\w\d._,\-:]*)` | A capturing group representing a value that starts
    with an alphanumeric character, but can also contain a dot, comma, backslash,
    hyphen, colon, or underscore |'
  id: totrans-760
  prefs: []
  type: TYPE_TB
  zh: '| `([\w\d]+[\w\d._,\-:]*)` | 表示以字母数字字符开头的值，但也可以包含点、逗号、反斜杠、连字符、冒号或下划线等字符的捕获组
    |'
- en: '| `$` | End of line |'
  id: totrans-761
  prefs: []
  type: TYPE_TB
  zh: '| `$` | 行尾 |'
- en: 'Table 2.15: Breaking down the regular expression'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.15：分解正则表达式
- en: We can use `std::regex_search()` to search for a match anywhere in the input
    text. This algorithm has several overloads, but in general, they work in the same
    way. You must specify the range of characters to work through, an output `std::match_results`
    object that will contain the result of the match, and an `std::basic_regex` object
    representing the regular expression and matching flags (which define the way the
    search is done). The function returns `true` if a match was found or `false` otherwise.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `std::regex_search()` 在输入文本的任何位置进行搜索。此算法有几个重载版本，但通常它们的工作方式相同。您必须指定要处理的字符范围、一个输出
    `std::match_results` 对象，该对象将包含匹配结果，以及一个表示正则表达式和匹配标志（定义搜索方式）的 `std::basic_regex`
    对象。如果找到匹配项，函数返回 `true`，否则返回 `false`。
- en: In the first example from the previous section (see the fourth list item), `match`
    is an instance of `std::smatch` that is a typedef of `std::match_results` with
    `string::const_iterator` as the template type. If a match is found, this object
    will contain the matching information in a sequence of values for all matched
    subexpressions. The submatch at index 0 is always the entire match.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节的第一例（见第四个列表项）中，`match` 是 `std::smatch` 的一个实例，它是 `std::match_results` 的一个
    typedef，模板类型为 `string::const_iterator`。如果找到匹配项，此对象将包含所有匹配子表达式的匹配信息序列。索引 0 的子匹配始终是整个匹配。
- en: 'The submatch at index 1 is the first subexpression that was matched, the submatch
    at index 2 is the second subexpression that was matched, and so on. Since we have
    two capturing groups (which are subexpressions) in our regular expression, the
    `std::match_results` will have three submatches in the event of success. The identifier
    representing the name is at index 1, and the value after the equals sign is at
    index 2\. Therefore, this code only prints the following:'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 索引 1 的子匹配是第一个匹配的子表达式，索引 2 的子匹配是第二个匹配的子表达式，依此类推。由于我们的正则表达式中有两个捕获组（即子表达式），在成功的情况下
    `std::match_results` 将有三个子匹配。代表名称的标识符位于索引 1，等号后面的值位于索引 2。因此，此代码只打印以下内容：
- en: '![](img/B21549_02_09.png)'
  id: totrans-766
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21549_02_09.png)'
- en: 'Figure 2.9: Output of the first example'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.9：第一个示例的输出
- en: The `std::regex_search()` algorithm is not able to iterate through all the possible
    matches in a piece of text. To do that, we need to use an iterator. `std::regex_iterator`
    is intended for this purpose. It allows not only iterating through all the matches
    but also accessing all the submatches of a match.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::regex_search()` 算法无法遍历文本中所有可能的匹配项。为了做到这一点，我们需要使用一个迭代器。`std::regex_iterator`
    就是为了这个目的而设计的。它不仅允许遍历所有匹配项，还可以访问匹配项的所有子匹配。'
- en: The iterator actually calls `std::regex_search()` upon construction and on each
    increment, and it remembers the resulting `std::match_results` from the call.
    The default constructor creates an iterator that represents the end of the sequence
    and can be used to test when the loop through the matches should stop.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器实际上在构造和每次递增时都会调用 `std::regex_search()`，并且会记住调用结果中的 `std::match_results`。默认构造函数创建了一个表示序列末尾的迭代器，可以用来测试在遍历匹配时何时应该停止循环。
- en: 'In the second example from the previous section (see the fifth list item),
    we first create an end-of-sequence iterator, and then we start iterating through
    all the possible matches. When constructed, it will call `std::regex_match()`,
    and if a match is found, we can access its results through the current iterator.
    This will continue until no match is found (the end of the sequence). This code
    will print the following output:'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节的第二个示例（见第五个列表项）中，我们首先创建了一个序列末尾的迭代器，然后开始遍历所有可能的匹配项。在构造时，它将调用 `std::regex_match()`，如果找到匹配项，我们可以通过当前迭代器访问其结果。这将一直持续到没有找到匹配项（序列的末尾）。此代码将打印以下输出：
- en: '![](img/B21549_02_10.png)'
  id: totrans-771
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21549_02_10.png)'
- en: 'Figure 2.10: Output of the second example'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10：第二个示例的输出
- en: 'An alternative to `std::regex_iterator` is `std::regex_token_iterator`. This
    works similarly to the way `std::regex_iterator` works and, in fact, it contains
    such an iterator internally, except that it enables us to access a particular
    subexpression from a match. This is shown in the third example in the *How to
    do it...* section (see the sixth list item). We start by creating an end-of-sequence
    iterator and then loop through the matches until the end-of-sequence is reached.
    In the constructor we used, we did not specify the index of the subexpression
    to access through the iterator; therefore, the default value of 0 is used. This
    means this program will print all the matches:'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::regex_iterator` 的一个替代方案是 `std::regex_token_iterator`。它的工作方式与 `std::regex_iterator`
    类似，实际上，它内部包含这样一个迭代器，但它使我们能够访问匹配中的特定子表达式。这在本节中的第三个示例（见第六个列表项）中有所展示。我们首先创建一个序列结束迭代器，然后遍历匹配直到达到序列结束。在构造函数中，我们没有指定通过迭代器访问的子表达式的索引；因此，使用默认值
    0。这意味着这个程序将打印出所有匹配项：'
- en: '![](img/B21549_02_11.png)'
  id: totrans-774
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21549_02_11.png)'
- en: 'Figure 2.11: Output of the third example'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.11：第三个示例的输出
- en: 'If we wanted to access only the first subexpression (this means the names in
    our case), all we had to do was specify the index of the subexpression in the
    constructor of the token iterator, as shown here:'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想访问第一个子表达式（在我们的例子中意味着名称），我们只需在标记迭代器的构造函数中指定子表达式的索引，如下所示：
- en: '[PRE128]'
  id: totrans-777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'This time, the output that we get contains only the names. This is shown in
    the following image:'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们得到的输出只包含名称。如下图所示：
- en: '![](img/B21549_02_12.png)'
  id: totrans-779
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21549_02_12.png)'
- en: 'Figure 2.12: Output containing only the names'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.12：仅包含名称的输出
- en: 'An interesting thing about the token iterator is that it can return the unmatched
    parts of the string if the index of the subexpressions is `-1`, in which case
    it returns an `std::match_results` object that corresponds to the sequence of
    characters between the last match and the end of the sequence:'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 关于标记迭代器的一个有趣之处在于，如果子表达式的索引为 `-1`，它可以返回字符串的不匹配部分，在这种情况下，它返回一个 `std::match_results`
    对象，该对象对应于最后一个匹配项和序列结束之间的字符序列：
- en: '[PRE129]'
  id: totrans-782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'This program will output the following:'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序将输出以下内容：
- en: '![](img/B21549_02_13.png)'
  id: totrans-784
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21549_02_13.png)'
- en: 'Figure 2.13: Output including empty lines'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.13：包括空行的输出
- en: Please note that the empty lines in the output correspond to empty tokens.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，输出中的空行对应于空标记。
- en: See also
  id: totrans-787
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Verifying the format of a string using regular expressions*, to familiarize
    yourself with the C++ library support for working with regular expressions'
  id: totrans-788
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用正则表达式验证字符串格式*，以熟悉 C++ 库对正则表达式工作的支持'
- en: '*Replacing the content of a string using regular expressions*, to learn how
    to perform multiple matches of a pattern in a text'
  id: totrans-789
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用正则表达式替换字符串内容*，以学习如何在文本中执行多个模式匹配'
- en: Replacing the content of a string using regular expressions
  id: totrans-790
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用正则表达式替换字符串内容
- en: In the previous two recipes, we looked at how to match a regular expression
    on a string or a part of a string and iterate through matches and submatches.
    The regular expression library also supports text replacement based on regular
    expressions. In this recipe, we will learn how to use `std::regex_replace()` to
    perform such text transformations.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两个示例中，我们探讨了如何在字符串或字符串的一部分上匹配正则表达式，并遍历匹配和子匹配。正则表达式库还支持基于正则表达式的文本替换。在本例中，我们将学习如何使用
    `std::regex_replace()` 来执行此类文本转换。
- en: Getting ready
  id: totrans-792
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For general information about regular expression support in C++11, refer to
    the *Verifying the format of a string using regular expressions* recipe earlier
    in this chapter.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 C++11 中正则表达式支持的详细信息，请参阅本章早些时候的 *使用正则表达式验证字符串格式* 示例。
- en: How to do it...
  id: totrans-794
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In order to perform text transformations using regular expressions, you should
    perform the following:'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用正则表达式执行文本转换，你应该执行以下操作：
- en: 'Include `<regex>` and `<string>` and the namespace `std::string_literals` for
    C++14 standard user-defined literals for strings:'
  id: totrans-796
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含 `<regex>` 和 `<string>` 以及 `std::string_literals` 命名空间，用于 C++14 标准的字符串用户定义文字：
- en: '[PRE130]'
  id: totrans-797
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Use the `std::regex_replace()` algorithm with a replacement string as the third
    argument. Consider the following example. Replace all words composed of exactly
    three characters that are either `a`, `b`, or `c` with three hyphens:'
  id: totrans-798
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `std::regex_replace()` 算法，并将替换字符串作为第三个参数。考虑以下示例。将所有由 `a`、`b` 或 `c` 组成的恰好三个字符的单词替换为三个连字符：
- en: '[PRE131]'
  id: totrans-799
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Use the `std::regex_replace()` algorithm with match identifiers prefixed with
    a `$` for the third argument. For example, replace names in the format “lastname,
    firstname” with names in the format “firstname lastname”, as follows:'
  id: totrans-800
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用带有`$`前缀的匹配标识符的`std::regex_replace()`算法的第三个参数。例如，将“姓氏，名字”格式的名字替换为“名字 姓氏”格式，如下所示：
- en: '[PRE132]'
  id: totrans-801
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: How it works...
  id: totrans-802
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `std::regex_replace()` algorithm has several overloads with different types
    of parameters, but the meaning of the parameters is as follows:'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::regex_replace()`算法有几个具有不同类型参数的重载，但参数的意义如下：'
- en: The input string on which the replacement is performed
  id: totrans-804
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行替换的输入字符串
- en: An `std::basic_regex` object that encapsulates the regular expression used to
    identify the parts of the strings to be replaced
  id: totrans-805
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个封装用于识别要替换的字符串部分的正则表达式的`std::basic_regex`对象
- en: The string format used for replacement
  id: totrans-806
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于替换的字符串格式
- en: Optional matching flags
  id: totrans-807
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的匹配标志
- en: 'The return value is, depending on the overload used, either a string or a copy
    of the output iterator provided as an argument. The string format used for replacement
    can either be a simple string or a match identifier, indicated with a `$` prefix:'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值取决于使用的重载，可以是字符串或作为参数提供的输出迭代器的副本。用于替换的字符串格式可以是简单的字符串或带有`$`前缀的匹配标识符：
- en: '`$&` indicates the entire match.'
  id: totrans-809
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$&`表示整个匹配。'
- en: '`$1`, `$2`, `$3`, and so on indicate the first, second, and third submatches,
    and so on.'
  id: totrans-810
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$1`、`$2`、`$3`等表示第一个、第二个和第三个子匹配等。'
- en: '`` $` `` indicates the part of the string before the first match.'
  id: totrans-811
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`` $` ``表示字符串中第一个匹配之前的部分。'
- en: '`$''` indicates the part of the string after the last match.'
  id: totrans-812
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$''`表示字符串中最后一个匹配之后的部分。'
- en: 'In the first example shown in the *How to do it...* section, the initial text
    contains two words made of exactly three `a`, `b`, and `c` characters: `abc` and
    `bca`. The regular expression indicates an expression of exactly three characters
    between word boundaries. This means a subtext, such as `bbbb`, will not match
    the expression. The result of the replacement is that the string text will be
    `--- aa --- ca bbbb`.'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 在“如何做...”部分展示的第一个示例中，初始文本包含由恰好三个`a`、`b`和`c`字符组成的两个单词：`abc`和`bca`。正则表达式表示在单词边界之间的恰好三个字符的表达式。这意味着像`bbbb`这样的子文本不会与表达式匹配。替换的结果是字符串文本将变为`---
    aa --- ca bbbb`。
- en: 'Additional flags for the match can be specified for the `std::regex_replace()`
    algorithm. By default, the matching flag is `std::regex_constants::match_default`,
    which basically specifies ECMAScript as the grammar used for constructing the
    regular expression. If we want, for instance, to replace only the first occurrence,
    then we can specify `std::regex_constants::format_first_only`. In the following
    example, the result is `--- aa bca ca bbbb` as the replacement stops after the
    first match is found:'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 可以为`std::regex_replace()`算法指定额外的匹配标志。默认情况下，匹配标志是`std::regex_constants::match_default`，这基本上指定了ECMAScript作为构建正则表达式所使用的语法。如果我们想，例如，只替换第一次出现的内容，那么我们可以指定`std::regex_constants::format_first_only`。在下面的示例中，结果是替换后的字符串为`---
    aa bca ca bbbb`，因为替换在找到第一个匹配后停止：
- en: '[PRE133]'
  id: totrans-815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: The replacement string, however, can contain special indicators for the whole
    match, a particular submatch, or the parts that were not matched, as explained
    earlier. In the second example shown in the *How to do it...* section, the regular
    expression identifies a word of at least one character, followed by a comma and
    possible white spaces, and then another word of at least one character. The first
    word is supposed to be the last name, while the second word is supposed to be
    the first name. The replacement string is in the `$2 $1` format. This is an instruction
    that’s used to replace the matched expression (in this example, the entire original
    string) with another string formed of the second submatch, followed by a space,
    and then the first submatch.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，替换字符串可以包含特殊指示符，用于整个匹配、特定的子匹配或未匹配的部分，如前所述。在“如何做...”部分展示的第二个示例中，正则表达式识别一个至少包含一个字符的单词，后面跟一个逗号和可能的空白字符，然后是另一个至少包含一个字符的单词。第一个单词应该是姓氏，而第二个单词应该是名字。替换字符串采用`$2
    $1`格式。这是一条用于将匹配的表达式（在这个例子中是整个原始字符串）替换为另一个字符串的指令，该字符串由第二个子匹配组成，后面跟一个空格，然后是第一个子匹配。
- en: 'In this case, the entire string was a match. In the following example, there
    will be multiple matches inside the string, and they will all be replaced with
    the indicated string. In this example, we are replacing the indefinite article
    *a* when preceding a word that starts with a vowel (this, of course, does not
    cover words that start with a vowel sound) with the indefinite article *an*:'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，整个字符串都是匹配的。在下面的例子中，字符串内部将有多个匹配，并且它们都将被替换为指定的字符串。在这个例子中，我们正在替换以元音字母开头的单词（当然，这并不包括以元音音素开头的单词）前的不定冠词
    *a*，将其替换为不定冠词 *an*：
- en: '[PRE134]'
  id: totrans-818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: The regular expression identifies the letter *a* as a single word (`\b` indicates
    a word boundary, so `\ba` means a word with a single letter, *a*), followed by
    a space and a word of at least two characters starting with a vowel. When such
    a match is identified, it is replaced with a string formed of the fixed string
    *an*, followed by a space and the first subexpression of the match, which is the
    word itself. In this example, the `newtext` string will be `this is an example
    with an error`.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式将字母 *a* 识别为一个单独的单词（`\b` 表示单词边界，所以 `\ba` 表示一个只有一个字母的单词，*a*），后面跟着一个空格和一个至少有两个字符且以元音字母开头的单词。当识别到这样的匹配时，它将被替换为一个由固定字符串
    *an* 后跟一个空格和匹配的第一个子表达式组成的字符串，即单词本身。在这个例子中，`newtext` 字符串将是 `this is an example
    with an error`。
- en: 'Apart from the identifiers of the subexpressions (`$1`, `$2`, and so on), there
    are other identifiers for the entire match (`$&`), the part of the string before
    the first match (`` $` ``), and the part of the string after the last match (`$''`).
    In the last example, we change the format of a date from `dd.mm.yyyy` to `yyyy.mm.dd`,
    but also show the matched parts:'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 除了子表达式的标识符（`$1`、`$2` 等等）之外，还有整个匹配的标识符（`$&`）、第一个匹配之前字符串的部分（`$`），以及最后一个匹配之后字符串的部分（`$'`）。在最后一个例子中，我们将日期的格式从
    `dd.mm.yyyy` 更改为 `yyyy.mm.dd`，同时也显示了匹配的部分：
- en: '[PRE135]'
  id: totrans-821
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: The regular expression matches a one- or two-digit number followed by a dot,
    hyphen, or slash; followed by another one- or two-digit number; then a dot, hyphen,
    or slash; and lastly, a four-digit number. Keep in mind this is only an example,
    and there are better expressions for parsing a date.
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式匹配一个一位或两位数字后跟一个点、连字符或斜杠；然后是另一个一位或两位数字；然后是一个点、连字符或斜杠；最后是一个四位数。请记住，这只是一个例子，并且有更好的表达式可以用来解析日期。
- en: For `newtext1`, the replacement string is `$5$4$3$2$1`; this means year, followed
    by the second separator, then month, the first separator, and finally, day. Therefore,
    for the input string `today is 1.06.2023!`, the result is `today is 2023.06.1!!`.
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `newtext1`，替换字符串是 `$5$4$3$2$1`；这意味着年份，然后是第二个分隔符，然后是月份，第一个分隔符，最后是日期。因此，对于输入字符串
    `today is 1.06.2023!`，结果是 `today is 2023.06.1!!`。
- en: For `newtext2`, the replacement string is ``[$`][$&][$']``; this means the part
    before the first match, followed by the entire match, and finally, the part after
    the last match are in square brackets. However, the result is not `[!!][1.06.2023][today
    is ]` as you perhaps might expect at first glance, but `today is [today is ][1.06.2023][!!]!!`.
    The reason for this is that what is replaced is the matched expression, and, in
    this case, that is only the date (`1.06.2023`). This substring is replaced with
    another string formed of all the parts of the initial string.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `newtext2`，替换字符串是 ``[$`][$&][$']``；这意味着第一个匹配之前的部分，然后是整个匹配，最后是最后一个匹配之后的部分都放在方括号中。然而，结果并不是你一开始可能期望的
    `[!!][1.06.2023][today is ]`，而是 `today is [today is ][1.06.2023][!!]!!`。这是因为被替换的是匹配的表达式，在这种情况下，只有日期
    (`1.06.2023`)。这个子字符串被替换为另一个由初始字符串的所有部分组成的字符串。
- en: See also
  id: totrans-825
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Verifying the format of a string using regular expressions*, to familiarize
    yourself with the C++ library support for working with regular expressions'
  id: totrans-826
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用正则表达式验证字符串的格式*，以便熟悉C++库对正则表达式工作的支持'
- en: '*Parsing the content of a string using regular expressions*, to learn how to
    perform multiple matches of a pattern in a text'
  id: totrans-827
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用正则表达式解析字符串内容*，以学习如何在文本中执行多个模式的匹配'
- en: Using std::string_view instead of constant string references
  id: totrans-828
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 std::string_view 而不是常量字符串引用
- en: When working with strings, temporary objects are created all the time, even
    if you might not be really aware of it. Many times, these temporary objects are
    irrelevant and only serve the purpose of copying data from one place to another
    (for example, from a function to its caller). This represents a performance issue
    because they require memory allocation and data copying, which should be avoided.
    For this purpose, the C++17 standard provides a new string class template called
    `std::basic_string_view`, which represents a non-owning constant reference to
    a string (that is, a sequence of characters). In this recipe, you will learn when
    and how you should use this class.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理字符串时，会不断创建临时对象，即使你可能并没有真正意识到这一点。很多时候，这些临时对象都是无关紧要的，它们仅仅是为了将数据从一个地方复制到另一个地方（例如，从一个函数到其调用者）而服务的。这代表了一个性能问题，因为它们需要内存分配和数据复制，这些都应该尽量避免。为此，C++17
    标准提供了一个新的字符串类模板，称为 `std::basic_string_view`，它表示对字符串的非拥有常量引用（即，字符序列）。在本食谱中，你将学习何时以及如何使用这个类。
- en: Getting ready
  id: totrans-830
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `string_view` class is available in the namespace `std` in the `string_view`
    header.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: '`string_view` 类在 `string_view` 头文件中的 `std` 命名空间中可用。'
- en: How to do it...
  id: totrans-832
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'You should use `std::string_view` to pass a parameter to a function (or return
    a value from a function), instead of `std::string const &`, unless your code needs
    to call other functions that take `std::string` parameters (in which case, conversions
    would be necessary):'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该使用 `std::string_view` 来向函数传递参数（或从函数返回值），而不是 `std::string const &`，除非你的代码需要调用其他接受
    `std::string` 参数的函数（在这种情况下，需要进行转换）：
- en: '[PRE136]'
  id: totrans-834
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: How it works...
  id: totrans-835
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Before we look at how the new string type works, let’s consider the following
    example of a function that is supposed to extract the name of a file without its
    extension. This is basically how you would write the function from the previous
    section before C++17:'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看新的字符串类型是如何工作之前，让我们考虑以下一个函数的例子，该函数旨在提取不带扩展名的文件名。这基本上是在 C++17 之前你会如何编写该函数：
- en: '[PRE137]'
  id: totrans-837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Note that, in this example, the file separator is `\` (backslash), as in Windows.
    For Linux-based systems, it has to be changed to `/` (slash).
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个例子中，文件分隔符是 `\`（反斜杠），就像在 Windows 中一样。对于基于 Linux 的系统，它必须更改为 `/`（斜杠）。
- en: The `get_filename()` function is relatively simple. It takes a constant reference
    to an `std::string` and identifies a substring bounded by the last file separator
    and the last dot, which basically represents a filename without an extension (and
    without folder names).
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_filename()` 函数相对简单。它接受一个对 `std::string` 的常量引用，并识别由最后一个文件分隔符和最后一个点界定的子串，这基本上代表了一个不带扩展名（以及不带文件夹名称）的文件名。'
- en: The problem with this code, however, is that it creates one, two, or possibly
    even more temporaries, depending on the compiler optimizations. The function parameter
    is a constant `std::string` reference, but the function is called with a string
    literal, which means `std::string` needs to be constructed from the literal. These
    temporaries need to allocate and copy data, which is both time- and resource-consuming.
    In the last example, all we want to do is check whether the first character of
    the filename is an underscore, but we create at least two temporary string objects
    for that purpose.
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个代码的问题在于，它根据编译器的优化程度创建了一个、两个，甚至可能更多的临时对象。函数参数是一个常量 `std::string` 引用，但函数是用字符串字面量调用的，这意味着
    `std::string` 需要从字面量构造。这些临时对象需要分配和复制数据，这既耗时又消耗资源。在最后一个例子中，我们只想检查文件名的第一个字符是否是下划线，但我们为此创建了至少两个临时字符串对象。
- en: 'The `std::basic_string_view` class template is intended to solve this problem.
    This class template is very similar to `std::basic_string`, with the two having
    almost the same interface. The reason for this is that `std::basic_string_view`
    is intended to be used instead of a constant reference to an `std::basic_string`
    without further code changes. Just like with `std::basic_string`, there are specializations
    for all types of standard characters:'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::basic_string_view` 类模板旨在解决这个问题。这个类模板与 `std::basic_string` 非常相似，两者几乎有相同的接口。这是因为
    `std::basic_string_view` 的目的是在不进行进一步代码更改的情况下替代对 `std::basic_string` 的常量引用。就像 `std::basic_string`
    一样，它为所有标准字符类型都有特殊化：'
- en: '[PRE138]'
  id: totrans-842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: The `std::basic_string_view` class template defines a reference to a constant
    contiguous sequence of characters. As the name implies, it represents a view and
    cannot be used to modify the reference sequence of characters. An `std::basic_string_view`
    object has a relatively small size because all it needs is a pointer to the first
    character in the sequence and the length. It can be constructed not only from
    an `std::basic_string` object but also from a pointer and a length, or from a
    null-terminated sequence of characters (in which case, it will require an initial
    traversal of the string in order to find the length). Therefore, the `std::basic_string_view`
    class template can also be used as a common interface for multiple types of strings
    (as long as data only needs to be read). On the other hand, converting from an
    `std::basic_string_view` to an `std::basic_string` is not possible.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::basic_string_view` 类模板定义了对一个连续字符序列的引用。正如其名所示，它代表了一个视图，不能用来修改字符序列的引用。一个
    `std::basic_string_view` 对象具有相对较小的尺寸，因为它只需要一个指向序列中第一个字符的指针和长度。它可以从一个 `std::basic_string`
    对象构建，也可以从一个指针和长度构建，或者从一个以空字符终止的字符序列（在这种情况下，它将需要遍历字符串以找到长度）。因此，`std::basic_string_view`
    类模板也可以用作多种字符串类型的通用接口（只要数据只需要被读取）。另一方面，从 `std::basic_string_view` 转换到 `std::basic_string`
    是不可能的。'
- en: 'You must explicitly construct an `std::basic_string` object from a `std::basic_string_view`,
    as shown in the following example:'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须显式地从 `std::basic_string_view` 构造一个 `std::basic_string` 对象，如下例所示：
- en: '[PRE139]'
  id: totrans-845
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: Passing `std::basic_string_view` to functions and returning `std::basic_string_view`
    still creates temporaries of this type, but these are small-sized objects on the
    stack (a pointer and a size could be 16 bytes for 64-bit platforms); therefore,
    they should incur fewer performance costs than allocating heap space and copying
    data.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `std::basic_string_view` 传递给函数并返回 `std::basic_string_view` 仍然会创建这种类型的临时对象，但这些是在栈上的小尺寸对象（在64位平台上，一个指针和大小可能为16字节）；因此，它们应该比分配堆空间和复制数据产生更少的性能成本。
- en: Note that all major compilers provide an implementation of `std::basic_string`,
    which includes a small string optimization. Although the implementation details
    are different, they typically rely on having a statically allocated buffer of
    a number of characters (16 for VC++ and GCC 5 or newer) that does not involve
    heap operations, which are only required when the size of the string exceeds that
    number of characters.
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有主要编译器都提供了 `std::basic_string` 的实现，这包括一个小字符串优化。尽管实现细节不同，但它们通常依赖于具有一定数量的字符的静态分配缓冲区（对于VC++和GCC
    5或更新的版本为16），这不需要堆操作，只有当字符串的大小超过这个数字时才需要堆操作。
- en: 'In addition to the methods that are identical to those available in `std::basic_string`,
    the `std::basic_string_view` has two more:'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 除了与 `std::basic_string` 中可用的方法相同的方法外，`std::basic_string_view` 还有两个更多：
- en: '`remove_prefix()`: Shrinks the view by incrementing the start with *N* characters
    and decrementing the length with *N* characters'
  id: totrans-849
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove_prefix()`: 通过增加起始位置*N*个字符和减少长度*N*个字符来缩小视图'
- en: '`remove_suffix()`: Shrinks the view by decrementing the length with *N* characters'
  id: totrans-850
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove_suffix()`: 通过减少长度来缩小视图，长度减少*N*个字符'
- en: 'The two member functions are used in the following example to trim spaces from
    an `std::string_view`, both at the beginning and the end. The implementation of
    the function first looks for the first element that is not a space and then for
    the last element that is not a space. Then, it removes from the end everything
    after the last non-space character, and from the beginning, everything until the
    first non-space character. The function returns the new view, trimmed at both
    ends:'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，这两个成员函数用于从 `std::string_view` 中修剪空格，包括开头和结尾。函数的实现首先查找第一个不是空格的元素，然后查找最后一个不是空格的元素。然后，它从末尾移除最后一个非空格字符之后的所有内容，并从开头移除直到第一个非空格字符的所有内容。函数返回修剪两端的新视图：
- en: '[PRE140]'
  id: totrans-852
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'When using `std::basic_string_view`, you must be aware of two things: you cannot
    change the underlying data referred to by a view and you must manage the lifetime
    of the data, as the view is a non-owning reference.'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `std::basic_string_view` 时，你必须注意两件事：你不能更改视图所引用的底层数据，你必须管理数据的生命周期，因为视图是一个非拥有引用。
- en: See also
  id: totrans-854
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Creating a library of string helpers*, to see how to create useful text utilities
    that are not directly available in the standard library'
  id: totrans-855
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建字符串辅助库*，以了解如何创建有用的文本实用工具，这些实用工具在标准库中不可直接使用'
- en: Formatting and printing text with std::format and std::print
  id: totrans-856
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用std::format和std::print格式化和打印文本
- en: 'The C++ language has two ways of formatting text: the `printf` family of functions
    and the I/O streams library. The `printf` functions are inherited from C and provide
    a separation of the formatting text and the arguments. The streams library provides
    safety and extensibility and is usually recommended over `printf` functions, but
    is, in general, slower. The C++20 standard proposes a new formatting library alternative
    for output formatting, which is similar in form to `printf` but safe and extensible
    and is intended to complement the existing streams library. In this recipe, we
    will learn how to use the new functionalities instead of the `printf` functions
    or the streams library.'
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: C++语言有两种格式化文本的方式：`printf`函数族和I/O流库。`printf`函数是从C继承而来的，提供了格式文本和参数的分离。流库提供了安全性和可扩展性，通常比`printf`函数更推荐，但通常速度较慢。C++20标准提出了一个新的输出格式化库替代方案，其形式类似于`printf`，但更安全、更可扩展，旨在补充现有的流库。在本食谱中，我们将学习如何使用新的功能，而不是使用`printf`函数或流库。
- en: Getting ready
  id: totrans-858
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The new formatting library is available in the `<format>` header. You must include
    this header for the following samples to work.
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 新的格式化库在`<format>`头文件中可用。你必须包含此头文件，以下示例才能正常工作。
- en: How to do it...
  id: totrans-860
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The `std::format()` function formats its arguments according to the provided
    formatting string. You can use it as follows:'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::format()`函数根据提供的格式字符串格式化其参数。你可以如下使用它：'
- en: 'Provide empty replacement fields, represented by `{}`, in the format string
    for each argument:'
  id: totrans-862
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在格式字符串中为每个参数提供空替换字段，表示为`{}`：
- en: '[PRE141]'
  id: totrans-863
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Specify the 0-based index of each argument in the argument list inside the
    replacement field, such as `{0}`, `{1}`, and so on. The order of the arguments
    is not important, but the index must be valid:'
  id: totrans-864
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在替换字段内指定参数列表中每个参数的0基于索引，例如`{0}`、`{1}`等。参数的顺序不重要，但索引必须是有效的：
- en: '[PRE142]'
  id: totrans-865
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Control the output text with format specifiers provided in the replacement
    field after a colon (`:`). For basic and string types, this is a standard format
    specification. For chrono types, this is a chrono format specification:'
  id: totrans-866
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用冒号（`:`）之后替换字段中提供的格式说明符来控制输出文本。对于基本和字符串类型，这是一个标准格式说明符。对于chrono类型，这是一个chrono格式说明符：
- en: '[PRE143]'
  id: totrans-867
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'You can also write the arguments in an out format using an iterator with either
    `std::format_to()` or `std::format_to_n()`, as follows:'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`std::format_to()`或`std::format_to_n()`通过迭代器以输出格式写入参数，如下所示：
- en: 'Write to a buffer, such as an `std::string` or `std::vector<char>`, using `std::format_n()`
    and using the `std::back_inserter()` helper function:'
  id: totrans-869
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::format_n()`和`std::back_inserter()`辅助函数将内容写入缓冲区，例如`std::string`或`std::vector<char>`：
- en: '[PRE144]'
  id: totrans-870
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Use `std::formatted_size()` to retrieve the number of characters necessary
    to store the formatted representation of the arguments:'
  id: totrans-871
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`std::formatted_size()`检索存储参数格式化表示所需的字符数：
- en: '[PRE145]'
  id: totrans-872
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'To limit the number of characters written to the output buffer, you can use
    `std::format_to_n()`, which is similar to `std::format_to()` but writes, at most,
    `n` characters:'
  id: totrans-873
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要限制写入输出缓冲区的字符数，你可以使用`std::format_to_n()`，它与`std::format_to()`类似，但最多写入`n`个字符：
- en: '[PRE146]'
  id: totrans-874
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'In C++23, you can write formatted text directly to a file stream, such as the
    standard output console, using the following functions from the new `<print>`
    header:'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++23中，你可以使用新`<print>`头文件中的以下函数直接将格式化文本写入文件流，例如标准输出控制台：
- en: '`std::print`, to write the arguments according to the format string:'
  id: totrans-876
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::print`，用于根据格式字符串写入参数：'
- en: '[PRE147]'
  id: totrans-877
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '`std::println`, to write the arguments according to the format string followed
    by a new line character (`''\n''`):'
  id: totrans-878
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::println`，用于根据格式字符串后跟一个换行符（`''\n''`）写入参数：'
- en: '[PRE148]'
  id: totrans-879
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: How it works...
  id: totrans-880
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `std::format()` function has multiple overloads. You can specify the format
    string either as a string view or a wide string view, with the function returning
    either an `std::string` or an `std::wstring`. You can also specify, as the first
    argument, an `std::locale`, which is used for locale-specific formatting. The
    function overloads are all variadic function templates, which means you can specify
    any number of arguments after the format.
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::format()`函数有多个重载。你可以指定格式字符串为字符串视图或宽字符串视图，函数返回`std::string`或`std::wstring`。你也可以指定第一个参数为一个`std::locale`，它用于特定区域设置的格式化。函数重载都是变参函数模板，这意味着你可以在格式之后指定任意数量的参数。'
- en: The format string consists of ordinary characters, replacement fields, and escape
    sequences. The escape sequences are `{{` and `}}` and are replaced with `{` and
    `}` in the output. A replacement field is provided within curly brackets `{}`.
    It can optionally contain a non-negative number, representing the 0-based index
    of the argument to be formatted, and a colon (`:`), followed by a format specifier.
    If the format specifier is invalid, an exception of the type `std::format_error`
    is thrown.
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 格式字符串由普通字符、替换字段和转义序列组成。转义序列是 `{{` 和 `}}`，在输出中它们被替换为 `{` 和 `}`。替换字段在花括号 `{}`
    内提供。它可以包含一个非负数，表示要格式化的参数的0基于索引，后跟一个冒号（`:`），然后是一个格式规范。如果格式规范无效，则抛出 `std::format_error`
    类型的异常。
- en: In a similar manner, `std::format_to()` has multiple overloads, just like `std::format()`.
    The difference between these two is that `std::format_to()` always takes an iterator
    to the output buffer as the first argument and returns an iterator past the end
    of the output range (and not a string as `std::format()` does). On the other hand,
    `std::format_to_n()` has one more parameter than `std::format_to()`. Its second
    parameter is a number representing the maximum number of characters to be written
    to the buffer.
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`std::format_to()` 有多个重载，就像 `std::format()` 一样。这两个函数的区别在于 `std::format_to()`
    总是接受输出缓冲区的迭代器作为第一个参数，并返回输出范围的末尾之后的迭代器（而不是 `std::format()` 所做的字符串）。另一方面，`std::format_to_n()`
    比 `std::format_to()` 多一个参数。它的第二个参数是一个表示要写入缓冲区的最大字符数的数字。
- en: 'The following listing shows the signature of the simplest overload of each
    of these three function templates:'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了这三个函数模板最简单重载的签名：
- en: '[PRE149]'
  id: totrans-885
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: When you provide the format string, you can supply argument identifiers (their
    0-based index) or omit them. However, it is illegal to use both. If the indexes
    are omitted in the replacement fields, the arguments are processed in the provided
    order, and the number of replacement fields must not be greater than the number
    of supplied arguments. If indexes are provided, they must be valid for the format
    string to be valid.
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 当你提供格式字符串时，你可以提供参数标识符（它们的0基于索引）或省略它们。然而，同时使用两者是不合法的。如果省略了替换字段中的索引，则按提供的顺序处理参数，并且替换字段的数量不得大于提供的参数数量。如果提供了索引，它们必须对格式字符串有效。
- en: 'When a format specification is used, then:'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用格式规范时：
- en: For basic types and string types, it is considered to be a standard format specification.
  id: totrans-888
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于基本类型和字符串类型，它被认为是标准格式规范。
- en: For chrono types, it is considered to be a chrono format specification.
  id: totrans-889
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于chrono类型，它被认为是chrono格式规范。
- en: For user-defined types, it is defined by a user-defined specialization of the
    `std::formatter` class for the desired type.
  id: totrans-890
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于用户定义的类型，它由用户定义的 `std::formatter` 类的特化来定义，该特化针对所需类型。
- en: 'The standard format specification is based on the format specification in Python
    and has the following syntax:'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 标准格式规范基于Python中的格式规范，具有以下语法：
- en: '[PRE150]'
  id: totrans-892
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: These syntax parts are briefly described here.
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 这些语法部分在此简要描述。
- en: '`fill-and-align` is an optional fill character, followed by one of the align
    options:'
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: '`fill-and-align` 是一个可选的填充字符，后跟一个对齐选项：'
- en: '`<`: Forces the field to be left-aligned with the available space.'
  id: totrans-895
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<`: 强制字段与可用空间左对齐。'
- en: '`>`: Forces the field to be right-aligned with the available space.'
  id: totrans-896
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>`: 强制字段与可用空间右对齐。'
- en: '`^`: Forces the field to be centered with the available space. To do so, it
    will insert n/2 characters to the left and n/2 characters to the right:'
  id: totrans-897
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`^`: 强制字段与可用空间居中对齐。为此，它将在左侧插入 n/2 个字符，在右侧插入 n/2 个字符：'
- en: '[PRE151]'
  id: totrans-898
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '`sign`, `#`, and `0` are only valid when a number (either an integer or a floating-point)
    is used. The sign can be one of:'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: '`sign`, `#`, 和 `0` 仅在数字（整数或浮点数）使用时有效。符号可以是以下之一：'
- en: '`+`: Specifies that the sign must be used for both negative and positive numbers'
  id: totrans-900
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+`: 指定对于负数和正数都必须使用符号'
- en: '`-`: Specifies that the sign must be used only for negative numbers (which
    is the implicit behavior)'
  id: totrans-901
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-`: 指定仅对负数使用符号（这是隐式行为）'
- en: 'A space: Specifies that the sign must be used for negative numbers and that
    a leading space must be used for non-negative numbers:'
  id: totrans-902
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个空格：指定对于负数必须使用符号，并且对于非负数必须使用前导空格：
- en: '[PRE152]'
  id: totrans-903
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'The `#` symbol causes the alternate form to be used. This can be one of the
    following:'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: '`#` 符号会导致使用交替形式。这可以是以下之一：'
- en: For integral types, when binary, octal, or hexadecimal representation is specified,
    the alternate form adds the prefix `0b`, `0`, or `0x` to the output.
  id: totrans-905
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于整型，当指定二进制、八进制或十六进制表示时，交替形式会在输出前添加前缀 `0b`、`0` 或 `0x`。
- en: For floating-point types, the alternate form causes a decimal-point character
    to always be present in the formatted value, even if no digits follow it. In addition,
    when `g` or `G` are used, the trailing zeros are not removed from the output.
  id: totrans-906
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于浮点类型，交替形式会导致格式化值中始终存在小数点字符，即使后面没有数字。此外，当使用 `g` 或 `G` 时，输出中不会移除尾随零。
- en: 'The digit `0` specifies that leading zeros should be outputted to the field
    width, except when the value of a floating-point type is infinity or `NaN`. When
    present alongside an align option, the specifier `0` is ignored:'
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 数字 `0` 指定应该输出前导零到字段宽度，除非浮点类型的值为无穷大或 `NaN`。当与对齐选项一起出现时，指定符 `0` 被忽略：
- en: '[PRE153]'
  id: totrans-908
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '`width` specifies the minimum field width and can be either a positive decimal
    number or a nested replacement field. The `precision` field indicates the precision
    for floating-point types or, for string types, how many characters will be used
    from the string. It is specified with a dot (`.`), followed by a non-negative
    decimal number or a nested replacement field.'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: '`width` 指定最小字段宽度，可以是正的十进制数或嵌套替换字段。`precision` 字段表示浮点类型的精度或对于字符串类型，将使用多少个字符。它用一个点（`.`）后跟一个非负十进制数或嵌套替换字段来指定。'
- en: Locale-specific formatting is specified with the uppercase `L` and causes the
    locale-specific form to be used. This option is only available for arithmetic
    types.
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 使用大写 `L` 指定区域特定的格式化，这将导致使用区域特定的格式。此选项仅适用于算术类型。
- en: 'The optional `type` determines how the data will be presented in the output.
    The available string presentation types are shown in the following table:'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的 `type` 决定了数据在输出中的表示方式。以下表格显示了可用的字符串表示类型：
- en: '| **Type** | **Presentation type** | **Description** |'
  id: totrans-912
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **表示类型** | **描述** |'
- en: '| Strings | none, `s` | Copies the string to the output. |'
  id: totrans-913
  prefs: []
  type: TYPE_TB
  zh: '| 字符串 | 无、`s` | 将字符串复制到输出。 |'
- en: '| Integral types | `b` | Binary format with 0b as a prefix. |'
  id: totrans-914
  prefs: []
  type: TYPE_TB
  zh: '| 整型 | `b` | 带前缀 0b 的二进制格式。 |'
- en: '| `B` | Binary format with 0B as a prefix. |'
  id: totrans-915
  prefs: []
  type: TYPE_TB
  zh: '| `B` | 带前缀 0B 的二进制格式。 |'
- en: '| `C` | Character format. Copies the value to the output as it was a character
    type. |'
  id: totrans-916
  prefs: []
  type: TYPE_TB
  zh: '| `C` | 字符格式。将值作为字符类型复制到输出。 |'
- en: '| none or `d` | Decimal format. |'
  id: totrans-917
  prefs: []
  type: TYPE_TB
  zh: '| 无或 `d` | 十进制格式。 |'
- en: '| `O` | Octal format with 0 as a prefix (unless the value is 0). |'
  id: totrans-918
  prefs: []
  type: TYPE_TB
  zh: '| `O` | 带前缀 0 的八进制格式（除非值为 0）。 |'
- en: '| `x` | Hexadecimal format with 0x as a prefix. |'
  id: totrans-919
  prefs: []
  type: TYPE_TB
  zh: '| `x` | 带前缀 0x 的十六进制格式。 |'
- en: '| `X` | Hexadecimal format with 0X as a prefix. |'
  id: totrans-920
  prefs: []
  type: TYPE_TB
  zh: '| `X` | 带前缀 0X 的十六进制格式。 |'
- en: '| `char` and `wchar_t` | none or `c` | Copies the character to the output.
    |'
  id: totrans-921
  prefs: []
  type: TYPE_TB
  zh: '| `char` 和 `wchar_t` | 无或 `c` | 将字符复制到输出。 |'
- en: '| `b`, `B`, `c`, `d`, `o`, `x`, `X` | Integer presentation types. |'
  id: totrans-922
  prefs: []
  type: TYPE_TB
  zh: '| `b`、`B`、`c`、`d`、`o`、`x`、`X` | 整数表示类型。 |'
- en: '| `bool` | none or `s` | Copies true or false as a textual representation (or
    their local-specific form) to the output. |'
  id: totrans-923
  prefs: []
  type: TYPE_TB
  zh: '| `bool` | 无或 `s` | 将 true 或 false 作为文本表示（或其区域特定的形式）复制到输出。 |'
- en: '| `b`, `B`, `c`, `d`, `o`, `x`, `X` | Integer presentation types. |'
  id: totrans-924
  prefs: []
  type: TYPE_TB
  zh: '| `b`、`B`、`c`、`d`、`o`、`x`、`X` | 整数表示类型。 |'
- en: '| Floating-point | `a` | Hexadecimal representation. Same as if calling `std::to_chars(first,
    last, value, std::chars_format::hex, precision)` or `std::to_chars(first, last,
    value, std::chars_format::hex)`, depending on whether precision is specified or
    not. |'
  id: totrans-925
  prefs: []
  type: TYPE_TB
  zh: '| 浮点数 | `a` | 十六进制表示。相当于调用 `std::to_chars(first, last, value, std::chars_format::hex,
    precision)` 或 `std::to_chars(first, last, value, std::chars_format::hex)`，具体取决于是否指定了精度。
    |'
- en: '| `A` | Same as `a` except that it uses uppercase letters for digits above
    9 and uses P to indicate the exponent. |'
  id: totrans-926
  prefs: []
  type: TYPE_TB
  zh: '| `A` | 与 `a` 相同，除了它使用大写字母表示大于9的数字，并使用 P 来表示指数。 |'
- en: '| `e` | Scientific representation. Produces the output as if calling `std::to_chars(first,
    last, value, std::chars_format::scientific, precision)`. |'
  id: totrans-927
  prefs: []
  type: TYPE_TB
  zh: '| `e` | 科学表示。产生输出，就像调用 `std::to_chars(first, last, value, std::chars_format::scientific,
    precision)`。 |'
- en: '| `E` | Similar to `e` except that it uses `E` to indicate the exponent. |'
  id: totrans-928
  prefs: []
  type: TYPE_TB
  zh: '| `E` | 与 `e` 类似，除了它使用 `E` 来表示指数。 |'
- en: '| `f`, `F` | Fixed representation. Produces the output as if by calling `std::to_chars(first,
    last, value, std::chars_format::fixed, precision)`. When no precision is specified,
    the default is 6. |'
  id: totrans-929
  prefs: []
  type: TYPE_TB
  zh: '| `f`、`F` | 固定表示。产生输出，就像通过调用 `std::to_chars(first, last, value, std::chars_format::fixed,
    precision)`。当未指定精度时，默认为 6。 |'
- en: '| `g` | General floating-point representation. Produces the output as if by
    calling `std::to_chars(first, last, value, std::chars_format::general, precision)`.
    When no precision is specified, the default is 6. |'
  id: totrans-930
  prefs: []
  type: TYPE_TB
  zh: '| `g` | 通用浮点表示。输出结果类似于调用 `std::to_chars(first, last, value, std::chars_format::general,
    precision)`。当未指定精度时，默认为 6。|'
- en: '| `G` | Same as `g` except that it uses `E` to indicate the exponent. |'
  id: totrans-931
  prefs: []
  type: TYPE_TB
  zh: '| `G` | 与 `g` 相同，但使用 `E` 来表示指数。|'
- en: '| Pointer | none or `p` | Pointer representation. Produces the output as if
    by calling `std::to_chars(first, last, reinterpret_cast<std::uintptr_t>(value),
    16)` with the prefix `0x` added to the output. This is available only when `std::uintptr_t`
    is defined; otherwise, the output is implementation-defined. |'
  id: totrans-932
  prefs: []
  type: TYPE_TB
  zh: '| 指针 | 无或 `p` | 指针表示。输出结果类似于调用 `std::to_chars(first, last, reinterpret_cast<std::uintptr_t>(value),
    16)` 并在输出前加上前缀 `0x`。这仅在 `std::uintptr_t` 被定义时可用；否则，输出是未定义的。|'
- en: 'Table 2.16: The list of available presentation types'
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.16：可用的表示类型列表
- en: 'The chrono format specification has the following form:'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 时间格式规范具有以下形式：
- en: '[PRE154]'
  id: totrans-935
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: The `fill-and-align`, `width`, and `precision` fields have the same meaning
    as in the standard format specification, described previously. The precision is
    only valid for `std::chrono::duration` types when the representation type is a
    floating-point type. Using it in other cases throws an `std::format_error` exception.
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: '`fill-and-align`、`width` 和 `precision` 字段与之前描述的标准格式规范中的意义相同。精度仅在 `std::chrono::duration`
    类型且表示类型为浮点类型时有效。在其他情况下使用它将抛出 `std::format_error` 异常。'
- en: 'The chrono specification can be empty, in which case the argument is formatted
    as if by streaming it to an `std::stringstream` and copying the result string.
    Alternatively, it can consist of a series of conversion specifiers and ordinary
    characters. Some of these format specifiers are presented in the following table:'
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 时间规范可以是空的，在这种情况下，参数将被格式化为如果将其流式传输到 `std::stringstream` 并复制结果字符串。或者，它可以由一系列转换规范和普通字符组成。以下表格中展示了其中一些格式规范：
- en: '| **Conversion specifier** | **Description** |'
  id: totrans-938
  prefs: []
  type: TYPE_TB
  zh: '| **转换规范** | **描述** |'
- en: '| `%%` | Writes a literal `%` character. |'
  id: totrans-939
  prefs: []
  type: TYPE_TB
  zh: '| `%%` | 写入一个字面的 `%` 字符。|'
- en: '| `%n` | Writes a newline character. |'
  id: totrans-940
  prefs: []
  type: TYPE_TB
  zh: '| `%n` | 写入一个换行符。|'
- en: '| `%t` | Writes a horizontal tab character. |'
  id: totrans-941
  prefs: []
  type: TYPE_TB
  zh: '| `%t` | 写入一个水平制表符。|'
- en: '| `%Y` | Writes the year as a decimal number. If the result is less than four
    digits, it is left-padded with `0` to four digits. |'
  id: totrans-942
  prefs: []
  type: TYPE_TB
  zh: '| `%Y` | 将年份以十进制数字形式写入。如果结果小于四位数字，则使用 `0` 左侧填充至四位数字。|'
- en: '| `%m` | Writes the month as a decimal number (January is `01`). If the result
    is a single digit, it is prefixed with `0`. |'
  id: totrans-943
  prefs: []
  type: TYPE_TB
  zh: '| `%m` | 将月份以十进制数字形式写入（一月为 `01`）。如果结果是单个数字，则前面会加上 `0`。|'
- en: '| `%d` | Writes the day of the month as a decimal number. If the result is
    a single decimal digit, it is prefixed with `0`. |'
  id: totrans-944
  prefs: []
  type: TYPE_TB
  zh: '| `%d` | 将月份中的日期以十进制数字形式写入。如果结果是单个数字，则前面会加上 `0`。|'
- en: '| `%w` | Writes the weekday as a decimal number (`0`-`6`), where Sunday is
    `0`. |'
  id: totrans-945
  prefs: []
  type: TYPE_TB
  zh: '| `%w` | 写入星期几的十进制数字（`0`-`6`），其中星期天为 `0`。|'
- en: '| `%D` | Equivalent to `%m/%d/%y`. |'
  id: totrans-946
  prefs: []
  type: TYPE_TB
  zh: '| `%D` | 等同于 `%m/%d/%y`。|'
- en: '| `%F` | Equivalent to `%Y-%m-%d`. |'
  id: totrans-947
  prefs: []
  type: TYPE_TB
  zh: '| `%F` | 等同于 `%Y-%m-%d`。|'
- en: '| `%H` | Writes the hour (24-hour clock) as a decimal number. If the result
    is a single digit, it is prefixed with `0`. |'
  id: totrans-948
  prefs: []
  type: TYPE_TB
  zh: '| `%H` | 将小时（24小时制）以十进制数字形式写入。如果结果是单个数字，则前面会加上 `0`。|'
- en: '| `%I` | Writes the hour (12-hour clock) as a decimal number. If the result
    is a single digit, it is prefixed with `0`. |'
  id: totrans-949
  prefs: []
  type: TYPE_TB
  zh: '| `%I` | 将小时（12小时制）以十进制数字形式写入。如果结果是单个数字，则前面会加上 `0`。|'
- en: '| `%M` | Writes the minute as a decimal number. If the result is a single digit,
    it is prefixed with `0`. |'
  id: totrans-950
  prefs: []
  type: TYPE_TB
  zh: '| `%M` | 将分钟以十进制数字形式写入。如果结果是单个数字，则前面会加上 `0`。|'
- en: '| `%S` | Writes the second as a decimal number. If the number of seconds is
    less than 10, the result is prefixed with `0`. |'
  id: totrans-951
  prefs: []
  type: TYPE_TB
  zh: '| `%S` | 将秒以十进制数字形式写入。如果秒数小于 10，则结果前面会加上 `0`。|'
- en: '| `%R` | Equivalent to `%H:%M`. |'
  id: totrans-952
  prefs: []
  type: TYPE_TB
  zh: '| `%R` | 等同于 `%H:%M`。|'
- en: '| `%T` | Equivalent to `%H:%M:%S`. |'
  id: totrans-953
  prefs: []
  type: TYPE_TB
  zh: '| `%T` | 等同于 `%H:%M:%S`。|'
- en: '| `%X` | Writes the locale’s time representation. |'
  id: totrans-954
  prefs: []
  type: TYPE_TB
  zh: '| `%X` | 写入区域设置的时间表示。|'
- en: 'Table 2.17: A list of the most commonly used chrono specifiers'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.17：最常见的chrono规范列表
- en: The complete list of format specifiers for the chrono library can be consulted
    at [https://en.cppreference.com/w/cpp/chrono/system_clock/formatter](https://en.cppreference.com/w/cpp/chrono/system_clock/formatter).
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的chrono库格式规范列表可以在 [https://en.cppreference.com/w/cpp/chrono/system_clock/formatter](https://en.cppreference.com/w/cpp/chrono/system_clock/formatter)
    查询。
- en: Because writing formatted text to the console or a file stream requires two
    operations (formatting text into a string or a vector of characters and then writing
    that buffer to the output stream), the C++23 standard introduced a couple of new
    functions to simplify this process.
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: 由于将格式化文本写入控制台或文件流需要两个操作（将文本格式化为字符串或字符向量，然后将该缓冲区写入输出流），C++23标准引入了一些新函数来简化此过程。
- en: 'The new `std::print` and `std::println` functions are very similar. The only
    difference is that `std::println` appends a `\n` character (new line) after the
    formatted text. These two functions have two overloads each:'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`std::print`和`std::println`函数非常相似。唯一的区别是`std::println`在格式化文本后附加一个`\n`字符（换行符）。这两个函数各有两个重载：
- en: One that takes an `std::FILE*` as the first argument, representing the output
    file stream
  id: totrans-959
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数是`std::FILE*`，表示输出文件流
- en: One that does not have such an argument, and uses the C output stream stdout
    implicitly
  id: totrans-960
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有这样的参数，并且隐式地使用C输出流stdout
- en: 'Because of this, the following two calls to `std::println` are equivalent:'
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，以下两个对`std::println`的调用是等效的：
- en: '[PRE155]'
  id: totrans-962
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'Also, the following two calls to `std::print` and `std::println` have the same
    result on the standard output stream:'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，以下两个对`std::print`和`std::println`的调用在标准输出流上具有相同的结果：
- en: '[PRE156]'
  id: totrans-964
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: The format string specification is the same as for `std::format` and was presented
    previously.
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 格式字符串的指定与`std::format`相同，之前已经介绍过。
- en: See also
  id: totrans-966
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Using std::format with user-defined types*, to learn how to create custom
    formatting specialization for user-defined types'
  id: totrans-967
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用用户定义类型与std::format结合*，学习如何为用户定义类型创建自定义格式化特化'
- en: '*Converting between numeric and string types*, to learn how to convert between
    numbers and strings'
  id: totrans-968
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在数字和字符串类型之间转换*，学习如何在不同数字和字符串之间进行转换'
- en: Using std::format with user-defined types
  id: totrans-969
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用用户定义类型与std::format结合
- en: The C++20 formatting library is a modern alternative to using `printf`-like
    functions or the I/O streams library, which it actually complements. Although
    the standard provides default formatting for basic types, such as integral and
    floating-point types, `bool`, character types, strings, and chrono types, the
    user can create custom specializations for user-defined types. In this recipe,
    we will learn how to do that.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: C++20格式化库是使用类似`printf`的函数或I/O流库的现代替代品，它实际上是对它们的补充。尽管标准为基本类型（如整数和浮点类型、`bool`、字符类型、字符串和chrono类型）提供了默认格式化，但用户可以为用户定义类型创建自定义特化。在本食谱中，我们将学习如何做到这一点。
- en: Getting ready
  id: totrans-971
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You should read the previous recipe, *Formatting and printing text with std::format
    and std::print*, to familiarize yourself with the formatting library.
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该阅读之前的食谱，*使用std::format和std::print格式化和打印文本*，以便熟悉格式化库。
- en: 'In the examples that we’ll be showing here, we will use the following class:'
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将要展示的示例中，我们将使用以下类：
- en: '[PRE157]'
  id: totrans-974
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: In the next section, we’ll introduce the necessary steps to implement to enable
    text formatting using `std::format()` for user-defined types.
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍实现使用`std::format()`对用户定义类型进行文本格式化的必要步骤。
- en: How to do it...
  id: totrans-976
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'To enable formatting using the new formatting library for user-defined types,
    you must do the following:'
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用使用新格式化库对用户定义类型进行格式化，必须执行以下操作：
- en: Define a specialization of the `std::formatter<T, CharT>` class in the `std`
    namespace.
  id: totrans-978
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`std`命名空间中定义`std::formatter<T, CharT>`类的特化。
- en: Implement the `parse()` method to parse the portion of the format string corresponding
    to the current argument. If the class inherits from another formatter, then this
    method can be omitted.
  id: totrans-979
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个`parse()`方法来解析格式字符串中对应当前参数的部分。如果类继承自另一个格式化器，则可以省略此方法。
- en: Implement the `format()` method to format the argument and write the output
    via `format_context`.
  id: totrans-980
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个`format()`方法来格式化参数，并通过`format_context`写入输出。
- en: 'For the `employee` class listed here, a formatter that formats `employee` to
    the form `[42]` `John Doe` (that is, `[id] firstName lastName`) can be implemented
    as follows:'
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这里列出的`employee`类，可以实现一个格式化器，将`employee`格式化为`[42] John Doe`的形式（即`[id] firstName
    lastName`），具体实现如下：
- en: '[PRE158]'
  id: totrans-982
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: How it works...
  id: totrans-983
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The formatting library uses the `std::formatter<T, CharT>` class template to
    define formatting rules for a given type. Built-in types, string types, and chrono
    types have formatters provided by the library. These are implemented as specializations
    of the `std::formatter<T, CharT>` class template.
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 格式化库使用`std::formatter<T, CharT>`类模板来定义给定类型的格式化规则。内置类型、字符串类型和chrono类型由库提供格式化器。这些是`std::formatter<T,
    CharT>`类模板的特殊化实现。
- en: 'This class has two methods:'
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类有两个方法：
- en: '`parse()`, which takes a single argument of the type `std::basic_format_parse_context<CharT>`
    and parses the format’s specification for the type `T`, provided by the parse
    context. The result of the parsing is supposed to be stored in member fields of
    the class. If the parsing succeeds, this function should return a value of the
    type `std::basic_format_parse_context<CharT>::iterator`, which represents the
    end of the format specification. If the parsing fails, the function should throw
    an exception of the type `std::format_error` to provide details about the error.'
  id: totrans-986
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parse()`函数接受一个类型为`std::basic_format_parse_context<CharT>`的单个参数，并解析由解析上下文提供的类型`T`的格式说明。解析的结果应存储在类的成员字段中。如果解析成功，此函数应返回类型为`std::basic_format_parse_context<CharT>::iterator`的值，它表示格式说明符的结束。如果解析失败，函数应抛出类型为`std::format_error`的异常，以提供有关错误的详细信息。'
- en: '`format()`, which takes two arguments, with the first being the object of the
    type `T` to format and the second being a formatting context object of the type
    `std::basic_format_context<OutputIt, CharT>`. This function should write the output
    to `ctx.out()` according to the desired specifiers (which could be something implicit
    or the result of parsing the format specification). The function must return a
    value of the type `std::basic_format_context<OutputIt, CharT>::iterator`, representing
    the end of the output.'
  id: totrans-987
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`format()`函数接受两个参数，第一个是要格式化的类型`T`的对象，第二个是格式化上下文对象，类型为`std::basic_format_context<OutputIt,
    CharT>`。此函数应根据所需的说明符（可能是隐式的或解析格式说明的结果）将输出写入`ctx.out()`。函数必须返回类型为`std::basic_format_context<OutputIt,
    CharT>::iterator`的值，表示输出的结束。'
- en: 'In the implementation shown in the previous section, the `parse()` function
    does not do anything other than return an iterator representing the beginning
    of the format specification. The formatting is always done by printing the employee
    identifier between square brackets, followed by the first name and the last name,
    such as in `[42] John Doe`. An attempt to use a format specifier would result
    in a compile-time error:'
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个部分中展示的实现中，`parse()`函数除了返回表示格式说明符开始的迭代器之外，不做任何事情。格式化总是通过在方括号内打印员工标识符，然后是名字和姓氏来完成的，例如`[42]
    John Doe`。尝试使用格式说明符会导致编译时错误：
- en: '[PRE159]'
  id: totrans-989
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'If you want your user-defined types to support format specifiers, then you
    must properly implement the `parse()` method. To show how this can be done, we
    will support the several specifiers for the `employee` class, as defined in the
    following table:'
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望你的用户定义类型支持格式说明符，那么你必须正确实现`parse()`方法。为了展示如何实现这一点，我们将支持`employee`类中定义的几个说明符，如下表所示：
- en: '| **Specifier** | **Description** | **Example** |'
  id: totrans-991
  prefs: []
  type: TYPE_TB
  zh: '| **说明符** | **描述** | **示例** |'
- en: '| `L` | Lexicographic order | [42] Doe, John |'
  id: totrans-992
  prefs: []
  type: TYPE_TB
  zh: '| `L` | 字典顺序 | [42] Doe, John |'
- en: '| `l` | Lowercase | [42] john doe |'
  id: totrans-993
  prefs: []
  type: TYPE_TB
  zh: '| `l` | 小写 | [42] john doe |'
- en: '| `u` | Uppercase | [42] JOHN DOE |'
  id: totrans-994
  prefs: []
  type: TYPE_TB
  zh: '| `u` | 大写 | [42] JOHN DOE |'
- en: 'Table 2.18: Specifiers supported for the user-defined employee class'
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.18：用户定义的`employee`类支持的说明符
- en: When the `L` specifier is used, the `employee` is formatted with the identifier
    in square brackets, followed by the last name, a comma, and then the first name,
    such as in *[42] Doe, John*. A combination of these specifiers is also possible.
    For instance `{:Ll}` would produce *[42] doe, john*, while `{:uL}` would produce
    *[42] DOE, JOHN*.
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`L`说明符时，`employee`将以方括号内的标识符开始格式化，然后是姓氏，一个逗号，然后是名字，例如`[42] Doe, John`。这些说明符的组合也是可能的。例如，`{:Ll}`将产生`[42]
    doe, john`，而`{:uL}`将产生`[42] DOE, JOHN`。
- en: 'The specialization of the `std::formatter` class for the employee class that
    implements the defined requirements may look as follows:'
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 实现定义要求的`std::formatter`类模板的`employee`类的特殊化可能如下所示：
- en: '[PRE160]'
  id: totrans-998
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'The `parse()` function receives the parsing context that includes the format
    string. The `begin()` iterator points to the first element of the format string
    after the format delimiter (`:`). An example is provided in the next table:'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: '`parse()` 函数接收包含格式字符串的解析上下文。`begin()` 迭代器指向格式分隔符（`:`）之后的格式字符串的第一个元素。下一个表格提供了一个示例：'
- en: '| **Format** | **begin() iterator** | **Range** |'
  id: totrans-1000
  prefs: []
  type: TYPE_TB
  zh: '| **格式** | **begin() 迭代器** | **范围** |'
- en: '| `"{}"` | Equal to `end()` | Empty |'
  id: totrans-1001
  prefs: []
  type: TYPE_TB
  zh: '| `"{}"` | 等同于 `end()` | 空的 |'
- en: '| `"{0}"` | Equal to `end()` | Empty |'
  id: totrans-1002
  prefs: []
  type: TYPE_TB
  zh: '| `"{0}"` | 等同于 `end()` | 空的 |'
- en: '| `"{0:L}"` | Points to `''L''` | `L}` |'
  id: totrans-1003
  prefs: []
  type: TYPE_TB
  zh: '| `"{0:L}"` | 指向 `''L''` | `L}` |'
- en: '| `"{:L}"` | Points to `''L''` | `L}` |'
  id: totrans-1004
  prefs: []
  type: TYPE_TB
  zh: '| `"{:L}"` | 指向 `''L''` | `L}` |'
- en: '| `"{:Lul}"` | Points to `''L''` | `Lul}` |'
  id: totrans-1005
  prefs: []
  type: TYPE_TB
  zh: '| `"{:Lul}"` | 指向 `''L''` | `Lul}` |'
- en: 'Table 2.19: Examples of the content of the parsing context'
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.19：解析上下文内容的示例
- en: 'With this defined, the preceding sample code (using the `{:L}` format argument)
    would work. Moreover, various combinations of the `L`, `u`, and `l` specifiers
    can be used, as exemplified next:'
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了这些之后，前面的示例代码（使用 `{:L}` 格式参数）将可以工作。此外，可以使用 `L`、`u` 和 `l` 指定符的各种组合，如下所示：
- en: '[PRE161]'
  id: totrans-1008
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'Multiple usage of the same argument is also possible, as in the following snippet:'
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 同一个参数的多次使用也是可能的，如下面的代码片段所示：
- en: '[PRE162]'
  id: totrans-1010
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'However, using other format specifiers (such as `A`, for example) would not
    work; the specifier is simply ignored and the default formatting is used:'
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用其他格式指定符（例如 `A`）将不会工作；指定符将被简单地忽略，并使用默认格式化：
- en: '[PRE163]'
  id: totrans-1012
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'If you do not need to parse the format specifier in order to support various
    options, you could entirely omit the `parse()` method. However, in order to do
    so, your `std::formatter` specialization must derive from another `std::formatter`
    class. An implementation is shown here:'
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不需要解析格式指定符以支持各种选项，你可以完全省略 `parse()` 方法。但是，为了这样做，你的 `std::formatter` 特化必须从另一个
    `std::formatter` 类派生。一个实现示例如下：
- en: '[PRE164]'
  id: totrans-1014
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: This specialization for the `employee` class is equivalent to the first implementation
    shown earlier in the *How to do it...* section.
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `employee` 类的特化与前面在 *如何做...* 部分中显示的第一个实现等效。
- en: There’s more…
  id: totrans-1016
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The C++23 standard introduces a new concept called `std::formattable` (also
    in the `<format>` header), which specifies that a type is formattable. That means
    that a specialization of `std::format` is available for a type `T` and that it
    defines the `parse()` and `format()` member functions, as described in this recipe.
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: C++23 标准引入了一个新的概念，称为 `std::formattable`（也在 `<format>` 头文件中），它指定一个类型是可格式化的。这意味着对于类型
    `T`，有 `std::format` 的特化，并且它定义了 `parse()` 和 `format()` 成员函数，如本食谱中所述。
- en: See also
  id: totrans-1018
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考内容
- en: '*Formatting text with std::format*, to get a good introduction to the new C++20
    text formatting library'
  id: totrans-1019
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 std::format 格式化文本*，以获得对新的 C++20 文本格式化库的介绍'
- en: Learn more on Discord
  id: totrans-1020
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://discord.gg/7xRaTCeEhx](Chapter_02.xhtml)'
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://discord.gg/7xRaTCeEhx](Chapter_02.xhtml)'
- en: '![](img/QR_Code2659294082093549796.png)'
  id: totrans-1023
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code2659294082093549796.png)'
