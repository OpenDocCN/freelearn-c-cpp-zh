["```cpp\n#ifndef OTHELLOWINDOW_H \n#define OTHELLOWINDOW_H \n\n#include \"..\\MainWindow\\MainWindow.h\" \n#include \"OthelloWidget.h\" \n\nclass OthelloWindow : public MainWindow { \n  Q_OBJECT \n\n  public: \n    OthelloWindow(QWidget *parentWidget = nullptr); \n    ~OthelloWindow(); \n\n    void closeEvent(QCloseEvent *eventPtr)\n                   {m_othelloWidgetPtr->closeEvent(eventPtr);} \n\n  private: \n    OthelloWidget* m_othelloWidgetPtr; \n}; \n\n#endif // OTHELLOWINDOW_H \n```", "```cpp\n#include \"OthelloWidget.h\" \n#include \"OthelloWindow.h\" \n#include <QtWidgets> \n```", "```cpp\nOthelloWindow::OthelloWindow(QWidget *parentWidget /*= nullptr*/) \n :MainWindow(parentWidget) { \n  setWindowTitle(tr(\"Othello Advanced\")); \n  resize(1000, 500); \n\n  m_othelloWidgetPtr = new OthelloWidget(this); \n  setCentralWidget(m_othelloWidgetPtr); \n\n  { QMenu* gameMenuPtr = menuBar()->addMenu(tr(\"&Game\")); \n    connect(gameMenuPtr, SIGNAL(aboutToShow()), \n            this, SLOT(onMenuShow())); \n```", "```cpp\n    { QMenu* computerStartsMenuPtr = \n        gameMenuPtr->addMenu(tr(\"&Computer Starts\")); \n      connect(computerStartsMenuPtr, SIGNAL(aboutToShow()), \n              this, SLOT(onMenuShow())); \n```", "```cpp\n      addAction(computerStartsMenuPtr, tr(\"Computer &Black\"), \n                SLOT(onComputerStartsBlack()), 0, \n                tr(\"Computer Black\"), nullptr, \n                tr(\"Computer Black\"), \n                LISTENER(isComputerStartsBlackEnabled)); \n\n      addAction(computerStartsMenuPtr, tr(\"Computer &White\"), \n                SLOT(onComputerStartsWhite()), 0, \n                tr(\"Computer White\"), nullptr, \n                tr(\"Computer White\"), \n                LISTENER(isComputerStartsWhiteEnabled)); \n    } \n```", "```cpp\n    { QMenu* humanStartsMenuPtr = \n        gameMenuPtr->addMenu(tr(\"&Human Starts\")); \n      connect(humanStartsMenuPtr, SIGNAL(aboutToShow()), \n              this, SLOT(onMenuShow())); \n\n      addAction(humanStartsMenuPtr, tr(\"Human &Black\"), \n                SLOT(onHumanStartsBlack()), 0, tr(\"Human Black\"), \n                nullptr, tr(\"Human Black\"), \n                LISTENER(isHumanStartsBlackEnabled)); \n\n      addAction(humanStartsMenuPtr, tr(\"Human &White\"), \n                SLOT(onHumanStartsWhite()), 0, tr(\"Human White\"), \n                nullptr, tr(\"Human White\"), \n                LISTENER(isHumanStartsWhiteEnabled)); \n    } \n\n    gameMenuPtr->addSeparator(); \n\n    addAction(gameMenuPtr, tr(\"&Quit the Game\"), \n              SLOT(onQuit()), \n              QKeySequence(Qt::CTRL + Qt::Key_Q), tr(\"Quit Game\"), \n              nullptr, tr(\"Quit the Game\"), \n              LISTENER(isQuitEnabled)); \n\n    addAction(gameMenuPtr, tr(\"E&xit\"),i \n              SLOT(onExit()), QKeySequence::Quit); \n  } \n} \n\nOthelloWindow::~OthelloWindow() { \n  delete m_othelloWidgetPtr; \n} \n```", "```cpp\n#ifndef OTHELLOWIDGET_H \n#define OTHELLOWIDGET_H \n\n#include \"..\\MainWindow\\GameWidget.h\" \n\n#define ROWS    8 \n#define COLUMNS 8 \n\nenum Mark {Empty = 0, Black, White}; \n\nclass OthelloWidget : public GameWidget { \n  Q_OBJECT \n\n  public: \n    OthelloWidget(QWidget* parentWidget); \n\n    void mouseMark(int row, int column); \n    void drawMark(QPainter& painter, \n                  const QRect& markRect, int mark); \n\n  public slots: \n    DEFINE_LISTENER(OthelloWidget, isComputerStartsBlackEnabled); \n    DEFINE_LISTENER(OthelloWidget, isComputerStartsWhiteEnabled); \n    DEFINE_LISTENER(OthelloWidget, isHumanStartsBlackEnabled); \n    DEFINE_LISTENER(OthelloWidget, isHumanStartsWhiteEnabled); \n\n    void onComputerStartsBlack(); \n    void onComputerStartsWhite(); \n    void onHumanStartsBlack(); \n    void onHumanStartsWhite(); \n\n  private: \n    bool checkWinner(); \n    void turn(int row, int column, Mark mark); \n    void calculateComputerMove(); \n    void calculateTurns(int row, int column, Mark mark, \n                        QSet<QPair<int,int>>& totalSet, \n                        int& neighbours); \n    Mark m_humanMark, m_computerMark; \n}; \n\n#endif // OTHELLOWIDGET_H \n```", "```cpp\n#include \"OthelloWidget.h\" \n#include \"OthelloWindow.h\" \n\n#include <QTime> \n#include <CTime> \n#include <CAssert> \nusing namespace std; \n\nOthelloWidget::OthelloWidget(QWidget* parentWidget) \n :GameWidget(ROWS, COLUMNS, parentWidget) { \n  // Empty. \n} \n```", "```cpp\nbool OthelloWidget::isComputerStartsBlackEnabled() { \n  return !isGameInProgress(); \n} \n\nbool OthelloWidget::isComputerStartsWhiteEnabled() { \n  return !isGameInProgress(); \n} \n\nbool OthelloWidget::isHumanStartsBlackEnabled() { \n  return !isGameInProgress(); \n} \n\nbool OthelloWidget::isHumanStartsWhiteEnabled() { \n  return !isGameInProgress(); \n} \n```", "```cpp\nvoid OthelloWidget::onComputerStartsBlack() { \n  setGameInProgress(true); \n  set(ROWS / 2, COLUMNS / 2, m_computerMark = Black); \n  m_humanMark = White; \n  update(); \n} \n\nvoid OthelloWidget::onComputerStartsWhite() { \n  setGameInProgress(true); \n  set(ROWS / 2, COLUMNS / 2, m_computerMark = White); \n  m_humanMark = Black; \n  update(); \n} \n```", "```cpp\nvoid OthelloWidget::onHumanStartsBlack() { \n  setGameInProgress(true); \n  m_humanMark = Black; \n  m_computerMark = White; \n  update(); \n} \n\nvoid OthelloWidget::onHumanStartsWhite() { \n  setGameInProgress(true); \n  m_humanMark = White; \n  m_computerMark = Black; \n  update(); \n} \n```", "```cpp\nvoid OthelloWidget::mouseMark(int row, int column) { \n  set(row, column, m_humanMark); \n  turn(row, column, m_humanMark); \n  update(); \n```", "```cpp\n  if (!checkWinner()) { \n    calculateComputerMove(); \n    update(); \n    checkWinner(); \n  } \n} \n```", "```cpp\nvoid OthelloWidget::drawMark(QPainter& painter, \n                             const QRect& markRect, int mark) { \n  painter.setPen(Qt::black); \n  painter.drawRect(markRect); \n  painter.fillRect(markRect, Qt::lightGray); \n\n  switch (mark) { \n    case Black: \n      painter.setPen(Qt::black); \n      painter.setBrush(Qt::black); \n      painter.drawEllipse(markRect); \n      break; \n\n    case White: \n      painter.setPen(Qt::white); \n      painter.setBrush(Qt::white); \n      painter.drawEllipse(markRect); \n      break; \n\n    case Empty: \n      break; \n  } \n} \n```", "```cpp\nbool OthelloWidget::checkWinner() { \n  int blacks = 0, whites = 0, empties = 0; \n\n  for (int row = 0; row < ROWS; ++row) { \n    for (int column = 0; column < COLUMNS; ++column) { \n      switch (get(row, column)) { \n        case Black: \n          ++blacks; \n          break; \n\n        case White: \n          ++whites; \n          break; \n\n        case Empty: \n          ++empties; \n          break; \n      } \n    } \n  } \n\n  if (empties == 0) { \n    QMessageBox messageBox(QMessageBox::Information, \n                           tr(\"Victory\"), QString()); \n    QString text; \n\n    if (blacks > whites) { \n      text.sprintf(\"The Winner: %s.\", (m_computerMark == Black) \n                                      ? \"Computer\" : \"Human\"); \n    } \n    else if (whites > blacks) { \n      text.sprintf(\"The Winner: %s.\", (m_computerMark == White) \n                                      ? \"Computer\" : \"Human\"); \n    } \n    else { \n      text.sprintf(\"A Draw.\"); \n    } \n\n    messageBox.setText(text); \n    messageBox.setStandardButtons(QMessageBox::Ok); \n    messageBox.exec(); \n    setGameInProgress(false); \n    clearGrid(); \n    update(); \n\n    return true; \n  } \n\n  return false; \n} \n```", "```cpp\nvoid OthelloWidget::calculateComputerMove() { \n  int maxTurnSetSize = 0, maxNeighbours = 0; \n  QList<QSet<QPair<int,int>>> maxTurnSetList; \n  QList<QPair<int,int>> maxNeighboursList; \n```", "```cpp\n  for (int row = 0; row < ROWS; ++row) { \n    for (int column = 0; column < COLUMNS; ++column) { \n      if (get(row, column) == Empty) { \n        QSet<QPair<int,int>> turnSet; \n        int neighbours = 0; \n        calculateTurns(row, column, m_computerMark, \n                       turnSet, neighbours); \n        int turnSetSize = turnSet.size(); \n```", "```cpp\n        if (turnSetSize > maxTurnSetSize) { \n          maxTurnSetSize = turnSetSize; \n          turnSet.insert(QPair<int,int>(row, column)); \n          maxTurnSetList.clear(); \n          maxTurnSetList.append(turnSet); \n        } \n```", "```cpp\n        else if ((turnSetSize > 0) && \n                 (turnSetSize == maxTurnSetSize)) { \n          turnSet.insert(QPair<int,int>(row, column)); \n          maxTurnSetList.append(turnSet); \n        } \n```", "```cpp\n        if (neighbours > maxNeighbours) { \n          maxNeighbours = neighbours; \n          maxNeighboursList.clear(); \n          maxNeighboursList.append(QPair<int,int>(row, column)); \n        } \n```", "```cpp\n        else if ((neighbours > 0) && \n                 (neighbours == maxNeighbours)) { \n          maxNeighboursList.append(QPair<int,int>(row, column)); \n        } \n      } \n    } \n  } \n```", "```cpp\n  if (maxTurnSetSize > 0) { \n    srand(time(NULL)); \n    int index = rand() % maxTurnSetList.size(); \n    QSet<QPair<int,int>> maxTurnSet = maxTurnSetList[index]; \n```", "```cpp\n    for (QPair<int,int> position : maxTurnSet) { \n      int row = position.first, column = position.second; \n      set(row, column, m_computerMark); \n    } \n  } \n```", "```cpp\n  else { \n    assert(!maxNeighboursList.empty()); \n    srand(time(NULL)); \n    int index = rand() % maxNeighboursList.size(); \n    QPair<int,int> position = maxNeighboursList[index]; \n    int row = position.first, column = position.second; \n    set(row, column, m_computerMark); \n  } \n} \n```", "```cpp\nvoid OthelloWidget::turn(int row, int column, Mark mark) { \n  QSet<QPair<int,int>> turnSet; \n  calculateMark(row, column, mark, turnSet); \n\n  for (QPair<int,int> pair : turnSet) { \n    int row = pair.first, column = pair.second; \n    set(row, column, mark); \n  } \n} \n```", "```cpp\nvoid OthelloWidget::calculateTurns(int row, int column, \n                  Mark playerMark,QSet<QPair<int,int>>& totalSet, \n                  int& neighbours) { \n```", "```cpp\n  QPair<int,int> directionArray[] = \n    {QPair<int,int>(-1, 0),   // North \n     QPair<int,int>(-1, 1),   // Northeast \n     QPair<int,int>(0, 1),    // East \n     QPair<int,int>(1, 1),    // Southeast \n     QPair<int,int>(1, 0),    // South \n     QPair<int,int>(1, -1),   // Southwest \n     QPair<int,int>(0, -1),   // West \n     QPair<int,int>(-1, -1)}; // Northwest \n```", "```cpp\n  int arraySize = \n    (sizeof directionArray) / (sizeof directionArray[0]); \n\n  neighbours = 0; \n  int opponentMark = (playerMark == Black) ? White : Black; \n```", "```cpp\n  for (int index = 0; index < arraySize; ++index) { \n    QPair<int,int> pair = directionArray[index]; \n```", "```cpp\n    int rowStep = pair.first, columnStep = pair.second, \n        currRow = row, currColumn = column; \n```", "```cpp\n    if (((row + rowStep) >= 0) && ((row + rowStep) < ROWS) && \n        ((column + rowStep) >= 0) && \n        ((column + columnStep) < COLUMNS) && \n        (get(row + rowStep, column + rowStep) == opponentMark)) { \n      ++neighbours; \n    } \n\n```", "```cpp\n    QSet<QPair<int,int>> directionSet; \n\n    while (true) { \n      currRow += rowStep; \n      currColumn += columnStep; \n```", "```cpp\n      if ((currRow < 0) || (currRow == ROWS) || \n          (currColumn < 0) || (currColumn == COLUMNS) || \n          (get(currRow, currColumn) == Empty)) { \n        break; \n      } \n```", "```cpp\n      else if (get(currRow, currColumn) == playerMark) { \n        totalSet += directionSet; \n        break; \n      } \n```", "```cpp\n      else { \n        directionSet.insert(QPair<int,int>(row, column)); \n      } \n    } \n  } \n} \n```", "```cpp\n#include \"OthelloWidget.h\" \n#include \"OthelloWindow.h\" \n#include <QApplication> \n\nint main(int argc, char *argv[]) { \n  QApplication application(argc, argv); \n  OthelloWindow othelloWindow; \n  othelloWindow.show(); \n  return application.exec(); \n} \n```", "```cpp\n#ifndef NACWINDOW_H \n#define NACWINDOW_H \n\n#include \"..\\MainWindow\\MainWindow.h\" \n#include \"NaCWidget.h\" \n\nclass NaCWindow : public MainWindow { \n  Q_OBJECT \n\n  public: \n    NaCWindow(QWidget *parentWidget = nullptr); \n    ~NaCWindow(); \n\n  public: \n    void closeEvent(QCloseEvent *eventPtr)\n                   {m_nacWidgetPtr->closeEvent(eventPtr);} \n\n  private: \n    NaCWidget* m_nacWidgetPtr; \n}; \n\n#endif // NACWINDOW_H \n```", "```cpp\n#include \"NaCWindow.h\" \n#include <QtWidgets> \n```", "```cpp\nNaCWindow::NaCWindow(QWidget *parentWidget /*= nullptr*/) \n :MainWindow(parentWidget) { \n  setWindowTitle(tr(\"Noughts and Crosses Advanced\")); \n  resize(1000, 500); \n\n  m_nacWidgetPtr = new NaCWidget(this); \n  setCentralWidget(m_nacWidgetPtr); \n\n  { QMenu* gameMenuPtr = menuBar()->addMenu(tr(\"&Game\")); \n    connect(gameMenuPtr, SIGNAL(aboutToShow()), \n            this, SLOT(onMenuShow())); \n\n    { QMenu* computerStartsMenuPtr = \n        gameMenuPtr->addMenu(tr(\"&Computer Starts\")); \n      connect(computerStartsMenuPtr, SIGNAL(aboutToShow()), \n              this, SLOT(onMenuShow())); \n\n      addAction(computerStartsMenuPtr, tr(\"Computer &Nought\"), \n                SLOT(onComputerStartsNought()), 0, \n                tr(\"Computer Nought\"), nullptr, \n                tr(\"Computer Nought\"), \n                LISTENER(isComputerStartsNoughtEnabled)); \n\n        addAction(computerStartsMenuPtr, tr(\"Computer &Cross\"), \n                  SLOT(onComputerStartsCross()), 0, \n                  tr(\"Computer Cross\"), nullptr, \n                  tr(\"Computer Cross\"), \n                  LISTENER(isComputerStartsCrossEnabled)); \n    } \n\n    { QMenu* humanStartsMenuPtr = \n        gameMenuPtr->addMenu(tr(\"&Human Starts\")); \n      connect(humanStartsMenuPtr, SIGNAL(aboutToShow()), \n              this, SLOT(onMenuShow())); \n\n      addAction(humanStartsMenuPtr, tr(\"Human &Nought\"), \n                SLOT(onHumanNought()), 0, tr(\"Human Nought\"), \n                nullptr, tr(\"Human Nought\"), \n                LISTENER(isHumanNoughtEnabled)); \n\n      addAction(humanStartsMenuPtr, tr(\"Human &Cross\"), \n                SLOT(onHumanCross()), 0, tr(\"Human Cross\"), \n                nullptr, tr(\"Human Cross\"), \n                LISTENER(isHumanCrossEnabled)); \n    } \n\n    gameMenuPtr->addSeparator(); \n\n    addAction(gameMenuPtr, tr(\"&Quit the Game\"), \n              SLOT(onQuit()), \n              QKeySequence(Qt::CTRL + Qt::Key_Q), tr(\"Quit Game\"), \n              nullptr, tr(\"Quit the Game\"), \n              LISTENER(isQuitEnabled)); \n\n    addAction(gameMenuPtr, tr(\"E&xit\"), \n              SLOT(onExit()), QKeySequence::Quit); \n  } \n} \n\nNaCWindow::~NaCWindow() { \n  delete m_nacWidgetPtr; \n} \n```", "```cpp\n#ifndef NACWIDGET_H \n#define NACWIDGET_H \n\n#include \"..\\MainWindow\\GameWidget.h\" \n\n#define ROWS    26 \n#define COLUMNS 26 \n\nenum Mark {Empty = 0, Nought, Cross}; \n\nclass NaCWidget : public GameWidget { \n  Q_OBJECT \n\n  public: \n    NaCWidget(QWidget* parentWidget); \n\n    void mouseMark(int row, int column); \n    void drawMark(QPainter& painter, \n                  const QRect& markRect, int mark); \n\n  public slots: \n    DEFINE_LISTENER(NaCWidget, isComputerStartsNoughtEnabled); \n    DEFINE_LISTENER(NaCWidget, isComputerStartsCrossEnabled); \n    DEFINE_LISTENER(NaCWidget, isHumanStartsNoughtEnabled); \n    DEFINE_LISTENER(NaCWidget, isHumanStartsCrossEnabled); \n\n    void onComputerStartsNought(); \n    void onComputerStartsCross(); \n    void onHumanStartsNought(); \n    void onHumanStartsCross(); \n\n  private: \n    bool checkWinner(int row, int column, Mark mark); \n    int countMarks(int row, int column, int rowStep, \n                   int columnStep, Mark mark); \n    void calculateComputerMove(int& row, int &column); \n    double calculateMarkValue(int row, int column, Mark mark); \n\n    Mark m_humanMark, m_computerMark; \n}; \n\n#endif // NACWIDGET_H \n```", "```cpp\n#include \"NaCWidget.h\" \n#include <CTime> \n#include <CAssert> \n\nNaCWidget::NaCWidget(QWidget* parentWidget) \n :GameWidget(ROWS, COLUMNS, parentWidget) { \n  // Empty. \n} \n```", "```cpp\nbool NaCWidget::isComputerStartsNoughtEnabled() { \n  return !isGameInProgress(); \n} \n\nbool NaCWidget::isComputerStartsCrossEnabled() { \n  return !isGameInProgress(); \n} \n\nbool NaCWidget::isHumanStartsNoughtEnabled() { \n  return !isGameInProgress(); \n} \n\nbool NaCWidget::isHumanStartsCrossEnabled() { \n  return !isGameInProgress(); \n} \n```", "```cpp\nvoid NaCWidget::onComputerStartsNought() { \n  setGameInProgress(true); \n  set(ROWS /2, COLUMNS / 2, m_computerMark = Nought); \n  m_humanMark = Cross; \n  update(); \n} \n\nvoid NaCWidget::onComputerStartsCross() { \n  setGameInProgress(true); \n  set(ROWS /2, COLUMNS / 2, m_computerMark = Cross); \n  m_humanMark = Nought; \n  update(); \n} \n\nvoid NaCWidget::onHumanStartsNought() { \n  setGameInProgress(true); \n  m_computerMark = Cross; \n  m_humanMark = Nought; \n  update(); \n} \n\nvoid NaCWidget::onHumanStartsCross() { \n  setGameInProgress(true); \n  m_computerMark = Nought; \n  m_humanMark = Cross; \n  update(); \n} \n```", "```cpp\nvoid NaCWidget::mouseMark(int row, int column) { \n  set(row, column, m_humanMark); \n  update(); \n```", "```cpp\n  if (!checkWinner(row, column, m_humanMark)) { \n    calculateComputerMove(row, column); \n    set(row, column, m_computerMark); \n    checkWinner(row, column, m_computerMark); \n    update(); \n  } \n} \n```", "```cpp\nvoid NaCWidget::drawMark(QPainter& painter, \n                         const QRect& markRect, int mark) { \n  painter.setPen(Qt::black); \n\n  switch (mark) { \n    case Nought: \n      painter.drawEllipse(markRect); \n      break; \n\n    case Cross: \n      painter.drawLine(markRect.topLeft(), \n                       markRect.bottomRight()); \n      painter.drawLine(markRect.topRight(), \n                       markRect.bottomLeft()); \n      break; \n\n    case Empty: \n      break; \n  } \n} \n```", "```cpp\nbool NaCWidget::checkWinner(int row, int column, Mark mark) { \n  if ((countMarks(row, column, -1, 0, mark) >= 5) || \n      (countMarks(row, column, 0, -1, mark) >= 5) || \n      (countMarks(row, column, -1, 1, mark) >= 5) || \n      (countMarks(row, column, 1, 1, mark) >= 5)) { \n    QMessageBox messageBox(QMessageBox::Information, \n                           tr(\"Victory\"), QString()); \n    QString text; \n    text.sprintf(\"The Winner: %s.\", \n                 (mark == m_computerMark) ? \"Computer\" : \"Human\"); \n\n    messageBox.setText(text); \n    messageBox.setStandardButtons(QMessageBox::Ok); \n    messageBox.exec(); \n    setGameInProgress(false); \n    clearGrid(); \n    update(); \n    return true; \n  } \n\n  return false; \n} \n```", "```cpp\ndouble NaCWidget::countMarks(int row, int column, int rowStep, \n                        int columnStep, Mark mark) { \n```", "```cpp\n  double markCount = 0; \n  int freeCount = 0; \n```", "```cpp\n  { bool marked = true; \n    int currentRow = row, currentColumn = column; \n\n    while ((currentRow >= 0) && (currentRow < ROWS) && \n           (currentColumn >= 0) && (currentColumn < COLUMNS)) { \n```", "```cpp\n      if (get(currentRow, currentColumn) == mark) { \n        if (marked) { \n          ++markCount; \n        } \n\n        ++freeCount; \n      } \n```", "```cpp\n      else if (get(currentRow, currentColumn) == Empty) { \n        if (marked) { \n          markCount += 0.4; \n        } \n\n        marked = false; \n        ++freeCount; \n      } \n```", "```cpp\n      else { \n        break; \n      } \n```", "```cpp\n      currentRow += rowStep; \n      currentColumn += columnStep; \n    } \n  } \n```", "```cpp\n  { bool marked = true; \n    int currentRow = row + rowStep, \n        currentColumn = column + columnStep; \n\n    while ((currentRow >= 0) && (currentRow < ROWS) && \n           (currentColumn >= 0) && (currentColumn < COLUMNS)) { \n      if (get(currentRow, currentColumn) == mark) { \n        if (marked) { \n          ++markCount; \n        } \n      } \n      else if (get(currentRow, currentColumn) == Empty) { \n        if (marked) { \n          markCount += 0.4; \n        } \n\n        marked = false; \n        ++freeCount; \n      } \n      else { \n        break; \n      } \n\n      currentRow -= rowStep; \n      currentColumn -= columnStep; \n    } \n  } \n```", "```cpp\n  return (freeCount >= 5) ? markCount : 0; \n} \n```", "```cpp\nvoid NaCWidget::calculateComputerMove(int& maxRow,int &maxColumn){ \n  double maxComputerValue = 0, maxHumanValue = 0; \n  QList<QPair<int,int>> maxComputerList, maxHumanList; \n```", "```cpp\n  for (int row = 0; row < ROWS; ++row) { \n    for (int column = 0; column < COLUMNS; ++column)  { \n      if (get(row, column) == Empty) { \n        set(row, column, m_computerMark); \n```", "```cpp\n        { double computerValue = \n            calculateMarkValue(row, column, m_computerMark); \n\n          if (computerValue > maxComputerValue) { \n            maxComputerValue = computerValue; \n            maxComputerList.clear(); \n            maxComputerList.append(QPair<int,int>(row, column)); \n          } \n```", "```cpp\n          else if ((computerValue > 0) && \n                   (computerValue == maxComputerValue)) { \n            maxComputerList.append(QPair<int,int>(row, column)); \n          } \n        } \n```", "```cpp\n        set(row, column, m_humanMark); \n\n        { double humanValue = \n            calculateMarkValue(row, column, m_humanMark); \n\n          if (humanValue > maxHumanValue) { \n            maxHumanValue = humanValue; \n            maxHumanList.clear(); \n            maxHumanList.append(QPair<int,int>(row, column)); \n          } \n          else if ((humanValue > 0) && \n                   (humanValue == maxHumanValue)) { \n            maxHumanList.append(QPair<int,int>(row, column)); \n          } \n        } \n```", "```cpp\n        set(row, column, Empty); \n      } \n    } \n  } \n```", "```cpp\n  assert(!maxComputerList.empty() && !maxHumanList.empty()); \n```", "```cpp\n  if ((maxComputerValue >= 2) && \n      ((maxComputerValue >= maxHumanValue) || \n       (maxHumanValue < 3.8))) { \n    srand(time(NULL)); \n    QPair<int,int> pair = \n      maxComputerList[rand() % maxComputerList.size()]; \n    maxRow = pair.first; \n    maxColumn = pair.second; \n  } \n```", "```cpp\n  else { \n    srand(time(NULL)); \n    QPair<int,int> pair = \n      maxHumanList[rand() % maxHumanList.size()]; \n    maxRow = pair.first; \n    maxColumn = pair.second; \n  } \n} \n```", "```cpp\ndouble NaCWidget::calculateMarkValue(int row, int column, \n                                     Mark mark) { \n  return qMax(qMax(countMarks(row, column, -1, 0, mark), \n                   countMarks(row, column, 0, -1, mark)), \n              qMax(countMarks(row, column, -1, 1, mark), \n                   countMarks(row, column, 1, 1, mark))); \n} \n```", "```cpp\n#include \"NaCWidget.h\" \n#include \"NaCWindow.h\" \n#include <QApplication> \n\nint main(int argc, char *argv[]) { \n  QApplication application(argc, argv); \n  NaCWindow mainWindow; \n  mainWindow.show(); \n  return application.exec(); \n} \n\n```"]