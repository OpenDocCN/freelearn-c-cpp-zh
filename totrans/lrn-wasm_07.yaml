- en: Creating an Application from Scratch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now it's time to apply your knowledge! Since one of WebAssembly's primary design
    goals is to execute within and integrate well with the existing web platform,
    it makes sense to build a web application to test it out. Even though WebAssembly's
    current feature set is rather limited, we can utilize the technology at a basic
    level. In this chapter, we will build a single-page application from scratch that
    utilizes Wasm modules within the context of the *Core Specification*.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you''ll know how to:'
  prefs: []
  type: TYPE_NORMAL
- en: Write functions that perform simple computations with C
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a basic JavaScript application with Vue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrate Wasm into your JavaScript application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify the capabilities and limitations of WebAssembly in its current form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run and test a JavaScript application using `browser-sync`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cook the Books – making WebAssembly accountable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned before, WebAssembly's current feature set is rather limited. We
    can use Emscripten to greatly extend the capabilities of a web application, but
    that carries the cost of noncompliance with the official specification and the
    addition of glue code. We can still use WebAssembly effectively today, which brings
    us to the application we'll build in this chapter. In this section, we will review
    the libraries and tools we'll use to build the application, as well as a brief
    overview of its functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Overview and functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In WebAssembly''s current form, we can pass numbers between a Wasm module and
    JavaScript code with relative ease. An accounting application seems like a logical
    choice in terms of real-world applicability. The only contention I have with accounting
    software is that it''s a little boring (no offense). We''re going to *spice it
    up* a bit by building in some unethical accounting practices. The application
    is named *Cook the Books*, a term associated with accounting fraud. Investopedia
    provides the following definition of Cook the Books:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Cook the Books is an idiom describing fraudulent activities performed by corporations
    in order to falsify their financial statements. Typically, cooking the books involves
    augmenting financial data to yield previously nonexistent earnings. Examples of
    techniques used to cook the books involve accelerating revenues, delaying expenses,
    manipulating pension plans, and implementing synthetic leases."'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Investopedia page at [https://www.investopedia.com/terms/c/cookthebooks.asp](https://www.investopedia.com/terms/c/cookthebooks.asp)
    offers detailed examples of what constitutes cooking the books. We''ll take a
    simple approach for our application. We will allow the user to enter a transaction
    with a raw and cooked amount. The raw amount represents the actual amount of money
    that was either deposited or withdrawn, while the cooked amount is what everyone
    else will see. The application will generate pie charts that display expenses
    and income by category for either the raw or cooked transactions. The user will
    be able to easily toggle between the two views. The application consists of the
    following components:'
  prefs: []
  type: TYPE_NORMAL
- en: Tabs for switching between transactions and charts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Table that displays transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Buttons that allow a user to add, edit, or remove a transaction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modal dialog for adding/updating a transaction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pie charts to display the income/expenses by category
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript libraries used
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The JavaScript portion of the application will use several libraries served
    from a CDN. It will also use one locally installed library to watch for changes
    in the code. The following sections will describe each library and its purpose
    in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Vue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vue is a JavaScript framework that allows you to split an application into individual
    components for ease of development and debugging. We're using it to avoid having
    one monolithic JavaScript file with all of our application logic and another monolithic
    HTML file with the entire UI. Vue was chosen because it doesn't require the added
    complexity of a build system and allows us to use HTML, CSS, and JavaScript without
    having to do any transpiling. The official website is [https://vuejs.org](https://vuejs.org).
  prefs: []
  type: TYPE_NORMAL
- en: UIkit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: UIkit is the frontend framework we will use to add styling and layout to our
    application. There are dozens of alternatives, like Bootstrap or Bulma, that offer
    comparable components and functionality. But I chose UIkit because of the helpful
    utility classes and added JavaScript functionality. You can view the documentation
    at [https://getuikit.com](https://getuikit.com).
  prefs: []
  type: TYPE_NORMAL
- en: Lodash
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lodash is an excellent utility library that provides methods for performing
    common actions in JavaScript that aren't already built into the language. We will
    use it to perform calculations and manipulate the transactions data. Documentation
    and installation instructions can be found at [https://lodash.com](https://lodash.com).
  prefs: []
  type: TYPE_NORMAL
- en: Data-driven documents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Data-driven documents** (**D3**) is a multi-faceted library that allows you
    to translate data into impressive visualizations. D3''s API consists of several
    modules that range from array manipulation to charting and transitions. We will
    use D3 primarily to create the pie charts, but we''ll also take advantage of some
    of the utility methods it provides. You can find more information at [https://d3js.org](https://d3js.org).'
  prefs: []
  type: TYPE_NORMAL
- en: Other libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to display currency values in the correct format and ensure the user
    enters a valid dollar amount, we will utilize the **accounting.js** ([http://openexchangerates.github.io/accounting.js](http://openexchangerates.github.io/accounting.js))
    and **vue-numeric** ([https://kevinongko.github.io/vue-numeric](https://kevinongko.github.io/vue-numeric))
    libraries. To simplify development, we'll set up a basic `npm` project and use
    **browser-sync** ([https://www.browsersync.io](https://www.browsersync.io)) to
    immediately see code changes reflected in the running application.
  prefs: []
  type: TYPE_NORMAL
- en: C and the build process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The application uses C since we're performing simple calculations with basic
    algebra. It wouldn't make sense to use C++ in this case. That would introduce
    the added step of ensuring the functions we need to call from JavaScript are wrapped
    in an `extern` block. We'll write the calculation functions in a single C file
    and compile it down to a single Wasm module. We can continue to use VS Code's
    Tasks functionality to perform the build, but the arguments will need to be updated
    since we'll only compile a single file. Let's move on to project configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WebAssembly hasn't been around long enough to have established best practices
    with regard to folder structure, file naming conventions, and so on. If you were
    to search for best practices for C/C++ or JavaScript projects, you'd encounter
    a great deal of conflicting advice and strongly held opinions. With that in mind,
    let's spend this section setting up our project with the required configuration
    files.
  prefs: []
  type: TYPE_NORMAL
- en: The code for this project is located in the `/chapter-07-cook-the-books` folder
    in the `learn-webassembly` repository. You must have this code available when
    we get to the JavaScript portion of the application. I won't be providing the
    source code for all of the Vue components in the book, so you need to copy them
    from the repository.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring for Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the interest of keeping the application as simple as possible, we'll avoid
    a build/bundling tool like Webpack or Rollup.js. This allows us to cut down on
    the number of required dependencies and ensures that any issues you run into aren't
    caused by a breaking change in a build dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll create a Node.js project because it allows us to run scripts and install
    a dependency locally for development purposes. We''ve used the `/book-examples`
    folder up to this point, but we''ll create a new project folder outside of `/book-examples`
    to configure a different default build task in VS Code. Open a terminal, `cd`
    into the desired folder, and enter the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-y` command forgoes the prompts and populates the `package.json` file
    with sensible defaults. Once completed, run the following command to install `browser-sync`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-D` is optional and indicates that the library is a development dependency.
    You would use the `-D` flag if you were building and distributing the application,
    so I included it to adhere to common practice. I''d recommend installing that
    specific version to ensure the `start` script runs without any issues. After `browser-sync`
    installs, add the following entry to the `scripts` entry in the `package.json`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If you run `npm init` with the `-y` flag, there should be an existing script
    named `test`, which I omitted for clarity. If you didn't run it with the `-y`
    flag, you may need to create the `scripts` entry.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can populate the `"description"` and `"author"` keys if desired. The file
    should end up looking similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you omit the `--no-open` flag from the `start` script, the browser will open
    automatically. The flag was included to prevent issues with users running in a
    headless environment.
  prefs: []
  type: TYPE_NORMAL
- en: Adding files and folders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create two new folders within the root folder: `/lib` and `/src`. The JavaScript,
    HTML, CSS, and Wasm files will be located in the `/src` folder while the C file
    will be in `/lib`. I only want to include files that are used by the web application
    in `/src`. We''ll never use the C file directly from the application, only the
    compiled output.'
  prefs: []
  type: TYPE_NORMAL
- en: Copy the `/.vscode` folder from your `/book-examples` project into the root
    folder. This will ensure you're using the existing C/C++ settings and give you
    a good starting point for the build task.
  prefs: []
  type: TYPE_NORMAL
- en: If you're using macOS or Linux, you'll have to use the terminal to copy the
    folder; you can accomplish this by running the `cp -r command`.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the build step
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to modify the default build step in the `/.vscode/tasks.json` file
    to accommodate our updated workflow. The arguments for the build step we used
    in our `/book-examples` project allowed us to compile whichever file was currently
    active in the editor. It also output the `.wasm` file into the same folder as
    the source C file. However, this configuration doesn''t make sense for this project.
    We''ll always compile the same C file that is output to the compiled `.wasm` file
    in a specific folder. To accomplish this, update the `args` array in the `Build`
    task in `/.vscode/tasks.json` with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We changed the input and output paths, which are the first and last elements
    in the `args` array. Now both are static paths that always compile and output
    the same files regardless of which file is open in the active editor.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a mock API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need some mock data and a means of persisting any updates. If you store
    the data locally in a JSON file, any changes you make to the transactions will
    be lost as soon as you refresh the page. We could set up a local server with a
    library like Express, mock a database, write routes, and so on. But instead we''re
    going to take advantage of the excellent development tooling available online.
    The online too jsonstore.io is allows you to store JSON data for small projects
    and provides endpoints out of the box. Take the following steps to get your mock
    API up and running:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to [https://www.jsonstore.io/](https://www.jsonstore.io/) and press
    the Copy button to copy the endpoint to your clipboard; this is the endpoint you'll
    be making HTTP requests to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the JSFiddle at [https://jsfiddle.net/mikerourke/cta0km6d](https://jsfiddle.net/mikerourke/cta0km6d),
    paste your jsonstore.io endpoint into the input, and press the Populate Data button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open up a new tab and paste your jsonstore.io endpoint in the address bar and
    add `/transactions` to the end of the URL and press *Enter*. If you see the contents
    of the JSON file in your browser, the API setup was successful.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Keep that jsonstore.io endpoint handy—you'll need it when we build the JavaScript
    portion of the app.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading the C stdlib Wasm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need the `malloc()` and `free()` functions from C's standard library for
    the functionality in our C code. WebAssembly doesn't have these functions built
    in, so we need to provide our own implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, someone has already built that for us; we just need to download
    the module and include it in the instantiation step. The module can be downloaded
    from Guy Bedford's `wasm-stdlib-hack` GitHub repository at [https://github.com/guybedford/wasm-stdlib-hack](https://github.com/guybedford/wasm-stdlib-hack).
    You need the `memory.wasm` file from the `/dist` folder. Once the file is downloaded,
    create a folder named `/assets` in the `/src` folder of your project and copy
    the `memory.wasm` file there.
  prefs: []
  type: TYPE_NORMAL
- en: You can copy the `memory.wasm` file from the `/chapter-07-cook-the-books/src/assets`
    folder of the `learn-webassembly` repository instead of downloading it from GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: The final result
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After performing these steps, your project should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Building the C portion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C portion of the application will aggregate transaction and category amounts.
    The calculations we perform in C could be done just as easily in JavaScript, but
    WebAssembly is ideal for computation. We'll dive deeper into more complex usage
    of C/C++ in [Chapter 8](384a3356-a9ca-4c3c-99e7-e632c6228a0b.xhtml), *Porting
    a Game with Emscripten*, but for now we're trying to limit our scope to what can
    be done within the confines of the *Core Specification*. In this section, we'll
    write some C code to demonstrate how to integrate WebAssembly with a web application
    without the use of Emscripten.
  prefs: []
  type: TYPE_NORMAL
- en: Overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will write some C functions that calculate the grand totals as well as the
    ending balances for raw and cooked transactions. In addition to calculating the
    grand totals, we need to calculate the totals for each category for display in
    the pie charts. All of these calculations will be performed in a single C file
    and compiled down to a single Wasm file that will be instantiated when the application
    loads. C can be a little daunting for the uninitiated, so our code will be sacrificing
    some efficiency for the sake of clarity. I'd like to take a moment to apologize
    to the C/C++ programmers reading this book; you're not going to like what you
    C.
  prefs: []
  type: TYPE_NORMAL
- en: In order to perform calculations dynamically, we need to allocate and deallocate
    memory as transactions are added and deleted. To accomplish this, we'll use a
    **doubly linked list**. A doubly linked list is a data structure that allows us
    to remove items or *nodes* inside a list and add and edit nodes as needed. Nodes
    are added using `malloc()` and removed using `free()`, both of which are provided
    by the `memory.wasm` module you downloaded in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: A note regarding workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The order of operations in terms of development doesn't reflect how you would
    normally build an application that uses WebAssembly. The workflow would consist
    of jumping between C/C++ and JavaScript to achieve the desired results. In this
    case, the functionality that we're offloading from JavaScript into WebAssembly
    is already known, so we'll write the C code up front.
  prefs: []
  type: TYPE_NORMAL
- en: C file contents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's walk through each section of the C file. Create a file in the `/lib` folder
    named `main.c` and populate it with the following contents in each section. It'll
    be easier to comprehend what's happening in the C file if we break it into smaller
    chunks. Let's start with the *Declarations *section.
  prefs: []
  type: TYPE_NORMAL
- en: Declarations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first section contains declarations we will use to create and traverse
    the doubly linked list, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `Node` struct is used to represent a transaction or category. The `transactionsHead`
    and `categoriesHead` node instances represent the first node in each linked list
    we'll use (one for transactions and one for categories). The `AmountType` the `enum`
    isn't required, but we'll discuss how it's useful when we get to the section of
    code that utilizes it.
  prefs: []
  type: TYPE_NORMAL
- en: Linked list operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The second section contains the two functions used to add and delete nodes
    from the linked list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The comments within the code describe what's happening at each step. When we
    need to add a Node to the list, we have to allocate the memory taken up by the
    `struct` `Node` using `malloc()` and append it to the last node in the linked
    list. If we need to delete a node, we have to remove it from the linked list and
    deallocate the memory that the node was using by calling the `free()` function.
  prefs: []
  type: TYPE_NORMAL
- en: transactions operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The third section contains functions to add, edit, and remove transactions
    from the `transactions` linked list, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `appendNode()` and `deleteNode()` functions we reviewed in the previous
    section aren't intended to be called from the JavaScript code. Instead, calls
    to `addTransaction()`, `editTransaction()`, and `removeTransaction()` are used
    to update the local linked list. The `addTransaction()` function calls the `appendNode()`
    function to add the data passed in as arguments to a new node in the local linked
    list. The `removeTransaction()` calls the `deleteNode()` function to delete the
    corresponding transaction node. The `findNodeById()` function is used to determine
    which node needs to be updated or deleted within the linked list based on the
    specified ID.
  prefs: []
  type: TYPE_NORMAL
- en: transactions calculations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The fourth section contains functions to calculate the grand totals and final
    balances for raw and cooked `transactions`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `AmountType enum` we declared in the declarations section is used here to
    avoid **magic numbers**. It makes it easy to remember that `1` represents raw
    transactions and `2` represents cooked transactions. The grand totals for both
    raw and cooked transactions are calculated in the `calculateGrandTotals()` function,
    even though we're only asking for one type in `getGrandTotalForType()`. Since
    we can only return a single value from a Wasm function, we end up looping through
    all of the transactions twice when we call `getGrandTotalForType()` for both raw
    and cooked transactions. With a relatively small amount of transactions and the
    simplicity of the calculation, this doesn't present any issues. The `getFinalBalanceForType()`
    returns the grand total plus the specified `initialBalance`. You'll see this in
    action when we add the ability to change initial balances in the web application.
  prefs: []
  type: TYPE_NORMAL
- en: Category calculations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The fifth and final section contains functions to calculate totals by category,
    which we''ll utilize in the pie charts, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `buildValuesByCategoryList()` function is called whenever the `recalculateForCategories()`
    or `getCategoryTotal()` functions are called. The function loops through all of
    the transactions in the `transactions` linked list and creates a node in a separate
    linked list for each corresponding category with the aggregated raw and total
    amounts. The `upsertCategoryNode()` function looks for a node that corresponds
    to the `categoryId` in the `categories` linked list. If it finds it, the raw and
    cooked transaction amounts are added to the existing amounts on that node, otherwise
    a new node is created for said category. The `recalculateForCategories()` function
    is called to ensure the category totals are up to date with any transactions changes.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling to Wasm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After populating the file, we need to compile it down to Wasm for use in the
    JavaScript portion of the application. Run the build task by selecting Tasks |
    Run Build Task... from the menu or using the keyboard shortcut *Cmd*/*Ctrl* +
    *Shift* + *B*. If the build was successful, you'll see a file named `main.wasm`
    in the `/src/assets` folder. If an error occurred, the terminal should provide
    details on how to resolve it.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re not using VS Code, open a terminal instance in the `/cook-the-books`
    folder and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: That's it for the C code. Let's move on to the JavaScript portion.
  prefs: []
  type: TYPE_NORMAL
- en: Building the JavaScript portion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The JavaScript portion of the application presents the transactions data to
    the user and allows them to easily add, edit, and remove transactions. The application
    is split across several files to simplify the development process and uses the
    libraries described in the *JavaScript libraries used* section of this chapter.
    In this section, we will build the application step by step, starting with the
    API and global state interaction layer. We'll write functions to instantiate and
    interact with our Wasm module and review the Vue components required to build
    the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The application is broken down into contexts to simplify the development process.
    We'll build the application from the bottom up to ensure we don't have to bounce
    back and forth between the different contexts when writing code. We'll start with
    the Wasm interaction code, then move on to the global store and API interaction.
    I'll describe the purpose of each Vue component, but the source code will only
    be provided for a select few. If you're following along and wish to run the application
    locally, you'll need to copy the `/src/components` folder from the `/chapter-07-cook-the-books`
    folder in the `learn-webassembly` repository into the `/src` folder of your project.
  prefs: []
  type: TYPE_NORMAL
- en: A note about browser compatibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start writing any code, you must ensure your browser supports the
    newer JavaScript features we'll use in the application. Your browser has to support
    ES Modules (`import` and `export`), the Fetch API, and `async` / `await`. You
    need at least Version 61 of Google Chrome or Version 60 of Firefox. You can check
    which version you're currently using by selecting About Chrome or About Firefox
    from the menu bar. I'm currently running the application with Chrome Version 67
    and Firefox Version 61 without any issues.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Wasm instance in initializeWasm.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You should have two compiled Wasm files in the `/src/assets` folder of your
    project: `main.wasm` and `memory.wasm`. Since we need to utilize the `malloc()`
    and `free()` functions exported from `memory.wasm` in the `main.wasm` code, our
    loading code is going to look different from the earlier examples. Create a file
    in the `/src/store` folder named `initializeWasm.js` and populate it with the
    following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The file''s default `export` function, `initializeWasm()`, performs the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `WebAssembly.Memory` instance (`wasmMemory`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the `fetchAndCompileModules()` function to get a `WebAssembly.Module` instance
    for `memory.wasm` (`compiledMemory`) and `main.wasm` (`compiledMain`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Instantiate `compiledMemory` (`memoryInstance`) and pass the `wasmMemory` into
    the `importObj`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pass `compiledMain`, `memoryInstance`, and `wasmMemory` into the `instantiateMain()`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Instantiate `compiledMain` and pass the exported `malloc()` and `free()` functions
    from `memoryInstance` along with `wasmMemory` into the `importObj`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the `exports` property of the `Instance` returned from `instantiateMain`
    (`mainInstance`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, the process is more complex when you have dependencies within
    Wasm modules.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that the `malloc` and `free` methods on the `memoryInstance` `exports`
    property weren't prefixed with an underscore. This is because the `memory.wasm`
    file was compiled using LLVM without Emscripten, which doesn't add the `_`.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with Wasm in WasmTransactions.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use JavaScript''s `class` syntax to create a wrapper that encapsulates
    the Wasm interaction functions. This allows us to make changes to the C code quickly
    without having to search through the entire application to find where Wasm functions
    are being called. If you rename a method in the C file, you only need to rename
    it one place. Create a new file in the `/src/store` folder named `WasmTransactions.js`
    and populate it with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When the `initialize()` function is called on an instance of the class, the
    return value of the `initializeWasm()` function is assigned to the `instance`
    property of the class. The `class` methods call functions from `this.instance`
    and, if applicable, return the desired results. Note the `AMOUNT_TYPE` object
    referenced in the `getCurrentBalances()` and `getCategoryTotals()` functions.
    This corresponds to the `AmountType enum` in our C file. The `AMOUNT_TYPE` object
    is declared globally in the `/src/main.js` file where the application is loaded.
    Now that we have our Wasm interaction code written, let's move on to API interaction
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing the API in api.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The API provides means for adding, editing, removing, and querying transactions
    in the form of HTTP methods defined on a fetch call. To simplify the process of
    performing these actions, we''ll write some API `wrapper` functions. Create a
    file in the `/src/store` folder named `api.js` and populate it with the following
    contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You'll need the jsonstore.io endpoint you created in the *Setting up the project*
    section in order to interact with the API. Replace `[JSONSTORE.IO ENDPOINT]` with
    your jsonstore.io endpoint. Ensure the endpoint doesn't end with a forward slash
    or the word transactions.
  prefs: []
  type: TYPE_NORMAL
- en: Managing global state in store.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The file that manages global state in the application has a lot of moving parts.
    Consequently, we will break the code down into smaller chunks and walk through
    each section individually. Create a file in the `/src/store` folder named `store.js`
    and populate it with the contents from each of the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: The import and store declarations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first section contains `import` statements and the `wasm` and `state` properties
    on the exported `store` object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: All API interaction is limited to the `store.js` file. Since we need to manipulate,
    add, and search transactions, all of the exported functions from `api.js` are
    imported. The `store` object holds the `WasmTransactions` instance in the `wasm`
    property and initial state in the `state` property. The values in `state` are
    referenced in multiple locations throughout the application. The `store` object
    will be added to the global `window` object when the application loads, so all
    components have access to the global state.
  prefs: []
  type: TYPE_NORMAL
- en: Transactions operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The second section contains functions that manage transactions in the Wasm
    instance (through the `WasmTransactions` instance) and the API, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `populateTransactions()` function fetches all of the transactions from the
    API and loads them into the global state and the Wasm instance. The category names
    are extrapolated from the `transactions` array in the `getCategories()` function.
    The results are passed to the `WasmTransactions` instance when `store.wasm.populateInWasm()`
    is called.
  prefs: []
  type: TYPE_NORMAL
- en: The `addTransaction()`, `editTransaction()`, and `removeTransaction()` functions
    perform the actions that correspond with their names. All three functions manipulate
    the Wasm instance and update the data on the API through a fetch call. Each of
    the functions call `this.hideTransactionModal()` because changes to a transaction
    can only be made through the `TransactionModal` component. Once the change is
    successfully made, the modal should close. Let's look at the `TransactionModal`
    management code next.
  prefs: []
  type: TYPE_NORMAL
- en: TransactionModal management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The third section contains functions to manage the visibility and content of
    the `TransactionModal` component (located in `/src/components/TransactionsTab/TransactionModal.js`)
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `showTransactionModal()` and `hideTransactionModal()` functions should be
    self-explanatory. The `hide()` or `show()` method of `UIkit.modal()` is called
    on the DOM element representing the `TransactionModal`. The `getActiveTransaction()`
    function returns the transaction record associated with the `activeTransactionId`
    value in global state.
  prefs: []
  type: TYPE_NORMAL
- en: Balances calculation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The fourth section contains functions that calculate and update the balances
    object in global state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `updateInitialBalance()` function sets the property value in the `balances`
    object in global state based on the `amount` and `fieldName` arguments. The `recalculateBalances()`
    function updates all of the fields on the `balances` object to reflect any changes
    made to the initial balances or transactions.
  prefs: []
  type: TYPE_NORMAL
- en: Store initialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final section of code in the file initializes the store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `initializeStore()` function instantiates the Wasm module, fetches all transactions
    from the API, and populates the contents of state. This function is called from
    the application loading code in `/src/main.js`, which we'll cover in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Loading the application in main.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need an entry point to load our application. Create a file in the `/src`
    folder named `main.js` and populate it with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This file is loaded after the libraries are fetched and loaded from CDNs in
    `/src/index.html`. We use the global `Vue` object to specify that we want to use
    the `VueNumeric` component. We add the `store` object exported from `/store/store.js`
    to `window` as `$store`. This isn't the most robust solution, but will be sufficient
    given the scope of the application. If you were creating a production application,
    you'd use a library like **Vuex** or **Redux** for global state management. We'll
    forego this approach in the interest of keeping things simple.
  prefs: []
  type: TYPE_NORMAL
- en: We also added `AMOUNT_TYPE` to the `window` object. This was done to ensure
    the entire application can reference the `AMOUNT_TYPE` value, rather than specify
    a magic number. After values are assigned to `window`, the `initializeStore()`
    function is called. If the `initializeStore()` function fired successfully, a
    new `Vue` instance is created to render the application. Let's add the web assets
    next, then move on to the Vue components.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the web assets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start adding Vue components to the application, let''s create the
    HTML and CSS files that house our markup and styles. Create a file in the `/src`
    folder named `index.html` and populate it with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re only using the HTML file to fetch libraries from CDNs, specify a `<div>`
    that Vue can render to, and load `main.js` to start the application. Note the
    `type="module"` attribute on the final `<script>` element. This allows us to use
    ES modules throughout our application. Now let''s add the CSS file. Create a file
    in the `/src` folder named `styles.css` and populate it with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This file has only a few classes because most of the styling will be handled
    at the component level. In the next section, we'll review the Vue components that
    make up our application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Vue components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With Vue, we can create separate components that encapsulate their own functionality,
    then compose these components to build an application. This makes debugging, extensibility,
    and change management much easier than storing the application in a single monolithic
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application uses a single-component-per-file development methodology. Before
    we start reviewing the component files, let''s look at the finished product. The
    following screenshot is of the application with the TRANSACTIONS tab selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5fd7ee43-480d-4d13-8b0c-370bd2f851ba.png)'
  prefs: []
  type: TYPE_IMG
- en: Running the application with TRANSACTIONS tab visible
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a screenshot of the application with the CHARTS tab selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/593e5d7b-16ae-416e-91c6-a44a890d495c.png)'
  prefs: []
  type: TYPE_IMG
- en: Running the application with the CHARTS tab visible
  prefs: []
  type: TYPE_NORMAL
- en: The structure of a Vue component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A Vue component is simply a file with an exported object containing properties
    that define how that component should look and behave. The properties must be
    given names that adhere to the Vue API. You can read about these properties and
    other aspects of the Vue API at [https://vuejs.org/v2/api](https://vuejs.org/v2/api).
    The following code represents an example component containing the elements of
    the Vue API used in this application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The comments above each property describe its purpose, albeit at a very high
    level. Let's see Vue in action by reviewing the `App` component.
  prefs: []
  type: TYPE_NORMAL
- en: The App component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `App` component is the base component that renders all of the child components
    in the application. We''ll briefly review the `App` component''s code to gain
    a better understanding of Vue. Going forward, we''ll describe the role each remaining
    component plays, but only review sections of the corresponding code. The contents
    of the `App` component file, located at `/src/components/App.js`, are shown as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the `components` property to specify the other Vue components we''ll
    render in the `template` for the `App` component. The `data()` function, which
    returns the local state, is used to keep track of balances and which tab is active
    (TRANSACTIONS or CHARTS). The `methods` property contains two functions: `onTransactionChange()`
    and `onTabClick()`. The `onTransactionChange()` function calls `$store.recalculateBalances()`
    and updates `balances` in local state if a change is made to a transaction record.
    The `onTabClick()` function changes the value of `activeTab` in the local state
    to the `data-tab` attribute of the clicked tab. Finally, the `template` property
    contains the markup used to render the component.'
  prefs: []
  type: TYPE_NORMAL
- en: If you're not using single file components in Vue (`.vue` extension), you need
    to convert the component name to kebab case in the template property. For example,
    in the `App` component shown earlier, `BalancesBar` was changed to `<balances-bar>`
    in the `template`.
  prefs: []
  type: TYPE_NORMAL
- en: The BalancesBar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `/components/BalancesBar` folder contains two component files: `BalanceCard.js`
    and `BalancesBar.js`. The `BalancesBar` component persists across the TRANSACTIONS
    and CHARTS tabs and is located directly under the tab control. It contains four
    of the `BalanceCard` components, one for each balance type: initial raw, current
    raw, initial cooked, and current cooked. The first and third cards representing
    the initial balances contain inputs so the balance can be changed. The second
    and fourth cards representing the current balances are calculated dynamically
    in the Wasm module (using the `getFinalBalanceForType()` function). The following
    snippet, taken from the `BalancesBar` component, demonstrates Vue''s binding syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `:` preceding the `value` and `onChange` attributes indicate that these
    properties are bound to the Vue component. If the value of `balances.initialRaw`
    changes, the value displayed in the `BalanceCard` will update as well. The `onBalanceChange()`
    function for this card updates the value of `balances.initialRaw` in global state.
  prefs: []
  type: TYPE_NORMAL
- en: The TransactionsTab
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `/components/TransactionsTab` folder contains the following four component
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ConfirmationModal.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TransactionModal.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TransactionsTab.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TransactionsTable.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `TransactionsTab` component contains the `TransactionsTable` and `TransactionsModal`
    components, as well as a button used to add new transactions. Changes and additions
    are done through the `TransactionModal` component. The `TransactionsTable` contains
    all of the current transactions with buttons on each row to either edit or delete
    the transaction. If the user presses the Delete button, the `ConfirmationModal`
    component appears and prompts the user to proceed. If the user presses Yes, the
    transaction is deleted. The following snippet, taken from the `methods` property
    in the `TransactionsTable` component, demonstrates how display values are formatted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `getFormattedTransactions()` function shown applies formatting
    to the `rawAmount`, `cookedAmount`, and `transactionDate` fields within each `transaction`
    record. This is done to ensure the value being displayed includes a dollar sign
    (for amounts) and is presented in a user-friendly format.
  prefs: []
  type: TYPE_NORMAL
- en: The ChartsTab
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `/components/ChartsTab` folder contains two component files: `ChartsTab.js`
    and `PieChart.js`. The `ChartsTab` component contains two instances of the `PieChart`
    component, one for income and one for expenses. Each `PieChart` component displays
    either the raw or cooked percentages by category. The user can switch between
    raw or cooked views via buttons directly above the chart. The `drawChart()` method
    in `PieChart.js` uses D3 to render the pie chart and legend. It uses D3''s built-in
    animations to animate each piece of the pie when loading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Running the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You've written and compiled the C code and added the frontend logic. It's time
    to start the application and interact with it. In this section, we will validate
    your application's `/src` folder, run the application, and test out the features
    to ensure everything is working correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Validating the /src folder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before starting the application, reference the following structure to ensure
    your `/src` folder is structured correctly and contains the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If everything matches up, you're ready to proceed.
  prefs: []
  type: TYPE_NORMAL
- en: Start it up!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start the application, open up a terminal in the `/cook-the-books` folder
    and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`browser-sync` the development dependency we installed in the first section
    of this chapter, acts as a local server (like the `serve` library). It makes the
    application accessible in the browser from the port specified in the `package.json`
    file (in this case, `4000`). If you navigate to `http://localhost:4000/index.html`
    in your browser, you should see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fc07674b-a7b5-4fd6-8593-6a0429558e2e.png)'
  prefs: []
  type: TYPE_IMG
- en: Application on initial load
  prefs: []
  type: TYPE_NORMAL
- en: We're using `browser-sync` instead of `serve` because it watches for changes
    in your files and automatically reloads the application if you make a change.
    To see this in action, try changing the contents of the title bar in `App.js`
    from `Cook the Books` to `Broil the Books`. The browser will refresh and you'll
    see the updated text in the title bar.
  prefs: []
  type: TYPE_NORMAL
- en: Testing it out
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To ensure everything is working correctly, let's test out the application. Each
    of the following sections describes an action and expected behavior for a particular
    function of the application. Follow along to see if you're getting the expected
    results. If you run into an issue, you can always refer back to the `/chapter-07-cook-the-books`
    folder in the `learn-webassembly` repository.
  prefs: []
  type: TYPE_NORMAL
- en: Changing initial balances
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Try changing the input values on the INITIAL RAW BALANCE and INITIAL COOKED
    BALANCE `BalanceCard` components. The CURRENT RAW BALANCE and CURRENT COOKED BALANCE card
    values should update to reflect your changes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new transaction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Make a note of the current raw and cooked balances, then press the blue Add
    button at the bottom-right corner of the window. It should load the `TransactionModal`
    component. Populate the inputs, make a note of the **Type**, **Raw Amount**, and
    **Cooked Amount** you entered, then press the Save button.
  prefs: []
  type: TYPE_NORMAL
- en: 'The balances should have updated to reflect the new amounts. If you picked
    Withdrawal for the **Type**, the balances should decrease, otherwise, they increase
    (for Deposit) as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dace2c59-c6f4-4039-ae01-3b6f3293777a.png)'
  prefs: []
  type: TYPE_IMG
- en: TransactionModal when adding a new transaction
  prefs: []
  type: TYPE_NORMAL
- en: Deleting an existing transaction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Pick a row within the `TransactionsTable` component, note the amounts, and
    press the button that looks like a trash can for that record. The `ConfirmationModal`
    component should appear. When you press the **Yes** button, the transaction record
    should no longer be present in the table and the current balances should update
    to reflect the amounts associated with the deleted transaction as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/850ece1d-3df5-4919-9380-e268ba3975b6.png)'
  prefs: []
  type: TYPE_IMG
- en: Confirmation modal shown after delete button is pressed
  prefs: []
  type: TYPE_NORMAL
- en: Editing an existing transaction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Follow the same procedure as you did for creating a new transaction, except
    change the existing amounts. Check the current balances to ensure they reflect
    the updated transaction amounts.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Charts tab
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Select the Charts tab to load the `ChartsTab` component. Press the buttons
    in each `PieChart` component to switch between the raw and cooked views. The pie
    charts should re-render with the updated values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/24cbe04a-2d49-49cb-9d5b-09cb6f6c3699.png)'
  prefs: []
  type: TYPE_IMG
- en: Contents of CHARTS tab with different amount types selected
  prefs: []
  type: TYPE_NORMAL
- en: Wrap up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations, you just built an application that uses WebAssembly! Tell your
    friends! Now that you understand the capabilities and limitations of WebAssembly,
    it's time to expand our horizons and use some of the excellent features Emscripten
    provides.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we built an accounting application from scratch that uses WebAssembly
    without any of the extra features Emscripten provides. By adhering to the *Core
    Specification*, we demonstrated the limitations of WebAssembly in its current
    form. However, we were able to perform computation quickly through the use of
    Wasm modules, which is well suited for accounting. We used Vue to split our application
    into components, UIkit for the design and layout, and D3 to create pie charts
    from our transactions data. In [Chapter 8](384a3356-a9ca-4c3c-99e7-e632c6228a0b.xhtml), *Porting
    a Game with Emscripten*, we'll take full advantage of Emscripten to port an existing
    C++ code base to WebAssembly.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why did we use Vue for this application (instead of React or Angular)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why did we use C instead of C++ for this project?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why did we need to set up a mock API using jsonstore.io instead of storing the
    data locally in a JSON file?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the name of the data structure we used for managing transactions in
    the C file?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which functions did we need from the `memory.wasm` file and what are they used
    for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why did we create a wrapper class around the Wasm module?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why did we make the `$store` object global?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which libraries could you use in a production application for managing global
    state?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why are we using `browser-sync`, instead of `serve`, to run the application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Vue: [https://vuejs.org](https://vuejs.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
