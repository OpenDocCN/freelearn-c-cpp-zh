<html><head></head><body>
		<div><h1 class="chapter-number" id="_idParaDest-129"><a id="_idTextAnchor188"/><a id="_idTextAnchor189"/>9</h1>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor190"/>Creating an Online Adventure Prototype</h1>
			<p>In this chapter, we will explore the fascinating world of an online space adventure game that has the potential<a id="_idIndexMarker292"/> to evolve into a <strong class="bold">massive multiplayer online role-playing game</strong> (<strong class="bold">MMORPG</strong>). Throughout this journey, we will lay the foundations for an immersive gaming experience, allowing players to join a persistent world and seamlessly synchronize their game state with the current state of the game world.</p>
			<p>Here’s a<a id="_idIndexMarker293"/> snapshot of what the final spaceshooter adventure prototype will look like:</p>
			<div><div><img alt="Figure 9.1 – Two players accomplishing the Destroy 10 Asteroids quest together" src="img/Figure_09.01_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – Two players accomplishing the Destroy 10 Asteroids quest together</p>
			<p>Our primary focus will be building a robust networking system that facilitates real-time interaction among players by using the powerful Godot Engine Network API. Through this system, players will connect to a central server, ensuring that everyone shares the same game world and can witness each other’s actions, promoting collaboration and a sense of togetherness.</p>
			<p>Furthermore, we will dive into the creation of a dynamic quest system capable of tracking player progress and storing this data in a database, so that when players come back, they will maintain their progress. Within our prototype of a space adventure, players will collaborate to complete missions such as destroying asteroids.<a id="_idTextAnchor191"/></p>
			<p>We will start the chapter by understanding the role of each piece of our game: the asteroids, the spaceship, and the player scene. Then, we will move to the core feature of an adventure game, the quest system, where we are going to learn how to pull and push data to the server and what builds up this robust system from both the server’s and player’s perspectives.</p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>Introducing the prototype</li>
				<li>Logging the player in to the server</li>
				<li>Separating server and client responsibilities</li>
				<li>Storing and retrieving data on the server<a id="_idTextAnchor192"/></li>
			</ul>
			<p>By the end of this chapter, you will have a solid foundation for an online adventure game that can expand into a vast and captivating MMORPG. Equipped with a persistent world, synchronized gameplay, and a quest system, you will be well prepared to build an engaging and dynamic online gaming experience.<a id="_idTextAnchor193"/></p>
			<h1 id="_idParaDest-131"><a id="_idTextAnchor194"/>Technical requirements</h1>
			<p>To access the resources for this chapter, go to our online project’s repository found at <a href="https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0">https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0</a>.</p>
			<p>With the repository in your computer, open the <code>res://09.prototyping-space-adventure</code> folder in the Godot Engine editor. You will find all the necessary files for this chapter there.</p>
			<p>Now, let us begin the onboarding process. In the next section, we will introduce the project, explore its main classes, and identify where we need to implement networking features.<a id="_idTextAnchor195"/><a id="_idTextAnchor196"/></p>
			<h1 id="_idParaDest-132"><a id="_idTextAnchor197"/>Introducing the prototype</h1>
			<p>In this <a id="_idIndexMarker294"/>section, we will gain a comprehensive understanding of the core systems driving our prototype. As the network engineers of our fictional studio, our role is core in transforming our local game prototype into an exciting online multiplayer game prototype. To accomplish this, we must familiarize ourselves with the major classes and files that make up our project.</p>
			<p>Let’s not overlook the significance of the onboarding process when we join a project. As network engineers, applying our knowledge and insights is essential for seamless integration into the development process. By understanding the core systems and concepts, we create a collaborative and productive environment, empowering the team to collectively bring our vision to life.</p>
			<p>So, let’s dive into the heart of our prototype and unlock the potential of online multiplayer gaming. By the end of this section, you will be equipped with the necessary systems you can tweak to shape an immersive and engaging online experience, uniting players in a dynamic and interconnected world. In the next section, let’s understand how the <code>Player</code> class and scene work<a id="_idTextAnchor198"/>.</p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor199"/>Understanding the Player scene</h2>
			<p>In any<a id="_idIndexMarker295"/> game, the player’s avatar is a fundamental element of the player’s experience. In this section, our goal is to understand the composition of the <code>Player</code> scene, the scene that represents the player’s avatar in our prototype.</p>
			<p>The <code>Player</code> scene is an abstract representation of the player as an entity in the game. It is a Node2D class that has a <code>Spaceship</code> scene, a <code>Weapon2D</code> scene, a <code>Sprite2D</code> node, a <code>HurtArea2D</code> node, a <code>CameraRemoteTransform2D</code> node, and, of course, the <code>Camera2D</code> node.</p>
			<div><div><img alt="Figure 9.2 – The Player scene ﻿node’s hierarchy" src="img/Figure_09.02_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – The Player scene node’s hierarchy</p>
			<p>Now, let’s<a id="_idIndexMarker296"/> understand the role of the main components of this scene, namely the <code>Spaceship</code> and <code>Weapon2D</code> nodes.</p>
			<p>The <code>Spaceship</code> node is a direct child of <code>Player</code> node and carries most of the other components, with the exception of the <code>Camera2D</code> node; instead, it uses the <code>CameraRemoteTransform2D</code> node to remotely transform the <code>Camera2D</code> node. The <code>Spaceship</code> node is a RigidBody2D node that simulates the movement of a body within an environment with no gravity and very low friction. It has two main methods, <code>Spaceship.thrust()</code> and <code>Spaceship.turn()</code>. In the following code, we can see how we implemented these methods:</p>
			<pre class="source-code">
class_name Spaceship2D
extends RigidBody2D
@export var acceleration = 600.0
@export var turn_torque = 10.0
func thrust():
    var delta = get_physics_process_delta_time()
    linear_velocity += (acceleration * delta) *
        Vector2.RIGHT.rotated(rotation)
func turn(direction):
    var delta = get_physics_process_delta_time()
    angular_velocity += (direction * turn_torque) * delta</pre>			<p>The <code>thrust()</code> method<a id="_idIndexMarker297"/> applies an acceleration force to <code>Spaceship.linear_velocity</code> property that makes it move. Then, the <code>turn()</code> method applies an acceleration force to the <code>Spaceship.angular_velocity</code> property that rotates it. We’ve set up the <code>Spaceship</code> node so that this is all it needs to perform a nice and smooth movement. It has some damping forces as well. In the following figure, we can see the properties related to the <code>Spaceship</code> scene to understand this movement better.</p>
			<div><div><img alt="Figure 9.3 – The Spaceship RigidBody2D properties settings" src="img/Figure_9.03_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – The Spaceship RigidBody2D properties settings</p>
			<p>The <code>Player</code> scene controls the <code>Spaceship</code> node’s movement simply by calling the <code>Spaceship.thrust()</code> and <code>Spaceship.turn()</code> methods based on the player’s inputs. In the following code snippet, we can see how this works in the <code>_physics_process()</code> callback:</p>
			<pre class="source-code">
extends Node2D
@export var thrust_action = "move_up"
@export var turn_left_action = "move_left"
@export var turn_right_action = "move_right"
@export var shoot_action = "shoot"
@onready var spaceship = $Spaceship
@onready var weapon = $Spaceship/Weapon2D
func _process(delta):
  if Input.is_action_pressed(shoot_action):
    weapon.fire()
func _physics_process(delta):
  if Input.is_action_pressed(thrust_action):
    spaceship.thrust()
  if Input.is_action_pressed(turn_left_action):
    spaceship.turn(-1)
  elif Input.is_action_pressed(turn_right_action):
    spaceship.turn(1)</pre>			<p>Now, if you are <a id="_idIndexMarker298"/>an attentive engineer, which at this point we can assume you are, you might have noticed that in the <code>_process()</code> callback, we call the <code>fire()</code> method on the <code>Weapon2D</code> node, right? Let’s understand how the <code>Weapon2D</code> node works; it’s another core class for us.</p>
			<p>The <code>Weapon2D</code> scene is a <code>Marker2D</code> node with <code>BulletSpawner2D</code>, <code>Timer</code>, <code>Sprite2D</code>, and <code>AnimationPlayer</code> nodes as its children. The following screenshot showcases the <code>Weapon2D</code> scene’s structure:</p>
			<div><div><img alt="Figure 9.4 – The Weapon2D scene’s node hierarchy" src="img/Figure_09.04_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – The Weapon2D scene’s node hierarchy</p>
			<p><code>BulletSpawner2D</code> instantiates<a id="_idIndexMarker299"/> bullets and gives them a direction based on <code>BulletSpawner2D</code>’s <code>global_rotation</code> value. We can see how this works in the following code block:</p>
			<pre class="source-code">
extends Spawner2D
func spawn(reference = spawn_scene):
  var bullet = super(reference)
  bullet.direction = Vector2.RIGHT.rotated(global_rotation)</pre>			<p>As for <code>Weapon2D</code>, it uses <code>Timer</code> to establish a fire rate in which if <code>Timer</code> is currently active, it can’t shoot. Otherwise, it plays the <code>"fire"</code> animation, spawns a bullet using whatever scene we set in its <code>bullet_scene</code> property, and starts <code>Timer</code> based on <code>Weapon2D</code>’s <code>fire_rate</code> value. By default, it shoots three bullets per second. In the following code, we can see how we implemented this behavior:</p>
			<pre class="source-code">
class_name Weapon2D
extends Marker2D
@export var bullet_scene: PackedScene
@export_range(0, 1, 1, "or_greater") var fire_rate = 3
@onready var spawner = $BulletSpawner2D
@onready var timer = $Timer
@onready var animation_player = $AnimationPlayer
func fire():
  if timer.is_stopped():
    animation_player.play("fire")
    spawner.spawn(bullet_scene)
    timer.start(1.0 / fire_rate)</pre>			<p>With that, players<a id="_idIndexMarker300"/> can shoot bullets and defend themselves while they accomplish their missions. One of these missions is to destroy some asteroids. So, in the next section, we are going to understand how the <code>Asteroid</code> scene works so we can move on to the quest system afterw<a id="_idTextAnchor200"/><a id="_idTextAnchor201"/>ard.</p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor202"/>Gauging the Asteroid scene</h2>
			<p>The <code>Asteroid</code> scene plays <a id="_idIndexMarker301"/>a fundamental role in our prototype. It represents an object that players must destroy in order to progress in a given mission. With the <code>Asteroid</code> scene working as planned, we can evaluate the quest system. In this section, we are going to understand how the <code>Asteroid</code> scene works so we have an idea of what to do in the process of turning the local gameplay prototype into an online multiplayer prototype.</p>
			<p>The <code>Asteroid</code> scene is a <code>Node2D</code> node with an <code>AnimationPlayer</code> node, a <code>Sprite2D</code> node, a <code>GPUParticle2D</code> node, a <code>HitArea2D</code> scene, a <code>HurtArea2D</code> scene, a <code>StaticBody2D</code> node, and a <code>QuestProgress</code> scene. We can see the scene structure in the following screenshot:</p>
			<div><div><img alt="Figure 9.5 – The Asteroid scene’s node hierarchy" src="img/Figure_09.05_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – The Asteroid scene’s node hierarchy</p>
			<p><code>HitArea2D</code> node <a id="_idIndexMarker302"/>applies <em class="italic">1</em> damage to players’ spaceships that touch it. When players shoot bullets, their <code>HitArea2D</code> node applies <em class="italic">1</em> damage to the <code>Asteroid</code> node if they hit its <code>HurtArea2D</code> node. If the <code>Asteroid</code> node doesn’t have any hit points left, it plays the <code>"explode"</code> animation, emitting some particles through <code>GPUParticles2D</code> node and putting itself in the queue so <code>SceneTree</code> frees it from memory as soon as the animation finishes.</p>
			<p>Doing so emits the <code>tree_exiting</code> signal, which is connected to <code>QuestProgress.increase_progress()</code> method. We are going to talk about <code>QuestProgress</code> node in the <em class="italic">Unraveling the quest system</em> section. The <code>Asteroid</code> node’s behavior is expressed in the following code snippet:</p>
			<pre class="source-code">
extends Node2D
@export var max_health = 3
@onready var health = max_health
@onready var animator = $AnimationPlayer
func apply_damage(damage):
  health -= damage
  if health &lt; 1:
    animator.play("explode")
  elif health &gt; 0:
    animator.play("hit")
func _on_hurt_area_2d_damage_taken(damage):
  apply_damage(damage)
func _on_animation_player_animation_finished(anim_name):
  if anim_name == "explode":
    queue_free()</pre>			<p>With that, the <code>Asteroid</code> node <a id="_idIndexMarker303"/>becomes a good testing subject for our quest system. In the next section, let’s understand how this system works and the important aspects that we should consider for the online multiplayer version of our prot<a id="_idTextAnchor203"/><a id="_idTextAnchor204"/>otype.</p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor205"/>Unraveling the quest system</h2>
			<p>It’s time to <a id="_idIndexMarker304"/>understand the very core of what defines an adventure game. In this section, we are going to understand how the quest system of our prototype works and what we can do with it. This will enlighten us with a good understanding of what we need to change in order to turn it into a system that works for an online multiplayer version of the game.</p>
			<p>Let’s get started!</p>
			<h3>Representing a quest as a node</h3>
			<p>In this <a id="_idIndexMarker305"/>section, we will understand how the <code>Quest</code> node works and what we can do with it. To do that, open the <code>res://09.prototyping-space-adventure/Quests/Quest.tscn</code> scene. As with all other components of the quest system, it is a node with a script. Open the script and let’s understand it.</p>
			<p>The <code>Quest</code> node ultimately represents a quest in the player’s quest log, and for that, it bundles all the data relevant to the quest itself:</p>
			<ul>
				<li>The <code>id</code> property that represents the quest in the database, <code>"asteroid_1"</code> by default.</li>
				<li>The quest’s <code>title</code>, <code>description</code>, and <code>target_amount</code> properties. Note that these are exported variables, so this allows our (fake) quest designers to directly create new quests using the <strong class="bold">Inspector</strong>. You can see the <strong class="bold">Inspector</strong> displaying all these properties in the following figures:</li>
			</ul>
			<div><div><img alt="Figure 9.6 – The Quest properties in the Inspector" src="img/Figure_9.06_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.6 – The Quest properties in the Inspector</p>
			<ul>
				<li>It also has <code>current_amount</code> property to track the player’s progress toward the quest’s target amount, and a <code>completed</code> property to tell whether the player has finished the quest already or not.</li>
				<li>On top of that, it has a setter method for <code>current_amount</code> property to process the received value. It ensures that the value is clamped between <code>0</code> and <code>target_amount</code> property. It also emits a signal notifying the quest was updated, and if <code>current_amount</code> property is equal to <code>target_amount</code> property, it emits a signal notifying that the quest was completed.</li>
			</ul>
			<p>In the following<a id="_idIndexMarker306"/> code snippet, we can see how this was implemented concretely:</p>
			<pre class="source-code">
extends Node
signal updated(quest_id, new_amount)
signal finished(quest_id)
@export var id = "asteroid_1"
@export var title = "Quest Title"
@export var description = "Insert Quest description here"
@export var target_amount = 1
var current_amount = 0 : set = set_current_amount
var completed = false
func set_current_amount(new_value):
  current_amount = new_value
  current_amount = clamp(current_amount, 0, target_amount)
  updated.emit(id, current_amount)
  if current_amount &gt;= target_amount:
    finished.emit(id)</pre>			<p>With that, we have an object that can represent a quest in our quest system. This is the very basic component of this system. As we saw, there is some data that makes up a <code>Quest</code>, right? This<a id="_idIndexMarker307"/> data is stored in a database so we can load and store the quest’s content. In the next section, we are going to see what this database looks like and how we can load quest content and store any changes made to thes<a id="_idTextAnchor206"/><a id="_idTextAnchor207"/>e quests.</p>
			<h3>Loading and storing quests with QuestDatabase</h3>
			<p>In any <a id="_idIndexMarker308"/>given adventure game, the players need quests to progress through the game story and overall world design. It is likely that these quests are stored in a place where quest designers can simply write them out and create an NPC to provide these quests to players.</p>
			<p>Since in our fake quest designers would need some kind of database to design the quests, we made the <code>QuestDatabase</code> singleton. It loads JSON files containing all the available quests in the game and the player’s progress in each of them. In this section, we will see how we can load these files and store the player’s progress so they won’t lose it when they leave the game, and how the <code>QuestDatabase</code> singleton provides this data to other classes.</p>
			<p>Open the scene provided in the <code>res://09.prototyping-space-adventure/Quests/QuestDatabase.tscn</code> file and you will also notice that it’s nothing more than a node with a script. In the <strong class="bold">Inspector</strong>, you’ll notice the path to two important files:</p>
			<div><div><img alt="Figure 9.7 – QuestDatabase’s Inspector" src="img/Figure_9.07_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.7 – QuestDatabase’s Inspector</p>
			<p>These are the<a id="_idIndexMarker309"/> JSON files that <code>QuestDatabase</code> uses to load the game’s quest and the player’s progress in the quests they have already started. The <code>PlayerProgress.json</code> file content is shown in the following code snippet:</p>
			<pre class="source-code">
{
  "asteroid_1": {
    "completed": false,
    "progress": 0
  }
}</pre>			<p>So, each quest is represented by its ID and a dictionary with an indication of whether they are already completed or not and the progress the player has currently made. Now, for <code>QuestDatabase.json</code>, it is a bit more complex; the file content is shown in the following code snippet:</p>
			<pre class="source-code">
{
    "asteroid_1" : {
        "title": "Destroy 10 Asteroids",
        "description": "Destroy some asteroids,
            please. They are taking too much space here",
        "target_amount": 10}
}</pre>			<p>Again, every <a id="_idIndexMarker310"/>quest is abstracted as a dictionary that reflects the quest’s ID. Inside the dictionary, we have the <code>"title"</code>, <code>"description"</code>, and <code>"target_amount"</code> keys, which contain important data regarding the quest’s object serialization and deserialization processes.</p>
			<p>Now, the <code>QuestDatabase</code> singleton has some important methods to load, read, process, store, and even allow other objects to access this data. Let’s briefly go through the main methods; you’ll notice there are some extra methods in the class, but they are essentially there to retrieve specific information about a quest’s data, such as the quest’s title.</p>
			<p>But let’s focus on the more relevant methods:</p>
			<ul>
				<li><code>QuestDatabase.load_database()</code>: Loads and deserializes the <code>QuestDatabase.json</code> and <code>PlayerProgress.json</code> files and stores their content, respectively, in the <code>quests_database</code> and <code>progress_database</code> member variables.</li>
				<li><code>QuestDatabase.store_database()</code>: Does the opposite of the preceding method, serializing the <code>quests_database</code> and <code>progress_database</code> member variables into their respective files.</li>
				<li><code>QuestDatabase.get_player_quests()</code>: Creates a <code>quest_data</code> dictionary for each key in the <code>progress_database</code> dictionary, gathering their data using the auxiliary methods, and returns a <code>quests</code> dictionary with all quests the player has started and their data.</li>
				<li><code>QuestDatabase.update_player_progress()</code>: Updates the player’s progress in a given quest. It receives a <code>quest_id</code>, <code>current_amount</code>, and <code>completed</code> argument to do so.</li>
			</ul>
			<p>In the <code>QuestDatabase</code> script, we can see the concrete implementation of this behavior and the auxiliary methods. You will notice there’s an implementation of the <code>_notification()</code> callback, which essentially calls the <code>store_database()</code> method when the application’s window receives a close request:</p>
			<pre class="source-code">
func _notification(notification):
    if notification == NOTIFICATION_WM_CLOSE_REQUEST:
        store_database()</pre>			<p>This guarantees that if the player quits the game through the usual means, for instance, clicking on the close button, their progress will be saved.</p>
			<p>With that, we <a id="_idIndexMarker311"/>have the quest data and player’s progress available at runtime and the quest system is almost done. We just need to know what we do with all that in the end, right? In the next section, we will understand how we use the intriguing <code>QuestProgress</code> nodes to update the system whenever a player makes progress in a <a id="_idTextAnchor208"/><a id="_idTextAnchor209"/>given quest.</p>
			<h3>Managing players’ quests</h3>
			<p>Now that<a id="_idIndexMarker312"/> we know that we can use the <code>QuestProgress</code> class when players get to progress in a given quest, we need to understand how these quests are managed in the system itself. In this section, we will understand how we retrieve quests from a quests database, how we create new quests for the current player based on the available quests retrieved, how we manage the player’s progress in a given quest, and how we communicate that the player has a new quest in their quest log.</p>
			<p>Open the scene available at <code>res://09.prototyping-space-adventure/Quests/QuestSingleton.tscn</code> and you will see it is a node with a script attached to it. Open the script and let’s understand what this scene does.</p>
			<p>As the singleton name, <code>Quests</code>, suggests, this scene is a set of all quests the player currently has. In the <em class="italic">Representing a quest as a node</em> section, we will see how we abstract each quest as an object with all the relevant properties, such as <code>title</code>, <code>description</code>, and <code>id</code>. The <code>QuestSingleton</code> class is responsible for retrieving and managing the quests.</p>
			<p>To do that, it <a id="_idIndexMarker313"/>has three core methods:</p>
			<ul>
				<li><code>QuestSingleton.retrieve_quests()</code>: Requests all the available quests for the players from the <code>QuestDatabase</code> singleton. We talked about <code>QuestDatabase</code> in the <em class="italic">Loading and storing quests with </em><em class="italic">QuestDatabase</em> section.</li>
				<li><code>QuestSingleton.create_quest()</code>: Receives a <code>quest_data</code> dictionary with all the relevant data to create a <code>Quest</code> node, then it instantiates a <code>Quest</code> and maps it to the <code>QuestSingleton.quests</code> dictionary using the quest ID. This allows other classes to access the <code>Quest</code> node using the quest ID in the upcoming method.</li>
				<li><code>QuestSingleton.get_quest()</code>: Receives a <code>quest_id</code> value as an argument and uses it to return the given <code>Quest</code> node associated with the provided ID.</li>
				<li><code>QuestSingleton.increase_quest_progress()</code>: Receives a <code>quest_id</code> value as an argument and an <code>amount</code> value to determine how much to increase in the provided quest’s progress.</li>
			</ul>
			<p>In the following code, we can see how these behaviors were implemented:</p>
			<pre class="source-code">
extends Node
signal quest_created(new_quest)
var quest_scene = preload("res://09.prototyping-space-
    adventure/Quests/Quest.tscn")
var quests = {}
func retrieve_quests():
  var player_quests = QuestDatabase.get_player_quests()
  for quest in player_quests:
    create_quest(player_quests[quest])
func create_quest(quest_data):
  var quest = quest_scene.instantiate()
  quest.id = quest_data["id"]
  quest.title = quest_data["title"]
  quest.description = quest_data["description"]
  quest.target_amount = quest_data["target_amount"]
  quest.current_amount = quest_data["current_amount"]
  quest.completed = quest_data["completed"]
  add_child(quest)
  quests[quest.id] = quest
  quest_created.emit(quest)
func get_quest(quest_id):
  return quests[quest_id]
func increase_quest_progress(quest_id, amount):
  var quest = quests[quest_id]
  quest.current_amount += amount
  QuestDatabase.update_player_progress(quest_id,
      quest.current_amount, quest.completed)</pre>			<p>With that, <code>QuestSingleton</code> is able to retrieve all the quests the player is currently engaged in and provide them to user classes so they can access and work with said quests. This <a id="_idIndexMarker314"/>will allow us to actually increase the players’ progress in a given quest. For that, we will understand how the <code>QuestProgr<a id="_idTextAnchor210"/>ess</code> node works.</p>
			<h3>Increasing quests’ progress</h3>
			<p>Back in the <code>Asteroid</code> scene, we have the <code>QuestProgress</code> node. This node is responsible for communicating to the quest system when the player makes progress in a given quest. To know which quest <code>QuestProgress</code> refers to, we use a variable called <code>quest_id</code>, and this is a fundamental concept in our quest system. Through this data, other classes of the system can communicate with each other, requesting changes or retrieving information about a given quest.</p>
			<p>On top of that, the <code>QuestProgress</code> class has a method called <code>increase_quest_progress()</code>, which requests <code>QuestSingleton</code>, referred to as <code>Quests</code>, to increase the quest’s progress by the <code>amount</code> value provided, by default <code>1</code>.</p>
			<p>We saw how <code>QuestSingleton</code> works in the <em class="italic">Managing players’ quests</em> section. Nonetheless, in the following code snippet, we can see the <code>QuestProgress</code> class’ code:</p>
			<pre class="source-code">
extends Node
@export var quest_id = "asteroid_1"
func increase_progress(amount = 1):
  Quests.increase_quest_progress(quest_id, amount)</pre>			<p>The<code>QuestProgress</code> node itself is a small component of the system that works on the very end of the system, where the final output is processed. It is meant to be used by other classes to trigger its behavior. For instance, as mentioned in the <em class="italic">Gauging the Asteroid scene</em> section, the <code>Asteroid</code> node uses its <code>tree_exiting</code> signal to trigger the <code>QuestProgress.increase_progress()</code> method.</p>
			<p>This concludes our quest system onboarding. Throughout this section, we understood how objects can increase a quest’s progress, how we retrieve quests and players’ progress from a database, how and what kind of data we store in the database files, and how this data ends up in a node in which we can implement higher-level behavior.</p>
			<p>Our <a id="_idIndexMarker315"/>onboarding process is not over yet. In the upcoming section, we will understand how players will actually see the quest information in <code>QuestPanel</code> node, which is a component of the last piece of our prototype, the <code>World</code> scene. It is in this scene that all the action actually happens, so stay focused, and let’s see<a id="_idTextAnchor211"/><a id="_idTextAnchor212"/><a id="_idTextAnchor213"/><a id="_idTextAnchor214"/><a id="_idTextAnchor215"/><a id="_idTextAnchor216"/><a id="_idTextAnchor217"/> how this works.</p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor218"/>Breaking down the World scene</h2>
			<p>Everything we’ve seen<a id="_idIndexMarker316"/> so far will come together into the <code>World</code> scene. This is the scene where everything is put together to interact. It’s the <code>World</code> scene that we use to test our current prototype. To do so, open the <code>res://09.prototyping-space-adventure/Levels/World.tscn</code> scene and hit the <strong class="bold">Run Current Scene</strong> button. You will be able to test the game and get a feel for the prototype.</p>
			<p>Now, in this section, we are going to understand how we create asteroids and players in the game, and how we display the player’s quest log on the screen. The world itself is a high-level abstraction scene, so things are easier to understand.</p>
			<p>The scene itself is a node called <code>Main</code> that has a <code>RadialSpawner</code> child node called <code>Asteroids</code> responsible for spawning asteroids around it, a <code>Spawner</code> node called <code>Players</code> responsible for spawning <code>Player</code> instances, and some <code>CanvasLayers</code> nodes to create the overall visual of the game, namely <code>BackgroundLayer</code> node, which uses a <code>ColorRect</code> node to set the game’s background color, then <code>ParallaxBackground</code> node, which has a <code>ParallaxLayer</code> node containing a <code>GPUParticles2D</code> node that creates a repeating starfield for the background.</p>
			<p>Finally, we also have <code>InterfaceCanvasLayer</code> node, which, as the name suggests, contains interface elements. Here, we have an important element to wrap up the quest system: <code>QuestPanel</code> node. We are going to talk about it in the <em class="italic">Displaying quest information</em> section. In the following screenshot, we can see the <code>World</code> scene node hierarchy:</p>
			<div><div><img alt="Figure 9.8 – The World scene node’s hierarchy" src="img/Figure_09.08_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.8 – The World scene node’s hierarchy</p>
			<p>Here, we were<a id="_idIndexMarker317"/> able to structure a prototype that spawns some Asteroids around a given area, spawns a pPlayer, and displays the player’s quest log with the current active quests and their information. In the next section, let’s understand how the <code>QuestPanel</code> node gathers, displays, and updates information about the<a id="_idTextAnchor219"/> player’s quests.</p>
			<h3>Displaying quest information</h3>
			<p>In the end, the<a id="_idIndexMarker318"/> quest system has a main responsibility that summarizes everything we’ve seen so far regarding it. It has to display information about the current active quests to the player. This funnels down to <code>QuestPanel</code> node, which is a UI element that displays such information based on the data it gathers from <code>QuestSingleton</code> node. In this section, we are going to understand how <code>QuestPanel</code> node works. To do so, open the <code>res://09.prototyping-space-adventure/Quests/QuestPanel.tscn</code> scene.</p>
			<p>Note that <code>QuestPanel</code> node itself extends the <code>ScrollContainer</code> class and it has a <code>VBoxContainer</code> node as its child. This allows us to display many quests for the player and they will be able to navigate these quests using a scrollbar. We currently have only one quest, as seen in the <code>QuestDatabase.json</code> file, but the ground is paved for more quests. Now, open the <code>QuestPanel</code> script, and let’s see how it implements displaying quest information.</p>
			<p>The first thing it does right at the <code>_ready()</code> callback is to connect the <code>Quests</code> singleton’s <code>quest_created</code> signal to <code>QuestPanel</code>’s <code>add_quest()</code> method. Then it tells the <code>Quests</code> singleton to retrieve quests, which will populate the <code>Quests</code> singleton with the players’ quests. Every time the <code>Quests</code> singleton creates a new <code>Quest</code> node, adding it as its child, it emits a signal that the <code>QuestPanel</code> node listens to and calls the <code>add_quest()</code> method. Let’s <a id="_idIndexMarker319"/>talk about the <code>QuestPanel</code> node member variables and methods:</p>
			<ul>
				<li><code>quests_labels</code> is a dictionary used to map <code>Label</code> nodes to their reference using the <code>Quest.id</code> property as the key.</li>
				<li>The <code>add_quest()</code> method creates a new <code>Label</code> node and sets its <code>text</code> property to a formatted String using the information from the <code>Quest</code> node stored in the quest property. It also connects the <code>quest.updated</code> signal to its <code>update_quest()</code> method, which we are going to talk about in a moment. Then, it adds this <code>Label</code> node as a child of the<code>VBoxContainer</code> node and maps it in the <code>quests_labels</code> property for further reference.</li>
				<li>The <code>update_quest()</code> method takes the <code>quest_id</code> String and the <code>current_amount</code> integer as arguments, and uses the <code>quest_id</code> argument to find the proper <code>Label</code> node to update the text with the updated quest data.</li>
			</ul>
			<p>This behavior is expressed in the following code snippet if you want to understand the concrete implementation of how this all happens:</p>
			<pre class="source-code">
extends ScrollContainer
var quest_labels = {}
func _ready():
  Quests.quest_created.connect(add_quest)
  Quests.retrieve_quests()
func add_quest(quest):
  var label = Label.new()
  var quest_data = "%s \n %s/%s \n \n %s" %[quest.title,
      quest.current_amount, quest.target_amount,
          quest.description]
  label.autowrap_mode = TextServer.AUTOWRAP_WORD_SMART
  label.text = quest_data
  $VBoxContainer.add_child(label)
  quest.updated.connect(update_quest)
  quest_labels[quest.id] = label
func update_quest(quest_id, current_amount):
  var quest = Quests.get_quest(quest_id)
  var quest_data_text = "%s \n %s/%s \n \n %s" %
      [quest.title, quest.current_amount,
          quest.target_amount, quest.description]
  var label = quest_labels[quest_id]
  label.text = quest_data_text</pre>			<p>With that, we close our <a id="_idIndexMarker320"/>quest system onboarding, and you are ready to understand how you will use it for our online multiplayer version of the prototype! You’ve seen it all, how objects can update quest progress, where quests are gathered and stored, how we load and save a player’s progress in a given quest, how we implement a node to represent a quest in our game, and finally, how this all comes together to display the quest’s information to the player in a <a id="_idIndexMarker321"/>UI element.</p>
			<p>In the upcoming section, we will see how the World’s <code>Main</code> node works. Its main responsibility is to ensure the game world is running as planned with all objects in<a id="_idTextAnchor220"/><a id="_idTextAnchor221"/> their proper places.</p>
			<h3>Initializing the game world</h3>
			<p>To ensure<a id="_idIndexMarker322"/> that the game runs as we plan, at least its initialization, we have the <code>Main</code> node. It essentially spawns 30 <code>Asteroid</code> instances using the <code>Asteroids</code> node and creates an instance of the <code>Player</code> scene using the <code>Players</code> node. As explained at the beginning of the <em class="italic">Breaking down the World scene</em> section, the latter two nodes are spawners.</p>
			<p>In this local gameplay prototype, the <code>Main</code> node is really simple, but keep it in mind, especially regarding its responsibility, when you start implementing the online multiplayer features. For reference, the <code>Main</code> node script is shown in the following code snippet:</p>
			<pre class="source-code">
extends Node
@onready var asteroid_spawner = $Asteroids
@onready var player_spawner = $Players
func _ready():
  for i in 30:
    asteroid_spawner.spawn()
  create_spaceship()
func create_spaceship():
  player_spawner.spawn()</pre>			<p>Note that it has a <code>create_spaceship()</code> method instead of directly calling the <code>player_spawner.spawn()</code> method. This will help you with your job later on, so you can thank our fake team for making your job easier.</p>
			<p>And with that, your onboarding process is done! We’ve seen how the player controls their spaceship, how the asteroids take hits and explode, increasing the player’s progress in a quest, how the quest system works, and what it handles and outputs. We’ve also just seen how the<a id="_idIndexMarker323"/> game world initializes and establishes where each object should be and how many of them there should be.</p>
			<p>Now, it’s time for the magic. In the upcoming sections, we are going to see how we will turn this prototype into an online multiplayer game prototype where players can join anytime, so there won’t be a lobby. We will also understand what we need to do to keep the players’ world in sync with the server’s world and how we separate the server and client’s responsibilities using the same script. This will be useful especially when handling our databases to prevent players from cheating and completing<a id="_idTextAnchor222"/><a id="_idTextAnchor223"/><a id="_idTextAnchor224"/><a id="_idTextAnchor225"/> quests without effort.</p>
			<h1 id="_idParaDest-137"><a id="_idTextAnchor226"/>Logging the player in to the server</h1>
			<p>In this section, we will <a id="_idIndexMarker324"/>implement a different type of logging system. This time, the players don’t have a lobby screen where they wait for other players to join a game and start a match. No, here the world is always active; it doesn’t start only when the players ask the server to start the match or the game. And this type of connection requires a different approach.</p>
			<p>The major problem is that since the game world is always active and running, the players who join this world need to sync their game instance to the server’s game instance. This includes the position of objects, new objects that usually are not part of the world, for instance, other players and the number of objects (in our case, how many asteroids are currently available), and many other factors necessary to build a shared world.</p>
			<p>It all starts with the player authentication, because now the server and the client are in different parts of the game life cycle; while the player is just opening the game, the server is already <a id="_idTextAnchor227"/>handling the game world.</p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor228"/>Authenticating players</h2>
			<p>Don’t panic, yet. Besides <a id="_idIndexMarker325"/>the conditions of authentication being different, the overall logic is very much the same as the one we’ve been using so far. The major difference here is that we will need to have an <code>Authentication</code> node dedicated to each side of the connection performing the authentication procedure according to the client or server’s responsibilities.</p>
			<p>These <a id="_idIndexMarker326"/>nodes will be on the two major points of interaction for each side of the connection:</p>
			<ul>
				<li>For the client, in this case the player, we will have the <code>Authentication</code> node on the <code>LoggingScreen</code> scene</li>
				<li>For the server we will have its <code>Authentication</code> node on the <code>World</code> scene itself, waiting for players to join</li>
			</ul>
			<p>Note that for each side of this relationship, we will implement distinct authentication procedures. So, besides both nodes being called <code>Authentication</code> and having the same path, in other words, both being direct children of a parent node called <code>Main</code>, they will be totally different classes.</p>
			<p>They will need shared methods, but we will see that the method implementations are different. This is all due to how RPCs work. Remember, when making an RPC, it will look for a node with the same node path in all peer game instances, and this node must have all the same methods as the one making the RPC, even if we are not calling these other methods. This means that the server side will share client-side methods, and vice versa.</p>
			<p>This will get<a id="_idIndexMarker327"/> less confusing once we start to implement it, so let’s open the <code>res://09.prototyping-space-adventure/LoggingScreen.tscn</code> scene and implement the client <a id="_idTextAnchor229"/>side of the authentication.</p>
			<h3>Implementing client-side authentication</h3>
			<p>In<a id="_idIndexMarker328"/> the <code>LoggingScreen</code> scene, you will notice a scene structure meant to be a simple logging screen where players insert their credentials, get authenticated, and log in to the game. This is a bit similar to the lobby we’ve been using in previous chapters, such as the one in <a href="B18527_08.xhtml#_idTextAnchor162"><em class="italic">Chapter 8</em></a>, <em class="italic">Designing an Online </em><em class="italic">Co-Op Platformer</em>.</p>
			<p>This time, we don’t have a panel showcasing the current players; this is not necessary as players can join the game and experience individually even when other players are not around. Note that the scene’s script is attached to the <code>Authentication</code> node this time, instead of attached to the <code>Main</code> node.</p>
			<p>This is because in the <code>World</code> scene, the <code>Main</code> node has other responsibilities, so it’s better to delegate the authentication to an exclusive node. Due to that, <code>LoggingScreen</code>’s authentication was also delegated to its <code>Authentication</code> node.</p>
			<div><div><img alt="Figure 9.9 – The LoggingScreen scene’s node hierarchy&#13;&#10;" src="img/Figure_09.09_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.9 – The LoggingScreen scene’s node hierarchy</p>
			<p>Now, open<a id="_idIndexMarker329"/> the <code>res://09.prototyping-space-adventure/LoggingScreen.gd</code> script file. You will notice there are a lot of things in common with what we’ve created in <a href="B18527_03.xhtml#_idTextAnchor065"><em class="italic">chapter 3</em></a>, <em class="italic">Making a Lobby to Gather Players Together</em>, so let’s focus on the necessary work we need to do this time:</p>
			<ol>
				<li>Since this time we are only communicating with the server, we don’t need to start the game on all peers, so in the <code>_on_StartButton_pressed()</code> callback, we need to send an RPC directly to the server asking it to start the game:<pre class="source-code">
func _on_StartButton_pressed():
  rpc_id(1, "start_game")</pre></li>				<li>The server<a id="_idIndexMarker330"/> itself will then authenticate the player, and if everything goes well, the server will also call the client’s <code>start_game()</code> method, which has a different implementation. In the client, <code>start_game()</code> is an RPC that only the network authority can call and is called locally. When called, it switches the current scene to the <code>next_scene</code> property, which in this case will be the <code>World</code> scene:<pre class="source-code">
@rpc("authority", "call_local")
func start_game():
  get_tree().change_scene_to_file(next_scene)</pre></li>			</ol>
			<p>Alright, most of the code is very similar to the <code>one</code> we have in the implementations of the <code>Lobby</code> scene. This one is cleaner as we’ve removed other methods such as the ones we used to display logged players or display avatars.</p>
			<p>With these changes, this code is able to send a direct request authentication for the server and start the game on this instance of the game. In the next section, we will see the other side of <a id="_idTextAnchor230"/><a id="_idTextAnchor231"/>this system, the server side.</p>
			<h3>Implementing server-side authentication</h3>
			<p>Now, the <a id="_idIndexMarker331"/>server-side authentication is a bit trickier. Previously, all that we needed to do was to handle the player’s authentication requests. But now, since the authentication happens while the server is already running the game, we need to transfer the responsibility of setting up the hosting as well.</p>
			<p>This means that if the current instance is the server, it will need to set up <code>ENetMultiplayerPeer</code> on top of authenticating players’ credentials as well. Open the <code>res://09.prototyping-space-adventure/Authentication.gd</code> file and let’s make the necessary changes.</p>
			<p>Again, we will focus only on what we need to change based on the work we did previously, so feel free to go through the other parts of the script if you don’t remember how this all works:</p>
			<ol>
				<li>In the <code>_ready()</code> callback, let’s create the <code>ENet</code> server using the default <code>PORT</code>. Remember, since this script will be running on both the client and server, we will need to check whether the current instance running is the server. For that, we use the <code>multiplayer.is_server()</code> method. After setting up the server, we load the <a id="_idIndexMarker332"/>users’ database to properly authenticate them as usual:<pre class="source-code">
func _ready():
    if multiplayer.is_server():
        peer.create_server(PORT)
        multiplayer.multiplayer_peer = peer
        load_database()</pre></li>				<li>The second thing we need to do is to connect as a client if the instance is not the server:<pre class="source-code">
    else:
        peer.create_client(ADDRESS, PORT)
        multiplayer.multiplayer_peer = peer</pre></li>				<li>The third thing we need to do is to set up the <code>start_game()</code> method to respond to all peers remotely, so this method won’t be called locally in the server’s instance. Inside this method, we will make an RPC to the peer that requested the game to start telling their instance to start the game.<p class="list-inset">This allows the server to dictate whether the player can or cannot join the game, and if the player happens to try to connect locally, simply pressing the start button won’t actually start the game as their instance will hang, waiting for a response from the server:</p><pre class="source-code">
@rpc("any_peer", "call_remote")
func start_game():
    var peer_id = multiplayer.get_remote_sender_id()
    rpc_id(peer_id, "start_game")</pre></li>			</ol>
			<p>With these changes, we are able to have a server that can run an independent instance of the game and wait for players to join it. Using the <code>rpc_id()</code> method, we can pinpoint which peer we want to contact and establish direct communication between instances of the game. In this case, we did that with the server and the client, but we can do it between <a id="_idIndexMarker333"/>two clients as well if necessary.</p>
			<p>In the next section, we are going to focus on how to sync the server’s persistent <code>World</code> scene with the players’ <code>World</code> scene, which may not reflect the current<a id="_idTextAnchor232"/><a id="_idTextAnchor233"/><a id="_idTextAnchor234"/> state of the shared game world.</p>
			<h2 id="_idParaDest-139"><a id="_idTextAnchor235"/>Syncing the World scenes</h2>
			<p>When the player<a id="_idIndexMarker334"/> logs in to the game, their world will likely be different from the server’s world. For instance, only the server should be able to spawn asteroids, and even if the client were able to spawn them, there would be nothing to guarantee they would be in the same position. So, this is the first thing we are going to fix.</p>
			<p>In the next section, we will see how we can sync the <code>Asteroid</code> instances from the server<a id="_idTextAnchor236"/>’s world into the client’s world.</p>
			<h3>Syncing the asteroids</h3>
			<p>Open <a id="_idIndexMarker335"/>the <code>Asteroid</code> scene again and let’s add a new <code>MultiplayerSynchronizer</code> as its child. This <code>MultiplayerSynchronizer</code> will replicate the asteroid’s <code>position</code> and <code>top_level</code> properties. The following figure showcases the asteroid’s <strong class="bold">MultiplayerSynchronizer Replication </strong><strong class="bold">Menu</strong> settings.</p>
			<div><div><img alt="Figure 9.10 – The Asteroid’s MultiplayerSynchronizer Replication Menu settings" src="img/Figure_09.10_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.10 – The Asteroid’s MultiplayerSynchronizer Replication Menu settings</p>
			<p>Then, we are<a id="_idIndexMarker336"/> going to use something really interesting regarding network replication. The <code>MultiplayerSynchronizer</code> node has a property called <code>World</code> scene. So, we will toggle that property off. In the following screenshot, we can see what this property should look like in the <strong class="bold">Inspector</strong>.</p>
			<div><div><img alt="Figure 9.11 – The asteroid’s MultiplayerSynchronizer Public Visibility property in the Inspector" src="img/Figure_9.11_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.11 – The asteroid’s MultiplayerSynchronizer Public Visibility property in the Inspector</p>
			<p>Before we move on to the next necessary steps, I want to present you with a trick that will help you synchronize relevant objects all at once. Add <code>MultiplayerSynchronizer</code> node inside a group so that you can perform a group call using <code>SceneTree</code> later on. In this case, to be clearer about the group’s intent, let’s call it <code>Sync</code>. The following screenshot showcases this group with the <code>Asteroid</code> node’s <code>MultiplayerSynchronizer</code> node inside of it.</p>
			<div><div><img alt="Figure 9.12 – The asteroid’s MultiplayerSynchronizer inside the Sync group" src="img/Figure_9.12_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.12 – The asteroid’s MultiplayerSynchronizer inside the Sync group</p>
			<p>With that, the <code>Asteroid</code> instances <a id="_idIndexMarker337"/>are ready to replicate their properties on the client’s <code>World</code> instance. But there’s still a problem. The client’s <code>World</code> instance should not create these <code>Asteroid</code> instances; instead, only the server should be able to spawn these objects. So, let’s open the <code>World</code> scene and set it up for synchronization:</p>
			<ol>
				<li>The first thing we need to do is to add a <code>MultiplayerSpawner</code> node that points to the <code>Asteroids</code> node. Let’s call it <code>AsteroidsMultiplayerSpawner</code>, and it should have the <code>Asteroid</code> scene set up as its first and only element in the <strong class="bold">Auto Spawn List</strong> property. We can see these properties configured in the following screenshot:</li>
			</ol>
			<div><div><img alt="Figure 9.13 – The world’s AsteroidsMultiplayerSpawner properties in the Inspector" src="img/Figure_9.13_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.13 – The world’s AsteroidsMultiplayerSpawner properties in the Inspector</p>
			<p class="list-inset">This will <a id="_idIndexMarker338"/>ensure that all the instances of the server’s world asteroids will also exist in the client’s world as well. But note that until now, they will only be spawned, but not synced yet. So, let’s fix that. Open the <code>World</code> script and let’s set it up for the sync logic.</p>
			<ol>
				<li value="2">First things first, in the <code>_ready()</code> callback, we need to prevent the <code>World</code> node from spawning asteroids if it isn’t the server. It should request synchronization from the server instead. For that, it will make an RPC to the server’s <code>sync_world</code> method, which we will create in the next step:<pre class="source-code">
func _ready():
  if not multiplayer.get_unique_id() == 1:
    rpc_id(1, "sync_world")
  else:
    for i in 30:
      asteroid_spawner.spawn()</pre></li>				<li>Then, let’s create the <code>sync_world()</code> RPC method, which can be called by any peer locally. It needs to be called locally because we will tell the server’s <code>Asteroid</code> instances’ <code>MultiplayerSynchronizer</code> nodes, which are in the <code>Sync</code> group, to add the player to their visibility list, effectively syncing the <code>Asteroid</code> instances.<pre class="source-code">
@rpc("any_peer", "call_local")
func sync_world():
    var player_id = multiplayer.get_remote_sender_id()
    get_tree().call_group("Sync", "set_visibility_for
        ",player_id, true)</pre></li>			</ol>
			<p><code>set_visibility_for()</code> is a<a id="_idIndexMarker339"/> method from the <code>MultiplayerSynchronizer</code> node that adds a peer to its visibility list, which basically means a whitelist of peers it should synchronize to.</p>
			<p>For that, it uses the peer’s ID and receives a Boolean to tell it whether this peer should or shouldn’t see the replication of the properties set in <code>multiplayer.get_remote_sender_id()</code> method, so whoever requests to sync will be synced.</p>
			<p>This is all we need for the syncing of the asteroids. Now, we are still missing the players and their spaceships, right? In the next section, we will see how to remotely create <code>Player</code> instances on all connected peers, sync their spaceships, and only allow the<a id="_idTextAnchor237"/><a id="_idTextAnchor238"/>ir owner to control the spaceship.</p>
			<h3>Syncing the players</h3>
			<p>It’s time to put our<a id="_idIndexMarker340"/> players together in this vast world. In this section, we will understand how we sync players’ scenes that were already in the World when another player joins the game.</p>
			<p>Let’s get started:</p>
			<ol>
				<li>Still in the <code>World</code> script, we are going to turn the <code>create_spaceship()</code> method into an RPC method that any peer can call remotely:<pre class="source-code">
@rpc("any_peer", "call_remote")
func create_spaceship():</pre></li>				<li>Due to <a id="_idIndexMarker341"/>how the <code>Players</code> spawner works, we won’t be able to do the proper renaming and identification of the newly created spaceship before it syncs to other peers. So, the <code>create_spaceship()</code> method takes the responsibility of spawning spaceships as well.<p class="list-inset">Before we add the <code>spaceship</code> instance as a child of the <code>Players</code> node, we will set its name to match the player’s peer ID. This ensures this instance has a unique name and we can use this name to identify the proper authority of the instance:</p><pre class="source-code">
  var player_id = multiplayer.get_remote_sender_id()
var spaceship = preload("res://09.prototyping-space-
adventure/Actors/Player/Player2D.tscn").instantiate()
  spaceship.name = str(player_id)
  $Players.add_child(spaceship)</pre></li>				<li>Now we come to a very important part. We are going to implement the <code>setup_multiplayer()</code> method in the player, which essentially does the same thing as the one we made in <a href="B18527_08.xhtml#_idTextAnchor162"><em class="italic">Chapter 8</em></a>, <em class="italic">Designing an Online Co-Op Platformer</em>. So, we can make an RPC to this function here after waiting for <code>0.1</code> seconds:<pre class="source-code">
  await(get_tree().create_timer(0.1).timeout)
  spaceship.rpc("setup_multiplayer", player_id)</pre><p class="list-inset">With that, whenever a player asks the server’s <code>World</code> instance to create a spaceship, it will instantiate a <code>Player</code> scene, assign it a unique ID, and ask it to configure its multiplayer settings. Remember, since we are doing this using an RPC, this means this <code>Player</code> instance will configure its multiplayer settings in all currently connected peers. But as it is now, only the server has an instance of this <code>Player</code> node.</p></li>				<li>To fix that, we<a id="_idIndexMarker342"/> are going to add another <code>MultiplayerSpawner</code> node called <code>PlayersMultiplayerSpawner</code> to the <code>World</code> scene. Its <code>Players</code> node and its <code>Player</code> scene, <code>res://09.prototyping-space-adventure/Actors/Player/Player2D.tscn</code>. In the following screenshot, we can see these properties set up in the <strong class="bold">Inspector</strong>.</li>
			</ol>
			<div><div><img alt="Figure 9.14 – The World scene’s PlayersMultiplayerSpawner node properties in the Inspector" src="img/Figure_9.14_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.14 – The World scene’s PlayersMultiplayerSpawner node properties in the Inspector</p>
			<p class="list-inset">Now, since the instances created by the <code>PlayersMultiplayerSpawner</code> node will still not be configured yet, we also need to call their <code>setup_multiplayer()</code> method as soon as they spawn.</p>
			<ol>
				<li value="5">For that, let’s connect the <code>PlayersMultiplayerSpawner</code>‘s <code>spawned</code> signal to the <code>World</code> scene’s <code>Main</code> node script, and inside then <code>_on_players_multiplayer_spawner()</code> callback, we make an RPC on the recently spawned node passing <code>set_up_multiplayer</code> as argument. This time, we will use the node’s name as an argument instead of <code>player_id</code>. This is because we don’t have access to the ID of the player that is supposed to own this instance, so we can use the instance name instead:<pre class="source-code">
func _on_players_multiplayer_spawner_spawned(Node):
    Node.rpc("setup_multiplayer", int(str(Node.name)))</pre></li>				<li>With that, every<a id="_idIndexMarker343"/> time a player joins the game, the server will create a new <code>Player</code> instance for them and set this instance up. This also works for <code>Player</code> instances that are already in the server’s <code>World</code>.<p class="list-inset">If a player joins the game, the server will spawn all other <code>Player</code> instances that are also currently playing. Now, we need the <code>Player</code> scene itself to sync its relevant properties to its peers and to implement its <code>setup_multiplayer</code> method.</p></li>
				<li>Open the <code>res://08.designing-online-platformer/Actors/Player/Player2D.tscn</code> scene, and let’s start by adding <code>MultiplayerSynchronizer</code> node as a child of the <code>Player</code> node. This <code>MultiplayerSynchronizer</code> node should sync the <code>Player</code> instance’s <code>position</code> and <code>top_level</code> properties and the <code>Spaceship</code> node’s <code>position</code> and <code>rotation</code> properties. The following screenshot showcases the <code>Player</code> scene’s <strong class="bold">MultiplayerSynchronizer </strong><strong class="bold">Replication Menu</strong>:</li>
			</ol>
			<div><div><img alt="Figure 9.15 – The Player’s MultiplayerSynchronizer Replication Menu" src="img/Figure_09.15_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.15 – The Player’s MultiplayerSynchronizer Replication Menu</p>
			<p class="list-inset">Since this <code>MultiplayerSynchronizer</code> node will work by syncing physics properties, we need to set its <strong class="bold">Visibility Update Mode</strong> property to <strong class="bold">Physics</strong>. This will prevent some weird behaviors such as bodies overlapping and unhandled or mishandled collisions.</p>
			<p class="list-inset">Now, let’s implement the <code>setup_multiplayer()</code> method. In the following instructions, we are going to create an RPC method that checks whether the current instance is a competence of the current player and disables some important processes to prevent interaction from players into instances they don’t own, as well as preventing overwriting properties synchronized by the network.</p>
			<ol>
				<li value="8">In the <code>Player.gd</code> script, let’s<a id="_idIndexMarker344"/> start by creating an RPC method called <code>setup_multiplayer</code> that any peer can call locally. It should receive <code>player_id</code> as an argument:<pre class="source-code">
@rpc("any_peer", "call_local")
func setup_multiplayer(player_id):</pre></li>				<li>Then, inside this method, we need to compare whether the <code>player_id</code> value received as an argument matches the current player’s peer ID. We will store this information in a variable called <code>is_player</code> to use for further reference:<pre class="source-code">
  var self_id = multiplayer.get_unique_id()
  var is_player = self_id == player_id</pre></li>				<li>With this information in hand, we can set up the player’s processes. We also need to disable <code>camera</code> if this isn’t the current player and make <code>camera</code> the current camera if it is:<pre class="source-code">
  set_process(is_player)
  set_physics_process(is_player)
  camera.enabled = is_player
  if is_player:
    camera.make_current()</pre></li>				<li>Finally, we set the player’s multiplayer authority to be <code>player_id</code>. This will ultimately prevent this client from making any changes on this <code>Player</code> instance and propagating them on the network:<pre class="source-code">
  set_multiplayer_authority(player_id)
setup_multiplayer()</strong> method’s code implementation:</pre><pre class="source-code">@rpc("any_peer", "call_local")
func setup_multiplayer(player_id):
  var self_id = multiplayer.get_unique_id()
  var is_player = self_id == player_id
  set_process(is_player)
  set_physics_process(is_player)
  camera.enabled = is_player
  if is_player:
    camera.make_current()
  set_multiplayer_authority(player_id)</pre></li>			</ol>
			<p>Throughout this section, we learned how we can spawn already existing objects to a player’s game instances when they log in when the game world is already running. We also saw how we can selectively synchronize objects using the <code>MultiplayerSynchronizer.set_visibility_for()</code> method.</p>
			<p>On top of that, we used the <code>MultiplayerSpawner.spawned</code> signal to configure spawned instances of an object on the client’s side. In our case, we needed to configure the player multiplayer settings. To do that, we created a method that checks whether this instance belongs to the current player, properly disabling or enabling its processing and camera and setting its multiplayer authority accordingly.</p>
			<p>In the next section, we are going to learn how we can separate some responsibilities in the game to prevent cheating and to establish a more coherent multiplayer system, for instance, preventing a player’s game instances from deleting asteroids as they are the responsibility of the server.</p>
			<p>We will also see how we can sync players’ actions on all peers. This will be useful to replicate actions locally; for instance, when a player shoots on their game instance, all other game instance<a id="_idTextAnchor239"/><a id="_idTextAnchor240"/><a id="_idTextAnchor241"/><a id="_idTextAnchor242"/>s should perform the shooting as well.</p>
			<h1 id="_idParaDest-140"><a id="_idTextAnchor243"/>Separating server and client responsibilities</h1>
			<p>Now that we have<a id="_idIndexMarker346"/> players sharing the same world, we need to establish which actions they are responsible for and which actions are part of the server’s responsibility. For instance, if a player shoots on their game instance and their bullet damages an asteroid but this asteroid was already destroyed by another player, what should happen? For this kind of situation, the server is the perfect mediator to prevent instance conflicts.</p>
			<p>With all this context in place, players tell all peers, including the server, to update their <code>Player</code> instance according to their actions, but only the server should have the authority to manage the actual impact of these actions in the game world, such as if the player managed to destroy an asteroid or not. In the next section, we are going to understand how players can sync their actions, not only their objects’ properti<a id="_idTextAnchor244"/>es, across all network-connected peers.</p>
			<h2 id="_idParaDest-141"><a id="_idTextAnchor245"/>Shooting bullets on all instances</h2>
			<p>Since<a id="_idIndexMarker347"/> the <code>Player</code> scene’s <code>Spaceship</code> node movement is already synced by the <code>MultiplayerSynchronizer</code> node, we can focus our efforts on syncing the <code>Bullet</code> instances’ movement now. One way we could do that would be to use the <code>MultiplayerSpawner</code> and <code>MultiplayerSynchronizer</code> nodes to spawn <code>Bullet</code> instances remotely and replicate their position, rotation, and so on. But instead, we can make an RPC telling all <code>Spaceship</code> instances to call the <code>fire()</code> method on their <code>Weapon2D</code> nodes.</p>
			<p>This is <a id="_idIndexMarker348"/>a quick and cheap way to do this. As the <code>Bullet</code> nodes have a constant trajectory, there’s no reason to sync their movement properties. The only thing relevant is where they start, that is, the spawning position, and the direction they should move. Both these properties are being synced already by the <code>Player</code> node’s <code>MultiplayerSynchronizer</code> node. So, we can leverage them. Nice trick, right?</p>
			<p>To do this, open the <code>res://09.prototyping-space-adventure/Actors/Player/Player2D.gd</code> script, and in the <code>_process()</code> callback, change the <code>weapon.fire()</code> line to <code>weapon.rpc("fire")</code>, as shown in the following code snippet:</p>
			<pre class="source-code">
func _process(delta):
  if Input.is_action_pressed(shoot_action):
    weapon.rpc("fire")</pre>			<p>If you test the game now, you should see the <code>Player</code> instances’ <code>Spaceship</code> nodes shooting bullets on all game instances: server and clients. In the following screenshot, we can see a player shooting being replicated on the server’s game instance:</p>
			<div><div><img alt="Figure 9.16 – The Payer scene’s Spaceship node shooting Bullet instances on the server’s game instance using an RPC function" src="img/Figure_09.16_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.16 – The Payer scene’s Spaceship node shooting Bullet instances on the server’s game instance using an RPC function</p>
			<p>Now that the <code>Player</code> instances can shoot bullets on every peer instance of the game, we need to understand who should manage the damage calculation and the destruction of the <a id="_idIndexMarker349"/>objects the <code>Bullet</code> nodes hit. We’ve already talked about that, and this responsibility is the server’s.</p>
			<p>But how do we do that? In the next section, we are going to break down the <code>Asteroid</code> nodes’ behavior in order to separate what should happen on the client’s side and<a id="_idTextAnchor246"/><a id="_idTextAnchor247"/> what should happen on the server’s side.</p>
			<h2 id="_idParaDest-142"><a id="_idTextAnchor248"/>Calculating an asteroid’s damage</h2>
			<p>Here, it’s time to<a id="_idIndexMarker350"/> use the <code>multiplayer.is_server()</code> method extensively. We need to break down the <code>Asteroid</code> node’s behavior and establish what should happen when the <code>Bullet</code> instances on a client’s game instance hit an <code>Asteroid</code> node and what should happen when these <code>Bullet</code> instances hit an <code>Asteroid</code> node on the server side.</p>
			<p>Open the <code>res://09.prototyping-space-adventure/Objects/Asteroid/Asteroid.gd</code> script, and let’s implement the damage-taking behavior, respecting the responsibilities of each side of the connection:</p>
			<ol>
				<li>The first thing we need to do is prevent applying any damage to the <code>Asteroid</code> node if the current peer isn’t the server. So, in a client’s game instance, the <code>Bullet</code> node should hit the <code>Asteroid</code> node and disappear, but should not apply damage to the <code>Asteroid</code> node. To do that, in the <code>_on_hurt_area_2d_damage_taken()</code> callback, we are going to check whether the peer is the server, and if it is, we call the <code>apply_damage()</code> method, passing <code>damage</code> as an argument:<pre class="source-code">
func _on_hurt_area_2d_damage_taken(damage):
    if multiplayer.is_server():
        apply_damage(damage)</pre></li>				<li>Now, in the <code>apply_damage()</code> method, after doing the proper calculation, the server must tell the <code>Asteroid</code> instances on all peers to play their proper animation, either playing <code>"hit"</code> or <code>"explode"</code>. But here’s the trick: the <code>animator</code> doesn’t have an <code>RPC</code> method to do that.<p class="list-inset">So, instead, we <a id="_idIndexMarker351"/>are going to extract this behavior into two RPC methods and call these methods. These RPC methods should be called only by the network authority, and they should also be called locally:</p><pre class="source-code">
func apply_damage(damage):
  health -= damage
  if health &lt; 1:
    rpc("explode")
  elif health &gt; 0:
    rpc("hit")
@rpc("authority", "call_local")
func explode():
  animator.play("explode")
@rpc("authority", "call_local")
func hit():
  animator.play("hit")</pre></li>				<li>The last thing we need to do is to allow only the server to call the <code>queue_free()</code> method on the <code>Asteroid</code> nodes, preventing players from cheating and completing the quest in unpredictable ways. To do that, in the <code>_on_animation_player_animation_finished()</code> callback, we are going to check whether the peer is the server and call <code>queue_free()</code> if the current animation is <code>"explode"</code>:<pre class="source-code">
func _on_animation_player_animation_finished(anim_name):
  if multiplayer.is_server():
    if anim_name == "explode":
      queue_free()</pre><p class="list-inset">Since the server, which is the <code>Asteroid</code> node’s multiplayer authority, is removing the <code>Asteroid</code> instance from its <code>SceneTree</code>, the <code>World</code> node’s <code>AsteroidsMultiplayerSpawner</code> node will ensure that the <code>Asteroid</code> instances spawned on the clients’ game instances will also be removed as well. Isn’t the<a id="_idIndexMarker352"/> Godot Engine’s Network API clever?</p></li>			</ol>
			<p>With that, each side of the connection is performing its duty. The client side plays animations based on the <code>Asteroid</code> node’s state, while the server side deals with the actual impacts of <code>Bullet</code> nodes hitting <code>Asteroid</code> nodes. In this section, we saw how we can work around the issue when a behavior needs to be replicated remotely on all peers, but the built-in class, for instance the <code>AnimationPlayer</code>, doesn’t have a way to do it.</p>
			<p>We also learned how to separate things and give each side of the connection the power to execute their responsibility. While the client side must instantiate bullet’s and do all the processing of the shooting, the server side does its part by processing the damage dealt by the <code>Bullet</code> nodes and handling the <code>Asteroid</code> node’s life cycle.</p>
			<p>In the next section, we are going to strengthen this knowledge by applying the same principles to the quest system. How does the player retrieve their quests? What is the client’s responsibility? Should the client store the player’s progress? What about the server? How does it handle clients’ requests and maintain information consistently between play sessi<a id="_idTextAnchor249"/><a id="_idTextAnchor250"/>ons? That’s what we are going to talk about.</p>
			<h1 id="_idParaDest-143"><a id="_idTextAnchor251"/>Storing and retrieving data on the server</h1>
			<p>It’s time to <a id="_idIndexMarker353"/>handle a sensitive topic when it comes to online adventure games: databases. Note that in this book, we are not focusing on the best and most secure way to handle and protect a database. Instead, we are practicing and understanding what the Godot Engine Network API allows us to achieve and exploring its possibilities.</p>
			<p>That said, in this section, we are going to implement the necessary steps to establish a communication channel where the client can retrieve its quests data from the server and send their progress updates to the server.</p>
			<p>To do that, we are going to work with the two main classes in our quest system, <code>QuestSingleton</code> node and the <code>QuestDatabase</code> node. But before we set these classes up for this new challenge, we need to change how the database is structured. Since now the <code>QuestDatabase</code> node will work by delivering and handling multiple players’ data, the <code>PlayerProgress.json</code> file needs to have its data linked to a user. So, let’s create these fake users, matching the ones in <code>FakeDatabase.json</code> file, and store this arbitrary data.</p>
			<p>Open the <code>res://09.prototyping-space-adventure/Quests/PlayerProgress.json</code> file and create two new keys, one for <code>user1</code> and another for <code>user2</code>. Then, add some<a id="_idIndexMarker354"/> manual data matching the original structure for each user key:</p>
			<pre class="source-code">
{
  "user1":{
    "asteroid_1":{
      "completed":false,
      "progress":4
    }
  },
  "user2":{
    "asteroid_1":{
      "completed":false,
      "progress":2
    }
  }
}</pre>			<p>Now, with this in mind, remember that we can, and should, use the user we have stored in the <code>AuthenticationCredentials</code> singleton to refer to any sensitive user data. This is important because it’s <a id="_idIndexMarker355"/>how we are going to properly manage users’ requests and deliver the data accordingly. In the next section, we are going to see how <code>QuestSingle<a id="_idTextAnchor252"/>ton</code> node should retrieve and update quest data.</p>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor253"/>Implementing the quest system’s client side</h2>
			<p>It’s<a id="_idIndexMarker356"/> time to finally have our quest system ready to work in a network where players can retrieve quests from a remote database, make progress on them, and store their information for the future. In this section, we are going to see what the <code>QuestSingleton</code> node’s role is in this online multiplayer environment.</p>
			<p>So, let’s open the <code>res://09.prototyping-space-adventure/Quests/QuestSingleton.gd</code> script and get started with that. In the following instructions, we will see how we can retrieve and update quest data in a remote <code>QuestDatabase</code>:</p>
			<ol>
				<li>The <code>retrieve_quests()</code> method needs a complete, but simpler and more elegant, revamp. The easiest way to create new quests in this online environment is to make the client request the remote <code>QuestDatabase</code> to create them remotely. We will see how this happens in depth in the <em class="italic">Implementing the quest system’s </em><em class="italic">server</em> section.</li>
				<li>But for now, we will wait for <code>0.1</code> seconds to guarantee that everything is in place, and then we can make an RPC on the <code>QuestDatabase</code> node’s <code>get_player_quests()</code> method if this <code>QuestSingleton</code> node is not the server’s. Remember to pass <code>AuthenticationCredentials.user</code> property as an argument to the <code>get_player_quests()</code> method:<pre class="source-code">
func retrieve_quests():
  if multiplayer.is_server():
    return
  await(get_tree().create_timer(0.1).timeout)
  QuestDatabase.rpc_id(1, "get_player_quests",
      AuthenticationCredentials.user)</pre></li>				<li>Now, since the server’s <code>QuestDatabase</code> node will create the quests on the client’s <code>QuestSingleton</code> node, we need to turn the <code>create_quest()</code> method into an RPC method that only the authority can call remotely:<pre class="source-code">
@rpc("authority", "call_remote")
func create_quest(quest_data):</pre></li>				<li>Finally, in the <code>increase_quest_progress()</code> method, we need to call the <code>QuestDatabase.update_player_progress()</code> method using an RPC directly to the server as well. Let’s not forget to also pass <code>AuthenticationCredentials.user</code> as an argument as well:<pre class="source-code">
func increase_quest_progress(quest_id, amount):
  if not quest_id in quests.keys():
    return
  var quest = quests[quest_id]
  quest.current_amount += amount
  QuestDatabase.rpc_id(1, "update_player_progress",
      quest_id, quest.current_amount, quest.completed,
          AuthenticationCredentials.user)</pre></li>			</ol>
			<p>With that, the <code>QuestSingleton</code> node will<a id="_idIndexMarker357"/> ask the server’s <code>QuestDatabase</code> node to create the current player’s quests, and whenever the player makes progress in a quest, the client’s <code>QuestSingleton</code> node updates the server’s <code>QuestDatabase</code> node about the current quest’s progress, ultimately delegating to the server the responsibility of handling this important data.</p>
			<p>Now, my friends, comes the last piece of our puzzle. In the next section, we are going to understand how the server side of this system works now tha<a id="_idTextAnchor254"/>t it is put in an online multiplayer environment.</p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor255"/>Implementing the quest system’s server side</h2>
			<p>In this <a id="_idIndexMarker358"/>section, we will add the necessary functionalities to the <code>QuestDatabase</code> node in order for it to properly provide and store players’ quest data. To do that, we are going to use RPCs extensively together with the <code>multiplayer.is_server()</code> method to prevent some behaviors from happening on the players’ instances of the <code>QuestDatabase</code> node.</p>
			<p>We do this mainly to maintain the quest data only on the server side, so clients don’t run into the temptation to cheat directly on their machines. This will be an extensive section, so take a breather. We’ve been through quite a bit of information up to this point. Take a pause, and once you feel ready, come right back.</p>
			<p>Ready? Okay, open the <code>res://09.prototyping-space-adventure/Quests/QuestDatabase.gd</code> script and let’s get started. In the upcoming instructions, we are going to tweak the current <code>QuestDatabase</code> node’s methods and even create new ones in order to make it work as it should, starting with…the <code>_ready()</code> method:</p>
			<ol>
				<li>In the <code>_ready()</code> callback, we should only load the database files if the current peer is the server:<pre class="source-code">
func _ready():
  if multiplayer.is_server():
  load_database()</pre></li>				<li>We do the same thing in the <code>_notification()</code> callback. We should only store the files if the current peer is the server, so let’s add this check together with the notification check:<pre class="source-code">
func _notification(notification):
    if notification == NOTIFICATION_WM_CLOSE_REQUEST
       and multiplayer.is_server():
        store_database()</pre></li>				<li>Moving on to <code>get_player_quests()</code>, it should now be an RPC method that any peer can call remotely:<pre class="source-code">
@rpc("any_peer", "call_remote")
func get_player_quests():</pre></li>				<li>Since it’s now an RPC, we will store the peer ID of the client that requested this data so we can use this later on when we respond to the request:<pre class="source-code">
func get_player_quests():
    var requester_id = multiplayer.get_remote_
        sender_id()</pre></li>				<li>Then, add an argument called <code>user</code> to the method’s signature so we know which key to<a id="_idIndexMarker359"/> look at in the <code>progress_database</code> dictionary. Remember, now each user has their own key with their progress data in the <code>PlayerProgress.json</code> file, so this is how we access the proper user data:<pre class="source-code">
func get_player_quests(user):
  var requester_id = multiplayer.get_remote_
      sender_id()
  var quests = {}
  for quest in progress_database[user]:</pre></li>				<li>Now, we have some changes to make in the <code>get_progress()</code> and <code>get_completion()</code> method signatures, right? We need to add the user as an argument. So, let’s call them using this argument:<pre class="source-code">
  for quest in progress_database[user]:
    var quest_data = {}
    quest_data["id"] = quest
    quest_data["title"] = get_title(quest)
    quest_data["description"] = get_description(quest)
    quest_data["target_amount"] = get_target_amount
        (quest)
    quest_data["current_amount"] = get_progress
        (quest, user)
    quest_data["completed"] = get_completion
        (quest, user)
    quests[quest] = quest_data</pre></li>				<li>Now, we need <a id="_idIndexMarker360"/>to fix the methods’ signatures to match the previous changes and allow them to receive a <code>user</code> argument and access the <code>user</code> key in the <code>progress_database</code>:<pre class="source-code">
func get_progress(quest_id, user):
  return progress_database[user][quest_id]["progress"]
func get_completion(quest_id, user):
  return progress_database[user][quest_id]
      ["completed"]</pre></li>				<li>Back to the <code>get_player_quests()</code> method – for each <code>quest</code> key found in <code>progress_database</code> dictionary for a user, we will make an RPC directly to the <code>create_quest()</code> method of the client’s <code>QuestSingleton</code> node, passing the <code>quest_data</code> dictionary we just created:<pre class="source-code">
    for quest in progress_database[user]:
        var quest_data = {}
        quest_data["id"] = quest
        quest_data["title"] = get_title(quest)
        quest_data["description"] = get_description
            (quest)
        quest_data["target_amount"] = get_target_
            amount(quest)
        quest_data["current_amount"] = get_progress
            (quest, user)
        quest_data["completed"] = get_completion
            (quest, user)
        quests[quest] = quest_data
        Quests.rpc_id(requester_id, "create_quest",
            quest_data)</pre></li>				<li>Finally, let’s also turn <code>update_player_progress()</code> into an RPC method that any peer can call remotely. It should also receive a <code>user</code> argument to update the<a id="_idIndexMarker361"/> progress on the proper <code>user</code> key in <code>progress_database</code>. This should only happen if this is the server’s instance of the <code>QuestDatabase</code> node, of course:<pre class="source-code">
@rpc("any_peer", "call_remote")
func update_player_progress(quest_id, current_amount,
    completed, user):
  if multiplayer.is_server():
    progress_database[user][quest_id]["progress"] =
        current_amount
    progress_database[user][quest_id]["completed"] =
        completed</pre></li>			</ol>
			<p>And that wraps up our quest system and database management logic on both the client and server sides. If you test the <code>res://09.prototyping-space-adventure/MainMenu.tscn</code> scene and log in as a user, you will be able to see <code>QuestPanel</code> displaying the quest<a id="_idIndexMarker362"/> data correctly with the current player’s progress on the quest. In the following screenshot, we can see <code>user2</code>’s quest information:</p>
			<div><div><img alt="Figure 9.17 – QuestPanel displaying user2’s Destroy 10 Asteroids quest information" src="img/Figure_09.17_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.17 – QuestPanel displaying user2’s Destroy 10 Asteroids quest information</p>
			<p>The following screenshot displays <code>user1</code>’s quest information. So, we can assume that our system is working as it should, properly loading, displaying, and modifying players’ quest progress:</p>
			<p class="IMG---Figure"/>
			<div><div><img alt="Figure 9.18 – QuestPanel displaying user1’s Destroy 10 Asteroids quest information" src="img/Figure_09.18_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.18 – QuestPanel displaying user1’s Destroy 10 Asteroids quest information</p>
			<p>With that, our <a id="_idIndexMarker363"/>top-down space adventure prototype is ready! Congratulations on making it all the way to this point. This chapter tested out everything we’ve seen so far extensively, and it closes <em class="italic">Part 2</em>, <em class="italic">Creating Online Multiplayer Mechanics</em>, of this book, where we created five prototypes to learn the ins and outs of Godot Engine’s high-level Network API.</p>
			<p>Hopefully, by now, you feel confident in building and testing more prototypes on your own. In <em class="italic">Part 3</em>, <em class="italic">Optimizing the Online Experience</em>, which we are going to start in the next chapter, we are going to see how we can use the available tools to improve upon the experiences we created in <em class="italic">Part 2</em>. We will talk about how to debug and profile the network, optimize data requests, implement optimization techniques such as predic<a id="_idTextAnchor256"/><a id="_idTextAnchor257"/>tion and interpolation, cache data, and more.</p>
			<h1 id="_idParaDest-146"><a id="_idTextAnchor258"/>Summary</h1>
			<p>In this chapter, we learned how to allow players to join in the middle of a game run; how to synchronize their game instances; how to load, retrieve, send, and store information on a remote database; how to create a quest system; and overall, how to structure the very basics of an online multiplayer adventure game. In the next chapter, we are going to learn how to debug and profile the network so we can find bottlenecks and potential areas of improvement and optimization for our games. See you there!</p>
		</div>
	

		<div><h1 id="_idParaDest-147" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor259"/>Part 3:Optimizing the Online Experience</h1>
		</div>
		<div><p>One of the core aspects of developing an application, especially a game, is to make the experience smooth and keep it without any hiccups or lag. When talking about games, which are real-time experiences, this is even more relevant. So, throughout this part of the book, we learn about the debugging and profiling tools necessary to assess potential bottlenecks and then we implement techniques to effectively optimize the network usage of the final project from<em class="italic"> </em><em class="italic">Part 2</em>.</p>
			<p>This part contains the following chapters:</p>
			<ul>
				<li><a href="B18527_10.xhtml#_idTextAnchor260"><em class="italic">Chapter 10</em></a>, <em class="italic">Debugging and Profiling the Network</em></li>
				<li><a href="B18527_11.xhtml#_idTextAnchor276"><em class="italic">Chapter 11</em></a>, <em class="italic">Optimizing Data Requests</em></li>
				<li><a href="B18527_12.xhtml#_idTextAnchor285"><em class="italic">Chapter 12</em></a>, <em class="italic">Lag and Packet Loss Compensation</em></li>
				<li><a href="B18527_13.xhtml#_idTextAnchor296"><em class="italic">Chapter 13</em></a>, <em class="italic">Caching Data to Decrease Bandwidth</em></li>
			</ul>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
	</body></html>