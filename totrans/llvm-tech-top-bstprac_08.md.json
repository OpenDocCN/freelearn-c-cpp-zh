["```cpp\n$ ninja clang\n```", "```cpp\n#define HELLO 4\nint foo(int x) {\n  return x + HELLO;\n}\n```", "```cpp\n$ clang -E foo.c\n```", "```cpp\n…\nint foo(int x) {\n  return x + 4;\n}\n```", "```cpp\nvoid foo(SourceManager &SM, SourceLocation SLoc) {\n  auto Line = SM.getSpellingLineNumber(SLoc),\n       Column = SM.getSpellingColumnNumber(SLoc);\n  …\n}\n```", "```cpp\nSourceLocation NewSLoc = SM.createExpansionLoc(\n  SpellingLoc,    // The original macro spelling location\n  ExpansionStart, // Start of the location where macro is                   //expanded\n  ExpansionEnd,   // End of the location where macro is                   // expanded\n  Len             // Length of the content you want to expand\n);\n```", "```cpp\nToken GetNextToken(Preprocessor &PP) {\n  Token Tok;\n  PP.Lex(Tok);\n  return Tok;\n}\n```", "```cpp\n$ clang -fsyntax-only -Xclang -dump-tokens foo.cc\n```", "```cpp\nnamespace foo {\n  class MyClass {};\n}\nfoo::MyClass Obj;\n```", "```cpp\nnamespace 'namespace'    [StartOfLine]  Loc=<foo.cc:1:1>\nidentifier 'foo'         [LeadingSpace] Loc=<foo.cc:1:11>\nl_brace '{'      [LeadingSpace] Loc=<foo.cc:1:15>\nclass 'class'    [StartOfLine] [LeadingSpace]   Loc=<foo.cc:2:3>\nidentifier 'MyClass'     [LeadingSpace] Loc=<foo.cc:2:9>\nl_brace '{'      [LeadingSpace] Loc=<foo.cc:2:17>\nr_brace '}'             Loc=<foo.cc:2:18>\nsemi ';'                Loc=<foo.cc:2:19>\nr_brace '}'      [StartOfLine]  Loc=<foo.cc:3:1>\nidentifier 'foo'         [StartOfLine]  Loc=<foo.cc:5:1>\ncoloncolon '::'         Loc=<foo.cc:5:4>\nidentifier 'MyClass'            Loc=<foo.cc:5:6>\nidentifier 'Obj'         [LeadingSpace] Loc=<foo.cc:5:14>\nsemi ';'                Loc=<foo.cc:5:17>\neof ''          Loc=<foo.cc:5:18>\n```", "```cpp\nint* foo(int N) {\n  return ::new int[N]; // Equivalent to 'new int[N]'\n}\n```", "```cpp\nbool IsReturn(Token Tok) {\n  return Tok.getKind() == tok::kw_return;\n}\n```", "```cpp\nbool IsReturn(Token Tok) {\n  return Tok.is(tok::kw_return);\n}\n```", "```cpp\nIdentifierInfo *II = Tok.getIdentifierInfo();\n```", "```cpp\n    void foo(int auto) {}\n    ```", "```cpp\n    $ clang++ -std=c++03 standard into -std=c++11 or a later standard. The error message in the latter case will say that auto, a language keyword since C++11, can't be used there. To give the frontend have an easier time judging if a given token is a keyword in any case, the IdentifierInfo object attached on keyword tokens is designed to answer if an identifier is a keyword under a certain language standard (or language feature), using the IdentifierInfo::isKeyword(…) function, for example, whereby you pass a LangOptions class object (a class carrying information such as the language standard and features currently being used) as the argument to that function.\n    ```", "```cpp\n#define FOO(X) (X + 1)\nreturn FOO(3); // Equivalent to \"return (3 + 1);\"\n#define FOO(X) (X - 100)\nreturn FOO(3); // Now this is equivalent to \"return (3 - 100);\"\n#undef FOO\nreturn FOO(3); // \"FOO(3)\" here will not be expanded in                //preprocessor\n```", "```cpp\nvoid printMacroBody(IdentifierInfo *MacroII, Preprocessor &PP) {\n  MacroDefinition Def = PP.getMacroDefinition(MacroII);\n  MacroInfo *Info = Def.getMacroInfo();\n  …\n}\n```", "```cpp\nvoid printMacroBody(IdentifierInfo *MacroII, Preprocessor &PP) {\n  …\n  MacroInfo *Info = Def.getMacroInfo();\n  for(Token Tok : Info->tokens()) {\n    std::cout << Tok.getName() << \"\\n\";\n  }\n}\n```", "```cpp\n#define PRINT(val) \\\n  printf(\"%d\\n\", val * 2)\nvoid main() {\n  PRINT(1 + 3);\n}\n```", "```cpp\nvoid main() {\n  printf(\"%d\\n\", 1 + 3 * 2);\n}\n```", "```cpp\n#define PRINT(val) \\\n  printf(\"%d\\n\", (val) * 2)\n```", "```cpp\nvoid main() {\n  printf(\"%d\\n\", (1 + 3) * 2);\n}\n```", "```cpp\n#pragma macro_arg_guard val\n#define PRINT(val) \\\n  printf(\"%d\\n\", val * 94 + (val) * 87);\nvoid main() {\n  PRINT(1 + 3);\n}\n```", "```cpp\n$ clang … foo.c\n[WARNING] In foo.c:3:18: macro argument 'val' is not enclosed by parenthesis\n```", "```cpp\nMacroGuard\n  |___ CMakeLists.txt\n  |___ MacroGuardPragma.cpp\n  |___ MacroGuardValidator.h\n  |___ MacroGuardValidator.cpp\n```", "```cpp\n# In MacroGuard/CmakeLists.txt\n…\n# (after importing LLVM's CMake directives)\nfind_package(Clang REQUIRED CONFIG)\ninclude_directories(${CLANG_INCLUDE_DIRS})\n```", "```cpp\nset(_SOURCE_FILES\n    MacroGuardPragma.cpp\n    MacroGuardValidator.cpp\n    )\nadd_llvm_library(MacroGuardPlugin MODULE\n                 ${_SOURCE_FILES}\n                 PLUGIN_TOOL clang)\n```", "```cpp\nWindows platforms, since PLUGIN_TOOL is also used for specifying this plugin loader executable's name.\n```", "```cpp\n$ clang … -fplugin=/path/to/MacroGuardPlugin.so foo.c\n```", "```cpp\nstruct MacroGuardHandler : public PragmaHandler {\n  MacroGuardHandler() : PragmaHandler(\"macro_arg_guard\"){}\n  void HandlePragma(Preprocessor &PP, PragmaIntroducer                     Introducer, Token &PragmaTok) override;\n};\n```", "```cpp\n#pragma macro_arg_guard val\n                       ^--Stop at here\n```", "```cpp\nvoid MacroGuardHandler::HandlePragma(Preprocessor &PP,…) {\n  Token Tok;\n  PP.Lex(Tok);\n  while (Tok.isNot(tok::eod)) {\n    ArgsToEnclosed.push_back(Tok.getIdentifierInfo());\n    PP.Lex(Tok);\n  }\n}\n```", "```cpp\nSmallVector<const IdentifierInfo*, 2> ArgsToEnclosed;\nstruct MacroGuardHandler: public PragmaHandler {\n  …\n};\n```", "```cpp\nstruct MacroGuardHandler : public PragmaHandler {\n  bool IsValidatorRegistered;\n  MacroGuardHandler() : PragmaHandler(\"macro_arg_guard\"),\n                        IsValidatorRegistered(false) {}\n  …\n};\nvoid MacroGuardHandler::HandlePragma(Preprocessor &PP,…) {\n  …\n  if (!IsValidatorRegistered) {\n    auto Validator = std::make_unique<MacroGuardValidator>(…);\n    PP.addCallbackPPCallbacks(std::move(Validator));\n    IsValidatorRegistered = true;\n  }\n}\n```", "```cpp\nstruct MacroGuardHandler : public PragmaHandler {\n  …\n};\nstatic PragmaHandlerRegistry::Add<MacroGuardHandler>\n  X(\"macro_arg_guard\", \"Verify if designated macro args are     enclosed\");\n```", "```cpp\n// In MacroGuardValidator.h\nextern SmallVector<const IdentifierInfo*, 2> ArgsToEnclosed;\nclass MacroGuardValidator : public PPCallbacks {\n  SourceManager &SM;\npublic:\n  explicit MacroGuardValidator(SourceManager &SM) : SM(SM) {}\n  void MacroDefined(const Token &MacroNameToke,\n                    const MacroDirective *MD) override;\n};\n// In MacroGuardValidator.cpp\nvoid MacroGuardValidator::MacroDefined(const Token &MacroNameTok, const MacroDirective *MD) {\n}\n```", "```cpp\nvoid MacroGuardValidator::MacroDefined(const Token &MacroNameTok, const MacroDirective *MD) {\n  const MacroInfo *MI = MD->getMacroInfo();\n  // For each argument to be checked…\n  for (const IdentifierInfo *ArgII : ArgsToEnclosed) {\n    // Scanning the macro body\n    for (auto TokIdx = 0U, TokSize = MI->getNumTokens();\n         TokIdx < TokSize; ++TokIdx) {\n      …\n    }\n  }\n}\n```", "```cpp\nfor (const IdentifierInfo *ArgII : ArgsToEnclosed) {\n  for (auto TokIdx = 0U, TokSize = MI->getNumTokens();\n       TokIdx < TokSize; ++TokIdx) {\n    Token CurTok = *(MI->tokens_begin() + TokIdx);\n    if (CurTok.getIdentifierInfo() == ArgII) {\n      if (TokIdx > 0 && TokIdx < TokSize - 1) {\n        auto PrevTok = *(MI->tokens_begin() + TokIdx - 1),\n             NextTok = *(MI->tokens_begin() + TokIdx + 1);\n        if (PrevTok.is(tok::l_paren) && NextTok.is            (tok::r_paren))\n          continue;\n      }\n      …\n    }  \n  }\n}\n```", "```cpp\nfor (const IdentifierInfo *ArgII : ArgsToEnclosed) {\n  for (auto TokIdx = 0U, TokSize = MI->getNumTokens();\n       TokIdx < TokSize; ++TokIdx) {\n    …\n    if (CurTok.getIdentifierInfo() == ArgII) {\n      if (TokIdx > 0 && TokIdx < TokSize - 1) {\n        …\n        if (PrevTok.is(tok::l_paren) && NextTok.is            (tok::r_paren))\n          continue;\n      }\n      SourceLocation TokLoc = CurTok.getLocation();\n      errs() << \"[WARNING] In \" << TokLoc.printToString(SM) << \": \";\n      errs() << \"macro argument '\" << ArgII->getName()\n             << \"' is not enclosed by parenthesis\\n\";\n    }  \n  }\n}\n```", "```cpp\n    ./simple_warn.c:2:7: warning: unused variable 'y'…\n      int y = x + 1;\n          ^\n    1 warning generated.\n    ```"]