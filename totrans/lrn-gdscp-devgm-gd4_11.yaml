- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Playing Together with Multiplayer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Playing games on your own is lots of fun. I’ve spent many hours exploring exotic
    worlds, acquiring new skills, and experiencing deep storylines on my own. But
    where games really shine, compared to other forms of media, is the ability for
    the player to create their own stories. Nothing lets players create their own
    story like letting them play with another real person. From cooperation and tense
    moments trying to help each other in games like World of Warcraft or Rocket League,
    to rivalry and intimidating each other in games like Call of Duty or Gran Turismo.
    Human behavior is still something that invokes more emotions than interacting
    with a complete fictional world.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: A crash course in computer networking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `MultiplayerSynchronizer` and `MultiplayerSpawner`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running the game on multiple computers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we are going to implement networked multiplayer. This means
    that two people will be able to play together over the internet. Now, because
    of how networks work, and we still want to be safe, we’ll only be able to play
    over a **local area network** (**LAN**). This means that people who are connected
    to the same Wi-Fi network, for example, will be able to play together.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason why you don’t want to run a globally accessible server from your
    personal computer is quite simple: you don’t want the risk of people hacking your
    computer. Though there are ways to do this in a safe way, this is beyond the scope
    of this book.'
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As for every chapter, you can find the final code on the GitHub repository
    in the subfolder for this chapter: [https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter11](https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter11).'
  prefs: []
  type: TYPE_NORMAL
- en: A crash course in computer networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, I would like to give you a brief crash course on computer networking.
    Because Godot does a lot out of the box, we don’t have to be complete networking
    wizards to implement simple multiplayer games. This means that you could skip
    this section and directly start with the actual implementation of the multiplayer
    nodes and code. However, I recommend reading on if you want at least some high-level
    explanation of why we do things the way we are going to do them.
  prefs: []
  type: TYPE_NORMAL
- en: Computers in networks talk to each other through a layered model. On the top
    level, there is the eventual application, the game. Our game needs to send information
    from one instance of the game, running on one computer, to another instance of
    the game, running on another computer, also called **another machine**. This top
    layer is called the **Application Layer**. In between these computers could be
    a vast network of interconnected servers, routers, and other networking infrastructure.
    This network is the lowest layer, called the **Physical Layer**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – The seven layers of computer networking](img/B19358_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – The seven layers of computer networking
  prefs: []
  type: TYPE_NORMAL
- en: Between the Application Layer and the Physical Layer, there are multiple other
    layers. These layers make sure that data is sent and received between all links
    in the chain that need to be taken to transmit this packet of data from Computer
    A to Computer B and each serves a different purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'Though Godot provides us with a great deal of flexibility, not every layer
    is equally important to us at the moment. Let’s take a closer look at two network
    layers: the Transport and Application Layers.'
  prefs: []
  type: TYPE_NORMAL
- en: What is a Transport Layer?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first layer we’ll look at is the **Transport Layer**, the fourth layer of
    computer networking. This layer is, among other things, responsible for deciding
    how to cut the data we want to send in smaller packages of data, making sure that
    packages of data are received from one end to the other, uncorrupted.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – The Transport Layer is the fourth layer in computer networking](img/B19358_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – The Transport Layer is the fourth layer in computer networking
  prefs: []
  type: TYPE_NORMAL
- en: To meet these responsibilities, different protocols have been invented that
    are able to take care of them with varying degrees of reliability. A **protocol**
    is basically a set of rules by which computers can communicate with each other.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we send out a package of data from Computer A to Computer B,
    we could just send it off and hope for the best. However, our package of data
    could accidentally get dropped somewhere within the vast internet. A server forgets
    to send it from one link to the other, a cable gets unplugged, or any other error
    could happen.
  prefs: []
  type: TYPE_NORMAL
- en: Now, how do we make sure that the data we send actually arrives? Well, we could
    ask for confirmation from the receiving computer. But what if that confirmation
    gets lost somewhere? Well, we could do a double confirmation, one from each participant
    in the communication.
  prefs: []
  type: TYPE_NORMAL
- en: All these rules just solve the problem of making sure a package of data gets
    sent and received, but there are many other problems that we need to overcome
    as well. You can see that these protocols quickly become complex. Luckily, smart
    people already thought about all of this for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'In gaming, there are two main protocols that are used:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Transmission Control Protocol** (**TCP**): The TCP is a Transport Layer protocol
    that makes sure that every package that is sent will be received. But to achieve
    this, the protocol takes more time, sending confirmations back and forth.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User Datagram Protocol** (**UDP**): The UDP is a Transport Layer protocol
    that does not care whether packages arrive or not. It just sends them over a connection
    in the hopes that they make it, which most of them should do. This is way faster
    than the TCP but less reliable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Godot Engine can operate using either TCP or UDP and can even switch between
    the two for different kinds of data, depending on how important guaranteed delivery
    is. For our game, we will use both the UDP and TCP for different kinds of data.
  prefs: []
  type: TYPE_NORMAL
- en: What is an Application Layer?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Application Layer is the highest layer in the networking layers. This is
    when we actually use the data that we received within the game. Additionally,
    here, we have a choice to make; even though we have the data, how are we going
    to organize the computers that we are connected with?
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – The Application Layer is the seventh layer in computer networking](img/B19358_11_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – The Application Layer is the seventh layer in computer networking
  prefs: []
  type: TYPE_NORMAL
- en: 'For games, there are two network architectures that prevail: peer-to-peer or
    client-server.'
  prefs: []
  type: TYPE_NORMAL
- en: Peer-to-peer network
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a peer-to-peer network, every computer can talk to any other computer and
    ask it things. They are all equals and peers. For example, Computer A could ask
    Computer B to tell at what location its player character is located. Computer
    B will then send over this data so that Computer A can show its user where the
    player character of Computer B is situated in the game world.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4 – In a peer-to-peer network, each computer can talk to the other
    computers](img/B19358_11_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 – In a peer-to-peer network, each computer can talk to the other
    computers
  prefs: []
  type: TYPE_NORMAL
- en: This solution is pretty elegant because every computer is equal and has the
    same number of rights. However, we’ll also need to be vigilant because what if
    Computer B is used by a hacker and lies to the other computers? Instead of reporting
    the position of the player according to the game’s rules, Computer B gives positions
    that are impossible to reach; maybe they teleport its player character around.
    This is quite a problem. The next network architecture tries to tackle this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Client-server network
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Instead of treating every computer as equal, we could have one of the computers
    as the center for all communication. Every time any of the computers in the network
    want information, such as the location of another computer’s player character,
    they’ll have to ask this central computer. The central computer will then answer
    for the other computer.
  prefs: []
  type: TYPE_NORMAL
- en: In this situation, we call the central computer the server, and the connected
    computers the clients.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5 – In a client-server, network each computer talks to the server](img/B19358_11_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.5 – In a client-server, network each computer talks to the server
  prefs: []
  type: TYPE_NORMAL
- en: With this architecture, the server can check up on all clients and make sure
    none of them are cheating.
  prefs: []
  type: TYPE_NORMAL
- en: Networking in Godot Engine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Again, Godot Engine supports both peer-to-peer and client-server network architectures.
    To make it easier on ourselves, we’ll go with a client-server approach. This way,
    we can make sure that important parts of the game get run only on the server and
    our clients don’t have to worry about them. For example, considering counting
    the score – clients can easily lie about this, while now the server will be the
    only computer keeping score.
  prefs: []
  type: TYPE_NORMAL
- en: Alright, after this short introduction to computer networking, although there
    is still so much to learn, we have enough knowledge of the underlying structure
    that we can start implementing multiplayer in our game.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about IP addresses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In real life, to send mail to another person, you need to know the address of
    their house. For computer networks, this is pretty much the same. To send messages
    between computers, we need to know their **IP address**. This is a unique address
    that makes sure you can find any computer connected to the internet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, there are two versions of IP addresses in use: `0` to `255` separated
    by a period, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This version is supposed to be able to have a unique address for 4.3 billion
    devices. But it turns out that humans have been so productive that 4.3 billion
    devices will probably not be enough! These days, almost any electrical device
    can be connected to the internet, even fridges, toasters, and watches. That is
    why we are slowly transitioning to IPv6 addresses, which support 340 undecillion
    devices. That is 340 trillion devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'An IPv6 address looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Depending on how your computer is connected to the internet, this IP address
    changes from time to time, so don’t depend on it being the same.
  prefs: []
  type: TYPE_NORMAL
- en: An IP address is a postal address we can send a letter to, but then, we still
    need to know to whom in the household the letter is addressed. In a computer network,
    a **port** is used to address the exact application within the computer. Let’s
    talk about ports next.
  prefs: []
  type: TYPE_NORMAL
- en: Using port numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An IP address, be it IPv4 or IPv6, only indicates where to send the data to.
    But computers have many applications that each need their own connection. So,
    from the moment the data is received, to which application do we send it? Well,
    each application can use different ports, which are like the different platforms
    in a train station. Although each train arrives at the same station, they arrive
    at different platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Each application can choose a port, which is just a number from `0` to `65535`.
    However, the first 1,024 are reserved for standard computer functionality and
    we will not be able to pick these.
  prefs: []
  type: TYPE_NORMAL
- en: 'To specify which port to send data to, we can add the port number at the end
    of the IP address, behind a colon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'const PORT: int = 7890'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'func host_game():'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: var peer = ENetMultiplayerPeer.new()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: peer.create_server(PORT)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if peer.get_connection_status() == MultiplayerPeer.CONNECTION_DISCONNECTED:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: multiplayer.multiplayer_peer = peer
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'func connect_to_game(ip_address: String):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: var peer = ENetMultiplayerPeer.new()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: peer.create_client(ip_address, PORT)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if peer.get_connection_status() == MultiplayerPeer.CONNECTION_DISCONNECTED:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: multiplayer.multiplayer_peer = peer
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '@onready var _ip_address_line_edit = $CenterContainer/MainUIContainer/PanelContainer/MarginContainer/VBoxContainer/VBoxContainer/IpAddressLineEdit'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'func _on_play_button_pressed():'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if _ip_address_line_edit.text.is_empty():'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: host_game()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'else:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: connect_to_game(_ip_address_line_edit.text)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: get_tree().change_scene_to_file("res://screens/game/main.tscn")
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '@export var player_scene: PackedScene'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '@onready var _player_multiplayer_spawner: MultiplayerSpawner = $PlayerMultiplayerSpawner'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@onready var _player_start_positions: Node2D = $PlayerStartPositions'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'main.gd script:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'func _ready():'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: _player_multiplayer_spawner.spawn_function = spawn_player
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if multiplayer.is_server():'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: multiplayer.peer_connected.connect(add_player)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: add_player(1)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: multiplayer.peer_connected.connect(add_player)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'var multiplayer_id: int'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'func _enter_tree():'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: set_multiplayer_authority(multiplayer_id)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '@onready var _camera_position: Node2D = $CameraPosition'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'func _ready():'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: update_health_label()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if not multiplayer.is_server():'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: _shoot_timer.stop()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if not is_multiplayer_authority():'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: _camera_position.queue_free()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: set_physics_process(false))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'func _enter_tree() -> void:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: set_multiplayer_authority(multiplayer_id)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1. So, to give the authority to the server, we set the multiplayer authority
    of HealthMultiplayerSynchronizer to 1.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '@onready var _multiplayer_spawner = $MultiplayerSpawner'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'func _ready():'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: _multiplayer_spawner.add_spawnable_scene(entity_scene.resource_path)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if multiplayer.is_server():'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: start_timer()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: add_child(new_entity, true)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '@onready var _player_detection_area: Area2D = $PlayerDetectionArea'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'func _ready():'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if not multiplayer.is_server():'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: set_physics_process(false)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: _player_detection_area.monitoring = false
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'var player_nodes: Array = get_tree().get_nodes_in_group("player")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if not player_nodes.is_empty():'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: target = player_nodes.pick_random()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '@onready var _enemy_detection_area: Area2D = $EnemyDetectionArea'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'func _ready():'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if not multiplayer.is_server():'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: set_physics_process(false)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: _enemy_detection_area.monitoring = false
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: get_parent().add_child(new_projectile, true)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'func _ready():'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '# Other code'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if not multiplayer.is_server():'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: set_process(false)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'func add_player(id: int):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'var player: Player = player_scene.instantiate()'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: player.name = str(id)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: add_child(player)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '_on_player_died() function and add a new end_game() function:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'func _ready():'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '_highscore_label.text = "Highscore: " + str(Highscore.highscore)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if multiplayer.has_multiplayer_peer():'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: multiplayer.multiplayer_peer.close()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '@onready var _ip_label = $CanvasLayer/NetworkUI/IPLabel'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'func show_local_ip_address():'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: var addresses = []
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'for ip in IP.get_local_addresses():'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if ip.begins_with("10.") or ip.begins_with("172.16.") or ip.begins_with("192.168."):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: addresses.push_back(ip)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if not addresses.is_empty():'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: _ip_label.text = addresses[0]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'func _ready():'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if multiplayer.is_server():'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: show_local_ip_address()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '# …'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Part 3: Deepening Our Knowledge'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After learning how to program and creating your very own game from scratch,
    you will now take a step back and learn some more advanced programming and game
    development techniques.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this final part, you will have exported and distributed your game
    to various different platforms on the web so that everyone can play it from within
    their browser. You will also learn more advanced OOP concepts and different programming
    patterns that will help you in your future game projects. Even the filesystem
    will be covered so that you can save and load data. The last chapter will guide
    you through the next steps to take, which resources you could consult to learn
    more, and how to join the game development community.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B19358_12.xhtml#_idTextAnchor689), *Exporting to Multiple Platforms*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 13*](B19358_13.xhtml#_idTextAnchor705), *OOP Continued and Advanced
    Topics*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 14*](B19358_14.xhtml#_idTextAnchor721), *Advanced Programming Patterns*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 15*](B19358_15.xhtml#_idTextAnchor740), *Using the File System*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 16*](B19358_16.xhtml#_idTextAnchor755), *What Next?*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
