- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Playing Together with Multiplayer
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与多人一起游戏
- en: Playing games on your own is lots of fun. I’ve spent many hours exploring exotic
    worlds, acquiring new skills, and experiencing deep storylines on my own. But
    where games really shine, compared to other forms of media, is the ability for
    the player to create their own stories. Nothing lets players create their own
    story like letting them play with another real person. From cooperation and tense
    moments trying to help each other in games like World of Warcraft or Rocket League,
    to rivalry and intimidating each other in games like Call of Duty or Gran Turismo.
    Human behavior is still something that invokes more emotions than interacting
    with a complete fictional world.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 独自玩游戏很有趣。我花了很多时间探索异国世界，获得新技能，并在自己的故事中体验深刻的剧情。但与其他媒体形式相比，游戏真正闪耀的地方在于玩家能够创造自己的故事。没有什么比让他们与另一个人一起玩游戏更能让玩家创造自己的故事了。从在像《魔兽世界》或《火箭联盟》这样的游戏中合作和紧张的时刻互相帮助，到在像《使命召唤》或《Gran
    Turismo》这样的游戏中竞争和恐吓对方。人类行为仍然是一种比与一个完全虚构的世界互动更能引发情感的东西。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: A crash course in computer networking
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算机网络速成课程
- en: Using the `MultiplayerSynchronizer` and `MultiplayerSpawner`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`MultiplayerSynchronizer`和`MultiplayerSpawner`
- en: Running the game on multiple computers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多台计算机上运行游戏
- en: In this chapter, we are going to implement networked multiplayer. This means
    that two people will be able to play together over the internet. Now, because
    of how networks work, and we still want to be safe, we’ll only be able to play
    over a **local area network** (**LAN**). This means that people who are connected
    to the same Wi-Fi network, for example, will be able to play together.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将实现网络化多人游戏。这意味着两个人将能够通过互联网一起玩游戏。现在，由于网络的工作方式，我们仍然想要保持安全，我们只能通过**局域网**（**LAN**）来玩游戏。这意味着连接到同一Wi-Fi网络的人将能够一起玩游戏。
- en: 'The reason why you don’t want to run a globally accessible server from your
    personal computer is quite simple: you don’t want the risk of people hacking your
    computer. Though there are ways to do this in a safe way, this is beyond the scope
    of this book.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你不想从你的个人电脑上运行一个全球可访问的服务器的原因很简单：你不想冒别人黑客攻击你的电脑的风险。尽管有安全地这样做的方法，但这超出了本书的范围。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'As for every chapter, you can find the final code on the GitHub repository
    in the subfolder for this chapter: [https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter11](https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter11).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一章，你都可以在GitHub仓库的该章节子文件夹中找到最终代码：[https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter11](https://github.com/PacktPublishing/Learning-GDScript-by-Developing-a-Game-with-Godot-4/tree/main/chapter11).
- en: A crash course in computer networking
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算机网络速成课程
- en: In this section, I would like to give you a brief crash course on computer networking.
    Because Godot does a lot out of the box, we don’t have to be complete networking
    wizards to implement simple multiplayer games. This means that you could skip
    this section and directly start with the actual implementation of the multiplayer
    nodes and code. However, I recommend reading on if you want at least some high-level
    explanation of why we do things the way we are going to do them.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我想给你提供一个关于计算机网络的基础速成课程。因为Godot提供了很多开箱即用的功能，所以我们不需要成为完整的网络大师就能实现简单的多人游戏。这意味着你可以跳过这一节，直接开始实际的多玩家节点和代码实现。然而，如果你想要至少对为什么要以这种方式做事有一个高级的解释，我建议你继续阅读。
- en: Computers in networks talk to each other through a layered model. On the top
    level, there is the eventual application, the game. Our game needs to send information
    from one instance of the game, running on one computer, to another instance of
    the game, running on another computer, also called **another machine**. This top
    layer is called the **Application Layer**. In between these computers could be
    a vast network of interconnected servers, routers, and other networking infrastructure.
    This network is the lowest layer, called the **Physical Layer**.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 网络中的计算机通过分层模型相互通信。在最顶层，是最终的应用程序，即游戏。我们的游戏需要将信息从一个运行在某一台计算机上的游戏实例发送到另一个运行在另一台计算机上的游戏实例，也称为**另一台机器**。这一层被称为**应用层**。在这些计算机之间可能是一个庞大的互联服务器、路由器和其他网络基础设施的网络。这个网络是最低层，称为**物理层**。
- en: '![Figure 11.1 – The seven layers of computer networking](img/B19358_11_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图11.1 – 计算机网络的七层](img/B19358_11_01.jpg)'
- en: Figure 11.1 – The seven layers of computer networking
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 – 计算机网络的七层
- en: Between the Application Layer and the Physical Layer, there are multiple other
    layers. These layers make sure that data is sent and received between all links
    in the chain that need to be taken to transmit this packet of data from Computer
    A to Computer B and each serves a different purpose.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用层和物理层之间，还有多个其他层。这些层确保数据能够在需要传输此数据包从计算机A到计算机B的所有链路之间发送和接收，并且每个层都服务于不同的目的。
- en: 'Though Godot provides us with a great deal of flexibility, not every layer
    is equally important to us at the moment. Let’s take a closer look at two network
    layers: the Transport and Application Layers.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Godot为我们提供了大量的灵活性，但并非每一层对我们来说都同等重要。让我们更仔细地看看两个网络层：传输层和应用层。
- en: What is a Transport Layer?
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传输层是什么？
- en: The first layer we’ll look at is the **Transport Layer**, the fourth layer of
    computer networking. This layer is, among other things, responsible for deciding
    how to cut the data we want to send in smaller packages of data, making sure that
    packages of data are received from one end to the other, uncorrupted.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将研究的是**传输层**，这是计算机网络的第四层。这个层在许多方面都负责决定如何将我们想要发送的数据切割成更小的数据包，并确保数据包从一端无损坏地接收至另一端。
- en: '![Figure 11.2 – The Transport Layer is the fourth layer in computer networking](img/B19358_11_02.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图11.2 – 传输层是计算机网络中的第四层](img/B19358_11_02.jpg)'
- en: Figure 11.2 – The Transport Layer is the fourth layer in computer networking
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 – 传输层是计算机网络中的第四层
- en: To meet these responsibilities, different protocols have been invented that
    are able to take care of them with varying degrees of reliability. A **protocol**
    is basically a set of rules by which computers can communicate with each other.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了履行这些职责，已经发明了不同的协议，它们能够以不同程度的可靠性来处理这些问题。**协议**基本上是一套规则，通过这些规则计算机可以相互通信。
- en: For example, if we send out a package of data from Computer A to Computer B,
    we could just send it off and hope for the best. However, our package of data
    could accidentally get dropped somewhere within the vast internet. A server forgets
    to send it from one link to the other, a cable gets unplugged, or any other error
    could happen.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们从计算机A向计算机B发送一组数据包，我们只需将其发送出去，并寄希望于最好的结果。然而，我们的数据包可能会在浩瀚的互联网中某个地方意外丢失。服务器忘记将数据从一条链路发送到另一条链路，电缆被拔掉，或者可能发生任何其他错误。
- en: Now, how do we make sure that the data we send actually arrives? Well, we could
    ask for confirmation from the receiving computer. But what if that confirmation
    gets lost somewhere? Well, we could do a double confirmation, one from each participant
    in the communication.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们如何确保我们发送的数据实际上到达了目的地呢？嗯，我们可以要求接收计算机进行确认。但是，如果确认信息丢失了呢？嗯，我们可以进行双重确认，每个通信参与者都进行一次。
- en: All these rules just solve the problem of making sure a package of data gets
    sent and received, but there are many other problems that we need to overcome
    as well. You can see that these protocols quickly become complex. Luckily, smart
    people already thought about all of this for us.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些规则只是解决了确保数据包被发送和接收的问题，但我们还需要克服许多其他问题。你可以看到，这些协议很快就会变得复杂。幸运的是，聪明的人已经为我们考虑到了所有这些。
- en: 'In gaming, there are two main protocols that are used:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏领域，有两个主要的协议被使用：
- en: '**Transmission Control Protocol** (**TCP**): The TCP is a Transport Layer protocol
    that makes sure that every package that is sent will be received. But to achieve
    this, the protocol takes more time, sending confirmations back and forth.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传输控制协议**（**TCP**）：TCP是一种传输层协议，确保每个发送的数据包都会被接收。但要实现这一点，该协议需要花费更多的时间，来回发送确认信息。'
- en: '**User Datagram Protocol** (**UDP**): The UDP is a Transport Layer protocol
    that does not care whether packages arrive or not. It just sends them over a connection
    in the hopes that they make it, which most of them should do. This is way faster
    than the TCP but less reliable.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户数据报协议**（**UDP**）：UDP是一种传输层协议，它不关心数据包是否到达。它只是将它们发送到连接中，希望它们能够到达，其中大部分应该能够到达。这比TCP快得多，但可靠性较低。'
- en: Godot Engine can operate using either TCP or UDP and can even switch between
    the two for different kinds of data, depending on how important guaranteed delivery
    is. For our game, we will use both the UDP and TCP for different kinds of data.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Godot 引擎可以使用 TCP 或 UDP 操作，甚至可以根据保证交付的重要性在不同类型的数据之间切换。对于我们的游戏，我们将使用 UDP 和 TCP
    来处理不同类型的数据。
- en: What is an Application Layer?
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是应用层？
- en: The Application Layer is the highest layer in the networking layers. This is
    when we actually use the data that we received within the game. Additionally,
    here, we have a choice to make; even though we have the data, how are we going
    to organize the computers that we are connected with?
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 应用层是网络层中的最高层。这是我们实际上在游戏中使用我们接收到的数据的时候。此外，在这里，我们有一个选择要做；尽管我们有数据，但我们如何组织我们连接的计算机呢？
- en: '![Figure 11.3 – The Application Layer is the seventh layer in computer networking](img/B19358_11_03.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.3 – 应用层是计算机网络中的第七层](img/B19358_11_03.jpg)'
- en: Figure 11.3 – The Application Layer is the seventh layer in computer networking
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 – 应用层是计算机网络中的第七层
- en: 'For games, there are two network architectures that prevail: peer-to-peer or
    client-server.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于游戏，有两种主要的网络架构：对等或客户端-服务器。
- en: Peer-to-peer network
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对等网络
- en: In a peer-to-peer network, every computer can talk to any other computer and
    ask it things. They are all equals and peers. For example, Computer A could ask
    Computer B to tell at what location its player character is located. Computer
    B will then send over this data so that Computer A can show its user where the
    player character of Computer B is situated in the game world.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在对等网络中，每台计算机都可以与其他任何计算机通信并询问它。它们都是平等的，都是对等体。例如，计算机 A 可以要求计算机 B 告诉它的玩家角色位于何处。然后计算机
    B 将发送这些数据，以便计算机 A 可以向其用户显示计算机 B 的玩家角色在游戏世界中的位置。
- en: '![Figure 11.4 – In a peer-to-peer network, each computer can talk to the other
    computers](img/B19358_11_04.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.4 – 在对等网络中，每台计算机都可以与其他计算机通信](img/B19358_11_04.jpg)'
- en: Figure 11.4 – In a peer-to-peer network, each computer can talk to the other
    computers
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4 – 在对等网络中，每台计算机都可以与其他计算机通信
- en: This solution is pretty elegant because every computer is equal and has the
    same number of rights. However, we’ll also need to be vigilant because what if
    Computer B is used by a hacker and lies to the other computers? Instead of reporting
    the position of the player according to the game’s rules, Computer B gives positions
    that are impossible to reach; maybe they teleport its player character around.
    This is quite a problem. The next network architecture tries to tackle this problem.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解决方案相当优雅，因为每台计算机都是平等的，并且拥有相同数量的权利。然而，我们还需要保持警惕，因为如果计算机 B 被黑客使用并欺骗其他计算机怎么办？计算机
    B 不会根据游戏规则报告玩家的位置，而是给出无法到达的位置；也许它们会将其玩家角色传送到其他地方。这是一个相当大的问题。下一个网络架构试图解决这个问题。
- en: Client-server network
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 客户端-服务器网络
- en: Instead of treating every computer as equal, we could have one of the computers
    as the center for all communication. Every time any of the computers in the network
    want information, such as the location of another computer’s player character,
    they’ll have to ask this central computer. The central computer will then answer
    for the other computer.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是将每台计算机视为平等，我们可以将其中一台计算机作为所有通信的中心。每当网络中的任何计算机需要信息，例如另一台计算机的玩家角色的位置时，它们必须询问这台中央计算机。然后中央计算机将为其他计算机做出回答。
- en: In this situation, we call the central computer the server, and the connected
    computers the clients.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将中央计算机称为服务器，将连接的计算机称为客户端。
- en: '![Figure 11.5 – In a client-server, network each computer talks to the server](img/B19358_11_05.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.5 – 在客户端-服务器网络中，每台计算机都与服务器通信](img/B19358_11_05.jpg)'
- en: Figure 11.5 – In a client-server, network each computer talks to the server
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5 – 在客户端-服务器网络中，每台计算机都与服务器通信
- en: With this architecture, the server can check up on all clients and make sure
    none of them are cheating.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种架构，服务器可以检查所有客户端，并确保它们中没有作弊的。
- en: Networking in Godot Engine
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Godot 引擎中的网络
- en: Again, Godot Engine supports both peer-to-peer and client-server network architectures.
    To make it easier on ourselves, we’ll go with a client-server approach. This way,
    we can make sure that important parts of the game get run only on the server and
    our clients don’t have to worry about them. For example, considering counting
    the score – clients can easily lie about this, while now the server will be the
    only computer keeping score.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，Godot引擎支持对等网络和客户端-服务器网络架构。为了简化操作，我们将采用客户端-服务器方法。这样，我们可以确保游戏的重要部分只在服务器上运行，而我们的客户端不必担心这些部分。例如，考虑计分——客户端可以轻易地撒谎，而现在服务器将是唯一记录分数的计算机。
- en: Alright, after this short introduction to computer networking, although there
    is still so much to learn, we have enough knowledge of the underlying structure
    that we can start implementing multiplayer in our game.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，在这次关于计算机网络简短介绍之后，尽管还有很多东西要学习，但我们已经拥有了足够的底层结构知识，可以开始在游戏中实现多人游戏。
- en: Learning about IP addresses
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解IP地址
- en: In real life, to send mail to another person, you need to know the address of
    their house. For computer networks, this is pretty much the same. To send messages
    between computers, we need to know their **IP address**. This is a unique address
    that makes sure you can find any computer connected to the internet.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中，要给另一个人寄信，你需要知道他们的家庭地址。对于计算机网络来说，这几乎是相同的。要在计算机之间发送消息，我们需要知道它们的**IP地址**。这是一个独特的地址，确保你可以找到任何连接到互联网的计算机。
- en: 'Currently, there are two versions of IP addresses in use: `0` to `255` separated
    by a period, like so:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，正在使用两种IP地址版本：用点分隔的`0`到`255`，如下所示：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This version is supposed to be able to have a unique address for 4.3 billion
    devices. But it turns out that humans have been so productive that 4.3 billion
    devices will probably not be enough! These days, almost any electrical device
    can be connected to the internet, even fridges, toasters, and watches. That is
    why we are slowly transitioning to IPv6 addresses, which support 340 undecillion
    devices. That is 340 trillion devices.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这种版本原本能够为43亿个设备提供唯一的地址。但结果是，人类已经如此高效，43亿个设备可能还不够！如今，几乎任何电器设备都可以连接到互联网，甚至冰箱、烤面包机和手表。这就是为什么我们正在逐步过渡到IPv6地址，它支持340个十亿亿个设备。那就是340万亿个设备。
- en: 'An IPv6 address looks like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6地址看起来是这样的：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Depending on how your computer is connected to the internet, this IP address
    changes from time to time, so don’t depend on it being the same.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的计算机如何连接到互联网，这个IP地址会时不时地改变，所以不要依赖它保持不变。
- en: An IP address is a postal address we can send a letter to, but then, we still
    need to know to whom in the household the letter is addressed. In a computer network,
    a **port** is used to address the exact application within the computer. Let’s
    talk about ports next.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: IP地址就像一封可以寄出的信的邮政地址，但然后，我们仍然需要知道信是寄给家庭中的谁的。在计算机网络中，**端口**用于在计算机内部指定确切的应用程序。让我们接下来谈谈端口。
- en: Using port numbers
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用端口号
- en: An IP address, be it IPv4 or IPv6, only indicates where to send the data to.
    But computers have many applications that each need their own connection. So,
    from the moment the data is received, to which application do we send it? Well,
    each application can use different ports, which are like the different platforms
    in a train station. Although each train arrives at the same station, they arrive
    at different platforms.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一个IP地址，无论是IPv4还是IPv6，仅表示数据要发送到的位置。但是，计算机有众多应用程序，每个都需要自己的连接。因此，从数据接收的那一刻起，我们应该将其发送到哪个应用程序呢？嗯，每个应用程序都可以使用不同的端口，这些端口就像火车站的不同平台。尽管每列火车都到达同一个车站，但它们到达的是不同的站台。
- en: Each application can choose a port, which is just a number from `0` to `65535`.
    However, the first 1,024 are reserved for standard computer functionality and
    we will not be able to pick these.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序都可以选择一个端口，它只是一个从`0`到`65535`的数字。然而，前1,024个是为标准计算机功能保留的，我们无法选择这些。
- en: 'To specify which port to send data to, we can add the port number at the end
    of the IP address, behind a colon:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定发送数据到哪个端口，我们可以在IP地址的末尾添加端口号，后面跟着一个冒号：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'const PORT: int = 7890'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'const PORT: int = 7890'
- en: '[PRE3]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'func host_game():'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'func host_game():'
- en: var peer = ENetMultiplayerPeer.new()
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: var peer = ENetMultiplayerPeer.new()
- en: peer.create_server(PORT)
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: peer.create_server(PORT)
- en: 'if peer.get_connection_status() == MultiplayerPeer.CONNECTION_DISCONNECTED:'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'if peer.get_connection_status() == MultiplayerPeer.CONNECTION_DISCONNECTED:'
- en: return
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return
- en: multiplayer.multiplayer_peer = peer
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: multiplayer.multiplayer_peer = peer
- en: 'func connect_to_game(ip_address: String):'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'func connect_to_game(ip_address: String):'
- en: var peer = ENetMultiplayerPeer.new()
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: var peer = ENetMultiplayerPeer.new()
- en: peer.create_client(ip_address, PORT)
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: peer.create_client(ip_address, PORT)
- en: 'if peer.get_connection_status() == MultiplayerPeer.CONNECTION_DISCONNECTED:'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'if peer.get_connection_status() == MultiplayerPeer.CONNECTION_DISCONNECTED:'
- en: return
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return
- en: multiplayer.multiplayer_peer = peer
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: multiplayer.multiplayer_peer = peer
- en: '[PRE4]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '@onready var _ip_address_line_edit = $CenterContainer/MainUIContainer/PanelContainer/MarginContainer/VBoxContainer/VBoxContainer/IpAddressLineEdit'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@onready var _ip_address_line_edit = $CenterContainer/MainUIContainer/PanelContainer/MarginContainer/VBoxContainer/VBoxContainer/IpAddressLineEdit'
- en: '[PRE5]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'func _on_play_button_pressed():'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'func _on_play_button_pressed():'
- en: 'if _ip_address_line_edit.text.is_empty():'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'if _ip_address_line_edit.text.is_empty():'
- en: host_game()
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: host_game()
- en: 'else:'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'else:'
- en: connect_to_game(_ip_address_line_edit.text)
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: connect_to_game(_ip_address_line_edit.text)
- en: get_tree().change_scene_to_file("res://screens/game/main.tscn")
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: get_tree().change_scene_to_file("res://screens/game/main.tscn")
- en: '[PRE6]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '@export var player_scene: PackedScene'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@export var player_scene: PackedScene'
- en: '[PRE7]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '@onready var _player_multiplayer_spawner: MultiplayerSpawner = $PlayerMultiplayerSpawner'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@onready var _player_multiplayer_spawner: MultiplayerSpawner = $PlayerMultiplayerSpawner'
- en: '@onready var _player_start_positions: Node2D = $PlayerStartPositions'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@onready var _player_start_positions: Node2D = $PlayerStartPositions'
- en: '[PRE8]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'main.gd script:'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: main.gd 脚本：
- en: '[PRE9]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'func _ready():'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'func _ready():'
- en: _player_multiplayer_spawner.spawn_function = spawn_player
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: _player_multiplayer_spawner.spawn_function = spawn_player
- en: 'if multiplayer.is_server():'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'if multiplayer.is_server():'
- en: multiplayer.peer_connected.connect(add_player)
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: multiplayer.peer_connected.connect(add_player)
- en: add_player(1)
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: add_player(1)
- en: '[PRE11]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: multiplayer.peer_connected.connect(add_player)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: multiplayer.peer_connected.connect(add_player)
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'var multiplayer_id: int'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'var multiplayer_id: int'
- en: '[PRE13]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'func _enter_tree():'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'func _enter_tree():'
- en: set_multiplayer_authority(multiplayer_id)
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: set_multiplayer_authority(multiplayer_id)
- en: '[PRE14]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '@onready var _camera_position: Node2D = $CameraPosition'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@onready var _camera_position: Node2D = $CameraPosition'
- en: '[PRE15]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'func _ready():'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'func _ready():'
- en: update_health_label()
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: update_health_label()
- en: 'if not multiplayer.is_server():'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'if not multiplayer.is_server():'
- en: _shoot_timer.stop()
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: _shoot_timer.stop()
- en: 'if not is_multiplayer_authority():'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'if not is_multiplayer_authority():'
- en: _camera_position.queue_free()
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: _camera_position.queue_free()
- en: set_physics_process(false))
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: set_physics_process(false))
- en: '[PRE16]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'func _enter_tree() -> void:'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'func _enter_tree() -> void:'
- en: set_multiplayer_authority(multiplayer_id)
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: set_multiplayer_authority(multiplayer_id)
- en: 1. So, to give the authority to the server, we set the multiplayer authority
    of HealthMultiplayerSynchronizer to 1.
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 1. 因此，为了将权限赋予服务器，我们将 HealthMultiplayerSynchronizer 的多玩家权限设置为 1。
- en: '[PRE17]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '@onready var _multiplayer_spawner = $MultiplayerSpawner'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@onready var _multiplayer_spawner = $MultiplayerSpawner'
- en: '[PRE18]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'func _ready():'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'func _ready():'
- en: _multiplayer_spawner.add_spawnable_scene(entity_scene.resource_path)
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: _multiplayer_spawner.add_spawnable_scene(entity_scene.resource_path)
- en: 'if multiplayer.is_server():'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'if multiplayer.is_server():'
- en: start_timer()
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: start_timer()
- en: '[PRE19]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: add_child(new_entity, true)
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: add_child(new_entity, true)
- en: '[PRE20]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '@onready var _player_detection_area: Area2D = $PlayerDetectionArea'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@onready var _player_detection_area: Area2D = $PlayerDetectionArea'
- en: '[PRE21]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'func _ready():'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'func _ready():'
- en: 'if not multiplayer.is_server():'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'if not multiplayer.is_server():'
- en: set_physics_process(false)
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: set_physics_process(false)
- en: _player_detection_area.monitoring = false
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: _player_detection_area.monitoring = false
- en: return
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return
- en: 'var player_nodes: Array = get_tree().get_nodes_in_group("player")'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'var player_nodes: Array = get_tree().get_nodes_in_group("player")'
- en: 'if not player_nodes.is_empty():'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'if not player_nodes.is_empty():'
- en: target = player_nodes.pick_random()
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: target = player_nodes.pick_random()
- en: '[PRE22]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '@onready var _enemy_detection_area: Area2D = $EnemyDetectionArea'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '@onready var _enemy_detection_area: Area2D = $EnemyDetectionArea'
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'func _ready():'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'func _ready():'
- en: 'if not multiplayer.is_server():'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'if not multiplayer.is_server():'
- en: set_physics_process(false)
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: set_physics_process(false)
- en: _enemy_detection_area.monitoring = false
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: _enemy_detection_area.monitoring = false
- en: '[PRE24]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: get_parent().add_child(new_projectile, true)
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: get_parent().add_child(new_projectile, true)
- en: '[PRE25]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'func _ready():'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'func _ready():'
- en: '# Other code'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '# 其他代码'
- en: 'if not multiplayer.is_server():'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'if not multiplayer.is_server():'
- en: set_process(false)
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: set_process(false)
- en: '[PRE26]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'func add_player(id: int):'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'func add_player(id: int):'
- en: 'var player: Player = player_scene.instantiate()'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'var player: Player = player_scene.instantiate()'
- en: player.name = str(id)
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: player.name = str(id)
- en: add_child(player)
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: add_child(player)
- en: '_on_player_died() function and add a new end_game() function:'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '_on_player_died() 函数和添加一个新函数 end_game():'
- en: '[PRE27]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'func _ready():'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'func _ready():'
- en: '_highscore_label.text = "Highscore: " + str(Highscore.highscore)'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '_highscore_label.text = "Highscore: " + str(Highscore.highscore)'
- en: 'if multiplayer.has_multiplayer_peer():'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'if multiplayer.has_multiplayer_peer():'
- en: multiplayer.multiplayer_peer.close()
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: multiplayer.multiplayer_peer.close()
- en: '[PRE29]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '@onready var _ip_label = $CanvasLayer/NetworkUI/IPLabel'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@onready var _ip_label = $CanvasLayer/NetworkUI/IPLabel'
- en: '[PRE30]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'func show_local_ip_address():'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'func show_local_ip_address():'
- en: var addresses = []
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: var addresses = []
- en: 'for ip in IP.get_local_addresses():'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'for ip in IP.get_local_addresses():'
- en: 'if ip.begins_with("10.") or ip.begins_with("172.16.") or ip.begins_with("192.168."):'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'if ip.begins_with("10.") or ip.begins_with("172.16.") or ip.begins_with("192.168."):'
- en: addresses.push_back(ip)
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: addresses.push_back(ip)
- en: 'if not addresses.is_empty():'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'if not addresses.is_empty():'
- en: _ip_label.text = addresses[0]
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: _ip_label.text = addresses[0]
- en: '[PRE31]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'func _ready():'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'func _ready():'
- en: 'if multiplayer.is_server():'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'if multiplayer.is_server():'
- en: show_local_ip_address()
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: show_local_ip_address()
- en: '# …'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '# …'
- en: '[PRE32]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Part 3: Deepening Our Knowledge'
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分：深化我们的知识
- en: After learning how to program and creating your very own game from scratch,
    you will now take a step back and learn some more advanced programming and game
    development techniques.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习如何编程并从头开始创建你自己的游戏之后，你现在将退一步，学习一些更高级的编程和游戏开发技术。
- en: By the end of this final part, you will have exported and distributed your game
    to various different platforms on the web so that everyone can play it from within
    their browser. You will also learn more advanced OOP concepts and different programming
    patterns that will help you in your future game projects. Even the filesystem
    will be covered so that you can save and load data. The last chapter will guide
    you through the next steps to take, which resources you could consult to learn
    more, and how to join the game development community.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本最终部分的结束时，你将把你的游戏导出并分发到网络上的各种不同平台，以便每个人都可以在他们的浏览器中玩。你还将学习更多高级的面向对象编程概念和不同的编程模式，这些模式将有助于你在未来的游戏项目中。文件系统也将被涵盖，这样你就可以保存和加载数据。最后一章将指导你进行下一步，你可以咨询哪些资源来学习更多，以及如何加入游戏开发社区。
- en: 'This part has the following chapters:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 12*](B19358_12.xhtml#_idTextAnchor689), *Exporting to Multiple Platforms*'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B19358_12.xhtml#_idTextAnchor689)，*导出到多个平台*'
- en: '[*Chapter 13*](B19358_13.xhtml#_idTextAnchor705), *OOP Continued and Advanced
    Topics*'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第13章*](B19358_13.xhtml#_idTextAnchor705)，*面向对象编程的继续与高级主题*'
- en: '[*Chapter 14*](B19358_14.xhtml#_idTextAnchor721), *Advanced Programming Patterns*'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第14章*](B19358_14.xhtml#_idTextAnchor721)，*高级编程模式*'
- en: '[*Chapter 15*](B19358_15.xhtml#_idTextAnchor740), *Using the File System*'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第15章*](B19358_15.xhtml#_idTextAnchor740)，*使用文件系统*'
- en: '[*Chapter 16*](B19358_16.xhtml#_idTextAnchor755), *What Next?*'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第16章*](B19358_16.xhtml#_idTextAnchor755)，*接下来是什么？*'
