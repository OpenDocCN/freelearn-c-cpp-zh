- en: Enhancing the Qt Graphical Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 5](411aae8c-9215-4315-8a2e-882bf028834c.xhtml), *Qt Graphical Applications*,
    we developed graphical Qt applications involving an analog clock, a drawing program,
    and an editor. In this chapter, we will continue to work on the three graphical
    applications of  [Chapter 5](https://cdp.packtpub.com/c___by_example/wp-admin/post.php?post=72&action=edit#post_67),
    *Qt Graphical Applications*. However, we will make the following improvements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Clock**: We will add digits to the clock dial'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The drawing program**: We will add the ability to move and modify figures,
    to cut and paste them, and to mark one or several figures'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The editor**: We will add the ability to change font and alignment as well
    as to mark a text block'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, we will continue to work with the Qt libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: Windows and widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Menus and toolbars
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mouse and keyboard events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving the clock
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will replace the version of clock dial markings with digits.
  prefs: []
  type: TYPE_NORMAL
- en: The Clock class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Clock` class definition is similar to the one in [Chapter 5](https://cdp.packtpub.com/c___by_example/wp-admin/post.php?post=72&action=edit#post_67), *Qt
    Graphical Applications*. The timer updates the window 10 times each second. The
    constructor initializes the clock and `paintEvent` is called every time the window
    needs to be repainted.
  prefs: []
  type: TYPE_NORMAL
- en: '**Clock.h:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Clock.cpp:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to [Chapter 5](https://cdp.packtpub.com/c___by_example/wp-admin/post.php?post=72&action=edit#post_67), *Qt
    Graphical Applications*, the constructor sets the header of the window to `Clock
    Advanced`, the window size to *1000* x *500* pixels, initializes the timer to
    send a timeout message every `100` milliseconds, and connect the `timeout` message
    to the `update` method, which forces the window to be repainted for each timeout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `paintEvent` method is called every time the window needs to be repainted.
    We will start by calculating the side of the clock and obtaining the current time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We then create and initialize a `QPainter` object. We call `translate` and
    `scale` to match the physical size (pixels) to the logical size of *200 x 200*
    units:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As we write digits to the clock in this version of the chapter, we add the
    font `Times New Roman`, `12` points, to the painter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We write the digits of the clock, `1` to `12`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'A whole leap is 360° and the angle between two consecutive digits is 30°, since
    360 divided by 12 is 30:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `x` and `y` coordinates of the digits are calculated by the sine and cosine
    functions. However, first, we need to transform the degrees to radians since sine
    and cosine accept radians only. This is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `drawText` methods write the digit, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When the digits have been written, we draw the `hour`, `minute`, and `second`
    hands in the same way as in [Chapter 5](https://cdp.packtpub.com/c___by_example/wp-admin/post.php?post=72&action=edit#post_67), *Qt
    Graphical Applications*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The main function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `main` function is similar to the one in [Chapter 5](https://cdp.packtpub.com/c___by_example/wp-admin/post.php?post=72&action=edit#post_67), *Qt
    Graphical Applications*. It creates an application object, initializes the clock,
    and executes the application.
  prefs: []
  type: TYPE_NORMAL
- en: '**Main.cpp:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '**Output**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4fc9d538-a689-43c2-9e55-d697cc18342c.png)'
  prefs: []
  type: TYPE_IMG
- en: Improving the drawing program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The drawing program of this chapter is a more advanced version of the drawing
    program of [Chapter 5](https://cdp.packtpub.com/c___by_example/wp-admin/post.php?post=72&action=edit#post_67), *Qt
    Graphical Applications.* In this version, it is possible to modify a figure, to
    enclose one or more figures and then change their colors, and to cut and paste
    figures.
  prefs: []
  type: TYPE_NORMAL
- en: The Figure class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Figure` class is rather similar to the one in [Chapter 5](https://cdp.packtpub.com/c___by_example/wp-admin/post.php?post=72&action=edit#post_67), *Qt
    Graphical Applications*. However, `isInside`, `doubleClick`, `modify`, and `marked`
    have been added.
  prefs: []
  type: TYPE_NORMAL
- en: '**Figure.h:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In this version, the pure virtual `clone` method has been added. That is due
    to the cut and paste. When pasting a figure we want to create a copy of it, without
    actually knowing which class the object belongs to. We could not do that with
    the copy constructor only. This is actually the main point of this section: how
    to use pure virtual methods and how to take advantage of dynamic binding. We need
    `clone`, which calls the copy constructor of its class to return a pointer to
    the new object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In this version of the drawing program, `onClick` sets fields to indicate whether
    the figure shall be modified or moved. If the user grabs one of the marked points
    of the figure (which varies between different kinds of figures), the figure shall
    be modified. Otherwise, it shall be moved. The `modify` method is called when
    the user grabs one of the corners of the figure. In that case, the figure shall
    be modified rather than moved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `isInside` method returns `true` if the figure is completely enclosed in
    the area. It is called when the user encloses figures with the mouse:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `doubleClick` method is called when the user double-clicks at the figure,
    each figure performs some suitable action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `marked` methods return and set the `m_marked` field. When a figure is
    marked, it is annotated with small squares:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '**Figure.cpp:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `write` and `read` methods write and read the color of the figure and whether
    it is filled. However, they do not write or read the marked status. A figure is
    always unmarked when written or read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The Line class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Line` class is a subclass of `Figure`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Line.h:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned in the preceding `Figure` section, `isClick` decided whether the
    line shall be modified or moved. If the user grabs one of its endpoints, only
    that endpoint shall be moved. If the user grabs the line between the endpoints,
    the line shall be moved. That is, both the endpoints of the line shall be moved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `isInside` method checks whether the line is completely enclosed by the
    area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `doubleClick` method does nothing in the `Line` class. However, we still
    need to define it, since it is pure virtual in `Figure`. If we had not defined
    it, `Line` would have been abstract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `modify` method modifies the line in accordance with the settings of the
    preceding `isClick`. If the user grabs one of the endpoints, that endpoint is
    moved. Otherwise, the whole line (both the endpoints) is moved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `area` method returns a slightly larger area if the line is marked, in
    order to include the marking squares:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `m_lineMode` field keeps track of the movement or modification of the line.
    When the line is created, `m_lineMode` is set to `LastPoint`. When the user grabs
    the first or last endpoint of the line, `m_lineMode` is set to `FirstPoint` or
    `LastPoint`. When the user grabs the line between the endpoints, `m_lineMode`
    is set to `MoveLine`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `isPointInLine` method decides whether the user has clicked on the line,
    with some tolerance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '**Line.cpp:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'When a line becomes created, the line mode is set to the last point. That means
    that the last point of the line will be changed when the user moves the mouse:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `clone` method is called when a line is being pasted. The copy constructor
    of `Figure` is called to set the color of the figure. Note that we call the `Figure`
    constructor with a `Line` object as a parameter, even though it takes a reference
    to a `Figure` object as a parameter. We are allowed to do this since `Line` is
    a subclass of `Figure` and the `Line` object will be transformed into a `Figure`
    object during the call. Moreover, the first and last endpoints are copied. Note
    that we do need to copy the value `m_lineMode` since its value is set when the
    user creates, modifies, or moves the line only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `clone` method uses the copy constructor to create a new object, which
    is then returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `initializePoints` method is called shortly after the line is being created.
    The reason for this call is that we do not create a `Line` object directly. Instead,
    we create the line indirectly by calling `clone`. We then need to initialize the
    end-points by calling `initializePoints`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `isClick` method is called when the user clicks with the mouse. First,
    we check whether they have clicked at the first endpoint. We use the `Tolerance`
    field to create a small square, with the first endpoint in its center. If the
    user clicks on the square, `m_lineMode` is set to `FirstPoint` and `true` is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same way, we create a small square with the last endpoint in its center.
    If the user clicks at the square, `m_lineMode` is set to `LastPoint` and `true`
    is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If the user does not click on either of the endpoints, we check if they click
    on the line itself. If they do, `m_lineMode` is set to `ModeLine` and `true` is
    returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, if the user does not click on one of the endpoints or the line itself,
    they missed the line altogether and `false` is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `isInside` method returns `true` if the line is completely enclosed by
    the area. It is quite easy, we just check whether the two end-points are located
    inside the area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `isPointInLine` method is identical to `isClick` in the version of [Chapter
    5](411aae8c-9215-4315-8a2e-882bf028834c.xhtml), *Qt Graphical Application**s*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `modify` method moves the first or last endpoint, or both of them, depending
    on the settings of `m_lineMode` in the preceding `isClick` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The `move` method simply moves both the end-points of the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `draw` method draws the line. The difference between this version and the
    version of [Chapter 5](411aae8c-9215-4315-8a2e-882bf028834c.xhtml), *Qt Graphical
    Applications*, is that it also draws the squares at the end-points of the line
    if it is marked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The `area` method returns the area covering the line. If the line is marked,
    the area is slightly expanded in order to cover the squares marking the endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the version of [Chapter 5](https://cdp.packtpub.com/c___by_example/wp-admin/post.php?post=72&action=edit#post_67), *Qt
    Graphical Applications*, `write` and `read` call their counterparts in `Figure`
    and then write and read the two endpoints of the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The Rectangle class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`RectangleX` is a subclass of `Figure`. It is an expanded version of the version
    of [Chapter 5](https://cdp.packtpub.com/c___by_example/wp-admin/post.php?post=72&action=edit#post_67), *Qt
    Graphical Applications*. The `isClick` method has been modified, `doubleClick`
    and `modify` have been added.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Rectangle.h:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '**Rectangle.cpp:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'When a rectangle is added by the user, its mode is `BottomRightPoint`. That
    means that the bottom-right corner of the rectangle will be moved when the user
    moves the mouse:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The copy constructor copies the rectangle. More specifically, first it calls
    the copy constructor of the `Figure` class, then it copies the top-left and bottom-right
    corner. Note that it does not copy the `m_rectangleMode` field, since it is used
    when the user moves the mouse only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The `clone` method creates and returns a pointer to a new object by calling
    the copy constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The `isClick` method is called when the user clicks with the mouse. Similar
    to the preceding bool `Line`, we start by checking whether they have clicked at
    any of the corners. If they have not, we check whether they have clicked on the
    rectangle border or inside the rectangle, depending on whether it is filled.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by defining a small square covering the top-left corner. If the user
    clicks on it, we set the `m_rectangleMode` field to `TopLeftPoint` and return
    `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We continue by defining a square covering the top-right corner. If the user
    clicks on it, we set `m_rectangleMode` to `TopRightPoint` and return `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'If the user clicks at the square covering the bottom-right corner, we set `m_rectangleMode`
    to `BottomRightPoint` and return `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'If the user clicks at the square covering the bottom-left corner, we set `m_rectangleMode`
    to `BottomLeftPoint` and return `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'If the user does not click at any of the corners of the rectangle, we check
    the rectangle itself. If it is filled, we check whether the mouse pointer is located
    inside the rectangle itself. If it is, we set `m_rectangleMode` to `MoveRectangle`
    and return `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'If the rectangle is not filled, we define slightly larger and smaller rectangles.
    If the mouse click is located inside the larger rectangle, but not in the smaller
    one, we set `m_rectangleMode` to `MoveRectangle` and return `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, if the user does not click at one of the corners or the rectangle
    itself, they missed the rectangle and we return `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The `isInside` method is quite simple. We simply check if the top-left and
    bottom-right corners are located inside the rectangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The `doubleClick` method is called when the user double-clicks with the mouse.
    If the call to `onClick` returns `true`, `doubleClick` is called. In the rectangle
    case, the filled status is changed—a filled rectangle becomes unfilled and an
    unfilled rectangle becomes filled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The first call to `filled` is a call to the version that returns a reference
    to the `m_filled` field, which allows us to change the returned value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The `modify` method modifies the rectangle in accordance with the `m_rectangleMode`
    field, which was set by the preceding `isClick`. If it is set to one of the four
    corners, we modify that corner. If not, we move the whole rectangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The `move` method is quite simple. It just changes the top-left and bottom-right
    corners:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The `area` method returns the area covering the rectangle. If it is marked,
    we slightly expand the area in order for it to cover the marking squares:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The `draw` method draws the rectangle; with a full brush it is filled and with
    a hollow brush if it is unfilled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'If the rectangle is marked, the four squares covering the corners of the rectangle
    are also drawn:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The `write` and `read` methods first call their counterparts in `Figure` in
    order to write and read the color of the rectangle. Then it writes and reads the
    top-left and bottom-right corners:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The Ellipse class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`EllipseX` is a direct sub class of `RectangleX` and an indirect subclass of
    `Figure` that draws a filled or unfilled ellipse:'
  prefs: []
  type: TYPE_NORMAL
- en: '**EllipseX.h:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the preceding rectangle case, `isClick` checks whether the user
    grabs the ellipse in one of its four corners, or if the ellipse itself shall be
    moved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The `modify` method modifies the ellipse in accordance with the settings of
    following `m_ellipseMode` in preceding `isClick`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'While the preceding rectangle could be grabbed by its four corners, the ellipse
    can be grabbed by its left, top, right, and bottom points. Therefore, we need
    to add the `CreateEllipse` enumeration value, which modifies the bottom-right
    corner of the area covering the ellipse:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '**EllipseX.cpp:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'In contrast to the preceding line and rectangle cases, we set the `m_ellipseMode`
    field to `CreateEllipse`, which is valid when the ellipse is being created only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The copy constructor does not need to set the `m_topLeft` and `m_bottomRight`
    fields, since it is taken care of by the copy constructor of `RectangleX`, which
    is being called by the copy constructor of `EllipseX`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the preceding rectangle case, `isClick` checks whether the user
    grabs the ellipse by one of its four points. However, in the ellipse case, we
    do not check the corners of the rectangle. Instead, we check the left, top, right,
    and bottom position of the ellipse. We create a small square for each of those
    positions and check whether the user clicks on them. If they do, we set the `m_ellipseMode`
    field to an appropriate value and return `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'If the user does not click on any of the four positions, we check whether they
    click on the ellipse itself. If it is filled, we use the Qt `QRegion` class to
    create an elliptic region and we check whether the mouse point is located inside
    the region:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'If the ellipse is unfilled, we create slightly larger and smaller elliptic
    regions and then check whether the mouse point is located inside the larger region,
    and also inside the smaller one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, if the user does not click at any of the grabbing positions or the
    ellipse itself, we return `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The `modify` method modifies the ellipse in accordance with the settings of
    `m_ellipseMode` in `onClick`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The `draw` method draws the ellipse with a solid brush if it is filled, and
    with a hollow brush if it is unfilled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'If the ellipse is marked, the four squares covering the top, left, right, and
    bottom points of the ellipse are also drawn:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The DrawingWindow class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `DrawingWindow` class is similar to the version of the previous chapter.
    It overrides the `closeEvent` method.
  prefs: []
  type: TYPE_NORMAL
- en: '**DrawingWindow.h:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '**DrawingWindow.cpp:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor initializes the window size to *1000* x *500* pixels, puts
    the drawing widget in the middle of the window, adds the standard File and Edit
    menus, and adds the application-specific Format and Figure menus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The Format menu holds the `Color`, `Fill`, and `Modify` items as well as the
    Figure submenu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The user selects the Modify item when they want to mark or modify existing
    figures instead of adding new figures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'The Figure menu is a submenu holding the `Line`, `Rectangle`, and `Ellipse`
    items. It becomes a submenu when we add it to the Format menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The DrawingWidget class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `DrawingWidget` class is the main class of the application. It catches the
    mouse and paint events. It also catches the menu item selections of the File,
    Edit, and Figure menus.
  prefs: []
  type: TYPE_NORMAL
- en: '**DrawingWidget.h:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike the version of [Chapter 5](411aae8c-9215-4315-8a2e-882bf028834c.xhtml), *Qt
    Graphical Applications*, this version overrides the cut and copy event methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The `m_applicationMode` field holds the values `Idle`, `ModifySingle`, or `ModifyRectangle`.
    The `Idle` mode is active when the user is not pressing the mouse. The `ModifySingle`
    mode becomes active when the user grabs a figure and modifies or moves it (depending
    on which part of the figure the user grabs). Finally, the `ModifyRectangle` mode
    becomes active when the user clicks at the window without hitting a figure. In
    that case, a rectangle is shown, and every figure enclosed by the rectangle becomes
    marked when the user releases the mouse button. The user can delete or cut and
    paste the marked figure, or change their color or the filled status. When the
    user releases the mouse button, the `Application` mode again becomes `Idle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The `m_actionMode` field holds the values `Modify` or `Add`. In `Modify` mode,
    when the user clicks with the mouse, `m_applicationMode` is set to `ModifySingle`
    or `ModifyRectangle`, depending on whether they hit a figure. In `Add` mode, a
    new figure is added, regardless of whether the user hits a figure. The kind of
    figure to be added is set by `m_addFigureId`, which holds the values `LineId`,
    `RectangleId`, or `EllipseId`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'The color of the next figure to be added to the drawing is initialized to black,
    and the filled status is initialized to false (unfilled). In both cases, it can
    later be changed by the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to save the latest mouse point in order to calculate distances between
    mouse movements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Pointers to the figures of the drawing are stored in `m_figurePtrList`. The
    top-most figure is stored at the end of the list. When the user cuts or copies
    one or several figures, the figures are copied and the pointers to the copies
    are stored in `m_copyPtrList`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'When `m_actionMode` holds `Modify` and the user presses the mouse button without
    hitting a figure, a rectangle becomes visible in the window. That rectangle is
    stored in `m_insideRectangle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '**DrawingWidget.cpp:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor calls the constructor of the base class `DocumentWidget` to
    set the header of the window to `Drawing Advanced`, and to set the file suffix
    of the drawing files to `drw`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The destructor does nothing, it has been included for the sake of completeness
    only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'The `setApplicationMode` method sets the application mode and calls `onMenuShow`
    in the main window for the toolbar icons to be correctly enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'The `newDocument` method is called when the user selects the `New` menu item.
    We start by deallocating every figure in the figure and copy pointer lists, and
    they clear the list themselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'The current color and filled status are set to black and false (unfilled).
    The action mode is set to `Add` and the add figure identity is set to `LineId`,
    which means that when the user presses the mouse button a black line is added
    to the drawing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'The `writeFile` method is called when the user selects the `Save` or `Save
    As` menu items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'If the file was successfully opened, we start by writing the next color and
    filled status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'We then write the number of figures in the drawing, and then we write the figures
    themselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'For each figure, first we write its identity value, we then write the figure
    itself by calling `write` on its pointer. Note that we do not know which class
    the figure pointer points at. We do not need to know that, since `write` is a
    pure virtual method in the base class `Figure`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'We return the output stream converted to `bool`, which is true if the writing
    was successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'If the file was not successfully opened, we return `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'The `readFile` method is called when the user selects the Open menu item. We
    read the parts of the file in the same order as we wrote them in the preceding `writeFile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'If the file was successfully opened, we start by reading the next color and
    filled status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'We then write the number of figures in the drawing, and then we write the figures
    themselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'For each figure, first we read its identity value, we then create a figure
    of the class indicated by the identity value by calling `createFigure`. Finally,
    we read the figure itself by calling `write` on its pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'We return the input stream converted to `bool`, which is true if the reading
    was successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'If the file was not successfully opened, we return `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'The `createFigure` method dynamically creates an object of the `Line`, `RectangleX`,
    or `EllipseX` class, depending on the value of the `figureId` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'The `isCopyEnable` method is called before the Edit menu becomes visible in
    order to enable the Copy item. It is also called by the framework in order to
    enable the Copy toolbar icon. It returns `true` if at least one figure is marked,
    and by then it is ready to be copied. If it returns `true`, the Copy item and
    toolbar icon become enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onCopy` method is called when the user selects the Copy menu item. To
    start with, it deallocates every figure in the copy pointer list and clears the
    list itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we iterate through the figure pointer list and add the pointer to a copy
    of each marked figure to the copy pointer list. We call `clone` on each figure
    pointer to provide us with the copy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'The `isPasteEnabled` method is called before the Edit menu becomes visible
    to enable the Paste item. It is also called by the framework to enable the paste
    toolbar icon. If the copy pointer list is not empty, it returns `true`, and thereby
    enables the Paste item and image. That is, it returns `true` if there are figures
    ready to be pasted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onPaste` method is called when the user selects the Paste item in the
    Edit menu, or when they select the paste image in the edit toolbar. We iterate
    through the copy pointer list and add a copy (which we obtain by calling `clone`)
    of the figure to the figure pointer list, after we have moved it 10 pixels downwards
    and to the right:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, when the figures have been added to the list, we force an eventual
    call to the `paintEvent` by calling `update`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onDelete` method is called every time the user selects the Delete menu
    item or toolbar icon. We iterate through the figure pointer list and remove every
    marked figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, in this case, we force an eventual call to `paintEvent` by calling the `update`
    method, after the figures have been deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onColor` method is called every time the user selects the `Color` item
    in the Format menu. We start by obtaining the new color by calling the static
    method `getColor` in the Qt `QColorDialog` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'If the color is valid, which it is if the user has closed the dialog by pressing
    the Ok button rather than the Cancel button, and if they have chosen a new color,
    we set the next color to the new color and set the modified flag. We also iterate
    through the figure pointer list and, for each marked figure, set the color of
    the figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'If at least one figure is marked, we force an eventual call to `paintEvent`
    by calling update:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'The `isFillEnabled` method is called before the `Fill` item in the Format menu
    becomes visible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'In `Modify` mode, we iterate through the figure pointer list. If at least one
    rectangle or ellipse is marked, we return `true` and the item becomes enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'If no rectangle or ellipse is marked, we return `false` and the item becomes
    disabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Add` mode, we return `true` if the next figure to be added by the user
    is a rectangle or an ellipse:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'We are not supposed to reach this point. The `assert` macro call is for debugging
    purposes only. However, we still must return a value at the end of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onFill` method is called when the user selects the `Fill` item in the
    Format menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Modify` mode, we iterate through the figure pointer list and invert
    the filled status of all marked figures. If at least one figure changes, we force
    an eventual call to `paintEvent` by calling `update`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'We also invert the filled status of the next figure to be added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Add` mode, we invert the filled status of the next figure to be added
    by the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'The `isModifyChecked` method is called before the `Modify` item in the Format
    menu becomes visible. In `Modify` mode, it returns `true` and enables the item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onModify` method is called when the user selects the `Modify` item in
    the Format menu. It sets the action mode to `Modify`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'The `isLineChecked` method is called before the `Line` item in the `Add` submenu
    becomes visible. It returns `true`, and the item becomes checked (with a radio
    button, since the item belongs to a group) in case of add action mode, and the
    next figure to be added is a line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onLine` method is called when the user selects the `Line` item in the
    `Add` submenu. It set the action mode to `Add` and the next figure to be added
    by the user to a line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'The `isRectangleChecked` method is called before the `Rectangle` item in the
    `Add` submenu becomes visible. It returns `true` in case of `Add` action mode
    and if the next figure to be added is a rectangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onRectangle` method is called when the user selects the `Rectangle` item.
    It sets the action mode to `Add` and the next figure to be added by the user to
    a rectangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'The `isEllipseChecked` method is called before the `Ellipse` item in the `Add`
    submenu becomes visible. It returns `true` in case of `Add` action mode and if
    the next figure to be added is an ellipse:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onEllipse` method is called when the user selects the `Ellipse` item.
    It sets the action mode to `Add` and the next figure to be added by the user to
    an ellipse:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mousePressEvent` method is called when the user presses one of the mouse
    buttons. We store the mouse point in `m_mousePoint`, to be used in `mouseMoveEvent` as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'In case of `Modify` mode, we first iterate through the figure pointer list
    and unmark every figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'We then iterate through the list again, to find if the user has hit a figure.
    Since the top-most figure is placed at the end of the list, we need to iterate
    through the list backward. We do so by using the `reverse_iterator` type of the
    Qt `QList` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'If we found out (by calling `isClick` on the figure) that a figure has been
    hit by the user''s mouse click, we set the application mode to `ModifySingle`
    and mark the figure. We also remove it from the list and add it to the end of
    the list, to make it appear top-most in the drawing. Finally, we break the loop
    since we have found a figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'If we have not found a figure, we set the application mode to `ModifyRectangle`
    and initialize the top-most and bottom-right corners of the enclosing rectangle
    to the mouse point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'In case of `Add` action mode, we create a new figure by calling `createFigure`
    with the identity of the next figure to be added by the user as a parameter. We
    then set the color, filled status of the new figure, and initialize its endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'When the new figure has been created and initialized, we add it at the end
    of the figure pointer list and set the application mode to `ModifySingle`, since
    the `mouseMoveEvent` method will continue to modify the last figure in the list,
    just as if the user had hit a figure in the `Modify` mode. We also set the modified
    flag since we have added a figure to the drawing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we force an eventual call to `paintEvent` by calling `update`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mouseMoveEvent` method is called when the user moves the mouse. If they
    also press the left mouse button, we save the mouse point to future calls to `mouseMoveEvent`
    and calculate the distance since the last call to `mousePressEvent` or `mouseMoveEvent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Modify` mode, we modify the current figure (the figure placed at the
    end of the figure pointer list) by calling `modify`. Remember that the figure
    can be either modified or moved, depending on the settings in the call to `isClick`
    in `onMousePress` previously. We also set the modified flag since the figure has
    been altered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'In case of the enclosing rectangle, we just update its bottom-right corner.
    Note that we do not set the modified flag since no figure has yet been altered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we force an eventual call to `paintEvent` by calling `update`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mouseReleaseEvent` method is called when the user releases a mouse button.
    If it is the left mouse button, we check the application mode. The only mode we
    actually are interested in is the enclosing rectangle mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'We iterate through the figure pointer list and call `isInside` on each figure.
    Each figure that is completely enclosed by the rectangle becomes marked, removed
    from the list, and added to `insidePtrList` to be later added at the end of the
    figure pointer list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'Each figure which is completely enclosed by the rectangle is removed from the
    figure pointer list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, all enclosed figures are added at the end of the list in order to
    appear top-most in the drawing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'When the user has released the mouse button, the application mode is set to
    idle, and we force an eventual call to `paintEvent` by calling `update`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mouseDoubleClick` method is called when the user double-clicks one of
    the buttons. However, `mouseClickEvent` is always called before `mouseDoubleClickEvent`.
    If the preceding call to `mouseClickEvent` has made `m_clickedFigurePtr` point
    at the clicked figure, we call `doubleClick` on that figure. This may cause some
    change in the figure, depending on which kind of figure it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, `paintEvent` is called when the content of the window needs to be
    repainted. Before the call, the framework clears the window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'We iterate through the figure pointer list and draw every figure. The last
    figure in the list is placed at the end of the list, to appear at the top of the
    drawing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'In case of enclosing rectangle mode, we draw a hollow rectangle with a light-gray
    border:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: The main function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `main` function is similar to the `main` function of the previous applications—it
    creates an application, shows the drawing window, and starts the execution of
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: '**Main.cpp:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e32d6956-fb1d-4513-bb7f-b7b7529a3466.png)'
  prefs: []
  type: TYPE_IMG
- en: Improving the editor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The editor of this chapter is a more advanced version of the editor of [Chapter
    5](411aae8c-9215-4315-8a2e-882bf028834c.xhtml), *Qt Graphical Applications*. In
    this version, it is possible to change the font and alignment of the text, to
    mark text, and to cut and paste text.
  prefs: []
  type: TYPE_NORMAL
- en: The EditorWindow class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `EditorWindow` class of this chapter is similar to the class of [Chapter
    5](https://cdp.packtpub.com/c___by_example/wp-admin/post.php?post=72&action=edit#post_67), *Qt
    Graphical Applications*. It catches the key pressing event and the window closing
    event.
  prefs: []
  type: TYPE_NORMAL
- en: '**EditorWindow.h:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '**EditorWindow.cpp:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor initializes the editor window. It sets the size of the window
    to *1000 x 500* pixels. It also dynamically creates an editor widget and adds
    the standard File and Edit menus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'The Figure menu is different, compared to [Chapter 5](411aae8c-9215-4315-8a2e-882bf028834c.xhtml), *Qt
    Graphical Applications*. We add the item `Font` and the submenu Alignment, to
    which, in turn, we add the three items: left, center, and right:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'We also add a toolbar for the `Alignment` menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'The key pressing event and the window closing event are passed on to the editor
    widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: The EditorWidget class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `EditorWidget` class is similar to the version of [Chapter 5](411aae8c-9215-4315-8a2e-882bf028834c.xhtml),
    *Qt Graphical Applications*. However, methods and listeners to handle the font
    and alignment have been added.
  prefs: []
  type: TYPE_NORMAL
- en: '**EditorWidget.h:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mousePresseEvent`, `mouseMoveEvent`, and `mouseReleaseEvent` are called
    when the user presses a mouse button, moves the mouse, and releases the mouse
    button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: 'The `newDocument` method is called when the user selects the New menu item,
    `writeFile` is called when they select Save or Save As, and `readFile` is called
    when they select the Open menu item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: 'The `isLeftChecked`, `isCenterChecked`, and `isRightChecked` methods are called
    before the `Alignment` submenu becomes visible. They then annotate a radio button
    to the selected alignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onLeft`, `onCenter`, and `onRight` methods are called when the user selects
    one of the items of the Alignment submenu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: 'In this version of the editor, we have two modes—edit and mark. The edit mark
    is active when the user inputs text or moves the caret with the arrow key, while
    the mark mode is active when the user has marked a block of the code with the
    mouse. The caret is visible in edit mode, but not in mark mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: 'The text can be aligned in the left, center, and right direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: 'In edit mode, `m_editIndex` holds the index to place the next character to
    be input by the user, which also is the position of the caret. In mark mode, `m_firstIndex`
    and `m_lastIndex` hold the indexes of the first and last marked character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: 'The `m_caret` object holds the caret of the editor. The caret is visible in
    edit mode, but not in mark mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: 'The `m_editorText` field holds the text of the editor, and `m_copyText` holds
    the text which is cut or pasted by the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: 'The text of the editor is divided into lines; the index of the first and last
    character of each line is stored in `m_lineList`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: 'The current font of the text is stored in `m_textFont`. The height in pixels
    of a character of the current font is stored in `m_fontHeight`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mousePressEvent` and `mouseMoveEvent` methods store the last mouse point
    in order to calculate the distance between mouse events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the method of [Chapter 5](411aae8c-9215-4315-8a2e-882bf028834c.xhtml),
    *Qt Graphical Applications*, `calculate` is an auxiliary method that calculates
    the enclosing rectangle of each character of the text. However, the version of
    this chapter is more complicated since it has to take into consideration whether
    the text is left, center, or right-aligned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: 'The enclosing rectangles are stored in `m_rectList`, and then used by the caret
    and `paintEvent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '**EditorWidget.cpp:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor sets the window header to `Editor Advanced` and the file suffix
    to `edi`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: 'The text font is initialized to `12` point `Times New Roman`. The application
    mode is set to edit, the index of the next character to be input by the user is
    set to zero, and the text is left- aligned from the beginning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: 'The rectangles enclosing the characters are calculated by `calculate`, the
    caret is initialized and shown since the application holds edit mode from the
    beginning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: 'The `newDocument` method is called when the user selects the New menu item.
    We start by setting the application mode to edit and the edit index to zero. The
    text font is set to `12` point Times New Roman. The text of the editor is cleared,
    the rectangles enclosing the characters are calculated by `calculate`, and the
    caret is set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: 'The `writeFile` method is called when the user selects the Save or Save As
    menu items. The file format is quite simple: we write the font on the first line,
    and then the text of the editor on the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the `Ok` field of the input stream to decide if the writing was successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: 'If we could not open the file for writing, we return `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: 'The `readFile` method is called when the user selects the Open menu items.
    Similar to `writeFile` previously, we read the first line and initialize the text
    font with the text. We then read the editor text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: 'When the text is read, we call `calculate` to calculate the rectangles enclosing
    the characters of the text. We then set the caret and return `true`, since the
    reading was successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the `Ok` field of the input stream to decide if the reading was successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: 'If we could not open the file for reading, we `return false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: 'The `isCopyEnabled` method is called before the Edit menu becomes visible.
    It is also called by the framework to decide whether the copy toolbar icon shall
    be enabled. It returns true (and the item becomes enabled) if the application
    holds mark mode, which means that the user has marked a part of the text, which
    can be copied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onCopy` method is called when the user selects the Copy item. We copy
    the marked text into `m_EditorText`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: 'The `isPasteEnabled` method is also called before the Edit menu becomes visible.
    It returns `true` (and the item becomes visible) if the copy text is not empty.
    That is, if there is a block of text that has been copied and is ready to be pasted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onPaste` method is called when the user selects the Paste menu item. In
    mark mode, we call `onDelete`, which causes the marked text to be deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: 'We then insert the copied text into the editor text. We also update `m_editIndex`,
    since the edit index after the text has been copied shall be the position after
    the inserted text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we calculate the rectangles enclosing the characters of the text,
    set the caret to the new index, set the modified flag since the text has been
    altered, and call `update` to force an eventual call to `paintEvent` in order
    to display the new text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: The `onDelete` method is called when the user selects the Delete menu item or
    the Delete toolbar icon. The effect is similar to the event when the user presses
    the *Delete* key. Therefore, we prepare a keypress event with the *Delete* key,
    which we use as a parameter in the call to `keyPressEvent`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that there is no `isDeleteEnabled` method because the user can always
    use the Delete item. In edit mode, the next character is deleted. In mark mode,
    the marked text is deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '`isCopyEnabled` is called before the Format menu becomes visible. It returns
    `true` in edit mode, since it would be illogical to change the font on all characters
    when a subset of them is marked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onFont` method is called when the user selects the `Font` menu item. We
    let the user select the new font with the Qt `QFontDialog` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: 'If the user closes the dialog by pressing the Ok button, we set the font of
    the editor (`m_textFont`) field and the modified flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: 'We calculate the newly enclosed rectangles by calling `calculate`, set the
    caret, and force an eventual call to `paintEvent` by calling `update`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: 'The `isLeftChecked`, `isCenterChecked`, and `isRightChecked` methods are called
    before the alignment submenu becomes visible. They return `true` to the current
    alignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: The `onLeft`, `onCenter`, and `onRight` methods are called when the user selects
    the `Left`, `Center`, and `Right` menu item. They set the alignment and the modified
    flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'They also calculate the new enclosing rectangles, set the caret, and force
    an eventual call to `paintEvent` by calling `update`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mousePressEvent` method is called when the user presses one of the mouse
    buttons. We call `mouseToIndex` to find the character index the user clicked on.
    For the time being, both the first and last mark index is set to the mouse index.
    The last index may later be changed by a call to `mouseMoveEvent` in the following
    snippet. Finally, the mode is set to mark, and the caret is hidden:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mouseMoveEvent` method is called when the user moves the mouse. We set
    the last mark index to the mouse index and force an eventual call to `paintEvent`
    by calling `update`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mouseReleaseEvent` method is called when the user releases the mouse button.
    If the user has moved the mouse to the original start position of the mouse movement,
    there is nothing to mark and we set the application in edit mode. In that case,
    we set the edit index to the first mark index, and set and show the caret (since
    it shall be visible in edit mode). Finally, we force an eventual call to `paintEvent`
    by calling `update`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '`keyPressEvent` is called when the user presses a key on the keyboard. Depending
    on the application mode (edit or mark), we call `keyEditPressEvent` or the following `keyMarkPressEvent` to
    further process the key event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '`keyEditPressEvent` handles the key press in edit mode. First, we check if
    the key is an arrow key, page up or down, *Delete*, *Backspace*, or return key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of the left-arrow key, we move the edit index one step backward,
    unless it is already at the beginning of the text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of the right-arrow key, we mode the edit index one step forward,
    unless it is already at the end of the text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of the up-arrow key, we calculate the appropriate `x` and `y` position
    for the character on the previous line, unless it is already on top of the text.
    We then call `simulateMouseClick`, which has the same effect as if the user has
    clicked on the character above the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: In the same way, in the case of the down-arrow key, we move the edit index one
    line downwards unless it is already at the bottom of the text.
  prefs: []
  type: TYPE_NORMAL
- en: 'We calculate the appropriate `x` and `y` position for the character on the
    line below and call `simulateMouseClick`, which has the same effect as if the
    user has clicked at the point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of the *Delete* key, we remove the current key, unless we are at
    the end of the text. That is, if we are one step beyond the last character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of the backspace key, we move the edit index one step backward,
    unless it already is at the beginning of the text, and call `onDelete`. In this
    way, we remove the previous character and move the edit index one step backward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of the return key, we simply insert the new line character to the
    text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: 'If the key is not a special key, we check whether it is a regular character
    by calling `text` on the key event pointer. If the text is not empty, add its
    first character to the text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we calculate the enclosing rectangles, set the caret, and force an
    eventual call to `paintEvent` by calling `update`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '`keyMarkPressEvent` is called when the user presses a key in mark mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: 'In case of the left-arrow key, we set the application to edit mode and the
    edit index to the minimum of the first and last marked index. However, if the
    minimum index is located at the beginning of the text, we do nothing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, in the case of the right-arrow key, we set the application
    to edit mode and the edit index to the maximum of the first and last marked index.
    However, if the maximum index is located at the end of the text, we do nothing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: 'In case of the up and down arrows, we simulate a mouse click one line above
    or below the current line, just as in the previous edit case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: 'In the mark mode, the delete and backspace keys perform the same task—they
    delete the marked text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: 'We remove the marked text from the edit text, set the modified flag, set the
    application to edit mode, set the edit index to the minimum of the first and last
    marked index, and show the caret:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: 'The return key case is similar to the previous edit mode case, with the difference
    that we first delete the marked text. We then add a new line to the editor text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: 'If the key is not a special key, we check if it is a regular key by calling
    `text` on the key event pointer. If the text is not empty, the user has printed
    a regular key, and we insert the first character in the editor text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we calculate the new rectangles enclosing the characters, set the
    caret, and force an eventual call to `paintEvent` by calling `update`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: 'The `simulateMouseClick` method is called when the user moves the caret up
    or down. It simulates a mouse click by calling `mousePressEvent` and `mouseReleaseEvent`,
    with suitably prepared event objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: 'The `setCaret` method sets the caret to the appropriate size and position in
    edit mode. Firstly, we use `m_editIndex` to find the rectangle of the correct
    character. We then create a new rectangle that is of only one-pixel width, in
    order for the caret to appear as a thin vertical line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mouseToIndex` method takes a mouse point and returns the index of the
    character at that point. Unlike the version of [Chapter 5](411aae8c-9215-4315-8a2e-882bf028834c.xhtml),
    *Qt Graphical Applications*, we need to take into consideration that the text
    may be center or right-aligned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: 'If the mouse point is below the text of the editor, the index of the last character
    is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, we start by finding the line of the mouse point, and obtain the
    indexes of the first and last character on the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: 'If the mouse point is located to the left of the first character on the line
    (which it may be if the text is center or right-aligned), we return the index
    of the first character of the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: 'If the mouse point, on the other hand, is located to the right of the line,
    we return the index of the character next to the last character of the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, we iterate through the character on the line and, for each character,
    we check whether the mouse point is located inside the character''s enclosing
    rectangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: 'If the mouse point is located inside the rectangle, we check if it is closest
    to the left or right border of the rectangle. If it is closest to the left border,
    we return the index of the character. If it is closest to the right border, we
    instead return the index of the next character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: 'We are not supposed to reach this point. The `assert` macro is added for debugging
    purposes only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: 'The `resizeEvent` method is called when the user resizes the window. We calculate
    the rectangles enclosing the characters, since the width of the window may have
    changed, which may cause the lines to hold fewer or more characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: 'The `calculate` method divides the text into lines, and calculates the rectangles
    enclosing every character of the text. The indexes of the first and last character
    of each line are stored in `m_lineList`, and the enclosing rectangles are stored
    in `m_rectList`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the Qt `QFontMetrics` class to obtain the height of a character of the
    editor font. The height is stored in `m_fontHeight`. The `width` method gives
    the width of the window content, in pixels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by iterating through the editor text in order to divide the text into
    lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: 'When we encounter a new line, we add the first and last index of the current
    line to `m_lineList`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, we call the `width` method of the Qt `QMetrics` object to obtain
    the width of the character, in pixels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: If the character makes the width of the line exceed the width of the window
    content, we add the first and last index to `m_lineList` and start a new line.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we have two different cases to consider. If the current character
    is the first character of the line, we have the (rather unlikely) situation that
    the width of that character exceeds the width of the window content. In that case,
    we add the index of that character as both the first and last index to `m_lineList`.
    The first index of the next line is the character next to that character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: 'If the current character is not the first character of the line, we add the
    indexes of the first character and the character preceding the current character
    to `m_lineList`. The index of the next line becomes the index of the current character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: 'If the character does not make the width of the line exceed the width of the
    window content, we simply add the width of the character to the width of the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to add the last line to `m_lineList`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: 'When we have divided the text into lines, we continue to calculate the enclosing
    rectangles of the individual characters. We start by setting `top` to zero, since
    it holds the top position of the line. It will be increased by the line height
    for each line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: 'Depending on the alignment of the text, we need to decide where the line starts.
    In the case of left alignment, we set the left position of the line to zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: 'In case of center alignment, we set the left position to half of the difference
    between the width of the window content and the line. In this way, the line will
    appear at the center of the window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: 'In case of right alignment, we set the left position to the difference between
    the width of the window content and the line. In this way, the line will appear
    to the right in the window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, when we have decided the starting left position of the line and the
    width of each individual character of the text, we iterate through the line and
    calculate the enclosing rectangle for each character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: 'For the very last line of the text, we add a rectangle holding the position
    beyond the last character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: 'The top field is increased by the height of the line for each new line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: 'The `paintEvent` method is called by the framework every time the window needs
    to be repainted, or when we force a repainting by calling `update`. The framework
    clears the content of the window before the call to `paintEvent`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create a `QPinter` object that we then use to write on. We set some
    rendering and the font of the text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: 'We calculate the minimum and maximum index of the marked text (even though
    we do not yet know if the application holds mark mode):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: 'We iterate through the text of the editor. We write every character except
    a new line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: 'If the character is marked, we write it with white text on a black background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: 'If the character is not marked, we write it with black text on a white background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: 'When the colors of the text and background have been set, we look up the rectangle
    enclosing the character and write the character itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we also paint the caret:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: The main function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `main` function is similar to the main function of the previous applications:
    it creates an application, shows the drawing window, and starts the execution
    of the application.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Main.cpp:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4191c0b5-fcd6-4a9e-a3e4-540323edcd89.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have developed more advanced versions of the analog clock,
    the drawing program, and the editor. The clock shows the current hour, minute,
    and second. The drawing program, allows the user to draw lines, rectangles, and
    ellipses. The editor allows the user to input and edit text. The clock face has
    digits instead of lines. In the drawing program we can mark, modify, and cut and
    paste figures, and in the editor, we can change font and alignment and mark a
    text block.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 7](1ce9af28-ea17-439f-945d-2353f6097157.xhtml), *The Games*, we
    will start developing the games Othello and Nought and Crosses.
  prefs: []
  type: TYPE_NORMAL
