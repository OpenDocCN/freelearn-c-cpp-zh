- en: Enhancing the Qt Graphical Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提升Qt图形应用程序
- en: 'In [Chapter 5](411aae8c-9215-4315-8a2e-882bf028834c.xhtml), *Qt Graphical Applications*,
    we developed graphical Qt applications involving an analog clock, a drawing program,
    and an editor. In this chapter, we will continue to work on the three graphical
    applications of  [Chapter 5](https://cdp.packtpub.com/c___by_example/wp-admin/post.php?post=72&action=edit#post_67),
    *Qt Graphical Applications*. However, we will make the following improvements:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](411aae8c-9215-4315-8a2e-882bf028834c.xhtml)，*Qt图形应用程序*中，我们开发了包含模拟时钟、绘图程序和编辑器的图形Qt应用程序。在本章中，我们将继续对第5章中提到的三个图形应用程序进行工作，即[第5章](https://cdp.packtpub.com/c___by_example/wp-admin/post.php?post=72&action=edit#post_67)，*Qt图形应用程序*。然而，我们将进行以下改进：
- en: '**Clock**: We will add digits to the clock dial'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时钟**: 我们将向时钟表盘添加数字'
- en: '**The drawing program**: We will add the ability to move and modify figures,
    to cut and paste them, and to mark one or several figures'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绘图程序**: 我们将添加移动和修改图形、剪切和粘贴它们以及标记一个或多个图形的能力'
- en: '**The editor**: We will add the ability to change font and alignment as well
    as to mark a text block'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编辑器**: 我们将添加更改字体和对齐方式以及标记文本块的能力'
- en: 'In this chapter, we will continue to work with the Qt libraries:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续使用Qt库：
- en: Windows and widgets
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 窗口和小部件
- en: Menus and toolbars
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 菜单和工具栏
- en: Mouse and keyboard events
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鼠标和键盘事件
- en: Improving the clock
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进时钟
- en: In this chapter, we will replace the version of clock dial markings with digits.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将替换时钟表盘标记的版本，使用数字。
- en: The Clock class
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Clock`类'
- en: The `Clock` class definition is similar to the one in [Chapter 5](https://cdp.packtpub.com/c___by_example/wp-admin/post.php?post=72&action=edit#post_67), *Qt
    Graphical Applications*. The timer updates the window 10 times each second. The
    constructor initializes the clock and `paintEvent` is called every time the window
    needs to be repainted.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`Clock`类的定义与[第5章](https://cdp.packtpub.com/c___by_example/wp-admin/post.php?post=72&action=edit#post_67)，*Qt图形应用程序*中的定义类似。计时器每秒更新窗口10次。构造函数初始化时钟，每当窗口需要重绘时，都会调用`paintEvent`。'
- en: '**Clock.h:**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**Clock.h**: '
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Clock.cpp:**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**Clock.cpp**: '
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Similar to [Chapter 5](https://cdp.packtpub.com/c___by_example/wp-admin/post.php?post=72&action=edit#post_67), *Qt
    Graphical Applications*, the constructor sets the header of the window to `Clock
    Advanced`, the window size to *1000* x *500* pixels, initializes the timer to
    send a timeout message every `100` milliseconds, and connect the `timeout` message
    to the `update` method, which forces the window to be repainted for each timeout:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 与[第5章](https://cdp.packtpub.com/c___by_example/wp-admin/post.php?post=72&action=edit#post_67)，*Qt图形应用程序*类似，构造函数将窗口标题设置为`Clock
    Advanced`，窗口大小设置为*1000* x *500*像素，初始化计时器以每`100`毫秒发送一个超时消息，并将`timeout`消息连接到`update`方法，这将强制窗口在每次超时时重绘：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `paintEvent` method is called every time the window needs to be repainted.
    We will start by calculating the side of the clock and obtaining the current time:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 每当窗口需要重绘时，都会调用`paintEvent`方法。我们首先计算时钟的边长并获取当前时间：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We then create and initialize a `QPainter` object. We call `translate` and
    `scale` to match the physical size (pixels) to the logical size of *200 x 200*
    units:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后创建并初始化一个`QPainter`对象。我们调用`translate`和`scale`来匹配物理大小（像素）与逻辑大小（*200 x 200*单位）：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As we write digits to the clock in this version of the chapter, we add the
    font `Times New Roman`, `12` points, to the painter:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的这个版本中，我们向画家添加了`Times New Roman`字体，`12`点，以写入时钟的数字：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We write the digits of the clock, `1` to `12`, as shown in the following code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将时钟的数字`1`到`12`写入，如下所示：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'A whole leap is 360° and the angle between two consecutive digits is 30°, since
    360 divided by 12 is 30:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一个完整的跳跃是360°，两个连续数字之间的角度是30°，因为360除以12等于30：
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `x` and `y` coordinates of the digits are calculated by the sine and cosine
    functions. However, first, we need to transform the degrees to radians since sine
    and cosine accept radians only. This is shown in the following code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 数字`x`和`y`坐标通过正弦和余弦函数计算得出。然而，首先我们需要将度数转换为弧度，因为正弦和余弦函数只接受弧度。以下代码展示了这一过程：
- en: '[PRE8]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `drawText` methods write the digit, as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawText`方法将数字写入，如下所示：'
- en: '[PRE9]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When the digits have been written, we draw the `hour`, `minute`, and `second`
    hands in the same way as in [Chapter 5](https://cdp.packtpub.com/c___by_example/wp-admin/post.php?post=72&action=edit#post_67), *Qt
    Graphical Applications*:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当数字被写入后，我们将以与[第5章](https://cdp.packtpub.com/c___by_example/wp-admin/post.php?post=72&action=edit#post_67)，*Qt图形应用程序*中相同的方式绘制`hour`、`minute`和`second`指针：
- en: '[PRE10]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The main function
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主要功能
- en: The `main` function is similar to the one in [Chapter 5](https://cdp.packtpub.com/c___by_example/wp-admin/post.php?post=72&action=edit#post_67), *Qt
    Graphical Applications*. It creates an application object, initializes the clock,
    and executes the application.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 函数与 [第 5 章](https://cdp.packtpub.com/c___by_example/wp-admin/post.php?post=72&action=edit#post_67)
    中的类似，*Qt 图形应用程序*。它创建一个应用程序对象，初始化时钟，并执行应用程序。'
- en: '**Main.cpp:**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**Main.cpp:**'
- en: '[PRE11]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**Output**:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出**:'
- en: '![](img/4fc9d538-a689-43c2-9e55-d697cc18342c.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4fc9d538-a689-43c2-9e55-d697cc18342c.png)'
- en: Improving the drawing program
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高绘图程序
- en: The drawing program of this chapter is a more advanced version of the drawing
    program of [Chapter 5](https://cdp.packtpub.com/c___by_example/wp-admin/post.php?post=72&action=edit#post_67), *Qt
    Graphical Applications.* In this version, it is possible to modify a figure, to
    enclose one or more figures and then change their colors, and to cut and paste
    figures.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的绘图程序是 [第 5 章](https://cdp.packtpub.com/c___by_example/wp-admin/post.php?post=72&action=edit#post_67)
    中 *Qt 图形应用程序* 绘图程序的更高级版本。在这个版本中，可以修改图形，包围一个或多个图形然后改变它们的颜色，以及剪切和粘贴图形。
- en: The Figure class
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图形类
- en: The `Figure` class is rather similar to the one in [Chapter 5](https://cdp.packtpub.com/c___by_example/wp-admin/post.php?post=72&action=edit#post_67), *Qt
    Graphical Applications*. However, `isInside`, `doubleClick`, `modify`, and `marked`
    have been added.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`Figure` 类与 [第 5 章](https://cdp.packtpub.com/c___by_example/wp-admin/post.php?post=72&action=edit#post_67)
    中的类似，*Qt 图形应用程序*。然而，增加了 `isInside`、`doubleClick`、`modify` 和 `marked`。'
- en: '**Figure.h:**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**Figure.h:**'
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this version, the pure virtual `clone` method has been added. That is due
    to the cut and paste. When pasting a figure we want to create a copy of it, without
    actually knowing which class the object belongs to. We could not do that with
    the copy constructor only. This is actually the main point of this section: how
    to use pure virtual methods and how to take advantage of dynamic binding. We need
    `clone`, which calls the copy constructor of its class to return a pointer to
    the new object:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本中，增加了纯虚 `clone` 方法。这是由于剪切和粘贴。当粘贴图形时，我们希望创建它的一个副本，而不必实际知道该对象属于哪个类。我们只能通过复制构造函数来做这件事。这实际上是本节的主要点：如何使用纯虚方法和如何利用动态绑定。我们需要
    `clone`，它调用其类的复制构造函数以返回新对象的指针：
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In this version of the drawing program, `onClick` sets fields to indicate whether
    the figure shall be modified or moved. If the user grabs one of the marked points
    of the figure (which varies between different kinds of figures), the figure shall
    be modified. Otherwise, it shall be moved. The `modify` method is called when
    the user grabs one of the corners of the figure. In that case, the figure shall
    be modified rather than moved:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本的绘图程序中，`onClick` 设置字段以指示图形是否应该被修改或移动。如果用户抓住图形的标记点之一（不同类型的图形之间有所不同），则修改图形。否则，应移动图形。当用户抓住图形的一个角时调用
    `modify` 方法。在这种情况下，应修改图形而不是移动它：
- en: '[PRE14]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `isInside` method returns `true` if the figure is completely enclosed in
    the area. It is called when the user encloses figures with the mouse:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`isInside` 方法返回 `true` 如果图形完全包含在区域内。当用户用鼠标包围图形时调用：'
- en: '[PRE15]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `doubleClick` method is called when the user double-clicks at the figure,
    each figure performs some suitable action:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在图形上双击时调用 `doubleClick` 方法，每个图形执行一些合适的操作：
- en: '[PRE16]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `marked` methods return and set the `m_marked` field. When a figure is
    marked, it is annotated with small squares:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`marked` 方法返回和设置 `m_marked` 字段。当一个图形被标记时，它会被小方块注释：'
- en: '[PRE17]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**Figure.cpp:**'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**Figure.cpp:**'
- en: '[PRE18]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `write` and `read` methods write and read the color of the figure and whether
    it is filled. However, they do not write or read the marked status. A figure is
    always unmarked when written or read:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`write` 和 `read` 方法写入和读取图形的颜色以及它是否被填充。然而，它们不写入或读取标记状态。图形在写入或读取时总是未标记的：'
- en: '[PRE19]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The Line class
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线类
- en: The `Line` class is a subclass of `Figure`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`Line` 类是 `Figure` 的子类。'
- en: '**Line.h:**'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**Line.h:**'
- en: '[PRE20]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As mentioned in the preceding `Figure` section, `isClick` decided whether the
    line shall be modified or moved. If the user grabs one of its endpoints, only
    that endpoint shall be moved. If the user grabs the line between the endpoints,
    the line shall be moved. That is, both the endpoints of the line shall be moved:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如前文 `Figure` 部分所述，`isClick` 决定线是否应该被修改或移动。如果用户抓住其端点之一，则仅移动该端点。如果用户抓住端点之间的线，则移动整条线。也就是说，线的两个端点都将移动：
- en: '[PRE21]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `isInside` method checks whether the line is completely enclosed by the
    area:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`isInside` 方法检查线是否完全被区域包围：'
- en: '[PRE22]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `doubleClick` method does nothing in the `Line` class. However, we still
    need to define it, since it is pure virtual in `Figure`. If we had not defined
    it, `Line` would have been abstract:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Line` 类中，`doubleClick` 方法不执行任何操作。然而，我们仍然需要定义它，因为它是 `Figure` 中的纯虚函数。如果我们没有定义它，`Line`
    将会是抽象的：
- en: '[PRE23]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `modify` method modifies the line in accordance with the settings of the
    preceding `isClick`. If the user grabs one of the endpoints, that endpoint is
    moved. Otherwise, the whole line (both the endpoints) is moved:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`modify` 方法根据前一个 `isClick` 的设置修改线。如果用户抓取了一个端点，则该端点被移动。否则，整个线（包括两个端点）被移动：'
- en: '[PRE24]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `area` method returns a slightly larger area if the line is marked, in
    order to include the marking squares:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果线被标记，`area` 方法返回一个稍微大一点的区域，以便包括标记的正方形：
- en: '[PRE25]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `m_lineMode` field keeps track of the movement or modification of the line.
    When the line is created, `m_lineMode` is set to `LastPoint`. When the user grabs
    the first or last endpoint of the line, `m_lineMode` is set to `FirstPoint` or
    `LastPoint`. When the user grabs the line between the endpoints, `m_lineMode`
    is set to `MoveLine`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_lineMode` 字段跟踪线的移动或修改。当线被创建时，`m_lineMode` 被设置为 `LastPoint`。当用户抓取线的第一个或最后一个端点时，`m_lineMode`
    被设置为 `FirstPoint` 或 `LastPoint`。当用户抓取端点之间的线时，`m_lineMode` 被设置为 `MoveLine`：'
- en: '[PRE26]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `isPointInLine` method decides whether the user has clicked on the line,
    with some tolerance:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`isPointInLine` 方法决定用户是否点击了线，并有一定的容差：'
- en: '[PRE27]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '**Line.cpp:**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**Line.cpp:**'
- en: '[PRE28]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When a line becomes created, the line mode is set to the last point. That means
    that the last point of the line will be changed when the user moves the mouse:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当一条线被创建时，线模式被设置为最后一个点。这意味着当用户移动鼠标时，线的最后一个点将会改变：
- en: '[PRE29]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `clone` method is called when a line is being pasted. The copy constructor
    of `Figure` is called to set the color of the figure. Note that we call the `Figure`
    constructor with a `Line` object as a parameter, even though it takes a reference
    to a `Figure` object as a parameter. We are allowed to do this since `Line` is
    a subclass of `Figure` and the `Line` object will be transformed into a `Figure`
    object during the call. Moreover, the first and last endpoints are copied. Note
    that we do need to copy the value `m_lineMode` since its value is set when the
    user creates, modifies, or moves the line only:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当粘贴线时，会调用 `clone` 方法。调用 `Figure` 的拷贝构造函数来设置图形的颜色。请注意，我们使用 `Line` 对象作为参数调用 `Figure`
    构造函数，尽管它接受一个 `Figure` 对象的引用作为参数。我们允许这样做，因为 `Line` 是 `Figure` 的子类，并且在调用过程中 `Line`
    对象将被转换成 `Figure` 对象。此外，第一个和最后一个端点被复制。请注意，我们确实需要复制 `m_lineMode` 的值，因为它的值是在用户创建、修改或移动线时设置的：
- en: '[PRE30]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `clone` method uses the copy constructor to create a new object, which
    is then returned:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`clone` 方法使用拷贝构造函数来创建一个新的对象，然后返回：'
- en: '[PRE31]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `initializePoints` method is called shortly after the line is being created.
    The reason for this call is that we do not create a `Line` object directly. Instead,
    we create the line indirectly by calling `clone`. We then need to initialize the
    end-points by calling `initializePoints`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在线被创建后不久，会调用 `initializePoints` 方法。调用这个方法的原因是我们没有直接创建 `Line` 对象。相反，我们通过调用 `clone`
    间接创建线。然后我们需要通过调用 `initializePoints` 来初始化端点：
- en: '[PRE32]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `isClick` method is called when the user clicks with the mouse. First,
    we check whether they have clicked at the first endpoint. We use the `Tolerance`
    field to create a small square, with the first endpoint in its center. If the
    user clicks on the square, `m_lineMode` is set to `FirstPoint` and `true` is returned:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户用鼠标点击时，会调用 `isClick` 方法。首先，我们检查他们是否点击了第一个端点。我们使用 `Tolerance` 字段创建一个以第一个端点为中心的小正方形。如果用户点击了这个正方形，`m_lineMode`
    被设置为 `FirstPoint` 并返回 `true`：
- en: '[PRE33]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the same way, we create a small square with the last endpoint in its center.
    If the user clicks at the square, `m_lineMode` is set to `LastPoint` and `true`
    is returned:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，我们在最后一个端点的中心创建一个小正方形。如果用户点击这个正方形，`m_lineMode` 被设置为 `LastPoint` 并返回 `true`：
- en: '[PRE34]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If the user does not click on either of the endpoints, we check if they click
    on the line itself. If they do, `m_lineMode` is set to `ModeLine` and `true` is
    returned:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户没有点击任一端点，我们将检查他们是否点击了线本身。如果他们点击了，`m_lineMode` 被设置为 `ModeLine` 并返回 `true`：
- en: '[PRE35]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, if the user does not click on one of the endpoints or the line itself,
    they missed the line altogether and `false` is returned:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果用户没有点击线的一个端点或线本身，他们完全错过了线，并返回 `false`：
- en: '[PRE36]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `isInside` method returns `true` if the line is completely enclosed by
    the area. It is quite easy, we just check whether the two end-points are located
    inside the area:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`isInside` 方法如果线完全被区域包围则返回 `true`。这相当简单，我们只需检查两个端点是否位于区域内：'
- en: '[PRE37]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `isPointInLine` method is identical to `isClick` in the version of [Chapter
    5](411aae8c-9215-4315-8a2e-882bf028834c.xhtml), *Qt Graphical Application**s*:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`isPointInLine` 方法与 [第 5 章](411aae8c-9215-4315-8a2e-882bf028834c.xhtml) 的版本，*Qt
    图形应用程序* 中的 `isClick` 方法相同：'
- en: '[PRE38]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `modify` method moves the first or last endpoint, or both of them, depending
    on the settings of `m_lineMode` in the preceding `isClick` method:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`modify` 方法根据前面 `isClick` 方法中 `m_lineMode` 的设置移动第一个或最后一个端点，或两者都移动：'
- en: '[PRE39]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `move` method simply moves both the end-points of the line:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`move` 方法简单地移动线的两个端点：'
- en: '[PRE40]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `draw` method draws the line. The difference between this version and the
    version of [Chapter 5](411aae8c-9215-4315-8a2e-882bf028834c.xhtml), *Qt Graphical
    Applications*, is that it also draws the squares at the end-points of the line
    if it is marked:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw` 方法绘制线。与 [第 5 章](411aae8c-9215-4315-8a2e-882bf028834c.xhtml) 的版本，*Qt
    图形应用程序* 相比，它还绘制了如果被标记的线端点的正方形：'
- en: '[PRE41]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `area` method returns the area covering the line. If the line is marked,
    the area is slightly expanded in order to cover the squares marking the endpoints:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`area` 方法返回覆盖线的区域。如果线被标记，区域会略微扩展以覆盖标记端点的正方形：'
- en: '[PRE42]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Similar to the version of [Chapter 5](https://cdp.packtpub.com/c___by_example/wp-admin/post.php?post=72&action=edit#post_67), *Qt
    Graphical Applications*, `write` and `read` call their counterparts in `Figure`
    and then write and read the two endpoints of the line:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 与 [第 5 章](https://cdp.packtpub.com/c___by_example/wp-admin/post.php?post=72&action=edit#post_67)
    的版本类似，*Qt 图形应用程序*，`write` 和 `read` 调用 `Figure` 中的对应方法，然后写入和读取线的两个端点：
- en: '[PRE43]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The Rectangle class
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 矩形类
- en: '`RectangleX` is a subclass of `Figure`. It is an expanded version of the version
    of [Chapter 5](https://cdp.packtpub.com/c___by_example/wp-admin/post.php?post=72&action=edit#post_67), *Qt
    Graphical Applications*. The `isClick` method has been modified, `doubleClick`
    and `modify` have been added.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`RectangleX` 是 `Figure` 的子类。它是 [第 5 章](https://cdp.packtpub.com/c___by_example/wp-admin/post.php?post=72&action=edit#post_67)
    的扩展版本，*Qt 图形应用程序*。`isClick` 方法已被修改，增加了 `doubleClick` 和 `modify`：'
- en: '**Rectangle.h:**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**Rectangle.h**: '
- en: '[PRE44]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '**Rectangle.cpp:**'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**Rectangle.cpp**: '
- en: '[PRE45]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'When a rectangle is added by the user, its mode is `BottomRightPoint`. That
    means that the bottom-right corner of the rectangle will be moved when the user
    moves the mouse:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户添加矩形时，其模式是 `BottomRightPoint`。这意味着当用户移动鼠标时，矩形的右下角将被移动：
- en: '[PRE46]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The copy constructor copies the rectangle. More specifically, first it calls
    the copy constructor of the `Figure` class, then it copies the top-left and bottom-right
    corner. Note that it does not copy the `m_rectangleMode` field, since it is used
    when the user moves the mouse only:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 复制构造函数复制矩形。更具体地说，首先它调用 `Figure` 类的复制构造函数，然后复制左上角和右下角。请注意，它不会复制 `m_rectangleMode`
    字段，因为它仅在用户移动鼠标时使用：
- en: '[PRE47]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `clone` method creates and returns a pointer to a new object by calling
    the copy constructor:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`clone` 方法通过调用复制构造函数创建并返回一个指向新对象的指针：'
- en: '[PRE48]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `isClick` method is called when the user clicks with the mouse. Similar
    to the preceding bool `Line`, we start by checking whether they have clicked at
    any of the corners. If they have not, we check whether they have clicked on the
    rectangle border or inside the rectangle, depending on whether it is filled.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户用鼠标点击时调用 `isClick` 方法。与前面的布尔 `Line` 类似，我们首先检查他们是否点击了任何角落。如果没有，我们检查他们是否点击了矩形边框或矩形内部，这取决于它是否被填充：
- en: 'We start by defining a small square covering the top-left corner. If the user
    clicks on it, we set the `m_rectangleMode` field to `TopLeftPoint` and return
    `true`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个覆盖左上角的小正方形。如果用户点击它，我们将 `m_rectangleMode` 字段设置为 `TopLeftPoint` 并返回 `true`：
- en: '[PRE49]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We continue by defining a square covering the top-right corner. If the user
    clicks on it, we set `m_rectangleMode` to `TopRightPoint` and return `true`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续定义一个覆盖右上角的正方形。如果用户点击它，我们将 `m_rectangleMode` 设置为 `TopRightPoint` 并返回 `true`：
- en: '[PRE50]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'If the user clicks at the square covering the bottom-right corner, we set `m_rectangleMode`
    to `BottomRightPoint` and return `true`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户点击在覆盖右下角的正方形上，我们将 `m_rectangleMode` 设置为 `BottomRightPoint` 并返回 `true`：
- en: '[PRE51]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'If the user clicks at the square covering the bottom-left corner, we set `m_rectangleMode`
    to `BottomLeftPoint` and return `true`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户点击在覆盖左下角的正方形上，我们将 `m_rectangleMode` 设置为 `BottomLeftPoint` 并返回 `true`：
- en: '[PRE52]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'If the user does not click at any of the corners of the rectangle, we check
    the rectangle itself. If it is filled, we check whether the mouse pointer is located
    inside the rectangle itself. If it is, we set `m_rectangleMode` to `MoveRectangle`
    and return `true`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户没有点击在矩形的任何一个角落，我们检查矩形本身。如果它是填充的，我们检查鼠标指针是否位于矩形本身内部。如果是，我们将 `m_rectangleMode`
    设置为 `MoveRectangle` 并返回 `true`：
- en: '[PRE53]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If the rectangle is not filled, we define slightly larger and smaller rectangles.
    If the mouse click is located inside the larger rectangle, but not in the smaller
    one, we set `m_rectangleMode` to `MoveRectangle` and return `true`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果矩形没有被填充，我们定义稍微大一些和稍微小一些的矩形。如果鼠标点击位于较大的矩形内部，但不在较小的矩形内，我们将 `m_rectangleMode`
    设置为 `MoveRectangle` 并返回 `true`：
- en: '[PRE54]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Finally, if the user does not click at one of the corners or the rectangle
    itself, they missed the rectangle and we return `false`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果用户没有点击在任何一个角落或矩形本身，他们错过了矩形，我们返回 `false`：
- en: '[PRE55]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `isInside` method is quite simple. We simply check if the top-left and
    bottom-right corners are located inside the rectangle:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`isInside` 方法相当简单。我们只需检查左上角和右下角是否位于矩形内部：'
- en: '[PRE56]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `doubleClick` method is called when the user double-clicks with the mouse.
    If the call to `onClick` returns `true`, `doubleClick` is called. In the rectangle
    case, the filled status is changed—a filled rectangle becomes unfilled and an
    unfilled rectangle becomes filled:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户用鼠标双击时，会调用 `doubleClick` 方法。如果 `onClick` 的调用返回 `true`，则调用 `doubleClick`。在矩形的情况下，填充状态会改变——填充的矩形变为未填充，未填充的矩形变为填充：
- en: '[PRE57]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The first call to `filled` is a call to the version that returns a reference
    to the `m_filled` field, which allows us to change the returned value:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用 `filled` 是调用返回对 `m_filled` 字段引用的版本，这允许我们更改返回的值：
- en: '[PRE58]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The `modify` method modifies the rectangle in accordance with the `m_rectangleMode`
    field, which was set by the preceding `isClick`. If it is set to one of the four
    corners, we modify that corner. If not, we move the whole rectangle:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`modify` 方法根据前一个 `isClick` 中设置的 `m_rectangleMode` 字段来修改矩形。如果它设置为四个角落之一，我们修改那个角落。如果不是，我们移动整个矩形：'
- en: '[PRE59]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The `move` method is quite simple. It just changes the top-left and bottom-right
    corners:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`move` 方法相当简单。它只是改变左上角和右下角：'
- en: '[PRE60]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The `area` method returns the area covering the rectangle. If it is marked,
    we slightly expand the area in order for it to cover the marking squares:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`area` 方法返回覆盖矩形的面积。如果它被标记，我们稍微扩大面积，以便它覆盖标记的正方形：'
- en: '[PRE61]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The `draw` method draws the rectangle; with a full brush it is filled and with
    a hollow brush if it is unfilled:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw` 方法绘制矩形；使用全画笔时填充，使用空心画笔时未填充：'
- en: '[PRE62]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'If the rectangle is marked, the four squares covering the corners of the rectangle
    are also drawn:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果矩形被标记，覆盖矩形四个角落的四个正方形也会被绘制：
- en: '[PRE63]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The `write` and `read` methods first call their counterparts in `Figure` in
    order to write and read the color of the rectangle. Then it writes and reads the
    top-left and bottom-right corners:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`write` 和 `read` 方法首先调用 `Figure` 中的对应方法来写入和读取矩形的颜色。然后写入和读取左上角和右下角：'
- en: '[PRE64]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The Ellipse class
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ellipse 类
- en: '`EllipseX` is a direct sub class of `RectangleX` and an indirect subclass of
    `Figure` that draws a filled or unfilled ellipse:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`EllipseX` 是 `RectangleX` 的直接子类，也是 `Figure` 的间接子类，它绘制一个填充或未填充的椭圆：'
- en: '**EllipseX.h:**'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**EllipseX.h:** '
- en: '[PRE65]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Similar to the preceding rectangle case, `isClick` checks whether the user
    grabs the ellipse in one of its four corners, or if the ellipse itself shall be
    moved:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的矩形情况类似，`isClick` 检查用户是否在椭圆的四个角落之一抓取椭圆，或者椭圆本身是否应该移动：
- en: '[PRE66]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The `modify` method modifies the ellipse in accordance with the settings of
    following `m_ellipseMode` in preceding `isClick`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`modify` 方法根据前一个 `isClick` 中设置的 `m_ellipseMode` 的设置来修改椭圆：'
- en: '[PRE67]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'While the preceding rectangle could be grabbed by its four corners, the ellipse
    can be grabbed by its left, top, right, and bottom points. Therefore, we need
    to add the `CreateEllipse` enumeration value, which modifies the bottom-right
    corner of the area covering the ellipse:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的矩形可以通过其四个角抓取不同，椭圆可以通过其左、上、右和底部点抓取。因此，我们需要添加 `CreateEllipse` 枚举值，它修改覆盖椭圆的区域右下角：
- en: '[PRE68]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '**EllipseX.cpp:**'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**EllipseX.cpp:**'
- en: '[PRE69]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'In contrast to the preceding line and rectangle cases, we set the `m_ellipseMode`
    field to `CreateEllipse`, which is valid when the ellipse is being created only:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的行和矩形情况相比，我们将 `m_ellipseMode` 字段设置为 `CreateEllipse`，这在创建椭圆时是有效的：
- en: '[PRE70]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The copy constructor does not need to set the `m_topLeft` and `m_bottomRight`
    fields, since it is taken care of by the copy constructor of `RectangleX`, which
    is being called by the copy constructor of `EllipseX`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 复制构造函数不需要设置 `m_topLeft` 和 `m_bottomRight` 字段，因为这是由 `RectangleX` 的复制构造函数处理的，而
    `RectangleX` 的复制构造函数是由 `EllipseX` 的复制构造函数调用的：
- en: '[PRE71]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Similar to the preceding rectangle case, `isClick` checks whether the user
    grabs the ellipse by one of its four points. However, in the ellipse case, we
    do not check the corners of the rectangle. Instead, we check the left, top, right,
    and bottom position of the ellipse. We create a small square for each of those
    positions and check whether the user clicks on them. If they do, we set the `m_ellipseMode`
    field to an appropriate value and return `true`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的矩形情况类似，`isClick` 检查用户是否通过椭圆的四个点之一抓取椭圆。然而，在椭圆的情况下，我们不检查矩形的角。相反，我们检查椭圆的左、上、右和底部位置。我们为这些位置中的每一个创建一个小正方形，并检查用户是否点击了它们。如果点击了，我们将
    `m_ellipseMode` 字段设置为适当的值并返回 `true`：
- en: '[PRE72]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'If the user does not click on any of the four positions, we check whether they
    click on the ellipse itself. If it is filled, we use the Qt `QRegion` class to
    create an elliptic region and we check whether the mouse point is located inside
    the region:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户没有点击四个位置中的任何一个，我们检查他们是否点击了椭圆本身。如果它是填充的，我们使用 Qt 的 `QRegion` 类创建一个椭圆区域，并检查鼠标点是否位于该区域内：
- en: '[PRE73]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'If the ellipse is unfilled, we create slightly larger and smaller elliptic
    regions and then check whether the mouse point is located inside the larger region,
    and also inside the smaller one:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果椭圆未填充，我们创建稍大和稍小的椭圆区域，然后检查鼠标点是否位于较大的区域内，同时也位于较小的区域内：
- en: '[PRE74]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Finally, if the user does not click at any of the grabbing positions or the
    ellipse itself, we return `false`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果用户没有在任何抓取位置或椭圆本身上点击，我们返回 `false`：
- en: '[PRE75]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The `modify` method modifies the ellipse in accordance with the settings of
    `m_ellipseMode` in `onClick`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`modify` 方法根据 `onClick` 中 `m_ellipseMode` 的设置修改椭圆：'
- en: '[PRE76]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The `draw` method draws the ellipse with a solid brush if it is filled, and
    with a hollow brush if it is unfilled:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw` 方法根据椭圆是否填充，使用实心画笔绘制椭圆，如果未填充则使用空心画笔：'
- en: '[PRE77]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'If the ellipse is marked, the four squares covering the top, left, right, and
    bottom points of the ellipse are also drawn:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果椭圆被标记，则绘制覆盖椭圆顶部、左侧、右侧和底部点的四个正方形：
- en: '[PRE78]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The DrawingWindow class
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`DrawingWindow` 类'
- en: The `DrawingWindow` class is similar to the version of the previous chapter.
    It overrides the `closeEvent` method.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`DrawingWindow` 类与上一章的版本类似。它重写了 `closeEvent` 方法。'
- en: '**DrawingWindow.h:**'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**DrawingWindow.h:**'
- en: '[PRE79]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '**DrawingWindow.cpp:**'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**DrawingWindow.cpp:**'
- en: '[PRE80]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The constructor initializes the window size to *1000* x *500* pixels, puts
    the drawing widget in the middle of the window, adds the standard File and Edit
    menus, and adds the application-specific Format and Figure menus:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数将窗口大小初始化为 *1000* x *500* 像素，将绘图小部件放置在窗口中间，添加标准文件和编辑菜单，并添加应用程序特定的格式和图形菜单：
- en: '[PRE81]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The Format menu holds the `Color`, `Fill`, and `Modify` items as well as the
    Figure submenu:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 格式菜单包含 `Color`、`Fill` 和 `Modify` 项以及图形子菜单：
- en: '[PRE82]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The user selects the Modify item when they want to mark or modify existing
    figures instead of adding new figures:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户想要标记或修改现有图形而不是添加新图形时，他们选择修改项：
- en: '[PRE83]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The Figure menu is a submenu holding the `Line`, `Rectangle`, and `Ellipse`
    items. It becomes a submenu when we add it to the Format menu:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图形菜单是一个包含 `Line`、`Rectangle` 和 `Ellipse` 项的子菜单。当我们将其添加到格式菜单时，它成为一个子菜单：
- en: '[PRE84]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The DrawingWidget class
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`DrawingWidget` 类'
- en: The `DrawingWidget` class is the main class of the application. It catches the
    mouse and paint events. It also catches the menu item selections of the File,
    Edit, and Figure menus.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`DrawingWidget` 类是应用程序的主要类。它捕获鼠标和绘图事件。它还捕获文件、编辑和图形菜单项的选择。'
- en: '**DrawingWidget.h:**'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**DrawingWidget.h:**'
- en: '[PRE85]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Unlike the version of [Chapter 5](411aae8c-9215-4315-8a2e-882bf028834c.xhtml), *Qt
    Graphical Applications*, this version overrides the cut and copy event methods:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 与 [第 5 章](411aae8c-9215-4315-8a2e-882bf028834c.xhtml) 的版本（*Qt 图形应用程序*）不同，这个版本覆盖了剪切和复制事件方法：
- en: '[PRE86]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The `m_applicationMode` field holds the values `Idle`, `ModifySingle`, or `ModifyRectangle`.
    The `Idle` mode is active when the user is not pressing the mouse. The `ModifySingle`
    mode becomes active when the user grabs a figure and modifies or moves it (depending
    on which part of the figure the user grabs). Finally, the `ModifyRectangle` mode
    becomes active when the user clicks at the window without hitting a figure. In
    that case, a rectangle is shown, and every figure enclosed by the rectangle becomes
    marked when the user releases the mouse button. The user can delete or cut and
    paste the marked figure, or change their color or the filled status. When the
    user releases the mouse button, the `Application` mode again becomes `Idle`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_applicationMode` 字段包含 `Idle`、`ModifySingle` 或 `ModifyRectangle` 的值。当用户没有按鼠标时，`Idle`
    模式是活动的。当用户抓住一个图形并修改或移动它（取决于用户抓住图形的哪个部分）时，`ModifySingle` 模式变为活动状态。最后，当用户在窗口中点击而没有点击图形时，`ModifyRectangle`
    模式变为活动状态。在这种情况下，显示一个矩形，当用户释放鼠标按钮时，矩形内的每个图形都会被标记。用户可以删除或剪切粘贴标记的图形，或更改其颜色或填充状态。当用户释放鼠标按钮时，`Application`
    模式再次变为 `Idle`：'
- en: '[PRE87]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The `m_actionMode` field holds the values `Modify` or `Add`. In `Modify` mode,
    when the user clicks with the mouse, `m_applicationMode` is set to `ModifySingle`
    or `ModifyRectangle`, depending on whether they hit a figure. In `Add` mode, a
    new figure is added, regardless of whether the user hits a figure. The kind of
    figure to be added is set by `m_addFigureId`, which holds the values `LineId`,
    `RectangleId`, or `EllipseId`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_actionMode` 字段包含 `Modify` 或 `Add` 的值。在 `Modify` 模式下，当用户用鼠标点击时，`m_applicationMode`
    被设置为 `ModifySingle` 或 `ModifyRectangle`，具体取决于是否点击了图形。在 `Add` 模式下，无论用户是否点击了图形，都会添加一个新的图形。要添加的图形类型由
    `m_addFigureId` 设置，它包含 `LineId`、`RectangleId` 或 `EllipseId` 的值：'
- en: '[PRE88]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The color of the next figure to be added to the drawing is initialized to black,
    and the filled status is initialized to false (unfilled). In both cases, it can
    later be changed by the user:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加到绘图中的下一个图形的颜色初始化为黑色，填充状态初始化为 false（未填充）。在两种情况下，用户都可以稍后更改它们：
- en: '[PRE89]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'We need to save the latest mouse point in order to calculate distances between
    mouse movements:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要保存最新的鼠标点，以便计算鼠标移动之间的距离：
- en: '[PRE90]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Pointers to the figures of the drawing are stored in `m_figurePtrList`. The
    top-most figure is stored at the end of the list. When the user cuts or copies
    one or several figures, the figures are copied and the pointers to the copies
    are stored in `m_copyPtrList`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 绘图图形的指针存储在 `m_figurePtrList` 中。最顶层的图形存储在列表的末尾。当用户剪切或复制一个或多个图形时，图形被复制，复制的指针存储在
    `m_copyPtrList` 中：
- en: '[PRE91]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'When `m_actionMode` holds `Modify` and the user presses the mouse button without
    hitting a figure, a rectangle becomes visible in the window. That rectangle is
    stored in `m_insideRectangle`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `m_actionMode` 包含 `Modify` 且用户按下鼠标按钮而没有点击图形时，窗口中会出现一个矩形。这个矩形存储在 `m_insideRectangle`
    中：
- en: '[PRE92]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '**DrawingWidget.cpp:**'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**DrawingWidget.cpp:**'
- en: '[PRE93]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The constructor calls the constructor of the base class `DocumentWidget` to
    set the header of the window to `Drawing Advanced`, and to set the file suffix
    of the drawing files to `drw`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数调用基类 `DocumentWidget` 的构造函数，将窗口标题设置为 `Drawing Advanced`，并将绘图文件的文件后缀设置为 `drw`：
- en: '[PRE94]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The destructor does nothing, it has been included for the sake of completeness
    only:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数不执行任何操作，仅为了完整性而包含：
- en: '[PRE95]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The `setApplicationMode` method sets the application mode and calls `onMenuShow`
    in the main window for the toolbar icons to be correctly enabled:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`setApplicationMode` 方法设置应用程序模式，并在主窗口中调用 `onMenuShow` 以确保工具栏图标正确启用：'
- en: '[PRE96]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The `newDocument` method is called when the user selects the `New` menu item.
    We start by deallocating every figure in the figure and copy pointer lists, and
    they clear the list themselves:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择 `New` 菜单项时调用 `newDocument` 方法。我们首先在图形和复制指针列表中释放每个图形，然后它们自己清除列表：
- en: '[PRE97]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The current color and filled status are set to black and false (unfilled).
    The action mode is set to `Add` and the add figure identity is set to `LineId`,
    which means that when the user presses the mouse button a black line is added
    to the drawing:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当前颜色和填充状态设置为黑色和 false（未填充）。操作模式设置为 `Add`，添加图形标识符设置为 `LineId`，这意味着当用户按下鼠标按钮时，会在绘图上添加一条黑色线条：
- en: '[PRE98]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The `writeFile` method is called when the user selects the `Save` or `Save
    As` menu items:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择`保存`或`另存为`菜单项时，会调用`writeFile`方法：
- en: '[PRE99]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'If the file was successfully opened, we start by writing the next color and
    filled status:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件成功打开，我们首先写入下一个颜色和填充状态：
- en: '[PRE100]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'We then write the number of figures in the drawing, and then we write the figures
    themselves:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们写入绘图中的图形数量，然后写入图形本身：
- en: '[PRE101]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'For each figure, first we write its identity value, we then write the figure
    itself by calling `write` on its pointer. Note that we do not know which class
    the figure pointer points at. We do not need to know that, since `write` is a
    pure virtual method in the base class `Figure`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个图形，首先我们写入其身份值，然后通过在其指针上调用`write`来写入图形本身。注意，我们不知道图形指针指向哪个类。我们不需要知道这一点，因为`write`是基类`Figure`中的纯虚方法：
- en: '[PRE102]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'We return the output stream converted to `bool`, which is true if the writing
    was successful:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们返回输出流转换为`bool`的结果，如果写入成功则为`true`：
- en: '[PRE103]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'If the file was not successfully opened, we return `false`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件未能成功打开，我们返回`false`：
- en: '[PRE104]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The `readFile` method is called when the user selects the Open menu item. We
    read the parts of the file in the same order as we wrote them in the preceding `writeFile`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择打开菜单项时，会调用`readFile`方法。我们按照与之前`writeFile`中写入相同的顺序读取文件的部分：
- en: '[PRE105]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'If the file was successfully opened, we start by reading the next color and
    filled status:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件成功打开，我们首先读取下一个颜色和填充状态：
- en: '[PRE106]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'We then write the number of figures in the drawing, and then we write the figures
    themselves:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们写入绘图中的图形数量，然后写入图形本身：
- en: '[PRE107]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'For each figure, first we read its identity value, we then create a figure
    of the class indicated by the identity value by calling `createFigure`. Finally,
    we read the figure itself by calling `write` on its pointer:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个图形，首先我们读取其身份值，然后通过调用`createFigure`创建由身份值指示的图形类。最后，通过在其指针上调用`write`来读取图形本身：
- en: '[PRE108]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'We return the input stream converted to `bool`, which is true if the reading
    was successful:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们返回输入流转换为`bool`的结果，如果读取成功则为`true`：
- en: '[PRE109]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'If the file was not successfully opened, we return `false`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件未能成功打开，我们返回`false`：
- en: '[PRE110]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'The `createFigure` method dynamically creates an object of the `Line`, `RectangleX`,
    or `EllipseX` class, depending on the value of the `figureId` parameter:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`createFigure`方法根据`figureId`参数的值动态创建`Line`、`RectangleX`或`EllipseX`类的一个对象：'
- en: '[PRE111]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'The `isCopyEnable` method is called before the Edit menu becomes visible in
    order to enable the Copy item. It is also called by the framework in order to
    enable the Copy toolbar icon. It returns `true` if at least one figure is marked,
    and by then it is ready to be copied. If it returns `true`, the Copy item and
    toolbar icon become enabled:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑菜单可见之前调用`isCopyEnable`方法以启用复制项。框架也会调用它来启用复制工具栏图标。如果至少有一个图形被标记，它返回`true`，此时它就准备好被复制。如果它返回`true`，复制项和工具栏图标将变为启用状态：
- en: '[PRE112]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'The `onCopy` method is called when the user selects the Copy menu item. To
    start with, it deallocates every figure in the copy pointer list and clears the
    list itself:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择复制菜单项时，会调用`onCopy`方法。首先，它释放复制指针列表中的每个图形并清除列表本身：
- en: '[PRE113]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Then, we iterate through the figure pointer list and add the pointer to a copy
    of each marked figure to the copy pointer list. We call `clone` on each figure
    pointer to provide us with the copy:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们遍历图形指针列表，并将每个标记图形的指针添加到复制指针列表中。我们对每个图形指针调用`clone`以提供复制：
- en: '[PRE114]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'The `isPasteEnabled` method is called before the Edit menu becomes visible
    to enable the Paste item. It is also called by the framework to enable the paste
    toolbar icon. If the copy pointer list is not empty, it returns `true`, and thereby
    enables the Paste item and image. That is, it returns `true` if there are figures
    ready to be pasted:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑菜单可见之前调用`isPasteEnabled`方法以启用粘贴项。框架也会调用它来启用粘贴工具栏图标。如果复制指针列表不为空，它返回`true`，从而启用粘贴项和图像。也就是说，如果有图形准备好粘贴，它返回`true`：
- en: '[PRE115]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'The `onPaste` method is called when the user selects the Paste item in the
    Edit menu, or when they select the paste image in the edit toolbar. We iterate
    through the copy pointer list and add a copy (which we obtain by calling `clone`)
    of the figure to the figure pointer list, after we have moved it 10 pixels downwards
    and to the right:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在编辑菜单中选择粘贴项，或者在选择编辑工具栏中的粘贴图像时，会调用`onPaste`方法。我们遍历复制指针列表，并在将其向下和向右移动10像素后，将图形的复制（通过调用`clone`获得）添加到图形指针列表中：
- en: '[PRE116]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Finally, when the figures have been added to the list, we force an eventual
    call to the `paintEvent` by calling `update`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当图形被添加到列表中时，我们通过调用`update`强制最终调用`paintEvent`：
- en: '[PRE117]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'The `onDelete` method is called every time the user selects the Delete menu
    item or toolbar icon. We iterate through the figure pointer list and remove every
    marked figure:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 每次用户选择删除菜单项或工具栏图标时，都会调用`onDelete`方法。我们遍历图形指针列表并删除每个标记的图形：
- en: '[PRE118]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Also, in this case, we force an eventual call to `paintEvent` by calling the `update`
    method, after the figures have been deleted:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在这种情况下，我们在图形被删除后通过调用`update`方法强制最终调用`paintEvent`。
- en: '[PRE119]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'The `onColor` method is called every time the user selects the `Color` item
    in the Format menu. We start by obtaining the new color by calling the static
    method `getColor` in the Qt `QColorDialog` class:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 每次用户在格式菜单中选择“颜色”项时，都会调用`onColor`方法。我们首先通过调用Qt `QColorDialog`类的静态方法`getColor`来获取新的颜色：
- en: '[PRE120]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'If the color is valid, which it is if the user has closed the dialog by pressing
    the Ok button rather than the Cancel button, and if they have chosen a new color,
    we set the next color to the new color and set the modified flag. We also iterate
    through the figure pointer list and, for each marked figure, set the color of
    the figure:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果颜色有效，即用户通过按下“确定”按钮而不是“取消”按钮关闭了对话框，并且他们选择了一种新的颜色，我们将下一个颜色设置为新的颜色并设置修改标志。我们还会遍历图形指针列表，并为每个标记的图形设置图形颜色：
- en: '[PRE121]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'If at least one figure is marked, we force an eventual call to `paintEvent`
    by calling update:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果至少有一个图形被标记，我们将通过调用`update`强制最终调用`paintEvent`：
- en: '[PRE122]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'The `isFillEnabled` method is called before the `Fill` item in the Format menu
    becomes visible:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在格式菜单中的“填充”项变得可见之前，会调用`isFillEnabled`方法：
- en: '[PRE123]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'In `Modify` mode, we iterate through the figure pointer list. If at least one
    rectangle or ellipse is marked, we return `true` and the item becomes enabled:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在“修改”模式下，我们遍历图形指针列表。如果至少有一个矩形或椭圆被标记，我们返回`true`并使项目启用：
- en: '[PRE124]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'If no rectangle or ellipse is marked, we return `false` and the item becomes
    disabled:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有标记矩形或椭圆，我们返回`false`并使项目禁用：
- en: '[PRE125]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'In the `Add` mode, we return `true` if the next figure to be added by the user
    is a rectangle or an ellipse:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在“添加”模式下，如果用户将要添加的下一个图形是矩形或椭圆，我们返回`true`：
- en: '[PRE126]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'We are not supposed to reach this point. The `assert` macro call is for debugging
    purposes only. However, we still must return a value at the end of the method:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不应该到达这一点。`assert`宏调用仅用于调试目的。然而，我们仍然必须在方法末尾返回一个值：
- en: '[PRE127]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'The `onFill` method is called when the user selects the `Fill` item in the
    Format menu:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在格式菜单中选择“填充”项时，会调用`onFill`方法：
- en: '[PRE128]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'In the `Modify` mode, we iterate through the figure pointer list and invert
    the filled status of all marked figures. If at least one figure changes, we force
    an eventual call to `paintEvent` by calling `update`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在“修改”模式下，我们遍历图形指针列表并反转所有标记图形的填充状态。如果至少有一个图形发生变化，我们将通过调用`update`强制最终调用`paintEvent`：
- en: '[PRE129]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'We also invert the filled status of the next figure to be added:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还反转用户将要添加的下一个图形的填充状态：
- en: '[PRE130]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'In the `Add` mode, we invert the filled status of the next figure to be added
    by the user:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在“添加”模式下，我们反转用户将要添加的下一个图形的填充状态：
- en: '[PRE131]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'The `isModifyChecked` method is called before the `Modify` item in the Format
    menu becomes visible. In `Modify` mode, it returns `true` and enables the item:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在格式菜单中的“修改”项变得可见之前，会调用`isModifyChecked`方法。在“修改”模式下，它返回`true`并启用项目：
- en: '[PRE132]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'The `onModify` method is called when the user selects the `Modify` item in
    the Format menu. It sets the action mode to `Modify`:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在格式菜单中选择“修改”项时，会调用`onModify`方法。它将操作模式设置为“修改”：
- en: '[PRE133]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'The `isLineChecked` method is called before the `Line` item in the `Add` submenu
    becomes visible. It returns `true`, and the item becomes checked (with a radio
    button, since the item belongs to a group) in case of add action mode, and the
    next figure to be added is a line:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在“添加”子菜单中的“线条”项变得可见之前，会调用`isLineChecked`方法。它返回`true`，并在添加操作模式下，如果下一个要添加的图形是线条，则项目（由于项目属于一组，因此带有单选按钮）变为选中状态：
- en: '[PRE134]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'The `onLine` method is called when the user selects the `Line` item in the
    `Add` submenu. It set the action mode to `Add` and the next figure to be added
    by the user to a line:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在“添加”子菜单中选择“线条”项时，会调用`onLine`方法。它将操作模式设置为“添加”，并将用户将要添加到线条中的下一个图形设置为：
- en: '[PRE135]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'The `isRectangleChecked` method is called before the `Rectangle` item in the
    `Add` submenu becomes visible. It returns `true` in case of `Add` action mode
    and if the next figure to be added is a rectangle:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Add`子菜单中的`Rectangle`项变得可见之前，会调用`isRectangleChecked`方法。在`Add`动作模式下，如果下一个要添加的图形是矩形，它将返回`true`：
- en: '[PRE136]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'The `onRectangle` method is called when the user selects the `Rectangle` item.
    It sets the action mode to `Add` and the next figure to be added by the user to
    a rectangle:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择`Rectangle`项时，会调用`onRectangle`方法。它将动作模式设置为`Add`，并将用户将要添加的下一个图形设置为矩形：
- en: '[PRE137]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'The `isEllipseChecked` method is called before the `Ellipse` item in the `Add`
    submenu becomes visible. It returns `true` in case of `Add` action mode and if
    the next figure to be added is an ellipse:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Add`子菜单中的`Ellipse`项变得可见之前，会调用`isEllipseChecked`方法。在`Add`动作模式下，如果下一个要添加的图形是椭圆，它将返回`true`：
- en: '[PRE138]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'The `onEllipse` method is called when the user selects the `Ellipse` item.
    It sets the action mode to `Add` and the next figure to be added by the user to
    an ellipse:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择`Ellipse`项时，会调用`onEllipse`方法。它将动作模式设置为`Add`，并将用户将要添加的下一个图形设置为椭圆：
- en: '[PRE139]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'The `mousePressEvent` method is called when the user presses one of the mouse
    buttons. We store the mouse point in `m_mousePoint`, to be used in `mouseMoveEvent` as
    follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下鼠标按钮之一时，会调用`mousePressEvent`方法。我们将鼠标点存储在`m_mousePoint`中，以便在`mouseMoveEvent`中使用，如下所示：
- en: '[PRE140]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'In case of `Modify` mode, we first iterate through the figure pointer list
    and unmark every figure:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Modify`模式下，我们首先遍历图形指针列表，并取消标记每个图形：
- en: '[PRE141]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'We then iterate through the list again, to find if the user has hit a figure.
    Since the top-most figure is placed at the end of the list, we need to iterate
    through the list backward. We do so by using the `reverse_iterator` type of the
    Qt `QList` class:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后再次遍历列表，以查找用户是否击中了图形。由于最顶部的图形被放置在列表的末尾，我们需要从列表的末尾开始遍历。我们通过使用Qt `QList`类的`reverse_iterator`类型来实现这一点：
- en: '[PRE142]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'If we found out (by calling `isClick` on the figure) that a figure has been
    hit by the user''s mouse click, we set the application mode to `ModifySingle`
    and mark the figure. We also remove it from the list and add it to the end of
    the list, to make it appear top-most in the drawing. Finally, we break the loop
    since we have found a figure:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们通过在图形上调用`isClick`发现用户点击了图形，我们将应用程序模式设置为`ModifySingle`并标记该图形。我们还将它从列表中移除，并将其添加到列表的末尾，以便它在绘图中最先显示。最后，我们中断循环，因为我们已经找到了一个图形：
- en: '[PRE143]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'If we have not found a figure, we set the application mode to `ModifyRectangle`
    and initialize the top-most and bottom-right corners of the enclosing rectangle
    to the mouse point:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有找到图形，我们将应用程序模式设置为`ModifyRectangle`，并将包含矩形的顶部和底部右角初始化为鼠标点：
- en: '[PRE144]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'In case of `Add` action mode, we create a new figure by calling `createFigure`
    with the identity of the next figure to be added by the user as a parameter. We
    then set the color, filled status of the new figure, and initialize its endpoints:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Add`动作模式下，我们通过调用`createFigure`并传递用户将要添加的下一个图形的标识符作为参数来创建一个新的图形。然后我们设置新图形的颜色、填充状态，并初始化其端点：
- en: '[PRE145]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'When the new figure has been created and initialized, we add it at the end
    of the figure pointer list and set the application mode to `ModifySingle`, since
    the `mouseMoveEvent` method will continue to modify the last figure in the list,
    just as if the user had hit a figure in the `Modify` mode. We also set the modified
    flag since we have added a figure to the drawing:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 当新图形被创建并初始化后，我们将它添加到图形指针列表的末尾，并将应用程序模式设置为`ModifySingle`，因为`mouseMoveEvent`方法将继续修改列表中的最后一个图形，就像用户在`Modify`模式下击中了图形一样。我们还设置了修改标志，因为我们已经向绘图添加了一个图形：
- en: '[PRE146]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Finally, we force an eventual call to `paintEvent` by calling `update`:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过调用`update`强制调用`paintEvent`：
- en: '[PRE147]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'The `mouseMoveEvent` method is called when the user moves the mouse. If they
    also press the left mouse button, we save the mouse point to future calls to `mouseMoveEvent`
    and calculate the distance since the last call to `mousePressEvent` or `mouseMoveEvent`:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户移动鼠标时，会调用`mouseMoveEvent`方法。如果他们同时按下鼠标左键，我们将鼠标点保存到未来的`mouseMoveEvent`调用中，并计算自上次调用`mousePressEvent`或`mouseMoveEvent`以来的距离：
- en: '[PRE148]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'In the `Modify` mode, we modify the current figure (the figure placed at the
    end of the figure pointer list) by calling `modify`. Remember that the figure
    can be either modified or moved, depending on the settings in the call to `isClick`
    in `onMousePress` previously. We also set the modified flag since the figure has
    been altered:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Modify`模式下，我们通过调用`modify`来修改当前图形（位于图形指针列表末尾的图形）。请记住，图形可以是修改的，也可以是移动的，这取决于之前在`onMousePress`中调用`isClick`时的设置。我们还设置了修改标志，因为图形已经被更改：
- en: '[PRE149]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'In case of the enclosing rectangle, we just update its bottom-right corner.
    Note that we do not set the modified flag since no figure has yet been altered:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含矩形的情况下，我们只需更新其右下角。请注意，我们并没有设置修改标志，因为还没有任何图形被更改：
- en: '[PRE150]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Finally, we force an eventual call to `paintEvent` by calling `update`:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过调用`update`强制进行可能的`paintEvent`调用：
- en: '[PRE151]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'The `mouseReleaseEvent` method is called when the user releases a mouse button.
    If it is the left mouse button, we check the application mode. The only mode we
    actually are interested in is the enclosing rectangle mode:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户释放鼠标按钮时，会调用`mouseReleaseEvent`方法。如果是左键，我们会检查应用程序模式。我们唯一感兴趣的模式是包含矩形模式：
- en: '[PRE152]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'We iterate through the figure pointer list and call `isInside` on each figure.
    Each figure that is completely enclosed by the rectangle becomes marked, removed
    from the list, and added to `insidePtrList` to be later added at the end of the
    figure pointer list:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遍历图形指针列表，并对每个图形调用`isInside`。每个完全被矩形包含的图形被标记，从列表中移除，并添加到`insidePtrList`中，稍后将其添加到图形指针列表的末尾：
- en: '[PRE153]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Each figure which is completely enclosed by the rectangle is removed from the
    figure pointer list:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 每个完全被矩形包含的图形都会从图形指针列表中移除：
- en: '[PRE154]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Finally, all enclosed figures are added at the end of the list in order to
    appear top-most in the drawing:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将所有包含的图形添加到列表的末尾，以便在绘图中最先显示：
- en: '[PRE155]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'When the user has released the mouse button, the application mode is set to
    idle, and we force an eventual call to `paintEvent` by calling `update`:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户释放鼠标按钮时，应用程序模式设置为空闲，并通过调用`update`强制进行可能的`paintEvent`调用：
- en: '[PRE156]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'The `mouseDoubleClick` method is called when the user double-clicks one of
    the buttons. However, `mouseClickEvent` is always called before `mouseDoubleClickEvent`.
    If the preceding call to `mouseClickEvent` has made `m_clickedFigurePtr` point
    at the clicked figure, we call `doubleClick` on that figure. This may cause some
    change in the figure, depending on which kind of figure it is:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户双击按钮之一时，会调用`mouseDoubleClick`方法。然而，`mouseClickEvent`总是在`mouseDoubleClickEvent`之前被调用。如果先前的`mouseClickEvent`调用使`m_clickedFigurePtr`指向被点击的图形，我们会在该图形上调用`doubleClick`。这可能会根据图形的类型引起一些变化：
- en: '[PRE157]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Finally, `paintEvent` is called when the content of the window needs to be
    repainted. Before the call, the framework clears the window:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当窗口内容需要重绘时，会调用`paintEvent`。在调用之前，框架会清除窗口：
- en: '[PRE158]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'We iterate through the figure pointer list and draw every figure. The last
    figure in the list is placed at the end of the list, to appear at the top of the
    drawing:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遍历图形指针列表，并绘制每个图形。列表中的最后一个图形被放置在列表的末尾，以便在绘图的最上方显示：
- en: '[PRE159]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'In case of enclosing rectangle mode, we draw a hollow rectangle with a light-gray
    border:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含矩形模式下，我们用浅灰色边框绘制一个空心矩形：
- en: '[PRE160]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: The main function
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主函数
- en: The `main` function is similar to the `main` function of the previous applications—it
    creates an application, shows the drawing window, and starts the execution of
    the application.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数与之前应用程序的`main`函数类似——创建一个应用程序，显示绘图窗口，并开始应用程序的执行。'
- en: '**Main.cpp:**'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '**Main.cpp:**'
- en: '[PRE161]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'The output is shown in the following screenshot:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了输出：
- en: '![](img/e32d6956-fb1d-4513-bb7f-b7b7529a3466.png)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e32d6956-fb1d-4513-bb7f-b7b7529a3466.png)'
- en: Improving the editor
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进编辑器
- en: The editor of this chapter is a more advanced version of the editor of [Chapter
    5](411aae8c-9215-4315-8a2e-882bf028834c.xhtml), *Qt Graphical Applications*. In
    this version, it is possible to change the font and alignment of the text, to
    mark text, and to cut and paste text.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的编辑器是[第5章](411aae8c-9215-4315-8a2e-882bf028834c.xhtml)中编辑器的更高级版本，*Qt图形应用程序*。在这个版本中，可以更改文本的字体和对齐方式，标记文本，以及剪切和粘贴文本。
- en: The EditorWindow class
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EditorWindow类
- en: The `EditorWindow` class of this chapter is similar to the class of [Chapter
    5](https://cdp.packtpub.com/c___by_example/wp-admin/post.php?post=72&action=edit#post_67), *Qt
    Graphical Applications*. It catches the key pressing event and the window closing
    event.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的`EditorWindow`类与[第5章](https://cdp.packtpub.com/c___by_example/wp-admin/post.php?post=72&action=edit#post_67)，*Qt
    图形应用程序*中的类相似。它捕获按键事件和窗口关闭事件。
- en: '**EditorWindow.h:**'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '**EditorWindow.h:**'
- en: '[PRE162]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '**EditorWindow.cpp:**'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '**EditorWindow.cpp:**'
- en: '[PRE163]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'The constructor initializes the editor window. It sets the size of the window
    to *1000 x 500* pixels. It also dynamically creates an editor widget and adds
    the standard File and Edit menus:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数初始化编辑器窗口。它将窗口大小设置为 *1000 x 500* 像素。它还动态创建了一个编辑器小部件，并添加了标准的文件和编辑菜单：
- en: '[PRE164]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'The Figure menu is different, compared to [Chapter 5](411aae8c-9215-4315-8a2e-882bf028834c.xhtml), *Qt
    Graphical Applications*. We add the item `Font` and the submenu Alignment, to
    which, in turn, we add the three items: left, center, and right:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 与[第5章](411aae8c-9215-4315-8a2e-882bf028834c.xhtml)，*Qt 图形应用程序*相比，图形单菜单有所不同。我们添加了`字体`项和子菜单对齐，然后我们依次添加了三个项：左对齐、居中对齐和右对齐：
- en: '[PRE165]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'We also add a toolbar for the `Alignment` menu:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还为`Alignment`菜单添加了一个工具栏：
- en: '[PRE166]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'The key pressing event and the window closing event are passed on to the editor
    widget:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 关键按键事件和窗口关闭事件被传递给编辑器小部件：
- en: '[PRE167]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: The EditorWidget class
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`EditorWidget`类'
- en: The `EditorWidget` class is similar to the version of [Chapter 5](411aae8c-9215-4315-8a2e-882bf028834c.xhtml),
    *Qt Graphical Applications*. However, methods and listeners to handle the font
    and alignment have been added.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '`EditorWidget`类与[第5章](411aae8c-9215-4315-8a2e-882bf028834c.xhtml)，*Qt 图形应用程序*中的版本相似。然而，已经添加了处理字体和对齐的方法和监听器。'
- en: '**EditorWidget.h:**'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '**EditorWidget.h:**'
- en: '[PRE169]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'The `mousePresseEvent`, `mouseMoveEvent`, and `mouseReleaseEvent` are called
    when the user presses a mouse button, moves the mouse, and releases the mouse
    button:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下鼠标按钮、移动鼠标和释放鼠标按钮时，会调用`mousePressEvent`、`mouseMoveEvent`和`mouseReleaseEvent`：
- en: '[PRE170]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'The `newDocument` method is called when the user selects the New menu item,
    `writeFile` is called when they select Save or Save As, and `readFile` is called
    when they select the Open menu item:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择新建菜单项时，会调用`newDocument`方法，当选择保存或另存为时，会调用`writeFile`，当选择打开菜单项时，会调用`readFile`：
- en: '[PRE171]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'The `isLeftChecked`, `isCenterChecked`, and `isRightChecked` methods are called
    before the `Alignment` submenu becomes visible. They then annotate a radio button
    to the selected alignment:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Alignment`子菜单可见之前，会调用`isLeftChecked`、`isCenterChecked`和`isRightChecked`方法。然后它们会对选定的对齐方式标注一个单选按钮：
- en: '[PRE172]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'The `onLeft`, `onCenter`, and `onRight` methods are called when the user selects
    one of the items of the Alignment submenu:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择对齐子菜单的任一项时，会调用`onLeft`、`onCenter`和`onRight`方法：
- en: '[PRE173]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'In this version of the editor, we have two modes—edit and mark. The edit mark
    is active when the user inputs text or moves the caret with the arrow key, while
    the mark mode is active when the user has marked a block of the code with the
    mouse. The caret is visible in edit mode, but not in mark mode:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本的编辑器中，我们有两种模式——编辑和标记。当用户输入文本或使用箭头键移动光标时，编辑标记是活动的，而当用户用鼠标标记代码块时，标记模式是活动的。光标在编辑模式下可见，但在标记模式下不可见：
- en: '[PRE174]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'The text can be aligned in the left, center, and right direction:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 文本可以沿左、中、右方向对齐：
- en: '[PRE175]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'In edit mode, `m_editIndex` holds the index to place the next character to
    be input by the user, which also is the position of the caret. In mark mode, `m_firstIndex`
    and `m_lastIndex` hold the indexes of the first and last marked character:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑模式下，`m_editIndex`持有用户将要输入的下一个字符的索引，这同时也是光标的位置。在标记模式下，`m_firstIndex`和`m_lastIndex`持有第一个和最后一个标记字符的索引：
- en: '[PRE176]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'The `m_caret` object holds the caret of the editor. The caret is visible in
    edit mode, but not in mark mode:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_caret`对象持有编辑器的光标。光标在编辑模式下可见，但在标记模式下不可见：'
- en: '[PRE177]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'The `m_editorText` field holds the text of the editor, and `m_copyText` holds
    the text which is cut or pasted by the user:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_editorText`字段持有编辑器的文本，而`m_copyText`持有用户剪切或粘贴的文本：'
- en: '[PRE178]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'The text of the editor is divided into lines; the index of the first and last
    character of each line is stored in `m_lineList`:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑器的文本被分成行；每行的第一个和最后一个字符的索引存储在`m_lineList`中：
- en: '[PRE179]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'The current font of the text is stored in `m_textFont`. The height in pixels
    of a character of the current font is stored in `m_fontHeight`:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 当前文本的字体存储在`m_textFont`中。当前字体中字符的高度（以像素为单位）存储在`m_fontHeight`中：
- en: '[PRE180]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'The `mousePressEvent` and `mouseMoveEvent` methods store the last mouse point
    in order to calculate the distance between mouse events:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '`mousePressEvent` 和 `mouseMoveEvent` 方法存储最后一个鼠标点，以便计算鼠标事件之间的距离：'
- en: '[PRE181]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'Similar to the method of [Chapter 5](411aae8c-9215-4315-8a2e-882bf028834c.xhtml),
    *Qt Graphical Applications*, `calculate` is an auxiliary method that calculates
    the enclosing rectangle of each character of the text. However, the version of
    this chapter is more complicated since it has to take into consideration whether
    the text is left, center, or right-aligned:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 与第 5 章[方法](411aae8c-9215-4315-8a2e-882bf028834c.xhtml)中的方法类似，*Qt 图形应用程序*，`calculate`
    是一个辅助方法，用于计算文本中每个字符的包含矩形。然而，本章的版本更复杂，因为它必须考虑文本是左对齐、居中对齐还是右对齐：
- en: '[PRE182]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'The enclosing rectangles are stored in `m_rectList`, and then used by the caret
    and `paintEvent`:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 包含矩形存储在 `m_rectList` 中，然后由光标和 `paintEvent` 使用：
- en: '[PRE183]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '**EditorWidget.cpp:**'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '**EditorWidget.cpp:**'
- en: '[PRE184]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'The constructor sets the window header to `Editor Advanced` and the file suffix
    to `edi`:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数将窗口标题设置为 `Editor Advanced` 并将文件后缀设置为 `edi`：
- en: '[PRE185]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'The text font is initialized to `12` point `Times New Roman`. The application
    mode is set to edit, the index of the next character to be input by the user is
    set to zero, and the text is left- aligned from the beginning:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 文本字体初始化为 `12` 点 `Times New Roman`。将应用程序模式设置为编辑，将用户下一个要输入的字符的索引设置为零，并从开始将文本设置为左对齐：
- en: '[PRE186]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'The rectangles enclosing the characters are calculated by `calculate`, the
    caret is initialized and shown since the application holds edit mode from the
    beginning:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `calculate` 计算包含字符的矩形，初始化并显示光标，因为应用程序从开始就持有编辑模式：
- en: '[PRE187]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'The `newDocument` method is called when the user selects the New menu item.
    We start by setting the application mode to edit and the edit index to zero. The
    text font is set to `12` point Times New Roman. The text of the editor is cleared,
    the rectangles enclosing the characters are calculated by `calculate`, and the
    caret is set:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择“新建”菜单项时调用 `newDocument` 方法。我们首先将应用程序模式设置为编辑并将编辑索引设置为零。文本字体设置为 `12` 点 Times
    New Roman。清除编辑器的文本，通过 `calculate` 计算包含字符的矩形，并设置光标：
- en: '[PRE188]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'The `writeFile` method is called when the user selects the Save or Save As
    menu items. The file format is quite simple: we write the font on the first line,
    and then the text of the editor on the following lines:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择“保存”或“另存为”菜单项时调用 `writeFile` 方法。文件格式相当简单：我们在第一行写入字体，然后在以下行写入编辑器的文本：
- en: '[PRE189]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: 'We use the `Ok` field of the input stream to decide if the writing was successful:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用输入流的 `Ok` 字段来决定写入是否成功：
- en: '[PRE190]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'If we could not open the file for writing, we return `false`:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们无法打开文件进行写入，我们返回 `false`：
- en: '[PRE191]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'The `readFile` method is called when the user selects the Open menu items.
    Similar to `writeFile` previously, we read the first line and initialize the text
    font with the text. We then read the editor text:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择“打开”菜单项时调用 `readFile` 方法。类似于之前的 `writeFile`，我们读取第一行并用文本初始化文本字体。然后读取编辑器文本：
- en: '[PRE192]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'When the text is read, we call `calculate` to calculate the rectangles enclosing
    the characters of the text. We then set the caret and return `true`, since the
    reading was successful:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 当文本被读取时，我们调用 `calculate` 来计算包含文本字符的矩形。然后设置光标并返回 `true`，因为读取是成功的：
- en: '[PRE193]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'We use the `Ok` field of the input stream to decide if the reading was successful:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用输入流的 `Ok` 字段来决定读取是否成功：
- en: '[PRE194]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: 'If we could not open the file for reading, we `return false`:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们无法打开文件进行读取，我们 `return false`：
- en: '[PRE195]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'The `isCopyEnabled` method is called before the Edit menu becomes visible.
    It is also called by the framework to decide whether the copy toolbar icon shall
    be enabled. It returns true (and the item becomes enabled) if the application
    holds mark mode, which means that the user has marked a part of the text, which
    can be copied:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑菜单可见之前调用 `isCopyEnabled` 方法。框架也会调用它来决定是否启用复制工具栏图标。如果应用程序处于标记模式（意味着用户已标记文本的一部分，可以复制），则返回
    `true`（并且项目变为启用状态）：
- en: '[PRE196]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: 'The `onCopy` method is called when the user selects the Copy item. We copy
    the marked text into `m_EditorText`:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择“复制”菜单项时调用 `onCopy` 方法。我们将标记的文本复制到 `m_EditorText`：
- en: '[PRE197]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: 'The `isPasteEnabled` method is also called before the Edit menu becomes visible.
    It returns `true` (and the item becomes visible) if the copy text is not empty.
    That is, if there is a block of text that has been copied and is ready to be pasted:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑菜单可见之前也会调用 `isPasteEnabled` 方法。如果复制的文本不为空，它返回 `true`（并且项目变为可见）。也就是说，如果有一个已复制的文本块准备好粘贴：
- en: '[PRE198]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: 'The `onPaste` method is called when the user selects the Paste menu item. In
    mark mode, we call `onDelete`, which causes the marked text to be deleted:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择粘贴菜单项时，会调用 `onPaste` 方法。在标记模式下，我们调用 `onDelete`，这将导致标记的文本被删除：
- en: '[PRE199]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: 'We then insert the copied text into the editor text. We also update `m_editIndex`,
    since the edit index after the text has been copied shall be the position after
    the inserted text:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将复制的文本插入到编辑器文本中。我们还更新 `m_editIndex`，因为文本被复制后，编辑索引应该是插入文本后的位置：
- en: '[PRE200]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'Finally, we calculate the rectangles enclosing the characters of the text,
    set the caret to the new index, set the modified flag since the text has been
    altered, and call `update` to force an eventual call to `paintEvent` in order
    to display the new text:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们计算包含文本字符的矩形，将光标设置到新索引，设置修改标志，因为文本已被更改，并通过调用 `update` 强制调用 `paintEvent`
    以显示新文本：
- en: '[PRE201]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: The `onDelete` method is called when the user selects the Delete menu item or
    the Delete toolbar icon. The effect is similar to the event when the user presses
    the *Delete* key. Therefore, we prepare a keypress event with the *Delete* key,
    which we use as a parameter in the call to `keyPressEvent`.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择删除菜单项或删除工具栏图标时，会调用 `onDelete` 方法。效果类似于用户按下 *Delete* 键时的事件。因此，我们准备一个带有 *Delete*
    键的按键事件，将其用作 `keyPressEvent` 调用的参数：
- en: 'Note that there is no `isDeleteEnabled` method because the user can always
    use the Delete item. In edit mode, the next character is deleted. In mark mode,
    the marked text is deleted:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，没有 `isDeleteEnabled` 方法，因为用户始终可以使用删除项。在编辑模式下，下一个字符被删除。在标记模式下，标记的文本被删除：
- en: '[PRE202]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '`isCopyEnabled` is called before the Format menu becomes visible. It returns
    `true` in edit mode, since it would be illogical to change the font on all characters
    when a subset of them is marked:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 在格式菜单可见之前调用 `isCopyEnabled`。在编辑模式下它返回 `true`，因为当只有一部分字符被标记时，改变所有字符的字体是不合逻辑的：
- en: '[PRE203]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: 'The `onFont` method is called when the user selects the `Font` menu item. We
    let the user select the new font with the Qt `QFontDialog` class:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择 `Font` 菜单项时，会调用 `onFont` 方法。我们让用户使用 Qt 的 `QFontDialog` 类选择新的字体：
- en: '[PRE204]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: 'If the user closes the dialog by pressing the Ok button, we set the font of
    the editor (`m_textFont`) field and the modified flag:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户通过按下 Ok 按钮关闭对话框，我们将编辑器（`m_textFont`）字段的字体和修改标志设置：
- en: '[PRE205]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: 'We calculate the newly enclosed rectangles by calling `calculate`, set the
    caret, and force an eventual call to `paintEvent` by calling `update`:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用 `calculate` 计算新包含的矩形，设置光标，并通过调用 `update` 强制调用 `paintEvent`：
- en: '[PRE206]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: 'The `isLeftChecked`, `isCenterChecked`, and `isRightChecked` methods are called
    before the alignment submenu becomes visible. They return `true` to the current
    alignment:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '`isLeftChecked`, `isCenterChecked`, 和 `isRightChecked` 方法在对齐子菜单可见之前被调用。它们返回
    `true` 给当前的对齐方式：'
- en: '[PRE207]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: The `onLeft`, `onCenter`, and `onRight` methods are called when the user selects
    the `Left`, `Center`, and `Right` menu item. They set the alignment and the modified
    flag.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择 `Left`、`Center` 和 `Right` 菜单项时，会调用 `onLeft`、`onCenter` 和 `onRight` 方法。它们设置对齐方式和修改标志。
- en: 'They also calculate the new enclosing rectangles, set the caret, and force
    an eventual call to `paintEvent` by calling `update`:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 它们也会计算新的包含矩形，设置光标，并通过调用 `update` 强制调用 `paintEvent`：
- en: '[PRE208]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: 'The `mousePressEvent` method is called when the user presses one of the mouse
    buttons. We call `mouseToIndex` to find the character index the user clicked on.
    For the time being, both the first and last mark index is set to the mouse index.
    The last index may later be changed by a call to `mouseMoveEvent` in the following
    snippet. Finally, the mode is set to mark, and the caret is hidden:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下鼠标按钮之一时，会调用 `mousePressEvent` 方法。我们调用 `mouseToIndex` 来找到用户点击的字符索引。暂时，第一个和最后一个标记索引被设置为鼠标索引。最后一个索引可能稍后通过以下片段中的
    `mouseMoveEvent` 调用而改变。最后，模式被设置为标记，光标被隐藏：
- en: '[PRE209]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: 'The `mouseMoveEvent` method is called when the user moves the mouse. We set
    the last mark index to the mouse index and force an eventual call to `paintEvent`
    by calling `update`:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户移动鼠标时，会调用 `mouseMoveEvent` 方法。我们将最后一个标记索引设置为鼠标索引，并通过调用 `update` 强制调用 `paintEvent`：
- en: '[PRE210]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: 'The `mouseReleaseEvent` method is called when the user releases the mouse button.
    If the user has moved the mouse to the original start position of the mouse movement,
    there is nothing to mark and we set the application in edit mode. In that case,
    we set the edit index to the first mark index, and set and show the caret (since
    it shall be visible in edit mode). Finally, we force an eventual call to `paintEvent`
    by calling `update`:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户释放鼠标按钮时，会调用 `mouseReleaseEvent` 方法。如果用户将鼠标移动到鼠标移动的原始起始位置，则没有标记要做，并将应用程序设置为编辑模式。在这种情况下，我们将编辑索引设置为第一个标记索引，并设置和显示插入点（因为它应该在编辑模式下可见）。最后，我们通过调用
    `update` 强制调用 `paintEvent`：
- en: '[PRE211]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '`keyPressEvent` is called when the user presses a key on the keyboard. Depending
    on the application mode (edit or mark), we call `keyEditPressEvent` or the following `keyMarkPressEvent` to
    further process the key event:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在键盘上按下键时，会调用 `keyPressEvent`。根据应用程序模式（编辑或标记），我们调用 `keyEditPressEvent` 或以下
    `keyMarkPressEvent` 以进一步处理按键事件：
- en: '[PRE212]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '`keyEditPressEvent` handles the key press in edit mode. First, we check if
    the key is an arrow key, page up or down, *Delete*, *Backspace*, or return key:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '`keyEditPressEvent` 处理编辑模式下的按键。首先，我们检查键是否是箭头键、页面上下、*删除*、*退格*或回车键：'
- en: '[PRE213]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: 'In the case of the left-arrow key, we move the edit index one step backward,
    unless it is already at the beginning of the text:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 在左箭头键的情况下，我们将编辑索引向后移动一步，除非它已经位于文本的开头：
- en: '[PRE214]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: 'In the case of the right-arrow key, we mode the edit index one step forward,
    unless it is already at the end of the text:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 在右箭头键的情况下，我们将编辑索引向前移动一步，除非它已经位于文本的末尾：
- en: '[PRE215]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: 'In the case of the up-arrow key, we calculate the appropriate `x` and `y` position
    for the character on the previous line, unless it is already on top of the text.
    We then call `simulateMouseClick`, which has the same effect as if the user has
    clicked on the character above the line:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 在上箭头键的情况下，我们计算上一行字符的适当 `x` 和 `y` 位置，除非它已经在文本顶部。然后我们调用 `simulateMouseClick`，这会产生与用户点击行上方的字符相同的效果：
- en: '[PRE216]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: In the same way, in the case of the down-arrow key, we move the edit index one
    line downwards unless it is already at the bottom of the text.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在下箭头键的情况下，我们将编辑索引向下移动一行，除非它已经位于文本底部。
- en: 'We calculate the appropriate `x` and `y` position for the character on the
    line below and call `simulateMouseClick`, which has the same effect as if the
    user has clicked at the point:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计算下一行字符的适当 `x` 和 `y` 位置，并调用 `simulateMouseClick`，这会产生与用户在点击点相同的效果：
- en: '[PRE217]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: 'In the case of the *Delete* key, we remove the current key, unless we are at
    the end of the text. That is, if we are one step beyond the last character:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *删除* 键的情况下，我们删除当前键，除非我们位于文本末尾。也就是说，如果我们比最后一个字符多一步：
- en: '[PRE218]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: 'In the case of the backspace key, we move the edit index one step backward,
    unless it already is at the beginning of the text, and call `onDelete`. In this
    way, we remove the previous character and move the edit index one step backward:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 在退格键的情况下，我们将编辑索引向后移动一步，除非它已经位于文本的开头，并调用 `onDelete`。这样，我们就删除了前面的字符，并将编辑索引向后移动一步：
- en: '[PRE219]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: 'In the case of the return key, we simply insert the new line character to the
    text:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 在回车键的情况下，我们简单地将在文本中插入新行字符：
- en: '[PRE220]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: 'If the key is not a special key, we check whether it is a regular character
    by calling `text` on the key event pointer. If the text is not empty, add its
    first character to the text:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 如果键不是特殊键，我们通过在按键事件指针上调用 `text` 来检查它是否是常规字符。如果文本不为空，则将其第一个字符添加到文本中：
- en: '[PRE221]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: 'Finally, we calculate the enclosing rectangles, set the caret, and force an
    eventual call to `paintEvent` by calling `update`:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们计算包含的矩形，设置插入点，并通过调用 `update` 强制调用 `paintEvent`：
- en: '[PRE222]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '`keyMarkPressEvent` is called when the user presses a key in mark mode:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在标记模式下按下键时，会调用 `keyMarkPressEvent`：
- en: '[PRE223]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: 'In case of the left-arrow key, we set the application to edit mode and the
    edit index to the minimum of the first and last marked index. However, if the
    minimum index is located at the beginning of the text, we do nothing:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 在左箭头键的情况下，我们将应用程序设置为编辑模式，并将编辑索引设置为第一个和最后一个标记索引的最小值。然而，如果最小索引位于文本开头，我们不做任何操作：
- en: '[PRE224]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: 'On the other hand, in the case of the right-arrow key, we set the application
    to edit mode and the edit index to the maximum of the first and last marked index.
    However, if the maximum index is located at the end of the text, we do nothing:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在右箭头键的情况下，我们将应用程序设置为编辑模式，并将编辑索引设置为第一个和最后一个标记索引的最大值。然而，如果最大索引位于文本末尾，我们不做任何操作：
- en: '[PRE225]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: 'In case of the up and down arrows, we simulate a mouse click one line above
    or below the current line, just as in the previous edit case:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 在上下箭头的情况下，我们模拟在当前行上方或下方一行处的鼠标点击，就像在之前的编辑情况中一样：
- en: '[PRE227]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: 'In the mark mode, the delete and backspace keys perform the same task—they
    delete the marked text:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 在标记模式下，删除键和退格键执行相同的任务——它们删除标记的文本：
- en: '[PRE228]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: 'We remove the marked text from the edit text, set the modified flag, set the
    application to edit mode, set the edit index to the minimum of the first and last
    marked index, and show the caret:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从编辑文本中移除标记的文本，设置修改标志，将应用程序设置为编辑模式，将编辑索引设置为第一个和最后一个标记索引的最小值，并显示光标：
- en: '[PRE229]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: 'The return key case is similar to the previous edit mode case, with the difference
    that we first delete the marked text. We then add a new line to the editor text:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 回车键的情况与之前的编辑模式情况类似，不同之处在于我们首先删除标记的文本。然后我们在编辑器文本中添加一个新行：
- en: '[PRE230]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: 'If the key is not a special key, we check if it is a regular key by calling
    `text` on the key event pointer. If the text is not empty, the user has printed
    a regular key, and we insert the first character in the editor text:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 如果键不是特殊键，我们通过在键事件指针上调用 `text` 来检查它是否是常规键。如果文本不为空，则用户打印了一个常规键，并且我们在编辑器文本中插入第一个字符：
- en: '[PRE231]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: 'Finally, we calculate the new rectangles enclosing the characters, set the
    caret, and force an eventual call to `paintEvent` by calling `update`:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们计算包围字符的新矩形，设置光标，并通过调用 `update` 强制调用 `paintEvent`：
- en: '[PRE232]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: 'The `simulateMouseClick` method is called when the user moves the caret up
    or down. It simulates a mouse click by calling `mousePressEvent` and `mouseReleaseEvent`,
    with suitably prepared event objects:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户移动光标上下时调用 `simulateMouseClick` 方法。它通过调用 `mousePressEvent` 和 `mouseReleaseEvent`
    并使用适当准备的事件对象来模拟鼠标点击：
- en: '[PRE233]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: 'The `setCaret` method sets the caret to the appropriate size and position in
    edit mode. Firstly, we use `m_editIndex` to find the rectangle of the correct
    character. We then create a new rectangle that is of only one-pixel width, in
    order for the caret to appear as a thin vertical line:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '`setCaret` 方法在编辑模式下设置光标到适当的大小和位置。首先，我们使用 `m_editIndex` 找到正确字符的矩形。然后我们创建一个只有一像素宽的新矩形，以便光标看起来像一条细的垂直线：'
- en: '[PRE234]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: 'The `mouseToIndex` method takes a mouse point and returns the index of the
    character at that point. Unlike the version of [Chapter 5](411aae8c-9215-4315-8a2e-882bf028834c.xhtml),
    *Qt Graphical Applications*, we need to take into consideration that the text
    may be center or right-aligned:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '`mouseToIndex` 方法接受一个鼠标点并返回该点的字符索引。与 [第 5 章](411aae8c-9215-4315-8a2e-882bf028834c.xhtml)
    的版本 *Qt 图形应用程序* 不同，我们需要考虑文本可能是居中或右对齐的：'
- en: '[PRE235]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: 'If the mouse point is below the text of the editor, the index of the last character
    is returned:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 如果鼠标指针位于编辑器文本下方，则返回最后一个字符的索引：
- en: '[PRE236]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: 'Otherwise, we start by finding the line of the mouse point, and obtain the
    indexes of the first and last character on the line:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们首先找到鼠标指针所在的行，并获取该行第一个和最后一个字符的索引：
- en: '[PRE237]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: 'If the mouse point is located to the left of the first character on the line
    (which it may be if the text is center or right-aligned), we return the index
    of the first character of the line:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 如果鼠标指针位于行上第一个字符的左侧（如果文本是居中或右对齐，则可能如此），我们返回行的第一个字符的索引：
- en: '[PRE238]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: 'If the mouse point, on the other hand, is located to the right of the line,
    we return the index of the character next to the last character of the line:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 如果鼠标指针位于行的右侧，我们返回行中最后一个字符旁边的字符的索引：
- en: '[PRE239]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: 'Otherwise, we iterate through the character on the line and, for each character,
    we check whether the mouse point is located inside the character''s enclosing
    rectangle:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们遍历行上的字符，并对每个字符检查鼠标指针是否位于该字符的包围矩形内：
- en: '[PRE240]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: 'If the mouse point is located inside the rectangle, we check if it is closest
    to the left or right border of the rectangle. If it is closest to the left border,
    we return the index of the character. If it is closest to the right border, we
    instead return the index of the next character:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 如果鼠标指针位于矩形内，我们检查它是否最接近矩形的左边界或右边界。如果它最接近左边界，我们返回字符的索引。如果它最接近右边界，我们则返回下一个字符的索引：
- en: '[PRE241]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: 'We are not supposed to reach this point. The `assert` macro is added for debugging
    purposes only:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不应该到达这个点。添加 `assert` 宏仅用于调试目的：
- en: '[PRE242]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: 'The `resizeEvent` method is called when the user resizes the window. We calculate
    the rectangles enclosing the characters, since the width of the window may have
    changed, which may cause the lines to hold fewer or more characters:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户调整窗口大小时，会调用`resizeEvent`方法。我们计算包含字符的矩形，因为窗口的宽度可能已更改，这可能导致行包含的字符数量减少或增加：
- en: '[PRE243]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: 'The `calculate` method divides the text into lines, and calculates the rectangles
    enclosing every character of the text. The indexes of the first and last character
    of each line are stored in `m_lineList`, and the enclosing rectangles are stored
    in `m_rectList`:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '`calculate`方法将文本分成行，并计算包含文本中每个字符的矩形。每行的第一个和最后一个字符的索引存储在`m_lineList`中，包围的矩形存储在`m_rectList`中：'
- en: '[PRE244]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: 'We use the Qt `QFontMetrics` class to obtain the height of a character of the
    editor font. The height is stored in `m_fontHeight`. The `width` method gives
    the width of the window content, in pixels:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Qt `QFontMetrics`类来获取编辑器字体中字符的高度。高度存储在`m_fontHeight`中。`width`方法给出窗口内容的宽度，以像素为单位：
- en: '[PRE245]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: 'We start by iterating through the editor text in order to divide the text into
    lines:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先遍历编辑器文本，以便将文本分成行：
- en: '[PRE246]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: 'When we encounter a new line, we add the first and last index of the current
    line to `m_lineList`:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遇到新行时，我们将当前行的第一个和最后一个索引添加到`m_lineList`中：
- en: '[PRE247]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: 'Otherwise, we call the `width` method of the Qt `QMetrics` object to obtain
    the width of the character, in pixels:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们调用Qt `QMetrics`对象的`width`方法来获取字符的宽度，以像素为单位：
- en: '[PRE248]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: If the character makes the width of the line exceed the width of the window
    content, we add the first and last index to `m_lineList` and start a new line.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字符使行的宽度超过了窗口内容的宽度，我们将第一个和最后一个索引添加到`m_lineList`中，并开始新的一行。
- en: 'However, we have two different cases to consider. If the current character
    is the first character of the line, we have the (rather unlikely) situation that
    the width of that character exceeds the width of the window content. In that case,
    we add the index of that character as both the first and last index to `m_lineList`.
    The first index of the next line is the character next to that character:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们需要考虑两种不同的情况。如果当前字符是行的第一个字符，那么会出现（相当不可能）这种情况，即该字符的宽度超过了窗口内容的宽度。在这种情况下，我们将该字符的索引添加到`m_lineList`中作为第一个和最后一个索引。下一行的第一个索引是那个字符旁边的字符：
- en: '[PRE249]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: 'If the current character is not the first character of the line, we add the
    indexes of the first character and the character preceding the current character
    to `m_lineList`. The index of the next line becomes the index of the current character:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前字符不是行的第一个字符，我们将第一个字符和当前字符之前的字符的索引添加到`m_lineList`中。下一行的索引变为当前字符的索引：
- en: '[PRE250]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: 'If the character does not make the width of the line exceed the width of the
    window content, we simply add the width of the character to the width of the line:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字符没有使行的宽度超过窗口内容的宽度，我们只需将字符的宽度添加到行的宽度中：
- en: '[PRE251]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: 'Finally, we need to add the last line to `m_lineList`:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将最后一行添加到`m_lineList`中：
- en: '[PRE252]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: 'When we have divided the text into lines, we continue to calculate the enclosing
    rectangles of the individual characters. We start by setting `top` to zero, since
    it holds the top position of the line. It will be increased by the line height
    for each line:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将文本分成行后，我们继续计算单个字符的包围矩形。我们首先将`top`设置为零，因为它持有行的顶部位置。对于每一行，它将增加行高：
- en: '[PRE253]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: 'Depending on the alignment of the text, we need to decide where the line starts.
    In the case of left alignment, we set the left position of the line to zero:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 根据文本的对齐方式，我们需要决定行从哪里开始。在左对齐的情况下，我们将行的左位置设置为零：
- en: '[PRE254]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: 'In case of center alignment, we set the left position to half of the difference
    between the width of the window content and the line. In this way, the line will
    appear at the center of the window:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 在居中对齐的情况下，我们将左位置设置为窗口内容宽度与行宽度的差的一半。这样，行将出现在窗口的中心：
- en: '[PRE255]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: 'In case of right alignment, we set the left position to the difference between
    the width of the window content and the line. In this way, the line will appear
    to the right in the window:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 在右对齐的情况下，我们将左位置设置为窗口内容宽度与行宽度的差。这样，行将看起来在窗口的右侧：
- en: '[PRE256]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: 'Finally, when we have decided the starting left position of the line and the
    width of each individual character of the text, we iterate through the line and
    calculate the enclosing rectangle for each character:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当我们确定了文本行的起始左位置和每个文本字符的宽度后，我们遍历该行并计算每个字符的包围矩形：
- en: '[PRE257]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: 'For the very last line of the text, we add a rectangle holding the position
    beyond the last character:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 对于文本的最后一行，我们添加一个包含超出最后一个字符位置的矩形：
- en: '[PRE258]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: 'The top field is increased by the height of the line for each new line:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 每行新行时，顶部字段增加行高：
- en: '[PRE259]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: 'The `paintEvent` method is called by the framework every time the window needs
    to be repainted, or when we force a repainting by calling `update`. The framework
    clears the content of the window before the call to `paintEvent`:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 框架在每次需要重绘窗口或通过调用`update`强制重绘时都会调用`paintEvent`方法。在调用`paintEvent`之前，框架会清除窗口的内容：
- en: 'First, we create a `QPinter` object that we then use to write on. We set some
    rendering and the font of the text:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个`QPinter`对象，然后使用它来书写。我们设置了某些渲染和文本字体：
- en: '[PRE260]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: 'We calculate the minimum and maximum index of the marked text (even though
    we do not yet know if the application holds mark mode):'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计算被标记文本的最小和最大索引（即使我们尚不知道应用程序是否处于标记模式）：
- en: '[PRE261]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: 'We iterate through the text of the editor. We write every character except
    a new line:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遍历编辑器的文本。我们书写除换行符外的每个字符：
- en: '[PRE262]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: 'If the character is marked, we write it with white text on a black background:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字符被标记，我们使用白色文本在黑色背景上书写：
- en: '[PRE263]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: 'If the character is not marked, we write it with black text on a white background:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字符没有被标记，我们使用黑色文本在白色背景上书写：
- en: '[PRE264]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: 'When the colors of the text and background have been set, we look up the rectangle
    enclosing the character and write the character itself:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 当文本和背景的颜色设置好后，我们查找包含字符的矩形并书写字符本身：
- en: '[PRE265]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: 'Finally, we also paint the caret:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还绘制了光标：
- en: '[PRE266]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: The main function
  id: totrans-579
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主函数
- en: 'The `main` function is similar to the main function of the previous applications:
    it creates an application, shows the drawing window, and starts the execution
    of the application.'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数与之前应用程序的`main`函数类似：它创建一个应用程序，显示绘图窗口，并开始应用程序的执行。'
- en: '**Main.cpp:**'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '**Main.cpp:**'
- en: '[PRE267]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: 'The output is shown in the following screenshot:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了输出：
- en: '![](img/4191c0b5-fcd6-4a9e-a3e4-540323edcd89.png)'
  id: totrans-584
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/4191c0b5-fcd6-4a9e-a3e4-540323edcd89.png)'
- en: Summary
  id: totrans-585
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have developed more advanced versions of the analog clock,
    the drawing program, and the editor. The clock shows the current hour, minute,
    and second. The drawing program, allows the user to draw lines, rectangles, and
    ellipses. The editor allows the user to input and edit text. The clock face has
    digits instead of lines. In the drawing program we can mark, modify, and cut and
    paste figures, and in the editor, we can change font and alignment and mark a
    text block.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开发了更高级的模拟时钟、绘图程序和编辑器版本。时钟显示当前的小时、分钟和秒。绘图程序允许用户绘制线条、矩形和椭圆。编辑器允许用户输入和编辑文本。时钟面使用数字而不是线条。在绘图程序中，我们可以标记、修改，以及剪切和粘贴图形，而在编辑器中，我们可以更改字体和段落对齐方式，并标记文本块。
- en: In [Chapter 7](1ce9af28-ea17-439f-945d-2353f6097157.xhtml), *The Games*, we
    will start developing the games Othello and Nought and Crosses.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](1ce9af28-ea17-439f-945d-2353f6097157.xhtml)“游戏”中，我们将开始开发奥赛罗和井字棋游戏。
