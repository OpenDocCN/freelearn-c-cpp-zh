- en: Introducing Networks and Protocols
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍网络和协议
- en: In this chapter, we will review the fundamentals of computer networking. We'll
    look at abstract models that attempt to explain the main concerns of networking,
    and we'll explain the operation of the primary network protocol, the Internet
    Protocol. We'll look at address families and end with writing programs to list
    your computer's local IP addresses.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将回顾计算机网络的基本原理。我们将探讨试图解释网络主要问题的抽象模型，并解释主要网络协议——互联网协议的操作。我们将探讨地址族，并以编写程序列出计算机的本地IP地址结束。
- en: 'The following topics are covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Network programming and C
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络编程与C语言
- en: OSI layer model
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OSI层模型
- en: TCP/IP reference model
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TCP/IP参考模型
- en: The Internet Protocol
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互联网协议
- en: IPv4 addresses and IPv6 addresses
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IPv4地址和IPv6地址
- en: Domain names
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 域名
- en: Internet protocol routing
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互联网协议路由
- en: Network address translation
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络地址转换
- en: The client-server paradigm
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端-服务器模式
- en: Listing your IP addresses programmatically from C
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从C语言程序中列出IP地址
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Most of this chapter focuses on theory and concepts. However, we do introduce
    some sample programs near the end. To compile these programs, you will need a
    good C compiler. We recommend MinGW on Windows and GCC on Linux and macOS. See
    [Appendix B](47da8507-709b-44a6-9399-b18ce6afd8c9.xhtml), *Setting Up Your C Compiler
    On Windows*, [Appendix C](221eebc0-0bb1-4661-a5aa-eafed9fcba7e.xhtml), *Setting
    Up Your C Compiler On Linux*, and [Appendix D](632db68e-0911-4238-a2be-bd1aa5296120.xhtml),
    *Setting Up Your C Compiler On macOS*, for compiler setup.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的大部分内容集中在理论和概念上。然而，我们在本章末尾介绍了一些示例程序。要编译这些程序，您需要一个良好的C编译器。我们推荐在Windows上使用MinGW，在Linux和macOS上使用GCC。请参阅[附录B](47da8507-709b-44a6-9399-b18ce6afd8c9.xhtml)，*在Windows上设置您的C编译器*，[附录C](221eebc0-0bb1-4661-a5aa-eafed9fcba7e.xhtml)，*在Linux上设置您的C编译器*，以及[附录D](632db68e-0911-4238-a2be-bd1aa5296120.xhtml)，*在macOS上设置您的C编译器*，以了解编译器的设置。
- en: 'The code for this book can be found at: [https://github.com/codeplea/Hands-On-Network-Programming-with-C](https://github.com/codeplea/Hands-On-Network-Programming-with-C)[.](https://github.com/codeplea/Hands-On-Network-Programming-with-C)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本书代码可在以下位置找到：[https://github.com/codeplea/Hands-On-Network-Programming-with-C](https://github.com/codeplea/Hands-On-Network-Programming-with-C)[.](https://github.com/codeplea/Hands-On-Network-Programming-with-C)
- en: 'From the command line, you can download the code for this chapter with the
    following command:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行，您可以使用以下命令下载本章的代码：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'On Windows, using MinGW, you can use the following command to compile and run
    code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，使用MinGW，您可以使用以下命令来编译和运行代码：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'On Linux and macOS, you can use the following command:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux和macOS上，您可以使用以下命令：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The internet and C
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互联网与C语言
- en: Today, the internet needs no introduction. Certainly, millions of desktops,
    laptops, routers, and servers are connected to the internet and have been for
    decades. However, billions of additional devices are now connected as well—mobile
    phones, tablets, gaming systems, vehicles, refrigerators, television sets, industrial
    machinery, surveillance systems, doorbells, and even light bulbs. The new **Internet
    of Things** (**IoT**) trend has people rushing to connect even more unlikely devices
    every day.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，互联网无需介绍。当然，数百万台台式机、笔记本电脑、路由器和服务器已经连接到互联网，并且已经连接了几十年。然而，现在还有数十亿额外的设备也连接到了互联网——移动电话、平板电脑、游戏系统、车辆、冰箱、电视、工业机械、监控系统、门铃，甚至灯泡。新的**物联网（IoT**）趋势使得每天都有越来越多的人急于连接更多不太可能的设备。
- en: Over 20 billion devices are estimated to be connected to the internet now. These
    devices use a wide variety of hardware. They connect over an Ethernet connection,
    Wi-Fi, cellular, a phone line, fiber optics, and other media, but they likely
    have one thing in common; they likely use **C**.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在估计有超过200亿台设备连接到互联网。这些设备使用各种各样的硬件。它们通过以太网连接、Wi-Fi、蜂窝网络、电话线、光纤和其他媒体连接，但它们可能有一个共同点；它们可能都使用**C**语言。
- en: The use of the C programming language is ubiquitous. Almost every network stack
    is programmed in C. This is true for Windows, Linux, and macOS. If your mobile
    phone uses Android or iOS, then even though the apps for these were programmed
    in a different language (Java and Objective C), the kernel and networking code
    was written in C. It is very likely that the network routers that your internet
    data goes through are programmed in C. Even if the user interface and higher-level
    functions of your modem or router are programmed in another language, the networking
    drivers are still probably implemented in C.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: C编程语言的使用无处不在。几乎每个网络栈都是用C编写的。这适用于Windows、Linux和macOS。如果你的手机使用Android或iOS，那么尽管这些应用程序是用不同的语言编写的（Java和Objective
    C），但内核和网络代码是用C编写的。很可能你的互联网数据通过的网络路由器也是用C编写的。即使你的调制解调器或路由器的用户界面和高级功能是用另一种语言编写的，但网络驱动程序仍然很可能是用C实现的。
- en: Networking encompasses concerns at many different abstraction levels. The concerns
    your web browser has with formatting a web page are much different than the concerns
    your router has with forwarding network packets. For this reason, it is useful
    to have a theoretical model that helps us to understand communications at these
    different levels of abstraction. Let's look at these models now.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 网络涵盖了多个不同抽象层次的关注点。你的网络浏览器在格式化网页时的关注点与你的路由器在转发网络数据包时的关注点大不相同。因此，有一个理论模型帮助我们理解这些不同抽象层次上的通信是有用的。现在让我们看看这些模型。
- en: OSI layer model
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OSI层模型
- en: It's clear that if all of the disparate devices composing the internet are going
    to communicate seamlessly, there must be agreed-upon standards that define their
    communications. These standards are called **protocols**. Protocols define everything
    from the voltage levels on an Ethernet cable to how a JPEG image is compressed
    on a web page. It's clear that, when we talk about the voltage on an Ethernet
    cable, we are at a much different level of abstraction compared to talking about
    the JPEG image format. If you're programming a website, you don't want to think
    about Ethernet cables or Wi-Fi frequencies. Likewise, if you're programming an
    internet router, you don't want to have to worry about how JPEG images are compressed.
    For this reason, we break the problem down into many smaller pieces.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，如果构成互联网的所有不同设备都要无缝通信，那么必须有一套定义它们通信的标准。这些标准被称为**协议**。协议定义了从以太网电缆上的电压级别到网页上JPEG图像的压缩方式等所有内容。很明显，当我们谈论以太网电缆上的电压时，我们处于一个与谈论JPEG图像格式完全不同的抽象层次。如果你正在编写一个网站，你不想去考虑以太网电缆或Wi-Fi频率。同样，如果你正在编写一个互联网路由器，你也不想担心JPEG图像是如何压缩的。因此，我们将问题分解成许多更小的部分。
- en: One common method of breaking down the problem is to place levels of concern
    into layers. Each layer then provides services for the layer on top of it, and
    each upper layer can rely on the layers underneath it without concern for how
    they work.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 分解问题的常见方法是将关注层次放入层中。每一层随后为它上面的层提供服务，并且每一上层都可以依赖下面的层，而不必担心它们是如何工作的。
- en: 'The most popular layer system for networking is called the **Open Systems Interconnection**
    model (**OSI** model). It was standardized in 1977 and is published as ISO 7498\.
    It has seven layers:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 网络中最流行的层系统被称为**开放系统互联**模型（**OSI**模型）。它在1977年标准化，并作为ISO 7498发布。它有七个层次：
- en: '![](img/a5983503-0eb0-4276-a5b8-4835308429ba.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a5983503-0eb0-4276-a5b8-4835308429ba.png)'
- en: 'Let''s understand these layers one by one:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个了解这些层：
- en: '**Physical** (1): This is the level of physical communication in the real world. 
    At this level, we have specifications for things such as the voltage levels on
    an Ethernet cable, what each pin on a connector is for, the radio frequency of
    Wi-Fi, and the light flashes over an optic fiber.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**物理**（1）：这是现实世界中物理通信的层次。在这个层次上，我们有关于诸如以太网电缆上的电压级别、连接器上每个引脚的用途、Wi-Fi的无线电频率以及光纤上的光闪烁等事物的规范。'
- en: '**Data Link** (2): This level builds on the physical layer. It deals with protocols
    for directly communicating between two nodes. It defines how a direct message
    between nodes starts and ends (framing), error detection and correction, and flow
    control.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据链路**（2）：这个层次建立在物理层之上。它处理两个节点之间直接通信的协议。它定义了节点之间直接消息的开始和结束（帧定界），错误检测和纠正，以及流量控制。'
- en: '**Network layer** (3): The network layer provides the methods to transmit data
    sequences (called packets) between nodes in different networks. It provides methods
    to route packets from one node to another (without a direct physical connection)
    by transferring through many intermediate nodes. This is the layer that the Internet
    Protocol is defined on, which we will go into in some depth later.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络层** (3)：网络层提供在不同网络节点之间传输数据序列（称为数据包）的方法。它提供方法通过许多中间节点将数据包从一个节点路由到另一个节点（无需直接物理连接）。这是定义互联网协议的层，我们将在稍后深入探讨。'
- en: '**Transport layer** (4): At this layer, we have methods to reliably deliver
    variable length data between hosts. These methods deal with splitting up data,
    recombining it, ensuring data arrives in order, and so on. The **Transmission
    Control Protocol** (**TCP**) and **User Datagram Protocol** (**UDP**) are commonly
    said to exist on this layer.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传输层** (4)：在这一层，我们有方法在主机之间可靠地传输可变长度的数据。这些方法涉及分割数据、重新组合数据、确保数据按顺序到达等。通常说**传输控制协议**（**TCP**）和**用户数据报协议**（**UDP**）存在于这一层。'
- en: '**Session layer** (5): This layer builds on the transport layer by adding methods
    to establish, checkpoint, suspend, resume, and terminate dialogs.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**会话层** (5)：这一层通过添加建立、检查点、暂停、恢复和终止对话的方法来构建在传输层之上。'
- en: '**Presentation layer** (6): This is the lowest layer at which data structure
    and presentation for an application are defined. Concerns such as data encoding,
    serialization, and encryption are handled here.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表示层** (6)：这是定义应用程序数据结构和表示的最低层。在此层处理诸如数据编码、序列化和加密等问题。'
- en: '**Application layer** (7): The applications that the user interfaces with (for
    example, web browsers and email clients) exist here. These applications make use
    of the services provided by the six lower layers.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用层** (7)：用户界面中的应用程序（例如，网页浏览器和电子邮件客户端）存在于这里。这些应用程序利用了下面六层提供的服务。'
- en: 'In the OSI model, an application, such as a web browser, exists in the application
    layer (layer 7). A protocol from this layer, such as HTTP used to transmit web
    pages, doesn''t have to concern itself with how the data is being transmitted.
    It can rely on services provided by the layer underneath it to effectively transmit
    data. This is illustrated in the following diagram:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在OSI模型中，一个应用程序，例如网页浏览器，存在于应用层（第7层）。该层的一个协议，如用于传输网页的HTTP，不必关心数据是如何传输的。它可以依赖其下层的服务来有效地传输数据。这在下图中得到了说明：
- en: '![](img/49fd2d62-6291-4571-b457-f819a74ade79.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/49fd2d62-6291-4571-b457-f819a74ade79.png)'
- en: It should be noted that chunks of data are often referred to by different names
    depending on the OSI layer they're on. A data unit on layer 2 is called a **frame**, since
    layer 2 is responsible for framing messages. A data unit on layer 3 is referred
    to as a **packet**, while a data unit on layer 4 is a **segment** if it is part
    of a TCP connection or a **datagram** if it is a UDP message.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，根据OSI层不同，数据块通常有不同的名称。第2层的数据单元称为**帧**，因为第2层负责消息封装。第3层的数据单元被称为**数据包**，而第4层的数据单元如果是TCP连接的一部分，则称为**段**；如果是UDP消息，则称为**数据报**。
- en: In this book, we often use the term packet as a generic term to refer to a data
    unit on any layer. However, segment will only be used in the context of a TCP
    connection, and datagram will only refer to UDP datagrams.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们经常使用术语“数据包”作为任何层的数据单元的通用术语。然而，“段”一词仅用于TCP连接的上下文中，而“数据报”仅指UDP数据报。
- en: As we will see in the next section, the OSI model doesn't fit precisely with
    the common protocols in use today. However, it is still a handy model to explain
    networking concerns, and it is still in widespread use for that purpose today.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在下一节中将要看到的，OSI模型并不完全符合今天常用的协议。然而，它仍然是一个方便的模型来解释网络问题，并且今天它仍然被广泛用于这个目的。
- en: TCP/IP layer model
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP/IP层模型
- en: The **TCP/IP protocol suite** is the most common network communication model
    in use today. The TCP/IP reference model differs a bit from the OSI model, as
    it has only four layers instead of seven.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**TCP/IP协议族** 是目前最常用的网络通信模型。TCP/IP参考模型与OSI模型略有不同，因为它只有四层而不是七层。'
- en: 'The following diagram illustrates how the four layers of the TCP/IP model line
    up to the seven layers of the OSI model:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 下图说明了TCP/IP模型的四层如何与OSI模型的七层相对应：
- en: '![](img/5a4d69f7-1019-4835-8f1c-c855c13b9fdd.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5a4d69f7-1019-4835-8f1c-c855c13b9fdd.png)'
- en: Notably, the TCP/IP model doesn't match up exactly with the layers in the OSI
    model. That's OK. In both models, the same functions are performed; they are just
    divided differently.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，TCP/IP模型与OSI模型中的层并不完全匹配。这没关系。在这两个模型中，执行相同的函数；只是划分方式不同。
- en: The TCP/IP reference model was developed after the TCP/IP protocol was already
    in common use. It differs from the OSI model by subscribing a less rigid, although
    still hierarchical, model. For this reason, the OSI model is sometimes better
    for understanding and reasoning about networking concerns, but the TCP/IP model
    reflects a more realistic view of how networking is commonly implemented today.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP参考模型是在TCP/IP协议已经普遍使用之后开发的。它通过采用一个不那么严格但仍然分层的模型与OSI模型不同。因此，OSI模型有时更适合理解和推理网络问题，但TCP/IP模型反映了今天网络通常实施的一个更现实的视角。
- en: 'The four layers of the TCP/IP model are as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP模型的四层如下：
- en: '**Network Access layer **(1): On this layer, physical connections and data
    framing happen. Sending an Ethernet or Wi-Fi packet are examples of layer 1 concerns.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络访问层（1）**：在这一层，发生物理连接和数据帧定界。发送以太网或Wi-Fi数据包是这一层关注的问题的例子。'
- en: '**Internet layer **(2): This layer deals with the concerns of addressing packets
    and routing them over multiple interconnection networks. It''s at this layer that
    an IP address is defined.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**互联网层（2）**：这一层处理地址分组和通过多个互连网络路由分组的问题。在这一层定义了IP地址。'
- en: '**Host-to-Host layer **(3): The host-to-host layer provides two protocols,
    TCP and UDP, which we will discuss in the next few chapters. These protocols address
    concerns such as data order, data segmentation, network congestion, and error
    correction.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主机到主机层（3）**：主机到主机层提供了TCP和UDP两种协议，我们将在下一章中讨论。这些协议解决数据顺序、数据分段、网络拥塞和错误纠正等问题。'
- en: '**Process/Application layer **(4): The process/application layer is where protocols
    such as HTTP, SMTP, and FTP are implemented. Most of the programs that feature
    in this book could be considered to take place on this layer while consuming functionality
    provided by our operating system''s implementation of the lower layers.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进程/应用层（4）**：进程/应用层是HTTP、SMTP和FTP等协议实现的地方。本书中大多数程序都可以被认为是发生在这一层，同时消耗操作系统对低层实现的提供的功能。'
- en: Regardless of your chosen abstraction model, real-world protocols do work at
    many levels. Lower levels are responsible for handling data for the higher levels.
    These lower-level data structures must, therefore, encapsulate data from the higher
    levels. Let's look at encapsulating data now.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择哪种抽象模型，现实世界的协议确实在许多层面上工作。低层负责处理高层的数据。因此，这些低级数据结构必须封装来自高层的数據。现在让我们看看如何封装数据。
- en: Data encapsulation
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据封装
- en: The advantage of these abstractions is that, when programming an application,
    we only need to consider the highest-level protocol. For example, a web browser
    needs only to implement the protocols dealing specifically with websites—HTTP,
    HTML, CSS, and so on. It does not need to bother with implementing TCP/IP, and
    it certainly doesn't have to understand how an Ethernet or Wi-Fi packet is encoded.
    It can rely on ready-made implementations of the lower layers for these tasks.
    These implementations are provided by the operating system (for example, Windows,
    Linux, and macOS).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这些抽象的优势在于，在编写应用程序时，我们只需要考虑最高层协议。例如，一个网页浏览器只需要实现专门处理网站的协议——HTTP、HTML、CSS等。它不需要担心实现TCP/IP，当然也不必理解以太网或Wi-Fi数据包是如何编码的。它可以依赖低层为这些任务提供的现成实现。这些实现由操作系统（例如Windows、Linux和macOS）提供。
- en: 'When communicating over a network, data must be processed down through the
    layers at the sender and up again through the layers at the receiver. For example,
    if we have a web server, **Host A**, which is transmitting a web page to the receiver,
    **Host B**, it may look like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过网络进行通信时，数据必须在发送方的各层中进行处理，然后再在接收方的各层中重新进行。例如，如果我们有一个网页服务器，**主机A**，它正在向接收方，**主机B**，传输网页，它可能看起来像这样：
- en: '![](img/93381b7b-baf3-4699-88f3-45847f1dc0a1.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/93381b7b-baf3-4699-88f3-45847f1dc0a1.png)'
- en: 'The web page contains a few paragraphs of text, but the web server doesn''t
    only send the text by itself. For the text to be rendered correctly, it must be
    encoded in an **HTML** structure:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 网页包含几段文本，但网页服务器并不仅仅发送文本本身。为了正确渲染文本，它必须被编码在**HTML**结构中：
- en: '![](img/8b9ec5f2-f84f-4588-a8e9-0c79cb25d6ad.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8b9ec5f2-f84f-4588-a8e9-0c79cb25d6ad.png)'
- en: 'In some cases, the text is already preformatted into **HTML** and saved that
    way but, in this example, we are considering a web application that dynamically
    generates the **HTML**, which is the most common paradigm for dynamic web pages.
    As the text cannot be transmitted directly, neither can the **HTML**. It instead
    must be transmitted as part of an **HTTP** response. The web server does this
    by applying the appropriate **HTTP** response header to the **HTML**:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，文本已经预先格式化为 **HTML** 并以这种方式保存，但在这个例子中，我们正在考虑一个动态生成 **HTML** 的 Web 应用程序，这是动态网页最常见的方法。由于文本不能直接传输，**HTML**
    也不能直接传输。它必须作为 **HTTP** 响应的一部分进行传输。Web 服务器通过将适当的 **HTTP** 响应头应用到 **HTML** 上来完成这项工作：
- en: '![](img/5b4e3058-17d7-4e6d-aac7-7f4a3026a81c.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5b4e3058-17d7-4e6d-aac7-7f4a3026a81c.png)'
- en: 'The **HTTP** is transmitted as part of a **TCP** session. This isn''t done
    explicitly by the web server, but is taken care of by the operating system''s
    TCP/IP stack:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**HTTP** 作为 **TCP** 会话的一部分进行传输。这不是由 Web 服务器显式完成的，而是由操作系统的 TCP/IP 堆栈处理的：'
- en: '![](img/36489bba-e9f0-45eb-8540-7062f5601b6e.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/36489bba-e9f0-45eb-8540-7062f5601b6e.png)'
- en: 'The **TCP** packet is routed by an **IP** packet:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**TCP** 数据包由 **IP** 数据包路由：'
- en: '![](img/fa770b2a-75de-4d97-9288-b55d2512eb0e.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fa770b2a-75de-4d97-9288-b55d2512eb0e.png)'
- en: 'This is transmitted over the wire in an **Ethernet** packet (or another protocol):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过以太网数据包（或其他协议）在网络上传输：
- en: '![](img/1e6ffefb-650e-4729-a81a-3d3e4ecbbff5.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1e6ffefb-650e-4729-a81a-3d3e4ecbbff5.png)'
- en: Luckily for us, the lower-level concerns are handled automatically when we use
    the socket APIs for network programming. It is still useful to know what happens
    behind the scenes. Without this knowledge, dealing with failures or optimizing
    for performance is difficult if not impossible.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，当我们使用套接字 API 进行网络编程时，低级问题会自动处理。了解幕后发生的事情仍然很有用。如果没有这些知识，处理故障或优化性能将是困难的，如果不是不可能的。
- en: With some of the theory out of the way, let's dive into the actual protocols
    powering modern networking.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在理论部分介绍完毕后，让我们深入了解推动现代网络的实际协议。
- en: Internet Protocol
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互联网协议
- en: Twenty years ago, there were many competing networking protocols. Today, one
    protocol is overwhelmingly common—the Internet Protocol. It comes in two versions—IPv4
    and IPv6\. IPv4 is completely ubiquitous and deployed everywhere. If you're deploying
    network code today, you must support IPv4 or risk that a significant portion of
    your users won't be able to connect.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 二十年前，有许多相互竞争的网络协议。今天，一个协议非常普遍——互联网协议。它有两个版本——IPv4 和 IPv6。IPv4 完全无处不在，到处都有部署。如果你今天正在部署网络代码，你必须支持
    IPv4，否则可能会有一大部分用户无法连接。
- en: IPv4 uses 32-bit addresses, which limits it to addressing no more than 2^(32)
    or 4,294,967,296 systems. However, these 4.3 billion addresses were not initially
    assigned efficiently, and now many **Internet Service Providers** (**ISPs**) are
    forced to ration IPv4 addresses.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4 使用 32 位地址，这限制了它最多只能地址 2^(32) 或 4,294,967,296 个系统。然而，这 43 亿个地址最初并没有被有效地分配，现在许多
    **互联网服务提供商**（**ISPs**）被迫配给 IPv4 地址。
- en: IPv6 was designed to replace IPv4 and has been standardized by the **Internet
    Engineering Task Force** (**IETF**) since 1998\. It uses a 128-bit address, which
    allows it to address a theoretical 2^(128) = 340,282,366,920,938,463,463,374,607,431,768,211,456,
    or about a 3.4 x 10^(38) addresses.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6 被设计用来取代 IPv4，自 1998 年以来已被互联网工程任务组（**IETF**）标准化。它使用 128 位地址，这使得它可以地址理论上的
    2^(128) = 340,282,366,920,938,463,463,374,607,431,768,211,456，或大约 3.4 x 10^(38)
    个地址。
- en: Today, every major desktop and smartphone operating system supports both IPv4
    and IPv6 in what is called a **dual-stack configuration**. However, many applications,
    servers, and networks are still only configured to use IPv4\. From a practical
    standpoint, this means that you need to support IPv4 in order to access much of
    the internet. However, you should also support IPv6 to be future-proof and to
    help the world to transition away from IPv4.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，每个主要的桌面和智能手机操作系统都支持 IPv4 和 IPv6，这被称为 **双栈配置**。然而，许多应用程序、服务器和网络仍然只配置为使用 IPv4。从实际的角度来看，这意味着你需要支持
    IPv4 才能访问互联网的大部分内容。然而，你也应该支持 IPv6 以确保未来兼容性，并帮助世界过渡到 IPv4。
- en: What is an address?
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是地址？
- en: All Internet Protocol traffic routes to an address. This is similar to how phone
    calls must be dialed to phone numbers. IPv4 addresses are 32 bits long. They are
    commonly divided into four 8-bit sections. Each section is displayed as a decimal
    number between `0` and `255` inclusive and is delineated by a period.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 所有互联网协议流量都会路由到某个地址。这类似于电话通话必须拨打电话号码。IPv4 地址长度为 32 位。它们通常分为四个 8 位部分。每个部分显示为一个介于
    `0` 和 `255` 之间的十进制数，并由点分隔。
- en: 'Here are some examples of IPv4 addresses:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些 IPv4 地址的示例：
- en: '`0.0.0.0`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0.0.0.0`'
- en: '`127.0.0.1`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`127.0.0.1`'
- en: '`10.0.0.0`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`10.0.0.0`'
- en: '`172.16.0.5`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`172.16.0.5`'
- en: '`192.168.0.1`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`192.168.0.1`'
- en: '`192.168.50.1`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`192.168.50.1`'
- en: '`255.255.255.255`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`255.255.255.255`'
- en: A special address, called the **loopback** address, is reserved at `127.0.0.1`.
    This address essentially means *establish a connection to myself*. Operating systems
    short-circuit this address so that packets to it never enter the network but instead
    stay local on the originating system.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特殊地址，称为 **环回** 地址，被预留于 `127.0.0.1`。这个地址实际上意味着 *建立到自己的连接*。操作系统会短路这个地址，使得发送到该地址的数据包永远不会进入网络，而是保持在源系统上本地。
- en: 'IPv4 reserves some address ranges for private use. If you''re using IPv4 through
    a router/NAT, then you are likely using an IP address in one of these ranges.
    These reserved private ranges are as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4 为私有用途预留了一些地址范围。如果你通过路由器/NAT 使用 IPv4，那么你很可能正在使用这些范围之一中的 IP 地址。这些预留的私有范围如下：
- en: '`10.0.0.0` to `10.255.255.255`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`10.0.0.0` 至 `10.255.255.255`'
- en: '`172.16.0.0` to `172.31.255.255`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`172.16.0.0` 至 `172.31.255.255`'
- en: '`192.168.0.0` to `192.168.255.255`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`192.168.0.0` 至 `192.168.255.255`'
- en: 'The concept of IP address ranges is a useful one that comes up many times in
    networking. It''s probably not surprising then that there is a shorthand notation
    for writing them. Using **Classless Inter-Domain Routing** (**CIDR**)notation,
    we can write the three previous address ranges as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: IP 地址范围的概念在计算机网络中非常有用，经常出现。因此，存在一种简写表示法来书写它们。使用 **无类别域间路由**（**CIDR**）表示法，我们可以将前面提到的三个地址范围写成以下形式：
- en: '`10.0.0.0/8`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`10.0.0.0/8`'
- en: '`172.16.0.0/12`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`172.16.0.0/12`'
- en: '`192.168.0.0/16`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`192.168.0.0/16`'
- en: CIDR notation works by specifying the number of bits that are fixed. For example, `10.0.0.0/8`
    specifies that the first eight bits of the `10.0.0.0` address are fixed, the first
    eight bits being just the first `10.` part; the remaining `0.0.0` part of the
    address can be anything and still be on the `10.0.0.0/8` block. Therefore, `10.0.0.0/8`
    encompasses `10.0.0.0` through `10.255.255.255`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: CIDR 表示法通过指定固定位的数量来工作。例如，`10.0.0.0/8` 指定 `10.0.0.0` 地址的前八个位是固定的，前八个位仅仅是第一个 `10.`
    部分；地址的剩余 `0.0.0` 部分可以是任何东西，仍然位于 `10.0.0.0/8` 块中。因此，`10.0.0.0/8` 包括从 `10.0.0.0`
    到 `10.255.255.255`。
- en: 'IPv6 addresses are 128 bits long. They are written as eight groups of four
    hexadecimal characters delineated by colons. A hexadecimal character can be from
    0-9 or from a-f. Here are some examples of IPv6 addresses:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6 地址长度为 128 位。它们以八个由冒号分隔的四位十六进制字符组成。十六进制字符可以是 0-9 或 a-f。以下是一些 IPv6 地址的示例：
- en: '`0000:0000:0000:0000:0000:0000:0000:0001`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0000:0000:0000:0000:0000:0000:0000:0001`'
- en: '`2001:0db8:0000:0000:0000:ff00:0042:8329`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2001:0db8:0000:0000:0000:ff00:0042:8329`'
- en: '`fe80:0000:0000:0000:75f4:ac69:5fa7:67f9`'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fe80:0000:0000:0000:75f4:ac69:5fa7:67f9`'
- en: '`ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff`'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff`'
- en: Note that the standard is to use lowercase letters in IPv6 addresses. This is
    in contrast to many other uses of hexadecimal in computers.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，IPv6 地址的标准是使用小写字母。这与计算机中许多其他十六进制用法形成对比。
- en: There are a couple of rules for shortening IPv6 addresses to make them easier.
    Rule 1 allows for the leading zeros in each section to be omitted (for example,
    `0db8` = `db8`). Rule 2 allows for consecutive sections of zeros to be replaced
    with a double colon (`::`). Rule 2 may only be used once in each address; otherwise,
    the address would be ambiguous.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有几条规则可以缩短 IPv6 地址，使其更容易使用。规则 1 允许省略每个部分前面的零（例如，`0db8` = `db8`）。规则 2 允许用双冒号（`::`）替换连续的零部分。规则
    2 在每个地址中只能使用一次；否则，地址将是模糊的。
- en: 'Applying both rules, the preceding addresses can be shortened as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 应用这两个规则，前面的地址可以缩短如下：
- en: '`::1`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`::1`'
- en: '`2001:db8::ff00:42:8329`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2001:db8::ff00:42:8329`'
- en: '`fe80::75f4:ac69:5fa7:67f9`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fe80::75f4:ac69:5fa7:67f9`'
- en: '`ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff`'
- en: Like IPv4, IPv6 also has a loopback address. It is `::1`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 与 IPv4 类似，IPv6 也有一个环回地址。它是 `::1`。
- en: Dual-stack implementations also recognize a special class of IPv6 address that
    map directly to an IPv4 address. These reserved addresses start with 80 zero bits,
    and then by 16 one bits, followed by the 32-bit IPv4 address. Using CIDR notation,
    this block of address is `::ffff:0:0/96`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 双栈实现还识别一类可以直接映射到IPv4地址的特殊IPv6地址。这些保留地址以80个零位开头，然后是16个一位，接着是32位的IPv4地址。使用CIDR表示法，这个地址块是`::ffff:0:0/96`。
- en: 'These mapped addresses are commonly written with the first 96 bits in IPv6
    format followed by the remaining 32 bits in IPv4 format. Here are some examples:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这些映射地址通常以IPv6格式的前96位开头，然后是IPv4格式的剩余32位。以下是一些示例：
- en: '| **IPv6 Address** | **Mapped IPv4 Address** |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| **IPv6地址** | **映射的IPv4地址** |'
- en: '| `::ffff:10.0.0.0` | `10.0.0.0` |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `::ffff:10.0.0.0` | `10.0.0.0` |'
- en: '| `::ffff:172.16.0.5` | `172.16.0.5` |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `::ffff:172.16.0.5` | `172.16.0.5` |'
- en: '| `::ffff:192.168.0.1 ` | `192.168.0.1` |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `::ffff:192.168.0.1 ` | `192.168.0.1` |'
- en: '| `::ffff:192.168.50.1` | `192.168.50.1` |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `::ffff:192.168.50.1` | `192.168.50.1` |'
- en: You may also run into IPv6 **site-local addresses**. These site-local addresses
    are in the `fec0::/10` range and are for use on private local networks. Site-local
    addresses have now been deprecated and should not be used for new networks, but
    many existing implementations still use them.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可能遇到IPv6 **站点本地地址**。这些站点本地地址位于`fec0::/10`范围内，用于私有本地网络。站点本地地址现在已经过时，不应用于新的网络，但许多现有的实现仍在使用它们。
- en: Another address type that you should be familiar with are **link-local addresses**.
    Link-local addresses are usable only on the local link. Routers never forward
    packets from these addresses. They are useful for a system to accesses auto-configuration
    functions before having an assigned IP address. Link-local addresses are in the
    IPv4 `169.254.0.0/16` address block or the IPv6 `fe80::/10` address block.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您还应该熟悉另一种地址类型，即**链路本地地址**。链路本地地址只能在本地链路上使用。路由器从不转发来自这些地址的数据包。它们对于系统在分配IP地址之前访问自动配置功能是有用的。链路本地地址位于IPv4的`169.254.0.0/16`地址块或IPv6的`fe80::/10`地址块。
- en: It should be noted the IPv6 introduces many additional features over IPv4 besides
    just a greatly expanded address range. IPv6 addresses have new attributes, such
    as scope and lifetime, and it is normal for IPv6 network interfaces to have multiple
    IPv6 addresses. IPv6 addresses are used and managed differently than IPv4 addresses.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，IPv6除了地址范围大大扩展之外，还引入了许多IPv4没有的新特性。IPv6地址有新的属性，如作用域和生存期，IPv6网络接口通常具有多个IPv6地址是正常的。IPv6地址的使用和管理与IPv4地址不同。
- en: Regardless of these differences, in this book, we strive to write code that
    works well for both IPv4 and IPv6.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 不论这些差异如何，在这本书中，我们努力编写适用于IPv4和IPv6都表现良好的代码。
- en: If you think that IPv4 addresses are difficult to memorize, and IPv6 addresses
    impossible, then you are not alone. Luckily, we have a system to assign names
    to specific addresses.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您认为IPv4地址难以记忆，IPv6地址则几乎不可能记忆，那么您并不孤单。幸运的是，我们有一个系统来为特定地址分配名称。
- en: Domain names
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 域名
- en: The Internet Protocol can only route packets to an IP address, not a name. So,
    if you try to connect to a website, such as `example.com`, your system must first
    resolve that domain name, `example.com`, into an IP address for the server that
    hosts that website.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网协议只能将数据包路由到IP地址，而不是名称。因此，如果您尝试连接到网站，例如`example.com`，则您的系统必须首先将那个域名`example.com`解析为托管该网站的服务器的IP地址。
- en: This is done by connecting to a **Domain Name System** (**DNS**) server. You
    connect to a domain name server by knowing in advance its IP address. The IP address
    for a domain name server is usually assigned by your ISP.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过连接到一个**域名系统**（**DNS**）服务器来实现的。您通过事先知道其IP地址来连接到域名服务器。域名服务器的IP地址通常由您的ISP分配。
- en: 'Many other domain name servers are made publicly available by different organizations.
    Here are a few free and public DNS servers:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 许多其他域名服务器由不同的组织公开提供。以下是一些免费和公开的DNS服务器：
- en: '| **DNS Provider** | **IPv4 Addresses** | **IPv6 Addresses** |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| **DNS提供商** | **IPv4地址** | **IPv6地址** |'
- en: '| Cloudflare 1.1.1.1 | `1.1.1.1` | `2606:4700:4700::1111` |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| Cloudflare 1.1.1.1 | `1.1.1.1` | `2606:4700:4700::1111` |'
- en: '|  | `1.0.0.1` | `2606:4700:4700::1001` |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '|  | `1.0.0.1` | `2606:4700:4700::1001` |'
- en: '| FreeDNS | `37.235.1.174` |  |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| FreeDNS | `37.235.1.174` |  |'
- en: '|  | `37.235.1.177` |  |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '|  | `37.235.1.177` |  |'
- en: '| Google Public DNS | `8.8.8.8` | `2001:4860:4860::8888` |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| Google Public DNS | `8.8.8.8` | `2001:4860:4860::8888` |'
- en: '|  | `8.8.4.4` | `2001:4860:4860::8844` |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '|  | `8.8.4.4` | `2001:4860:4860::8844` |'
- en: '| OpenDNS | `208.67.222.222` | `2620:0:ccc::2` |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| OpenDNS | `208.67.222.222` | `2620:0:ccc::2` |'
- en: '|  | `208.67.220.220` | `2620:0:ccd::2` |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '|  | `208.67.220.220` | `2620:0:ccd::2` |'
- en: To resolve a hostname, your computer sends a UDP message to your domain name
    server and asks it for an AAAA-type record for the domain you're trying to resolve.
    If this record exists, an IPv6 address is returned. You can then connect to a
    server at that address to load the website. If no AAAA record exists, then your
    computer queries the server again, but asks for an A record. If this record exists,
    you will receive an IPv4 address for the server. In many cases, a site will publish
    an A record and an AAAA record that route to the same server.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解析主机名，你的计算机向你的域名服务器发送一个UDP消息，并请求为你正在尝试解析的域名获取一个AAAA类型的记录。如果此记录存在，则会返回一个IPv6地址。然后你可以连接到该地址的服务器以加载网站。如果没有AAAA记录，则你的计算机再次查询服务器，但请求一个A记录。如果此记录存在，你将收到服务器的IPv4地址。在许多情况下，网站将发布一个A记录和一个AAAA记录，它们都路由到同一服务器。
- en: It is also possible, and common, for multiple records of the same type to exist,
    each pointing to a different address. This is useful for redundancy in the case
    where multiple servers can provide the same service.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 同样可能且常见的是存在多个相同类型的记录，每个记录指向不同的地址。这在多个服务器可以提供相同服务的情况下，用于冗余。
- en: We will see a lot more about DNS queries in [Chapter 5](3d80e3b8-07d3-49f4-b60f-b006a17f7213.xhtml),
    *Hostname Resolution and DNS*.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第五章](3d80e3b8-07d3-49f4-b60f-b006a17f7213.xhtml)中看到更多关于DNS查询的内容，*主机名解析和DNS*。
- en: Now that we have a basic understanding of IP addresses and names, let's look
    into detail of how IP packets are routed over the internet.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对IP地址和名称有了基本的了解，让我们详细了解一下IP数据包如何在互联网上路由。
- en: Internet routing
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互联网路由
- en: 'If all networks contained only a maximum of only two devices, then there would
    be no need for routing. Computer A would just send its data directly over the
    wire, and computer B would receive it as the only possibility:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有网络中只包含最多两个设备，那么就无需进行路由。计算机A只需直接通过电线发送其数据，而计算机B将作为唯一可能性接收它：
- en: '![](img/32930107-6a9e-4bdb-ae88-8c66d3c14545.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/32930107-6a9e-4bdb-ae88-8c66d3c14545.png)'
- en: 'The internet today has an estimated 20 billion devices connected. When you
    make a connection over the internet, your data first transmits to your local router.
    From there, it is transmitted to another router, which is connected to another
    router, and so on. Eventually, your data reaches a router that is connected to
    the receiving device, at which point, the data has reached its destination:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的互联网估计有200亿台设备连接。当你通过互联网建立连接时，你的数据首先传输到你的本地路由器。从那里，它被传输到另一个路由器，该路由器连接到另一个路由器，以此类推。最终，你的数据到达一个连接到接收设备的路由器，此时，数据已到达目的地：
- en: '![](img/b0c23825-cf53-4fe8-a7e6-66a397b1026b.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b0c23825-cf53-4fe8-a7e6-66a397b1026b.png)'
- en: Imagine that each router in the preceding diagram is connected to tens, hundreds,
    or even thousands of other routers and systems. It's an amazing feat that IP can
    discover the correct path and deliver traffic seamlessly.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，前面图中的每个路由器都连接到成百上千个其他路由器和系统。IP能够发现正确的路径并无缝地传输流量，这是一个惊人的成就。
- en: Windows includes a utility, `tracert`, which lists the routers between your
    system and the destination system.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Windows包括一个名为`tracert`的实用程序，它列出了你的系统和目标系统之间的路由器。
- en: 'Here is an example of using the `tracert` command on Windows 10 to trace the
    route to `example.com`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个使用Windows 10上的`tracert`命令追踪到`example.com`路由的示例：
- en: '![](img/729100fb-3aad-4bc4-96f9-8b1c72adbab9.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/729100fb-3aad-4bc4-96f9-8b1c72adbab9.png)'
- en: As you can see from the example, there are 11 hops between our system and the
    destination system (`example.com`, `93.184.216.34`). The IP addresses are listed
    for many of these intermediate routers, but a few are missing with the `Request
    timed out` message. This usually means that the system in question doesn't support
    the part of the **Internet Control Message Protocol** (**ICMP**) protocol needed.
    It's not unusual to see a few such systems when running `tracert`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如示例所示，我们的系统和目标系统（`example.com`，`93.184.216.34`）之间有11个跳数。列出了许多这些中间路由器的IP地址，但有一些由于`Request
    timed out`消息而缺失。这通常意味着相关的系统不支持**互联网控制消息协议**（**ICMP**）协议的一部分。在运行`tracert`时看到几个这样的系统并不罕见。
- en: In Unix-based systems, the utility to trace routes is called `traceroute`. You
    would use it like `traceroute example.com`, for example, but the information obtained
    is essentially the same.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于Unix的系统上，追踪路由的实用程序称为`traceroute`。例如，你会使用`traceroute example.com`，但获得的信息基本上是相同的。
- en: More information on `tracert` and `traceroute` can be found in [Chapter 12](1d616e6f-d234-4269-8507-f007ffc1b7d0.xhtml), *Network
    Monitoring and Security*.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`tracert`和`traceroute`的更多信息可以在第12章找到，*网络监控和安全*。
- en: Sometimes, when IP packets are transferred between networks, their addresses
    must be translated. This is especially common when using IPv4\. Let's look at
    the mechanism for this next.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当IP数据包在网络之间传输时，它们的地址必须进行转换。这在使用IPv4时尤其常见。让我们看看这个机制的下一个部分。
- en: Local networks and address translation
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地网络和地址转换
- en: It's common for households and organizations to have small **Local Area Networks**
    (**LANs**). As mentioned previously, there are IPv4 addresses ranges reserved
    for use in these small local networks.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 家庭和组织通常会有小型的**局域网**（**LANs**）。如前所述，有一些IPv4地址范围是为这些小型本地网络预留的。
- en: 'These reserved private ranges are as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这些保留的私有范围如下：
- en: '`10.0.0.0` to `10.255.255.255`'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`10.0.0.0` 至 `10.255.255.255`'
- en: '`172.16.0.0` to `172.31.255.255`'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`172.16.0.0` 至 `172.31.255.255`'
- en: '`192.168.0.0` to `192.168.255.255`'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`192.168.0.0` 至 `192.168.255.255`'
- en: When a packet originates from a device on an IPv4 local network, it must undergo
    **Network Address Translation** (**NAT**) before being routed on the internet.
    A router that implements NAT remembers which local address a connection is established
    from.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个数据包从一个IPv4本地网络上的设备发出时，在它被路由到互联网之前，它必须经过**网络地址转换**（**NAT**）。实现NAT的路由器会记住连接是从哪个本地地址建立的。
- en: 'The devices on the same LAN can directly address one another by their local
    address. However, any traffic communicated to the internet must undergo address
    translation by the router. The router does this by modifying the source IP address
    from the original private LAN IP address to its public internet IP address:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 同一局域网上的设备可以直接通过它们的本地地址相互通信。然而，任何发送到互联网的流量都必须通过路由器进行地址转换。路由器通过修改原始私有局域网IP地址为它的公网IP地址来完成这项工作：
- en: '![](img/a6b13180-2f35-4f1e-bbfd-fa0788fb9402.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a6b13180-2f35-4f1e-bbfd-fa0788fb9402.png)'
- en: 'Likewise, when the router receives the return communication, it must modify
    the destination address from its public IP to the private IP of the original sender.
    It knows the private IP address because it was stored in memory after the first
    outgoing packet:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当路由器接收到回传通信时，它必须将目标地址从其公网IP修改为原始发送者的私有IP。因为它在第一次出站数据包后将其存储在内存中，所以它知道私有IP地址：
- en: '![](img/330aac07-6c97-4b92-a260-cb46dbbd8d5f.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/330aac07-6c97-4b92-a260-cb46dbbd8d5f.png)'
- en: Network address translation can be more complicated than it first appears. In
    addition to modifying the source IP address in the packet, it must also update
    the checksums in the packet. Otherwise, the packet would be detected as containing
    errors and discarded by the next router. The NAT router must also remember which
    private IP address sent the packet in order to route the reply. Without remembering
    the translation address, the NAT router wouldn't know where to send the reply
    to on the private network.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 网络地址转换可能比最初看起来更复杂。除了在数据包中修改源IP地址外，它还必须更新数据包中的校验和。否则，数据包会被检测为包含错误并被下一个路由器丢弃。NAT路由器还必须记住哪个私有IP地址发送了数据包，以便路由回复。如果没有记住转换地址，NAT路由器就不会知道在私有网络上将回复发送到何处。
- en: NATs will also modify the packet data in some cases. For example, in the **File
    Transfer Protocol** (**FTP**), some connection information is sent as part of
    the packet's data. In these cases, the NAT router will look at the packet's data
    in order to know how to forward future incoming packets. IPv6 largely avoids the
    need for NAT, as it is possible (and common) for each device to have its own publicly-addressable
    address.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: NAT在某些情况下也会修改数据包数据。例如，在**文件传输协议**（**FTP**）中，一些连接信息作为数据包数据的一部分发送。在这些情况下，NAT路由器将查看数据包数据，以便知道如何转发未来的入站数据包。IPv6在很大程度上避免了NAT的需求，因为每个设备都有自己的公开可寻址的地址，这是可能的（也是常见的）。
- en: You may be wondering how a router knows whether a message is locally deliverable
    or whether it must be forwarded. This is done using a netmask, subnet mask, or
    CIDR.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道路由器如何知道一条消息是本地可投递的还是必须转发。这是通过使用子网掩码、子网掩码或CIDR来完成的。
- en: Subnetting and CIDR
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子网划分和CIDR
- en: IP addresses can be split into parts. The most significant bits are used to
    identify the network or subnetwork, and the least significant bits are used to
    identify the specific device on the network.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: IP地址可以被分成几个部分。最重要的位用于标识网络或子网络，而最不重要的位用于标识网络上的特定设备。
- en: This is similar to how your home address can be split into parts. Your home
    address includes a house number, a street name, and a city. The city is analogous
    to the network part, the street name could be the subnetwork part, and your house
    number is the device part.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这与你的家庭地址可以被分割成部分的方式类似。你的家庭地址包括门牌号、街道名称和城市。城市相当于网络部分，街道名称可能是子网部分，而你的门牌号是设备部分。
- en: IPv4 traditionally uses a mask notation to identify the IP address parts. For
    example, consider a router on the `10.0.0.0` network with a subnet mask of `255.255.255.0`.
    This router can take any incoming packet and perform a bitwise `AND` operation
    with the subnet mask to determine whether the packet belongs on the local subnet
    or needs to be forwarded on. For example, this router receives a packet to be
    delivered to `10.0.0.105`. It does a bitwise `AND` operation on this address with
    the subnet mask of `255.255.255.0`, which produces `10.0.0.0`. That matches the
    subnet of the router, so the traffic is local. If, instead, we consider a packet
    destined for `10.0.15.22`, the result of the bitwise AND with the subnet mask
    is `10.0.15.0`. This address doesn't match the subnet the router is on, and so
    it must be forwarded.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4传统上使用掩码表示法来识别IP地址部分。例如，考虑一个位于`10.0.0.0`网络上的路由器，其子网掩码为`255.255.255.0`。这个路由器可以接收任何传入的数据包，并对其进行与子网掩码的位与操作，以确定数据包是否属于本地子网或需要转发。例如，这个路由器接收一个要发送到`10.0.0.105`的数据包。它对这个地址与子网掩码`255.255.255.0`进行位与操作，结果是`10.0.0.0`。这与路由器的子网匹配，所以流量是本地的。如果考虑一个目的地为`10.0.15.22`的数据包，与子网掩码进行位与操作的结果是`10.0.15.0`。这个地址不匹配路由器所在的子网，因此必须转发。
- en: IPv6 uses CIDR. Networks and subnetworks are specified using the CIDR notation
    we described earlier. For example, if the IPv6 subnet is `/112`, then the router
    knows that any address that matches on the first 112 bits is on the local subnet.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6使用CIDR。网络和子网使用我们之前描述的CIDR表示法指定。例如，如果IPv6子网是`/112`，那么路由器知道任何匹配前112位地址的地址都在本地子网上。
- en: So far, we've covered only routing with one sender and one receiver. While this
    is the most common situation, let's consider alternative cases too.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只讨论了只有一个发送者和一个接收者的路由。虽然这是最常见的情况，但让我们也考虑一下其他情况。
- en: Multicast, broadcast, and anycast
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组播、广播和单播
- en: When a packet is routed from one sender to one receiver, it uses **unicast**
    addressing. This is the simplest and most common type of addressing. All of the
    protocols we deal with in this book use unicast addressing.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个数据包从一个发送者路由到单个接收者时，它使用**单播**寻址。这是最简单也是最常见的一种寻址方式。本书中我们讨论的所有协议都使用单播寻址。
- en: '**Broadcast** addressing allows a single sender to address a packet to all
    recipients simultaneously. It is typically used to deliver a packet to every receiver
    on an entire subnet.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**广播**寻址允许单个发送者同时将数据包发送给所有接收者。它通常用于将数据包发送到整个子网上的每个接收者。'
- en: If a broadcast is a one-to-all communication, then **multicast** is a one-to-many
    communication. Multicast involves some group management, and a message is addressed
    and delivered to members of a group.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果广播是一对全的通信，那么**多播**就是一对多的通信。多播涉及一些群组管理，消息被寻址并发送给群组的成员。
- en: '**Anycast **addressed packets are used to deliver a message to one recipient
    when you don''t care who that recipient is. This is useful if you have several
    servers that provide the same functionality, and you simply want one of them (you
    don''t care which) to handle your request.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**任播**寻址的数据包用于在不关心接收者是谁的情况下将消息发送给一个接收者。如果你有多个提供相同功能的服务器，而你只想让其中一个（你不在乎是哪一个）处理你的请求，这很有用。'
- en: IPv4 and lower network levels support local broadcast addressing. IPv4 provides
    some optional (but commonly implemented) support for multicasting. IPv6 mandates
    multicasting support while providing additional features over IPv4's multicasting.
    Though IPv6 is not considered to broadcast, its multicasting functionality can
    essentially emulate it.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4和较低的网络层支持本地广播寻址。IPv4提供了一些可选（但通常实现）的多播支持。IPv6强制支持多播，同时提供了比IPv4多播更多的功能。尽管IPv6不被认为是广播，但其多播功能本质上可以模拟它。
- en: It's worth noting that these alternative addressing methods don't generally
    work over the broader internet. Imagine if one peer was able to broadcast a packet
    to every connected internet device. It would be a mess!
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，这些替代寻址方法通常不适用于更广泛的互联网。想象一下，如果有一个对等体能够向所有连接的互联网设备广播一个数据包，那将是一团糟！
- en: If you can use IP multicasting on your local network, though, it is worthwhile
    to implement it. Sending one IP level multicast conserves bandwidth compared to
    sending the same unicast message multiple times.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你可以在本地网络上使用IP多播，那么实现它是值得的。发送一个IP级别的多播消息比发送多次相同的单播消息节省带宽。
- en: However, multicasting is often done at the application level. That is, when
    the application wants to deliver the same message to several recipients, it sends
    the message multiple times – once to each recipient. In [Chapter 3](eb2e080f-fad2-4e14-b4c1-9a6c124df77c.xhtml), *An
    In-Depth Overview of TCP Connections*, we build a chat room. This chat room could
    be said to use application-level multicasting, but it does not take advantage
    of IP multicasting.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，多播通常在应用层进行。也就是说，当应用程序想要将相同的信息发送给多个接收者时，它会多次发送消息——一次发送给每个接收者。在第3章中，*TCP连接的深入概述*，我们构建了一个聊天室。这个聊天室可以说使用了应用层多播，但它没有利用IP多播。
- en: We've covered how messages are routed through a network. Now, let's see how
    a message knows which application is responsible for it once it arrives at a specific
    system.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了消息如何在网络中路由。现在，让我们看看消息到达特定系统后，如何知道由哪个应用程序负责处理它。
- en: Port numbers
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 端口号
- en: An IP address alone isn't quite enough. We need port numbers. To return to the
    telephone analogy, if IP addresses are phone numbers, then port numbers are like
    phone extensions.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 仅IP地址还不够。我们需要端口号。回到电话的比喻，如果IP地址是电话号码，那么端口号就像电话分机。
- en: Generally, an IP address gets a packet routed to a specific system, but a port
    number is used to route the packet to a specific application on that system.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个IP地址会将数据包路由到特定的系统，但端口号用于将数据包路由到该系统上的特定应用程序。
- en: For example, on your system, you may be running multiple web browsers, an email
    client, and a video-conferencing client. When your computer receives a TCP segment
    or UDP datagram, your operating system looks at the destination port number in
    that packet. That port number is used to look up which application should handle
    it.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在你的系统上，你可能正在运行多个网络浏览器、电子邮件客户端和视频会议客户端。当你的计算机接收到TCP段或UDP数据报时，操作系统会查看该数据包中的目标端口号。该端口号用于查找哪个应用程序应该处理它。
- en: Port numbers are stored as unsigned 16-bit integers. This means that they are
    between `0` and `65,535` inclusive.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 端口号存储为无符号16位整数。这意味着它们在`0`到`65,535`之间，包括这两个数。
- en: 'Some port numbers for common protocols are as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一些常见协议的端口号如下：
- en: '| **Port Number** |  | **Protocol** |  |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| **端口号** |  | **协议** |  |'
- en: '| `20`, `21` | TCP | **File Transfer Protocol** (**FTP**) |  |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `20`, `21` | TCP | **文件传输协议** (**FTP**) |  |'
- en: '| `22` | TCP | **Secure Shell** (**SSH**) | [Chapter 11](c9d0a1dc-878b-4961-825e-65688fac08ae.xhtml), *Establishing
    SSH Connections with libssh* |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `22` | TCP | **安全外壳** (**SSH**) | [第11章](c9d0a1dc-878b-4961-825e-65688fac08ae.xhtml)，*使用libssh建立SSH连接*
    |'
- en: '| `23` | TCP | **Telnet** |  |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `23` | TCP | **Telnet** |  |'
- en: '| `25` | TCP | **Simple Mail Transfer Protocol** (**SMTP**) | [Chapter 8](47e209f2-0231-418c-baef-82db74df8c29.xhtml), *Making
    Your Program Send Email* |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `25` | TCP | **简单邮件传输协议** (**SMTP**) | [第8章](47e209f2-0231-418c-baef-82db74df8c29.xhtml)，*让你的程序发送电子邮件*
    |'
- en: '| `53` | UDP | **Domain Name System** (**DNS**) | [Chapter 5](3d80e3b8-07d3-49f4-b60f-b006a17f7213.xhtml),
    *Hostname Resolution and DNS* |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `53` | UDP | **域名系统** (**DNS**) | [第5章](3d80e3b8-07d3-49f4-b60f-b006a17f7213.xhtml)，*主机名解析和DNS*
    |'
- en: '| `80` | TCP | **Hypertext Transfer Protocol** (**HTTP**) | [Chapter 6](de3d2e9b-b94e-47d1-872c-c2ecb34c4026.xhtml), *Building
    a Simple Web Client*[Chapter 7](f352830e-089c-4369-b7a2-18a896e1c5d5.xhtml), *Building
    a Simple Web Server* |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `80` | TCP | **超文本传输协议** (**HTTP**) | [第6章](de3d2e9b-b94e-47d1-872c-c2ecb34c4026.xhtml)，*构建简单的Web客户端*
    [第7章](f352830e-089c-4369-b7a2-18a896e1c5d5.xhtml)，*构建简单的Web服务器* |'
- en: '| `110` | TCP | **Post Office Protocol, Version 3** (**POP3**) |  |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `110` | TCP | **邮局协议第3版** (**POP3**) |  |'
- en: '| `143` | TCP | **Internet Message Access Protocol** (**IMAP**) |  |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `143` | TCP | **互联网消息访问协议** (**IMAP**) |  |'
- en: '| `194` | TCP | **Internet Relay Chat** (**IRC**) |  |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `194` | TCP | **互联网中继聊天** (**IRC**) |  |'
- en: '| `443` | TCP | **HTTP over TLS/SSL** (**HTTPS**) | [Chapter 9](47ba170d-42d9-4e38-b5d8-89503e005708.xhtml), *Loading
    Secure Web Pages with HTTPS and OpenSSL* [Chapter 10](f57ffaa2-3eba-45cf-914b-bb6aef36174f.xhtml), *Implementing
    a Secure Web Server* |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `443` | TCP | **通过TLS/SSL的HTTP** (**HTTPS**) | [第9章](47ba170d-42d9-4e38-b5d8-89503e005708.xhtml)，*使用HTTPS和OpenSSL加载安全网页*
    [第10章](f57ffaa2-3eba-45cf-914b-bb6aef36174f.xhtml)，*实现安全Web服务器* |'
- en: '| `993` | TCP | **IMAP over TLS/SSL** (**IMAPS**) |  |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `993` | TCP | **通过TLS/SSL的IMAP** (**IMAPS**) |  |'
- en: '| `995` | TCP | **POP3 over TLS/SSL** (**POP3S**) |  |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `995` | TCP | **POP3 over TLS/SSL** (**POP3S**) |  |'
- en: Each of these listed port numbers is assigned by the **Internet Assigned Numbers
    Authority** (**IANA**). They are responsible for the official assignments of port
    numbers for specific protocols. Unofficial port usage is very common for applications
    implementing custom protocols. In this case, the application should try to choose
    a port number that is not in common use to avoid conflict.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这些列出的端口号都是由**互联网数字分配机构**（**IANA**）分配的。它们负责为特定协议的端口号进行官方分配。对于实现自定义协议的应用程序，非官方的端口号使用非常普遍。在这种情况下，应用程序应尝试选择一个不常用的端口号，以避免冲突。
- en: Clients and servers
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端和服务器
- en: In the telephone analogy, a call must be initiated first by one party. The initiating
    party dials the number for the receiving party, and the receiving party answers.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在电话类比中，通话必须首先由一方发起。发起方拨打接收方的电话号码，接收方接听。
- en: This is also a common paradigm in networking called the **client-server** model. 
    In this model, a server listens for connections. The client, knowing the address
    and port number that the server is listening on, establishes the connection by
    sending the first packet.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是网络中一个常见的范式，称为**客户端-服务器**模型。在这个模型中，服务器监听连接。客户端知道服务器监听的地址和端口号，通过发送第一个数据包来建立连接。
- en: For example, the web server at `example.com` listens on port `80` (HTTP) and
    port `443` (HTTPS). A web browser (client) must establish the connection by sending
    the first packet to the web server address and port.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`example.com`上的Web服务器监听`80`端口（HTTP）和`443`端口（HTTPS）。一个网络浏览器（客户端）必须通过向Web服务器地址和端口发送第一个数据包来建立连接。
- en: Putting it together
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组装起来
- en: A socket is one end-point of a communication link between systems. It's an abstraction
    in which your application can send and receive data over the network, in much
    the same way that your application can read and write to a file using a file handle.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字是系统之间通信链路的一端。它是一种抽象，您的应用程序可以通过网络发送和接收数据，这与您的应用程序使用文件句柄读取和写入文件的方式非常相似。
- en: 'An open socket is uniquely defined by a 5-tuple consisting of the following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 一个开放的套接字由以下五个元素组成的五元组唯一确定：
- en: Local IP address
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地IP地址
- en: Local port
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地端口
- en: Remote IP address
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程IP地址
- en: Remote port
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程端口
- en: Protocol (UDP or TCP)
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协议（UDP或TCP）
- en: This 5-tuple is important, as it is how your operating system knows which application
    is responsible for any packets received. For example, if you use two web browsers
    to establish two simultaneous connections to `example.com` on port `80`, then
    your operating system keeps the connections separate by looking at the local IP
    address, local port, remote IP address, remote port, and protocol. In this case,
    the local IP addresses, remote IP addresses, remote port (`80`), and protocol
    (TCP) are identical.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这个五元组很重要，因为它是操作系统知道哪个应用程序负责接收任何数据包的方式。例如，如果您使用两个网络浏览器同时连接到`example.com`的`80`端口，那么您的操作系统会通过查看本地IP地址、本地端口、远程IP地址、远程端口和协议来保持连接的分离。在这种情况下，本地IP地址、远程IP地址、远程端口（`80`）和协议（TCP）是相同的。
- en: The deciding factor then is the local port (also called the **ephemeral port**),
    which will have been chosen to be different by the operating system for connection.
    This 5-tuple is also important to understand how NAT works. A private network
    may have many systems accessing the same outside resource, and the router NAT
    must store this five tuple for each connection in order to know how to route received
    packets back into the private network.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 决定因素是本地端口（也称为**临时端口**），操作系统将选择一个不同的端口用于连接。这个五元组对于理解NAT的工作原理也很重要。一个私有网络可能有多个系统访问相同的公共资源，并且路由器NAT必须为每个连接存储这个五元组，以便知道如何将接收到的数据包路由回私有网络。
- en: What's your address?
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的地址是什么？
- en: You can find your IP address using the `ipconfig` command on Windows, or the
    `ifconfig` command on Unix-based systems (such as Linux and macOS).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Windows上的`ipconfig`命令或基于Unix的系统（如Linux和macOS）上的`ifconfig`命令来查找您的IP地址。
- en: 'Using the `ipconfig` command from Windows PowerShell looks like this:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Windows PowerShell中的`ipconfig`命令看起来像这样：
- en: '![](img/a6b1c696-13bb-4954-8f44-f4b761c8feca.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a6b1c696-13bb-4954-8f44-f4b761c8feca.png)'
- en: In this example, you can find that the IPv4 address is listed under `Ethernet
    adapter Ethernet0`. Your system may have more network adapters, and each will
    have its own IP address. We can tell that this computer is on a local network
    because the IP address, `192.168.182.133`, is in the private IP address range.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你可以找到IPv4地址在`以太网适配器 Ethernet0`下列出。你的系统可能有更多的网络适配器，每个适配器都有自己的IP地址。我们可以判断这台计算机位于本地网络中，因为IP地址`192.168.182.133`位于私有IP地址范围内。
- en: On Unix-based systems, we use either the `ifconfig` or `ip addr` commands. The `ifconfig` command
    is the old way and is now deprecated on some systems. The `ip addr` command is
    the new way, but not all systems support it yet.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于Unix的系统上，我们使用`ifconfig`或`ip addr`命令。`ifconfig`命令是旧的方法，现在在某些系统上已弃用。`ip addr`命令是新的方法，但并非所有系统都支持它。
- en: 'Using the `ifconfig` command from a macOS terminal looks like this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS终端中使用`ifconfig`命令看起来是这样的：
- en: '![](img/df4feb51-b0b4-4ea0-960c-297484beaaea.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/df4feb51-b0b4-4ea0-960c-297484beaaea.png)'
- en: The IPv4 address is listed next to `inet`. In this case, we can see that it's
    `192.168.182.128`. Again, we see that this computer is on a local network because
    of the IP address range. The same adapter has an IPv6 address listed next to `inet6`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4地址列在`inet`旁边。在这种情况下，我们可以看到它是`192.168.182.128`。同样，我们看到这台计算机位于本地网络中，因为IP地址范围。相同的适配器在`inet6`旁边列出了IPv6地址。
- en: 'The following screenshot shows using the `ip addr` command on Ubuntu Linux:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在Ubuntu Linux上使用`ip addr`命令的情况：
- en: '![](img/e007f8b3-be2d-4445-a377-df716a5368f5.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e007f8b3-be2d-4445-a377-df716a5368f5.png)'
- en: The preceding screenshot shows the local IPv4 address as `192.168.182.145`.
    We can also see that the link-local IPv6 address is `fe80::df60:954e:211:7ff0`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图显示了本地IPv4地址为`192.168.182.145`。我们还可以看到链路本地IPv6地址为`fe80::df60:954e:211:7ff0`。
- en: These commands, `ifconfig`, `ip addr`, and `ipconfig`, show the IP address or
    addresses for each adapter on your computer. You may have several. If you are
    on a local network, the IP addresses you see will be your local private network
    IP addresses.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令，`ifconfig`、`ip addr`和`ipconfig`，显示了计算机上每个适配器的IP地址或地址。你可能有几个。如果你在一个本地网络中，你看到的IP地址将是你的本地私有网络IP地址。
- en: If you are behind a NAT, there is often no good way to know your public IP address.
    Usually, the only resort is to contact an internet server that provides an API
    that informs you of your IP address.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你位于NAT后面，通常没有很好的方法知道你的公网IP地址。通常，唯一的办法是联系一个提供API的互联网服务器，该API会告诉你你的IP地址。
- en: 'A few free and public APIs for this are as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 一些免费和公开的API如下：
- en: '`http://api.ipify.org/`'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://api.ipify.org/`'
- en: '`http://helloacm.com/api/what-is-my-ip-address/`'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://helloacm.com/api/what-is-my-ip-address/`'
- en: '`http://icanhazip.com/`'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://icanhazip.com/`'
- en: '`http://ifconfig.me/ip`'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://ifconfig.me/ip`'
- en: 'You can test out these APIs in a web browser:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在网页浏览器中测试这些API：
- en: '![](img/a4152ccb-c75c-4b69-99f6-3a7e1e81ac51.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a4152ccb-c75c-4b69-99f6-3a7e1e81ac51.png)'
- en: Each of these listed web pages should return your public IP address and not
    much else. These sites are useful for when you need to determine your public IP
    address from behind an NAT programmatically. We look at writing a small HTTP client
    capable of downloading these web pages and others in [Chapter 6](de3d2e9b-b94e-47d1-872c-c2ecb34c4026.xhtml),
    *Building a Simple Web Client*.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 列出的每个网页都应该返回你的公网IP地址以及不多于其他信息。这些网站在你需要从NAT后面程序化地确定公网IP地址时很有用。我们在[第6章](de3d2e9b-b94e-47d1-872c-c2ecb34c4026.xhtml)，*构建简单的Web客户端*中讨论了编写能够下载这些网页和其他网页的小型HTTP客户端。
- en: Now that we've seen the built-in utilities for determining our local IP addresses,
    let's next look at how to accomplish this from C.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了确定本地IP地址的内置工具，接下来让我们看看如何从C语言中实现这一功能。
- en: Listing network adapters from C
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从C语言列出网络适配器
- en: 'Sometimes, it is useful for your C programs to know what your local address
    is. For most of this book, we are able to write code that works both on Windows
    and Unix-based (Linux and macOS) systems. However, the API for listing local addresses
    is very different between systems. For this reason, we split this program into
    two: one for Windows and one for Unix-based systems.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，让你的C程序知道你的本地地址是有用的。在这本书的大部分内容中，我们能够编写既适用于Windows也适用于基于Unix的系统（Linux和macOS）的代码。然而，列出本地地址的API在不同系统之间非常不同。因此，我们将这个程序分为两个：一个用于Windows，一个用于基于Unix的系统。
- en: We will address the Windows case first.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先解决Windows的情况。
- en: Listing network adapters on Windows
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Windows上列出网络适配器
- en: The Windows networking API is called **Winsock**, and we will go into much more
    detail about it in the next chapter.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Windows网络API称为**Winsock**，我们将在下一章中详细介绍它。
- en: 'Whenever we are using Winsock, the first thing we must do is initialize it.
    This is done with a call to `WSAStartup()`. Here is a small C program, `win_init.c`,
    showing the initialization and cleanup of Winsock:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们使用Winsock时，我们必须做的第一件事就是初始化它。这是通过调用`WSAStartup()`来完成的。以下是一个小的C程序，`win_init.c`，展示了Winsock的初始化和清理：
- en: '[PRE3]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `WSAStartup()` function is called with the requested version, Winsock 2.2
    in this case, and a `WSADATA` structure. The `WSADATA` structure will be filled
    in by `WSAStartup()` with details about the Windows Sockets implementation. The `WSAStartup()` function
    returns `0` upon success, and non-zero upon failure.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`WSAStartup()`函数使用请求的版本调用，在本例中是Winsock 2.2，以及一个`WSADATA`结构。`WSADATA`结构将由`WSAStartup()`填充，包含有关Windows
    Sockets实现的详细信息。`WSAStartup()`函数在成功时返回`0`，在失败时返回非零值。'
- en: When a Winsock program is finished, it should call `WSACleanup()`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 当Winsock程序完成时，它应该调用`WSACleanup()`。
- en: If you are using Microsoft Visual C as your compiler, then `#pragma comment(lib,
    "ws2_32.lib")` tells Microsoft Visual C to link the executable with the Winsock
    library, `ws2_32.lib`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Microsoft Visual C作为编译器，那么`#pragma comment(lib, "ws2_32.lib")`告诉Microsoft
    Visual C将可执行文件与Winsock库`ws2_32.lib`链接。
- en: 'If you are using MinGW as your compiler, the pragma is ignored. You need to
    explicitly tell the compiler to link in the library by adding the command-line
    option, `-lws2_32`. For example, you can compile this program using MinGW with
    the following command:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用MinGW作为编译器，则忽略该pragma。你需要明确告诉编译器链接库，通过添加命令行选项`-lws2_32`。例如，你可以使用以下命令使用MinGW编译此程序：
- en: '[PRE4]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We will cover Winsock initialization and usage in more detail in [Chapter 2](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml),
    *Getting to Grips with Socket APIs*.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第2章](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml)中更详细地介绍Winsock的初始化和使用，*掌握Socket
    API*。
- en: Now that we know how to initialize Winsock, we will begin work on the complete
    program to list network adapters on Windows. Please refer to the `win_list.c` file
    to follow along.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何初始化Winsock，我们将开始编写一个完整的程序来列出Windows上的网络适配器。请参考`win_list.c`文件以了解整个过程。
- en: 'To begin with, we need to define `_WIN32_WINNT` and include the needed headers:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要定义`_WIN32_WINNT`并包含所需的头文件：
- en: '[PRE5]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `_WIN32_WINNT` macro must be defined first so that the proper version of
    the Windows headers are included. `winsock2.h`, `iphlpapi.h`, and `ws2tcpip.h`
    are the Windows headers we need in order to list network adapters. We need `stdio.h`
    for the `printf()` function and `stdlib.h` for memory allocation.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`_WIN32_WINNT`宏必须首先定义，以便包含正确的Windows头文件版本。`winsock2.h`、`iphlpapi.h`和`ws2tcpip.h`是我们列出网络适配器所需的Windows头文件。我们还需要`stdio.h`用于`printf()`函数和`stdlib.h`用于内存分配。'
- en: 'Next, we include the following pragmas to tell Microsoft Visual C which libraries
    must be linked with the executable:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们包含以下pragma来告诉Microsoft Visual C必须与可执行文件链接哪些库：
- en: '[PRE6]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you're compiling with MinGW, these lines will have no effect. You will need
    to link to these libraries explicitly on the command line, for example, `gcc win_list.c
    -o win_list.exe -liphlpapi -lws2_32`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用MinGW编译，这些行将没有效果。你需要在命令行上显式链接到这些库，例如，`gcc win_list.c -o win_list.exe -liphlpapi
    -lws2_32`。
- en: 'We then enter the `main()` function and initialize Winsock 2.2 using `WSAStartup()`
    as described earlier. We check its return value to detect any errors:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们进入`main()`函数，并使用前面描述的`WSAStartup()`初始化Winsock 2.2。我们检查其返回值以检测任何错误：
- en: '[PRE7]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, we allocate memory for the adapters, and we request the adapters'' addresses
    from Windows using the `GetAdapterAddresses()` function:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为适配器分配内存，并使用`GetAdapterAddresses()`函数从Windows请求适配器的地址：
- en: '[PRE8]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `asize` variable will store the size of our adapters' address buffer. To
    begin with, we set it to `20000` and allocate 20,000 bytes to `adapters` using
    the `malloc()` function. The `malloc()` function will return `0` on failure, so
    we test for that and display an error message if allocation failed.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`asize`变量将存储我们适配器地址缓冲区的大小。一开始，我们将其设置为`20000`，并使用`malloc()`函数为`adapters`分配20,000字节。`malloc()`函数在失败时将返回`0`，因此我们检查这一点，如果分配失败则显示错误信息。'
- en: Next, we call `GetAdapterAddresses()`. The first parameter, `AF_UNSPEC`, tells
    Windows that we want both IPv4 and IPv6 addresses. You can pass in `AF_INET` or
    `AF_INET6` to request only IPv4 or only IPv6 addresses. The second parameter,
    `GAA_FLAG_INCLUDE_PREFIX`, is required to request a list of addresses. The next
    parameter is reserved and should be passed in as `0` or `NULL`. Finally, we pass
    in our buffer, `adapters`, and a pointer to its size, `asize`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用 `GetAdapterAddresses()`。第一个参数 `AF_UNSPEC` 告诉 Windows 我们想要 IPv4 和 IPv6
    地址。你可以传入 `AF_INET` 或 `AF_INET6` 来请求只获取 IPv4 或只获取 IPv6 地址。第二个参数 `GAA_FLAG_INCLUDE_PREFIX`
    是请求地址列表所必需的。下一个参数是保留的，应该传入 `0` 或 `NULL`。最后，我们传入我们的缓冲区 `adapters` 和其大小的指针 `asize`。
- en: If our buffer is not big enough to store all of the addresses, then `GetAdapterAddresses()` returns `ERROR_BUFFER_OVERFLOW`
    and sets `asize` to the required buffer size. In this case, we free our `adapters`
    buffer and try the call again with a larger buffer.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的缓冲区不足以存储所有地址，那么 `GetAdapterAddresses()` 将返回 `ERROR_BUFFER_OVERFLOW` 并将
    `asize` 设置为所需的缓冲区大小。在这种情况下，我们释放 `adapters` 缓冲区，并使用更大的缓冲区再次尝试调用。
- en: On success, `GetAdapterAddresses()` returns `ERROR_SUCCESS`, in which case,
    we break from the loop and continue. Any other return value is an error.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时，`GetAdapterAddresses()` 返回 `ERROR_SUCCESS`，在这种情况下，我们退出循环并继续。任何其他返回值都是错误。
- en: 'When `GetAdapterAddresses()` returns successfully, it will have written a linked
    list into `adapters` with each adapter''s address information. Our next step is
    to loop through this linked list and print information for each adapter and address:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `GetAdapterAddresses()` 成功返回时，它将在 `adapters` 中写入一个链表，其中包含每个适配器的地址信息。我们的下一步是遍历这个链表，并打印每个适配器和地址的信息：
- en: '[PRE9]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We first define a new variable, `adapter`, which we use to walk through the
    linked list of adapters. The first adapter is at the beginning of `adapters`,
    so we initially set `adapter` to `adapters`. At the end of each loop, we set `adapter
    = adapter->Next;` to get the next adapter. The loop aborts when `adapter` is `0`,
    which means we've reached the end of the list.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个新的变量 `adapter`，我们用它来遍历适配器的链表。第一个适配器在 `adapters` 的开始处，所以我们最初将 `adapter`
    设置为 `adapters`。在每个循环的末尾，我们将 `adapter = adapter->Next;` 设置为获取下一个适配器。当 `adapter`
    为 `0` 时，循环终止，这意味着我们已经到达了列表的末尾。
- en: We get the adapter name from `adapter->FriendlyName`, which we then print using
    `printf()`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 `adapter->FriendlyName` 获取适配器名称，然后使用 `printf()` 打印出来。
- en: The first address for each adapter is in `adapter->FirstUnicastAddress`. We
    define a second pointer, `address`, and set it to this address. Addresses are
    also stored as a linked list, so we begin an inner loop that walks through the
    addresses.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 每个适配器的第一个地址在 `adapter->FirstUnicastAddress` 中。我们定义一个第二个指针 `address`，并将其设置为这个地址。地址也存储为链表，所以我们开始一个内部循环，遍历地址。
- en: The `address->Address.lpSockaddr->sa_family` variable stores the address family
    type. If it is set to `AF_INET`, then we know this is an IPv4 address. Otherwise,
    we assume it is an IPv6 address (in which case the family is `AF_INET6`).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`address->Address.lpSockaddr->sa_family` 变量存储地址族类型。如果它被设置为 `AF_INET`，那么我们知道这是一个
    IPv4 地址。否则，我们假设它是一个 IPv6 地址（在这种情况下，族是 `AF_INET6`）。'
- en: Next, we allocate a buffer, `ap`, to store the text representation of the address.
    The `getnameinfo()` function is called to convert the address into a standard
    notation address. We'll cover more about `getnameinfo()` in the next chapter.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们分配一个缓冲区 `ap` 来存储地址的文本表示。调用 `getnameinfo()` 函数将地址转换为标准表示的地址。我们将在下一章中详细介绍
    `getnameinfo()`。
- en: Finally, we can print the address from our buffer, `ap`, using `printf()`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用 `printf()` 打印出我们缓冲区 `ap` 中的地址。
- en: 'We finish the program by freeing the allocated memory and calling `WSACleanup()`:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过释放分配的内存并调用 `WSACleanup()` 来结束程序：
- en: '[PRE10]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'On Windows, using MinGW, you can compile and run the program with the following:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，使用 MinGW，你可以使用以下命令编译和运行程序：
- en: '[PRE11]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It should list each of your adapter's names and addresses.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该列出你每个适配器的名称和地址。
- en: Now that we can list local IP addresses on Windows, let's consider the same
    task for Unix-based systems.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在 Windows 上列出本地 IP 地址了，让我们考虑基于 Unix 的系统上的相同任务。
- en: Listing network adapters on Linux and macOS
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Linux 和 macOS 上列出网络适配器
- en: Listing local network addresses is somewhat easier on a Unix-based system, compared
    to Windows. Load up `unix_list.c` to follow along.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在类 Unix 系统上列出本地网络地址比在 Windows 上要容易一些。加载 `unix_list.c` 以便跟随。
- en: 'To begin with, we include the necessary system headers:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们包含必要的系统头文件：
- en: '[PRE12]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We then enter the `main` function:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们进入 `main` 函数：
- en: '[PRE13]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We declare a variable, `addresses`, which stores the addresses. A call to the
    `getifaddrs()` function allocates memory and fills in a linked list of addresses.
    This function returns `0` on success or `-1` on failure.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明一个变量，`addresses`，用于存储地址。调用`getifaddrs()`函数分配内存并填充地址的链表。此函数在成功时返回`0`，在失败时返回`-1`。
- en: 'Next, we use a new pointer, `address`, to walk through the linked list of addresses.
    After considering each address, we set `address = address->ifa_next` to get the
    next address. We stop the loop when `address == 0`, which happens at the end of
    the linked list:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用一个新的指针，`address`，遍历地址的链表。考虑完每个地址后，我们将`address = address->ifa_next`设置为获取下一个地址。当`address
    == 0`时，我们停止循环，这发生在链表末尾：
- en: '[PRE14]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: For each address, we identify the address family. We are interested in `AF_INET`
    (IPv4 addresses) and `AF_INET6` (IPv6 addresses). The `getifaddrs()` function
    can return other types, so we skip those.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个地址，我们识别地址族。我们感兴趣的是`AF_INET`（IPv4地址）和`AF_INET6`（IPv6地址）。`getifaddrs()`函数可以返回其他类型，所以我们跳过那些。
- en: For each address, we then continue to print its adapter name and its address
    type, IPv4 or IPv6.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个地址，我们继续打印其适配器名称和地址类型，IPv4或IPv6。
- en: We then define a buffer, `ap`, to store the textual address. A call to the `getnameinfo()`
    function fills in this buffer, which we can then print. We cover the `getnameinfo()`
    function in more detail in the next chapter, [Chapter 2](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml),
    *Getting to Grips with Socket APIs*.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义一个缓冲区，`ap`，用于存储文本地址。调用`getnameinfo()`函数填充此缓冲区，然后我们可以打印它。我们将在下一章更详细地介绍`getnameinfo()`函数，[第2章](4f41c930-c4b4-47e5-b9ef-f8faf21fa96b.xhtml)，*掌握套接字API*。
- en: 'Finally, we free the memory allocated by `getifaddrs()` and we have finished:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们释放`getifaddrs()`分配的内存，我们完成了：
- en: '[PRE15]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'On Linux and macOS, you can compile and run this program with the following:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux和macOS上，您可以使用以下命令编译和运行此程序：
- en: '[PRE16]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It should list each of your adapter's names and addresses.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该列出您适配器的每个名称和地址。
- en: Summary
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked briefly at how internet traffic is routed. We learned
    that there are two Internet Protocol versions, IPv4 and IPv6\. IPv4 has a limited
    number of addresses, and these addresses are running out. One of IPv6's main advantages
    is that it has enough address space for every system to have its own unique publicly-routable
    address. The limited address space of IPv4 is largely mitigated by network address
    translation performed by routers. We also looked at how to detect your local IP
    address using both utilities and APIs provided by the operating system.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们简要地探讨了互联网流量的路由方式。我们了解到存在两种互联网协议版本，IPv4和IPv6。IPv4地址数量有限，这些地址正在耗尽。IPv6的主要优势之一是它为每个系统提供了足够的地址空间，以便每个系统都有自己的唯一公开可路由地址。IPv4有限的地址空间在很大程度上被路由器执行的地址转换所缓解。我们还探讨了如何使用操作系统提供的实用程序和API检测您的本地IP地址。
- en: We saw that the APIs provided for listing local IP addresses differ quite a
    bit between Windows and Unix-based operating systems. In future chapters, we will
    see that most other networking functions are similar between operating systems,
    and we can write one portable program that works between operating systems.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，用于列出本地IP地址的API在Windows和基于Unix的操作系统之间差异很大。在未来的章节中，我们将看到大多数其他网络功能在操作系统之间是相似的，我们可以编写一个在操作系统之间工作的可移植程序。
- en: It's OK if you didn't pick up all of the details in this chapter. Most of this
    information is a helpful background, but it's not essential to most network application
    programming. Details such as network address translation are handled by the network,
    and these details will not usually need to be explicitly addressed by your programs.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有完全掌握本章的细节，那没关系。大部分信息都是有益的背景知识，但对于大多数网络应用程序编程来说并非必需。例如，网络地址转换这样的细节由网络处理，并且通常不需要您的程序明确处理这些细节。
- en: In the next chapter, we will reinforce the ideas covered here by introducing
    socket-programming APIs.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过介绍套接字编程API来巩固本章介绍的概念。
- en: Questions
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Try these questions to test your knowledge from this chapter:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试以下问题来测试您对本章知识的掌握：
- en: What are the key differences between IPv4 and IPv6?
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: IPv4和IPv6之间的主要区别是什么？
- en: Are the IP addresses given by the `ipconfig` and `ifconfig` commands the same
    IP addresses that a remote web server sees if you connect to it?
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ipconfig`和`ifconfig`命令给出的IP地址与远程Web服务器看到的IP地址相同吗？
- en: What is the IPv4 loopback address?
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是IPv4回环地址？
- en: What is the IPv6 loopback address?
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是IPv6回环地址？
- en: How are domain names (for example, `example.com`) resolved into IP addresses?
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 域名（例如，`example.com`）是如何解析成IP地址的？
- en: How can you find your public IP address?
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何找到你的公网IP地址？
- en: How does an operating system know which application is responsible for an incoming
    packet?
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 操作系统是如何知道哪个应用程序负责处理传入的数据包的？
- en: The answers are in [Appendix A](bd8b8f52-52cb-4d34-b01b-e907564bfece.xhtml),
    *Answers to Questions*.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 答案在[附录A](bd8b8f52-52cb-4d34-b01b-e907564bfece.xhtml)，*问题解答*中。
