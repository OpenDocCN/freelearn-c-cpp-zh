<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer118">
			<h1 id="_idParaDest-226" class="chapter-number"><a id="_idTextAnchor392"/>14</h1>
			<h1 id="_idParaDest-227"><a id="_idTextAnchor393"/>External Interrupts and Events (EXTI)</h1>
			<p>In this chapter, we will learn about interrupts and their critical role in embedded systems development. Interrupts are pivotal for creating responsive and efficient firmware, allowing microcontrollers to handle real-time events effectively. By understanding interrupts, you can develop systems that can react promptly to external stimuli, making your embedded applications more robust <span class="No-Break">and versatile.</span></p>
			<p>We will begin by exploring the fundamental role of interrupts in firmware, contrasting them with exceptions to highlight their unique purposes and handling mechanisms. Following this, we<a id="_idIndexMarker997"/> will dive into the<a id="_idIndexMarker998"/> specifics o<a id="_idTextAnchor394"/>f the <strong class="bold">Interrupt Service Routine</strong> (<strong class="bold">ISR</strong>), the <strong class="bold">Interrupt Vector Table</strong> (<strong class="bold">IVT</strong>), and the <strong class="bold">Nested Vectored Interrupt Controller</strong> (<strong class="bold">NVIC</strong>), which <a id="_idIndexMarker999"/>collectively form the backbone of interrupt handling in Arm <span class="No-Break">Cortex-M microcontrollers.</span></p>
			<p>Next, we will focus on the <a id="_idIndexMarker1000"/>STM32 <strong class="bold">External Interrupt</strong> (<strong class="bold">EXTI</strong>) controller, an essential peripheral for managing external interrupts in STM32 microcontrollers. We will examine the key features and registers of the EXTI controller, learning how to configure and utilize it for <span class="No-Break">various applications.</span></p>
			<p>Finally, we will apply this knowledge by developing an EXTI driver, providing you with practical experience in implementing interrupt-driven firmware. This hands-on approach will solidify your understanding and enable you to create responsive, <span class="No-Break">interrupt-based systems.</span></p>
			<p>In this chapter, we will cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Interrupts and their role <span class="No-Break">in firmware</span></li>
				<li>The STM32 <span class="No-Break">EXTI control<a id="_idTextAnchor395"/>ler</span></li>
				<li>Developing the <span class="No-Break">EXTI driver</span></li>
			</ul>
			<p>By the end of this chapter, you will have a comprehensive understanding of interrupts and how to develop bare-metal EXTI drivers for STM32 microcontrollers, empowering you to create responsive and efficient <span class="No-Break">embedded systems.</span></p>
			<h1 id="_idParaDest-228"><a id="_idTextAnchor396"/>Technical requirements</h1>
			<p>All the code examples for this chapter can be found on GitHub at the <span class="No-Break">following link:</span></p>
			<p><a href="https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming"><span class="No-Break">https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming</span></a></p>
			<h1 id="_idParaDest-229"><a id="_idTextAnchor397"/>Interrupts and their role in firmware</h1>
			<p>Interrupts <a id="_idIndexMarker1001"/>are one of the most critical mechanisms in embedded systems, allowing microcontrollers to react to real-time events efficiently. To fully appreciate their role in firmware, it’s essential to understand what interrupts are, how they work, and the various scenarios where they prove indispensable. So, let’s dive in and explore the fascinating world of interrupts, their operation, and their <span class="No-Break">practical applications.</span></p>
			<h2 id="_idParaDest-230"><a id="_idTextAnchor398"/>What are interrupts?</h2>
			<p>Imagine you’re deeply engrossed in reading a book but then the doorbell rings. You momentarily stop reading, attend to the visitor, and then return to your book. Interrupts in microcontrollers work similarly. They are signals that temporarily halt the current execution of a program to allow a special routine, known as an ISR, to run. Once the ISR completes, the microcontroller resumes its previous task right where it <span class="No-Break">left off.</span></p>
			<p>Interrupts can be triggered by hardware events, such as a timer overflow, a key press, or data reception on a communication interface. They can also be generated by software, providing a flexible way to manage both external and internal events. Now, let’s see how <span class="No-Break">they work.</span></p>
			<h2 id="_idParaDest-231"><a id="_idTextAnchor399"/>How do interrupts work?</h2>
			<p>At the <a id="_idIndexMarker1002"/>heart of interrupt handling is the concept of context switching. When an interrupt occurs, the microcontroller saves its current state—essentially, a snapshot of all the important information, such as the program counter and CPU registers. This allows the microcontroller to pause its current task, execute the ISR, and then restore the saved state to continue where it left off. The process typically follows <span class="No-Break">these steps:</span></p>
			<ol>
				<li><strong class="bold">Interrupt request</strong>: An <a id="_idIndexMarker1003"/>event triggers an <strong class="bold">Interrupt </strong><span class="No-Break"><strong class="bold">Request</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">IRQ</strong></span><span class="No-Break">).</span></li>
				<li><strong class="bold">Acknowledge and prioritize</strong>: The interrupt controller acknowledges the request and prioritizes it based on <span class="No-Break">predefined levels.</span></li>
				<li><strong class="bold">Context save</strong>: The CPU saves its current <span class="No-Break">execution context.</span></li>
				<li><strong class="bold">Vector fetch</strong>: The CPU fetches the address of the ISR from <span class="No-Break">the IVT.</span></li>
				<li><strong class="bold">ISR execution</strong>: The ISR runs to handle <span class="No-Break">the interrupt.</span></li>
				<li><strong class="bold">Context restore</strong>: After the ISR completes, the CPU restores the <span class="No-Break">saved context.</span></li>
				<li><strong class="bold">Resume execution</strong>: The CPU resumes the <span class="No-Break">interrupted task.</span></li>
			</ol>
			<p>You may <a id="_idIndexMarker1004"/>wonder why interrupts are important. Let’s <span class="No-Break">find out.</span></p>
			<h2 id="_idParaDest-232"><a id="_idTextAnchor400"/>Importance of interrupts in firmware</h2>
			<p>Interrupts<a id="_idIndexMarker1005"/> are important for creating efficient and responsive embedded systems. Here are some key reasons why they are <span class="No-Break">so important:</span></p>
			<ul>
				<li><strong class="bold">Real-time response</strong>: Interrupts allow a microcontroller to react almost instantaneously to critical events. For instance, in a motor control system, an interrupt can immediately handle a sensor signal indicating that the motor has reached its <span class="No-Break">desired position.</span></li>
				<li><strong class="bold">Resource optimization</strong>: Instead of constantly polling for events (which wastes CPU cycles and power), interrupts enable the CPU to remain in a low-power state or focus on other tasks until an event occurs. This optimization is crucial for battery-powered devices such as wearables or <span class="No-Break">remote sensors.</span></li>
				<li><strong class="bold">Prioritization and preemption</strong>: Interrupts can be prioritized, allowing more critical tasks to preempt less critical ones. This ensures that high-priority tasks, such as emergency stop signals in industrial machinery, are <span class="No-Break">addressed immediately.</span></li>
			</ul>
			<p>When discussing interrupts, we often encounter another key term: exceptions. Although they share similarities, they serve different purposes in embedded systems. Let’s explore the differences between interrupts <span class="No-Break">and exceptions.</span></p>
			<h2 id="_idParaDest-233"><a id="_idTextAnchor401"/>Interrupts versus exceptions</h2>
			<p>Interrupts<a id="_idIndexMarker1006"/> are signals from hardware or software indicating an event that needs immediate attention. Examples include timer overflows, GPIO pin changes, and peripheral <span class="No-Break">data reception.</span></p>
			<p>As we learned earlier, interrupts enable embedded systems to handle real-time events and are essential for responsive and efficient system behavior. When an interrupt occurs, the CPU stops executing the main program and jumps to a predefined address to execute <span class="No-Break">the ISR.</span></p>
			<p>Exceptions are events that disrupt the normal execution flow, often due to errors such as divide-by-zero operations or accessing invalid memory addresses. While similar to interrupts, exceptions typically handle error conditions and <span class="No-Break">system-level events.</span></p>
			<h3>Differences between interrupts and exceptions</h3>
			<p>Here are some of the differences between <span class="No-Break">the two:</span></p>
			<ul>
				<li><strong class="bold">Source</strong>: Interrupts usually originate from external hardware devices or other peripherals within the microcontroller, while exceptions are typically the result of internal <span class="No-Break">CPU operations</span></li>
				<li><strong class="bold">Purpose</strong>: Interrupts manage real-time events, whereas exceptions handle error conditions and <span class="No-Break">system anomalies</span></li>
				<li><strong class="bold">Handling</strong>: Both use ISRs, but exceptions often involve more complex error handling and <span class="No-Break">recovery mechanisms</span></li>
			</ul>
			<p>To properly understand how interrupts are handled, we need to examine the three key components involved: the NVIC, the ISR, and <span class="No-Break">the IVT.</span></p>
			<h3>The NVIC, ISR, and IVT</h3>
			<p>The NVIC in Arm Cortex-M microcontrollers, such as the STM32 series, plays a pivotal role in managing interrupts. Let’s explore what the NVIC is, how it works, and why it’s so important for <span class="No-Break">embedded development.</span></p>
			<h4>The NVIC</h4>
			<p>The NVIC is a <a id="_idIndexMarker1007"/>hardware module integrated into Arm Cortex-M microcontrollers that manages the prioritization and handling of interrupts. It enables the microcontroller to respond to interrupts quickly and efficiently, while also allowing for nested interrupts, where higher-priority interrupts can preempt lower-priority ones. This capability is essential for real-time applications where timely responses to events <span class="No-Break">are<a id="_idTextAnchor402"/> critical.</span></p>
			<p>Its key features <a id="_idIndexMarker1008"/>include <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Interrupt prioritization</strong>: The NVIC supports multiple priority levels, allowing us to assign different priorities to different interrupts. This ensures that more critical tasks are <span class="No-Break">handled first.</span></li>
				<li><strong class="bold">Nested interrupts</strong>: The NVIC allows higher-priority interrupts to interrupt lower-priority ones. This feature is crucial for maintaining system responsiveness in <span class="No-Break">real-time applications.</span></li>
				<li><strong class="bold">Dynamic priority adjustment</strong>: We can dynamically adjust the priority of interrupts during runtime, providing flexibility to adapt to <span class="No-Break">changing conditions.</span><p class="list-inset">The diagram in <span class="No-Break"><em class="italic">Figure 14</em></span><em class="italic">.1</em> illustrates the NVIC and its connections to various components within <span class="No-Break">the microcontroller.</span></p></li>
			</ul>
			<div>
				<div id="_idContainer117" class="IMG---Figure">
					<img src="image/B21914_14_1.jpg" alt="Figure 14.1: The NVIC" width="1542" height="515"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.1: The NVIC</p>
			<p>Next, we have <span class="No-Break">the ISR.</span></p>
			<h4>The ISR</h4>
			<p>The<a id="_idIndexMarker1009"/> ISR is a crucial piece of the puzzle when it comes to handling interrupts in embedded systems. The ISR is a specialized function that the CPU executes in response to an interrupt. Every interrupt has its own ISR. When an interrupt occurs, the CPU temporarily halts its current task, saves its state, and jumps to the ISR’s predefined address (function) to execute the <span class="No-Break">necessary code.</span></p>
			<p>The final critical component is <span class="No-Break">the IVT.</span></p>
			<h4>The IVT</h4>
			<p>The IVT is<a id="_idIndexMarker1010"/> like the roadmap for the CPU when an interrupt occurs. It’s a data structure that holds the addresses of all the ISRs. Each interrupt source is assigned a specific entry in this table, mapping it to its corresponding ISR. When an interrupt is triggered, the CPU consults the IVT to find the address of the ISR associated with that interrupt. This lookup ensures that the CPU can quickly and efficiently jump to the right piece of code to handle <span class="No-Break">the event.</span></p>
			<p>Its key features include <a id="_idIndexMarker1011"/><span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Fixed location</strong>: The IVT is typically located at a fixed address in memory. For Arm Cortex-M microcontrollers, it starts at <span class="No-Break">address </span><span class="No-Break"><strong class="source-inline">0x00000000</strong></span><span class="No-Break">.</span></li>
				<li><strong class="bold">ISR addresses</strong>: Each entry in the IVT contains the address of an ISR. When an interrupt occurs, the CPU uses the IVT to quickly locate and jump to the <span class="No-Break">appropriate ISR.</span></li>
				<li><strong class="bold">Vector numbers</strong>: Each interrupt source is assigned a unique vector number, which corresponds to an entry in the IVT. For example, vector number <strong class="source-inline">0</strong> might be for a reset interrupt, vector number <strong class="source-inline">1</strong> for a <strong class="bold">non-maskable interrupt</strong> (<strong class="bold">NMI</strong>), and <a id="_idIndexMarker1012"/><span class="No-Break">so on.</span></li>
				<li><strong class="bold">Configurable</strong>: In many systems, the IVT can be configured during system initialization to point to the ISRs defined in <span class="No-Break">your firmware.</span></li>
			</ul>
			<h2 id="_idParaDest-234"><a id="_idTextAnchor403"/>Comparative analysis—interrupt-driven solutions versus polling-based solutions</h2>
			<p>But what happens when we don’t use interrupts? Let’s explore some real-world case studies to illustrate the difference between solutions using interrupts and those that rely <span class="No-Break">on polling.</span></p>
			<h3>Case study 1—button debouncing</h3>
			<p>In embedded<a id="_idIndexMarker1013"/> systems, handling user inputs such as button presses is a common task. However, the way these inputs are managed can significantly impact the efficiency and responsiveness of the system. One particular issue is dealing with the problem of “bouncing,” where a mechanical button generates multiple rapid signals due to its physical characteristics. This can lead to incorrect readings and erratic behavior if not properly managed. In this case study, we will explore two approaches to handling button debouncing: one without interrupts and the other <span class="No-Break">using interrupts.</span></p>
			<p>We’ll start with the approach that doesn’t <span class="No-Break">use interrupts.</span></p>
			<p>Imagine you have a simple user interface with a button that, when pressed, toggles an LED. Without interrupts, the most straightforward approach is to continuously check (or “poll”) the button’s state in the main loop. This involves repeatedly reading the button’s input pin to see whether it has changed from high to low, indicating a press. The problem here is that mechanical buttons can generate spurious signals due to physical bouncing, leading to multiple detections of a single press. To handle this, you need to add a delay after detecting a press, effectively ignoring further signals for a <span class="No-Break">short period.</span></p>
			<p>There are a couple <span class="No-Break">of drawbacks:</span></p>
			<ul>
				<li><strong class="bold">Inefficiency</strong>: The CPU is constantly busy checking the button state, wasting valuable processing time that could be used for <span class="No-Break">other tasks</span></li>
				<li><strong class="bold">Delayed response</strong>: Adding a delay to handle debouncing means the system might miss other important tasks while waiting for the button <span class="No-Break">to stabilize</span></li>
			</ul>
			<p>Let’s look at the approach <span class="No-Break">with interrupts.</span></p>
			<p>Using interrupts, you configure the button pin to generate an interrupt on a falling edge (when the button is pressed). The ISR is triggered immediately when the button is pressed, handling the debouncing logic. The main loop remains free to perform other tasks without<a id="_idIndexMarker1014"/> the overhead of constantly polling <span class="No-Break">the button.</span></p>
			<p>There are a couple <span class="No-Break">of benefits:</span></p>
			<ul>
				<li><strong class="bold">Efficiency</strong>: The CPU can focus on other tasks and only respond to the button press <span class="No-Break">when necessary</span></li>
				<li><strong class="bold">Immediate response</strong>: The ISR responds instantly to the button press, making the system <span class="No-Break">more responsive</span></li>
			</ul>
			<h3>Case study 2—sensor data acquisition</h3>
			<p>Another <a id="_idIndexMarker1015"/>common task in embedded systems is acquiring data from sensors, especially in applications such as weather stations, where multiple sensors continuously monitor environmental conditions. The method used to handle sensor data acquisition can greatly affect the system’s complexity and efficiency. Let’s compare two approaches: one without using interrupts and the other leveraging interrupts to optimize <span class="No-Break">the process.</span></p>
			<p>We’ll start with the approach that doesn’t <span class="No-Break">use interrupts.</span></p>
			<p>Consider a weather station that reads data from various sensors such as temperature, humidity, and pressure at regular intervals. Without interrupts, the main loop would include code to periodically read data from each sensor. This could be done using timers to create delays between readings, ensuring data is acquired at the <span class="No-Break">right intervals.</span></p>
			<p>There are a couple <span class="No-Break">of drawbacks:</span></p>
			<ul>
				<li><strong class="bold">Complexity</strong>: Managing multiple sensors with precise timing using polling can lead to a complicated <span class="No-Break">main loop</span></li>
				<li><strong class="bold">Inefficiency</strong>: The main loop might spend a lot of time waiting for timers to expire—again, wasting <span class="No-Break">CPU resources</span></li>
			</ul>
			<p>Let’s look at the approach <span class="No-Break">with interrupts.</span></p>
			<p>Using interrupts, each sensor can trigger an interrupt when new data is available. The ISR for each sensor reads the data and stores it in a buffer for the main loop to process later. This approach decouples data acquisition from the main loop, allowing it to focus on data processing and <span class="No-Break">other tasks.</span></p>
			<p>There are a<a id="_idIndexMarker1016"/> couple <span class="No-Break">of benefits:</span></p>
			<ul>
				<li><strong class="bold">Simplified code</strong>: The main loop is cleaner and easier to manage, as it doesn’t need to handle timing and sensor<a id="_idTextAnchor404"/> <span class="No-Break">polling directly.</span></li>
				<li><strong class="bold">Resource efficiency</strong>: The CPU spends less time waiting and more time processing, leading to more efficient use <span class="No-Break">of resources.</span></li>
			</ul>
			<h3>Case study 3—communication protocols</h3>
			<p>Now, let’s see<a id="_idIndexMarker1017"/> how interrupts can improve communication. Effective communication between a microcontroller and external devices is crucial for many embedded systems, whether you’re dealing with sensors, displays, or other peripherals. The approach you take to manage data transmission and reception can have a significant impact on your system’s performance, particularly in terms of CPU load and latency. Let’s analyze two methods for handling communication over <strong class="bold">Universal Asynchronous Receiver/Transmitter</strong> (<strong class="bold">UART</strong>): one without using interrupts and the other leveraging interrupts to optimize <span class="No-Break">the process.</span></p>
			<p>We’ll start with the approach that doesn’t <span class="No-Break">use interrupts.</span></p>
			<p>Let’s look at a scenario where a microcontroller communicates with another device over UART. Without interrupts, the firmware would continuously check the UART status register to see whether new data has arrived or whether the transmitter is ready to send data. This polling approach ensures no data is missed, but it can be <span class="No-Break">very CPU-intensive.</span></p>
			<p>There are a couple <span class="No-Break">of drawbacks:</span></p>
			<ul>
				<li><strong class="bold">Resource efficiency</strong>: Continuous polling keeps the CPU busy, leaving less processing power for <span class="No-Break">other tasks</span></li>
				<li><strong class="bold">Latency</strong>: The time between data arrival and processing depends on how frequently the UART status <span class="No-Break">is checked</span></li>
			</ul>
			<p>Let’s look at the approach <span class="No-Break">with interrupts.</span></p>
			<p>Enabling UART interrupts allows the microcontroller to handle data reception and transmission events automatically. When new data arrives, an interrupt is triggered, and the ISR reads the <a id="_idIndexMarker1018"/>data and processes it. Similarly, when the transmitter is ready, another interrupt can handle <span class="No-Break">sending data.</span></p>
			<p>There are a couple <span class="No-Break">of benefits:</span></p>
			<ul>
				<li><strong class="bold">Low CPU load</strong>: The CPU can perform other tasks and only deal with UART events <span class="No-Break">when necessary</span></li>
				<li><strong class="bold">Real-time handling</strong>: Data is processed immediately upon arrival, reducing latency and improving <span class="No-Break">communication efficiency</span></li>
			</ul>
			<p>Interrupts provide a powerful and efficient way to handle real-time events in embedded systems. Compared to polling methods, interrupts offer significant benefits in terms of responsiveness, efficiency, and code simplicity. By understanding and leveraging interrupts, you can develop more robust and efficient firmware, capable of handling a wide range of real-time applications. Whether it’s managing user inputs, acquiring sensor data, handling communication protocols, or maintaining accurate timekeeping, interrupts are an <span class="No-Break">indispensable tool.</span></p>
			<p>In the next section, we shall explore the STM32 EXTI <span class="No-Break">controller peripheral.</span></p>
			<h1 id="_idParaDest-235"><a id="_idTextAnchor405"/>The STM32 EXTI controller</h1>
			<p>The <a id="_idIndexMarker1019"/>EXTI module in STM32 microcontrollers is designed to manage external interrupt lines. These lines can be triggered by signals on GPIO pins, enabling your microcontroller to react to changes in the external environment quickly <span class="No-Break">and efficiently.</span></p>
			<p>The EXTI controller is equipped with a range of features that enhance its flexibility and utility in embedded systems. Let’s explore these features in detail and understand their <span class="No-Break">practical applications.</span></p>
			<h2 id="_idParaDest-236"><a id="_idTextAnchor406"/>Key features of the EXTI</h2>
			<p>Here are <a id="_idIndexMarker1020"/>the key features of the EXTI module that make it a versatile and powerful tool for managing external and internal events in <span class="No-Break">STM32 microcontrollers:</span></p>
			<ul>
				<li>Provides up to 23 independent interrupt/event lines, with up to 16 from GPIO pins, and the rest from <span class="No-Break">internal signals</span></li>
				<li>Each line can be independently configured as either an interrupt or <span class="No-Break">an event</span></li>
				<li>Edge detection options for each line: rising, falling, or <span class="No-Break">both edges</span></li>
				<li>Dedicated status flags for each line to indicate <span class="No-Break">pending interrupts/events</span></li>
				<li>Ability to generate <span class="No-Break">software interrupts/events</span></li>
			</ul>
			<p>An event registers that something happened by setting a corresponding status flag bit, but does not trigger an interrupt or execute any <span class="No-Break">code (ISR).</span></p>
			<p>For example, events can be used to wake the system from sleep mode without executing <span class="No-Break">an ISR.</span></p>
			<p>To use the EXTI for generating interrupts, we need to configure and enable the interrupt line properly. This involves programming the trigger registers to detect the desired edge (rising, falling, or both) and enabling the IRQ by setting the appropriate bit in the interrupt mask register. When the specified edge is detected on the external interrupt line, an IRQ is generated, and the corresponding pending bit is set. This pending bit must be cleared by writing a <em class="italic">1</em> to it in the <span class="No-Break">pending register.</span></p>
			<p>To generate events, we simply configure the event line by setting the appropriate trigger registers and enabling the corresponding bit in the event <span class="No-Break">mask register.</span></p>
			<p>We can also generate interrupts/events by software by writing a <em class="italic">1</em> to the software interrupt/event <span class="No-Break">register (EXTI_SWIER).</span></p>
			<p>Configuring the <a id="_idIndexMarker1021"/>lines as interrupt sources involves <span class="No-Break">three steps:</span></p>
			<ol>
				<li><strong class="bold">Configure mask bits</strong>: Set the mask bits for the 23 interrupt lines using the <strong class="bold">Interrupt Mask </strong><span class="No-Break"><strong class="bold">Register</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">EXTI_IMR</strong></span><span class="No-Break">).</span></li>
				<li><strong class="bold">Configure trigger selection bits</strong>: Use the <strong class="bold">Rising Trigger Selection Register</strong> (<strong class="bold">EXTI_RTSR</strong>) and <strong class="bold">Falling Trigger Selection Register</strong> (<strong class="bold">EXTI_FTSR</strong>) to set the desired trigger conditions for the <span class="No-Break">interrupt lines.</span></li>
				<li><strong class="bold">Enable the NVIC IRQ channel</strong>: Over here, we simply configure the <strong class="bold">enable</strong> and <strong class="bold">mask</strong> bits that control the NVIC IRQ channel mapped to <span class="No-Break">the EXTI.</span></li>
			</ol>
			<p>Before we <a id="_idIndexMarker1022"/>develop the EXTI driver, let’s first understand how the EXTI lines are mapped to the <span class="No-Break">GPIO pins.</span></p>
			<h2 id="_idParaDest-237"><a id="_idTextAnchor407"/>External interrupt/event line mapping</h2>
			<p>The <a id="_idIndexMarker1023"/>EXTI controller can connect up to 81 GPIOs (in the STM32F411xC/E series) to the 16 external interrupt/event lines. The GPIO pins are mapped to the EXTI lines through the <span class="No-Break">SYSCFG_EXTICR registers.</span></p>
			<h3>GPIO pins and EXTI lines</h3>
			<p>Each <a id="_idIndexMarker1024"/>GPIO pin on the STM32 microcontroller can be connected to an EXTI line, allowing it to generate external interrupts. This flexibility <a id="_idIndexMarker1025"/>means you can enable interrupts for any GPIO pin, but there’s a catch: multiple pins share the same EXTI line. This sharing is based on the pin number, not <span class="No-Break">the port.</span></p>
			<p>Here’s a breakdown of how the pins <span class="No-Break">are connected:</span></p>
			<ul>
				<li>Pin 0 of every port is connected <span class="No-Break">to EXTI0_IRQ</span></li>
				<li>Pin 1 of every port is connected <span class="No-Break">to EXTI1_IRQ</span></li>
				<li>Pin 2 of every port is connected <span class="No-Break">to EXTI2_IRQ</span></li>
				<li>Pin 3 of every port is connected <span class="No-Break">to EXTI3_IRQ</span></li>
				<li>And <span class="No-Break">so on...</span></li>
			</ul>
			<p>This mapping means that all pins with the same number across different ports share the same EXTI line. For example, PA0, PB0, PC0, PD0, PE0, and PH0 are all connected <span class="No-Break">to EXTI0.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout"><strong class="bold">Shared EXTI lines</strong>: Since <a id="_idIndexMarker1026"/>multiple pins share the same EXTI line, you cannot enable interrupts on two pins with the same number across different ports simultaneously. For instance, if you enable an interrupt on PB0, you cannot also enable an interrupt on PA0 because both pins <span class="No-Break">share EXTI0.</span></p>
			<p class="callout"><strong class="bold">Configuration in SYSCFG_EXTICR</strong>: The SYSCFG <strong class="bold">external interrupt configuration registers</strong> (<strong class="bold">EXTICRs</strong>) are <a id="_idIndexMarker1027"/>used to select which port’s pin will be connected to a particular EXTI line. This selection ensures that only one pin from one port can be the source for a given <span class="No-Break">EXTI line.</span></p>
			<h1 id="_idParaDest-238"><a id="_idTextAnchor408"/>Developing the EXTI driver</h1>
			<p>The<a id="_idIndexMarker1028"/> STM32 EXTI module relies on several key registers to configure its operation. These registers allow you to set up trigger conditions, enable interrupts, and manage pending interrupt requests. Understanding these registers is crucial for effectively using the EXTI module in your <span class="No-Break">embedded projects.</span></p>
			<h2 id="_idParaDest-239"><a id="_idTextAnchor409"/>EXTI_IMR</h2>
			<p>We use the EXTI_IMR to<a id="_idIndexMarker1029"/> enable or disable interrupts on each <span class="No-Break">EXTI line.</span></p>
			<p>The bits in this register are named <strong class="bold">MRx</strong>. They are mask bits for each EXTI line (<strong class="source-inline">x</strong> = <strong class="source-inline">0</strong> to <strong class="source-inline">22</strong>). Setting a bit to <strong class="source-inline">1</strong> unmasks the interrupt line, allowing it to generate an interrupt request. Conversely, setting it to <strong class="source-inline">0</strong> masks the line, preventing it from <span class="No-Break">generating interrupts.</span></p>
			<h2 id="_idParaDest-240"><a id="_idTextAnchor410"/>EXTI_RTSR</h2>
			<p>The <a id="_idIndexMarker1030"/>EXTI_RTSR configures the rising edge trigger for each EXTI line. When a rising edge is detected on a line configured in this register, it can generate an interrupt or <span class="No-Break">an event.</span></p>
			<p>The bits in this register are named <strong class="bold">TRx</strong>. They are trigger selection bits for each EXTI line (<strong class="source-inline">x</strong> = <strong class="source-inline">0</strong> to <strong class="source-inline">22</strong>). Setting a bit to <strong class="source-inline">1</strong> configures the line to trigger on a <span class="No-Break">rising edge.</span></p>
			<h2 id="_idParaDest-241"><a id="_idTextAnchor411"/>EXTI_FTSR</h2>
			<p>The <a id="_idIndexMarker1031"/>EXTI_FTSR is used to configure the falling edge trigger for each EXTI line. When a falling edge is detected on a line set in this register, it can generate an interrupt or <span class="No-Break">an event.</span></p>
			<p>The bits in this register are named <strong class="bold">TRx</strong>. They are trigger selection bits for each EXTI line (<strong class="source-inline">x</strong> = <strong class="source-inline">0</strong> to <strong class="source-inline">22</strong>). Setting a bit to <strong class="source-inline">1</strong> configures the line to trigger on a <span class="No-Break">falling edge.</span></p>
			<h2 id="_idParaDest-242"><a id="_idTextAnchor412"/>Pending Register (EXTI_PR)</h2>
			<p>The EXTI_PR <a id="_idIndexMarker1032"/>indicates which EXTI lines have pending interrupt requests. This register is also used to clear pending interrupts by writing a <strong class="source-inline">1</strong> to the <span class="No-Break">appropriate bit.</span></p>
			<p>The bits in this register are named <strong class="bold">PRx</strong>. They are pending bits for each EXTI line (<strong class="source-inline">x</strong> = <strong class="source-inline">0</strong> to <strong class="source-inline">22</strong>). A bit set to <strong class="source-inline">1</strong> indicates a pending interrupt request. Writing <strong class="source-inline">1</strong> to the bit clears the <span class="No-Break">pending request.</span></p>
			<p>Let’s configure PC13 as an <span class="No-Break">EXTI pin.</span></p>
			<h2 id="_idParaDest-243"><a id="_idTextAnchor413"/>The EXTI driver</h2>
			<p>Create <a id="_idIndexMarker1033"/>a copy of your previous project in your IDE and rename this copied project <a id="_idTextAnchor414"/><strong class="source-inline">EXTI</strong>. Next, create a new file named <strong class="source-inline">gpio_exti.c</strong> in the <strong class="source-inline">Src</strong> folder and another file named <strong class="source-inline">gpio_exti.h</strong> in the <span class="No-Break"><strong class="source-inline">Inc</strong></span><span class="No-Break"> folder.</span></p>
			<p>Populate <strong class="source-inline">gpio_exti.c</strong> with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
<strong class="bold">#include</strong> "gpio_exti.h"
<strong class="bold">#define</strong> GPIOCEN            (1U&lt;&lt;2)
<strong class="bold">#define</strong> SYSCFGEN        (1U&lt;&lt;14)
<strong class="bold">void pc13_exti_init(void)</strong>
{
    /*Disable global interrupts*/
    __disable_irq();
    /*Enable clock access for GPIOC*/
    RCC-&gt;AHB1ENR |=GPIOCEN;
    /*Set PC13 as input*/
    GPIOC-&gt;MODER &amp;=~(1U&lt;&lt;26);
    GPIOC-&gt;MODER &amp;=~(1U&lt;&lt;27);
    /*Enable clock access to SYSCFG*/
    RCC-&gt;APB2ENR |=SYSCFGEN;
    /*Select PORTC for EXTI13*/
    SYSCFG-&gt;EXTICR[3] |=(1U&lt;&lt;5);
    /*<strong class="bold">Unmask</strong> EXTI13*/
    EXTI-&gt;IMR |=(1U&lt;&lt;13);
    /*Select falling edge trigger*/
    EXTI-&gt;FTSR |=(1U&lt;&lt;13);
    /*Enable EXTI13 line in NVIC*/
    NVIC_EnableIRQ(<strong class="bold">EXTI15_10_IRQn</strong>);
    /*Enable global interrupts*/
    __enable_irq();
}</pre>			<p>Let’s break down each step within the <span class="No-Break"><strong class="source-inline">pc13_exti_init</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
__disable_irq();</pre>			<p>This line <a id="_idIndexMarker1034"/>disables global interrupts to ensure that the configuration process is not interrupted, which is crucial for maintaining consistency and avoiding <span class="No-Break">race conditions.</span></p>
			<pre class="source-code">
RCC-&gt;AHB1ENR |= GPIOCEN;</pre>			<p>This line enables the clock for GPIOC by setting the appropriate bit in the <strong class="source-inline">AHB1</strong> peripheral clock enable <span class="No-Break">register (</span><span class="No-Break"><strong class="source-inline">AHB1ENR</strong></span><span class="No-Break">).</span></p>
			<pre class="source-code">
GPIOC-&gt;MODER &amp;= ~(1U&lt;&lt;26);
GPIOC-&gt;MODER &amp;= ~(1U&lt;&lt;27);</pre>			<p>These lines configure pin <strong class="source-inline">PC13</strong> as an input by clearing the appropriate bits in the GPIO mode <span class="No-Break">register (</span><span class="No-Break"><strong class="source-inline">MODER</strong></span><span class="No-Break">).</span></p>
			<pre class="source-code">
RCC-&gt;APB2ENR |= SYSCFGEN;</pre>			<p>This line enables the clock for <strong class="source-inline">SYSCFG</strong> by setting the appropriate bit in the <strong class="source-inline">APB2</strong> peripheral clock enable register (<strong class="source-inline">APB2ENR</strong>). <strong class="source-inline">SYSCFG</strong> is required for configuring the EXTI lines to map to the appropriate <span class="No-Break">GPIO pins.</span></p>
			<pre class="source-code">
SYSCFG-&gt;EXTICR[3] |= (1U&lt;&lt;5);</pre>			<p>This line configures the <strong class="source-inline">SYSCFG</strong> external interrupt configuration register to map EXTI line 13 to <strong class="source-inline">PORTC</strong>. The <strong class="source-inline">EXTICR[3]</strong> register controls EXTI lines 12 to 15, and setting the correct bits ensures that <strong class="source-inline">EXTI13</strong> is connected <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">PC13</strong></span><span class="No-Break">.</span></p>
			<pre class="source-code">
EXTI-&gt;IMR |= (1U&lt;&lt;13);</pre>			<p>This line unmasks EXTI line 13 by setting the appropriate bit in the interrupt mask register (<strong class="source-inline">IMR</strong>). Unmasking the line allows it to generate <span class="No-Break">interrupt requests.</span></p>
			<pre class="source-code">
EXTI-&gt;FTSR |= (1U&lt;&lt;13);</pre>			<p>This line<a id="_idIndexMarker1035"/> sets EXTI line 13 to trigger on a falling edge by setting the appropriate bit in the FTSR. This configuration is essential for detecting when the signal transitions from high <span class="No-Break">to low.</span></p>
			<pre class="source-code">
NVIC_EnableIRQ(EXTI15_10_IRQn);</pre>			<p>This line enables the <strong class="source-inline">EXTI15_10</strong> interrupt line in the NVIC. EXTI lines 10 to 15 share an IRQ in the NVIC, and enabling it allows the microcontroller to handle interrupts from <span class="No-Break">these lines.</span></p>
			<pre class="source-code">
__enable_irq();</pre>			<p>This line re-enables global interrupts after the configuration is complete, allowing the microcontroller to respond <span class="No-Break">to interrupts.</span></p>
			<p>Our next task is to populate the <span class="No-Break"><strong class="source-inline">gpio_exti.h</strong></span><span class="No-Break"> file.</span></p>
			<p>Here is <span class="No-Break">the code:</span></p>
			<pre class="source-code">
<strong class="bold">#ifndef</strong>  GPIO_EXTI_H__
<strong class="bold">#define</strong> GPIO_EXTI_H__
<strong class="bold">#include</strong> &lt;stdint.h&gt;
<strong class="bold">#include</strong> "stm32f4xx.h"
<strong class="bold">#define</strong>   LINE13        (1U&lt;&lt;13)
<strong class="bold">void pc13_exti_init</strong>(<strong class="bold">void</strong>);
<strong class="bold">#endif</strong></pre>			<p>Now, let’s test the driver in the <span class="No-Break"><strong class="source-inline">main.c</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
<strong class="bold">#include</strong> &lt;stdio.h&gt;
<strong class="bold">#include</strong> "adc.h"
<strong class="bold">#include</strong> "uart.h"
<strong class="bold">#include</strong> "gpio.h"
<strong class="bold">#include</strong> "gpio_exti.h"
uint8_t g_btn_press;
<strong class="bold">int main</strong>(<strong class="bold">void</strong>)
{
    /*Initialize debug UART*/
    uart_init();
    /*Initialize LED*/
    led_init();
    /*Initialize EXTI*/
    pc13_exti_init();
    <strong class="bold">while</strong>(1)
    {
    }
}
<strong class="bold">static void exti_callback</strong>(<strong class="bold">void</strong>)
{
    <strong class="bold">printf</strong>("BTN Pressed...\n\r");
    led_toggle();
}
<strong class="bold">void EXTI15_10_IRQHandler</strong>(<strong class="bold">void</strong>) {
    <strong class="bold">if</strong>((EXTI-&gt;PR &amp; LINE13)!=0)
    {
        /*Clear PR flag*/
        EXTI-&gt;PR |=LINE13;
        //Do something...
        exti_callback();
    }
}</pre>			<p>Let’s break <a id="_idIndexMarker1036"/>down <span class="No-Break">the code:</span></p>
			<ul>
				<li>The main function initializes the system components and then enters an <span class="No-Break">infinite loop.</span></li>
				<li>The <strong class="source-inline">exti_callback</strong> function is called when the external <span class="No-Break">interrupt occurs.</span></li>
				<li><strong class="source-inline">EXTI15_10_IRQHandler</strong> handles interrupts for EXTI lines 10 to 15, including line <span class="No-Break">13 (</span><span class="No-Break"><strong class="source-inline">PC13</strong></span><span class="No-Break">)</span></li>
			</ul>
			<pre class="source-code">
if((EXTI-&gt;PR &amp; LINE13) != 0)</pre>			<p>The preceding line checks whether the pending bit for EXTI line 13 is set, indicating an interrupt <span class="No-Break">has occurred.</span></p>
			<pre class="source-code">
EXTI-&gt;PR |= LINE13;</pre>			<p>The preceding line clears the pending bit by writing a <strong class="source-inline">1</strong> to it, acknowledging the interrupt, and allowing it to be <span class="No-Break">processed again.</span></p>
			<pre class="source-code">
exti_callback();</pre>			<p>This <a id="_idIndexMarker1037"/>calls the <strong class="source-inline">exti_callback</strong> function to handle the interrupt, which, in our case<a id="_idTextAnchor415"/>, prints a message and toggles <span class="No-Break">the LED.</span></p>
			<p>To test on the microcontroller, simply build the project and run it. To generate the EXTI interrupt, press the blue <span class="No-Break">push button.</span></p>
			<p>Open RealTerm and configure the appropriate port and baud rate to view the printed message that confirms the EXTI interrupts occur when the blue push button <span class="No-Break">is pressed.</span></p>
			<h1 id="_idParaDest-244"><a id="_idTextAnchor416"/>Summary</h1>
			<p>In this chapter, we learned about the important role of interrupts in embedded systems development. Interrupts are essential for creating responsive and efficient firmware, allowing microcontrollers to handle real-time events effectively. By mastering the concepts of interrupts, you can develop systems that react promptly to external stimuli, enhancing the robustness and versatility of your <span class="No-Break">embedded applications.</span></p>
			<p>We started by exploring the fundamental role of interrupts in firmware, comparing them with exceptions to highlight their unique purposes and handling mechanisms. We then examined the specifics of the ISR, the IVT, and the NVIC, which together form the backbone of interrupt handling in Arm <span class="No-Break">Cortex-M microcontrollers.</span></p>
			<p>Next, we focused on the STM32 EXTI controller, a vital peripheral for managing external interrupts in STM32 microcontrollers. We discussed the key features and registers of the EXTI, and how to configure and utilize it for <span class="No-Break">various applications.</span></p>
			<p>Finally, we applied this knowledge by developing an EXTI driver, providing practical experience in implementing <span class="No-Break">interrupt-driven firmware.</span></p>
			<p>In the next chapter, we will learn about the <strong class="bold">Realtime Clock</strong> (<span class="No-Break"><strong class="bold">RTC</strong></span><span class="No-Break">) peripheral.</span></p>
		</div>
	</div>
</div>
</body></html>