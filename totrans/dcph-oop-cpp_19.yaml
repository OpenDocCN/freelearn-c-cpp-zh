- en: '19'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the Singleton Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will continue our goal to expand your C++ programming skills beyond
    core OOP concepts, with the objective of empowering you to solve recurring types
    of coding conundrums utilizing core design patterns. Utilizing design patterns
    in coding solutions can not only provide refined solutions but also contribute
    to easier code maintenance and provide potential opportunities for code reuse.
  prefs: []
  type: TYPE_NORMAL
- en: The next core design pattern that we will learn how to implement effectively
    in C++ is the **Singleton pattern**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Singleton pattern and how it contributes to OOP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the Singleton pattern in C++ (with simple techniques versus a paired-class
    approach), and using a registry to allow many classes to utilize the Singleton
    pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand the Singleton pattern and how
    it can be used to ensure that only a single instance of a given type can exist.
    Adding an additional core design pattern to your knowledge set will further augment
    your programming skills to help you become a more valuable programmer.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s increase our programming skillset by examining another common design pattern,
    the Singleton pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Online code for full program examples can be found in the following GitHub
    URL: [https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter19](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter19).
    Each full program example can be found in the GitHub repository under the appropriate
    chapter heading (subdirectory) in a file that corresponds to the chapter number,
    followed by a dash, followed by the example number in the chapter at hand. For
    example, the first full program in this chapter can be found in the subdirectory
    `Chapter19` in a file named `Chp19-Ex1.cpp` under the aforementioned GitHub directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/3ThNKe0](https://bit.ly/3ThNKe0).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Singleton pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Singleton pattern is a creational design pattern that guarantees only one
    instance will exist for a class embracing this idiom; two or more instances of
    the type may simply not exist simultaneously. A class embracing this pattern will
    be known as a **Singleton**.
  prefs: []
  type: TYPE_NORMAL
- en: A Singleton can be implemented using static data members and static methods.
    This means that a Singleton will have a global point of access to the instance
    at hand. This ramification initially seems dangerous; introducing global state
    information into the code is one criticism that has led the Singleton to sometimes
    be considered an anti-pattern. However, with the appropriate use of access regions
    for the static data members defining the Singleton, we can insist that access
    to the Singleton (other than initialization) only uses the appropriate static
    methods of the class at hand (and alleviate this potential pattern concern).
  prefs: []
  type: TYPE_NORMAL
- en: Another criticism of the pattern is that it is not thread-safe. There may be
    race conditions to enter the segment of code where the Singleton instance is created.
    Without guaranteeing mutual exclusivity to that critical region of code, the Singleton
    pattern will break, allowing multiple such instances. As such, if multithreaded
    programming is employed, so must be proper locking mechanisms to protect the critical
    region of code where the Singleton is instantiated. A Singleton (implemented using
    static memory) is shared memory between threads in the same process; at times,
    Singleton can be criticized for monopolizing resources.
  prefs: []
  type: TYPE_NORMAL
- en: The Singleton pattern can utilize several techniques for implementation. Each
    manner of implementation inevitably will have benefits and drawbacks. We will
    use a pair of related classes, `Singleton` and `SingletonDestroyer`, to robustly
    fulfill the pattern. Whereas there are more simple, straightforward implementations
    (two of which we will briefly review), the simplest techniques leave the possibility
    that the Singleton will not be adequately destructed. Recall that a destructor
    may include important and necessary activities.
  prefs: []
  type: TYPE_NORMAL
- en: Singletons tend to be long-lived; it is, therefore, appropriate for a Singleton
    to be destructed just before the application terminates. Many Clients may have
    pointers to a Singleton, so no single Client should delete the Singleton. We will
    see that a `Singleton` will be *self-created*, so it should ideally be *self-destructed*
    (that is, with the help of its `SingletonDestroyer`). As such, the paired-class
    approach, though not as simple, will ensure proper `Singleton` destruction. Note
    that our implementation will also allow the Singleton to be directly deleted;
    this is rare, but our code will also handle this situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Singleton pattern with the paired-class implementation will include the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: A **Singleton** class, which represents the core mechanics needed to implement
    the concept of a Singleton.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Singleton`, ensuring that a given Singleton is properly destructed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A class derived from `Singleton` represents a class that we want to ensure can
    only create a single instance of its type at a given time. This will be our **Target**
    class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optionally, the Target class may be both derived from `Singleton` and another
    class, which may represent existing functionality that we would like to specialize
    in or simply encompass (that is, *mix-in*). In this case, we will multiply inherit
    from an application-specific class and the Singleton class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional **Client** classes, which will interact with the Target class(es) to
    fully define the application at hand.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternatively, the Singleton may also be implemented within a Target class,
    bundling the class functionalities together in a single class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A true Singleton pattern can be expanded to allow for multiple (discrete), but
    not an undetermined number of instances to be made. This is rare.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will focus on a traditional Singleton pattern that ensures only a single
    instance of a class embracing this pattern will exist at a given time.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move forward to first examine two simple implementations, then our preferred
    paired-class implementation of the Singleton pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Singleton pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Singleton pattern will be used to ensure that a given class may only instantiate
    a single instance of that class. However, a true Singleton pattern will also have
    expansion capabilities to allow for multiple (but a well-defined number of) instances
    to be made. This unusual and not well-known caveat of the Singleton pattern is
    rare.
  prefs: []
  type: TYPE_NORMAL
- en: We will start with two simple Singleton implementations to understand their
    limitations. We will then progress to the more robust paired-class implementation
    of the Singleton, with the most common pattern goal of only allowing one Target
    class instantiation at any given time.
  prefs: []
  type: TYPE_NORMAL
- en: Using a simple implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To implement a very simple Singleton, we will use a straightforward single class
    specification for the Singleton itself. We will define a class, known as `Singleton`,
    to encapsulate the pattern. We will ensure that our constructor(s) are private
    so that they cannot be applied more than once. We will also add a static `instance()`
    method to provide the interface for instantiation of the `Singleton` object. This
    method will ensure that the private construction occurs exactly once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at this straightforward implementation, which can be found
    in our GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter19/Chp19-Ex1.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter19/Chp19-Ex1.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Notice, in the aforementioned class definition, we include data member `static
    Singleton *theInstance;` to represent the `Singleton` instance itself. Our constructor
    is private so it cannot be used multiple times to create multiple `Singleton`
    instances. Instead, we add a `static Singleton *instance()` method to create the
    `Singleton`. Within this method, we check whether data member `theInstance` is
    equal to the `nullptr` and if so, we instantiate the one and only `Singleton`
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: Outside of the class definition, we see the external variable (and its initialization)
    to support the memory requirements of the static data member with the definition
    of `Singleton *Singleton::theInstance = nullptr;`. We also see how, in `main()`,
    we call the static `instance()` method to create a `Singleton` instance using
    `Singleton::instance()`. The first call to this method will instantiate a `Singleton`,
    whereas subsequent calls to this method will merely return a pointer to the existing
    `Singleton` object. We can verify that the instances are the same by printing
    the address of these objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the output for this simple program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the previously mentioned output, we notice something perhaps unexpected –
    the destructor is not called! What if the destructor had crucial tasks to perform?
  prefs: []
  type: TYPE_NORMAL
- en: Understanding a key deficiency with the simple Singleton implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The destructor is not called for our `Singleton` in the simple implementation
    merely because we have not deleted the dynamically allocated `Singleton` instance
    through either the `s1` or `s2` identifiers. Why not? There clearly may be multiple
    pointers (handles) to a `Singleton` object. Deciding which handle should be responsible
    for removing the `Singleton` is difficult to determine – the handles would minimally
    need to collaborate or employ reference counting.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, a `Singleton` tends to exist for the duration of the application.
    This longevity further suggests that a `Singleton` should be in charge of its
    own destruction. But how? We soon see an implementation that will allow a `Singleton`
    to control its own destruction with a helper class. With the simple implementation,
    however, we might simply throw our hands in the air and suggest that the operating
    system will reclaim the memory resources when the application terminates – including
    the heap memory for this small `Singleton`. This is true; however, what if an
    important task needs to be completed in the destructor? We are running into a
    limitation within the simple pattern implementation.
  prefs: []
  type: TYPE_NORMAL
- en: If we need the destructor to be called, shall we resort to allowing one of the
    handles to delete the instance using, for example, `delete s1;`? We have previously
    reviewed issues regarding whether to allow any one handle to perform the deletion,
    but let’s now additionally examine potential issues within the destructor itself.
    For example, if our destructor hypothetically only includes `delete theInstance;`,
    we will have a recursive function call. That is, calling `delete s1;` will invoke
    the `Singleton` destructor, yet `delete theInstance;` within the destructor body
    will recognize `theInstance` as a `Singleton` type and again call the `Singleton`
    destructor – *recursively*.
  prefs: []
  type: TYPE_NORMAL
- en: Not to worry! Our destructor, as shown, instead manages recursion by first checking
    whether `theInstance` data member is not equal to the `nullptr` and then arranges
    for `temp` to point to `theInstance` to save a handle to the instance we need
    to delete. We then make the assignment `temp->theInstance = nullptr;` to prevent
    recursion when we `delete temp;`. Why? Because `delete temp;` will also call the
    `Singleton` destructor. Upon this destructor call, `temp` will bind to `this`
    and will fail the conditional test `if (theInstance != nullptr)` on this first
    recursive function call, backing us out of continued recursion. Note that our
    upcoming implementation with a paired-class approach will not have this potential
    issue.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that in an actual application, we would not create a
    domain-unspecific `Singleton` instance. Rather, we would factor our application
    into the design to employ the pattern. After all, we want to have a `Singleton`
    instance of a meaningful class type. To do so using our simple `Singleton` class
    as a basis, we simply inherit our Target (application-specific) class from `Singleton`.
    The Target class will also have private constructors – ones that accept the arguments
    necessary to adequately instantiate the Target class. We will then move the static
    `instance()` method from `Singleton` to the Target class and ensure that the argument
    list for `instance()` accepts the necessary arguments to pass to a private Target
    constructor.
  prefs: []
  type: TYPE_NORMAL
- en: To sum up, our simple implementation has the inherent design flaw that there
    is no guaranteed proper destruction for the `Singleton` itself. Letting the operating
    system collect the memory when the application terminates does not call the destructor.
    Choosing one of many handles for the `Singleton` to delete the memory, though
    possible, requires coordination and also defeats the usual application of the
    pattern to allow the `Singleton` to live for the duration of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Let us next consider an alternate simple implementation of using a reference
    to static local memory, rather than a pointer to heap memory, for our Singleton.
  prefs: []
  type: TYPE_NORMAL
- en: An alternate simple implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As an alternative approach for implementing a very straightforward Singleton,
    we will modify the previous simple class definition. First, we will remove the
    static pointer data member (which was dynamically allocated within `Singleton::instance()`).
    Instead of using a static data member within the class, we will use a (non-pointer)
    static local variable within the `instance()` method to represent the Singleton.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at this alternative implementation, which can be found in
    our GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter19/Chp19-Ex1b.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter19/Chp19-Ex1b.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Notice, in the aforementioned Singleton class definition, we no longer include
    a static data member (nor the external static variable declaration to support
    this data member) to represent the `Singleton` instance itself. Instead, we have
    specified the Singleton’s implementation using a static local (non-pointer) variable
    in the static `instance()` method. Our constructor is private; it can be invoked
    to initialize this static local variable within a static member function of the
    class. The local variable, as static (and not a pointer with an allocation), will
    only be created and initialized once. Its space will be set aside when the application
    starts and the static variable will be initialized upon the first call to `instance()`.
    Subsequent calls to `instance()` will not yield a replacement of this `Singleton`;
    the static local variable declaration will be ignored for anything other than
    the first call to `instance()`. Notice that the return value of `instance()` is
    now a reference (`&`) to this static local `Singleton` instance. Remember, a static
    local variable will exist for the entire application (it is not stored on the
    stack with other local variables).
  prefs: []
  type: TYPE_NORMAL
- en: Also, quite importantly, notice that we have passed data to initialize the Singleton
    to the `instance()` method via the parameter list; this data is passed along to
    the `Singleton` constructor. The ability to construct the Singleton with appropriate
    data is quite important. By implementing the Singleton as a static local (non-pointer)
    variable in the static `instance()` method, we have the opportunity to construct
    the Singleton within this method. Note that a static pointer data member defined
    in the class also has this ability, as the allocation (and hence construction,
    such as in the previous example) is also made within the `instance()` method.
    However, a non-pointer static data member of the class would not allow the ability
    to provide meaningful constructor arguments because the instance would be created
    and initialized at the start of the program before such meaningful initializers
    would be available (not actually within the `instance()` method). In the latter
    case, the Singleton would only be returned from `instance()`, not initialized
    within it.
  prefs: []
  type: TYPE_NORMAL
- en: Now notice, in `main()`, we call the static `instance()` method to create a
    `Singleton` instance using `Singleton::instance()`. We create an alias, `s1`,
    using a reference to the Singleton returned from `Singleton::instance()`. The
    first call to this method will instantiate the `Singleton`, whereas subsequent
    calls to this method will merely return a reference to the existing `Singleton`
    object. We can verify that the instance referenced by both aliases (`s1` and `s2`)
    is the same object by printing the data contained within the Singleton.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the output for this simple program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the previously mentioned output, we notice that the destructor is automatically
    called to clean up the Singleton before the application ends. We also notice that
    the attempted creation of the second `Singleton` instance only returns the existing
    `Singleton`. This is because the static local variable, `theInstance`, is only
    created and initialized only once per application, no matter how many times `instance()`
    is invoked (a simple property of static local variables). However, this implementation
    also has a potential drawback; let’s take a look.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding a limitation with the alternate simple Singleton implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The implementation using a non-pointer static local variable in `instance()`
    for the Singleton does not give us the flexibility to change the Singleton. In
    a function, any static local variable has its memory set aside when the application
    begins; this memory is only initialized once (on the initial call to `instance()`).
    The implication is that we always have exactly one `Singleton` in the application.
    The space for this `Singleton` exists even if we never call `instance()` to initialize
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the `Singleton` in this implementation cannot be exchanged for
    another `Singleton` object due to the nature of how static local variables are
    implemented. In some applications, we may want one `Singleton` object at a time,
    yet also desire the ability to change out one instance of a `Singleton` for another.
    Imagine, for example, that an organization can have exactly one president; however,
    it is desirable that the (Singleton) president can be replaced every few years
    with a different (Singleton) president. The initial simple implementation using
    a pointer allows for this possibility, yet has the potential deficiency that its
    destructor is never called. Each of the simple implementations has a potential
    drawback.
  prefs: []
  type: TYPE_NORMAL
- en: Now, because we understand the limitations of the simple Singleton implementations,
    we will instead move onward to a preferred paired-class implementation of the
    Singleton pattern. The paired-class approach will guarantee proper destruction
    of our `Singleton`, whether the application allows the `Singleton` to be destructed
    just prior to the application’s termination through the deliberate class pairing
    (the most frequently encountered situation), or in the rare case that a `Singleton`
    is destroyed prematurely in the application. This approach will also allow us
    to replace a Singleton with another instance of a Singleton.
  prefs: []
  type: TYPE_NORMAL
- en: Using a more robust paired-class implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To implement the Singleton pattern with a paired-class approach in a nicely
    encapsulated fashion, we will define a Singleton class to purely add the core
    mechanics of creating a single instance. We will name this class `Singleton`.
    We will then add a helper class to `Singleton`, known as `SingletonDestroyer`,
    to ensure that our `Singleton` instance always goes through proper destruction
    before our application terminates. This pair of classes will be related through
    aggregation and association. More specifically, the `Singleton` will conceptually
    contain a `SingletonDestroyer` (aggregate), and the `SingletonDestroyer` will
    hold an association to the (outer) `Singleton` in which it is conceptually embedded.
    Because the implementation of the `Singleton` and `SingletonDestroyer` is through
    static data members, the aggregation is conceptual – static members are stored
    as external variables.
  prefs: []
  type: TYPE_NORMAL
- en: Once these core classes have been defined, we will consider how we may incorporate
    the Singleton pattern into a class hierarchy with which we have familiarity. Let’s
    imagine that we would like to implement a class to encapsulate the concept of
    a *president*. Whether it be a president of a nation or the president of a university,
    it is important that there be only one president at a given point in time. `President`
    will be our Target class; `President` is a good candidate to utilize our Singleton
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: It is interesting to note that, whereas there will only be one president at
    a given point in time, it is possible to replace a president. For example, the
    term of a U.S. president is only four years at a time, with possible re-election
    for one more term. There may be similar conditions for a university president.
    A president may leave prematurely through resignation, impeachment, or death,
    or may simply leave upon term expiration. Once a sitting president’s existence
    is removed, it is then acceptable to instantiate a new, Singleton `President`.
    Hence, our Singleton pattern allows only one Singleton of the Target class at
    a given point in time.
  prefs: []
  type: TYPE_NORMAL
- en: Reflecting on how we may best implement a `President` class, we realize that
    a `President` *Is-A* `Person` and also needs to *mix-in* `Singleton` capabilities.
    With this in mind, we now have our design. `President` will use multiple inheritances
    to extend the concept of `Person` and to mix-in the functionality of a `Singleton`.
  prefs: []
  type: TYPE_NORMAL
- en: Certainly, we could have built a `President` class from scratch, but why do
    so when the `Person` components of the `President` class are represented in a
    well-tested and available class? Also, certainly, we could embed the `Singleton`
    class information into our `President` class, rather than inheriting it from a
    separate `Singleton` class. Absolutely, this is also an option. However, our application
    will instead encapsulate each piece of the solution. This will enable easier future
    reuse. Nonetheless, the design choices are many.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying the Singleton and the SingletonDestroyer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s take a look at the mechanics of our Singleton pattern, starting by examining
    the `Singleton` and `SingletonDestroyer` class definitions. These classes work
    cooperatively to implement the Singleton pattern. This example can be found, as
    a complete program, on our GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter19/Chp19-Ex2.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter19/Chp19-Ex2.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned code segment, we begin with several forward class declarations,
    such as `class Singleton;`. These declarations allow references to be made to
    these data types before their complete class definitions have been seen by the
    compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s take a look at our `SingletonDestroyer` class definition. This simple
    class contains a private data member, `Singleton *theSingleton;`, which will be
    the association to the `Singleton` that the `SingletonDestroyer` will one day
    be responsible for deallocating (we will examine the destructor definition for
    `SingletonDestroyer` shortly). Notice that our destructor is not virtual as this
    class is not meant to be specialized.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that our constructor has a default value of the `nullptr` specified for
    the `Singleton *`, which is an input parameter. `SingletonDestroyer` also contains
    two member functions, `setSingleton()` and `getSingleton()`, which merely provide
    the means to *set* and *get* the associated `Singleton` member.
  prefs: []
  type: TYPE_NORMAL
- en: Also notice that both the use of the copy constructor and the overloaded assignment
    operator in `SingletonDestroyer` have been disallowed using `=delete` in their
    prototypes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we examine the destructor for this class, let us examine the class definition
    for `Singleton`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The aforementioned `Singleton` class contains protected data member `static
    Singleton *theInstance;`, which will represent (when allocated) a pointer to the
    one and only instance allocated for a class employing the Singleton idiom.
  prefs: []
  type: TYPE_NORMAL
- en: The protected data member `static SingletonDestroyer destroyer;` represents
    a conceptual aggregate or contained member. The containment is truly only conceptual,
    as static data members are not stored within the memory layout for any instance;
    they are instead stored in external memory and *name-mangled* to appear as part
    of the class. This (conceptual) aggregate subobject, `destroyer`, will be responsible
    for the proper destruction of the `Singleton`. Recall that the `SingletonDestroyer`
    has an association with the one and only `Singleton`, representing the outer object
    in which the `SingletonDestroyer` is conceptually contained. This association
    is how the `SingletonDestroyer` will access the Singleton.
  prefs: []
  type: TYPE_NORMAL
- en: When the memory for the external variable that implements the static data member
    `static SingletonDestroyer destroyer;` goes away at the end of the application,
    the destructor for `SingletonDestroyer` (the static, conceptual, subobject) will
    be called. This destructor will `delete theSingleton;`, ensuring that the outer
    `Singleton` object (which was dynamically allocated), will have the appropriate
    destructor sequence run on it. Because the destructor in `Singleton` is protected,
    it is necessary that `SingletonDestroyer` is specified as a friend class of `Singleton`.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that both uses of the copy constructor and the overloaded assignment
    operator in `Singleton` have been disallowed using `=delete` in their prototypes.
  prefs: []
  type: TYPE_NORMAL
- en: In our implementation, we have assumed that `Singleton` will be mixed-in via
    inheritance to a derived Target class. It will be in the derived class (the one
    that intends to use the Singleton idiom), that we provide the required static
    `instance()` method to create the `Singleton` instance. Note that had `Singleton`
    been used as a standalone class to create Singletons, we would instead add `static
    Singleton* instance()` to the public access region of `Singleton`. We would also
    then move the data members from the protected to the private access region. However,
    having an application-unspecific Singleton is only of use to demonstrate the concept.
    Instead, we will apply the Singleton idiom to an actual type requiring the use
    of this idiom.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our `Singleton` and `SingletonDestroyer` class definitions in place, let’s
    next examine the remaining implementation necessities for these classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned code fragment, let’s first notice the two external variable
    definitions that provide the memory to support the two static data members within
    the `Singleton` class – that is, `Singleton *Singleton::theInstance = nullptr;`
    and `SingletonDestroyer Singleton::destroyer;`. Recall that static data members
    are not stored within any instance of their designated class. Rather, they are
    stored in external variables; these two definitions designate the memory. Notice
    that the data members are both labeled as `protected`. This means that though
    we may define their outer storage directly in this manner, we may not access these
    data members other than through static member functions of `Singleton`. This will
    give us some peace of mind. Though there is a potential global access point to
    the static data members, their levied protected access region requires appropriate
    static methods of the `Singleton` class to be used to properly manipulate these
    important members.
  prefs: []
  type: TYPE_NORMAL
- en: Next, draw your attention to the destructor for `SingletonDestroyer`. This clever
    destructor first checks whether its association to the `Singleton` for which it
    is responsible is equal to the `nullptr`. This will be rare and will happen in
    the very unusual situation when a Client releases the Singleton object directly
    with an explicit `delete`.
  prefs: []
  type: TYPE_NORMAL
- en: The usual destruction scenario in the `SingletonDestroyer` destructor will be
    the execution of the `else` clause in which the `SingletonDestructor`, as a static
    object, will be responsible for the deletion, and hence destruction, of its paired
    `Singleton`. Remember, there will be a contained `SingletonDestroyer` object within
    the `Singleton`. The memory for this static (conceptual) subobject will not go
    away until the application has finished. Recall that static memory is not actually
    part of any instance. However, the static subobject will be destructed just prior
    to `main()`’s completion. So, when the `SingletonDestroyer` is destructed, its
    usual case will be to `delete theSingleton;`, which will release its paired Singleton’s
    memory, allowing the `Singleton` to be properly destructed.
  prefs: []
  type: TYPE_NORMAL
- en: The driving design decision behind the Singleton pattern is that a Singleton
    is a long-lived object, and its destruction may most often correctly occur near
    the end of the application. The Singleton is responsible for its own inner Target
    object creation so that the Singleton should not be deleted (and hence destructed)
    by a Client. Rather, the preferred mechanism is that the `SingletonDestroyer`,
    when removed as a static object, deletes its paired `Singleton`.
  prefs: []
  type: TYPE_NORMAL
- en: Nonetheless, occasionally, there are reasonable scenarios for deleting a `Singleton`
    mid-application. Should a replacement `Singleton` never be created, our `SingletonDestroyer`
    destructor will still work correctly, identifying that its paired `Singleton`
    has already been released. However, it is more likely that our `Singleton` will
    be replaced with another `Singleton` instance somewhere in the application. Recall
    our application example where a president may be impeached, resign, or die, but
    will be replaced by another president. In these cases, it is acceptable for a
    `Singleton` to be deleted directly and a new `Singleton` is then created. In this
    case, the `SingletonDestroyer` will now reference the replacement `Singleton`.
  prefs: []
  type: TYPE_NORMAL
- en: Deriving a Target class from Singleton
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, let’s take a look at how we can create our Target class, `President`,
    from `Singleton`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In our aforementioned Target class, `President`, we merely inherit `President`
    from `Person` using public inheritance and then multiply inherit `President` from
    `Singleton` to *mix-in* the `Singleton` mechanics.
  prefs: []
  type: TYPE_NORMAL
- en: We place our constructor in the private access region. Static method `instance()`
    will utilize this constructor internally to create the one and only `Singleton`
    instance permitted, to adhere to the pattern. There is no default constructor
    (unusual) because we do not wish to allow `President` instances to be created
    without their relevant details. Recall that C++ will not link in a default constructor
    if we have provided an alternate constructor interface. As we do not desire copies
    of a `President` or the assignment of a `President` to another potential `President`,
    we have disallowed copies and assignments using the `=delete` specification in
    the prototypes for these methods.
  prefs: []
  type: TYPE_NORMAL
- en: Our destructor for `President` is simple, yet crucial. In the case that our
    `Singleton` object will be deleted explicitly, we prepare by setting `destroyer.setSingleton(nullptr);`.
    Recall, `President` inherits the protected `static SingletonDestroyer destroyer;`
    data member. Here, we are setting the destroyer’s associated `Singleton` to the
    `nullptr`. This line of code in our `President` destructor then enables the destructor
    in `SingletonDestroyer` to accurately depend on checking for the unusual case
    of whether its associated `Singleton` has already been deleted before commencing
    the usual deletion of its `Singleton` counterpart.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have defined a static method to provide the creation interface for
    our `President` as a `Singleton` with `static President *instance(const string
    &, const string &, char, const string &);`. In the definition of `instance()`,
    we first check whether the inherited, protected data member `Singleton *theInstance`
    is equal to the `nullptr`. If we have not yet allocated the `Singleton`, we allocate
    `President` using the aforementioned private constructor and assign this newly
    allocated `President` instance to `theInstance`. This is an upcast from a `President
    *` to a `Singleton *`, which is no problem across a public inheritance boundary.
    If, however, in the `instance()` method, we find that `theInstance` is not equal
    to a `nullptr`, we simply return a pointer to the previously allocated `Singleton`
    object. As users will undoubtedly want to use this object as a `President` to
    enjoy the inherited `Person` features, we downcast `theInstance` to `President
    *` for its return value from this method.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let us consider the logistics of a sample Client in our overall application.
    In its simplest form, our Client will contain a `main()` function to drive the
    application and showcase our Singleton pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Bringing the pattern components together within the Client
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s now take a look at our `main()` function to see how our pattern is orchestrated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Reviewing our `main()` function in the preceding code, we first allocate a Singleton
    `President` using `President *p1 = President::instance("John"``, "Adams", 'Q',
    "President");`. We then try to allocate an additional `President` on the next
    line of code using `*p2`. Because we can only have one `Singleton` (a `President`
    *mixes-in* a `Singleton`), a pointer is returned to our existing `President` and
    stored in `p2`. We verify that there is only one `Singleton` by comparing `p1
    == p2`; the pointers indeed point to the same instance.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we take advantage of using our `President` instance in its intended manner,
    such as by using some of the inherited member functions from `Person`. As an example,
    we invoke `p1->Print();`. Certainly, our `President` class could have added specialized
    functionality that would be appropriate to utilize in our Client as well.
  prefs: []
  type: TYPE_NORMAL
- en: Now, at the end of `main()`, our static object `SingletonDestroyer Singleton::destroyer;`
    will be appropriately destructed before its memory is reclaimed. As we have seen,
    the destructor for `SingletonDestroyer` will (most often) issue a `delete` to
    its associated `Singleton` (which is actually a `President`) using `delete theSingleton;`.
    This will trigger our `President` destructor, `Singleton` destructor, and `Person`
    destructor to each be called and executed (going from most specialized to most
    general subobjects). As our destructor in `Singleton` is virtual, we are guaranteed
    to start at the proper level for destruction and to include all destructors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the output for this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding output, we can visualize the creation of the Singleton `President`,
    as well as see that the second `instance()` request for a `President` merely returns
    the existing `President`. We then see the details of the `President` that were
    printed.
  prefs: []
  type: TYPE_NORMAL
- en: Most interestingly, we can see the destruction sequence for the `Singleton`,
    which is driven by the static object reclamation of the `SingletonDestroyer`.
    Through proper deletion of the `Singleton` in the `SingletonDestroyer` destructor,
    we see that `President`, `Singleton`, and `Person` destructors are each invoked
    as they contribute to the complete `President` object.
  prefs: []
  type: TYPE_NORMAL
- en: Examining explicit Singleton deletion and its impact on SingletonDestroyer destructor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s take a look at an alternate version of the Client with an alternate `main()`
    function. Here, we force deletion of our `Singleton`; this is rare. In this scenario,
    our `SingletonDestroyer` will not delete its paired `Singleton`. This example
    can be found, as a complete program, in our GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter19/Chp19-Ex3.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter19/Chp19-Ex3.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned `main()` function, notice that we explicitly deallocate
    our Singleton `President` using `delete p1;`, versus allowing the instance to
    be reclaimed via static objection deletion as the program ends. Fortunately, we
    have included a test in our `SingletonDestroyer` destructor to let us know whether
    the `SingletonDestroyer` must delete its associated `Singleton` or whether this
    deletion has already occurred.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the revised output to notice the differences from our
    original `main()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned output for our revised Client, we can again visualize
    the creation of the Singleton `President`, the *unsuccessful* creation request
    of a second `President`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s notice the destruction sequence and how it differs from our first Client.
    Here, the Singleton `President` is explicitly deallocated. We can see the proper
    deletion of the `President` through the call and execution of the destructors
    in `President`, `Singleton`, and `Person` as each is executed. Now, when the application
    is about to end and the static `SingletonDestroyer` is about to have its memory
    reclaimed, we can visualize the destructor called on the `SingletonDestroyer`.
    However, this destructor no longer will delete its associated `Singleton`.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding design advantages and disadvantages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An advantage of the preceding (paired-class) implementation of the Singleton
    pattern (irrespective of which `main()` is employed) is that we have guaranteed
    proper destruction of the `Singleton`. This happens regardless of whether the
    `Singleton` is long-lived and is deleted in its usual fashion by its associated
    `SingletonDestroyer`, or whether it is deleted earlier on in the application directly
    (a rare scenario).
  prefs: []
  type: TYPE_NORMAL
- en: A disadvantage of this implementation is inherited from the concept of the `Singleton`.
    That is, there can only be one derived class of `Singleton` that incorporates
    the specific mechanics of the `Singleton` class. Because we have inherited `President`
    from `Singleton`, we are using the Singleton logistics (namely static data members,
    stored in external variables) for `President` and `President` alone. Should another
    class wish to be derived from `Singleton` to embrace this idiom, the internal
    implementation for the `Singleton` has already been utilized for `President`.
    Ouch! That does not seem fair.
  prefs: []
  type: TYPE_NORMAL
- en: Not to worry! Our design can be easily expanded to accommodate multiple classes
    that wish to use our `Singleton` base class. We will augment our design to accommodate
    multiple `Singleton` objects. We will assume, however, that we still intend to
    have only one `Singleton` instance per class type.
  prefs: []
  type: TYPE_NORMAL
- en: Another potential concern is thread safety. For example, if multithreaded programming
    will be utilized, we need to ensure that our `static President::instance()` method
    acts as though it is atomic, that is, uninterruptible. We can do this through
    carefully synchronized access to the static method itself.
  prefs: []
  type: TYPE_NORMAL
- en: Let us now take a brief look at how we may expand the Singleton pattern to solve
    this issue.
  prefs: []
  type: TYPE_NORMAL
- en: Using a registry to allow many classes to utilize Singleton
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us more closely examine a shortcoming with our current Singleton pattern
    implementation. Currently, there can only be one derived class of `Singleton`
    that can effectively utilize the `Singleton` class. Why is this? `Singleton` is
    a class that comes with external variable definitions to support the static data
    members within the class. The static data member representing `theInstance` (implemented
    using the external variable `Singleton *Singleton::theInstance`) may only be set
    to one `Singleton` instance. *Not one per class* – there is only one set of external
    variables creating the memory for the crucial `Singleton` data members of `theInstance`
    and `destroyer`. Herein lies the problem.
  prefs: []
  type: TYPE_NORMAL
- en: We can, instead, specify a `Registry` class to keep track of the classes applying
    the Singleton pattern. There are many implementations for a **Registry**, and
    we will review one such implementation.
  prefs: []
  type: TYPE_NORMAL
- en: In our implementation, the `Registry` will be a class that pairs class names
    (for classes employing the Singleton pattern) with `Singleton` pointers to the
    single allowed instance of each registered class. We will still derive each Target
    class from `Singleton` (and from any other class as deemed appropriate by our
    design).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `instance()` method in each class *derived* from `Singleton` will be revised,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Our first check within `instance()` will be to call a `Registry` method (with
    the derived class’ name) asking whether a `Singleton` had previously been created
    for that class. If the `Registry` method determines a `Singleton` for the requested
    derived type has previously been instantiated, a pointer to the existing instance
    will be returned by `instance()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead, if the `Registry` provides permission to allocate the `Singleton`,
    `instance()` will allocate the `Singleton` much as before, setting the inherited
    protected data member of `theInstance` to the allocated derived `Singleton`. The
    static `instance()` method will also set the backlink through the inherited protected
    destroyer data member using `setSingleton()`. We will then pass the newly instantiated
    derived class instance (which is a `Singleton`) to a `Registry` method to `Store()`
    the newly allocated `Singleton` within the `Registry`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We notice that four pointers to the same `Singleton` will exist. One will be
    the specialized pointer of our derived class type, which is returned from our
    derived class `instance()` method. This pointer will be handed to our Client for
    application usage. The second `Singleton` pointer will be the pointer stored in
    our inherited, protected data member `theInstance`. The third `Singleton` pointer
    will be the pointer stored in the `SingletonDestroyer`. The fourth pointer to
    the `Singleton` will be a pointer that is stored in the `Registry`. No problem,
    we can have multiple pointers to a `Singleton`. This is one reason the `SingletonDestroyer`,
    used in its traditional destruction capacity, is so important – it will destroy
    our one and only `Singleton` for each type at the end of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Our `Registry` will maintain a pair for each class employing the `Singleton`
    pattern, consisting of a class name and the (eventual) pointer to the specific
    `Singleton` for the corresponding class. The pointer to each specific `Singleton`
    instance will be a static data member and will additionally require an external
    variable to garner its underlying memory. The result is one additional external
    variable per class embracing the Singleton pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of the `Registry` can be expanded further still if we choose to additionally
    accommodate the rare use of the Singleton pattern to allow multiple (but a finite
    set of) `Singleton` objects per class type. This rare existence of controlled,
    multiple singletons is known as the `Principal` would be an expected derived class
    of `Singleton`, yet the multiple vice-principals would represent a fixed number
    of instances of the `Vice-Principal` class (derived from `Singleton`). Our registry
    could be expanded to allow up to `N` registered `Singleton` objects for the `Vice-Principal`
    type (the multiton).
  prefs: []
  type: TYPE_NORMAL
- en: We have now seen an implementation of the Singleton pattern using a paired-class
    approach. We have folded the classes and concepts of `Singleton`, `SingetonDestroyer`,
    Target, and Client into the framework of classes we are accustomed to seeing,
    namely `Person`, as well as into a descendant class of our `Singleton` and `Person`
    (`President`). Let’s now briefly recap what we have learned relating to patterns
    before moving forward to our next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have furthered our goal of becoming better C++ programmers
    by expanding our programming repertoire by embracing another design pattern. We
    have explored the Singleton pattern by first employing two simple approaches,
    and then a paired-class implementation using `Singleton` and `SingletonDestroyer`.
    Our approach uses inheritance to incorporate our Singleton’s implementation into
    our Target class. Optionally, we incorporate a useful, existing base class into
    our Target class using multiple inheritances.
  prefs: []
  type: TYPE_NORMAL
- en: Making use of core design patterns, such as the Singleton pattern, will help
    you more easily reuse existing, well-tested portions of code in a manner understood
    by other programmers. By employing familiar design patterns, you will be contributing
    to well-understood and reusable solutions with avant-garde programming techniques.
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to continue onward with our final design pattern in [*Chapter
    20*](B19087_20.xhtml#_idTextAnchor876), *Removing Implementation Details Using
    the pImpl Pattern*. Adding more patterns to our arsenal of programming skills
    makes us more versatile and valued programmers. Let’s continue onward!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the Singleton pattern examples found in this chapter, create a program
    to accomplish the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement either an interface for a `President` to `Resign()` or implement the
    interface to `Impeach()` a `President`. Your method should delete the current
    Singleton `President` (and remove that link from the `SingletonDestroyer`). `SingletonDestroyer`
    has a `setSingleton()` method that may be useful to aid in removing the backlink.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Noting that the former Singleton `President` has been removed, create a new
    `President` using `President::instance()`. Verify that the new `President` has
    been installed.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: (Optional) Create a `Registry` to allow `Singleton` to be used effectively in
    multiple classes (not mutually exclusively, as is the current implementation).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Why can you not label the `static instance()` method as virtual in `Singleton`
    and override it in `President`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What other examples can you imagine that might easily incorporate the Singleton
    pattern?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
