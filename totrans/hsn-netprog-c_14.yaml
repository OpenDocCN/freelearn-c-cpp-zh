- en: Establishing SSH Connections with libssh
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用libssh建立SSH连接
- en: This chapter is all about programming with the **Secure Shell** (**SSH**) protocol.
    SSH is a secure network protocol used to authenticate with remote servers, grant
    command-line access, and securely transfer files.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章全部关于使用**安全外壳协议**（**SSH**）进行编程。SSH是一种安全的网络协议，用于与远程服务器进行身份验证、授予命令行访问权限以及安全地传输文件。
- en: SSH is widely used for the configuration and management of remote servers. Oftentimes,
    web servers aren't connected to monitors or keyboards. For many of these servers,
    SSH provides the only method of command-line access and administration.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: SSH广泛用于远程服务器的配置和管理。很多时候，Web服务器并没有连接到显示器或键盘。对于这些服务器中的许多，SSH提供了唯一的命令行访问和管理方法。
- en: 'The following topics are covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: SSH protocol overview
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SSH协议概述
- en: The `libssh` library
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libssh`库'
- en: Establishing a connection
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立连接
- en: SSH authentication methods
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SSH认证方法
- en: Executing a remote command
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行远程命令
- en: File transfers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件传输
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The example programs from this chapter can be compiled using any modern C compiler.
    We recommend **MinGW** for Windows and **GCC** for Linux and macOS. You also need
    to have the `libssh` library installed. See [Appendix B](47da8507-709b-44a6-9399-b18ce6afd8c9.xhtml), *Setting
    Up Your C Compiler on Windows*, [Appendix C](221eebc0-0bb1-4661-a5aa-eafed9fcba7e.xhtml), *Setting
    Up Your C Compiler on Linux*, and [Appendix D](632db68e-0911-4238-a2be-bd1aa5296120.xhtml), *Setting
    Up Your C Compiler on macOS*, for compiler setup and `libssh` installation.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例程序可以使用任何现代的C编译器进行编译。我们推荐Windows上的**MinGW**和Linux及macOS上的**GCC**。您还需要安装`libssh`库。请参阅[附录B](47da8507-709b-44a6-9399-b18ce6afd8c9.xhtml)，*在Windows上设置您的C编译器*，[附录C](221eebc0-0bb1-4661-a5aa-eafed9fcba7e.xhtml)，*在Linux上设置您的C编译器*，以及[附录D](632db68e-0911-4238-a2be-bd1aa5296120.xhtml)，*在macOS上设置您的C编译器*，以了解编译器和`libssh`的安装设置。
- en: The code for this book can be found at [https://github.com/codeplea/Hands-On-Network-Programming-with-C](https://github.com/codeplea/Hands-On-Network-Programming-with-C).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本书代码可在[https://github.com/codeplea/Hands-On-Network-Programming-with-C](https://github.com/codeplea/Hands-On-Network-Programming-with-C)找到。
- en: 'From the command-line, you can download the code for this chapter by using
    the following command:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行，您可以使用以下命令下载本章的代码：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Each example program in this chapter runs on Windows, Linux, and macOS.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的每个示例程序都可在Windows、Linux和macOS上运行。
- en: Each example needs to be linked against the `libssh` library. This is accomplished
    by passing the `-lssh` option to `gcc`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 每个示例都需要链接到`libssh`库。这是通过向`gcc`传递`-lssh`选项来实现的。
- en: We provide the exact commands needed to compile each example as it is introduced.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了编译每个示例所需的精确命令，就像它被介绍时一样。
- en: 'For brevity, we use a standard header file with each example program in this
    chapter. This header includes the other needed headers in one place. Its contents
    are as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁，我们为每个示例程序使用了一个标准的头文件。这个头文件将其他需要的头文件放在一个地方。其内容如下：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The SSH protocol
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SSH协议
- en: Most servers providing a service (such as websites and emails) over the modern
    internet aren't attached to keyboards or monitors. Even when servers do have local
    input/output hardware, remote access is often much more convenient.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代互联网上提供服务的多数服务器（如网站和电子邮件）并没有连接键盘或显示器。即使服务器确实有本地输入/输出硬件，远程访问通常也更为方便。
- en: Various protocols have been used to provide remote command-line access to servers.
    One of the first such protocols was **Telnet**. With Telnet, a client remotely
    connects to a server using plaintext over TCP port `23`. The server provides more-or-less
    direct access to the operating system command-line through this **Transmission
    Control Protocol** (**TCP**) connection. The client sends plaintext commands to
    the server, and the server executes these commands. The command-line output is
    sent back from the server to the client.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 已使用各种协议提供对服务器的远程命令行访问。其中第一个这样的协议是**Telnet**。使用Telnet，客户端通过TCP端口`23`上的明文远程连接到服务器。服务器通过这个**传输控制协议**（**TCP**）连接提供对操作系统命令行的更多或更少的直接访问。客户端向服务器发送明文命令，服务器执行这些命令。命令行输出从服务器发送回客户端。
- en: 'Telnet has a major security shortcoming: it does not encrypt any data sent
    over the network. Even user passwords are sent as plaintext when using Telnet.
    This means that any network eavesdropper could obtain user credentials!'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Telnet有一个重大的安全缺陷：它不会加密通过网络发送的任何数据。即使在使用Telnet时，用户密码也会以明文形式发送。这意味着任何网络窃听者都可能获取用户凭据！
- en: The SSH protocol has now largely replaced Telnet. The SSH protocol works over
    TCP using port `22`. SSH uses strong encryption to protect against eavesdropping.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: SSH 协议现在已经很大程度上取代了 Telnet。SSH 协议通过 TCP 使用端口 `22` 进行工作。SSH 使用强加密来防止窃听。
- en: SSH allows clients to verify servers' identities using **public-key authentication**.
    Without public-key authentication of the server, an impostor could masquerade
    as a legitimate server and attempt to trick a client into connecting. Once connected,
    the client would send its credentials to the impostor server.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: SSH 允许客户端使用 **公钥认证** 来验证服务器的身份。如果没有对服务器进行公钥认证，冒充者可以伪装成合法的服务器并试图欺骗客户端连接。一旦连接成功，客户端会将其凭证发送给冒充的服务器。
- en: SSH also provides many methods for client authentication with severs. These
    include sending a password or using public-key authentication. We look at these
    methods in detail later.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: SSH 还提供了许多用于客户端与服务器认证的方法。这包括发送密码或使用公钥认证。我们将在稍后详细探讨这些方法。
- en: SSH is a complicated protocol. So, instead of attempting to implement it ourselves,
    we use an existing library to provide the needed functionality.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: SSH 是一个复杂的协议。因此，我们不是尝试自己实现它，而是使用现有的库来提供所需的功能。
- en: libssh
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: libssh
- en: '`libssh` is a widely used open source C library implementing the SSH protocol.
    It allows us to remotely execute commands and transfer files using the SSH protocol.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`libssh` 是一个广泛使用的开源 C 库，实现了 SSH 协议。它允许我们使用 SSH 协议远程执行命令和传输文件。'
- en: '`libssh` is structured in a way that abstracts network connections. We won''t
    need to bother with the low-level networking APIs we''ve been using so far. The `libssh` library handles
    hostname resolution and creation of the needed TCP sockets for us.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`libssh` 以一种抽象网络连接的方式构建。我们不需要担心到目前为止所使用的低级网络 API。`libssh` 库为我们处理主机名解析和创建所需的
    TCP 套接字。'
- en: Testing out libssh
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 libssh
- en: Before continuing with this chapter, it is essential that you have the `libssh` library
    installed and available. Please refer to [Appendix B](47da8507-709b-44a6-9399-b18ce6afd8c9.xhtml),
    *Setting Up Your C Compiler on Windows*, [Appendix C](221eebc0-0bb1-4661-a5aa-eafed9fcba7e.xhtml),
    *Setting Up Your C Compiler on Linux*, and [Appendix D](632db68e-0911-4238-a2be-bd1aa5296120.xhtml),
    *Setting Up Your C Compiler on macOS*, for `libssh` installation.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续本章内容之前，确保你已经安装并可用 `libssh` 库是非常重要的。请参阅附录 B，*在 Windows 上设置您的 C 编译器*，附录 C，*在
    Linux 上设置您的 C 编译器*，以及附录 D，*在 macOS 上设置您的 C 编译器*，以了解 `libssh` 的安装。
- en: 'Our first program using `libssh` is designed to ensure that it''s installed
    correctly. This program merely prints the `libssh` library version. The program
    is as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `libssh` 的第一个程序旨在确保它已正确安装。此程序仅打印 `libssh` 库版本。程序如下：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can compile and run `ssh_version.c` with the following commands on Windows
    using MinGW:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令在 Windows 上使用 MinGW 编译和运行 `ssh_version.c`：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'On Linux and macOS, the commands to compile and run `ssh_version.c` are as
    follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 和 macOS 上，编译和运行 `ssh_version.c` 的命令如下：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following screenshot shows `ssh_version.c` being successfully compiled
    and run on Linux:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 `ssh_version.c` 在 Linux 上成功编译和运行的情况：
- en: '![](img/c1ff83a9-7bef-4aa7-83e9-bba24cedcf8e.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1ff83a9-7bef-4aa7-83e9-bba24cedcf8e.png)'
- en: If you receive an error message about `libssh.h` not being found, you should
    check that you have the `libssh` library headers in your compiler's `include`
    directory search path. If you see an error message about an undefined reference
    to `ssh_version`, then please check that you didn't forget to pass the `-lssh`
    option to your compiler.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你收到关于 `libssh.h` 未找到的错误消息，你应该检查是否在你的编译器的 `include` 目录搜索路径中包含了 `libssh` 库的头文件。如果你看到关于
    `ssh_version` 未定义引用的错误消息，那么请检查你是否忘记将 `-lssh` 选项传递给你的编译器。
- en: The next step to understanding `libssh` is to establish an actual SSH connection.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 `libssh` 的下一步是建立实际的 SSH 连接。
- en: Establishing a connection
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立连接
- en: Now that we've ensured that `libssh` is correctly installed, it's time to attempt
    an actual SSH connection.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确保 `libssh` 正确安装，是时候尝试实际的 SSH 连接了。
- en: You'll need to have access to an SSH server before continuing. OpenSSH is a
    popular server that is available for Linux, macOS, and Windows 10\. It works well
    for testing but be sure to understand the security implementations before installing
    it on your device. Refer to your operating system's documentation for more information.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，您需要访问一个SSH服务器。OpenSSH是一个流行的服务器，适用于Linux、macOS和Windows 10。它适用于测试，但在您的设备上安装之前，请确保您了解其安全实现。有关更多信息，请参阅您操作系统的文档。
- en: If you would rather test with a remote system, Linux **Virtual Private Servers**
    (**VPS**) running OpenSSH are available from many providers. They typically cost
    only a few dollars a month.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用远程系统进行测试，许多提供商都提供运行OpenSSH的Linux **虚拟专用服务器**（**VPS**）。它们通常每月只需几美元。
- en: Let's continue by implementing a program that uses `libssh` to open an SSH connection.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续实现一个使用`libssh`打开SSH连接的程序。
- en: 'We structure the rest of the programs in this chapter to take the SSH server''s
    hostname and port number as command-line arguments. Our program starts with the
    following code, which checks these arguments:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将本章的其余程序结构为接受SSH服务器的hostname和端口号作为命令行参数。我们的程序从以下代码开始，该代码检查这些参数：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding code, `argc` is checked to see whether at least the hostname
    was passed in as a command-line argument. If it wasn't, a usage message is displayed
    instead. Otherwise, the server's hostname is stored in the `hostname` variable.
    If a port number was passed in, it is stored in the `port` variable. Otherwise,
    the default port `22` is stored instead.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，`argc`被检查以确定是否至少传递了主机名作为命令行参数。如果没有，则显示用法消息。否则，服务器的主机名存储在`hostname`变量中。如果传递了端口号，则存储在`port`变量中。否则，将存储默认端口`22`。
- en: SSH often provides complete and total access to a server. For this reason, some
    internet criminals randomly scan IP addresses for SSH connections. When they successfully
    establish a connection, they attempt to guess login credentials, and if successful,
    they take control of the server. These attacks aren't successful against properly
    secured servers, but they are a common nuisance, nonetheless. Using SSH on a port
    other than the default (`22`) often avoids these automated attacks. This is one
    reason why we want to ensure our programs work well with non-default port numbers.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: SSH通常提供对服务器的完全和全面访问。因此，一些网络犯罪分子会随机扫描IP地址以寻找SSH连接。当他们成功建立连接时，他们会尝试猜测登录凭证，如果成功，他们将控制服务器。这些攻击针对安全设置得当的服务器不会成功，但它们仍然是一个常见的麻烦。在非默认端口（`22`）上使用SSH通常可以避免这些自动攻击。这就是我们想要确保我们的程序与非默认端口号良好工作的一个原因。
- en: 'Once our program has obtained the hostname and connection port number, we continue
    by creating an SSH session object. This is done with a call to `ssh_new()` as
    shown in the following code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的程序获得了主机名和连接端口号，我们继续创建一个SSH会话对象。这通过调用`ssh_new()`来完成，如下所示：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding code creates a new SSH session object and stores it in the `ssh` variable.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码创建了一个新的SSH会话对象，并将其存储在`ssh`变量中。
- en: 'Once the SSH session is created, we need to specify some options before completing
    the connection. The `ssh_options_set()` function is used to set options. The following
    code shows setting the remote hostname and port:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了SSH会话，在完成连接之前，我们需要指定一些选项。`ssh_options_set()`函数用于设置选项。以下代码展示了设置远程主机名和端口：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`libssh` includes useful debugging tools. By setting the `SSH_OPTIONS_LOG_VERBOSITY`
    option, we tell `libssh` to print almost everything it does. The following code
    causes `libssh` to log a lot of information about which actions it takes:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`libssh`包括有用的调试工具。通过设置`SSH_OPTIONS_LOG_VERBOSITY`选项，我们告诉`libssh`打印出它几乎所做的一切。以下代码导致`libssh`记录了大量关于它采取哪些行动的信息：'
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This logging is useful to see, but it can also be distracting. I recommend you
    try it once and then disable it unless you run into problems. The rest of this
    chapter's examples won't use it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这种日志记录很有用，但它也可能令人分心。我建议您试一次，然后除非遇到问题，否则禁用它。本章的其余示例将不会使用它。
- en: 'We can now use `ssh_connect()` to initiate the SSH connection. The following
    code shows this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用`ssh_connect()`来初始化SSH连接。以下代码展示了这一点：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that `ssh_connect()` returns `SSH_OK` on success. On failure, we use the
    `ssh_get_error()` function to detail what went wrong.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`ssh_connect()`在成功时返回`SSH_OK`。在失败时，我们使用`ssh_get_error()`函数来详细说明出了什么问题。
- en: 'Next, our code prints out that the connection was successful:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们的代码会打印出连接成功的消息：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The SSH protocol allows servers to send a message to clients upon connecting.
    This message is called the **banner**. It is typically used to identify the server
    or provide short access rules. We can print the banner using the following code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: SSH协议允许服务器在连接时向客户端发送一条消息。这条消息被称为**横幅**。它通常用于识别服务器或提供简短的访问规则。我们可以使用以下代码来打印横幅：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is as far as our `ssh_connect.c` example goes. Our program simply disconnects
    and frees the SSH session before terminating. The following code concludes `ssh_connect.c`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`ssh_connect.c`示例就到这里。我们的程序在终止前简单地断开连接并释放SSH会话。以下代码总结了`ssh_connect.c`：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can compile `ssh_connect.c` with the following command on Windows using
    MinGW:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令在Windows上使用MinGW编译`ssh_connect.c`：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'On Linux and macOS, the command to compile `ssh_connect.c` is as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux和macOS上，编译`ssh_connect.c`的命令如下：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following screenshot shows `ssh_connect.c` being successfully compiled
    and run on Linux:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了`ssh_connect.c`在Linux上成功编译和运行的情况：
- en: '![](img/9e3681f9-10ad-44da-a8fd-a740fb004421.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9e3681f9-10ad-44da-a8fd-a740fb004421.png)'
- en: In the preceding screenshot, you can see that `ssh_connect` was able to connect
    to the OpenSSH server running locally.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，你可以看到`ssh_connect`能够连接到本地运行的OpenSSH服务器。
- en: Now that we've established a connection, let's continue by authenticating with
    the server.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了连接，接下来让我们通过服务器认证来继续操作。
- en: SSH authentication
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SSH认证
- en: SSH provides authentication methods for both the server (host) and the client
    (user). It should be obvious why the server must authenticate the client. The
    server wants to only provide access to authorized users. Otherwise, anyone could
    take over the server.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: SSH为服务器（主机）和客户端（用户）提供了认证方法。显然，服务器必须认证客户端的原因是服务器只想授权给授权用户。否则，任何人都可以接管服务器。
- en: However, the client also needs to authenticate the server. If the client fails
    to authenticate the server properly, then the client could be tricked into sending
    its password to an impostor!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，客户端也需要认证服务器。如果客户端未能正确认证服务器，那么客户端可能会被欺骗向冒充者发送其密码！
- en: In SSH, servers are authenticated using public key encryption. Conceptually,
    this is very similar to how HTTPS provides server authentication. However, SSH
    doesn't typically rely on certificate authorities. Instead, when using SSH, most
    clients simply keep a list of the public keys (or hashes of the public keys) that
    they trust. How the clients obtain this list in the first place varies. Generally,
    if a client connects to a server under trusted circumstances, then it can trust
    that public key in the future too.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在SSH中，服务器使用公钥加密进行认证。从概念上讲，这与HTTPS提供服务器认证非常相似。然而，SSH通常不依赖于证书颁发机构。相反，当使用SSH时，大多数客户端只是简单地保留一个它们信任的公钥（或公钥哈希）列表。客户端最初是如何获得这个列表的各不相同。一般来说，如果一个客户端在受信任的环境下连接到服务器，那么它也可以信任该公钥在未来的使用。
- en: '`libssh` implements features to remember trusted servers'' public keys. In
    this way, once a server has been connected to and trusted once, `libssh` remembers
    that it''s trusted in the future.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`libssh`实现了记住受信任服务器公钥的功能。这样，一旦服务器被连接并信任一次，`libssh`就会记住它在未来的信任状态。'
- en: Some SSH deployments also use other methods to validate SSH hosts' public keys.
    For example, a **Secure Shell fingerprint** (**SSHFP**) record is a type of DNS
    record used to validate SSH public keys. Its use requires secure DNS access.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一些SSH部署还使用其他方法来验证SSH主机的公钥。例如，**Secure Shell指纹**（**SSHFP**）记录是一种DNS记录，用于验证SSH公钥。其使用需要安全的DNS访问。
- en: Regardless of how you decide to trust (or not trust) a server's public key,
    you'll need to obtain the server's public key in the first place. Let's look at
    how `libssh` provides access to the server authentication functionality.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你决定是否信任（或不信任）服务器的公钥，你首先都需要获取服务器的公钥。让我们看看`libssh`是如何提供服务器认证功能的访问的。
- en: Server authentication
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器认证
- en: 'Once the SSH session is established, we can get the server''s public key using
    the `ssh_get_server_publickey()` function. The following code illustrates this
    function call:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦建立了SSH会话，我们可以使用`ssh_get_server_publickey()`函数来获取服务器的公钥。以下代码展示了这个函数调用：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It is often useful to obtain and display a hash of the server's SSH public key.
    Users can look at hashes and compare these to known keys. The `libssh` library provides
    the `ssh_get_publickey_hash()` function for this purpose.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 获取并显示服务器SSH公钥的哈希值通常很有用。用户可以查看哈希值并将这些值与已知密钥进行比较。`libssh`库提供了`ssh_get_publickey_hash()`函数来实现这个目的。
- en: 'The following code prints out an `SHA1` hash of the public key obtained earlier:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码打印出之前获得的公钥的 `SHA1` 哈希：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`libssh` prints `SHA1` hashes using Base64\. It also prepends the hash type
    first. For example, the preceding code might print the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`libssh` 使用 Base64 打印 `SHA1` 哈希。它还会首先添加哈希类型。例如，前面的代码可能会打印以下内容：'
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When you''ve finished with the public key and hash, free their resources with
    the following code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成公钥和哈希的处理后，使用以下代码释放它们的资源：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`libssh` provides the `ssh_session_is_known_server()` function to determine
    whether a server''s public key is known. The following code shows an example of
    using this code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`libssh` 提供了 `ssh_session_is_known_server()` 函数来确定服务器的公钥是否已知。以下代码展示了如何使用此代码：'
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If the server's public key is known (previously trusted), then `ssh_session_is_known_server()`
    returns `SSH_KNOWN_HOSTS_OK`. Otherwise, `ssh_session_is_known_server()` can return
    other values with various meanings.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器的公钥已知（之前已信任），则 `ssh_session_is_known_server()` 返回 `SSH_KNOWN_HOSTS_OK`。否则，`ssh_session_is_known_server()`
    可以返回其他具有不同含义的值。
- en: '`SSH_KNOWN_HOSTS_UNKNOWN` indicates that the server is unknown. In this case,
    the user should verify the server''s hash.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`SSH_KNOWN_HOSTS_UNKNOWN` 表示服务器未知。在这种情况下，用户应验证服务器的哈希值。'
- en: '`SSH_KNOWN_HOSTS_NOT_FOUND` means that `libssh` didn''t find a hosts file,
    and one is created automatically. This should generally be treated in the same
    way as `SSH_KNOWN_HOSTS_UNKNOWN`.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`SSH_KNOWN_HOSTS_NOT_FOUND` 表示 `libssh` 没有找到主机文件，并自动创建一个。这通常应与 `SSH_KNOWN_HOSTS_UNKNOWN`
    以相同方式处理。'
- en: '`SSH_KNOWN_HOSTS_CHANGED` indicates that the server is returning a different
    key than was previously known, while `SSH_KNOWN_HOSTS_OTHER` indicates that the
    server is returning a different type of key than was previously used. Either of
    these could indicate a potential attack! In a real-world application, you should
    be more explicit about notifying the user of these risks.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`SSH_KNOWN_HOSTS_CHANGED` 表示服务器返回的密钥与之前所知的密钥不同，而 `SSH_KNOWN_HOSTS_OTHER` 表示服务器返回的密钥类型与之前使用的不同。这些可能都表明潜在的攻击！在实际应用中，你应该更明确地通知用户这些风险。'
- en: If the user has verified that a host is to be trusted, use `ssh_session_update_known_hosts()`
    to allow `libssh` to save the servers public key hash. This allows `ssh_session_is_known_server()` to
    return `SSH_KNOWN_HOSTS_OK` for the next connection.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户已验证主机是可信任的，请使用 `ssh_session_update_known_hosts()` 允许 `libssh` 保存服务器的公钥哈希。这允许
    `ssh_session_is_known_server()` 在下一次连接时返回 `SSH_KNOWN_HOSTS_OK`。
- en: 'The following code illustrates prompting the user to trust a connection and
    using `ssh_session_update_known_hosts()`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码说明了提示用户信任连接并使用 `ssh_session_update_known_hosts()` 的示例：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Please see `ssh_auth.c` in this chapter's code repository for a working example.
    Consult the `libssh` documentation for more information.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅本章代码库中的 `ssh_auth.c` 以获取一个工作示例。有关更多信息，请参阅 `libssh` 文档。
- en: After the client has authenticated the server, the server needs to authenticate
    the client.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端认证服务器之后，服务器需要认证客户端。
- en: Client authentication
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端认证
- en: 'SSH offers several methods of client authentication. These methods include
    the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: SSH 提供了多种客户端认证方法。这些方法包括以下几种：
- en: '**No authentication**: This allows any user to connect'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无认证**：这允许任何用户连接'
- en: '**Password authentication**: This requires the user to provide a username and
    password'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密码认证**：这要求用户提供用户名和密码'
- en: '**Public key**: This uses public key encryption methods to authenticate'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公钥**：这使用公钥加密方法进行认证'
- en: '**Keyboard-interactive**: This authenticates by having the user answer several
    prompts'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**键盘交互式**：通过让用户回答几个提示进行认证'
- en: '**Generic Security Service Application Program Interface** (**GSS-API**): This
    allows authentication through a variety of other services'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用安全服务应用程序接口**（**GSS-API**）：这允许通过各种其他服务进行认证'
- en: Password authentication is the most common method, but it does have some drawbacks.
    If an impostor server tricks a user into sending their password, then that user's
    password is effectively compromised. Public key user authentication doesn't suffer
    from this attack to the same degree. With public key authentication, the server
    issues a unique challenge for each authentication attempt. This prevents a malicious
    impostor server from replaying a previous authentication to the legitimate server.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 密码认证是最常见的方法，但它确实有一些缺点。如果冒充服务器欺骗用户发送他们的密码，那么该用户的密码实际上就受到了损害。公钥用户认证不会像密码认证那样容易受到这种攻击。使用公钥认证时，服务器为每次认证尝试发出一个独特的挑战。这阻止了恶意冒充服务器重新播放之前的认证到合法服务器。
- en: Once public key authentication is set up, `libssh` makes using it very simple.
    In many cases, it's as easy as calling the `ssh_userauth_publickey_auto()` function.
    However, setting up public key authentication in the first place can be a tedious
    process.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了公钥认证，`libssh`使得使用它变得非常简单。在许多情况下，只需调用`ssh_userauth_publickey_auto()`函数即可。然而，设置公钥认证本身可能是一个繁琐的过程。
- en: Although public key authentication is more secure, password authentication is
    still in common use. Password authentication is also more straightforward and
    easier to test. For these reasons, we continue the examples in this chapter by
    using password authentication.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然公钥认证更安全，但密码认证仍然很常见。密码认证也更直接，更容易测试。出于这些原因，我们继续在本章中使用密码认证的示例。
- en: 'Regardless of the user authentication method, the SSH server must know what
    user you are trying to authenticate as. The `libssh` library lets us provide this
    information using the `ssh_set_options()` function that we saw earlier. It should
    be called before using `ssh_connect()`. To set the user, call `ssh_options_set()`
    with `SSH_OPTIONS_USER` as shown in the following code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 无论使用哪种用户认证方法，SSH服务器都必须知道你试图认证的用户是谁。`libssh`库允许我们使用之前看到的`ssh_set_options()`函数提供此信息。在使用`ssh_connect()`之前应该调用它。要设置用户，可以使用以下代码中的`ssh_options_set()`函数，并传入`SSH_OPTIONS_USER`：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After the SSH session has been established, a password can be provided with
    the `ssh_userauth_password()` function. The following code prompts for a password
    and sends it to the connected SSH server:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在SSH会话建立之后，可以使用`ssh_userauth_password()`函数提供密码。以下代码提示输入密码并将其发送到已连接的SSH服务器：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The preceding code uses the `fgets()` function to obtain the password from the
    user. The `fgets()` function always includes the newline character with the input,
    which we don't want. The `password[strlen(password)-1] = 0` code effectively shortens
    the password by one character, thus removing the newline character.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码使用`fgets()`函数从用户那里获取密码。`fgets()`函数总是将换行符与输入一起包含，而我们不希望这样。`password[strlen(password)-1]
    = 0`代码实际上将密码缩短一个字符，从而移除了换行符。
- en: Note that using `fgets()` causes the entered password to display on the screen.
    This isn't secure, and it would be an improvement to hide the password while it's
    being entered. Unfortunately, there isn't a cross-platform way to do this. If
    you're using Linux, consider using the `getpass()` function in place of `fgets()`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用`fgets()`会导致输入的密码在屏幕上显示。这并不安全，最好在输入密码时隐藏它。不幸的是，没有跨平台的方法可以实现这一点。如果你使用Linux，可以考虑用`getpass()`函数代替`fgets()`。
- en: See `ssh_auth.c` in this chapter's code repository for a working example of
    authenticating with a server using user password authentication.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的代码仓库中查看`ssh_auth.c`，以获取使用用户密码认证与服务器进行认证的工作示例。
- en: 'You can compile and run `ssh_auth.c` with the following commands on Windows
    using MinGW:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令在Windows上使用MinGW编译和运行`ssh_auth.c`：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'On Linux and macOS, the commands to compile and run `ssh_auth.c` are as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux和macOS上，编译和运行`ssh_auth.c`的命令如下：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following screenshot shows compiling `ssh_auth` and using it to connect
    to a locally running SSH server on Linux:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了编译`ssh_auth`并使用它连接到Linux上本地运行的SSH服务器：
- en: '![](img/3e14a7e9-b149-4d92-a352-3f3cb3a250fd.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3e14a7e9-b149-4d92-a352-3f3cb3a250fd.png)'
- en: In the preceding screenshot, `ssh_auth` was used to successfully authenticate
    with the locally running SSH server. The `ssh_auth` program used password authentication
    with the username `alice` and the password `password123`. Needless to say, you
    need to change the username and password as appropriate for your SSH server. Authentication
    will be successful only if you use the username and password for an actual user
    account on the server you connect to.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，`ssh_auth` 被用来成功认证本地运行的 SSH 服务器。`ssh_auth` 程序使用用户名 `alice` 和密码 `password123`
    进行密码认证。不用说，你需要根据你的 SSH 服务器更改用户名和密码。只有当你使用连接到的服务器上实际用户账户的用户名和密码时，认证才会成功。
- en: After authenticating, we're ready to run a command over SSH.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在认证后，我们就可以通过 SSH 运行命令了。
- en: Executing a remote command
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行远程命令
- en: The SSH protocol works using channels. After we've established an SSH connection,
    a channel must be opened to do any real work. The advantage is that many channels
    can be opened over one connection. This potentially allows an application to do
    multiple things (seemingly) simultaneously.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: SSH 协议通过通道工作。在我们建立 SSH 连接后，必须打开一个通道才能进行任何实际的工作。其优势是可以在一个连接上打开多个通道。这潜在地允许应用程序同时执行多项操作（看似）。
- en: 'After the SSH session is open and the user is authenticated, a channel can
    be opened. A new channel is opened by calling the `ssh_channel_new()` function.
    The following code illustrates this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SSH 会话打开并且用户认证后，可以打开一个通道。通过调用 `ssh_channel_new()` 函数可以打开一个新的通道。以下代码说明了这一点：
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The SSH protocol implements many types of channels. The **session** channel
    type is used for executing remote commands and transferring files. With `libssh`,
    we can request a session channel by using the `ssh_channel_open_session()` function.
    The following code shows calling `ssh_channel_open_session()`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: SSH 协议实现了许多类型的通道。**会话**通道类型用于执行远程命令和传输文件。使用 `libssh`，我们可以通过 `ssh_channel_open_session()`
    函数请求会话通道。以下代码展示了调用 `ssh_channel_open_session()`：
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Once the session channel is open, we can issue a command to run with the `ssh_channel_request_exec()`
    function. The following code uses `fgets()` to prompt the user for a command and
    `ssh_channel_request_exec()` to send the command to the remote host:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦会话通道打开，我们可以使用 `ssh_channel_request_exec()` 函数发出命令。以下代码使用 `fgets()` 提示用户输入命令，并使用
    `ssh_channel_request_exec()` 将命令发送到远程主机：
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Once the command has been sent, our program uses `ssh_channel_read()` to receive
    the command output. The following code loops until the entire output is read:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 命令发送后，我们的程序使用 `ssh_channel_read()` 接收命令输出。以下代码循环直到读取整个输出：
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The preceding code first allocates a buffer, `output`, to hold the received
    data from the command's output. The `ssh_channel_read()` function returns the
    number of bytes read, but it returns `0` when the read is complete or a negative
    number for an error. Our code loops while `ssh_channel_read()` returns data.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码首先分配一个缓冲区 `output` 来存储命令输出的接收数据。`ssh_channel_read()` 函数返回读取的字节数，但在读取完成或发生错误时返回
    `0`。我们的代码在 `ssh_channel_read()` 返回数据时循环。
- en: 'After the entire output from the command has been received, the client should
    send an **end-of-file** (**EOF**) over the channel, close the channel, and free
    the channel resources. The following code shows this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在收到命令的全部输出后，客户端应在通道上发送一个 **文件结束符** (**EOF**)，关闭通道，并释放通道资源。以下代码展示了这一过程：
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If your program is also done with the SSH session, be sure to call `ssh_disconnect()`
    and `ssh_free()` as well.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的程序也完成了 SSH 会话，请务必调用 `ssh_disconnect()` 和 `ssh_free()`。
- en: The `ssh_command.c` program included in this chapter's code repository is a
    simple utility that connects to a remote SSH host and executes a single command.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 本章代码库中包含的 `ssh_command.c` 程序是一个简单的实用程序，它连接到远程 SSH 主机并执行单个命令。
- en: 'You can compile `ssh_command.c` with the following command on Windows using
    MinGW:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令在 Windows 上使用 MinGW 编译 `ssh_command.c`：
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'On Linux and macOS, the command to compile `ssh_command.c` is as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 和 macOS 上，编译 `ssh_command.c` 的命令如下：
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The following screenshot shows `ssh_command.c` being compiled and run on Linux:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在 Linux 上编译和运行 `ssh_command.c`：
- en: '![](img/63f94273-810d-45e6-bf34-82c3f88985a8.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/63f94273-810d-45e6-bf34-82c3f88985a8.png)'
- en: The preceding screenshot shows connecting to the local OpenSSH server and executing
    the `ls -l` command. The `ssh_command` code faithfully prints the output of that
    command (which is a file listing for the user's home directory).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的截图显示了连接到本地 OpenSSH 服务器并执行 `ls -l` 命令。`ssh_command` 代码忠实地打印了该命令的输出（这是用户主目录的文件列表）。
- en: The `libssh` library function `ssh_channel_request_exec()` is useful to execute
    a single command. However, SSH also supports methods for opening a fully interactive
    remote shell. Generally, a session channel is opened as shown previously. Then
    the `libssh` library function `ssh_channel_request_pty()` is called to initialize
    a remote shell. The `libssh` library provides many functions to send and receive
    data this way. Please refer to the `libssh` documentation for more information.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`libssh` 库中的函数 `ssh_channel_request_exec()` 适用于执行单个命令。然而，SSH 也支持打开一个完全交互式远程
    shell 的方法。通常，会话通道会按照之前所示的方式打开。然后调用 `libssh` 库函数 `ssh_channel_request_pty()` 来初始化远程
    shell。`libssh` 库提供了许多函数用于以这种方式发送和接收数据。请参阅 `libssh` 文档以获取更多信息。'
- en: Now that you're able to execute a remote command and receive its output, it
    may also be useful to transfer files. Let's consider that next.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您能够执行远程命令并接收其输出，也可能需要传输文件。让我们考虑一下下一步。
- en: Downloading a file
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载文件
- en: The **Secure Copy Protocol** (**SCP**) provides a method to transfer files.
    It supports both uploading and downloading files.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全复制协议**（**SCP**）提供了一种文件传输的方法。它支持上传和下载文件。'
- en: '`libssh` makes using SCP easy. This chapter''s code repository contains an
    example, `ssh_download.c`, which shows the basic method for downloading a file
    over SCP with `libssh`.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`libssh` 使使用 SCP 变得简单。本章的代码仓库包含一个示例，`ssh_download.c`，它展示了使用 `libssh` 在 SCP
    上下载文件的基本方法。'
- en: 'After the SSH session is started and the user is authenticated, `ssh_download.c`
    prompts the user for the remote filename using the following code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SSH 会话启动并用户认证后，`ssh_download.c` 使用以下代码提示用户输入远程文件名：
- en: '[PRE32]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'A new SCP session is initialized by calling the `libssh` library function `ssh_scp_new()`,
    as shown in the following code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用 `libssh` 库函数 `ssh_scp_new()` 可以初始化一个新的 SCP 会话，如下所示：
- en: '[PRE33]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the preceding code, `SSH_SCP_READ` is passed to `ssh_scp_new()`. This specifies
    that we are going to use the new SCP session for downloading files. The `SSH_SCP_WRITE` option
    would be used to upload files. The `libssh` library also provides the `SSH_SCP_RECURSIVE` option
    to assist with uploading or downloading entire directory trees.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，将 `SSH_SCP_READ` 传递给 `ssh_scp_new()`。这指定我们将使用新的 SCP 会话来下载文件。`SSH_SCP_WRITE`
    选项将用于上传文件。`libssh` 库还提供了 `SSH_SCP_RECURSIVE` 选项，以帮助上传或下载整个目录树。
- en: 'After the SCP session is created successfully, `ssh_scp_init()` must be called
    to initialize the SCP channel. The following code shows this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 成功创建 SCP 会话后，必须调用 `ssh_scp_init()` 来初始化 SCP 通道。以下代码展示了这一过程：
- en: '[PRE34]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`ssh_scp_pull_request()` must be called to begin the file download. This function
    returns `SSH_SCP_REQUEST_NEWFILE` to indicate that the remote host is going to
    begin sending a new file. The following code shows this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 必须调用 `ssh_scp_pull_request()` 来开始文件下载。此函数返回 `SSH_SCP_REQUEST_NEWFILE` 以指示远程主机将开始发送新文件。以下代码展示了这一过程：
- en: '[PRE35]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`libssh` provides some methods we can use to retrieve the remote filename,
    file size, and permissions. The following code retrieves these values and prints
    them to the console:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`libssh` 提供了一些我们可以使用的方法来检索远程文件名、文件大小和权限。以下代码检索这些值并将它们打印到控制台：'
- en: '[PRE36]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Once the file size is known, we can allocate space to store it in memory. This
    is done using `malloc()` as shown in the following code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦知道文件大小，我们就可以使用 `malloc()` 分配空间来在内存中存储它。以下代码展示了这一过程：
- en: '[PRE37]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Our program then accepts the new file request with `ssh_scp_accept_request()` and
    downloads the file with `ssh_scp_read()`. The following code shows this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们的程序使用 `ssh_scp_accept_request()` 接受新的文件请求，并使用 `ssh_scp_read()` 下载文件。以下代码展示了这一过程：
- en: '[PRE38]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The downloaded file can be printed to the screen with a simple call to `printf()`.
    When we''re finished with the file data, it''s important to free the allocated
    space too. The following code prints out the file''s contents and frees the allocated
    memory:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过简单的 `printf()` 调用来将下载的文件打印到屏幕上。当我们完成文件数据后，释放分配的空间也很重要。以下代码打印出文件内容并释放分配的内存：
- en: '[PRE39]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'An additional call to `ssh_scp_pull_request()` should return `SSH_SCP_REQUEST_EOF`.
    This indicates that we received the entire file from the remote host. The following
    code checks for the end-of-file request from the remote host:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对`ssh_scp_pull_request()`的额外调用应返回`SSH_SCP_REQUEST_EOF`。这表示我们已经从远程主机接收了整个文件。以下代码检查来自远程主机的文件结束请求：
- en: '[PRE40]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The preceding code is simplified a bit. The remote host could also return other
    values which aren't necessarily errors. For example, if `ssh_scp_pull_request()`
    returns `SSH_SCP_REQUEST_WARNING`, then the remote host has sent a warning. This
    warning can be read by calling `ssh_scp_request_get_warning()`, but, in any case,
    `ssh_scp_pull_request()` should be called again.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码略有简化。远程主机也可能返回其他值，这些值不一定是错误。例如，如果`ssh_scp_pull_request()`返回`SSH_SCP_REQUEST_WARNING`，则远程主机已发送警告。这个警告可以通过调用`ssh_scp_request_get_warning()`来读取，但无论如何，都应该再次调用`ssh_scp_pull_request()`。
- en: 'After the file is received, `ssh_scp_close()` and `ssh_scp_free()` should be
    used to free resources as shown in the following code excerpt:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 文件接收后，应使用`ssh_scp_close()`和`ssh_scp_free()`来释放资源，如下述代码片段所示：
- en: '[PRE41]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: After your program is done with the SSH session, don't forget to call `ssh_disconnect()`
    and `ssh_free()` as well.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的程序完成SSH会话后，别忘了调用`ssh_disconnect()`和`ssh_free()`。
- en: The entire file-downloading example is included with this chapter's code as
    `ssh_download.c`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 整个文件下载示例包含在本章代码中的`ssh_download.c`文件。
- en: 'You can compile `ssh_download.c` with the following command on Windows using
    MinGW:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Windows上使用MinGW通过以下命令编译`ssh_download.c`：
- en: '[PRE42]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'On Linux and macOS, the command to compile `ssh_download.c` is as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux和macOS上，编译`ssh_download.c`的命令如下：
- en: '[PRE43]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The following screenshot shows `ssh_download.c` being successfully compiled
    and used on Linux to download a file:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在Linux上成功编译并使用`ssh_download.c`下载文件的情况：
- en: '![](img/45e07451-d9e8-43ce-8c4a-0f2c22ce53d9.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/45e07451-d9e8-43ce-8c4a-0f2c22ce53d9.png)'
- en: As you can see from the preceding screenshot, downloading a file using SSH and
    SCP is pretty straightforward. This can be a useful way to transfer data between
    computers securely.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述截图所示，使用SSH和SCP下载文件非常简单。这可以是一种在计算机之间安全传输数据的有用方式。
- en: Summary
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter provided a cursory overview of the SSH protocol and how to use
    it with `libssh`. We learned a lot about authentication with the SSH protocol,
    and how the server and client must both authenticate for security. Once the connection
    was established, we implemented a simple program to execute a command on a remote
    host. We also saw how `libssh` makes downloading a file using SCP very easy.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 本章简要概述了SSH协议及其使用`libssh`的方式。我们了解了很多关于SSH协议的身份验证知识，以及服务器和客户端都必须进行身份验证以确保安全。一旦建立连接，我们就实现了一个简单的程序来在远程主机上执行命令。我们还看到了`libssh`如何使使用SCP下载文件变得非常简单。
- en: SSH provides a secure communication channel, which effectively denies eavesdroppers
    the meaning of intercepted communication.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: SSH提供了一个安全的通信通道，有效地阻止了窃听者获取截获通信的意义。
- en: In the next chapter, [Chapter 12](1d616e6f-d234-4269-8507-f007ffc1b7d0.xhtml),
    *Network Monitoring and Security*, we continue with the security theme by looking
    at tools that can effectively eavesdrop on non-secure communication channels.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，[第12章](1d616e6f-d234-4269-8507-f007ffc1b7d0.xhtml)，*网络监控与安全*，我们继续探讨安全主题，通过查看能够有效监听非安全通信通道的工具。
- en: Questions
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Try these questions to test your knowledge from this chapter:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试以下问题来测试你对本章知识的掌握：
- en: What is a significant downside of using Telnet?
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Telnet的一个显著缺点是什么？
- en: Which port does SSH typically run on?
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SSH通常运行在哪个端口上？
- en: Why is it essential that the client authenticates the SSH server?
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么客户端验证SSH服务器是至关重要的？
- en: How is the server typically authenticated?
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器通常是如何进行身份验证的？
- en: How is the SSH client typically authenticated?
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SSH客户端通常是如何进行身份验证的？
- en: The answers to this questions can be found in [Appendix A](bd8b8f52-52cb-4d34-b01b-e907564bfece.xhtml),
    *Answers to Questions*.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的答案可以在[附录A](bd8b8f52-52cb-4d34-b01b-e907564bfece.xhtml)，*问题答案*中找到。
- en: Further reading
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information about Telnet, SSH, and `libssh`, please refer to the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Telnet、SSH和`libssh`的更多信息，请参考以下内容：
- en: The SSH library [https://www.libssh.org](https://www.libssh.org)
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SSH库[https://www.libssh.org](https://www.libssh.org)
- en: '**RFC 15**: *Network Subsystem for Time Sharing Hosts* (Telnet) ([https://tools.ietf.org/html/rfc15](https://tools.ietf.org/html/rfc15))'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RFC 15**：*时分共享主机网络子系统*（Telnet）([https://tools.ietf.org/html/rfc15](https://tools.ietf.org/html/rfc15))'
- en: '**RFC 855**: *Telnet Option Specifications* ([https://tools.ietf.org/html/rfc855](https://tools.ietf.org/html/rfc855))'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RFC 855**: *Telnet Option Specifications* ([https://tools.ietf.org/html/rfc855](https://tools.ietf.org/html/rfc855))'
- en: '**RFC 4250**: *The **Secure Shell** (**SSH**) Protocol Assigned Numbers* ([https://tools.ietf.org/html/rfc4250](https://tools.ietf.org/html/rfc4250))'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RFC 4250**: *The **Secure Shell** (**SSH**) Protocol Assigned Numbers* ([https://tools.ietf.org/html/rfc4250](https://tools.ietf.org/html/rfc4250))'
- en: '**RFC 4251**: *The **Secure Shell** (**SSH**) Protocol Architecture* ([https://tools.ietf.org/html/rfc4251](https://tools.ietf.org/html/rfc4251))'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RFC 4251**: *The **Secure Shell** (**SSH**) Protocol Architecture* ([https://tools.ietf.org/html/rfc4251](https://tools.ietf.org/html/rfc4251))'
- en: '**RFC 4252**: *The **Secure Shell** (**SSH**) Authentication Protocol* ([https://tools.ietf.org/html/rfc4252](https://tools.ietf.org/html/rfc4252))'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RFC 4252**: *The **Secure Shell** (**SSH**) Authentication Protocol* ([https://tools.ietf.org/html/rfc4252](https://tools.ietf.org/html/rfc4252))'
- en: '**RFC 4253**: *The **Secure Shell** (**SSH**) Transport Layer Protocol* ([https://tools.ietf.org/html/rfc4253](https://tools.ietf.org/html/rfc4253))'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RFC 4253**: *The **Secure Shell** (**SSH**) Transport Layer Protocol* ([https://tools.ietf.org/html/rfc4253](https://tools.ietf.org/html/rfc4253))'
- en: '**RFC 4254**: *The **Secure Shell** (**SSH**) Connection Protocol* ([https://tools.ietf.org/html/rfc4254](https://tools.ietf.org/html/rfc4254))'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RFC 4254**: *The **Secure Shell** (**SSH**) Connection Protocol* ([https://tools.ietf.org/html/rfc4254](https://tools.ietf.org/html/rfc4254))'
- en: '**RFC 4255**: *Using DNS to Securely Publish **Secure Shell** (**SSH**) Key
    Fingerprints* ([https://tools.ietf.org/html/rfc4255](https://tools.ietf.org/html/rfc4255))'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RFC 4255**: *Using DNS to Securely Publish **Secure Shell** (**SSH**) Key
    Fingerprints* ([https://tools.ietf.org/html/rfc4255](https://tools.ietf.org/html/rfc4255))'
- en: '**RFC 4256**: *Generic Message Exchange Authentication for the **Secure Shell**
    Protocol (**SSH**)* ([https://tools.ietf.org/html/rfc4256](https://tools.ietf.org/html/rfc4256))'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RFC 4256**: *Generic Message Exchange Authentication for the **Secure Shell**
    Protocol (**SSH**)* ([https://tools.ietf.org/html/rfc4256](https://tools.ietf.org/html/rfc4256))'
