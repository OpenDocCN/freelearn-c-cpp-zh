- en: 'Communication Between Classes and Interfaces: Part I'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following recipes will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a UInterface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a UInterface on an object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking if a class implements a UInterface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Casting to a UInterface implemented in native code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling native UInterface functions from C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheriting UInterfaces from one another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overriding UInterface functions in C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a simple interaction system with UInterfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter shows you how to write your own UInterfaces, and demonstrates how
    to take advantage of them within C++ to minimize class coupling and help keep
    your code clean.
  prefs: []
  type: TYPE_NORMAL
- en: In your game projects, you will sometimes require a series of potentially disparate
    objects to share a common functionality, but it would be inappropriate to use
    inheritance because there is no *is-a* relationship between the different objects
    in question. Languages such as C++ tend to use multiple inheritance to solve this
    issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, in Unreal, if you wanted functions from both parent classes to be
    accessible to Blueprint, you would need to make both of them `UCLASS`. This is
    a problem for two reasons. Inheriting from `UClass` twice in the same object would
    break the concept that `UObject` should form a neatly traversable hierarchy. It
    also means that there are two instances of the `UClass` methods on the object,
    and they would have to be explicitly differentiated between within the code. The
    Unreal codebase solves this issue by borrowing a concept from C#: that of an explicit
    Interface type.'
  prefs: []
  type: TYPE_NORMAL
- en: The reason for using this approach, instead of composition, is that Components
    are only available on Actors, not on UObjects in general. Interfaces can be applied
    to any `UObject`. Furthermore, it means that we are no longer modeling an *is-a*
    relationship between the object and the component; instead, it would only be able
    to represent *has-a* relationships.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires the use of Unreal Engine 4 and uses Visual Studio 2017
    as the IDE. Instructions on how to install both pieces of software and the requirements
    for them can be found in [Chapter 1](4adb307e-d86f-4d70-b6de-a0893102d1cf.xhtml),
    *UE4 Development Tools*, of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a UInterface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: UInterfaces are pairs of classes that work together to enable classes to exhibit
    polymorphic behavior among multiple class hierarchies. This recipe shows you the
    basic steps involved in creating a UInterface purely in code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From the Content Browser, go to Add New | New C++ Class. From the menu that
    pops up, scroll down all the way until you see the Unreal Interface selection
    and select it. Afterward, click on the Next button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6dca5f4f-671b-4279-91c2-4ec127cda935.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From there, verify that the Name of the class is `MyInterface` and then click
    on the Create Class button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c611d729-5476-4d87-8324-0052c4d67e5c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Add the following code to the header file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the class with this code in the `.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Compile your project to verify that the code was written without errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: UInterfaces are implemented as pairs of classes that are declared in the interface's
    header.
  prefs: []
  type: TYPE_NORMAL
- en: As always, because we are leveraging Unreal's reflection system, we need to
    include our generated header file. Refer to the *Handling events implemented via
    virtual functions* recipe in [Chapter 5](cf821ef4-8a19-440c-805d-573748b76d5f.xhtml),
    *Handling Events and Delegates*, for more information.
  prefs: []
  type: TYPE_NORMAL
- en: As with classes that inherit from `UObject`, which uses `UCLASS`, we need to
    use the `UINTERFACE` macro to declare our new `UInterface`. Passing in the class
    specifier of `MinimalAPI` causes only the class's type information to be exported
    for use by other modules.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on this and other class specifiers, check out: [https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Classes/Specifiers](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Classes/Specifiers).
  prefs: []
  type: TYPE_NORMAL
- en: The class is tagged as `UE4COOKBOOK_API` to help with exporting library symbols.
  prefs: []
  type: TYPE_NORMAL
- en: The base class for the `UObject` portion of the interface is `UInterface`.
  prefs: []
  type: TYPE_NORMAL
- en: Just like `UCLASS` types, we require a macro to be placed inside the body of
    our class so that the auto-generated code is inserted into it. That macro is `GENERATED_BODY()`
    for UInterfaces. The macro must be placed at the very start of the class body.
  prefs: []
  type: TYPE_NORMAL
- en: The second class is also tagged as `UE4COOKBOOK_API`, and is named in a specific
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `UInterface` derived class and the standard class have the same
    name but a different prefix. The `UInterface` derived class has the prefix `U`,
    and the standard class has the prefix `I`. This is important as this is how the
    Unreal Header Tool expects classes to be named for the code it generates to work
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: The plain native Interface class requires its own autogenerated content, which
    we include using the `GENERATED_BODY()` macro.
  prefs: []
  type: TYPE_NORMAL
- en: We declare functions that classes inheriting the interface should implement
    inside `IInterface`.
  prefs: []
  type: TYPE_NORMAL
- en: Within the implementation file, we implement the constructor for our `UInterface`,
    as it is declared by the Unreal Header Tool and requires an implementation.
  prefs: []
  type: TYPE_NORMAL
- en: We also create a default implementation for our `GetTestName()` function. Without
    this, the linking phase in the compilation will fail. This default implementation
    uses the `unimplemented()` macro, which will issue a debug assert when the line
    of code is executed.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on creating interfaces, check out the following link: [https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/Reference/Interfaces](https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/Reference/Interfaces).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refer to the *Passing payload data with a delegate binding* recipe in [Chapter
    5](cf821ef4-8a19-440c-805d-573748b76d5f.xhtml), *Handling Events and Delegates*;
    the first recipe, in particular, explains some of the principles that we've applied
    here
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a UInterface on an object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have created a UInterface, we can say that an object has all of
    the functions defined or implements them. In this recipe, we will see exactly
    how to do that.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ensure that you've followed the previous recipe so that you have a `UInterface`
    ready to be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new `Actor` class using the Unreal Wizard, called `SingleInterfaceActor`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7e99dfee-3068-4773-a9e3-442b78c69dc1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Add `IInterface`—in this case, `IMyInterface`—to the public inheritance list
    for our new `Actor` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an `override` declaration to the class for the `IInterface` function(s)
    that we wish to override:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the overridden function in the implementation file by adding the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ uses multiple inheritance in the way it implements interfaces, so we leverage
    that mechanism here with the declaration of our `SingleInterfaceActor` class,
    where we add `public IMyInterface`.
  prefs: []
  type: TYPE_NORMAL
- en: We inherit from `IInterface` rather than `UInterface` to prevent `SingleInterfaceActor`
    from inheriting two copies of `UObject`.
  prefs: []
  type: TYPE_NORMAL
- en: Given that the interface declares a `virtual` function, we need to redeclare
    that function with the override specifier if we wish to implement it ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: In our implementation file, we implement our overridden `virtual` function.
  prefs: []
  type: TYPE_NORMAL
- en: Inside our function override, for demonstration purposes, we call the base `IInterface`
    implementation of the function. Alternatively, we could write our own implementation
    and avoid calling the base class one altogether.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use `IInterface:: specifier` rather than `Super`, because `Super` refers
    to the `UClass` that is the parent of our class, and `IInterfaces` aren''t UClasses
    (hence there''s no `U` prefix).'
  prefs: []
  type: TYPE_NORMAL
- en: You can implement a second, or multiple, `IInterfaces` on your object, as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Checking if a class implements a UInterface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When writing C++ code, it's always a good idea to make sure that something exists
    before using it. In this recipe, we will see how we can check whether a particular
    object implements a specific `UInterface`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Follow the first two recipes so that you have a `UInterface` we can check for,
    and a class implementing the interface that can be tested against.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inside your Game Mode implementation, add the following code to the `BeginPlay`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Given that we are referencing both `ASingleInterfaceActor` and `IMyInterface`,
    we need to `#include` both `MyInterface.h` and `SingleInterfaceActor.h` in our
    source file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Save your script and compile your code. Afterward, from the World Settings
    menu, set the GameMode Override property to your `GameModeBase` class and play
    the game. If all went well, you should see a message stating that you''ve implemented
    the interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/422edfd8-62f6-48ff-ab9e-71064b5d6b52.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inside `BeginPlay`, we create an empty `FTransform` object, which has the default
    value of `0` for all translation and rotation components, so we don't need to
    explicitly set any of them.
  prefs: []
  type: TYPE_NORMAL
- en: We then use the `SpawnActor` function from `UWorld` so that we can create an
    instance of our `SingleActorInterface`, storing the pointer to the instance into
    a temporary variable.
  prefs: []
  type: TYPE_NORMAL
- en: We then use `GetClass()` on our instance to get a reference to its associated
    `UClass`. We need a reference to `UClass` because that object is the one that
    holds all of the reflection data for the object.
  prefs: []
  type: TYPE_NORMAL
- en: Reflection data includes the names and types of all `UPROPERTY` on the object,
    the inheritance hierarchy for the object, and a list of all the interfaces that
    it implements.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, we can call `ImplementsInterface()` on `UClass`, and it will return
    `true` if the object implements the `UInterface` in question.
  prefs: []
  type: TYPE_NORMAL
- en: If the object implements the interface, and therefore returns `true` from `ImplementsInterface`,
    we then print a message to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 4](eade601c-4b55-484a-ba49-0a989d81d7f8.xhtml), Actors and Components,
    has a number of recipes relating to the spawning of actors (such as Instantiating
    an Actor using SpawnActor)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Casting to a UInterface implemented in native code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One advantage that UInterfaces provide you with as a developer is the ability
    to treat a collection of heterogeneous objects that implement a common interface
    as a collection of the same object, using `Cast< >` to handle the conversion.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that this won't work if your class implements the interface through
    a Blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should have a `UInterface` and an `Actor` implementing the interface ready
    for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new game mode using the wizard within Unreal, or reuse a project and
    `GameMode` from a previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open your game mode''s declaration and add a new property to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Add `#include "MyInterface.h"` to the header''s include section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following within the game mode''s `BeginPlay` implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we are using the `TActorIterator` class, we will need to add the following
    `#include` to the top of our `GameModeBase` class'' implementation file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If you haven't done so already, set the level's game mode override to your game
    mode, then drag a few instances of your custom Interface-implementing actor into
    the level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you play your level, a message should be printed on screen that indicates the
    number of instances of the interface that have been implemented in Actors in the
    level:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0a8cdda5-261c-4524-9d5f-bf81e434fb90.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We create an array of pointers to `MyInterface` implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Inside `BeginPlay`, we use `TActorIterator<AActor>` to get all of the `Actor`
    instances in our level.
  prefs: []
  type: TYPE_NORMAL
- en: '`TActorIterator` has the following constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`TActorIterator` expects a world to act on, as well as a `UClass` instance
    to specify what types of Actor we are interested in.'
  prefs: []
  type: TYPE_NORMAL
- en: '`ActorIterator` is an iterator like the STL iterator type. This means that
    we can write a `for` loop in the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Inside the loop, we dereference the iterator to get an `Actor` pointer.
  prefs: []
  type: TYPE_NORMAL
- en: We then attempt to cast it to our interface; this will return a pointer to the
    interface if it does implement it, otherwise it will return `nullptr`.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, we can check if the interface pointer is `null`, and if not, we
    can add the interface pointer reference to our array.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, once we've iterated through all the actors in `TActorIterator`, we
    can display a message on the screen that displays the count of items that implemented
    the interface.
  prefs: []
  type: TYPE_NORMAL
- en: Calling native UInterface functions from C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can use C++ to call native `UInterface` functions from other classes as well.
    For example, in this recipe, we will make a volume call a function on an object
    if it implements a particular interface.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Follow the previous recipe to get an understanding of casting an `Actor` pointer
    to an Interface pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Note that as this recipe relies on the casting technique we used in the previous
    recipe, it will only work with objects that implement the interface using C++
    rather than Blueprint. This is because Blueprint classes are not available at
    compile time, and so, technically, don't inherit the interface.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new `Actor` class using the editor wizard. Call it `AntiGravityVolume`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/792cb6e1-aada-45b7-91cb-a91759eec844.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Update the header file to add a `BoxComponent` to the new `Actor` and two virtual
    functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an implementation within your source file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize the `BoxComponent` in your constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The script will not compile since `GravityObject` doesn''t exist. Let''s fix
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an interface called `GravityObject`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f70de395-ca21-4083-ba93-20a4bfc9d5e3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Add the following `virtual` functions to `IGravityObject`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the default implementation of the `virtual` functions inside the `IGravityObject`
    implementation file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Afterward, go back to the `AntiGravityVolume.cpp` file and add the following
    `#include`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: At this point, our code will compile, but there's nothing using the interface.
    Let's add a new class that will.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a subclass of `Actor` called `PhysicsCube`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9d05909d-0f15-4f7f-be62-c37bbe5a0822.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Add a static mesh property to the header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize the component in your constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To have `PhysicsCube` implement `GravityObject`, first `#include "GravityObject.h"`
    in the header file, then modify the class declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Compile your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new level and place an instance of our gravity volume in the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Place an instance of `PhysicsCube` above the gravity volume, then rotate it
    slightly so that it has one corner lower than the others, as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/104ff00e-4823-4862-b609-48373dbda8a8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Verify that the gravity is turned off on the object when it enters the volume
    and then turns back on again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a8a01273-e5e5-42c6-97b6-e47dc0aeeb6a.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that the gravity volume doesn't need to know anything about your `PhysicsCube` actor,
    just the `GravityObject` interface.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We create a new `Actor` class and add a box component to give the actor something
    that will collide with the character. Alternatively, you could subclass `AVolume`
    if you wanted to use the **Binary Space Partitioning** (**BSP**) functionality
    to define the volume's shape (found under Geometry in the Place section of the
    Modes tab).
  prefs: []
  type: TYPE_NORMAL
- en: '`NotifyActorBeginOverlap` and `NotifyActorEndOverlap` are overridden so that
    we can perform an operation when an object enters or leaves the `AntiGravityVolume`
    area.'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `NotifyActorBeginOverlap` implementation, we attempt to cast the
    object that overlapped us into an `IGravityObject` pointer. This tests whether
    the object in question implements the interface. If the pointer is valid, then
    the object does implement the interface, so it is safe to use the interface pointer
    to call Interface methods on the object.
  prefs: []
  type: TYPE_NORMAL
- en: Given that we are inside `NotifyActorBeginOverlap`, we want to disable gravity
    on the object, so we call `DisableGravity()`. Inside `NotifyActorEndOverlap`,
    we perform the same check, but we re-enable gravity on the object. Within the
    default implementation of `DisableGravity`, we cast our own pointer (the `this`
    pointer) to `AActor`. This allows us to confirm that the interface has been implemented
    only on the `Actor` subclasses, and to call methods defined in `AActor`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the pointer is valid, we know we are an `Actor`, so we can use `GetComponents<class
    ComponentType>()` to get a `TArray` of all components of a specific type from
    ourselves. `GetComponents` is a `template` function. It expects some template
    parameters, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Since the 2014 version of the standard, C++ supports compile-time deduction
    of template parameters. This means that we don't need to actually specify the
    template parameters when we call the function if the compiler can work them out
    from the normal function parameters that we provide.
  prefs: []
  type: TYPE_NORMAL
- en: The default implementation of `TArray` is `template<typename T, typename Allocator
    = FDefaultAllocator> class TArray;`. This means that we don't need to specify
    an allocator by default, so we just use `TArray<UPrimitiveComponent*>` when we
    declare the array.
  prefs: []
  type: TYPE_NORMAL
- en: When `TArray` is passed into the `GetComponents` function, the compiler knows
    it is actually `TArray<UPrimitiveComponent*, FDefaultAllocator>`, and it is able
    to fill in the template parameters `T` and `AllocatorType` with `UPrimitiveComponent`
    and `FDefaultAllocator`, so neither of those are required as template parameters
    for the function's invocation.
  prefs: []
  type: TYPE_NORMAL
- en: '`GetComponents` iterates through the components that `Actor` has, and any components
    that inherit from `typename T` have pointers to them stored inside the `PrimitiveComponents`
    array.'
  prefs: []
  type: TYPE_NORMAL
- en: Using a range-based `for` loop, another new feature of C++, we can iterate over
    the components that the function placed into our `TArray` without needing to use
    the traditional `for` loop structure.
  prefs: []
  type: TYPE_NORMAL
- en: Each of the components has `SetEnableGravity(false)` called on them, which disables
    gravity.
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, the `EnableGravity` function iterates over all the primitive components
    contained in the actor, and enables gravity with `SetEnableGravity(true)`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Look at [Chapter 4](eade601c-4b55-484a-ba49-0a989d81d7f8.xhtml), *Actors and
    Components,* for extensive discussions on Actors and Components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 5](cf821ef4-8a19-440c-805d-573748b76d5f.xhtml), *Handling Events and
    Delegates,* discusses events such as `NotifyActorOverlap`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheriting UInterfaces from one another
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, you may need to create a `UInterface` that specializes on a more
    general `UInterface`. This recipe shows you how to use inheritance with UInterfaces
    to specialize a `Killable` interface with an `Undead` interface that cannot be
    killed by normal means.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a `UInterface`/`IInterface` called `Killable`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/20054dc1-f6a5-4b7e-aec6-a85686630416.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Add `UINTERFACE(meta=(CannotImplementInterfaceInBlueprint))` to the `UInterface`
    declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following functions to the header file under the `IKillable` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Provide default implementations for the interface inside the implementation
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `UINTERFACE`/`IInterface` called `Undead`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/10841280-bffb-4867-a944-d463288ade74.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Modify them so they inherit from `UKillable`/`IKillable`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Ensure that you include the header defining the `Killable` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add some overrides and new method declarations to the new interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Create implementations for the functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Create two new `Actor` classes in C++: one called `Snail`, and another called
    `Zombie`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the `Snail` class to implement the `IKillable` interface, and add the appropriate
    header file, `#include`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, set the `Zombie` class to implement `IUndead`, and `#include "Undead.h"`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile your project and drag an instance of both `Zombie` and `Snail` into
    your level:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/131d2208-a1c8-45cd-ab64-d2bb2dfc2f2c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Open the Level Blueprint by going to Blueprints | Level Blueprint. Afterward,
    add references to each of the newly created objects in the Level Blueprint by
    dragging and dropping them from the World Outliner into the Level Blueprint and
    releasing them, one at a time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/266bfc76-5685-4a63-872c-59b39aea216a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Afterward, call `Die (Interface Call)` on each reference:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/48189563-55b8-4d89-9964-44ff7b73676d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Connect the execution pins of the two message calls, then wire it up to `Event
    BeginPlay`. Run the game, and then verify that the `Zombie` is disdainful of your
    efforts to kill it, but the `Snail` groans and then dies (it is removed from the
    world outliner):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/64dc17b9-ed35-4104-bfec-cd739c40da78.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To make it possible to test this recipe in the Level Blueprint, we need to make
    the interface functions callable via Blueprint, so we need the `BlueprintCallable`
    specifier on our `UFUNCTION`.
  prefs: []
  type: TYPE_NORMAL
- en: However, in a `UInterface`, the compiler expects the interface to be implementable
    via both C++ and Blueprint by default. This conflicts with `BlueprintCallable`,
    which is merely saying that the function can be invoked from Blueprint, not that
    it can be overridden in it.
  prefs: []
  type: TYPE_NORMAL
- en: We can resolve this conflict by marking the interface as `CannotImplementInterfaceInBlueprint`.
    This enables the use of `BlueprintCallable` as our `UFUNCTION` specifier, rather
    than `BlueprintImplementableEvent` (which has extra overhead due to the extra
    code allowing for the function to be overridden via Blueprint).
  prefs: []
  type: TYPE_NORMAL
- en: We define `IsDead` and `Die` as `virtual` to allow them to be overridden in
    another C++ class that inherits this one. In our default interface implementation,
    `IsDead` always returns `false`. The default implementation of `Die` prints a
    death message to the screen, and then destroys the object implementing this interface
    if it is an `Actor`.
  prefs: []
  type: TYPE_NORMAL
- en: We can now create a second interface called `Undead`, which inherits from `Killable`.
    We use `public UKillable`/`public IKillable` in the class declarations to express
    this.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, as a result, we need to include the header file that defines the
    `Killable` interface. Our new interface overrides the two functions that `Killable`
    defines to provide more appropriate definitions of `IsDead`/`Die` for `Undead`.
    Our overridden definitions have `Undead` already dead by returning `true` from
    `IsDead`. When `Die` is called on `Undead`, we simply print a message with `Undead`
    laughing at our feeble attempt to kill it again, and do nothing.
  prefs: []
  type: TYPE_NORMAL
- en: We can also specify default implementations for our Undead-specific functions,
    namely `Turn()` and `Banish()`. When the `Undead` are Turned, they flee, and for
    demonstration purposes, we print a message to the screen. If an `Undead` is Banished,
    however, they are annihilated and destroyed without a trace.
  prefs: []
  type: TYPE_NORMAL
- en: To test our implementation, we create two `Actors` that each inherit from one
    of the two interfaces. After we add an instance of each actor to our level, we
    use the Level Blueprint to access the level's `BeginPlay` event. When the level
    begins to play, we use a message call to try and call the `Die` function on our
    instances.
  prefs: []
  type: TYPE_NORMAL
- en: The messages that print out are different and correspond to the two function
    implementations, showing that the Zombie's implementation of `Die` is different, and
    has overridden the Snail's.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding UInterface functions in C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One side-effect of UInterfaces allowing inheritance in C++ is that we can override
    default implementations in subclasses as well as in Blueprint. This recipe shows
    you how to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Follow the *Calling native UInterface functions from C++* recipe in which a
    Physics Cube has already been created so that you have the class ready.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new Interface called `Selectable`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cf51461a-92cc-42bb-b53b-83914ce680dd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Define the following functions inside `ISelectable`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Provide a default implementation for the functions, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a class based on `APhysicsCube` by right-clicking on the Physics Cube
    script from the Content Browser and selecting Create C++ class derived from PhysicsCube:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/705a33b1-bc34-4cab-83ef-5eb9f2f739c2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you''re done, change the Name of the new cube to `SelectableCube` and
    click on the Create Class option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/76752a9d-e70c-4fae-a2e7-faa8ab5cb57b.png)'
  prefs: []
  type: TYPE_IMG
- en: Add `#include "Selectable.h"` inside the `SelectableCube` class' header.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the `ASelectableCube` declaration, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following functions to the header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new class called `NonSelectableCube`, which inherits from `SelectableCube`,
    in the same manner that we did with the `Physics Cube` to create the `SelectableCube`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/604d9703-5f99-44c1-8cea-36ab7a22d846.png)'
  prefs: []
  type: TYPE_IMG
- en: '`NonSelectableCube` should override the functions from `SelectableInterface`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation file should be altered to include the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Place an instance of `SelectableCube` into the level at a certain range above
    the ground, and then play your game. You should get messages verifying that the
    actor is selectable, and that it has accepted the selection when the cube hits
    the ground:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d514b9e7-96d1-4b54-963e-3a1f72546c67.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Remove `SelectableCube` and replace it with an instance of `NonSelectableCube`
    to see the alternative messages indicating that this actor isn't selectable and
    has refused selection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We create three functions inside the `Selectable` interface. `IsSelectable`
    returns a Boolean to indicate whether the object is selectable. You could avoid
    this and simply use `TrySelect`, given that it returns a Boolean value to indicate
    success, but, for example, you might want to know if the object inside your UI
    is a valid selection without having to actually try it.
  prefs: []
  type: TYPE_NORMAL
- en: '`TrySelect` actually attempts to select the object. There''s no explicit contract
    forcing users to respect `IsSelectable` when trying to select the object, so `TrySelect`
    is named to communicates that the selection may not always succeed.'
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, `Deselect` is a function that's added to allow objects to handle losing
    the player selection. This could involve changing the UI elements, halting sounds
    or other visual effects, or simply removing a selection outline from around the
    unit.
  prefs: []
  type: TYPE_NORMAL
- en: The default implementations of the functions return `true` for `IsSelectable`
    (the default is for any object to be selectable), `true` for `TrySelect` (selection
    attempts always succeed), and issue a debug assert if `Deselect` is called without
    being implemented by the class.
  prefs: []
  type: TYPE_NORMAL
- en: You could also implement `Deselect` as a pure `virtual` function if you wish.
    `SelectableCube` is a new class inheriting from `PhysicsCube`, but also implementing
    the `ISelectable` interface. It also overrides `NotifyHit`, a `virtual` function
    defined in `AActor` that triggers when the actor undergoes a **RigidBody** collision.
  prefs: []
  type: TYPE_NORMAL
- en: We call the constructor from `PhysicsCube` with the `Super()` constructor call
    inside the implementation of `SelectableCube`. We then add our own implementation,
    which calls `SetNotifyRigidBodyCollision(true)` on our static mesh instance. This
    is necessary, because by default, `RigidBodies` (such as `PrimitiveComponents`
    with a collision) don't trigger `Hit` events as a performance optimization. As
    a result, our overridden `NotifyHit` function would never be called.
  prefs: []
  type: TYPE_NORMAL
- en: Within the implementation of `NotifyHit`, we call some of the `ISelectable`
    interface functions on ourselves. Given that we know we are an object that inherits
    from `ISelectable`, we don't need to cast to an `ISelectable*` to call them.
  prefs: []
  type: TYPE_NORMAL
- en: We check to see if the object is selectable with `IsSelectable` and, if so,
    we try to actually perform the selection using `TrySelect`. `NonSelectableCube`
    inherits from `SelectableCube`, so we can force the object to never be selectable.
  prefs: []
  type: TYPE_NORMAL
- en: We accomplish this by overriding the `ISelectable` interface functions again.
    Within `ANonSelectableCube::IsSelectable()`, we print a message to the screen
    so that we can verify that the function is being called, and then return `false`
    to indicate that the object isn't selectable at all.
  prefs: []
  type: TYPE_NORMAL
- en: In case the user doesn't respect `IsSelectable()`, `ANonSelectableCube::TrySelect()`
    always returns `false` to indicate that the selection wasn't successful.
  prefs: []
  type: TYPE_NORMAL
- en: Given that it is impossible for `NonSelectableCube` to be selected, `Deselect()`
    calls `unimplemented()`, which throws an assert warning that the function was
    not implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Now, when playing your scene, each time `SelectableCube`/`NonSelectableCube`
    hits another object, causing a RigidBody collision, the actor in question will
    attempt to select itself, and print messages to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refer to [Chapter 6](613bddf9-b8a6-44a4-a5ee-61d450415745.xhtml), *Input and
    Collision, and* the *Mouse UI input handling* recipe, which shows you how to **Raycast**
    from the mouse cursor into the game world to determine what is being clicked on.
    This could be used to extend this recipe to allow the player to click on items
    to select them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a simple interaction system with UInterfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how to combine a number of other recipes in this chapter
    to demonstrate a simple interaction system, and a door with an interactable doorbell
    to cause the door to open.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe requires the use of Action bindings. If you are unfamiliar with
    creating Action mappings, please refer to [Chapter 6](613bddf9-b8a6-44a4-a5ee-61d450415745.xhtml),
    *Input and Collision*, before continuing with this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new interface called `Interactable`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following functions to the `IInteractable` class declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Create a second interface, `Openable`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add this function to its declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Create a new class, based on `StaticMeshActor`, called `DoorBell`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add `#include "Interactable.h"` in `DoorBell.h`, and add the following functions
    to the class declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In the `.cpp` file for `DoorBell`, add `#include "Openable.h"`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Load a static mesh for our `DoorBell` in the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following function implementations to implement the `Interactable`
    interface on our `DoorBell`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Now create a new StaticMeshActor-based class called `Door`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`#include` the `Openable` and `Interactable` interfaces into the class header,
    and then modify Door''s declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Add interface functions and a constructor to `Door`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'As with `DoorBell`, in the `Door` constructor, initialize our mesh component
    and load a model in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement interface functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new DefaultPawn-based class called `InteractingPawn`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7461c8ae-8fcd-4088-9b81-11ef24f01cad.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Add the following functions to the `Pawn` class header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the implementation file for the `Pawn`, add `#include "Interactable.h"`,
    and then provide implementations for both functions from the header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Now, create a new `GameMode` in either C++ or Blueprint, and set `InteractingPawn`
    as our default `Pawn` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/69d62766-4048-48e4-9aeb-2f953a73ba43.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Drag a copy of both `Door` and `Doorbell` into the level:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7942f20f-0d64-45fd-9d08-35eac82a5dd1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Use the eyedropper beside doorbell''s Door to Open, as shown in the following
    screenshot, then click on the door actor instance in your level:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9423df93-c5d2-4666-bf2c-1a97fef82dc0.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you select the actor, you should see something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e2c5d6d5-100e-42b4-87fa-9225736a8849.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a new Action binding in the editor called `Interact` and bind it to
    a key of your choice:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3e619bc5-fa62-4306-a5b7-44f79c468adc.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Play your level and walk up to the doorbell. Look at it, and press whatever
    key you bound `Interact` with. Verify that the door moves once. Refer to the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3d3015cb-4993-4264-a6aa-5cfa33f45a0a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also interact with the door directly to receive some information about
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c417b020-3dc8-450b-8f4f-d185d61d75a1.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As in previous recipes, we mark `UFUNCTION` as `BlueprintNativeEvent` and `BlueprintCallable` to
    allow the `UInterface` to be implemented in either native code or Blueprint, and
    allow the functions to be called with either method.
  prefs: []
  type: TYPE_NORMAL
- en: We create `DoorBell` based on `StaticMeshActor` for convenience, and have `DoorBell`
    implement the `Interactable` interface. Inside the constructor for `DoorBell`,
    we initialize `HasBeenPushed` and `DoorToOpen` to the default safe values.
  prefs: []
  type: TYPE_NORMAL
- en: Within the implementation for `CanInteract`, we return the inverse of `HasBeenPushed`
    so that once the button has been pushed, it can't be interacted with.
  prefs: []
  type: TYPE_NORMAL
- en: Inside `PerformInteract`, we check if we have a reference to a door object to
    open. If we have a valid reference, we verify that the door actor implements `Openable`,
    and then we invoke the `Open` function on our door. Within `Door`, we implement
    both `Interactable` and `Openable`, and override the functions from each.
  prefs: []
  type: TYPE_NORMAL
- en: We define the `Door` implementation of `CanInteract` to be the same as the default.
    Within `PerformInteract`, we display a message to the user. Inside `Open`, we
    use `AddActorLocalOffset` to move the door a certain distance away. With Timeline
    in Blueprint or a linear interpolation, we could make this transition smooth rather
    than a teleport.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we create a new `Pawn` so that the player can actually interact with
    objects. We create a `TryInteract` function, which we bind to the `Interact` input
    action in the overridden `SetupPlayerInputComponent` function.
  prefs: []
  type: TYPE_NORMAL
- en: This means that when the player performs the input that is bound to `Interact`,
    our `TryInteract` function will run. `TryInteract` gets a reference to `PlayerController`,
    casting the generic controller reference that all Pawns have.
  prefs: []
  type: TYPE_NORMAL
- en: '`PlayerCameraManager` is retrieved through `PlayerController`, so we can access
    the current location and rotation of the player camera. We create start and end
    points using the camera''s location, then 100 units in the forward direction away
    from the camera''s location, and pass those into `GetWorld::SweepSingleByObjectType`.
    This function takes in a number of parameters. `HitResult` is a variable that
    allows the function to return information about any object hit by the trace. `CollisionObjectQueryParams`
    allows us to specify whether we are interested in dynamic, static items, or both.'
  prefs: []
  type: TYPE_NORMAL
- en: We accomplish a sphere trace by passing the shape in using the `MakeSphere`
    function. Sphere traces allow for slightly more human error by defining a cylinder
    to check for objects rather than a straight line. Given that the players might
    not look directly at your object, you can tweak the sphere's radius as appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: The final parameter, `SweepSingleByObjectType`, is a struct that gives the trace
    a name, lets us specify whether we are colliding against a complex collision geometry,
    and most importantly, allows us to specify that we want to ignore the object that
    is initiating the trace.
  prefs: []
  type: TYPE_NORMAL
- en: If `HitResult` contains an actor after the trace is done, we check whether the
    actor implements our interface, then attempt to call `CanInteract` on it. If the
    actor indicates yes, it can be interacted with, so we then tell it to actually
    perform the interaction.
  prefs: []
  type: TYPE_NORMAL
