- en: 'Communication Between Classes and Interfaces: Part I'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类和接口之间的通信：第一部分
- en: 'The following recipes will be covered in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: Creating a UInterface
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 UInterface
- en: Implementing a UInterface on an object
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在对象上实现 UInterface
- en: Checking if a class implements a UInterface
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查类是否实现了 UInterface
- en: Casting to a UInterface implemented in native code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将类型强制转换为原生代码中实现的 UInterface
- en: Calling native UInterface functions from C++
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 C++ 调用原生 UInterface 函数
- en: Inheriting UInterfaces from one another
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从一个 UInterface 继承另一个 UInterface
- en: Overriding UInterface functions in C++
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 C++ 中重写 UInterface 函数
- en: Implementing a simple interaction system with UInterfaces
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 UInterface 实现一个简单的交互系统
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This chapter shows you how to write your own UInterfaces, and demonstrates how
    to take advantage of them within C++ to minimize class coupling and help keep
    your code clean.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您展示如何编写自己的 UInterfaces，并演示如何在 C++ 中利用它们以最小化类耦合并保持代码整洁。
- en: In your game projects, you will sometimes require a series of potentially disparate
    objects to share a common functionality, but it would be inappropriate to use
    inheritance because there is no *is-a* relationship between the different objects
    in question. Languages such as C++ tend to use multiple inheritance to solve this
    issue.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的游戏项目中，您有时需要一系列可能不同的对象共享一个共同的功能，但使用继承是不合适的，因为所涉及的不同对象之间没有 *is-a* 关系。像 C++
    这样的语言倾向于使用多重继承来解决这个问题。
- en: 'However, in Unreal, if you wanted functions from both parent classes to be
    accessible to Blueprint, you would need to make both of them `UCLASS`. This is
    a problem for two reasons. Inheriting from `UClass` twice in the same object would
    break the concept that `UObject` should form a neatly traversable hierarchy. It
    also means that there are two instances of the `UClass` methods on the object,
    and they would have to be explicitly differentiated between within the code. The
    Unreal codebase solves this issue by borrowing a concept from C#: that of an explicit
    Interface type.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 Unreal 中，如果您想使父类中的函数对 Blueprint 可访问，您需要将它们都设置为 `UCLASS`。这有两个原因。在同一个对象中两次继承
    `UClass` 会破坏 `UObject` 应该形成一个整洁的可遍历层次结构的概念。这也意味着对象上有两个 `UClass` 方法的实例，它们必须在代码中明确区分。Unreal
    代码库通过借鉴 C# 中的一个概念来解决此问题：显式接口类型。
- en: The reason for using this approach, instead of composition, is that Components
    are only available on Actors, not on UObjects in general. Interfaces can be applied
    to any `UObject`. Furthermore, it means that we are no longer modeling an *is-a*
    relationship between the object and the component; instead, it would only be able
    to represent *has-a* relationships.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法而不是组合的原因是，组件仅在 Actors 上可用，而不是在一般的 UObjects 上。接口可以应用于任何 `UObject`。此外，这意味着我们不再在对象和组件之间建模
    *is-a* 关系；相反，它只能表示 *has-a* 关系。
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires the use of Unreal Engine 4 and uses Visual Studio 2017
    as the IDE. Instructions on how to install both pieces of software and the requirements
    for them can be found in [Chapter 1](4adb307e-d86f-4d70-b6de-a0893102d1cf.xhtml),
    *UE4 Development Tools*, of this book.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要使用 Unreal Engine 4，并使用 Visual Studio 2017 作为 IDE。有关如何安装这两款软件及其要求的信息，请参阅本书第
    1 章，*UE4 开发工具*。
- en: Creating a UInterface
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个 UInterface
- en: UInterfaces are pairs of classes that work together to enable classes to exhibit
    polymorphic behavior among multiple class hierarchies. This recipe shows you the
    basic steps involved in creating a UInterface purely in code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: UInterfaces 是成对的类，它们协同工作以使类能够在多个类层次结构中表现出多态行为。本食谱展示了仅通过代码创建 UInterface 的基本步骤。
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'From the Content Browser, go to Add New | New C++ Class. From the menu that
    pops up, scroll down all the way until you see the Unreal Interface selection
    and select it. Afterward, click on the Next button:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从内容浏览器中，转到添加新 | 新 C++ 类。从弹出的菜单中，向下滚动直到看到 Unreal Interface 选择项并选择它。之后，点击下一步按钮：
- en: '![](img/6dca5f4f-671b-4279-91c2-4ec127cda935.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6dca5f4f-671b-4279-91c2-4ec127cda935.png)'
- en: 'From there, verify that the Name of the class is `MyInterface` and then click
    on the Create Class button:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从那里，验证类的名称是否为 `MyInterface`，然后点击创建类按钮：
- en: '![](img/c611d729-5476-4d87-8324-0052c4d67e5c.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c611d729-5476-4d87-8324-0052c4d67e5c.png)'
- en: 'Add the following code to the header file:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到头文件中：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Implement the class with this code in the `.cpp` file:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `.cpp` 文件中实现以下代码的类：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Compile your project to verify that the code was written without errors.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译你的项目以验证代码是否编写无误。
- en: How it works...
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: UInterfaces are implemented as pairs of classes that are declared in the interface's
    header.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: UInterfaces 是作为接口头文件中声明的类对的实现。
- en: As always, because we are leveraging Unreal's reflection system, we need to
    include our generated header file. Refer to the *Handling events implemented via
    virtual functions* recipe in [Chapter 5](cf821ef4-8a19-440c-805d-573748b76d5f.xhtml),
    *Handling Events and Delegates*, for more information.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，因为我们正在利用 Unreal 的反射系统，我们需要包含我们的生成头文件。有关更多信息，请参阅 [第 5 章](cf821ef4-8a19-440c-805d-573748b76d5f.xhtml)
    中的 *Handling events implemented via virtual functions* 菜单，*Handling Events and
    Delegates*。
- en: As with classes that inherit from `UObject`, which uses `UCLASS`, we need to
    use the `UINTERFACE` macro to declare our new `UInterface`. Passing in the class
    specifier of `MinimalAPI` causes only the class's type information to be exported
    for use by other modules.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 就像继承自使用 `UCLASS` 的 `UObject` 的类一样，我们需要使用 `UINTERFACE` 宏来声明我们的新 `UInterface`。传递
    `MinimalAPI` 类指定符只会导出类的类型信息供其他模块使用。
- en: For more information on this and other class specifiers, check out: [https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Classes/Specifiers](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Classes/Specifiers).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 想要了解更多关于此以及其他类指定符的信息，请查看：[https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Classes/Specifiers](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Classes/Specifiers).
- en: The class is tagged as `UE4COOKBOOK_API` to help with exporting library symbols.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 该类被标记为 `UE4COOKBOOK_API` 以帮助导出库符号。
- en: The base class for the `UObject` portion of the interface is `UInterface`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接口 `UObject` 部分的基类是 `UInterface`。
- en: Just like `UCLASS` types, we require a macro to be placed inside the body of
    our class so that the auto-generated code is inserted into it. That macro is `GENERATED_BODY()`
    for UInterfaces. The macro must be placed at the very start of the class body.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `UCLASS` 类型一样，我们需要在类的主体内部放置一个宏，以便将自动生成的代码插入其中。对于 UInterfaces，这个宏是 `GENERATED_BODY()`。这个宏必须放在类主体的开头。
- en: The second class is also tagged as `UE4COOKBOOK_API`, and is named in a specific
    way.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个类也被标记为 `UE4COOKBOOK_API`，并且以特定的方式命名。
- en: Note that the `UInterface` derived class and the standard class have the same
    name but a different prefix. The `UInterface` derived class has the prefix `U`,
    and the standard class has the prefix `I`. This is important as this is how the
    Unreal Header Tool expects classes to be named for the code it generates to work
    properly.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`UInterface` 派生类和标准类具有相同的名称但不同的前缀。`UInterface` 派生类的前缀是 `U`，而标准类的前缀是 `I`。这一点很重要，因为
    Unreal Header Tool 预期类以这种方式命名，以便生成的代码能够正常工作。
- en: The plain native Interface class requires its own autogenerated content, which
    we include using the `GENERATED_BODY()` macro.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 纯原生的 Interface 类需要其自己的自动生成内容，我们使用 `GENERATED_BODY()` 宏来包含它。
- en: We declare functions that classes inheriting the interface should implement
    inside `IInterface`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `IInterface` 中声明了继承该接口的类应该实现的功能。
- en: Within the implementation file, we implement the constructor for our `UInterface`,
    as it is declared by the Unreal Header Tool and requires an implementation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现文件中，我们实现 `UInterface` 的构造函数，因为它是由 Unreal Header Tool 声明并需要实现的。
- en: We also create a default implementation for our `GetTestName()` function. Without
    this, the linking phase in the compilation will fail. This default implementation
    uses the `unimplemented()` macro, which will issue a debug assert when the line
    of code is executed.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还为我们自己的 `GetTestName()` 函数创建了一个默认实现。如果没有这个实现，编译过程中的链接阶段将会失败。这个默认实现使用了 `unimplemented()`
    宏，当执行到该代码行时会发出调试断言。
- en: For more information on creating interfaces, check out the following link: [https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/Reference/Interfaces](https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/Reference/Interfaces).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 想要了解更多关于创建界面的信息，请查看以下链接：[https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/Reference/Interfaces](https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/Reference/Interfaces).
- en: See also
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the *Passing payload data with a delegate binding* recipe in [Chapter
    5](cf821ef4-8a19-440c-805d-573748b76d5f.xhtml), *Handling Events and Delegates*;
    the first recipe, in particular, explains some of the principles that we've applied
    here
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参阅 [第 5 章](cf821ef4-8a19-440c-805d-573748b76d5f.xhtml) 中的 *Passing payload data
    with a delegate binding* 菜单，*Handling Events and Delegates*；特别是第一个菜谱解释了我们在这里应用的一些原则。
- en: Implementing a UInterface on an object
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在对象上实现 UInterface
- en: Now that we have created a UInterface, we can say that an object has all of
    the functions defined or implements them. In this recipe, we will see exactly
    how to do that.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个 UInterface，我们可以说一个对象具有定义的所有函数或实现了它们。在这个食谱中，我们将看到如何确切地做到这一点。
- en: Getting ready
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Ensure that you've followed the previous recipe so that you have a `UInterface`
    ready to be implemented.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已经遵循了前面的食谱，以便你有一个准备实现的 `UInterface`。
- en: How to do it...
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new `Actor` class using the Unreal Wizard, called `SingleInterfaceActor`:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Unreal Wizard 创建一个新的 `Actor` 类，命名为 `SingleInterfaceActor`：
- en: '![](img/7e99dfee-3068-4773-a9e3-442b78c69dc1.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7e99dfee-3068-4773-a9e3-442b78c69dc1.png)'
- en: 'Add `IInterface`—in this case, `IMyInterface`—to the public inheritance list
    for our new `Actor` class:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `IInterface`——在这种情况下，`IMyInterface`——添加到我们新的 `Actor` 类的公共继承列表中：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add an `override` declaration to the class for the `IInterface` function(s)
    that we wish to override:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们希望重写的 `IInterface` 函数添加一个 `override` 声明：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Implement the overridden function in the implementation file by adding the
    following code:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实现文件中通过添加以下代码来实现重写的函数：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: C++ uses multiple inheritance in the way it implements interfaces, so we leverage
    that mechanism here with the declaration of our `SingleInterfaceActor` class,
    where we add `public IMyInterface`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 在实现接口时使用多重继承，所以我们利用这个机制在这里声明我们的 `SingleInterfaceActor` 类，其中我们添加 `public
    IMyInterface`。
- en: We inherit from `IInterface` rather than `UInterface` to prevent `SingleInterfaceActor`
    from inheriting two copies of `UObject`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 `IInterface` 而不是 `UInterface` 继承，以防止 `SingleInterfaceActor` 继承两份 `UObject`。
- en: Given that the interface declares a `virtual` function, we need to redeclare
    that function with the override specifier if we wish to implement it ourselves.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于接口声明了一个 `virtual` 函数，如果我们想自己实现它，我们需要使用 `override` 指示符重新声明该函数。
- en: In our implementation file, we implement our overridden `virtual` function.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的实现文件中，我们实现我们的重写 `virtual` 函数。
- en: Inside our function override, for demonstration purposes, we call the base `IInterface`
    implementation of the function. Alternatively, we could write our own implementation
    and avoid calling the base class one altogether.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的函数重写中，为了演示目的，我们调用基 `IInterface` 的函数实现。或者，我们也可以编写自己的实现，完全避免调用基类。
- en: 'We use `IInterface:: specifier` rather than `Super`, because `Super` refers
    to the `UClass` that is the parent of our class, and `IInterfaces` aren''t UClasses
    (hence there''s no `U` prefix).'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `IInterface::specifier` 而不是 `Super`，因为 `Super` 指的是我们类父类的 `UClass`，而 `IInterfaces`
    不是 UClasses（因此没有 `U` 前缀）。
- en: You can implement a second, or multiple, `IInterfaces` on your object, as needed.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 根据需要，你可以在你的对象上实现第二个或多个 `IInterfaces`。
- en: Checking if a class implements a UInterface
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查类是否实现了 UInterface
- en: When writing C++ code, it's always a good idea to make sure that something exists
    before using it. In this recipe, we will see how we can check whether a particular
    object implements a specific `UInterface`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写 C++ 代码时，确保在使用之前某物存在总是一个好主意。在这个食谱中，我们将看到我们如何检查一个特定的对象是否实现了特定的 `UInterface`。
- en: Getting ready
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Follow the first two recipes so that you have a `UInterface` we can check for,
    and a class implementing the interface that can be tested against.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 按照前两个食谱操作，以便你有一个可以检查的 `UInterface`，以及一个实现该接口并可进行测试的类。
- en: How to do it...
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Inside your Game Mode implementation, add the following code to the `BeginPlay`
    function:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的游戏模式实现中，将以下代码添加到 `BeginPlay` 函数中：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Given that we are referencing both `ASingleInterfaceActor` and `IMyInterface`,
    we need to `#include` both `MyInterface.h` and `SingleInterfaceActor.h` in our
    source file:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们同时引用了 `ASingleInterfaceActor` 和 `IMyInterface`，我们需要在我们的源文件中包含 `MyInterface.h`
    和 `SingleInterfaceActor.h`：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Save your script and compile your code. Afterward, from the World Settings
    menu, set the GameMode Override property to your `GameModeBase` class and play
    the game. If all went well, you should see a message stating that you''ve implemented
    the interface:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的脚本并编译你的代码。之后，从“世界设置”菜单中，将游戏模式覆盖属性设置为你的 `GameModeBase` 类并玩游戏。如果一切顺利，你应该会看到一个消息表明你已经实现了接口：
- en: '![](img/422edfd8-62f6-48ff-ab9e-71064b5d6b52.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/422edfd8-62f6-48ff-ab9e-71064b5d6b52.png)'
- en: How it works...
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Inside `BeginPlay`, we create an empty `FTransform` object, which has the default
    value of `0` for all translation and rotation components, so we don't need to
    explicitly set any of them.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `BeginPlay` 中，我们创建一个空的 `FTransform` 对象，其所有平移和旋转组件的默认值为 `0`，因此我们不需要显式设置任何组件。
- en: We then use the `SpawnActor` function from `UWorld` so that we can create an
    instance of our `SingleActorInterface`, storing the pointer to the instance into
    a temporary variable.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 `UWorld` 中的 `SpawnActor` 函数来创建我们的 `SingleActorInterface` 实例，并将实例的指针存储到一个临时变量中。
- en: We then use `GetClass()` on our instance to get a reference to its associated
    `UClass`. We need a reference to `UClass` because that object is the one that
    holds all of the reflection data for the object.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 `GetClass()` 在我们的实例上获取其关联的 `UClass` 的引用。我们需要 `UClass` 的引用，因为该对象持有对象的全部反射数据。
- en: Reflection data includes the names and types of all `UPROPERTY` on the object,
    the inheritance hierarchy for the object, and a list of all the interfaces that
    it implements.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 反射数据包括对象上所有 `UPROPERTY` 的名称和类型，对象的继承层次结构，以及它实现的所有接口列表。
- en: As a result, we can call `ImplementsInterface()` on `UClass`, and it will return
    `true` if the object implements the `UInterface` in question.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以在 `UClass` 上调用 `ImplementsInterface()`，如果对象实现了相关的 `UInterface`，它将返回 `true`。
- en: If the object implements the interface, and therefore returns `true` from `ImplementsInterface`,
    we then print a message to the screen.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对象实现了该接口，因此从 `ImplementsInterface` 返回 `true`，我们就会在屏幕上打印一条消息。
- en: See also
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: '[Chapter 4](eade601c-4b55-484a-ba49-0a989d81d7f8.xhtml), Actors and Components,
    has a number of recipes relating to the spawning of actors (such as Instantiating
    an Actor using SpawnActor)'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 4 章](eade601c-4b55-484a-ba49-0a989d81d7f8.xhtml)，演员和组件，包含许多与演员生成相关的菜谱（例如使用
    SpawnActor 实例化演员）'
- en: Casting to a UInterface implemented in native code
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将其转换为在本地代码中实现的 UInterface
- en: One advantage that UInterfaces provide you with as a developer is the ability
    to treat a collection of heterogeneous objects that implement a common interface
    as a collection of the same object, using `Cast< >` to handle the conversion.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: UInterfaces 作为开发者提供的一个优点是，能够将实现公共接口的异构对象集合视为同一对象的集合，使用 `Cast< >` 来处理转换。
- en: Please note that this won't work if your class implements the interface through
    a Blueprint.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果你的类通过蓝图实现接口，则此方法将不起作用。
- en: Getting ready
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You should have a `UInterface` and an `Actor` implementing the interface ready
    for this recipe.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该准备好一个 `UInterface` 和一个实现该接口的 `Actor`。
- en: Create a new game mode using the wizard within Unreal, or reuse a project and
    `GameMode` from a previous recipe.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Unreal 中的向导创建一个新的游戏模式，或者重用之前菜谱中的项目及 `GameMode`。
- en: How to do it...
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Open your game mode''s declaration and add a new property to the class:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的游戏模式声明，并向类中添加一个新属性：
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add `#include "MyInterface.h"` to the header''s include section:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在头文件的包含部分添加 `#include "MyInterface.h"`：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Add the following within the game mode''s `BeginPlay` implementation:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在游戏模式的 `BeginPlay` 实现中添加以下内容：
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Since we are using the `TActorIterator` class, we will need to add the following
    `#include` to the top of our `GameModeBase` class'' implementation file:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们使用 `TActorIterator` 类，我们需要在 `GameModeBase` 类的实现文件顶部添加以下 `#include`：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If you haven't done so already, set the level's game mode override to your game
    mode, then drag a few instances of your custom Interface-implementing actor into
    the level.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未这样做，请将级别的游戏模式覆盖设置为你的游戏模式，然后将几个自定义接口实现 Actor 的实例拖入级别。
- en: 'When you play your level, a message should be printed on screen that indicates the
    number of instances of the interface that have been implemented in Actors in the
    level:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你播放你的级别时，屏幕上应该会打印一条消息，指示级别中 Actor 实现的接口实例数量：
- en: '![](img/0a8cdda5-261c-4524-9d5f-bf81e434fb90.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0a8cdda5-261c-4524-9d5f-bf81e434fb90.png)'
- en: How it works...
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We create an array of pointers to `MyInterface` implementations.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个指向 `MyInterface` 实现的指针数组。
- en: Inside `BeginPlay`, we use `TActorIterator<AActor>` to get all of the `Actor`
    instances in our level.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `BeginPlay` 中，我们使用 `TActorIterator<AActor>` 来获取我们级别中的所有 `Actor` 实例。
- en: '`TActorIterator` has the following constructor:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`TActorIterator` 有以下构造函数：'
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`TActorIterator` expects a world to act on, as well as a `UClass` instance
    to specify what types of Actor we are interested in.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`TActorIterator` 期望一个可以作用的世界，以及一个 `UClass` 实例来指定我们感兴趣的 Actor 类型。'
- en: '`ActorIterator` is an iterator like the STL iterator type. This means that
    we can write a `for` loop in the following form:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`ActorIterator`是一个类似于STL迭代器类型的迭代器。这意味着我们可以编写如下形式的`for`循环：'
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Inside the loop, we dereference the iterator to get an `Actor` pointer.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环内部，我们取消迭代器的引用以获取一个`Actor`指针。
- en: We then attempt to cast it to our interface; this will return a pointer to the
    interface if it does implement it, otherwise it will return `nullptr`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后尝试将其转换为我们的接口；如果它确实实现了该接口，这将返回接口的指针，否则它将返回`nullptr`。
- en: As a result, we can check if the interface pointer is `null`, and if not, we
    can add the interface pointer reference to our array.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以检查接口指针是否为`null`，如果不是，我们可以将接口指针引用添加到我们的数组中。
- en: Finally, once we've iterated through all the actors in `TActorIterator`, we
    can display a message on the screen that displays the count of items that implemented
    the interface.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一旦我们迭代了`TActorIterator`中的所有演员，我们可以在屏幕上显示一个消息，显示实现了该接口的项目数量。
- en: Calling native UInterface functions from C++
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从C++调用原生UInterface函数
- en: We can use C++ to call native `UInterface` functions from other classes as well.
    For example, in this recipe, we will make a volume call a function on an object
    if it implements a particular interface.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用C++从其他类调用原生的`UInterface`函数。例如，在这个菜谱中，我们将使一个体积在对象实现特定接口的情况下调用该对象上的函数。
- en: Getting ready
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Follow the previous recipe to get an understanding of casting an `Actor` pointer
    to an Interface pointer.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 按照之前的菜谱了解如何将`Actor`指针转换为接口指针。
- en: Note that as this recipe relies on the casting technique we used in the previous
    recipe, it will only work with objects that implement the interface using C++
    rather than Blueprint. This is because Blueprint classes are not available at
    compile time, and so, technically, don't inherit the interface.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于这个菜谱依赖于我们在之前的菜谱中使用的转换技术，它只适用于使用C++而不是Blueprint实现接口的对象。这是因为Blueprint类在编译时不可用，因此技术上不继承接口。
- en: How to do it...
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a new `Actor` class using the editor wizard. Call it `AntiGravityVolume`:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用编辑器向导创建一个新的`Actor`类。命名为`AntiGravityVolume`：
- en: '![](img/792cb6e1-aada-45b7-91cb-a91759eec844.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/792cb6e1-aada-45b7-91cb-a91759eec844.png)'
- en: 'Update the header file to add a `BoxComponent` to the new `Actor` and two virtual
    functions:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新头文件以向新的`Actor`添加一个`BoxComponent`和两个虚拟函数：
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create an implementation within your source file, as follows:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的源文件中创建一个实现，如下所示：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Initialize the `BoxComponent` in your constructor:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的构造函数中初始化`BoxComponent`：
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The script will not compile since `GravityObject` doesn''t exist. Let''s fix
    that:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本将无法编译，因为`GravityObject`不存在。让我们修复这个问题：
- en: 'Create an interface called `GravityObject`:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`GravityObject`的接口：
- en: '![](img/f70de395-ca21-4083-ba93-20a4bfc9d5e3.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/f70de395-ca21-4083-ba93-20a4bfc9d5e3.png)'
- en: 'Add the following `virtual` functions to `IGravityObject`:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`IGravityObject`添加以下`virtual`函数：
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create the default implementation of the `virtual` functions inside the `IGravityObject`
    implementation file:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`IGravityObject`实现文件中创建`virtual`函数的默认实现：
- en: '[PRE17]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Afterward, go back to the `AntiGravityVolume.cpp` file and add the following
    `#include`:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，回到`AntiGravityVolume.cpp`文件并添加以下`#include`：
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: At this point, our code will compile, but there's nothing using the interface.
    Let's add a new class that will.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的代码可以编译，但没有东西使用这个接口。让我们添加一个新的类来使用它。
- en: 'Create a subclass of `Actor` called `PhysicsCube`:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`PhysicsCube`的`Actor`的子类：
- en: '![](img/9d05909d-0f15-4f7f-be62-c37bbe5a0822.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/9d05909d-0f15-4f7f-be62-c37bbe5a0822.png)'
- en: 'Add a static mesh property to the header:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在头文件中添加一个静态网格属性：
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Initialize the component in your constructor:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的构造函数中初始化组件：
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To have `PhysicsCube` implement `GravityObject`, first `#include "GravityObject.h"`
    in the header file, then modify the class declaration:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要让`PhysicsCube`实现`GravityObject`，首先在头文件中包含`#include "GravityObject.h"`，然后修改类声明：
- en: '[PRE21]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Compile your project.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译你的项目。
- en: Create a new level and place an instance of our gravity volume in the scene.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的关卡并将我们的重力体积实例放置在场景中。
- en: 'Place an instance of `PhysicsCube` above the gravity volume, then rotate it
    slightly so that it has one corner lower than the others, as shown in the following
    screenshot:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在重力体积上方放置一个`PhysicsCube`实例，然后稍微旋转它，使其一个角比其他角低，如下面的截图所示：
- en: '![](img/104ff00e-4823-4862-b609-48373dbda8a8.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/104ff00e-4823-4862-b609-48373dbda8a8.png)'
- en: 'Verify that the gravity is turned off on the object when it enters the volume
    and then turns back on again:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证当对象进入体积时重力被关闭，然后再次打开：
- en: '![](img/a8a01273-e5e5-42c6-97b6-e47dc0aeeb6a.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a8a01273-e5e5-42c6-97b6-e47dc0aeeb6a.png)'
- en: Note that the gravity volume doesn't need to know anything about your `PhysicsCube` actor,
    just the `GravityObject` interface.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，重力体积不需要了解你的 `PhysicsCube` 演员任何事情，只需要 `GravityObject` 接口。
- en: How it works...
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We create a new `Actor` class and add a box component to give the actor something
    that will collide with the character. Alternatively, you could subclass `AVolume`
    if you wanted to use the **Binary Space Partitioning** (**BSP**) functionality
    to define the volume's shape (found under Geometry in the Place section of the
    Modes tab).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个新的 `Actor` 类并添加一个盒子组件，以便让演员拥有可以与角色碰撞的东西。或者，如果你想使用 **二叉空间划分（BSP**） 功能来定义体积的形状（在模式选项卡的“位置”部分下的“几何”中找到），你可以将
    `AVolume` 作为子类。
- en: '`NotifyActorBeginOverlap` and `NotifyActorEndOverlap` are overridden so that
    we can perform an operation when an object enters or leaves the `AntiGravityVolume`
    area.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`NotifyActorBeginOverlap` 和 `NotifyActorEndOverlap` 被覆盖，这样我们就可以在对象进入或离开 `AntiGravityVolume`
    区域时执行操作。'
- en: Inside the `NotifyActorBeginOverlap` implementation, we attempt to cast the
    object that overlapped us into an `IGravityObject` pointer. This tests whether
    the object in question implements the interface. If the pointer is valid, then
    the object does implement the interface, so it is safe to use the interface pointer
    to call Interface methods on the object.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `NotifyActorBeginOverlap` 的实现中，我们尝试将重叠我们的对象强制转换为 `IGravityObject` 指针。这测试了问题中的对象是否实现了接口。如果指针有效，那么该对象确实实现了接口，因此可以使用接口指针在对象上调用接口方法。
- en: Given that we are inside `NotifyActorBeginOverlap`, we want to disable gravity
    on the object, so we call `DisableGravity()`. Inside `NotifyActorEndOverlap`,
    we perform the same check, but we re-enable gravity on the object. Within the
    default implementation of `DisableGravity`, we cast our own pointer (the `this`
    pointer) to `AActor`. This allows us to confirm that the interface has been implemented
    only on the `Actor` subclasses, and to call methods defined in `AActor`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们处于 `NotifyActorBeginOverlap` 中，我们希望禁用对象的重力，因此我们调用 `DisableGravity()`。在 `NotifyActorEndOverlap`
    中，我们执行相同的检查，但重新启用对象的重力。在 `DisableGravity` 的默认实现中，我们将自己的指针（`this` 指针）强制转换为 `AActor`。这允许我们确认接口仅在
    `Actor` 子类中实现，并且可以调用 `AActor` 中定义的方法。
- en: 'If the pointer is valid, we know we are an `Actor`, so we can use `GetComponents<class
    ComponentType>()` to get a `TArray` of all components of a specific type from
    ourselves. `GetComponents` is a `template` function. It expects some template
    parameters, as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指针有效，我们知道我们是一个 `Actor`，因此我们可以使用 `GetComponents<class ComponentType>()` 来从我们自身获取所有特定类型的组件的
    `TArray`。`GetComponents` 是一个 `template` 函数。它期望一些模板参数，如下所示：
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Since the 2014 version of the standard, C++ supports compile-time deduction
    of template parameters. This means that we don't need to actually specify the
    template parameters when we call the function if the compiler can work them out
    from the normal function parameters that we provide.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 2014 年的标准化版本以来，C++ 支持编译时模板参数推导。这意味着如果编译器可以从我们提供的普通函数参数中解析出这些参数，我们就不需要实际指定模板参数来调用函数。
- en: The default implementation of `TArray` is `template<typename T, typename Allocator
    = FDefaultAllocator> class TArray;`. This means that we don't need to specify
    an allocator by default, so we just use `TArray<UPrimitiveComponent*>` when we
    declare the array.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`TArray` 的默认实现是 `template<typename T, typename Allocator = FDefaultAllocator>
    class TArray;` 这意味着我们默认不需要指定分配器，因此当我们声明数组时，我们只需使用 `TArray<UPrimitiveComponent*>`。'
- en: When `TArray` is passed into the `GetComponents` function, the compiler knows
    it is actually `TArray<UPrimitiveComponent*, FDefaultAllocator>`, and it is able
    to fill in the template parameters `T` and `AllocatorType` with `UPrimitiveComponent`
    and `FDefaultAllocator`, so neither of those are required as template parameters
    for the function's invocation.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `TArray` 被传递到 `GetComponents` 函数时，编译器知道它实际上是 `TArray<UPrimitiveComponent*,
    FDefaultAllocator>`，并且它能够用 `UPrimitiveComponent` 和 `FDefaultAllocator` 填充模板参数
    `T` 和 `AllocatorType`，因此这两个都不是函数调用的模板参数所必需的。
- en: '`GetComponents` iterates through the components that `Actor` has, and any components
    that inherit from `typename T` have pointers to them stored inside the `PrimitiveComponents`
    array.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetComponents` 遍历 `Actor` 拥有的组件，并将任何从 `typename T` 继承的组件的指针存储在 `PrimitiveComponents`
    数组中。'
- en: Using a range-based `for` loop, another new feature of C++, we can iterate over
    the components that the function placed into our `TArray` without needing to use
    the traditional `for` loop structure.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于范围的`for`循环，C++的另一个新特性，我们可以遍历函数放入我们的`TArray`中的组件，而无需使用传统的`for`循环结构。
- en: Each of the components has `SetEnableGravity(false)` called on them, which disables
    gravity.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 每个组件都会调用`SetEnableGravity(false)`，这将禁用重力。
- en: Likewise, the `EnableGravity` function iterates over all the primitive components
    contained in the actor, and enables gravity with `SetEnableGravity(true)`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`EnableGravity`函数遍历演员中包含的所有原始组件，并使用`SetEnableGravity(true)`启用重力。
- en: See also
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考也
- en: Look at [Chapter 4](eade601c-4b55-484a-ba49-0a989d81d7f8.xhtml), *Actors and
    Components,* for extensive discussions on Actors and Components
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看[第四章](eade601c-4b55-484a-ba49-0a989d81d7f8.xhtml)，*演员和组件*，以了解关于演员和组件的详细讨论
- en: '[Chapter 5](cf821ef4-8a19-440c-805d-573748b76d5f.xhtml), *Handling Events and
    Delegates,* discusses events such as `NotifyActorOverlap`'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第五章](cf821ef4-8a19-440c-805d-573748b76d5f.xhtml)，*处理事件和委托*，讨论了诸如`NotifyActorOverlap`的事件'
- en: Inheriting UInterfaces from one another
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从彼此继承UInterfaces
- en: Sometimes, you may need to create a `UInterface` that specializes on a more
    general `UInterface`. This recipe shows you how to use inheritance with UInterfaces
    to specialize a `Killable` interface with an `Undead` interface that cannot be
    killed by normal means.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能需要创建一个专门于更通用`UInterface`的`UInterface`。这个配方展示了如何使用UInterfaces的继承来专门化一个不能通过常规方式被杀死的`Killable`接口。
- en: How to do it...
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Create a `UInterface`/`IInterface` called `Killable`:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Killable`的`UInterface`/`IInterface`：
- en: '![](img/20054dc1-f6a5-4b7e-aec6-a85686630416.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/20054dc1-f6a5-4b7e-aec6-a85686630416.png)'
- en: 'Add `UINTERFACE(meta=(CannotImplementInterfaceInBlueprint))` to the `UInterface`
    declaration:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`UInterface`声明中添加`UINTERFACE(meta=(CannotImplementInterfaceInBlueprint))`：
- en: '[PRE23]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Add the following functions to the header file under the `IKillable` class:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`IKillable`类下添加以下函数：
- en: '[PRE24]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Provide default implementations for the interface inside the implementation
    file:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实现文件中为接口提供默认实现：
- en: '[PRE25]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Create a new `UINTERFACE`/`IInterface` called `Undead`:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`UINTERFACE`/`IInterface`名为`Undead`：
- en: '![](img/10841280-bffb-4867-a944-d463288ade74.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/10841280-bffb-4867-a944-d463288ade74.png)'
- en: 'Modify them so they inherit from `UKillable`/`IKillable`:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改它们，使它们从`UKillable`/`IKillable`继承：
- en: '[PRE26]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Ensure that you include the header defining the `Killable` interface.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你包含了定义`Killable`接口的头文件。
- en: 'Add some overrides and new method declarations to the new interface:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向新接口添加一些重写和新方法声明：
- en: '[PRE27]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Create implementations for the functions:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为以下函数创建实现：
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Create two new `Actor` classes in C++: one called `Snail`, and another called
    `Zombie`.'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在C++中创建两个新的`Actor`类：一个名为`Snail`，另一个名为`Zombie`。
- en: 'Set the `Snail` class to implement the `IKillable` interface, and add the appropriate
    header file, `#include`:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Snail`类设置为实现`IKillable`接口，并添加适当的头文件，`#include`：
- en: '[PRE29]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Likewise, set the `Zombie` class to implement `IUndead`, and `#include "Undead.h"`:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，将`Zombie`类设置为实现`IUndead`，并添加`#include "Undead.h"`：
- en: '[PRE30]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Compile your project and drag an instance of both `Zombie` and `Snail` into
    your level:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译你的项目并将`Zombie`和`Snail`的实例拖入你的关卡中：
- en: '![](img/131d2208-a1c8-45cd-ab64-d2bb2dfc2f2c.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/131d2208-a1c8-45cd-ab64-d2bb2dfc2f2c.png)'
- en: 'Open the Level Blueprint by going to Blueprints | Level Blueprint. Afterward,
    add references to each of the newly created objects in the Level Blueprint by
    dragging and dropping them from the World Outliner into the Level Blueprint and
    releasing them, one at a time:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过转到蓝prints | 关卡蓝图来打开关卡蓝图。之后，通过从世界大纲拖放并释放每个新创建的对象到关卡蓝图，逐个添加对新创建对象的引用：
- en: '![](img/266bfc76-5685-4a63-872c-59b39aea216a.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/266bfc76-5685-4a63-872c-59b39aea216a.png)'
- en: 'Afterward, call `Die (Interface Call)` on each reference:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，对每个引用调用`Die (Interface Call)`：
- en: '![](img/48189563-55b8-4d89-9964-44ff7b73676d.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/48189563-55b8-4d89-9964-44ff7b73676d.png)'
- en: 'Connect the execution pins of the two message calls, then wire it up to `Event
    BeginPlay`. Run the game, and then verify that the `Zombie` is disdainful of your
    efforts to kill it, but the `Snail` groans and then dies (it is removed from the
    world outliner):'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接两个消息调用的执行引脚，并将其连接到`Event BeginPlay`。运行游戏，然后验证`Zombie`对你的杀戮努力感到不屑，而`Snail`则会呻吟然后死亡（它将从世界大纲中移除）：
- en: '![](img/64dc17b9-ed35-4104-bfec-cd739c40da78.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/64dc17b9-ed35-4104-bfec-cd739c40da78.jpg)'
- en: How it works...
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To make it possible to test this recipe in the Level Blueprint, we need to make
    the interface functions callable via Blueprint, so we need the `BlueprintCallable`
    specifier on our `UFUNCTION`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使Level Blueprint能够测试这个配方，我们需要使接口函数可以通过Blueprint调用，因此我们需要在`UFUNCTION`上使用`BlueprintCallable`指定符。
- en: However, in a `UInterface`, the compiler expects the interface to be implementable
    via both C++ and Blueprint by default. This conflicts with `BlueprintCallable`,
    which is merely saying that the function can be invoked from Blueprint, not that
    it can be overridden in it.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在`UInterface`中，编译器默认期望接口可以通过C++和Blueprint两种方式实现。这与`BlueprintCallable`相冲突，后者仅仅表示函数可以从Blueprint中调用，并不意味着可以在其中重写它。
- en: We can resolve this conflict by marking the interface as `CannotImplementInterfaceInBlueprint`.
    This enables the use of `BlueprintCallable` as our `UFUNCTION` specifier, rather
    than `BlueprintImplementableEvent` (which has extra overhead due to the extra
    code allowing for the function to be overridden via Blueprint).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将接口标记为`CannotImplementInterfaceInBlueprint`来解决这个冲突。这使我们可以使用`BlueprintCallable`作为我们的`UFUNCTION`指定符，而不是`BlueprintImplementableEvent`（它由于额外的代码允许通过Blueprint重写函数而具有额外的开销）。
- en: We define `IsDead` and `Die` as `virtual` to allow them to be overridden in
    another C++ class that inherits this one. In our default interface implementation,
    `IsDead` always returns `false`. The default implementation of `Die` prints a
    death message to the screen, and then destroys the object implementing this interface
    if it is an `Actor`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`IsDead`和`Die`定义为`virtual`，以便它们可以在继承自这个类的另一个C++类中被重写。在我们的默认接口实现中，`IsDead`始终返回`false`。`Die`的默认实现会在屏幕上打印一条死亡消息，然后如果实现此接口的是`Actor`，则销毁该对象。
- en: We can now create a second interface called `Undead`, which inherits from `Killable`.
    We use `public UKillable`/`public IKillable` in the class declarations to express
    this.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个名为`Undead`的第二个接口，它继承自`Killable`。我们在类声明中使用`public UKillable`/`public
    IKillable`来表示这一点。
- en: Of course, as a result, we need to include the header file that defines the
    `Killable` interface. Our new interface overrides the two functions that `Killable`
    defines to provide more appropriate definitions of `IsDead`/`Die` for `Undead`.
    Our overridden definitions have `Undead` already dead by returning `true` from
    `IsDead`. When `Die` is called on `Undead`, we simply print a message with `Undead`
    laughing at our feeble attempt to kill it again, and do nothing.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，作为结果，我们需要包含定义`Killable`接口的头文件。我们的新接口覆盖了`Killable`定义的两个函数，为Undead提供了更合适的`IsDead`/`Die`定义。我们覆盖的定义在`IsDead`中返回`true`，使Undead已经死亡。当对`Undead`调用`Die`时，我们只是打印一条消息，其中Undead嘲笑我们再次试图杀死它的无力尝试，并且不采取任何行动。
- en: We can also specify default implementations for our Undead-specific functions,
    namely `Turn()` and `Banish()`. When the `Undead` are Turned, they flee, and for
    demonstration purposes, we print a message to the screen. If an `Undead` is Banished,
    however, they are annihilated and destroyed without a trace.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以为我们的Undead特定函数指定默认实现，即`Turn()`和`Banish()`。当Undead被Turn时，他们会逃跑，为了演示目的，我们在屏幕上打印一条消息。然而，如果一个Undead被Banished，他们将被消灭并消失无踪。
- en: To test our implementation, we create two `Actors` that each inherit from one
    of the two interfaces. After we add an instance of each actor to our level, we
    use the Level Blueprint to access the level's `BeginPlay` event. When the level
    begins to play, we use a message call to try and call the `Die` function on our
    instances.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的实现，我们创建了两个`Actors`，每个`Actors`都继承自这两个接口之一。在我们将每个演员实例添加到我们的关卡中后，我们使用Level
    Blueprint来访问关卡中的`BeginPlay`事件。当关卡开始播放时，我们使用消息调用尝试在我们的实例上调用`Die`函数。
- en: The messages that print out are different and correspond to the two function
    implementations, showing that the Zombie's implementation of `Die` is different, and
    has overridden the Snail's.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 打印出来的消息不同，对应于两个函数实现，这表明僵尸对`Die`的实现不同，并覆盖了蜗牛的实现。
- en: Overriding UInterface functions in C++
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C++中覆盖UInterface函数
- en: One side-effect of UInterfaces allowing inheritance in C++ is that we can override
    default implementations in subclasses as well as in Blueprint. This recipe shows
    you how to do so.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: UInterfaces允许在C++中继承的一个副作用是，我们可以在子类以及Blueprint中重写默认实现。这个配方将向您展示如何做到这一点。
- en: Getting ready
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Follow the *Calling native UInterface functions from C++* recipe in which a
    Physics Cube has already been created so that you have the class ready.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 按照在C++中调用原生UInterface函数的配方进行操作，其中已经创建了一个物理立方体，以便您有准备好的类。
- en: How to do it...
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a new Interface called `Selectable`:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Selectable` 的新接口：
- en: '![](img/cf51461a-92cc-42bb-b53b-83914ce680dd.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cf51461a-92cc-42bb-b53b-83914ce680dd.png)'
- en: 'Define the following functions inside `ISelectable`:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ISelectable` 内部定义以下函数：
- en: '[PRE31]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Provide a default implementation for the functions, like so:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为函数提供默认实现，如下所示：
- en: '[PRE32]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Create a class based on `APhysicsCube` by right-clicking on the Physics Cube
    script from the Content Browser and selecting Create C++ class derived from PhysicsCube:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在内容浏览器中右键单击物理立方体脚本并选择从 `PhysicsCube` 创建派生自 `PhysicsCube` 的 C++ 类来创建一个基于 `APhysicsCube`
    的类：
- en: '![](img/705a33b1-bc34-4cab-83ef-5eb9f2f739c2.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/705a33b1-bc34-4cab-83ef-5eb9f2f739c2.png)'
- en: 'Once you''re done, change the Name of the new cube to `SelectableCube` and
    click on the Create Class option:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，将新立方体的名称更改为 `SelectableCube` 并单击创建类选项：
- en: '![](img/76752a9d-e70c-4fae-a2e7-faa8ab5cb57b.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/76752a9d-e70c-4fae-a2e7-faa8ab5cb57b.png)'
- en: Add `#include "Selectable.h"` inside the `SelectableCube` class' header.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SelectableCube` 类的头文件中添加 `#include "Selectable.h"`。
- en: 'Modify the `ASelectableCube` declaration, like so:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `ASelectableCube` 的声明，如下所示：
- en: '[PRE33]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Add the following functions to the header:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在头文件中添加以下函数：
- en: '[PRE34]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Implement the functions:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现函数：
- en: '[PRE35]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Create a new class called `NonSelectableCube`, which inherits from `SelectableCube`,
    in the same manner that we did with the `Physics Cube` to create the `SelectableCube`
    class:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以与创建 `SelectableCube` 类相同的方式，在相同的位置创建一个名为 `NonSelectableCube` 的新类，它继承自 `SelectableCube`：
- en: '![](img/604d9703-5f99-44c1-8cea-36ab7a22d846.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](img/604d9703-5f99-44c1-8cea-36ab7a22d846.png)'
- en: '`NonSelectableCube` should override the functions from `SelectableInterface`:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`NonSelectableCube` 应该覆盖 `SelectableInterface` 中的函数：'
- en: '[PRE36]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The implementation file should be altered to include the following:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现文件应修改为包含以下内容：
- en: '[PRE37]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Place an instance of `SelectableCube` into the level at a certain range above
    the ground, and then play your game. You should get messages verifying that the
    actor is selectable, and that it has accepted the selection when the cube hits
    the ground:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在地面上方一定范围内放置一个 `SelectableCube` 的实例，然后玩游戏。你应该收到确认消息，表明演员是可选择的，并且在立方体触地时已接受选择：
- en: '![](img/d514b9e7-96d1-4b54-963e-3a1f72546c67.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d514b9e7-96d1-4b54-963e-3a1f72546c67.jpg)'
- en: Remove `SelectableCube` and replace it with an instance of `NonSelectableCube`
    to see the alternative messages indicating that this actor isn't selectable and
    has refused selection.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除 `SelectableCube` 并用 `NonSelectableCube` 的实例替换它，以查看表示此演员不可选择且已拒绝选择的替代消息。
- en: How it works...
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We create three functions inside the `Selectable` interface. `IsSelectable`
    returns a Boolean to indicate whether the object is selectable. You could avoid
    this and simply use `TrySelect`, given that it returns a Boolean value to indicate
    success, but, for example, you might want to know if the object inside your UI
    is a valid selection without having to actually try it.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `Selectable` 接口中创建了三个函数。`IsSelectable` 返回一个布尔值，表示对象是否可选择。你可以避免使用它，直接使用 `TrySelect`，因为
    `TrySelect` 返回一个布尔值以指示成功，但例如，你可能想知道你的 UI 中的对象是否是一个有效的选择，而无需实际尝试它。
- en: '`TrySelect` actually attempts to select the object. There''s no explicit contract
    forcing users to respect `IsSelectable` when trying to select the object, so `TrySelect`
    is named to communicates that the selection may not always succeed.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`TrySelect` 实际上尝试选择对象。没有显式的契约强制用户在尝试选择对象时遵守 `IsSelectable`，因此 `TrySelect` 被命名为以传达选择可能不会总是成功。'
- en: Lastly, `Deselect` is a function that's added to allow objects to handle losing
    the player selection. This could involve changing the UI elements, halting sounds
    or other visual effects, or simply removing a selection outline from around the
    unit.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Deselect` 是一个函数，它被添加以允许对象处理失去玩家选择的情况。这可能涉及更改 UI 元素、停止声音或其他视觉效果，或者简单地从单位周围移除选择轮廓。
- en: The default implementations of the functions return `true` for `IsSelectable`
    (the default is for any object to be selectable), `true` for `TrySelect` (selection
    attempts always succeed), and issue a debug assert if `Deselect` is called without
    being implemented by the class.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的默认实现返回 `true` 对于 `IsSelectable`（默认情况下任何对象都是可选择的），对于 `TrySelect`（选择尝试总是成功），如果调用
    `Deselect` 而没有由类实现，则发出调试断言。
- en: You could also implement `Deselect` as a pure `virtual` function if you wish.
    `SelectableCube` is a new class inheriting from `PhysicsCube`, but also implementing
    the `ISelectable` interface. It also overrides `NotifyHit`, a `virtual` function
    defined in `AActor` that triggers when the actor undergoes a **RigidBody** collision.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想，你也可以将 `Deselect` 实现为一个纯 `virtual` 函数。`SelectableCube` 是一个从 `PhysicsCube`
    继承的新类，同时也实现了 `ISelectable` 接口。它还覆盖了 `NotifyHit`，这是一个在 `AActor` 中定义的 `virtual`
    函数，当演员发生 **RigidBody** 碰撞时触发。
- en: We call the constructor from `PhysicsCube` with the `Super()` constructor call
    inside the implementation of `SelectableCube`. We then add our own implementation,
    which calls `SetNotifyRigidBodyCollision(true)` on our static mesh instance. This
    is necessary, because by default, `RigidBodies` (such as `PrimitiveComponents`
    with a collision) don't trigger `Hit` events as a performance optimization. As
    a result, our overridden `NotifyHit` function would never be called.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `SelectableCube` 的实现中调用 `PhysicsCube` 的构造函数，并在其中使用 `Super()` 构造函数调用。然后我们添加自己的实现，它在我们静态网格实例上调用
    `SetNotifyRigidBodyCollision(true)`。这是必要的，因为默认情况下，`RigidBodies`（例如具有碰撞的 `PrimitiveComponents`）不会触发
    `Hit` 事件，作为性能优化。因此，我们的覆盖 `NotifyHit` 函数永远不会被调用。
- en: Within the implementation of `NotifyHit`, we call some of the `ISelectable`
    interface functions on ourselves. Given that we know we are an object that inherits
    from `ISelectable`, we don't need to cast to an `ISelectable*` to call them.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `NotifyHit` 的实现中，我们对自己调用了一些 `ISelectable` 接口函数。鉴于我们知道我们是一个继承自 `ISelectable`
    的对象，我们不需要将其转换为 `ISelectable*` 来调用它们。
- en: We check to see if the object is selectable with `IsSelectable` and, if so,
    we try to actually perform the selection using `TrySelect`. `NonSelectableCube`
    inherits from `SelectableCube`, so we can force the object to never be selectable.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查对象是否可由 `IsSelectable` 选择，如果是，我们尝试使用 `TrySelect` 实际执行选择。`NonSelectableCube`
    继承自 `SelectableCube`，因此我们可以强制对象永远不可选择。
- en: We accomplish this by overriding the `ISelectable` interface functions again.
    Within `ANonSelectableCube::IsSelectable()`, we print a message to the screen
    so that we can verify that the function is being called, and then return `false`
    to indicate that the object isn't selectable at all.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过再次覆盖 `ISelectable` 接口函数来实现这一点。在 `ANonSelectableCube::IsSelectable()` 中，我们在屏幕上打印一条消息，以便我们可以验证该函数是否被调用，然后返回
    `false` 以指示该对象根本不可选择。
- en: In case the user doesn't respect `IsSelectable()`, `ANonSelectableCube::TrySelect()`
    always returns `false` to indicate that the selection wasn't successful.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户不尊重 `IsSelectable()`，`ANonSelectableCube::TrySelect()` 总是返回 `false` 以指示选择未成功。
- en: Given that it is impossible for `NonSelectableCube` to be selected, `Deselect()`
    calls `unimplemented()`, which throws an assert warning that the function was
    not implemented.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `NonSelectableCube` 不可能被选中，`Deselect()` 调用 `unimplemented()`，这会抛出一个断言警告，表明该函数尚未实现。
- en: Now, when playing your scene, each time `SelectableCube`/`NonSelectableCube`
    hits another object, causing a RigidBody collision, the actor in question will
    attempt to select itself, and print messages to the screen.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您播放场景时，每次 `SelectableCube`/`NonSelectableCube` 与另一个对象发生碰撞，导致 RigidBody 碰撞时，相关的演员将尝试选择自己，并在屏幕上打印消息。
- en: See also
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to [Chapter 6](613bddf9-b8a6-44a4-a5ee-61d450415745.xhtml), *Input and
    Collision, and* the *Mouse UI input handling* recipe, which shows you how to **Raycast**
    from the mouse cursor into the game world to determine what is being clicked on.
    This could be used to extend this recipe to allow the player to click on items
    to select them.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅[第 6 章](613bddf9-b8a6-44a4-a5ee-61d450415745.xhtml)，*输入和碰撞*以及*鼠标 UI 输入处理*食谱，该食谱向您展示了如何从鼠标光标向游戏世界进行
    **Raycast** 以确定被点击的对象。这可以用来扩展本食谱，允许玩家点击物品以选择它们。
- en: Implementing a simple interaction system with UInterfaces
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 UInterfaces 实现简单的交互系统
- en: This recipe will show you how to combine a number of other recipes in this chapter
    to demonstrate a simple interaction system, and a door with an interactable doorbell
    to cause the door to open.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将向您展示如何结合本章中的其他多个食谱来演示一个简单的交互系统，以及一个带有可交互门铃的门，以使门打开。
- en: Getting ready...
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作...
- en: This recipe requires the use of Action bindings. If you are unfamiliar with
    creating Action mappings, please refer to [Chapter 6](613bddf9-b8a6-44a4-a5ee-61d450415745.xhtml),
    *Input and Collision*, before continuing with this recipe.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱需要使用动作绑定。如果您不熟悉创建动作映射，请在继续本食谱之前，请参阅[第 6 章](613bddf9-b8a6-44a4-a5ee-61d450415745.xhtml)，*输入和碰撞*。
- en: How to do it...
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Create a new interface called `Interactable`.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的接口，称为`Interactable`。
- en: 'Add the following functions to the `IInteractable` class declaration:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下函数添加到`IInteractable`类声明中：
- en: '[PRE38]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Create a second interface, `Openable`.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建第二个接口，`Openable`。
- en: 'Add this function to its declaration:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此函数添加到其声明中：
- en: '[PRE39]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Create a new class, based on `StaticMeshActor`, called `DoorBell`.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的基于`StaticMeshActor`的类，称为`DoorBell`。
- en: 'Add `#include "Interactable.h"` in `DoorBell.h`, and add the following functions
    to the class declaration:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DoorBell.h`中添加`#include "Interactable.h"`，并将以下函数添加到类声明中：
- en: '[PRE40]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the `.cpp` file for `DoorBell`, add `#include "Openable.h"`.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DoorBell.cpp`文件中添加`#include "Openable.h"`。
- en: 'Load a static mesh for our `DoorBell` in the constructor:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中为我们的`DoorBell`加载一个静态网格：
- en: '[PRE41]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Add the following function implementations to implement the `Interactable`
    interface on our `DoorBell`:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下函数实现添加到实现`Interactable`接口的`DoorBell`中：
- en: '[PRE42]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now create a new StaticMeshActor-based class called `Door`.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建一个基于`StaticMeshActor`的新类，称为`Door`。
- en: '`#include` the `Openable` and `Interactable` interfaces into the class header,
    and then modify Door''s declaration:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类头文件中包含`Openable`和`Interactable`接口，然后修改`Door`的声明：
- en: '[PRE43]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Add interface functions and a constructor to `Door`:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Door`中添加接口函数和构造函数：
- en: '[PRE44]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'As with `DoorBell`, in the `Door` constructor, initialize our mesh component
    and load a model in it:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与`DoorBell`一样，在`Door`的构造函数中，初始化我们的网格组件并在其中加载一个模型：
- en: '[PRE45]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Implement interface functions:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现接口函数：
- en: '[PRE46]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Create a new DefaultPawn-based class called `InteractingPawn`:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个基于`DefaultPawn`的新类，称为`InteractingPawn`：
- en: '![](img/7461c8ae-8fcd-4088-9b81-11ef24f01cad.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7461c8ae-8fcd-4088-9b81-11ef24f01cad.png)'
- en: 'Add the following functions to the `Pawn` class header:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下函数添加到`Pawn`类头文件中：
- en: '[PRE47]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Inside the implementation file for the `Pawn`, add `#include "Interactable.h"`,
    and then provide implementations for both functions from the header:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Pawn`的实现文件中添加`#include "Interactable.h"`，然后提供头文件中两个函数的实现：
- en: '[PRE48]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Now, create a new `GameMode` in either C++ or Blueprint, and set `InteractingPawn`
    as our default `Pawn` class.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在C++或蓝图中创建一个新的`GameMode`，并将`InteractingPawn`设置为我们的默认`Pawn`类。
- en: '![](img/69d62766-4048-48e4-9aeb-2f953a73ba43.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/69d62766-4048-48e4-9aeb-2f953a73ba43.png)'
- en: 'Drag a copy of both `Door` and `Doorbell` into the level:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Door`和`Doorbell`的副本拖入级别中：
- en: '![](img/7942f20f-0d64-45fd-9d08-35eac82a5dd1.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7942f20f-0d64-45fd-9d08-35eac82a5dd1.png)'
- en: 'Use the eyedropper beside doorbell''s Door to Open, as shown in the following
    screenshot, then click on the door actor instance in your level:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用门铃的“打开门”旁边的吸管工具，如图所示，然后点击你级别中的门演员实例：
- en: '![](img/9423df93-c5d2-4666-bf2c-1a97fef82dc0.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9423df93-c5d2-4666-bf2c-1a97fef82dc0.jpg)'
- en: 'Once you select the actor, you should see something similar to the following:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你选择了演员，你应该会看到以下类似的内容：
- en: '![](img/e2c5d6d5-100e-42b4-87fa-9225736a8849.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e2c5d6d5-100e-42b4-87fa-9225736a8849.jpg)'
- en: 'Create a new Action binding in the editor called `Interact` and bind it to
    a key of your choice:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中创建一个新的动作绑定，称为`Interact`，并将其绑定到您选择的键：
- en: '![](img/3e619bc5-fa62-4306-a5b7-44f79c468adc.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3e619bc5-fa62-4306-a5b7-44f79c468adc.jpg)'
- en: 'Play your level and walk up to the doorbell. Look at it, and press whatever
    key you bound `Interact` with. Verify that the door moves once. Refer to the following
    screenshot:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放你的级别，走到门铃前。看看它，并按你绑定的`Interact`键。验证门移动了一次。参见图示：
- en: '![](img/3d3015cb-4993-4264-a6aa-5cfa33f45a0a.png)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3d3015cb-4993-4264-a6aa-5cfa33f45a0a.png)'
- en: 'You can also interact with the door directly to receive some information about
    it:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你也可以直接与门进行交互，以获取一些关于它的信息：
- en: '![](img/c417b020-3dc8-450b-8f4f-d185d61d75a1.png)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c417b020-3dc8-450b-8f4f-d185d61d75a1.png)'
- en: How it works...
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As in previous recipes, we mark `UFUNCTION` as `BlueprintNativeEvent` and `BlueprintCallable` to
    allow the `UInterface` to be implemented in either native code or Blueprint, and
    allow the functions to be called with either method.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的食谱一样，我们将`UFUNCTION`标记为`BlueprintNativeEvent`和`BlueprintCallable`，以允许在本地代码或蓝图实现`UInterface`，并允许使用任一方法调用函数。
- en: We create `DoorBell` based on `StaticMeshActor` for convenience, and have `DoorBell`
    implement the `Interactable` interface. Inside the constructor for `DoorBell`,
    we initialize `HasBeenPushed` and `DoorToOpen` to the default safe values.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基于`StaticMeshActor`创建`DoorBell`以方便起见，并让`DoorBell`实现`Interactable`接口。在`DoorBell`的构造函数中，我们将`HasBeenPushed`和`DoorToOpen`初始化为默认的安全值。
- en: Within the implementation for `CanInteract`, we return the inverse of `HasBeenPushed`
    so that once the button has been pushed, it can't be interacted with.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CanInteract`的实现中，我们返回`HasBeenPushed`的逆值，这样一旦按钮被按下，就不能再与之互动。
- en: Inside `PerformInteract`, we check if we have a reference to a door object to
    open. If we have a valid reference, we verify that the door actor implements `Openable`,
    and then we invoke the `Open` function on our door. Within `Door`, we implement
    both `Interactable` and `Openable`, and override the functions from each.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PerformInteract`内部，我们检查是否有打开门的物体对象的引用。如果我们有一个有效的引用，我们验证门actor是否实现了`Openable`接口，然后在我们的大门上调用`Open`函数。在`Door`中，我们实现了`Interactable`和`Openable`接口，并覆盖了每个接口的函数。
- en: We define the `Door` implementation of `CanInteract` to be the same as the default.
    Within `PerformInteract`, we display a message to the user. Inside `Open`, we
    use `AddActorLocalOffset` to move the door a certain distance away. With Timeline
    in Blueprint or a linear interpolation, we could make this transition smooth rather
    than a teleport.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义`Door`的`CanInteract`实现与默认值相同。在`PerformInteract`中，我们向用户显示一条消息。在`Open`中，我们使用`AddActorLocalOffset`将门移动一定的距离。通过蓝图中的Timeline或线性插值，我们可以使这个过渡更加平滑，而不是瞬移。
- en: Lastly, we create a new `Pawn` so that the player can actually interact with
    objects. We create a `TryInteract` function, which we bind to the `Interact` input
    action in the overridden `SetupPlayerInputComponent` function.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建一个新的`Pawn`，以便玩家能够真正地与物体互动。我们创建了一个`TryInteract`函数，并将其绑定到在重写的`SetupPlayerInputComponent`函数中的`Interact`输入动作。
- en: This means that when the player performs the input that is bound to `Interact`,
    our `TryInteract` function will run. `TryInteract` gets a reference to `PlayerController`,
    casting the generic controller reference that all Pawns have.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当玩家执行绑定到`Interact`的输入时，我们的`TryInteract`函数将会运行。`TryInteract`获取对`PlayerController`的引用，将所有Pawn都具有的通用控制器引用进行类型转换。
- en: '`PlayerCameraManager` is retrieved through `PlayerController`, so we can access
    the current location and rotation of the player camera. We create start and end
    points using the camera''s location, then 100 units in the forward direction away
    from the camera''s location, and pass those into `GetWorld::SweepSingleByObjectType`.
    This function takes in a number of parameters. `HitResult` is a variable that
    allows the function to return information about any object hit by the trace. `CollisionObjectQueryParams`
    allows us to specify whether we are interested in dynamic, static items, or both.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`PlayerController`获取`PlayerCameraManager`，这样我们就可以访问玩家摄像机的当前位置和旋转。我们使用摄像机的位置创建起点和终点，然后在摄像机位置前方100单位处，将这些传递给`GetWorld::SweepSingleByObjectType`。这个函数接受多个参数。`HitResult`是一个变量，允许函数返回关于被追踪的任何物体的信息。`CollisionObjectQueryParams`允许我们指定我们是否对动态、静态物品或两者都感兴趣。
- en: We accomplish a sphere trace by passing the shape in using the `MakeSphere`
    function. Sphere traces allow for slightly more human error by defining a cylinder
    to check for objects rather than a straight line. Given that the players might
    not look directly at your object, you can tweak the sphere's radius as appropriate.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用`MakeSphere`函数传递形状来实现球体追踪。球体追踪允许有轻微的人为错误，因为它定义了一个圆柱来检查物体，而不是直线。鉴于玩家可能不会直接看向你的物体，你可以根据需要调整球体的半径。
- en: The final parameter, `SweepSingleByObjectType`, is a struct that gives the trace
    a name, lets us specify whether we are colliding against a complex collision geometry,
    and most importantly, allows us to specify that we want to ignore the object that
    is initiating the trace.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个参数`SweepSingleByObjectType`是一个结构体，它为追踪赋予一个名称，允许我们指定我们是否在碰撞复杂的碰撞几何体，并且最重要的是，允许我们指定我们想要忽略触发追踪的对象。
- en: If `HitResult` contains an actor after the trace is done, we check whether the
    actor implements our interface, then attempt to call `CanInteract` on it. If the
    actor indicates yes, it can be interacted with, so we then tell it to actually
    perform the interaction.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在追踪完成后`HitResult`包含一个actor，我们检查该actor是否实现了我们的接口，然后尝试调用其上的`CanInteract`。如果actor表示可以互动，那么我们就告诉它实际执行互动。
