["```cpp\n\"Response\\n\"\n```", "```cpp\n#include <boost/asio.hpp>\n\n#include <thread>\n#include <atomic>\n#include <memory>\n#include <iostream>\n\nusing namespace boost;\n\nclass Service {\npublic:\n  Service(){}\n\n  void HandleClient(asio::ip::tcp::socket& sock) {\n    try {\n      asio::streambuf request;\n      asio::read_until(sock, request, '\\n');\n\n      // Emulate request processing.\n      inti = 0;\n      while (i != 1000000)\n        i++;\n        std::this_thread::sleep_for(\nstd::chrono::milliseconds(500));\n\n      // Sending response.\n      std::string response = \"Response\\n\";\n      asio::write(sock, asio::buffer(response));\n}\n    catch (system::system_error&e) {\n      std::cout  << \"Error occured! Error code = \" \n<<e.code() << \". Message: \"\n          <<e.what();\n    }\n  }\n};\n```", "```cpp\nclass Acceptor {\npublic:\n  Acceptor(asio::io_service&ios, unsigned short port_num) :\n    m_ios(ios),\n    m_acceptor(m_ios,\n        asio::ip::tcp::endpoint(\n              asio::ip::address_v4::any(),\n              port_num))\n  {\n    m_acceptor.listen();\n  }\n\n  void Accept() {\n    asio::ip::tcp::socket sock(m_ios);\n\n    m_acceptor.accept(sock);\n\n    Service svc;\n    svc.HandleClient(sock);\n  }\n\nprivate:\n  asio::io_service&m_ios;\n  asio::ip::tcp::acceptor m_acceptor;\n};\n```", "```cpp\nclass Server {\npublic:\n  Server() : m_stop(false) {}\n\n  void Start(unsigned short port_num) {\n    m_thread.reset(new std::thread([this, port_num]() {\n      Run(port_num);\n    }));\n  }\n\n  void Stop() {\n    m_stop.store(true);\n    m_thread->join();\n  }\n\nprivate:\n  void Run(unsigned short port_num) {\n    Acceptor acc(m_ios, port_num);\n\n    while (!m_stop.load()) {\n      acc.Accept();\n    }\n  }\n\n  std::unique_ptr<std::thread>m_thread;\n  std::atomic<bool>m_stop;\n  asio::io_servicem_ios;\n};\n```", "```cpp\nint main()\n{\n  unsigned short port_num = 3333;\n\n  try {\n    Server srv;\n    srv.Start(port_num);\n\n    std::this_thread::sleep_for(std::chrono::seconds(60));\n\n    srv.Stop();\n  }\n  catch (system::system_error&e) {\n        std::cout  << \"Error occured! Error code = \" \n                   <<e.code() << \". Message: \"\n                   <<e.what();\n  }\n\n  return 0;\n}\n```", "```cpp\n#include <boost/asio.hpp>\n\n#include <thread>\n#include <atomic>\n#include <memory>\n#include <iostream>\n\nusing namespace boost;\n\nclass Service {\npublic:\n   Service(){}\n\n   void StartHandligClient(\n         std::shared_ptr<asio::ip::tcp::socket> sock) {\n\n      std::thread th(([this, sock]() {\n         HandleClient(sock);\n      }));\n\n      th.detach();\n   }\n\nprivate: \nvoid HandleClient(std::shared_ptr<asio::ip::tcp::socket> sock) {\n      try {\n         asio::streambuf request;\n         asio::read_until(*sock.get(), request, '\\n');\n\n         // Emulate request processing.\n         int i = 0;\n         while (i != 1000000)\n            i++;\n\n            std::this_thread::sleep_for(\nstd::chrono::milliseconds(500));\n\n         // Sending response.\n         std::string response = \"Response\\n\";\n         asio::write(*sock.get(), asio::buffer(response));\n      } \n      catch (system::system_error &e) {\n         std::cout    << \"Error occured! Error code = \" \n<< e.code() << \". Message: \"\n               << e.what();\n      }\n\n      // Clean-up.\n      delete this;\n   }\n};\n```", "```cpp\nclass Acceptor {\npublic:\n   Acceptor(asio::io_service& ios, unsigned short port_num) :\n      m_ios(ios),\n      m_acceptor(m_ios,\n          asio::ip::tcp::endpoint(\nasio::ip::address_v4::any(), \nport_num))\n   {\n      m_acceptor.listen();\n   }\n\n   void Accept() {\n      std::shared_ptr<asio::ip::tcp::socket> \nsock(new asio::ip::tcp::socket(m_ios));\n\n      m_acceptor.accept(*sock.get());\n\n      (new Service)->StartHandligClient(sock);\n   }\n\nprivate:\n   asio::io_service& m_ios;\n   asio::ip::tcp::acceptor m_acceptor;\n};\n```", "```cpp\nclass Server {\npublic:\n  Server() : m_stop(false) {}\n\n  void Start(unsigned short port_num) {\n    m_thread.reset(new std::thread([this, port_num]() {\n      Run(port_num);\n    }));\n  }\n\n  void Stop() {\n    m_stop.store(true);\n    m_thread->join();\n  }\n\nprivate:\n  void Run(unsigned short port_num) {\n    Acceptor acc(m_ios, port_num);\n\n    while (!m_stop.load()) {\n      acc.Accept();\n    }\n  }\n\n  std::unique_ptr<std::thread>m_thread;\n  std::atomic<bool>m_stop;\n  asio::io_servicem_ios;\n};\n```", "```cpp\nint main()\n{\n   unsigned short port_num = 3333;\n\n   try {\n      Server srv;\n      srv.Start(port_num);\n\n      std::this_thread::sleep_for(std::chrono::seconds(60));\n\n      srv.Stop();\n   }\n   catch (system::system_error &e) {\n      std::cout    << \"Error occured! Error code = \" \n<< e.code() << \". Message: \"\n            << e.what();\n   }\n\n   return 0;\n}\n```", "```cpp\n#include <boost/asio.hpp>\n\n#include <thread>\n#include <atomic>\n#include <memory>\n#include <iostream>\n\nusing namespace boost;\n\nclass Service {\npublic:\n   Service(std::shared_ptr<asio::ip::tcp::socket> sock) :\n      m_sock(sock)\n   {}\n\n   void StartHandling() {\n\n      asio::async_read_until(*m_sock.get(), \n            m_request, \n            '\\n', \n            [this](\n                        const boost::system::error_code& ec,\n                        std::size_t bytes_transferred) \n                        {                  \n                              onRequestReceived(ec,\n                               bytes_transferred);\n               });\n   }\n\nprivate:\n   void onRequestReceived(const boost::system::error_code& ec,\n                std::size_t bytes_transferred) {\n      if (ec != 0) {\n         std::cout << \"Error occured! Error code = \"\n            << ec.value()\n            << \". Message: \" << ec.message();\n\n         onFinish();\n                return;\n      }\n\n// Process the request.\n      m_response = ProcessRequest(m_request);\n\n      // Initiate asynchronous write operation.\n      asio::async_write(*m_sock.get(), \n            asio::buffer(m_response),\n            [this](\n                            const boost::system::error_code& ec,\n                            std::size_t bytes_transferred) \n                            {\n                  onResponseSent(ec,\n                                  bytes_transferred);\n               });\n   }\n\n   void onResponseSent(const boost::system::error_code& ec,\n                      std::size_t bytes_transferred) {\n      if (ec != 0) {\n         std::cout << \"Error occured! Error code = \"\n            << ec.value()\n            << \". Message: \" << ec.message();\n      }\n\n      onFinish();\n   }\n\n   // Here we perform the cleanup.\n   void onFinish() {\n      delete this;\n   }\n\n   std::string ProcessRequest(asio::streambuf& request) {\n\n      // In this method we parse the request, process it\n      // and prepare the request.\n\n      // Emulate CPU-consuming operations.\n      int i = 0;\n      while (i != 1000000)\n         i++;\n\n      // Emulate operations that block the thread\n// (e.g. synch I/O operations).\n         std::this_thread::sleep_for(\n                      std::chrono::milliseconds(100));\n\n      // Prepare and return the response message. \n      std::string response = \"Response\\n\";\n      return response;\n   }\n\nprivate:\n   std::shared_ptr<asio::ip::tcp::socket> m_sock;\n   std::string m_response;\n   asio::streambuf m_request;\n};\n```", "```cpp\nclass Acceptor {\npublic:\n  Acceptor(asio::io_service&ios, unsigned short port_num) :\n    m_ios(ios),\n    m_acceptor(m_ios,\n      asio::ip::tcp::endpoint(\n                  asio::ip::address_v4::any(), \n                  port_num)),\n    m_isStopped(false)\n  {}\n\n  // Start accepting incoming connection requests.\n  void Start() {\n    m_acceptor.listen();\n    InitAccept();\n  }\n\n  // Stop accepting incoming connection requests.\n  void Stop() {\n    m_isStopped.store(true);\n  }\n\nprivate:\n  void InitAccept() {\n    std::shared_ptr<asio::ip::tcp::socket>\n              sock(new asio::ip::tcp::socket(m_ios));\n\n    m_acceptor.async_accept(*sock.get(),\n      [this, sock](\n                   const boost::system::error_code& error) \n           {\n        onAccept(error, sock);\n      });\n  }\n\n  void onAccept(const boost::system::error_code&ec,\n               std::shared_ptr<asio::ip::tcp::socket> sock) \n  {\n    if (ec == 0) {\n      (new Service(sock))->StartHandling();\n    }\n    else {\n      std::cout<< \"Error occured! Error code = \"\n        <<ec.value()\n        << \". Message: \" <<ec.message();\n    }\n\n    // Init next async accept operation if\n    // acceptor has not been stopped yet.\n    if (!m_isStopped.load()) {\n      InitAccept();\n    }\n    else {\n      // Stop accepting incoming connections\n      // and free allocated resources.\n      m_acceptor.close();\n    }\n  }\n\nprivate:\n  asio::io_service&m_ios;\n  asio::ip::tcp::acceptor m_acceptor;\n  std::atomic<bool>m_isStopped;\n}; \n```", "```cpp\nclass Server {\npublic:\n   Server() {\n      m_work.reset(new asio::io_service::work(m_ios));\n   }\n\n   // Start the server.\n   void Start(unsigned short port_num, \nunsigned int thread_pool_size) {\n\n      assert(thread_pool_size > 0);\n\n      // Create and start Acceptor.\n      acc.reset(new Acceptor(m_ios, port_num));\n      acc->Start();\n\n      // Create specified number of threads and \n      // add them to the pool.\n      for (unsigned int i = 0; i < thread_pool_size; i++) {\n         std::unique_ptr<std::thread> th(\n                   new std::thread([this]()\n                   {\n                          m_ios.run();\n                   }));\n\n         m_thread_pool.push_back(std::move(th));\n      }\n   }\n\n   // Stop the server.\n   void Stop() {\n      acc->Stop();\n      m_ios.stop();\n\n      for (auto& th : m_thread_pool) {\n         th->join();\n      }\n   }\n\nprivate:\n   asio::io_servicem_ios;\n   std::unique_ptr<asio::io_service::work>m_work;\n   std::unique_ptr<Acceptor>acc;\n   std::vector<std::unique_ptr<std::thread>>m_thread_pool;\n};\n```", "```cpp\nconst unsigned intDEFAULT_THREAD_POOL_SIZE = 2;\n\nint main()\n{\n  unsigned short port_num = 3333;\n\n  try {\n    Server srv;\n\n    unsigned intthread_pool_size =\n      std::thread::hardware_concurrency() * 2;\n\n      if (thread_pool_size == 0)\n      thread_pool_size = DEFAULT_THREAD_POOL_SIZE;\n\n    srv.Start(port_num, thread_pool_size);\n\n    std::this_thread::sleep_for(std::chrono::seconds(60));\n\n    srv.Stop();\n  }\n  catch (system::system_error&e) {\n    std::cout  << \"Error occured! Error code = \" \n               <<e.code() << \". Message: \"\n               <<e.what();\n  }\n\n  return 0;\n}\n```", "```cpp\nvoid onFinish() {\n  delete this;\n}\n```"]