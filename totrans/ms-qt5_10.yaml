- en: Chapter 10.  Need IPC? Get Your Minions to Work
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。需要IPC？让你的小兵开始工作
- en: 'In the previous chapter, you learned how to send information across threads
    of the same process. In this chapter, you will discover how to share data between
    threads of different processes. We will even share information between applications
    running on different physical computers. We will enhance the Mandelbrot generator
    application from [Chapter 9](part0090.xhtml#aid-2LQIK2 "Chapter 9.  Keeping Your
    Sanity with Multithreading"), *Keeping Your Sanity with Multithreading*. The Mandelbrot
    application will now only display results processed by the worker programs. These
    minions have only one mission: compute the tasks as fast as possible and return
    a result to your main application.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了如何在同一进程的线程之间发送信息。在本章中，你将发现如何在不同进程的线程之间共享数据。我们甚至将在不同物理计算机上运行的应用程序之间共享信息。我们将增强第9章中提到的Mandelbrot生成器应用程序，即*通过多线程保持理智*。现在，Mandelbrot应用程序将只显示由工作程序处理的结果。这些小兵只有一个任务：尽可能快地计算任务并返回结果给主应用程序。
- en: 'Here are the topics covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: How two applications can communicate together
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个应用程序如何相互通信
- en: Creating a multithreaded TCP server
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个多线程TCP服务器
- en: Reading and writing on a TCP socket
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在TCP套接字上读写
- en: Other IPC techniques like `QSharedMemory`, `QProcess`, and Qt D-Bus
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他IPC技术，如`QSharedMemory`、`QProcess`和Qt D-Bus
- en: Network serialization using `QDataStream`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`QDataStream`进行网络序列化
- en: Computer clustering
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算机集群
- en: Inter-process communication techniques
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程间通信技术
- en: An **IPC** (**inter-process communication**) is a communication between two
    or more processes. They can be instances of the same or a different application.
    The Qt framework provides multiple modules to help you implement a communication
    between your applications. Most of these modules are cross-platform. Let's talk
    about the IPC tools provided by Qt.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**IPC**（**进程间通信**）是两个或更多进程之间的通信。它们可以是同一应用或不同应用的实例。Qt框架提供了多个模块来帮助你实现应用程序之间的通信。大多数这些模块都是跨平台的。让我们来谈谈Qt提供的IPC工具。'
- en: 'The first tools are the TCP/IP sockets. They provide a bidirectional data exchange
    over a network. Therefore, you can use them to talk with processes on different
    computers. Moreover, the `loopback` interface allows you to communicate with processes
    running on the same computer. All the required classes are inside the `QtNetwork`
    module. This technique relies on a client-server architecture. Here is an example
    of the server part:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 第一工具是TCP/IP套接字。它们在网络中提供双向数据交换。因此，你可以使用它们与不同计算机上的进程通信。此外，`loopback`接口允许你与同一计算机上运行的进程通信。所有必需的类都在`QtNetwork`模块中。这种技术依赖于客户端-服务器架构。以下是一个服务器部分的示例：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The first step is to instantiate a `QTcpServer` class. It deals with the new
    incoming TCP connections. Then, we call the `listen()` function. You can provide
    a network interface and specify the port on which the server must listen for incoming
    connections. In this example, we listen on all network addresses (for example, `127.0.0.1`, `192.168.1.4`,
    and so on) on the port `5000`. When a client establishes a connection with this
    server, the `QTcpServer::newConnection()` signal is triggered. Let''s break together
    this lambda slot:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是实例化一个`QTcpServer`类。它处理新的传入TCP连接。然后，我们调用`listen()`函数。你可以提供一个网络接口并指定服务器必须监听传入连接的端口。在这个例子中，我们在端口`5000`上监听所有网络地址（例如，`127.0.0.1`、`192.168.1.4`等等）。当客户端与这个服务器建立连接时，会触发`QTcpServer::newConnection()`信号。让我们一起分析这个lambda槽：
- en: We retrieve the `QTcpSocket` class related to this new connection with a client.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用与这个新连接相关的`QTcpSocket`类来检索客户端。
- en: A `QByteArray` response is prepared with the ASCII message "Hello". Forget the
    lack of originality.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个包含ASCII消息“Hello”的`QByteArray`响应。不要在意原创性的缺乏。
- en: The message is sent to the client through the socket.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 消息通过套接字发送到客户端。
- en: Finally, we close the socket. So the client, on this side, will be disconnected.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们关闭套接字。因此，在这个客户端，将会断开连接。
- en: Tip
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can test a `QTcpServer` class with a telnet tool like Putty on Windows or
    the `telnet` command on Linux and Mac OS.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用Windows上的PuTTY或Linux和Mac OS上的`telnet`命令这样的telnet工具来测试`QTcpServer`类。
- en: 'The following snippet is the client part:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下片段是客户端部分：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The client also uses a `QTcpSocket` class to communicate. It turns out that
    the connection is initiated by the client, therefore we need to call the `connectToHost()`
    function with the server address and port. This class provides a lot of useful
    signals such as `connected()` and `disconnected()` that indicate the connection
    status. The `readyRead()` signal is emitted when new data is available for reading.
    The `readAll()`function returns `QByteArray` with all the available data. In our
    case, we know that the server sends an ASCII message to its client. Thus, we can
    convert this byte array in a `QString` and display it.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端也使用`QTcpSocket`类进行通信。结果是连接是由客户端发起的，因此我们需要使用服务器地址和端口调用`connectToHost()`函数。这个类提供了一些有用的信号，如`connected()`和`disconnected()`，它们指示连接状态。当有新数据可供读取时，会发出`readyRead()`信号。`readAll()`函数返回包含所有可用数据的`QByteArray`。在我们的例子中，我们知道服务器向其客户端发送ASCII消息。因此，我们可以将这个字节数组转换为`QString`并显示它。
- en: For this example, the server writes in the TCP socket and the client reads in
    it. But this communication is bidirectional, so the client can also write data
    and the server can read it. Try to send data from the client and display it in
    the server. Notice that you need to keep the communication alive by removing the
    `disconnectFromHost()` call in the server part.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，服务器在TCP套接字中写入，客户端读取。但是这种通信是双向的，所以客户端也可以写入数据，服务器可以读取它。尝试从客户端发送数据并在服务器上显示。请注意，您需要通过在服务器部分移除`disconnectFromHost()`调用来保持通信活跃。
- en: The Qt framework provides a helper class, `QDataStream,` to easily send a complex
    object and handle the package fragmentation. This notion will be covered later
    with the project example of this chapter.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Qt框架提供了一个辅助类`QDataStream`，可以轻松发送复杂对象并处理数据包分段。这个概念将在本章的项目示例中稍后介绍。
- en: 'Let''s talk about the second IPC technique: **shared memory**. By default,
    different processes do not use the same memory space. The `QSharedMemory` class
    provides a cross-platform method to create and use a shared memory across multiple
    processes. Nevertheless, the processes must run on the same computer. A shared
    memory is identified by a key. All the processes must use the same key to share
    the same shared memory segment. The first process will create the shared memory
    segment and put data in it:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈第二种IPC技术：**共享内存**。默认情况下，不同的进程不使用相同的内存空间。`QSharedMemory`类提供了一个跨平台的方法，可以在多个进程之间创建和使用共享内存。尽管如此，这些进程必须在同一台计算机上运行。共享内存由一个键标识。所有进程都必须使用相同的键来共享相同的共享内存段。第一个进程将创建共享内存段并将数据放入其中：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s analyze all the steps together:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一起分析所有步骤：
- en: Once again, we want to share the `QString` "Hello" converted in a `QByteArray`
    class.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，我们想要共享将`QString` "Hello"转换为`QByteArray`类。
- en: A `QSharedMemory` class is initialized with the key, `sharedMemoryKey`. This
    same key should be used by the second process.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用键`sharedMemoryKey`初始化了一个`QSharedMemory`类。第二个进程也应该使用这个相同的键。
- en: The first process creates the shared memory segment with a specific size in
    bytes. The creation also attaches the process to the shared memory segment.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个进程使用特定字节的尺寸创建共享内存段。创建过程也将进程附加到共享内存段。
- en: You should now be confident with the lock/unlock system. The `QSharedMemory`
    class uses semaphore to protect the shared access. You must lock it before manipulating
    the shared memory.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在应该对锁定/解锁系统有信心。`QSharedMemory`类使用信号量来保护共享访问。在操作共享内存之前，您必须锁定它。
- en: A classical `memcpy()` function is used to copy data from the `QByteArray` class
    to the `QSharedMemory` class.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用经典的`memcpy()`函数将数据从`QByteArray`类复制到`QSharedMemory`类。
- en: Finally, we can unlock the shared memory.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以解锁共享内存。
- en: 'Destroying a `QShareMemory` class will call the `detach()` function that detaches
    the process from the shared memory segment. If this process was the last one attached, `detach()`
    also destroys the shared memory segment. While an attached `QShareMemory` is alive,
    the shared memory segment is available for other processes. The next snippet describes
    how a second segment can access the shared memory:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 销毁`QShareMemory`类将调用`detach()`函数，该函数将进程从共享内存段中分离出来。如果这个进程是最后一个附加的进程，`detach()`也会销毁共享内存段。当一个附加的`QShareMemory`对象存活时，共享内存段对其他进程可用。下面的片段描述了第二个段如何访问共享内存：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here are the key steps:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是关键步骤：
- en: As with the first process, this second process initializes a `QShareMemory`
    class with the key, `sharedMemoryKey`.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与第一个进程一样，第二个进程使用键`sharedMemoryKey`初始化了一个`QShareMemory`类。
- en: Then we attach the process to the shared memory segment with the `attach()`
    function.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们使用`attach()`函数将进程附加到共享内存段。
- en: We must lock the `QShareMemory` class before accessing it.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在访问`QShareMemory`类之前，我们必须锁定它。
- en: We initialize a `QByteArray` with the null character, `\0`, with the size of
    the shared memory.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用空字符`\0`初始化一个`QByteArray`，其大小与共享内存相同。
- en: The `memcpy()` function copies the data from the `QShareMemory` to the `QByteArray`.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`memcpy()`函数将数据从`QShareMemory`复制到`QByteArray`。'
- en: We can convert the `QByteArray` in a `QString` and display our message.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以将`QByteArray`转换为`QString`并显示我们的消息。
- en: The last step is to call the `detach()`function to detach the process from the
    shared memory segment.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是调用`detach()`函数，将进程从共享内存段中分离出来。
- en: Please notice that `create()` and `attach()` functions specify by default a `QShareMemory::ReadWrite`
    access. You can also use the `QShareMemory::ReadOnly` access.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`create()`和`attach()`函数默认指定`QShareMemory::ReadWrite`访问权限。你也可以使用`QShareMemory::ReadOnly`访问权限。
- en: Tip
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can use the classes, `QBuffer` and `QDataStream` to serialize a complex
    object in or from a bytes array.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`QBuffer`和`QDataStream`类将复杂对象序列化到或从字节数组中。
- en: 'Another IPC way is to use the `QProcess` class. The main process starts an
    external application as a child process. The communication is done using the standard
    input and output devices. Let''s create a `hello` console application relying
    on the standard input and output channels:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种IPC方法是使用`QProcess`类。主进程以子进程的形式启动外部应用。通信是通过标准输入和输出设备完成的。让我们创建一个依赖于标准输入和输出通道的`hello`控制台应用：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We use the `QTextStream` class to easily work with the standards streams, `stdout`
    and `stdin`. The application prints the message `Please enter your name:`. Then
    we wait while the user types his name by calling the `readLine()` function. Finally,
    the program displays the message `Hello` and the user `name`. If you start yourself
    this console application, you must type your name on the keyboard to see the final
    hello message with your name.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`QTextStream`类轻松地处理标准流，`stdout`和`stdin`。应用打印消息`请输入你的名字:`。然后我们等待用户通过调用`readLine()`函数输入他的名字。最后，程序显示消息`Hello`和用户`name`。如果你自己启动这个控制台应用，你必须按键盘输入你的名字才能看到带有你名字的最终问候信息。
- en: 'The following snippet runs and communicates with the `hello` application. Furthermore,
    we can programmatically control the child `hello` application:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段运行并与`hello`应用进行通信。此外，我们可以通过编程方式控制子`hello`应用：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here are all the steps performed by this main application:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是主应用执行的所有步骤：
- en: We initialize a `QProcess` object that can start an external application.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们初始化一个可以启动外部应用的`QProcess`对象。
- en: The child process displays messages on the console and so writes in the standard
    output. Then, the `readyReadStandardOutput()` signal is sent. In this case, we
    print the message as debug text with the prefix `[*]` to identify that it comes
    from the child process.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 子进程在控制台上显示消息，因此写入标准输出。然后，发送`readyReadStandardOutput()`信号。在这种情况下，我们以带有前缀`[*]`的调试文本形式打印消息，以标识它来自子进程。
- en: As soon as the child process is started, the `started()` signal is sent. In
    our case, we write in the child standard input the name `Sophie` (Lenna will be
    jealous!).
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 子进程启动后，立即发送`started()`信号。在我们的例子中，我们在子进程的标准输入中写入名字`Sophie`（Lenna会嫉妒的！）。
- en: All is ready, we can start the `QProcess` class with the path to the `hello`
    console application.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一切准备就绪，我们可以使用`QProcess`类的路径启动`hello`控制台应用。
- en: 'If you start the main application you should get this result in its console:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你启动主应用，你应该在其控制台中看到以下结果：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Mission completed! The main application is a wrapper for the `hello` application.
    We receive all messages from the child process and we can send it some information
    like a specific name.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 任务完成！主要应用是对`hello`应用的包装。我们接收来自子进程的所有消息，并且可以发送一些信息，比如特定的名字。
- en: Tip
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'The `QProcess::start()` function also accepts a second variable: the command
    line arguments for the child process.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`QProcess::start()`函数还接受第二个变量：子进程的命令行参数。'
- en: 'The last IPC mechanism that we will cover together is the **D-Bus protocol**.
    Currently, the Qt D-Bus module is officially supported only on Linux. If you need
    to use it on Windows, you will have to compile it from Qt sources. It can be seen
    as a unified protocol for IPC and **RPC** (**remote procedure calling**). Many
    forms of communication are possible, such as:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要一起覆盖的最后一种IPC机制是**D-Bus协议**。目前，Qt D-Bus模块仅在Linux上官方支持。如果您需要在Windows上使用它，您将不得不从Qt源代码编译它。它可以被视为IPC和**RPC（远程过程调用**）的统一协议。可能的通信形式很多，例如：
- en: One-to-one
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对一
- en: One-to-many
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对多
- en: Many-to-many
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多对多
- en: The best thing about Qt D-Bus is that you can even use the signal/slot mechanism
    across the bus. A signal emitted from one application can be connected to a slot
    from another application. Linux desktop environments like KDE and GNOME use the
    D-Bus. That implies that you can (also) control your desktop with D-Bus.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Qt D-Bus最好的事情是您甚至可以在总线上使用信号/槽机制。一个应用程序发出的信号可以连接到另一个应用程序的槽。Linux桌面环境，如KDE和GNOME使用D-Bus。这意味着您可以用D-Bus（也）控制您的桌面。
- en: 'Here are the main concepts of D-Bus:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是D-Bus的主要概念：
- en: '`Bus`: This is used in many-to-many communication. D-Bus defines two buses:
    the **system bus** and the **session bus**.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`总线`：这在多对多通信中使用。D-Bus定义了两个总线：**系统总线**和**会话总线**。'
- en: '`Service name`: This is the identifier of a service on a bus.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`服务名称`：这是总线上服务的标识符。'
- en: '`Message`: This is a message sent by one application. If a bus is used, the
    message contains the destination.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`消息`：这是由一个应用程序发送的消息。如果使用总线，则消息包含目的地。'
- en: A Qt D-Bus Viewer tool can be found in your Qt installation folder (for example,
    `/Qt/5.7/gcc_64/bin/qdbusviewer`). All objects and messages from all services
    of the system and the session bus are displayed. Try to invoke exposed methods
    and retrieve a result.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Qt D-Bus查看器工具可以在您的Qt安装文件夹中找到（例如，`/Qt/5.7/gcc_64/bin/qdbusviewer`）。所有服务对象和消息都显示在系统总线和服务总线上。尝试调用公开的方法并检索结果。
- en: 'Now that you have messed about with your Linux D-Bus services, it is time to
    create your own! At first, we will create a simple `HelloService` object:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经玩弄了您的Linux D-Bus服务，是时候创建您自己的了！首先，我们将创建一个简单的`HelloService`对象：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'No big deal here, the only function is a public slot that requires a `name`,
    displays who is here, and returns a hello message. In the following snippet, the
    main application registers a new D-Bus service and the `HelloService` object:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没什么大不了的，只有一个需要`name`参数的公共槽，显示谁在这里，并返回一个问候消息。在下面的代码片段中，主应用注册了一个新的D-Bus服务和`HelloService`对象：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The main application initializes an `HelloService` object. Then, we register
    a new service named `org.masteringqt.QtDBus.HelloService` on the session bus.
    Finally, we register the `HelloService` object, exposing all its slots. Notice
    the simple object path `/` used for this example. The service application part
    is finished. Here is the client application calling the `HelloService` object:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 主要应用初始化一个`HelloService`对象。然后，我们在会话总线上注册了一个名为`org.masteringqt.QtDBus.HelloService`的新服务。最后，我们注册了`HelloService`对象，暴露了它所有的槽。注意这个示例中使用的简单对象路径`/`。服务应用部分完成。以下是调用`HelloService`对象的客户端应用：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s analyze the client part step by step:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步分析客户端部分：
- en: We initialize a `QDBusInterface` object with the same service name and path
    as the service application.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用与服务应用相同的服务名称和路径初始化一个`QDBusInterface`对象。
- en: We call the remote method, `sayHello()` on `HelloService`, with the parameter `Lenna`
    (Wait, where is Sophie!?).
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们调用`HelloService`上的远程方法`sayHello()`，参数为`Lenna`（等等，Sophie在哪里！？）。
- en: The response is stored in a `QDBusReply` object. In our case, type `QString`.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 响应存储在`QDBusReply`对象中。在我们的例子中，类型为`QString`。
- en: Finally, we display the message generated by the `HelloService` object.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们显示由`HelloService`对象生成的消息。
- en: 'If you start the service application and then the client application, you should
    get this console output:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您先启动服务应用，然后启动客户端应用，您应该得到以下控制台输出：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Use the `QDBusViewer` tool to find your D-Bus service. Select the **Session
    Bus** tab. Choose your service in the list. Then you can select the method `sayHello`.
    A right-click on it allows you to call the method. An input popup will ask you
    to fill the method parameter that is a name in our example. The following screenshot
    shows you what it looks like (it seems that Sophie is here):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`QDBusViewer`工具查找您的D-Bus服务。选择**会话总线**选项卡。在列表中选择您的服务。然后您可以选择`sayHello`方法。右键单击它允许您调用该方法。一个输入弹出窗口会要求您填写方法参数，在我们的例子中是一个名字。以下截图显示了它的样子（看起来Sophie在这里）：
- en: '![Need IPC? Get Your Minions to Work](img/image00432.jpeg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![需要 IPC？让你的小弟们开始工作](img/image00432.jpeg)'
- en: Architecturing an IPC project
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构化 IPC 项目
- en: The Mandelbrot picture generator from [Chapter 9](part0090.xhtml#aid-2LQIK2
    "Chapter 9.  Keeping Your Sanity with Multithreading"), *Keeping Your Sanity with
    Multithreading*, uses all cores of your computer to speed up the computing. This
    time, we want to use all the cores of all your computers! The first thing to do
    is to choose an appropriated IPC technique. For this project example, we want
    to establish communication between several clients acting as workers to a server
    running the main application. The TCP/IP sockets allows a one-to-many communication.
    Moreover, this IPC method is not bounded to a single computer and can operate
    through a network on multiple computers. This project example uses sockets by
    implementing a multi-threaded TCP server.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 来自第 9 章 [“保持你的理智：多线程”](part0090.xhtml#aid-2LQIK2 "第 9 章。保持你的理智：多线程") 的曼德布罗特图像生成器使用您计算机的所有核心来加速计算。这次，我们想要使用您所有计算机的所有核心！首先要做的事情是选择一个合适的
    IPC 技术。对于这个项目示例，我们想要在运行主应用程序的服务器与充当工作进程的多个客户端之间建立通信。TCP/IP 套接字允许一对多通信。此外，这种 IPC
    方法不受单个计算机的限制，可以通过网络在多台计算机上操作。这个项目示例通过实现多线程 TCP 服务器来使用套接字。
- en: 'The next diagram describes the architecture:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个图描述了架构：
- en: '![Architecturing an IPC project](img/image00433.jpeg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![架构化 IPC 项目](img/image00433.jpeg)'
- en: 'Let''s talk about the global role of each actor:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈每个角色的全局作用：
- en: '`mandelbrot-app`: This is the main application displaying the Mandelbrot picture
    and handling user mouse events. However, in this chapter, the application does
    not compute the algorithm itself but rather generates requests to connected workers.
    Then, it aggregates results provided by workers.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mandelbrot-app`：这是主应用程序，用于显示曼德布罗特图像和处理用户鼠标事件。然而，在本章中，应用程序本身不计算算法，而是生成连接到工作进程的请求。然后，它汇总工作进程提供的结果。'
- en: '`mandelbrot-worker`: Here is our minion! A worker is a standalone program.
    It is connecting to the `mandelbrot-app` through a TCP socket. A worker receives
    a request, computes a job, and sends back a result.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mandelbrot-worker`：这里是我们的小弟！一个工作进程是一个独立的程序。它通过 TCP 套接字连接到 `mandelbrot-app`。工作进程接收请求，计算任务，并将结果发送回去。'
- en: '`SDK`: This regroups common stuff used by both applications. If the SDK changes,
    all the dependent applications must be updated.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SDK`：它将两个应用程序共同使用的常用功能重新组合。如果 SDK 发生变化，所有依赖的应用程序都必须更新。'
- en: As you can see, this architecture fits well with the one-to-many communication
    required by this project. The `mandelbrot-app` application can use one or many
    workers to generate the same Mandelbrot picture.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这种架构很好地适应了本项目所需的一对多通信。`mandelbrot-app` 应用程序可以使用一个或多个工作进程来生成相同的曼德布罗特图像。
- en: 'Now that you get the big picture, let''s look in detail at each module. You
    can see all of the classes in the SDK in the following diagram:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了整体情况，让我们详细看看每个模块。您可以在以下图中看到 SDK 中的所有类：
- en: '![Architecturing an IPC project](img/image00434.jpeg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![架构化 IPC 项目](img/image00434.jpeg)'
- en: An SDK is essential when you have several modules (applications, libraries,
    and so on) that communicate together or need to perform the same actions. You
    can give the SDK to a third-party developer without compromising your main source
    code. In our project, `mandelbrot-app` and `mandelbrot-worker` communicate together
    by exchanging `Message`. The message structure must be known by both entities.
    A `Message` class contains a `type` and a raw `data` of the type, `QByteArray`.
    Depending on the message `type`, the raw data can be empty or can contain an object.
    In this project, a message `data` can be a `JobRequest` or a `JobResult`. The `mandelbrot-app`
    sends a `JobRequest` to `mandelbrot-worker`. Then, the worker returns `JobResult`
    to the main application. Finally, `MessageUtils` contains functions used by the
    main application and the workers to send and retrieve a `Message`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当您有多个模块（应用程序、库等）需要相互通信或执行相同操作时，SDK 是必不可少的。您可以将 SDK 交给第三方开发者，而不会损害您的主要源代码。在我们的项目中，`mandelbrot-app`
    和 `mandelbrot-worker` 通过交换 `Message` 来进行通信。消息结构必须为双方所知。`Message` 类包含一个 `type`
    和一个 `QByteArray` 类型的原始 `data`。根据消息 `type`，原始数据可以是空的，也可以包含一个对象。在这个项目中，消息 `data`
    可以是一个 `JobRequest` 或一个 `JobResult`。`mandelbrot-app` 向 `mandelbrot-worker` 发送一个
    `JobRequest`。然后，工作进程返回 `JobResult` 给主应用程序。最后，`MessageUtils` 包含主应用程序和工作进程用于发送和检索
    `Message` 的函数。
- en: 'We can now talk about the `mandelbrot-worker` in more detail. The next diagram
    describes it:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以更详细地讨论 `mandelbrot-worker`。下一个图解描述了它：
- en: '![Architecturing an IPC project](img/image00435.jpeg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![设计 IPC 项目架构](img/image00435.jpeg)'
- en: 'The `mandelbrot-worker` program is able to use all the CPU cores of a machine.
    The socket mechanism allows us to run it on multiple physical machines at the
    same time. The `WorkerWidget` class displays the status of the `Worker` object.
    The `Worker` object handles the communication with `mandelbrot-app` using a `QTcpSocket`.
    A `Job` is a `QRunnable` class that computes a task. Here is the workflow of this
    software:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`mandelbrot-worker` 程序能够使用机器的所有CPU核心。套接字机制允许我们同时运行在多个物理机器上。`WorkerWidget` 类显示
    `Worker` 对象的状态。`Worker` 对象使用 `QTcpSocket` 与 `mandelbrot-app` 进行通信。一个 `Job` 是一个计算任务的
    `QRunnable` 类。以下是该软件的工作流程：'
- en: Send a register `Message` to `mandelbrot-app` application.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `mandelbrot-app` 应用程序发送注册 `Message`。
- en: Receive some `JobRequest` from `mandelbrot-app` and create several `Job` instances
    to complete all tasks.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `mandelbrot-app` 接收一些 `JobRequest` 并创建几个 `Job` 实例以完成所有任务。
- en: Each `Job` is running in a dedicated thread and will generate a `JobResult`.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个 `Job` 都在一个专用的线程中运行，并将生成一个 `JobResult`。
- en: Send `JobResult` to `mandelbrot-app`.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `JobResult` 发送到 `mandelbrot-app`。
- en: On exit, send an unregister `Message` to `mandelbrot-app`.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在退出时，向 `mandelbrot-app` 发送注销 `Message`。
- en: 'It is now time to talk about the `mandelbrot-app` architecture. Look at the
    next diagram:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候讨论 `mandelbrot-app` 架构了。看看下一个图解：
- en: '![Architecturing an IPC project](img/image00436.jpeg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![设计 IPC 项目架构](img/image00436.jpeg)'
- en: 'This is the main application. You can launch it on a computer with a weak CPU
    and the real heavy work is done by workers running the `mandelbrot-worker` software.
    The GUI `MainWindow` and `MandelbrotWidget` objects are the same as those in [Chapter
    9](part0090.xhtml#aid-2LQIK2 "Chapter 9.  Keeping Your Sanity with Multithreading"), *Keeping
    Your Sanity with Multithreading.* The `MandelbrotCalculator` class is a little
    different in this project, because it does not run any `QRunnable` itself. It
    is a TCP server that handles all registered workers and dispatches tasks to those
    tasks. Each `mandelbrot-worker` is managed by a `WorkerClient` object instance
    with a dedicated `QTcpSocket`. Here is the workflow for `mandelbrot-app`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这是主要的应用。你可以在一个CPU性能较弱的电脑上启动它，而真正的重活是由运行`mandelbrot-worker`软件的工作者完成的。GUI `MainWindow`
    和 `MandelbrotWidget` 对象与[第9章](part0090.xhtml#aid-2LQIK2 "第9章。通过多线程保持理智")中的相同，*通过多线程保持理智*。在这个项目中，`MandelbrotCalculator`
    类略有不同，因为它本身不运行任何 `QRunnable`。它是一个TCP服务器，处理所有已注册的工作者并将任务分配给这些任务。每个 `mandelbrot-worker`
    都由一个带有专用 `QTcpSocket` 的 `WorkerClient` 对象实例管理。以下是 `mandelbrot-app` 的工作流程：
- en: Run a TCP server on a specific port.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在特定端口上运行TCP服务器。
- en: Receive a register `Message` and create a `WorkerClient` object for each registered
    worker.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接收注册 `Message` 并为每个注册的工作者创建一个 `WorkerClient` 对象。
- en: When `MandelbrotWidget` requests a picture generation,  `MandelbrotCalculator`
    creates the `JobRequest` object required to compute the full Mandelbrot picture.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 `MandelbrotWidget` 请求生成图片时，`MandelbrotCalculator` 创建计算完整曼德布罗特图片所需的 `JobRequest`
    对象。
- en: The `JobRequest` objects are sent to the workers.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `JobRequest` 对象发送给工作者。
- en: Receive and aggregate `JobResult` from the `mandelbrot-worker`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `mandelbrot-worker` 接收并汇总 `JobResult`。
- en: Transmit `JobResult` to the `MandelbrotWidget` object that displays the picture.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `JobResult` 传输到显示图片的 `MandelbrotWidget` 对象。
- en: If an unregister `Message` is received from a worker, the `WorkerClient` object
    is released and this worker will not be used for picture generation anymore.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果收到来自工作者的注销 `Message`，则释放 `WorkerClient` 对象，并且这个工作者将不再用于图片生成。
- en: You should now get a complete overview of this project architecture. We can
    begin the implementation of this project. Create a **Subdirs** project called `ch10-mandelbrot-ipc`.
    As you might guess, we now create two sub-projects: `mandelbrot-app` and `mandelbrot-worker`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该对这个项目架构有一个完整的了解。我们可以开始这个项目的实现了。创建一个名为 `ch10-mandelbrot-ipc` 的 **Subdirs**
    项目。正如你可能猜到的，我们现在创建了两个子项目：`mandelbrot-app` 和 `mandelbrot-worker`。
- en: 'The implementation in the subsequent sections follows the architecture presentation
    order:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 后续章节中的实现遵循架构展示的顺序：
- en: SDK.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SDK。
- en: '`mandelbrot-worker`.'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`mandelbrot-worker`。'
- en: '`mandelbrot-app`.'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`mandelbrot-app`。'
- en: The implementation is a step up in complexity. Do not hesitate to take a break
    and come back to this section to keep the overall architecture clear.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 实现的复杂性有所增加。不要犹豫，休息一下，然后回到这一节，以保持整体架构清晰。
- en: Laying down the foundations with an SDK
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SDK 奠定基础
- en: The first step is to implement the classes that will be shared between our application
    and the workers. To do so, we are going to rely on a custom SDK. If you need to
    refresh your memory about this technique, take a look at [Chapter 8](part0081.xhtml#aid-2D7TI2
    "Chapter 8.  Animations - Its Alive, Alive!"), *Animations-- It's Alive, Alive!*.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是实现将在我们的应用程序和工作者之间共享的类。为此，我们将依赖一个自定义 SDK。如果您需要刷新对这个技术的记忆，请查看[第 8 章](part0081.xhtml#aid-2D7TI2
    "第 8 章。动画 - 它是活生生的，活生生的！")，*动画 - 它是活生生的，活生生的！*。
- en: 'As a reminder, here is the diagram describing the SDK:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，以下是描述 SDK 的图示：
- en: '![Laying down the foundations with an SDK](img/image00437.jpeg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![使用 SDK 奠定基础](img/image00437.jpeg)'
- en: 'Let''s describe the job of each of these components:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们描述一下这些组件的职责：
- en: The `Message` component encapsulates a piece of information that is exchanged
    between the application and the worker
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Message` 组件封装了应用程序和工作者之间交换的信息'
- en: The `JobRequest` component contains the necessary information to dispatch a
    proper job to a worker
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JobRequest` 组件包含将适当工作分配给工作者的必要信息'
- en: The `JobResult` component contains the result of the Mandelbrot set calculation
    for a given line
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JobResult` 组件包含针对给定行的 Mandelbrot 集计算的输出结果'
- en: The `MessageUtils` component contains helper functions to serialize/deserialize
    data across the TCP socket
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MessageUtils` 组件包含用于在 TCP 套接字间序列化/反序列化数据的辅助函数'
- en: All these files have to be accessible from each side of our IPC mechanism (application
    and worker). Note that the SDK will contain only header files. We did it on purpose
    to simplify the SDK usage.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些文件都必须可以从我们 IPC 机制的每一侧访问（应用程序和工作者）。请注意，SDK 将仅包含头文件。我们故意这样做是为了简化 SDK 的使用。
- en: 'Let''s start with `Message` implementation in the `sdk` directory. Create a `Message.h`
    file with the following content:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `sdk` 目录中的 `Message` 实现开始。创建一个包含以下内容的 `Message.h` 文件：
- en: '[PRE11]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The first thing to note is the `enum class Type` which details all the possible
    message types:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是 `enum class Type`，它详细说明了所有可能的消息类型：
- en: '`WORKER_REGISTER`: This is the message sent by the worker when it first connects
    to the application. The content of the message is only the number of cores of
    the worker''s CPU. We will see soon why this is useful.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WORKER_REGISTER`：这是工作者首次连接到应用程序时发送的消息。消息的内容仅是工作者 CPU 的核心数。我们很快就会看到这为什么有用。'
- en: '`WORKER_UNREGISTER`: This is the message sent by the worker when it is disconnected.
    This lets the application know that it should remove this worker from its list
    and stop sending any messages to it.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WORKER_UNREGISTER`：这是工作者断开连接时发送的消息。这使应用程序知道它应该从其列表中删除此工作者并停止向其发送任何消息。'
- en: '`ALL_JOBS_ABORT`: This is the message sent by the application each time a picture
    generation is canceled. The worker is then responsible for canceling all its current
    local threads.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ALL_JOBS_ABORT`：这是应用程序在每次取消图片生成时发送的消息。然后工作者负责取消其所有当前本地线程。'
- en: '`JOB_REQUEST`: This is the message sent by the application to calculate a specific
    line of the desired picture.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JOB_REQUEST`：这是应用程序发送以计算所需图片特定行的消息。'
- en: '`JOB_RESULT`: This is the message sent by the worker with the calculated result
    from the `JOB_REQUEST` inputs.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JOB_RESULT`：这是工作者从 `JOB_REQUEST` 输入中计算出的结果发送的消息。'
- en: 'A quick word about the `enum` class type, which is a C++11 addition. It is
    a safer version of enum (some might say that it is enum as it should have been
    from the beginning):'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 简单介绍一下 `enum` 类类型，它是 C++11 的一个新增功能。它是枚举（有些人可能会说它应该是枚举）的一个更安全版本：
- en: The scope of the values is local. In this example, you can only reference an `enum`
    value with the syntax `Message::Type::WORKER_REGISTER`; no more `Message::WORKER_REGISTER`
    shortcuts. The good thing about this restriction is that you do not need to prefix `enum`
    values with a `MESSAGE_TYPE_` to be sure that the name does not conflict with
    anything else.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值的作用域是局部的。在这个例子中，你只能使用语法 `Message::Type::WORKER_REGISTER` 引用 `enum` 值；没有更多的
    `Message::WORKER_REGISTER` 快捷方式。这个限制的好处是，你不需要在 `enum` 值前加上 `MESSAGE_TYPE_` 前缀，以确保名称不会与其他任何内容冲突。
- en: There is no implicit conversion to `int`. The `enum` class acts like a real
    type, to cast an `enum` class to `int`, you have to write `static_cast<int>( Message::Type::WORKER_REGISTER)`.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有到 `int` 的隐式转换。`enum` 类表现得像一个真实类型，要将 `enum` 类转换为 `int`，你必须写 `static_cast<int>(
    Message::Type::WORKER_REGISTER)`。
- en: 'There is no forward declaration. You can specify that an `enum class` is a
    char type (with the syntax `enum class Test : char { ... }`), but the compiler
    will not be able to deduce the `enum` class size with a forward declaration. Therefore,
    it has been simply forbidden.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '没有前向声明。你可以指定一个`enum class`是char类型（语法为`enum class Test : char { ... }`），但编译器无法通过前向声明推断出`enum`类的大小。因此，它被简单地禁止了。'
- en: We tend to use the `enum` class whenever possible, meaning when it does not
    clash with Qt `enum` usage.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尽可能使用`enum`类，这意味着当它不与Qt `enum`使用冲突时。
- en: 'As you can see, a message has only two members:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，消息只有两个成员：
- en: '`type`: This is the message type we just described'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`：这是我们刚刚描述的消息类型'
- en: '`data`: This is an opaque type that contains the piece of information to be
    transmitted'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`：这是一个不透明的类型，包含要传输的信息片段'
- en: We chose to make `data` very generic to place the responsibility of serializing/deserializing
    on the `Message` callers. Based on the message `type`, they should know how to
    read or write the message content.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择使`data`非常通用，将序列化/反序列化的责任放在`Message`调用者身上。根据消息`type`，他们应该知道如何读取或写入消息内容。
- en: By using this approach, we avoid a tangled class hierarchy with `MessageRegister`, `MessageUnregister`,
    and so on. Adding a new `Message type` is simply adding a value in the `Type enum
    class` and doing the proper serialization/deserialization in `data` (which you
    have to do anyway).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这种方法，我们避免了与`MessageRegister`、`MessageUnregister`等纠缠不清的类层次结构。添加一个新的`Message类型`只需在`Type
    enum class`中添加一个值，并在`data`中进行适当的序列化/反序列化（你无论如何都必须这样做）。
- en: 'To see the file in Qt Creator, do not forget to add the `Message.h` in `ch10-mandelbrot-ipc.pro`
    file:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Qt Creator中查看文件，请务必在`ch10-mandelbrot-ipc.pro`文件中添加`Message.h`：
- en: '[PRE12]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The next header we will look at is `JobRequest.h`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要查看的下一个头文件是`JobRequest.h`：
- en: '[PRE13]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This `struct` element contains all the necessary data for the worker to calculate
    a line of the target Mandelbrot picture. Because the application and the worker(s)
    will live in different memory spaces (or even different physical machines), the
    parameters to calculate the Mandelbrot set have to be transmitted somehow. This
    is the purpose of `JobRequest`. The meaning of each field is the same as `JobResult`
    from [Chapter 9](part0090.xhtml#aid-2LQIK2 "Chapter 9.  Keeping Your Sanity with
    Multithreading"), *Keeping Your Sanity with Multithreading*.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`struct`元素包含了工作线程计算目标Mandelbrot图片一行所需的所有必要数据。因为应用程序和工作线程将存在于不同的内存空间（甚至不同的物理机器），因此必须以某种方式传输计算Mandelbrot集的参数。这就是`JobRequest`的目的。每个字段的意义与[第9章](part0090.xhtml#aid-2LQIK2
    "第9章。使用多线程保持理智")中的`JobResult`相同，*使用多线程保持理智*。
- en: Note the presence of the `Q_DECLARE_METATYPE(JobRequest)` macro. This macro
    is used to let the Qt meta-object system know about `JobRequest`. This is needed
    to be able to use the class in conjunction with `QVariant`. We will not use `QVariant`
    directly, but rather through the use of `QDataStream` which relies on `QVariant`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`Q_DECLARE_METATYPE(JobRequest)`宏的存在。这个宏用于让Qt元对象系统了解`JobRequest`。这是能够与`QVariant`一起使用类所必需的。我们不会直接使用`QVariant`，而是通过使用依赖于`QVariant`的`QDataStream`。
- en: 'Speaking of `JobResult`, here is the new `JobResult.h`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 说到`JobResult`，这里是新版的`JobResult.h`：
- en: '[PRE14]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The new version is a shameless copy-paste (with the small `Q_DECLARE_METATYPE`
    addition) of the project example of [Chapter 9](part0090.xhtml#aid-2LQIK2 "Chapter 9. 
    Keeping Your Sanity with Multithreading"), *Keeping Your Sanity with Multithreading*.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本是无耻地复制粘贴（添加了小的`Q_DECLARE_METATYPE`）了[第9章](part0090.xhtml#aid-2LQIK2 "第9章。使用多线程保持理智")的项目示例，*使用多线程保持理智*。
- en: Working with QDataStream and QTcpSocket
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用QDataStream和QTcpSocket
- en: 'The missing piece of the SDK is `MesssageUtils`. It deserves a dedicated section
    because it covers two major topics: serialization and `QDataStream` transactions.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: SDK缺少的部分是`MesssageUtils`。它值得一个专门的章节，因为它涵盖了两个主要主题：序列化和`QDataStream`事务。
- en: We will start with the serialization. We already know that `Message` stores
    only an opaque `QByteArray` data member. As a consequence, the desired data has
    to be serialized as a `QByteArray` before being passed to `Message`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从序列化开始。我们已经知道`Message`只存储一个不透明的`QByteArray`数据成员。因此，在传递给`Message`之前，所需的数据必须被序列化为`QByteArray`。
- en: 'If we take the example of a `JobRequest` object, it is not directly sent. We
    first put in in a generic `Message` object with the appropriate `Message` type.
    The following diagram summarizes the sequence of actions to be done:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们以 `JobRequest` 对象为例，它不是直接发送的。我们首先将其放入一个通用的 `Message` 对象中，并指定适当的 `Message`
    类型。以下图表总结了需要执行的操作序列：
- en: '![Working with QDataStream and QTcpSocket](img/image00438.jpeg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![使用 QDataStream 和 QTcpSocket](img/image00438.jpeg)'
- en: The `JobRequest` object is first serialized to a `QByteArray` class; it is then
    passed to a `Message` instance which is in turn serialized to a final `QByteArray`.
    The deserialization process is the exact mirror of this sequence (from right to
    left).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`JobRequest` 对象首先序列化到一个 `QByteArray` 类；然后将其传递给一个 `Message` 实例，该实例随后被序列化到一个最终的
    `QByteArray`。反序列化过程与此序列（从右到左）完全相同。'
- en: Serializing data brings a lot of questions. How can we do it in a generic fashion?
    How do we handle the possible endianness of the CPU architecture? How do we specify
    the length of the data to be able to deserialize it properly?
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化数据带来了许多问题。我们如何以通用方式执行它？我们如何处理可能的 CPU 架构的端序？我们如何指定数据长度以便正确反序列化？
- en: 'Once again, the Qt folks did a great job and provided us a great tool to deal
    with these issues: `QDataStream`.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一次又一次，Qt 团队做得非常出色，为我们提供了一款处理这些问题的强大工具：`QDataStream`。
- en: The `QDataStream` class enables you to serialize binary data to any `QIODevice`
    (`QAbstractSocket`, `QProcess`, `QFileDevice`, `QSerialPort`, and so on). The
    great advantage of `QDataStream` is that it encodes the information in a platform-agnostic
    format. You do not have to worry about the byte order, the operating system, or
    the CPU.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`QDataStream` 类允许您将二进制数据序列化到任何 `QIODevice`（`QAbstractSocket`、`QProcess`、`QFileDevice`、`QSerialPort`
    等）。`QDataStream` 的巨大优势在于它以平台无关的格式编码信息。您无需担心字节序、操作系统或 CPU。'
- en: 'The `QDataStream` class implements the serialization of C++ primitive types
    and several Qt type (`QBrush`, `QColor`, `QString`, and so on). Here is an example
    of a basic write:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`QDataStream` 类实现了 C++ 原始类型和几个 Qt 类型（`QBrush`、`QColor`、`QString` 等）的序列化。以下是一个基本写入的示例：'
- en: '[PRE15]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, `QDataStream` relies on the overload of the `<<` operator to
    write data. To read information, open the file with the correct mode and read
    with the `>>` operator.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`QDataStream` 依赖于 `<<` 操作符的重载来写入数据。为了读取信息，以正确的模式打开文件，并使用 `>>` 操作符读取。
- en: 'Back to our case; we want to serialize custom classes, like `JobRequest`. To
    do so, we have to overload the `<<` operator for `JobRequest`. The signature of
    the function will be like so:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的案例；我们想要序列化自定义类，如 `JobRequest`。为了做到这一点，我们必须重载 `JobRequest` 的 `<<` 操作符。函数的签名将如下所示：
- en: '[PRE16]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: What we write have here is that we want to overload the `out << jobRequest`
    operator call with our custom version. By doing so, we intend to fill the `out`
    object with the content of `jobRequest`. Because `QDataStream` already supports
    the serialization of primitive types, all we have to do is serialize them.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里写的是，我们想要重载 `out << jobRequest` 操作符调用，使用我们的自定义版本。通过这样做，我们的意图是将 `out` 对象填充为
    `jobRequest` 的内容。因为 `QDataStream` 已经支持原始类型的序列化，我们只需要序列化它们。
- en: 'Here is the updated version of `JobRequest.h`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `JobRequest.h` 的更新版本：
- en: '[PRE17]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We include `QDataStream` and overload the `<<` very easily. The returned `out`
    will be updated with the platform-agnostic content of the passed `jobRequest`.
    The `>>` operator overload follows the same pattern: we fill the `jobRequest`
    parameter with the content of the `in` variable. Behind the scenes, `QDataStream`
    stores the variable size in the serialized data to be able to read it afterwards.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很容易就包含了 `QDataStream` 并重载了 `<<` 操作符。返回的 `out` 将会更新为传递的 `jobRequest` 的平台无关内容。`>>`
    操作符的重载遵循相同的模式：我们将 `jobRequest` 参数填充为 `in` 变量的内容。在幕后，`QDataStream` 将变量大小存储在序列化数据中，以便之后能够读取。
- en: Be careful to serialize and deserialize the members in the same order. If you
    do not pay attention to this, you might encounter very peculiar values in `JobRequest`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以相同的顺序序列化和反序列化成员。如果您不留意这一点，您可能会在 `JobRequest` 中遇到非常奇特的数据。
- en: The `JobResult` operators overload follows the same pattern, and it does not
    deserve to be included in the chapter. Look at the source code of the project
    if you have any doubt about its implementation.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`JobResult` 操作符的重载遵循相同的模式，并且不值得包含在本章中。如果您对其实现有任何疑问，请查看项目的源代码。'
- en: 'On the other hand, `Message` operator overload needs to be covered:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，需要覆盖 `Message` 操作符的重载：
- en: '[PRE18]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Because the `Message::Type enum class` signal does not have an implicit conversion
    to `int`, we need to explicitly convert it to be able to serialize it. We know
    that there will not be more than 255 message types, therefore we can safely cast
    it to a `qint8` type.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Message::Type`枚举类信号没有隐式转换为`int`，我们需要显式转换它才能进行序列化。我们知道消息类型不会超过255种，因此我们可以安全地将它转换为`qint8`类型。
- en: The same story applies to the reading part. We start by declaring a `qint8 type`
    variable that will be filled with `in >> type`, and then, the `type` variable
    is casted to a `Message::Type` in `message`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的故事也适用于读取部分。我们首先声明一个`qint8`类型的变量，该变量将被`in >> type`填充，然后，将`type`变量转换为`message`中的`Message::Type`。
- en: Our SDK classes are ready to be serialized and deserialized. Let's see it in
    action in `MessageUtils` with the serialization of a message and its writing to
    a `QTcpSocket` class.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的SDK类已经准备好进行序列化和反序列化。让我们在`MessageUtils`中看看它是如何工作的，我们将对一条消息进行序列化并将其写入`QTcpSocket`类。
- en: 'Always in the `sdk` directory, create a `MessageUtils.h` header with the following
    content:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 总是在`sdk`目录下，创建一个包含以下内容的`MessageUtils.h`头文件：
- en: '[PRE19]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: There is no need to instantiate a `MessageUtils` class, as it does not hold
    any state. Here we used a `MessageUtils` namespace to simply protect our function
    against any name collision.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 没有必要实例化`MessageUtils`类，因为它不持有任何状态。在这里，我们使用`MessageUtils`命名空间来简单地保护我们的函数免受任何名称冲突的影响。
- en: 'The meat of the snippet lies in `sendMessage()`. Let''s look at the parameters:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 段落的精髓在于`sendMessage()`函数。让我们看看它的参数：
- en: '`socket`: This is the `QTcpSocket` class in which the message will be sent.
    It is the responsibility of the caller to ensure that it is properly opened.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket`: 这是将要发送消息的`QTcpSocket`类。确保它被正确打开是调用者的责任。'
- en: '`messageType`: This is the type of the message to be sent.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`messageType`: 这是将要发送的消息类型。'
- en: '`data`: This is the serialized data to be included in the message. It is a `QByteArray`
    class, meaning that the caller already serialized its custom class or data.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`: 这是包含在消息中的序列化数据。它是一个`QByteArray`类，意味着调用者已经序列化其自定义类或数据。'
- en: '`forceFlush`: This is a flag to force the socket to flush upon the message
    shipment. The OS keeps socket buffers that wait to be filled before being sent
    across the wire. Some messages need to be delivered immediately, like an abort
    all jobs message.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forceFlush`: 这是一个标志，用于在消息发送时强制套接字刷新。操作系统保留套接字缓冲区，等待填充后再通过网络发送。有些消息需要立即发送，比如中止所有作业的消息。'
- en: In the function itself, we start by creating a message with the passed parameters.
    Then, a `QByteArray` class is created. This `byteArray` will be the receptacle
    of the serialized data.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数本身中，我们首先使用传入的参数创建一个消息。然后，创建一个`QByteArray`类。这个`byteArray`将是序列化数据的容器。
- en: As a matter of fact, `byteArray` is passed in the constructor of the `QDataStream`
    stream, which is opened in the `QIODevice::WriteOnly` mode. It means that the
    stream will output its data to the `byteArray`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`byteArray`是在`QDataStream`流构造函数中传入的，该流以`QIODevice::WriteOnly`模式打开。这意味着流将输出其数据到`byteArray`。
- en: After that, the message is elegantly serialized to stream with `stream << message`
    and the modified `byteArray` is written to the socket with `socket.write(byteArray)`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，消息通过`stream << message`优雅地序列化到流中，并且修改后的`byteArray`通过`socket.write(byteArray)`写入套接字。
- en: Finally, if the `forceFlush` flag is set to `true`, the socket is flushed with `socket.flush()`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果`forceFlush`标志设置为`true`，则使用`socket.flush()`刷新套接字。
- en: 'Some messages will not have any payload associated. For this reason, we add
    a small helper function for this purpose:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 一些消息可能没有任何负载相关联。因此，我们添加了一个小型辅助函数来完成这个目的：
- en: '[PRE20]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now that the `sendMessage()` is done, let's turn to the `readMessages()`. Because
    we are working in IPC and more specifically with sockets, interesting issues arise
    when we want to read and parse messages.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经完成了`sendMessage()`，让我们转向`readMessages()`。因为我们正在处理IPC，更具体地说是在套接字上，当我们想要读取和解析消息时，会出现一些有趣的问题。
- en: When something is ready to be read in the socket, a signal will notify us. But
    how do we know how much to read? In the case of a `WORKER_DISCONNECT` message,
    there is no payload. On the other hand, a `JOB_RESULT` message can be very heavy.
    Even worse, several `JOB_RESULT` messages can line up in the socket, waiting to
    be read.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当套接字中有东西准备好读取时，一个信号会通知我们。但我们如何知道要读取多少呢？在`WORKER_DISCONNECT`消息的情况下，没有负载。另一方面，`JOB_RESULT`消息可能非常庞大。更糟糕的是，几个`JOB_RESULT`消息可以排队在套接字中，等待读取。
- en: To make things more difficult, we have to acknowledge the fact that we are working
    with the network. Packets can be lost, retransmitted, incomplete or whatever.
    Sure, TCP ensures that we eventually get all of the information, but it can be
    delayed.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要使事情更加复杂，我们必须承认我们正在与网络一起工作。数据包可能会丢失、重传、不完整或任何其他情况。当然，TCP 确保我们最终会得到所有信息，但它可能会延迟。
- en: If we had to do it ourselves, it would have implied a custom message header,
    with a payload size and a footer for each message.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们必须自己完成，那就意味着需要一个自定义的消息头，包括每个消息的有效负载大小和脚部。
- en: 'A feature introduced in Qt 5.7 comes to the rescue: `QDataStream` transaction.
    The idea is the following: when you start reading on a `QIODevice` class, you
    already know how much you have to read (based on the size of the object you want
    to fill). However, you might not get all the data in a single read.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 5.7 中引入的一个特性提供了帮助：`QDataStream` 事务。其思路如下：当你开始在 `QIODevice` 类上读取时，你已经知道你需要读取多少数据（基于你想要填充的对象的大小）。然而，你可能不会在一次读取中获取所有数据。
- en: If the read is not complete, `QDataStream` stores what was already read in a
    temporary buffer and restores it upon the next read. The next read will contain
    what was already loaded plus the content of the new read. You can see it as a
    checkpoint in the read stream that can be loaded later.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果读取未完成，`QDataStream` 将已读取的数据存储在一个临时缓冲区中，并在下一次读取时恢复它。下一次读取将包含已加载的内容加上新读取的内容。你可以将其视为读取流中的一个检查点，稍后可以加载。
- en: 'This process can be repeated until data is read. The official documentation
    provides a simple enough example:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程可以重复进行，直到读取数据。官方文档提供了一个足够简单的示例：
- en: '[PRE21]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the `QDataStream` class in which we want to read, `in.startTransaction()`
    marks the checkpoint in the stream. It will then try to read  `messageType` and `messageData` atomically.
    If it cannot do it, `in.commitTransaction()` returns `false` and the read data
    is copied in an internal buffer.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们想要读取的 `QDataStream` 类中，`in.startTransaction()` 标记流中的检查点。然后，它将尝试原子地读取 `messageType`
    和 `messageData`。如果它无法这样做，`in.commitTransaction()` 返回 `false`，并且读取的数据被复制到一个内部缓冲区中。
- en: Upon the next call to this code (more data to read), `in.startTransaction()`
    will restore the preceding buffer and try to finish the atomic read.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一次调用此代码（读取更多数据）时，`in.startTransaction()` 将恢复前面的缓冲区并尝试完成原子读取。
- en: 'In our `readMessages()` situation, we can receive several messages at once.
    This is why the code is a bit more complex. Here is the updated version of `MessageUtils`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `readMessages()` 情况中，我们一次可以接收多个消息。这就是为什么代码稍微复杂一些。以下是 `MessageUtils` 的更新版本：
- en: '[PRE22]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the function, the parameter is only a `QDataStream`. We assume that the caller
    linked the stream with the socket with `stream.setDevice(socket)`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数中，参数仅是一个 `QDataStream`。我们假设调用者使用 `stream.setDevice(socket)` 将流与套接字链接。
- en: Because we do not know the length of the content to be read, we prepare ourselves
    to read several messages. To explicitly indicate ownership and avoid any memory
    leaks, we return a `vector<unique_ptr<Message>>`. This `vector` has to be a `unique_ptr`
    pointer to be able to allocate it on the heap and avoid any copy during the return
    of the function.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不知道要读取的内容长度，我们准备读取多个消息。为了明确表示所有权并避免任何内存泄漏，我们返回一个 `vector<unique_ptr<Message>>`。这个
    `vector` 必须是一个 `unique_ptr` 指针，以便能够在堆上分配它，并在函数返回时避免任何复制。
- en: 'In the function itself, we start by declaring the `vector`. After that, a `while`
    loop is executed. The two conditions to stay in the loop are:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数本身中，我们首先声明 `vector`。之后，执行一个 `while` 循环。保持循环的两个条件是：
- en: '`commitTransaction == true`: This an atomic read in the stream that has been
    performed; a complete `message` has been read'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`commitTransaction == true`: 这表示在流中已经执行了一个原子读取；已读取了一个完整的 `message`'
- en: '`stream.device().bytesAvailable() > 0`: This states that there is still data
    to read in the stream'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stream.device().bytesAvailable() > 0`: 这表示在流中仍有数据可读'
- en: In the `while` loop, we start by marking the stream with `stream.startTransaction()`.
    After that, we try to perform an atomic read of a `*message` signal and see the
    result with `stream.commitTransaction()`. If it succeeded, the new `message` is
    added to the `messages` vector. This is repeated until we read all the content
    of the stream with the `bytesAvailable() > 0` test.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `while` 循环中，我们首先使用 `stream.startTransaction()` 标记流。之后，我们尝试执行一个原子的 `*message`
    信号读取，并使用 `stream.commitTransaction()` 查看结果。如果成功，新的 `message` 将被添加到 `messages`
    向量中。这会一直重复，直到我们通过 `bytesAvailable() > 0` 测试读取了流的全部内容。
- en: 'Let''s study a use case to understand what will happen. Consider that we receive
    multiple messages in `readMessages()`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个用例来了解会发生什么。假设我们在`readMessages()`中接收到多个消息：
- en: The `stream` object will try to read it into `message`.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stream`对象将尝试将其读取到`message`中。'
- en: The `commitTransaction` variable will be set to `true` and the first message
    will be added to `messages`.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`commitTransaction`变量将被设置为`true`，并将第一条消息添加到`messages`中。'
- en: If there are still bytes to read in the `stream`, repeat from step one. Otherwise,
    exit the loop.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`stream`中仍有可读的字节，则从第一步重复。否则，退出循环。
- en: To sum up, working with sockets raises its own set of questions. On one hand,
    it is a very powerful IPC mechanism with a lot of flexibility. On the other hand,
    it brings a lot of complexity due the nature of the network itself. Luckily, Qt
    (and moreover Qt 5.7) brings great classes to help us.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，使用套接字会引发一系列问题。一方面，它是一个非常强大的具有很多灵活性的IPC机制。另一方面，由于网络的本质，它带来了很多复杂性。幸运的是，Qt（尤其是Qt
    5.7）为我们带来了许多优秀的类来帮助我们。
- en: Keep in mind that we tolerate the `QDataStream` serialization and transactions
    overhead because it fits well to our need. If you are working on a constrained
    embedded platform, you might not have so much liberty about serializing overhead
    and buffer copies. However, you will still have to rebuild messages by hand for
    incoming bytes.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们容忍`QDataStream`序列化和事务开销，因为它非常适合我们的需求。如果你在一个受限制的嵌入式平台上工作，你可能没有太多关于序列化开销和缓冲区复制的自由。然而，你仍然需要手动重建消息，以处理传入的字节。
- en: Interacting with sockets in the worker
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在工作线程中与套接字交互
- en: 'Now that the SDK is completed, we can turn to the worker. The project is complex
    enough; we can refresh our memory with the `mandelbrot-worker` architecture:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在SDK已经完成，我们可以转向工作线程。项目已经足够复杂；我们可以通过`mandelbrot-worker`架构来刷新我们的记忆：
- en: '![Interacting with sockets in the worker](img/image00439.jpeg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![在工作线程中与套接字交互](img/image00439.jpeg)'
- en: 'We will start by implementing the `Job` class. Inside the `mandelbrot-worker`
    project, create a new C++ class named `Job`. Here is the `Job.h` content:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先实现`Job`类。在`mandelbrot-worker`项目中，创建一个名为`Job`的新C++类。以下是`Job.h`的内容：
- en: '[PRE23]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If you remember the `Job` class from [Chapter 9](part0090.xhtml#aid-2LQIK2 "Chapter 9. 
    Keeping Your Sanity with Multithreading"), *Keeping Your Sanity with Multithreading*,
    this header should ring a bell. The only difference is that the parameters of
    the job (area size, scale factor, and so on) are extracted from the `JobRequest`
    object rather than stored directly as member variables.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得第9章中的`Job`类，即[第9章。通过多线程保持理智](part0090.xhtml#aid-2LQIK2 "第9章。通过多线程保持理智")，这个头文件应该会让你想起。唯一的区别是，作业的参数（区域大小、缩放因子等）是从`JobRequest`对象中提取的，而不是直接作为成员变量存储。
- en: As you can see, the `JobRequest` object is provided in the constructor of `Job`.
    We will not cover `Job.cpp`, as it is very much like the version of it in [Chapter
    9](part0090.xhtml#aid-2LQIK2 "Chapter 9.  Keeping Your Sanity with Multithreading"), *Keeping
    Your Sanity with Multithreading*.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`JobRequest`对象是在`Job`的构造函数中提供的。我们不会介绍`Job.cpp`，因为它与第9章中[第9章。通过多线程保持理智](part0090.xhtml#aid-2LQIK2
    "第9章。通过多线程保持理智")中的版本非常相似。
- en: 'We now proceed to the `Worker` class. This class has the following roles:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在继续研究`Worker`类。这个类有以下角色：
- en: It interacts with the `mandelbrot-app` using a `QTcpSocket` class
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用`QTcpSocket`类与`mandelbrot-app`交互
- en: It dispatches `JobRequests` to a `QThreadPool` class, aggregates the results,
    and sends them back to `mandelbrot-app` application through the `QTcpSocket` class
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将`JobRequests`调度到`QThreadPool`类，聚合结果，并通过`QTcpSocket`类将它们发送回`mandelbrot-app`应用程序
- en: 'We will start by studying the interaction with the `QTcpSocket` class. Create
    a new class named `Worker` with the following header:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先研究与`QTcpSocket`类的交互。创建一个名为`Worker`的新类，并具有以下头文件：
- en: '[PRE24]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `Worker` class is the owner of `mSocket`. The first thing we will implement
    is the connection with `mandelbrot-app`. Here is the constructor of `Worker` in `Worker.cpp`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`Worker`类是`mSocket`的所有者。我们将要实现的第一件事是与`mandelbrot-app`的连接。以下是`Worker.cpp`中`Worker`的构造函数：'
- en: '[PRE25]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The constructor initializes `mSocket` with `this` as the parent and it then
    proceeds to connecting the relevant `mSocket` signals to lambdas:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数使用`this`作为父类初始化`mSocket`，然后继续将相关的`mSocket`信号连接到lambda函数：
- en: '`QTcpSocket::connected`: When the socket is connected, it will send its register
    message. We will soon cover this function'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QTcpSocket::connected`：当套接字连接时，它将发送其注册消息。我们很快就会介绍这个函数'
- en: '`QTcpSocket::disconnected`: When the socket is disconnected, it simply prints
    a message in the console'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QTcpSocket::disconnected`: 当套接字断开连接时，它会在控制台简单地打印一条消息。'
- en: Finally, `mSocket` tries to connect on the `localhost` on the port `5000`. In
    the code example, we assume that you execute the worker and the application on
    the same machine. Feel free to change this value if you run the worker and the
    application on different machines.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`mSocket` 尝试在 `localhost` 的端口 `5000` 上建立连接。在代码示例中，我们假设你在同一台机器上执行工作器和应用程序。如果你在不同的机器上运行工作器和应用程序，请随意更改此值。
- en: 'The body of `sendRegister()` function looks like this:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`sendRegister()` 函数的主体如下：'
- en: '[PRE26]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: A `QByteArray` class is filled with the `idealThreadCount` function of the worker's
    machine. After that, we call `MessageUtils::sendMessage` to serialize the message
    and send it through our `mSocket`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`QByteArray` 类被工作机的 `idealThreadCount` 函数填充。之后，我们调用 `MessageUtils::sendMessage`
    来序列化消息并通过我们的 `mSocket` 发送它。'
- en: 'Once the worker is registered, it will start to receive job requests, process
    them, and send job results back. Here is the updated `Worker.h`:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦工作器注册，它将开始接收工作请求，处理它们，并发送工作结果。以下是更新的 `Worker.h`：
- en: '[PRE27]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s review the role of each one of these new members:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下这些新成员的每个角色的作用：
- en: '`mSocketReader`: This is the `QDataStream` class through which we will read `mSocket`
    content. It will be passed as a parameter to our `MessageUtils::readMessages()`
    function.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mSocketReader`: 这是我们将通过它读取 `mSocket` 内容的 `QDataStream` 类。它将被作为参数传递给我们的 `MessageUtils::readMessages()`
    函数。'
- en: '`mReceivedJobsCounter`: This is incremented each time a new `JobRequest` is
    received from `mandelbrot-app`.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mReceivedJobsCounter`: 每当从 `mandelbrot-app` 接收到新的 `JobRequest` 时，这个计数器会增加。'
- en: '`mSentJobsCounter`: This is incremented each time a new `JobResult` is sent
    to `mandelbrot-app`.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mSentJobsCounter`: 每当向 `mandelbrot-app` 发送新的 `JobResult` 时，这个计数器会增加。'
- en: 'Now for the new functions:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来看看新的函数：
- en: '`abortAllJobs()`: This is a signal emitted when the `Worker` class receives
    the appropriate message.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abortAllJobs()`: 当 `Worker` 类接收到适当的消息时，会发出这个信号。'
- en: '`readMessages()`: This is the slot called each time there is something to read
    in `mTcpSocket`. It parses the messages and, for each message type, it will call
    the corresponding function.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readMessages()`: 这是每次在 `mTcpSocket` 中有可读内容时被调用的槽。它解析消息，并为每种消息类型调用相应的函数。'
- en: '`handleJobRequest()`: This function creates and dispatches a `Job` class according
    to the `JobRequest` object contained in the message parameter.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handleJobRequest()`: 这个函数根据消息参数中包含的 `JobRequest` 对象创建和调度 `Job` 类。'
- en: '`handleAllJobsAbort()`: This function cancels all the current jobs and clear
    the thread queue.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handleAllJobsAbort()`: 这个函数取消所有当前的工作，并清除线程队列。'
- en: '`sendJobResult()`: This function sends the `JobResult` object to `mandelbrot-app`.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sendJobResult()`: 这个函数将 `JobResult` 对象发送到 `mandelbrot-app`。'
- en: '`sendUnregister()`: This function sends the unregister message to `mandelbrot-app`.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sendUnregister()`: 这个函数将注销消息发送到 `mandelbrot-app`。'
- en: '`createJob()`: This is a helper function to create and properly connect the
    signals of a new `Job`.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`createJob()`: 这是一个辅助函数，用于创建并正确连接新 `Job` 的信号。'
- en: 'The header is now complete. We can proceed to the updated constructor in `Worker.cpp`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在头部已经完整。我们可以继续更新 `Worker.cpp` 中的构造函数：
- en: '[PRE28]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `QDataStream mSocketReader` variable is initialized with the address of `mSocket`.
    This means that it will read its content from the `QIODevice` class. After that,
    we add the new connect to the `QTcpSocket` signal, `readyRead()`. Each time that
    data is available to read on the socket, our slot, `readMessages()`, will be called.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`QDataStream mSocketReader` 变量被初始化为 `mSocket` 的地址。这意味着它将从 `QIODevice` 类读取其内容。之后，我们添加了新的连接到
    `QTcpSocket` 信号，`readyRead()`。每次套接字上有可读数据时，我们的槽 `readMessages()` 会被调用。'
- en: 'Here is the implementation of `readMessages()`:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 `readMessages()` 的实现：
- en: '[PRE29]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The messages are parsed with the `MessageUtils::readMessages()` function. Note
    the use of C++11 semantics with `auto`, which elegantly hides the smart pointers
    syntax and still handles the memory for us.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 消息是通过 `MessageUtils::readMessages()` 函数解析的。注意使用了 C++11 语义中的 `auto`，它优雅地隐藏了智能指针的语法，同时仍然为我们处理内存。
- en: 'For each parsed `message`, it is handled in the `switch` case. Let''s review 
    `handleJobRequest()`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个解析的 `message`，它都在 `switch` 案中处理。让我们回顾一下 `handleJobRequest()`：
- en: '[PRE30]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this function, the `message` object is already deserialized. However, `message.data`
    still needs to be deserialized. To achieve this, we create a `QDataStream` in
    a variable that will read from `message.data`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，`message` 对象已经被反序列化。然而，`message.data` 仍然需要被反序列化。为了实现这一点，我们在一个变量中创建一个
    `QDataStream`，它将读取 `message.data`。
- en: From here, we parse the requests `QList`. Because `QList` already overrides
    the `>>` operator, it works in cascade and calls our `JobRequest >>` operator
    overload. Deserializing data has never been so easy!
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们解析请求的 `QList`。因为 `QList` 已经重载了 `>>` 操作符，它以级联方式工作并调用我们的 `JobRequest >>`
    操作符重载。数据反序列化从未如此简单！
- en: After that, we increment `mReceivedJobsCounter` and start processing these 
    `JobRequests`. For each one, we create a `Job` class and dispatch it to the global `QThreadPool`
    class. If you have a doubt about `QThreadPool`, get back to [Chapter 9](part0090.xhtml#aid-2LQIK2
    "Chapter 9.  Keeping Your Sanity with Multithreading"), *Keeping Your Sanity with
    Multithreading*.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们增加 `mReceivedJobsCounter` 并开始处理这些 `JobRequests`。对于每一个，我们创建一个 `Job` 类并将其调度到全局的
    `QThreadPool` 类。如果你对 `QThreadPool` 有疑问，请回到[第9章](part0090.xhtml#aid-2LQIK2 "第9章。使用多线程保持理智")，*使用多线程保持理智*。
- en: 'The `createJob()` function is straightforward to implement:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`createJob()` 函数实现起来很简单：'
- en: '[PRE31]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: A new `Job` class is created and its signals are properly connected. When `Worker::abortAllJobs`
    is emitted, every running `Job` should be canceled with the `Job::abort` slot.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的 `Job` 类，并正确连接其信号。当 `Worker::abortAllJobs` 被发射时，每个正在运行的 `Job` 都应该通过 `Job::abort`
    插槽被取消。
- en: 'The second signal, `Job::jobCompleted` is emitted when the `Job` class has
    finished calculating its values. Let''s see the connected slot, `sendJobResult()`:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个信号 `Job::jobCompleted` 在 `Job` 类完成计算其值时被发射。让我们看看连接的槽，`sendJobResult()`：
- en: '[PRE32]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We first increment the `mSentJobsCounter` and then serialize the `JobResult`
    to a `QByteArray` data which is passed `to MessageUtils::sendMessage()`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先增加 `mSentJobsCounter`，然后将 `JobResult` 序列化到 `QByteArray` 数据中，并将其传递给 `MessageUtils::sendMessage()`。
- en: 'We completed the tour of the `JobRequest` handling and the following `JobResult`
    shipment. We still have to cover `handleAllJobsAbort()`, which is called from `readMessages()`:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了对 `JobRequest` 处理和随后的 `JobResult` 发送的巡礼。我们仍然需要涵盖 `handleAllJobsAbort()`，它从
    `readMessages()` 中被调用：
- en: '[PRE33]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `abortAllJobs()` signal is emitted first to tell all the running jobs to
    cancel their process. After that, the `QThreadPool` class is cleared and the counters
    are reset.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 首先发射 `abortAllJobs()` 信号，告诉所有正在运行的任务取消其进程。之后，清除 `QThreadPool` 类并重置计数器。
- en: 'The last piece of `Worker` is the `sendUnregister()`, which is called in the `Worker`
    destructor:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`Worker` 的最后一部分是 `sendUnregister()`，它在 `Worker` 析构函数中被调用：'
- en: '[PRE34]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `sendUnregister()` function just calls `sendMessage` without any data to
    serialize. Note that it passes the `forceFlush` flag to `true` to make sure that
    the socket is flushed and that `mandelbrot-app` application will receive the message
    as fast as possible.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`sendUnregister()` 函数只是调用 `sendMessage` 而不进行任何数据序列化。注意，它将 `forceFlush` 标志传递为
    `true`，以确保套接字被刷新，并且 `mandelbrot-app` 应用程序能够尽可能快地接收到消息。'
- en: 'The `Worker` instance will be managed by a widget which will display the progress
    of the current calculation. Create a new class named `WorkerWidget` and update
     `WorkerWidget.h`, like so:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`Worker` 实例将由一个显示当前计算进度的窗口小部件管理。创建一个名为 `WorkerWidget` 的新类，并更新 `WorkerWidget.h`，如下所示：'
- en: '[PRE35]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The members of `WorkerWidget` are:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkerWidget` 的成员包括：'
- en: '`mStatus`: The `QProgressBar` that will display the percentage of processed `JobRequests`'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mStatus`: 将显示已处理 `JobRequests` 百分比的 `QProgressBar`'
- en: '`mWorker`: The `Worker` instance owned and started by `WorkerWidget`'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mWorker`: 由 `WorkerWidget` 拥有和启动的 `Worker` 实例'
- en: '`mWorkerThread`: The `QThread` class in which `mWorker` will be executed'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mWorkerThread`: `mWorker` 将在其中执行的 `QThread` 类'
- en: '`mRefreshTimer`: The `QTimer` class that will periodically poll `mWorker` to
    know the process advancement'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mRefreshTimer`: 将周期性地轮询 `mWorker` 以了解进程进度的 `QTimer` 类'
- en: 'We can proceed to `WorkerWidget.cpp`:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续到 `WorkerWidget.cpp`：
- en: '[PRE36]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: First, the `mStatus` variable is added to the `WorkerWidget` layout. Then the `mWorker`
    thread affinity is moved to `mWorkerThread` and `mRefreshTimer` is configured
    to poll `mWorker` and update `mStatus` data.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将 `mStatus` 变量添加到 `WorkerWidget` 布局中。然后，将 `mWorker` 线程亲和性移动到 `mWorkerThread`，并将
    `mRefreshTimer` 配置为轮询 `mWorker` 并更新 `mStatus` 数据。
- en: Finally, `mWorkerThread` is started, triggering the `mWorker` process. The `mRefreshTimer`
    object is also started with an interval of 100 milliseconds between each timeout.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，启动`mWorkerThread`，触发`mWorker`进程。同时，`mRefreshTimer`对象也被启动，每个超时之间的间隔为100毫秒。
- en: 'The last thing to cover in `mandelbrot-worker` is the `main.cpp`:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在`mandelbrot-worker`中要讨论的最后一件事是`main.cpp`：
- en: '[PRE37]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We start by registering `JobResult` with `qRegisterMetaType` because it is used
    in the signal/slot mechanism. After that, we instantiate a `WorkerWidget` layout
    and display it.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用`qRegisterMetaType`注册`JobResult`，因为它在信号/槽机制中使用。之后，我们实例化一个`WorkerWidget`布局并显示它。
- en: Interacting with sockets from the application
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从应用程序与套接字交互
- en: 'The next project to complete is `mandelbrot-app`. It will contain the `QTcpServer`
    that will interact with the workers and the picture drawing of the Mandelbrot
    set. As a reminder, the diagram of the `mandelbrot-app` architecture is shown
    here:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个要完成的项目是`mandelbrot-app`。它将包含与工作者交互的`QTcpServer`以及曼德布罗特集的图片绘制。作为提醒，`mandelbrot-app`架构的图示如下：
- en: '![Interacting with sockets from the application](img/image00440.jpeg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![从应用程序与套接字交互](img/image00440.jpeg)'
- en: 'We will build this application from the ground up. Let''s start with the class
    responsible for maintaining the connection with a specific `Worker: WorkerClient`.
    This class will live in its specific `QThread` and will interact with a `Worker`
    class using the same  `QTcpSocket`/`QDataStream` mechanism we covered in the last
    section.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从零开始构建这个应用程序。让我们从负责与特定`Worker`保持连接的类`WorkerClient`开始。这个类将存在于其特定的`QThread`中，并使用我们在上一节中介绍的相同的`QTcpSocket`/`QDataStream`机制与`Worker`类交互。
- en: 'In `mandelbrot-app`, create a new C++ class named `WorkerClient` and update 
    `WorkerClient.h` like so:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在`mandelbrot-app`中，创建一个名为`WorkerClient`的新C++类，并更新`WorkerClient.h`如下：
- en: '[PRE38]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: It looks very similar to `Worker`. Yet it may behave differently from a life
    cycle point of view. Each time a new `Worker` connects to our `QTcpServer`, a
    new `WorkerClient` will be spawned with an associated `QThread`. The `WorkerClient`
    object will take the responsibility of interacting with the `Worker` class through
    the `mSocket`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来与`Worker`非常相似。然而，从生命周期角度来看，它可能表现得不同。每次新的`Worker`连接到我们的`QTcpServer`时，都会创建一个新的`WorkerClient`，并关联一个`QThread`。`WorkerClient`对象将负责通过`mSocket`与`Worker`类交互。
- en: If the `Worker` disconnects, the `WorkerClient` object will be deleted and removed
    from the `QTcpServer` class.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Worker`断开连接，`WorkerClient`对象将被删除并从`QTcpServer`类中移除。
- en: 'Let''s review the content of this header, starting with the members:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下这个标题的内容，从成员开始：
- en: '`mSocketDescriptor`: This is the unique integer assigned by the system to interact
    with the socket. `stdin`, `stdout`, and `stderr` are also descriptors that point
    to specific streams in your application. For a given socket, the value will be
    retrieved in `QTcpServer`. More on this later on.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mSocketDescriptor`：这是系统分配的唯一整数，用于与套接字交互。`stdin`、`stdout`和`stderr`也是指向应用程序中特定流的描述符。对于给定的套接字，该值将在`QTcpServer`中检索。关于这一点，稍后会有更多介绍。'
- en: '`mCpuCoreCount`: This is the CPU core count for the connected `Worker`. This
    field will be initialized when the `Worker` sends the `WORKER_REGISTER` message.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mCpuCoreCount`：这是连接的`Worker`的CPU核心数。当`Worker`发送`WORKER_REGISTER`消息时，该字段将被初始化。'
- en: '`mSocket`: This is the `QTcpSocket` used to interact with the `Worker` class.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mSocket`：这是用于与`Worker`类交互的`QTcpSocket`。'
- en: '`mSocketReader`: This has the same role it had in `Worker` - it reads `mSocket`
    content.'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mSocketReader`：这个信号在`Worker`类中扮演相同的角色——它读取`mSocket`的内容。'
- en: 'Now we can add the functions to `WorkerClient.h`:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以向`WorkerClient.h`添加函数：
- en: '[PRE39]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let''s see what each function does:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看每个函数的作用：
- en: '`WorkerClient()`: This function expects a `socketDescriptor` as a parameter.
    As a consequence, a `WorkerClient` function cannot be initialized without a valid
    socket.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WorkerClient()`：这个函数期望一个`socketDescriptor`作为参数。因此，没有有效的套接字，`WorkerClient`函数不能被初始化。'
- en: '`cpuCoreCount()`: This function is a simple getter to let the owner of `WorkerClient`
    know how many cores the `Worker` has.'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cpuCoreCount()`：这个函数是一个简单的获取器，让`WorkerClient`的所有者知道`Worker`有多少个核心。'
- en: 'The class has three signals:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类有三个信号：
- en: '`unregister()`: This is the signal sent by `WorkerClient` when it has received
    the `WORKER_UNREGISTER` message.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unregister()`：这是`WorkerClient`在接收到`WORKER_UNREGISTER`消息时发送的信号。'
- en: '`jobCompleted()`: This is the signal sent by `WorkerClient` when it has received
    the `JOB_RESULT` message. It will pass by copying the deserialized `JobResult`.'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jobCompleted()`：这是`WorkerClient`在接收到`JOB_RESULT`消息时发送的信号。它将通过复制反序列化的`JobResult`传递。'
- en: '`sendJobRequests()`: This is emitted from the owner of `WorkerClient` to pass `JobRequests`
    in a queued connection to the proper slot:  `doSendJobRequests()`.'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sendJobRequests()`：这个信号由`WorkerClient`的所有者发出，以将`JobRequests`通过队列连接传递到适当的槽位：`doSendJobRequests()`。'
- en: 'Here are the details of the slots:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是槽位的详细信息：
- en: '`start()`: This slot is called when `WorkerClient` can start its process. Typically,
    it will be connected to the `start` signal of the `QThread` associated with the `WorkerClient`.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start()`：当`WorkerClient`可以开始其进程时调用这个槽位。通常，它将连接到与`WorkerClient`关联的`QThread`的`start`信号。'
- en: '`abortJob()`: This slot triggers the shipment of the `ALL_JOBS_ABORT` message
    to the `Worker`.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abortJob()`：这个槽位触发将`ALL_JOBS_ABORT`消息发送到`Worker`。'
- en: '`readMessages()`: This slot is called each time there is something to read
    in the socket.'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readMessages()`：每次在套接字中有东西要读取时调用这个槽位。'
- en: '`doSendJobRequests()`: This slot is the real slot that triggers the shipment
    of the `JobRequests` to the `Worker`.'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doSendJobRequests()`：这个槽位是实际触发将`JobRequests`发送到`Worker`的槽位。'
- en: 'And finally, here are the details of the private functions:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以下是私有函数的详细信息：
- en: '`handleWorkerRegistered()`: This function processes the `WORKER_REGISTER` message
    and initializes `mCpuCoreCount`'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handleWorkerRegistered()`：这个函数处理`WORKER_REGISTER`消息并初始化`mCpuCoreCount`。'
- en: '`handleWorkerUnregistered()`: This function processes the `WORKER_UNREGISTER`
    message and emits the `unregistered()` signal'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handleWorkerUnregistered()`：这个函数处理`WORKER_UNREGISTER`消息并发出`unregistered()`信号。'
- en: '`handleJobResult()`: This function processes the `JOB_RESULT` message and dispatches
    the content through the `jobCompleted()` signal'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handleJobResult()`：这个函数处理`JOB_RESULT`消息，并通过`jobCompleted()`信号分发内容。'
- en: 'The implementation in `WorkerClient.cpp` should be quite familiar. Here is
    the constructor:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkerClient.cpp`中的实现应该相当熟悉。以下是构造函数：'
- en: '[PRE40]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The fields are initialized in the initialization list and the `sendJobRequests`
    signal is connected to the private slot, `doSendJobRequests`. This trick is used
    to still have a queued connection across threads while avoiding multiple functions
    declarations.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 字段在初始化列表中初始化，并将`sendJobRequests`信号连接到私有槽`doSendJobRequests`。这个技巧用于在避免多个函数声明的同时，仍然能够在线程之间保持队列连接。
- en: 'We will proceed with the `start()` function:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续处理`start()`函数：
- en: '[PRE41]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This is very short indeed. It first connects the `readyRead()` signal from the
    socket to our `readMessages()` slot. After that, `mSocket` is properly configured
    with  `mSocketDescriptor`.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实非常简短。它首先将套接字的`readyRead()`信号连接到我们的`readMessages()`槽。之后，使用`mSocketDescriptor`正确配置`mSocket`。
- en: The connect has to be done in `start()` because it should be executed in the `QThread`
    class associated with our `WorkerClient`. By doing so, we know that the connect
    will be a direct connection and that `mSocket` will not have to queue signals
    to interact with `WorkerClient`.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 连接必须在`start()`中完成，因为它应该在关联我们的`WorkerClient`的`QThread`类中执行。这样做，我们知道这将是一个直接连接，并且`mSocket`不需要排队信号以与`WorkerClient`交互。
- en: Note that at the end of the function, the associated `QThread` is not terminated.
    On the contrary, it is executing its event loop with `QThread::exec()`. The `QThread`
    class will continue to run its event loop until someone calls `QThread::exit()`.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在函数的末尾，相关的`QThread`并没有终止。相反，它正在通过`QThread::exec()`执行其事件循环。`QThread`类将继续运行其事件循环，直到有人调用`QThread::exit()`。
- en: The only purpose of the `start()` function is to do the `mSocket` connect work
    in the right thread affinity. After that, we rely solely on the Qt signal/slot
    mechanism to process data. There is no need for a busy `while` loop.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`start()`函数的唯一目的是在正确的线程亲和度中执行`mSocket`连接工作。之后，我们完全依赖于Qt的信号/槽机制来处理数据。不需要忙的`while`循环。'
- en: 'The `readMessages()` class is waiting for us; let''s see it:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`readMessages()`类正在等待我们；让我们看看它：'
- en: '[PRE42]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: No surprises here. It's exactly like we did for `Worker`. The `Messages` are
    deserialized using `MessageUtils::readMessages()` and, for each message type,
    the appropriate function is called.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何惊喜。它与我们为`Worker`所做的一模一样。使用`MessageUtils::readMessages()`反序列化`Messages`，并为每种消息类型调用适当的函数。
- en: 'Here is the content of each of these functions, starting with `handleWorkerRegistered()`:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是每个函数的内容，从`handleWorkerRegistered()`开始：
- en: '[PRE43]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: For the `WORKER_REGISTER` message, `Worker` only serialized an `int` in `message.data`,
    so we can initialize `mCpuCoreCount` on the spot with `in >> mCpuCoreCount`.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`WORKER_REGISTER`消息，`Worker`只在`message.data`中序列化了一个`int`，因此我们可以立即使用`in >>
    mCpuCoreCount`初始化`mCpuCoreCount`。
- en: 'Now the body of `handleWorkerUnregistered()`:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是`handleWorkerUnregistered()`函数的主体：
- en: '[PRE44]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: It is a relay to send the `unregistered()` signal, which will be picked up by
    the owner of `WorkerClient`.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一个中继器，用于发送`unregistered()`信号，该信号将被`WorkerClient`的所有者捕获。
- en: 'The last "read" function is `handleJobResult()`:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个"读取"函数是`handleJobResult()`：
- en: '[PRE45]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This is deceptively short. It only deserializes the `jobResult` component from `message.data`
    and emits the `jobCompleted()` signal.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 这看似简短。它只从`message.data`反序列化`jobResult`组件并发出`jobCompleted()`信号。
- en: 'The "write-to-socket" functions are `abortJob()` and `doSendJobRequest()`:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '"写入套接字"函数是`abortJob()`和`doSendJobRequest()`：'
- en: '[PRE46]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `abortJob()` function sends the `ALL_JOBS_ABORT` message with the `forceFlush`
    flag set to `true` and `doSendJobRequests()` serializes the `requests` to stream
    before sending them using `MessageUtils::sendMessage()`.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '`abortJob()`函数发送带有`forceFlush`标志设置为`true`的`ALL_JOBS_ABORT`消息，而`doSendJobRequests()`在发送之前使用`MessageUtils::sendMessage()`将`requests`序列化到流中。'
- en: Building your own QTcpServer
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建自己的QTcpServer
- en: Everything is ready to read and write in our sockets. We still need a server
    to orchestrate all these instances. To do so, we will develop a modified version
    of the `MandelbrotCalculator` class, which was covered in [Chapter 9](part0090.xhtml#aid-2LQIK2
    "Chapter 9.  Keeping Your Sanity with Multithreading"), *Keeping Your Sanity with
    Multithreading*.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的网络套接字已经准备好读写。我们仍然需要一个服务器来协调所有这些实例。为此，我们将开发一个修改版的`MandelbrotCalculator`类，该类在[第9章](part0090.xhtml#aid-2LQIK2
    "第9章。使用多线程保持理智")中有所介绍，*使用多线程保持理智*。
- en: The idea is to respect the same interface, in order to have `MandelbrotWidget`
    oblivious to the fact that the Mandelbrot picture generation is deported on different
    processes/machines.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是尊重相同的接口，以便让`MandelbrotWidget`对曼德布罗特图片生成被委派到不同的进程/机器的事实无感。
- en: The main difference between the old `MandelbrotCalculator` and the new one is
    that we replaced the `QThreadPool` class by a `QTcpServer`. The `MandelbrotCalculator`
    class now only has the responsibility to dispatch `JobRequests` to Workers and
    aggregate the result, but it never interacts anymore with a `QThreadPool` class.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 旧版`MandelbrotCalculator`与新版的主要区别在于，我们用`QTcpServer`类替换了`QThreadPool`类。现在`MandelbrotCalculator`类只负责将`JobRequests`分发给工作者并汇总结果，但它不再与`QThreadPool`类交互。
- en: 'Create a new C++ class named `MandelbrotCalculator.cpp` and update  `MandelbrotCalculator.h`
    to match this:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`MandelbrotCalculator.cpp`的新C++类，并更新`MandelbrotCalculator.h`以匹配以下内容：
- en: '[PRE47]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The modified (or new) data is highlighted. First, note that the class now inherits
    from `QTcpServer` rather than `QObject`. The `MandelbrotCalculator` class is now
    a `QTcpServer` and is able to accept and manage connections. Before digging into
    this topic, we can review the new members:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 修改（或新）的数据被突出显示。首先，请注意，类现在从`QTcpServer`继承而不是`QObject`。`MandelbrotCalculator`类现在是一个`QTcpServer`，能够接受和管理连接。在深入这个主题之前，我们可以回顾一下新成员：
- en: '`mWorkerClients`: This is a `QMap` that stores the pair `WorkerClient` and `QThread`.
    Each time a `WorkerClient` is created, an associated `QThread` is also spawned
    and both of them are stored in `mWorkerClients`.'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mWorkerClients`：这是一个存储`WorkerClient`和`QThread`对的`QMap`。每次创建`WorkerClient`时，都会生成一个相关的`QThread`，并将它们都存储在`mWorkerClients`中。'
- en: '`mJobRequests`: This is the list of `JobRequests` for the current picture.
    Each time a picture generation is requested, the full list of `JobRequest` is
    generated, ready to be dispatched to `WorkerClients` (that is, to the `Worker`
    on the other side of the socket).'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mJobRequests`：这是当前图片的`JobRequests`列表。每次请求生成图片时，都会生成完整的`JobRequest`列表，准备分发给`WorkerClients`（即套接字另一侧的`Worker`）。'
- en: 'And the functions are:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 并且函数是：
- en: '`process()`: This function is a slightly modified version of the one seen in [Chapter
    9](part0090.xhtml#aid-2LQIK2 "Chapter 9.  Keeping Your Sanity with Multithreading"), *Keeping
    Your Sanity with Multithreading*. It not only aggregates `JobResults` before sending
    them with the `pictureLinesGenerated()` signal, but also dispatches `JobRequest`
    to the passed `WorkerClient` to keep them busy.'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`process()`：这个函数是[第9章](part0090.xhtml#aid-2LQIK2 "第9章。使用多线程保持理智")中看到的函数的一个略微修改版本，*使用多线程保持理智*。它不仅在使用`pictureLinesGenerated()`信号发送之前汇总`JobResults`，还将`JobRequest`分发给传递的`WorkerClient`以保持它们忙碌。'
- en: '`removeWorkerClient()`: This function removes and deletes the given `WorkerClient`
    from `mWorkerClients`.'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`removeWorkerClient()`: 这个函数从 `mWorkerClients` 中移除并删除给定的 `WorkerClient`。'
- en: '`incomingConnection()`: This function is an overloaded function from `QTcpServer`.
    It is called each time a new client tries to connect to `MandelbrotCalculator`.'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`incomingConnection()`: 这个函数是来自 `QTcpServer` 的重载函数。每次有新客户端尝试连接到 `MandelbrotCalculator`
    时都会调用它。'
- en: '`createJobRequest()`: This is a helper function that creates a `JobRequest`
    that is added to `mJobRequests`.'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`createJobRequest()`: 这是一个辅助函数，它创建一个被添加到 `mJobRequests` 的 `JobRequest`。'
- en: '`sendJobRequests()`: This function is responsible for sending a list of `JobRequests`
    to the specified `WorkerClient`.'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sendJobRequests()`: 这个函数负责向指定的 `WorkerClient` 发送 `JobRequests` 列表。'
- en: 'Let''s turn to `MandelbrotCalculator.cpp` with the constructor:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转到 `MandelbrotCalculator.cpp` 并从构造函数开始：
- en: '[PRE48]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This is the common initialization list with the `listen()` instruction in the
    body. Because we are subclassing `QTcpServer`, we can call listen on ourselves.
    Note that `QHostAddress::Any` works either for IPv4 and IPv6.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个带有 `listen()` 指令的常见初始化列表。因为我们正在继承 `QTcpServer`，我们可以对自己调用 `listen`。请注意，`QHostAddress::Any`
    适用于 IPv4 和 IPv6。
- en: 'Let''s see the overloaded function, `incomingConnection()`:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看重载函数 `incomingConnection()`：
- en: '[PRE49]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Once `listen()` has been called, each time someone connects to our ip/port pair, `incomingConnection()`
    will be triggered with `socketDescriptor` passed as a parameter.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦调用 `listen()`，每次有人连接到我们的 IP/端口对时，`incomingConnection()` 都会被触发，并将 `socketDescriptor`
    作为参数传递。
- en: Tip
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can test this on your machine connection with a simple `telnet 127.0.0.1
    5000` command. You should see the `Connected workerClient` log in `mandelbrot-app`.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在机器上使用简单的 `telnet 127.0.0.1 5000` 命令来测试这个机器连接。你应该在 `mandelbrot-app` 中看到
    `Connected workerClient` 日志。
- en: We start by creating a `QThread` class and a `WorkerClient`. This pair is immediately
    inserted in the `mWorkerClients` map and `client` thread affinity is changed to `thread`.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个 `QThread` 类和一个 `WorkerClient`。这个对立即插入到 `mWorkerClients` 映射中，并将 `client`
    线程亲和力更改为 `thread`。
- en: After that, we do all the connects to manage the `client` (`abortJob`, `unregister`,
    and `jobCompleted`). We continue with the `QThread::started()` signal, which is
    connected to the `WorkerClient::start()` slot and finally, `thread` is started.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们执行所有连接来管理 `client`（`abortJob`、`unregister` 和 `jobCompleted`）。我们继续使用 `QThread::started()`
    信号，它连接到 `WorkerClient::start()` 插槽，最后，`thread` 被启动。
- en: The last part of the function is used to trigger a picture generation upon the
    first `client` connection. If we did not do this, the screen would have remained
    black until we panned or zoomed.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的最后部分用于在第一个 `client` 连接时触发图片生成。如果我们不这样做，屏幕将保持黑色，直到我们进行平移或缩放。
- en: 'We have covered the `WorkerClient` creation; let''s finish its life cycle with
    its destruction with `removeWorkerClient()`:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了 `WorkerClient` 的创建；让我们通过 `removeWorkerClient()` 来完成其生命周期：
- en: '[PRE50]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `workerClient`/`thread` pair is removed from `mWorkerClients` and cleanly
    deleted. Note that this function can be called from the `WorkerClient::unregistered`
    signal or in the `MandelbrotCalculator` destructor:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '`workerClient`/`thread` 对从 `mWorkerClients` 中移除并干净地删除。请注意，这个函数可以从 `WorkerClient::unregistered`
    信号或 `MandelbrotCalculator` 析构函数中调用：'
- en: '[PRE51]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: When `MandelbrotCalculator` is deleted, `mWorkerClients` has to be properly
    emptied. The iterator style `while` loop does a good job of calling  `removeWorkerClient()`.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `MandelbrotCalculator` 被删除时，`mWorkerClients` 必须被适当地清空。迭代风格的 `while` 循环很好地完成了调用
    `removeWorkerClient()` 的工作。
- en: 'In this new version of `MandelbrotCalculator`, `generatePicture()` does not
    have exactly the same behavior:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `MandelbrotCalculator` 的这个新版本中，`generatePicture()` 的行为并不完全相同：
- en: '[PRE52]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The beginning is the same. However, the end is quite different. Rather than
    creating `Jobs` and giving them to a `QThreadPool`, `MandelbrotCalculator` now:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 开始部分是相同的。然而，结束部分相当不同。而不是创建 `Jobs` 并将它们分配给 `QThreadPool`，`MandelbrotCalculator`
    现在：
- en: Creates `JobRequests` to generate the whole picture. Note that they are created
    in reverse order. We will soon see why.
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建用于生成整个图片的 `JobRequests`。请注意，它们是按相反顺序创建的。我们很快就会看到原因。
- en: Dispatches a number of `JobRequests` to each `WorkerClient` it owns.
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向它拥有的每个 `WorkerClient` 分发多个 `JobRequests`。
- en: The second point deserves a strong emphasis. If we want to maximize the speed
    of our system, we have to use multiple workers, each one having multiple cores
    to process multiple jobs at the same time.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点值得强调。如果我们想最大化我们系统的速度，我们必须使用多个工作者，每个工作者拥有多个核心以同时处理多个任务。
- en: Even though a `Worker` class can process multiple jobs at the same time, it
    can only send us `JobResults` one by one (through `WorkerClient::jobCompleted`).
    Each time we process a `JobResult` object from a `WorkerClient`, we will dispatch
    a single  `JobRequest` to it.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 `Worker` 类可以同时处理多个工作，它也只能通过 `WorkerClient::jobCompleted` 逐个发送 `JobResults`。每次我们从
    `WorkerClient` 处理一个 `JobResult` 对象时，我们都会向它分发单个 `JobRequest`。
- en: Assume that the `Worker` class has eight cores. If we send `JobRequests` one
    by one, the `Worker` will always have seven cores idle. We are here to heat up
    your CPUs, not to let them drink mojitos on the beach!
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 `Worker` 类有八个核心。如果我们逐个发送 `JobRequests`，`Worker` 将始终有七个核心空闲。我们在这里是为了让你的 CPU
    加热，而不是让它们在海滩上喝莫吉托！
- en: 'To mitigate this, the first batch of `JobResults` we send to a worker has to
    be higher than its `coreCount()`. By doing so, we ensure that is always has a
    queue of  `JobRequests` to process until we generate the whole picture. This is
    why we send  `client->cpuCoreCount() * two` initial `JobRequests`. If you play
    with this value, you will see that:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减轻这种情况，我们发送给工作者的第一批 `JobResults` 必须高于其 `coreCount()`。通过这样做，我们确保它始终有一个 `JobRequests`
    队列要处理，直到我们生成整个图片。这就是为什么我们发送 `client->cpuCoreCount() * two` 个初始 `JobRequests`。如果你玩这个值，你会看到：
- en: If `jobCount < cpuCoreCount()`, some cores of your `Worker` will be idle and
    you will not leverage the full power of its CPU
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `jobCount` 小于 `cpuCoreCount()`，一些 `Worker` 的核心将会空闲，你将无法充分利用其 CPU 的全部功率
- en: If `jobCount > cpuCoreCount()` by too much, you might overload the queue of
    one your `Workers`
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `jobCount` 比 `cpuCoreCount()` 多得太多，你可能会超载某个 `Worker` 的队列
- en: Remember that this system is flexible enough to have multiple workers. If you
    have a RaspberryPI and an x86 with 16 cores, the RaspberryPI will lag behind the
    x86 CPU. By giving too much initial `JobRequests`, the RaspberryPI will hinder
    the whole picture generation while the x86 CPU has already finished all its jobs.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这个系统足够灵活，可以拥有多个工作者。如果你有一个 RaspberryPI 和一个 16 核的 x86 CPU，RaspberryPI 将落后于
    x86 CPU。通过提供过多的初始 `JobRequests`，RaspberryPI 将阻碍整个图片生成过程，而 x86 CPU 已经完成了所有的工作。
- en: 'Let''s cover the remaining functions of `MandelbrotCalculator`, starting with 
    `createJobRequest()`:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续探讨 `MandelbrotCalculator` 的剩余功能，从 `createJobRequest()` 开始：
- en: '[PRE53]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This is a simple creation of a `jobRequest` with the member fields of  `MandelbrotCalculator`.
    Again, we use `unique_ptr` to explicitly indicate the ownership of `jobRequest`
    and avoid any memory leaks.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是使用 `MandelbrotCalculator` 的成员字段创建一个简单的 `jobRequest`。同样，我们使用 `unique_ptr`
    来明确表示 `jobRequest` 的所有权，以避免任何内存泄漏。
- en: 'Next, with `sendJobRequests()`:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用 `sendJobRequests()`：
- en: '[PRE54]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Because we can send multiple `JobRequests` at the same time, we loop on  `jobRequestCount`
    by taking the last `jobRequest` of `mJobRequests` and adding it to `listJobRequest`.
    This is the reason for which we had to fill `mJobRequests` in the reverse order.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可以同时发送多个 `JobRequests`，我们通过循环 `jobRequestCount`，取 `mJobRequests` 的最后一个 `jobRequest`
    并将其添加到 `listJobRequest`。这就是为什么我们必须以相反的顺序填充 `mJobRequests`。
- en: Finally, the `client.sendJobRequests()` signal is emitted, which in turns triggers
    the `WorkerClient::doSendJobRequests()` slot.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，发出 `client.sendJobRequests()` 信号，这反过来触发 `WorkerClient::doSendJobRequests()`
    插槽。
- en: 'We are now going to see the modified version of `process()`:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看到 `process()` 的修改版本：
- en: '[PRE55]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In this version, we pass `workerClient` as a parameter. This is used at the
    end of the function, to be able to dispatch a new `JobRequest` to the given `workerClient`.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本中，我们传递 `workerClient` 作为参数。这在函数的末尾使用，以便能够向给定的 `workerClient` 分发新的 `JobRequest`。
- en: 'Finally, the updated version of `abortAllJobs()`:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`abortAllJobs()` 的更新版本：
- en: '[PRE56]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This simply cleared `mJobRequests` instead of emptying `QThreadPool`.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是简单地清除了 `mJobRequests`，而不是清空 `QThreadPool`。
- en: 'The `MandelbrotCalculator` class is completed! You can copy and paste  `MandelBrotWidget`
    and `MainWindow` (`.ui` file included) from [Chapter 9](part0090.xhtml#aid-2LQIK2
    "Chapter 9.  Keeping Your Sanity with Multithreading"), *Keeping Your Sanity with
    Multithreading*. We designed it to be plug and play, without knowing who generates
    the picture: a local `QThreadPool` with `QRunnable` or minions through an IPC
    mechanism.'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '`MandelbrotCalculator` 类已经完成！你可以从 [第9章](part0090.xhtml#aid-2LQIK2 "第9章。通过多线程保持理智")，*通过多线程保持理智*
    中复制并粘贴 `MandelBrotWidget` 和 `MainWindow`（包含 `.ui` 文件）。我们设计它是即插即用的，无需知道是谁生成图片：一个本地的
    `QThreadPool` 使用 `QRunnable` 或通过 IPC 机制的小兵。'
- en: 'There is only a tiny difference in `main.cpp`:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main.cpp` 中只有微小的差别：
- en: '[PRE57]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: You can now launch `mandelbrot-app` and after that, the one or many `mandelbrot-worker` programs
    that will connect to the application. It should automatically trigger a picture
    generation. The Mandelbrot picture generation is now working across multiple processes!
    Because we chose to use sockets, you can start the application and the workers
    on different physical machines.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以启动 `mandelbrot-app`，然后启动一个或多个将连接到应用程序的 `mandelbrot-worker` 程序。它应该会自动触发图片生成。Mandelbrot
    图片生成现在可以在多个进程之间工作！因为我们选择使用套接字，所以你可以在不同的物理机器上启动应用程序和工作进程。
- en: Tip
  id: totrans-410
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Using IPv6, you may very easily test the app/worker connection in different
    locations. If you do not have a high-speed Internet connection, you will see how
    the network hinders the picture generation.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 IPv6，你可以在不同的位置非常容易地测试应用程序/工作进程的连接。如果你没有高速互联网连接，你会看到网络是如何阻碍图片生成的。
- en: You may want to take some time to deploy the application on multiple machines
    and see how this cluster works together. During our tests, we ramped up our cluster
    up to 18 cores with very heterogeneous machines (PC, laptop, Macbook, and so on).
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想花些时间在多台机器上部署应用程序，看看这个集群是如何协同工作的。在我们的测试中，我们将集群扩展到 18 个核心，使用了非常异构的机器（PC、笔记本电脑、Macbook
    等等）。
- en: Summary
  id: totrans-413
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: IPC is a fundamental mechanism in computer science. In this chapter, you learned
    the various techniques offered by Qt to do IPC and how to create an application
    that uses sockets to interact, send, and receive commands. You took the original
    `mandelbrot-threadpool` application to the next level by enabling it to generate
    pictures on a cluster of machines.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: IPC（进程间通信）是计算机科学中的一个基本机制。在本章中，你学习了 Qt 提供的各种 IPC 技巧，以及如何创建一个使用套接字进行交互、发送和接收命令的应用程序。你通过启用它能够在机器集群上生成图片，将原始的
    `mandelbrot-threadpool` 应用程序提升到了一个新的水平。
- en: Adding IPC on top of a multi-threaded application brings some issues. You have
    many more possible bottlenecks, chances of leaking memory, and have an inefficient
    calculation. Qt provides multiple mechanisms to do IPC. In Qt 5.7, the addition
    of transactions makes the serialization/deserialization part much easier.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在多线程应用程序之上添加 IPC 会带来一些问题。你会有更多的潜在瓶颈，内存泄漏的机会，以及低效的计算。Qt 提供了多种机制来进行 IPC。在 Qt 5.7
    中，事务的添加使得序列化/反序列化部分变得更加容易。
- en: In the next chapter, you will discover the Qt Multimedia framework and how to
    save and load an C++ object from a file. The project example will be a virtual
    drum machine. You will be able to save and load your tracks.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将了解 Qt 多媒体框架以及如何从文件中保存和加载 C++ 对象。项目示例将是一个虚拟鼓机。你将能够保存和加载你的音轨。
