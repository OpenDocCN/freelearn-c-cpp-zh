- en: Chapter 10.  Need IPC? Get Your Minions to Work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, you learned how to send information across threads
    of the same process. In this chapter, you will discover how to share data between
    threads of different processes. We will even share information between applications
    running on different physical computers. We will enhance the Mandelbrot generator
    application from [Chapter 9](part0090.xhtml#aid-2LQIK2 "Chapter 9.  Keeping Your
    Sanity with Multithreading"), *Keeping Your Sanity with Multithreading*. The Mandelbrot
    application will now only display results processed by the worker programs. These
    minions have only one mission: compute the tasks as fast as possible and return
    a result to your main application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the topics covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How two applications can communicate together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a multithreaded TCP server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading and writing on a TCP socket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other IPC techniques like `QSharedMemory`, `QProcess`, and Qt D-Bus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network serialization using `QDataStream`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computer clustering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inter-process communication techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An **IPC** (**inter-process communication**) is a communication between two
    or more processes. They can be instances of the same or a different application.
    The Qt framework provides multiple modules to help you implement a communication
    between your applications. Most of these modules are cross-platform. Let's talk
    about the IPC tools provided by Qt.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first tools are the TCP/IP sockets. They provide a bidirectional data exchange
    over a network. Therefore, you can use them to talk with processes on different
    computers. Moreover, the `loopback` interface allows you to communicate with processes
    running on the same computer. All the required classes are inside the `QtNetwork`
    module. This technique relies on a client-server architecture. Here is an example
    of the server part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The first step is to instantiate a `QTcpServer` class. It deals with the new
    incoming TCP connections. Then, we call the `listen()` function. You can provide
    a network interface and specify the port on which the server must listen for incoming
    connections. In this example, we listen on all network addresses (for example, `127.0.0.1`, `192.168.1.4`,
    and so on) on the port `5000`. When a client establishes a connection with this
    server, the `QTcpServer::newConnection()` signal is triggered. Let''s break together
    this lambda slot:'
  prefs: []
  type: TYPE_NORMAL
- en: We retrieve the `QTcpSocket` class related to this new connection with a client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `QByteArray` response is prepared with the ASCII message "Hello". Forget the
    lack of originality.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The message is sent to the client through the socket.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we close the socket. So the client, on this side, will be disconnected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can test a `QTcpServer` class with a telnet tool like Putty on Windows or
    the `telnet` command on Linux and Mac OS.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet is the client part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The client also uses a `QTcpSocket` class to communicate. It turns out that
    the connection is initiated by the client, therefore we need to call the `connectToHost()`
    function with the server address and port. This class provides a lot of useful
    signals such as `connected()` and `disconnected()` that indicate the connection
    status. The `readyRead()` signal is emitted when new data is available for reading.
    The `readAll()`function returns `QByteArray` with all the available data. In our
    case, we know that the server sends an ASCII message to its client. Thus, we can
    convert this byte array in a `QString` and display it.
  prefs: []
  type: TYPE_NORMAL
- en: For this example, the server writes in the TCP socket and the client reads in
    it. But this communication is bidirectional, so the client can also write data
    and the server can read it. Try to send data from the client and display it in
    the server. Notice that you need to keep the communication alive by removing the
    `disconnectFromHost()` call in the server part.
  prefs: []
  type: TYPE_NORMAL
- en: The Qt framework provides a helper class, `QDataStream,` to easily send a complex
    object and handle the package fragmentation. This notion will be covered later
    with the project example of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s talk about the second IPC technique: **shared memory**. By default,
    different processes do not use the same memory space. The `QSharedMemory` class
    provides a cross-platform method to create and use a shared memory across multiple
    processes. Nevertheless, the processes must run on the same computer. A shared
    memory is identified by a key. All the processes must use the same key to share
    the same shared memory segment. The first process will create the shared memory
    segment and put data in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s analyze all the steps together:'
  prefs: []
  type: TYPE_NORMAL
- en: Once again, we want to share the `QString` "Hello" converted in a `QByteArray`
    class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `QSharedMemory` class is initialized with the key, `sharedMemoryKey`. This
    same key should be used by the second process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first process creates the shared memory segment with a specific size in
    bytes. The creation also attaches the process to the shared memory segment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should now be confident with the lock/unlock system. The `QSharedMemory`
    class uses semaphore to protect the shared access. You must lock it before manipulating
    the shared memory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A classical `memcpy()` function is used to copy data from the `QByteArray` class
    to the `QSharedMemory` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we can unlock the shared memory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Destroying a `QShareMemory` class will call the `detach()` function that detaches
    the process from the shared memory segment. If this process was the last one attached, `detach()`
    also destroys the shared memory segment. While an attached `QShareMemory` is alive,
    the shared memory segment is available for other processes. The next snippet describes
    how a second segment can access the shared memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the key steps:'
  prefs: []
  type: TYPE_NORMAL
- en: As with the first process, this second process initializes a `QShareMemory`
    class with the key, `sharedMemoryKey`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we attach the process to the shared memory segment with the `attach()`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We must lock the `QShareMemory` class before accessing it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We initialize a `QByteArray` with the null character, `\0`, with the size of
    the shared memory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `memcpy()` function copies the data from the `QShareMemory` to the `QByteArray`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can convert the `QByteArray` in a `QString` and display our message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last step is to call the `detach()`function to detach the process from the
    shared memory segment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Please notice that `create()` and `attach()` functions specify by default a `QShareMemory::ReadWrite`
    access. You can also use the `QShareMemory::ReadOnly` access.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can use the classes, `QBuffer` and `QDataStream` to serialize a complex
    object in or from a bytes array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another IPC way is to use the `QProcess` class. The main process starts an
    external application as a child process. The communication is done using the standard
    input and output devices. Let''s create a `hello` console application relying
    on the standard input and output channels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We use the `QTextStream` class to easily work with the standards streams, `stdout`
    and `stdin`. The application prints the message `Please enter your name:`. Then
    we wait while the user types his name by calling the `readLine()` function. Finally,
    the program displays the message `Hello` and the user `name`. If you start yourself
    this console application, you must type your name on the keyboard to see the final
    hello message with your name.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet runs and communicates with the `hello` application. Furthermore,
    we can programmatically control the child `hello` application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are all the steps performed by this main application:'
  prefs: []
  type: TYPE_NORMAL
- en: We initialize a `QProcess` object that can start an external application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The child process displays messages on the console and so writes in the standard
    output. Then, the `readyReadStandardOutput()` signal is sent. In this case, we
    print the message as debug text with the prefix `[*]` to identify that it comes
    from the child process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As soon as the child process is started, the `started()` signal is sent. In
    our case, we write in the child standard input the name `Sophie` (Lenna will be
    jealous!).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All is ready, we can start the `QProcess` class with the path to the `hello`
    console application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you start the main application you should get this result in its console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Mission completed! The main application is a wrapper for the `hello` application.
    We receive all messages from the child process and we can send it some information
    like a specific name.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `QProcess::start()` function also accepts a second variable: the command
    line arguments for the child process.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last IPC mechanism that we will cover together is the **D-Bus protocol**.
    Currently, the Qt D-Bus module is officially supported only on Linux. If you need
    to use it on Windows, you will have to compile it from Qt sources. It can be seen
    as a unified protocol for IPC and **RPC** (**remote procedure calling**). Many
    forms of communication are possible, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: One-to-one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One-to-many
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many-to-many
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The best thing about Qt D-Bus is that you can even use the signal/slot mechanism
    across the bus. A signal emitted from one application can be connected to a slot
    from another application. Linux desktop environments like KDE and GNOME use the
    D-Bus. That implies that you can (also) control your desktop with D-Bus.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the main concepts of D-Bus:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Bus`: This is used in many-to-many communication. D-Bus defines two buses:
    the **system bus** and the **session bus**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Service name`: This is the identifier of a service on a bus.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Message`: This is a message sent by one application. If a bus is used, the
    message contains the destination.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Qt D-Bus Viewer tool can be found in your Qt installation folder (for example,
    `/Qt/5.7/gcc_64/bin/qdbusviewer`). All objects and messages from all services
    of the system and the session bus are displayed. Try to invoke exposed methods
    and retrieve a result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have messed about with your Linux D-Bus services, it is time to
    create your own! At first, we will create a simple `HelloService` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'No big deal here, the only function is a public slot that requires a `name`,
    displays who is here, and returns a hello message. In the following snippet, the
    main application registers a new D-Bus service and the `HelloService` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The main application initializes an `HelloService` object. Then, we register
    a new service named `org.masteringqt.QtDBus.HelloService` on the session bus.
    Finally, we register the `HelloService` object, exposing all its slots. Notice
    the simple object path `/` used for this example. The service application part
    is finished. Here is the client application calling the `HelloService` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s analyze the client part step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: We initialize a `QDBusInterface` object with the same service name and path
    as the service application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We call the remote method, `sayHello()` on `HelloService`, with the parameter `Lenna`
    (Wait, where is Sophie!?).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The response is stored in a `QDBusReply` object. In our case, type `QString`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we display the message generated by the `HelloService` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you start the service application and then the client application, you should
    get this console output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `QDBusViewer` tool to find your D-Bus service. Select the **Session
    Bus** tab. Choose your service in the list. Then you can select the method `sayHello`.
    A right-click on it allows you to call the method. An input popup will ask you
    to fill the method parameter that is a name in our example. The following screenshot
    shows you what it looks like (it seems that Sophie is here):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Need IPC? Get Your Minions to Work](img/image00432.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Architecturing an IPC project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Mandelbrot picture generator from [Chapter 9](part0090.xhtml#aid-2LQIK2
    "Chapter 9.  Keeping Your Sanity with Multithreading"), *Keeping Your Sanity with
    Multithreading*, uses all cores of your computer to speed up the computing. This
    time, we want to use all the cores of all your computers! The first thing to do
    is to choose an appropriated IPC technique. For this project example, we want
    to establish communication between several clients acting as workers to a server
    running the main application. The TCP/IP sockets allows a one-to-many communication.
    Moreover, this IPC method is not bounded to a single computer and can operate
    through a network on multiple computers. This project example uses sockets by
    implementing a multi-threaded TCP server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next diagram describes the architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Architecturing an IPC project](img/image00433.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s talk about the global role of each actor:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mandelbrot-app`: This is the main application displaying the Mandelbrot picture
    and handling user mouse events. However, in this chapter, the application does
    not compute the algorithm itself but rather generates requests to connected workers.
    Then, it aggregates results provided by workers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mandelbrot-worker`: Here is our minion! A worker is a standalone program.
    It is connecting to the `mandelbrot-app` through a TCP socket. A worker receives
    a request, computes a job, and sends back a result.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SDK`: This regroups common stuff used by both applications. If the SDK changes,
    all the dependent applications must be updated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, this architecture fits well with the one-to-many communication
    required by this project. The `mandelbrot-app` application can use one or many
    workers to generate the same Mandelbrot picture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you get the big picture, let''s look in detail at each module. You
    can see all of the classes in the SDK in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Architecturing an IPC project](img/image00434.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: An SDK is essential when you have several modules (applications, libraries,
    and so on) that communicate together or need to perform the same actions. You
    can give the SDK to a third-party developer without compromising your main source
    code. In our project, `mandelbrot-app` and `mandelbrot-worker` communicate together
    by exchanging `Message`. The message structure must be known by both entities.
    A `Message` class contains a `type` and a raw `data` of the type, `QByteArray`.
    Depending on the message `type`, the raw data can be empty or can contain an object.
    In this project, a message `data` can be a `JobRequest` or a `JobResult`. The `mandelbrot-app`
    sends a `JobRequest` to `mandelbrot-worker`. Then, the worker returns `JobResult`
    to the main application. Finally, `MessageUtils` contains functions used by the
    main application and the workers to send and retrieve a `Message`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now talk about the `mandelbrot-worker` in more detail. The next diagram
    describes it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Architecturing an IPC project](img/image00435.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `mandelbrot-worker` program is able to use all the CPU cores of a machine.
    The socket mechanism allows us to run it on multiple physical machines at the
    same time. The `WorkerWidget` class displays the status of the `Worker` object.
    The `Worker` object handles the communication with `mandelbrot-app` using a `QTcpSocket`.
    A `Job` is a `QRunnable` class that computes a task. Here is the workflow of this
    software:'
  prefs: []
  type: TYPE_NORMAL
- en: Send a register `Message` to `mandelbrot-app` application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Receive some `JobRequest` from `mandelbrot-app` and create several `Job` instances
    to complete all tasks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each `Job` is running in a dedicated thread and will generate a `JobResult`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send `JobResult` to `mandelbrot-app`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On exit, send an unregister `Message` to `mandelbrot-app`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It is now time to talk about the `mandelbrot-app` architecture. Look at the
    next diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Architecturing an IPC project](img/image00436.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is the main application. You can launch it on a computer with a weak CPU
    and the real heavy work is done by workers running the `mandelbrot-worker` software.
    The GUI `MainWindow` and `MandelbrotWidget` objects are the same as those in [Chapter
    9](part0090.xhtml#aid-2LQIK2 "Chapter 9.  Keeping Your Sanity with Multithreading"), *Keeping
    Your Sanity with Multithreading.* The `MandelbrotCalculator` class is a little
    different in this project, because it does not run any `QRunnable` itself. It
    is a TCP server that handles all registered workers and dispatches tasks to those
    tasks. Each `mandelbrot-worker` is managed by a `WorkerClient` object instance
    with a dedicated `QTcpSocket`. Here is the workflow for `mandelbrot-app`:'
  prefs: []
  type: TYPE_NORMAL
- en: Run a TCP server on a specific port.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Receive a register `Message` and create a `WorkerClient` object for each registered
    worker.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When `MandelbrotWidget` requests a picture generation,  `MandelbrotCalculator`
    creates the `JobRequest` object required to compute the full Mandelbrot picture.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `JobRequest` objects are sent to the workers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Receive and aggregate `JobResult` from the `mandelbrot-worker`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Transmit `JobResult` to the `MandelbrotWidget` object that displays the picture.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If an unregister `Message` is received from a worker, the `WorkerClient` object
    is released and this worker will not be used for picture generation anymore.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should now get a complete overview of this project architecture. We can
    begin the implementation of this project. Create a **Subdirs** project called `ch10-mandelbrot-ipc`.
    As you might guess, we now create two sub-projects: `mandelbrot-app` and `mandelbrot-worker`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation in the subsequent sections follows the architecture presentation
    order:'
  prefs: []
  type: TYPE_NORMAL
- en: SDK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`mandelbrot-worker`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`mandelbrot-app`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The implementation is a step up in complexity. Do not hesitate to take a break
    and come back to this section to keep the overall architecture clear.
  prefs: []
  type: TYPE_NORMAL
- en: Laying down the foundations with an SDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step is to implement the classes that will be shared between our application
    and the workers. To do so, we are going to rely on a custom SDK. If you need to
    refresh your memory about this technique, take a look at [Chapter 8](part0081.xhtml#aid-2D7TI2
    "Chapter 8.  Animations - Its Alive, Alive!"), *Animations-- It's Alive, Alive!*.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a reminder, here is the diagram describing the SDK:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Laying down the foundations with an SDK](img/image00437.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s describe the job of each of these components:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Message` component encapsulates a piece of information that is exchanged
    between the application and the worker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `JobRequest` component contains the necessary information to dispatch a
    proper job to a worker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `JobResult` component contains the result of the Mandelbrot set calculation
    for a given line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `MessageUtils` component contains helper functions to serialize/deserialize
    data across the TCP socket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these files have to be accessible from each side of our IPC mechanism (application
    and worker). Note that the SDK will contain only header files. We did it on purpose
    to simplify the SDK usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with `Message` implementation in the `sdk` directory. Create a `Message.h`
    file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing to note is the `enum class Type` which details all the possible
    message types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`WORKER_REGISTER`: This is the message sent by the worker when it first connects
    to the application. The content of the message is only the number of cores of
    the worker''s CPU. We will see soon why this is useful.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WORKER_UNREGISTER`: This is the message sent by the worker when it is disconnected.
    This lets the application know that it should remove this worker from its list
    and stop sending any messages to it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ALL_JOBS_ABORT`: This is the message sent by the application each time a picture
    generation is canceled. The worker is then responsible for canceling all its current
    local threads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JOB_REQUEST`: This is the message sent by the application to calculate a specific
    line of the desired picture.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JOB_RESULT`: This is the message sent by the worker with the calculated result
    from the `JOB_REQUEST` inputs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A quick word about the `enum` class type, which is a C++11 addition. It is
    a safer version of enum (some might say that it is enum as it should have been
    from the beginning):'
  prefs: []
  type: TYPE_NORMAL
- en: The scope of the values is local. In this example, you can only reference an `enum`
    value with the syntax `Message::Type::WORKER_REGISTER`; no more `Message::WORKER_REGISTER`
    shortcuts. The good thing about this restriction is that you do not need to prefix `enum`
    values with a `MESSAGE_TYPE_` to be sure that the name does not conflict with
    anything else.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no implicit conversion to `int`. The `enum` class acts like a real
    type, to cast an `enum` class to `int`, you have to write `static_cast<int>( Message::Type::WORKER_REGISTER)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is no forward declaration. You can specify that an `enum class` is a
    char type (with the syntax `enum class Test : char { ... }`), but the compiler
    will not be able to deduce the `enum` class size with a forward declaration. Therefore,
    it has been simply forbidden.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We tend to use the `enum` class whenever possible, meaning when it does not
    clash with Qt `enum` usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, a message has only two members:'
  prefs: []
  type: TYPE_NORMAL
- en: '`type`: This is the message type we just described'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data`: This is an opaque type that contains the piece of information to be
    transmitted'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We chose to make `data` very generic to place the responsibility of serializing/deserializing
    on the `Message` callers. Based on the message `type`, they should know how to
    read or write the message content.
  prefs: []
  type: TYPE_NORMAL
- en: By using this approach, we avoid a tangled class hierarchy with `MessageRegister`, `MessageUnregister`,
    and so on. Adding a new `Message type` is simply adding a value in the `Type enum
    class` and doing the proper serialization/deserialization in `data` (which you
    have to do anyway).
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the file in Qt Creator, do not forget to add the `Message.h` in `ch10-mandelbrot-ipc.pro`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The next header we will look at is `JobRequest.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This `struct` element contains all the necessary data for the worker to calculate
    a line of the target Mandelbrot picture. Because the application and the worker(s)
    will live in different memory spaces (or even different physical machines), the
    parameters to calculate the Mandelbrot set have to be transmitted somehow. This
    is the purpose of `JobRequest`. The meaning of each field is the same as `JobResult`
    from [Chapter 9](part0090.xhtml#aid-2LQIK2 "Chapter 9.  Keeping Your Sanity with
    Multithreading"), *Keeping Your Sanity with Multithreading*.
  prefs: []
  type: TYPE_NORMAL
- en: Note the presence of the `Q_DECLARE_METATYPE(JobRequest)` macro. This macro
    is used to let the Qt meta-object system know about `JobRequest`. This is needed
    to be able to use the class in conjunction with `QVariant`. We will not use `QVariant`
    directly, but rather through the use of `QDataStream` which relies on `QVariant`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Speaking of `JobResult`, here is the new `JobResult.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The new version is a shameless copy-paste (with the small `Q_DECLARE_METATYPE`
    addition) of the project example of [Chapter 9](part0090.xhtml#aid-2LQIK2 "Chapter 9. 
    Keeping Your Sanity with Multithreading"), *Keeping Your Sanity with Multithreading*.
  prefs: []
  type: TYPE_NORMAL
- en: Working with QDataStream and QTcpSocket
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The missing piece of the SDK is `MesssageUtils`. It deserves a dedicated section
    because it covers two major topics: serialization and `QDataStream` transactions.'
  prefs: []
  type: TYPE_NORMAL
- en: We will start with the serialization. We already know that `Message` stores
    only an opaque `QByteArray` data member. As a consequence, the desired data has
    to be serialized as a `QByteArray` before being passed to `Message`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we take the example of a `JobRequest` object, it is not directly sent. We
    first put in in a generic `Message` object with the appropriate `Message` type.
    The following diagram summarizes the sequence of actions to be done:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with QDataStream and QTcpSocket](img/image00438.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The `JobRequest` object is first serialized to a `QByteArray` class; it is then
    passed to a `Message` instance which is in turn serialized to a final `QByteArray`.
    The deserialization process is the exact mirror of this sequence (from right to
    left).
  prefs: []
  type: TYPE_NORMAL
- en: Serializing data brings a lot of questions. How can we do it in a generic fashion?
    How do we handle the possible endianness of the CPU architecture? How do we specify
    the length of the data to be able to deserialize it properly?
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, the Qt folks did a great job and provided us a great tool to deal
    with these issues: `QDataStream`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `QDataStream` class enables you to serialize binary data to any `QIODevice`
    (`QAbstractSocket`, `QProcess`, `QFileDevice`, `QSerialPort`, and so on). The
    great advantage of `QDataStream` is that it encodes the information in a platform-agnostic
    format. You do not have to worry about the byte order, the operating system, or
    the CPU.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `QDataStream` class implements the serialization of C++ primitive types
    and several Qt type (`QBrush`, `QColor`, `QString`, and so on). Here is an example
    of a basic write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `QDataStream` relies on the overload of the `<<` operator to
    write data. To read information, open the file with the correct mode and read
    with the `>>` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to our case; we want to serialize custom classes, like `JobRequest`. To
    do so, we have to overload the `<<` operator for `JobRequest`. The signature of
    the function will be like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: What we write have here is that we want to overload the `out << jobRequest`
    operator call with our custom version. By doing so, we intend to fill the `out`
    object with the content of `jobRequest`. Because `QDataStream` already supports
    the serialization of primitive types, all we have to do is serialize them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the updated version of `JobRequest.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We include `QDataStream` and overload the `<<` very easily. The returned `out`
    will be updated with the platform-agnostic content of the passed `jobRequest`.
    The `>>` operator overload follows the same pattern: we fill the `jobRequest`
    parameter with the content of the `in` variable. Behind the scenes, `QDataStream`
    stores the variable size in the serialized data to be able to read it afterwards.'
  prefs: []
  type: TYPE_NORMAL
- en: Be careful to serialize and deserialize the members in the same order. If you
    do not pay attention to this, you might encounter very peculiar values in `JobRequest`.
  prefs: []
  type: TYPE_NORMAL
- en: The `JobResult` operators overload follows the same pattern, and it does not
    deserve to be included in the chapter. Look at the source code of the project
    if you have any doubt about its implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, `Message` operator overload needs to be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Because the `Message::Type enum class` signal does not have an implicit conversion
    to `int`, we need to explicitly convert it to be able to serialize it. We know
    that there will not be more than 255 message types, therefore we can safely cast
    it to a `qint8` type.
  prefs: []
  type: TYPE_NORMAL
- en: The same story applies to the reading part. We start by declaring a `qint8 type`
    variable that will be filled with `in >> type`, and then, the `type` variable
    is casted to a `Message::Type` in `message`.
  prefs: []
  type: TYPE_NORMAL
- en: Our SDK classes are ready to be serialized and deserialized. Let's see it in
    action in `MessageUtils` with the serialization of a message and its writing to
    a `QTcpSocket` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Always in the `sdk` directory, create a `MessageUtils.h` header with the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: There is no need to instantiate a `MessageUtils` class, as it does not hold
    any state. Here we used a `MessageUtils` namespace to simply protect our function
    against any name collision.
  prefs: []
  type: TYPE_NORMAL
- en: 'The meat of the snippet lies in `sendMessage()`. Let''s look at the parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`socket`: This is the `QTcpSocket` class in which the message will be sent.
    It is the responsibility of the caller to ensure that it is properly opened.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`messageType`: This is the type of the message to be sent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data`: This is the serialized data to be included in the message. It is a `QByteArray`
    class, meaning that the caller already serialized its custom class or data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`forceFlush`: This is a flag to force the socket to flush upon the message
    shipment. The OS keeps socket buffers that wait to be filled before being sent
    across the wire. Some messages need to be delivered immediately, like an abort
    all jobs message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the function itself, we start by creating a message with the passed parameters.
    Then, a `QByteArray` class is created. This `byteArray` will be the receptacle
    of the serialized data.
  prefs: []
  type: TYPE_NORMAL
- en: As a matter of fact, `byteArray` is passed in the constructor of the `QDataStream`
    stream, which is opened in the `QIODevice::WriteOnly` mode. It means that the
    stream will output its data to the `byteArray`.
  prefs: []
  type: TYPE_NORMAL
- en: After that, the message is elegantly serialized to stream with `stream << message`
    and the modified `byteArray` is written to the socket with `socket.write(byteArray)`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if the `forceFlush` flag is set to `true`, the socket is flushed with `socket.flush()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some messages will not have any payload associated. For this reason, we add
    a small helper function for this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now that the `sendMessage()` is done, let's turn to the `readMessages()`. Because
    we are working in IPC and more specifically with sockets, interesting issues arise
    when we want to read and parse messages.
  prefs: []
  type: TYPE_NORMAL
- en: When something is ready to be read in the socket, a signal will notify us. But
    how do we know how much to read? In the case of a `WORKER_DISCONNECT` message,
    there is no payload. On the other hand, a `JOB_RESULT` message can be very heavy.
    Even worse, several `JOB_RESULT` messages can line up in the socket, waiting to
    be read.
  prefs: []
  type: TYPE_NORMAL
- en: To make things more difficult, we have to acknowledge the fact that we are working
    with the network. Packets can be lost, retransmitted, incomplete or whatever.
    Sure, TCP ensures that we eventually get all of the information, but it can be
    delayed.
  prefs: []
  type: TYPE_NORMAL
- en: If we had to do it ourselves, it would have implied a custom message header,
    with a payload size and a footer for each message.
  prefs: []
  type: TYPE_NORMAL
- en: 'A feature introduced in Qt 5.7 comes to the rescue: `QDataStream` transaction.
    The idea is the following: when you start reading on a `QIODevice` class, you
    already know how much you have to read (based on the size of the object you want
    to fill). However, you might not get all the data in a single read.'
  prefs: []
  type: TYPE_NORMAL
- en: If the read is not complete, `QDataStream` stores what was already read in a
    temporary buffer and restores it upon the next read. The next read will contain
    what was already loaded plus the content of the new read. You can see it as a
    checkpoint in the read stream that can be loaded later.
  prefs: []
  type: TYPE_NORMAL
- en: 'This process can be repeated until data is read. The official documentation
    provides a simple enough example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the `QDataStream` class in which we want to read, `in.startTransaction()`
    marks the checkpoint in the stream. It will then try to read  `messageType` and `messageData` atomically.
    If it cannot do it, `in.commitTransaction()` returns `false` and the read data
    is copied in an internal buffer.
  prefs: []
  type: TYPE_NORMAL
- en: Upon the next call to this code (more data to read), `in.startTransaction()`
    will restore the preceding buffer and try to finish the atomic read.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `readMessages()` situation, we can receive several messages at once.
    This is why the code is a bit more complex. Here is the updated version of `MessageUtils`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the function, the parameter is only a `QDataStream`. We assume that the caller
    linked the stream with the socket with `stream.setDevice(socket)`.
  prefs: []
  type: TYPE_NORMAL
- en: Because we do not know the length of the content to be read, we prepare ourselves
    to read several messages. To explicitly indicate ownership and avoid any memory
    leaks, we return a `vector<unique_ptr<Message>>`. This `vector` has to be a `unique_ptr`
    pointer to be able to allocate it on the heap and avoid any copy during the return
    of the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the function itself, we start by declaring the `vector`. After that, a `while`
    loop is executed. The two conditions to stay in the loop are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`commitTransaction == true`: This an atomic read in the stream that has been
    performed; a complete `message` has been read'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stream.device().bytesAvailable() > 0`: This states that there is still data
    to read in the stream'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `while` loop, we start by marking the stream with `stream.startTransaction()`.
    After that, we try to perform an atomic read of a `*message` signal and see the
    result with `stream.commitTransaction()`. If it succeeded, the new `message` is
    added to the `messages` vector. This is repeated until we read all the content
    of the stream with the `bytesAvailable() > 0` test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s study a use case to understand what will happen. Consider that we receive
    multiple messages in `readMessages()`:'
  prefs: []
  type: TYPE_NORMAL
- en: The `stream` object will try to read it into `message`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `commitTransaction` variable will be set to `true` and the first message
    will be added to `messages`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there are still bytes to read in the `stream`, repeat from step one. Otherwise,
    exit the loop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To sum up, working with sockets raises its own set of questions. On one hand,
    it is a very powerful IPC mechanism with a lot of flexibility. On the other hand,
    it brings a lot of complexity due the nature of the network itself. Luckily, Qt
    (and moreover Qt 5.7) brings great classes to help us.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that we tolerate the `QDataStream` serialization and transactions
    overhead because it fits well to our need. If you are working on a constrained
    embedded platform, you might not have so much liberty about serializing overhead
    and buffer copies. However, you will still have to rebuild messages by hand for
    incoming bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with sockets in the worker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that the SDK is completed, we can turn to the worker. The project is complex
    enough; we can refresh our memory with the `mandelbrot-worker` architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Interacting with sockets in the worker](img/image00439.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We will start by implementing the `Job` class. Inside the `mandelbrot-worker`
    project, create a new C++ class named `Job`. Here is the `Job.h` content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If you remember the `Job` class from [Chapter 9](part0090.xhtml#aid-2LQIK2 "Chapter 9. 
    Keeping Your Sanity with Multithreading"), *Keeping Your Sanity with Multithreading*,
    this header should ring a bell. The only difference is that the parameters of
    the job (area size, scale factor, and so on) are extracted from the `JobRequest`
    object rather than stored directly as member variables.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the `JobRequest` object is provided in the constructor of `Job`.
    We will not cover `Job.cpp`, as it is very much like the version of it in [Chapter
    9](part0090.xhtml#aid-2LQIK2 "Chapter 9.  Keeping Your Sanity with Multithreading"), *Keeping
    Your Sanity with Multithreading*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now proceed to the `Worker` class. This class has the following roles:'
  prefs: []
  type: TYPE_NORMAL
- en: It interacts with the `mandelbrot-app` using a `QTcpSocket` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It dispatches `JobRequests` to a `QThreadPool` class, aggregates the results,
    and sends them back to `mandelbrot-app` application through the `QTcpSocket` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will start by studying the interaction with the `QTcpSocket` class. Create
    a new class named `Worker` with the following header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Worker` class is the owner of `mSocket`. The first thing we will implement
    is the connection with `mandelbrot-app`. Here is the constructor of `Worker` in `Worker.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor initializes `mSocket` with `this` as the parent and it then
    proceeds to connecting the relevant `mSocket` signals to lambdas:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QTcpSocket::connected`: When the socket is connected, it will send its register
    message. We will soon cover this function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QTcpSocket::disconnected`: When the socket is disconnected, it simply prints
    a message in the console'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, `mSocket` tries to connect on the `localhost` on the port `5000`. In
    the code example, we assume that you execute the worker and the application on
    the same machine. Feel free to change this value if you run the worker and the
    application on different machines.
  prefs: []
  type: TYPE_NORMAL
- en: 'The body of `sendRegister()` function looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: A `QByteArray` class is filled with the `idealThreadCount` function of the worker's
    machine. After that, we call `MessageUtils::sendMessage` to serialize the message
    and send it through our `mSocket`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the worker is registered, it will start to receive job requests, process
    them, and send job results back. Here is the updated `Worker.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s review the role of each one of these new members:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mSocketReader`: This is the `QDataStream` class through which we will read `mSocket`
    content. It will be passed as a parameter to our `MessageUtils::readMessages()`
    function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mReceivedJobsCounter`: This is incremented each time a new `JobRequest` is
    received from `mandelbrot-app`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mSentJobsCounter`: This is incremented each time a new `JobResult` is sent
    to `mandelbrot-app`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now for the new functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`abortAllJobs()`: This is a signal emitted when the `Worker` class receives
    the appropriate message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`readMessages()`: This is the slot called each time there is something to read
    in `mTcpSocket`. It parses the messages and, for each message type, it will call
    the corresponding function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`handleJobRequest()`: This function creates and dispatches a `Job` class according
    to the `JobRequest` object contained in the message parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`handleAllJobsAbort()`: This function cancels all the current jobs and clear
    the thread queue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sendJobResult()`: This function sends the `JobResult` object to `mandelbrot-app`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sendUnregister()`: This function sends the unregister message to `mandelbrot-app`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`createJob()`: This is a helper function to create and properly connect the
    signals of a new `Job`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The header is now complete. We can proceed to the updated constructor in `Worker.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `QDataStream mSocketReader` variable is initialized with the address of `mSocket`.
    This means that it will read its content from the `QIODevice` class. After that,
    we add the new connect to the `QTcpSocket` signal, `readyRead()`. Each time that
    data is available to read on the socket, our slot, `readMessages()`, will be called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the implementation of `readMessages()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The messages are parsed with the `MessageUtils::readMessages()` function. Note
    the use of C++11 semantics with `auto`, which elegantly hides the smart pointers
    syntax and still handles the memory for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each parsed `message`, it is handled in the `switch` case. Let''s review 
    `handleJobRequest()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In this function, the `message` object is already deserialized. However, `message.data`
    still needs to be deserialized. To achieve this, we create a `QDataStream` in
    a variable that will read from `message.data`.
  prefs: []
  type: TYPE_NORMAL
- en: From here, we parse the requests `QList`. Because `QList` already overrides
    the `>>` operator, it works in cascade and calls our `JobRequest >>` operator
    overload. Deserializing data has never been so easy!
  prefs: []
  type: TYPE_NORMAL
- en: After that, we increment `mReceivedJobsCounter` and start processing these 
    `JobRequests`. For each one, we create a `Job` class and dispatch it to the global `QThreadPool`
    class. If you have a doubt about `QThreadPool`, get back to [Chapter 9](part0090.xhtml#aid-2LQIK2
    "Chapter 9.  Keeping Your Sanity with Multithreading"), *Keeping Your Sanity with
    Multithreading*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `createJob()` function is straightforward to implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: A new `Job` class is created and its signals are properly connected. When `Worker::abortAllJobs`
    is emitted, every running `Job` should be canceled with the `Job::abort` slot.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second signal, `Job::jobCompleted` is emitted when the `Job` class has
    finished calculating its values. Let''s see the connected slot, `sendJobResult()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We first increment the `mSentJobsCounter` and then serialize the `JobResult`
    to a `QByteArray` data which is passed `to MessageUtils::sendMessage()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We completed the tour of the `JobRequest` handling and the following `JobResult`
    shipment. We still have to cover `handleAllJobsAbort()`, which is called from `readMessages()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `abortAllJobs()` signal is emitted first to tell all the running jobs to
    cancel their process. After that, the `QThreadPool` class is cleared and the counters
    are reset.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last piece of `Worker` is the `sendUnregister()`, which is called in the `Worker`
    destructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `sendUnregister()` function just calls `sendMessage` without any data to
    serialize. Note that it passes the `forceFlush` flag to `true` to make sure that
    the socket is flushed and that `mandelbrot-app` application will receive the message
    as fast as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Worker` instance will be managed by a widget which will display the progress
    of the current calculation. Create a new class named `WorkerWidget` and update
     `WorkerWidget.h`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The members of `WorkerWidget` are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mStatus`: The `QProgressBar` that will display the percentage of processed `JobRequests`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mWorker`: The `Worker` instance owned and started by `WorkerWidget`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mWorkerThread`: The `QThread` class in which `mWorker` will be executed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mRefreshTimer`: The `QTimer` class that will periodically poll `mWorker` to
    know the process advancement'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can proceed to `WorkerWidget.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: First, the `mStatus` variable is added to the `WorkerWidget` layout. Then the `mWorker`
    thread affinity is moved to `mWorkerThread` and `mRefreshTimer` is configured
    to poll `mWorker` and update `mStatus` data.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, `mWorkerThread` is started, triggering the `mWorker` process. The `mRefreshTimer`
    object is also started with an interval of 100 milliseconds between each timeout.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing to cover in `mandelbrot-worker` is the `main.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We start by registering `JobResult` with `qRegisterMetaType` because it is used
    in the signal/slot mechanism. After that, we instantiate a `WorkerWidget` layout
    and display it.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with sockets from the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next project to complete is `mandelbrot-app`. It will contain the `QTcpServer`
    that will interact with the workers and the picture drawing of the Mandelbrot
    set. As a reminder, the diagram of the `mandelbrot-app` architecture is shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Interacting with sockets from the application](img/image00440.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We will build this application from the ground up. Let''s start with the class
    responsible for maintaining the connection with a specific `Worker: WorkerClient`.
    This class will live in its specific `QThread` and will interact with a `Worker`
    class using the same  `QTcpSocket`/`QDataStream` mechanism we covered in the last
    section.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `mandelbrot-app`, create a new C++ class named `WorkerClient` and update 
    `WorkerClient.h` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: It looks very similar to `Worker`. Yet it may behave differently from a life
    cycle point of view. Each time a new `Worker` connects to our `QTcpServer`, a
    new `WorkerClient` will be spawned with an associated `QThread`. The `WorkerClient`
    object will take the responsibility of interacting with the `Worker` class through
    the `mSocket`.
  prefs: []
  type: TYPE_NORMAL
- en: If the `Worker` disconnects, the `WorkerClient` object will be deleted and removed
    from the `QTcpServer` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review the content of this header, starting with the members:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mSocketDescriptor`: This is the unique integer assigned by the system to interact
    with the socket. `stdin`, `stdout`, and `stderr` are also descriptors that point
    to specific streams in your application. For a given socket, the value will be
    retrieved in `QTcpServer`. More on this later on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mCpuCoreCount`: This is the CPU core count for the connected `Worker`. This
    field will be initialized when the `Worker` sends the `WORKER_REGISTER` message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mSocket`: This is the `QTcpSocket` used to interact with the `Worker` class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mSocketReader`: This has the same role it had in `Worker` - it reads `mSocket`
    content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we can add the functions to `WorkerClient.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see what each function does:'
  prefs: []
  type: TYPE_NORMAL
- en: '`WorkerClient()`: This function expects a `socketDescriptor` as a parameter.
    As a consequence, a `WorkerClient` function cannot be initialized without a valid
    socket.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cpuCoreCount()`: This function is a simple getter to let the owner of `WorkerClient`
    know how many cores the `Worker` has.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The class has three signals:'
  prefs: []
  type: TYPE_NORMAL
- en: '`unregister()`: This is the signal sent by `WorkerClient` when it has received
    the `WORKER_UNREGISTER` message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jobCompleted()`: This is the signal sent by `WorkerClient` when it has received
    the `JOB_RESULT` message. It will pass by copying the deserialized `JobResult`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sendJobRequests()`: This is emitted from the owner of `WorkerClient` to pass `JobRequests`
    in a queued connection to the proper slot:  `doSendJobRequests()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the details of the slots:'
  prefs: []
  type: TYPE_NORMAL
- en: '`start()`: This slot is called when `WorkerClient` can start its process. Typically,
    it will be connected to the `start` signal of the `QThread` associated with the `WorkerClient`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`abortJob()`: This slot triggers the shipment of the `ALL_JOBS_ABORT` message
    to the `Worker`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`readMessages()`: This slot is called each time there is something to read
    in the socket.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`doSendJobRequests()`: This slot is the real slot that triggers the shipment
    of the `JobRequests` to the `Worker`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And finally, here are the details of the private functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`handleWorkerRegistered()`: This function processes the `WORKER_REGISTER` message
    and initializes `mCpuCoreCount`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`handleWorkerUnregistered()`: This function processes the `WORKER_UNREGISTER`
    message and emits the `unregistered()` signal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`handleJobResult()`: This function processes the `JOB_RESULT` message and dispatches
    the content through the `jobCompleted()` signal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The implementation in `WorkerClient.cpp` should be quite familiar. Here is
    the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The fields are initialized in the initialization list and the `sendJobRequests`
    signal is connected to the private slot, `doSendJobRequests`. This trick is used
    to still have a queued connection across threads while avoiding multiple functions
    declarations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will proceed with the `start()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This is very short indeed. It first connects the `readyRead()` signal from the
    socket to our `readMessages()` slot. After that, `mSocket` is properly configured
    with  `mSocketDescriptor`.
  prefs: []
  type: TYPE_NORMAL
- en: The connect has to be done in `start()` because it should be executed in the `QThread`
    class associated with our `WorkerClient`. By doing so, we know that the connect
    will be a direct connection and that `mSocket` will not have to queue signals
    to interact with `WorkerClient`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that at the end of the function, the associated `QThread` is not terminated.
    On the contrary, it is executing its event loop with `QThread::exec()`. The `QThread`
    class will continue to run its event loop until someone calls `QThread::exit()`.
  prefs: []
  type: TYPE_NORMAL
- en: The only purpose of the `start()` function is to do the `mSocket` connect work
    in the right thread affinity. After that, we rely solely on the Qt signal/slot
    mechanism to process data. There is no need for a busy `while` loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `readMessages()` class is waiting for us; let''s see it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: No surprises here. It's exactly like we did for `Worker`. The `Messages` are
    deserialized using `MessageUtils::readMessages()` and, for each message type,
    the appropriate function is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the content of each of these functions, starting with `handleWorkerRegistered()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: For the `WORKER_REGISTER` message, `Worker` only serialized an `int` in `message.data`,
    so we can initialize `mCpuCoreCount` on the spot with `in >> mCpuCoreCount`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the body of `handleWorkerUnregistered()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: It is a relay to send the `unregistered()` signal, which will be picked up by
    the owner of `WorkerClient`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last "read" function is `handleJobResult()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This is deceptively short. It only deserializes the `jobResult` component from `message.data`
    and emits the `jobCompleted()` signal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The "write-to-socket" functions are `abortJob()` and `doSendJobRequest()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The `abortJob()` function sends the `ALL_JOBS_ABORT` message with the `forceFlush`
    flag set to `true` and `doSendJobRequests()` serializes the `requests` to stream
    before sending them using `MessageUtils::sendMessage()`.
  prefs: []
  type: TYPE_NORMAL
- en: Building your own QTcpServer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Everything is ready to read and write in our sockets. We still need a server
    to orchestrate all these instances. To do so, we will develop a modified version
    of the `MandelbrotCalculator` class, which was covered in [Chapter 9](part0090.xhtml#aid-2LQIK2
    "Chapter 9.  Keeping Your Sanity with Multithreading"), *Keeping Your Sanity with
    Multithreading*.
  prefs: []
  type: TYPE_NORMAL
- en: The idea is to respect the same interface, in order to have `MandelbrotWidget`
    oblivious to the fact that the Mandelbrot picture generation is deported on different
    processes/machines.
  prefs: []
  type: TYPE_NORMAL
- en: The main difference between the old `MandelbrotCalculator` and the new one is
    that we replaced the `QThreadPool` class by a `QTcpServer`. The `MandelbrotCalculator`
    class now only has the responsibility to dispatch `JobRequests` to Workers and
    aggregate the result, but it never interacts anymore with a `QThreadPool` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new C++ class named `MandelbrotCalculator.cpp` and update  `MandelbrotCalculator.h`
    to match this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The modified (or new) data is highlighted. First, note that the class now inherits
    from `QTcpServer` rather than `QObject`. The `MandelbrotCalculator` class is now
    a `QTcpServer` and is able to accept and manage connections. Before digging into
    this topic, we can review the new members:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mWorkerClients`: This is a `QMap` that stores the pair `WorkerClient` and `QThread`.
    Each time a `WorkerClient` is created, an associated `QThread` is also spawned
    and both of them are stored in `mWorkerClients`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mJobRequests`: This is the list of `JobRequests` for the current picture.
    Each time a picture generation is requested, the full list of `JobRequest` is
    generated, ready to be dispatched to `WorkerClients` (that is, to the `Worker`
    on the other side of the socket).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And the functions are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`process()`: This function is a slightly modified version of the one seen in [Chapter
    9](part0090.xhtml#aid-2LQIK2 "Chapter 9.  Keeping Your Sanity with Multithreading"), *Keeping
    Your Sanity with Multithreading*. It not only aggregates `JobResults` before sending
    them with the `pictureLinesGenerated()` signal, but also dispatches `JobRequest`
    to the passed `WorkerClient` to keep them busy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`removeWorkerClient()`: This function removes and deletes the given `WorkerClient`
    from `mWorkerClients`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`incomingConnection()`: This function is an overloaded function from `QTcpServer`.
    It is called each time a new client tries to connect to `MandelbrotCalculator`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`createJobRequest()`: This is a helper function that creates a `JobRequest`
    that is added to `mJobRequests`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sendJobRequests()`: This function is responsible for sending a list of `JobRequests`
    to the specified `WorkerClient`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s turn to `MandelbrotCalculator.cpp` with the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This is the common initialization list with the `listen()` instruction in the
    body. Because we are subclassing `QTcpServer`, we can call listen on ourselves.
    Note that `QHostAddress::Any` works either for IPv4 and IPv6.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the overloaded function, `incomingConnection()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Once `listen()` has been called, each time someone connects to our ip/port pair, `incomingConnection()`
    will be triggered with `socketDescriptor` passed as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can test this on your machine connection with a simple `telnet 127.0.0.1
    5000` command. You should see the `Connected workerClient` log in `mandelbrot-app`.
  prefs: []
  type: TYPE_NORMAL
- en: We start by creating a `QThread` class and a `WorkerClient`. This pair is immediately
    inserted in the `mWorkerClients` map and `client` thread affinity is changed to `thread`.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we do all the connects to manage the `client` (`abortJob`, `unregister`,
    and `jobCompleted`). We continue with the `QThread::started()` signal, which is
    connected to the `WorkerClient::start()` slot and finally, `thread` is started.
  prefs: []
  type: TYPE_NORMAL
- en: The last part of the function is used to trigger a picture generation upon the
    first `client` connection. If we did not do this, the screen would have remained
    black until we panned or zoomed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have covered the `WorkerClient` creation; let''s finish its life cycle with
    its destruction with `removeWorkerClient()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The `workerClient`/`thread` pair is removed from `mWorkerClients` and cleanly
    deleted. Note that this function can be called from the `WorkerClient::unregistered`
    signal or in the `MandelbrotCalculator` destructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: When `MandelbrotCalculator` is deleted, `mWorkerClients` has to be properly
    emptied. The iterator style `while` loop does a good job of calling  `removeWorkerClient()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this new version of `MandelbrotCalculator`, `generatePicture()` does not
    have exactly the same behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The beginning is the same. However, the end is quite different. Rather than
    creating `Jobs` and giving them to a `QThreadPool`, `MandelbrotCalculator` now:'
  prefs: []
  type: TYPE_NORMAL
- en: Creates `JobRequests` to generate the whole picture. Note that they are created
    in reverse order. We will soon see why.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dispatches a number of `JobRequests` to each `WorkerClient` it owns.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second point deserves a strong emphasis. If we want to maximize the speed
    of our system, we have to use multiple workers, each one having multiple cores
    to process multiple jobs at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Even though a `Worker` class can process multiple jobs at the same time, it
    can only send us `JobResults` one by one (through `WorkerClient::jobCompleted`).
    Each time we process a `JobResult` object from a `WorkerClient`, we will dispatch
    a single  `JobRequest` to it.
  prefs: []
  type: TYPE_NORMAL
- en: Assume that the `Worker` class has eight cores. If we send `JobRequests` one
    by one, the `Worker` will always have seven cores idle. We are here to heat up
    your CPUs, not to let them drink mojitos on the beach!
  prefs: []
  type: TYPE_NORMAL
- en: 'To mitigate this, the first batch of `JobResults` we send to a worker has to
    be higher than its `coreCount()`. By doing so, we ensure that is always has a
    queue of  `JobRequests` to process until we generate the whole picture. This is
    why we send  `client->cpuCoreCount() * two` initial `JobRequests`. If you play
    with this value, you will see that:'
  prefs: []
  type: TYPE_NORMAL
- en: If `jobCount < cpuCoreCount()`, some cores of your `Worker` will be idle and
    you will not leverage the full power of its CPU
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `jobCount > cpuCoreCount()` by too much, you might overload the queue of
    one your `Workers`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that this system is flexible enough to have multiple workers. If you
    have a RaspberryPI and an x86 with 16 cores, the RaspberryPI will lag behind the
    x86 CPU. By giving too much initial `JobRequests`, the RaspberryPI will hinder
    the whole picture generation while the x86 CPU has already finished all its jobs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s cover the remaining functions of `MandelbrotCalculator`, starting with 
    `createJobRequest()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This is a simple creation of a `jobRequest` with the member fields of  `MandelbrotCalculator`.
    Again, we use `unique_ptr` to explicitly indicate the ownership of `jobRequest`
    and avoid any memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, with `sendJobRequests()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Because we can send multiple `JobRequests` at the same time, we loop on  `jobRequestCount`
    by taking the last `jobRequest` of `mJobRequests` and adding it to `listJobRequest`.
    This is the reason for which we had to fill `mJobRequests` in the reverse order.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `client.sendJobRequests()` signal is emitted, which in turns triggers
    the `WorkerClient::doSendJobRequests()` slot.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now going to see the modified version of `process()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: In this version, we pass `workerClient` as a parameter. This is used at the
    end of the function, to be able to dispatch a new `JobRequest` to the given `workerClient`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the updated version of `abortAllJobs()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This simply cleared `mJobRequests` instead of emptying `QThreadPool`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MandelbrotCalculator` class is completed! You can copy and paste  `MandelBrotWidget`
    and `MainWindow` (`.ui` file included) from [Chapter 9](part0090.xhtml#aid-2LQIK2
    "Chapter 9.  Keeping Your Sanity with Multithreading"), *Keeping Your Sanity with
    Multithreading*. We designed it to be plug and play, without knowing who generates
    the picture: a local `QThreadPool` with `QRunnable` or minions through an IPC
    mechanism.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is only a tiny difference in `main.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: You can now launch `mandelbrot-app` and after that, the one or many `mandelbrot-worker` programs
    that will connect to the application. It should automatically trigger a picture
    generation. The Mandelbrot picture generation is now working across multiple processes!
    Because we chose to use sockets, you can start the application and the workers
    on different physical machines.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using IPv6, you may very easily test the app/worker connection in different
    locations. If you do not have a high-speed Internet connection, you will see how
    the network hinders the picture generation.
  prefs: []
  type: TYPE_NORMAL
- en: You may want to take some time to deploy the application on multiple machines
    and see how this cluster works together. During our tests, we ramped up our cluster
    up to 18 cores with very heterogeneous machines (PC, laptop, Macbook, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IPC is a fundamental mechanism in computer science. In this chapter, you learned
    the various techniques offered by Qt to do IPC and how to create an application
    that uses sockets to interact, send, and receive commands. You took the original
    `mandelbrot-threadpool` application to the next level by enabling it to generate
    pictures on a cluster of machines.
  prefs: []
  type: TYPE_NORMAL
- en: Adding IPC on top of a multi-threaded application brings some issues. You have
    many more possible bottlenecks, chances of leaking memory, and have an inefficient
    calculation. Qt provides multiple mechanisms to do IPC. In Qt 5.7, the addition
    of transactions makes the serialization/deserialization part much easier.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will discover the Qt Multimedia framework and how to
    save and load an C++ object from a file. The project example will be a virtual
    drum machine. You will be able to save and load your tracks.
  prefs: []
  type: TYPE_NORMAL
