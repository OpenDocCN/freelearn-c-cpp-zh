["```cpp\nTEST(\"Simple message can be logged\")\n{\n    std::string message = \"simple \";\n    message += Util::randomString();\n    MereMemo::log() << message << \" with more text.\";\n    bool result = Util::isTextInFile(message,     \"application.log\");\n    CONFIRM_TRUE(result);\n}\nTEST(\"Complicated message can be logged\")\n{\n    std::string message = \"complicated \";\n    message += Util::randomString();\n    MereMemo::log() << message\n        << \" double=\" << 3.14\n        << \" quoted=\" << std::quoted(\"in quotes\");\n    bool result = Util::isTextInFile(message,     \"application.log\");\n    CONFIRM_TRUE(result);\n}\n```", "```cpp\n#include \"../Log.h\"\n#include \"LogTags.h\"\n#include \"Util.h\"\n#include <MereTDD/Test.h>\nTEST(\"Message can be tagged in log\")\n{\n    std::string message = \"simple tag \";\n    message += Util::randomString();\n    MereMemo::log(error) << message;\n    std::string taggedMessage = \" log_level=\\\"error\\\" \";\n    taggedMessage += message;\n    bool result = Util::isTextInFile(taggedMessage,          \"application.log\");\n    CONFIRM_TRUE(result);\n}\n```", "```cpp\nkey=\"value\"\n```", "```cpp\nlog_level=\"error\"\n```", "```cpp\n    MereMemo::log(\"Eror\") << message;\n```", "```cpp\n#ifndef MEREMEMO_TESTS_LOGTAGS_H\n#define MEREMEMO_TESTS_LOGTAGS_H\n#include \"../Log.h\"\ninline MereMemo::LogLevel error(\"error\");\ninline MereMemo::LogLevel info(\"info\");\ninline MereMemo::LogLevel debug(\"debug\");\n#endif // MEREMEMO_TESTS_LOGTAGS_H\n```", "```cpp\n    MereMemo::log(error) << message;\n```", "```cpp\n    MereMemo::log(MereMemo::error) << message;\n```", "```cpp\n#ifndef YOUR_PROJECT_LOGTAGS_H\n#define YOUR_PROJECT_LOGTAGS_H\n#include <MereMemo/Log.h>\nnamespace yourproject\n{\ninline MereMemo::LogLevel error(\"error\");\ninline MereMemo::LogLevel info(\"info\");\ninline MereMemo::LogLevel debug(\"debug\");\n} // namespace yourproject\n#endif // YOUR_PROJECT_LOGTAGS_H\n```", "```cpp\nTEST(\"log needs no namespace when used with LogLevel\")\n{\n    log(error) << \"no namespace\";\n}\n```", "```cpp\nclass Tag\n{\npublic:\n    virtual ~Tag () = default;\n    std::string key () const\n    {\n        return mKey;\n    }\n    std::string text () const\n    {\n        return mText;\n    }\nprotected:\n    Tag (std::string const & key, std::string const & value)\n    : mKey(key), mText(key + \"=\\\"\" + value + \"\\\"\")\n    { }\nprivate:\n    std::string mKey;\n    std::string const mText;\n};\nclass LogLevel : public Tag\n{\npublic:\n    LogLevel (std::string const & text)\n    : Tag(\"log_level\", text)\n    { }\n};\n```", "```cpp\ninline std::fstream log (Tag const & tag)\n{\n    return log(to_string(tag));\n}\n```", "```cpp\ninline std::string to_string (Tag const & tag)\n{\n    return tag.text();\n}\n```", "```cpp\ninline std::fstream log (std::string_view preMessage = \"\")\n{\n    auto const now = std::chrono::system_clock::now();\n    std::time_t const tmNow =          std::chrono::system_clock::to_time_t(now);\n    auto const ms = duration_cast<std::chrono::milliseconds>(\n        now.time_since_epoch()) % 1000;\n    std::fstream logFile(\"application.log\", std::ios::app);\n    logFile << std::endl\n        << std::put_time(std::gmtime(&tmNow),            \"%Y-%m-%dT%H:%M:%S.\")\n        << std::setw(3) << std::setfill('0')         << std::to_string(ms.count())\n        << \" \" << preMessage << \" \";\n    return logFile;\n}\n```", "```cpp\n    MereMemo::log(error) << message;\n```", "```cpp\nRunning 1 test suites\n--------------- Suite: Single Tests\n------- Test: Message can be tagged in log\nPassed\n------- Test: log needs no namespace when used with LogLevel\nPassed\n------- Test: Simple message can be logged\nPassed\n------- Test: Complicated message can be logged\nPassed\n-----------------------------------\nTests passed: 4\nTests failed: 0\n```", "```cpp\n2022-06-25T23:52:05.842 log_level=\"error\" simple tag 7529\n2022-06-25T23:52:05.844 log_level=\"error\" no namespace\n2022-06-25T23:52:05.844  simple 248 with more text.\n2022-06-25T23:52:05.844  complicated 637 double=3.14 quoted=\"in quotes\"\n```", "```cpp\ndouble = 3.14\n```", "```cpp\ndouble=3.14, quoted=\"in quotes\"\n```", "```cpp\n#include \"../Log.h\"\n#include \"LogTags.h\"\n#include <MereTDD/Test.h>\n#include <iostream>\nint main ()\n{\n    MereMemo::addDefaultTag(info);\n    MereMemo::addDefaultTag(green);\n    return MereTDD::runTests(std::cout);\n}\n```", "```cpp\nTEST(\"Default tags set in main appear in log\")\n{\n    std::string message = \"default tag \";\n    message += Util::randomString();\n    MereMemo::log() << message;\n    std::string logLevelTag = \" log_level=\\\"info\\\" \";\n    std::string colorTag = \" color=\\\"green\\\" \";\n    bool result = Util::isTextInFile(message,          \"application.log\",\n        {logLevelTag, colorTag});\n    CONFIRM_TRUE(result);\n}\n```", "```cpp\nTEST(\"Message can be tagged in log\")\n{\n    std::string message = \"simple tag \";\n    message += Util::randomString();\n    MereMemo::log(error) << message;\n    std::string logLevelTag = \" log_level=\\\"error\\\" \";\n    bool result = Util::isTextInFile(message,          \"application.log\",\n        {logLevelTag});\n    CONFIRM_TRUE(result);\n}\n```", "```cpp\n#include <string>\n#include <string_view>\n#include <vector>\nstruct Util\n{\n    static std::string randomString ();\n    static bool isTextInFile (\n        std::string_view text,\n        std::string_view fileName,\n        std::vector<std::string> const & wantedTags = {},\n        std::vector<std::string> const & unwantedTags = {});\n};\n```", "```cpp\nbool Util::isTextInFile (\n    std::string_view text,\n    std::string_view fileName,\n    std::vector<std::string> const & wantedTags,\n    std::vector<std::string> const & unwantedTags)\n{\n    std::ifstream logfile(fileName.data());\n    std::string line;\n    while (getline(logfile, line))\n    {\n        if (line.find(text) != std::string::npos)\n        {\n            for (auto const & tag: wantedTags)\n            {\n                if (line.find(tag) == std::string::npos)\n                {\n                    return false;\n                }\n            }\n            for (auto const & tag: unwantedTags)\n            {\n                if (line.find(tag) != std::string::npos)\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    return false;\n}\n```", "```cpp\ninline MereMemo::LogLevel error(\"error\");\ninline MereMemo::LogLevel info(\"info\");\ninline MereMemo::LogLevel debug(\"debug\");\nclass Color : public MereMemo::Tag\n{\npublic:\n    Color (std::string const & text)\n    : Tag(\"color\", text)\n    { }\n};\ninline Color red(\"red\");\ninline Color green(\"green\");\ninline Color blue(\"blue\");\n```", "```cpp\ninline void addDefaultTag (Tag const & tag)\n{\n    static std::map<std::string, Tag const *> tags;\n    tags[tag.key()] = &tag;\n}\n```", "```cpp\n#include <chrono>\n#include <ctime>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <string>\n#include <string_view>\n```", "```cpp\ninline std::map<std::string, std::unique_ptr<Tag>> & getDefaultTags ()\n{\n    static std::map<std::string, std::unique_ptr<Tag>> tags;\n    return tags;\n}\ninline void addDefaultTag (Tag const & tag)\n{\n    auto & tags = getDefaultTags();\n    tags[tag.key()] = tag.clone();\n}\n```", "```cpp\n    std::string text () const\n    {\n        return mText;\n    }\n    virtual std::unique_ptr<Tag> clone () const = 0;\nprotected:\n```", "```cpp\nclass LogLevel : public Tag\n{\npublic:\n    LogLevel (std::string const & text)\n    : Tag(\"log_level\", text)\n    { }\n    std::unique_ptr<Tag> clone () const override\n    {\n        return std::unique_ptr<Tag>(\n            new LogLevel(*this));\n    }\n};\n```", "```cpp\nclass Color : public MereMemo::Tag\n{\npublic:\n    Color (std::string const & text)\n    : Tag(\"color\", text)\n    { }\n    std::unique_ptr<Tag> clone () const override\n    {\n        return std::unique_ptr<Tag>(\n            new Color(*this));\n    }\n};\n```", "```cpp\nRunning 1 test suites\n--------------- Suite: Single Tests\n------- Test: Message can be tagged in log\nPassed\n------- Test: log needs no namespace when used with LogLevel\nPassed\n------- Test: Default tags set in main appear in log\nFailed confirm on line 37\n    Expected: true\n------- Test: Simple message can be logged\nPassed\n------- Test: Complicated message can be logged\nPassed\n-----------------------------------\nTests passed: 4\nTests failed: 1\n```", "```cpp\ninline auto log (Tag const & tag1)\n{\n    return log({&tag1});\n}\ninline auto log (Tag const & tag1,\n    Tag const & tag2)\n{\n    return log({&tag1, &tag2});\n}\ninline auto log (Tag const & tag1,\n    Tag const & tag2,\n    Tag const & tag3)\n{\n    return log({&tag1, &tag2, &tag3});\n}\n```", "```cpp\n#include <algorithm>\n#include <chrono>\n#include <ctime>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <string>\n#include <string_view>\n#include <vector>\n```", "```cpp\ninline std::fstream log (std::vector<Tag const *> tags = {})\n{\n    auto const now = std::chrono::system_clock::now();\n    std::time_t const tmNow =          std::chrono::system_clock::to_time_t(now);\n    auto const ms = duration_cast<std::chrono::milliseconds>(\n        now.time_since_epoch()) % 1000;\n    std::fstream logFile(\"application.log\", std::ios::app);\n    logFile << std::endl\n        << std::put_time(std::gmtime(&tmNow),            \"%Y-%m-%dT%H:%M:%S.\")\n        << std::setw(3) << std::setfill('0')         << std::to_string(ms.count());\n    for (auto const & defaultTag: getDefaultTags())\n    {\n        if (std::find_if(tags.begin(), tags.end(),\n            [&defaultTag](auto const & tag)\n            {\n                return defaultTag.first == tag->key();\n            }) == tags.end())\n        {\n            logFile << \" \" << defaultTag.second->text();\n        }\n    }\n    for (auto const & tag: tags)\n    {\n        logFile << \" \" << tag->text();\n    }\n    logFile << \" \";\n    return logFile;\n}\n```", "```cpp\n2022-06-26T06:24:26.607 color=\"green\" log_level=\"error\" simple tag 4718\n2022-06-26T06:24:26.609 color=\"green\" log_level=\"error\" no namespace\n2022-06-26T06:24:26.609 color=\"green\" log_level=\"info\" default tag 8444\n2022-06-26T06:24:26.609 color=\"green\" log_level=\"info\" simple 4281 with more text.\n2022-06-26T06:24:26.610 color=\"green\" log_level=\"info\" complicated 8368 double=3.14 quoted=\"in quotes\"\n```", "```cpp\nTEST(\"Message can be tagged in log\")\n{\n    std::string message = \"simple tag \";\n    message += Util::randomString();\n    MereMemo::log(error) << message;\n    // Confirm that the error tag value exists and that the\n    // default info tag value does not.\n    std::string logLevelTag = \" log_level=\\\"error\\\" \";\n    std::string defaultLogLevelTag = \" log_level=\\\"info\\\" \";\n    bool result = Util::isTextInFile(message,          \"application.log\",\n        {logLevelTag}, {defaultLogLevelTag});\n    CONFIRM_TRUE(result);\n}\n```", "```cpp\nclass Size : public MereMemo::Tag\n{\npublic:\n    Size (std::string const & text)\n    : Tag(\"size\", text)\n    { }\n    std::unique_ptr<Tag> clone () const override\n    {\n        return std::unique_ptr<Tag>(\n            new Size(*this));\n    }\n};\ninline Size small(\"small\");\ninline Size medium(\"medium\");\ninline Size large(\"large\");\n```", "```cpp\nTEST(\"Multiple tags can be used in log\")\n{\n    std::string message = \"multi tags \";\n    message += Util::randomString();\n    MereMemo::log(debug, red, large) << message;\n    std::string logLevelTag = \" log_level=\\\"debug\\\" \";\n    std::string colorTag = \" color=\\\"red\\\" \";\n    std::string sizeTag = \" size=\\\"large\\\" \";\n    bool result = Util::isTextInFile(message,          \"application.log\",\n        {logLevelTag, colorTag, sizeTag});\n    CONFIRM_TRUE(result);\n}\n```", "```cpp\n2022-06-26T07:09:31.192 log_level=\"debug\" color=\"red\" size=\"large\" multi tags 9863\n```", "```cpp\nMereMemo::log(info, \" count=\", 5, \" with text\");\n```", "```cpp\nMereMemo::log(info) << \"count=\" << 5 << \" with text\" << MereMemo::endlog;\n```", "```cpp\nMereMemo::log() << info << \" count=\" << 5 << \" with text\" << MereMemo::endlog;\n```", "```cpp\nMereMemo::log(info) << \"count=\" << 5 << \" with text\";\n```", "```cpp\nMereMemo::log(info) << green << \" count=\" << 5 << \" with text\";\n```", "```cpp\nMereMemo::log(info, green) << \"count=\" << 5 << \" with text\";\n```", "```cpp\nprotected:\n    Tag (std::string const & key, std::string const & value)\n    : mKey(key), mText(key + \"=\\\"\" + value + \"\\\"\")\n    { }\n    Tag (std::string const & key, int value)\n    : mKey(key), mText(key + \"=\" + std::to_string(value))\n    { }\n    Tag (std::string const & key, long long value)\n    : mKey(key), mText(key + \"=\" + std::to_string(value))\n    { }\n    Tag (std::string const & key, double value)\n    : mKey(key), mText(key + \"=\" + std::to_string(value))\n    { }\n    Tag (std::string const & key, bool value)\n    : mKey(key), mText(key + \"=\" + (value?\"true\":\"false\"))\n    { }\n```", "```cpp\nclass Count : public MereMemo::Tag\n{\npublic:\n    Count (int value)\n    : Tag(\"count\", value)\n    { }\n    std::unique_ptr<Tag> clone () const override\n    {\n        return std::unique_ptr<Tag>(\n            new Count(*this));\n    }\n};\nclass Identity : public MereMemo::Tag\n{\npublic:\n    Identity (long long value)\n    : Tag(\"id\", value)\n    { }\n    std::unique_ptr<Tag> clone () const override\n    {\n        return std::unique_ptr<Tag>(\n            new Identity(*this));\n    }\n};\n```", "```cpp\nclass Scale : public MereMemo::Tag\n{\npublic:\n    Scale (double value)\n    : Tag(\"scale\", value)\n    { }\n    std::unique_ptr<Tag> clone () const override\n    {\n        return std::unique_ptr<Tag>(\n            new Scale(*this));\n    }\n};\n```", "```cpp\nclass CacheHit : public MereMemo::Tag\n{\npublic:\n    CacheHit (bool value)\n    : Tag(\"cache_hit\", value)\n    { }\n    std::unique_ptr<Tag> clone () const override\n    {\n        return std::unique_ptr<Tag>(\n            new CacheHit(*this));\n    }\n};\ninline CacheHit cacheHit(true);\ninline CacheHit cacheMiss(false);\n```", "```cpp\nMereMemo::log(info) << Count(1) << \" message\";\n```", "```cpp\ninline std::fstream & operator << (std::fstream && stream, Tag const & tag)\n{\n    stream << to_string(tag);\n    return stream;\n}\n```", "```cpp\nTEST(\"Tags can be streamed to log\")\n{\n    std::string messageBase = \" 1 type \";\n    std::string message = messageBase + Util::randomString();\n    MereMemo::log(info) << Count(1) << message;\n    std::string countTag = \" count=1 \";\n    bool result = Util::isTextInFile(message,          \"application.log\", {countTag});\n    CONFIRM_TRUE(result);\n    messageBase = \" 2 type \";\n    message = messageBase + Util::randomString();\n    MereMemo::log(info) << Identity(123456789012345)             << message;\n    std::string idTag = \" id=123456789012345 \";\n    result = Util::isTextInFile(message, \"application.log\",\n        {idTag});\n    CONFIRM_TRUE(result);\n    messageBase = \" 3 type \";\n    message = messageBase + Util::randomString();\n    MereMemo::log(info) << Scale(1.5) << message;\n    std::string scaleTag = \" scale=1.500000 \";\n    result = Util::isTextInFile(message, \"application.log\",\n        {scaleTag});\n    CONFIRM_TRUE(result);\n    messageBase = \" 4 type \";\n    message = messageBase + Util::randomString();\n    MereMemo::log(info) << cacheMiss << message;\n    std::string cacheTag = \" cache_hit=false \";\n    result = Util::isTextInFile(message, \"application.log\",\n        {cacheTag});\n    CONFIRM_TRUE(result);\n}\n```", "```cpp\n2022-06-27T02:06:43.569 color=\"green\" log_level=\"info\" count=1 1 type 2807\n2022-06-27T02:06:43.569 color=\"green\" log_level=\"info\" id=123456789012345 2 type 7727\n2022-06-27T02:06:43.570 color=\"green\" log_level=\"info\" scale=1.500000 3 type 5495\n2022-06-27T02:06:43.570 color=\"green\" log_level=\"info\" cache_hit=false 4 type 3938\n```", "```cpp\nclass LogLevel : public Tag\n{\npublic:\n    LogLevel (std::string const & text)\n    : Tag(\"log_level\", text)\n    { }\n    std::unique_ptr<Tag> clone () const override\n    {\n        return std::unique_ptr<Tag>(\n            new LogLevel(*this));\n    }\n};\n```", "```cpp\nclass CacheHit : public MereMemo::Tag\n{\npublic:\n    CacheHit (bool value)\n    : Tag(\"cache_hit\", value)\n    { }\n    std::unique_ptr<Tag> clone () const override\n    {\n        return std::unique_ptr<Tag>(\n            new CacheHit(*this));\n    }\n};\n```", "```cpp\ntemplate <typename T, typename ValueT>\nclass TagType : public Tag\n{\npublic:\n    std::unique_ptr<Tag> clone () const override\n    {\n        return std::unique_ptr<Tag>(\n            new T(*static_cast<T const *>(this)));\n    }\n    ValueT value () const\n    {\n        return mValue;\n    }\nprotected:\n    TagType (ValueT const & value)\n    : Tag(T::key, value), mValue(value)\n    { }\n    ValueT mValue;\n};\nclass LogLevel : public TagType<LogLevel, std::string>\n{\npublic:\n    static constexpr char key[] = \"log_level\";\n    LogLevel (std::string const & value)\n    : TagType(value)\n    { }\n};\n```", "```cpp\nclass Color : public MereMemo::TagType<Color, std::string>\n{\npublic:\n    static constexpr char key[] = \"color\";\n    Color (std::string const & value)\n    : TagType(value)\n    { }\n};\nclass Size : public MereMemo::TagType<Size, std::string>\n{\npublic:\n    static constexpr char key[] = \"size\";\n    Size (std::string const & value)\n    : TagType(value)\n    { }\n};\n```", "```cpp\nclass Count : public MereMemo::TagType<Count, int>\n{\npublic:\n    static constexpr char key[] = \"count\";\n    Count (int value)\n    : TagType(value)\n    { }\n};\nclass Identity : public MereMemo::TagType<Identity, long long>\n{\npublic:\n    static constexpr char key[] = \"id\";\n    Identity (long long value)\n    : TagType(value)\n    { }\n};\n```", "```cpp\nclass Scale : public MereMemo::TagType<Scale, double>\n{\npublic:\n    static constexpr char key[] = \"scale\";\n    Scale (double value)\n    : TagType(value)\n    { }\n};\n```", "```cpp\nclass CacheHit : public MereMemo::TagType<CacheHit, bool>\n{\npublic:\n    static constexpr char key[] = \"cache_hit\";\n    CacheHit (bool value)\n    : TagType(value)\n    { }\n};\n```", "```cpp\nTEST(\"Tags can be used to filter messages\")\n{\n    int id = MereMemo::createFilterClause();\n    MereMemo::addFilterLiteral(id, error);\n    std::string message = \"filter \";\n    message += Util::randomString();\n    MereMemo::log(info) << message;\n    bool result = Util::isTextInFile(message,          \"application.log\");\n    CONFIRM_FALSE(result);\n    MereMemo::clearFilterClause(id);\n    MereMemo::log(info) << message;\n    bool result = Util::isTextInFile(message,          \"application.log\");\n    CONFIRM_TRUE(result);\n}\n```", "```cpp\nTEST(\"Overridden default tag not used to filter messages\")\n{\n    int id = MereMemo::createFilterClause();\n    MereMemo::addFilterLiteral(id, info);\n    std::string message = \"override default \";\n    message += Util::randomString();\n    MereMemo::log(debug) << message;\n    bool result = Util::isTextInFile(message,          \"application.log\");\n    CONFIRM_FALSE(result);\n    MereMemo::clearFilterClause(id);\n}\n```", "```cpp\nclass TempFilterClause\n{\npublic:\n    void setup ()\n    {\n        mId = MereMemo::createFilterClause();\n    }\n    void teardown ()\n    {\n        MereMemo::clearFilterClause(mId);\n    }\n    int id () const\n    {\n        return mId;\n    }\nprivate:\n    int mId;\n};\n```", "```cpp\nTEST(\"Tags can be used to filter messages\")\n{\n    int id = MereMemo::createFilterClause();\n    MereMemo::addFilterLiteral(id, error);\n    std::string message = \"filter \";\n    message += Util::randomString();\n    MereMemo::log(info) << message;\n    bool result = Util::isTextInFile(message,          \"application.log\");\n    CONFIRM_FALSE(result);\n    MereMemo::clearFilterClause(id);\n    MereMemo::log(info) << message;\n    result = Util::isTextInFile(message, \"application.log\");\n    CONFIRM_TRUE(result);\n}\n```", "```cpp\nTEST(\"Overridden default tag not used to filter messages\")\n{\n    MereTDD::SetupAndTeardown<TempFilterClause> filter;\n    MereMemo::addFilterLiteral(filter.id(), info);\n    std::string message = \"override default \";\n    message += Util::randomString();\n    MereMemo::log(debug) << message;\n    bool result = Util::isTextInFile(message,          \"application.log\");\n    CONFIRM_FALSE(result);\n}\n```", "```cpp\ninline int createFilterClause ()\n{\n    return 1;\n}\ninline void addFilterLiteral (int filterId,\n    Tag const & tag,\n    bool normal = true)\n{\n}\ninline void clearFilterClause (int filterId)\n{\n}\n```", "```cpp\nRunning 1 test suites\n--------------- Suite: Single Tests\n------- Test: Message can be tagged in log\nPassed\n------- Test: log needs no namespace when used with LogLevel\nPassed\n------- Test: Default tags set in main appear in log\nPassed\n------- Test: Multiple tags can be used in log\nPassed\n------- Test: Tags can be streamed to log\nPassed\n------- Test: Tags can be used to filter messages\nFailed confirm on line 123\n    Expected: false\n------- Test: Overridden default tag not used to filter messages\nFailed confirm on line 143\n    Expected: false\n------- Test: Simple message can be logged\nPassed\n------- Test: Complicated message can be logged\nPassed\n-----------------------------------\nTests passed: 7\nTests failed: 2\n```", "```cpp\nstruct FilterClause\n{\n    std::vector<std::unique_ptr<Tag>> normalLiterals;\n    std::vector<std::unique_ptr<Tag>> invertedLiterals;\n};\ninline std::map<int, FilterClause> & getFilterClauses ()\n{\n    static std::map<int, FilterClause> clauses;\n    return clauses;\n}\n```", "```cpp\ninline int createFilterClause ()\n{\n    static int currentId = 0;\n    ++currentId;\n    auto & clauses = getFilterClauses();\n    clauses[currentId] = FilterClause();\n    return currentId;\n}\n```", "```cpp\ninline void addFilterLiteral (int filterId,\n    Tag const & tag,\n    bool normal = true)\n{\n    auto & clauses = getFilterClauses();\n    if (clauses.contains(filterId))\n    {\n        if (normal)\n        {\n            clauses[filterId].normalLiterals.push_back(\n                tag.clone());\n        }\n        else\n        {\n            clauses[filterId].invertedLiterals.push_back(\n                tag.clone());\n        }\n    }\n}\n```", "```cpp\ninline void clearFilterClause (int filterId)\n{\n    auto & clauses = getFilterClauses();\n    clauses.erase(filterId);\n}\n```", "```cpp\nclass LogStream : public std::fstream\n{\npublic:\n    LogStream (std::string const & filename,\n        std::ios_base::openmode mode = ios_base::app)\n    : std::fstream(filename, mode)\n    { }\n    LogStream (LogStream const & other) = delete;\n    LogStream (LogStream && other)\n    : std::fstream(std::move(other))\n    { }\n    ~LogStream ()\n    {\n        *this << std::endl;\n    }\n\n    LogStream & operator = (LogStream const & rhs) = delete;\n    LogStream & operator = (LogStream && rhs) = delete;\n};\n```", "```cpp\ninline LogStream log (std::vector<Tag const *> tags = {})\n{\n    auto const now = std::chrono::system_clock::now();\n    std::time_t const tmNow =          std::chrono::system_clock::to_time_t(now);\n    auto const ms = duration_cast<std::chrono::milliseconds>(\n        now.time_since_epoch()) % 1000;\n    LogStream ls(\"application.log\");\n    ls << std::put_time(std::gmtime(&tmNow),        \"%Y-%m-%dT%H:%M:%S.\")\n        << std::setw(3) << std::setfill('0')         << std::to_string(ms.count());\n    for (auto const & defaultTag: getDefaultTags())\n    {\n        if (std::find_if(tags.begin(), tags.end(),\n            [&defaultTag](auto const & tag)\n            {\n                return defaultTag.first == tag->key();\n            }) == tags.end())\n        {\n            ls << \" \" << defaultTag.second->text();\n        }\n    }\n    for (auto const & tag: tags)\n    {\n        ls << \" \" << tag->text();\n    }\n    ls << \" \";\n    return ls;\n}\n```", "```cpp\ninline std::ostream & operator << (std::ostream && stream, Tag const & tag)\n{\n    stream << to_string(tag);\n    return stream;\n}\n```", "```cpp\n#include <algorithm>\n#include <chrono>\n#include <ctime>\n#include <fstream>\n#include <iomanip>\n#include <map>\n#include <memory>\n#include <ostream>\n#include <sstream>\n#include <string>\n#include <string_view>\n#include <vector>\n```", "```cpp\nclass LogStream : public std::stringstream\n{\npublic:\n    LogStream (std::string const & filename,\n        std::ios_base::openmode mode = ios_base::app)\n    : mProceed(true), mFile(filename, mode)\n    { }\n    LogStream (LogStream const & other) = delete;\n    LogStream (LogStream && other)\n    : std::stringstream(std::move(other)),\n    mProceed(other.mProceed), mFile(std::move(other.mFile))\n    { }\n    ~LogStream ()\n    {\n        if (not mProceed)\n        {\n            return;\n        }\n        mFile << this->str();\n        mFile << std::endl;\n    }\n    LogStream & operator = (LogStream const & rhs) = delete;\n    LogStream & operator = (LogStream && rhs) = delete;\n    void ignore ()\n    {\n        mProceed = false;\n    }\nprivate:\n    bool mProceed;\n    std::fstream mFile;\n};\n```", "```cpp\ninline LogStream log (std::vector<Tag const *> tags = {})\n{\n    auto const now = std::chrono::system_clock::now();\n    std::time_t const tmNow =          std::chrono::system_clock::to_time_t(now);\n    auto const ms = duration_cast<std::chrono::milliseconds>(\n        now.time_since_epoch()) % 1000;\n    LogStream ls(\"application.log\");\n    ls << std::put_time(std::gmtime(&tmNow),        \"%Y-%m-%dT%H:%M:%S.\")\n        << std::setw(3) << std::setfill('0')         << std::to_string(ms.count());\n    std::map<std::string, Tag const *> activeTags;\n    for (auto const & defaultTag: getDefaultTags())\n    {\n        activeTags[defaultTag.first] = defaultTag.second.get();\n    }\n    for (auto const & tag: tags)\n    {\n        activeTags[tag->key()] = tag;\n    }\n    for (auto const & activeEntry: activeTags)\n    {\n        ls << \" \" << activeEntry.second->text();\n    }\n    ls << \" \";\n    // Filtering will go here.\n    return ls;\n}\n```", "```cpp\n    bool proceed = true;\n    for (auto const & clause: getFilterClauses())\n    {\n        proceed = false;\n        bool allLiteralsMatch = true;\n        for (auto const & normal: clause.second.normalLiterals)\n        {\n            // We need to make sure that the tag is\n            // present and with the correct value.\n            if (not activeTags.contains(normal->key()))\n            {\n                allLiteralsMatch = false;\n                break;\n            }\n            if (activeTags[normal->key()]->text() !=\n                normal->text())\n            {\n                allLiteralsMatch = false;\n                break;\n            }\n        }\n        if (not allLiteralsMatch)\n        {\n            continue;\n        }\n        for (auto const & inverted:             clause.second.invertedLiterals)\n        {\n            // We need to make sure that the tag is either\n            // not present or has a mismatched value.\n            if (activeTags.contains(inverted->key()))\n            {\n                if (activeTags[inverted->key()]->text() !=\n                    inverted->text())\n                {\n                    break;\n                }\n                allLiteralsMatch = false;\n                break;\n            }\n        }\n        if (allLiteralsMatch)\n        {\n            proceed = true;\n            break;\n        }\n    }\n    if (not proceed)\n    {\n        ls.ignore();\n    }\n    return ls;\n```", "```cpp\nRunning 1 test suites\n--------------- Suite: Single Tests\n------- Test: Message can be tagged in log\nPassed\n------- Test: log needs no namespace when used with LogLevel\nPassed\n------- Test: Default tags set in main appear in log\nPassed\n------- Test: Multiple tags can be used in log\nPassed\n------- Test: Tags can be streamed to log\nPassed\n------- Test: Tags can be used to filter messages\nPassed\n------- Test: Overridden default tag not used to filter messages\nPassed\n------- Test: Simple message can be logged\nPassed\n------- Test: Complicated message can be logged\nPassed\n-----------------------------------\nTests passed: 9\nTests failed: 0\n```", "```cpp\nTEST(\"Inverted tag can be used to filter messages\")\n{\n    MereTDD::SetupAndTeardown<TempFilterClause> filter;\n    MereMemo::addFilterLiteral(filter.id(), green, false);\n    std::string message = \"inverted \";\n    message += Util::randomString();\n    MereMemo::log(info) << message;\n    bool result = Util::isTextInFile(message,          \"application.log\");\n    CONFIRM_FALSE(result);\n}\n```", "```cpp\nTEST(\"Tag values can be used to filter messages\")\n{\n    MereTDD::SetupAndTeardown<TempFilterClause> filter;\n    MereMemo::addFilterLiteral(filter.id(),\n        Count(100, MereMemo::TagOperation::GreaterThan));\n    std::string message = \"values \";\n    message += Util::randomString();\n    MereMemo::log(Count(1)) << message;\n    bool result = Util::isTextInFile(message,          \"application.log\");\n    CONFIRM_FALSE(result);\n    MereMemo::log() << Count(101) << message;\n    result = Util::isTextInFile(message, \"application.log\");\n    CONFIRM_FALSE(result);\n    MereMemo::log(Count(101)) << message;\n    result = Util::isTextInFile(message, \"application.log\");\n    CONFIRM_TRUE(result);\n}\n```", "```cpp\nCount(100)\n```", "```cpp\nCount(100, MereMemo::TagOperation::GreaterThan)\n```", "```cpp\nenum class TagOperation\n{\n    None,\n    Equal,\n    LessThan,\n    LessThanOrEqual,\n    GreaterThan,\n    GreaterThanOrEqual\n};\n```", "```cpp\n    virtual std::unique_ptr<Tag> clone () const = 0;\n    virtual bool match (Tag const & other) const = 0;\n```", "```cpp\ntemplate <typename T>\nclass StringTagType : public TagType<T, std::string>\n{\nprotected:\n    StringTagType (std::string const & value,\n        TagOperation operation)\n    : TagType<T, std::string>(value, operation)\n    { }\n    bool compareTagTypes (std::string const & value,\n        TagOperation operation,\n        std::string const & criteria) const override\n    {\n        int result = value.compare(criteria);\n        switch (operation)\n        {\n        case TagOperation::Equal:\n            return result == 0;\n        case TagOperation::LessThan:\n            return result == -1;\n        case TagOperation::LessThanOrEqual:\n            return result == 0 || result == -1;\n        case TagOperation::GreaterThan:\n            return result == 1;\n        case TagOperation::GreaterThanOrEqual:\n            return result == 0 || result == 1;\n        default:\n            return false;\n        }\n    }\n};\n```", "```cpp\nclass LogLevel : public StringTagType<LogLevel>\n{\npublic:\n    static constexpr char key[] = \"log_level\";\n    LogLevel (std::string const & value,\n        TagOperation operation = TagOperation::None)\n    : StringTagType(value, operation)\n    { }\n};\n```", "```cpp\nprotected:\n    TagType (ValueT const & value,\n        TagOperation operation)\n    : Tag(T::key, value), mValue(value), mOperation(operation)\n    { }\n    virtual bool compareTagTypes (ValueT const & value,\n        TagOperation operation,\n        ValueT const & criteria) const\n    {\n        return false;\n    }\n    ValueT mValue;\n    TagOperation mOperation;\n};\n```", "```cpp\n    bool match (Tag const & other) const override\n    {\n        if (key() != other.key())\n        {\n            return false;\n        }\n        TagType const & otherCast =                 static_cast<TagType const &>(other);\n        if (mOperation == TagOperation::None)\n        {\n            switch (otherCast.mOperation)\n            {\n            case TagOperation::None:\n                return mValue == otherCast.mValue;\n            default:\n                return compareTagTypes(mValue,\n                    otherCast.mOperation,\n                    otherCast.mValue);\n            }\n        }\n        switch (otherCast.mOperation)\n        {\n        case TagOperation::None:\n            return compareTagTypes(otherCast.mValue,\n                mOperation,\n                mValue);\n        default:\n            return false;\n        }\n    }\n```", "```cpp\ntemplate <typename T>\nclass IntTagType : public TagType<T, int>\n{\nprotected:\n    IntTagType (int const & value,\n        TagOperation operation)\n    : TagType<T, int>(value, operation)\n    { }\n    bool compareTagTypes (int const & value,\n        TagOperation operation,\n        int const & criteria) const override\n    {\n        switch (operation)\n        {\n        case TagOperation::Equal:\n            return value == criteria;\n        case TagOperation::LessThan:\n            return value < criteria;\n        case TagOperation::LessThanOrEqual:\n            return value <= criteria;\n        case TagOperation::GreaterThan:\n            return value > criteria;\n        case TagOperation::GreaterThanOrEqual:\n            return value >= criteria;\n        default:\n            return false;\n        }\n    }\n};\n```", "```cpp\ntemplate <typename T>\nclass LongLongTagType : public TagType<T, long long>\n{\nprotected:\n    LongLongTagType (long long const & value,\n        TagOperation operation)\n    : TagType<T, long long>(value, operation)\n    { }\n    bool compareTagTypes (long long const & value,\n        TagOperation operation,\n        long long const & criteria) const override\n    {\n        switch (operation)\n        {\n        case TagOperation::Equal:\n            return value == criteria;\n        case TagOperation::LessThan:\n            return value < criteria;\n        case TagOperation::LessThanOrEqual:\n            return value <= criteria;\n        case TagOperation::GreaterThan:\n            return value > criteria;\n        case TagOperation::GreaterThanOrEqual:\n            return value >= criteria;\n        default:\n            return false;\n        }\n    }\n};\n```", "```cpp\ntemplate <typename T>\nclass DoubleTagType : public TagType<T, double>\n{\nprotected:\n    DoubleTagType (double const & value,\n        TagOperation operation)\n    : TagType<T, double>(value, operation)\n    { }\n    bool compareTagTypes (double const & value,\n        TagOperation operation,\n        double const & criteria) const override\n    {\n        switch (operation)\n        {\n        case TagOperation::Equal:\n            return value == criteria;\n        case TagOperation::LessThan:\n            return value < criteria;\n        case TagOperation::LessThanOrEqual:\n            return value <= criteria;\n        case TagOperation::GreaterThan:\n            return value > criteria;\n        case TagOperation::GreaterThanOrEqual:\n            return value >= criteria;\n        default:\n            return false;\n        }\n    }\n};\n```", "```cpp\ntemplate <typename T>\nclass BoolTagType : public TagType<T, bool>\n{\nprotected:\n    BoolTagType (bool const & value,\n        TagOperation operation)\n    : TagType<T, bool>(value, operation)\n    { }\n    bool compareTagTypes (bool const & value,\n        TagOperation operation,\n        bool const & criteria) const override\n    {\n        switch (operation)\n        {\n        case TagOperation::Equal:\n            return value == criteria;\n        default:\n            return false;\n        }\n    }\n};\n```", "```cpp\n        for (auto const & normal: clause.second.normalLiterals)\n        {\n            // We need to make sure that the tag is\n            // present and with the correct value.\n            if (not activeTags.contains(normal->key()))\n            {\n                allLiteralsMatch = false;\n                break;\n            }\n            if (not activeTags[normal->key()]->match(*normal))\n            {\n                allLiteralsMatch = false;\n                break;\n            }\n        }\n```", "```cpp\n        for (auto const & inverted:             clause.second.invertedLiterals)\n        {\n            // We need to make sure that the tag is either\n            // not present or has a mismatched value.\n            if (activeTags.contains(inverted->key()))\n            {\n                if (activeTags[inverted->key()]->match(                   *inverted))\n                {\n                    allLiteralsMatch = false;\n                }\n                break;\n            }\n        }\n```", "```cpp\nclass Color : public MereMemo::StringTagType<Color>\n{\npublic:\n    static constexpr char key[] = \"color\";\n    Color (std::string const & value,\n        MereMemo::TagOperation operation =\n            MereMemo::TagOperation::None)\n    : StringTagType(value, operation)\n    { }\n};\n```", "```cpp\nclass Size : public MereMemo::StringTagType<Size>\n{\npublic:\n    static constexpr char key[] = \"size\";\n    Size (std::string const & value,\n        MereMemo::TagOperation operation =\n            MereMemo::TagOperation::None)\n    : StringTagType(value, operation)\n    { }\n};\n```", "```cpp\nclass Count : public MereMemo::IntTagType<Count>\n{\npublic:\n    static constexpr char key[] = \"count\";\n    Count (int value,\n        MereMemo::TagOperation operation =\n            MereMemo::TagOperation::None)\n    : IntTagType(value, operation)\n    { }\n};\nclass Identity : public MereMemo::LongLongTagType<Identity>\n{\npublic:\n    static constexpr char key[] = \"id\";\n    Identity (long long value,\n        MereMemo::TagOperation operation =\n            MereMemo::TagOperation::None)\n    : LongLongTagType(value, operation)\n    { }\n};\n```", "```cpp\nclass Scale : public MereMemo::DoubleTagType<Scale>\n{\npublic:\n    static constexpr char key[] = \"scale\";\n    Scale (double value,\n        MereMemo::TagOperation operation =\n            MereMemo::TagOperation::None)\n    : DoubleTagType(value, operation)\n    { }\n};\nclass CacheHit : public MereMemo::BoolTagType<CacheHit>\n{\npublic:\n    static constexpr char key[] = \"cache_hit\";\n    CacheHit (bool value,\n        MereMemo::TagOperation operation =\n            MereMemo::TagOperation::None)\n    : BoolTagType(value, operation)\n    { }\n};\n```", "```cpp\nTEST(\"Tag values can be used to filter messages\")\n{\n    MereTDD::SetupAndTeardown<TempFilterClause> filter;\n    MereMemo::addFilterLiteral(filter.id(),\n        Count(100, MereMemo::TagOperation::GreaterThan));\n    std::string message = \"values \";\n    message += Util::randomString();\n    MereMemo::log(Count(1)) << message;\n    bool result = Util::isTextInFile(message,          \"application.log\");\n    CONFIRM_FALSE(result);\n    MereMemo::log() << Count(101) << message;\n    result = Util::isTextInFile(message, \"application.log\");\n    CONFIRM_FALSE(result);\n    MereMemo::log(Count(101)) << message;\n    result = Util::isTextInFile(message, \"application.log\");\n    CONFIRM_TRUE(result);\n}\n```", "```cpp\nTEST(\"Tag values can be used to filter messages\")\n{\n    MereTDD::SetupAndTeardown<TempFilterClause> filter;\n    MereMemo::addFilterLiteral(filter.id(),\n        Count(100, MereMemo::TagOperation::GreaterThan));\n```"]