- en: Chapter 1.  Get Your Qt Feet Wet
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章。让你的 Qt 脚步湿透
- en: If you know C++ but have never touched Qt, or if you have made some intermediate
    Qt applications, this chapter will ensure that your Qt foundations are safe before
    studying advanced concepts in the following chapters.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉 C++ 但从未接触过 Qt，或者如果你已经制作了一些中级 Qt 应用程序，那么本章将确保你在学习以下章节的高级概念之前，Qt 的基础是安全的。
- en: We will teach you to create a simple todo application using Qt Creator. This
    application will display a list of tasks that you can create/update/delete. We
    will cover the Qt Creator and Qt Designer interfaces, an introduction to the signal/slot
    mechanism, the creation of a custom widget with custom signals/slots, and its
    integration into your application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将教你如何使用 Qt Creator 创建一个简单的待办事项应用程序。此应用程序将显示一个任务列表，你可以创建/更新/删除任务。我们将涵盖 Qt Creator
    和 Qt Designer 界面、信号/槽机制的介绍、创建具有自定义信号/槽的自定义小部件以及将其集成到你的应用程序中。
- en: 'You will implement a todo app using new C++14 semantics: lambdas, auto variables,
    and for loops. Each one of these concepts will be explained in depth and will
    be used throughout the book.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用新的 C++14 语义实现一个待办事项应用程序：lambda 表达式、auto 变量和 for 循环。这些概念将逐一深入解释，并在整本书中应用。
- en: At the end of this chapter, you will be able to create a desktop application
    with a flexible UI using Qt widgets and new C++ semantics.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束时，你将能够使用 Qt 小部件和新的 C++ 语义创建一个具有灵活 UI 的桌面应用程序。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Qt project basic structure
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt 项目基本结构
- en: Qt Designer interface
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt Designer 界面
- en: UI fundamentals
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI 基础
- en: Signals and slots
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号和槽
- en: Custom `QWidget`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义 `QWidget`
- en: C++14 lambda, auto, for each
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++14 lambda、auto、for each
- en: Creating a project
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建项目
- en: The first thing to do is to start Qt Creator.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 第一件事是启动 Qt Creator。
- en: In Qt Creator, you can create a new Qt project via **File** | **New File or
    Project** | **Application** | **Qt Widgets Application** | **Choose**.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Qt Creator 中，你可以通过 **文件** | **新建文件或项目** | **应用程序** | **Qt 小部件应用程序** | **选择**
    来创建一个新的 Qt 项目。
- en: 'The wizard will then guide you through four steps:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然后向导将引导你完成四个步骤：
- en: '**Location**: You must choose a project name and a location.'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**位置**：你必须选择一个项目名称和位置。'
- en: '**Kits**: Target platforms that your project aims at (Desktop, Android, and
    so on).'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**工具包**：你的项目目标平台（桌面、Android 等）。'
- en: '**Details**: Base class information and name for the generated class.'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**详情**：生成类的基类信息和名称。'
- en: '**Summary**: Allows you to configure your new project as a subproject and automatically
    add it to a version control system.'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**摘要**：允许你将你的新项目配置为子项目，并自动将其添加到版本控制系统。'
- en: Even if all default values can be kept, please at least set a useful project
    name such as "todo" or "TodoApp." We won't blame you if you want to call it "Untitled"
    or "Hello world."
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 即使可以保留所有默认值，也请至少设置一个有用的项目名称，例如 "todo" 或 "TodoApp"。如果你想要将其命名为 "Untitled" 或 "Hello
    world"，我们也不会责怪你。
- en: 'Once done, Qt Creator will generate several files that you can see in the **Projects**
    hierarchy view:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，Qt Creator 将生成几个文件，你可以在 **项目** 层级视图中看到它们：
- en: '![Creating a project](img/image00350.jpeg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![创建项目](img/image00350.jpeg)'
- en: The `.pro` file is Qt's configuration project file. As Qt adds specific file
    formats and C++ keywords, an intermediate build step is performed, parsing all
    files to generate final files. This process is done by `qmake`, an executable
    from the Qt SDK. It will also generate the final Makefiles for your project.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`.pro` 文件是 Qt 的配置项目文件。由于 Qt 添加了特定的文件格式和 C++ 关键字，因此会执行一个中间构建步骤，解析所有文件以生成最终文件。这个过程由
    `qmake`（Qt SDK 中的一个可执行文件）完成。它还将为你的项目生成最终的 Makefiles。'
- en: 'A basic `.pro` file generally contains:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一个基本的 `.pro` 文件通常包含：
- en: Qt modules used (`core`, `gui`, and so on)
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用的 Qt 模块（`core`、`gui` 等）
- en: Target name (`todo`, `todo.exe`, and so on)
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标名称（`todo`、`todo.exe` 等）
- en: Project template (`app`, `lib`, and so on)
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目模板（`app`、`lib` 等）
- en: Sources, headers, and forms
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源文件、头文件和表单
- en: 'There are some great features that come with Qt and C++14\. This book will
    showcase them in all its projects. For `GCC` and `CLANG` compilers, you must add `CONFIG
    += c++14` to the `.pro` file to enable C++14 on a Qt project, as shown in the
    following code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 和 C++14 提供了一些很棒的功能。本书将在所有项目中展示它们。对于 `GCC` 和 `CLANG` 编译器，你必须将 `CONFIG += c++14`
    添加到 `.pro` 文件中，以在 Qt 项目上启用 C++14，如下面的代码所示：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `MainWindow.h` and `MainWindow.cpp` files are the headers/sources for the `MainWindow`
    class. These files contain the default GUI generated by the wizard.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainWindow.h` 和 `MainWindow.cpp` 文件是 `MainWindow` 类的头文件/源文件。这些文件包含向导生成的默认
    GUI。'
- en: The `MainWindow.ui` file is your UI design file in XML format. It can be edited
    more easily with Qt Designer. This tool is a **WYSIWYG** (**What You See Is What
    You Get**) editor that helps you to add and adjust your graphical components (widgets).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainWindow.ui`文件是你的XML格式的UI设计文件。它可以用Qt Designer更容易地编辑。这个工具是一个**WYSIWYG**（**所见即所得**）编辑器，它可以帮助你添加和调整你的图形组件（小部件）。'
- en: 'Here is the `main.cpp` file, with its well-known function:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`main.cpp`文件，其中包含其著名的函数：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As usual, the `main.cpp` file contains the program entry point. It will, by
    default, perform two actions:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，`main.cpp`文件包含程序的入口点。默认情况下，它将执行两个操作：
- en: Instantiate and show your main window
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例化和显示你的主窗口
- en: Instantiate a `QApplication` and execute the blocking main event loop
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例化一个`QApplication`并执行阻塞的主事件循环
- en: 'This is the bottom-left toolbar for Qt Creator:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Qt Creator的底部左侧工具栏：
- en: '![Creating a project](img/image00351.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![创建项目](img/image00351.jpeg)'
- en: 'Use it to build and start your `todo` application in debug mode:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用它以调试模式构建和启动你的`todo`应用程序：
- en: Check that the project is in **Debug** build mode.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认项目处于**调试**构建模式。
- en: Use the hammer button to build your project.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用锤子按钮来构建你的项目。
- en: Start debugging using the green Play button with a little blue bug.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用带有小蓝色虫的绿色播放按钮开始调试。
- en: 'You will discover a wonderful and beautifully empty window. We will rectify
    this after explaining how this `MainWindow` is constructed:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现一个奇妙且空荡荡的窗口。在解释如何构建这个`MainWindow`之后，我们将纠正这个问题：
- en: '![Creating a project](img/image00352.jpeg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![创建项目](img/image00352.jpeg)'
- en: An empty **MainWindow** screenshot
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一个空的**MainWindow**截图
- en: Tip
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Qt tip**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**Qt技巧**'
- en: Press *Ctrl* + *B* (for Windows/Linux) or *Command* + *B* (for Mac) to build
    your project
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按*Ctrl* + *B*（Windows/Linux）或*Command* + *B*（Mac）来构建你的项目
- en: Press *F5* (for Windows / Linux) or *Command* +*R* (for Mac) to run your application
    in debug mode
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按*F5*（Windows/Linux）或*Command* + *R*（Mac）以调试模式运行你的应用程序
- en: MainWindow structure
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MainWindow结构
- en: This generated class is a perfect yet simple example of Qt framework usage;
    we will dissect it together. As mentioned previously, the `MainWindow.ui` file
    describes your UI design and `MainWindow.h`/ `MainWindow.cpp` is the C++ object
    where you can manipulate the UI with code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这个生成的类是Qt框架使用的完美且简单的例子；我们将一起剖析它。如前所述，`MainWindow.ui`文件描述了你的UI设计，而`MainWindow.h`/`MainWindow.cpp`是你可以用代码操作UI的C++对象。
- en: 'It is important to take a look at the header file `MainWindow.h`. Our `MainWindow`
    object inherits from Qt''s `QMainWindow` class:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下头文件`MainWindow.h`很重要。我们的`MainWindow`对象继承自Qt的`QMainWindow`类：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As our class inherits from the `QMainWindow` class, on top of the header file,
    we add the corresponding include. The second part is the forward declaration of
    the `Ui::MainWindow`, as we only declare a pointer.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的类继承自`QMainWindow`类，我们在头文件顶部添加了相应的包含。第二部分是`Ui::MainWindow`的前向声明，因为我们只声明了一个指针。
- en: The `Q_OBJECT` can look a little strange to a non-Qt developer. This macro allows
    the class to define its own signals/slots and more globally Qt's meta-object system.
    These features will be covered later in this chapter.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`Q_OBJECT`对于非Qt开发者来说可能看起来有点奇怪。这个宏允许类定义自己的信号/槽，以及更广泛的Qt元对象系统。这些特性将在本章的后面部分介绍。'
- en: This class defines a public constructor and destructor. The latter is pretty
    common. But the constructor takes a parameter parent. This parameter is a `QWidget`
    pointer that is `null` by default.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类定义了一个公共构造函数和析构函数。后者相当常见。但构造函数接受一个参数parent。这个参数是一个默认为`null`的`QWidget`指针。
- en: A `QWidget` is a UI component. It can be a label, a textbox, a button, and so
    on. If you define a parent-child relationship between your window, layout, and
    other UI widgets, memory management of your application will be easier. Indeed,
    in this case, deleting the parent is enough because its destructor will take care
    of also deleting its child, which in turn will delete its children and so on.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`QWidget`是一个UI组件。它可以是一个标签、一个文本框、一个按钮等等。如果你在窗口、布局和其他UI小部件之间定义了父子关系，你的应用程序的内存管理将会更容易。实际上，在这种情况下，删除父对象就足够了，因为它的析构函数将负责删除其子对象，然后子对象再删除其子对象，依此类推。'
- en: 'Our `MainWindow` class extends `QMainWindow` from the Qt framework. We have
    a `ui` member variable in the private fields. The type is a pointer of `Ui::MainWindow`,
    which is defined in the `ui_MainWindow.h` file generated by Qt. It''s the C++
    transcription of the UI design file `MainWindow.ui`. The `ui` member variable
    will allow you to interact with your UI components (`QLabel`, `QPushButton`, and
    so on) from C++, as shown in the following figure:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `MainWindow` 类从 Qt 框架扩展了 `QMainWindow`。我们在私有字段中有一个 `ui` 成员变量。其类型是 `Ui::MainWindow`
    的指针，该指针在由 Qt 生成的 `ui_MainWindow.h` 文件中定义。它是 UI 设计文件 `MainWindow.ui` 的 C++ 转写。`ui`
    成员变量将允许您从 C++ 中与 UI 组件（`QLabel`、`QPushButton` 等）交互，如图所示：
- en: '![MainWindow structure](img/image00353.jpeg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![MainWindow 结构](img/image00353.jpeg)'
- en: Tip
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**C++ tip**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**C++ 小贴士**'
- en: If your class only uses pointers or references for a class type, you can avoid
    including the header by using forward declaration. That will drastically reduce
    compilation time.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的类只使用指针或引用来表示类类型，您可以通过使用前向声明来避免包含头文件。这将大大减少编译时间。
- en: Now that the header part is done, we can talk about the `MainWindow.cpp` source
    file.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在头部部分已经完成，我们可以谈谈 `MainWindow.cpp` 源文件。
- en: 'In the following code snippet, the first include is our class header. The second
    one is the include required by the generated class `Ui::MainWindow`. This include
    is required as we only use a forward declaration in the header:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，第一个包含是我们类的头文件。第二个包含是生成类 `Ui::MainWindow` 所需的包含。这个包含是必需的，因为我们只在头文件中使用前向声明：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In many cases, Qt generates a good piece of code using the initializer list.
    The `parent` argument is used to call the superclass constructor `QMainWindow`.
    Our private member variable `ui` is also initialized now.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，Qt 使用初始化列表生成一段很好的代码。`parent` 参数用于调用超类构造函数 `QMainWindow`。我们的私有成员变量 `ui`
    也被初始化了。
- en: 'Now that `ui` is initialized, we must call the `setupUi` function to initialize
    all widgets used by the `MainWindow.ui` design file:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`ui`已经初始化，我们必须调用`setupUi`函数来初始化`MainWindow.ui`设计文件中使用的所有组件：
- en: 'As we initialize a pointer in the constructor, it must be cleaned in the destructor:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在构造函数中初始化了一个指针，它必须在析构函数中清理：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Qt Designer
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt Designer
- en: 'Qt Designer is a major tool for developing Qt applications. This WYSIWYG editor
    will help you easily design your GUI. If you switch between **Edit** mode and **Design**
    mode for the `MainWindow.ui` file, you will see the real XML content and the designer:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Designer 是开发 Qt 应用程序的主要工具。这个所见即所得编辑器将帮助您轻松设计您的 GUI。如果您在`MainWindow.ui`文件之间切换到**编辑**模式或**设计**模式，您将看到真实的
    XML 内容和设计器：
- en: '![Qt Designer](img/image00354.jpeg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![Qt Designer](img/image00354.jpeg)'
- en: 'The designer displays several parts:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 设计器显示几个部分：
- en: '**Form Editor**: This is a visual representation of the form (empty for now)'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表单编辑器**：这是表单的可视表示（目前为空）'
- en: '**Widget Box**: This contains all widgets that can be used with your form'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组件箱**：这包含可以与您的表单一起使用的所有组件'
- en: '**Object Inspector**: This displays your form as a hierarchical tree'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象检查器**：这以分层树的形式显示您的表单'
- en: '**Property Editor**: This enumerates the properties of the selected widget'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性编辑器**：这列出了所选组件的属性'
- en: '**Action Editor/Signal & Slots Editor**: This handles connections between your
    objects'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动作编辑器/信号与槽编辑器**：这处理对象之间的连接'
- en: It's time to embellish this empty window! Let's drag and drop a **Label** widget
    from the **Display Widgets** section on the form. You can change the name and
    the text properties from the properties editor.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候装饰这个空白的窗口了！让我们从表单上的“显示组件”部分拖放一个**标签**组件。您可以从属性编辑器中更改名称和文本属性。
- en: 'As we are making a `todo` application, we suggest these properties:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在制作一个 `todo` 应用程序，我们建议以下属性：
- en: '`objectName`: `statusLabel`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`objectName`: `statusLabel`'
- en: '`text`: `Status: 0 todo/0 done`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`text`: `状态：0 待办/0 完成`'
- en: This label will later display the count of `todo` tasks and the count of tasks
    already done. OK, save, build, and start your application. You should now see
    your new label in the window.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个标签将稍后显示 `todo` 任务的数量和已完成任务的数量。好的，保存，构建，并启动您的应用程序。现在您应该在窗口中看到您的新标签。
- en: 'You can now add a push button with those properties:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以使用以下属性添加一个按钮：
- en: '`objectName`: `addTaskButton`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`objectName`: `addTaskButton`'
- en: '`text`: `Add task`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`text`: `添加任务`'
- en: 'You should get a result close to this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到一个接近以下结果：
- en: '![Qt Designer](img/image00355.jpeg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![Qt Designer](img/image00355.jpeg)'
- en: Tip
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Qt tip**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**Qt 小贴士**'
- en: You can edit the text property of a widget directly on your form by double-clicking
    on it!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过双击它直接在表单上编辑组件的文本属性！
- en: Signals and slots
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号和槽
- en: 'The Qt framework brings a flexible message exchange mechanism through three
    concepts: signals, slots, and connections:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 框架通过三个概念：信号、槽和连接，提供了一个灵活的消息交换机制：
- en: A `signal` is a message sent by an object
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`signal` 是对象发送的消息'
- en: A `slot` is a function that will be called when this signal is triggered
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`slot` 是当这个信号被触发时将被调用的函数'
- en: The `connect` function specifies which `signal` is linked to which `slot`
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`connect` 函数指定哪个 `signal` 连接到哪个 `slot`'
- en: Qt already provides signals and slots for its classes, which you can use in
    your application. For example, `QPushButton` has a `signal clicked()`, which will
    be triggered when the user clicks on the button. The `QApplication` class has
    a `slot quit()` function, which can be called when you want to terminate your
    application.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 已经为其类提供了信号和槽，你可以在应用程序中使用它们。例如，`QPushButton` 有一个 `clicked()` 信号，当用户点击按钮时将被触发。`QApplication`
    类有一个 `quit()` 槽函数，可以在你想终止应用程序时调用。
- en: 'Here is why you will love Qt signals and slots:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么你会喜欢 Qt 信号和槽：
- en: A slot remains an ordinary function, so you can call it yourself
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 槽仍然是一个普通函数，所以你可以自己调用它
- en: A single signal can be linked to different slots
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个信号可以连接到不同的槽
- en: A single slot can be called by different linked signals
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个槽可以被不同的链接信号调用
- en: A connection can be made between a signal and a slot from different objects,
    and even between objects living inside different threads!
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在来自不同对象的信号和槽之间，甚至在位于不同线程中的对象之间建立连接！
- en: Keep in mind that, to be able to connect a `signal` to a `slot`, their methods'
    signatures must match. The count, order, and type of arguments must be identical.
    Note that signals and slots never return values.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，为了能够将 `signal` 连接到 `slot`，它们的函数签名必须匹配。参数的数量、顺序和类型必须相同。注意，信号和槽从不返回值。
- en: 'This is the syntax of a Qt connection:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Qt 连接的语法：
- en: '[PRE5]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The first test that we can do to use this wonderful mechanism is to connect
    an existing `signal` with an existing `slot`. We will add this connect call to
    the `MainWindow` constructor:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用此出色机制进行的第一个测试是将现有的 `signal` 与现有的 `slot` 连接起来。我们将把这个连接调用添加到 `MainWindow`
    构造函数中：
- en: '[PRE6]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s analyze how a connection is done:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下如何完成连接：
- en: '`sender`: This is the object that will send the signal. In our example, it
    is the `QPushButton` named `addTaskButton` added from the UI designer.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sender`：这是将发送信号的对象。在我们的例子中，它是从 UI 设计器添加的名为 `addTaskButton` 的 `QPushButton`。'
- en: '`&Sender::signalName`: This is the pointer to the member signal function. Here,
    we want do something when the clicked signal is triggered.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`&Sender::signalName`：这是成员信号函数的指针。在这里，我们希望在点击信号被触发时执行某些操作。'
- en: '`receiver`: This is the object that will receive and handle the signal. In
    our case, it is the `QApplication` object created in `main.cpp`.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`receiver`：这是将接收并处理信号的对象。在我们的情况下，它是 `main.cpp` 中创建的 `QApplication` 对象。'
- en: '`&Receiver::slotName`: This is a pointer to one of the receiver''s `member`
    slot functions. In this example, we use the built-in `quit()` slot from `Qapplication`,
    which will exit the application.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`&Receiver::slotName`：这是指向接收者之一的成员槽函数的指针。在这个例子中，我们使用内置的 `quit()` 槽从 `Qapplication`，这将退出应用程序。'
- en: You can now compile and run this short example. You will terminate the application
    if you click on the `addTaskButton` of your `MainWindow`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以编译并运行这个简短的示例。如果你点击 `MainWindow` 的 `addTaskButton`，应用程序将被终止。
- en: Tip
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Qt tip**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**Qt 小贴士**'
- en: You can connect a signal to another signal. The second signal will be emitted
    when the first one is triggered.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将一个信号连接到另一个信号。当第一个信号被触发时，第二个信号将被发出。
- en: Now that you know how to connect a signal to an existing slot, let's see how
    to declare and implement a custom `addTask()` slot in our `MainWindow` class.
    This slot will be called when the user clicks on `ui->addTaskButton`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何将信号连接到现有的槽，让我们看看如何在 `MainWindow` 类中声明和实现一个自定义的 `addTask()` 槽。当用户点击
    `ui->addTaskButton` 时，这个槽将被调用。
- en: 'This is the updated `MainWindow.h`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这是更新后的 `MainWindow.h`：
- en: '[PRE7]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Qt uses a specific `slot` keyword to identify slots. Since a slot is a function,
    you can always adjust the visibility (`public`, `protected` or `private`) depending
    on your needs.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 使用特定的 `slot` 关键字来识别槽。由于槽是一个函数，你可以根据需要调整其可见性（`public`、`protected` 或 `private`）。
- en: 'Add this slot implementation in the `MainWindow.cpp` file:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `MainWindow.cpp` 文件中添加此槽实现：
- en: '[PRE8]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Qt provides an efficient way of displaying debug information with the `QDebug`
    class. An easy way to obtain a `QDebug` object is to call the `qDebug()` function.
    Then, you can use the stream operator to send your debug information.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 提供了一种使用 `QDebug` 类高效显示调试信息的方法。获取 `QDebug` 对象的一个简单方法是调用 `qDebug()` 函数。然后，您可以使用流运算符发送您的调试信息。
- en: 'Update the top of the file like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 更新文件顶部如下：
- en: '[PRE9]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Since we now use `qDebug()` in out slot, we must include `<QDebug>`. The updated
    connect now calls our custom slot instead of quitting the application.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在在槽中使用 `qDebug()`，我们必须包含 `<QDebug>`。更新的连接现在调用我们的自定义槽而不是退出应用程序。
- en: Build and run the application. If you click on the button, you will see your
    debug message inside the Qt Creator `Application Output` tab.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行应用程序。如果您点击按钮，您将在 Qt Creator 的 `应用程序输出` 选项卡中看到您的调试信息。
- en: Custom QWidget
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义 QWidget
- en: We now have to create the `Task` class that will hold our data (task name and
    completed status). This class will have its form file separated from `MainWindow`.
    Qt Creator provides an automatic tool to generate a base class and the associated
    form.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须创建一个 `Task` 类来保存我们的数据（任务名称和完成状态）。这个类将有一个与 `MainWindow` 分离的表单文件。Qt Creator
    提供了一个自动工具来生成基类和相关表单。
- en: 'Click on **File** | **New File or Project** | **Qt** | **Qt Designer Form Class**.
    There are several form templates; you will recognize Main Window, which Qt Creator
    created for us when we started the `todo` app project. Select **Widget** and name
    the class `Task`, then click on **Next**. Here is a summary of what Qt Creator
    will do:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **文件** | **新建文件或项目** | **Qt** | **Qt Designer 表单类**。这里有几个表单模板；您将认出主窗口，这是我们在启动
    `todo` 应用程序项目时 Qt Creator 为我们创建的。选择 **小部件** 并将类命名为 `Task`，然后点击 **下一步**。以下是 Qt
    Creator 将执行的操作的摘要：
- en: Create a `Task.h` file and a `Task.cpp` file.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `Task.h` 文件和一个 `Task.cpp` 文件。
- en: Create the associated `Task.ui` and do the plumbing to connect it to `Task.h`.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建相关的 `Task.ui` 并进行管道连接，将其连接到 `Task.h`。
- en: Add these three new files to `todo.pro` so they can be compiled.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这三个新文件添加到 `todo.pro` 中，以便它们可以被编译。
- en: 'Finish and, voilÃ , the `Task` class is ready to be filled. We will jump into
    the `Task.ui` first. Start by dragging and dropping a `Check Box` (put `checkbox`
    in the `objectName`) and a `Push Button` (`objectName` = `removeButton`):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 完成，然后，`Task` 类就准备好了，可以填充。我们将首先跳转到 `Task.ui`。首先，拖放一个 `Check Box`（将 `checkbox`
    放入 `objectName`）和一个 `Push Button` (`objectName` = `removeButton`)：
- en: '![Custom QWidget](img/image00356.jpeg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![自定义 QWidget](img/image00356.jpeg)'
- en: My alignment looks great, let's ship this to the customers!
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我的对齐看起来很棒，让我们把它发给客户吧！
- en: 'Unless you have a pixel-perfect eye, your items are not very well aligned.
    You need to indicate how your widgets should be laid out and how they should react
    when the window geometry changes (for example, when the user resizes the window).
    For this, Qt has several default layout classes:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 除非您有像素级的眼睛，否则您的小部件对齐得不是很好。您需要指示小部件应该如何布局以及当窗口几何形状改变时它们应该如何反应（例如，当用户调整窗口大小时）。为此，Qt
    提供了几个默认布局类：
- en: '`Vertical Layout`: In this layout, widgets are vertically stacked'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`垂直布局`: 在这种布局中，小部件垂直堆叠'
- en: '`Horizontal Layout`: In this layout, widgets are horizontally stacked'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`水平布局`: 在这种布局中，小部件水平堆叠'
- en: '`Grid Layout`: In this layout, widgets are arranged in a grid that can be subdivided
    into smaller cells'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`网格布局`: 在这种布局中，小部件被排列在一个可以细分到更小单元格的网格中'
- en: '`Form Layout`: In this layout, widgets are arranged like a web form, a label,
    and an input'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`表单布局`: 在这种布局中，小部件排列得像网页表单，一个标签和一个输入'
- en: Every layout will try to constrain all widgets to occupy equal surfaces. It
    will either change the widgets' shape or add extra margins, depending on each
    widget's constraints. A `Check Box` will not be stretched but a `Push Button`
    will.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 每个布局都会尝试将所有小部件约束在相等表面上。它将根据每个小部件的约束更改小部件的形状或添加额外的边距。一个复选框不会被拉伸，但一个按钮会被拉伸。
- en: In our `Task` object, we want this to be horizontally stacked. In the **Form
    Editor** tab, right-click on the window and select **Lay out** | **Lay out Horizontally**.
    Each time you add a new widget in this layout, it will be arranged horizontally.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `Task` 对象中，我们希望这些是水平堆叠的。在 **表单编辑器** 选项卡中，右键单击窗口并选择 **布局** | **水平布局**。每次您在此布局中添加新小部件时，它都将水平排列。
- en: Now add a `Push Button (objectName = editButton)` line just after the `checkbox`
    object.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在 `checkbox` 对象之后添加一行 `Push Button (objectName = editButton)`。
- en: 'The **Form Editor** window offers a realistic preview of how your UI will render.
    If you stretch the window now, you can observe how each widget will react to this
    event. When resizing horizontally, you can note that the push buttons are stretched.
    It looks bad. We need something to "hint" to the layout that these buttons should
    not be stretched. Enter the `Spacer` widget. Take the `Horizontal Spacer` in the
    widget box and drop it after the `checkbox` object:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**表单编辑器**窗口提供了你UI渲染的逼真预览。如果你现在拉伸窗口，你可以观察到每个部件将如何对此事件做出反应。当水平调整大小时，你可以注意到按钮被拉伸了。这看起来很糟糕。我们需要一些“提示”布局，这些按钮不应该被拉伸。进入`Spacer`部件。在部件框中取`Horizontal
    Spacer`，并将其放在`checkbox`对象之后：'
- en: '![Custom QWidget](img/image00357.jpeg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![自定义QWidget](img/image00357.jpeg)'
- en: A spacer is a special widget that tries to push (horizontally or vertically)
    adjacent widgets to force them to take up as little space as possible. The `editButton`
    and `removeButton` objects now take up only the space of their text and will be
    pushed to the edge of the window when it is resized.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 空间部件是一个特殊的部件，它试图将相邻的部件（水平或垂直）推到一边，迫使它们尽可能少地占用空间。`editButton`和`removeButton`对象现在只占用它们的文本空间，当窗口大小调整时，它们将被推到窗口的边缘。
- en: You can add sub layouts of any type in a form (vertical, horizontal, grid, form)
    and create a complex-looking application with a combination of widgets, spacers,
    and layouts. These tools are targeted at designing a good-looking desktop application
    that can react properly to different window geometries.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在表单中添加任何类型的子布局（垂直、水平、网格、表单），并通过组合部件、空间和布局创建一个看起来复杂的应用程序。这些工具旨在设计一个能够正确响应不同窗口几何形状的桌面应用程序。
- en: 'The Designer part is finished, so we can switch to the `Task` source code.
    Since we created a Qt Designer Form class, `Task` is closely linked to its UI.
    We will use this as leverage to store our model in a single place. When we create
    a `Task` object, it has to have a name:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 设计器部分已完成，因此我们可以切换到`Task`源代码。由于我们创建了一个Qt Designer表单类，`Task`与其UI紧密相关。我们将利用这一点将模型存储在单个位置。当我们创建一个`Task`对象时，它必须有一个名称：
- en: '[PRE10]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The constructor specifies a name, and as you can see there are no private fields
    storing any state of the object. All this will be done in the form part. We also
    added some getters and setters that will interact with the form. It is better
    to have a model completely separated from the UI, but our example is simple enough
    to merge them. Moreover, `Task` implementation details are hidden from the outside
    world and can still be refactored later on. Here is the content of the `Task.cpp`
    file:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数指定了一个名称，正如你所见，没有私有字段存储对象的任何状态。所有这些都将通过表单部分来完成。我们还添加了一些getter和setter，它们将与表单交互。最好将模型与UI完全分离，但我们的示例足够简单，可以合并它们。此外，`Task`的实现细节对外界是隐藏的，并且可以在以后进行重构。以下是`Task.cpp`文件的内容：
- en: '[PRE11]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The implementation is straightforward; we store the information in our `ui->checkbox`
    and the `name()` and `isCompleted()` getters take their data from the `ui->checkbox`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 实现很简单；我们在`ui->checkbox`中存储信息，`name()`和`isCompleted()`getter从`ui->checkbox`中获取数据。
- en: Adding a task
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加任务
- en: 'We will now rearrange the layout of `MainWindow` to be able to display our
    todo tasks. Right now, there is no widget where we can display our tasks. Open
    the `MainWindow.ui` file and edit it to get the following result:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将重新排列`MainWindow`的布局，以便能够显示我们的待办任务。目前，我们没有可以显示任务的部件。打开`MainWindow.ui`文件并编辑它以获得以下结果：
- en: '![Adding a task](img/image00358.jpeg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![添加任务](img/image00358.jpeg)'
- en: 'If we detail the content, we have:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们详细说明内容，我们有：
- en: A vertical layout for `centralWidget` containing the `toolbarLayout` file and
    the `tasksLayout` file.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含`toolbarLayout`文件和`tasksLayout`文件的`centralWidget`的垂直布局。
- en: A vertical spacer pushing these layouts to the top, forcing them to take up
    the smallest possible space.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个垂直空间将这些布局推到顶部，迫使它们占用尽可能小的空间。
- en: We got rid of `menuBar`, `mainToolBar`, and `statusBar`. Qt Creator created
    them automatically, we simply don't need them for our purposes. You can guess
    their uses from their names.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们去掉了`menuBar`、`mainToolBar`和`statusBar`。Qt Creator会自动创建它们，我们只是不需要它们来完成我们的目的。你可以从它们的名字中猜测它们的用途。
- en: Do not forget to rename the `MainWindow` title to `Todo` by selecting the **MainWindow**
    in the **Object Inspector** window and editing the **Qwidget** | **windowTitle**
    property. Your app deserves to be named properly.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记通过在**对象检查器**窗口中选择**MainWindow**并编辑**Qwidget** | **windowTitle**属性，将`MainWindow`的标题重命名为`Todo`。你的应用程序值得有一个合适的名字。
- en: Tip
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Qt Tip**'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**Qt小贴士**'
- en: Press *Shift* + *F4* in Designer mode to switch between the form editor and
    the source.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计模式中按*Shift* + *F4*切换到表单编辑器和源代码。
- en: 'Now that the `MainWindow` UI is ready to welcome tasks, let''s switch to the
    code part. The application has to keep track of the new tasks. Add the following
    in the `MainWindow.h` file:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`MainWindow` UI已经准备好欢迎任务，让我们切换到代码部分。应用程序必须跟踪新任务。在`MainWindow.h`文件中添加以下内容：
- en: '[PRE12]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `QVector` is the Qt container class providing a dynamic array, which is
    an equivalent of the `std::vector`. As a general rule, STL containers are more
    customizable but might miss some features compared to Qt containers. If you use
    C++11 smart pointers, you should favor `std` containers, but we will get into
    that later.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`QVector`是Qt容器类，提供动态数组，相当于`std::vector`。作为一个一般规则，STL容器更可定制，但可能缺少一些与Qt容器相比的功能。如果你使用C++11智能指针，你应该优先使用`std`容器，但我们会稍后讨论这一点。'
- en: 'In the Qt documentation of `QVector`, you might stumble upon the following
    statement: "*For most purposes,* `QList` *is the right class to use*". There is
    a debate about this in the Qt community:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在Qt的`QVector`文档中，你可能会遇到以下说法：“*对于大多数用途，* `QList` *是正确的类来使用*”。在Qt社区中对此有争议：
- en: Do you often need to insert objects larger than a pointer at the beginning or
    in the middle of your array? Use a `QList` class.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是否经常需要在数组的开始或中间插入比指针更大的对象？请使用`QList`类。
- en: Need contiguous memory allocation? Less CPU and memory overhead? Use a `QVector`
    class.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要连续内存分配？更少的CPU和内存开销？请使用`QVector`类。
- en: The already added slot `addTask()` will now be called each time we want to add
    a new `Task` object to the `mTasks` function.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 已经添加的槽`addTask()`现在将在我们想要将新的`Task`对象添加到`mTasks`函数时被调用。
- en: 'Let''s fill our `QVector` tasks each time `addTaskButton` is clicked. First,
    we connect the `clicked()` signal in the `MainWindow.cpp` file:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 每次点击`addTaskButton`时，让我们填充我们的`QVector`任务。首先，在`MainWindow.cpp`文件中连接`clicked()`信号：
- en: '[PRE13]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Tip
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**C++ tip**'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**C++小贴士**'
- en: As a best practice, try to always initialize member variables in the initializer
    list and respect the order of variable declarations. Your code will run faster
    and you will avoid unnecessary variable copies. Take a look at the standard C++
    documentation at [https://isocpp.org/wiki/faq/ctors#init-lists](https://isocpp.org/wiki/faq/ctors#init-lists).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最佳实践，尽量始终在初始化列表中初始化成员变量，并尊重变量声明的顺序。这样你的代码将运行得更快，并且可以避免不必要的变量复制。请查看标准C++文档[https://isocpp.org/wiki/faq/ctors#init-lists](https://isocpp.org/wiki/faq/ctors#init-lists)。
- en: 'The body of the `addTask()` function should look like this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`addTask()`函数的主体应该如下所示：'
- en: '[PRE14]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We created a new task and added it to our `mTask` vector. Because Task is a `QWidget`,
    we also added it directly to the `tasksLayout`. An important thing to note here
    is that we never managed this new task's memory. Where is the `delete task` instruction?
    This is a key feature of the Qt Framework we started to broach earlier in the
    chapter; the `QObject` class parenting automatically handles object destruction.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个新的任务并将其添加到我们的`mTask`向量中。因为`Task`是一个`QWidget`，所以我们直接将其添加到`tasksLayout`中。这里需要注意的是，我们从未管理过这个新任务的内存。`delete
    task`指令在哪里？这是我们在本章早期开始探讨的Qt框架的关键特性；`QObject`类会自动处理对象销毁。
- en: In our case, the `ui->tasksLayout->addWidget(task)` call has an interesting
    side-effect; the ownership of the task is transferred to `tasksLayout`. The `QObject*`
    parent defined in `Task` constructor is now `tasksLayout`, and the `Task` destructor
    will be called when `tasksLayout` releases its own memory by recursively iterating
    through its children and calling their destructor.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，`ui->tasksLayout->addWidget(task)`调用有一个有趣的副作用；任务的所有权被转移到了`tasksLayout`。在`Task`构造函数中定义的`QObject*`父类现在是`tasksLayout`，当`tasksLayout`通过递归遍历其子项并调用它们的析构函数来释放自己的内存时，将调用`Task`的析构函数。
- en: 'This will happen at this precise moment:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在这一精确时刻发生：
- en: '[PRE15]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When `MainWindow` is released (remember, it's a stack variable allocated in
    the `main.cpp` file), it will call `delete ui`, which in turn will bring down
    the whole `QObject` hierarchy. This feature has interesting consequences. First,
    if you use the `QObject` parenting model in your application, you will have much
    less memory to manage. Second, it can collide with some new C++11 semantics, specifically
    the smart pointers. We will get into that in later chapters.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当`MainWindow`被释放（记住，它是在`main.cpp`文件中分配的栈变量），它将调用`delete ui`，这反过来又会使整个`QObject`层次结构崩溃。这个特性有一些有趣的后果。首先，如果你在应用程序中使用`QObject`父子模型，你将需要管理的内存将少得多。其次，它可能与一些新的C++11语义冲突，特别是智能指针。我们将在后面的章节中讨论这一点。
- en: Using a QDialog
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`QDialog`
- en: 'We deserve something better than an untitled task. The user needs to define
    its name when it''s created. The easiest path would be to display a dialog where
    the user can input the task name. Fortunately Qt offers us a very configurable
    dialog that fits perfectly in `addTask()`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该得到比未命名的任务更好的东西。用户在创建时需要定义其名称。最简单的方法是显示一个对话框，用户可以在其中输入任务名称。幸运的是，Qt为我们提供了一个非常可配置的对话框，它完美地适用于`addTask()`：
- en: '[PRE16]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `QinputDialog::getText` function is a static blocking function that displays
    the dialog. When the user validates/cancels the dialog, the code continues. If
    we run the application and try to add a new task, we''ll see this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`QinputDialog::getText`函数是一个静态阻塞函数，用于显示对话框。当用户验证/取消对话框时，代码继续执行。如果我们运行应用程序并尝试添加一个新任务，我们会看到以下内容：'
- en: '![Using a QDialog](img/image00359.jpeg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![使用`QDialog`](img/image00359.jpeg)'
- en: 'The `QInputDialog::getText` signature looks like this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`QInputDialog::getText`的签名如下：'
- en: '[PRE17]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s break it down:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下：
- en: '`parent`: This is the parent widget (`MainWindow`) to which the `QinputDialog`
    is attached. This is another instance of the `QObject` class''s parenting model.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parent`: 这是`QinputDialog`附加到的父小部件（`MainWindow`）。这是`QObject`类父子模型的另一个实例。'
- en: '`title`: This is the title displayed in the window title. In our example, we
    use `tr("Add task")`, which is how Qt handles i18n in your code. We will see later
    on how to provide multiple translations for a given string.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title`: 这是窗口标题中显示的标题。在我们的示例中，我们使用`tr("Add task")`，这是Qt处理代码中的i18n的方式。我们将在稍后看到如何为给定的字符串提供多个翻译。'
- en: '`label`: This is the label displayed right above the input text field.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`label`: 这是在输入文本字段上方显示的标签。'
- en: '`mode`: This is how the input field is rendered (password mode will hide the
    text).'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mode`: 这是指输入字段如何渲染（密码模式将隐藏文本）。'
- en: '`ok`: This is a pointer to a variable that is set to true if the user presses **OK**
    and to false if the user presses **Cancel**.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ok`: 这是一个指向变量的指针，如果用户按下**OK**，则将其设置为true；如果用户按下**Cancel**，则将其设置为false。'
- en: '`QString`: The returned `QString` is what the user has typed.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QString`: 返回的`QString`是用户输入的内容。'
- en: There are a few more optional parameters we can safely ignore for our example.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，还有一些可选参数我们可以安全忽略。
- en: Distributing code responsibility
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分配代码责任
- en: 'Great, the user can now specify the task name when it''s created. What if he
    makes an error when typing the name? The next logical step is to rename the task
    after we created it. We''ll take a slightly different approach. We want our `Task`
    to be as autonomous as possible. If we attach it to another component (rather
    than `MainWindow`), this renaming feature has to keep working. Thus, this responsibility
    has to be given to the `Task` class:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，用户现在可以在创建任务时指定任务名称。如果他输入名称时出错怎么办？下一个合乎逻辑的步骤是在创建任务后重命名它。我们将采取稍微不同的方法。我们希望我们的`Task`尽可能自主。如果我们将其附加到另一个组件（而不是`MainWindow`），这个重命名功能必须继续工作。因此，这个责任必须交给`Task`类：
- en: '[PRE18]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We add a public slot `rename()` to connect it to a signal. The body of `rename()`
    reuses what we had previously covered with `QInputDialog`. The only difference
    is the `QInputDialog` default value, which is the current task name. When `setName(value)`
    is called, the UI is instantly refreshed with the new value; there's nothing to
    synchronize or update, the Qt main loop will do its job.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个公共槽`rename()`来将其连接到信号。`rename()`函数的主体重用了我们之前用`QInputDialog`覆盖的内容。唯一的区别是`QInputDialog`的默认值，它是当前任务名称。当调用`setName(value)`时，UI会立即刷新为新值；无需同步或更新，Qt主循环会完成其工作。
- en: The nice thing is that `Task::rename()` is completely autonomous. Nothing has
    been modified in `MainWindow`, so we have effectively zero coupling between our `Task`
    and the parent `QWidget`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 好处在于`Task::rename()`是完全自主的。在`MainWindow`中没有进行任何修改，因此我们实际上在`Task`和父`QWidget`之间有零耦合。
- en: Emitting a custom signal using lambdas
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `lambda` 发出自定义信号
- en: 'The remove task is straightforward to implement, but we''ll study some new
    concepts along the way. The `Task` has to notify its owner and parent (`MainWindow`)
    that the `removeTaskButton``QPushButton` has been clicked. We''ll implement this
    by defining a custom signal `removed` in `Task.h` files:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 删除任务的操作实现起来很简单，但我们在过程中会学习一些新概念。`Task` 必须通知其所有者和父类（`MainWindow`），`removeTaskButton`（`QPushButton`）已被点击。我们将在
    `Task.h` 文件中定义一个自定义信号 `removed` 来实现这一点：
- en: '[PRE19]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Like we did for the slots, we have to add the Qt keyword signals in our header.
    Since a `signal` is used only to notify another class, the `public` keyword is
    not needed (it even raises a compilation error). A `signal` is simply a notification
    sent to the receiver (the connected `slot`); it implies that there is no function
    body for the `removed(Task* task)` function. We added the `task` parameter to
    allow the receiver to know which task asked to be removed. The next step is to
    emit the `removed` signal upon the `removeButton` click. This is done in the `Task.cpp`
    file:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们对槽函数所做的那样，我们必须在我们的头文件中添加 Qt 关键字信号。由于 `signal` 只用于通知另一个类，因此不需要 `public` 关键字（它甚至会导致编译错误）。`signal`
    简单地是一个发送给接收者（连接的 `slot`）的通知；它意味着 `removed(Task* task)` 函数没有函数体。我们添加了 `task` 参数，以便接收者知道哪个任务请求被删除。下一步是在
    `removeButton` 点击时发出 `removed` 信号。这是在 `Task.cpp` 文件中完成的：
- en: '[PRE20]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This code excerpt shows a very interesting feature of C++11: `lambdas`. In
    our example, the `lambda` is the following part:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码摘录展示了 C++11 的一个非常有趣的功能：`lambda` 表达式。在我们的例子中，`lambda` 表达式是以下部分：
- en: '[PRE21]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: What we did here is to connect the clicked signal to an anonymous inline function,
    a `lambda`. Qt allows signal relaying by connecting a signal to another signal
    if their signatures match. It's not the case here; the `clicked` signal has no
    parameter and the `removed` signal needs a `Task*`. A `lambda` avoids the declaration
    of a verbose `slot` in `Task`. Qt 5 accepts a `lambda` instead of a slot in a `connect`,
    and both syntaxes can be used.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的就是将点击信号连接到一个匿名内联函数，一个 `lambda`。Qt 允许通过将一个信号连接到另一个信号（如果它们的签名匹配）来传递信号。这里不是这种情况；`clicked`
    信号没有参数，而 `removed` 信号需要一个 `Task*`。`lambda` 避免了在 `Task` 中声明冗长的 `slot`。Qt 5 接受 `lambda`
    而不是槽函数在 `connect` 中，并且两种语法都可以使用。
- en: Our `lambda` executes a single line of code: `emit removed(this)`. `Emit` is
    a Qt macro that will immediately trigger the connected `slot` with what we passed
    in a parameter. As we said earlier, `removed(Task* this)` has no function body,
    its purpose is to notify the registered slot of an event.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `lambda` 执行一行代码：`emit removed(this)`。`Emit` 是一个 Qt 宏，它将立即触发连接的 `slot` 并传递我们作为参数传递的内容。正如我们之前所说的，`removed(Task*
    this)` 没有函数体，它的目的是通知已注册的槽函数一个事件。
- en: 'Lambdas are a great addition to C++. They offer a very practical way of defining
    short functions in your code. Technically, a `lambda` is the construction of a
    closure capable of capturing variables in its scope. The full syntax goes like
    this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`lambda` 是 C++ 的一个很好的补充。它们提供了一种非常实用的方法来定义代码中的短函数。技术上讲，`lambda` 是一个能够捕获其作用域内变量的闭包的构造。完整的语法如下：'
- en: '[PRE22]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: "Letâ\x80\x99s study each part of this statement:"
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们研究这个语句的每一部分：
- en: '`capture-list`: This defines what variables will be visible inside the `lambda`
    scope.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`capture-list`：这定义了在 `lambda` 范围内可见的变量。'
- en: '`params`: This is the function parameters type list that can be passed to the `lambda`
    scope. There are no parameters in our case, We might have written `[this] () {
    ... }`, but C++11 lets us skip the parentheses altogether.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`params`：这是可以传递到 `lambda` 范围的函数参数类型列表。在我们的例子中没有参数，我们可能会写成 `[this] () { ...
    }`，但 C++11 允许我们完全省略括号。'
- en: '`ret`: This is the return type of the `lambda` function. Just like `params`,
    this parameter can be omitted if the return type is `void`.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ret`：这是 `lambda` 函数的返回类型。就像 `params` 一样，如果返回类型是 `void`，则可以省略此参数。'
- en: '`body`: This is obviously your code body where you have access to your `capture-list`,
    and `params`, and which must return a variable with a type `ret`.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`body`：这显然是你的代码主体，其中你可以访问你的 `capture-list` 和 `params`，并且必须返回一个类型为 `ret` 的变量。'
- en: 'In our example, we captured the `this` pointer to be able to:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们捕获了 `this` 指针以便能够：
- en: 'Have a reference on the `removed()` function, which is a part of the `Task`
    class. If we did not capture `this`, the compiler would have shouted `error: ''this''
    was not captured for this lambda function emit removed(this);`.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '参考一下 `removed()` 函数，它是 `Task` 类的一部分。如果我们没有捕获 `this`，编译器会报错：`error: ''this''
    was not captured for this lambda function emit removed(this);`。'
- en: Pass `this` to the `removed` signal; the caller needs to know which task triggered `removed`.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `this` 传递给 `removed` 信号；调用者需要知道哪个任务触发了 `removed`。
- en: 'The `capture-list` relies on standard C++ semantics: capture variables by copy
    or by reference. Let us say that we wanted to print a log of the constructor parameter `name`
    and we capture it by reference in our `lambda`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`capture-list` 依赖于标准的 C++ 语义：通过复制或引用捕获变量。假设我们想要打印构造函数参数 `name` 的日志，并在我们的 `lambda`
    中通过引用捕获它：'
- en: '[PRE23]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This code will compile fine. Unfortunately, the runtime will crash with a dazzling
    segmentation fault when we try to remove a `Task`. What happened? As we said,
    our `lambda` is an anonymous function that will be executed when the `clicked()`
    signal has been emitted. We captured the `name` reference, but this reference
    may be `-` and is `-` invalid once we get out of `Task` constructor (more precisely,
    from the caller scope). The `qDebug()` function will then try to display an unreachable
    code and crash.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以正常编译。不幸的是，当我们尝试移除一个 `Task` 时，运行时会因为一个耀眼的段错误而崩溃。发生了什么？正如我们所说，我们的 `lambda`
    是一个匿名函数，它将在 `clicked()` 信号被发射时执行。我们捕获了 `name` 引用，但这个引用可能是 `-`，一旦我们离开 `Task` 构造函数（更准确地说，从调用者作用域），这个引用就变得无效了。然后
    `qDebug()` 函数将尝试显示一个不可达的代码并崩溃。
- en: 'You really want to be careful with what you capture and the context in which
    your lambda will be executed. In this example, the segmentation fault can be amended
    by capturing the `name` by copy:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你真的需要小心你捕获的内容以及你的 lambda 将被执行的上下文。在这个例子中，可以通过通过复制捕获 `name` 来修正段错误：
- en: '[PRE24]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Tip
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**C++ Tip**'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**C++ 小贴士**'
- en: You can capture by copy or reference all variables that are reachable in the
    function where you define your lambda with the syntax [`=`] and [`&`].
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 `=` 和 `&` 语法捕获在定义 lambda 的函数中可到达的所有变量。
- en: The `this` variable is a special case of the capture list. You cannot capture
    it by reference `[&this]` and the compiler will warn you if you are in this situation: `[=,
    this]`. Don't do this. Kittens will die.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`this` 变量是捕获列表的一个特例。你不能通过引用 `[&this]` 来捕获它，如果你处于这种情况，编译器会警告你：`[=, this]`。不要这样做。小猫会死的。'
- en: 'Our `lambda` is passed directly as a parameter to the connect function. In
    other words, the `lambda` is variable. This has many consequences: we can call
    it, assign it, and return it. To illustrate a "fully formed" `lambda`, we can
    define one that returns a formatted version of the task name. The sole purpose
    of this snippet is to investigate the `lambda` function''s machinery. Don''t include
    the following code in your `todo` app, your colleagues might call you something
    like a "functional zealot":'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `lambda` 直接作为参数传递给 connect 函数。换句话说，这个 `lambda` 是一个变量。这有很多后果：我们可以调用它、赋值给它，并返回它。为了说明一个“完全形成”的
    `lambda`，我们可以定义一个返回任务名称格式化版本的 `lambda`。这个代码片段的唯一目的是调查 `lambda` 函数的机制。不要将以下代码包含在你的
    `todo` 应用程序中，你的同事可能会称你为“函数狂热者”：
- en: '[PRE25]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here we did a tricky thing. We called `qDebug()`; inside this call we defined
    a `lambda` which is immediately executed. Let''s analyze it:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们做了一件巧妙的事情。我们调用了 `qDebug()`；在这个调用中我们定义了一个立即执行的 `lambda`。让我们分析一下：
- en: '`[]`: We performed no capture. The `lambda` does not depend on the enclosing
    function.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[]`: 我们没有进行捕获。这个 `lambda` 不依赖于封装的函数。'
- en: '`(const Qstring& taskName)`: When this lambda is called, it will expect a `QString`
    to work on.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(const QString& taskName)`: 当这个 lambda 被调用时，它将期望一个 `QString` 来工作。'
- en: '`-> QString`: The returned value of the lambda will be a `QString`.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-> QString`: 返回的 lambda 表达式的值将是一个 `QString`。'
- en: '`return "------- " + taskName.toUpper()`: the body of our `lambda`. We return
    a concatenation of a string and the uppercase version of the parameter `taskName`.
    As you can see, string manipulation becomes a lot easier with Qt.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`return "------- " + taskName.toUpper()`: 我们 lambda 的主体。如您所见，使用 Qt，字符串操作变得容易得多。'
- en: '`(name)`: Here comes the catch. Now that the `lambda` function is defined,
    we can call it passing the `name` parameter. In a single instruction, we define
    it and call it. The `QDebug()` function will simply print the result.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(name)`: 现在到了关键点。现在 `lambda` 函数已经定义，我们可以通过传递 `name` 参数来调用它。在一条指令中，我们定义并调用它。`QDebug()`
    函数将简单地打印结果。'
- en: The real benefit of this `lambda` will emerge if we are able to assign it to
    a variable and call it multiple times. C++ is statically typed, so we must provide
    the type of our `lambda` variable. In the language specification, a `lambda` type
    cannot be explicitly defined. We'll see soon how we can do it with C++11\. For
    now, let's finish our remove feature.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能将这个 `lambda` 赋值给一个变量并多次调用它，这个 `lambda` 的真正好处就会显现出来。C++ 是静态类型的，因此我们必须提供
    `lambda` 变量的类型。在语言规范中，`lambda` 类型不能显式定义。我们将很快看到如何使用 C++11 来实现它。现在，让我们完成我们的删除功能。
- en: 'Task now emits the `removed()` signal. This signal has to be consumed by `MainWindow`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 任务现在发出 `removed()` 信号。这个信号必须由 `MainWindow` 消费：
- en: '[PRE26]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `MainWindow::removeTask()` must match the signal signature. The connection
    is made when the task is created. The interesting part comes in the implementation
    of  `MainWindow::removeTask()`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainWindow::removeTask()` 函数必须匹配信号签名。当任务创建时建立连接。有趣的部分在于 `MainWindow::removeTask()`
    的实现。'
- en: The task is first removed from the `mTasks` vector. It is then removed from `tasksLayout`.
    Here, `tasksLayout` releases its ownership of `task` (that is, `tasksLayout` ceases
    to be the `task` class's parent).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 任务首先从 `mTasks` 向量中删除。然后从 `tasksLayout` 中删除。在这里，`tasksLayout` 释放了对 `task` 的所有权（即，`tasksLayout`
    停止成为 `task` 类的父类）。
- en: 'So far so good. The next two lines are interesting. The ownership transfer
    does not completely release the `task` class ownership. If we commented these
    lines, here is how `removeTask()` will look:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切顺利。接下来的两行很有趣。所有权转移并没有完全释放 `task` 类的所有权。如果我们注释掉这些行，`removeTask()` 将会看起来像这样：
- en: '[PRE27]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If you add a log message in `Task` destructor and execute the program, this
    log message will be displayed. Nonetheless, the Qt documentation tells us in `Qlayout::removeWidget`
    part: *The ownership of a widget remains the same as when it was added*.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 `Task` 析构函数中添加日志消息并执行程序，这个日志消息将会显示。然而，Qt 文档告诉我们，在 `Qlayout::removeWidget`
    部分：*小部件的所有权保持不变，就像它被添加时一样*。
- en: Instead, what really happens is that the `task` class's parent becomes `centralWidget`,
    the `tasksLayout` class's parent. We want Qt to forget everything about `task`,
    that's why we call `task->setParent(0)`. We can then safely delete it and call
    it a day.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上发生的情况是，`task` 类的父类变成了 `centralWidget`，`tasksLayout` 类的父类。我们希望 Qt 忘记关于 `task`
    的所有信息，这就是为什么我们调用 `task->setParent(0)`。然后我们可以安全地删除它并结束。
- en: Simplifying with the auto type and a range-based for loop
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `auto` 类型和一个基于范围的 for 循环简化
- en: 'The final step to a complete CRUD of our tasks is to implement the completed
    task feature. We''ll implement the following:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 完成我们任务系统的 CRUD 功能的最终一步是实现已完成任务功能。我们将实现以下功能：
- en: Click on the checkbox to mark the task as completed
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击复选框以标记任务为已完成
- en: Strike the task name
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除任务名称
- en: Update the status label in `MainWindow`
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新 `MainWindow` 中的状态标签
- en: 'The checkbox click handling follows the same pattern as `removed`:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 复选框点击处理遵循与 `removed` 相同的模式：
- en: '[PRE28]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We define a slot `checked(bool checked)` that will be connected to the `checkbox::toggled`
    signal. In our `slot checked()`, we strike out the `checkbox` text according to
    the `bool checked` value. This is done using the `QFont` class. We create a copy
    font from the `checkbox->font()`, modify it, and assign it back to `ui->checkbox`.
    If the original `font` was in bold, with a special size, its appearance would
    be guaranteed to stay the same.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义一个槽 `checked(bool checked)`，它将被连接到 `checkbox::toggled` 信号。在我们的 `slot checked()`
    中，根据 `bool checked` 值划掉 `checkbox` 文本。这是使用 `QFont` 类完成的。我们创建一个从 `checkbox->font()`
    的副本字体，修改它，并将其重新分配给 `ui->checkbox`。如果原始的 `font` 是加粗的，具有特殊大小，其外观将保证保持不变。
- en: Tip
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Play around with the font object in Qt Designer. Select the `checkbox` in the `Task.ui`
    file and go to **Properties Editor** | **QWidget** | **font**.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Qt Designer 中玩转字体对象。选择 `Task.ui` 文件中的 `checkbox` 并转到 **属性编辑器** | **QWidget**
    | **字体**。
- en: 'The last instruction notifies `MainWindow` that the `Task` status has changed.
    The signal name is `statusChanged`, rather than `checkboxChecked`, to hide the
    implementation details of the task. Add the following code in the `MainWindow.h`
    file:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一条指令通知 `MainWindow` 任务的状态已更改。信号名称是 `statusChanged`，而不是 `checkboxChecked`，以隐藏任务的实现细节。在
    `MainWindow.h` 文件中添加以下代码：
- en: '[PRE29]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We defined a slot `taskStatusChanged`, which is connected when a task is created.
    The single instruction of this `slot` is to call `updateStatus()`. This function
    iterates through the tasks and updates the `statusLabel`. The `updateStatus()`
    function is called upon task creation and deletion.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个槽 `taskStatusChanged`，当任务创建时与之连接。这个 `slot` 的单一指令是调用 `updateStatus()`。这个函数遍历任务并更新
    `statusLabel`。`updateStatus()` 函数在任务创建和删除时被调用。
- en: 'In `updateStatus()`, we meet more new C++11 semantics:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `updateStatus()` 中，我们遇到了更多新的 C++11 语义：
- en: '[PRE30]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `for` keyword lets us loop over a range-based container. Because `QVector`
    is an iterable container, we can use it here. The range declaration (`auto t`)
    is the type and variable name that will be assigned at each iteration. The range
    expression (`mTasks`) is simply the container on which the process will be done.
    Qt provides a custom implementation of the `for` (namely `foreach`) loop targeted
    at prior versions of C++; you don't need it anymore.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 关键字让我们可以遍历基于范围的容器。因为 `QVector` 是一个可迭代的容器，所以我们可以在这里使用它。范围声明（`auto t`）是每次迭代将被分配的类型和变量名。范围表达式（`mTasks`）简单地是执行过程将进行的容器。Qt
    为 C++ 早期版本提供了一个针对 `for` 循环（即 `foreach`）的定制实现；你不再需要它了。'
- en: 'The `auto` keyword is another great new semantic. The compiler deduces the
    variable type automatically based on the initializer. It relieves a lot of pain
    for cryptic iterators such as this:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`auto` 关键字是另一个伟大的新语义。编译器根据初始化器自动推断变量类型。它为诸如这样的神秘迭代器减轻了许多痛苦：'
- en: '[PRE31]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Since C++14, `auto` can even be used for function return types. It's a fabulous
    tool, but use it sparingly. If you put `auto`, the type should be obvious from
    the signature name/variable name.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 自 C++14 以来，`auto` 甚至可以用于函数返回类型。这是一个了不起的工具，但请谨慎使用。如果你使用 `auto`，类型应该从签名名称/变量名中明显可见。
- en: Tip
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'The `auto` keyword can be combined with `const` and references. You can write
    a for loop like this: `for (const auto & t : mTasks) { ... }`.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`auto` 关键字可以与 `const` 和引用结合使用。你可以编写这样的 for 循环：`for (const auto & t : mTasks)
    { ... }`。'
- en: 'Remember our half bread `lambda`? With all the covered features, we can write:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们之前提到的半面包 `lambda` 吗？有了所有这些特性，我们可以写出：
- en: '[PRE32]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now that's something beautiful. Combining `auto` with `lambda` makes very readable
    code and opens up a world of possibilities.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在真是一件美丽的事情。将 `auto` 与 `lambda` 结合使用，可以编写出非常易读的代码，并开启了一个充满可能性的世界。
- en: 'The last item to study is the `QString` API. We used it in `updateStatus()`:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要学习的是 `QString` API。我们在 `updateStatus()` 中使用了它：
- en: '[PRE33]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The people behind Qt put a lot of work into making string manipulation bearable
    in C++. This is a perfect example, where we replace the classic C `sprintf` with
    a more modern and robust API. Arguments are position-based only, no need to specify
    the type (less error-prone), and the `arg(...)` function accepts all kinds of
    types.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 背后的开发者们投入了大量工作，使得在 C++ 中进行字符串操作变得可行。这是一个完美的例子，我们用更现代、更健壮的 API 替换了经典的 C `sprintf`。参数仅基于位置，无需指定类型（更不易出错），并且
    `arg(...)` 函数接受所有类型的参数。
- en: Tip
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Take some time to skim through the `QString` documentation at [http://doc.qt.io/qt-5/qstring.html](http://doc.qt.io/qt-5/qstring.html).
    It shows how much you can do with this class and you'll see yourself using fewer
    and fewer examples of `std string` or even `cstring`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 花些时间浏览一下 [http://doc.qt.io/qt-5/qstring.html](http://doc.qt.io/qt-5/qstring.html)
    上的 `QString` 文档。它展示了你可以用这个类做多少事情，你也会发现自己使用 `std string` 或 `cstring` 的例子越来越少。
- en: Summary
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we created a desktop Qt application from scratch. Qt is well
    known for its signal/slot mechanism and you must be confident with this paradigm.
    We also introduced some important C++14 features that will be used all through
    this book.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从零开始创建了一个桌面 Qt 应用程序。Qt 以其信号/槽机制而闻名，你必须对这种范式有信心。我们还介绍了一些重要的 C++14 特性，这些特性将贯穿整本书。
- en: It's now time to discover some `qmake` secrets and what is really done when
    you build your Qt project. In the next chapter, we will also talk about how to
    create and organize an application with some platform-dependent code that must
    run on Windows, Mac OS, and Linux.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候发现一些 `qmake` 的秘密了，以及当你构建 Qt 项目时实际上会发生什么。在下一章中，我们还将讨论如何创建和组织一个应用程序，其中包含必须在
    Windows、Mac OS 和 Linux 上运行的与平台相关的代码。
