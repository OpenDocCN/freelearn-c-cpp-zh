- en: Chapter 1.  Get Your Qt Feet Wet
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章。让你的 Qt 脚步湿透
- en: If you know C++ but have never touched Qt, or if you have made some intermediate
    Qt applications, this chapter will ensure that your Qt foundations are safe before
    studying advanced concepts in the following chapters.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉 C++ 但从未接触过 Qt，或者如果你已经制作了一些中级 Qt 应用程序，那么本章将确保你在学习以下章节的高级概念之前，Qt 的基础是安全的。
- en: We will teach you to create a simple todo application using Qt Creator. This
    application will display a list of tasks that you can create/update/delete. We
    will cover the Qt Creator and Qt Designer interfaces, an introduction to the signal/slot
    mechanism, the creation of a custom widget with custom signals/slots, and its
    integration into your application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将教你如何使用 Qt Creator 创建一个简单的待办事项应用程序。此应用程序将显示一个任务列表，你可以创建/更新/删除任务。我们将涵盖 Qt Creator
    和 Qt Designer 界面、信号/槽机制的介绍、创建具有自定义信号/槽的自定义小部件以及将其集成到你的应用程序中。
- en: 'You will implement a todo app using new C++14 semantics: lambdas, auto variables,
    and for loops. Each one of these concepts will be explained in depth and will
    be used throughout the book.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用新的 C++14 语义实现一个待办事项应用程序：lambda 表达式、auto 变量和 for 循环。这些概念将逐一深入解释，并在整本书中应用。
- en: At the end of this chapter, you will be able to create a desktop application
    with a flexible UI using Qt widgets and new C++ semantics.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束时，你将能够使用 Qt 小部件和新的 C++ 语义创建一个具有灵活 UI 的桌面应用程序。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Qt project basic structure
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt 项目基本结构
- en: Qt Designer interface
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt Designer 界面
- en: UI fundamentals
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI 基础
- en: Signals and slots
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号和槽
- en: Custom `QWidget`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义 `QWidget`
- en: C++14 lambda, auto, for each
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++14 lambda、auto、for each
- en: Creating a project
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建项目
- en: The first thing to do is to start Qt Creator.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 第一件事是启动 Qt Creator。
- en: In Qt Creator, you can create a new Qt project via **File** | **New File or
    Project** | **Application** | **Qt Widgets Application** | **Choose**.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Qt Creator 中，你可以通过 **文件** | **新建文件或项目** | **应用程序** | **Qt 小部件应用程序** | **选择**
    来创建一个新的 Qt 项目。
- en: 'The wizard will then guide you through four steps:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然后向导将引导你完成四个步骤：
- en: '**Location**: You must choose a project name and a location.'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**位置**：你必须选择一个项目名称和位置。'
- en: '**Kits**: Target platforms that your project aims at (Desktop, Android, and
    so on).'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**工具包**：你的项目目标平台（桌面、Android 等）。'
- en: '**Details**: Base class information and name for the generated class.'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**详情**：生成类的基类信息和名称。'
- en: '**Summary**: Allows you to configure your new project as a subproject and automatically
    add it to a version control system.'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**摘要**：允许你将你的新项目配置为子项目，并自动将其添加到版本控制系统。'
- en: Even if all default values can be kept, please at least set a useful project
    name such as "todo" or "TodoApp." We won't blame you if you want to call it "Untitled"
    or "Hello world."
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 即使可以保留所有默认值，也请至少设置一个有用的项目名称，例如 "todo" 或 "TodoApp"。如果你想要将其命名为 "Untitled" 或 "Hello
    world"，我们也不会责怪你。
- en: 'Once done, Qt Creator will generate several files that you can see in the **Projects**
    hierarchy view:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，Qt Creator 将生成几个文件，你可以在 **项目** 层级视图中看到它们：
- en: '![Creating a project](img/image00350.jpeg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![创建项目](img/image00350.jpeg)'
- en: The `.pro` file is Qt's configuration project file. As Qt adds specific file
    formats and C++ keywords, an intermediate build step is performed, parsing all
    files to generate final files. This process is done by `qmake`, an executable
    from the Qt SDK. It will also generate the final Makefiles for your project.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`.pro` 文件是 Qt 的配置项目文件。由于 Qt 添加了特定的文件格式和 C++ 关键字，因此会执行一个中间构建步骤，解析所有文件以生成最终文件。这个过程由
    `qmake`（Qt SDK 中的一个可执行文件）完成。它还将为你的项目生成最终的 Makefiles。'
- en: 'A basic `.pro` file generally contains:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一个基本的 `.pro` 文件通常包含：
- en: Qt modules used (`core`, `gui`, and so on)
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用的 Qt 模块（`core`、`gui` 等）
- en: Target name (`todo`, `todo.exe`, and so on)
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标名称（`todo`、`todo.exe` 等）
- en: Project template (`app`, `lib`, and so on)
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目模板（`app`、`lib` 等）
- en: Sources, headers, and forms
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源文件、头文件和表单
- en: 'There are some great features that come with Qt and C++14\. This book will
    showcase them in all its projects. For `GCC` and `CLANG` compilers, you must add `CONFIG
    += c++14` to the `.pro` file to enable C++14 on a Qt project, as shown in the
    following code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 和 C++14 提供了一些很棒的功能。本书将在所有项目中展示它们。对于 `GCC` 和 `CLANG` 编译器，你必须将 `CONFIG += c++14`
    添加到 `.pro` 文件中，以在 Qt 项目上启用 C++14，如下面的代码所示：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `MainWindow.h` and `MainWindow.cpp` files are the headers/sources for the `MainWindow`
    class. These files contain the default GUI generated by the wizard.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainWindow.h` 和 `MainWindow.cpp` 文件是 `MainWindow` 类的头文件/源文件。这些文件包含向导生成的默认
    GUI。'
- en: The `MainWindow.ui` file is your UI design file in XML format. It can be edited
    more easily with Qt Designer. This tool is a **WYSIWYG** (**What You See Is What
    You Get**) editor that helps you to add and adjust your graphical components (widgets).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `main.cpp` file, with its well-known function:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As usual, the `main.cpp` file contains the program entry point. It will, by
    default, perform two actions:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Instantiate and show your main window
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instantiate a `QApplication` and execute the blocking main event loop
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is the bottom-left toolbar for Qt Creator:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a project](img/image00351.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
- en: 'Use it to build and start your `todo` application in debug mode:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Check that the project is in **Debug** build mode.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the hammer button to build your project.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start debugging using the green Play button with a little blue bug.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will discover a wonderful and beautifully empty window. We will rectify
    this after explaining how this `MainWindow` is constructed:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a project](img/image00352.jpeg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
- en: An empty **MainWindow** screenshot
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Qt tip**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Press *Ctrl* + *B* (for Windows/Linux) or *Command* + *B* (for Mac) to build
    your project
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Press *F5* (for Windows / Linux) or *Command* +*R* (for Mac) to run your application
    in debug mode
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MainWindow structure
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This generated class is a perfect yet simple example of Qt framework usage;
    we will dissect it together. As mentioned previously, the `MainWindow.ui` file
    describes your UI design and `MainWindow.h`/ `MainWindow.cpp` is the C++ object
    where you can manipulate the UI with code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to take a look at the header file `MainWindow.h`. Our `MainWindow`
    object inherits from Qt''s `QMainWindow` class:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As our class inherits from the `QMainWindow` class, on top of the header file,
    we add the corresponding include. The second part is the forward declaration of
    the `Ui::MainWindow`, as we only declare a pointer.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: The `Q_OBJECT` can look a little strange to a non-Qt developer. This macro allows
    the class to define its own signals/slots and more globally Qt's meta-object system.
    These features will be covered later in this chapter.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: This class defines a public constructor and destructor. The latter is pretty
    common. But the constructor takes a parameter parent. This parameter is a `QWidget`
    pointer that is `null` by default.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: A `QWidget` is a UI component. It can be a label, a textbox, a button, and so
    on. If you define a parent-child relationship between your window, layout, and
    other UI widgets, memory management of your application will be easier. Indeed,
    in this case, deleting the parent is enough because its destructor will take care
    of also deleting its child, which in turn will delete its children and so on.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `MainWindow` class extends `QMainWindow` from the Qt framework. We have
    a `ui` member variable in the private fields. The type is a pointer of `Ui::MainWindow`,
    which is defined in the `ui_MainWindow.h` file generated by Qt. It''s the C++
    transcription of the UI design file `MainWindow.ui`. The `ui` member variable
    will allow you to interact with your UI components (`QLabel`, `QPushButton`, and
    so on) from C++, as shown in the following figure:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '![MainWindow structure](img/image00353.jpeg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
- en: Tip
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**C++ tip**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: If your class only uses pointers or references for a class type, you can avoid
    including the header by using forward declaration. That will drastically reduce
    compilation time.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Now that the header part is done, we can talk about the `MainWindow.cpp` source
    file.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code snippet, the first include is our class header. The second
    one is the include required by the generated class `Ui::MainWindow`. This include
    is required as we only use a forward declaration in the header:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In many cases, Qt generates a good piece of code using the initializer list.
    The `parent` argument is used to call the superclass constructor `QMainWindow`.
    Our private member variable `ui` is also initialized now.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that `ui` is initialized, we must call the `setupUi` function to initialize
    all widgets used by the `MainWindow.ui` design file:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'As we initialize a pointer in the constructor, it must be cleaned in the destructor:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Qt Designer
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Qt Designer is a major tool for developing Qt applications. This WYSIWYG editor
    will help you easily design your GUI. If you switch between **Edit** mode and **Design**
    mode for the `MainWindow.ui` file, you will see the real XML content and the designer:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '![Qt Designer](img/image00354.jpeg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
- en: 'The designer displays several parts:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '**Form Editor**: This is a visual representation of the form (empty for now)'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Widget Box**: This contains all widgets that can be used with your form'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Object Inspector**: This displays your form as a hierarchical tree'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Property Editor**: This enumerates the properties of the selected widget'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Action Editor/Signal & Slots Editor**: This handles connections between your
    objects'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's time to embellish this empty window! Let's drag and drop a **Label** widget
    from the **Display Widgets** section on the form. You can change the name and
    the text properties from the properties editor.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'As we are making a `todo` application, we suggest these properties:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '`objectName`: `statusLabel`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`text`: `Status: 0 todo/0 done`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This label will later display the count of `todo` tasks and the count of tasks
    already done. OK, save, build, and start your application. You should now see
    your new label in the window.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now add a push button with those properties:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '`objectName`: `addTaskButton`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`text`: `Add task`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You should get a result close to this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '![Qt Designer](img/image00355.jpeg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
- en: Tip
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Qt tip**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: You can edit the text property of a widget directly on your form by double-clicking
    on it!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Signals and slots
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Qt framework brings a flexible message exchange mechanism through three
    concepts: signals, slots, and connections:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: A `signal` is a message sent by an object
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `slot` is a function that will be called when this signal is triggered
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `connect` function specifies which `signal` is linked to which `slot`
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Qt already provides signals and slots for its classes, which you can use in
    your application. For example, `QPushButton` has a `signal clicked()`, which will
    be triggered when the user clicks on the button. The `QApplication` class has
    a `slot quit()` function, which can be called when you want to terminate your
    application.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is why you will love Qt signals and slots:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: A slot remains an ordinary function, so you can call it yourself
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A single signal can be linked to different slots
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A single slot can be called by different linked signals
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A connection can be made between a signal and a slot from different objects,
    and even between objects living inside different threads!
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep in mind that, to be able to connect a `signal` to a `slot`, their methods'
    signatures must match. The count, order, and type of arguments must be identical.
    Note that signals and slots never return values.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the syntax of a Qt connection:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The first test that we can do to use this wonderful mechanism is to connect
    an existing `signal` with an existing `slot`. We will add this connect call to
    the `MainWindow` constructor:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s analyze how a connection is done:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '`sender`: This is the object that will send the signal. In our example, it
    is the `QPushButton` named `addTaskButton` added from the UI designer.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`&Sender::signalName`: This is the pointer to the member signal function. Here,
    we want do something when the clicked signal is triggered.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`receiver`: This is the object that will receive and handle the signal. In
    our case, it is the `QApplication` object created in `main.cpp`.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`&Receiver::slotName`: This is a pointer to one of the receiver''s `member`
    slot functions. In this example, we use the built-in `quit()` slot from `Qapplication`,
    which will exit the application.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can now compile and run this short example. You will terminate the application
    if you click on the `addTaskButton` of your `MainWindow`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Qt tip**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: You can connect a signal to another signal. The second signal will be emitted
    when the first one is triggered.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to connect a signal to an existing slot, let's see how
    to declare and implement a custom `addTask()` slot in our `MainWindow` class.
    This slot will be called when the user clicks on `ui->addTaskButton`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the updated `MainWindow.h`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Qt uses a specific `slot` keyword to identify slots. Since a slot is a function,
    you can always adjust the visibility (`public`, `protected` or `private`) depending
    on your needs.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this slot implementation in the `MainWindow.cpp` file:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Qt provides an efficient way of displaying debug information with the `QDebug`
    class. An easy way to obtain a `QDebug` object is to call the `qDebug()` function.
    Then, you can use the stream operator to send your debug information.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the top of the file like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Since we now use `qDebug()` in out slot, we must include `<QDebug>`. The updated
    connect now calls our custom slot instead of quitting the application.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Build and run the application. If you click on the button, you will see your
    debug message inside the Qt Creator `Application Output` tab.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Custom QWidget
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have to create the `Task` class that will hold our data (task name and
    completed status). This class will have its form file separated from `MainWindow`.
    Qt Creator provides an automatic tool to generate a base class and the associated
    form.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on **File** | **New File or Project** | **Qt** | **Qt Designer Form Class**.
    There are several form templates; you will recognize Main Window, which Qt Creator
    created for us when we started the `todo` app project. Select **Widget** and name
    the class `Task`, then click on **Next**. Here is a summary of what Qt Creator
    will do:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Create a `Task.h` file and a `Task.cpp` file.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the associated `Task.ui` and do the plumbing to connect it to `Task.h`.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add these three new files to `todo.pro` so they can be compiled.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finish and, voilÃ , the `Task` class is ready to be filled. We will jump into
    the `Task.ui` first. Start by dragging and dropping a `Check Box` (put `checkbox`
    in the `objectName`) and a `Push Button` (`objectName` = `removeButton`):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom QWidget](img/image00356.jpeg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
- en: My alignment looks great, let's ship this to the customers!
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'Unless you have a pixel-perfect eye, your items are not very well aligned.
    You need to indicate how your widgets should be laid out and how they should react
    when the window geometry changes (for example, when the user resizes the window).
    For this, Qt has several default layout classes:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '`Vertical Layout`: In this layout, widgets are vertically stacked'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Horizontal Layout`: In this layout, widgets are horizontally stacked'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Grid Layout`: In this layout, widgets are arranged in a grid that can be subdivided
    into smaller cells'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Form Layout`: In this layout, widgets are arranged like a web form, a label,
    and an input'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every layout will try to constrain all widgets to occupy equal surfaces. It
    will either change the widgets' shape or add extra margins, depending on each
    widget's constraints. A `Check Box` will not be stretched but a `Push Button`
    will.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: In our `Task` object, we want this to be horizontally stacked. In the **Form
    Editor** tab, right-click on the window and select **Lay out** | **Lay out Horizontally**.
    Each time you add a new widget in this layout, it will be arranged horizontally.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Now add a `Push Button (objectName = editButton)` line just after the `checkbox`
    object.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Form Editor** window offers a realistic preview of how your UI will render.
    If you stretch the window now, you can observe how each widget will react to this
    event. When resizing horizontally, you can note that the push buttons are stretched.
    It looks bad. We need something to "hint" to the layout that these buttons should
    not be stretched. Enter the `Spacer` widget. Take the `Horizontal Spacer` in the
    widget box and drop it after the `checkbox` object:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom QWidget](img/image00357.jpeg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
- en: A spacer is a special widget that tries to push (horizontally or vertically)
    adjacent widgets to force them to take up as little space as possible. The `editButton`
    and `removeButton` objects now take up only the space of their text and will be
    pushed to the edge of the window when it is resized.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: You can add sub layouts of any type in a form (vertical, horizontal, grid, form)
    and create a complex-looking application with a combination of widgets, spacers,
    and layouts. These tools are targeted at designing a good-looking desktop application
    that can react properly to different window geometries.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'The Designer part is finished, so we can switch to the `Task` source code.
    Since we created a Qt Designer Form class, `Task` is closely linked to its UI.
    We will use this as leverage to store our model in a single place. When we create
    a `Task` object, it has to have a name:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The constructor specifies a name, and as you can see there are no private fields
    storing any state of the object. All this will be done in the form part. We also
    added some getters and setters that will interact with the form. It is better
    to have a model completely separated from the UI, but our example is simple enough
    to merge them. Moreover, `Task` implementation details are hidden from the outside
    world and can still be refactored later on. Here is the content of the `Task.cpp`
    file:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The implementation is straightforward; we store the information in our `ui->checkbox`
    and the `name()` and `isCompleted()` getters take their data from the `ui->checkbox`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Adding a task
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now rearrange the layout of `MainWindow` to be able to display our
    todo tasks. Right now, there is no widget where we can display our tasks. Open
    the `MainWindow.ui` file and edit it to get the following result:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a task](img/image00358.jpeg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
- en: 'If we detail the content, we have:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: A vertical layout for `centralWidget` containing the `toolbarLayout` file and
    the `tasksLayout` file.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A vertical spacer pushing these layouts to the top, forcing them to take up
    the smallest possible space.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We got rid of `menuBar`, `mainToolBar`, and `statusBar`. Qt Creator created
    them automatically, we simply don't need them for our purposes. You can guess
    their uses from their names.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not forget to rename the `MainWindow` title to `Todo` by selecting the **MainWindow**
    in the **Object Inspector** window and editing the **Qwidget** | **windowTitle**
    property. Your app deserves to be named properly.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Qt Tip**'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Press *Shift* + *F4* in Designer mode to switch between the form editor and
    the source.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计模式中按*Shift* + *F4*切换到表单编辑器和源代码。
- en: 'Now that the `MainWindow` UI is ready to welcome tasks, let''s switch to the
    code part. The application has to keep track of the new tasks. Add the following
    in the `MainWindow.h` file:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`MainWindow` UI已经准备好欢迎任务，让我们切换到代码部分。应用程序必须跟踪新任务。在`MainWindow.h`文件中添加以下内容：
- en: '[PRE12]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `QVector` is the Qt container class providing a dynamic array, which is
    an equivalent of the `std::vector`. As a general rule, STL containers are more
    customizable but might miss some features compared to Qt containers. If you use
    C++11 smart pointers, you should favor `std` containers, but we will get into
    that later.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`QVector`是Qt容器类，提供动态数组，相当于`std::vector`。作为一个一般规则，STL容器更可定制，但可能缺少一些与Qt容器相比的功能。如果你使用C++11智能指针，你应该优先使用`std`容器，但我们会稍后讨论这一点。'
- en: 'In the Qt documentation of `QVector`, you might stumble upon the following
    statement: "*For most purposes,* `QList` *is the right class to use*". There is
    a debate about this in the Qt community:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在Qt的`QVector`文档中，你可能会遇到以下说法：“*对于大多数用途，* `QList` *是正确的类来使用*”。在Qt社区中对此有争议：
- en: Do you often need to insert objects larger than a pointer at the beginning or
    in the middle of your array? Use a `QList` class.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是否经常需要在数组的开始或中间插入比指针更大的对象？请使用`QList`类。
- en: Need contiguous memory allocation? Less CPU and memory overhead? Use a `QVector`
    class.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要连续内存分配？更少的CPU和内存开销？请使用`QVector`类。
- en: The already added slot `addTask()` will now be called each time we want to add
    a new `Task` object to the `mTasks` function.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 已经添加的槽`addTask()`现在将在我们想要将新的`Task`对象添加到`mTasks`函数时被调用。
- en: 'Let''s fill our `QVector` tasks each time `addTaskButton` is clicked. First,
    we connect the `clicked()` signal in the `MainWindow.cpp` file:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 每次点击`addTaskButton`时，让我们填充我们的`QVector`任务。首先，在`MainWindow.cpp`文件中连接`clicked()`信号：
- en: '[PRE13]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Tip
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**C++ tip**'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**C++小贴士**'
- en: As a best practice, try to always initialize member variables in the initializer
    list and respect the order of variable declarations. Your code will run faster
    and you will avoid unnecessary variable copies. Take a look at the standard C++
    documentation at [https://isocpp.org/wiki/faq/ctors#init-lists](https://isocpp.org/wiki/faq/ctors#init-lists).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最佳实践，尽量始终在初始化列表中初始化成员变量，并尊重变量声明的顺序。这样你的代码将运行得更快，并且可以避免不必要的变量复制。请查看标准C++文档[https://isocpp.org/wiki/faq/ctors#init-lists](https://isocpp.org/wiki/faq/ctors#init-lists)。
- en: 'The body of the `addTask()` function should look like this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`addTask()`函数的主体应该如下所示：'
- en: '[PRE14]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We created a new task and added it to our `mTask` vector. Because Task is a `QWidget`,
    we also added it directly to the `tasksLayout`. An important thing to note here
    is that we never managed this new task's memory. Where is the `delete task` instruction?
    This is a key feature of the Qt Framework we started to broach earlier in the
    chapter; the `QObject` class parenting automatically handles object destruction.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个新的任务并将其添加到我们的`mTask`向量中。因为`Task`是一个`QWidget`，所以我们直接将其添加到`tasksLayout`中。这里需要注意的是，我们从未管理过这个新任务的内存。`delete
    task`指令在哪里？这是我们在本章早期开始探讨的Qt框架的关键特性；`QObject`类会自动处理对象销毁。
- en: In our case, the `ui->tasksLayout->addWidget(task)` call has an interesting
    side-effect; the ownership of the task is transferred to `tasksLayout`. The `QObject*`
    parent defined in `Task` constructor is now `tasksLayout`, and the `Task` destructor
    will be called when `tasksLayout` releases its own memory by recursively iterating
    through its children and calling their destructor.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，`ui->tasksLayout->addWidget(task)`调用有一个有趣的副作用；任务的所有权被转移到了`tasksLayout`。在`Task`构造函数中定义的`QObject*`父类现在是`tasksLayout`，当`tasksLayout`通过递归遍历其子项并调用它们的析构函数来释放自己的内存时，将调用`Task`的析构函数。
- en: 'This will happen at this precise moment:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在这一精确时刻发生：
- en: '[PRE15]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When `MainWindow` is released (remember, it's a stack variable allocated in
    the `main.cpp` file), it will call `delete ui`, which in turn will bring down
    the whole `QObject` hierarchy. This feature has interesting consequences. First,
    if you use the `QObject` parenting model in your application, you will have much
    less memory to manage. Second, it can collide with some new C++11 semantics, specifically
    the smart pointers. We will get into that in later chapters.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当`MainWindow`被释放（记住，它是在`main.cpp`文件中分配的栈变量），它将调用`delete ui`，这反过来又会使整个`QObject`层次结构崩溃。这个特性有一些有趣的后果。首先，如果你在应用程序中使用`QObject`父子模型，你将需要管理的内存将少得多。其次，它可能与一些新的C++11语义冲突，特别是智能指针。我们将在后面的章节中讨论这一点。
- en: Using a QDialog
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`QDialog`
- en: 'We deserve something better than an untitled task. The user needs to define
    its name when it''s created. The easiest path would be to display a dialog where
    the user can input the task name. Fortunately Qt offers us a very configurable
    dialog that fits perfectly in `addTask()`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该得到比未命名的任务更好的东西。用户在创建时需要定义其名称。最简单的方法是显示一个对话框，用户可以在其中输入任务名称。幸运的是，Qt为我们提供了一个非常可配置的对话框，它完美地适用于`addTask()`：
- en: '[PRE16]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `QinputDialog::getText` function is a static blocking function that displays
    the dialog. When the user validates/cancels the dialog, the code continues. If
    we run the application and try to add a new task, we''ll see this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`QinputDialog::getText`函数是一个静态阻塞函数，用于显示对话框。当用户验证/取消对话框时，代码继续执行。如果我们运行应用程序并尝试添加一个新任务，我们会看到以下内容：'
- en: '![Using a QDialog](img/image00359.jpeg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![使用`QDialog`](img/image00359.jpeg)'
- en: 'The `QInputDialog::getText` signature looks like this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`QInputDialog::getText`的签名如下：'
- en: '[PRE17]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s break it down:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下：
- en: '`parent`: This is the parent widget (`MainWindow`) to which the `QinputDialog`
    is attached. This is another instance of the `QObject` class''s parenting model.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parent`: 这是`QinputDialog`附加到的父小部件（`MainWindow`）。这是`QObject`类父子模型的另一个实例。'
- en: '`title`: This is the title displayed in the window title. In our example, we
    use `tr("Add task")`, which is how Qt handles i18n in your code. We will see later
    on how to provide multiple translations for a given string.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title`: 这是窗口标题中显示的标题。在我们的示例中，我们使用`tr("Add task")`，这是Qt处理代码中的i18n的方式。我们将在稍后看到如何为给定的字符串提供多个翻译。'
- en: '`label`: This is the label displayed right above the input text field.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`label`: 这是在输入文本字段上方显示的标签。'
- en: '`mode`: This is how the input field is rendered (password mode will hide the
    text).'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mode`: 这是指输入字段如何渲染（密码模式将隐藏文本）。'
- en: '`ok`: This is a pointer to a variable that is set to true if the user presses **OK**
    and to false if the user presses **Cancel**.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ok`: 这是一个指向变量的指针，如果用户按下**OK**，则将其设置为true；如果用户按下**Cancel**，则将其设置为false。'
- en: '`QString`: The returned `QString` is what the user has typed.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QString`: 返回的`QString`是用户输入的内容。'
- en: There are a few more optional parameters we can safely ignore for our example.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，还有一些可选参数我们可以安全忽略。
- en: Distributing code responsibility
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分配代码责任
- en: 'Great, the user can now specify the task name when it''s created. What if he
    makes an error when typing the name? The next logical step is to rename the task
    after we created it. We''ll take a slightly different approach. We want our `Task`
    to be as autonomous as possible. If we attach it to another component (rather
    than `MainWindow`), this renaming feature has to keep working. Thus, this responsibility
    has to be given to the `Task` class:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，用户现在可以在创建任务时指定任务名称。如果他输入名称时出错怎么办？下一个合乎逻辑的步骤是在创建任务后重命名它。我们将采取稍微不同的方法。我们希望我们的`Task`尽可能自主。如果我们将其附加到另一个组件（而不是`MainWindow`），这个重命名功能必须继续工作。因此，这个责任必须交给`Task`类：
- en: '[PRE18]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We add a public slot `rename()` to connect it to a signal. The body of `rename()`
    reuses what we had previously covered with `QInputDialog`. The only difference
    is the `QInputDialog` default value, which is the current task name. When `setName(value)`
    is called, the UI is instantly refreshed with the new value; there's nothing to
    synchronize or update, the Qt main loop will do its job.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个公共槽`rename()`来将其连接到信号。`rename()`函数的主体重用了我们之前用`QInputDialog`覆盖的内容。唯一的区别是`QInputDialog`的默认值，它是当前任务名称。当调用`setName(value)`时，UI会立即刷新为新值；无需同步或更新，Qt主循环会完成其工作。
- en: The nice thing is that `Task::rename()` is completely autonomous. Nothing has
    been modified in `MainWindow`, so we have effectively zero coupling between our `Task`
    and the parent `QWidget`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 好处在于`Task::rename()`是完全自主的。在`MainWindow`中没有进行任何修改，因此我们实际上在`Task`和父`QWidget`之间有零耦合。
- en: Emitting a custom signal using lambdas
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The remove task is straightforward to implement, but we''ll study some new
    concepts along the way. The `Task` has to notify its owner and parent (`MainWindow`)
    that the `removeTaskButton``QPushButton` has been clicked. We''ll implement this
    by defining a custom signal `removed` in `Task.h` files:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Like we did for the slots, we have to add the Qt keyword signals in our header.
    Since a `signal` is used only to notify another class, the `public` keyword is
    not needed (it even raises a compilation error). A `signal` is simply a notification
    sent to the receiver (the connected `slot`); it implies that there is no function
    body for the `removed(Task* task)` function. We added the `task` parameter to
    allow the receiver to know which task asked to be removed. The next step is to
    emit the `removed` signal upon the `removeButton` click. This is done in the `Task.cpp`
    file:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This code excerpt shows a very interesting feature of C++11: `lambdas`. In
    our example, the `lambda` is the following part:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: What we did here is to connect the clicked signal to an anonymous inline function,
    a `lambda`. Qt allows signal relaying by connecting a signal to another signal
    if their signatures match. It's not the case here; the `clicked` signal has no
    parameter and the `removed` signal needs a `Task*`. A `lambda` avoids the declaration
    of a verbose `slot` in `Task`. Qt 5 accepts a `lambda` instead of a slot in a `connect`,
    and both syntaxes can be used.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Our `lambda` executes a single line of code: `emit removed(this)`. `Emit` is
    a Qt macro that will immediately trigger the connected `slot` with what we passed
    in a parameter. As we said earlier, `removed(Task* this)` has no function body,
    its purpose is to notify the registered slot of an event.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'Lambdas are a great addition to C++. They offer a very practical way of defining
    short functions in your code. Technically, a `lambda` is the construction of a
    closure capable of capturing variables in its scope. The full syntax goes like
    this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: "Letâ\x80\x99s study each part of this statement:"
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '`capture-list`: This defines what variables will be visible inside the `lambda`
    scope.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`params`: This is the function parameters type list that can be passed to the `lambda`
    scope. There are no parameters in our case, We might have written `[this] () {
    ... }`, but C++11 lets us skip the parentheses altogether.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ret`: This is the return type of the `lambda` function. Just like `params`,
    this parameter can be omitted if the return type is `void`.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`body`: This is obviously your code body where you have access to your `capture-list`,
    and `params`, and which must return a variable with a type `ret`.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our example, we captured the `this` pointer to be able to:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a reference on the `removed()` function, which is a part of the `Task`
    class. If we did not capture `this`, the compiler would have shouted `error: ''this''
    was not captured for this lambda function emit removed(this);`.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pass `this` to the `removed` signal; the caller needs to know which task triggered `removed`.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `capture-list` relies on standard C++ semantics: capture variables by copy
    or by reference. Let us say that we wanted to print a log of the constructor parameter `name`
    and we capture it by reference in our `lambda`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This code will compile fine. Unfortunately, the runtime will crash with a dazzling
    segmentation fault when we try to remove a `Task`. What happened? As we said,
    our `lambda` is an anonymous function that will be executed when the `clicked()`
    signal has been emitted. We captured the `name` reference, but this reference
    may be `-` and is `-` invalid once we get out of `Task` constructor (more precisely,
    from the caller scope). The `qDebug()` function will then try to display an unreachable
    code and crash.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'You really want to be careful with what you capture and the context in which
    your lambda will be executed. In this example, the segmentation fault can be amended
    by capturing the `name` by copy:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Tip
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**C++ Tip**'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: You can capture by copy or reference all variables that are reachable in the
    function where you define your lambda with the syntax [`=`] and [`&`].
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `this` variable is a special case of the capture list. You cannot capture
    it by reference `[&this]` and the compiler will warn you if you are in this situation: `[=,
    this]`. Don't do this. Kittens will die.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our `lambda` is passed directly as a parameter to the connect function. In
    other words, the `lambda` is variable. This has many consequences: we can call
    it, assign it, and return it. To illustrate a "fully formed" `lambda`, we can
    define one that returns a formatted version of the task name. The sole purpose
    of this snippet is to investigate the `lambda` function''s machinery. Don''t include
    the following code in your `todo` app, your colleagues might call you something
    like a "functional zealot":'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here we did a tricky thing. We called `qDebug()`; inside this call we defined
    a `lambda` which is immediately executed. Let''s analyze it:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '`[]`: We performed no capture. The `lambda` does not depend on the enclosing
    function.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(const Qstring& taskName)`: When this lambda is called, it will expect a `QString`
    to work on.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-> QString`: The returned value of the lambda will be a `QString`.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`return "------- " + taskName.toUpper()`: the body of our `lambda`. We return
    a concatenation of a string and the uppercase version of the parameter `taskName`.
    As you can see, string manipulation becomes a lot easier with Qt.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(name)`: Here comes the catch. Now that the `lambda` function is defined,
    we can call it passing the `name` parameter. In a single instruction, we define
    it and call it. The `QDebug()` function will simply print the result.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The real benefit of this `lambda` will emerge if we are able to assign it to
    a variable and call it multiple times. C++ is statically typed, so we must provide
    the type of our `lambda` variable. In the language specification, a `lambda` type
    cannot be explicitly defined. We'll see soon how we can do it with C++11\. For
    now, let's finish our remove feature.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'Task now emits the `removed()` signal. This signal has to be consumed by `MainWindow`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `MainWindow::removeTask()` must match the signal signature. The connection
    is made when the task is created. The interesting part comes in the implementation
    of  `MainWindow::removeTask()`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: The task is first removed from the `mTasks` vector. It is then removed from `tasksLayout`.
    Here, `tasksLayout` releases its ownership of `task` (that is, `tasksLayout` ceases
    to be the `task` class's parent).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'So far so good. The next two lines are interesting. The ownership transfer
    does not completely release the `task` class ownership. If we commented these
    lines, here is how `removeTask()` will look:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If you add a log message in `Task` destructor and execute the program, this
    log message will be displayed. Nonetheless, the Qt documentation tells us in `Qlayout::removeWidget`
    part: *The ownership of a widget remains the same as when it was added*.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Instead, what really happens is that the `task` class's parent becomes `centralWidget`,
    the `tasksLayout` class's parent. We want Qt to forget everything about `task`,
    that's why we call `task->setParent(0)`. We can then safely delete it and call
    it a day.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying with the auto type and a range-based for loop
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final step to a complete CRUD of our tasks is to implement the completed
    task feature. We''ll implement the following:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Click on the checkbox to mark the task as completed
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strike the task name
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update the status label in `MainWindow`
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The checkbox click handling follows the same pattern as `removed`:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We define a slot `checked(bool checked)` that will be connected to the `checkbox::toggled`
    signal. In our `slot checked()`, we strike out the `checkbox` text according to
    the `bool checked` value. This is done using the `QFont` class. We create a copy
    font from the `checkbox->font()`, modify it, and assign it back to `ui->checkbox`.
    If the original `font` was in bold, with a special size, its appearance would
    be guaranteed to stay the same.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Play around with the font object in Qt Designer. Select the `checkbox` in the `Task.ui`
    file and go to **Properties Editor** | **QWidget** | **font**.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'The last instruction notifies `MainWindow` that the `Task` status has changed.
    The signal name is `statusChanged`, rather than `checkboxChecked`, to hide the
    implementation details of the task. Add the following code in the `MainWindow.h`
    file:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We defined a slot `taskStatusChanged`, which is connected when a task is created.
    The single instruction of this `slot` is to call `updateStatus()`. This function
    iterates through the tasks and updates the `statusLabel`. The `updateStatus()`
    function is called upon task creation and deletion.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个槽 `taskStatusChanged`，当任务创建时与之连接。这个 `slot` 的单一指令是调用 `updateStatus()`。这个函数遍历任务并更新
    `statusLabel`。`updateStatus()` 函数在任务创建和删除时被调用。
- en: 'In `updateStatus()`, we meet more new C++11 semantics:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `updateStatus()` 中，我们遇到了更多新的 C++11 语义：
- en: '[PRE30]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `for` keyword lets us loop over a range-based container. Because `QVector`
    is an iterable container, we can use it here. The range declaration (`auto t`)
    is the type and variable name that will be assigned at each iteration. The range
    expression (`mTasks`) is simply the container on which the process will be done.
    Qt provides a custom implementation of the `for` (namely `foreach`) loop targeted
    at prior versions of C++; you don't need it anymore.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 关键字让我们可以遍历基于范围的容器。因为 `QVector` 是一个可迭代的容器，所以我们可以在这里使用它。范围声明（`auto t`）是每次迭代将被分配的类型和变量名。范围表达式（`mTasks`）简单地是执行过程将进行的容器。Qt
    为 C++ 早期版本提供了一个针对 `for` 循环（即 `foreach`）的定制实现；你不再需要它了。'
- en: 'The `auto` keyword is another great new semantic. The compiler deduces the
    variable type automatically based on the initializer. It relieves a lot of pain
    for cryptic iterators such as this:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`auto` 关键字是另一个伟大的新语义。编译器根据初始化器自动推断变量类型。它为诸如这样的神秘迭代器减轻了许多痛苦：'
- en: '[PRE31]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Since C++14, `auto` can even be used for function return types. It's a fabulous
    tool, but use it sparingly. If you put `auto`, the type should be obvious from
    the signature name/variable name.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 自 C++14 以来，`auto` 甚至可以用于函数返回类型。这是一个了不起的工具，但请谨慎使用。如果你使用 `auto`，类型应该从签名名称/变量名中明显可见。
- en: Tip
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'The `auto` keyword can be combined with `const` and references. You can write
    a for loop like this: `for (const auto & t : mTasks) { ... }`.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`auto` 关键字可以与 `const` 和引用结合使用。你可以编写这样的 for 循环：`for (const auto & t : mTasks)
    { ... }`。'
- en: 'Remember our half bread `lambda`? With all the covered features, we can write:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们之前提到的半面包 `lambda` 吗？有了所有这些特性，我们可以写出：
- en: '[PRE32]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now that's something beautiful. Combining `auto` with `lambda` makes very readable
    code and opens up a world of possibilities.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在真是一件美丽的事情。将 `auto` 与 `lambda` 结合使用，可以编写出非常易读的代码，并开启了一个充满可能性的世界。
- en: 'The last item to study is the `QString` API. We used it in `updateStatus()`:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要学习的是 `QString` API。我们在 `updateStatus()` 中使用了它：
- en: '[PRE33]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The people behind Qt put a lot of work into making string manipulation bearable
    in C++. This is a perfect example, where we replace the classic C `sprintf` with
    a more modern and robust API. Arguments are position-based only, no need to specify
    the type (less error-prone), and the `arg(...)` function accepts all kinds of
    types.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 背后的开发者们投入了大量工作，使得在 C++ 中进行字符串操作变得可行。这是一个完美的例子，我们用更现代、更健壮的 API 替换了经典的 C `sprintf`。参数仅基于位置，无需指定类型（更不易出错），并且
    `arg(...)` 函数接受所有类型的参数。
- en: Tip
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Take some time to skim through the `QString` documentation at [http://doc.qt.io/qt-5/qstring.html](http://doc.qt.io/qt-5/qstring.html).
    It shows how much you can do with this class and you'll see yourself using fewer
    and fewer examples of `std string` or even `cstring`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 花些时间浏览一下 [http://doc.qt.io/qt-5/qstring.html](http://doc.qt.io/qt-5/qstring.html)
    上的 `QString` 文档。它展示了你可以用这个类做多少事情，你也会发现自己使用 `std string` 或 `cstring` 的例子越来越少。
- en: Summary
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we created a desktop Qt application from scratch. Qt is well
    known for its signal/slot mechanism and you must be confident with this paradigm.
    We also introduced some important C++14 features that will be used all through
    this book.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从零开始创建了一个桌面 Qt 应用程序。Qt 以其信号/槽机制而闻名，你必须对这种范式有信心。我们还介绍了一些重要的 C++14 特性，这些特性将贯穿整本书。
- en: It's now time to discover some `qmake` secrets and what is really done when
    you build your Qt project. In the next chapter, we will also talk about how to
    create and organize an application with some platform-dependent code that must
    run on Windows, Mac OS, and Linux.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候发现一些 `qmake` 的秘密了，以及当你构建 Qt 项目时实际上会发生什么。在下一章中，我们还将讨论如何创建和组织一个应用程序，其中包含必须在
    Windows、Mac OS 和 Linux 上运行的与平台相关的代码。
