["```cpp\nenum class error {\n    Ok,\n    Error1,\n    Error2,\n    Unknown\n};\nerror h() {\n    return error::Error1;\n}\nerror g() {\n    auto err = h();\n    if(err!=error::Ok) {\n        if(err == error::Error1) {\n       // handle error directly\n        }\n        else if(err == error::Error2) {\n            // propagate this error\nreturn err;\n        }\n        else {\n            // unknown error\nreturn error::Unknown;\n        }\n    }\n    return error::Ok;\n}\nvoid f() {\n    auto err = g();\n    if(err==error::Ok) {\n        printf(\"Succes\\r\\n\");\n    }\n    else {\n        // handle errors\n    }\n} \n```", "```cpp\nenum class [[nodiscard]] error {\n    Ok,\n    Error1,\n    Error2,\n    Unknown\n}; \n```", "```cpp\n<source>:48:6: warning: ignoring returned value of type 'error', declared with attribute 'nodiscard' [-Wunused-result] \n```", "```cpp\n#include <cstdio>\n#include <cstdint>\n#include <cstdlib>\nint i2c_read(uint8_t *data, size_t len) {\n    return 0;\n}\nnamespace error {\n    struct i2c_failed{};\n    struct spi_failed{};\n    void handler(i2c_failed err) {\n        printf(\"I2C error!\\r\\n\");\n        exit(1);\n    }\n    void handler(spi_failed err) {\n        printf(\"SPI error!\\r\\n\");\n        exit(1);\n    }\n};\nclass accelerometer {\npublic:\n    struct data {\n        int16_t x;\n        int16_t y;\n        int16_t z;\n    };\n    data get_data() {\n        uint8_t buff[6];\n        if(i2c_read(buff, 6) != 6) {\n            error::handler(error::i2c_failed{});\n        }\n        return data{};\n    }\n};\nint main () {\n    accelerometer accel;\n    auto data = accel.get_data();\n    return 0;\n} \n```", "```cpp\n#include <cassert>\n#include <cstdint>\nenum class option : std::uint8_t {\n    Option1 = 0,\n    Option2,\n    Option3,\n    Last\n};\noption uint8_to_option(uint8_t num) {\n    assert(num < static_cast<uint8_t>(option::Last));\n    return static_cast<option>(num);\n}\nint main() {\n    const option opt = uint8_to_option(3);\n    return 0;\n} \n```", "```cpp\nassertion \"num < static_cast<uint8_t>(option::Last)\" failed: file \"/home/amar/projects/Cpp-in-Embedded Systems/Chapter07/error_handling/app/src/main.cpp\", line 21, function: option uint8_to_option(uint8_t) \n```", "```cpp\n#define assert(expr)                             \\\n     (static_cast <bool> (expr)                  \\\n      ? void (0)                                 \\\n      : __assert_fail (#expr, \n__ASSERT_FILE,            \\\n                       __ASSERT_LINE,            \\\n                       __ASSERT_FUNCTION)) \n```", "```cpp\n#define NDEBUG\n#include <cassert> \n```", "```cpp\nvoid log_pc_and_halt(std::uint32_t pc) {\n    printf(\"Assert at 0x%08lX\\r\\n\", pc);\n    while(true) {}\n}\n#define light_assert(expr)         \\\n        (static_cast<bool> (expr)  \\\n        ? void (0)                 \\\n        : log_pc_and_halt(hal::get_pc())    \\\n        ) \n```", "```cpp\n$ docker start dev_env\n$ docker exec -it dev_env /bin/bash \n```", "```cpp\n$ git clone https://github.com/PacktPublishing/Cpp-in-Embedded-Systems.git \n```", "```cpp\n$ cd Chapter07/error_handling\n$ cmake -B build -DCMAKE_BUILD_TYPE=Debug -DMAIN_CPP_FILE_NAME=main_assert.cpp\n$ cmake --build build --target run_in_renode \n```", "```cpp\n14:11:06.6293 [INFO] usart2: [host: 0.31s (+0.31s)|virt: 0s (+0s)] Assert example\n14:11:06.6455 [INFO] usart2: [host: 0.32s (+15.87ms)|virt: 0.11ms (+0.11ms)] Assert at 0x08000F74 \n```", "```cpp\n$ arm-none-eabi-addr2line --exe bare.elf 0x08000F74 \n```", "```cpp\n/workspace/Cpp-in-Embedded-Systems/Chapter07/error_handling/app/src/main_assert.cpp:30 (discriminator 1) \n```", "```cpp\n std::array<int, 4> arr;\n    try {\n      arr.at(5) = 6;\n    }\n    catch(std::out_of_range &e) {\n      printf(\"Array out of range!\\r\\n\");\n    } \n```", "```cpp\n$ mkdir build && cd build\n$ cmake .. -DCMAKE_BUILD_TYPE=Debug -DMAIN_CPP_FILE_NAME=main_exceptions.cpp\n$ make â€“j4\n$ make run_in_renode \n```", "```cpp\n std::set_terminate([]() {\n        printf(\"My terminate handler!\\r\\n\");\n        while(true){}\n    }); \n```", "```cpp\ntemplate <class T, std::size_t N> struct ring_buffer {\n  std::array<T, N> arr;\n  std::size_t write_idx = 0;\n  void push(T t) {\n    arr.at(write_idx++) = t;\n  }\n};\nint main()\n{\n    ring_buffer<int, 4> rb;\n    try {\n      for(int i = 0; i < 6; i++) {\n        rb.push(i);\n      }\n    }\n    catch(std::out_of_range &e) {\n      printf(\"Ring buffer out of range!\\r\\n\");\n    }\n    return 0;\n} \n```", "```cpp\n$ cd Chapter07/error_handling\n$ cmake -B build -DCMAKE_BUILD_TYPE=Debug -DMAIN_CPP_FILE_NAME=main_exceptions.cpp\n$ cmake --build build --target run_in_renode \n```", "```cpp\n#include <cstdio>\n#include <optional>\nstruct sensor {\n    struct data {\n        int x;\n        int y;\n    };\n    static inline bool ret_val = true;\n    static std::optional<data> get_data() {\n        ret_val = !ret_val;\n        if(ret_val) {\n            return data{4, 5};\n        }\n        else {\n            return std::nullopt;\n        }\n    }\n};\nint main()\n{\n    const auto get_data_from_main = [] () {\n        auto result = sensor::get_data();\n        if(result) {\n            printf(\"x = %d, y = %d\\r\\n\", (*result).x, (*result).y);\n        }\n        else {\n            printf(\"No data!\\r\\n\");\n        }\n    };\n    get_data_from_main();\n    get_data_from_main();\n    return 0;\n} \n```", "```cpp\n#include <cstdio>\n#include <expected>\nstruct ble_light_bulb {\n    enum class error {\n        disconnected,\n        timeout\n    };\n    struct config {\n        int r;\n        int g;\n        int b;\n    };\n    bool ret_val;\n    std::expected<config, error> get_config() {\n        ret_val = !ret_val;\n        if(ret_val) {\n            return config {10, 20, 30};\n        }\n        else {\n            return std::unexpected(error::timeout);\n        }\n    }\n};\nint main()\n{  \n    ble_light_bulb bulb;\n    const auto get_config_from_main = [&bulb]() {\n        auto result = bulb.get_config();\n        if(result.has_value()) {\n            auto conf = result.value();\n            printf(\"Config r %d, g %d, b %d\\r\\n\", conf.r, conf.g, conf.b);\n        } else {\n            auto err = result.error();\n            using bulb_error = ble_light_bulb::error;\n            if(err == bulb_error::disconnected) {\n                printf(\"The bulb is disconnected!\\r\\n\");\n            }\n            else if(err == bulb_error::timeout) {\n                printf(\"Timeout!\\r\\n\");\n            }\n        }\n    };\n    get_config_from_main();\n    get_config_from_main();\n    return 0;\n} \n```", "```cpp\n$ cd Chapter07/error_handling\n$ cmake -B build -DCMAKE_BUILD_TYPE=Debug -DMAIN_CPP_FILE_NAME=main_expected.cpp\n$ cmake --build build --target run_in_renode \n```"]