- en: '*Chapter 16*: Building Playable Levels and Collision Detection'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第16章*：构建可玩关卡和碰撞检测'
- en: This chapter will probably be one of the most satisfying chapters of this project.
    The reason for this is that, by the end of it, we will have a playable game. Although
    there will still be features to implement (sound, particle effects, the HUD, and
    shader effects), Bob and Thomas will be able to run, jump, and explore the world.
    Furthermore, you will be able to create your very own level designs of any size
    or complexity by simply making platforms and obstacles in a text file.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是这个项目中最有满足感的一章。原因是，到本章结束时，我们将有一个可玩的游戏。尽管仍有一些功能需要实现（声音、粒子效果、HUD和着色器效果），但鲍勃和托马斯将能够跑步、跳跃和探索世界。此外，你只需在文本文件中创建平台和障碍物，就可以创建任何大小或复杂性的自己的关卡设计。
- en: 'We will achieve all this by covering the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过以下主题来实现所有这些：
- en: Exploring how to design levels in a text file
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索如何在文本文件中设计关卡
- en: Building a `LevelManager` class that will load levels from a text file, convert
    them into data that our game can use, and keep track of the level details such
    as spawn position, current level, and allowed time limit
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个`LevelManager`类，它将从文本文件中加载关卡，将它们转换为游戏可以使用的数据，并跟踪关卡细节，如出生位置、当前关卡和允许的时间限制
- en: Updating the game engine to use `LevelManager`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新游戏引擎以使用`LevelManager`
- en: Coding a polymorphic function to handle collision detection for both Bob and
    Thomas
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个多态函数来处理鲍勃和托马斯的碰撞检测
- en: Designing some levels
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计一些关卡
- en: 'Remember the sprite-sheet that we introduced in [*Chapter 14*](B14278_14_Final_AG_ePub.xhtml#_idTextAnchor292),
    *Abstraction and Code Management – Making Better Use of OOP*? Here it is again,
    annotated with numbers that represent each tile that we will build all our levels
    from:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们在[*第14章*](B14278_14_Final_AG_ePub.xhtml#_idTextAnchor292)中介绍的精灵图集，*抽象和代码管理
    – 更好地利用面向对象编程*？这里它又出现了，用数字标注了我们将构建所有关卡的地块：
- en: '![](img/B14278_16_01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_16_01.jpg)'
- en: 'The image has been placed on a grey background so that we can see the different
    details of the sprite-sheet better. The chequered background represents the level
    of transparency. So, all the tiles except for number 1 will reveal at least a
    little of the background behind them. Let''s go over them now:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图片被放置在灰色背景上，这样我们可以更好地看到精灵图集的不同细节。棋盘格背景代表透明度级别。因此，除了编号1之外的所有地块都将至少透露出它们背后的背景。现在让我们来看看它们：
- en: Tile 0 is completely transparent and will be used to fill in the gaps where
    there aren't any other tiles.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地块0是完全透明的，将用于填充没有其他地块的空隙。
- en: Tile 1 is for the platforms that Thomas and Bob will walk on.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地块1是托马斯和鲍勃将行走的平台。
- en: Tile 2 is for fire tiles and 3 is for water tiles.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地块2用于火焰地块，3用于水域地块。
- en: In terms of tile 4, you might need to look quite closely to see it. It has a
    white square outline. This is the goal of the level and is where Thomas and Bob
    must get to together.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于地块4，你可能需要非常仔细地看才能看到它。它有一个白色的方块轮廓。这是关卡的目标，托马斯和鲍勃必须一起到达的地方。
- en: Keep this image in mind as we discuss designing the levels.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论设计关卡时，请记住这张图片。
- en: 'We will enter combinations of these tile numbers into text files to design
    the layouts. An example will help:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这些地块编号的组合输入到文本文件中，以设计布局。以下是一个例子：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The previous code translates into the following level layout:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码转换为以下关卡布局：
- en: '![](img/B14278_16_02.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_16_02.jpg)'
- en: 'Note that, to get the previous screenshot, I had to zoom out of the `View`
    and that the image has been cropped. The actual start of the level would look
    as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，为了获取之前的截图，我不得不缩小`视图`，并且图片已经被裁剪。实际的关卡开始看起来如下：
- en: '![](img/B14278_16_03.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_16_03.jpg)'
- en: These screenshots demonstrate two things. First, you can see how you can quickly
    construct level designs using a simple and free text editor such as Windows Notepad
    or Notepad ++. Just make sure you use a monospace font so that all the numbers
    are the same size. This makes designing the levels much easier.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些截图展示了两个要点。首先，你可以看到如何使用简单的免费文本编辑器，如Windows记事本或Notepad ++，快速构建关卡设计。只需确保你使用等宽字体，这样所有的数字都是相同的大小。这使得设计关卡变得容易得多。
- en: 'Secondly, these screenshots demonstrate the gameplay aspects of the design.
    From left to right in the level, Thomas and Bob need to jump over a small hole
    or they will fall to their death (respawn). Then, they have a large expanse of
    fire to traverse. It is impossible for Bob to jump that many tiles. The players
    will need to work together to find the solution. The only way that Bob will clear
    the fire tiles is by standing on Thomas''s head and jumping from there, as shown
    in the following screenshot:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，这些截图展示了设计的游戏玩法方面。在关卡中从左到右，托马斯和鲍勃需要跳过一个小的洞，否则他们会掉入死亡（重生）。然后，他们需要穿越一大片火海。鲍勃无法跳过这么多方块。玩家需要合作找到解决方案。鲍勃清除火方块的唯一方法就是站在托马斯的头上并从那里跳起，如下面的截图所示：
- en: '![](img/B14278_16_04.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14278_16_04.jpg)'
- en: It is then quite simple to get to the goal and move on to the next level.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，达到目标并进入下一级就相当简单了。
- en: Tip
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: I strongly encourage you to complete this chapter and then spend some time designing
    your own levels.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议你完成这一章，然后花些时间设计你自己的关卡。
- en: I have included a few level designs to get us started. They are in the `levels`
    folder that we added to the project back in [*Chapter 14*](B14278_14_Final_AG_ePub.xhtml#_idTextAnchor292),
    *Abstraction and Code Management – Making Better Use of OOP*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经包含了一些关卡设计以供我们开始。它们位于我们在[*第14章*](B14278_14_Final_AG_ePub.xhtml#_idTextAnchor292)中添加到项目中的`levels`文件夹中，*抽象和代码管理
    – 更好地利用面向对象编程*。
- en: There are some zoomed-out views of the game there, along with a screenshot of
    the code of the level design. The screenshot of the code is probably more useful
    than reproducing the textual content. If the code has to be checked, just open
    the files in the `levels` folder.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 那里有游戏的缩略视图，以及关卡设计的代码截图。代码截图可能比重现文本内容更有用。如果需要检查代码，只需打开`levels`文件夹中的文件。
- en: 'This is what the code looks like:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是代码的样子：
- en: '![](img/B14278_16_05.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14278_16_05.jpg)'
- en: 'This is the level layout that the previous code will produce:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这是前述代码将生成的关卡布局：
- en: '![](img/B14278_16_05b.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14278_16_05b.jpg)'
- en: 'This level is the "leap of faith" level I referred to in [*Chapter 14*](B14278_14_Final_AG_ePub.xhtml#_idTextAnchor292),
    *Abstraction and Code Management – Making Better Use of OOP*:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个关卡就是我[*第14章*](B14278_14_Final_AG_ePub.xhtml#_idTextAnchor292)中提到的“信仰跳跃”关卡：
- en: '![](img/B14278_16_06.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14278_16_06.jpg)'
- en: 'The code for the in-game platforms has been highlighted, as they are not very
    clear in the zoomed-out screenshot that follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对游戏平台代码的突出显示，因为它们在接下来的缩略图中不是很清晰：
- en: '![](img/B14278_16_06b.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14278_16_06b.jpg)'
- en: The provided designs are simple. The game engine will be able to handle very
    large designs, but we have the freedom to use our imagination and build some long
    and challenging levels.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的设计很简单。游戏引擎能够处理非常大的设计，但我们有自由发挥想象力和构建一些长而具有挑战性的关卡。
- en: Of course, these designs won't do anything until we learn how to load them and
    convert the text into a playable level. Additionally, it won't be possible to
    stand on any platforms until we have implemented the collision detection.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这些设计在没有学习如何加载它们并将文本转换为可玩关卡之前不会做任何事情。此外，在没有实现碰撞检测的情况下，玩家无法站在任何平台上。
- en: First, let's handle loading the level designs.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们处理加载关卡设计。
- en: Building the LevelManager class
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建LevelManager类
- en: It will take several phases of coding to make our level designs work.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要使我们的关卡设计工作，需要经过几个阶段的编码。
- en: The first thing we will do is code the `LevelManager` header file. This will
    allow us to look at and discuss the member variables and functions that will be
    in the `LevelManager` class.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将编写`LevelManager`头文件。这将使我们能够查看并讨论`LevelManager`类中将包含的成员变量和函数。
- en: Next, we will code the `LevelManager.cpp` file, which will have all the function
    definitions in it. Since this is a long file, we will break it up into several
    sections to code and discuss them.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编写`LevelManager.cpp`文件，其中将包含所有的函数定义。由于这是一个很长的文件，我们将将其分成几个部分进行编码和讨论。
- en: Once the `LevelManager` class is complete, we will add an instance of it to
    the game engine (`Engine` class). We will also add a new function to the `Engine`
    class, `loadLevel`, which we can call from the `update` function whenever a new
    level is required. The `loadLevel` function will not only use the `LevelManager`
    instance to load the appropriate level – it will also take care of aspects such
    as spawning the player characters and preparing the clock.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 `LevelManager` 类完成，我们将将其实例添加到游戏引擎（`Engine` 类）中。我们还将向 `Engine` 类添加一个新函数，`loadLevel`，我们可以在需要新级别时从
    `update` 函数中调用它。`loadLevel` 函数不仅将使用 `LevelManager` 实例加载适当的级别，还将处理诸如生成玩家角色和准备时钟等方面。
- en: Now, let's get an overview of `LevelManager` by coding the `LevelManager.h`
    file.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过编写 `LevelManager.h` 文件来对 `LevelManager` 进行概述。
- en: Coding LevelManager.h
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 LevelManager.h
- en: Right-click `LevelManager.h`. Finally, click the `LevelManager` class.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 右键点击 `LevelManager.h`。最后，点击 `LevelManager` 类。
- en: 'Add the following include directives and private variables and then we will
    discuss them:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下包含指令和私有变量，然后我们将讨论它们：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding code declares a `Vector2i`, `m_LevelSize` to hold two integer
    values that will hold the horizontal and vertical number of tiles that the current
    map contains. The `Vector2f`, `m_StartPosition` contains the coordinates in the
    world where Bob and Thomas should be spawned. Note that this is not a tile position
    relatable to `m_LevelSize` units but a horizontal and vertical pixel position
    in the level.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码声明了一个 `Vector2i`，`m_LevelSize`，用于存储两个整数值，这两个值将包含当前地图包含的水平方向和垂直方向的瓦片数量。`Vector2f`，`m_StartPosition`
    包含 Bob 和 Thomas 应该在世界坐标中生成的坐标。请注意，这并不是与 `m_LevelSize` 单位相关的瓦片位置，而是在级别中的水平和垂直像素位置。
- en: The `m_TimeModifier` member variable is a float type variable that will be used
    to multiply the time that's available in the current level. The reason we want
    to do this is so that we can change (decrease) this value so that we can shorten
    the time that's available each time the player attempts the same level. As an
    example, if the player gets 60 seconds for the first time they attempt level 1,
    then 60 multiplied by 1 is, of course, 60\. When the player completes all the
    levels and comes back to level 1 for the second time, `m_TimeModifier` will have
    been reduced by 10 percent. Then, when the time available is multiplied by 0.9,
    the amount of time that's available to the player will be 54 seconds. This is
    10 percent less. The game will get steadily harder.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_TimeModifier` 成员变量是一个浮点类型变量，它将被用来乘以当前级别中可用的游戏时间。我们想要这样做的原因是，我们可以改变（减少）这个值，以便每次玩家尝试相同的级别时，都可以缩短可用的游戏时间。例如，如果玩家第一次尝试第
    1 级时得到 60 秒，那么当然，60 乘以 1 就是 60。当玩家完成所有级别并第二次回到第 1 级时，`m_TimeModifier` 将减少了 10%。然后，当可用时间乘以
    0.9 时，玩家可用的游戏时间将是 54 秒。这比原来少了 10%。游戏将逐渐变得更具挑战性。'
- en: The `m_BaseTimeLimit` float variable holds the original, unmodified time limit
    we have just discussed.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_BaseTimeLimit` 浮点变量持有我们刚刚讨论的原始、未修改的时间限制。'
- en: We can probably guess that `m_CurrentLevel` will hold the current level number
    that is being played.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能可以猜测 `m_CurrentLevel` 将存储正在播放的当前级别编号。
- en: The `int`, `NUM_LEVELS` constant will be used to flag when it is appropriate
    to go back to level 1 again and reduce the value of `m_TimeModifier`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`int` 和 `NUM_LEVELS` 常量将用于标记何时适宜再次回到第 1 级并减少 `m_TimeModifier` 的值。'
- en: 'Now, add the following public variables and function declarations after the
    previous code we added:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在之前添加的代码之后添加以下公共变量和函数声明：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the previous code, there are two constant `int` members. `TILE_SIZE` is a
    useful constant to remind us that each tile in the sprite-sheet is fifty pixels
    wide and fifty pixels high. `VERTS_IN_QUAD` is a useful constant to make our manipulation
    of a `VertexArray` less error-prone. There are, in fact, four vertices in a quad.
    Now, we can't forget this.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，有两个 `int` 类型的常量成员。`TILE_SIZE` 是一个有用的常量，提醒我们精灵图中每个瓦片的宽度为五十像素，高度为五十像素。`VERTS_IN_QUAD`
    是一个有用的常量，可以使我们对 `VertexArray` 的操作更不容易出错。实际上，一个四边形有四个顶点。现在，我们不要忘记这一点。
- en: The `getTimeLimit`, `getStartPosition`, `getLevelSize`, and `getCurrentLevel`
    functions are simple getter functions which return the current value of the private
    member variables we declared in the previous block of code.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`getTimeLimit`、`getStartPosition`、`getLevelSize` 和 `getCurrentLevel` 函数是简单的获取函数，它们返回我们在之前代码块中声明的私有成员变量的当前值。'
- en: The function that deserves to be talked about more is `nextLevel`. This function
    receives a `VertexArray` reference, just like we used in the Zombie Arena game.
    The function can then work on the `VertexArray` reference and all the changes
    will be present in the `VertexArray` reference from the calling code.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 值得更多讨论的函数是 `nextLevel`。该函数接收一个 `VertexArray` 引用，就像我们在僵尸竞技场游戏中使用的那样。然后该函数可以操作
    `VertexArray` 引用，所有更改都将反映在调用代码的 `VertexArray` 引用中。
- en: The `nextLevel` function returns a pointer to a pointer, which means we can
    return an address of the first element of a two-dimensional array of `int` values.
    We will be building a two-dimensional array of `int` values that will represent
    the layout of each level. Of course, these int values will be read from the level
    design text files.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`nextLevel` 函数返回一个指向指针，这意味着我们可以返回一个二维 `int` 值数组的第一个元素的地址。我们将构建一个二维 `int` 值数组，它将表示每个级别的布局。当然，这些
    `int` 值将从级别设计文本文件中读取。'
- en: Coding the LevelManager.cpp file
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 LevelManager.cpp 文件
- en: Right-click `LevelManager.cpp`. Finally, click the `.cpp` file for the `LevelManager`
    class.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 右键点击 `LevelManager.cpp`。最后，点击 `LevelManager` 类的 `.cpp` 文件。
- en: As this is quite a long class, we will break it up to discuss it in six chunks.
    The first five will cover the `nextLevel` function, while the sixth will cover
    the rest of the functions.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个相当长的类，我们将将其分成六个部分来讨论。前五个将涵盖 `nextLevel` 函数，而第六个将涵盖其余的函数。
- en: 'Add the following include directives and the first (of five) part of the `nextLevel`
    function:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下包含指令和 `nextLevel` 函数的第一个（五个中的第一个）部分：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After the include directives, the code initializes the `m_LevelSize.x` and `m_LevelSize.y`
    variables to zero.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含指令之后，代码将 `m_LevelSize.x` 和 `m_LevelSize.y` 变量初始化为零。
- en: Next, `m_CurrentLevel` is incremented. The `if` statement that follows checks
    whether `m_CurrentLevel` is greater than `NUM_LEVELS`. If it is, then `m_CurrentLevel`
    is set back to `1` and `m_TimeModifier` is reduced by `0.1` in order to shorten
    the allowed time for all levels.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`m_CurrentLevel` 增加。随后的 `if` 语句检查 `m_CurrentLevel` 是否大于 `NUM_LEVELS`。如果是，则将
    `m_CurrentLevel` 设置回 `1`，并将 `m_TimeModifier` 减少 `0.1` 以缩短所有级别的允许时间。
- en: The code then switches based on the value held by `m_CurrentLevel`. Each `case`
    statement initializes the name of the text file that holds the level design, the
    starting position for Thomas and Bob, as well as `m_BaseTimeLimit`, which is the
    unmodified time limit for the level in question.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 代码随后根据 `m_CurrentLevel` 保存的值进行切换。每个 `case` 语句初始化包含级别设计的文本文件名、托马斯和鲍勃的起始位置，以及
    `m_BaseTimeLimit`，这是所讨论级别的未修改时间限制。
- en: Tip
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you design your own levels, add a `case` statement and the appropriate values
    for it here. Also, edit the `NUM_LEVELS` constant in the `LevelManager.h` file.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你设计自己的级别，请在此处添加一个 `case` 语句及其相应的值。还要编辑 `LevelManager.h` 文件中的 `NUM_LEVELS`
    常量。
- en: 'Now, add the second part of the `nextLevel` function, as follows. Add this
    code immediately after the previous code. Study the code as we add it so we can
    discuss it:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加 `nextLevel` 函数的第二部分，如下所示。将此代码立即添加到前面的代码之后。在我们添加代码的同时研究代码，这样我们就可以讨论它：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding (second part) code, we declare an `ifstream` object called
    `inputFile` which opens a stream to the file name contained in `levelToLoad`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的（第二部分）代码中，我们声明了一个名为 `inputFile` 的 `ifstream` 对象，该对象打开到 `levelToLoad` 中包含的文件名的流。
- en: The code loops through each line of the file using `getLine`, but doesn't record
    any of its content. All it does is count the number of lines by incrementing `m_LevelSize.y`.
    After the `for` loop, the width of the level is saved in `m_LevelSize.x` using
    the `s.length` function. This implies that the length of all the lines must be
    the same or we would run into trouble.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 代码通过 `getLine` 函数遍历文件的每一行，但并不记录其内容。它所做的只是通过增加 `m_LevelSize.y` 来计数行数。在 `for`
    循环之后，使用 `s.length` 函数将级别的宽度保存到 `m_LevelSize.x` 中。这表明所有行的长度必须相同，否则我们会遇到麻烦。
- en: At this point, we know and have saved the length and width of the current level
    in `m_LevelSize`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们已经知道并保存了当前级别的长度和宽度在 `m_LevelSize` 中。
- en: 'Now, add the third part of the `nextLevel` function, as shown in the following
    code. Add the code immediately underneath the previous code. Study the code as
    we add it so we can discuss it:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加 `nextLevel` 函数的第三部分，如下所示代码。将代码立即添加到前面的代码之下。在我们添加代码的同时研究代码，这样我们就可以讨论它：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: First, we clear `inputFile` using its `clear` function. The `seekg` function,
    which is called with the `0, ios::beg` parameters, moves the file cursor's position
    (where characters will be read from next) to the beginning of the file.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Next, we declare a pointer to a pointer called `arrayLevel`. Note that this
    is done on the free store/heap using the `new` keyword. Once we have initialized
    this two-dimensional array, we will be able to return its address to the calling
    code and it will persist until we either delete it or the game is closed.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: The `for` loop loops from 0 to `m_LevelSize.y -1`. In each pass of the loop,
    it adds a new array of `int` values, on the heap, to match the value of `m_LevelSize.x`.
    We now have a perfectly configured (for the current level) two-dimensional array.
    The only problem is that there is nothing in it yet.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the fourth part of the `nextLevel` function, as shown in the following
    code. Add this code immediately after the previous code. Study the code as we
    add it so we can discuss it:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: First, the code initializes a `string` called `row` that will hold only one
    row of the level design at a time. We also declare and initialize an `int` called
    `y` that will help us count the rows.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: The `while` loop executes repeatedly until `inputFile` gets past the last row.
    Inside the `while` loop, there is a `for` loop which goes through each character
    of the current row and stores it in the two-dimensional array, `arrayLevel`. Notice
    that we access the right element of the two-dimensional array with `arrayLevel[y][x]=`.
    The `atoi` function converts the `char val` into an `int`. This is required because
    we have a two-dimensional array for `int`, and not for `char`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s add the fifth part of the `nextLevel` function, as shown here.
    Add this code immediately after the previous code. Study the code as we add it,
    so we can discuss it:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Although this is the longest section of code from the five sections (we divided
    `nextLevel` in two), it is also the most straightforward. This is because we have
    seen very similar code in the Zombie Arena project.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: The process for the precedingcode is that the nested `for` loops loop from zero
    through to the width and height of the level. For each position in the array,
    four vertices are put into the `VertexArray` and four texture coordinates are
    assigned from the sprite-sheet. The positions of the vertices and texture coordinates
    are calculated using the `currentVertex` variable, `TILE SIZE`, and the `VERTS_IN_QUAD`
    constants. At the end of each loop of the inner `for` loop, `currentVertex` is
    increased by `VERTS_IN_QUAD`, moving nicely on to the next tile.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: The important thing to remember about `VertexArray` is that it was passed in
    to `nextLevel` by reference. Therefore, `VertexArray` will be available in the
    calling code. We will call `nextLevel` from the code in the `Engine` class.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Once this function has been called, the `Engine` class will have a `VertexArray`
    to represent the level graphically and a two-dimensional array of `int` values
    as a numerical representation of all the platforms and obstacles in the level.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦调用此函数，`Engine` 类将有一个 `VertexArray` 来图形化表示关卡，以及一个二维 `int` 值数组，作为关卡中所有平台和障碍物的数值表示。
- en: 'The rest of the `LevelManager` functions are all simple getter functions but
    do take the time to familiarize yourself with which private value is returned
    by which function. Add the remaining functions from the `LevelManager` class,
    as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`LevelManager` 类的其余函数都是简单的获取函数，但请花时间熟悉每个函数返回哪个私有值。添加 `LevelManager` 类的其余函数，如下所示：'
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now that the `LevelManager` class is complete, we can move on to using it. We
    will code another function in the `Engine` class to do so.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `LevelManager` 类已经完成，我们可以继续使用它。我们将在 `Engine` 类中编写另一个函数来实现这一点。
- en: Coding the loadLevel function
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写 loadLevel 函数
- en: To be clear, this function is part of the `Engine` class, although it will delegate
    much of its work to other functions, including those of the `LevelManager` class
    that we just built.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，此函数是 `Engine` 类的一部分，尽管它将大部分工作委托给其他函数，包括我们刚刚构建的 `LevelManager` 类的函数。
- en: 'First, let''s add the declaration for the new function, along with some other
    new pieces of code, to the `Engine.h` file. Open the `Engine.h` file and add the
    highlighted lines of code shown in the abbreviated snapshot of the `Engine.h`
    file, as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将新函数的声明以及一些其他新代码添加到 `Engine.h` 文件中。打开 `Engine.h` 文件，并添加 `Engine.h` 文件缩略快照中显示的突出显示的代码行，如下所示：
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is what we can see in the previous code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们可以在前面的代码中看到的内容：
- en: We included the `LevelManager.h` file.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们包含了 `LevelManager.h` 文件。
- en: We added an instance of `LevelManager` called `m_LM`.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了一个名为 `m_LM` 的 `LevelManager` 实例。
- en: We added a `VertexArray` called `m_VALevel`.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了一个名为 `m_VALevel` 的 `VertexArray`。
- en: We added a pointer to a pointer to int that will hold the two-dimensional array
    that is returned from `nextLevel`.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了一个指向指向整数的指针，它将持有从 `nextLevel` 返回的二维数组。
- en: We added a new `Texture` object for the sprite-sheet.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为精灵图集添加了一个新的 `Texture` 对象。
- en: We added the declaration for the `loadLevel` function that we will write now.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了我们将要编写的 `loadLevel` 函数的声明。
- en: Right-click `LoadLevel.cpp`. Finally, click the `loadLevel` function.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 右键单击 `LoadLevel.cpp`。最后，单击 `loadLevel` 函数。
- en: 'Add the code for the `loadLevel` function to the `LoadLevel.cpp` file. Then,
    we can discuss it:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `loadLevel` 函数的代码添加到 `LoadLevel.cpp` 文件中。然后，我们可以讨论它：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: First, we set `m_Playing` to false to stop parts of the `update` function from
    executing. Next, we loop through all the horizontal arrays within `m_ArrayLevel`
    and delete them. After the `for` loop, we delete `m_ArrayLevel` itself.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将 `m_Playing` 设置为 `false` 以停止 `update` 函数的部分执行。接下来，我们遍历 `m_ArrayLevel`
    中的所有水平数组并将它们删除。在 `for` 循环之后，我们删除 `m_ArrayLevel` 本身。
- en: '`m_ArrayLevel = m_LM.nextLevel(m_VALevel)` calls `nextLevel` and prepares the
    `VertexArray`  `m_VALevel`, as well as the two-dimensional array known as `m_ArrayLevel`.
    The level is set up and ready to go.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`m_ArrayLevel = m_LM.nextLevel(m_VALevel)` 调用 `nextLevel` 并准备 `VertexArray`
    `m_VALevel` 以及称为 `m_ArrayLevel` 的二维数组。关卡已设置并准备就绪。'
- en: '`m_TimeRemaining` is initialized by calling `getTimeLimit` and Thomas and Bob
    are spawned using the `spawn` function, along with the value returned from `getStartPosition`.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用 `getTimeLimit` 初始化 `m_TimeRemaining`，并使用 `spawn` 函数生成 Thomas 和 Bob，同时使用
    `getStartPosition` 返回的值。
- en: Finally, `m_NewLevelRequired` is set to `false`. As we will see in a few pages
    time, `m_NewLevelRequired` being set to `true` causes `loadLevel` to be called.
    We only want to run this function once.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将 `m_NewLevelRequired` 设置为 `false`。正如我们将在几页后看到的那样，将 `m_NewLevelRequired`
    设置为 `true` 会导致调用 `loadLevel`。我们只想运行这个函数一次。
- en: Updating the engine
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新引擎
- en: 'Open the `Engine.cpp` file and add the following highlighted code to load the
    sprite-sheet texture at the end of the Engine constructor:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `Engine.cpp` 文件，并在 Engine 构造函数的末尾添加以下突出显示的代码来加载精灵图集纹理：
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: All we do in the previous code is load the sprite-sheet into `m_TextureTiles`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们只是将精灵图集加载到 `m_TextureTiles`。
- en: 'Open the `Update.cpp` file and make the following highlighted changes and additions:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `Update.cpp` 文件，进行以下突出显示的更改和添加：
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Actually, we should delete, rather than comment out, the lines we are no longer
    using. I have just shown it in this way so that the changes are clear. All there
    should be in the previous `if` statement is the call to `loadLevel`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们应该删除而不是注释掉我们不再使用的行。我之所以这样展示，是为了使更改清晰。在之前的`if`语句中，应该只有调用`loadLevel`的代码。
- en: 'Finally, before we can see the results of the work we''ve done so far in this
    chapter, open the `Draw.cpp` file and make the following highlighted additions
    to draw the vertex array that represents a level:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们能够看到本章到目前为止所做工作的结果之前，打开`Draw.cpp`文件，并添加以下突出显示的修改以绘制表示一个级别的顶点数组：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note that we need to draw the `VertexArray` for all the screen options (full,
    left, and right).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们需要为所有屏幕选项（全屏、左屏和右屏）绘制`VertexArray`。
- en: Now, you can run the game. Unfortunately, however, Thomas and Bob fall straight
    through all our lovingly designed platforms. Due to this, we can't try and progress
    through the levels and beat the clock.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以运行游戏了。然而，不幸的是，Thomas和Bob会直接穿过我们精心设计的所有平台。因此，我们无法尝试通过关卡并击败时钟。
- en: Collision detection
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞检测
- en: We will handle collision detection using rectangle intersection and the SFML
    `intersects` function. What will be different in this project is that we will
    abstract the collision detection code into its own function. Thomas and Bob, as
    we have already seen, have multiple rectangles (`m_Head`, `m_Feet`, `m_Left`,
    and `m_Right`) that we need to check for collisions.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用矩形交集和SFML的`intersects`函数来处理碰撞检测。在这个项目中，我们将把碰撞检测代码抽象成一个单独的函数。正如我们已经看到的，Thomas和Bob有多个矩形（`m_Head`、`m_Feet`、`m_Left`和`m_Right`），我们需要检查这些矩形是否发生碰撞。
- en: Coding the detectCollisions function
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写`detectCollisions`函数
- en: 'To be clear, this function is part of the `Engine` class. Open the `Engine.h`
    file and add a declaration for a function called `detectCollisions`. This is highlighted
    in the following code snippet:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，这个函数是`Engine`类的一部分。打开`Engine.h`文件，并添加一个名为`detectCollisions`的函数声明。以下代码片段中已突出显示：
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice from the signature that the `detectCollision` function takes a polymorphic
    argument as a `PlayerCharacter` object. As we know, `PlayerCharacter` is abstract
    and can never be instantiated. We do, however, inherit from it with the `Thomas`
    and `Bob` classes. We will be able to pass either `m_Thomas` or `m_Bob` to `detectCollisions`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，从签名中可以看出，`detectCollision`函数接受一个作为`PlayerCharacter`对象的泛型参数。正如我们所知，`PlayerCharacter`是抽象的，永远不能实例化。然而，我们确实通过`Thomas`和`Bob`类从它继承。我们将能够将`m_Thomas`或`m_Bob`传递给`detectCollisions`。
- en: Right-click `DetectCollisions.cpp`. Finally, click the `detectCollisions` function.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 右键点击`DetectCollisions.cpp`。最后，点击`detectCollisions`函数。
- en: 'Add the following code to `DetectCollisions.cpp`. Note that this is just the
    first part of this function:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`DetectCollisions.cpp`中。请注意，这仅仅是这个函数的第一部分：
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first thing that we do is declare a Boolean called `reachedGoal`. This is
    the value that the `detectCollisions` function returns to the calling code. It
    is initialized to `false`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先声明一个名为`reachedGoal`的布尔值。这是`detectCollisions`函数返回给调用代码的值。它被初始化为`false`。
- en: Next, we declare a `FloatRect` object called `detectionZone` and initialize
    it with the same rectangle that represents the entire rectangle of the character
    sprite. Note that we will not actually do intersection tests with this rectangle.
    After, we declare another `FloatRect` called `block`. We initialize `block` as
    a 50 by 50 game unit rectangle. We will see `block` in use shortly.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声明一个名为`detectionZone`的`FloatRect`对象，并用代表整个角色精灵矩形相同的矩形初始化它。请注意，我们实际上不会与这个矩形进行交集测试。之后，我们声明另一个名为`block`的`FloatRect`。我们将`block`初始化为一个50x50的游戏单位矩形。我们很快就会看到`block`的使用。
- en: Next, we will look at how we will use `detectionZone`. We initialize four `int`
    variables, `startX`, `startY`, `endX`, and `endY`, by expanding the area around
    `detectionZone` by a few blocks. In the four `if` statements that follow, we check
    that it is not possible to try and do collision detection on a tile that does
    not exist. We will achieve this by making sure we never check positions less than
    zero or greater than the value returned by `getLevelSize().x` or `.y`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看如何使用`detectionZone`。我们通过在`detectionZone`周围扩展几个方块的区域来初始化四个`int`变量，`startX`、`startY`、`endX`和`endY`。在接下来的四个`if`语句中，我们检查不可能尝试在不存在的小块上进行碰撞检测。我们将通过确保我们永远不会检查小于零或大于`getLevelSize().x`或`.y`返回值的坐标位置来实现这一点。
- en: What all this previous code has done is create an area that is used to do collision
    detection. There is no point doing collision detection on a block that is hundreds
    or thousands of pixels away from the character. In addition, if we try and do
    collision detection where an array position doesn't exist (less than zero or greater
    than `getLevelSize()...`), the game will crash.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 所有之前的代码所做的是创建一个用于碰撞检测的区域。在距离角色数百或数千像素的方块上进行碰撞检测是没有意义的。此外，如果我们尝试在数组位置不存在的地方（小于零或大于`getLevelSize()...`）进行碰撞检测，游戏将会崩溃。
- en: 'Next, add the following code, which handles the player falling out of the level:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加以下代码，用于处理玩家从关卡中掉落的情况：
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: For a character to stop falling, it must collide with a platform. Therefore,
    if the player moves out of the map (where there are no platforms), they will continuously
    fall. The previous code checks whether the character *does not* intersect with
    the `FloatRect`, `level`. If it does not, then it has fallen out of the level
    and the `spawn` function sends it back to the start.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使角色停止下落，它必须与平台发生碰撞。因此，如果玩家移动出地图（那里没有平台），他们将会持续下落。之前的代码检查角色是否没有与`FloatRect`、`level`相交。如果没有，那么它已经掉出关卡，`spawn`函数将其送回起点。
- en: 'Add the following, quite long. code block and then we will go through what
    it does:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下相当长的代码块，然后我们将解释它的功能：
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The previous code does three things using the same techniques. It loops through
    all the values contained between `startX`, `endX`, and `startY`, `endY`. For each
    pass, it checks and does the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码使用相同的技巧做了三件事。它遍历`startX`、`endX`和`startY`、`endY`之间的所有值。对于每次遍历，它都会检查并执行以下操作：
- en: Has the character been burned or drowned? `if (m_ArrayLevel[y][x] == 2 || m_ArrayLevel[y][x]
    == 3)` determines whether the current position being checked is a fire or a water
    tile. If the character's head intersects with one of these tiles, the player is
    respawned. We also code an empty `if`/`else` block in preparation to add sound
    in the next chapter.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色是否被烧伤或淹死？`if (m_ArrayLevel[y][x] == 2 || m_ArrayLevel[y][x] == 3)`确定当前检查的位置是否是火或水方块。如果角色的头部与这些方块之一相交，玩家将被重生。我们还编写了一个空的`if`/`else`块，为下一章添加声音做准备。
- en: Has the character touched a regular tile? `code if (m_ArrayLevel[y][x] == 1)`
    determines whether the current position being checked holds a regular tile. If
    it intersects with any of the rectangles that represent the various body parts
    of the character, then the related function is called (`stopRight`, `stopLeft`,
    `stopFalling`, or `stopJump`). The value that is passed to each of these functions
    and how the function uses that value to reposition the character is quite nuanced.
    While it is not necessary to closely examine these values to understand the code,
    we might like to look at the values that are passed in and then refer to the appropriate
    function of the `PlayableCharacter` class in the previous chapter. This will help
    you appreciate exactly what is going on.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色是否触碰到普通方块？`code if (m_ArrayLevel[y][x] == 1)`确定当前检查的位置是否持有普通方块。如果它与代表角色各个身体部位的矩形之一相交，则调用相关函数（`stopRight`、`stopLeft`、`stopFalling`或`stopJump`）。传递给每个函数的值以及函数如何使用这些值来重新定位角色相当微妙。虽然理解代码不需要仔细检查这些值，但我们可能想查看传递的值，然后参考上一章中`PlayableCharacter`类的适当函数。这将帮助你真正理解正在发生的事情。
- en: Has the character touched the goal tile? This is determined with `if (m_ArrayLevel[y][x]
    == 4)`. All we need to do is set `reachedGoal` to `true`. The `update` function
    of the `Engine` class will keep track of whether both characters (Thomas and Bob)
    have reached the goal simultaneously. We will write this code in the `update`
    function in just a minute.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色是否触碰到目标方块？这是通过`if (m_ArrayLevel[y][x] == 4)`来确定的。我们只需要将`reachedGoal`设置为`true`。`Engine`类的`update`函数将跟踪两个角色（托马斯和鲍勃）是否同时达到目标。我们将在下一分钟内将此代码写入`update`函数。
- en: 'Add the following line of code to the `detectCollisions` function:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下行代码添加到`detectCollisions`函数中：
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The previous line of code returns the `reachedGoal` Boolean value so that the
    calling code can keep track and respond appropriately if both characters simultaneously
    reach the goal.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 上一行代码返回`reachedGoal`布尔值，以便调用代码可以跟踪并适当地响应，如果两个角色同时达到目标。
- en: 'All we need to do now is call the `detectCollision` function once per character,
    per frame. Add the following highlighted code in the `Update.cpp` file within
    the `if(m_Playing)` block of code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要做的只是对每个字符、每帧调用一次`detectCollision`函数。在`Update.cpp`文件中`if(m_Playing)`代码块内添加以下高亮代码：
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The previous code calls the `detectCollision` function and checks if both Bob
    and Thomas have simultaneously reached the goal. If they have, then the next level
    is prepared by setting `m_NewLevelRequired` to `true`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码调用了`detectCollision`函数，并检查鲍勃和托马斯是否同时达到目标。如果他们做到了，那么下一级将通过将`m_NewLevelRequired`设置为`true`来准备。
- en: You can run the game and walk on the platforms. You can reach the goal and start
    a new level. Also, for the first time, the jump button (*W* or *Up* arrow) will
    work.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以运行游戏并在平台上行走。你可以达到目标并开始新的一级。此外，对于第一次，跳跃按钮（*W*或*向上箭头*）将生效。
- en: If you reach the goal, then the next level will load. If you reach the goal
    of the last level, then the first level will load with a 10% reduced time limit.
    Of course, there is no visual feedback for the time or the current level because
    we haven't built a HUD yet. We will do so in the next chapter.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你达到目标，则将加载下一级。如果你达到最后一关的目标，则第一级将以10%减少的时间限制加载。当然，由于我们还没有构建HUD，所以没有时间或当前级别的视觉反馈。我们将在下一章中这样做。
- en: Many of the levels, however, require Thomas and Bob to work as a team. More
    specifically, Thomas and Bob need to be able to climb on each other's heads.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，许多关卡需要托马斯和鲍勃作为团队一起工作。更具体地说，托马斯和鲍勃需要能够爬到彼此的头上。
- en: More collision detection
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多碰撞检测
- en: 'Add the following code just after you added the previous code in the `Update.cpp`
    file, within the `if (m_Playing)` section:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Update.cpp`文件中添加了之前的代码之后，在`if (m_Playing)`部分之后添加以下代码：
- en: '[PRE20]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You can run the game again and stand on the heads of Thomas and Bob to get
    to the hard-to-reach places that were previously not possible to get to:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以再次运行游戏并站在托马斯和鲍勃的头上，以到达之前无法到达的难以到达的地方：
- en: '![](img/B14278_16_09.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14278_16_09.jpg)'
- en: Summary
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: There was quite a lot of code in this chapter. We learned how to read from a
    file and convert strings of text into `char` values and then into int `values`.
    Once we had a two-dimensional array of `int` values, we were able to populate
    a `VertexArray` instance to show the level on the screen. We then used the same
    two-dimensional array of `int` values to implement collision detection. We used
    rectangle intersection, just like we did in the Zombie Arena project, although
    this time, for more precision, we gave each character four collision zones – one
    each to represent their head, feet, left, and right-hand sides.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中有很多代码。我们学习了如何从文件中读取并将文本字符串转换为`char`值，然后转换为int`值`。一旦我们有了`int`值的二维数组，我们就能填充一个`VertexArray`实例来在屏幕上显示关卡。然后我们使用相同的`int`值的二维数组来实现碰撞检测。我们使用了矩形交集，就像我们在Zombie
    Arena项目中做的那样，不过这次，为了提高精度，我们给每个角色分配了四个碰撞区域——分别代表他们的头部、脚部、左侧和右侧。
- en: Now that the game is totally playable, we need to represent the state of the
    game (score and time) on the screen. In the next chapter, we will implement the
    HUD, along with some much more advanced sound effects than we have used so far.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏已经完全可玩，我们需要在屏幕上表示游戏状态（得分和时间）。在下一章中，我们将实现HUD，以及一些比我们迄今为止使用的更高级的声音效果。
