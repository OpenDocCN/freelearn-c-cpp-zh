- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Making a Lobby to Gather Players Together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we discussed how to use UDP packets to exchange data
    between multiple players in a game. While this approach is highly efficient, it
    requires a lot of manual work to ensure that data is sent and received correctly.
    In this chapter, we will explore the high-level network API of the Godot Engine,
    which simplifies the networking process by providing a set of built-in tools and
    functions that can handle common network tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, we will focus on the **ENetMultiplayerPeer API**, which is the
    Godot Engine’s wrapper class for its ENet library implementation, and **Remote
    Procedure Call** (**RPC**), a communication protocol that allows us to make calls
    to functions and methods on remote computers as if we were making them locally.
    We will use these tools to create a lobby, authenticate players, retrieve player
    avatar data from a fake JSON database, and synchronize all players when a player
    enters the lobby. We will explore the benefits of using RPCs instead of exchanging
    UDP packets, and how this approach can simplify the process of synchronizing game
    states between multiple players.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Calling functions remotely with RPCs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the multiplayer authority
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing UDP and ENet approaches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remaking the login screen with RPCs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the player’s avatar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving players’ avatars
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the lobby
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a solid understanding of how to use
    the Godot Engine’s high-level network API and RPCs to create a robust multiplayer
    lobby for your game.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will build yet another project using the Godot Engine. Remember,
    throughout this book, we are using Godot Engine version 4.0, so this is also a
    requirement.
  prefs: []
  type: TYPE_NORMAL
- en: 'This time around, we are going to use the files provided in the `res://03.making-lobby-to-gather-players`
    folder. So, if you don’t have the project repository yet, download it through
    this link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0](https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0)'
  prefs: []
  type: TYPE_NORMAL
- en: Then, with the project added to your Godot Engine’s project manager, open the
    project and proceed to the `res://03.making-lobby-to-gather-players` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Calling functions remotely with RPCs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a network context, **RPC** stands for **remote procedure call**, which is
    a protocol that allows one program to call a function or procedure on another
    program running on a different machine or over a network. In the context of the
    Godot Engine, RPCs allow objects to exchange data between each other over the
    network, which is a key feature in creating multiplayer games.
  prefs: []
  type: TYPE_NORMAL
- en: To use RPCs in the Godot Engine, we need to use the `ENetMultiplayerPeer` API,
    which provides a high-level network interface for handling network connections
    and sending and receiving data, as well as managing RPCs. By using `ENetMultiplayerPeer`,
    we can easily send and receive RPCs and handle network communication more straightforwardly.
  prefs: []
  type: TYPE_NORMAL
- en: When exchanging data with RPCs, objects can exchange data through functions,
    which makes the process more straightforward compared to exchanging data using
    UDP packets. With UDP packets, we need to send packets requesting procedures and
    wait for a response, and only then can we get the data. This process can be complex
    and difficult to manage, as we saw in the previous chapter, especially in large
    games with many objects exchanging data.
  prefs: []
  type: TYPE_NORMAL
- en: One limitation of RPCs is that they don’t allow the transmission of objects,
    such as nodes or resources, through the network. This can be a challenge in games
    that require the exchange of complex objects between different machines. However,
    there are workarounds to this limitation, such as sending serialized data or using
    custom serialization methods. We learned how to do that in [*Chapter 2*](B18527_02.xhtml#_idTextAnchor037),
    *Sending and Receiving Data*, so this won’t be a problem to us.
  prefs: []
  type: TYPE_NORMAL
- en: RPCs are a powerful tool for creating multiplayer games, and using the `ENetMultiplayerPeer`
    API in the Godot Engine makes it easy to use them. Although there are limitations
    to RPCs, such as the inability to transmit objects over the network, they are
    still a crucial part of creating a robust and seamless multiplayer experience.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the @rpc annotation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Godot Engine 4.0 introduces a new feature called `@rpc` function annotation.
    An `@rpc`, this annotation is used to mark functions that can be called remotely
    over the network in a multiplayer game.
  prefs: []
  type: TYPE_NORMAL
- en: There are several options that we can add to the `@rpc` annotation, which control
    how the function is called and executed over the network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a closer look at each option:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have the calling options, meaning what should happen when we make an RPC
    to this function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`call_remote`: This option indicates that the function should only be called
    remotely on instances of the node in other peers’ machines but not on the node’s
    local instance.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`call_local`: This option indicates that the function should also be called
    locally on the current peer’s instance of the node as well. This is useful when
    we need to sync all peers in the network, including the caller.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, we have the caller option, meaning who can call this function remotely:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`authority`: This option indicates that the function should only be called
    by the multiplayer authority. We’ll see more about that soon.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`any_peer`: This option indicates that the function can be called by any peer
    in the network. This is useful for functions that can be executed by multiple
    peers in a multiplayer game and not only the multiplayer authority.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We also have options regarding the reliability of the remote data exchange
    when we make an RPC to this function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reliable`: This option indicates that the function should be executed reliably
    over the network, which means that the function call will be guaranteed to arrive
    at its destination. This is useful for functions that need to be executed without
    the risk of losing data.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unreliable`: This option indicates that the function should be executed with
    low reliability, which means that there is a chance that some data may be lost
    or delayed over the network. This is useful for functions that can tolerate some
    loss of data.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unreliable_ordered`: This option is similar to `unreliable` but ensures that
    function calls are executed in order over the network. This is useful for functions
    that need to be executed in a specific order but can tolerate some data loss.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We can also specify which connection channel the RPC should use to transmit
    its data. This is useful to prevent bottlenecking or to dedicate some channels
    for specific functions. For instance, we can pick a channel that uses `reliable`
    data, such as the transmission of a message between players. Then, we can have
    another channel that uses `unreliable_ordered` data, such as updating peers about
    their avatars’ current position.
  prefs: []
  type: TYPE_NORMAL
- en: In that sense, we just need the most recent position to arrive; every other
    call with previous positions is irrelevant. So, while one channel waits for messages
    to arrive, the other is constantly receiving new updates about avatars’ positions
    and neither of them blocks the other.
  prefs: []
  type: TYPE_NORMAL
- en: 'The order in which we pass these options doesn’t matter for the Godot Engine
    itself. The only exception is the channel, which should always be the *last option*
    passed. Take the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'These two ways of establishing the RPC options are the same and both will work.
    Now, the following annotation has an issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Only the second RPC annotation will work, because we are passing the channel
    as the last argument of the annotation. In the first RPC annotation example, we
    are passing the channel as the first argument, so it won’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand how we can mark a function as an `rpc` function and what
    options we can use to fine-tune it and achieve what we need in our game, let’s
    see what we need to be able to call such functions and propagate them across the
    network.
  prefs: []
  type: TYPE_NORMAL
- en: What’s necessary for an RPC?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make RPCs in the Godot Engine, first, we must set up an `ENetMultiplayerPeer`
    connection, which manages the network connection and handles the transmission
    of data between nodes. We did that in the first chapter, but we will also go through
    the process here as well.
  prefs: []
  type: TYPE_NORMAL
- en: Once the `ENetMultiplayerPeer` connection is set up, we must ensure that the
    `NodePath` to the nodes receiving the RPC is exact. This means that the `NodePath`
    to the target node must be identical on all peers in the network. If the `NodePath`
    is not exact, the RPC may not be sent to the correct node or may not be sent at
    all.
  prefs: []
  type: TYPE_NORMAL
- en: We can establish a default name for our root nodes to avoid issues. We chose
    the root node to facilitate the logic afterward as it is the first node in the
    hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, in our upcoming `Main`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – The ServerLobby, LoginScreen, and ClientLobby scenes with their
    root node named Main](img/Figure_03.01_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – The ServerLobby, LoginScreen, and ClientLobby scenes with their
    root node named Main
  prefs: []
  type: TYPE_NORMAL
- en: It’s also important to note that every node in the network should share all
    the methods marked with `@rpc`, even if they are not called or used by anyone.
    This is because the Godot Engine requires all nodes to have access to the same
    set of methods to function properly. This can be a minor inconvenience for developers
    as it may bloat some classes with unnecessary methods, but it is necessary for
    Godot’s networking system to work effectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, these are the methods found in each of the scenes that compose
    our upcoming **Lobby** project. Note that they all share the highlighted methods
    on top of their non-RPC methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – The Server.gd, LoginScreen.gd, and Client.gd scripts share functions
    marked with the @rpc annotation](img/Figure_03.02_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – The Server.gd, LoginScreen.gd, and Client.gd scripts share functions
    marked with the @rpc annotation
  prefs: []
  type: TYPE_NORMAL
- en: Making RPCs in the Godot Engine requires setting up `ENetMultiplayerPeer` connections,
    ensuring that the `NodePath` to the target node is exact, and ensuring that all
    nodes in the network share all the methods marked as RPC. While this may require
    some additional setup and minor inconvenience, it enables developers to create
    multiplayer games easily and efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we understand the core of RPCs in the Godot Engine. We saw what we
    need to set our game to support RPCs, how the `@rpc` annotation works, and how
    we can tweak it to match our design. In one of those tweaking options, we saw
    that it’s possible to only allow the multiplayer authority to call a given RPC
    function. Let’s see what the multiplayer authority is and what we can do with
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the multiplayer authority
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Godot Engine’s high-level network API, the **multiplayer authority** is a
    concept that refers to the node that has the authority to make decisions about
    a node state in a multiplayer game. When two or more peers are connected in a
    multiplayer game, it is important to have a centralized peer that decides what
    changes are valid and should be synchronized across all connected clients.
  prefs: []
  type: TYPE_NORMAL
- en: The multiplayer authority is assigned to a specific peer in the game, usually
    the server or host, and this peer has the power to decide which changes from a
    given node should be accepted and synchronized across all connected clients. This
    is important because in a multiplayer game, multiple players may try to make changes
    to the game state at the same time, and it is the responsibility of the multiplayer
    authority to manage, verify, and synchronize these changes correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Each connected client in a multiplayer game is assigned a unique peer ID, which
    is a number that identifies the client within the game’s network. Peer IDs are
    managed by the `Node.multiplayer.multiplayer_peer` object, which is a reference
    to the `ENetMultiplayerPeer` object, which handles the game’s network connection.
    The `multiplayer_peer` object can be used to send and receive data between connected
    clients, as well as to manage the state of the game’s network connection.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the `Node.get_multiplayer_authority()` method to retrieve the node’s
    current multiplayer authority, as well as set a different one using `Node.set_multiplayer_authority(),`
    passing the peer ID as an argument. Changing a node’s multiplayer authority will
    allow the new peer to make and sync changes to this node across the network, and
    this can be quite dangerous.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, if a player is responsible for a node that contains its health,
    the player may somehow hack it and be able to self-manage their health, ultimately
    becoming immortal.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing UDP and ENet approaches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `UDPServer` and `PacketPeerUDP` classes are lower-level networking tools
    that allow for the exchange of data through UDP packets. This approach requires
    more work from us, as we must manage the sending and receiving of packets ourselves.
    For example, to create a login system using `UDPServer` and `PacketPeerUDP`, we
    would need to create a packet that contains the user’s login information, send
    it to the server, and then wait for a response.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 2*](B18527_02.xhtml#_idTextAnchor037), *Sending and Receiving Data*
    project, we saw how to use `UDPServer` and `PacketPeerUDP` to pass data around.
    We saw that using these classes, we can serialize data and deserialize it on each
    end of the system, both client and server. Using this approach, we need to poll
    packets and wait for requests and responses to arrive. It does the trick, but
    you saw it can get a bit complicated.
  prefs: []
  type: TYPE_NORMAL
- en: One advantage of using the `UDPServer` and `PacketPeerUDP` classes is that they
    provide more control over the networking process, which can be useful for more
    complex games that require fine-tuned networking. However, this approach is also
    more error-prone, as we must handle the sending and receiving of packets ourselves,
    which can lead to issues such as packet loss or out-of-order packets.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, using `ENetMultiplayerPeer` and RPCs provides a higher-level
    networking solution that simplifies the process of creating a login system. With
    this approach, developers can use the `@rpc` function annotation to mark a method
    as an RPC, which allows it to be called from any node in the network.
  prefs: []
  type: TYPE_NORMAL
- en: For example, to create a login system using `ENetMultiplayerPeer` and RPCs,
    we can mark the method that handles the login process as an RPC, and then call
    it from the client nodes. We are going to see that in a moment, and you will understand
    how powerful and simple the Godot Engine’s high-level network API is.
  prefs: []
  type: TYPE_NORMAL
- en: Using `ENetMultiplayerPeer` and RPCs simplifies the networking process and makes
    it easier to create multiplayer games. The built-in features of `ENetMultiplayerPeer`,
    such as automatic packet ordering and error correction, make it easier to create
    a stable network connection. On top of that, the `@rpc` annotation makes it easy
    to call methods from any node in the network, simplifying the development process.
  prefs: []
  type: TYPE_NORMAL
- en: While the `UDPServer` and `PacketPeerUDP` classes provide more control over
    the networking process, using `ENetMultiplayerPeer` and RPCs offers a simpler
    and more streamlined approach to creating multiplayer games. The choice ultimately
    depends on the specific needs of the game you are making, but in most cases, using
    the higher-level tools provided by the Godot Engine will lead to a faster and
    more efficient development process.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand how the Godot Engine’s high-level network API solves
    a lot of issues through the `ENetMultiplayerPeer` class and how it compares to
    the UDP approach, with major advantages, such as its ability to easily allow the
    RPC features we need to make our game easier, let’s remake the login screen we
    made in [*Chapter 2*](B18527_02.xhtml#_idTextAnchor037), *Sending and Receiving
    Data*, using these new tools. This will allow us to use the high-level API while
    understanding the low-level approach and the advantages of using the high-level
    approach instead.
  prefs: []
  type: TYPE_NORMAL
- en: Remaking the login screen with RPCs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome back to our studio, fellow network engineer! In [*Chapter 2*](B18527_02.xhtml#_idTextAnchor037),
    *Sending and Receiving Data*, we learned how to create a basic login system using
    the Godot Engine’s `UDPServer` and `PacketPeerUDP` classes. While this approach
    was perfect for our small-scale project, we need to level our game as we move
    forward and create a lobby!
  prefs: []
  type: TYPE_NORMAL
- en: Fear not, for we have the perfect solution for you – the Godot Engine’s `ENetMultiplayerPeer`
    and RPCs! These two powerful tools will help us build a robust and efficient system
    that can easily scale up to support multiple connected clients – as far as we
    researched, up to 4,095 simultaneously connected players!
  prefs: []
  type: TYPE_NORMAL
- en: With the Godot Engine’s `ENetMultiplayerPeer`, we can easily manage multiple
    connections and synchronize game data across all connected clients. This means
    that our login system will be able to handle more connections, and our game will
    run smoother than ever before!
  prefs: []
  type: TYPE_NORMAL
- en: With that, we will also be able to make RPCs! RPCs are an essential part of
    networking in the Godot Engine. They allow us to call functions on other nodes
    in the network as if they were local functions. With RPCs, we can easily share
    data and perform actions across all connected clients, making our login system
    even more robust and efficient.
  prefs: []
  type: TYPE_NORMAL
- en: So, get ready to level up our game, network engineer! In the upcoming sections,
    we’ll dive into implementing the new login system using `ENetMultiplayerPeer`
    and RPCs and synchronizing players’ avatars into a lobby.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also cover some best practices and tips for working with `ENetMultiplayerPeer`
    and RPCs to ensure our multiplayer game runs smoothly and efficiently. With these
    powerful tools at our disposal, we’ll be able to create a multiplayer game that
    will wow players and leave them wanting more.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by establishing connections between our players and the server using
    the `ENetMultiplayerPeer` API.
  prefs: []
  type: TYPE_NORMAL
- en: Establishing an ENetMultiplayerPeer connection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s recap from the first chapter how to establish a connection using the high-level
    `ENetMultiplayerPeer` class. We’ll start with the server.
  prefs: []
  type: TYPE_NORMAL
- en: This time, we will also add elements such as the fake database and the logged
    users from our project from [*Chapter 2*](B18527_02.xhtml#_idTextAnchor037), *Sending
    and Receiving Data*. This will allow us to authenticate players and keep track
    of who’s connected and their session tokens. Well, without further ado, let’s
    dive into it!
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start by setting up an ENet multiplayer server on port `9999`, loading
    our fake JSON database file, and assigning the `peer` instance to the `multiplayer_peer`
    property of the node’s `multiplayer` object so we can make RPCs. Remember, we
    can only carry out RPCs within an established ENet connection:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `res://03.making-lobby-to-gather-players/LobbyServer.tscn` scene, and
    then open the **Main** node’s script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Declare a constant variable, `PORT`, and assign our default value of `9999`.
    This variable will be used later to specify the port number on which the server
    will listen for incoming connections:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `@export` decorator to create a new variable, `database_file_path`,
    which can be edited from the **Inspector** panel. This variable will store the
    path to the JSON file that contains our fake user database. We are using the same
    file from the previous chapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new `ENetMultiplayerPeer` instance and assign it to the `peer` variable.
    This will be our high-level network interface for sending and receiving data between
    clients and the server and making RPCs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an empty dictionary called `database` and an empty dictionary called
    `logged_users`. These variables will be used to store our fake user data and keep
    track of which users are currently logged in, respectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `_ready()` callback, call `peer.create_server(PORT)` to create a new
    multiplayer server that listens for incoming connections on the port number specified
    by the `PORT` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Still in the `_ready()` callback, assign the `peer` to `multiplayer.multiplayer_peer`.
    This variable makes our `peer` object the default network interface for all nodes
    in the game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, still in the `_ready()` callback, make a call to the `load_database()`
    method. We are going to create this in a moment. We do that to have the database
    in memory from the start, as soon as the server is ready:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, define a new function, `load_database()`, that takes an optional argument,
    `path_to_database_file`. This function will be used to load the user data from
    the JSON file into our `database` dictionary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside `load_database()`, open the file specified by `path_to_database_file`
    using `FileAccess.open()` and assign it to the `file` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get the contents of the file as text using `file.get_as_text()` and assign
    it to the `file_content` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Parse the contents of `file_content` as JSON using `JSON.parse_string()` and
    assign the resulting dictionary to `database`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At this point, this is how our `LobbyServer.gd` should look like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With that, it’s time to get our hands dirty with the fun part and the core of
    this chapter. Up next, we are going to finally create the `@rpc` methods that
    we’ll use across our upcoming classes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the RPC functions template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With that, we can start to define our `@rpc` methods so when we move on to `LobbyLogin`,
    we already know what we’ll call and how it works. So, still in `LobbyServer`,
    let’s create some RPC methods.
  prefs: []
  type: TYPE_NORMAL
- en: These methods are going to be used on `LobbyLogin` and `LobbyClient` as well.
    Remember, all classes that make RPCs should share the same RPC methods even if
    they don’t use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s create this interface:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@rpc` annotation on this line is an RPC annotation that tells Godot that
    this function is called remotely only by the multiplayer authority, which is the
    server itself. A remote call means that when `LobbyServer` makes an RPC to this
    function, it won’t execute it on itself locally. We will use the `add_avatar()`
    method to add a new avatar to the game’s lobby, and we will implement it on `LobbyClient`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `clear_avatars()` function will remove all avatars from the lobby. We use
    this function to clear all avatars from the game so we can sync with newer players.
    This is also a method that we’ll implement on `LobbyClient`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This `@rpc("any_peer", "call_remote")` annotation tells Godot any peer can
    remotely call this function. We’ll use the `retrieve_avatar()` method to retrieve
    the texture path for a specific player’s avatar. We’ll implement this method in
    `LobbyServer` soon, and the `LobbyClient` is the one that’s going to remotely
    call it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `authenticate_player()` method will authenticate a player using a username
    and password. We use this function to authenticate players’ credentials and pair
    them with a session token on the `logged_users` dictionary. This is also a method
    from `LobbyServer`, but now it’s `LobbyLogin` that’s going to remotely call it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, we use the `authentication_failed()` method to notify a player that their
    authentication failed. We will call this from `LobbyServer` on `LobbyClient` when
    the server can’t authenticate the credentials the player sent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note that while every function marked with an `@rpc` annotation should be on
    all other classes it interacts with, those classes don’t need to have the same
    options for their `@rpc`. You will understand this better when we jump into `LobbyLogin`
    and `LobbyClient`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also have `authentication_succeed()`. We call this function from `LobbsyServer`
    on the player’s `LobbyClient` to tell them that their authentication succeeded,
    providing them with their session token:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With that, we have all the RPC functions we are going to use in our lobby system.
    `LobbyServer`’s RPCs section should look like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our template is ready. It has the `@rpc` methods that the classes that comprise
    our lobby need to share to communicate in our network. Remember, this is a necessary
    step; even if some of the classes don’t implement the method, they should at least
    share this interface. For instance, coming next, we are going to implement the
    authentication logic in the lobby server, but other classes only need the method
    signature for that to work. Let’s see how this goes.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating the player
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will focus on authenticating the player in the lobby server.
    We will use the `authenticate_player()` RPC method that we previously defined
    in our server script to verify the player’s identity and grant access to the lobby.
  prefs: []
  type: TYPE_NORMAL
- en: The `authenticate_player()` method will take a username and a password as arguments
    and will return either an error message or a session token. If the credentials
    are invalid, the method will make a remote call to the `authentication_failed()`
    method with an error message explaining the reason for the failure.
  prefs: []
  type: TYPE_NORMAL
- en: If the credentials are valid, the method will make a remote call to the `authentication_succeed()`
    method, passing a session token and returning it to the player’s `LobbyClient`.
    The session token is a unique integer number that identifies the player and is
    used to authenticate the player in subsequent RPCs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how we can implement this logic using the tools we have at our disposal
    in the Godot Engine:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside `LobbyServer`’s `authenticate_player()` method, get the `peer_id` of
    the player who sent the authentication request using the `multiplayer.get_remote_sender_id()`
    method. This is how we identify who sent the request so we can properly respond
    to the request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check whether the user exists in the `database` dictionary. If they don’t exist,
    call the `authentication_failed` RPC method on the `peer_id` with the message
    `"User doesn''t exist"`. For that, we can use the `rpc_id()` method, which makes
    an RPC directly to the peer with the given ID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the user exists in the database, check whether the password matches the
    password associated with the user. If it does, generate a random token using the
    `randi()` built-in method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add the authenticated user to the `logged_users` dictionary and call
    the `authentication_succeed` RPC method on the `peer_id` passing the token as
    an argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is what this method should look like:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note how useful making RPCs is. We don’t need to poll or wait for packets to
    arrive at the destination or be concerned with serializing function arguments.
    We don’t even have to create a *request* API to detect what the requester is trying
    to achieve as we did previously. It’s very straightforward, almost like making
    a local application where you have direct access to the objects.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s see how we call this function on `LobbyLogin`. I’ll assume that you
    already understand how it connects to the server using the `ENetMultiplayerPeer.create_client()`
    method. If you have any doubts about that, refer to the first chapter; the procedure
    is the same.
  prefs: []
  type: TYPE_NORMAL
- en: '`LobbyLogin` resembles the login from the previous chapter, so let’s skip directly
    to the `send_credentials()` method, where it communicates with `LobbyServer`.
    You’ll notice it also has the RPC methods we saw in `LobbyServer`. In this case,
    they all have the default options since the server is the only one that should
    call these methods on it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `send_credentials()` method, retrieve the `text` String property from
    the `user_line_edit` node and store it in the `user` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, do the same but with `password_line_edit` and store it in the `password`
    variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, make an RPC to the multiplayer authority calling the `authenticate_player()`
    method with the `user` and `password` arguments. This will make this call only
    on `LobbyServer`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is what the `LobbyLogin.send_credentials()` method will look like in the
    end:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let’s take a look at the `authentication_failed()` and `authentication_succeed()`
    methods just so we understand how they work and how we keep the players’ authenticated
    credentials across the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: '`authentication_succeed()` takes one argument called `session_token`, which
    is passed by the server when it authenticates the player’s credentials, as we
    saw previously.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, we update the `AuthenticationCredentials.user` and `AuthenticationCredentials.session_token`
    values using `user_line_edit.text` and the `session_token` argument. Just like
    in the previous chapter, `AuthenticationCredentials` is a singleton autoload that
    stores the player’s username and session token so we can use it in further scenes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Talking about further scenes, after updating the `AuthenticationCredentials`
    singleton, we change the scene to `lobby_screen_scene` using `get_tree().change_scene_to_file(lobby_screen_scene)`.
    That means the player has successfully logged in and we can take them to the game
    lobby:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'As for `authentication_failed()`, we set `error_label.text` to the error message
    received from `LobbyServer`. This will display the error to the player:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now that we understand how both sides of this relationship communicate and what
    they do with the data they pass around and get from each other, it’s time to move
    on and see how the game resolves this data and displays the players’ avatars to
    each other, synchronizing new players across the network every time they join
    the session.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming section, we will see what the lobby screen looks like on the
    player’s end and how we load, display, and sync players’ avatars across the network.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the player’s avatar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In any online game, the player’s avatar is a crucial element that represents
    them in the virtual world. In the previous section, we successfully authenticated
    the player and saved their session token and username in our `AuthenticationCredentials`
    autoload. Now, it’s time to use that information to display the player’s avatar
    in the lobby.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, we will retrieve the player’s avatar information from our fake
    database and create a new `AvatarCard`, a custom scene with a `TextureRect` node
    to display the avatar’s image and a label to show its name. This way, players
    will be able to easily identify each other and feel more connected to the game
    world.
  prefs: []
  type: TYPE_NORMAL
- en: 'For that, let’s open the `LobbyClient.gd` script. Here, we are going to do
    three major things:'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieve the avatar information from the server by making an RPC to the `retrieve_avatar()`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the `add_avatar()` method that `LobbyServer` calls after retrieving
    the avatar data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the `clear_avatars()` method that `LobbyServer` calls before adding
    a new avatar to the lobby.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We are going to start with the latter two, then we can move on to the `LobbyServer.gd`
    file again to implement the `retrieve_avatar()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `add_avatar()` method, create a new instance of `avatar_card_scene`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the newly created instance of `avatar_card` to `avatar_card_container`.
    This is an `HBoxContainer` node inside a `ScrollContainer` node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Wait for the next frame to process before continuing the execution of the code.
    We do that because `AvatarCard` needs to be ready before we update its data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call the `update_data()` method on the `avatar_card` instance to update its
    data using the arguments passed to the `add_avatar()` method. With that, the lobby
    will use `avatar_name` to display the player’s avatar name and will load the image
    stored in the `texture_path` to display their avatar’s image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The whole `add_avatar()` method should look like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using the `@rpc` annotation, we created a method that the game’s server can
    call on clients to add a new player avatar to all players’ lobby screens, but
    this causes a small issue. As it is, this method may add the avatars that were
    already in the lobby before the newer player joined it.
  prefs: []
  type: TYPE_NORMAL
- en: So, we need to first clear all previous avatars and then add all currently logged
    players’ avatars again. This ensures the lobby has only the correct avatars.
  prefs: []
  type: TYPE_NORMAL
- en: In the coming section, we are going to create a method that will run through
    all current avatars and remove them to have an empty `HBoxContainer`that we can
    use to add new avatars.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning AvatarCards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned before, whenever the server adds a new avatar to the lobby, it
    first cleans the lobby and recreates all avatars from scratch. We are going to
    see that in detail when we implement the `retrieve_avatar()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `clear_avatars()` method frees all existing avatars from the `avatar_card_container`
    node. It iterates over all children of `avatar_card_container` and calls `queue_free()`
    on each of them. After this function is executed, all avatars previously displayed
    in the lobby are removed from the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `clear_avatars()` method, iterate over each child node in `avatar_card_container`
    using a `for` loop and call the `queue_free()` method on each child node to remove
    it from `SceneTree` and free its resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: That’s it; pretty simple, right?
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, before we move back to `LobbyServer.gd`, let’s make an RPC to the multiplayer
    authority so it retrieves the current player’s avatar. We do that in the `_ready()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We use the `rpc_id()` method to call the `retrieve_avatar()` RPC method on the
    multiplayer authority, which is `LobbyServer` in this case. We pass the player’s
    `username` and `session_token`, which are stored in the `AuthenticationCredentials`
    singleton autoload, as arguments to the `retrieve_avatar()` method. Now, it’s
    time to move back to `LobbyServer.gd`.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving players’ avatars
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will implement the `retrieve_avatar()` method on the `LobbyServer.gd`
    script, which will allow players to request their avatar data from the server.
    The avatar data is stored in the fake database. The server will respond with some
    RPCs to update all players with the appropriate data, displaying their avatars
    in the shared lobby.
  prefs: []
  type: TYPE_NORMAL
- en: With this method in place, we will complete the functionality of our **Lobby**
    project. Players will be able to authenticate themselves and display their avatars
    in the lobby. This will provide a solid foundation for building more complex multiplayer
    games in the upcoming chapter, as the basics of networking have been covered.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s do it!
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `retrieve_avatar()` method, check whether the user is logged in by verifying
    that the user exists in the `logged_users` dictionary. If the user is not logged
    in, exit the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, check whether the session token provided by the remote peer matches the
    session token stored in the `logged_users` dictionary for the user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the tokens match, call the `clear_avatars()` function on all connected peers
    to clear any existing avatars from their lobby screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Loop through all the logged-in users stored in the `logged_users` dictionary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Retrieve the avatar name and texture path for the current `logged_user` from
    the `database` dictionary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call the `add_avatar()` method on all connected peers and pass in `avatar_name`
    and `avatar_texture_path` as arguments to display the avatar in the lobby:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is how the `retrieve_avatar()` method should look after all these steps:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Pay attention to its `@rpc` annotation options. Notice that any peer can call
    it remotely. This is how we make an RPC API for our online multiplayer games in
    the Godot Engine.
  prefs: []
  type: TYPE_NORMAL
- en: Some methods should be called remotely only by the multiplayer authority, some
    should be called locally as well, and some can be called by any peer on the network.
    It is up to us to decide and manage how peers interact with each other.
  prefs: []
  type: TYPE_NORMAL
- en: With all that in place, it’s time to test out our game using multiple instances
    to simulate a server and multiple players connected to our network. Let’s do this
    in the next section!
  prefs: []
  type: TYPE_NORMAL
- en: Testing the lobby
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To test this out, we are going to run three instances of the game:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to **Debug** | **Run Multiple Instances** and select **Run** **3 Instances**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 3.3 – Choosing to run three instances in the Run Multiple Instance\uFEFF\
    s menu](img/Figure_3.03_B18527.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – Choosing to run three instances in the Run Multiple Instances menu
  prefs: []
  type: TYPE_NORMAL
- en: Then, open the `res://03.making-lobby-to-gather-players/MainMenu.tscn` scene
    and hit the **Play** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pick one of the instances to be the game’s server. To do that, just click on
    the **Server** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Pressing the Server button on the MainMenu screen](img/Figure_03.04_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – Pressing the Server button on the MainMenu screen
  prefs: []
  type: TYPE_NORMAL
- en: Now, pick another instance and click on the `LobbyLogin` screen, where you can
    enter the first fake player’s credentials.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert `user1` in the username field and `test` in the password field. These
    are the credentials we added to `FakeDatabase.json` for our first user. Then,
    press the `LobbyClient` screen with a single avatar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.5 – The LobbyLogin screen with the player’s credentials](img/Figure_3.05_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – The LobbyLogin screen with the player’s credentials
  prefs: []
  type: TYPE_NORMAL
- en: With that, the server will authenticate the player’s credentials and will allow
    the player to move on to the next screen, displaying the player’s character’s
    avatar and name based on the data it matched in the database file. In the following
    screenshot, we can see the next screen after a successful login.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – LobbyClient displaying the player’s avatar after login](img/Figure_03.06_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – LobbyClient displaying the player’s avatar after login
  prefs: []
  type: TYPE_NORMAL
- en: Then, select the last instance and click on the `LobbyLogin` screen, use the
    second player’s credentials. In the first field, insert `user2`, and then, in
    the second field, `test`. It will take you to the `LobbyClient` screen, where
    there should be two avatars now. You can check the other client instance and they
    will both have the same avatars in order.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.7 – The game displaying both players’ avatars after the second player
    is logged in](img/Figure_3.07_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – The game displaying both players’ avatars after the second player
    is logged in
  prefs: []
  type: TYPE_NORMAL
- en: We can see that everything is working as we want! The players can insert their
    credentials and the server authenticates them and provides a session token to
    keep them logged in after their validation. When logged in, they can see their
    avatar. Not only that, but our game also syncs players’ avatars when a new player
    joins the session.
  prefs: []
  type: TYPE_NORMAL
- en: We did all that using the powerful `@rpc` annotation, which is possible to use
    when peers connect using the `ENetMultiplayerPeer` API.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about RPCs and their importance in multiplayer game
    architectures. We saw how RPCs can be used to exchange data between nodes in the
    Godot Engine. We also saw what a multiplayer authority node is and how to set
    one up that manages all the game states between network peers. On top of that,
    we saw that by using the multiplayer API and `ENetMultiplayerPeer`, we can easily
    handle the communication between nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the chapter, we created a lobby, which is a multiplayer game that
    features a lobby where players can join together. We saw how to create a client-server
    architecture, authenticate users, and exchange data between the server and the
    clients using RPCs. We also learned how to use the multiplayer API and `ENetMultiplayerPeer`
    to create a connection between the client and the server.
  prefs: []
  type: TYPE_NORMAL
- en: One of the essential concepts we learned is how `ENetMultiplayerPeer` simplifies
    the whole process of creating a multiplayer game compared to the low-level UDP
    approach. It abstracts away the complexity of low-level network programming, such
    as sending and receiving data packets, managing connections, and handling errors.
    This makes it easier for us to focus on implementing the gameplay mechanics of
    the game rather than worrying about the low-level details of the network communication.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, this chapter has provided a solid foundation for developing multiplayer
    games in the Godot Engine. By following the steps outlined in this chapter, developers
    can create a simple lobby-based multiplayer game that utilizes RPCs, authentication,
    and the multiplayer API.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming chapter, we are going to test the `ENetMultiplayerPeer` capabilities
    to exchange, update, and sync players. For that, we will create a chat room where
    players can communicate with each other and finally create a shared experience
    and a sense of community.
  prefs: []
  type: TYPE_NORMAL
