["```cpp\nlayout (location = 0) in vec3 VertexPosition; \nlayout (location = 1) in vec3 VertexNormal; \n\nout vec3 LightIntensity; \n\nuniform vec4 LightPosition;// Light position in camera coords. \nuniform vec3 Kd;           // Diffuse reflectivity \nuniform vec3 Ld;           // Light source intensity \n\nuniform mat4 ModelViewMatrix; \nuniform mat3 NormalMatrix; \nuniform mat4 ProjectionMatrix; \nuniform mat4 MVP;             // Projection * ModelView \n\nvoid main() \n{ \n    // Convert normal and position to eye coords \n    vec3 tnorm = normalize( NormalMatrix * VertexNormal); \n    vec4 camCoords = ModelViewMatrix * \n                     vec4(VertexPosition,1.0)); \n    vec3 s = normalize(vec3(LightPosition - camCoords)); \n\n    // The diffuse shading equation \n    LightIntensity = Ld * Kd * max( dot( s, tnorm ), 0.0 ); \n\n    // Convert position to clip coordinates and pass along \n    gl_Position = MVP * vec4(VertexPosition,1.0); \n} \n```", "```cpp\nin vec3 LightIntensity; \nlayout( location = 0 ) out vec4 FragColor; \n\nvoid main() { \n    FragColor = vec4(LightIntensity, 1.0); \n}\n```", "```cpp\nlayout (location = 0) in vec3 VertexPosition; \nlayout (location = 1) in vec3 VertexNormal; \n\nout vec3 LightIntensity; \n\nuniform struct LightInfo {\n  vec4 Position; // Light position in eye coords.\n  vec3 La;       // Ambient light intensity\n  vec3 Ld;       // Diffuse light intensity\n  vec3 Ls;       // Specular light intensity\n} Light;\n\nuniform struct MaterialInfo {\n  vec3 Ka;      // Ambient reflectivity\n  vec3 Kd;      // Diffuse reflectivity\n  vec3 Ks;      // Specular reflectivity\n  float Shininess; // Specular shininess factor\n} Material;\n\nuniform mat4 ModelViewMatrix; \nuniform mat3 NormalMatrix; \nuniform mat4 ProjectionMatrix; \nuniform mat4 MVP; \n\nvoid main() { \n  vec3 n = normalize( NormalMatrix * VertexNormal);\n  vec4 camCoords = ModelViewMatrix * vec4(VertexPosition,1.0);\n\n  vec3 ambient = Light.La * Material.Ka;\n  vec3 s = normalize(vec3(Light.Position - camCoords));\n  float sDotN = max( dot(s,n), 0.0 );\n  vec3 diffuse = Light.Ld * Material.Kd * sDotN;\n  vec3 spec = vec3(0.0);\n  if( sDotN > 0.0 ) {\n    vec3 v = normalize(-camCoords.xyz);\n    vec3 r = reflect( -s, n );\n    spec = Light.Ls * Material.Ks *\n            pow( max( dot(r,v), 0.0 ), Material.Shininess );\n  }\n\n  LightIntensity = ambient + diffuse + spec;\n  gl_Position = MVP * vec4(VertexPosition,1.0); \n} \n```", "```cpp\nin vec3 LightIntensity; \nlayout( location = 0 ) out vec4 FragColor; \n\nvoid main() { \n    FragColor = vec4(LightIntensity, 1.0); \n} \n```", "```cpp\n// Uniform variables and attributes omitted...\n void getCamSpace( out vec3 norm, out vec3 position ) {\n    norm = normalize( NormalMatrix * VertexNormal);\n    position = (ModelViewMatrix * vec4(VertexPosition,1.0)).xyz;\n}\n\nvec3 phongModel( vec3 position, vec3 n ) { \n  vec3 ambient = Light.La * Material.Ka;\n  vec3 s = normalize( Light.Position.xyz - position );\n  float sDotN = max( dot(s,n), 0.0 );\n  vec3 diffuse = Light.Ld * Material.Kd * sDotN;\n  vec3 spec = vec3(0.0);\n  if( sDotN > 0.0 ) {\n    vec3 v = normalize(-position.xyz);\n    vec3 r = reflect( -s, n );\n    spec = Light.Ls * Material.Ks *\n            pow( max( dot(r,v), 0.0 ), Material.Shininess );\n  }\n\n  return ambient + diffuse + spec;\n}\n\nvoid main() {\n    // Get the position and normal in camera space\n    vec3 camNorm, camPosition;\n    getCamSpace(camNorm, camPosition);\n\n    // Evaluate the reflection model\n    LightIntensity = phongModel( camPosition, camNorm );\n\n    gl_Position = MVP * vec4(VertexPosition,1.0);\n} \n```", "```cpp\n// Uniforms and attributes...\nout vec3 FrontColor;\nout vec3 BackColor;\n\nvec3 phongModel( vec3 position, vec3 n ) { \n    // The Phong model calculations go here...\n} \n\nvoid main() {\n    vec3 tnorm = normalize( NormalMatrix * VertexNormal);\n    vec3 camCoords = (ModelViewMatrix * \n    vec4(VertexPosition,1.0)).xyz;\n\n    FrontColor = phongModel( camCoords, tnorm );\n    BackColor = phongModel( camCoords, -tnorm );\n\n    gl_Position = MVP * vec4(VertexPosition,1.0);\n}\n```", "```cpp\nin vec3 FrontColor; \nin vec3 BackColor; \n\nlayout( location = 0 ) out vec4 FragColor; \n\nvoid main() { \n    if( gl_FrontFacing ) { \n        FragColor = vec4(FrontColor, 1.0); \n    } else { \n        FragColor = vec4(BackColor, 1.0); \n    } \n} \n```", "```cpp\nvoid main() {\n  vec3 tnorm = normalize( NormalMatrix * VertexNormal);\n  vec3 camCoords = (ModelViewMatrix * vec4(VertexPosition,1.0)).xyz;\n  vec3 v = normalize(-camCoords.xyz);\n\n  float vDotN = dot(v, tnorm);\n\n  if( vDotN >= 0 ) {\n    Color = phongModel(camCoords, tnorm);\n  } else {\n    Color = phongModel(camCoords, -tnorm);\n  }\n  gl_Position = MVP * vec4(VertexPosition,1.0);\n}\n```", "```cpp\nFragColor = mix( vec4(BackColor,1.0), \n                vec4(1.0,0.0,0.0,1.0), 0.7 );\n```", "```cpp\nflat out vec3 LightIntensity; \n```", "```cpp\nflat in vec3 LightIntensity; \n```", "```cpp\nglProvokingVertex(GL_FIRST_VERTEX_CONVENTION); \n```", "```cpp\nsubroutine vec3 shadeModelType( vec3 position, vec3 normal); \nsubroutine uniform shadeModelType shadeModel; \n\nout vec3 LightIntensity;\n\n// Uniform variables and attributes here...\n\nsubroutine( shadeModelType ) \nvec3 phongModel( vec3 position, vec3 norm ) { \n    // The Phong reflection model calculations go here...\n} \n\nsubroutine( shadeModelType ) \nvec3 diffuseOnly( vec3 position, vec3 norm ) { \n   // Compute diffuse shading only..\n} \n\nvoid main() {\n   // Compute camPosition and camNorm ...\n\n    // Evaluate the shading equation, calling one of \n    // the functions: diffuseOnly or phongModel. \n    LightIntensity = shadeModel(camPosition, camNorm); \n\n    gl_Position = MVP * vec4(VertexPosition,1.0); \n} \n```", "```cpp\nGLuint phongIndex = \n   glGetSubroutineIndex(programHandle, \n                       GL_VERTEX_SHADER,\"phongModel\"); \nGLuint diffuseIndex = \n    glGetSubroutineIndex(programHandle, \n                       GL_VERTEX_SHADER, \"diffuseOnly\"); \n\nglUniformSubroutinesuiv( GL_VERTEX_SHADER, 1, &phongIndex); \n... // Render the left teapot \n\nglUniformSubroutinesuiv( GL_VERTEX_SHADER, 1, &diffuseIndex); \n... // Render the right teapot \n```", "```cpp\nsubroutine vec3 shadeModelType( vec3 position, vec3 normal); \n```", "```cpp\nsubroutine uniform shadeModelType shadeModel; \n```", "```cpp\nsubroutine ( shadeModelType ) \n```", "```cpp\nLightIntensity = shadeModel( eyePosition, eyeNorm );\n```", "```cpp\nsubroutine( type1, type2 ) \n```", "```cpp\nlayout (location = 0) in vec3 VertexPosition; \nlayout (location = 1) in vec3 VertexNormal; \nlayout (location = 2) in vec2 VertexTexCoord; \n\nout vec3 FrontColor; \nout vec3 BackColor; \nout vec2 TexCoord; \n\n// Other uniform variables here...\n// getCamSpace and phongModel functions...\n\nvoid main() { \n    TexCoord = VertexTexCoord;\n\n    // Get the position and normal in camera space \n    vec3 camNorm, camPosition;\n    getCamSpace(camNorm, camPosition); \n\n    FrontColor = phongModel( camPosition, eyeNorm ); \n    BackColor = phongModel( camPosition, -eyeNorm ); \n\n    gl_Position = MVP * vec4(VertexPosition,1.0); \n} \n```", "```cpp\nin vec3 FrontColor; \nin vec3 BackColor; \nin vec2 TexCoord; \n\nlayout( location = 0 ) out vec4 FragColor; \n\nvoid main() { \n    const float scale = 15.0; \n    bvec2 toDiscard = greaterThan( fract(TexCoord * scale), \n                                   vec2(0.2,0.2) );\n    if( all(toDiscard) ) \n        discard; \n\n    if( gl_FrontFacing ) \n        FragColor = vec4(FrontColor, 1.0); \n    else \n        FragColor = vec4(BackColor, 1.0); \n} \n```"]