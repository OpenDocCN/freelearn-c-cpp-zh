["```cpp\nif ( roughness <= 0.3 ) {\n```", "```cpp\nrng_state = seed( gl_LaunchIDEXT.xy ) + current_frame;\nfloat U1 = rand_pcg() * rnd_normalizer;\nfloat U2 = rand_pcg() * rnd_normalizer;\n```", "```cpp\nuint seed(uvec2 p) {\n    return 19u * p.x + 47u * p.y + 101u;\n}\nuint rand_pcg() {\n    uint state = rng_state;\n    rng_state = rng_state * 747796405u + 2891336453u;\n    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) \n                  277803737u;\n    return (word >> 22u) ^ word;\n}\n```", "```cpp\nvec3 reflected_ray = normalize( reflect( incoming, normal ) );\n```", "```cpp\nvec3 normal = sampleGGXVNDF( incoming, roughness, roughness, \n                             U1, U2 );\nvec3 reflected_ray = normalize( reflect( incoming, normal ) );\n```", "```cpp\ntraceRayEXT( as, // topLevel\n            gl_RayFlagsOpaqueEXT, // rayFlags\n            0xff, // cullMask\n            sbt_offset, // sbtRecordOffset\n            sbt_stride, // sbtRecordStride\n            miss_index, // missIndex\n            world_pos, // origin\n            0.05, // Tmin\n            reflected_ray, // direction\n            100.0, // Tmax\n            0 // payload index\n        );\n```", "```cpp\nfor ( uint l = 0; l < active_lights; ++l ) {\n    Light light = lights[ l ];\n```", "```cpp\n    vec3 p_to_light = light.world_position - p_world.xyz;\n    float point_light_angle = dot( normalize( p_to_light ), \n                              triangle_normal );\n    float theta_i = acos( point_light_angle );\n```", "```cpp\n    float distance_sq = dot( p_to_light, p_to_light );\n    float r_sq = light.radius * light.radius;\n```", "```cpp\n    bool light_active = ( point_light_angle > 1e-4 ) && ( \n                          distance_sq <= r_sq );\n```", "```cpp\n    float theta_u = asin( light.radius / sqrt( distance_sq \n    ) );\n    float theta_prime = max( 0, theta_i - theta_u );\n    float orientation = abs( cos( theta_prime ) );\n```", "```cpp\n    float importance = ( light.intensity * orientation ) / \n                         distance_sq; \n    float final_value = light_active ? importance : 0.0;\n    lights_importance[ l ] = final_value;\n```", "```cpp\n    total_importance += final_value;\n}\n```", "```cpp\nfor ( uint l = 0; l < active_lights; ++l ) {\n    lights_importance[ l ] /= total_importance;\n}\n```", "```cpp\nfloat rnd_value = rand_pcg() * rnd_normalizer;\n```", "```cpp\nfor ( ; light_index < active_lights; ++light_index ) {\n    accum_probability += lights_importance[ light_index ];\n     if ( accum_probability > rnd_value ) {\n        break;\n    }\n}\n```", "```cpp\nfloat u_1 = luminance( reflections_color );\nfloat u_2 = u_1 * u_1;\nvec2 moments = vec2( u_1, u_2 );\n```", "```cpp\nbool check_temporal_consistency( uvec2 frag_coord ) {\n    vec2 frag_coord_center = vec2( frag_coord ) + 0.5; \n    vec2 motion_vector = texelFetch( global_textures[ \n                         motion_vectors_texture_index ], \n                         ivec2( frag_coord ), 0 ).rg; \n    vec2 prev_frag_coord = frag_coord_center + \n                           motion_vector;\n```", "```cpp\n    if ( any( lessThan( prev_frag_coord, vec2( 0 ) ) ) || \n          any( greaterThanEqual( prev_frag_coord, \n                                 resolution ) ) ) {\n              return false;\n    }\n```", "```cpp\n    uint mesh_id = texelFetch( global_utextures[ \n                               mesh_id_texture_index ], \n                               ivec2( frag_coord ), 0 ).r;\n    uint prev_mesh_id = texelFetch( global_utextures[ \n                        history_mesh_id_texture_index ], \n                        ivec2( prev_frag_coord ), 0 ).r;\n\n    if ( mesh_id != prev_mesh_id ) {\n        return false;\n    }\n```", "```cpp\n        float z = texelFetch( global_textures[ \n                              depth_texture_index ], \n                              ivec2( frag_coord ), 0 ).r;\n    float prev_z = texelFetch( global_textures[ \n                               history_depth_texture ], \n                               ivec2( prev_frag_coord ), 0 \n                               ).r;\n\n    vec2 depth_normal_dd = texelFetch( global_textures[ \n                           depth_normal_dd_texture_index ], \n                           ivec2( frag_coord ), 0 ).rg;\n    float depth_diff = abs( z - prev_z ) / ( \n                       depth_normal_dd.x + 1e-2 );\n\n    if ( depth_diff > 10 ) {\n        return false;\n    }\n```", "```cpp\n    float normal_diff = distance( normal, prev_normal ) / ( \n                                  depth_normal_dd.y + 1e-2 \n                                  );\n    if ( normal_diff > 16.0 ) {\n        return false;\n    }\n```", "```cpp\nif ( is_consistent ) {\n    vec3 history_reflections_color = texelFetch( \n    global_textures[ history_reflections_texture_index ], \n    ivec2( frag_coord ), 0 ).rgb;\n    vec2 history_moments = texelFetch( global_textures[ \n                           history_moments_texture_index ], \n                           ivec2( frag_coord ), 0 ).rg;\n\n    float alpha = 0.2;\n    integrated_color_out = reflections_color * alpha + \n    ( 1 - alpha ) * history_reflections_color;\n    integrated_moments_out = moments * alpha + ( 1 - alpha \n    ) * moments;\n```", "```cpp\n} else {\n    integrated_color_out = reflections_color;\n    integrated_moments_out = moments;\n}\n```", "```cpp\nfloat variance = moments.y - pow( moments.x, 2 );\n```", "```cpp\nfor ( int y = -2; y <= 2; ++y) {\n    for( int x = -2; x <= 2; ++x ) {\n        ivec2 offset = ivec2( x, y );\n        ivec2 q = frag_coord + offset;\n\n        if ( any( lessThan( q, ivec2( 0 ) ) ) || any( \n             greaterThanEqual( q, ivec2( resolution ) ) ) ) \n             {\n                 continue;\n        }\n```", "```cpp\n        float h_q = h[ x + 2 ] * h[ y + 2 ];\n        float w_pq = compute_w( frag_coord, q );\n        float sample_weight = h_q * w_pq;\n```", "```cpp\n        vec3 c_q = texelFetch( global_textures[ \n        integrated_color_texture_index ], q, 0 ).rgb;\n        float prev_variance = texelFetch( global_textures[ \n        variance_texture_index ], q, 0 ).r;\n```", "```cpp\n        new_filtered_color += h_q * w_pq * c_q;\n        color_weight += sample_weight;\n\n        new_variance += pow( h_q, 2 ) * pow( w_pq, 2 ) * \n                        prev_variance;\n        variance_weight += pow( sample_weight, 2 );\n    }\n}\n```", "```cpp\n    new_filtered_color /= color_weight;\n    new_variance /= variance_weight;\n```", "```cpp\nvec2 encoded_normal_p = texelFetch( global_textures[ \n                        normals_texture_index ], p, 0 ).rg;\nvec3 n_p = octahedral_decode( encoded_normal_p );\n\nvec2 encoded_normal_q = texelFetch( global_textures[ \n                        normals_texture_index ], q, 0 ).rg;\nvec3 n_q = octahedral_decode( encoded_normal_q );\n\nfloat w_n = pow( max( 0, dot( n_p, n_q ) ), sigma_n );\n```", "```cpp\nfloat z_dd = texelFetch( global_textures[ depth_normal_dd_\n                         texture_index ], p, 0 ).r;\nfloat z_p = texelFetch( global_textures[ depth_texture_index ], \n                        p, 0 ).r;\nfloat z_q = texelFetch( global_textures[ depth_texture_index ], \n                        q, 0 ).r;\n\nfloat w_z = exp( -( abs( z_p – z_q ) / ( sigma_z * abs( \n            z_dd ) + 1e-8 ) ) );\n```", "```cpp\nvec3 c_p = texelFetch( global_textures[ integrated_color_\n                       texture_index ], p, 0 ).rgb;\nvec3 c_q = texelFetch( global_textures[ integrated_color_\n                       texture_index ], q, 0 ).rgb;\n\nfloat l_p = luminance( c_p );\nfloat l_q = luminance( c_q );\n```", "```cpp\nfloat g = 0.0;\nconst int radius = 1;\nfor ( int yy = -radius; yy <= radius; yy++ ) {\n    for ( int xx = -radius; xx <= radius; xx++ ) {\n        ivec2 s = p + ivec2( xx, yy );\n        float k = kernel[ abs( xx ) ][ abs( yy ) ];\n        float v = texelFetch( global_textures[ \n                  variance_texture_index ], s, 0 ).r;\n        g += v * k;\n    }\n}\n```", "```cpp\nfloat w_l = exp( -( abs( l_p - l_q ) / ( sigma_l * sqrt\n            ( g ) + 1e-8 ) ) );\n\nreturn w_z * w_n * w_l;\n```"]