["```cpp\n    gBufferBaseColorTexture_ = context->createTexture(\n        VK_IMAGE_TYPE_2D, VK_FORMAT_R8G8B8A8_UNORM, 0,\n        VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT |\n            VK_IMAGE_USAGE_SAMPLED_BIT |\n            VK_IMAGE_USAGE_STORAGE_BIT,…\n    gBufferNormalTexture_ = context->createTexture(\n        VK_IMAGE_TYPE_2D,\n        VK_FORMAT_R16G16B16A16_SFLOAT, 0,\n        VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT |\n            VK_IMAGE_USAGE_SAMPLED_BIT |\n            VK_IMAGE_USAGE_STORAGE_BIT,…\n    gBufferPositionTexture_ = context->createTexture(\n          VK_IMAGE_TYPE_2D, VK_FORMAT_R16G16B16A16_SFLOAT, 0,\n          VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_STORAGE_BIT,…\n    depthTexture_ = context->createTexture(\n        VK_IMAGE_TYPE_2D, VK_FORMAT_D24_UNORM_S8_UINT,\n        0,\n        VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT |\n            VK_IMAGE_USAGE_TRANSFER_DST_BIT |\n            VK_IMAGE_USAGE_SAMPLED_BIT,…\n    ```", "```cpp\n    frameBuffer_ = context->createFramebuffer(\n          renderPass_->vkRenderPass(),\n          {gBufferBaseColorTexture_, gBufferNormalTexture_, gBufferEmissiveTexture_,\n           gBufferSpecularTexture_, gBufferPositionTexture_, depthTexture_},\n          nullptr, nullptr, \"GBuffer framebuffer \");\n    ```", "```cpp\n    renderPass_ = context->createRenderPass(\n          {gBufferBaseColorTexture_, gBufferNormalTexture_, gBufferEmissiveTexture_,\n           gBufferSpecularTexture_, gBufferPositionTexture_, depthTexture_},\n          {VK_ATTACHMENT_LOAD_OP_CLEAR, VK_ATTACHMENT_LOAD_OP_CLEAR,\n           VK_ATTACHMENT_LOAD_OP_CLEAR, VK_ATTACHMENT_LOAD_OP_CLEAR,\n           VK_ATTACHMENT_LOAD_OP_CLEAR, VK_ATTACHMENT_LOAD_OP_CLEAR},\n          {VK_ATTACHMENT_STORE_OP_STORE, VK_ATTACHMENT_STORE_OP_STORE,\n           VK_ATTACHMENT_STORE_OP_STORE, VK_ATTACHMENT_STORE_OP_STORE,\n           VK_ATTACHMENT_STORE_OP_STORE, VK_ATTACHMENT_STORE_OP_STORE},\n          // final layout for all attachments\n          {VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,\n           VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,\n           VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL,\n           VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL},\n          VK_PIPELINE_BIND_POINT_GRAPHICS, \"GBuffer RenderPass\");\n    ```", "```cpp\n    layout(location=0) in vec2 inTexCoord;\n    layout(location=1) in flat uint inflatMeshId;\n    layout(location=2) in flat int inflatMaterialId;\n    layout(location=3) in vec3 inNormal;\n    layout(location=4) in vec4 inTangent;\n    layout(location = 0) out vec4 outgBufferBaseColor;\n    layout(location = 1) out vec4 outgBufferWorldNormal;\n    layout(location = 2) out vec4 outgBufferEmissive;\n    layout(location = 3) out vec4 outgBufferSpecular;\n    layout(location = 4) out vec4 outgBufferPosition;\n    const vec3 n = normalize(inNormal);\n    const vec3 t = normalize(inTangent.xyz);\n    const vec3 b = normalize(cross(n,t) * inTangent.w);\n    const mat3 tbn =  mat3(t, b, n);\n    outgBufferWorldNormal.rgb = normalize(tbn * normalize(normalTan));\n    ```", "```cpp\n    layout(set = 0, binding = 0, rgba16f) uniform image2D SSRIntersect;\n    layout(set = 1, binding = 0)uniform sampler2D gBufferWorldNormal;\n    layout(set = 1, binding = 1)uniform sampler2D gBufferSpecular;\n    layout(set = 1, binding = 2)uniform sampler2D gBufferBaseColor;\n    layout(set = 1, binding = 3)uniform sampler2D hierarchicalDepth;\n    layout(set = 2, binding = 0)uniform Transforms\n    {\n      mat4 model;\n      mat4 view;\n      mat4 projection;\n      mat4 projectionInv;\n      mat4 viewInv;\n    } cameraData;\n    ```", "```cpp\n    vec3 generatePositionFromDepth(vec2 texturePos, float depth);\n    vec2 generateProjectedPosition(vec3 worldPos);\n    ```", "```cpp\n    layout(local_size_x = 16, local_size_y = 16,\n           local_size_z = 1) in;\n    void main() {\n      // Return if the coordinate is outside the screen\n      ...\n      imageStore(SSRIntersect,\n                 ivec2(gl_GlobalInvocationID.xy),\n                 vec4(0));\n      vec2 uv = (vec2(gl_GlobalInvocationID.xy) +\n                 vec2(0.5f)) /\n                vec2(pushConstant.textureResolution);\n      ivec2 pixelPos = ivec2(gl_GlobalInvocationID.xy);\n      vec4 gbufferNormalData =\n          texelFetch(gBufferWorldNormal, pixelPos, 0);\n      vec4 gbufferSpecularData =\n          texelFetch(gBufferSpecular, pixelPos, 0);\n      vec3 basecolor =\n          texture(gBufferBaseColor, uv).xyz;\n      float roughness = gbufferSpecularData.g;\n      if (gbufferSpecularData.r <\n          .01) { // Metal-ness check\n        imageStore(SSRIntersect,\n                   ivec2(gl_GlobalInvocationID.xy),\n                   vec4(basecolor, 1.0));\n        return;\n      }\n    ```", "```cpp\n      float z =\n          texelFetch(hierarchicalDepth, pixelPos, 0).r;\n      vec3 position = generatePositionFromDepth(uv, z);\n      vec3 normal = normalize(gbufferNormalData.xyz);\n      vec3 camPos = cameraData.viewInv[3].xyz;\n      vec3 viewDirection = normalize(position - camPos);\n      vec3 reflectionDirection =\n          reflect(viewDirection, normal);\n    ;\n      float stepSize = 0.05; // Initial step size\n      vec3 currentPos = position;\n      for (int i = 0; i < 50; i++) {\n        currentPos += reflectionDirection * stepSize;\n        vec2 screenPos =\n            generateProjectedPosition(currentPos);\n        if (screenPos.x < 0.0 || screenPos.x > 1.0 ||\n            screenPos.y < 0.0 || screenPos.y > 1.0) {\n          break; // Ray went out of screen bounds\n        }\n        float depthAtCurrent =\n            texture(hierarchicalDepth, screenPos).r;\n        vec3 positionFromDepth =\n            generatePositionFromDepth(screenPos,\n                                      depthAtCurrent);\n        float depthDifference =\n            length(currentPos - positionFromDepth);\n    ```", "```cpp\n        if (depthDifference < 0.05) {\n          vec3 hitColor =\n              texture(gBufferBaseColor, screenPos).xyz;\n          if (hitColor.x <= .1 && hitColor.y <= .1 &&\n              hitColor.z <= .1 && hitColor.x >= .08 &&\n              hitColor.y >= .08 &&\n              hitColor.z >=\n                  .08) { // .1 is considered sky color,\n                         // ignore if we hit sky\n            hitColor = basecolor;\n          }\n          vec3 blendColor =\n              hitColor * (1.0 - roughness) +\n              roughness * basecolor;\n          imageStore(SSRIntersect,\n                     ivec2(gl_GlobalInvocationID.xy),\n                     vec4(blendColor, 1.0));\n          return;\n        }\n      }\n      // Fallback\n      imageStore(SSRIntersect,\n                 ivec2(gl_GlobalInvocationID.xy),\n                 vec4(basecolor, 1.0));\n    }\n    ```", "```cpp\n    void ShadowPass::initTextures(\n        VulkanCore::Context *context) {\n      depthTexture_ = context->createTexture(\n          VK_IMAGE_TYPE_2D, VK_FORMAT_D24_UNORM_S8_UINT,\n          0,\n          VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT |\n              VK_IMAGE_USAGE_TRANSFER_DST_BIT |\n              VK_IMAGE_USAGE_SAMPLED_BIT,\n          {\n              .width =\n                  context->swapchain()->extent().width *\n                  4, // 4x resolution for shadow maps\n              .height = context->swapchain()\n                            ->extent()\n                            .height *\n                        4,\n              .depth = 1,\n          },\n          1, 1, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,\n          false, \"ShadowMap Depth buffer\");\n    }\n    ```", "```cpp\n    renderPass_ = context->createRenderPass(\n        {depthTexture_}, {VK_ATTACHMENT_LOAD_OP_CLEAR},\n        {VK_ATTACHMENT_STORE_OP_STORE},\n        // final layout for all attachments\n        {VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL},\n        VK_PIPELINE_BIND_POINT_GRAPHICS,\n        \"ShadowMap RenderPass\");\n    frameBuffer_ = context->createFramebuffer(\n        renderPass_->vkRenderPass(), {depthTexture_},\n        nullptr, nullptr, \"ShadowMap framebuffer \");\n    ```", "```cpp\n    auto vertexShader = context->createShaderModule(\n        (resourcesFolder / \"shadowpass.vert\").string(),\n        VK_SHADER_STAGE_VERTEX_BIT, \"shadowmap vertex\");\n    auto fragmentShader = context->createShaderModule(\n        (resourcesFolder / \"empty.frag\").string(),\n        VK_SHADER_STAGE_FRAGMENT_BIT,\n        \"shadowmap fragment\");\n    const VulkanCore::Pipeline::\n        GraphicsPipelineDescriptor gpDesc = {\n            .sets_ = setLayout,\n            .vertexShader_ = vertexShader,\n            .fragmentShader_ = fragmentShader,\n            .dynamicStates_ =\n                {VK_DYNAMIC_STATE_VIEWPORT,\n                 VK_DYNAMIC_STATE_SCISSOR},\n            .colorTextureFormats = {},\n            .depthTextureFormat =\n                VK_FORMAT_D24_UNORM_S8_UINT,\n            .sampleCount = VK_SAMPLE_COUNT_1_BIT,\n            .cullMode = VK_CULL_MODE_BACK_BIT,\n            .viewport = VkExtent2D(\n                depthTexture_->vkExtents().width,\n                depthTexture_->vkExtents().height),\n            .depthTestEnable = true,\n            .depthWriteEnable = true,\n            .depthCompareOperation = VK_COMPARE_OP_LESS,\n    };\n    pipeline_ = context->createGraphicsPipeline(\n        gpDesc, renderPass_->vkRenderPass(),\n    ```", "```cpp\n    #version 460\n    #extension GL_EXT_nonuniform_qualifier : require\n    #extension GL_EXT_debug_printf : enable\n    #extension GL_GOOGLE_include_directive : require\n    #include \"CommonStructs.glsl\"\n    #include \"IndirectCommon.glsl\"\n    void main() {\n      Vertex vertex = vertexAlias[VERTEX_INDEX]\n                          .vertices[gl_VertexIndex];\n      vec3 position =\n          vec3(vertex.posX, vertex.posY, vertex.posZ);\n      gl_Position = MVP.projection * MVP.view *\n                    MVP.model * vec4(position, 1.0);\n    }\n    ```", "```cpp\n    #version 460\n    void main() {\n    }\n    ```", "```cpp\n    samplerShadowMap_ = context.createSampler(\n        VK_FILTER_NEAREST, VK_FILTER_NEAREST,\n        VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE,\n        VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE,\n        VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE, 1.0f,\n        true, VK_COMPARE_OP_LESS_OR_EQUAL,\n        \"lighting pass shadow\");\n    ```", "```cpp\n    #version 460\n    layout(set = 0, binding = 6)uniform sampler2DShadow shadowMap;\n    layout(set = 1, binding = 1)uniform Lights\n    {\n        vec4 lightPos;\n        vec4 lightDir;\n        vec4 lightColor;\n        vec4 ambientColor; // environment light color\n        mat4 lightVP;\n        float innerConeAngle;\n        float outerConeAngle;\n    } lightData;\n    ```", "```cpp\n    #version 460\n    layout(set = 0, binding = 6)uniform sampler2DShadow shadowMap;\n    layout(set = 1, binding = 1)uniform Lights\n    {\n        vec4 lightPos;\n        vec4 lightDir;\n        vec4 lightColor;\n        vec4 ambientColor; // environment light color\n        mat4 lightVP;\n        float innerConeAngle;\n        float outerConeAngle;\n    } lightData;\n    ```", "```cpp\n    float PCF(vec4 shadowCoord) {\n      vec2 texCoord = shadowCoord.xy / shadowCoord.w;\n      texCoord = texCoord * .5 + .5;\n      texCoord.y = 1.0 - texCoord.y;\n      if (texCoord.x > 1.0 || texCoord.y > 1.0 ||\n          texCoord.x < 0.0 || texCoord.y < 0.0) {\n        return 1.0;\n      }\n      vec2 texSize = textureSize(shadowMap, 0);\n      float result = 0.0;\n      vec2 offset = (1.0 / texSize) * shadowCoord.w;\n      for(float x = -1.5; x <= 1.5; x += 1.0) {\n        for(float y = -1.5; y <= 1.5; y += 1.0) {\n          result += computeShadow(shadowCoord + vec4(vec2(x, y) * offset, 0.0, 0.0));\n        }\n      }\n      return result / 16.0;\n    ```", "```cpp\n    void main() {\n      vec4 worldPos =\n          texture(gBufferPosition, fragTexCoord);\n      vec3 basecolor =\n          texture(gBufferBaseColor, fragTexCoord).rgb;\n      if (worldPos.x == 0.0 && worldPos.y == 0.0 &&\n          worldPos.z == 0.0 && worldPos.w == 0.0) {\n        outColor = vec4(basecolor, 1.0);\n        return;\n      }\n      // compute outColor …\n      vec4 shadowProjPos =\n          lightData.lightVP * vec4(worldPos.xyz, 1.0f);\n      float vis = PCF(shadowProjPos);\n      if (vis <= .001) {\n        vis = .3;\n      }\n      outColor.xyz *= vis;\n    }\n    ```", "```cpp\n    #version 460\n    layout(local_size_x = 16, local_size_y = 16,\n           local_size_z = 1) in;\n    layout(set = 0, binding = 0,\n           rgba8) uniform image2D OutputSSAO;\n    layout(set = 1, binding = 0) uniform sampler2D\n        gBufferDepth;\n    const float nearDistance = .1f;\n    const float farDistance = 100.0f;\n    vec2 generateRandomNoise(\n        in vec2 coord) // generating random noise\n    {\n      float noiseX = (fract(\n          sin(dot(coord, vec2(12.9898, 78.233))) *\n          43758.5453));\n      float noiseY = (fract(\n          sin(dot(coord,\n                  vec2(12.9898, 78.233) * 2.0)) *\n          43758.5453));\n      return vec2(noiseX, noiseY) * 0.004;\n    }\n    ```", "```cpp\n    float calculateLinearDepth(float depth) {\n      return (2.0 * nearDistance) /\n             (farDistance + nearDistance -\n              depth * (farDistance - nearDistance));\n    }\n    ```", "```cpp\n    float compareDepths(float depth1, float depth2) {\n      const float aoCap = 0.5;\n      const float aoMultiplier = 50.0;\n      const float depthTolerance = 0.001;\n      const float aoRange = 60.0;\n      float depthDifference = sqrt(\n          clamp(1.0 - (depth1 - depth2) /\n                          (aoRange / (farDistance -\n                                      nearDistance)),\n                0.0, 1.0));\n      float ao =\n          min(aoCap, max(0.0, depth1 - depth2 -\n                                  depthTolerance) *\n                         aoMultiplier) *\n          depthDifference;\n      return ao;\n    }\n    ```", "```cpp\n    void main() {\n      if (gl_GlobalInvocationID.x >=\n              pushConstant.textureResolution.x ||\n          gl_GlobalInvocationID.y >=\n              pushConstant.textureResolution.y) {\n        return;\n      }\n      imageStore(OutputSSAO,\n                 ivec2(gl_GlobalInvocationID.xy),\n                 vec4(0));\n      vec2 uv = (vec2(gl_GlobalInvocationID.xy) +\n                 vec2(0.5f)) /\n                vec2(pushConstant.textureResolution);\n      ivec2 pixelPos =\n          ivec2(gl_GlobalInvocationID.xy);\n      float depthBufferValue =\n          texelFetch(gBufferDepth, pixelPos, 0).r;\n      float depth =\n          calculateLinearDepth(depthBufferValue);\n      float textureWidth =\n          float(pushConstant.textureResolution.x);\n      float textureHeight =\n          float(pushConstant.textureResolution.y);\n      float aspectRatio =\n          textureWidth / textureHeight;\n      vec2 noise =\n          generateRandomNoise(vec2(pixelPos));\n    ```", "```cpp\n      float w = (1.0 / textureWidth) /\n                    clamp(depth, 0.05, 1.0) +\n                (noise.x * (1.0 - noise.x));\n      float h = (1.0 / textureHeight) /\n                    clamp(depth, 0.05, 1.0) +\n                (noise.y * (1.0 - noise.y));\n      w *= textureWidth / 2.0;\n      h *= textureHeight / 2.0;\n      float sampleWidth;\n      float sampleHeight;\n      float ao = 0.0;\n      float totalSamples = 0.0;\n      float fade = 1.0;\n      const int NUM_RINGS = 3;\n      const int NUM_SAMPLES = 6;\n    ```", "```cpp\n      for (int i = 0; i < NUM_RINGS; i++) {\n        fade *= 0.5;\n        for (int j = 0; j < NUM_SAMPLES * i; j++) {\n          float step = 3.14159265 * 2.0 /\n                       float(NUM_SAMPLES * i);\n          sampleWidth =\n              (cos(float(j) * step) * float(i));\n          sampleHeight =\n              (sin(float(j) * step) * float(i));\n          float newDepthValue =\n              texelFetch(\n                  gBufferDepth,\n                  pixelPos +\n                      ivec2(int(sampleWidth * w),\n                            int(sampleHeight * h)),\n                  0)\n                  .r;\n          ao += compareDepths(depth,\n                              calculateLinearDepth(\n                                  newDepthValue)) *\n                fade;\n          totalSamples += 1.0 * fade;\n        }\n      }\n      ao /= totalSamples;\n      ao = 1.0 - ao;\n      imageStore(OutputSSAO, ivec2(gl_GlobalInvocationID.xy), vec4(ao,ao,ao, 1.0));\n    ```", "```cpp\n    #version 460\n    #extension GL_EXT_nonuniform_qualifier : require\n    #extension GL_GOOGLE_include_directive : require\n    layout(set = 0, binding = 0)uniform sampler2D gBufferWorldNormal;\n    layout(set = 0, binding = 1)uniform sampler2D gBufferSpecular;\n    layout(set = 0, binding = 2)uniform sampler2D gBufferBaseColor;\n    layout(set = 0, binding = 3)uniform sampler2D gBufferDepth;\n    layout(set = 0, binding = 4)uniform sampler2D gBufferPosition;\n    layout(set = 0, binding = 5)uniform sampler2D ambientOcclusion;\n    layout(set = 0, binding = 6)uniform sampler2DShadow shadowMap;\n    layout(set = 1, binding = 0)uniform Transforms\n    {\n        mat4 viewProj;\n        mat4 viewProjInv;\n        mat4 viewInv;\n    } cameraData;\n    layout(set = 1, binding = 1)uniform Lights\n    {\n        vec4 lightPos;\n        vec4 lightDir;\n        vec4 lightColor;\n        vec4 ambientColor; // environment light color\n        mat4 lightVP;\n        float innerConeAngle;\n        float outerConeAngle;\n    } lightData;\n    layout(location=0) in vec2 fragTexCoord;\n    layout(location = 0) out vec4 outColor;\n    ```", "```cpp\n    vec3 fresnelSchlick(float cosTheta, vec3 F0) {\n      return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n    }\n    float distributionGGX(vec3 N, vec3 H,\n                          float roughness) {\n      float a = roughness * roughness;\n      float a2 = a * a;\n      float NdotH = max(dot(N, H), 0.0);\n      float NdotH2 = NdotH * NdotH;\n      float nom = a2;\n      float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n      denom = 3.14159265359 * denom * denom;\n      return nom / denom;\n    }\n    float geometrySchlickGGX(float NdotV,\n                             float roughness) {\n      float r = (roughness + 1.0) * 0.5;\n      float r2 = r * r;\n      float nom = NdotV;\n      float denom = NdotV * (1.0 - r2) + r2;\n      return nom / denom;\n    }\n    float geometrySmith(vec3 N, vec3 V, vec3 L,\n                        float roughness) {\n      float NdotV = max(dot(N, V), 0.0);\n      float NdotL = max(dot(N, L), 0.0);\n      float ggx2 = geometrySchlickGGX(NdotV, roughness);\n      float ggx1 = geometrySchlickGGX(NdotL, roughness);\n      return ggx1 * ggx2;\n    }\n    ```", "```cpp\n    void main() {\n      vec4 worldPos =\n          texture(gBufferPosition, fragTexCoord);\n      vec3 basecolor =\n          texture(gBufferBaseColor, fragTexCoord).rgb;\n      if (worldPos.x == 0.0 && worldPos.y == 0.0 &&\n          worldPos.z == 0.0 && worldPos.w == 0.0) {\n        outColor = vec4(basecolor, 1.0);\n        return;\n      }\n      vec2 gbufferSpecularData =\n          texture(gBufferSpecular, fragTexCoord).rg;\n      float metallic = gbufferSpecularData.r;\n      float roughness = gbufferSpecularData.g;\n      vec4 gbufferNormalData =\n          texture(gBufferWorldNormal, fragTexCoord);\n      vec3 N = normalize(gbufferNormalData.xyz);\n    ```", "```cpp\n    vec3 camPos = cameraData.viewInv[3].xyz;\n    vec3 V = normalize(camPos - worldPos.xyz);\n    vec3 F0 = vec3(0.04);\n    F0 = mix(F0, basecolor, metallic);\n    vec3 L = normalize(\n        lightData.lightDir.xyz -\n        worldPos.xyz); // Using spotlight direction\n    vec3 H = normalize(V + L);\n    ```", "```cpp\n    vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);\n    float D = distributionGGX(N, H, roughness);\n    float G = geometrySmith(N, V, L, roughness);\n    vec3 nominator = D * G * F;\n    float denominator = 4.0 * max(dot(N, V), 0.0) *\n                            max(dot(N, L), 0.0) +\n                        0.001;\n    vec3 specular = nominator / denominator;\n    ```", "```cpp\n    vec3 kS = F;\n    vec3 kD = vec3(1.0) - kS;\n    kD *= 1.0 - metallic;\n    float NdotL = max(dot(N, L), 0.0);\n    vec3 diffuse = kD * basecolor / 3.14159265359;\n    ```", "```cpp\n    vec3 ambient =\n        lightData.ambientColor.rgb * basecolor;\n    // Spotlight calculations\n    vec3 lightToFragment =\n        lightData.lightPos.xyz - worldPos.xyz;\n    vec3 lightDirection =\n        normalize(-lightData.lightDir.xyz);\n    float distanceToLight = length(lightToFragment);\n    float attenuation =\n        1.0 /\n        (1.0 + 0.1 * distanceToLight +\n         0.01 * distanceToLight * distanceToLight);\n    vec3 lightDir = normalize(lightToFragment);\n    float cosTheta = dot(-lightDir, lightDirection);\n    float spotAttenuation =\n        smoothstep(lightData.outerConeAngle,\n                   lightData.innerConeAngle, cosTheta);\n    vec3 lightIntensity = spotAttenuation *\n                          attenuation *\n                          lightData.lightColor.rgb;\n    // Final light contribution\n    vec3 finalColor = (NdotL * (lightIntensity) *\n                       (diffuse + specular)) +\n                      ambient;\n    ```", "```cpp\n    float ao =\n        texture(ambientOcclusion, fragTexCoord).r;\n    finalColor *= ao;\n    outColor = vec4(finalColor, 1.0);\n    vec4 shadowProjPos =\n        lightData.lightVP * vec4(worldPos.xyz, 1.0f);\n    float vis = PCF(shadowProjPos);\n    if (vis <= .001) {\n      vis = .3;\n    }\n    outColor.xyz *= vis;\n    ```"]