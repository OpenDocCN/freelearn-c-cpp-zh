- en: Coin Dash
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Coin Dash
- en: This first project will guide you through making your first Godot Engine project.
    You will learn how the Godot editor works, how to structure a project, and how
    to build a small 2D game.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一个项目将引导你完成你的第一个Godot引擎项目。你将学习Godot编辑器的工作方式，如何构建项目结构，以及如何制作一个小型2D游戏。
- en: Why 2D? In a nutshell, 3D games are much more complex than 2D ones, while many
    of the underlying game engine features you'll need to know are the same. You should
    stick to 2D until you have a good understanding of Godot's game development process.
    At that point, the jump to 3D will be much easier. You'll get an introduction
    to 3D in this book's fifth and final project.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么是2D？简而言之，3D游戏比2D游戏复杂得多，而你需要了解的许多底层游戏引擎功能是相同的。你应该坚持2D，直到你对Godot的游戏开发过程有很好的理解。到那时，转向3D将容易得多。这本书的第五个和最后一个项目将介绍3D。
- en: Important—don't skip this chapter, even if you aren't a complete newcomer to
    game development. While you may already understand many of the underlying concepts,
    this project will introduce a number of fundamental Godot features and design
    paradigms that you'll need to know going forward. You'll build on these concepts
    as you develop more complex projects.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 重要——即使你不是游戏开发的完全新手，也不要跳过这一章。虽然你可能已经理解了许多底层概念，但这个项目将介绍许多基本的Godot功能和设计范式，这些是你今后需要了解的。随着你开发更复杂的项目，你将在此基础上构建这些概念。
- en: 'The game in this chapter is called **Coin Dash**. Your character must move
    around the screen, collecting as many coins as possible while racing against the
    clock. When you''re finished, the game will look like this:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的游戏被称为**Coin Dash**。你的角色必须在屏幕上移动，尽可能多地收集硬币，同时与时间赛跑。完成游戏后，游戏将看起来像这样：
- en: '![](img/00015.jpeg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00015.jpeg)'
- en: Project setup
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目设置
- en: Launch Godot and create a new project, making sure to use the `Create Folder`
    button to ensure that this project's files will be kept separate from other projects.
    You can download a Zip file of the art and sounds (collectively known as *assets*)
    for the game here, [https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases](https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 启动Godot并创建一个新项目，确保使用`创建文件夹`按钮来确保此项目的文件将与其他项目分开保存。你可以在此处下载游戏的艺术和声音（统称为*资产*）的Zip文件，[https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases](https://github.com/PacktPublishing/Godot-Game-Engine-Projects/releases)。
- en: Unzip this file in your new project folder.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件解压到你的新项目文件夹中。
- en: 'In this project, you will make three independent scenes: `Player`, `Coin`,
    and `HUD`, which will all be combined into the game''s `Main` scene. In a larger
    project, it might be useful to make separate folders to hold each scene''s assets
    and scripts, but for this relatively small game, you can save your scenes and
    scripts in the root folder, which is referred to as `res://` (**res** is short
    for **resource**). All resources in your project will be located relative to the
    `res://` folder. You can see your project folders in the FileSystem dock in the
    upper-left corner:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将制作三个独立的场景：`Player`、`Coin`和`HUD`，它们都将组合到游戏的`Main`场景中。在一个更大的项目中，创建单独的文件夹来保存每个场景的资源和脚本可能很有用，但在这个相对较小的游戏中，你可以在根文件夹中保存你的场景和脚本，该文件夹被称为`res://`（**res**是**资源**的缩写）。你的项目中的所有资源都将位于`res://`文件夹的相对位置。你可以在左上角的文件系统窗口中查看你的项目文件夹：
- en: '![](img/00016.jpeg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00016.jpeg)'
- en: For example, the images for the coin would be located in `res://assets/coin/`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，硬币的图片将位于`res://assets/coin/`。
- en: 'This game will use portrait mode, so you need to adjust the size of the game
    window. Click on the Project menu and select Project Settings, as shown in the
    following screenshot:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这个游戏将使用竖屏模式，因此你需要调整游戏窗口的大小。点击项目菜单并选择项目设置，如下面的截图所示：
- en: '![](img/00017.jpeg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00017.jpeg)'
- en: Look for the Display/Window section and set Width to `480` and Height to `720`.
    Also in this section, set the Stretch/Mode to `2D` and the Aspect to `keep`. This
    will ensure that if the user resizes the game window, everything will scale appropriately
    and not become stretched or deformed. If you like, you can also uncheck the box
    for Resizable, to prevent the window from being resized entirely.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 查找显示/窗口部分，并将宽度设置为`480`，高度设置为`720`。在此部分中，还将拉伸/模式设置为`2D`，并将纵横比设置为`保持`。这将确保如果用户调整游戏窗口的大小，所有内容都将适当地缩放，而不会拉伸或变形。如果你喜欢，你也可以取消选中可调整大小的复选框，以防止窗口完全调整大小。
- en: Vectors and 2D coordinate systems
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向量和2D坐标系
- en: 'Note: This section is a very brief overview of 2D coordinate systems and does
    not delve very deeply into vector math. It is intended as a high-level overview
    of how such topics apply to game development in Godot. Vector math is an essential
    tool in game development, so if you need a broader understanding of the topic,
    see Khan Academy''s Linear Algebra series ([https://www.khanacademy.org/math/linear-algebra](https://www.khanacademy.org/math/linear-algebra)).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本节是2D坐标系的一个非常简短的概述，并没有深入探讨向量数学。它旨在为Godot游戏开发提供一个高级概述。向量数学是游戏开发中的基本工具，因此如果你需要对此主题有更广泛的理解，请参阅可汗学院的线性代数系列([https://www.khanacademy.org/math/linear-algebra](https://www.khanacademy.org/math/linear-algebra))。
- en: When working in 2D, you'll be using Cartesian coordinates to identify locations
    in space. A particular position in 2D space is written as a pair of values, such
    as `(4,3)`, representing the position along the *x* and *y* axes, respectively.
    Any position in the 2D plane can be described in this way.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在2D工作中，你将使用笛卡尔坐标系来识别空间中的位置。2D空间中的特定位置可以表示为一对值，例如`(4,3)`，分别代表沿*x*轴和*y*轴的位置。2D平面上的任何位置都可以用这种方式描述。
- en: 'In 2D space, Godot follows the common computer graphics practice of orienting
    the *x* axis to the right, and the *y *axis down:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在2D空间中，Godot遵循常见的计算机图形学惯例，将*x*轴向右，*y*轴向下：
- en: '![](img/00018.jpeg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片2](img/00018.jpeg)'
- en: If you're new to computer graphics or game development, it might seem odd that
    the positive y axis points downwards instead of upwards, as you likely learned
    in math class. However, this orientation is very common in computer graphics applications.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刚开始接触计算机图形学或游戏开发，可能会觉得正y轴向下而不是向上有点奇怪，正如你可能在数学课上所学的。然而，这种方向在计算机图形学应用中非常常见。
- en: Vectors
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向量
- en: 'You can also think of the position `(4, 3)` as an *offset* from the `(0, 0)`
    point, or *origin*. Imagine an arrow pointing from the origin to the point:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将位置`(4, 3)`视为从`(0, 0)`点或**原点**的偏移。想象一支箭从原点指向该点：
- en: '![](img/00019.jpeg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片1](img/00019.jpeg)'
- en: This arrow is a *vector*. It represents a great deal of useful information including
    the point's location, *(4, 3)*, its length, *m,* and its angle from the *x*-axis, *θ*.
    Altogether, this is a *position vector*, in other words, it describes a position
    in space. Vectors can also represent movement, acceleration, or any other quantity
    that has an *x* and a *y* component.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这支箭是一个**向量**。它代表了许多有用的信息，包括点的位置，*(4, 3)*，其长度，*m*，以及其与*x*-轴的夹角，*θ*。总的来说，这是一个**位置向量**，换句话说，它描述了空间中的位置。向量也可以表示运动、加速度或任何具有*x*和*y*分量的其他量。
- en: In Godot, vectors (`Vector2` for 2D or `Vector3` for 3D) are widely used, and
    you'll use them in the course of building the projects in this book.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在Godot中，向量（2D中的`Vector2`或3D中的`Vector3`）被广泛使用，你将在本书构建的项目过程中使用它们。
- en: Pixel rendering
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 像素渲染
- en: Vector coordinates in Godot are *floating point *numbers, not *integers*. This
    means a `Vector2` could have a fractional value, such as `(1.5, 1.5)`. Since objects
    can't be drawn at half pixels, this can cause visual problems for pixel art games
    where you want to ensure that all the pixels of the textures are drawn.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Godot中的向量坐标是**浮点数**，而不是**整数**。这意味着`Vector2`可以有一个分数值，例如`(1.5, 1.5)`。由于对象不能在半像素处绘制，这可能会为像素艺术游戏带来视觉问题，其中你希望确保所有纹理的像素都被绘制。
- en: 'To address this, open Project *|* Project Settings and find the Rendering*/*Quality
    section in the sidebar and enable Use Pixel Snap, as shown in the following screenshot:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，打开**项目** *|* **项目设置**，在侧边栏中找到**渲染**/***质量**部分并启用使用像素捕捉，如图下截图所示：
- en: '![](img/00020.jpeg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片3](img/00020.jpeg)'
- en: If you're using 2D pixel art in your game, it's a good idea to always enable
    this setting when you start your project. This setting has no effect in 3D games.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在游戏中使用2D像素艺术，那么在开始项目时始终启用此设置是个好主意。在3D游戏中，此设置没有任何效果。
- en: Part 1 – Player scene
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一部分 – 玩家场景
- en: The first scene you'll make defines the Player object. One of the benefits of
    creating a separate player scene is that you can test it independently, even before
    you've created the other parts of the game. This separation of game objects will
    become more and more helpful as your projects grow in size and complexity. Keeping
    individual game objects separate from each other makes them easier to troubleshoot,
    modify, and even replace entirely without affecting other parts of the game. It
    also makes your player reusable—you can drop the player scene into an entirely
    different game and it will work just the same.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你将制作的第一个场景定义了玩家对象。创建单独的玩家场景的一个好处是，你可以在创建游戏的其它部分之前独立测试它。随着你的项目规模和复杂性的增长，这种游戏对象的分离将变得越来越有帮助。将单个游戏对象与其他对象保持分离，使它们更容易调试、修改，甚至完全替换而不影响游戏的其它部分。这也使你的玩家可重用——你可以将玩家场景放入一个完全不同的游戏中，它将正常工作。
- en: The player scene will display your character and its animations, respond to
    user input by moving the character accordingly, and detect collisions with other
    objects in the game.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家场景将显示你的角色及其动画，通过响应用户输入相应地移动角色，并检测与游戏中的其他对象的碰撞。
- en: Creating the scene
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建场景
- en: 'Start by clicking the Add/Create a New Node button and selecting an `Area2D`.
    Then, click on its name and change it to `Player`. Click Scene | Save Scene to
    save the scene. This is the scene''s *root* or top-level node. You''ll add more
    functionality to the `Player` by adding children to this node:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，点击添加/创建新节点按钮并选择一个 `Area2D`。然后，点击其名称并将其更改为 `Player`。点击场景 | 保存场景以保存场景。这是场景的
    *根* 或顶级节点。你将通过向此节点添加子节点来为 `Player` 添加更多功能：
- en: '![](img/00021.gif)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00021.gif)'
- en: 'Before adding any children, it''s a good idea to make sure you don''t accidentally
    move or resize them by clicking on them. Select the `Player` node and click the
    icon next to the lock:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加任何子节点之前，确保你不小心通过点击它们来移动或调整它们的大小。选择 `Player` 节点并点击旁边的锁图标：
- en: '![](img/00022.jpeg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00022.jpeg)'
- en: The tooltip will say Make sure the object's children are not selectable, as
    shown in the preceding screenshot.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 工具提示将显示确保对象的孩子不可选择，如前面的截图所示。
- en: It's a good idea to always do this when creating a new scene. If a body's collision
    shape or sprite becomes offset or scaled, it can cause unexpected errors and be
    difficult to fix. With this option, the node and all of its children will always
    move together.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建新场景时始终这样做是个好主意。如果一个身体的碰撞形状或精灵偏移或缩放，可能会导致意外的错误并且难以修复。使用此选项，节点及其所有子节点将始终一起移动。
- en: Sprite animation
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 精灵动画
- en: 'With `Area2D`, you can detect when other objects overlap or run into the player,
    but `Area2D` doesn''t have an appearance on its own, so click on the `Player`
    node and add an `AnimatedSprite` node as a child. The `AnimatedSprite` will handle
    the appearance and animations for your player. Note that there is a warning symbol
    next to the node. An `AnimatedSprite` requires a `SpriteFrames` resource, which
    contains the animation(s) it can display. To create one, find the Frame*s* property
    in the Inspector and click <null> | New SpriteFrames:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '使用 `Area2D`，你可以检测其他对象何时与玩家重叠或碰撞，但 `Area2D` 本身没有外观，因此点击 `Player` 节点并添加一个作为子节点的
    `AnimatedSprite` 节点。`AnimatedSprite` 将处理玩家的外观和动画。注意，节点旁边有一个警告符号。`AnimatedSprite`
    需要一个 `SpriteFrames` 资源，其中包含它可以显示的动画。要创建一个，在检查器中找到 Frame*s* 属性并点击 <null> | 新建 SpriteFrames:'
- en: '![](img/00023.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00023.jpeg)'
- en: 'Next, in the same location, click <SpriteFrames> to open the SpriteFrames panel:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在相同的位置，点击 <SpriteFrames> 打开 SpriteFrames 面板：
- en: '![](img/00024.gif)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00024.gif)'
- en: On the left is a list of animations. Click the default one and rename it to
    `run`. Then, click the **Add** button and create a second animation named `idle`
    and a third named `hurt`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧是一个动画列表。点击默认的动画并将其重命名为 `run`。然后，点击 **添加** 按钮创建第二个名为 `idle` 的动画和第三个名为 `hurt`
    的动画。
- en: 'In the FileSystem dock on the left, find the `run`, `idle`, and `hurt` player
    images and drag them into the corresponding animations:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧的文件系统工具栏中，找到 `run`、`idle` 和 `hurt` 玩家图像并将它们拖入相应的动画中：
- en: '![](img/00025.jpeg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00025.jpeg)'
- en: 'Each animation has a default speed setting of 5 frames per second. This is
    a little too slow, so click on each of the animations and set the Speed (FPS)
    setting to 8\. In the Inspector, check On next to the Playing property and choose
    an Animation to see the animations in action:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 每个动画都有一个默认的每秒 5 帧的速度设置。这有点慢，所以点击每个动画并将速度（FPS）设置更改为 8。在检查器中，勾选Playing 属性旁边的复选框并选择一个动画来查看动画效果：
- en: '![](img/00026.jpeg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
- en: Later, you'll write code to select between these animations, depending on what
    the player is doing. But first, you need to finish setting up the player's nodes.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Collision shape
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using `Area2D`, or one of the other collision objects in Godot, it needs
    to have a shape defined, or it can't detect collisions. A collision shape defines
    the region that the object occupies and is used to detect overlaps and/or collisions.
    Shapes are defined by `Shape2D`, and include rectangles, circles, polygons, and
    other types of shapes.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: For convenience, when you need to add a shape to an area or physics body, you
    can add a `CollisionShape2D` as a child. You then select the type of shape you
    want and you can edit its size in the editor.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `CollisionShape2D` as a child of `Player` (make sure you don''t add it
    as a child of the `AnimatedSprite`). This will allow you to determine the player''s
    *hitbox*, or the bounds of its collision area. In the Inspector, next to Shape,
    click <null> and choose New RectangleShape2D. Adjust the shape''s size to cover
    the sprite:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00027.jpeg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
- en: Be careful not to scale the shape's outline! Only use the size handles (red)
    to adjust the shape! Collisions will not work properly with a scaled collision
    shape.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that the collision shape is not centered on the sprite.
    That is because the sprites themselves are not centered vertically. We can fix
    this by adding a small offset to the `AnimatedSprite`. Click on the node and look
    for the Offset property in the Inspector. Set it to `(0, -5)`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'When you''re finished, your `Player` scene should look like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00028.jpeg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
- en: Scripting the Player
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, you''re ready to add a script. Scripts allow you to add additional functionality
    that isn''t provided by the built-in nodes. Click the `Player` node and click
    the **Add Script** button:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00029.jpeg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
- en: 'In the Script Settings window, you can leave the default settings as they are.
    If you''ve remembered to save the scene (see the preceding screenshot), the script
    will automatically be named to match the scene''s name. Click Create and you''ll
    be taken to the script window. Your script will contain some default comments
    and hints. You can remove the comments (lines starting with `#`). Refer to the
    following code snippet:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The first line of every script will describe what type of node it is attached
    to. Next, you''ll define your class variables:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Using the `export` keyword on the `speed` variable allows you to set its value
    in the Inspector, as well as letting the Inspector know what type of data the
    variable should contain. This can be very handy for values that you want to be
    able to adjust, just like you adjust a node''s built-in properties. Click on the **`Player`**
    node and set the Speed property to 350, as shown in the following screenshot:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00030.jpeg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
- en: '`velocity` will contain the character''s current movement speed and direction,
    and `screensize` will be used to set the limits of the player''s movement. Later,
    the game''s main scene will set this variable, but for now you will set it manually
    so you can test.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`velocity`将包含角色的当前移动速度和方向，而`screensize`将用于设置玩家的移动限制。稍后，游戏的主场景将设置此变量，但现在你将手动设置它以便测试。'
- en: Moving the Player
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动玩家
- en: 'Next, you''ll use the `_process()` function to define what the player will
    do. The `_process()` function is called on every frame, so you''ll use it to update
    elements of your game that you expect to be changing often. You need the player
    to do three things:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将使用`_process()`函数来定义玩家将做什么。`_process()`函数在每一帧都会被调用，所以你会用它来更新你预期经常更改的游戏元素。你需要玩家做三件事：
- en: Check for keyboard input
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查键盘输入
- en: Move in the given direction
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照给定的方向移动
- en: Play the appropriate animation
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放适当的动画
- en: First, you need to check the inputs. For this game, you have four directional
    inputs to check (the four arrow keys). Input actions are defined in the project
    settings under the Input Map tab. In this tab, you can define custom events and
    assign different keys, mouse actions, or other inputs to them. By default, Godot
    has events assigned to the keyboard arrows, so you can use them for this project.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要检查输入。对于这个游戏，你有四个方向输入需要检查（四个箭头键）。输入操作在项目设置下的输入映射标签中定义。在这个标签中，你可以定义自定义事件并将不同的键、鼠标操作或其他输入分配给它们。默认情况下，Godot已经将事件分配给了键盘箭头，所以你可以使用它们在这个项目中。
- en: You can detect whether an input is pressed using `Input.is_action_pressed()`,
    which returns `true` if the key is held down and `false` if it is not. Combining
    the states of all four buttons will give you the resultant direction of movement. For
    example, if you hold `right` and `down` at the same time, the resulting velocity
    vector will be `(1, 1)`. In this case, since we’re adding a horizontal and a vertical
    movement together, the player would move *faster* than if they just moved horizontally.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`Input.is_action_pressed()`检测是否按下了输入，如果按键被按下则返回`true`，如果没有则返回`false`。结合所有四个按钮的状态将给出运动的结果方向。例如，如果你同时按下`right`和`down`，则结果速度向量将是`(1,
    1)`。在这种情况下，因为我们正在将水平和垂直运动结合起来，所以玩家会比仅水平移动时移动得更快。
- en: 'You can prevent that by *normalizing* the velocity, which means setting its length
    to **1**, then multiplying it by the desired speed:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过*归一化*速度来防止这种情况，这意味着将其长度设置为**1**，然后乘以期望的速度：
- en: '[PRE2]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'By grouping all of this code together in a `get_input()` function, you make
    it easier to change things later. For example, you could decide to change to an
    analog joystick or other type of controller. Call this function from `_process()`
    and then change the player''s `position` by the resulting `velocity`. To prevent
    the player from leaving the screen, you can use the `clamp()` function to limit
    the position to a minimum and maximum value:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将所有这些代码组合在一个`get_input()`函数中，你可以使后续更改变得更加容易。例如，你可以决定改为使用模拟摇杆或其他类型的控制器。从`_process()`函数中调用此函数，然后通过结果`velocity`更改玩家的`position`。为了防止玩家离开屏幕，你可以使用`clamp()`函数将位置限制在最小和最大值之间：
- en: '[PRE3]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Click Play the Edited Scene (*F6*) and confirm that you can move the player
    around the screen in all directions.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“播放编辑的场景”（*F6*）并确认你可以按所有方向移动玩家。
- en: About delta
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于delta
- en: The `_process()` function includes a parameter called `delta` that is then multiplied
    by the velocity. What is `delta`?
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`_process()`函数包含一个名为`delta`的参数，然后将其乘以速度。`delta`是什么？'
- en: The game engine attempts to run at a consistent 60 frames per second. However,
    this can change due to computer slowdowns, either in Godot or from the computer
    itself. If the frame rate is not consistent, then it will affect the movement
    of your game objects. For example, consider an object set to move `10` pixels
    every frame. If everything is running smoothly, this will translate to moving
    `600` pixels in one second. However, if some of those frames take longer, then
    there may only have been 50 frames in that second, so the object only moved `500`
    pixels.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏引擎试图以每秒60帧的速率一致运行。然而，这可能会因为Godot或计算机本身的减速而改变。如果帧率不一致，那么它将影响你的游戏对象的移动。例如，考虑一个设置为每帧移动`10`像素的对象。如果一切运行顺利，这将转化为在一秒内移动`600`像素。然而，如果其中一些帧耗时更长，那么那一秒可能只有50帧，所以对象只移动了`500`像素。
- en: Godot, like most game engines and frameworks, solves this by passing you `delta`,
    which is the elapsed time since the previous frame. Most of the time, this will
    be around `0.016` s (or around 16 milliseconds). If you then take your desired
    speed (`600` px/s) and multiply by delta, you will get a movement of exactly `10`.
    If, however, the `delta` increased to `0.3`, then the object will be moved `18`
    pixels. Overall, the movement speed remains consistent and independent of the
    frame rate.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Godot，就像大多数游戏引擎和框架一样，通过传递给你 `delta` 来解决这个问题，这是自上一帧以来经过的时间。大多数情况下，这将是大约 `0.016`
    秒（或大约 16 毫秒）。如果你然后将你的期望速度（`600` px/s）乘以 delta，你将得到精确的 `10` 像素移动。然而，如果 `delta`
    增加到 `0.3`，则对象将被移动 `18` 像素。总的来说，移动速度保持一致，且与帧率无关。
- en: As a side benefit, you can express your movement in units of px/s rather than
    px/frame, which is easier to visualize.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一项额外的好处，你可以用 px/s 而不是 px/frame 的单位来表示你的移动，这更容易可视化。
- en: Choosing animations
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择动画
- en: 'Now that the player can move, you need to change which animation the `AnimatedSprite`
    is playing based on whether it is moving or standing still. The art for the `run`
    animation faces to the right, which means it should be flipped horizontally (using
    the Flip H property) for movement to the left. Add this to the end of your `_process()`
    function:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在玩家可以移动了，你需要根据玩家是移动还是静止来更改 `AnimatedSprite` 播放的动画。`run` 动画的美术面向右侧，这意味着它应该使用翻转水平属性（使用
    `Flip H` 属性）来翻转，以便向左移动。将以下内容添加到你的 `_process()` 函数末尾：
- en: '[PRE4]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Note that this code takes a little shortcut. `flip_h` is a Boolean property,
    which means it can be `true` or `false`. A Boolean value is also the result of
    a comparison like `<`. Because of this, we can set the property equal to the result
    of the comparison. This one line is equivalent to writing it out like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这段代码采取了一些捷径。`flip_h` 是一个布尔属性，这意味着它可以设置为 `true` 或 `false`。布尔值也是比较操作（如 `<`）的结果。正因为如此，我们可以将属性设置为比较操作的结果。这一行代码等同于以下这样写：
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Play the scene again and check that the animations are correct in each case.
    Make sure Playing is set to On in the `AnimatedSprite` so that the animations
    will play.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 再次播放场景并检查每种情况下动画是否正确。确保在 `AnimatedSprite` 中将 `Playing` 设置为 On，以便动画可以播放。
- en: Starting and Ending the Player's Movement
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始和结束玩家的移动
- en: 'When the game starts, the main scene will need to inform the player that the
    game has begun. Add the `start()` function as follows, which the main scene will
    use to set the player''s starting animation and position:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当游戏开始时，主场景需要通知玩家游戏已经开始。添加以下 `start()` 函数，主场景将使用它来设置玩家的起始动画和位置：
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `die()` function will be called when the player hits an obstacle or runs
    out of time:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家撞击障碍物或用完时间时，将调用 `die()` 函数：
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Setting `set_process(false)` causes the `_process()` function to no longer be
    called for this node. That way, when the player has died, they can't still be
    moved by key input.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 `set_process(false)` 将导致 `_process()` 函数不再为该节点调用。这样，当玩家死亡时，他们就不能通过按键输入移动了。
- en: Preparing for collisions
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备碰撞
- en: The player should detect when it hits a coin or an obstacle, but you haven't
    made them do so yet. That's OK, because you can use Godot's *signal* functionality
    to make it work. Signals are a way for nodes to send out messages that other nodes
    can detect and react to. Many nodes have built-in signals to alert you when a
    body collides, for example, or when a button is pressed. You can also define custom
    signals for your own purposes.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家应该检测到它撞击硬币或障碍物时，但你还没有让他们这样做。没关系，因为你可以使用 Godot 的 *信号* 功能来实现这一点。信号是节点发送消息的方式，其他节点可以检测并响应这些消息。许多节点都有内置的信号，例如在身体碰撞时或按钮被按下时发出警报。你还可以定义自定义信号以供自己的用途。
- en: Signals are used by *connecting* them to the node(s) that you want to listen
    and respond to. This connection can be made in the Inspector or in the code. Later
    in the project, you'll learn how to connect signals in both ways.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 *连接* 信号到你想监听和响应的节点，使用信号。这种连接可以在检查器或代码中完成。在项目后期，你将学习如何以这两种方式连接信号。
- en: 'Add the following to the top of the script (after `extends Area2D`):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容添加到脚本顶部（在 `extends Area2D` 之后）：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'These define custom signals that your player will *emit* (send out) when they
    touch a coin or an obstacle. The touches will be detected by the `Area2D` itself.
    Select the `Player` node and click the Node tab next to the Inspector to see the
    list of signals the player can emit:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这些定义了玩家在触摸硬币或障碍物时将*发出*（发送）的自定义信号。触摸将由`Area2D`本身检测。选择`Player`节点并点击检查器旁边的节点标签页，以查看玩家可以发出的信号列表：
- en: '![](img/00031.jpeg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00031.jpeg)'
- en: Note your custom signals are there as well. Since the other objects will also
    be `Area2D` nodes, you want the `area_entered()` signal. Select it and click Connect.
    Click Connect on the Connecting Signal window—you don't need to change any of
    those settings. Godot will automatically create a new function called `_on_Player_area_entered()`
    in your script.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意你的自定义信号也在那里。由于其他对象也将是`Area2D`节点，你想要`area_entered()`信号。选择它并点击连接。在连接信号窗口中点击连接
    – 你不需要更改任何设置。Godot 将自动在你的脚本中创建一个名为`_on_Player_area_entered()`的新函数。
- en: When connecting a signal, instead of having Godot create a function for you,
    you can also give the name of an existing function that you want to link the signal
    to. Toggle the Make Function switch to Off if you don't want Godot to create the
    function for you.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当连接一个信号时，你不仅可以让 Godot 为你创建一个函数，还可以指定一个现有函数的名称，将其与信号链接。如果你不希望 Godot 为你创建函数，请将“创建函数”开关切换到关闭状态。
- en: 'Add the following code to this new function:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到这个新函数中：
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When another `Area2D` is detected, it will be passed in to the function (using
    the `area` variable). The coin object will have a `pickup()` function that defines
    the coin's behavior when picked up (playing an animation or sound, for example).
    When you create the coins and obstacles, you'll assign them to the appropriate *group*
    so they can be detected.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当检测到另一个`Area2D`时，它将被传递到函数中（使用`area`变量）。硬币对象将有一个`pickup()`函数，该函数定义了捡起硬币时的行为（例如播放动画或声音）。当你创建硬币和障碍物时，你需要将它们分配到适当的*组*，以便可以检测到。
- en: 'To summarize, here is the complete player script so far:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，以下是到目前为止完整的玩家脚本：
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Part 2 – Coin scene
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分 – 硬币场景
- en: In this part, you'll make the coins for the player to collect. This will be
    a separate scene describing all of the properties and behavior of a single coin.
    Once saved, the main scene will load the coin scene and create multiple *instances*
    (that is, copies) of it.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，你将为玩家创建可以收集的硬币。这将是一个独立的场景，描述单个硬币的所有属性和行为。一旦保存，主场景将加载硬币场景并创建多个*实例*（即副本）。
- en: Node setup
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 节点设置
- en: 'Click Scene | New Scene and add the following nodes. Don''t forget to set the
    children to not be selected, like you did with the `Player` scene:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“场景”|“新建场景”并添加以下节点。别忘了像处理“玩家”场景那样设置子节点不被选中：
- en: '`Area2D` (named `Coin`)'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Area2D`（命名为`Coin`）'
- en: '`AnimatedSprite`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AnimatedSprite`'
- en: '`CollisionShape2D`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CollisionShape2D`'
- en: Make sure to save the scene once you've added the nodes.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加节点后，请确保保存场景。
- en: 'Set up the `AnimatedSprite` like you did in the Player scene. This time, you
    only have one animation: a shine/sparkle effect that makes the coin look less
    flat and boring. Add all the frames and set the Speed (FPS) to `12`. The images
    are a little too large, so set the Scale of `AnimatedSprite` to (`0.5`, `0.5`). In
    the `CollisionShape2D`, use a `CircleShape2D` and size it to cover the coin image.
    Don''t forget: never use the scale handles when sizing a collision shape. The
    circle shape has a single handle that adjusts the circle''s radius.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 按照你在玩家场景中设置的方式设置`AnimatedSprite`。这次，你只有一个动画：一个使硬币看起来不那么扁平和无趣的闪光/闪耀效果。添加所有帧并将速度（FPS）设置为`12`。图像有点太大，所以将`AnimatedSprite`的`Scale`设置为（`0.5`，`0.5`）。在`CollisionShape2D`中使用`CircleShape2D`并调整其大小以覆盖硬币图像。别忘了：在调整碰撞形状大小时，永远不要使用缩放手柄。圆形形状有一个单独的手柄，用于调整圆的半径。
- en: Using groups
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用组
- en: 'Groups provide a tagging system for nodes, allowing you to identify similar
    nodes. A node can belong to any number of groups. You need to ensure that all
    coins will be in a group called `coins` for the player script to react correctly
    to touching the coin. Select the `Coin` node and click the Node tab (the same
    tab where you found the signals) and choose Groups. Type `coins` in the box and
    click Add, as shown in the following screenshot:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 组为节点提供了一个标签系统，允许你识别相似的节点。一个节点可以属于任意数量的组。你需要确保所有硬币都将位于一个名为“coins”的组中，以便玩家脚本能够正确响应触摸硬币。选择“Coin”节点，点击节点标签页（与找到信号相同的标签页）并选择组。在框中输入“coins”，然后点击添加，如图所示：
- en: '![](img/00032.jpeg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00032.jpeg)'
- en: Script
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本
- en: 'Next, add a script to the `Coin` node. If you choose Empty in the Template
    setting, Godot will create an empty script without any comments or suggestions.
    The code for the coin''s script is much shorter than the code for the player''s:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，向`Coin`节点添加一个脚本。如果你在模板设置中选择空，Godot将创建一个没有注释或建议的空脚本。硬币脚本的代码比玩家脚本的代码要短得多：
- en: '[PRE11]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `pickup()` function is called by the player script and tells the coin what
    to do when it's been collected. `queue_free()` is Godot's node removal method.
    It safely removes the node from the tree and deletes it from memory along with
    all of its children. Later, you'll add a visual effect here, but for now the coin
    disappearing is good enough.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`pickup()`函数由玩家脚本调用，告诉硬币在被收集时要做什么。`queue_free()`是Godot的节点移除方法。它安全地从树中移除节点，并从内存中删除它及其所有子节点。稍后，你将在这里添加一个视觉效果，但现在硬币消失的效果就足够了。'
- en: '`queue_free()` doesn''t delete the object immediately, but rather adds it to
    a queue to be deleted at the end of the current frame. This is safer than immediately
    deleting the node, because other code running in the game may still need the node
    to exist. By waiting until the end of the frame, Godot can be sure that all code
    that may access the node has completed and the node can be removed safely.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`queue_free()`不会立即删除对象，而是将其添加到队列中，在当前帧结束时删除。这比立即删除节点更安全，因为游戏中运行的其它代码可能仍然需要该节点存在。通过等待直到帧的结束，Godot可以确保所有可能访问该节点的代码都已完成，节点可以安全地被移除。'
- en: Part 3 – Main scene
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分 - 主场景
- en: The `Main` scene is what ties all the pieces of the game together. It will manage
    the player, the coins, the timer, and the other pieces of the game.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`主`场景是连接游戏所有部件的关键。它将管理玩家、硬币、计时器以及游戏的其它部件。'
- en: Node setup
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 节点设置
- en: 'Create a new scene and add a node named `Main`. To add the player to the scene,
    click the Instance button and select your saved `Player.tscn`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的场景并添加一个名为`Main`的节点。要将玩家添加到场景中，点击实例按钮并选择你保存的`Player.tscn`：
- en: '![](img/00033.gif)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![动画](img/00033.gif)'
- en: 'Now, add the following nodes as children of **`Main`**, naming them as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将以下节点作为`Main`的子节点添加，并按以下命名：
- en: '`TextureRect` (named `Background`)—for the background image'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`纹理矩形`（命名为`Background`）——用于背景图像'
- en: '`Node` (named `CoinContainer`)—to hold all the coins'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`节点`（命名为`CoinContainer`）——用于存放所有硬币'
- en: '`Position2D` (named `PlayerStart`)—to mark the starting position of the `Player`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`二维位置`（命名为`PlayerStart`）——用于标记`玩家`的起始位置'
- en: '`Timer` (named `GameTimer`)—to track the time limit'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`计时器`（命名为`GameTimer`）——用于跟踪时间限制'
- en: 'Make sure `Background` is the first child node. Nodes are drawn in the order
    shown, so the background will be *behind* the player in this case. Add an image
    to the `Background` node by dragging the `grass.png` image from the `assets` folder
    into the Texture property. Change the Stretch Mode to Tile and then click Layout |
    Full Rect to size the frame to the size of the screen, as shown in the following
    screenshot:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将`Background`作为第一个子节点。节点将按照显示的顺序绘制，所以在这种情况下背景将在玩家后面。通过将`assets`文件夹中的`grass.png`图像拖动到`Background`节点的纹理属性中，向`Background`节点添加一个图像。然后将拉伸模式更改为平铺，然后点击布局|全矩形以将框架大小调整为屏幕大小，如下面的截图所示：
- en: '![](img/00034.jpeg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00034.jpeg)'
- en: Set the Position of the `PlayerStart` node to (`240`, `350`).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 将`PlayerStart`节点的位置设置为（`240`，`350`）。
- en: 'Your scene layout should look like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你的场景布局应该看起来像这样：
- en: '![](img/00035.jpeg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00035.jpeg)'
- en: Main script
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主脚本
- en: 'Add a script to the `Main` node (use the Empty template) and add the following
    variables:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 向`Main`节点（使用空模板）添加一个脚本，并添加以下变量：
- en: '[PRE12]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `Coin` and `Playtime` properties will now appear in the Inspector when you
    click on `Main`. Drag `Coin.tscn` from the FileSystem panel and drop it in the
    `Coin` property. Set `Playtime` to `30` (this is the amount of time the game will
    last). The remaining variables will be used later in the code.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击`主`时，`Coin`和`Playtime`属性将现在出现在检查器中。从文件系统面板中拖动`Coin.tscn`到`Coin`属性，并将其放置在`Coin`属性中。将`Playtime`设置为`30`（这是游戏将持续的时间）。剩余的变量将在代码的后续部分使用。
- en: Initializing
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化
- en: 'Next, add the `_ready()` function:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加`_ready()`函数：
- en: '[PRE13]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In GDScript, you can use `$` to refer to a particular node by name. This allows
    you to find the size of the screen and assign it to the player's `screensize`
    variable. `hide()` makes the player start out invisible (you'll make them appear
    when the game actually starts).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在GDScript中，你可以使用`$`通过名称引用特定的节点。这允许你找到屏幕的大小并将其分配给玩家的`screensize`变量。`hide()`使玩家一开始不可见（你将在游戏真正开始时让它们出现）。
- en: In the `$` notation, the node name is relative to the node running the script.
    For example, `$Node1/Node2` would refer to a node (`Node2`) that is the child
    of `Node1`, which itself is a child of the currently running script. Godot's autocomplete
    will suggest node names from the tree as you type. Note that if the node's name
    contains spaces, you must put quote marks around it, for example, `$"My Node"`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在`$`符号表示法中，节点名称相对于运行脚本的节点。例如，`$Node1/Node2`将指代一个节点（`Node2`），它是`Node1`的子节点，而`Node1`本身又是当前运行脚本的子节点。Godot的自动完成功能将在你输入时建议树中的节点名称。请注意，如果节点的名称包含空格，你必须将其放在引号内，例如，`$"My
    Node"`。
- en: You must use `randomize()` if you want your sequence of "random" numbers to
    be different every time you run the scene. Technically speaking, this selects
    a random *seed* for the random number generator.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要每次运行场景时“随机”数字序列都不同，你必须使用`randomize()`。从技术上讲，这为随机数生成器选择了一个随机的**种子**。
- en: Starting a new game
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始新游戏
- en: 'Next, the `new_game()` function will initialize everything for a new game:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`new_game()`函数将为新游戏初始化一切：
- en: '[PRE14]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In addition to setting the variables to their starting values, this function
    calls the Player's `start()` function to ensure it moves to the proper starting
    location. The game timer is started, which will count down the remaining time
    in the game.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将变量设置为起始值外，此函数还调用玩家的`start()`函数以确保它移动到正确的起始位置。游戏计时器开始，这将倒计时剩余的游戏时间。
- en: 'You also need a function that will create a number of coins based on the current
    level:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要一个函数，该函数将根据当前级别创建一定数量的硬币：
- en: '[PRE15]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this function, you create a number of *instances* of the `Coin` object (in
    code this time, rather than by clicking the Instance a Scene button), and add
    it as a child of the `CoinContainer`. Whenever you instance a new node, it must
    be added to the tree using `add_child()`. Finally, you pick a random location
    for the coin to appear in. You'll call this function at the start of every level,
    generating more coins each time.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，你创建`Coin`对象（这次是通过代码，而不是点击实例化场景按钮）的多个实例，并将其添加为`CoinContainer`的子节点。每次实例化一个新的节点时，都必须使用`add_child()`将其添加到树中。最后，你为硬币随机选择一个出现的位置。你将在每个级别的开始时调用这个函数，每次生成更多的硬币。
- en: Eventually, you'll want `new_game()` to be called when the player clicks the
    start button. For now, to test if everything is working, add `new_game()` to the
    end of your `_ready()` function and click Play the Project (*F5*). When you are
    prompted to choose a main scene, choose `Main.tscn`. Now, whenever you play the
    project, the `Main` scene will be started.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，你希望当玩家点击开始按钮时调用`new_game()`。现在，为了测试一切是否正常工作，将`new_game()`添加到你的`_ready()`函数的末尾，并点击**播放项目**（*F5*）。当你被提示选择主场景时，选择`Main.tscn`。现在，每次你播放项目时，`Main`场景将被启动。
- en: At this point, you should see your player and five coins appear on the screen.
    When the player touches a coin, it disappears.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该在屏幕上看到你的玩家和五个硬币。当玩家触摸一个硬币时，它就会消失。
- en: Checking for remaining coins
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查剩余的硬币
- en: 'The main script needs to detect whether the player has picked up all of the
    coins. Since the coins are all children of `CoinCointainer`, you can use `get_child_count()` on
    this node to find out how many coins remain. Put this in the `_process()` function
    so that it will be checked every frame:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 主脚本需要检测玩家是否已经捡起所有硬币。由于硬币都是`CoinContainer`的子节点，你可以使用此节点的`get_child_count()`来找出剩余多少个硬币。将此放入`_process()`函数中，以便每帧都会进行检查：
- en: '[PRE16]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If no more coins remain, then the player advances to the next level.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有更多的硬币剩余，那么玩家将进入下一级。
- en: Part 4 – User Interface
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4部分 – 用户界面
- en: The final piece your game needs is a **user interface** (**UI**). This is an
    interface to display information that the player needs to see during gameplay.
    In games, this is also referred to as a **Heads-Up Display** (**HUD**), because
    the information appears as an overlay on top of the game view. You'll also use
    this scene to display a start button.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你的游戏需要的最后一部分是一个**用户界面**（**UI**）。这是一个用于在游戏过程中显示玩家需要看到的信息的界面。在游戏中，这也被称为**抬头显示**（**HUD**），因为信息以叠加的形式显示在游戏视图之上。你还会使用这个场景来显示一个开始按钮。
- en: 'The HUD will display the following information:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: HUD将显示以下信息：
- en: Score
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分数
- en: Time remaining
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 剩余时间
- en: A message, such as Game Over
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一条消息，例如游戏结束
- en: A start button
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个开始按钮
- en: Node setup
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 节点设置
- en: Create a new scene and add a `CanvasLayer` node named `HUD`. A `CanvasLayer`
    node allows you to draw your UI elements on a layer above the rest of the game,
    so that the information it displays doesn't get covered up by any game elements
    like the player or the coins.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的场景并添加一个名为`HUD`的`CanvasLayer`节点。`CanvasLayer`节点允许你在游戏其他元素之上绘制UI元素，这样显示的信息不会被玩家或金币等游戏元素覆盖。
- en: 'Godot provides a wide variety of UI elements that may be used to create anything
    from indicators such as health bars to complex interfaces such as inventories.
    In fact, the Godot editor that you are using to make this game is built in Godot
    using these elements. The basic nodes for UI elements are extended from `Control`,
    and appear with green icons in the node list. To create your UI, you''ll use various `Control` nodes
    to position, format, and display information. Here is what the `HUD` will look
    like when complete:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Godot提供了各种UI元素，可用于创建从健康条等指示器到复杂界面如存货界面等任何内容。实际上，你用来制作这个游戏的Godot编辑器就是使用这些元素在Godot中构建的。UI元素的基本节点是从`Control`扩展的，在节点列表中以绿色图标显示。要创建你的UI，你将使用各种`Control`节点来定位、格式化和显示信息。以下是完成后的`HUD`的外观：
- en: '![](img/00036.jpeg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00036.jpeg)'
- en: Anchors and margins
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 锚点和边距
- en: Control nodes have a position and size, but they also have properties called
    **anchors** and **margins**. Anchors define the origin, or the reference point,
    for the edges of the node, relative to the parent container. Margins represent
    the distance from the control node's edge to its corresponding anchor. Margins
    update automatically when you move or resize a control node.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 控制节点具有位置和大小，但它们还具有称为**锚点**和**边距**的属性。锚点定义了节点边缘相对于父容器的起点或参考点。边距表示控制节点边缘与其对应锚点之间的距离。当你移动或调整控制节点的大小时，边距会自动更新。
- en: Message label
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息标签
- en: Add a `Label` node to the scene and change its name to `MessageLabel`**.** This
    label will display the game's title, as well as Game Over when the game ends.
    This label should be centered on the game screen. You could drag it with the mouse,
    but to place UI elements precisely, you should use the Anchor properties.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在场景中添加一个`Label`节点并将其名称更改为`MessageLabel`**。** 这个标签将显示游戏标题，以及游戏结束时显示的Game Over。这个标签应该在游戏屏幕上居中。你可以用鼠标拖动它，但为了精确放置UI元素，你应该使用锚点属性。
- en: 'Select View | Show Helpers to display pins that will help you see the anchor
    positions, then click on the Layout menu and select HCenter Wide:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 选择视图 | 显示辅助工具以显示帮助您看到锚点位置的标记，然后点击布局菜单并选择水平居中宽：
- en: '![](img/00037.jpeg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00037.jpeg)'
- en: The `MessageLabel` now spans the width of the screen and is centered vertically.
    The Text property in the Inspector sets what text the label displays. Set it to
    Coin Dash! and set Align and Valign to Center.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageLabel`现在横跨屏幕宽度并垂直居中。检查器中的文本属性设置标签显示的文本。将其设置为Coin Dash!并将对齐和垂直对齐设置为居中。'
- en: 'The default font for `Label` nodes is very small, so the next step is to assign
    a custom font. Scroll down to the Custom Fonts section in the Inspector and select New
    DynamicFont, as shown in the following screenshot:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`Label`节点的默认字体非常小，所以下一步是为其分配一个自定义字体。在检查器中向下滚动到自定义字体部分，并选择新建动态字体，如图下所示：'
- en: '![](img/00038.jpeg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00038.jpeg)'
- en: 'Now, click on DynamicFont and you can adjust the font settings. From the FileSystem
    dock, drag the `Kenney Bold.ttf` font and drop it in the Font Dataproperty. Set Sizeto **`48`**,
    as shown in the following screenshot:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，点击动态字体，你可以调整字体设置。从文件系统坞中，拖动`Kenney Bold.ttf`字体并将其放入字体数据属性中。将大小设置为**`48`**，如图下所示：
- en: '![](img/00039.jpeg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00039.jpeg)'
- en: Score and time display
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 得分和时间显示
- en: The top of the `HUD` will display the player's score and the time remaining
    on the clock. Both of these will be `Label` nodes, arranged at opposite sides
    of the game screen. Rather than position them separately, you'll use a `Container`
    node to manage their positions.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`HUD`的顶部将显示玩家的得分和时钟剩余时间。这两个都将使用`Label`节点，分别位于游戏屏幕的两侧。而不是单独定位它们，你将使用`Container`节点来管理它们的位置。'
- en: Containers
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器
- en: UI containers automatically arrange the positions of their child `Control` nodes
    (including other `Containers`). You can use them to add padding around elements,
    center them, or arrange elements in rows or columns. Each type of `Container`
    has special properties that control how they arrange their children. You can see
    these properties in the Custom Constants section of the Inspector.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: UI容器自动排列其子`Control`节点（包括其他`Containers`）的位置。您可以使用它们在元素周围添加填充、居中元素或按行或列排列元素。每种类型的`Container`都有特殊的属性来控制它们如何排列子元素。您可以在检查器的“自定义常量”部分中查看这些属性。
- en: Remember that containers *automatically* arrange their children. If you move
    or resize a Control that's inside a `Container` node, you'll find it snaps back
    to its original position. You can manually arrange controls *or* arrange them
    with a container, but not both.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，容器**自动**排列其子元素。如果您移动或调整容器节点内的控件的大小，会发现它自动回到原始位置。您可以手动排列控件**或**使用容器排列控件，但不能同时进行。
- en: To manage the score and time labels, add a **`MarginContainer`** node to the **`HUD`.**
    Use the Layout menu to set the anchors to Top Wide. In the Custom Constants section,
    set Margin Right, Margin Top, and Margin Left to `10`. This will add some padding
    so that the text isn't against the edge of the screen.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要管理分数和时间标签，向`HUD`的**`MarginContainer`**节点添加一个**`MarginContainer`**节点。使用布局菜单设置锚点为顶部宽。在“自定义常量”部分中，将边距右、边距顶和边距左设置为`10`。这将添加一些填充，以便文本不会紧贴屏幕边缘。
- en: Since the score and time labels will use the same font settings as the `MessageLabel`,
    it will save time if you duplicate it. Click on `MessageLabel` and press *Ctrl*
    + *D* (*Cmd* + *D* on macOS) twice to create two duplicate labels. Drag them both
    and drop them on the `MarginContainer` to make them its children. Name one `ScoreLabel`
    and the other `TimeLabel` and set the Text property to `0` for both. Set Align
    to Left for `ScoreLabel` and Right for **`TimeLabel`.**
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 由于分数和时间标签将使用与`MessageLabel`相同的字体设置，因此如果您复制它将节省时间。单击`MessageLabel`并按*Ctrl* +
    *D* (*Cmd* + *D* 在macOS上)两次以创建两个副本标签。将它们都拖动并放在`MarginContainer`上，使它们成为其子元素。将一个命名为`ScoreLabel`，另一个命名为`TimeLabel`，并将两者的文本属性都设置为`0`。将`ScoreLabel`的对齐方式设置为左对齐，将**`TimeLabel`**的对齐方式设置为右对齐。
- en: Updating UI via GDScript
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过GDScript更新UI
- en: 'Add a script to the `HUD` node. This script will update the UI elements when
    their properties need to change, updating the score text whenever a coin is collected,
    for example. Refer to the following code:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 将脚本添加到`HUD`节点。此脚本将在需要更改属性时更新UI元素，例如，每当收集到金币时更新分数文本。参考以下代码：
- en: '[PRE17]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `Main` scene''s script will call these functions to update the display
    whenever there is a change in value. For the `MessageLabel`, you also need a timer
    to make it disappear after a brief period. Add a `Timer` node and change its name
    to `MessageTimer`**. **In the Inspector, set its Wait Time to `2` seconds and
    check the box to set One Shot to On. This ensures that, when started, the timer
    will only run once, rather than repeating. Add the following code:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main`场景的脚本将调用这些函数来更新显示，每当值发生变化时。对于`MessageLabel`，您还需要一个计时器，以便在短时间内消失。添加一个`Timer`节点，并将其名称更改为`MessageTimer`**。**在检查器中，将等待时间设置为`2`秒，并勾选复选框以设置单次触发为开启。这确保了当启动时，计时器只会运行一次，而不是重复。添加以下代码：'
- en: '[PRE18]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In this function, you display the message and start the timer. To hide the
    message, connect the `timeout()` signal of `MessageTimer` and add this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在此函数中，您显示消息并启动计时器。要隐藏消息，连接`MessageTimer`的`timeout()`信号并添加以下代码：
- en: '[PRE19]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Using buttons
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用按钮
- en: Add a `Button` node and change its name to `StartButton`**. **This button will
    be displayed before the game starts, and when clicked, it will hide itself and
    send a signal to the `Main` scene to start the game. Set the Text property to
    Start and change the custom font like you did with the **`MessageLabel`.** In
    the Layout menu, choose Center Bottom. This will put the button at the very bottom
    of the screen, so move it up a little bit either by pressing the *Up* arrow key
    or by editing the margins and setting Top to `-150` and Bottom to `-50`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个`Button`节点，并将其名称更改为`StartButton`**。**此按钮将在游戏开始前显示，点击后将隐藏自身并向`Main`场景发送信号以开始游戏。将文本属性设置为“开始”，并更改自定义字体，就像您对**`MessageLabel`**所做的那样。在布局菜单中，选择“居中底部”。这将使按钮位于屏幕底部，因此可以通过按*上*箭头键或通过编辑边距并将顶部设置为`-150`、底部设置为`-50`来稍微向上移动它。
- en: 'When a button is clicked, a signal is sent out. In the Node tab for the `StartButton`,
    connect the `pressed()` signal:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当按钮被点击时，会发出一个信号。在`StartButton`的节点标签页中，连接`pressed()`信号：
- en: '[PRE20]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `HUD` emits the `start_game` signal to notify `Main` that it's time to start
    a new game.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`HUD`发出`start_game`信号，通知`Main`是时候开始新游戏了。'
- en: Game over
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏结束
- en: 'The final task for your UI is to react to the game ending:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你UI的最终任务是响应游戏结束：
- en: '[PRE21]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this function, you need the Game Over message to be displayed for two seconds
    and then disappear, which is what `show_message()` does. However, you also want
    to show the start button once the message has disappeared. The `yield()` function
    pauses execution of the function until the given node (`MessageTimer`) emits a
    given signal (`timeout`). Once the signal is received, the function continues,
    returning you to the initial state so that you can play again.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个功能中，你需要游戏结束信息显示两秒钟后消失，这正是`show_message()`所做到的。然而，你希望在信息消失后显示开始按钮。`yield()`函数暂停函数的执行，直到给定的节点（`MessageTimer`）发出给定的信号（`timeout`）。一旦接收到信号，函数继续执行，返回到初始状态，这样你就可以再次玩游戏。
- en: Adding the HUD to Main
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将HUD添加到Main
- en: 'Now, you need to set up the communication between the `Main` scene and the
    `HUD`. Add an instance of the `HUD` scene to the `Main` scene. In the `Main` scene,
    connect the `timeout()` signal of `GameTimer` and add the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你需要设置`Main`场景和`HUD`之间的通信。将`HUD`场景的实例添加到`Main`场景中。在`Main`场景中，连接`GameTimer`的`timeout()`信号，并添加以下内容：
- en: '[PRE22]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Every time the `GameTimer` times out (every second), the remaining time is reduced.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 每当`GameTimer`超时（每秒一次），剩余时间会减少。
- en: 'Next, connect the `pickup()` and `hurt()` signals of the `Player`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，连接`Player`的`pickup()`和`hurt()`信号：
- en: '[PRE23]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Several things need to happen when the game ends, so add the following function:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏结束时需要发生几件事情，所以添加以下函数：
- en: '[PRE24]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This function halts the game, and also loops through the coins and removes any
    that are remaining, as well as calling the HUD's `show_game_over()` function.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数使游戏暂停，并遍历硬币，移除任何剩余的硬币，同时调用HUD的`show_game_over()`函数。
- en: 'Finally, the `StartButton` needs to activate the `new_game()` function. Click
    on the `HUD` instance and select its `new_game()` signal. In the signal connection
    dialog, click Make Function to Off and in the Method In Node field, type `new_game`.
    This will connect the signal to the existing function rather than creating a new
    one. Take a look at the following screenshot:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`StartButton`需要激活`new_game()`函数。点击`HUD`实例并选择其`new_game()`信号。在信号连接对话框中，点击“Make
    Function to Off”，在“Method In Node”字段中输入`new_game`。这将连接信号到现有函数而不是创建一个新的函数。请看以下截图：
- en: '![](img/00040.jpeg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00040.jpeg)'
- en: 'Remove `new_game()` from the `_ready()` function and add these two lines to
    the `new_game()` function:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 将`new_game()`从`_ready()`函数中移除，并将以下两行添加到`new_game()`函数中：
- en: '[PRE25]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, you can play the game! Confirm that all the parts are working as intended:
    the score, the countdown, the game ending and restarting, and so on. If you find
    a piece that''s not working, go back and check the step where you created it,
    as well as the step(s) where it was connected to the rest of the game.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以开始玩游戏了！确认所有部分都按预期工作：得分、倒计时、游戏结束和重新开始等。如果你发现某个部分不工作，请返回并检查你创建它的步骤，以及它连接到游戏其他部分的步骤。
- en: Part 5 – Finishing up
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5部分 - 完成工作
- en: You have created a working game, but it still could be made to feel a little
    more exciting. Game developers use the term *juice* to describe the things that
    make the game feel good to play. Juice can include things like sound, visual effects,
    or any other addition that adds to the player's enjoyment, without necessarily
    changing the nature of the gameplay.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经创建了一个可以工作的游戏，但它仍然可以变得更有趣。游戏开发者使用术语*juice*来描述使游戏感觉好玩的事物。juice可以包括声音、视觉效果或任何其他增加玩家享受的东西，而无需改变游戏玩法本身。
- en: In this section, you'll add some small *juicy* features to finish up the game.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将添加一些小的*juicy*功能来完成游戏。
- en: Visual effects
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视觉效果
- en: When you pick up the coins, they just disappear, which is not very appealing.
    Adding a visual effect will make it much more satisfying to collect lots of coins.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当你捡起硬币时，它们只是消失，这并不很有吸引力。添加视觉效果将使收集大量硬币变得更加令人满意。
- en: Start by adding a `Tween` node to the `Coin` scene.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，向`Coin`场景添加一个`Tween`节点。
- en: What is a tween?
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是tween？
- en: A **tween** is a way to interpolate (change gradually) some value over time
    (from a start value to an end value) using a particular function. For example,
    you might choose a function that steadily changes the value or one that starts
    slow but ramps up in speed. Tweening is also sometimes referred to as *easing*.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**tween** 是一种通过特定函数在时间上（从起始值到结束值）逐渐插值（改变）某些值的方法。例如，你可能选择一个稳定改变值的函数，或者一个开始缓慢但逐渐加速的函数。tweening
    也被称为 *easing*。'
- en: When using a `Tween` node in Godot, you can assign it to alter one or more properties
    of a node. In this case, you're going to increase the `Scale` of the coin and
    also cause it to fade out using the Modulate property.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 Godot 中使用 `Tween` 节点时，你可以将其分配给改变节点的一个或多个属性。在这种情况下，你将增加硬币的 `Scale` 并使用 Modulate
    属性使其淡出。
- en: 'Add this line to the `_ready()` function of `Coin`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 将此行添加到 `Coin` 的 `_ready()` 函数中：
- en: '[PRE26]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `interpolate_property()` function causes the `Tween` to change a node''s
    property. There are seven parameters:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`interpolate_property()` 函数会导致 `Tween` 改变节点的属性。有七个参数：'
- en: The node to affect
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 影响的节点
- en: The property to alter
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要改变的属性
- en: The property's starting value
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性的起始值
- en: The property's ending value
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性的结束值
- en: The duration (in seconds)
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续时间（以秒为单位）
- en: The function to use
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使用的函数
- en: The direction
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方向
- en: 'The tween should start playing when the player picks up the coin. Replace `queue_free()`
    in the `pickup()` function:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家捡起硬币时，tween 应该开始播放。在 `pickup()` 函数中替换 `queue_free()`：
- en: '[PRE27]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Setting `monitoring` to `false` ensures that the `area_enter()` signal won't
    be emitted if the player touches the coin during the tween animation.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `monitoring` 设置为 `false` 确保当玩家在 tween 动画期间触摸硬币时，不会发出 `area_enter()` 信号。
- en: 'Finally, the coin should be deleted when the animation finishes, so connect
    the `Tween` node''s `tween_completed()` signal:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当动画结束时，应该删除硬币，因此连接 `Tween` 节点的 `tween_completed()` 信号：
- en: '[PRE28]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, when you run the game, you should see the coins growing larger when they''re
    picked up. This is good, but tweens are even more effective when applied to multiple
    properties at once. You can add another `interpolate_property()`, this time to
    change the sprite''s opacity. This is done by altering the `modulate` property,
    which is a `Color` object, and changing its alpha channel from `1` (opaque) to
    `0` (transparent). Refer to the following code:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你运行游戏时，你应该看到当捡起硬币时，硬币会变大。这是好的，但将 tween 应用到多个属性同时时，效果会更明显。你可以添加另一个 `interpolate_property()`，这次用来改变精灵的不透明度。这是通过改变
    `modulate` 属性实现的，它是一个 `Color` 对象，并改变其 alpha 通道从 `1`（不透明）到 `0`（透明）。参考以下代码：
- en: '[PRE29]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Sound
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声音
- en: Sound is one of the most important but often neglected pieces of game design.
    Good sound design can add a huge amount of juice to your game for a very small
    amount of effort. Sounds can give the player feedback, connect them emotionally
    to the characters, or even be a part of the gameplay.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 声音是游戏设计中最重要的但经常被忽视的部分之一。良好的声音设计可以在非常小的努力下给你的游戏增添巨大的活力。声音可以给玩家反馈，将他们与角色情感上联系起来，甚至成为游戏玩法的一部分。
- en: For this game, you're going to add three sound effects. In the `Main` scene,
    add three `AudioStreamPlayer` nodes and name them `CoinSound`, `LevelSound`, and
    `EndSound`. Drag each sound from the `audio` folder (you can find it under `assets`
    in the FileSystem dock) into the corresponding Stream property of each node.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个游戏，你将添加三个音效。在 `Main` 场景中，添加三个 `AudioStreamPlayer` 节点，并分别命名为 `CoinSound`、`LevelSound`
    和 `EndSound`。将每个声音从 `audio` 文件夹（你可以在 FileSystem 中的 `assets` 下找到它）拖动到每个节点的相应 Stream
    属性中。
- en: To play a sound, you call the `play()` function on it. Add `$CoinSound.play()` to
    the `_on_Player_pickup()` function, `$EndSound.play()` to the `game_over()` function,
    and `$LevelSound.play()` to the `spawn_coins()` function.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 要播放声音，你可以在其上调用 `play()` 函数。将 `$CoinSound.play()` 添加到 `_on_Player_pickup()` 函数中，`$EndSound.play()`
    添加到 `game_over()` 函数中，以及 `$LevelSound.play()` 添加到 `spawn_coins()` 函数中。
- en: Powerups
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提升物品
- en: There are many possibilities for objects that give the player a small advantage
    or powerup. In this section, you'll add a powerup item that gives the player a
    small time bonus when collected. It will appear occasionally for a short time,
    then disappear.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多可能性可以给玩家带来小的优势或提升。在本节中，你将添加一个提升物品，当收集时会给玩家一小段时间奖励。它将偶尔短暂出现，然后消失。
- en: The new scene will be very similar to the `Coin` scene you already created,
    so click on your `Coin` scene and choose Scene | Save Scene As and save it as
    `Powerup.tscn`. Change the name of the root node to Powerup and remove the script
    by clicking the clear script button: ![](img/00041.jpeg). You should also disconnect
    the `area_entered` signal (you'll reconnect it later). In the Groups tab, remove
    the coins group by clicking the delete button (it looks like a trash can) and
    adding it to a new group called `powerups` instead.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 新场景将与你已经创建的 `Coin` 场景非常相似，所以点击你的 `Coin` 场景，选择 Scene | Save Scene As 并将其保存为 `Powerup.tscn`。将根节点名称更改为
    Powerup 并通过点击清除脚本按钮移除脚本：![](img/00041.jpeg)。你还应该断开 `area_entered` 信号（你稍后会重新连接它）。在
    Groups 选项卡中，通过点击删除按钮（看起来像垃圾桶）将硬币组移除，并将其添加到名为 `powerups` 的新组中。
- en: In the `AnimatedSprite`, change the images from the coin to the powerup, which
    you can find in the `res://assets/pow/` folder.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `AnimatedSprite` 中，将硬币的图像更改为 `powerup`，你可以在 `res://assets/pow/` 文件夹中找到它。
- en: Click to add a new script and copy the code from the `Coin.gd` script. Change
    the name of `_on_Coin_area_entered` to `_on_Powerup_area_entered` and connect
    the `area_entered` signal to it again. Remember, this function name will automatically
    be chosen by the signal connect window.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 点击添加新脚本，并将 `Coin.gd` 脚本中的代码复制过来。将 `_on_Coin_area_entered` 的名称更改为 `_on_Powerup_area_entered`
    并再次将 `area_entered` 信号连接到它。记住，这个函数名称将由信号连接窗口自动选择。
- en: 'Next, add a `Timer` node named `Lifetime`. This will limit the amount of time
    the object remains on the screen. Set its Wait Time to `2` and both One Shot and
    Autostart to `On`. Connect its timeout signal so that it can be removed at the
    end of the time period:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加一个名为 `Lifetime` 的 `Timer` 节点。这将限制对象在屏幕上停留的时间。将其等待时间设置为 `2`，并将单次触发和自动启动都设置为开启。连接其超时信号，以便在时间周期结束时将其移除：
- en: '[PRE30]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now, go to your Main scene and add another `Timer` node called `PowerupTimer`.
    Set its One Shot property to On. There is also a `Powerup.wav` sound in the `audio`
    folder you can add with another `AudioStreamPlayer`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，前往你的主场景并添加另一个名为 `PowerupTimer` 的 `Timer` 节点。将其单次触发属性设置为开启。在 `audio` 文件夹中还有一个
    `Powerup.wav` 声音，你可以通过另一个 `AudioStreamPlayer` 添加。
- en: 'Connect the `timeout` signal and add the following code to spawn a `Powerup`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 连接 `timeout` 信号并添加以下代码以生成 `Powerup`：
- en: '[PRE31]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `Powerup` scene needs to be linked by adding a variable, then dragging
    the scene into the property in the Inspector, as you did earlier with the `Coin`
    scene:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`Powerup` 场景需要通过添加变量，然后将场景拖动到检查器中的属性来链接，就像你之前对 `Coin` 场景所做的那样：'
- en: '[PRE32]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The powerups should appear unpredictably, so the wait time of the `PowerupTimer`
    needs to be set whenever you begin a new level. Add this to the `_process()` function
    after the new coins are spawned with `spawn_coins()`:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 能量提升物品应该以不可预测的方式出现，所以 `PowerupTimer` 的等待时间需要在开始新关卡时设置。在 `spawn_coins()` 生成新硬币后，将此代码添加到
    `_process()` 函数中：
- en: '[PRE33]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now that you will have powerups appearing, the last step is to give the player
    some bonus time when one is collected. Currently, the player script assumes anything
    it runs into is either a coin or an obstacle. Change the code in `Player.gd` to
    check for what kind of object has been hit:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你将会有能量提升物品出现，最后一步是在收集到一个时给玩家一些额外的时间。目前，玩家脚本假设它遇到的是硬币或障碍物。将 `Player.gd` 中的代码更改以检查被击中的对象类型：
- en: '[PRE34]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Note that now you''re emitting the pickup signal with an additional argument
    naming the type of object. The corresponding function in `Main.gd` can now be
    changed to accept that argument and use the `match` statement to decide what action
    to take:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，现在你正在使用一个额外的参数来命名对象的类型来发射拾取信号。`Main.gd` 中的相应函数现在可以接受该参数，并使用 `match` 语句来决定采取什么行动：
- en: '[PRE35]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `match` statement is a useful alternative to `if` statements, especially
    when you have a large number of possible values to test.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`match` 语句是 `if` 语句的有用替代品，尤其是在你有大量可能值要测试时。'
- en: Try running the game and collecting the powerup. Make sure the sound plays and
    the timer increases by five seconds.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行游戏并收集能量提升物品。确保声音播放并且计时器增加五秒钟。
- en: Coin animation
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 硬币动画
- en: When you created the `Coin` scene, you added an `AnimatedSprite`, but it isn't
    playing yet. The coin animation displays a *shimmer* effect traveling across the
    face of the coin. If all the coins display this at the same time, it will look
    too regular, so each coin needs a small random delay in its animation.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建了 `Coin` 场景时，你添加了一个 `AnimatedSprite`，但它还没有开始播放。硬币动画显示一个在硬币表面移动的 *闪烁* 效果。如果所有硬币同时显示这个效果，看起来会太规律，所以每个硬币的动画都需要一个小的随机延迟。
- en: First, click on the `AnimatedSprite` and then on the *Frames* resource. Make
    sure Loop is set to Off and that Speed is set to `12`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，点击 `AnimatedSprite`，然后点击 *Frames* 资源。确保 Loop 设置为 Off，并且 Speed 设置为 `12`。
- en: 'Add a `Timer` node to the `Coin` scene, and add this code to `_ready()`:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `Timer` 节点添加到 `Coin` 场景中，并在 `_ready()` 中添加以下代码：
- en: '[PRE36]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, connect the `timeout()` signal from the `Timer` and add this:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将 `Timer` 的 `timeout()` 信号连接起来，并添加以下内容：
- en: '[PRE37]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Try running the game and watching for the coins to animate. It's a nice visual
    effect for a very small amount of effort. You'll notice a lot of effects like
    this in professional games. Though very subtle, the visual appeal makes for a
    much more pleasing experience.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行游戏，并观察硬币的动画效果。这需要很少的努力，却是一个很好的视觉效果。你会在专业游戏中注意到很多这样的效果。虽然很微妙，但视觉吸引力使得游戏体验更加愉悦。
- en: The preceding `Powerup` object has a similar animation that you can add in the
    same manner.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `Powerup` 对象有类似的动画，你可以以相同的方式添加。
- en: Obstacles
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 障碍物
- en: Finally, the game can be made a bit more challenging by introducing an obstacle
    that the player must avoid. Touching the obstacle will end the game.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过引入玩家必须避免的障碍物，可以使游戏更具挑战性。触摸障碍物将结束游戏。
- en: 'Create a new scene for the cactus and add the following nodes:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 为仙人掌创建一个新的场景，并添加以下节点：
- en: '`Area2D` (named `Cactus`)'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Area2D`（命名为 `Cactus`）'
- en: '`Sprite`'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sprite`'
- en: '`CollisionShape2D`'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CollisionShape2D`'
- en: Drag the cactus texture from the FileSystem dock to the Texture property of
    the `Sprite`. Add a `RectangleShape2D` to the collision shape and size it so that
    it covers the image. Remember when you added `if area.is_in_group("obstacles")` to
    the player script? Add the `Cactus` body to the `obstacles` group using the Node
    tab (next to Inspector).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 将仙人掌纹理从 FileSystem 选项卡拖动到 `Sprite` 的 Texture 属性。向碰撞形状添加一个 `RectangleShape2D`，并调整其大小以覆盖图像。记得你之前在玩家脚本中添加了
    `if area.is_in_group("obstacles")` 吗？使用节点选项卡（在检查器旁边）将 `Cactus` 身体添加到 `obstacles`
    组。
- en: Now, add a `Cactus` instance to the `Main` scene and move it to a location in
    the upper half of the screen (away from where the player spawns). Play the game
    and see what happens when you run into the cactus.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将一个 `Cactus` 实例添加到 `Main` 场景中，并将其移动到屏幕上半部分的一个位置（远离玩家出生点）。玩玩游戏，看看当你撞到仙人掌时会发生什么。
- en: 'You may have spotted a problem: coins can spawn behind the cactus, making them
    impossible to pick up. When the coin is placed, it needs to move if it detects
    that it''s overlapping the obstacle. Connect the coin''s `area_entered()` signal
    and add the following:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经发现了一个问题：硬币可能会在仙人掌后面生成，这使得它们无法被捡起。当硬币放置时，如果它检测到与障碍物重叠，它需要移动。连接硬币的 `area_entered()`
    信号并添加以下内容：
- en: '[PRE38]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If you've added the preceding `Powerup` object, you'll need to do the same for
    its `area_entered` signal.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经添加了前面的 `Powerup` 对象，你还需要对其 `area_entered` 信号做同样的处理。
- en: Summary
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you learned the basics of Godot Engine by creating a basic
    2D game. You set up the project and created multiple scenes, worked with sprites
    and animations, captured user input, used *signals* to communicate with events,
    and created a UI using **Control** nodes. The things you learned here are important
    skills that you'll use in any Godot project.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你通过创建一个基本的 2D 游戏学习了 Godot 引擎的基础知识。你设置了项目并创建了多个场景，处理精灵和动画，捕获用户输入，使用 *signals*
    与事件通信，并使用 **Control** 节点创建 UI。在这里学到的技能是你在任何 Godot 项目中都会用到的关键技能。
- en: Before moving on to the next chapter, look through the project. Do you understand
    what each node is doing? Are there any bits of code that you don't understand?
    If so, go back and review that section of the chapter.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入下一章之前，查看一下项目。你理解每个节点的作用吗？有没有你不理解的代码片段？如果有，请返回并复习该章节的相关部分。
- en: Also, feel free to experiment with the game and change things around. One of
    the best ways to get a good feel for what different parts of the game are doing
    is to change them and see what happens.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你也可以自由地尝试游戏并改变一些东西。了解游戏不同部分如何工作的最好方法之一就是改变它们并观察会发生什么。
- en: In the next chapter, you'll explore more of Godot's features and learn how to
    use more node types by building a more complex game.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将探索更多 Godot 的功能，并通过构建一个更复杂的游戏来学习如何使用更多节点类型。
