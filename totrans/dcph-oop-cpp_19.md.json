["```cpp\nclass Singleton\n{\nprivate:\n    static Singleton *theInstance;   // initialized below\n    Singleton();  // private to prevent multiple\n                  // instantiation\npublic:\n    static Singleton *instance(); // interface for creation\n    virtual ~Singleton(); // never called, unless you\n};                        // delete Singleton explicitly, \n                          // which is unlikely and atypical\nSingleton *Singleton::theInstance = nullptr; // extern var\n                                   // to hold static member\nSingleton::Singleton()\n{\n    cout << \"Constructor\" << endl;\n    // Below line of code is not necessary and therefore\n    // commented out – see static member init. above\n    // theInstance = nullptr;\n}\nSingleton::~Singleton()  // the destructor is not called in\n{                        // the typical pattern usage\n    cout << \"Destructor\" << endl;\n    if (theInstance != nullptr)  \n    {  \n       Singleton *temp = theInstance;\n       // Remove pointer to Singleton and prevent recursion\n       // Remember, theInstance is static, so\n       // temp->theInstance = nullptr; would be duplicative \n       theInstance = nullptr;    \n       delete temp;              // delete the Singleton\n       // Note, delete theInstance; without temp usage\n       // above would be recursive \n    }                 \n}\nSingleton *Singleton::instance()\n{\n    if (theInstance == nullptr)\n        theInstance = new Singleton();// allocate Singleton\n    return theInstance;\n}\nint main()\n{\n    // create Singleton\n    Singleton *s1 = Singleton::instance(); \n    // returns existing Singleton (not a new one)\n    Singleton *s2 = Singleton::instance(); \n    // note: addresses are the same (same Singleton!)\n    cout << s1 << \" \" << s2 << endl; \n    return 0;\n}                                         \n```", "```cpp\nConstructor\n0xee1938 0xee1938\n```", "```cpp\nclass Singleton\n{ \nprivate:\n    string data;\n    Singleton(string d); // private to prevent multiple \npublic:                  // instantiation\n    static Singleton &instance(string); // return reference\n    // destructor is called for the static local variable\n    // declared in instance() before the application ends\n    virtual ~Singleton();   // destructor is now called\n    const string &getData() const { return data; }\n};\nSingleton::Singleton(string d): data(d)  // initialize data\n{                                   \n    cout << \"Constructor\" << endl;\n}\nSingleton::~Singleton()\n{\n    cout << \"Destructor\" << endl;\n}\n// Note that instance() takes a parameter to reflect how we\n// can provide meaningful data to the Singleton constructor\nSingleton &Singleton::instance(string d)\n{   // create the Singleton with desired constructor; But,\n    // we can never replace the Singleton in this approach!\n    // Remember, static local vars are ONLY created and \n    // initialized once - guaranteeing one Singleton\n    static Singleton theInstance(d);   \n    return theInstance;\n}\nint main()\n{   \n    // First call, creates/initializes Singleton\n    Singleton &s1 = Singleton::instance(\"Unique data\"); \n    // Second call returns existing Singleton\n    // (the static local declaration is ignored)\n    Singleton &s2 = Singleton::instance(\"More data\"); \n    cout << s1.getData() << \" \" << s2.getData() << endl;\n    return 0;\n}                                        \n```", "```cpp\nConstructor\nUnique data \nUnique data\nDestructor\n```", "```cpp\nclass Singleton;    // Necessary forward class declarations\nclass SingletonDestroyer;\nclass Person;\nclass President;\nclass SingletonDestroyer   \n{\nprivate:\n    Singleton *theSingleton = nullptr;\npublic:\n    SingletonDestroyer(Singleton *s = nullptr) \n        { theSingleton = s; }\n    // disallow copies and assignment\n    SingletonDestroyer(const SingletonDestroyer &) \n                                    = delete; \n    SingletonDestroyer &operator=\n       (const SingletonDestroyer &) = delete;\n    ~SingletonDestroyer(); // dtor shown further below\n    void setSingleton(Singleton *s) { theSingleton = s; }\n    Singleton *getSingleton() { return theSingleton; }\n};\n```", "```cpp\n// Singleton will be mixed-in using inheritance with a\n// Target class. If Singleton is used stand-alone, the data \n// members would be private. Also be sure to add a\n// Static *Singleton instance(); \n// method to the public access region.\nclass Singleton\n{\nprotected:    // protected data members\n    static Singleton *theInstance;\n    static SingletonDestroyer destroyer;\nprotected:   // and protected member functions\n    Singleton() = default;\n    // disallow copies and assignment\n    Singleton(const Singleton &) = delete; \n    Singleton &operator=(const Singleton &) = delete; \n    friend class SingletonDestroyer;\n    virtual ~Singleton() \n        { cout << \"Singleton destructor\" << endl; }\n};\n```", "```cpp\n// External (name mangled) vars to hold static data mbrs\nSingleton *Singleton::theInstance = nullptr;\nSingletonDestroyer Singleton::destroyer;\n// SingletonDestroyer destructor definition must appear \n// after class definition for Singleton because it is \n// deleting a Singleton (so its destructor can be seen)\n// This is not an issue when using header and source files.\nSingletonDestroyer::~SingletonDestroyer()\n{   \n    if (theSingleton == nullptr)\n        cout << \"SingletonDestroyer destructor: Singleton \n                 has already been destructed\" << endl;\n    else\n    {\n        cout << \"SingletonDestroyer destructor\" << endl;\n        delete theSingleton;   \n    }                          \n}\n```", "```cpp\n// Assume our Person class is as we are accustomed\n// A President Is-A Person and also mixes-in Singleton \nclass President: public Person, public Singleton\n{\nprivate:\n    President(const string &, const string &, char, \n              const string &);\npublic:\n    ~President() override;   // virtual destructor\n    // disallow copies and assignment\n    President(const President &) = delete;  \n    President &operator=(const President &) = delete; \n    static President *instance(const string &, \n                    const string &, char, const string &);\n};\nPresident::President(const string &fn, const string &ln, \n    char mi, const string &t): Person(fn, ln, mi, t),\n                               Singleton()\n{\n}\nPresident::~President()\n{\n    destroyer.setSingleton(nullptr);  \n    cout << \"President destructor\" << endl;\n}\nPresident *President::instance(const string &fn, \n           const string &ln, char mi, const string &t)\n{\n    if (theInstance == nullptr)\n    {\n        theInstance = new President(fn, ln, mi, t);\n        destroyer.setSingleton(theInstance);\n        cout << \"Creating the Singleton\" << endl;\n    }\n    else\n        cout << \"Singleton previously created. \n                 Returning existing singleton\" << endl;\n    // below cast is necessary since theInstance is \n    // a Singleton *\n    return dynamic_cast<President *>(theInstance);  \n}                              \n```", "```cpp\nint main()\n{ \n    // Create a Singleton President\n    President *p1 = President::instance(\"John\", \"Adams\", \n                                        'Q', \"President\");\n    // This second request will fail, returning \n    // the original instance\n    President *p2 = President::instance(\"William\",\n                            \"Harrison\", 'H', \"President\");\n    if (p1 == p2)   // Verification there's only one object\n        cout << \"Same instance (only 1 Singleton)\" << endl;\n    p1->Print();\n    // SingletonDestroyer will release Singleton at end\n    return 0;\n}\n```", "```cpp\nCreating the Singleton\nSingleton previously created. Returning existing singleton\nSame instance (only 1 Singleton)\nPresident John Q Adams\nSingletonDestroyer destructor\nPresident destructor\nSingleton destructor\nPerson destructor\n```", "```cpp\nint main()\n{\n    President *p1 = President::instance(\"John\", \"Adams\", \n                                        'Q', \"President\");\n    President *p2 = President::instance(\"William\",\n                             \"Harrison\", 'H', \"President\");\n    if (p1 == p2)  // Verification there's only one object\n        cout << \"Same instance (only 1 Singleton)\" << endl;\n    p1->Print();\n    delete p1;  // Delete the Singleton – unusual.\n    return 0;   // Upon checking, the SingletonDestroyer \n}   // will no longer need to destroy its paired Singleton\n```", "```cpp\nCreating the Singleton\nSingleton previously created. Returning existing singleton\nSame instance (only 1 Singleton)\nPresident John Q Adams\nPresident destructor\nSingleton destructor\nPerson destructor\nSingletonDestroyer destructor: Singleton has already been destructed\n```"]