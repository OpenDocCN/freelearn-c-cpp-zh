- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Implementing GPU-Driven Rendering
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现GPU驱动渲染
- en: In this chapter, we embark on a deep dive into the intricacies of manipulating
    geometry specifically for GPU rendering. The traditional approach heavily relies
    on the CPU for various tasks, which can be a bottleneck in many scenarios. Our
    goal here is to liberate your rendering techniques from such constraints. We aim
    to put the GPU in the driver’s seat, ensuring efficient processing by capitalizing
    on its parallel processing prowess. We will unravel the technique of generating
    and drawing lines, not from the traditional space of the CPU but directly from
    shaders, such as vertex or fragment shaders. This not only enhances efficiency
    but also opens new realms of creativity. Taking a step further, we’ll demonstrate
    how to extend this novel line-drawing feature to display numbers right from shaders.
    This capability paves the way for real-time displays and feedback without toggling
    between GPU and CPU. We then shift our gaze to a more intricate topic – rendering
    text on the GPU. By employing the **Signed Distance Fields** (**SDF**) approach,
    we’ll guide you in achieving smoother and more versatile text rendering on the
    GPU.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨专门用于 GPU 渲染的几何操作细节。传统方法在许多场景中严重依赖 CPU 执行各种任务，这可能会成为瓶颈。我们的目标是解放您的渲染技术，摆脱此类限制。我们的目标是让
    GPU 处于驾驶员的位置，通过利用其并行处理能力来确保高效的处理。我们将揭示从传统 CPU 空间直接从着色器（如顶点或片段着色器）生成和绘制线条的技术。这不仅提高了效率，还开辟了新的创意领域。更进一步，我们将演示如何将这种新颖的线绘制功能扩展到从着色器显示数字。这种能力为实时显示和反馈铺平了道路，无需在
    GPU 和 CPU 之间切换。然后，我们将目光转向一个更复杂的话题——在 GPU 上渲染文本。通过采用**符号距离场**（**SDF**）方法，我们将指导您在
    GPU 上实现更平滑、更通用的文本渲染。
- en: 'Lastly, we’ll address one of the classic challenges in rendering: frustum culling.
    **Frustum culling** involves avoiding the rendering of objects that are outside
    the camera’s **field of view** (**FOV**). **Frustum** refers to the volume of
    space that is visible through the camera. **Culling** means discarding or ignoring
    objects that fall outside this frustum, thus they are not processed for rendering.
    Instead of the traditional approach, we’ll show you how to implement this directly
    on the GPU using compute shaders, ensuring objects outside the camera view do
    not consume valuable GPU resources. By the chapter’s close, you’ll have a holistic
    grasp of GPU-driven rendering, enabling you to harness the GPU’s capabilities
    to its fullest and streamline your rendering tasks.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将解决渲染中的经典挑战之一：视锥剔除。**视锥剔除**涉及避免渲染位于摄像机**视野**（**FOV**）之外的对象。**视锥**指的是通过摄像机可见的空间体积。**剔除**意味着丢弃或忽略位于此视锥之外的对象，因此它们不会被处理用于渲染。与传统方法不同，我们将向您展示如何直接使用计算着色器在
    GPU 上实现此功能，确保位于摄像机视野之外的对象不会消耗宝贵的 GPU 资源。到本章结束时，您将全面掌握 GPU 驱动渲染，使您能够充分利用 GPU 的能力，并简化您的渲染任务。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: Implementing GPU-driven line rendering
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现由 GPU 驱动的线渲染
- en: Expanding line-drawing techniques to render textual values from shaders
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将线绘制技术扩展到从着色器渲染文本值
- en: Drawing text using SDF
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 SDF 绘制文本
- en: Frustum culling using compute shaders
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用计算着色器进行视锥剔除
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need to make sure you have VS 2022 installed along
    with the Vulkan SDK. Basic familiarity with the C++ programming language and an
    understanding of OpenGL or any other graphics API will be useful. Please revisit
    [*Chapter 1*](B18491_01.xhtml#_idTextAnchor019)*, Vulkan Core Concepts*, under
    the *Technical requirements* section for details on setting up and building executables
    for this chapter. This chapter has multiple recipes, which can be launched using
    the following executables:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您需要确保已安装 VS 2022 以及 Vulkan SDK。对 C++ 编程语言的基本熟悉程度以及对 OpenGL 或任何其他图形 API
    的理解将很有帮助。请重新查看 *技术要求* 部分的 [*第 1 章*](B18491_01.xhtml#_idTextAnchor019)*，Vulkan
    核心概念*，以获取有关设置和构建本章可执行文件的详细信息。本章包含多个配方，可以使用以下可执行文件启动：
- en: '`Chapter03_GPU_Lines.exe`'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Chapter03_GPU_Lines.exe`'
- en: '`Chapter03_GPU_Text.exe`'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Chapter03_GPU_Text.exe`'
- en: '`Chapter03_GPU_Text_SDF.exe`'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Chapter03_GPU_Text_SDF.exe`'
- en: '`Chapter03_GPU_Culling.exe`'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Chapter03_GPU_Culling.exe`'
- en: Implementing GPU-driven line rendering
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现由 GPU 驱动的线渲染
- en: In this recipe, you will learn a technique that allows drawing lines directly
    from shaders such as vertex or fragment shaders. In many graphics applications,
    the challenge arises when one wishes to draw lines directly and efficiently using
    the inherent capabilities of shaders, particularly vertex or fragment shaders.
    To address this, our recipe delves into a specialized technique tailored for this
    very purpose. We’ll be presenting a recipe that seamlessly integrates with a variety
    of pipelines and render passes. Through our approach, data, be it vertices or
    colors, gets stored in a device buffer, ensuring a streamlined process. The culmination
    of this procedure is the utilization of this accumulated data in a subsequent
    pass, where these lines are then masterfully rendered onto a framebuffer. By the
    end, you will have a robust and efficient method to directly render lines using
    shaders.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，你将学习一种技术，它允许直接从着色器（如顶点或片段着色器）绘制线条。在许多图形应用程序中，当人们希望直接且高效地使用着色器的固有功能（尤其是顶点或片段着色器）来绘制线条时，会面临挑战。为了解决这个问题，我们的菜谱深入研究了针对这一特定目的量身定制的专业技术。我们将展示一个与各种管线和渲染通道无缝集成的菜谱。通过我们的方法，数据（无论是顶点还是颜色）被存储在设备缓冲区中，确保了流程的流畅。此过程的最终结果是，在后续的通道中利用这些累积的数据，然后巧妙地将这些线条渲染到帧缓冲区中。最终，你将拥有一种强大且高效的方法，可以直接使用着色器绘制线条。
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before diving into the recipe, you should make sure you have VS 2022 installed
    and that you are able to build the repository as per the steps provided in [*Chapter
    1*](B18491_01.xhtml#_idTextAnchor019)*, Vulkan* *Core Concepts*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入菜谱之前，你应该确保已经安装了VS 2022，并且能够按照[*第1章*](B18491_01.xhtml#_idTextAnchor019)*，Vulkan*
    *核心概念*中提供的步骤构建存储库。
- en: You should be able to launch the executable named `Chapter03_GPU_Lines.exe`
    from VS 2022.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够从VS 2022中启动名为`Chapter03_GPU_Lines.exe`的可执行文件。
- en: The code covered in this recipe can be found in the repository, in `chapter3/mainGPULines.cpp`
    and `chapter3/resources/shaders`, in the `gpuLines.frag`, `gpuLines.vert`, `gpuLinesDraw.frag`,
    and `gpuLinesDraw.vert` files.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱中涵盖的代码可以在存储库中找到，位于`chapter3/mainGPULines.cpp`和`chapter3/resources/shaders`目录下的`gpuLines.frag`、`gpuLines.vert`、`gpuLinesDraw.frag`和`gpuLinesDraw.vert`文件中。
- en: How to do it…
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: In this section, we’ll guide you through the comprehensive procedure of directly
    drawing lines from shaders and integrating them into the final rendered frame
    using GPU-driven techniques. By leveraging a dedicated device buffer and carefully
    orchestrated render passes, this technique allows for real-time visual feedback
    and streamlined graphical processes. By the end of this walkthrough, you’ll have
    a robust mechanism in place for efficiently rendering lines directly from the
    GPU with minimal CPU involvement.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将指导你通过直接从着色器绘制线条并将其集成到最终渲染帧中的完整过程，使用GPU驱动的技术。通过利用专用设备缓冲区和精心安排的渲染通道，这项技术允许实时视觉反馈和流畅的图形过程。在本指南结束时，你将拥有一个强大的机制，可以高效地从GPU直接渲染线条，同时CPU的参与度最小化。
- en: 'The idea relies on having a device buffer that serves as a repository for lines
    and parameters for the indirect draw structure used to render those lines. After
    all render passes are complete, one additional render pass is performed to draw
    lines in the buffer. Here are the steps to do it:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法依赖于拥有一个设备缓冲区，它作为线条和用于渲染这些线条的间接绘制结构的参数的存储库。在所有渲染通道完成后，将执行一个额外的渲染通道来绘制缓冲区中的线条。以下是执行此操作的步骤：
- en: 'The first step is to create a buffer that will contain not only the line data
    but also metadata that is used for determining how many lines can fit into the
    buffer and other parameters used by the final indirect draw call. The following
    snippet defines the buffer structure in C++, with `GPULineBuffer` being the structure
    of the buffer used to store/draw lines:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是创建一个缓冲区，它不仅包含线条数据，还包含用于确定缓冲区中可以容纳多少线条以及其他用于最终间接绘制调用的参数的元数据。以下代码片段定义了C++中的缓冲区结构，其中`GPULineBuffer`是用于存储/绘制线条的缓冲区结构：
- en: '[PRE0]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This structure defines the device buffer we’ll use to store the GPU-generated
    lines and can store up to 65,536 lines plus the data in the `Header` section.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此结构定义了我们用来存储GPU生成的行的设备缓冲区，并且可以存储多达65,536行，以及`Header`部分中的数据。
- en: '*Figure 3**.1* shows the buffer’s layout as *seen* by the GPU:'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图3**.1*显示了GPU看到的缓冲区布局：'
- en: '![Figure 3.1 – The GPU lines’ buffer structure](img/B18491_03_01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – GPU行缓冲区结构](img/B18491_03_01.jpg)'
- en: Figure 3.1 – The GPU lines’ buffer structure
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – GPU行缓冲区结构
- en: 'This buffer is created with the following usage bits:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此缓冲区是用以下使用位创建的：
- en: '`VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT`'
- en: '`VK_BUFFER_USAGE_STORAGE_BUFFER_BIT`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_BUFFER_USAGE_STORAGE_BUFFER_BIT`'
- en: '`VK_BUFFER_USAGE_TRANSFER_DST_BIT`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VK_BUFFER_USAGE_TRANSFER_DST_BIT`'
- en: 'This buffer should be made available to all render passes you wish to be able
    to draw/generate lines from:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此缓冲区应可供所有您希望从中绘制/生成线条的渲染通道使用：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The provided code snippet initializes a `gpuLineBuffer` buffer using the Vulkan
    API. This buffer, created via the `context.createBuffer` method, is given a specified
    size (`kGPULinesBufferSize`) and is designated for multiple purposes, including
    indirect draw commands, shader data storage, and as a destination for buffer-to-buffer
    copy operations. Additionally, the buffer’s memory is set to reside on the GPU,
    ensuring fast access:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供的代码片段使用 Vulkan API 初始化了一个 `gpuLineBuffer` 缓冲区。这个缓冲区是通过 `context.createBuffer`
    方法创建的，它被赋予了一个指定的尺寸（`kGPULinesBufferSize`），并用于多个目的，包括间接绘制命令、着色器数据存储以及作为缓冲区到缓冲区复制操作的目的地。此外，缓冲区的内存被设置为位于
    GPU 上，确保快速访问：
- en: '[PRE2]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The function first checks for the next available index for storing the line
    information by retrieving the number of lines already in the buffer with `atomicAdd`.
    If the index returned by the function is greater than the maximum number of lines
    that can fit into the buffer, the function returns early and is a no-op. Otherwise,
    the line data is stored in the buffer.
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 函数首先通过 `atomicAdd` 获取已存储在缓冲区中的线条数量，以检查存储线条信息的下一个可用索引。如果函数返回的索引大于缓冲区中可以容纳的最大线条数，则函数提前返回，并且是一个无操作。否则，线条数据将被存储在缓冲区中。
- en: 'Rendering the lines is done with an extra render pass once all other passes
    have finished processing since the data from previous passes is required. The
    vertex shader code to render the lines looks like the following snippet:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于需要使用之前通道的数据，因此线条的渲染是在所有其他通道处理完成后通过额外的渲染通道完成的。渲染线条的顶点着色器代码如下片段所示：
- en: '[PRE3]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding code, two structures are introduced: `Line` and `VkDrawIndirectCommand`.
    The `Line` structure represents a colored line segment, defined by two 3D endpoints
    (`v0` and `v1`) and their corresponding colors (`c0` and `c1`). The `VkDrawIndirectCommand`
    structure represents a Vulkan command for indirect drawing. The shader also establishes
    a `GPULinesBuffer` buffer containing an array of `Line` structures. In the main
    function, depending on the value of `gl_VertexIndex`, the shader selects the starting
    or ending point of a line instance and assigns the respective color to `outColor`.
    Also, notice how in this shader, we only define the `GPULinesBuffer` structure
    without the header structure. That’s because for drawing lines, we bind the buffer
    at an offset, bypassing the need to define the `Header` segment in the shader.'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，引入了两个结构体：`Line` 和 `VkDrawIndirectCommand`。`Line` 结构体表示一个彩色线段，由两个 3D
    端点（`v0` 和 `v1`）及其相应的颜色（`c0` 和 `c1`）定义。`VkDrawIndirectCommand` 结构体表示一个用于间接绘制的 Vulkan
    命令。着色器还建立了一个包含 `Line` 结构体数组的 `GPULinesBuffer` 缓冲区。在主函数中，根据 `gl_VertexIndex` 的值，着色器选择线实例的起始或结束点，并将相应的颜色分配给
    `outColor`。此外，请注意，在这个着色器中，我们只定义了 `GPULinesBuffer` 结构体，而没有定义头部结构体。这是因为对于绘制线条，我们在偏移量处绑定缓冲区，从而绕过了在着色器中定义
    `Header` 段的需要。
- en: 'The fragment shader just outputs the color provided through the vertex shader:'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 片段着色器仅输出通过顶点着色器提供的颜色：
- en: '[PRE4]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Before rendering the lines, we need to make sure that the previous steps have
    finished writing into the buffer, so we issue a buffer barrier:'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在渲染线条之前，我们需要确保之前的步骤已经完成缓冲区的写入，因此我们发出一个缓冲区屏障：
- en: '[PRE5]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'After that, we issue an indirect draw command that derives its parameters directly
    from the buffer itself. We cleverly stored the number of lines stored in the buffer
    in the previous passes in `VkDrawIndirectCommand:: instanceCount`:'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '之后，我们发出一个间接绘制命令，其参数直接来自缓冲区本身。我们巧妙地将之前通道中存储在缓冲区中的线条数量存储在 `VkDrawIndirectCommand::
    instanceCount` 中：'
- en: '[PRE6]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The final step consists of clearing the buffer, which is required for clearing
    the number of lines in the buffer (`VkDrawIndirectCommand:: instanceCount`). Before
    clearing the buffer, we must ensure that the GPU has finished drawing lines, which
    we can verify by issuing another buffer barrier:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '最后一步是清除缓冲区，这是清除缓冲区中线条数量的必要步骤（`VkDrawIndirectCommand:: instanceCount`）。在清除缓冲区之前，我们必须确保
    GPU 已经完成了线条的绘制，我们可以通过发出另一个缓冲区屏障来验证这一点：'
- en: '[PRE7]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this recipe, we have unpacked a powerful technique for rendering lines directly
    from shaders. The utility of this method extends to diverse rendering applications,
    and it lays the groundwork for more advanced graphical outputs, elevating your
    skills to an even higher level in the realm of GPU programming using Vulkan.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Expanding line-drawing techniques to render textual values from shaders
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Continuing from our previous exploration, where we developed the capability
    to draw lines directly from shaders, our next challenge is to further refine this
    capability to facilitate the rendering of text values. Drawing inspiration from
    the foundational concepts established in the preceding recipe, we aim to implement
    a methodology that permits the conversion of numerical values into line segments,
    much like digital LCD displays. By doing so, not only do we breathe life into
    bare numerical data, making it more visual and interpretable, but we also harness
    the power and efficiency of shaders in crafting these representations. Upon completion,
    you will be equipped with a robust toolset, allowing them to render clear, scalable,
    and visually appealing textual data, right from their shaders.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before diving into the recipe, you should make sure you have VS 2022 installed
    and that you are able to build the repository as per the steps provided in [*Chapter
    1*](B18491_01.xhtml#_idTextAnchor019)*, Vulkan* *Core Concepts.*
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: You should be able to launch the executable named `Chapter03_GPU_Text.exe` from
    VS 2022.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Since this recipe is heavily based on the previous recipe, we recommend reading
    the previous recipe on GPU line drawing first. The code covered in this recipe
    can be found in the repository, in `chapter3/mainGPUText.cpp` and `chapter3/resources/shaders`,
    in the `gpuText.frag`, `gpuText.vert`, `gpuTextDraw.frag`, and `gpuTexDraw.vert`
    files.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The idea is to decompose numbers into segments (like LCD segment displays)
    and print values by drawing lines for each digit. The previous recipe covered
    how to store and draw lines; this recipe builds on top of that to print numbers.
    Since in this recipe we need to draw numbers, we will need to parse numbers and
    decompose them into lines:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to use a strategy to represent digits with only lines. We chose
    to implement a simple 7-segment approach that can be used to display all digits
    from 0 to 9 plus a minus sign. We also added an extra segment to represent a decimal
    separator. *Figure 3**.2* shows the seven segments plus the decimal separator
    and their indices as used by the code in the shader:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Segments used to represent all digits from 0 to 9 plus a decimal
    separator and a minus sign](img/B18491_03_02.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Segments used to represent all digits from 0 to 9 plus a decimal
    separator and a minus sign
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the structures defined in the previous recipe, we will replace
    the `pad0` member of the `GPULinesBuffer` buffer so that it stores the row number:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We’ll also need the definition of the segments shown in *Figure 3**.2* as two
    vectors:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要 *图 3**.2* 中显示的段落的定义，作为两个向量：
- en: '[PRE9]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Array `v` represents the coordinates of all vertices shown in *Figure 3**.2*
    normalized into the range [`-0.5`, `0.5`] in the *x* direction and [`-1.0`, `1.0`]
    in the *y* direction. Array `i` describes all segments and their vertices. For
    instance, the first element of the array describes segment 0 in the picture, from
    vertex 0 (`-0.5`, `1.0`) to vertex 1 (`0.5`, `1.0`).
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 数组 `v` 代表 *图 3**.2* 中显示的所有顶点的坐标，在 *x* 方向上归一化到范围 `[-0.5, 0.5]`，在 *y* 方向上归一化到范围
    `[-1.0, 1.0]`。数组 `i` 描述所有段及其顶点。例如，数组的第一个元素描述了图中的段 0，从顶点 0 (`-0.5`, `1.0`) 到顶点
    1 (`0.5`, `1.0`)。
- en: 'The `printSegment` function adds one segment, given its index, a scale, and
    a translation, to the GPU buffer where lines are stored:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`printSegment` 函数将一个段（给定其索引、缩放和转换）添加到存储线的 GPU 缓冲区中：'
- en: '[PRE10]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This function calls the `addLine` function presented before to record the final
    vertices and colors of lines in the buffer.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此函数调用之前提出的 `addLine` 函数来记录缓冲区中线的最终顶点和颜色。
- en: 'The `printDigit` function prints all segments for a digit at a specific line
    and column, passed in as parameters:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`printDigit` 函数在特定的行和列上打印一个数字的所有段，这些行和列作为参数传入：'
- en: '[PRE11]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Initially, it calculates the width and height of the characters in `switch`
    statement to decide which digit to print. The following snippet only shows how
    to print the digits 0 and 1, the decimal separator, and the minus sign for brevity:'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最初，它计算 `switch` 语句中字符的宽度和高度以决定要打印哪个数字。为了简洁起见，以下片段仅显示了如何打印数字 0 和 1、小数分隔符和负号：
- en: '[PRE12]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding code employs a switch-case structure to identify which segments
    should be activated based on the digit or symbol passed. For example, the number
    `0` requires several segments to depict its round shape. Therefore, when the digit
    is `0`, multiple `printSegment` calls are made to render each segment required
    for the `0` digit. Similarly, `1` is formed using two segments on its side. Beyond
    the digits, the function also has provisions to depict a decimal separator and
    a minus sign, distinguished by their unique segment arrangements.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 之前的代码使用 switch-case 结构来识别基于传入的数字或符号应激活哪些段。例如，数字 `0` 需要多个段来描绘其圆形形状。因此，当数字是 `0`
    时，会进行多个 `printSegment` 调用来渲染 `0` 数字所需的每个段。同样，`1` 使用其侧面的两个段形成。除了数字之外，该函数还有描绘小数分隔符和负号的条款，它们通过独特的段排列来区分。
- en: 'The `printNumber` function is designed to display an integer on a specified
    line, starting from a given column. After executing, it provides the next available
    column following the last digit printed. If the integer is zero, it simply prints
    `''0''`. For nonzero integers, the function efficiently computes the number of
    digits and iteratively prints each one, advancing the column accordingly:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`printNumber` 函数旨在在指定的行上显示一个整数，从给定的列开始。执行后，它提供最后一个打印的数字之后的下一个可用列。如果整数是零，它简单地打印
    `''0''`。对于非零整数，该函数有效地计算数字的位数，并迭代地打印每个数字，相应地推进列：'
- en: '[PRE13]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This function parses the integer parameter and prints each digit individually,
    while incrementing the `column` index.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此函数解析整数参数，并逐个打印每个数字，同时增加 `column` 索引。
- en: 'Finally, the `parse` function parses a float and prints it with a certain number
    of decimal places:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`parse` 函数解析一个浮点数，并以一定的小数位数打印它：
- en: '[PRE14]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The function splits the float into two parts, the integer part and the decimal
    part, and prints them separately. If the number is negative, it prints the minus
    sign.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该函数将浮点数分成两部分，整数部分和小数部分，并分别打印它们。如果数字是负数，它打印负号。
- en: 'The next step is to clear the buffer once the lines text has been rendered.
    In the previous recipe, we cleared the number of lines in the buffer. Here, we
    also need to clear the row number:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是在渲染文本行后清除缓冲区。在先前的配方中，我们清除了缓冲区中的行数。这里，我们还需要清除行号：
- en: '[PRE15]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The last step is to use the `parse` function. Just call it from any shader
    that includes those functions. Each call to `parse` will print the value on a
    new line. *Figure 3**.3* shows the result of printing some values with the following
    code in the vertex shader:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是使用 `parse` 函数。只需从包含这些函数的任何着色器中调用它。每次调用 `parse` 都会在新的一行上打印值。*图 3**.3* 展示了在顶点着色器中使用以下代码打印一些值的结果：
- en: '[PRE16]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following screenshot shows how we can use this technique for debugging
    purposes or to display text:'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图显示了我们可以如何使用这种技术进行调试或显示文本：
- en: '![Figure 3.3 – The result of printing values from the vertex shader](img/B18491_03_03.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3 – 从顶点着色器打印值的输出](img/B18491_03_03.jpg)'
- en: Figure 3.3 – The result of printing values from the vertex shader
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – 从顶点着色器打印值的输出
- en: In this recipe, we delved into the intricate process of representing numerical
    values using line segments, reminiscent of LCD displays. By breaking down numbers
    into their individual segments and leveraging our foundational line-drawing methods
    from shaders, we provided you with an innovative technique to visualize numbers.
    The end result is a seamless integration of numbers into your graphics, with clarity
    reminiscent of digital segment displays, enriching the overall visual experience.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们深入探讨了使用线段表示数值的复杂过程，这让人联想到LCD显示器。通过将数字分解为其各个段，并利用我们从着色器中获得的基础线绘制方法，我们为您提供了一种创新的技术来可视化数字。最终结果是数字与图形的无缝集成，其清晰度让人联想到数字段显示器，丰富了整体视觉体验。
- en: Drawing text using SDF
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SDF绘制文本
- en: In this recipe, we address the challenge of rendering crisp and scalable text,
    regardless of its size. By utilizing the principles of SDF, we transform traditional
    text rendering into a more fluid process, ensuring sharpness and clarity. The
    outcome is beautifully rendered text that remains clear and legible, whether you’re
    zooming in closely or viewing from a distance.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们解决了渲染清晰且可缩放的文本的挑战，无论其大小如何。通过利用SDF的原则，我们将传统的文本渲染转化为一个更流畅的过程，确保清晰度和锐度。结果是美丽渲染的文本，无论您是近距离放大还是从远处观看，都保持清晰易读。
- en: SDFs provide a way to represent surfaces. An SDF is basically a function that,
    for every point in space, returns the shortest distance to the surface of the
    shape. SDFs can be used for a variety of use cases such as volume rendering or
    to perform operations on shapes such as dilation, erosion, and other morphological
    operations.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: SDFs提供了一种表示表面的方法。SDF基本上是一个函数，对于空间中的每一个点，它返回到该形状表面的最短距离。SDFs可用于各种用例，例如体积渲染或对形状执行膨胀、腐蚀和其他形态学操作。
- en: Traditionally, text is rendered using bitmap fonts. One can use a 2D canvas
    to render text and then use that as a texture to draw a quad in a 3D context.
    However, this method creates bitmaps that are resolution-dependent and need to
    be generated and uploaded to the device by the CPU. Each font style, such as bold,
    italics, and so on, also needs to be processed by the CPU, which causes an extra
    overhead for the computation and transfer of the textures for each style needed
    for rendering.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，文本使用位图字体进行渲染。可以使用2D画布来渲染文本，然后将其作为纹理绘制到3D上下文中的四边形。然而，这种方法创建的位图是分辨率相关的，需要由CPU生成并上传到设备。每个字体样式，如粗体、斜体等，也需要由CPU处理，这导致计算和传输每种渲染所需样式的纹理时产生额外的开销。
- en: Rendering text using SDFs is a modern approach that uses distance fields for
    each character. These are grids in which each of the values represents the distance
    from each pixel to the nearest edge of the character. SDFs help avoid all the
    problems mentioned before by offering resolution-independent scaling as well as
    using the GPU for most of the work. Styles such as bold, outline, and so on require
    only changes to shaders.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SDF渲染文本是一种现代方法，它使用每个字符的距离场。这些是网格，其中每个值代表每个像素到字符最近边的距离。SDFs通过提供分辨率无关的缩放以及使用GPU来完成大部分工作，从而帮助避免之前提到的问题。如粗体、轮廓等样式只需更改着色器即可。
- en: 'Each letter of a font (a glyph) is described by a combination of straight lines
    and Bézier curves. One example of a glyph is shown in *Figure 3**.4*, which shows
    the detail of a glyph’s serif:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 字体中的每个字母（字形）由直线和贝塞尔曲线的组合描述。*图3.4*中展示了字形的一个示例，它显示了字形的衬线细节：
- en: '![Figure 3.4 – Detail of a glyph definition: circles, triangles, and squares
    represent the start and end points of each segment (curves or straight lines)](img/B18491_03_04.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图3.4 – 字形定义的细节：圆圈、三角形和正方形代表每个段（曲线或直线）的起点和终点](img/B18491_03_04.jpg)'
- en: 'Figure 3.4 – Detail of a glyph definition: circles, triangles, and squares
    represent the start and end points of each segment (curves or straight lines)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 – 字形定义的细节：圆圈、三角形和正方形代表每个段（曲线或直线）的起点和终点
- en: 'Traditional SDF algorithms encode the distance from a pixel to the glyph’s
    boundary for each pixel in a grid, store that information in a texture, and upload
    that to the CPU. The algorithm presented in this recipe implements a different
    approach, in which the distances from a pixel to the nearest curves are computed
    on the GPU. To do that, each glyph in the font is preprocessed on the CPU against
    a grid of fixed size of 8 x 8 cells. This preprocessing detects curves that intersect
    each cell and stores the information in a 32-bit integer, as shown in *Figure
    3**.5*:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的 SDF 算法为网格中每个像素到符号边界的距离进行编码，将此信息存储在纹理中，并将其上传到 CPU。本食谱中提出的算法实现了一种不同的方法，其中像素到最近曲线的距离是在
    GPU 上计算的。为此，字体中的每个符号都在 CPU 上与固定大小为 8 x 8 单元的网格进行预处理。这种预处理检测与每个单元格相交的曲线，并将信息存储在
    32 位整数中，如图 *图 3**.5* 所示：
- en: '![Figure 3.5 – Cell encoding stores the initial index of three separate curves
    that intersect the cell along with the length of each loop](img/B18491_03_05.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5 – 单元编码存储了与单元格相交的三个单独曲线的初始索引以及每个循环的长度](img/B18491_03_05.jpg)'
- en: Figure 3.5 – Cell encoding stores the initial index of three separate curves
    that intersect the cell along with the length of each loop
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – 单元编码存储了与单元格相交的三个单独曲线的初始索引以及每个循环的长度
- en: Each cell contains the information of up to three loops that intersect it by
    storing the initial index of each loop plus their lengths. For example, the glyph
    shown in cell (2, 0) intersects two curves, curve 1 and curve 2\. The information
    encoded for that cell would contain the index to curve 1 and a length of 2\. The
    other indices would remain 0, as the cell doesn’t intersect any other curves.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 每个单元格包含最多三个与之相交的循环的信息，通过存储每个循环的初始索引及其长度来实现。例如，单元格（2, 0）中显示的符号与两条曲线相交，曲线 1 和曲线
    2。该单元格编码的信息将包含曲线 1 的索引和长度为 2。其他索引保持为 0，因为该单元格不与任何其他曲线相交。
- en: 'The following diagram demonstrates how the letter *S* can be represented using
    glyphs:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了如何使用符号表示字母 *S*：
- en: "![Figure 3.6 – Curves representing an \uFEFFS glyph; cell (2, 0) intersects\
    \ two curves: curve 1 and curve 2](img/B18491_03_06.jpg)"
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.6 – 表示 S 符号的曲线；单元格（2, 0）与两条曲线相交：曲线 1 和曲线 2](img/B18491_03_06.jpg)'
- en: 'Figure 3.6 – Curves representing an S glyph; cell (2, 0) intersects two curves:
    curve 1 and curve 2'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – 表示 S 符号的曲线；单元格（2, 0）与两条曲线相交：曲线 1 和曲线 2
- en: The vertex shader passes the cell indices for each corner of the rectangle to
    the fragment shader, which receives the interpolated coordinate of the cell, uses
    it to retrieve the information of which curve loops and their lengths to inspect,
    and calculates the minimum distance to each one of the curves in the three loops,
    choosing the minimum distance.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色器将矩形的每个角单元格索引传递给片段着色器，片段着色器接收单元格的插值坐标，使用它来检索要检查的曲线循环及其长度信息，并计算三个循环中每个曲线的最小距离，选择最小距离。
- en: This information is then used to calculate the opacity of the current fragment,
    along with the color and the sharpness of the edge of the font.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这些信息被用来计算当前片段的不透明度，以及字体边缘的颜色和锐度。
- en: 'In this recipe, we use a third-party library to capture the definition of the
    glyphs and store that information in a shader-friendly format. The library is
    authored by Dávid Kocsis and can be found here: [https://github.com/kocsis1david/font-demo](https://github.com/kocsis1david/font-demo).'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们使用第三方库来捕获符号的定义，并将该信息存储在着色器友好的格式中。该库由 Dávid Kocsis 编写，可以在以下位置找到：[https://github.com/kocsis1david/font-demo](https://github.com/kocsis1david/font-demo)。
- en: Getting ready
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before diving into the recipe, you should make sure you have VS 2022 installed
    and that you are able to build the repo as per the steps provided in [*Chapter
    1*](B18491_01.xhtml#_idTextAnchor019)*, Vulkan* *Core Concepts.*
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入本食谱之前，您应该确保已安装 VS 2022，并且能够按照 [*第 1 章*](B18491_01.xhtml#_idTextAnchor019)*，Vulkan*
    *核心概念* 中提供的步骤构建存储库。
- en: You should be able to launch the executable named `Chapter03_GPU_Text_SDF.exe`
    from VS 2022.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该能够从 VS 2022 中启动名为 `Chapter03_GPU_Text_SDF.exe` 的可执行文件。
- en: A complete example with the code covered in this recipe can be found in the
    repository, in `chapter3/mainGPUTextSDF.cpp`, `chapter3/FontManager.hpp`, `chapter3/FontManager.cpp`,
    and `chapter3/resources/shaders`, in the `font.frag` and `font.vert` files.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中涵盖的代码的完整示例可以在存储库中找到，在 `chapter3/mainGPUTextSDF.cpp`、`chapter3/FontManager.hpp`、`chapter3/FontManager.cpp`
    和 `chapter3/resources/shaders` 中，在 `font.frag` 和 `font.vert` 文件中。
- en: How to do it…
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'The steps to render text using SDFs on the device are as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在设备上使用SDF渲染文本的步骤如下：
- en: 'The initial task involves loading the font file through the `FreeType` library.
    This step is crucial because it’s where we obtain the glyph data for each character.
    Glyph data, in essence, represents the basic design of a character in a font,
    describing its unique shape and appearance. Once we have this, the subsequent
    objective is to transform this glyph data into outline data. The outline data
    captures the essence of the glyph’s shape, breaking it down into components such
    as points, cells, and a bounding box specific to each character. These components
    essentially dictate how a character will be rendered on a screen or display. To
    achieve this transformation from `FreeType`’s intricate glyph data to more structured
    outline data, we employ the `fd_outline_convert` function. The data for each character
    is combined into a single stream of points and cells that is uploaded to the GPU
    as a *vertex buffer*:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始任务涉及通过`FreeType`库加载字体文件。这一步至关重要，因为这是我们获取每个字符的位图数据的地方。位图数据本质上代表字体中字符的基本设计，描述其独特的形状和外观。一旦我们有了这些数据，接下来的目标就是将位图数据转换为轮廓数据。轮廓数据捕捉位图形状的本质，将其分解为诸如点、单元格和针对每个字符的特定边界框等组件。这些组件本质上决定了字符如何在屏幕或显示器上渲染。为了实现从`FreeType`复杂的位图数据到更结构化的轮廓数据的转换，我们使用了`fd_outline_convert`函数。每个字符的数据被组合成一个包含点和单元格的单一流，作为*顶点缓冲区*上传到GPU：
- en: '[PRE17]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The code delves deeply into font rendering by handling the glyphs, which are
    the backbone of font representation. One of the main elements here is the point
    data. This crucial piece captures every point that makes up the Bézier curves
    of each glyph. Right now, our focus is mainly on the uppercase letters. But looking
    at how the code is structured, it’s clear that we could easily expand it to embrace
    other characters if we wished to. Parallel to the point data, we also work with
    the cell data. It has a special role when we’re in the rendering phase, especially
    in the fragment shader. It’s this data that aids in navigating the curves that
    intersect with a given cell, making sure that every glyph is depicted accurately
    and precisely on the screen. All in all, by marrying the point and cell data with
    the capabilities of the fragment shader, we’re able to render the font’s visual
    intricacies effectively.
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码深入处理字体渲染，处理位图，位图是字体表示的骨架。这里的主要元素之一是点数据。这个关键部分捕捉了构成每个位图贝塞尔曲线的每个点。目前，我们的主要关注点是
    uppercase 字母。但通过观察代码的结构，很明显，如果我们愿意，可以轻松地将其扩展以包含其他字符。与点数据并行，我们还处理单元格数据。在渲染阶段，特别是在片段着色器中，它具有特殊的作用。正是这些数据帮助我们在给定单元格相交的曲线上导航，确保每个位图在屏幕上被准确和精确地描绘。总的来说，通过将点和单元格数据与片段着色器的功能相结合，我们能够有效地渲染字体的视觉复杂性。
- en: 'Next, we build a buffer that contains the bounding rectangles of each glyph.
    This buffer serves as the vertex buffer, and we draw as many instances as the
    number of characters in the display string:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们构建一个包含每个位图边界矩形的缓冲区。这个缓冲区作为顶点缓冲区，我们绘制与显示字符串中字符数量相等的实例：
- en: '[PRE18]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the following step, we transfer the points, cell data, glyph data, and string
    to the GPU as separate buffers. Subsequently, we execute a `vkCmdDraw` command:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我们将点、单元格数据、位图数据和字符串作为单独的缓冲区传输到GPU。随后，我们执行一个`vkCmdDraw`命令：
- en: '[PRE19]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The vertex shader needs access to an array of glyph data (`GlyphInfo`) that
    is packed into the `glyph_buffer` buffer. The other inputs are `in_rect`, `in_glyph_index`,
    and `in_sharpness`, which come from the *vertex buffer*:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 顶点着色器需要访问一个包含位图数据（`GlyphInfo`）的数组，这些数据打包到`glyph_buffer`缓冲区中。其他输入包括来自*顶点缓冲区*的`in_rect`、`in_glyph_index`和`in_sharpness`：
- en: '[PRE20]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding vertex shader is tailored for glyph rendering. The shader works
    with a structure named `GlyphInfo` that encapsulates information about each glyph,
    including its bounding box and details related to the cell positioning of the
    glyph. Within the `main` function, the shader fetches data for a specific glyph
    using an input index. It subsequently determines the positions of both the input
    rectangle’s corners and the corresponding glyph’s bounding box and calculates
    the cell coordinates for the glyph. Using `gl_VertexIndex`, which indicates which
    vertex of the rectangle is currently being processed, the shader sets the position
    for that vertex and assigns necessary values to the output variables. This preprocessed
    information is leveraged by the fragment shader to produce a final visual representation
    of the glyph.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述顶点着色器是为图元渲染定制的。着色器与一个名为`GlyphInfo`的结构一起工作，该结构封装了有关每个图元的信息，包括其边界框和与图元的单元格定位相关的细节。在`main`函数中，着色器使用输入索引获取特定图元的数据。随后，它确定输入矩形的角和相应图元的边界框的位置，并计算图元的单元格坐标。使用`gl_VertexIndex`，它指示当前正在处理的矩形的哪个顶点，着色器设置该顶点的位置并将必要的值分配给输出变量。这些预处理信息被片段着色器利用，以产生图元的最终视觉表示。
- en: 'Next are the steps for calculating the text’s glyph color using the fragment
    shader:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是使用片段着色器计算文本的图元颜色的步骤：
- en: Calculates the cell index for a given fragment/pixel.
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算给定片段/像素的单元格索引。
- en: Fetches the cell from the cell buffer based on the cell index.
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据单元格索引从单元格缓冲区获取单元格。
- en: 'Calculates the SDF of the cell from the glyph’s bounding box. Based on the
    distance, an alpha value is computed:'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从图元的边界框计算单元格的SDF。基于距离，计算一个alpha值：
- en: '[PRE21]'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The result of the recipe can be seen in *Figure 3**.7*:'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 菜单的结果可以在*图3.7*中看到：
- en: '![Figure 3.7 – The output of the recipe](img/B18491_03_07.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图3.7 – 菜单的输出](img/B18491_03_07.jpg)'
- en: Figure 3.7 – The output of the recipe
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 – 菜单的输出
- en: In this recipe, we showcased the application of SDF for rendering text with
    the assistance of a GPU.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们展示了使用GPU辅助渲染文本时SDF的应用。
- en: See also
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Inigo Quilez demonstrates how to use SDFs to create shapes in an excellent
    video:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Inigo Quilez 在一个优秀的视频中演示了如何使用SDF创建形状：
- en: https://www.youtube.com/watch?v=8--5LwHRhjk
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: https://www.youtube.com/watch?v=8--5LwHRhjk
- en: There are multiple libraries that generate SDF textures – for example, [https://libgdx.com/wiki/tools/hiero](https://libgdx.com/wiki/tools/hiero)
    and https://github.com/Chlumsky/msdfgen.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 有多个库可以生成SDF纹理 – 例如，[https://libgdx.com/wiki/tools/hiero](https://libgdx.com/wiki/tools/hiero)
    和 https://github.com/Chlumsky/msdfgen.
- en: Frustum culling using compute shaders
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用计算着色器进行视锥剔除
- en: In this recipe, we will show how to do frustum culling using the GPU and compute
    shaders.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将展示如何使用GPU和计算着色器进行视锥剔除。
- en: 'In the world of real-time rendering, efficient rendering is key to achieving
    smooth performance and high-quality visuals. One of the most widely used techniques
    to optimize rendering is frustum culling. Frustum culling is a process that improves
    rendering speed by ignoring or *culling* objects that are not visible within the
    camera’s FOV, or *frustum*. The following diagram demonstrates it visually:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在实时渲染的世界中，高效的渲染是实现流畅性能和高质量视觉的关键。优化渲染最广泛使用的技术之一是视锥剔除。视锥剔除是一个通过忽略或*剔除*摄像机视野（视锥）内不可见对象的过程，以提高渲染速度。以下图表展示了这一过程：
- en: '![Figure 3.8 – Frustum culling works by ignoring objects that fall outside
    of the camera’s view (the frustum)](img/B18491_03_08.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图3.8 – 视锥剔除通过忽略摄像机视图（视锥）外的对象来工作](img/B18491_03_08.jpg)'
- en: Figure 3.8 – Frustum culling works by ignoring objects that fall outside of
    the camera’s view (the frustum)
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 – 视锥剔除通过忽略摄像机视图（视锥）外的对象来工作
- en: Frustum culling works by testing each object in the scene to see if it lies
    within the camera’s frustum. If an object is entirely outside the frustum, it
    gets culled; that is, it’s not drawn. This can significantly reduce the number
    of primitives that need to be drawn. Traditionally, culling was done on the CPU,
    but this meant it needed to be done every time the camera moved. We demonstrate
    culling by using the compute shader, eliminating the need to upload data from
    the CPU to the GPU every time the view changes. Compute shaders do not necessarily
    need to be related to rendering and can process data structures and perform operations
    such as sorting, physics simulations, and, in our case, frustum culling.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 视锥剔除通过测试场景中的每个对象是否位于摄像机的视锥体内来工作。如果一个对象完全位于视锥体之外，它将被剔除；也就是说，它不会被绘制。这可以显著减少需要绘制的原语数量。传统上，剔除是在
    CPU 上完成的，但这意味着每次摄像机移动时都需要进行。我们通过使用计算着色器来展示剔除，从而消除了每次视图变化时都需要从 CPU 上传数据到 GPU 的需求。计算着色器不一定需要与渲染相关，可以处理数据结构并执行排序、物理模拟等操作，在我们的案例中，是视锥剔除。
- en: Getting ready
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before diving into the recipe, you should make sure you have VS 2022 installed
    and that you are able to build the repository as per the steps provided in [*Chapter
    1*](B18491_01.xhtml#_idTextAnchor019)*, Vulkan* *Core Concepts.*
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入到食谱之前，您应该确保已安装 VS 2022，并且能够按照[*第1章*](B18491_01.xhtml#_idTextAnchor019)*，*Vulkan
    核心概念*中提供的步骤构建存储库。
- en: You should be able to launch the executable named `Chapter03_GPU_Culling.exe`
    from VS 2022.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该能够从 VS 2022 中启动名为`Chapter03_GPU_Culling.exe`的可执行文件。
- en: This recipe is based on the *Implementing Programmable Vertex Pulling and Multi-Draw
    Indirect* recipe from [*Chapter 2*](B18491_02.xhtml#_idTextAnchor126)*, Working
    with Modern Vulkan.* The code covered in this recipe can be found in the repository,
    in `chapter3/mainCullingCompute.cpp`, `chapter3/CullingComputePass.cpp`, and `chapter3/resources/shaders`,
    in the `gpuculling.comp`, `indirectdraw.frag`, and `indirectdraw.vert` files.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 此食谱基于[*第2章*](B18491_02.xhtml#_idTextAnchor126)*，*使用现代 Vulkan*中的*实现可编程顶点拉取和多绘制间接*食谱。本食谱中涵盖的代码可以在存储库中找到，位于`chapter3/mainCullingCompute.cpp`、`chapter3/CullingComputePass.cpp`和`chapter3/resources/shaders`目录下的`gpuculling.comp`、`indirectdraw.frag`和`indirectdraw.vert`文件中。
- en: How to do it…
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: We will be building on a recipe from [*Chapter 2*](B18491_02.xhtml#_idTextAnchor126)*,
    Working with Modern Vulkan.* that implemented Multi-Draw Indirect. We demonstrated
    during that recipe the use of `vkCmdDrawIndexedIndirect`. In this recipe, we will
    use a command that derives the number of its parameters from a device buffer,
    `vkCmdDrawIndexedIndirectCount`. This Vulkan API lets you specify a GPU buffer
    that contains the draw count instead of providing it by the CPU.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将基于[*第2章*](B18491_02.xhtml#_idTextAnchor126)*，*使用现代 Vulkan*中实现的 Multi-Draw
    Indirect 食谱进行构建。在那个食谱中，我们展示了`vkCmdDrawIndexedIndirect`的使用。在这个食谱中，我们将使用一个从设备缓冲区派生其参数数量的命令，`vkCmdDrawIndexedIndirectCount`。这个
    Vulkan API 允许您指定一个包含绘制计数的 GPU 缓冲区，而不是由 CPU 提供。
- en: 'This recipe’s technique relies on three buffers: the first two each contain
    the indirect draw parameters’ structures, `InputIndirectDraws` and `OutputIndirectDraws`
    respectively; the third one contains the number of meshes to be rendered. The
    first buffer contains the parameters for all meshes in the scene. The second buffer
    is populated by the compute shader: meshes that are *not* culled have their indirect
    parameters atomically copied from the `InputIndirectDraws` buffer to `OutputIndirectDraws`;
    meshes that are culled don’t have their parameters copied:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 此食谱的技术依赖于三个缓冲区：前两个分别包含间接绘制参数的结构，分别是`InputIndirectDraws`和`OutputIndirectDraws`；第三个包含要渲染的网格数量。第一个缓冲区包含场景中所有网格的参数。第二个缓冲区由计算着色器填充：未被剔除的网格将它们的间接参数原子地从`InputIndirectDraws`缓冲区复制到`OutputIndirectDraws`；被剔除的网格则没有它们的参数被复制：
- en: '![Figure 3.9 – Top buffer: all mesh parameters; bottom buffer: unculled meshes
    set to render](img/B18491_03_09.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图3.9 – 顶部缓冲区：所有网格参数；底部缓冲区：未剔除的网格设置以进行渲染](img/B18491_03_09.jpg)'
- en: 'Figure 3.9 – Top buffer: all mesh parameters; bottom buffer: unculled meshes
    set to render'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 – 顶部缓冲区：所有网格参数；底部缓冲区：未剔除的网格设置以进行渲染
- en: Additionally, the compute shader needs information about each mesh’s bounding
    box and their center, and the six planes of the frustum. With this information,
    the compute pass can cull (or not) each mesh. At the end of the pass, the `OutputIndirectDraws`
    buffer contains parameters only for the meshes that will be rendered and is used
    by the indirect draw command.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Next is the recipe broken down into steps, along with snippets from `mainCullingCompute.cpp`.
    It provides a high-level view of how culling and drawing passes are used in tandem
    to perform frustum culling using compute shaders in Vulkan. The compute shader
    takes care of determining which meshes should be drawn, and then the graphics
    pipeline takes care of drawing those meshes.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialize the culling pass by using scene information and a scene buffer:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The first step consists of initializing the two buffers shown in *Figure 3**.9*
    and uploading them to the device. The details are encapsulated by the `CullingComputePass`
    class.
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The compute pass is also encapsulated by the `CullingComputePass` class:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We will discuss the cull method shown next in more detail.
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To prevent a race condition between the compute pass and the rendering pass,
    we add a barrier for the culled indirect draw and the draw count buffer. This
    is necessary because the subsequent drawing commands rely on the results of the
    culling pass:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The draw call is recorded with the `vkCmdDrawIndexedIndirectCount` command:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Having grasped the essential elements of code for the culling pass, let’s delve
    into its operational mechanism.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `CullingComputePass::cull` method is responsible for updating frustum data,
    binding the compute pipeline, updating push constants, and calling `vkCmdDispatch`.
    `vkCmdDispatch` dispatches the compute work to the GPU. The compute work is divided
    into smaller units, each of which is called a workgroup. The `(pushConst.drawCount
    / 256) + 1, 1, 1)` parameters specify the number of workgroups that are dispatched
    in the *x*, *y*, and *z* dimensions, respectively:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `CullingComputePass::addBarrierForCulledBuffers` method adds a pipeline
    barrier that ensures the culling operation has finished before the results are
    read. The barrier is set up so that it blocks the indirect command read access
    (which will be used in the draw call) until the shader write (the culling operation)
    has completed:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the compute shader, we need a function that tells whether a bounding box
    falls completely outside of the frustum by comparing its extents and its center
    point against the six planes of the frustum:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If the mesh is culled, the function returns early. Otherwise, it atomically
    increments the number of visible meshes in the `IndirectDrawCount` buffer and
    copies the indirect draw parameters from the input to the output buffer using
    the previous number of meshes in the buffer as the index of the destination.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'The only remaining work for the main function is to call `cullMesh`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Through this recipe, we’ve harnessed the power of the GPU to effectively filter
    out non-essential objects, optimizing our rendering workflow. By implementing
    this method, you will achieve a more responsive and resource-efficient visualization,
    especially vital for intricate 3D scenes.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个配方，我们利用了GPU的强大功能，有效地过滤掉非必要对象，优化了我们的渲染工作流程。通过实施这种方法，您将实现更响应和资源高效的可视化，这对于复杂的3D场景尤为重要。
