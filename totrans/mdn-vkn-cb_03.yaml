- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing GPU-Driven Rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we embark on a deep dive into the intricacies of manipulating
    geometry specifically for GPU rendering. The traditional approach heavily relies
    on the CPU for various tasks, which can be a bottleneck in many scenarios. Our
    goal here is to liberate your rendering techniques from such constraints. We aim
    to put the GPU in the driver’s seat, ensuring efficient processing by capitalizing
    on its parallel processing prowess. We will unravel the technique of generating
    and drawing lines, not from the traditional space of the CPU but directly from
    shaders, such as vertex or fragment shaders. This not only enhances efficiency
    but also opens new realms of creativity. Taking a step further, we’ll demonstrate
    how to extend this novel line-drawing feature to display numbers right from shaders.
    This capability paves the way for real-time displays and feedback without toggling
    between GPU and CPU. We then shift our gaze to a more intricate topic – rendering
    text on the GPU. By employing the **Signed Distance Fields** (**SDF**) approach,
    we’ll guide you in achieving smoother and more versatile text rendering on the
    GPU.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we’ll address one of the classic challenges in rendering: frustum culling.
    **Frustum culling** involves avoiding the rendering of objects that are outside
    the camera’s **field of view** (**FOV**). **Frustum** refers to the volume of
    space that is visible through the camera. **Culling** means discarding or ignoring
    objects that fall outside this frustum, thus they are not processed for rendering.
    Instead of the traditional approach, we’ll show you how to implement this directly
    on the GPU using compute shaders, ensuring objects outside the camera view do
    not consume valuable GPU resources. By the chapter’s close, you’ll have a holistic
    grasp of GPU-driven rendering, enabling you to harness the GPU’s capabilities
    to its fullest and streamline your rendering tasks.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing GPU-driven line rendering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expanding line-drawing techniques to render textual values from shaders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing text using SDF
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Frustum culling using compute shaders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you will need to make sure you have VS 2022 installed along
    with the Vulkan SDK. Basic familiarity with the C++ programming language and an
    understanding of OpenGL or any other graphics API will be useful. Please revisit
    [*Chapter 1*](B18491_01.xhtml#_idTextAnchor019)*, Vulkan Core Concepts*, under
    the *Technical requirements* section for details on setting up and building executables
    for this chapter. This chapter has multiple recipes, which can be launched using
    the following executables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Chapter03_GPU_Lines.exe`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Chapter03_GPU_Text.exe`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Chapter03_GPU_Text_SDF.exe`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Chapter03_GPU_Culling.exe`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implementing GPU-driven line rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn a technique that allows drawing lines directly
    from shaders such as vertex or fragment shaders. In many graphics applications,
    the challenge arises when one wishes to draw lines directly and efficiently using
    the inherent capabilities of shaders, particularly vertex or fragment shaders.
    To address this, our recipe delves into a specialized technique tailored for this
    very purpose. We’ll be presenting a recipe that seamlessly integrates with a variety
    of pipelines and render passes. Through our approach, data, be it vertices or
    colors, gets stored in a device buffer, ensuring a streamlined process. The culmination
    of this procedure is the utilization of this accumulated data in a subsequent
    pass, where these lines are then masterfully rendered onto a framebuffer. By the
    end, you will have a robust and efficient method to directly render lines using
    shaders.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before diving into the recipe, you should make sure you have VS 2022 installed
    and that you are able to build the repository as per the steps provided in [*Chapter
    1*](B18491_01.xhtml#_idTextAnchor019)*, Vulkan* *Core Concepts*.
  prefs: []
  type: TYPE_NORMAL
- en: You should be able to launch the executable named `Chapter03_GPU_Lines.exe`
    from VS 2022.
  prefs: []
  type: TYPE_NORMAL
- en: The code covered in this recipe can be found in the repository, in `chapter3/mainGPULines.cpp`
    and `chapter3/resources/shaders`, in the `gpuLines.frag`, `gpuLines.vert`, `gpuLinesDraw.frag`,
    and `gpuLinesDraw.vert` files.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we’ll guide you through the comprehensive procedure of directly
    drawing lines from shaders and integrating them into the final rendered frame
    using GPU-driven techniques. By leveraging a dedicated device buffer and carefully
    orchestrated render passes, this technique allows for real-time visual feedback
    and streamlined graphical processes. By the end of this walkthrough, you’ll have
    a robust mechanism in place for efficiently rendering lines directly from the
    GPU with minimal CPU involvement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea relies on having a device buffer that serves as a repository for lines
    and parameters for the indirect draw structure used to render those lines. After
    all render passes are complete, one additional render pass is performed to draw
    lines in the buffer. Here are the steps to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to create a buffer that will contain not only the line data
    but also metadata that is used for determining how many lines can fit into the
    buffer and other parameters used by the final indirect draw call. The following
    snippet defines the buffer structure in C++, with `GPULineBuffer` being the structure
    of the buffer used to store/draw lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This structure defines the device buffer we’ll use to store the GPU-generated
    lines and can store up to 65,536 lines plus the data in the `Header` section.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Figure 3**.1* shows the buffer’s layout as *seen* by the GPU:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.1 – The GPU lines’ buffer structure](img/B18491_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – The GPU lines’ buffer structure
  prefs: []
  type: TYPE_NORMAL
- en: 'This buffer is created with the following usage bits:'
  prefs: []
  type: TYPE_NORMAL
- en: '`VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_BUFFER_USAGE_STORAGE_BUFFER_BIT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VK_BUFFER_USAGE_TRANSFER_DST_BIT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This buffer should be made available to all render passes you wish to be able
    to draw/generate lines from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The provided code snippet initializes a `gpuLineBuffer` buffer using the Vulkan
    API. This buffer, created via the `context.createBuffer` method, is given a specified
    size (`kGPULinesBufferSize`) and is designated for multiple purposes, including
    indirect draw commands, shader data storage, and as a destination for buffer-to-buffer
    copy operations. Additionally, the buffer’s memory is set to reside on the GPU,
    ensuring fast access:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The function first checks for the next available index for storing the line
    information by retrieving the number of lines already in the buffer with `atomicAdd`.
    If the index returned by the function is greater than the maximum number of lines
    that can fit into the buffer, the function returns early and is a no-op. Otherwise,
    the line data is stored in the buffer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Rendering the lines is done with an extra render pass once all other passes
    have finished processing since the data from previous passes is required. The
    vertex shader code to render the lines looks like the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the preceding code, two structures are introduced: `Line` and `VkDrawIndirectCommand`.
    The `Line` structure represents a colored line segment, defined by two 3D endpoints
    (`v0` and `v1`) and their corresponding colors (`c0` and `c1`). The `VkDrawIndirectCommand`
    structure represents a Vulkan command for indirect drawing. The shader also establishes
    a `GPULinesBuffer` buffer containing an array of `Line` structures. In the main
    function, depending on the value of `gl_VertexIndex`, the shader selects the starting
    or ending point of a line instance and assigns the respective color to `outColor`.
    Also, notice how in this shader, we only define the `GPULinesBuffer` structure
    without the header structure. That’s because for drawing lines, we bind the buffer
    at an offset, bypassing the need to define the `Header` segment in the shader.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The fragment shader just outputs the color provided through the vertex shader:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before rendering the lines, we need to make sure that the previous steps have
    finished writing into the buffer, so we issue a buffer barrier:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, we issue an indirect draw command that derives its parameters directly
    from the buffer itself. We cleverly stored the number of lines stored in the buffer
    in the previous passes in `VkDrawIndirectCommand:: instanceCount`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final step consists of clearing the buffer, which is required for clearing
    the number of lines in the buffer (`VkDrawIndirectCommand:: instanceCount`). Before
    clearing the buffer, we must ensure that the GPU has finished drawing lines, which
    we can verify by issuing another buffer barrier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this recipe, we have unpacked a powerful technique for rendering lines directly
    from shaders. The utility of this method extends to diverse rendering applications,
    and it lays the groundwork for more advanced graphical outputs, elevating your
    skills to an even higher level in the realm of GPU programming using Vulkan.
  prefs: []
  type: TYPE_NORMAL
- en: Expanding line-drawing techniques to render textual values from shaders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Continuing from our previous exploration, where we developed the capability
    to draw lines directly from shaders, our next challenge is to further refine this
    capability to facilitate the rendering of text values. Drawing inspiration from
    the foundational concepts established in the preceding recipe, we aim to implement
    a methodology that permits the conversion of numerical values into line segments,
    much like digital LCD displays. By doing so, not only do we breathe life into
    bare numerical data, making it more visual and interpretable, but we also harness
    the power and efficiency of shaders in crafting these representations. Upon completion,
    you will be equipped with a robust toolset, allowing them to render clear, scalable,
    and visually appealing textual data, right from their shaders.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before diving into the recipe, you should make sure you have VS 2022 installed
    and that you are able to build the repository as per the steps provided in [*Chapter
    1*](B18491_01.xhtml#_idTextAnchor019)*, Vulkan* *Core Concepts.*
  prefs: []
  type: TYPE_NORMAL
- en: You should be able to launch the executable named `Chapter03_GPU_Text.exe` from
    VS 2022.
  prefs: []
  type: TYPE_NORMAL
- en: Since this recipe is heavily based on the previous recipe, we recommend reading
    the previous recipe on GPU line drawing first. The code covered in this recipe
    can be found in the repository, in `chapter3/mainGPUText.cpp` and `chapter3/resources/shaders`,
    in the `gpuText.frag`, `gpuText.vert`, `gpuTextDraw.frag`, and `gpuTexDraw.vert`
    files.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The idea is to decompose numbers into segments (like LCD segment displays)
    and print values by drawing lines for each digit. The previous recipe covered
    how to store and draw lines; this recipe builds on top of that to print numbers.
    Since in this recipe we need to draw numbers, we will need to parse numbers and
    decompose them into lines:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to use a strategy to represent digits with only lines. We chose
    to implement a simple 7-segment approach that can be used to display all digits
    from 0 to 9 plus a minus sign. We also added an extra segment to represent a decimal
    separator. *Figure 3**.2* shows the seven segments plus the decimal separator
    and their indices as used by the code in the shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Segments used to represent all digits from 0 to 9 plus a decimal
    separator and a minus sign](img/B18491_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Segments used to represent all digits from 0 to 9 plus a decimal
    separator and a minus sign
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the structures defined in the previous recipe, we will replace
    the `pad0` member of the `GPULinesBuffer` buffer so that it stores the row number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll also need the definition of the segments shown in *Figure 3**.2* as two
    vectors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Array `v` represents the coordinates of all vertices shown in *Figure 3**.2*
    normalized into the range [`-0.5`, `0.5`] in the *x* direction and [`-1.0`, `1.0`]
    in the *y* direction. Array `i` describes all segments and their vertices. For
    instance, the first element of the array describes segment 0 in the picture, from
    vertex 0 (`-0.5`, `1.0`) to vertex 1 (`0.5`, `1.0`).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `printSegment` function adds one segment, given its index, a scale, and
    a translation, to the GPU buffer where lines are stored:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This function calls the `addLine` function presented before to record the final
    vertices and colors of lines in the buffer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `printDigit` function prints all segments for a digit at a specific line
    and column, passed in as parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initially, it calculates the width and height of the characters in `switch`
    statement to decide which digit to print. The following snippet only shows how
    to print the digits 0 and 1, the decimal separator, and the minus sign for brevity:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code employs a switch-case structure to identify which segments
    should be activated based on the digit or symbol passed. For example, the number
    `0` requires several segments to depict its round shape. Therefore, when the digit
    is `0`, multiple `printSegment` calls are made to render each segment required
    for the `0` digit. Similarly, `1` is formed using two segments on its side. Beyond
    the digits, the function also has provisions to depict a decimal separator and
    a minus sign, distinguished by their unique segment arrangements.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `printNumber` function is designed to display an integer on a specified
    line, starting from a given column. After executing, it provides the next available
    column following the last digit printed. If the integer is zero, it simply prints
    `''0''`. For nonzero integers, the function efficiently computes the number of
    digits and iteratively prints each one, advancing the column accordingly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This function parses the integer parameter and prints each digit individually,
    while incrementing the `column` index.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, the `parse` function parses a float and prints it with a certain number
    of decimal places:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The function splits the float into two parts, the integer part and the decimal
    part, and prints them separately. If the number is negative, it prints the minus
    sign.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next step is to clear the buffer once the lines text has been rendered.
    In the previous recipe, we cleared the number of lines in the buffer. Here, we
    also need to clear the row number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last step is to use the `parse` function. Just call it from any shader
    that includes those functions. Each call to `parse` will print the value on a
    new line. *Figure 3**.3* shows the result of printing some values with the following
    code in the vertex shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following screenshot shows how we can use this technique for debugging
    purposes or to display text:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.3 – The result of printing values from the vertex shader](img/B18491_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – The result of printing values from the vertex shader
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we delved into the intricate process of representing numerical
    values using line segments, reminiscent of LCD displays. By breaking down numbers
    into their individual segments and leveraging our foundational line-drawing methods
    from shaders, we provided you with an innovative technique to visualize numbers.
    The end result is a seamless integration of numbers into your graphics, with clarity
    reminiscent of digital segment displays, enriching the overall visual experience.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing text using SDF
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we address the challenge of rendering crisp and scalable text,
    regardless of its size. By utilizing the principles of SDF, we transform traditional
    text rendering into a more fluid process, ensuring sharpness and clarity. The
    outcome is beautifully rendered text that remains clear and legible, whether you’re
    zooming in closely or viewing from a distance.
  prefs: []
  type: TYPE_NORMAL
- en: SDFs provide a way to represent surfaces. An SDF is basically a function that,
    for every point in space, returns the shortest distance to the surface of the
    shape. SDFs can be used for a variety of use cases such as volume rendering or
    to perform operations on shapes such as dilation, erosion, and other morphological
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, text is rendered using bitmap fonts. One can use a 2D canvas
    to render text and then use that as a texture to draw a quad in a 3D context.
    However, this method creates bitmaps that are resolution-dependent and need to
    be generated and uploaded to the device by the CPU. Each font style, such as bold,
    italics, and so on, also needs to be processed by the CPU, which causes an extra
    overhead for the computation and transfer of the textures for each style needed
    for rendering.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering text using SDFs is a modern approach that uses distance fields for
    each character. These are grids in which each of the values represents the distance
    from each pixel to the nearest edge of the character. SDFs help avoid all the
    problems mentioned before by offering resolution-independent scaling as well as
    using the GPU for most of the work. Styles such as bold, outline, and so on require
    only changes to shaders.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each letter of a font (a glyph) is described by a combination of straight lines
    and Bézier curves. One example of a glyph is shown in *Figure 3**.4*, which shows
    the detail of a glyph’s serif:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Detail of a glyph definition: circles, triangles, and squares
    represent the start and end points of each segment (curves or straight lines)](img/B18491_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.4 – Detail of a glyph definition: circles, triangles, and squares
    represent the start and end points of each segment (curves or straight lines)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Traditional SDF algorithms encode the distance from a pixel to the glyph’s
    boundary for each pixel in a grid, store that information in a texture, and upload
    that to the CPU. The algorithm presented in this recipe implements a different
    approach, in which the distances from a pixel to the nearest curves are computed
    on the GPU. To do that, each glyph in the font is preprocessed on the CPU against
    a grid of fixed size of 8 x 8 cells. This preprocessing detects curves that intersect
    each cell and stores the information in a 32-bit integer, as shown in *Figure
    3**.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Cell encoding stores the initial index of three separate curves
    that intersect the cell along with the length of each loop](img/B18491_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – Cell encoding stores the initial index of three separate curves
    that intersect the cell along with the length of each loop
  prefs: []
  type: TYPE_NORMAL
- en: Each cell contains the information of up to three loops that intersect it by
    storing the initial index of each loop plus their lengths. For example, the glyph
    shown in cell (2, 0) intersects two curves, curve 1 and curve 2\. The information
    encoded for that cell would contain the index to curve 1 and a length of 2\. The
    other indices would remain 0, as the cell doesn’t intersect any other curves.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram demonstrates how the letter *S* can be represented using
    glyphs:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 3.6 – Curves representing an \uFEFFS glyph; cell (2, 0) intersects\
    \ two curves: curve 1 and curve 2](img/B18491_03_06.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.6 – Curves representing an S glyph; cell (2, 0) intersects two curves:
    curve 1 and curve 2'
  prefs: []
  type: TYPE_NORMAL
- en: The vertex shader passes the cell indices for each corner of the rectangle to
    the fragment shader, which receives the interpolated coordinate of the cell, uses
    it to retrieve the information of which curve loops and their lengths to inspect,
    and calculates the minimum distance to each one of the curves in the three loops,
    choosing the minimum distance.
  prefs: []
  type: TYPE_NORMAL
- en: This information is then used to calculate the opacity of the current fragment,
    along with the color and the sharpness of the edge of the font.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we use a third-party library to capture the definition of the
    glyphs and store that information in a shader-friendly format. The library is
    authored by Dávid Kocsis and can be found here: [https://github.com/kocsis1david/font-demo](https://github.com/kocsis1david/font-demo).'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before diving into the recipe, you should make sure you have VS 2022 installed
    and that you are able to build the repo as per the steps provided in [*Chapter
    1*](B18491_01.xhtml#_idTextAnchor019)*, Vulkan* *Core Concepts.*
  prefs: []
  type: TYPE_NORMAL
- en: You should be able to launch the executable named `Chapter03_GPU_Text_SDF.exe`
    from VS 2022.
  prefs: []
  type: TYPE_NORMAL
- en: A complete example with the code covered in this recipe can be found in the
    repository, in `chapter3/mainGPUTextSDF.cpp`, `chapter3/FontManager.hpp`, `chapter3/FontManager.cpp`,
    and `chapter3/resources/shaders`, in the `font.frag` and `font.vert` files.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The steps to render text using SDFs on the device are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The initial task involves loading the font file through the `FreeType` library.
    This step is crucial because it’s where we obtain the glyph data for each character.
    Glyph data, in essence, represents the basic design of a character in a font,
    describing its unique shape and appearance. Once we have this, the subsequent
    objective is to transform this glyph data into outline data. The outline data
    captures the essence of the glyph’s shape, breaking it down into components such
    as points, cells, and a bounding box specific to each character. These components
    essentially dictate how a character will be rendered on a screen or display. To
    achieve this transformation from `FreeType`’s intricate glyph data to more structured
    outline data, we employ the `fd_outline_convert` function. The data for each character
    is combined into a single stream of points and cells that is uploaded to the GPU
    as a *vertex buffer*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The code delves deeply into font rendering by handling the glyphs, which are
    the backbone of font representation. One of the main elements here is the point
    data. This crucial piece captures every point that makes up the Bézier curves
    of each glyph. Right now, our focus is mainly on the uppercase letters. But looking
    at how the code is structured, it’s clear that we could easily expand it to embrace
    other characters if we wished to. Parallel to the point data, we also work with
    the cell data. It has a special role when we’re in the rendering phase, especially
    in the fragment shader. It’s this data that aids in navigating the curves that
    intersect with a given cell, making sure that every glyph is depicted accurately
    and precisely on the screen. All in all, by marrying the point and cell data with
    the capabilities of the fragment shader, we’re able to render the font’s visual
    intricacies effectively.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we build a buffer that contains the bounding rectangles of each glyph.
    This buffer serves as the vertex buffer, and we draw as many instances as the
    number of characters in the display string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the following step, we transfer the points, cell data, glyph data, and string
    to the GPU as separate buffers. Subsequently, we execute a `vkCmdDraw` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The vertex shader needs access to an array of glyph data (`GlyphInfo`) that
    is packed into the `glyph_buffer` buffer. The other inputs are `in_rect`, `in_glyph_index`,
    and `in_sharpness`, which come from the *vertex buffer*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding vertex shader is tailored for glyph rendering. The shader works
    with a structure named `GlyphInfo` that encapsulates information about each glyph,
    including its bounding box and details related to the cell positioning of the
    glyph. Within the `main` function, the shader fetches data for a specific glyph
    using an input index. It subsequently determines the positions of both the input
    rectangle’s corners and the corresponding glyph’s bounding box and calculates
    the cell coordinates for the glyph. Using `gl_VertexIndex`, which indicates which
    vertex of the rectangle is currently being processed, the shader sets the position
    for that vertex and assigns necessary values to the output variables. This preprocessed
    information is leveraged by the fragment shader to produce a final visual representation
    of the glyph.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next are the steps for calculating the text’s glyph color using the fragment
    shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculates the cell index for a given fragment/pixel.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetches the cell from the cell buffer based on the cell index.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Calculates the SDF of the cell from the glyph’s bounding box. Based on the
    distance, an alpha value is computed:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'The result of the recipe can be seen in *Figure 3**.7*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.7 – The output of the recipe](img/B18491_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – The output of the recipe
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we showcased the application of SDF for rendering text with
    the assistance of a GPU.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inigo Quilez demonstrates how to use SDFs to create shapes in an excellent
    video:'
  prefs: []
  type: TYPE_NORMAL
- en: https://www.youtube.com/watch?v=8--5LwHRhjk
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple libraries that generate SDF textures – for example, [https://libgdx.com/wiki/tools/hiero](https://libgdx.com/wiki/tools/hiero)
    and https://github.com/Chlumsky/msdfgen.
  prefs: []
  type: TYPE_NORMAL
- en: Frustum culling using compute shaders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will show how to do frustum culling using the GPU and compute
    shaders.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the world of real-time rendering, efficient rendering is key to achieving
    smooth performance and high-quality visuals. One of the most widely used techniques
    to optimize rendering is frustum culling. Frustum culling is a process that improves
    rendering speed by ignoring or *culling* objects that are not visible within the
    camera’s FOV, or *frustum*. The following diagram demonstrates it visually:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – Frustum culling works by ignoring objects that fall outside
    of the camera’s view (the frustum)](img/B18491_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – Frustum culling works by ignoring objects that fall outside of
    the camera’s view (the frustum)
  prefs: []
  type: TYPE_NORMAL
- en: Frustum culling works by testing each object in the scene to see if it lies
    within the camera’s frustum. If an object is entirely outside the frustum, it
    gets culled; that is, it’s not drawn. This can significantly reduce the number
    of primitives that need to be drawn. Traditionally, culling was done on the CPU,
    but this meant it needed to be done every time the camera moved. We demonstrate
    culling by using the compute shader, eliminating the need to upload data from
    the CPU to the GPU every time the view changes. Compute shaders do not necessarily
    need to be related to rendering and can process data structures and perform operations
    such as sorting, physics simulations, and, in our case, frustum culling.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before diving into the recipe, you should make sure you have VS 2022 installed
    and that you are able to build the repository as per the steps provided in [*Chapter
    1*](B18491_01.xhtml#_idTextAnchor019)*, Vulkan* *Core Concepts.*
  prefs: []
  type: TYPE_NORMAL
- en: You should be able to launch the executable named `Chapter03_GPU_Culling.exe`
    from VS 2022.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe is based on the *Implementing Programmable Vertex Pulling and Multi-Draw
    Indirect* recipe from [*Chapter 2*](B18491_02.xhtml#_idTextAnchor126)*, Working
    with Modern Vulkan.* The code covered in this recipe can be found in the repository,
    in `chapter3/mainCullingCompute.cpp`, `chapter3/CullingComputePass.cpp`, and `chapter3/resources/shaders`,
    in the `gpuculling.comp`, `indirectdraw.frag`, and `indirectdraw.vert` files.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will be building on a recipe from [*Chapter 2*](B18491_02.xhtml#_idTextAnchor126)*,
    Working with Modern Vulkan.* that implemented Multi-Draw Indirect. We demonstrated
    during that recipe the use of `vkCmdDrawIndexedIndirect`. In this recipe, we will
    use a command that derives the number of its parameters from a device buffer,
    `vkCmdDrawIndexedIndirectCount`. This Vulkan API lets you specify a GPU buffer
    that contains the draw count instead of providing it by the CPU.
  prefs: []
  type: TYPE_NORMAL
- en: 'This recipe’s technique relies on three buffers: the first two each contain
    the indirect draw parameters’ structures, `InputIndirectDraws` and `OutputIndirectDraws`
    respectively; the third one contains the number of meshes to be rendered. The
    first buffer contains the parameters for all meshes in the scene. The second buffer
    is populated by the compute shader: meshes that are *not* culled have their indirect
    parameters atomically copied from the `InputIndirectDraws` buffer to `OutputIndirectDraws`;
    meshes that are culled don’t have their parameters copied:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – Top buffer: all mesh parameters; bottom buffer: unculled meshes
    set to render](img/B18491_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.9 – Top buffer: all mesh parameters; bottom buffer: unculled meshes
    set to render'
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the compute shader needs information about each mesh’s bounding
    box and their center, and the six planes of the frustum. With this information,
    the compute pass can cull (or not) each mesh. At the end of the pass, the `OutputIndirectDraws`
    buffer contains parameters only for the meshes that will be rendered and is used
    by the indirect draw command.
  prefs: []
  type: TYPE_NORMAL
- en: Next is the recipe broken down into steps, along with snippets from `mainCullingCompute.cpp`.
    It provides a high-level view of how culling and drawing passes are used in tandem
    to perform frustum culling using compute shaders in Vulkan. The compute shader
    takes care of determining which meshes should be drawn, and then the graphics
    pipeline takes care of drawing those meshes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialize the culling pass by using scene information and a scene buffer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first step consists of initializing the two buffers shown in *Figure 3**.9*
    and uploading them to the device. The details are encapsulated by the `CullingComputePass`
    class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The compute pass is also encapsulated by the `CullingComputePass` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will discuss the cull method shown next in more detail.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To prevent a race condition between the compute pass and the rendering pass,
    we add a barrier for the culled indirect draw and the draw count buffer. This
    is necessary because the subsequent drawing commands rely on the results of the
    culling pass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The draw call is recorded with the `vkCmdDrawIndexedIndirectCount` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Having grasped the essential elements of code for the culling pass, let’s delve
    into its operational mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `CullingComputePass::cull` method is responsible for updating frustum data,
    binding the compute pipeline, updating push constants, and calling `vkCmdDispatch`.
    `vkCmdDispatch` dispatches the compute work to the GPU. The compute work is divided
    into smaller units, each of which is called a workgroup. The `(pushConst.drawCount
    / 256) + 1, 1, 1)` parameters specify the number of workgroups that are dispatched
    in the *x*, *y*, and *z* dimensions, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CullingComputePass::addBarrierForCulledBuffers` method adds a pipeline
    barrier that ensures the culling operation has finished before the results are
    read. The barrier is set up so that it blocks the indirect command read access
    (which will be used in the draw call) until the shader write (the culling operation)
    has completed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the compute shader, we need a function that tells whether a bounding box
    falls completely outside of the frustum by comparing its extents and its center
    point against the six planes of the frustum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If the mesh is culled, the function returns early. Otherwise, it atomically
    increments the number of visible meshes in the `IndirectDrawCount` buffer and
    copies the indirect draw parameters from the input to the output buffer using
    the previous number of meshes in the buffer as the index of the destination.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only remaining work for the main function is to call `cullMesh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Through this recipe, we’ve harnessed the power of the GPU to effectively filter
    out non-essential objects, optimizing our rendering workflow. By implementing
    this method, you will achieve a more responsive and resource-efficient visualization,
    especially vital for intricate 3D scenes.
  prefs: []
  type: TYPE_NORMAL
