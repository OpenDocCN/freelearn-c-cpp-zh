<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-68"><a id="_idTextAnchor068"/>5</h1>
<h1 id="_idParaDest-69"><a id="_idTextAnchor069"/>Forgetting Tick</h1>
<p>In this chapter we are going to explore the topic of tick (an event or process that is called every frame), why using it can cause frame-rate issues for our game projects, and two approaches to building systems without using tick, reducing the impact of systems on the CPU. We will consider the example of a guard tower in an RTS game, with a searchlight rotating back and forth. If the player’s unit is seen by the searchlight, it will stop its rotation. We will start with the Update pattern introduced in the previous chapter and iteratively improve from there, reducing our reliance on the Update pattern by using Timers, Timelines, and event-driven solutions instead. At each step, we will measure code efficiency, using execution counting to quantify our improvements.</p>
<p>In this chapter, we’ll cover the following topics:</p>
<ul>
<li>Tick events and the challenges we face when using them</li>
<li>Timers and Timelines</li>
<li>Event-driven systems</li>
</ul>
<h1 id="_idParaDest-70"><a id="_idTextAnchor070"/>Technical requirements</h1>
<p>In this chapter, we will focus on the Guard Tower classes in the <a href="B18297_05.xhtml#_idTextAnchor068"><em class="italic">Chapter 5</em></a> folder of the project, linked via GitHub, that we downloaded for previous chapters. If you haven’t followed along with the developments in the previous chapters, you can download a version of the project, ready to start the <a href="B18297_05.xhtml#_idTextAnchor068"><em class="italic">Chapter 5</em></a> tutorials from the <code>chapter5</code> branch on GitHub at <a href="https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter05">https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter05</a></p>
<h1 id="_idParaDest-71"><a id="_idTextAnchor071"/>Before we begin</h1>
<p>In this class, we will use a new smart pointer type. <code>TObjectPtr&lt;&gt;</code> is the Unreal Engine 5 standard<a id="_idIndexMarker187"/> way of dealing with components held on an actor. The prior standard was to use raw pointers, but this will no longer work with the new garbage collector, as the new system provides reference tracking to detect when an object is actually used. This can mean that objects only stored in raw pointers get mistaken for de-referenced memory and can be deleted while still in use.</p>
<p>Within functions, we will still use raw pointers, as these variables will go out of scope, and so the garbage collector is not necessary to free their memory. Member variable object references will be <a id="_idIndexMarker188"/>stored as <code>TObjectPtr&lt;&gt;</code> and asset references <a id="_idIndexMarker189"/>stored as <code>TSoftObjectPtr&lt;&gt;</code>.</p>
<h1 id="_idParaDest-72"><a id="_idTextAnchor072"/>A world that ticks</h1>
<p>In the last chapter, we covered the idea of the Update pattern. When using the Update pattern, we design with the philosophy that lots of different types of classes need to execute code on each frame. To achieve this, we will use an update function or, in the case of Unreal, a <strong class="bold">Tick Event</strong>. This<a id="_idIndexMarker190"/> pattern provides a fast way to make things happen, which is why it has a certain gravity, pulling many learning resources into leaning on it heavily. The volume of learning materials doesn’t make this a good idea, but it does allow systems to be propped up quickly, thus making learning from resources like this easy to understand. The problem lies in the seeming loss of understanding, over the cost of relying on this method. When we place any nodes or lines of code under the purview of tick, we need to remember it runs once per frame. On modern machines this equates to an average of 60 times a second, but it can vary depending on hardware, which is an important consideration for developers. For small games on modern hardware, the odd variable set or transform change may be fine; however, this is significantly more concerning if you consider the impact of a loop. This should make it clear that, as powerful as tick may seem, a web of problems lies beneath its surface.</p>
<p>To <a id="_idIndexMarker191"/>illustrate the problem, let’s look at the <code>AGuardTower_CH5_1</code> actor in the <a href="B18297_05.xhtml#_idTextAnchor068"><em class="italic">Chapter 5</em></a><code> </code>folder. We have followed best practice with the header file, using forward declared classes for member component definitions and the most limited property specifiers that we can. You will probably notice though that the only function, bar the constructor, is <code>Tick</code>. In this function, we carry out all our searchlight functionality. Stepping through the tick function on the searchlight, we have the following:</p>
<ul>
<li>A call to the parent Tick</li>
<li>A sphere trace that gets reference to any actor that falls within the rough area of the light</li>
<li>A check to see whether the detected actor is of the player pawn type</li>
<li>Code <a id="_idIndexMarker192"/>branches to rotate the searchlight in every direction when the player has not been found</li>
</ul>
<p>The <code>GuardTower</code> body file contains a <code>tick</code> function which looks like this:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">GuardTower_CH5_1.cpp Tick function</p>
<pre class="source-code">
void AGuardTower_CH5_1::Tick(float DeltaTime)
{
    Super::Tick(DeltaTime);
    FVector startLocation = _Arrow-&gt;GetComponentLocation();
    FVector endLocation = _Arrow-&gt;GetComponentLocation() +         (_Arrow-&gt;GetForwardVector() * _DetectionRange);
    FHitResult hit;
    UKismetSystemLibrary::SphereTraceSingle(GetWorld(),startLocation,
    endLocation,_DetectionRadius, UEngineTypes::
        ConvertToTraceType(ECC_Visibility), false, {},
            EDrawDebugTrace::ForOneFrame,hit, true);
    ACharacter* otherCasted = Cast&lt;AEliteUnit&gt;(hit.GetActor());
    _EnemySpotted = (otherCasted != nullptr);
    if (!_EnemySpotted)
    {
        if (_RotateForward)
        {
            _LightPivot-&gt;AddLocalRotation(FRotator(0.0, 0.2, 0.0));
            if (FMath::IsNearlyEqual                 (_LightPivot-&gt;GetRelativeRotation().Yaw, 40.f))
            {
                _RotateForward = false;
            }
        }
        else
        {
            _LightPivot-&gt;AddLocalRotation(FRotator(0.0, -0.2, 0.0));
            if (FMath::IsNearlyEqual                 (_LightPivot-&gt;GetRelativeRotation().Yaw, -40.f))
            {
                _RotateForward = true;
            }
        }
    }
}</pre> <p>This <a id="_idIndexMarker193"/>code does run, and you can see that if you drag an instance of <code>BP_GuardTower</code> into the level provided in the <a href="B18297_05.xhtml#_idTextAnchor068"><em class="italic">Chapter 5</em></a> folder. However, there are some issues, so let’s break down these problems in order:</p>
<ul>
<li>With all the logic being on tick, we are performing some costly actions often. A sphere trace on its own is not too costly, but if we perform that sphere trace once per frame, per guard tower in a scene, the computational cost can add up quickly.</li>
<li>Quite a few getter functions are repeatedly used without caching. The world pointer could have been cached on <code>BeginPlay</code>, as that is unlikely to change, and multiple calls to the arrow component’s location could be done once. These are only minor improvements.</li>
<li>Casting is nowhere near as costly as it used to be in the early days of Unreal Engine. That said, when casting to a class, the target class must be loaded to ensure a match. This must be kept in mind when casting to a large class, as it can inflate the size of the process in RAM. Alternatives could include casting to an interface if you only need some functionality, checking tags if it is just a validity check, or, even better, trying to flip the communication on its head and remove the need to cast.</li>
<li>We then have a pattern that we will refer to as <strong class="bold">gated polling</strong>. On tick, check to see whether a block of code needs to run; if so, run it. This gated polling<a id="_idIndexMarker194"/> pattern is repeated a couple of times for different blocks of code. The alarm bells should now be ringing but maybe for the wrong reason. Yes, we have a repeated pattern of code, and we previously talked about avoiding repetition; that isn’t the real issue here. Any time we process something that may or may not need to happen, we guarantee a wasted check on some frames when it fails. We should consider how we can avoid the check and only process the code when it does need to happen.</li>
<li>Lastly, we have <a id="_idIndexMarker195"/>a compound problem with each branch of the gated poll. Yes, we are hardcoding values, both the rotation limit and the speed of rotation. Turning the hardcoded <code>0.2</code> and <code>40</code> into float member variables called <code>_RotationSpeed</code> and <code>_RotationLimit</code> respectively is a simple fix for the first part. Adding <code>EditAnywhere</code> to the <code>UPROPERTY()</code> block above each new variable will allow designers to not only balance the values in the actor but also create varied instances in their levels. This still leaves an issue with our code. Tick is not constant, yet we are using a constant value for rotation. This is where <code>DeltaTime</code> comes in. It is an argument of tick passed in as the time since the last frame rendered. Multiplying values by this will cause them to be applied evenly across 1 real-world second.</li>
</ul>
<p>It should be pretty clear that there is a lot of room for improvement with this code, but how much room? Back in <a href="B18297_03.xhtml#_idTextAnchor046"><em class="italic">Chapter 3</em></a>, we discussed Big O notation, but to get a higher resolution analysis, we need to calculate the <em class="italic">T(n)</em> or time efficiency of the algorithm. This should provide us with a baseline to prove that we can quantifiably do better.</p>
<p>The first<a id="_idIndexMarker196"/> sphere trace section contains roughly three assignments, six function calls, three arithmetic operations, and the internal time of a sphere trace. The cast section is two function calls, one test, and one assignment. In the <code>if</code> block, both branches are basically the same number of executions, so we will only count the top branch, giving us two tests, four function calls, and one assignment. Altogether, this makes roughly 23 + 1 * sphere trace executions per frame, with no overhead beyond a standard setup. Over a second at 60 <strong class="bold">frames per second</strong> (<strong class="bold">FPS</strong>), we would be<a id="_idIndexMarker197"/> running 1380 + 60 * sphere trace executions.</p>
<p class="callout-heading">Important note</p>
<p class="callout">You can find the full working solutions for the following two sections under the <code>_2</code> and <code>_3</code> versions of the <code>GuardTower_CH5</code> class, but try to follow along with this section, making changes to the <code>_1</code> version to get the most out of the chapter.</p>
<p>Now that we’ve reviewed the problems with using Tick for the guard tower, let’s begin to look at how we can fix it, removing our reliance on Tick and writing better code.</p>
<h1 id="_idParaDest-73"><a id="_idTextAnchor073"/>A clock that stops</h1>
<p>Now, we’ll deal with this gated polling issue. The<a id="_idIndexMarker198"/> go-to solutions for this are <code>UKismetSystemLibrary</code>, where you will see that simply calling it is a bit of a hassle. Timers will perform a check on each frame they are active to see whether the function they point at should fire yet. This can be a useful behavior for dynamically set delays or systems where you only want a signal after a set amount of time, such as a countdown to decrease once per second instead of once per frame. Timelines, however, provide <a id="_idIndexMarker201"/>a way of processing a behavior, similar to an update while a curve is being queried. The length of these curves is predetermined, although the play speed of the Timeline can be altered to achieve a dynamic length. Timelines can also hold multiple types of tracks, which will all be synchronized when playing, allowing a single Timeline to drive a lot of elements. This provides a better fit for our problem, as we need to retain the update behavior but with a smaller footprint, reducing the number of checks we perform each frame.</p>
<p>Looking at the following code, we can see that to set up a Timeline in C++, we start by adding the following variables and functions to our header to facilitate the Timeline. It may seem at first glance that adding this much to a class would slow the process down, but each element has its part to play. The first two variables are delegates and will provide us with a way of linking functions to the Timeline dynamically. These are followed by the functions we will link. This pattern follows a naming convention described as follows to aid future readability:</p>
<ul>
<li><code>On&lt;object name&gt;&lt;delegate purpose&gt;</code> for the delegate</li>
<li><code>Handle_&lt;object name&gt;&lt;delegate purpose&gt;</code> for the linked function</li>
</ul>
<p>The following two functions, <code>StartRotation</code> and <code>StopRotation</code>, are simply there to act as wrappers for the Timeline methods.</p>
<p>The Timeline<a id="_idIndexMarker202"/> itself is created as <code>TObjectPtr&lt;&gt;</code>, allowing for forward-looking reference tallying and safer garbage collection. The property specifiers on this also don’t matter too much, as we access all the functionality we need through functions we have created. The last variable is  <code>TSoftObjectPtr&lt;&gt;</code> to <code>UCurveFloat</code>. This type is used by the engine to store a spline in 2D space as a set of keyframes with tangents. We will use it to drive our searchlight angle over time, but we want a designer to have access to make changes. This means we need to store the variable as a reference to an asset that does not yet exist, hence the <code>TSoftObjectPtr&lt;&gt;</code> wrapper. Setting this as <code>EditAnywhere</code> will allow the default value and the instance variants to be set via their respective editor panels:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">GuardTower Timeline Header</p>
<pre class="source-code">
private:
    FOnTimelineFloat onTimeline_Update;
    FOnTimelineEventStatic onTimeline_Finished;
    UFUNCTION()
    void Handle_RotateLight_Update(float val);
    UFUNCTION()
    void Handle_RotateLight_Finished();
    void StartRotation();
    void StopRotation();
protected:
    UPROPERTY()
    TObjectPtr&lt;UTimelineComponent&gt; T_RotateLight;
    UPROPERTY(EditAnywhere)
    TSoftObjectPointer&lt;UCurveFloat&gt; _Curve;</pre> <p>Now, we will <a id="_idIndexMarker203"/>turn our attention to the <code>GuardTower</code> constructor implementation shown here. We need to create the Timeline component in the constructor. Then, our delegate handles need to be bound to the listener functions. Binding like this will allow rebinding later down the line as necessary, while any class derived from this will always have a default response. It is also worth noting that binding is done via function names created as <code>FName</code> types. This will make spelling and capitalization important, and it is unlikely that your IDE will have auto-complete functionality for these:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">GuardTower Timeline Constructor</p>
<pre class="source-code">
T_RotateLight = CreateDefaultSubobject&lt;UTimelineComponent&gt; (TEXT("T_RotateLight"));
onTimeline_Update.BindUFunction(this, FName("Handle_RotateLight_Update"));
onTimeline_Finished.BindUFunction(this, FName("Handle_RotateLight_Finished"));</pre> <p>We cannot do any more setup inside the constructor, as we are blocked by the fact that we could not have set a value for the <code>_Curve</code> variable yet. This will require linking in the editor, which forces the rest of the initialization process into the <code>BeginPlay</code> method.</p>
<p>The first thing to consider is that the variable may not have had a value set at all, which would invalidate the need to continue any setup. Instead of nesting all the code inside a positive conditioned <code>if</code> statement, we will reverse the condition to check for a negative condition and plug in an early return. This makes our code more human-readable and reduces the amount of information we need to keep in mind while constructing the function.</p>
<p>Following that, the<a id="_idIndexMarker204"/> Timeline needs to have a few things set up, as shown in the following code block. Any tracks that it should be running need to be added. Here, we will add a float track based on whatever asset the <code>_Curve</code> variable references. This needs to be injected with the delegate it will call whenever its value changes and the name of the track for future reference. Here, we will plug in the update delegate, <code>onTimeline_Update</code>, and a new <code>FName</code> value that makes sense for our usage. The same then needs to be done for the timeline’s finished callback. It is slightly different from the other function in that it doesn’t require a curve or a name, just a callback. So, all we do here is insert the finished delegate, <code>onTimeline_Finished</code>.</p>
<p>In this case, we also need to set the looping nature to <code>false</code> and the ignore time dilation property to <code>true</code>. We will control how the Timeline replays, so there is no need for any auto behavior, and the other variable is mainly there to show what sort of control you can get with a timeline. There are plenty of other properties to fiddle with to fine-tune how timelines behave, so it is well worth your time exploring the type header for functions.</p>
<p class="callout-heading">Useful tip</p>
<p class="callout">If you want to explore type or class headers, define a variable of that type anywhere in your code. This will allow you to right-click the type and select <strong class="bold">Go To Definition</strong> (<em class="italic">F12</em> in Visual Studio and Rider).</p>
<p>All these changes should lead you to a<code> Beginplay </code>setup for the Timeline that looks like the following code:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">GuardTower Timeline Setup</p>
<pre class="source-code">
Super::BeginPlay();
if (_Curve == nullptr)
{
    return;
}
T_RotateLight-&gt;AddInterpFloat(_Curve, onTimeline_Update,     FName("Alpha"));
T_RotateLight-&gt;SetTimelineFinishedFunc(onTimeline_Finished);
T_RotateLight-&gt;SetLooping(false);
T_RotateLight-&gt;SetIgnoreTimeDilation(true);
StartRotation();</pre> <p>Now, we need to fill <a id="_idIndexMarker205"/>out the callback handler functions, which are quite simple in nature – one to rotate the light on its killable update and the other to change the light’s direction when it reaches the rotation limit:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">Callback handler functions</p>
<pre class="source-code">
void AGuardTower_CH5_3::Handle_RotateLight_Update(float val)
{
    _LightPivot-&gt;SetRelativeRotation(
    FRotator(0.f, FMath::Lerp(-40.f, 40.f, val), 0.f));
}
void AGuardTower_CH5_3::Handle_RotateLight_Finished()
{
    _RotateForward = !_RotateForward;
    StartRotation();
}</pre> <p>The last thing we need to do is call the <code>StartRotation()</code> function to start the Timeline. The body of this simply calls the timeline’s <code>Play()</code> function if <code>_RotateForward</code> is <code>true</code>; otherwise, it calls <code>Reverse()</code>. We also have a wrapper for the <code>Stop()</code> function, but this provides no benefit beyond being good practice for later development, all it does is call the <code>Stop()</code> function on the timeline. With that done, we can delete the nested <code>if</code> statements at the end of our old <code>tick</code> function, add a <code>StopRotating()</code> call to our sphere trace where it sets <code>_EnemySpotted</code> to <code>true</code>, and head to the editor to link up our <code>_Curve variable</code> with an asset.</p>
<p>With the Timeline working, we can leverage some of its other features to improve the gameplay as well. The old rotation behavior on tick was very linear and not good for gameplay. Controlling the rotation with an f-curve telegraphs future actions to the player. As the rotation slows, the player gets an innate understanding that the light is about to swap <a id="_idIndexMarker206"/>direction and can plan accordingly. This concept of <code>C_GuardTower_RotAlpha</code> and can be found with the guard tower class in the <a href="B18297_05.xhtml#_idTextAnchor068"><em class="italic">Chapter 5</em></a> folder. The curve is a simple f-curve with flat tangents on start and end points, covering (<code>0,</code> <code>0</code>) to (<code>5,</code> <code>1</code>), as shown in <em class="italic">Figure 5</em><em class="italic">.1</em>.</p>
<div><div><img alt="Figure 5.1 – The C_SearchLightRotation curve asset in the curve editor window" src="img/Figure_05.01_B18297.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – The C_SearchLightRotation curve asset in the curve editor window</p>
<p>Now that we have <a id="_idIndexMarker208"/>changed the old, gated polling out for a Timeline system, we should recalculate the <em class="italic">T(n)</em> performance. We removed two tests, four function calls, and one assignment, bringing the total down to 16 + 1 * sphere trace. Then, we added a timeline, which is worth one test and one function call per frame, one test and six function calls that will run one time, one test, and two function calls that will currently run once every 5 seconds. Simply adding the values back together makes the situation look worse, giving us a 28 + 1 * sphere trace, but this is wrong. The new code will not run as regularly as the old, and when multiplying it out by the correct frequencies, you get (60 * (18 + 1 * sphere trace)) + (3 / 5) = ~1081 + 60 * sphere trace per second, plus 7 overhead. This is roughly a 22% improvement on the first implementation.</p>
<p>This is good, but we still have a problem. There is still something we are doing every tick: the sphere trace. Every frame this projects a sphere through space to see whether the player’s character is in “view” of the tower. This setup mirrors our previous problem of gated polling. Every frame, we run the test. If the player is overlapped, we fire the seen logic. If the player is not detected or is just out of sight, then nothing happens, and that sphere trace we checked was wasted.</p>
<p>The following section will go through the process of improving this and the architectural decisions that govern which route to take when considering efficiency versus design.</p>
<h1 id="_idParaDest-74"><a id="_idTextAnchor074"/>Event driven systems</h1>
<p>A software engineer’s job is to solve<a id="_idIndexMarker209"/> problems. Most of the time, this means special treatment in certain cases to make sure eventualities are handled. Sometimes, perfection is found, and the problem is not solved but erased from existence. In our current system, we want to solve the problem of needing to trace a sphere through our world for the player in every frame.</p>
<p>The question is not, <em class="italic">how do we make this more efficient?</em> Instead, we should be asking, <em class="italic">why sphere trace?</em> There isn’t really a clear answer to this. Yes, it allows us to check the volume of space for a player, but so do colliders. Yes, we can check all the space between the light mesh and the floor, but in our game, the player cannot jump. Yes, we can tell whether there are objects blocking a view of the player, but so can a cheaper line trace on the frames when we are not sure.</p>
<p>From these three answers, we can form a new solution. In principle, we will attach a sphere collider, as it’s the cheapest primitive to use, to the light. As the light swings, so does the attached collider. When the collider overlaps the player, we use a line trace from the light to the player to see whether there is a clear line of sight. This effectively flips the interaction between the searchlight and the player on its head. No longer does the searchlight ask the world whether it can see the player every frame. Now, the world will tell the searchlight only when the player is seen.</p>
<p>Walking through our implementation, we will link a handler function to our new sphere component’s <code>onComponentBeginOverlap</code> event. This handler function, detailed in the following code, starts with an early exit in case we have already collided with a player unit. If so, then we can ignore future collisions. In a larger scenario with more colliders in the scene, you may want to ignore this check and move on to incrementing a counter instead, as the searchlight is big enough to cover multiple units at once. We then cast the overlapped actor to the class we know the player will use. This, again, could be switched to a check for <code>teamID</code> or some similar group-identifying value. This would allow multiple players or factions to use the same units. The next few lines set up the values for and execute a line trace through the world, from the light position to the center of the unit we have just overlapped with. This is done because the collider we will swing around has no idea of the map it is on and where any vision-blocking walls may be. We will use the line trace as another early return because if it does hit something, that means we can ignore the player collision due to a mesh blocking vision. With a clear line of sight established, we then simply set the <code>_EnemySpotted</code> variable to <code>true</code> and stop the timeline-driven rotation. This would be where you would link into something like an alert<a id="_idIndexMarker210"/> system to draw the attention of nearby friendly units.</p>
<p>Let's start with the Begin Overlap:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">GuardTower Sphere Begin Overlap function</p>
<pre class="source-code">
if (_EnemyUnit != nullptr)
{
    return;
}
_EnemyUnit = Cast&lt;AEliteUnit&gt;(OtherActor);
if (_EnemyUnit == nullptr)
{
    return;
}
FHitResult hit(ForceInit);
FVector start = _Arrow-&gt;GetComponentLocation();
FVector end = _EnemyUnit-&gt;GetActorLocation();
if (UKismetSystemLibrary::LineTraceSingle(
        GetWorld(), start, end,
        UEngineTypes::ConvertToTraceType(ECC_Visibility),
        false, {_EnemyUnit}, EDrawDebugTrace::ForDuration, hit,
        true, FLinearColor::Red, FLinearColor::Green, 0.5f))
{
    return;
}
_EnemySpotted = true;
StopRotation();</pre> <p>The <code>onComponentEndOverlap</code> equivalent event is handled by the function shown in the following code block and is much smaller, as it only needs to check that the actor leaving the collision<a id="_idIndexMarker211"/> is the one that triggered the alarm in the first place. Then, it can reset the <code>_EnemySpotted</code> and <code>_EnemeyUnit</code> variables, followed by continuing the Timeline rotation code:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">GuardTower Sphere Overlap End</p>
<pre class="source-code">
if(_EnemyUnit != OtherActor) {
    return;
}
    _EnemySpotted = false;
    _EnemyUnit = nullptr;
    StartRotation();</pre> <p class="callout-heading">Important note</p>
<p class="callout">Component overlap functions were explored at the end of <a href="B18297_01.xhtml#_idTextAnchor016"><em class="italic">Chapter 1</em></a>. Remember to bind only functions matching <code>FComponentBeginOverlapSignature</code> and <code>FComponentEndOverlapSignature</code>, respectively. The arguments used in the sample code follow this pattern: <code>UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool FromSweep, const FHitResult&amp; SweepResult</code> for the begin overlap, which we can see are the same, minus the last two arguments for the end overlap.</p>
<p>This last change, from traces to colliders, calls for another recalculation of the <em class="italic">T(n)</em> performance. We repositioned the rest of the functionality in the Tick function completely, leaving only the Timeline update running. This drops our per frame executions to 2! The processing hasn’t been completely removed though. In the worst-case scenario, the player would overlap with the sphere collider and leave the interaction within a second, meaning all the code could fire. This would be equivalent to four assignments, eight function calls, three tests, and 1 * line trace on begin overlap and two assignments, one function call, and one test on end overlap. This, plus the four function calls to set up the new component and bind these functions, detailed in the following code, brings our cost to 2 per frame, 19 + 1 * line trace per second, and 3 per 5 seconds. This makes (60 * 2) + (19 + 1 * line trace) + (3 / 5) = ~140 + 1 * line trace per second, with an overhead setup cost of 11. This is a massive 90% improvement on the first implementation, showing how a change in approach can make a massive impact on performance, even though it may seem like more has been created. For reference, the following code can be used to link handler functions to the relevant component overlap events if you need a syntax example. Your functions may have different names, but these lines must run for the callback to work:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">GuardTower constructor new lines for sphere component setup</p>
<pre class="source-code">
_Sphere = CreateDefaultSubObject&lt;USphereComponent&gt;(TEXT("Sphere"));
_Sphere-&gt;SetupAttachment(_LightMesh);
_Sphere-&gt;OnComponentBeginOverlap.AddDynamic(this, &amp;AguardTower_CH5_3::OnSphereOverlapBegin);
_Sphere-&gt;OnComponentEndOverlap.AddDynamic(this, &amp;AguardTower_CH5_3::OnSphereOverlapEnd);</pre> <p>The <a id="_idIndexMarker212"/>performance benefit here is shown to be quite extreme, but this is actually the norm when compared to the prototype approach of dealing with all behavior in Tick. We can also apply this technique to any situation where the Update pattern has been extensively used. Unreal Engine 5 already uses it within the Enhanced Input system, only firing the delegate callback events when the input has been pressed. The old polling system would fire on axis inputs regardless, leaving us to gate values that were not needed. We can also look at a few places where Unreal provides options for communication, namely UI and networking – two very different areas, but the principle is the same. Both provide a way of quickly setting up a link using a polling, or update, method that fires every frame. For UI, it is property binding, and for networking, we have replicated variables. In both cases, there is some extra function run every frame to see whether the variable it is linked to has updated. Hopefully, the parallels are clear with the example we have just explored. Specific solutions would be to manually update UI through a custom function call and use replicated functions when dealing with networked systems, also <a id="_idIndexMarker213"/>called <strong class="bold">Remote Procedural Calls</strong> (<strong class="bold">RPCs</strong>), which allow us to only send data across a network when it needs to be updated.</p>
<p>With this chapter complete, you should now understand the need, and method, to design systems with an event-driven approach. We have shown that we can make code that has the exact same functionality in many ways, but using an event-driven approach can save a lot of processing, even if it means a more complex setup. As an additional task, consider how to make the searchlight work for multiple controllable units, or how it could track a unit once it has been seen until it loses sight. On a higher level, how could the searchlight notify the surrounding enemies that it has seen your unit? It is advised that you revisit this class after each chapter to see how the tools learned later can improve this further.</p>
<h1 id="_idParaDest-75"><a id="_idTextAnchor075"/>Summary</h1>
<p>Through the explicit example of a watchtower in our example game, we learned a host of different techniques and considerations to improve efficiency in our systems. We applied the general technique of always trying to do less, by swapping a gated polling system for a killable update and event-driven systems. We used Unreal Engine-specific tools, such as the Timeline and Timers, to achieve these patterns, and we thought about how their application may affect the design of the gameplay beyond our numbers-based efficiency targets. The iterative process of improvement that this chapter focused on has also shown how to improve code in small measurable ways, using <em class="italic">T(n)</em> calculations to quantify each step. Moving forward, we will look at more general programming tools and their implementations within Unreal to expand this toolkit. The big takeaway is to break the problem down into its base parts and measure your improvements as you go. This will allow you to better communicate your process to, and work with, your team to achieve your goals.</p>
</div>
</body></html>