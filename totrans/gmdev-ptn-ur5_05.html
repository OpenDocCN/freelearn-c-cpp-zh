<html><head></head><body>
<div id="_idContainer104">
<h1 class="chapter-number" id="_idParaDest-68"><a id="_idTextAnchor068"/><span class="koboSpan" id="kobo.1.1">5</span></h1>
<h1 id="_idParaDest-69"><a id="_idTextAnchor069"/><span class="koboSpan" id="kobo.2.1">Forgetting Tick</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In this chapter we are going to explore the topic of tick (an event or process that is called every frame), why using it can cause frame-rate issues for our game projects, and two approaches to building systems without using tick, reducing the impact of systems on the CPU. </span><span class="koboSpan" id="kobo.3.2">We will consider the example of a guard tower in an RTS game, with a searchlight rotating back and forth. </span><span class="koboSpan" id="kobo.3.3">If the player’s unit is seen by the searchlight, it will stop its rotation. </span><span class="koboSpan" id="kobo.3.4">We will start with the Update pattern introduced in the previous chapter and iteratively improve from there, reducing our reliance on the Update pattern by using Timers, Timelines, and event-driven solutions instead. </span><span class="koboSpan" id="kobo.3.5">At each step, we will measure code efficiency, using execution counting to quantify </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">our improvements.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In this chapter, we’ll cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">Tick events and the challenges we face when </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">using them</span></span></li>
<li><span class="koboSpan" id="kobo.9.1">Timers </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">and Timelines</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.11.1">Event-driven systems</span></span></li>
</ul>
<h1 id="_idParaDest-70"><a id="_idTextAnchor070"/><span class="koboSpan" id="kobo.12.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.13.1">In this chapter, we will focus on the Guard Tower classes in the </span><a href="B18297_05.xhtml#_idTextAnchor068"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.14.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.15.1"> folder of the project, linked via GitHub, that we downloaded for previous chapters. </span><span class="koboSpan" id="kobo.15.2">If you haven’t followed along with the developments in the previous chapters, you can download a version of the project, ready to start the </span><a href="B18297_05.xhtml#_idTextAnchor068"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.16.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.17.1"> tutorials from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.18.1">chapter5</span></strong><span class="koboSpan" id="kobo.19.1"> branch on GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">at </span></span><a href="https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter05"><span class="No-Break"><span class="koboSpan" id="kobo.21.1">https://github.com/PacktPublishing/Game-Development-Patterns-with-Unreal-Engine-5/tree/main/Chapter05</span></span></a></p>
<h1 id="_idParaDest-71"><a id="_idTextAnchor071"/><span class="koboSpan" id="kobo.22.1">Before we begin</span></h1>
<p><span class="koboSpan" id="kobo.23.1">In this class, we will use a new smart pointer type. </span><strong class="source-inline"><span class="koboSpan" id="kobo.24.1">TObjectPtr&lt;&gt;</span></strong><span class="koboSpan" id="kobo.25.1"> is the Unreal Engine 5 standard</span><a id="_idIndexMarker187"/><span class="koboSpan" id="kobo.26.1"> way of dealing with components held on an actor. </span><span class="koboSpan" id="kobo.26.2">The prior standard was to use raw pointers, but this will no longer work with the new garbage collector, as the new system provides reference tracking to detect when an object is actually used. </span><span class="koboSpan" id="kobo.26.3">This can mean that objects only stored in raw pointers get mistaken for de-referenced memory and can be deleted while still </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">in use.</span></span></p>
<p><span class="koboSpan" id="kobo.28.1">Within functions, we will still use raw pointers, as these variables will go out of scope, and so the garbage collector is not necessary to free their memory. </span><span class="koboSpan" id="kobo.28.2">Member variable object references will be </span><a id="_idIndexMarker188"/><span class="koboSpan" id="kobo.29.1">stored as </span><strong class="source-inline"><span class="koboSpan" id="kobo.30.1">TObjectPtr&lt;&gt;</span></strong><span class="koboSpan" id="kobo.31.1"> and asset references </span><a id="_idIndexMarker189"/><span class="koboSpan" id="kobo.32.1">stored </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.34.1">TSoftObjectPtr&lt;&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">.</span></span></p>
<h1 id="_idParaDest-72"><a id="_idTextAnchor072"/><span class="koboSpan" id="kobo.36.1">A world that ticks</span></h1>
<p><span class="koboSpan" id="kobo.37.1">In the last chapter, we covered the idea of the Update pattern. </span><span class="koboSpan" id="kobo.37.2">When using the Update pattern, we design with the philosophy that lots of different types of classes need to execute code on each frame. </span><span class="koboSpan" id="kobo.37.3">To achieve this, we will use an update function or, in the case of Unreal, a </span><strong class="bold"><span class="koboSpan" id="kobo.38.1">Tick Event</span></strong><span class="koboSpan" id="kobo.39.1">. </span><span class="koboSpan" id="kobo.39.2">This</span><a id="_idIndexMarker190"/><span class="koboSpan" id="kobo.40.1"> pattern provides a fast way to make things happen, which is why it has a certain gravity, pulling many learning resources into leaning on it heavily. </span><span class="koboSpan" id="kobo.40.2">The volume of learning materials doesn’t make this a good idea, but it does allow systems to be propped up quickly, thus making learning from resources like this easy to understand. </span><span class="koboSpan" id="kobo.40.3">The problem lies in the seeming loss of understanding, over the cost of relying on this method. </span><span class="koboSpan" id="kobo.40.4">When we place any nodes or lines of code under the purview of tick, we need to remember it runs once per frame. </span><span class="koboSpan" id="kobo.40.5">On modern machines this equates to an average of 60 times a second, but it can vary depending on hardware, which is an important consideration for developers. </span><span class="koboSpan" id="kobo.40.6">For small games on modern hardware, the odd variable set or transform change may be fine; however, this is significantly more concerning if you consider the impact of a loop. </span><span class="koboSpan" id="kobo.40.7">This should make it clear that, as powerful as tick may seem, a web of problems lies beneath </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">its surface.</span></span></p>
<p><span class="koboSpan" id="kobo.42.1">To </span><a id="_idIndexMarker191"/><span class="koboSpan" id="kobo.43.1">illustrate the problem, let’s look at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.44.1">AGuardTower_CH5_1</span></strong><span class="koboSpan" id="kobo.45.1"> actor in the </span><a href="B18297_05.xhtml#_idTextAnchor068"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.46.1">Chapter 5</span></em></span></a><strong class="source-inline"> </strong><span class="koboSpan" id="kobo.47.1">folder. </span><span class="koboSpan" id="kobo.47.2">We have followed best practice with the header file, using forward declared classes for member component definitions and the most limited property specifiers that we can. </span><span class="koboSpan" id="kobo.47.3">You will probably notice though that the only function, bar the constructor, is </span><strong class="source-inline"><span class="koboSpan" id="kobo.48.1">Tick</span></strong><span class="koboSpan" id="kobo.49.1">. </span><span class="koboSpan" id="kobo.49.2">In this function, we carry out all our searchlight functionality. </span><span class="koboSpan" id="kobo.49.3">Stepping through the tick function on the searchlight, we have </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.51.1">A call to the </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">parent Tick</span></span></li>
<li><span class="koboSpan" id="kobo.53.1">A sphere trace that gets reference to any actor that falls within the rough area of </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">the light</span></span></li>
<li><span class="koboSpan" id="kobo.55.1">A check to see whether the detected actor is of the player </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">pawn type</span></span></li>
<li><span class="koboSpan" id="kobo.57.1">Code </span><a id="_idIndexMarker192"/><span class="koboSpan" id="kobo.58.1">branches to rotate the searchlight in every direction when the player has not </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">been found</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.60.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.61.1">GuardTower</span></strong><span class="koboSpan" id="kobo.62.1"> body file contains a </span><strong class="source-inline"><span class="koboSpan" id="kobo.63.1">tick</span></strong><span class="koboSpan" id="kobo.64.1"> function which looks </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">like this:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.66.1">GuardTower_CH5_1.cpp Tick function</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.67.1">
void AGuardTower_CH5_1::Tick(float DeltaTime)
{
    Super::Tick(DeltaTime);
    FVector startLocation = _Arrow-&gt;GetComponentLocation();
    FVector endLocation = _Arrow-&gt;GetComponentLocation() +         (_Arrow-&gt;GetForwardVector() * _DetectionRange);
    FHitResult hit;
    UKismetSystemLibrary::SphereTraceSingle(GetWorld(),startLocation,
    endLocation,_DetectionRadius, UEngineTypes::
        ConvertToTraceType(ECC_Visibility), false, {},
            EDrawDebugTrace::ForOneFrame,hit, true);
    ACharacter* otherCasted = Cast&lt;AEliteUnit&gt;(hit.GetActor());
    _EnemySpotted = (otherCasted != nullptr);
    if (!_EnemySpotted)
    {
        if (_RotateForward)
        {
            _LightPivot-&gt;AddLocalRotation(FRotator(0.0, 0.2, 0.0));
            if (FMath::IsNearlyEqual                 (_LightPivot-&gt;GetRelativeRotation().Yaw, 40.f))
            {
                _RotateForward = false;
            }
        }
        else
        {
            _LightPivot-&gt;AddLocalRotation(FRotator(0.0, -0.2, 0.0));
            if (FMath::IsNearlyEqual                 (_LightPivot-&gt;GetRelativeRotation().Yaw, -40.f))
            {
                _RotateForward = true;
            }
        }
    }
}</span></pre> <p><span class="koboSpan" id="kobo.68.1">This </span><a id="_idIndexMarker193"/><span class="koboSpan" id="kobo.69.1">code does run, and you can see that if you drag an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.70.1">BP_GuardTower</span></strong><span class="koboSpan" id="kobo.71.1"> into the level provided in the </span><a href="B18297_05.xhtml#_idTextAnchor068"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.72.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.73.1"> folder. </span><span class="koboSpan" id="kobo.73.2">However, there are some issues, so let’s break down these problems </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">in order:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.75.1">With all the logic being on tick, we are performing some costly actions often. </span><span class="koboSpan" id="kobo.75.2">A sphere trace on its own is not too costly, but if we perform that sphere trace once per frame, per guard tower in a scene, the computational cost can add </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">up quickly.</span></span></li>
<li><span class="koboSpan" id="kobo.77.1">Quite a few getter functions are repeatedly used without caching. </span><span class="koboSpan" id="kobo.77.2">The world pointer could have been cached on </span><strong class="source-inline"><span class="koboSpan" id="kobo.78.1">BeginPlay</span></strong><span class="koboSpan" id="kobo.79.1">, as that is unlikely to change, and multiple calls to the arrow component’s location could be done once. </span><span class="koboSpan" id="kobo.79.2">These are only </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">minor improvements.</span></span></li>
<li><span class="koboSpan" id="kobo.81.1">Casting is nowhere near as costly as it used to be in the early days of Unreal Engine. </span><span class="koboSpan" id="kobo.81.2">That said, when casting to a class, the target class must be loaded to ensure a match. </span><span class="koboSpan" id="kobo.81.3">This must be kept in mind when casting to a large class, as it can inflate the size of the process in RAM. </span><span class="koboSpan" id="kobo.81.4">Alternatives could include casting to an interface if you only need some functionality, checking tags if it is just a validity check, or, even better, trying to flip the communication on its head and remove the need </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">to cast.</span></span></li>
<li><span class="koboSpan" id="kobo.83.1">We then have a pattern that we will refer to as </span><strong class="bold"><span class="koboSpan" id="kobo.84.1">gated polling</span></strong><span class="koboSpan" id="kobo.85.1">. </span><span class="koboSpan" id="kobo.85.2">On tick, check to see whether a block of code needs to run; if so, run it. </span><span class="koboSpan" id="kobo.85.3">This gated polling</span><a id="_idIndexMarker194"/><span class="koboSpan" id="kobo.86.1"> pattern is repeated a couple of times for different blocks of code. </span><span class="koboSpan" id="kobo.86.2">The alarm bells should now be ringing but maybe for the wrong reason. </span><span class="koboSpan" id="kobo.86.3">Yes, we have a repeated pattern of code, and we previously talked about avoiding repetition; that isn’t the real issue here. </span><span class="koboSpan" id="kobo.86.4">Any time we process something that may or may not need to happen, we guarantee a wasted check on some frames when it fails. </span><span class="koboSpan" id="kobo.86.5">We should consider how we can avoid the check and only process the code when it does need </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">to happen.</span></span></li>
<li><span class="koboSpan" id="kobo.88.1">Lastly, we have </span><a id="_idIndexMarker195"/><span class="koboSpan" id="kobo.89.1">a compound problem with each branch of the gated poll. </span><span class="koboSpan" id="kobo.89.2">Yes, we are hardcoding values, both the rotation limit and the speed of rotation. </span><span class="koboSpan" id="kobo.89.3">Turning the hardcoded </span><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">0.2</span></strong><span class="koboSpan" id="kobo.91.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">40</span></strong><span class="koboSpan" id="kobo.93.1"> into float member variables called </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">_RotationSpeed</span></strong><span class="koboSpan" id="kobo.95.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">_RotationLimit</span></strong><span class="koboSpan" id="kobo.97.1"> respectively is a simple fix for the first part. </span><span class="koboSpan" id="kobo.97.2">Adding </span><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">EditAnywhere</span></strong><span class="koboSpan" id="kobo.99.1"> to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">UPROPERTY()</span></strong><span class="koboSpan" id="kobo.101.1"> block above each new variable will allow designers to not only balance the values in the actor but also create varied instances in their levels. </span><span class="koboSpan" id="kobo.101.2">This still leaves an issue with our code. </span><span class="koboSpan" id="kobo.101.3">Tick is not constant, yet we are using a constant value for rotation. </span><span class="koboSpan" id="kobo.101.4">This is where </span><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">DeltaTime</span></strong><span class="koboSpan" id="kobo.103.1"> comes in. </span><span class="koboSpan" id="kobo.103.2">It is an argument of tick passed in as the time since the last frame rendered. </span><span class="koboSpan" id="kobo.103.3">Multiplying values by this will cause them to be applied evenly across 1 </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">real-world second.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.105.1">It should be pretty clear that there is a lot of room for improvement with this code, but how much room? </span><span class="koboSpan" id="kobo.105.2">Back in </span><a href="B18297_03.xhtml#_idTextAnchor046"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.106.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.107.1">, we discussed Big O notation, but to get a higher resolution analysis, we need to calculate the </span><em class="italic"><span class="koboSpan" id="kobo.108.1">T(n)</span></em><span class="koboSpan" id="kobo.109.1"> or time efficiency of the algorithm. </span><span class="koboSpan" id="kobo.109.2">This should provide us with a baseline to prove that we can quantifiably </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">do better.</span></span></p>
<p><span class="koboSpan" id="kobo.111.1">The first</span><a id="_idIndexMarker196"/><span class="koboSpan" id="kobo.112.1"> sphere trace section contains roughly three assignments, six function calls, three arithmetic operations, and the internal time of a sphere trace. </span><span class="koboSpan" id="kobo.112.2">The cast section is two function calls, one test, and one assignment. </span><span class="koboSpan" id="kobo.112.3">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">if</span></strong><span class="koboSpan" id="kobo.114.1"> block, both branches are basically the same number of executions, so we will only count the top branch, giving us two tests, four function calls, and one assignment. </span><span class="koboSpan" id="kobo.114.2">Altogether, this makes roughly 23 + 1 * sphere trace executions per frame, with no overhead beyond a standard setup. </span><span class="koboSpan" id="kobo.114.3">Over a second at 60 </span><strong class="bold"><span class="koboSpan" id="kobo.115.1">frames per second</span></strong><span class="koboSpan" id="kobo.116.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.117.1">FPS</span></strong><span class="koboSpan" id="kobo.118.1">), we would be</span><a id="_idIndexMarker197"/><span class="koboSpan" id="kobo.119.1"> running 1380 + 60 * sphere </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">trace executions.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.121.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.122.1">You can find the full working solutions for the following two sections under the </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">_2</span></strong><span class="koboSpan" id="kobo.124.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">_3</span></strong><span class="koboSpan" id="kobo.126.1"> versions of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">GuardTower_CH5</span></strong><span class="koboSpan" id="kobo.128.1"> class, but try to follow along with this section, making changes to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">_1</span></strong><span class="koboSpan" id="kobo.130.1"> version to get the most out of </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">the chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.132.1">Now that we’ve reviewed the problems with using Tick for the guard tower, let’s begin to look at how we can fix it, removing our reliance on Tick and writing </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">better code.</span></span></p>
<h1 id="_idParaDest-73"><a id="_idTextAnchor073"/><span class="koboSpan" id="kobo.134.1">A clock that stops</span></h1>
<p><span class="koboSpan" id="kobo.135.1">Now, we’ll deal with this gated polling issue. </span><span class="koboSpan" id="kobo.135.2">The</span><a id="_idIndexMarker198"/><span class="koboSpan" id="kobo.136.1"> go-to solutions for this are </span><strong class="bold"><span class="koboSpan" id="kobo.137.1">Timers and Timelines</span></strong><span class="koboSpan" id="kobo.138.1">. </span><span class="koboSpan" id="kobo.138.2">Timers </span><a id="_idIndexMarker199"/><span class="koboSpan" id="kobo.139.1">provide a way to delay the calling of a function, but not in the same </span><a id="_idIndexMarker200"/><span class="koboSpan" id="kobo.140.1">sense as the </span><strong class="bold"><span class="koboSpan" id="kobo.141.1">Delay</span></strong><span class="koboSpan" id="kobo.142.1"> node from Blueprint. </span><span class="koboSpan" id="kobo.142.2">The C++ backend for </span><strong class="bold"><span class="koboSpan" id="kobo.143.1">Delay </span></strong><span class="koboSpan" id="kobo.144.1">nodes can be found in </span><strong class="source-inline"><span class="koboSpan" id="kobo.145.1">UKismetSystemLibrary</span></strong><span class="koboSpan" id="kobo.146.1">, where you will see that simply calling it is a bit of a hassle. </span><span class="koboSpan" id="kobo.146.2">Timers will perform a check on each frame they are active to see whether the function they point at should fire yet. </span><span class="koboSpan" id="kobo.146.3">This can be a useful behavior for dynamically set delays or systems where you only want a signal after a set amount of time, such as a countdown to decrease once per second instead of once per frame. </span><span class="koboSpan" id="kobo.146.4">Timelines, however, provide </span><a id="_idIndexMarker201"/><span class="koboSpan" id="kobo.147.1">a way of processing a behavior, similar to an update while a curve is being queried. </span><span class="koboSpan" id="kobo.147.2">The length of these curves is predetermined, although the play speed of the Timeline can be altered to achieve a dynamic length. </span><span class="koboSpan" id="kobo.147.3">Timelines can also hold multiple types of tracks, which will all be synchronized when playing, allowing a single Timeline to drive a lot of elements. </span><span class="koboSpan" id="kobo.147.4">This provides a better fit for our problem, as we need to retain the update behavior but with a smaller footprint, reducing the number of checks we perform </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">each frame.</span></span></p>
<p><span class="koboSpan" id="kobo.149.1">Looking at the following code, we can see that to set up a Timeline in C++, we start by adding the following variables and functions to our header to facilitate the Timeline. </span><span class="koboSpan" id="kobo.149.2">It may seem at first glance that adding this much to a class would slow the process down, but each element has its part to play. </span><span class="koboSpan" id="kobo.149.3">The first two variables are delegates and will provide us with a way of linking functions to the Timeline dynamically. </span><span class="koboSpan" id="kobo.149.4">These are followed by the functions we will link. </span><span class="koboSpan" id="kobo.149.5">This pattern follows a naming convention described as follows to aid </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">future readability:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">On&lt;object name&gt;&lt;delegate purpose&gt;</span></strong><span class="koboSpan" id="kobo.152.1"> for </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">the delegate</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">Handle_&lt;object name&gt;&lt;delegate purpose&gt;</span></strong><span class="koboSpan" id="kobo.155.1"> for the </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">linked function</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.157.1">The following two functions, </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">StartRotation</span></strong><span class="koboSpan" id="kobo.159.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">StopRotation</span></strong><span class="koboSpan" id="kobo.161.1">, are simply there to act as wrappers for the </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">Timeline methods.</span></span></p>
<p><span class="koboSpan" id="kobo.163.1">The Timeline</span><a id="_idIndexMarker202"/><span class="koboSpan" id="kobo.164.1"> itself is created as </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">TObjectPtr&lt;&gt;</span></strong><span class="koboSpan" id="kobo.166.1">, allowing for forward-looking reference tallying and safer garbage collection. </span><span class="koboSpan" id="kobo.166.2">The property specifiers on this also don’t matter too much, as we access all the functionality we need through functions we have created. </span><span class="koboSpan" id="kobo.166.3">The last variable is  </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">TSoftObjectPtr&lt;&gt;</span></strong><span class="koboSpan" id="kobo.168.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">UCurveFloat</span></strong><span class="koboSpan" id="kobo.170.1">. </span><span class="koboSpan" id="kobo.170.2">This type is used by the engine to store a spline in 2D space as a set of keyframes with tangents. </span><span class="koboSpan" id="kobo.170.3">We will use it to drive our searchlight angle over time, but we want a designer to have access to make changes. </span><span class="koboSpan" id="kobo.170.4">This means we need to store the variable as a reference to an asset that does not yet exist, hence the </span><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">TSoftObjectPtr&lt;&gt;</span></strong><span class="koboSpan" id="kobo.172.1"> wrapper. </span><span class="koboSpan" id="kobo.172.2">Setting this as </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">EditAnywhere</span></strong><span class="koboSpan" id="kobo.174.1"> will allow the default value and the instance variants to be set via their respective </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">editor panels:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.176.1">GuardTower Timeline Header</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.177.1">
private:
    FOnTimelineFloat onTimeline_Update;
    FOnTimelineEventStatic onTimeline_Finished;
    UFUNCTION()
    void Handle_RotateLight_Update(float val);
    UFUNCTION()
    void Handle_RotateLight_Finished();
    void StartRotation();
    void StopRotation();
protected:
    UPROPERTY()
    TObjectPtr&lt;UTimelineComponent&gt; T_RotateLight;
    UPROPERTY(EditAnywhere)
    TSoftObjectPointer&lt;UCurveFloat&gt; _Curve;</span></pre> <p><span class="koboSpan" id="kobo.178.1">Now, we will </span><a id="_idIndexMarker203"/><span class="koboSpan" id="kobo.179.1">turn our attention to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">GuardTower</span></strong><span class="koboSpan" id="kobo.181.1"> constructor implementation shown here. </span><span class="koboSpan" id="kobo.181.2">We need to create the Timeline component in the constructor. </span><span class="koboSpan" id="kobo.181.3">Then, our delegate handles need to be bound to the listener functions. </span><span class="koboSpan" id="kobo.181.4">Binding like this will allow rebinding later down the line as necessary, while any class derived from this will always have a default response. </span><span class="koboSpan" id="kobo.181.5">It is also worth noting that binding is done via function names created as </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">FName</span></strong><span class="koboSpan" id="kobo.183.1"> types. </span><span class="koboSpan" id="kobo.183.2">This will make spelling and capitalization important, and it is unlikely that your IDE will have auto-complete functionality </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">for these:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.185.1">GuardTower Timeline Constructor</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.186.1">
T_RotateLight = CreateDefaultSubobject&lt;UTimelineComponent&gt; (TEXT("T_RotateLight"));
onTimeline_Update.BindUFunction(this, FName("Handle_RotateLight_Update"));
onTimeline_Finished.BindUFunction(this, FName("Handle_RotateLight_Finished"));</span></pre> <p><span class="koboSpan" id="kobo.187.1">We cannot do any more setup inside the constructor, as we are blocked by the fact that we could not have set a value for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">_Curve</span></strong><span class="koboSpan" id="kobo.189.1"> variable yet. </span><span class="koboSpan" id="kobo.189.2">This will require linking in the editor, which forces the rest of the initialization process into the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">BeginPlay</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.191.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.192.1">The first thing to consider is that the variable may not have had a value set at all, which would invalidate the need to continue any setup. </span><span class="koboSpan" id="kobo.192.2">Instead of nesting all the code inside a positive conditioned </span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">if</span></strong><span class="koboSpan" id="kobo.194.1"> statement, we will reverse the condition to check for a negative condition and plug in an early return. </span><span class="koboSpan" id="kobo.194.2">This makes our code more human-readable and reduces the amount of information we need to keep in mind while constructing </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">the function.</span></span></p>
<p><span class="koboSpan" id="kobo.196.1">Following that, the</span><a id="_idIndexMarker204"/><span class="koboSpan" id="kobo.197.1"> Timeline needs to have a few things set up, as shown in the following code block. </span><span class="koboSpan" id="kobo.197.2">Any tracks that it should be running need to be added. </span><span class="koboSpan" id="kobo.197.3">Here, we will add a float track based on whatever asset the </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">_Curve</span></strong><span class="koboSpan" id="kobo.199.1"> variable references. </span><span class="koboSpan" id="kobo.199.2">This needs to be injected with the delegate it will call whenever its value changes and the name of the track for future reference. </span><span class="koboSpan" id="kobo.199.3">Here, we will plug in the update delegate, </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">onTimeline_Update</span></strong><span class="koboSpan" id="kobo.201.1">, and a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.202.1">FName</span></strong><span class="koboSpan" id="kobo.203.1"> value that makes sense for our usage. </span><span class="koboSpan" id="kobo.203.2">The same then needs to be done for the timeline’s finished callback. </span><span class="koboSpan" id="kobo.203.3">It is slightly different from the other function in that it doesn’t require a curve or a name, just a callback. </span><span class="koboSpan" id="kobo.203.4">So, all we do here is insert the finished </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">delegate, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">onTimeline_Finished</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.207.1">In this case, we also need to set the looping nature to </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">false</span></strong><span class="koboSpan" id="kobo.209.1"> and the ignore time dilation property to </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">true</span></strong><span class="koboSpan" id="kobo.211.1">. </span><span class="koboSpan" id="kobo.211.2">We will control how the Timeline replays, so there is no need for any auto behavior, and the other variable is mainly there to show what sort of control you can get with a timeline. </span><span class="koboSpan" id="kobo.211.3">There are plenty of other properties to fiddle with to fine-tune how timelines behave, so it is well worth your time exploring the type header </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">for functions.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.213.1">Useful tip</span></p>
<p class="callout"><span class="koboSpan" id="kobo.214.1">If you want to explore type or class headers, define a variable of that type anywhere in your code. </span><span class="koboSpan" id="kobo.214.2">This will allow you to right-click the type and select </span><strong class="bold"><span class="koboSpan" id="kobo.215.1">Go To Definition</span></strong><span class="koboSpan" id="kobo.216.1"> (</span><em class="italic"><span class="koboSpan" id="kobo.217.1">F12</span></em><span class="koboSpan" id="kobo.218.1"> in Visual Studio </span><span class="No-Break"><span class="koboSpan" id="kobo.219.1">and Rider).</span></span></p>
<p><span class="koboSpan" id="kobo.220.1">All these changes should lead you to a</span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1"> Beginplay </span></strong><span class="koboSpan" id="kobo.222.1">setup for the Timeline that looks like the </span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">following code:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.224.1">GuardTower Timeline Setup</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.225.1">
Super::BeginPlay();
if (_Curve == nullptr)
{
    return;
}
T_RotateLight-&gt;AddInterpFloat(_Curve, onTimeline_Update,     FName("Alpha"));
T_RotateLight-&gt;SetTimelineFinishedFunc(onTimeline_Finished);
T_RotateLight-&gt;SetLooping(false);
T_RotateLight-&gt;SetIgnoreTimeDilation(true);
StartRotation();</span></pre> <p><span class="koboSpan" id="kobo.226.1">Now, we need to fill </span><a id="_idIndexMarker205"/><span class="koboSpan" id="kobo.227.1">out the callback handler functions, which are quite simple in nature – one to rotate the light on its killable update and the other to change the light’s direction when it reaches the </span><span class="No-Break"><span class="koboSpan" id="kobo.228.1">rotation limit:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.229.1">Callback handler functions</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.230.1">
void AGuardTower_CH5_3::Handle_RotateLight_Update(float val)
{
    _LightPivot-&gt;SetRelativeRotation(
    FRotator(0.f, FMath::Lerp(-40.f, 40.f, val), 0.f));
}
void AGuardTower_CH5_3::Handle_RotateLight_Finished()
{
    _RotateForward = !_RotateForward;
    StartRotation();
}</span></pre> <p><span class="koboSpan" id="kobo.231.1">The last thing we need to do is call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">StartRotation()</span></strong><span class="koboSpan" id="kobo.233.1"> function to start the Timeline. </span><span class="koboSpan" id="kobo.233.2">The body of this simply calls the timeline’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">Play()</span></strong><span class="koboSpan" id="kobo.235.1"> function if </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">_RotateForward</span></strong><span class="koboSpan" id="kobo.237.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">true</span></strong><span class="koboSpan" id="kobo.239.1">; otherwise, it calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">Reverse()</span></strong><span class="koboSpan" id="kobo.241.1">. </span><span class="koboSpan" id="kobo.241.2">We also have a wrapper for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">Stop()</span></strong><span class="koboSpan" id="kobo.243.1"> function, but this provides no benefit beyond being good practice for later development, all it does is call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">Stop()</span></strong><span class="koboSpan" id="kobo.245.1"> function on the timeline. </span><span class="koboSpan" id="kobo.245.2">With that done, we can delete the nested </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">if</span></strong><span class="koboSpan" id="kobo.247.1"> statements at the end of our old </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">tick</span></strong><span class="koboSpan" id="kobo.249.1"> function, add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">StopRotating()</span></strong><span class="koboSpan" id="kobo.251.1"> call to our sphere trace where it sets </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">_EnemySpotted</span></strong><span class="koboSpan" id="kobo.253.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">true</span></strong><span class="koboSpan" id="kobo.255.1">, and head to the editor to link up our </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">_Curve variable</span></strong><span class="koboSpan" id="kobo.257.1"> with </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">an asset.</span></span></p>
<p><span class="koboSpan" id="kobo.259.1">With the Timeline working, we can leverage some of its other features to improve the gameplay as well. </span><span class="koboSpan" id="kobo.259.2">The old rotation behavior on tick was very linear and not good for gameplay. </span><span class="koboSpan" id="kobo.259.3">Controlling the rotation with an f-curve telegraphs future actions to the player. </span><span class="koboSpan" id="kobo.259.4">As the rotation slows, the player gets an innate understanding that the light is about to swap </span><a id="_idIndexMarker206"/><span class="koboSpan" id="kobo.260.1">direction and can plan accordingly. </span><span class="koboSpan" id="kobo.260.2">This concept of </span><strong class="bold"><span class="koboSpan" id="kobo.261.1">telegraphing</span></strong><span class="koboSpan" id="kobo.262.1">, although it is a</span><a id="_idIndexMarker207"/><span class="koboSpan" id="kobo.263.1"> game design term, is important for programmers and system designers to understand, as it will aid us in building tools that are more useful to designers. </span><span class="koboSpan" id="kobo.263.2">Giving designers access to this curve will allow them to drastically change behavior with little effort, making better gameplay overall. </span><span class="koboSpan" id="kobo.263.3">The curve asset we have created in the project for you is called </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">C_GuardTower_RotAlpha</span></strong><span class="koboSpan" id="kobo.265.1"> and can be found with the guard tower class in the </span><a href="B18297_05.xhtml#_idTextAnchor068"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.266.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.267.1"> folder. </span><span class="koboSpan" id="kobo.267.2">The curve is a simple f-curve with flat tangents on start and end points, covering (</span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">0,</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.269.1">0</span></strong><span class="koboSpan" id="kobo.270.1">) to (</span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">5,</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.272.1">1</span></strong><span class="koboSpan" id="kobo.273.1">), as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.274.1">Figure 5</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.275.1">.1</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer103">
<span class="koboSpan" id="kobo.277.1"><img alt="Figure 5.1 – The C_SearchLightRotation curve asset in the curve editor window" src="image/Figure_05.01_B18297.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.278.1">Figure 5.1 – The C_SearchLightRotation curve asset in the curve editor window</span></p>
<p><span class="koboSpan" id="kobo.279.1">Now that we have </span><a id="_idIndexMarker208"/><span class="koboSpan" id="kobo.280.1">changed the old, gated polling out for a Timeline system, we should recalculate the </span><em class="italic"><span class="koboSpan" id="kobo.281.1">T(n)</span></em><span class="koboSpan" id="kobo.282.1"> performance. </span><span class="koboSpan" id="kobo.282.2">We removed two tests, four function calls, and one assignment, bringing the total down to 16 + 1 * sphere trace. </span><span class="koboSpan" id="kobo.282.3">Then, we added a timeline, which is worth one test and one function call per frame, one test and six function calls that will run one time, one test, and two function calls that will currently run once every 5 seconds. </span><span class="koboSpan" id="kobo.282.4">Simply adding the values back together makes the situation look worse, giving us a 28 + 1 * sphere trace, but this is wrong. </span><span class="koboSpan" id="kobo.282.5">The new code will not run as regularly as the old, and when multiplying it out by the correct frequencies, you get (60 * (18 + 1 * sphere trace)) + (3 / 5) = ~1081 + 60 * sphere trace per second, plus 7 overhead. </span><span class="koboSpan" id="kobo.282.6">This is roughly a 22% improvement on the </span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">first implementation.</span></span></p>
<p><span class="koboSpan" id="kobo.284.1">This is good, but we still have a problem. </span><span class="koboSpan" id="kobo.284.2">There is still something we are doing every tick: the sphere trace. </span><span class="koboSpan" id="kobo.284.3">Every frame this projects a sphere through space to see whether the player’s character is in “view” of the tower. </span><span class="koboSpan" id="kobo.284.4">This setup mirrors our previous problem of gated polling. </span><span class="koboSpan" id="kobo.284.5">Every frame, we run the test. </span><span class="koboSpan" id="kobo.284.6">If the player is overlapped, we fire the seen logic. </span><span class="koboSpan" id="kobo.284.7">If the player is not detected or is just out of sight, then nothing happens, and that sphere trace we checked </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">was wasted.</span></span></p>
<p><span class="koboSpan" id="kobo.286.1">The following section will go through the process of improving this and the architectural decisions that govern which route to take when considering efficiency </span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">versus design.</span></span></p>
<h1 id="_idParaDest-74"><a id="_idTextAnchor074"/><span class="koboSpan" id="kobo.288.1">Event driven systems</span></h1>
<p><span class="koboSpan" id="kobo.289.1">A software engineer’s job is to solve</span><a id="_idIndexMarker209"/><span class="koboSpan" id="kobo.290.1"> problems. </span><span class="koboSpan" id="kobo.290.2">Most of the time, this means special treatment in certain cases to make sure eventualities are handled. </span><span class="koboSpan" id="kobo.290.3">Sometimes, perfection is found, and the problem is not solved but erased from existence. </span><span class="koboSpan" id="kobo.290.4">In our current system, we want to solve the problem of needing to trace a sphere through our world for the player in </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">every frame.</span></span></p>
<p><span class="koboSpan" id="kobo.292.1">The question is not, </span><em class="italic"><span class="koboSpan" id="kobo.293.1">how do we make this more efficient?</span></em><span class="koboSpan" id="kobo.294.1"> Instead, we should be asking, </span><em class="italic"><span class="koboSpan" id="kobo.295.1">why sphere trace?</span></em><span class="koboSpan" id="kobo.296.1"> There isn’t really a clear answer to this. </span><span class="koboSpan" id="kobo.296.2">Yes, it allows us to check the volume of space for a player, but so do colliders. </span><span class="koboSpan" id="kobo.296.3">Yes, we can check all the space between the light mesh and the floor, but in our game, the player cannot jump. </span><span class="koboSpan" id="kobo.296.4">Yes, we can tell whether there are objects blocking a view of the player, but so can a cheaper line trace on the frames when we are </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">not sure.</span></span></p>
<p><span class="koboSpan" id="kobo.298.1">From these three answers, we can form a new solution. </span><span class="koboSpan" id="kobo.298.2">In principle, we will attach a sphere collider, as it’s the cheapest primitive to use, to the light. </span><span class="koboSpan" id="kobo.298.3">As the light swings, so does the attached collider. </span><span class="koboSpan" id="kobo.298.4">When the collider overlaps the player, we use a line trace from the light to the player to see whether there is a clear line of sight. </span><span class="koboSpan" id="kobo.298.5">This effectively flips the interaction between the searchlight and the player on its head. </span><span class="koboSpan" id="kobo.298.6">No longer does the searchlight ask the world whether it can see the player every frame. </span><span class="koboSpan" id="kobo.298.7">Now, the world will tell the searchlight only when the player </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">is seen.</span></span></p>
<p><span class="koboSpan" id="kobo.300.1">Walking through our implementation, we will link a handler function to our new sphere component’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">onComponentBeginOverlap</span></strong><span class="koboSpan" id="kobo.302.1"> event. </span><span class="koboSpan" id="kobo.302.2">This handler function, detailed in the following code, starts with an early exit in case we have already collided with a player unit. </span><span class="koboSpan" id="kobo.302.3">If so, then we can ignore future collisions. </span><span class="koboSpan" id="kobo.302.4">In a larger scenario with more colliders in the scene, you may want to ignore this check and move on to incrementing a counter instead, as the searchlight is big enough to cover multiple units at once. </span><span class="koboSpan" id="kobo.302.5">We then cast the overlapped actor to the class we know the player will use. </span><span class="koboSpan" id="kobo.302.6">This, again, could be switched to a check for </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">teamID</span></strong><span class="koboSpan" id="kobo.304.1"> or some similar group-identifying value. </span><span class="koboSpan" id="kobo.304.2">This would allow multiple players or factions to use the same units. </span><span class="koboSpan" id="kobo.304.3">The next few lines set up the values for and execute a line trace through the world, from the light position to the center of the unit we have just overlapped with. </span><span class="koboSpan" id="kobo.304.4">This is done because the collider we will swing around has no idea of the map it is on and where any vision-blocking walls may be. </span><span class="koboSpan" id="kobo.304.5">We will use the line trace as another early return because if it does hit something, that means we can ignore the player collision due to a mesh blocking vision. </span><span class="koboSpan" id="kobo.304.6">With a clear line of sight established, we then simply set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">_EnemySpotted</span></strong><span class="koboSpan" id="kobo.306.1"> variable to </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">true</span></strong><span class="koboSpan" id="kobo.308.1"> and stop the timeline-driven rotation. </span><span class="koboSpan" id="kobo.308.2">This would be where you would link into something like an alert</span><a id="_idIndexMarker210"/><span class="koboSpan" id="kobo.309.1"> system to draw the attention of nearby </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">friendly units.</span></span></p>
<p><span class="koboSpan" id="kobo.311.1">Let's start with the </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">Begin Overlap:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.313.1">GuardTower Sphere Begin Overlap function</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.314.1">
if (_EnemyUnit != nullptr)
{
    return;
}
_EnemyUnit = Cast&lt;AEliteUnit&gt;(OtherActor);
if (_EnemyUnit == nullptr)
{
    return;
}
FHitResult hit(ForceInit);
FVector start = _Arrow-&gt;GetComponentLocation();
FVector end = _EnemyUnit-&gt;GetActorLocation();
if (UKismetSystemLibrary::LineTraceSingle(
        GetWorld(), start, end,
        UEngineTypes::ConvertToTraceType(ECC_Visibility),
        false, {_EnemyUnit}, EDrawDebugTrace::ForDuration, hit,
        true, FLinearColor::Red, FLinearColor::Green, 0.5f))
{
    return;
}
_EnemySpotted = true;
StopRotation();</span></pre> <p><span class="koboSpan" id="kobo.315.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">onComponentEndOverlap</span></strong><span class="koboSpan" id="kobo.317.1"> equivalent event is handled by the function shown in the following code block and is much smaller, as it only needs to check that the actor leaving the collision</span><a id="_idIndexMarker211"/><span class="koboSpan" id="kobo.318.1"> is the one that triggered the alarm in the first place. </span><span class="koboSpan" id="kobo.318.2">Then, it can reset the </span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">_EnemySpotted</span></strong><span class="koboSpan" id="kobo.320.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">_EnemeyUnit</span></strong><span class="koboSpan" id="kobo.322.1"> variables, followed by continuing the Timeline </span><span class="No-Break"><span class="koboSpan" id="kobo.323.1">rotation code:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.324.1">GuardTower Sphere Overlap End</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.325.1">
if(_EnemyUnit != OtherActor) {
    return;
}
    _EnemySpotted = false;
    _EnemyUnit = nullptr;
    StartRotation();</span></pre> <p class="callout-heading"><span class="koboSpan" id="kobo.326.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.327.1">Component overlap functions were explored at the end of </span><a href="B18297_01.xhtml#_idTextAnchor016"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.328.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.329.1">. </span><span class="koboSpan" id="kobo.329.2">Remember to bind only functions matching </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">FComponentBeginOverlapSignature</span></strong><span class="koboSpan" id="kobo.331.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">FComponentEndOverlapSignature</span></strong><span class="koboSpan" id="kobo.333.1">, respectively. </span><span class="koboSpan" id="kobo.333.2">The arguments used in the sample code follow this pattern: </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool FromSweep, const FHitResult&amp; SweepResult</span></strong><span class="koboSpan" id="kobo.335.1"> for the begin overlap, which we can see are the same, minus the last two arguments for the </span><span class="No-Break"><span class="koboSpan" id="kobo.336.1">end overlap.</span></span></p>
<p><span class="koboSpan" id="kobo.337.1">This last change, from traces to colliders, calls for another recalculation of the </span><em class="italic"><span class="koboSpan" id="kobo.338.1">T(n)</span></em><span class="koboSpan" id="kobo.339.1"> performance. </span><span class="koboSpan" id="kobo.339.2">We repositioned the rest of the functionality in the Tick function completely, leaving only the Timeline update running. </span><span class="koboSpan" id="kobo.339.3">This drops our per frame executions to 2! </span><span class="koboSpan" id="kobo.339.4">The processing hasn’t been completely removed though. </span><span class="koboSpan" id="kobo.339.5">In the worst-case scenario, the player would overlap with the sphere collider and leave the interaction within a second, meaning all the code could fire. </span><span class="koboSpan" id="kobo.339.6">This would be equivalent to four assignments, eight function calls, three tests, and 1 * line trace on begin overlap and two assignments, one function call, and one test on end overlap. </span><span class="koboSpan" id="kobo.339.7">This, plus the four function calls to set up the new component and bind these functions, detailed in the following code, brings our cost to 2 per frame, 19 + 1 * line trace per second, and 3 per 5 seconds. </span><span class="koboSpan" id="kobo.339.8">This makes (60 * 2) + (19 + 1 * line trace) + (3 / 5) = ~140 + 1 * line trace per second, with an overhead setup cost of 11. </span><span class="koboSpan" id="kobo.339.9">This is a massive 90% improvement on the first implementation, showing how a change in approach can make a massive impact on performance, even though it may seem like more has been created. </span><span class="koboSpan" id="kobo.339.10">For reference, the following code can be used to link handler functions to the relevant component overlap events if you need a syntax example. </span><span class="koboSpan" id="kobo.339.11">Your functions may have different names, but these lines must run for the callback </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">to work:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.341.1">GuardTower constructor new lines for sphere component setup</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.342.1">
_Sphere = CreateDefaultSubObject&lt;USphereComponent&gt;(TEXT("Sphere"));
_Sphere-&gt;SetupAttachment(_LightMesh);
_Sphere-&gt;OnComponentBeginOverlap.AddDynamic(this, &amp;AguardTower_CH5_3::OnSphereOverlapBegin);
_Sphere-&gt;OnComponentEndOverlap.AddDynamic(this, &amp;AguardTower_CH5_3::OnSphereOverlapEnd);</span></pre> <p><span class="koboSpan" id="kobo.343.1">The </span><a id="_idIndexMarker212"/><span class="koboSpan" id="kobo.344.1">performance benefit here is shown to be quite extreme, but this is actually the norm when compared to the prototype approach of dealing with all behavior in Tick. </span><span class="koboSpan" id="kobo.344.2">We can also apply this technique to any situation where the Update pattern has been extensively used. </span><span class="koboSpan" id="kobo.344.3">Unreal Engine 5 already uses it within the Enhanced Input system, only firing the delegate callback events when the input has been pressed. </span><span class="koboSpan" id="kobo.344.4">The old polling system would fire on axis inputs regardless, leaving us to gate values that were not needed. </span><span class="koboSpan" id="kobo.344.5">We can also look at a few places where Unreal provides options for communication, namely UI and networking – two very different areas, but the principle is the same. </span><span class="koboSpan" id="kobo.344.6">Both provide a way of quickly setting up a link using a polling, or update, method that fires every frame. </span><span class="koboSpan" id="kobo.344.7">For UI, it is property binding, and for networking, we have replicated variables. </span><span class="koboSpan" id="kobo.344.8">In both cases, there is some extra function run every frame to see whether the variable it is linked to has updated. </span><span class="koboSpan" id="kobo.344.9">Hopefully, the parallels are clear with the example we have just explored. </span><span class="koboSpan" id="kobo.344.10">Specific solutions would be to manually update UI through a custom function call and use replicated functions when dealing with networked systems, also </span><a id="_idIndexMarker213"/><span class="koboSpan" id="kobo.345.1">called </span><strong class="bold"><span class="koboSpan" id="kobo.346.1">Remote Procedural Calls</span></strong><span class="koboSpan" id="kobo.347.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.348.1">RPCs</span></strong><span class="koboSpan" id="kobo.349.1">), which allow us to only send data across a network when it needs to </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">be updated.</span></span></p>
<p><span class="koboSpan" id="kobo.351.1">With this chapter complete, you should now understand the need, and method, to design systems with an event-driven approach. </span><span class="koboSpan" id="kobo.351.2">We have shown that we can make code that has the exact same functionality in many ways, but using an event-driven approach can save a lot of processing, even if it means a more complex setup. </span><span class="koboSpan" id="kobo.351.3">As an additional task, consider how to make the searchlight work for multiple controllable units, or how it could track a unit once it has been seen until it loses sight. </span><span class="koboSpan" id="kobo.351.4">On a higher level, how could the searchlight notify the surrounding enemies that it has seen your unit? </span><span class="koboSpan" id="kobo.351.5">It is advised that you revisit this class after each chapter to see how the tools learned later can improve </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">this further.</span></span></p>
<h1 id="_idParaDest-75"><a id="_idTextAnchor075"/><span class="koboSpan" id="kobo.353.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.354.1">Through the explicit example of a watchtower in our example game, we learned a host of different techniques and considerations to improve efficiency in our systems. </span><span class="koboSpan" id="kobo.354.2">We applied the general technique of always trying to do less, by swapping a gated polling system for a killable update and event-driven systems. </span><span class="koboSpan" id="kobo.354.3">We used Unreal Engine-specific tools, such as the Timeline and Timers, to achieve these patterns, and we thought about how their application may affect the design of the gameplay beyond our numbers-based efficiency targets. </span><span class="koboSpan" id="kobo.354.4">The iterative process of improvement that this chapter focused on has also shown how to improve code in small measurable ways, using </span><em class="italic"><span class="koboSpan" id="kobo.355.1">T(n)</span></em><span class="koboSpan" id="kobo.356.1"> calculations to quantify each step. </span><span class="koboSpan" id="kobo.356.2">Moving forward, we will look at more general programming tools and their implementations within Unreal to expand this toolkit. </span><span class="koboSpan" id="kobo.356.3">The big takeaway is to break the problem down into its base parts and measure your improvements as you go. </span><span class="koboSpan" id="kobo.356.4">This will allow you to better communicate your process to, and work with, your team to achieve </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">your goals.</span></span></p>
</div>
</body></html>