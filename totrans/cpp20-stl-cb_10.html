<html><head></head><body>
		<div><h1 id="_idParaDest-325"><em class="italic"><a id="_idTextAnchor324"/>Chapter 10</em>: Using the File System</h1>
			<p>The purpose of the STL <code>filesystem</code> library is to normalize file system operations across platforms. The <code>filesystem</code> library<a id="_idIndexMarker963"/> seeks to normalize operations, bridging irregularities between POSIX/Unix, Windows, and other file systems.</p>
			<p>The <code>filesystem</code> library was adopted from the corresponding <em class="italic">Boost</em> library and incorporated into the STL with C++17. At the time of writing, there are still gaps in its implementation on some systems, but the recipes in this chapter have been tested on Linux, Windows, and macOS file systems, and compiled with the latest available versions of the GCC, MSVC, and Clang compilers, respectively.</p>
			<p>The library uses the <code>&lt;filesystem&gt;</code> header, and the <code>std::filesystem</code> namespace is commonly aliased as <code>fs</code>:</p>
			<pre>namespace fs = std::filesystem;</pre>
			<p>The <code>fs::path</code> class<a id="_idIndexMarker964"/> is at the core of the <code>filesystem</code> library. It provides normalized filename and directory path representation across disparate environments. A <code>path</code> object may represent a file, a directory, or any object in a , even a non-existent or impossible object.</p>
			<p>In the following recipes, we cover tools for working with files and directories using the <code>filesystem</code> library:</p>
			<ul>
				<li>Specialize <code>std::formatter</code> for the <code>path</code> class</li>
				<li>Use manipulation functions with <code>path</code></li>
				<li>List files in a directory</li>
				<li>Search directories and files with a <code>grep</code> utility</li>
				<li>Rename files with <code>regex</code> and <code>directory_iterator</code></li>
				<li>Create a disk usage counter</li>
			</ul>
			<h1 id="_idParaDest-326"><a id="_idTextAnchor325"/>Technical requirements</h1>
			<p>You can find the code files for this chapter on GitHub at <a href="https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap10">https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap10</a>.</p>
			<h1 id="_idParaDest-327"><a id="_idTextAnchor326"/>Specialize std::formatter for the path class</h1>
			<p>The <code>path</code> class<a id="_idIndexMarker965"/> is used throughout the <code>filesystem</code> library to represent a file or directory path. On POSIX-conformant systems, such as macOS and Linux, the <code>path</code> object uses the <code>char</code> type to represent filenames. On Windows, <code>path</code> uses <code>wchar_t</code>. On Windows, <code>cout</code> and <code>format()</code> will not display primitive strings of <code>wchar_t</code> characters. This means there is no simple out-of-the-box way to write code that uses the <code>filesystem</code> library and is portable across POSIX and Windows.</p>
			<p>We could use preprocessor directives to write specific versions of code for Windows. That may be a reasonable solution for some code bases, but for this book, it's messy and does not serve the purpose of simple, portable, reusable recipes.</p>
			<p>The elegant solution is to write a C++20 <code>formatter</code> specialization for the <code>path</code> class. This allows us to display <code>path</code> objects simply and portably.</p>
			<h2 id="_idParaDest-328"><a id="_idTextAnchor327"/>How to do it…</h2>
			<p>In<a id="_idIndexMarker966"/> this recipe, we write a <code>formatter</code> specialization<a id="_idIndexMarker967"/> for use with the <code>fs::path</code> class:</p>
			<ul>
				<li>We start with a namespace alias for convenience. All the <code>filesystem</code> names are in the <code>std::filesystem</code> namespace:<pre>namespace <strong class="bold">fs</strong> = std::filesystem;</pre></li>
				<li>Our <code>formatter</code> specialization for the <code>path</code> class is simple and succinct:<pre>template&lt;&gt;
struct std::formatter&lt;<strong class="bold">fs::path</strong>&gt;: std::formatter&lt;<strong class="bold">std::string</strong>&gt; {
    template&lt;typename FormatContext&gt;
    auto format(<strong class="bold">const fs::path&amp; p</strong>, FormatContext&amp; ctx) {
        return format_to(ctx.out(), "{}", <strong class="bold">p.string()</strong>);
    }
};</pre></li>
			</ul>
			<p>Here, we're specializing <code>formatter</code> for the <code>fs::path</code> type, using its <code>string()</code> method to get a printable representation. We cannot use the <code>c_str()</code> method because it doesn't work with the <code>wchar_t</code> characters on Windows.</p>
			<p>There's a<a id="_idIndexMarker968"/> more complete <a id="_idIndexMarker969"/>explanation of <code>formatter</code> specialization in <a href="B18267_01_ePub.xhtml#_idTextAnchor027"><em class="italic">Chaper 1</em></a>, <em class="italic">New C++20 Features</em>, of this book. </p>
			<ul>
				<li>In the <code>main()</code> function, we use the command line to pass a filename or path:<pre>int main(const int <strong class="bold">argc</strong>, const char** <strong class="bold">argv</strong>) {
    if(<strong class="bold">argc != 2</strong>) {
        <strong class="bold">fs::path fn{ argv[0] }</strong>;
        cout &lt;&lt; format("usage: {} &lt;path&gt;\n", 
          <strong class="bold">fn.filename()</strong>);
        return 0;
    }
    <strong class="bold">fs::path dir{ argv[1] }</strong>;
    if(!<strong class="bold">fs::exists(dir)</strong>) {
        cout &lt;&lt; format("path: {} does not exist\n", 
          <strong class="bold">dir</strong>);
        return 1;
    }
    cout &lt;&lt; format("path: {}\n", <strong class="bold">dir</strong>);
    cout &lt;&lt; format("filename: {}\n", <strong class="bold">dir.filename()</strong>);
    cout &lt;&lt; format("cannonical: {}\n", 
      <strong class="bold">fs::canonical(dir)</strong>);
}</pre></li>
			</ul>
			<p>The <code>argc</code> and <code>argv</code> parameters are the standard command-line arguments.</p>
			<p><code>argv[0]</code> is always the full directory path and filename for the executable itself. If we don't have the correct number of arguments, we display the filename part from <code>argv[0]</code> as part of our <em class="italic">usage</em> message.</p>
			<p>We've used<a id="_idIndexMarker970"/> some <code>filesystem</code> functions in <a id="_idIndexMarker971"/>this example:</p>
			<ul>
				<li>The <code>fs::exists()</code> function checks if a directory or file exists.</li>
				<li><code>dir</code> is a <code>path</code> object. We can now pass it directly to <code>format()</code>, using our specialization to display the string representation of the path.</li>
				<li>The <code>filename()</code> method returns a new <code>path</code> object, which we pass directly to <code>format()</code> using our specialization.</li>
				<li>The <code>fs::cannonical()</code> function takes a <code>path</code> object and returns a new <code>path</code> object with the canonical absolute directory path. We pass this <code>path</code> object directly to <code>format()</code> and it displays the directory path returned from <code>cannonical()</code>.</li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">$ ./formatter ./formatter.cpp</strong>
<strong class="bold">path: ./formatter.cpp</strong>
<strong class="bold">filename: formatter.cpp</strong>
<strong class="bold">cannonical: /home/billw/working/chap10/formatter.cpp</strong></pre>
			<h2 id="_idParaDest-329"><a id="_idTextAnchor328"/>How it works…</h2>
			<p>The <code>fs::path</code> class is <a id="_idIndexMarker972"/>used throughout the <code>filesystem</code> library to represent directory paths and filenames. By providing a <code>formatter</code> specialization, we can <a id="_idIndexMarker973"/>easily display <code>path</code> objects consistently across platforms.</p>
			<p>The <code>path</code> class provides some useful methods. We can iterate through a path to see its component parts:</p>
			<pre>fs::path <strong class="bold">p</strong>{ "~/include/bwprint.h" };
cout &lt;&lt; format("{}\n", <strong class="bold">p</strong>);
for(<strong class="bold">auto&amp; x</strong> : p) cout &lt;&lt; format("[{}] ", <strong class="bold">x</strong>);
cout &lt;&lt; '\n';</pre>
			<p>Output:</p>
			<pre><strong class="bold">~/include/bwprint.h</strong>
<strong class="bold">[~] [include] [bwprint.h]</strong></pre>
			<p>The iterator returns a <code>path</code> object for each element of the path.</p>
			<p>We can also get different parts of the path:</p>
			<pre>fs::path p{ "~/include/bwprint.h" };
cout &lt;&lt; format("{}\n", p);
cout &lt;&lt; format("{}\n", p.<strong class="bold">stem</strong>());
cout &lt;&lt; format("{}\n", p.<strong class="bold">extension</strong>());
cout &lt;&lt; format("{}\n", p.<strong class="bold">filename</strong>());
cout &lt;&lt; format("{}\n", p.<strong class="bold">parent_path</strong>());</pre>
			<p>Output:</p>
			<pre>~/include/bwprint.h
bwprint
.h
bwprint.h
~/include</pre>
			<p>We will continue<a id="_idIndexMarker974"/> to use this <code>formatter</code> specialization <a id="_idIndexMarker975"/>for the <code>path</code> class throughout this chapter.</p>
			<h1 id="_idParaDest-330"><a id="_idTextAnchor329"/>Use manipulation functions with path</h1>
			<p>The <code>filesystem</code> library includes functions for manipulating the contents of <code>path</code> objects. In this recipe, we<a id="_idIndexMarker976"/> will consider a few of these <a id="_idIndexMarker977"/>tools.</p>
			<h2 id="_idParaDest-331"><a id="_idTextAnchor330"/>How to do it…</h2>
			<p>In this recipe, we examine some functions that manipulate the contents of <code>path</code> objects:</p>
			<ul>
				<li>We start with the <code>namespace</code> directive and our <code>formatter</code> specialization. We do this in every recipe in this chapter:<pre>namespace <strong class="bold">fs</strong> = std::filesystem;
template&lt;&gt;
struct std::formatter&lt;<strong class="bold">fs::path</strong>&gt;: std::formatter&lt;std::string&gt; {
    template&lt;typename FormatContext&gt;
    auto format(const <strong class="bold">fs::path</strong>&amp; p, FormatContext&amp; ctx) {
        return format_to(ctx.out(), "{}", p.string());
    }
};</pre></li>
				<li>We can get the current working directory with the <code>current_path()</code> function, which returns a <code>path</code> object:<pre>cout &lt;&lt; format("current_path: {}\n", fs::current_path());</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">current_path: /home/billw/chap10</strong></pre>
			<ul>
				<li>The <code>absolute()</code> function <a id="_idIndexMarker978"/>returns an <a id="_idIndexMarker979"/>absolute path from <a id="_idIndexMarker980"/>a relative path:<pre>cout &lt;&lt; format("absolute(p): {}\n", fs::absolute(p));</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">absolute(p): /home/billw/chap10/testdir/foo.txt</strong></pre>
			<p><code>absolute()</code> will also dereference symbolic links.</p>
			<ul>
				<li>The <code>+=</code> operator <em class="italic">concatenates</em> a string to the end of the <code>path</code> string:<pre>cout &lt;&lt; format("concatenate: {}\n",
    fs::path{ "testdir" } += "foo.txt");</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">concatenate: testdirfoo.txt</strong></pre>
			<ul>
				<li>The <code>/=</code> operator <em class="italic">appends</em> a string to the end of the <code>path</code> string and returns a new <code>path</code> object:<pre>cout &lt;&lt; format("append: {}\n",
    fs::path{ "testdir" } /= "foo.txt");</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">append: testdir/foo.txt</strong></pre>
			<ul>
				<li>The <code>canonical()</code> function<a id="_idIndexMarker981"/> returns the full canonical directory path:<pre>cout &lt;&lt; format("canonical: {}\n",
    fs::canonical(fs::path{ "." } /= "testdir"));</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">canonical: /home/billw/chap10/testdir</strong></pre>
			<ul>
				<li>The <code>equivalent()</code> function <a id="_idIndexMarker982"/>tests if two <a id="_idIndexMarker983"/>relative paths <a id="_idIndexMarker984"/>resolve to the same file system entity:<pre>cout &lt;&lt; format("equivalent: {}\n", 
    fs::equivalent("testdir/foo.txt", 
        "testdir/../testdir/foo.txt"));</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">equivalent: true</strong></pre>
			<ul>
				<li>The <code>filesystem</code> library includes the <code>filesystem_error</code> class for exception handling:<pre>try {
    fs::path p{ fp };
    cout &lt;&lt; <strong class="bold">format("p: {}\n", p)</strong>;
    ...
    cout &lt;&lt; format("equivalent: {}\n", 
        fs::equivalent("testdir/foo.txt", 
            "testdir/../testdir/foo.txt"));
} catch (const <strong class="bold">fs::filesystem_error</strong>&amp; e) {
    cout &lt;&lt; format("{}\n", <strong class="bold">e.what()</strong>);
    cout &lt;&lt; format("path1: {}\n", <strong class="bold">e.path1()</strong>);
    cout &lt;&lt; format("path2: {}\n", <strong class="bold">e.path2()</strong>);
}</pre></li>
			</ul>
			<p>The <code>filesystem_error</code> class includes methods for displaying the error message and for <a id="_idIndexMarker985"/>getting the path(s) involved in <a id="_idIndexMarker986"/>the error.</p>
			<p>If we introduce an error into the <code>equivalent()</code> call, we can see the results of the <code>fileystem_error</code> class:</p>
			<pre>cout &lt;&lt; format("equivalent: {}\n", 
    fs::equivalent("testdir/foo.txt<strong class="bold">/x</strong>", 
        "testdir/../testdir/foo.txt<strong class="bold">/y</strong>"));</pre>
			<p>Output:</p>
			<pre><strong class="bold">filesystem error: cannot check file equivalence: No such file or directory [testdir/foo.txt/x] [testdir/../testdir/foo.txt/y]</strong>
<strong class="bold">path1: testdir/foo.txt/x</strong>
<strong class="bold">path2: testdir/../testdir/foo.txt/y</strong></pre>
			<p>This is the output on Debian with GCC.</p>
			<p>The <code>filesystem_error</code> class provides additional detail through its <code>path1()</code> and <code>path2()</code> methods. These methods return <code>path</code> objects.</p>
			<ul>
				<li>You can also use <code>std::error_code</code> with some of the <code>filesystem</code> functions:<pre>fs::path p{ fp };
<strong class="bold">std::error_code e</strong>;
cout &lt;&lt; format("canonical: {}\n", 
    fs::<strong class="bold">canonical(p /= "foo", e)</strong>);
cout &lt;&lt; format("error: {}\n", e.message());</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">canonical:</strong>
<strong class="bold">error: Not a directory</strong></pre>
			<ul>
				<li>Even though <a id="_idIndexMarker987"/>Windows uses a very different<a id="_idIndexMarker988"/> file system, this code still works as expected, using Windows file naming conventions:<pre>p: testdir/foo.txt
current_path: C:\Users\billw\chap10
absolute(p): C:\Users\billw\chap10\testdir\foo.txt
concatenate: testdirfoo.txt
append: testdir\foo.txt
canonical: C:\Users\billw\chap10\testdir
equivalent: true</pre></li>
			</ul>
			<h2 id="_idParaDest-332"><a id="_idTextAnchor331"/>How it works…</h2>
			<p>Most of these functions take a <code>path</code> object, an optional <code>std::error_code</code> object, and return a <code>path</code> object:</p>
			<pre>path absolute(const path&amp; p);
path absolute(const path&amp; p, std::error_code&amp; ec);</pre>
			<p>The <code>equivalent()</code> function takes two <code>path</code> objects and returns a <code>bool</code>:</p>
			<pre>bool equivalent( const path&amp; p1, const path&amp; p2 );
bool equivalent( const path&amp; p1, const path&amp; p2,
    std::error_code&amp; ec );</pre>
			<p>The <code>path</code> class has operators for concatenate and append. Both operators are destructive. They modify the <code>path</code> on the left-hand side of the operator:</p>
			<pre>p1 += source; // concatenate
p1 /= source; // append</pre>
			<p>For the right-hand side, these operators take either a <code>path</code> object, a <code>string</code>, a <code>string_view</code>, a C-string, or a pair of iterators.</p>
			<p>The <a id="_idIndexMarker989"/>concatenate operator adds the string from <a id="_idIndexMarker990"/>the right-hand side of the operator to the end of the <code>p1</code> <code>path</code> string.</p>
			<p>The append operator adds a separator (e.g., <code>/</code> or <code>\</code>), followed by the string from the right-hand side of the operator to the end of the <code>p1</code> <code>path</code> string.</p>
			<h1 id="_idParaDest-333"><a id="_idTextAnchor332"/>List files in a directory</h1>
			<p>The <code>filesystem</code> library<a id="_idIndexMarker991"/> provides a <code>directory_entry</code> class with<a id="_idIndexMarker992"/> directory-related information about a given <code>path</code>. We can use this to create useful directory listings.</p>
			<h2 id="_idParaDest-334"><a id="_idTextAnchor333"/>How to do it…</h2>
			<p>In this recipe, we create a directory listing utility using the information in the <code>directory_entry</code> class:</p>
			<ul>
				<li>We start with our namespace alias and <code>formatter</code> specialization for displaying <code>path</code> objects:<pre>namespace <strong class="bold">fs</strong> = std::filesystem;
template&lt;&gt;
struct std::formatter&lt;<strong class="bold">fs::path</strong>&gt;: std::formatter&lt;std::string&gt; {
    template&lt;typename FormatContext&gt;
    auto format(const <strong class="bold">fs::path</strong>&amp; p, FormatContext&amp; ctx) {
        return format_to(ctx.out(), "{}", p.string());
    }
};</pre></li>
				<li>The <code>directory_iterator</code> class <a id="_idIndexMarker993"/>makes it easy to list a<a id="_idIndexMarker994"/> directory:<pre>int main() {
    constexpr const char* <strong class="bold">fn</strong>{ "." };
    <strong class="bold">const fs::path fp{fn};</strong>
    for(const auto&amp; <strong class="bold">de</strong> : <strong class="bold">fs::directory_iterator{fp}</strong>) {
        cout &lt;&lt; format("{} ", <strong class="bold">de.path().filename()</strong>);
    }
    cout &lt;&lt; '\n';
}</pre></li>
			</ul>
			<p>Output:</p>
			<pre><strong class="bold">chrono Makefile include chrono.cpp working formatter testdir formatter.cpp working.cpp</strong></pre>
			<ul>
				<li>We can add command-line options to make this work, like Unix <code>ls</code>:<pre>int main(const int argc, const char** argv) {
    <strong class="bold">fs::path fp</strong>{ argc &gt; 1 ? argv[1] : "." };
    if(!fs::exists(fp)) {
        const auto <strong class="bold">cmdname</strong> { 
          <strong class="bold">fs::path{argv[0]}.filename()</strong> };
        cout &lt;&lt; format("{}: {} does not exist\n",
            <strong class="bold">cmdname</strong>, fp);
        return 1;
    }
    if(<strong class="bold">is_directory(fp)</strong>) {
        for(const auto&amp; <strong class="bold">de</strong> : 
          <strong class="bold">fs::directory_iterator{fp}</strong>) {
            cout &lt;&lt; format("{} ", 
              <strong class="bold">de.path().filename()</strong>);
        }
    } else {
        cout &lt;&lt; format("{} ", <strong class="bold">fp.filename()</strong>);
    }
    cout &lt;&lt; '\n';
}</pre></li>
			</ul>
			<p>If there is a <a id="_idIndexMarker995"/>command-line argument, we use it to create<a id="_idIndexMarker996"/> a <code>path</code> object. Otherwise, we use <code>"."</code> for the current directory.</p>
			<p>We check if the path exists with <code>if_exists()</code>. If not, we print an error message and exit. The error message includes <code>cmdname</code> from <code>argv[0]</code>.</p>
			<p>Next, we check <code>is_directory()</code>. If we have a directory, we loop through a <code>directory_iterator</code> for each entry. <code>directory_iterator</code> iterates over <code>directory_entry</code> objects. <code>de.path().filename()</code> gets the <code>path</code> and <code>filename</code> from each <code>directory_entry</code> object.</p>
			<p>Output:</p>
			<pre><strong class="bold">$ ./working</strong>
<strong class="bold">chrono Makefile include chrono.cpp working formatter testdir formatter.cpp working.cpp</strong>
<strong class="bold">$ ./working working.cpp</strong>
<strong class="bold">working.cpp</strong>
<strong class="bold">$ ./working foo.bar</strong>
<strong class="bold">working: foo.bar does not exist</strong></pre>
			<ul>
				<li>If we want <a id="_idIndexMarker997"/>our output sorted, we can store our <code>directory_entry</code> objects in<a id="_idIndexMarker998"/> a sortable container.</li>
			</ul>
			<p>Let's create an alias for <code>fs::directory_entry</code>. We'll be using this a lot. This goes at the top of the file:</p>
			<pre>using <strong class="bold">de</strong> = fs::directory_entry;</pre>
			<p>At the top of <code>main()</code>, we declare a <code>vector</code> of <code>de</code> objects:</p>
			<pre>vector&lt;<strong class="bold">de</strong>&gt; entries{};</pre>
			<p>Inside the <code>is_directory()</code> block, we load the <code>vector</code>, sort it, and then display it:</p>
			<pre>if(<strong class="bold">is_directory(fp)</strong>) {
    for(const auto&amp; de : fs::directory_iterator{fp}) {
        <strong class="bold">entries.emplace_back(de)</strong>;
    }
    <strong class="bold">std::sort(entries.begin(), entries.end())</strong>;
    for(const auto&amp; <strong class="bold">e</strong> : <strong class="bold">entries</strong>) {
        <strong class="bold">cout &lt;&lt; format("{} ", e.path().filename());</strong>
    }
} else { ...</pre>
			<p>Now our output is sorted:</p>
			<pre>Makefile chrono chrono.cpp formatter formatter.cpp include testdir working working.cpp</pre>
			<p>Notice that <code>Makefile</code> is sorted first, apparently out of order. This is because capital letters sort before lowercase in ASCII order.</p>
			<ul>
				<li>If we want a case-insensitive sort, we need a comparison function that ignores case. First, we need a function to return a lowercase <code>string</code>:<pre>string <strong class="bold">strlower</strong>(string s) {
    auto <strong class="bold">char_lower</strong> = [](const char&amp; c) -&gt; char {
        if(c &gt;= 'A' &amp;&amp; c &lt;= 'Z') return c + ('a' - 'A');
        else return c;
    };
    std::transform(s.begin(), s.end(), s.begin(),
        <strong class="bold">char_lower</strong>);
    return s;
}</pre></li>
			</ul>
			<p>Now we<a id="_idIndexMarker999"/> need <a id="_idIndexMarker1000"/>a function that compares two <code>directory_entry</code> objects, using <code>strlower()</code>:</p>
			<pre>bool <strong class="bold">dircmp_lc</strong>(const <strong class="bold">de</strong>&amp; lhs, const <strong class="bold">de</strong>&amp; rhs) {
    const auto lhstr{ <strong class="bold">lhs.path().string()</strong> };
    const auto rhstr{ <strong class="bold">rhs.path().string()</strong> };
    return <strong class="bold">strlower(lhstr)</strong> &lt; <strong class="bold">strlower(rhstr)</strong>;
}</pre>
			<p>Now we can use <code>dircmp_lc()</code> in our sort:</p>
			<pre>std::sort(entries.begin(), entries.end(), <strong class="bold">dircmp_lc</strong>);</pre>
			<p>Our output is now sorted ignoring case:</p>
			<pre><strong class="bold">chrono chrono.cpp formatter formatter.cpp include Makefile testdir working working.cpp</strong></pre>
			<ul>
				<li>At this point, we have a simple directory listing utility.</li>
			</ul>
			<p>There's a lot<a id="_idIndexMarker1001"/> more information available from the <code>filesystem</code> library. Let's <a id="_idIndexMarker1002"/>create a <code>print_dir()</code> function to gather more information and format it for display in the style of Unix <code>ls</code>:</p>
			<pre>void print_dir(const <strong class="bold">de</strong>&amp; <strong class="bold">dir</strong>) {
    using <strong class="bold">fs::perms</strong>;
    const auto <strong class="bold">fpath</strong>{ dir.path() };
    const auto <strong class="bold">fstat</strong>{ dir.symlink_status() };
    const auto <strong class="bold">fperm</strong>{ fstat.permissions() };
    const uintmax_t <strong class="bold">fsize</strong>{ 
        <strong class="bold">is_regular_file(fstat)</strong> ? <strong class="bold">file_size(fpath)</strong> : 0 };
    const auto <strong class="bold">fn</strong>{ fpath.filename() };
    string <strong class="bold">suffix</strong>{};
    if(<strong class="bold">is_directory(fstat)</strong>) suffix = "/";
    else if(<strong class="bold">(fperm &amp; perms::owner_exec) != perms::none</strong>) {
        suffix = "*";
    }
    cout &lt;&lt; format("{}{}\n", fn, suffix);
}</pre>
			<p>The <code>print_dir()</code> function takes a <code>directory_entry</code> argument. We then retrieve some useful objects from the <code>directory_entry</code> object:</p>
			<ul>
				<li><code>dir.path()</code> returns a <code>path</code> object.</li>
				<li><code>dir.symlink_status()</code> returns a <code>file_status</code> object, without following symbolic links.</li>
				<li><code>fstat.permissions()</code> returns a <code>perms</code> object.</li>
				<li><code>fsize</code> is the size of the file and <code>fn</code> is the filename <code>string</code>. We'll look more closely at each of these as we use them.</li>
			</ul>
			<p>Unix <code>ls</code> uses <a id="_idIndexMarker1003"/>trailing characters, after the filename, to<a id="_idIndexMarker1004"/> indicate a directory or an executable. We test the <code>fstat</code> object with <code>is_directory()</code> to see if the file is a directory and add a trailing <code>/</code> to the filename. Likewise, we can test if a file is executable with the <code>fperm</code> object.</p>
			<p>We call <code>print_dir()</code> from <code>main()</code> in the <code>for</code> loop after <code>sort()</code>:</p>
			<pre>std::sort(entries.begin(), entries.end(), dircmp_lc);
for(const auto&amp; e : entries) {
    <strong class="bold">print_dir(e)</strong>;
}</pre>
			<p>Our output now looks like this:</p>
			<pre><strong class="bold">chrono*</strong>
<strong class="bold">chrono.cpp</strong>
<strong class="bold">formatter*</strong>
<strong class="bold">formatter.cpp</strong>
<strong class="bold">include*</strong>
<strong class="bold">Makefile</strong>
<strong class="bold">testdir/</strong>
<strong class="bold">working*</strong>
<strong class="bold">working.cpp</strong></pre>
			<ul>
				<li>Notice the <code>include*</code> entry. That's actually a symbolic link. Let's notate that properly by following the link to get the target path:<pre>string suffix{};
if(<strong class="bold">is_symlink(fstat)</strong>) {
    suffix = " -&gt; ";
    suffix += <strong class="bold">fs::read_symlink(fpath).string()</strong>;
}
else if(is_directory(fstat)) suffix = "/";
else if((fperm &amp; perms::owner_exec) != perms::none) suffix = "*";</pre></li>
			</ul>
			<p>The <code>read_symlink()</code> function returns a <code>path</code> object. We take the <code>string()</code> representation <a id="_idIndexMarker1005"/>of the returned <code>path</code> object and add it to the <a id="_idIndexMarker1006"/>suffix for this output:</p>
			<pre><strong class="bold">chrono*</strong>
<strong class="bold">chrono.cpp</strong>
<strong class="bold">formatter*</strong>
<strong class="bold">formatter.cpp</strong>
<strong class="bold">include -&gt; /Users/billw/include</strong>
<strong class="bold">Makefile</strong>
<strong class="bold">testdir/</strong>
<strong class="bold">working*</strong>
<strong class="bold">working.cpp</strong></pre>
			<ul>
				<li>The Unix <code>ls</code> command also includes a string of characters to indicate a file's permission bits. It looks something like this: <code>drwxr-xr-x</code>.</li>
			</ul>
			<p>The <a id="_idIndexMarker1007"/>first character indicates the type of the file, for <a id="_idIndexMarker1008"/>example: <code>d</code> for directory, <code>l</code> for symbolic link, and <code>-</code> for a regular file.</p>
			<p>The <code>type_char()</code> function returns the appropriate character:</p>
			<pre>char type_char(const fs::file_status&amp; <strong class="bold">fstat</strong>) {
         if(<strong class="bold">is_symlink</strong>(fstat))        return 'l';
    else if(<strong class="bold">is_directory</strong>(fstat))      return 'd';
    else if(<strong class="bold">is_character_file</strong>(fstat)) return 'c';
    else if(<strong class="bold">is_block_file</strong>(fstat))     return 'b';
    else if(<strong class="bold">is_fifo</strong>(fstat))           return 'p';
    else if(<strong class="bold">is_socket</strong>(fstat))         return 's';
    else if(<strong class="bold">is_other</strong>(fstat))          return 'o';
    else if(<strong class="bold">is_regular_file</strong>(fstat))   return '-';
    return '?';
}</pre>
			<p>The rest of the string is in three triplets. Each triplet includes positions for the read, write, and execute permission bits, in the form <code>rwx</code>. If a bit is not set, its character is replaced by a <code>-</code>. There are three triplets for three sets of permissions: owner, group, and other, respectively.</p>
			<pre>string rwx(const fs::perms&amp; p) {
    <strong class="bold">using fs::perms;</strong>
    auto bit2char = [&amp;p](perms bit, char c) {
        return (p &amp; bit) == perms::none ? '-' : c;
    };
    return { bit2char(perms::<strong class="bold">owner_read</strong>,   'r'),
             bit2char(perms::<strong class="bold">owner_write</strong>,  'w'),
             bit2char(perms::<strong class="bold">owner_exec</strong>,   'x'),
             bit2char(perms::<strong class="bold">group_read</strong>,   'r'),
             bit2char(perms::<strong class="bold">group_write</strong>,  'w'),
             bit2char(perms::<strong class="bold">group_exec</strong>,   'x'),
             bit2char(perms::<strong class="bold">others_read</strong>,  'r'),
             bit2char(perms::<strong class="bold">others_write</strong>, 'w'),
             bit2char(perms::<strong class="bold">others_exec</strong>,  'x') };
}</pre>
			<p>The <code>perms</code> object<a id="_idIndexMarker1009"/> represents the POSIX permissions bitmap, but<a id="_idIndexMarker1010"/> it's not necessarily implemented as bits. Each entry must be compared to the <code>perms::none</code> value. Our lambda function fulfills this requirement.</p>
			<p>We add this definition to the top of our <code>print_dir()</code> function:</p>
			<pre>const auto permstr{ <strong class="bold">type_char</strong>(fstat) + <strong class="bold">rwx</strong>(fperm) };</pre>
			<p>We update our <code>format()</code> string:</p>
			<pre>cout &lt;&lt; format("{} {}{}\n", permstr, fn, suffix);</pre>
			<p>And we get this output:</p>
			<pre>-rwxr-xr-x chrono*
-rw-r--r-- chrono.cpp
-rwxr-xr-x formatter*
-rw-r--r-- formatter.cpp
lrwxr-xr-x include -&gt; /Users/billw/include
-rw-r--r-- Makefile
drwxr-xr-x testdir/
-rwxr-xr-x working*
-rw-r--r-- working.cpp</pre>
			<ul>
				<li>Now, let's<a id="_idIndexMarker1011"/> add a size string. The <code>fsize</code> value is from the <code>file_size()</code> function, which returns a <code>std::uintmax_t</code> type. This represents the<a id="_idIndexMarker1012"/> maximum size natural integer on the target system. <code>uintmax_t</code> is not always the same as <code>size_t</code> and does not always convert easily. Notably, <code>uintmax_t</code> is 32 bits on Windows, where <code>size_t</code> is 64 bits:<pre>string size_string(const uintmax_t fsize) {
    constexpr const uintmax_t kilo{ 1024 };
    constexpr const uintmax_t mega{ kilo * kilo };
    constexpr const uintmax_t giga{ mega * kilo };
    string s;
    if(fsize &gt;= giga ) return
        format("{}{}", (fsize + giga / 2) / giga, 'G');
    else if (fsize &gt;= mega) return
        format("{}{}", (fsize + mega / 2) / mega, 'M');
    else if (fsize &gt;= kilo) return
        format("{}{}", (fsize + kilo / 2) / kilo, 'K');
    else return format("{}B", fsize);
}</pre></li>
			</ul>
			<p>I chose to use 1,024 as 1K in this function, as that appears to be the default on both Linux and BSD Unix. In production, this could be a command-line option.</p>
			<p>We update our <code>format()</code> string in <code>main()</code>:</p>
			<pre>cout &lt;&lt; format("{} {:&gt;6} {}{}\n",
    permstr, size_string(fsize), fn, suffix);</pre>
			<p>Now, we <a id="_idIndexMarker1013"/>get <a id="_idIndexMarker1014"/>this output:</p>
			<pre><strong class="bold">-rwxr-xr-x   284K chrono*</strong>
<strong class="bold">-rw-r--r--     2K chrono.cpp</strong>
<strong class="bold">-rwxr-xr-x   178K formatter*</strong>
<strong class="bold">-rw-r--r--   906B formatter.cpp</strong>
<strong class="bold">lrwxr-xr-x     0B include -&gt; /Users/billw/include</strong>
<strong class="bold">-rw-r--r--   642B Makefile</strong>
<strong class="bold">drwxr-xr-x     0B testdir/</strong>
<strong class="bold">-rwxr-xr-x   197K working*</strong>
<strong class="bold">-rw-r--r--     5K working.cpp</strong></pre>
			<p class="callout-heading">Note</p>
			<p class="callout">This utility is designed for POSIX systems, such as Linux and macOS. It works on a Windows system, but the Windows permissions system is different from the POSIX system. On Windows, the permissions bits will always appear fully set.</p>
			<h2 id="_idParaDest-335"><a id="_idTextAnchor334"/>How it works…</h2>
			<p>The <code>filesystem</code> library carries a rich set of information through its <code>directory_entry</code> and related classes. The major classes we used in this recipe include:</p>
			<ul>
				<li>The <code>path</code> class represents a file system path, according to the rules of the target system. A <code>path</code> object is constructed from a string or another path. It need not represent an existing path, or even a possible path. The path string is parsed to component parts, including a root name, root directory, and an optional series of filenames and directory separators.</li>
				<li>The <code>directory_entry</code> class carries a <code>path</code> object as a member, and may also store additional attributes, including hard link count, status, symbolic link, file size, and last write time.</li>
				<li>The <code>file_status</code> class carries information about the type and permissions of a file. A <code>perms</code> object may be a member of <code>file_status</code>, representing the permissions structure of a file.</li>
			</ul>
			<p>There are two <a id="_idIndexMarker1015"/>functions for retrieving a <code>perms</code> object from <code>file_status</code>. The <code>status()</code> function and the <code>symlink_status()</code> function both return a <code>perms</code> object. The <a id="_idIndexMarker1016"/>difference is in how they handle a symbolic link. The <code>status()</code> function will follow a symbolic link and return the <code>perms</code> from the target file. <code>symlink_status()</code> will return the <code>perms</code> from the symbolic link itself.</p>
			<h2 id="_idParaDest-336"><a id="_idTextAnchor335"/>There's more…</h2>
			<p>I had intended to include the last-write time of each file in the directory listing.</p>
			<p>The <code>directory_entry</code> class has a member function, <code>last_write_time()</code>, which returns a <code>file_time_type</code> object representing the timestamp of the last time the file was written.</p>
			<p>Unfortunately, at the time of writing, the available implementations lack a portable way to convert a <code>file_time_type</code> object to a standard <code>chrono::sys_time</code>, suitable for use with <code>cout</code> or <code>format()</code>.</p>
			<p>For now, here's a solution that works with GCC:</p>
			<pre>string time_string(const <strong class="bold">fs::directory_entry</strong>&amp; <strong class="bold">dir</strong>) {
    <strong class="bold">using std::chrono::file_clock;</strong>
    auto file_time{ dir.last_write_time() };
    return format("{:%F %T}", 
        <strong class="bold">file_clock::to_sys(dir.last_write_time())</strong>);
}</pre>
			<p>It's recommended that user code should use <code>std::chrono::clock_cast</code> instead of <code>file::clock::to_sys</code> to convert time points between clocks. Unfortunately, none of the currently available implementations have a working <code>std::chrono::clock_cast</code> specialization for this purpose.</p>
			<p>Using this <code>time_string()</code> function, we can add to <code>print_dir()</code>:</p>
			<pre>const string <strong class="bold">timestr</strong>{ time_string(dir) };</pre>
			<p>We can then change the <code>format()</code> string:</p>
			<pre>cout &lt;&lt; format("{} {:&gt;6} {} {}{}\n",
    permstr, sizestr, <strong class="bold">timestr</strong>, fn, suffix);</pre>
			<p>And we get this output:</p>
			<pre>-rwxr-xr-x   248K 2022-03-09 09:39:49 chrono*
-rw-r--r--     2K 2022-03-09 09:33:56 chrono.cpp
-rwxr-xr-x   178K 2022-03-09 09:39:49 formatter*
-rw-r--r--   906B 2022-03-09 09:33:56 formatter.cpp
lrwxrwxrwx     0B 2022-02-04 11:39:53 include -&gt; /home/billw/include
-rw-r--r--   642B 2022-03-09 14:08:37 Makefile
drwxr-xr-x     0B 2022-03-09 10:38:39 testdir/
-rwxr-xr-x   197K 2022-03-12 17:13:46 working*
-rw-r--r--     5K 2022-03-12 17:13:40 working.cpp</pre>
			<p>This works on Debian with GCC-11. Do not expect it to work without modification on any other systems.</p>
			<h1 id="_idParaDest-337"><a id="_idTextAnchor336"/>Search directories and files with a grep utility</h1>
			<p>To <a id="_idIndexMarker1017"/>demonstrate traversing and searching<a id="_idIndexMarker1018"/> directory structures, we create a simple utility<a id="_idIndexMarker1019"/> that works like Unix <em class="italic">grep</em>. This utility uses <code>recursive_directory_iterator</code> to traverse nested directories and searches files for matches with a regular expression.</p>
			<h2 id="_idParaDest-338"><a id="_idTextAnchor337"/>How to do it…</h2>
			<p>In this recipe, we write a simple <em class="italic">grep</em> utility that traverses directories to search files with a regular expression:</p>
			<ul>
				<li>We start with some convenience aliases:<pre>namespace <strong class="bold">fs</strong> = std::filesystem;
using <strong class="bold">de</strong> = fs::directory_entry;
using <strong class="bold">rdit</strong> = fs::recursive_directory_iterator;
using <strong class="bold">match_v</strong> = vector&lt;std::pair&lt;size_t, std::string&gt;&gt;;</pre></li>
			</ul>
			<p><code>match_v</code> is a <code>vector</code> of regular expression match results.</p>
			<ul>
				<li>We continue using our <code>formatter</code> specialization for <code>path</code> objects:<pre>template&lt;&gt;
struct std::formatter&lt;<strong class="bold">fs::path</strong>&gt;: std::formatter&lt;std::string&gt; {
    template&lt;typename FormatContext&gt;
    auto format(const <strong class="bold">fs::path</strong>&amp; p, FormatContext&amp; ctx) {
        return format_to(ctx.out(), "{}", p.string());
    }
};</pre></li>
				<li>We<a id="_idIndexMarker1020"/> have a simple function for<a id="_idIndexMarker1021"/> getting regular expression matches from<a id="_idIndexMarker1022"/> a file:<pre><strong class="bold">match_v</strong> matches(const fs::path&amp; <strong class="bold">fpath</strong>, const regex&amp; <strong class="bold">re</strong>) {
    match_v <strong class="bold">matches</strong>{};
    std::ifstream <strong class="bold">instrm</strong>(fpath.string(),
        std::ios_base::in);
    string s;
    for(size_t lineno{1}; <strong class="bold">getline(instrm, s</strong>); ++lineno) {
        if(<strong class="bold">std::regex_search(s.begin(), s.end(), re)</strong>) {
            <strong class="bold">matches.emplace_back(lineno, move(s)</strong>);
        }
    }
    return <strong class="bold">matches</strong>;
}</pre></li>
			</ul>
			<p>In this function, we open the file with <code>ifstream</code>, read lines from the file with <code>getline()</code>, and match the regular expression with <code>regex_search()</code>. Results are collected in the <code>vector</code> and returned.</p>
			<ul>
				<li>We can now call this function from <code>main()</code>:<pre>int main() {
    constexpr const char * <strong class="bold">fn</strong>{ "working.cpp" };
    constexpr const char * <strong class="bold">pattern</strong>{ "path" };
    fs::path <strong class="bold">fpath</strong>{ fn };
    regex <strong class="bold">re</strong>{ pattern };
    auto <strong class="bold">regmatches</strong>{ <strong class="bold">matches(fpath, re)</strong> };
    for(const auto&amp; [<strong class="bold">lineno</strong>, <strong class="bold">line</strong>] : <strong class="bold">regmatches</strong>) {
        cout &lt;&lt; format("{}: {}\n", lineno, line);
    }
    cout &lt;&lt; format("found {} matches\n", regmatches.size());
}</pre></li>
			</ul>
			<p>In this example, we use constants for the filename and the regular expression pattern. We create <code>path</code> and <code>regex</code> objects, call the <code>matches()</code> function, and print the results.</p>
			<p>Our<a id="_idIndexMarker1023"/> output has line numbers and<a id="_idIndexMarker1024"/> strings<a id="_idIndexMarker1025"/> for the matching lines:</p>
			<pre><strong class="bold">25: struct std::formatter&lt;fs::path&gt;: std::formatter&lt;std::string&gt; {</strong>
<strong class="bold">27:     auto format(const fs::path&amp; p, FormatContext&amp; ctx) {</strong>
<strong class="bold">32: match_v matches(const fs::path&amp; fpath, const regex&amp; re) {</strong>
<strong class="bold">34:     std::ifstream instrm(fpath.string(), std::ios_base::in);</strong>
<strong class="bold">62:     constexpr const char * pattern{ "path" };</strong>
<strong class="bold">64:     fs::path fpath{ fn };</strong>
<strong class="bold">66:     auto regmatches{ matches(fpath, re) };</strong></pre>
			<ul>
				<li>Our utility needs to take command-line arguments for the <code>regex</code> pattern and filenames. It should be able to traverse directories or take a list of filenames (which may be the result of command-line wildcard expansion). This requires a bit of logic in the <code>main()</code> function.</li>
			</ul>
			<p>First, we need one more helper function:</p>
			<pre>size_t pmatches(const regex&amp; <strong class="bold">re</strong>, const fs::path&amp; <strong class="bold">epath</strong>,
        const fs::path&amp; <strong class="bold">search_path</strong>) {
    fs::path target{epath};
    auto regmatches{ <strong class="bold">matches(epath, re)</strong> };
    auto matchcount{ regmatches.size() };
    if(!matchcount) return 0;
    if(!(search_path == epath)) {
        target = 
          epath.lexically_relative(search_path);
    }
    for (const auto&amp; [lineno, line] : regmatches) {
        cout &lt;&lt; <strong class="bold">format("{} {}: {}\n", target, lineno, </strong>
<strong class="bold">          line)</strong>;
    }
    return regmatches.size();
}</pre>
			<p>This<a id="_idIndexMarker1026"/> function calls our <code>matches()</code> function<a id="_idIndexMarker1027"/> and prints the results. It takes a <code>regex</code> object<a id="_idIndexMarker1028"/> and two <code>path</code> objects. <code>epath</code> is the result of a directory search, and <code>search_path</code> is the search directory itself. We'll set these in <code>main()</code>.</p>
			<ul>
				<li>In <code>main()</code>, we use the <code>argc</code> and <code>argv</code> command-line arguments and we declare a few variables:<pre>int main(const int <strong class="bold">argc</strong>, const char** <strong class="bold">argv</strong>) {
    const char * <strong class="bold">arg_pat</strong>{};
    regex <strong class="bold">re</strong>{};
    fs::path <strong class="bold">search_path</strong>{};
    size_t <strong class="bold">matchcount</strong>{};
    ...</pre></li>
			</ul>
			<p>The <a id="_idIndexMarker1029"/>variables declared<a id="_idIndexMarker1030"/> here<a id="_idIndexMarker1031"/> are:</p>
			<ul>
				<li><code>arg_pat</code> is for the regular expression pattern from the command line</li>
				<li><code>re</code> is the <code>regex</code> object</li>
				<li><code>search_path</code> is the command-line search path argument</li>
				<li><code>matchcount</code> is for counting the matched lines</li>
			</ul>
			<ul>
				<li>Continuing in <code>main()</code>, if we have no arguments, then we print a short usage string:<pre>if(<strong class="bold">argc &lt; 2</strong>) {
    auto <strong class="bold">cmdname</strong>{ fs::path(argv[0]).filename() };
    cout &lt;&lt; format("usage: {} pattern [path/file]\n", 
        <strong class="bold">cmdname</strong>);
    return 1;
}</pre></li>
			</ul>
			<p><code>argv[1]</code> is always the invoking command from the command line. <code>cmdname</code> uses the <code>filename()</code> method to return a <code>path</code> with just the filename part of the invoking command path.</p>
			<ul>
				<li>Next, we parse the regular expression. We use a <code>try-catch</code> block to capture any error from the <code>regex</code> parser:<pre>arg_pat = argv[1];
<strong class="bold">try</strong> {
    re = <strong class="bold">regex</strong>(<strong class="bold">arg_pat</strong>, <strong class="bold">std::regex_constants::icase</strong>);
} <strong class="bold">catch</strong>(const std::regex_error&amp; e) {
    cout &lt;&lt; <strong class="bold">format("{}: {}\n", e.what(), arg_pat)</strong>;
    return 1;
}</pre></li>
			</ul>
			<p>We use the <code>icase</code> flag to tell the <code>regex</code> parser to ignore case.</p>
			<ul>
				<li>If <code>argc == 2</code>, we have just one argument, which we treat as the regular expression <a id="_idIndexMarker1032"/>pattern, and we use <a id="_idIndexMarker1033"/>the current <a id="_idIndexMarker1034"/>directory for the search path:<pre>if(argc == 2) {
    <strong class="bold">search_path</strong> = ".";
        for (const auto&amp; <strong class="bold">entry</strong> : <strong class="bold">rdit</strong>{ search_path }) {
        const auto <strong class="bold">epath</strong>{ <strong class="bold">entry.path()</strong> };
        matchcount += pmatches(<strong class="bold">re</strong>, <strong class="bold">epath</strong>, 
          <strong class="bold">search_path</strong>);
    }
}</pre></li>
			</ul>
			<p><code>rdit</code> is an alias for the <code>recursive_directory_iterator</code> class, which traverses the directory tree from the starting path, returning a <code>directory_entry</code> object for each file it encounters. We then create a <code>path</code> object and call <code>pmatches()</code> to go through the file and print any regular expression matches.</p>
			<ul>
				<li>At this point in <code>main()</code>, we know that <code>argc</code> is <code>&gt;=2</code>. Now, we handle cases where we have one or more file paths on the command line:<pre>int <strong class="bold">count</strong>{ argc - 2 };
while(count-- &gt; 0) {
    <strong class="bold">fs::path p</strong>{ argv[count + 2] };
    if(!exists(p)) {
        cout &lt;&lt; <strong class="bold">format("not found: {}\n", p)</strong>;
        continue;
    }
    if(<strong class="bold">is_directory(p)</strong>) {
        for (const auto&amp; <strong class="bold">entry</strong> : <strong class="bold">rdit</strong>{ p }) {
            const auto <strong class="bold">epath</strong>{ entry.path() };
            <strong class="bold">matchcount += pmatches(re, epath, p)</strong>;
        }
    } else {
        <strong class="bold">matchcount += pmatches(re, p, p)</strong>;
    }
}</pre></li>
			</ul>
			<p>The <code>while</code> loop<a id="_idIndexMarker1035"/> handles one or<a id="_idIndexMarker1036"/> more arguments past the search pattern on the<a id="_idIndexMarker1037"/> command line. It checks each filename to ensure it exists. Then, if it's a directory, it uses the <code>rdit</code> alias for the <code>recursive_directory_iterator</code> class to traverse the directory and call <code>pmatches()</code> to print any pattern matches in the files.</p>
			<p>If it's a single file, it calls <code>pmatches()</code> on that file.</p>
			<ul>
				<li>We can<a id="_idIndexMarker1038"/> run our <code>grep</code> clone with <a id="_idIndexMarker1039"/>one <a id="_idIndexMarker1040"/>argument as the search pattern:<pre>$ ./bwgrep using
dir.cpp 12: using std::format;
dir.cpp 13: using std::cout;
dir.cpp 14: using std::string;
...
formatter.cpp 10: using std::cout;
formatter.cpp 11: using std::string;
formatter.cpp 13: using namespace std::filesystem;
found 33 matches</pre></li>
			</ul>
			<p>We can run it with a second argument as a directory to search:</p>
			<pre>$ ./bwgrep using ..
chap04/iterator-adapters.cpp 12: using std::format;
chap04/iterator-adapters.cpp 13: using std::cout;
chap04/iterator-adapters.cpp 14: using std::cin;
...
chap01/hello-version.cpp 24: using std::print;
chap01/chrono.cpp 8: using namespace std::chrono_literals;
chap01/working.cpp 15: using std::cout;
chap01/working.cpp 34:     using std::vector;
found 529 matches</pre>
			<p>Notice<a id="_idIndexMarker1041"/> that it <em class="italic">traverses the directory tree</em> to <a id="_idIndexMarker1042"/>find files in sub-directories.</p>
			<p>Or we can run<a id="_idIndexMarker1043"/> it with a single file argument:</p>
			<pre>$ ./bwgrep using bwgrep.cpp
bwgrep.cpp 13: using std::format;
bwgrep.cpp 14: using std::cout;
bwgrep.cpp 15: using std::string;
...
bwgrep.cpp 22: using rdit = fs::recursive_directory_iterator;
bwgrep.cpp 23: using match_v = vector&lt;std::pair&lt;size_t, std::string&gt;&gt;;
found 9 matches</pre>
			<h2 id="_idParaDest-339"><a id="_idTextAnchor338"/>How it works…</h2>
			<p>While the<a id="_idIndexMarker1044"/> main task of this utility is the regular<a id="_idIndexMarker1045"/> expression matching, we're concentrating on the <a id="_idIndexMarker1046"/>technique of recursively processing directories of files.</p>
			<p>The <code>recursive_directory_iterator</code> object is interchangeable with <code>directory_iterator</code>, except <code>recursive_directory_iterator</code> operates recursively over all the entries of each sub-directory.</p>
			<h2 id="_idParaDest-340"><a id="_idTextAnchor339"/>See also…</h2>
			<p>For more about regular expressions, see the recipe <em class="italic">Parse strings with Regular Expressions</em> in <a href="B18267_07_ePub.xhtml#_idTextAnchor212"><em class="italic">Chapter 7</em></a>, <em class="italic">Strings, Streams, and Formatting</em>.</p>
			<h1 id="_idParaDest-341"><a id="_idTextAnchor340"/>Rename files with regex and directory_iterator</h1>
			<p>This <a id="_idIndexMarker1047"/>is a simple utility that renames files using regular expressions. It<a id="_idIndexMarker1048"/> uses <code>directory_iterator</code> to find the files in a directory<a id="_idIndexMarker1049"/> and <code>fs::rename()</code> to rename them.</p>
			<h2 id="_idParaDest-342"><a id="_idTextAnchor341"/>How to do it…</h2>
			<p>In this recipe, we create a file rename utility that uses regular expressions:</p>
			<ul>
				<li>We start by defining a few convenience aliases:<pre>namespace <strong class="bold">fs</strong> = std::filesystem;
using <strong class="bold">dit</strong> = fs::directory_iterator;
using <strong class="bold">pat_v</strong> = vector&lt;std::pair&lt;regex, string&gt;&gt;;</pre></li>
			</ul>
			<p>The <code>pat_v</code> alias is a vector for use with our regular expressions.</p>
			<ul>
				<li>We also continue to use the <code>formatter</code> specialization for <code>path</code> objects:<pre>template&lt;&gt;
struct std::formatter&lt;<strong class="bold">fs::path</strong>&gt;: std::formatter&lt;std::string&gt; {
    template&lt;typename FormatContext&gt;
    auto format(const <strong class="bold">fs::path</strong>&amp; p, FormatContext&amp; ctx) {
        return format_to(ctx.out(), "{}", p.string());
    }
};</pre></li>
				<li>We have a function for applying the regular expression replacement to filename strings:<pre>string <strong class="bold">replace_str</strong>(string s, const <strong class="bold">pat_v</strong>&amp; replacements) {
    for(const auto&amp; [<strong class="bold">pattern, repl</strong>] : replacements) {
        s = <strong class="bold">regex_replace(s, pattern, repl)</strong>;
    }
    return s;
}</pre></li>
			</ul>
			<p>Notice that<a id="_idIndexMarker1050"/> we loop through a <code>vector</code> of pattern/replacement<a id="_idIndexMarker1051"/> pairs, applying the regular expressions <a id="_idIndexMarker1052"/>successively. This allows us to stack our replacements.</p>
			<ul>
				<li>In <code>main()</code>, we first check the command-line arguments:<pre>int main(const int argc, const char** argv) {
    pat_v <strong class="bold">patterns</strong>{};
    if(<strong class="bold">argc &lt; 3 || argc % 2 != 1</strong>) {
        fs::path cmdname{ <strong class="bold">fs::path{argv[0]}.filename()</strong> };
        cout &lt;&lt; format(
            "<strong class="bold">usage: {} [regex replacement] ...\n</strong>", 
            <strong class="bold">cmdname</strong>);
        return 1;
    }</pre></li>
			</ul>
			<p>The command line accepts one or more <em class="italic">pairs of strings</em>. Each pair of strings includes a <em class="italic">regex</em> (regular expression) followed by a <em class="italic">replacement</em>.</p>
			<ul>
				<li>Now we populate the <code>vector</code> with <code>regex</code> and <code>string</code> objects:<pre>for(int i{ 1 }; i &lt; argc; <strong class="bold">i += 2</strong>) {
    patterns.<strong class="bold">emplace_back</strong>(<strong class="bold">argv[i]</strong>, <strong class="bold">argv[i + 1]</strong>);
}</pre></li>
			</ul>
			<p>The <code>pair</code> constructor constructs the <code>regex</code> and <code>string</code> objects in place, from the C-strings passed on the command line. These are added to the <code>vector</code> with the <code>emplace_back()</code> method.</p>
			<ul>
				<li>We search the <a id="_idIndexMarker1053"/>current directory <a id="_idIndexMarker1054"/>using<a id="_idIndexMarker1055"/> a <code>directory_iterator</code> object:<pre>for(const auto&amp; entry : dit{fs::current_path()}) {
    fs::path fpath{ entry.path() };
    string <strong class="bold">rname</strong>{
        <strong class="bold">replace_str</strong>(fpath.filename().string(), 
<strong class="bold">          </strong>patterns) };
    if(fpath.filename().string() != rname) {
        fs::path <strong class="bold">rpath</strong>{ fpath };
        rpath.<strong class="bold">replace_filename(rname)</strong>;
        if(exists(rpath)) {
            cout &lt;&lt; "Error: cannot rename - destination file exists.\n";
        } else {
            <strong class="bold">fs::rename(fpath, rpath)</strong>;
            cout &lt;&lt; format(
                "{} -&gt; {}\n", 
                fpath.filename(), 
                rpath.filename());
        }
    }
}</pre></li>
			</ul>
			<p>In this <code>for</code> loop, we call <code>replace_str()</code> to get the replacement filename and then check that the new name is not a duplicate of a file in the directory. We use the <code>replace_filename()</code> method on a <code>path</code> object to create a <code>path</code> with the new filename and use <code>fs::rename()</code> to rename the file.</p>
			<ul>
				<li>To test the<a id="_idIndexMarker1056"/> utility, I've <a id="_idIndexMarker1057"/>created a <a id="_idIndexMarker1058"/>directory with a few files in it for renaming:<pre>$ ls
bwfoo.txt bwgrep.cpp chrono.cpp dir.cpp formatter.cpp path-ops.cpp working.cpp</pre></li>
				<li>We can do something simple, like change <code>.cpp</code> to <code>.Cpp</code>:<pre>$ ../rerename .cpp .Cpp
dir.cpp -&gt; dir.Cpp
path-ops.cpp -&gt; path-ops.Cpp
bwgrep.cpp -&gt; bwgrep.Cpp
working.cpp -&gt; working.Cpp
formatter.cpp -&gt; formatter.Cpp</pre></li>
			</ul>
			<p>Let's change them back again:</p>
			<pre>$ ../rerename .Cpp .cpp
formatter.Cpp -&gt; formatter.cpp
bwgrep.Cpp -&gt; bwgrep.cpp
dir.Cpp -&gt; dir.cpp
working.Cpp -&gt; working.cpp
path-ops.Cpp -&gt; path-ops.cpp</pre>
			<ul>
				<li>Using standard regular expression syntax, I can add "<code>bw</code>" to the beginning of each of the filenames:<pre>$ ../rerename '^' bw
bwgrep.cpp -&gt; bwbwgrep.cpp
chrono.cpp -&gt; bwchrono.cpp
formatter.cpp -&gt; bwformatter.cpp
bwfoo.txt -&gt; bwbwfoo.txt
working.cpp -&gt; bwworking.cpp</pre></li>
			</ul>
			<p>Notice that it <a id="_idIndexMarker1059"/>even renamed the files that already had "<code>bw</code>" at the <a id="_idIndexMarker1060"/>beginning. Let's have it not do that. First, we<a id="_idIndexMarker1061"/> restore the filenames:</p>
			<pre>$ ../rerename '^bw' ''
bwbwgrep.cpp -&gt; bwgrep.cpp
bwworking.cpp -&gt; working.cpp
bwformatter.cpp -&gt; formatter.cpp
bwchrono.cpp -&gt; chrono.cpp
bwbwfoo.txt -&gt; bwfoo.txt</pre>
			<p>Now we use a <em class="italic">regex</em> that checks if the filename already begins with "<code>bw</code>":</p>
			<pre>$ ../rerename '^(?!bw)' bw
chrono.cpp -&gt; bwchrono.cpp
formatter.cpp -&gt; bwformatter.cpp
working.cpp -&gt; bwworking.cpp</pre>
			<p>Because we use a <code>vector</code> of regex/replacement strings, we can stack several replacements:</p>
			<pre>$ ../rerename foo bar '\.cpp$' '.xpp' grep grok
bwgrep.cpp -&gt; bwgrok.xpp
bwworking.cpp -&gt; bwworking.xpp
bwformatter.cpp -&gt; bwformatter.xpp
bwchrono.cpp -&gt; bwchrono.xpp
bwfoo.txt -&gt; bwbar.txt</pre>
			<h2 id="_idParaDest-343"><a id="_idTextAnchor342"/>How it works…</h2>
			<p>The <code>filesystem</code> part <a id="_idIndexMarker1062"/>of this recipe uses <code>directory_iterator</code> to return<a id="_idIndexMarker1063"/> a <code>directory_entry</code> object for<a id="_idIndexMarker1064"/> each file in the current directory:</p>
			<pre>for(const auto&amp; <strong class="bold">entry</strong> : <strong class="bold">dit</strong>{<strong class="bold">fs::current_path()</strong>}) {
    fs::path fpath{ <strong class="bold">entry</strong>.path() };
    ...
}</pre>
			<p>We then construct a <code>path</code> object from the <code>directory_entry</code> object to process the file.</p>
			<p>We use the <code>replace_filename()</code> method on a <code>path</code> object to create the destination for the rename operation:</p>
			<pre>fs::path rpath{ fpath };
rpath.replace_filename(rname);</pre>
			<p>Here, we create a duplicate and change its name, giving us both sides for the rename operation:</p>
			<pre>fs::rename(fpath, rpath);</pre>
			<p>On the regular expression side of the recipe, we use <code>regex_replace()</code>, which uses regular expression syntax to perform substitutions in a string:</p>
			<pre>s = regex_replace(s, pattern, repl);</pre>
			<p>Regular expression<a id="_idIndexMarker1065"/> syntax is extremely powerful. It even allows replacements to<a id="_idIndexMarker1066"/> include <a id="_idIndexMarker1067"/>sections of the search string:</p>
			<pre>$ ../rerename '(bw)(.*\.)(.*)$' '$3$2$1'
bwgrep.cpp -&gt; cppgrep.bw
bwfoo.txt -&gt; txtfoo.bw</pre>
			<p>By using parentheses in the search pattern, I can easily rearrange parts of a filename.</p>
			<h2 id="_idParaDest-344"><a id="_idTextAnchor343"/>See also…</h2>
			<p>For more about regular expressions, see the recipe <em class="italic">Parse strings with Regular Expressions</em> in <a href="B18267_07_ePub.xhtml#_idTextAnchor212"><em class="italic">Chapter 7</em></a>, <em class="italic">Strings, Streams, and Formatting</em>.</p>
			<h1 id="_idParaDest-345"><a id="_idTextAnchor344"/>Create a disk usage counter</h1>
			<p>This is a simple utility that <a id="_idIndexMarker1068"/>totals the size of every file in a directory and its sub-directories. It runs on both POSIX/Unix and Windows file systems.</p>
			<h2 id="_idParaDest-346"><a id="_idTextAnchor345"/>How to do it…</h2>
			<p>This recipe is a utility to report the size of every file in a directory and its sub-directories, along with a total. We'll re-use some of the functions we've used elsewhere in this chapter:</p>
			<ul>
				<li>We start with a few convenience aliases:<pre>namespace <strong class="bold">fs</strong> = std::filesystem;
using <strong class="bold">dit</strong> = fs::directory_iterator;
using <strong class="bold">de</strong> = fs::directory_entry;</pre></li>
				<li>We also use our <code>format</code> specialization for <code>fs::path</code> objects:<pre>template&lt;&gt;
struct std::formatter&lt;<strong class="bold">fs::path</strong>&gt;: std::formatter&lt;std::string&gt; {
    template&lt;typename FormatContext&gt;
    auto format(const <strong class="bold">fs::path</strong>&amp; p, FormatContext&amp; ctx) {
        return format_to(ctx.out(), "{}", p.string());
    }
};</pre></li>
				<li>For reporting<a id="_idIndexMarker1069"/> the size of the directory, we'll use this <code>make_commas()</code> function:<pre>string make_commas(const uintmax_t&amp; num) {
    string s{ std::to_string(num) };
    for(long l = s.length() - 3; l &gt; 0; l -= 3) {
        s.insert(l, ",");
    }
    return s;
}</pre></li>
			</ul>
			<p>We've used this before. It inserts a comma before every third character from the end.</p>
			<ul>
				<li>To sort our directory, we'll need a lowercase string function:<pre>string strlower(string s) {
    auto char_lower = [](const char&amp; c) -&gt; char {
        if(<strong class="bold">c &gt;= 'A' &amp;&amp; c &lt;= 'Z'</strong>) return <strong class="bold">c + ('a' – </strong>
<strong class="bold">           'A')</strong>;
        else return c;
    };
    <strong class="bold">std::transform(s.begin(), s.end(), s.begin(), </strong>
<strong class="bold">      char_lower);</strong>
    return s;
}</pre></li>
				<li>We need a comparison predicate for sorting <code>directory_entry</code> objects by the lowercase of the <code>path</code> name:<pre>bool dircmp_lc(const de&amp; lhs, const de&amp; rhs) {
    const auto lhstr{ lhs.path().string() };
    const auto rhstr{ rhs.path().string() };
    return <strong class="bold">strlower</strong>(lhstr) &lt; <strong class="bold">strlower</strong>(rhstr);
}</pre></li>
				<li><code>size_string()</code> returns<a id="_idIndexMarker1070"/> abbreviated values for reporting file size in gigabytes, megabytes, kilobytes, or bytes:<pre>string size_string(const uintmax_t fsize) {
    constexpr const uintmax_t <strong class="bold">kilo</strong>{ 1024 };
    constexpr const uintmax_t <strong class="bold">mega</strong>{ kilo * kilo };
    constexpr const uintmax_t <strong class="bold">giga</strong>{ mega * kilo };
    if(fsize &gt;= giga ) return format("{}{}",
        (fsize + giga / 2) / giga, <strong class="bold">'G'</strong>);
    else if (fsize &gt;= mega) return format("{}{}",
        (fsize + mega / 2) / mega, <strong class="bold">'M'</strong>);
    else if (fsize &gt;= kilo) return format("{}{}",
        (fsize + kilo / 2) / kilo, <strong class="bold">'K'</strong>);
    else return format("{}<strong class="bold">B</strong>", fsize);
}</pre></li>
				<li><code>entry_size()</code> returns the <a id="_idIndexMarker1071"/>size of a file or, if it's a directory, the recursive size of the directory:<pre><strong class="bold">uintmax_t</strong> entry_size(const <strong class="bold">fs::path</strong>&amp; p) {
    if(fs::is_regular_file(p)) <strong class="bold">return </strong>
<strong class="bold">       fs::file_size(p)</strong>;
    uintmax_t <strong class="bold">accum</strong>{};
    if(fs::is_directory(p) &amp;&amp; ! fs::is_symlink(p)) {
        for(auto&amp; e : dit{ p }) {
            <strong class="bold">accum += entry_size(e.path())</strong>;
        }
    }
    <strong class="bold">return accum</strong>;
}</pre></li>
				<li>In <code>main()</code>, we start with declarations and test if we have a valid directory to search:<pre>int main(const int argc, const char** argv) {
    auto dir{ argc &gt; 1 ? 
        fs::path(<strong class="bold">argv[1]</strong>) : <strong class="bold">fs::current_path()</strong> };
    vector&lt;de&gt; <strong class="bold">entries</strong>{};
    uintmax_t <strong class="bold">accum</strong>{};
    if (<strong class="bold">!exists(dir)</strong>) {
        cout &lt;&lt; format("path {} does not exist\n", 
          dir);
        return 1;
    }
    if(<strong class="bold">!is_directory(dir)</strong>) {
        cout &lt;&lt; format("{} is not a directory\n", 
          dir);
        return 1;
    }
    cout &lt;&lt; <strong class="bold">format("{}:\n", absolute(dir))</strong>;</pre></li>
			</ul>
			<p>For our<a id="_idIndexMarker1072"/> directory path, <code>dir</code>, we use <code>argv[1]</code> if we have an argument; otherwise, we use <code>current_path()</code> for the current directory. Then we set up an environment for our usage counter:</p>
			<ul>
				<li>The <code>vector</code> of <code>directory_entry</code> objects is used for sorting our response.</li>
				<li><code>accum</code> is used to accumulate values for our final size total.</li>
				<li>We make sure <code>dir</code> exists and is a directory before proceeding to examine the directory.</li>
			</ul>
			<ul>
				<li>Next, a simple loop to populate the <code>vector</code>. Once populated, we sort <code>entries</code> using our <code>dircmp_lc()</code> function as a comparison predicate:<pre>for (const auto&amp; e : dit{ dir }) {
    <strong class="bold">entries.emplace_back(e.path())</strong>;
}
<strong class="bold">std::sort(entries.begin(), entries.end(), dircmp_lc);</strong></pre></li>
				<li>Now that everything is set up, we can accumulate results from the sorted <code>vector</code> of <code>directory_entry</code> objects:<pre>for (const auto&amp; <strong class="bold">e</strong> : <strong class="bold">entries</strong>) {
    fs::path <strong class="bold">p</strong>{ e };
    uintmax_t <strong class="bold">esize</strong>{ <strong class="bold">entry_size(p)</strong> };
    string <strong class="bold">dir_flag</strong>{};
    <strong class="bold">accum += esize;</strong>
    if(is_directory(p) &amp;&amp; !is_symlink(p)) <strong class="bold">dir_flag = </strong>
       <strong class="bold">" </strong><strong class="bold"><img src="img/6.png" alt=""/></strong><strong class="bold">"</strong>;
    cout &lt;&lt; format("{:&gt;5} {}{}\n",
        <strong class="bold">size_string(esize)</strong>, <strong class="bold">p.filename()</strong>, <strong class="bold">dir_flag</strong>);
}
cout &lt;&lt; format("{:-&gt;25}\n", "");
cout &lt;&lt; format("<strong class="bold">total bytes:</strong> {} ({})\n",
    <strong class="bold">make_commas(accum)</strong>, <strong class="bold">size_string(accum)</strong>);</pre></li>
			</ul>
			<p>The<a id="_idIndexMarker1073"/> call to <code>entry_size()</code> returns the size of the file or directory represented in the <code>directory_entry</code> object.</p>
			<p>If the current entry is a directory (and not a <em class="italic">symbolic link</em>), we add a symbol to indicate it's a directory. I chose an inverted triangle. You may use anything here.</p>
			<p>After the loop is complete, we display the accumulated size in both bytes with commas, and the abbreviated notation from <code>size_string()</code>.</p>
			<p>Our output:</p>
			<pre><strong class="bold">/home/billw/working/cpp-stl-wkbk/chap10:</strong>
<strong class="bold"> 327K bwgrep</strong>
<strong class="bold">   3K bwgrep.cpp</strong>
<strong class="bold"> 199K dir</strong>
<strong class="bold">   4K dir.cpp</strong>
<strong class="bold"> 176K formatter</strong>
<strong class="bold"> 905B formatter.cpp</strong>
<strong class="bold">   0B include</strong>
<strong class="bold">   1K Makefile</strong>
<strong class="bold"> 181K path-ops</strong>
<strong class="bold">   1K path-ops.cpp</strong>
<strong class="bold"> 327K rerename</strong>
<strong class="bold">   2K rerename.cpp</strong>
<strong class="bold">  11K testdir </strong><strong class="bold"><img src="img/6.png" alt=""/></strong>
<strong class="bold">  11K testdir-backup </strong><strong class="bold"><img src="img/6.png" alt=""/></strong>
<strong class="bold"> 203K working</strong>
<strong class="bold">   3K working.cpp</strong>
<strong class="bold">-------------------------</strong>
<strong class="bold">total bytes: 1,484,398 (1M)</strong></pre>
			<h2 id="_idParaDest-347"><a id="_idTextAnchor346"/>How it works…</h2>
			<p>The <code>fs::file_size()</code> function <a id="_idIndexMarker1074"/>returns a <code>uintmax_t</code> value that represents the size of the file as the largest natural unsigned integer on a given platform. While this is normally a 64-bit integer on most 64-bit systems, a notable exception is Windows, which uses a 32-bit integer. This means that while <code>size_t</code> may work for this value on some systems, it fails to compile on Windows because it may try to promote a 64-bit value to a 32-bit value.</p>
			<p>The <code>entry_size()</code> function takes a <code>path</code> object and returns a <code>uintmax_t</code> value:</p>
			<pre><strong class="bold">uintmax_t</strong> entry_size(const <strong class="bold">fs::path</strong>&amp; p) {
    if(<strong class="bold">fs::is_regular_file(p)</strong>) return <strong class="bold">fs::file_size(p)</strong>;
    uintmax_t accum{};
    if(<strong class="bold">fs::is_directory(p)</strong> &amp;&amp; !<strong class="bold">fs::is_symlink(p)</strong>) {
        for(auto&amp; e : <strong class="bold">dit</strong>{ p }) {
            accum += <strong class="bold">entry_size(e.path()</strong>);
        }
    }
    return accum;
}</pre>
			<p>The function<a id="_idIndexMarker1075"/> checks for a regular file and returns the size of the file. Otherwise, it checks for a directory that is not also a symbolic link. We just want the size of the files in a directory, so we don't want to follow symbolic links. (Symbolic links may also cause reference loops, leading to a runaway condition.)</p>
			<p>If we find a directory, we loop through it, calling <code>entry_size()</code> for each file we encounter. This is a recursive loop, so we eventually end up with the size of the directory.</p>
		</div>
	</body></html>