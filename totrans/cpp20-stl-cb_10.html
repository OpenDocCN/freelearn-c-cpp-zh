<html><head></head><body>
		<div id="_idContainer048">
			<h1 id="_idParaDest-325"><em class="italic"><a id="_idTextAnchor324"/>Chapter 10</em>: Using the File System</h1>
			<p>The purpose of the STL <strong class="source-inline">filesystem</strong> library is to normalize file system operations across platforms. The <strong class="source-inline">filesystem</strong> library<a id="_idIndexMarker963"/> seeks to normalize operations, bridging irregularities between POSIX/Unix, Windows, and other file systems.</p>
			<p>The <strong class="source-inline">filesystem</strong> library was adopted from the corresponding <em class="italic">Boost</em> library and incorporated into the STL with C++17. At the time of writing, there are still gaps in its implementation on some systems, but the recipes in this chapter have been tested on Linux, Windows, and macOS file systems, and compiled with the latest available versions of the GCC, MSVC, and Clang compilers, respectively.</p>
			<p>The library uses the <strong class="source-inline">&lt;filesystem&gt;</strong> header, and the <strong class="source-inline">std::filesystem</strong> namespace is commonly aliased as <strong class="source-inline">fs</strong>:</p>
			<p class="source-code">namespace fs = std::filesystem;</p>
			<p>The <strong class="source-inline">fs::path</strong> class<a id="_idIndexMarker964"/> is at the core of the <strong class="source-inline">filesystem</strong> library. It provides normalized filename and directory path representation across disparate environments. A <strong class="source-inline">path</strong> object may represent a file, a directory, or any object in a , even a non-existent or impossible object.</p>
			<p>In the following recipes, we cover tools for working with files and directories using the <strong class="source-inline">filesystem</strong> library:</p>
			<ul>
				<li>Specialize <strong class="source-inline">std::formatter</strong> for the <strong class="source-inline">path</strong> class</li>
				<li>Use manipulation functions with <strong class="source-inline">path</strong></li>
				<li>List files in a directory</li>
				<li>Search directories and files with a <strong class="source-inline">grep</strong> utility</li>
				<li>Rename files with <strong class="source-inline">regex</strong> and <strong class="source-inline">directory_iterator</strong></li>
				<li>Create a disk usage counter</li>
			</ul>
			<h1 id="_idParaDest-326"><a id="_idTextAnchor325"/>Technical requirements</h1>
			<p>You can find the code files for this chapter on GitHub at <a href="https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap10">https://github.com/PacktPublishing/CPP-20-STL-Cookbook/tree/main/chap10</a>.</p>
			<h1 id="_idParaDest-327"><a id="_idTextAnchor326"/>Specialize std::formatter for the path class</h1>
			<p>The <strong class="source-inline">path</strong> class<a id="_idIndexMarker965"/> is used throughout the <strong class="source-inline">filesystem</strong> library to represent a file or directory path. On POSIX-conformant systems, such as macOS and Linux, the <strong class="source-inline">path</strong> object uses the <strong class="source-inline">char</strong> type to represent filenames. On Windows, <strong class="source-inline">path</strong> uses <strong class="source-inline">wchar_t</strong>. On Windows, <strong class="source-inline">cout</strong> and <strong class="source-inline">format()</strong> will not display primitive strings of <strong class="source-inline">wchar_t</strong> characters. This means there is no simple out-of-the-box way to write code that uses the <strong class="source-inline">filesystem</strong> library and is portable across POSIX and Windows.</p>
			<p>We could use preprocessor directives to write specific versions of code for Windows. That may be a reasonable solution for some code bases, but for this book, it's messy and does not serve the purpose of simple, portable, reusable recipes.</p>
			<p>The elegant solution is to write a C++20 <strong class="source-inline">formatter</strong> specialization for the <strong class="source-inline">path</strong> class. This allows us to display <strong class="source-inline">path</strong> objects simply and portably.</p>
			<h2 id="_idParaDest-328"><a id="_idTextAnchor327"/>How to do it…</h2>
			<p>In<a id="_idIndexMarker966"/> this recipe, we write a <strong class="source-inline">formatter</strong> specialization<a id="_idIndexMarker967"/> for use with the <strong class="source-inline">fs::path</strong> class:</p>
			<ul>
				<li>We start with a namespace alias for convenience. All the <strong class="source-inline">filesystem</strong> names are in the <strong class="source-inline">std::filesystem</strong> namespace:<p class="source-code">namespace <strong class="bold">fs</strong> = std::filesystem;</p></li>
				<li>Our <strong class="source-inline">formatter</strong> specialization for the <strong class="source-inline">path</strong> class is simple and succinct:<p class="source-code">template&lt;&gt;</p><p class="source-code">struct std::formatter&lt;<strong class="bold">fs::path</strong>&gt;: std::formatter&lt;<strong class="bold">std::string</strong>&gt; {</p><p class="source-code">    template&lt;typename FormatContext&gt;</p><p class="source-code">    auto format(<strong class="bold">const fs::path&amp; p</strong>, FormatContext&amp; ctx) {</p><p class="source-code">        return format_to(ctx.out(), "{}", <strong class="bold">p.string()</strong>);</p><p class="source-code">    }</p><p class="source-code">};</p></li>
			</ul>
			<p>Here, we're specializing <strong class="source-inline">formatter</strong> for the <strong class="source-inline">fs::path</strong> type, using its <strong class="source-inline">string()</strong> method to get a printable representation. We cannot use the <strong class="source-inline">c_str()</strong> method because it doesn't work with the <strong class="source-inline">wchar_t</strong> characters on Windows.</p>
			<p>There's a<a id="_idIndexMarker968"/> more complete <a id="_idIndexMarker969"/>explanation of <strong class="source-inline">formatter</strong> specialization in <a href="B18267_01_ePub.xhtml#_idTextAnchor027"><em class="italic">Chaper 1</em></a>, <em class="italic">New C++20 Features</em>, of this book. </p>
			<ul>
				<li>In the <strong class="source-inline">main()</strong> function, we use the command line to pass a filename or path:<p class="source-code">int main(const int <strong class="bold">argc</strong>, const char** <strong class="bold">argv</strong>) {</p><p class="source-code">    if(<strong class="bold">argc != 2</strong>) {</p><p class="source-code">        <strong class="bold">fs::path fn{ argv[0] }</strong>;</p><p class="source-code">        cout &lt;&lt; format("usage: {} &lt;path&gt;\n", </p><p class="source-code">          <strong class="bold">fn.filename()</strong>);</p><p class="source-code">        return 0;</p><p class="source-code">    }</p><p class="source-code">    <strong class="bold">fs::path dir{ argv[1] }</strong>;</p><p class="source-code">    if(!<strong class="bold">fs::exists(dir)</strong>) {</p><p class="source-code">        cout &lt;&lt; format("path: {} does not exist\n", </p><p class="source-code">          <strong class="bold">dir</strong>);</p><p class="source-code">        return 1;</p><p class="source-code">    }</p><p class="source-code">    cout &lt;&lt; format("path: {}\n", <strong class="bold">dir</strong>);</p><p class="source-code">    cout &lt;&lt; format("filename: {}\n", <strong class="bold">dir.filename()</strong>);</p><p class="source-code">    cout &lt;&lt; format("cannonical: {}\n", </p><p class="source-code">      <strong class="bold">fs::canonical(dir)</strong>);</p><p class="source-code">}</p></li>
			</ul>
			<p>The <strong class="source-inline">argc</strong> and <strong class="source-inline">argv</strong> parameters are the standard command-line arguments.</p>
			<p><strong class="source-inline">argv[0]</strong> is always the full directory path and filename for the executable itself. If we don't have the correct number of arguments, we display the filename part from <strong class="source-inline">argv[0]</strong> as part of our <em class="italic">usage</em> message.</p>
			<p>We've used<a id="_idIndexMarker970"/> some <strong class="source-inline">filesystem</strong> functions in <a id="_idIndexMarker971"/>this example:</p>
			<ul>
				<li>The <strong class="source-inline">fs::exists()</strong> function checks if a directory or file exists.</li>
				<li><strong class="source-inline">dir</strong> is a <strong class="source-inline">path</strong> object. We can now pass it directly to <strong class="source-inline">format()</strong>, using our specialization to display the string representation of the path.</li>
				<li>The <strong class="source-inline">filename()</strong> method returns a new <strong class="source-inline">path</strong> object, which we pass directly to <strong class="source-inline">format()</strong> using our specialization.</li>
				<li>The <strong class="source-inline">fs::cannonical()</strong> function takes a <strong class="source-inline">path</strong> object and returns a new <strong class="source-inline">path</strong> object with the canonical absolute directory path. We pass this <strong class="source-inline">path</strong> object directly to <strong class="source-inline">format()</strong> and it displays the directory path returned from <strong class="source-inline">cannonical()</strong>.</li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">$ ./formatter ./formatter.cpp</strong></p>
			<p class="source-code"><strong class="bold">path: ./formatter.cpp</strong></p>
			<p class="source-code"><strong class="bold">filename: formatter.cpp</strong></p>
			<p class="source-code"><strong class="bold">cannonical: /home/billw/working/chap10/formatter.cpp</strong></p>
			<h2 id="_idParaDest-329"><a id="_idTextAnchor328"/>How it works…</h2>
			<p>The <strong class="source-inline">fs::path</strong> class is <a id="_idIndexMarker972"/>used throughout the <strong class="source-inline">filesystem</strong> library to represent directory paths and filenames. By providing a <strong class="source-inline">formatter</strong> specialization, we can <a id="_idIndexMarker973"/>easily display <strong class="source-inline">path</strong> objects consistently across platforms.</p>
			<p>The <strong class="source-inline">path</strong> class provides some useful methods. We can iterate through a path to see its component parts:</p>
			<p class="source-code">fs::path <strong class="bold">p</strong>{ "~/include/bwprint.h" };</p>
			<p class="source-code">cout &lt;&lt; format("{}\n", <strong class="bold">p</strong>);</p>
			<p class="source-code">for(<strong class="bold">auto&amp; x</strong> : p) cout &lt;&lt; format("[{}] ", <strong class="bold">x</strong>);</p>
			<p class="source-code">cout &lt;&lt; '\n';</p>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">~/include/bwprint.h</strong></p>
			<p class="source-code"><strong class="bold">[~] [include] [bwprint.h]</strong></p>
			<p>The iterator returns a <strong class="source-inline">path</strong> object for each element of the path.</p>
			<p>We can also get different parts of the path:</p>
			<p class="source-code">fs::path p{ "~/include/bwprint.h" };</p>
			<p class="source-code">cout &lt;&lt; format("{}\n", p);</p>
			<p class="source-code">cout &lt;&lt; format("{}\n", p.<strong class="bold">stem</strong>());</p>
			<p class="source-code">cout &lt;&lt; format("{}\n", p.<strong class="bold">extension</strong>());</p>
			<p class="source-code">cout &lt;&lt; format("{}\n", p.<strong class="bold">filename</strong>());</p>
			<p class="source-code">cout &lt;&lt; format("{}\n", p.<strong class="bold">parent_path</strong>());</p>
			<p>Output:</p>
			<p class="source-code">~/include/bwprint.h</p>
			<p class="source-code">bwprint</p>
			<p class="source-code">.h</p>
			<p class="source-code">bwprint.h</p>
			<p class="source-code">~/include</p>
			<p>We will continue<a id="_idIndexMarker974"/> to use this <strong class="source-inline">formatter</strong> specialization <a id="_idIndexMarker975"/>for the <strong class="source-inline">path</strong> class throughout this chapter.</p>
			<h1 id="_idParaDest-330"><a id="_idTextAnchor329"/>Use manipulation functions with path</h1>
			<p>The <strong class="source-inline">filesystem</strong> library includes functions for manipulating the contents of <strong class="source-inline">path</strong> objects. In this recipe, we<a id="_idIndexMarker976"/> will consider a few of these <a id="_idIndexMarker977"/>tools.</p>
			<h2 id="_idParaDest-331"><a id="_idTextAnchor330"/>How to do it…</h2>
			<p>In this recipe, we examine some functions that manipulate the contents of <strong class="source-inline">path</strong> objects:</p>
			<ul>
				<li>We start with the <strong class="source-inline">namespace</strong> directive and our <strong class="source-inline">formatter</strong> specialization. We do this in every recipe in this chapter:<p class="source-code">namespace <strong class="bold">fs</strong> = std::filesystem;</p><p class="source-code">template&lt;&gt;</p><p class="source-code">struct std::formatter&lt;<strong class="bold">fs::path</strong>&gt;: std::formatter&lt;std::string&gt; {</p><p class="source-code">    template&lt;typename FormatContext&gt;</p><p class="source-code">    auto format(const <strong class="bold">fs::path</strong>&amp; p, FormatContext&amp; ctx) {</p><p class="source-code">        return format_to(ctx.out(), "{}", p.string());</p><p class="source-code">    }</p><p class="source-code">};</p></li>
				<li>We can get the current working directory with the <strong class="source-inline">current_path()</strong> function, which returns a <strong class="source-inline">path</strong> object:<p class="source-code">cout &lt;&lt; format("current_path: {}\n", fs::current_path());</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">current_path: /home/billw/chap10</strong></p>
			<ul>
				<li>The <strong class="source-inline">absolute()</strong> function <a id="_idIndexMarker978"/>returns an <a id="_idIndexMarker979"/>absolute path from <a id="_idIndexMarker980"/>a relative path:<p class="source-code">cout &lt;&lt; format("absolute(p): {}\n", fs::absolute(p));</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">absolute(p): /home/billw/chap10/testdir/foo.txt</strong></p>
			<p><strong class="source-inline">absolute()</strong> will also dereference symbolic links.</p>
			<ul>
				<li>The <strong class="source-inline">+=</strong> operator <em class="italic">concatenates</em> a string to the end of the <strong class="source-inline">path</strong> string:<p class="source-code">cout &lt;&lt; format("concatenate: {}\n",</p><p class="source-code">    fs::path{ "testdir" } += "foo.txt");</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">concatenate: testdirfoo.txt</strong></p>
			<ul>
				<li>The <strong class="source-inline">/=</strong> operator <em class="italic">appends</em> a string to the end of the <strong class="source-inline">path</strong> string and returns a new <strong class="source-inline">path</strong> object:<p class="source-code">cout &lt;&lt; format("append: {}\n",</p><p class="source-code">    fs::path{ "testdir" } /= "foo.txt");</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">append: testdir/foo.txt</strong></p>
			<ul>
				<li>The <strong class="source-inline">canonical()</strong> function<a id="_idIndexMarker981"/> returns the full canonical directory path:<p class="source-code">cout &lt;&lt; format("canonical: {}\n",</p><p class="source-code">    fs::canonical(fs::path{ "." } /= "testdir"));</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">canonical: /home/billw/chap10/testdir</strong></p>
			<ul>
				<li>The <strong class="source-inline">equivalent()</strong> function <a id="_idIndexMarker982"/>tests if two <a id="_idIndexMarker983"/>relative paths <a id="_idIndexMarker984"/>resolve to the same file system entity:<p class="source-code">cout &lt;&lt; format("equivalent: {}\n", </p><p class="source-code">    fs::equivalent("testdir/foo.txt", </p><p class="source-code">        "testdir/../testdir/foo.txt"));</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">equivalent: true</strong></p>
			<ul>
				<li>The <strong class="source-inline">filesystem</strong> library includes the <strong class="source-inline">filesystem_error</strong> class for exception handling:<p class="source-code">try {</p><p class="source-code">    fs::path p{ fp };</p><p class="source-code">    cout &lt;&lt; <strong class="bold">format("p: {}\n", p)</strong>;</p><p class="source-code">    ...</p><p class="source-code">    cout &lt;&lt; format("equivalent: {}\n", </p><p class="source-code">        fs::equivalent("testdir/foo.txt", </p><p class="source-code">            "testdir/../testdir/foo.txt"));</p><p class="source-code">} catch (const <strong class="bold">fs::filesystem_error</strong>&amp; e) {</p><p class="source-code">    cout &lt;&lt; format("{}\n", <strong class="bold">e.what()</strong>);</p><p class="source-code">    cout &lt;&lt; format("path1: {}\n", <strong class="bold">e.path1()</strong>);</p><p class="source-code">    cout &lt;&lt; format("path2: {}\n", <strong class="bold">e.path2()</strong>);</p><p class="source-code">}</p></li>
			</ul>
			<p>The <strong class="source-inline">filesystem_error</strong> class includes methods for displaying the error message and for <a id="_idIndexMarker985"/>getting the path(s) involved in <a id="_idIndexMarker986"/>the error.</p>
			<p>If we introduce an error into the <strong class="source-inline">equivalent()</strong> call, we can see the results of the <strong class="source-inline">fileystem_error</strong> class:</p>
			<p class="source-code">cout &lt;&lt; format("equivalent: {}\n", </p>
			<p class="source-code">    fs::equivalent("testdir/foo.txt<strong class="bold">/x</strong>", </p>
			<p class="source-code">        "testdir/../testdir/foo.txt<strong class="bold">/y</strong>"));</p>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">filesystem error: cannot check file equivalence: No such file or directory [testdir/foo.txt/x] [testdir/../testdir/foo.txt/y]</strong></p>
			<p class="source-code"><strong class="bold">path1: testdir/foo.txt/x</strong></p>
			<p class="source-code"><strong class="bold">path2: testdir/../testdir/foo.txt/y</strong></p>
			<p>This is the output on Debian with GCC.</p>
			<p>The <strong class="source-inline">filesystem_error</strong> class provides additional detail through its <strong class="source-inline">path1()</strong> and <strong class="source-inline">path2()</strong> methods. These methods return <strong class="source-inline">path</strong> objects.</p>
			<ul>
				<li>You can also use <strong class="source-inline">std::error_code</strong> with some of the <strong class="source-inline">filesystem</strong> functions:<p class="source-code">fs::path p{ fp };</p><p class="source-code"><strong class="bold">std::error_code e</strong>;</p><p class="source-code">cout &lt;&lt; format("canonical: {}\n", </p><p class="source-code">    fs::<strong class="bold">canonical(p /= "foo", e)</strong>);</p><p class="source-code">cout &lt;&lt; format("error: {}\n", e.message());</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">canonical:</strong></p>
			<p class="source-code"><strong class="bold">error: Not a directory</strong></p>
			<ul>
				<li>Even though <a id="_idIndexMarker987"/>Windows uses a very different<a id="_idIndexMarker988"/> file system, this code still works as expected, using Windows file naming conventions:<p class="source-code">p: testdir/foo.txt</p><p class="source-code">current_path: C:\Users\billw\chap10</p><p class="source-code">absolute(p): C:\Users\billw\chap10\testdir\foo.txt</p><p class="source-code">concatenate: testdirfoo.txt</p><p class="source-code">append: testdir\foo.txt</p><p class="source-code">canonical: C:\Users\billw\chap10\testdir</p><p class="source-code">equivalent: true</p></li>
			</ul>
			<h2 id="_idParaDest-332"><a id="_idTextAnchor331"/>How it works…</h2>
			<p>Most of these functions take a <strong class="source-inline">path</strong> object, an optional <strong class="source-inline">std::error_code</strong> object, and return a <strong class="source-inline">path</strong> object:</p>
			<p class="source-code">path absolute(const path&amp; p);</p>
			<p class="source-code">path absolute(const path&amp; p, std::error_code&amp; ec);</p>
			<p>The <strong class="source-inline">equivalent()</strong> function takes two <strong class="source-inline">path</strong> objects and returns a <strong class="source-inline">bool</strong>:</p>
			<p class="source-code">bool equivalent( const path&amp; p1, const path&amp; p2 );</p>
			<p class="source-code">bool equivalent( const path&amp; p1, const path&amp; p2,</p>
			<p class="source-code">    std::error_code&amp; ec );</p>
			<p>The <strong class="source-inline">path</strong> class has operators for concatenate and append. Both operators are destructive. They modify the <strong class="source-inline">path</strong> on the left-hand side of the operator:</p>
			<p class="source-code">p1 += source; // concatenate</p>
			<p class="source-code">p1 /= source; // append</p>
			<p>For the right-hand side, these operators take either a <strong class="source-inline">path</strong> object, a <strong class="source-inline">string</strong>, a <strong class="source-inline">string_view</strong>, a C-string, or a pair of iterators.</p>
			<p>The <a id="_idIndexMarker989"/>concatenate operator adds the string from <a id="_idIndexMarker990"/>the right-hand side of the operator to the end of the <strong class="source-inline">p1</strong> <strong class="source-inline">path</strong> string.</p>
			<p>The append operator adds a separator (e.g., <strong class="source-inline">/</strong> or <strong class="source-inline">\</strong>), followed by the string from the right-hand side of the operator to the end of the <strong class="source-inline">p1</strong> <strong class="source-inline">path</strong> string.</p>
			<h1 id="_idParaDest-333"><a id="_idTextAnchor332"/>List files in a directory</h1>
			<p>The <strong class="source-inline">filesystem</strong> library<a id="_idIndexMarker991"/> provides a <strong class="source-inline">directory_entry</strong> class with<a id="_idIndexMarker992"/> directory-related information about a given <strong class="source-inline">path</strong>. We can use this to create useful directory listings.</p>
			<h2 id="_idParaDest-334"><a id="_idTextAnchor333"/>How to do it…</h2>
			<p>In this recipe, we create a directory listing utility using the information in the <strong class="source-inline">directory_entry</strong> class:</p>
			<ul>
				<li>We start with our namespace alias and <strong class="source-inline">formatter</strong> specialization for displaying <strong class="source-inline">path</strong> objects:<p class="source-code">namespace <strong class="bold">fs</strong> = std::filesystem;</p><p class="source-code">template&lt;&gt;</p><p class="source-code">struct std::formatter&lt;<strong class="bold">fs::path</strong>&gt;: std::formatter&lt;std::string&gt; {</p><p class="source-code">    template&lt;typename FormatContext&gt;</p><p class="source-code">    auto format(const <strong class="bold">fs::path</strong>&amp; p, FormatContext&amp; ctx) {</p><p class="source-code">        return format_to(ctx.out(), "{}", p.string());</p><p class="source-code">    }</p><p class="source-code">};</p></li>
				<li>The <strong class="source-inline">directory_iterator</strong> class <a id="_idIndexMarker993"/>makes it easy to list a<a id="_idIndexMarker994"/> directory:<p class="source-code">int main() {</p><p class="source-code">    constexpr const char* <strong class="bold">fn</strong>{ "." };</p><p class="source-code">    <strong class="bold">const fs::path fp{fn};</strong></p><p class="source-code">    for(const auto&amp; <strong class="bold">de</strong> : <strong class="bold">fs::directory_iterator{fp}</strong>) {</p><p class="source-code">        cout &lt;&lt; format("{} ", <strong class="bold">de.path().filename()</strong>);</p><p class="source-code">    }</p><p class="source-code">    cout &lt;&lt; '\n';</p><p class="source-code">}</p></li>
			</ul>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">chrono Makefile include chrono.cpp working formatter testdir formatter.cpp working.cpp</strong></p>
			<ul>
				<li>We can add command-line options to make this work, like Unix <strong class="source-inline">ls</strong>:<p class="source-code">int main(const int argc, const char** argv) {</p><p class="source-code">    <strong class="bold">fs::path fp</strong>{ argc &gt; 1 ? argv[1] : "." };</p><p class="source-code">    if(!fs::exists(fp)) {</p><p class="source-code">        const auto <strong class="bold">cmdname</strong> { </p><p class="source-code">          <strong class="bold">fs::path{argv[0]}.filename()</strong> };</p><p class="source-code">        cout &lt;&lt; format("{}: {} does not exist\n",</p><p class="source-code">            <strong class="bold">cmdname</strong>, fp);</p><p class="source-code">        return 1;</p><p class="source-code">    }</p><p class="source-code">    if(<strong class="bold">is_directory(fp)</strong>) {</p><p class="source-code">        for(const auto&amp; <strong class="bold">de</strong> : </p><p class="source-code">          <strong class="bold">fs::directory_iterator{fp}</strong>) {</p><p class="source-code">            cout &lt;&lt; format("{} ", </p><p class="source-code">              <strong class="bold">de.path().filename()</strong>);</p><p class="source-code">        }</p><p class="source-code">    } else {</p><p class="source-code">        cout &lt;&lt; format("{} ", <strong class="bold">fp.filename()</strong>);</p><p class="source-code">    }</p><p class="source-code">    cout &lt;&lt; '\n';</p><p class="source-code">}</p></li>
			</ul>
			<p>If there is a <a id="_idIndexMarker995"/>command-line argument, we use it to create<a id="_idIndexMarker996"/> a <strong class="source-inline">path</strong> object. Otherwise, we use <strong class="source-inline">"."</strong> for the current directory.</p>
			<p>We check if the path exists with <strong class="source-inline">if_exists()</strong>. If not, we print an error message and exit. The error message includes <strong class="source-inline">cmdname</strong> from <strong class="source-inline">argv[0]</strong>.</p>
			<p>Next, we check <strong class="source-inline">is_directory()</strong>. If we have a directory, we loop through a <strong class="source-inline">directory_iterator</strong> for each entry. <strong class="source-inline">directory_iterator</strong> iterates over <strong class="source-inline">directory_entry</strong> objects. <strong class="source-inline">de.path().filename()</strong> gets the <strong class="source-inline">path</strong> and <strong class="source-inline">filename</strong> from each <strong class="source-inline">directory_entry</strong> object.</p>
			<p>Output:</p>
			<p class="source-code"><strong class="bold">$ ./working</strong></p>
			<p class="source-code"><strong class="bold">chrono Makefile include chrono.cpp working formatter testdir formatter.cpp working.cpp</strong></p>
			<p class="source-code"><strong class="bold">$ ./working working.cpp</strong></p>
			<p class="source-code"><strong class="bold">working.cpp</strong></p>
			<p class="source-code"><strong class="bold">$ ./working foo.bar</strong></p>
			<p class="source-code"><strong class="bold">working: foo.bar does not exist</strong></p>
			<ul>
				<li>If we want <a id="_idIndexMarker997"/>our output sorted, we can store our <strong class="source-inline">directory_entry</strong> objects in<a id="_idIndexMarker998"/> a sortable container.</li>
			</ul>
			<p>Let's create an alias for <strong class="source-inline">fs::directory_entry</strong>. We'll be using this a lot. This goes at the top of the file:</p>
			<p class="source-code">using <strong class="bold">de</strong> = fs::directory_entry;</p>
			<p>At the top of <strong class="source-inline">main()</strong>, we declare a <strong class="source-inline">vector</strong> of <strong class="source-inline">de</strong> objects:</p>
			<p class="source-code">vector&lt;<strong class="bold">de</strong>&gt; entries{};</p>
			<p>Inside the <strong class="source-inline">is_directory()</strong> block, we load the <strong class="source-inline">vector</strong>, sort it, and then display it:</p>
			<p class="source-code">if(<strong class="bold">is_directory(fp)</strong>) {</p>
			<p class="source-code">    for(const auto&amp; de : fs::directory_iterator{fp}) {</p>
			<p class="source-code">        <strong class="bold">entries.emplace_back(de)</strong>;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    <strong class="bold">std::sort(entries.begin(), entries.end())</strong>;</p>
			<p class="source-code">    for(const auto&amp; <strong class="bold">e</strong> : <strong class="bold">entries</strong>) {</p>
			<p class="source-code">        <strong class="bold">cout &lt;&lt; format("{} ", e.path().filename());</strong></p>
			<p class="source-code">    }</p>
			<p class="source-code">} else { ...</p>
			<p>Now our output is sorted:</p>
			<p class="source-code">Makefile chrono chrono.cpp formatter formatter.cpp include testdir working working.cpp</p>
			<p>Notice that <strong class="source-inline">Makefile</strong> is sorted first, apparently out of order. This is because capital letters sort before lowercase in ASCII order.</p>
			<ul>
				<li>If we want a case-insensitive sort, we need a comparison function that ignores case. First, we need a function to return a lowercase <strong class="source-inline">string</strong>:<p class="source-code">string <strong class="bold">strlower</strong>(string s) {</p><p class="source-code">    auto <strong class="bold">char_lower</strong> = [](const char&amp; c) -&gt; char {</p><p class="source-code">        if(c &gt;= 'A' &amp;&amp; c &lt;= 'Z') return c + ('a' - 'A');</p><p class="source-code">        else return c;</p><p class="source-code">    };</p><p class="source-code">    std::transform(s.begin(), s.end(), s.begin(),</p><p class="source-code">        <strong class="bold">char_lower</strong>);</p><p class="source-code">    return s;</p><p class="source-code">}</p></li>
			</ul>
			<p>Now we<a id="_idIndexMarker999"/> need <a id="_idIndexMarker1000"/>a function that compares two <strong class="source-inline">directory_entry</strong> objects, using <strong class="source-inline">strlower()</strong>:</p>
			<p class="source-code">bool <strong class="bold">dircmp_lc</strong>(const <strong class="bold">de</strong>&amp; lhs, const <strong class="bold">de</strong>&amp; rhs) {</p>
			<p class="source-code">    const auto lhstr{ <strong class="bold">lhs.path().string()</strong> };</p>
			<p class="source-code">    const auto rhstr{ <strong class="bold">rhs.path().string()</strong> };</p>
			<p class="source-code">    return <strong class="bold">strlower(lhstr)</strong> &lt; <strong class="bold">strlower(rhstr)</strong>;</p>
			<p class="source-code">}</p>
			<p>Now we can use <strong class="source-inline">dircmp_lc()</strong> in our sort:</p>
			<p class="source-code">std::sort(entries.begin(), entries.end(), <strong class="bold">dircmp_lc</strong>);</p>
			<p>Our output is now sorted ignoring case:</p>
			<p class="source-code"><strong class="bold">chrono chrono.cpp formatter formatter.cpp include Makefile testdir working working.cpp</strong></p>
			<ul>
				<li>At this point, we have a simple directory listing utility.</li>
			</ul>
			<p>There's a lot<a id="_idIndexMarker1001"/> more information available from the <strong class="source-inline">filesystem</strong> library. Let's <a id="_idIndexMarker1002"/>create a <strong class="source-inline">print_dir()</strong> function to gather more information and format it for display in the style of Unix <strong class="source-inline">ls</strong>:</p>
			<p class="source-code">void print_dir(const <strong class="bold">de</strong>&amp; <strong class="bold">dir</strong>) {</p>
			<p class="source-code">    using <strong class="bold">fs::perms</strong>;</p>
			<p class="source-code">    const auto <strong class="bold">fpath</strong>{ dir.path() };</p>
			<p class="source-code">    const auto <strong class="bold">fstat</strong>{ dir.symlink_status() };</p>
			<p class="source-code">    const auto <strong class="bold">fperm</strong>{ fstat.permissions() };</p>
			<p class="source-code">    const uintmax_t <strong class="bold">fsize</strong>{ </p>
			<p class="source-code">        <strong class="bold">is_regular_file(fstat)</strong> ? <strong class="bold">file_size(fpath)</strong> : 0 };</p>
			<p class="source-code">    const auto <strong class="bold">fn</strong>{ fpath.filename() };</p>
			<p class="source-code">    string <strong class="bold">suffix</strong>{};</p>
			<p class="source-code">    if(<strong class="bold">is_directory(fstat)</strong>) suffix = "/";</p>
			<p class="source-code">    else if(<strong class="bold">(fperm &amp; perms::owner_exec) != perms::none</strong>) {</p>
			<p class="source-code">        suffix = "*";</p>
			<p class="source-code">    }</p>
			<p class="source-code">    cout &lt;&lt; format("{}{}\n", fn, suffix);</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">print_dir()</strong> function takes a <strong class="source-inline">directory_entry</strong> argument. We then retrieve some useful objects from the <strong class="source-inline">directory_entry</strong> object:</p>
			<ul>
				<li><strong class="source-inline">dir.path()</strong> returns a <strong class="source-inline">path</strong> object.</li>
				<li><strong class="source-inline">dir.symlink_status()</strong> returns a <strong class="source-inline">file_status</strong> object, without following symbolic links.</li>
				<li><strong class="source-inline">fstat.permissions()</strong> returns a <strong class="source-inline">perms</strong> object.</li>
				<li><strong class="source-inline">fsize</strong> is the size of the file and <strong class="source-inline">fn</strong> is the filename <strong class="source-inline">string</strong>. We'll look more closely at each of these as we use them.</li>
			</ul>
			<p>Unix <strong class="source-inline">ls</strong> uses <a id="_idIndexMarker1003"/>trailing characters, after the filename, to<a id="_idIndexMarker1004"/> indicate a directory or an executable. We test the <strong class="source-inline">fstat</strong> object with <strong class="source-inline">is_directory()</strong> to see if the file is a directory and add a trailing <strong class="source-inline">/</strong> to the filename. Likewise, we can test if a file is executable with the <strong class="source-inline">fperm</strong> object.</p>
			<p>We call <strong class="source-inline">print_dir()</strong> from <strong class="source-inline">main()</strong> in the <strong class="source-inline">for</strong> loop after <strong class="source-inline">sort()</strong>:</p>
			<p class="source-code">std::sort(entries.begin(), entries.end(), dircmp_lc);</p>
			<p class="source-code">for(const auto&amp; e : entries) {</p>
			<p class="source-code">    <strong class="bold">print_dir(e)</strong>;</p>
			<p class="source-code">}</p>
			<p>Our output now looks like this:</p>
			<p class="source-code"><strong class="bold">chrono*</strong></p>
			<p class="source-code"><strong class="bold">chrono.cpp</strong></p>
			<p class="source-code"><strong class="bold">formatter*</strong></p>
			<p class="source-code"><strong class="bold">formatter.cpp</strong></p>
			<p class="source-code"><strong class="bold">include*</strong></p>
			<p class="source-code"><strong class="bold">Makefile</strong></p>
			<p class="source-code"><strong class="bold">testdir/</strong></p>
			<p class="source-code"><strong class="bold">working*</strong></p>
			<p class="source-code"><strong class="bold">working.cpp</strong></p>
			<ul>
				<li>Notice the <strong class="source-inline">include*</strong> entry. That's actually a symbolic link. Let's notate that properly by following the link to get the target path:<p class="source-code">string suffix{};</p><p class="source-code">if(<strong class="bold">is_symlink(fstat)</strong>) {</p><p class="source-code">    suffix = " -&gt; ";</p><p class="source-code">    suffix += <strong class="bold">fs::read_symlink(fpath).string()</strong>;</p><p class="source-code">}</p><p class="source-code">else if(is_directory(fstat)) suffix = "/";</p><p class="source-code">else if((fperm &amp; perms::owner_exec) != perms::none) suffix = "*";</p></li>
			</ul>
			<p>The <strong class="source-inline">read_symlink()</strong> function returns a <strong class="source-inline">path</strong> object. We take the <strong class="source-inline">string()</strong> representation <a id="_idIndexMarker1005"/>of the returned <strong class="source-inline">path</strong> object and add it to the <a id="_idIndexMarker1006"/>suffix for this output:</p>
			<p class="source-code"><strong class="bold">chrono*</strong></p>
			<p class="source-code"><strong class="bold">chrono.cpp</strong></p>
			<p class="source-code"><strong class="bold">formatter*</strong></p>
			<p class="source-code"><strong class="bold">formatter.cpp</strong></p>
			<p class="source-code"><strong class="bold">include -&gt; /Users/billw/include</strong></p>
			<p class="source-code"><strong class="bold">Makefile</strong></p>
			<p class="source-code"><strong class="bold">testdir/</strong></p>
			<p class="source-code"><strong class="bold">working*</strong></p>
			<p class="source-code"><strong class="bold">working.cpp</strong></p>
			<ul>
				<li>The Unix <strong class="source-inline">ls</strong> command also includes a string of characters to indicate a file's permission bits. It looks something like this: <strong class="source-inline">drwxr-xr-x</strong>.</li>
			</ul>
			<p>The <a id="_idIndexMarker1007"/>first character indicates the type of the file, for <a id="_idIndexMarker1008"/>example: <strong class="source-inline">d</strong> for directory, <strong class="source-inline">l</strong> for symbolic link, and <strong class="source-inline">-</strong> for a regular file.</p>
			<p>The <strong class="source-inline">type_char()</strong> function returns the appropriate character:</p>
			<p class="source-code">char type_char(const fs::file_status&amp; <strong class="bold">fstat</strong>) {</p>
			<p class="source-code">         if(<strong class="bold">is_symlink</strong>(fstat))        return 'l';</p>
			<p class="source-code">    else if(<strong class="bold">is_directory</strong>(fstat))      return 'd';</p>
			<p class="source-code">    else if(<strong class="bold">is_character_file</strong>(fstat)) return 'c';</p>
			<p class="source-code">    else if(<strong class="bold">is_block_file</strong>(fstat))     return 'b';</p>
			<p class="source-code">    else if(<strong class="bold">is_fifo</strong>(fstat))           return 'p';</p>
			<p class="source-code">    else if(<strong class="bold">is_socket</strong>(fstat))         return 's';</p>
			<p class="source-code">    else if(<strong class="bold">is_other</strong>(fstat))          return 'o';</p>
			<p class="source-code">    else if(<strong class="bold">is_regular_file</strong>(fstat))   return '-';</p>
			<p class="source-code">    return '?';</p>
			<p class="source-code">}</p>
			<p>The rest of the string is in three triplets. Each triplet includes positions for the read, write, and execute permission bits, in the form <strong class="source-inline">rwx</strong>. If a bit is not set, its character is replaced by a <strong class="source-inline">-</strong>. There are three triplets for three sets of permissions: owner, group, and other, respectively.</p>
			<p class="source-code">string rwx(const fs::perms&amp; p) {</p>
			<p class="source-code">    <strong class="bold">using fs::perms;</strong></p>
			<p class="source-code">    auto bit2char = [&amp;p](perms bit, char c) {</p>
			<p class="source-code">        return (p &amp; bit) == perms::none ? '-' : c;</p>
			<p class="source-code">    };</p>
			<p class="source-code">    return { bit2char(perms::<strong class="bold">owner_read</strong>,   'r'),</p>
			<p class="source-code">             bit2char(perms::<strong class="bold">owner_write</strong>,  'w'),</p>
			<p class="source-code">             bit2char(perms::<strong class="bold">owner_exec</strong>,   'x'),</p>
			<p class="source-code">             bit2char(perms::<strong class="bold">group_read</strong>,   'r'),</p>
			<p class="source-code">             bit2char(perms::<strong class="bold">group_write</strong>,  'w'),</p>
			<p class="source-code">             bit2char(perms::<strong class="bold">group_exec</strong>,   'x'),</p>
			<p class="source-code">             bit2char(perms::<strong class="bold">others_read</strong>,  'r'),</p>
			<p class="source-code">             bit2char(perms::<strong class="bold">others_write</strong>, 'w'),</p>
			<p class="source-code">             bit2char(perms::<strong class="bold">others_exec</strong>,  'x') };</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">perms</strong> object<a id="_idIndexMarker1009"/> represents the POSIX permissions bitmap, but<a id="_idIndexMarker1010"/> it's not necessarily implemented as bits. Each entry must be compared to the <strong class="source-inline">perms::none</strong> value. Our lambda function fulfills this requirement.</p>
			<p>We add this definition to the top of our <strong class="source-inline">print_dir()</strong> function:</p>
			<p class="source-code">const auto permstr{ <strong class="bold">type_char</strong>(fstat) + <strong class="bold">rwx</strong>(fperm) };</p>
			<p>We update our <strong class="source-inline">format()</strong> string:</p>
			<p class="source-code">cout &lt;&lt; format("{} {}{}\n", permstr, fn, suffix);</p>
			<p>And we get this output:</p>
			<p class="source-code">-rwxr-xr-x chrono*</p>
			<p class="source-code">-rw-r--r-- chrono.cpp</p>
			<p class="source-code">-rwxr-xr-x formatter*</p>
			<p class="source-code">-rw-r--r-- formatter.cpp</p>
			<p class="source-code">lrwxr-xr-x include -&gt; /Users/billw/include</p>
			<p class="source-code">-rw-r--r-- Makefile</p>
			<p class="source-code">drwxr-xr-x testdir/</p>
			<p class="source-code">-rwxr-xr-x working*</p>
			<p class="source-code">-rw-r--r-- working.cpp</p>
			<ul>
				<li>Now, let's<a id="_idIndexMarker1011"/> add a size string. The <strong class="source-inline">fsize</strong> value is from the <strong class="source-inline">file_size()</strong> function, which returns a <strong class="source-inline">std::uintmax_t</strong> type. This represents the<a id="_idIndexMarker1012"/> maximum size natural integer on the target system. <strong class="source-inline">uintmax_t</strong> is not always the same as <strong class="source-inline">size_t</strong> and does not always convert easily. Notably, <strong class="source-inline">uintmax_t</strong> is 32 bits on Windows, where <strong class="source-inline">size_t</strong> is 64 bits:<p class="source-code">string size_string(const uintmax_t fsize) {</p><p class="source-code">    constexpr const uintmax_t kilo{ 1024 };</p><p class="source-code">    constexpr const uintmax_t mega{ kilo * kilo };</p><p class="source-code">    constexpr const uintmax_t giga{ mega * kilo };</p><p class="source-code">    string s;</p><p class="source-code">    if(fsize &gt;= giga ) return</p><p class="source-code">        format("{}{}", (fsize + giga / 2) / giga, 'G');</p><p class="source-code">    else if (fsize &gt;= mega) return</p><p class="source-code">        format("{}{}", (fsize + mega / 2) / mega, 'M');</p><p class="source-code">    else if (fsize &gt;= kilo) return</p><p class="source-code">        format("{}{}", (fsize + kilo / 2) / kilo, 'K');</p><p class="source-code">    else return format("{}B", fsize);</p><p class="source-code">}</p></li>
			</ul>
			<p>I chose to use 1,024 as 1K in this function, as that appears to be the default on both Linux and BSD Unix. In production, this could be a command-line option.</p>
			<p>We update our <strong class="source-inline">format()</strong> string in <strong class="source-inline">main()</strong>:</p>
			<p class="source-code">cout &lt;&lt; format("{} {:&gt;6} {}{}\n",</p>
			<p class="source-code">    permstr, size_string(fsize), fn, suffix);</p>
			<p>Now, we <a id="_idIndexMarker1013"/>get <a id="_idIndexMarker1014"/>this output:</p>
			<p class="source-code"><strong class="bold">-rwxr-xr-x   284K chrono*</strong></p>
			<p class="source-code"><strong class="bold">-rw-r--r--     2K chrono.cpp</strong></p>
			<p class="source-code"><strong class="bold">-rwxr-xr-x   178K formatter*</strong></p>
			<p class="source-code"><strong class="bold">-rw-r--r--   906B formatter.cpp</strong></p>
			<p class="source-code"><strong class="bold">lrwxr-xr-x     0B include -&gt; /Users/billw/include</strong></p>
			<p class="source-code"><strong class="bold">-rw-r--r--   642B Makefile</strong></p>
			<p class="source-code"><strong class="bold">drwxr-xr-x     0B testdir/</strong></p>
			<p class="source-code"><strong class="bold">-rwxr-xr-x   197K working*</strong></p>
			<p class="source-code"><strong class="bold">-rw-r--r--     5K working.cpp</strong></p>
			<p class="callout-heading">Note</p>
			<p class="callout">This utility is designed for POSIX systems, such as Linux and macOS. It works on a Windows system, but the Windows permissions system is different from the POSIX system. On Windows, the permissions bits will always appear fully set.</p>
			<h2 id="_idParaDest-335"><a id="_idTextAnchor334"/>How it works…</h2>
			<p>The <strong class="source-inline">filesystem</strong> library carries a rich set of information through its <strong class="source-inline">directory_entry</strong> and related classes. The major classes we used in this recipe include:</p>
			<ul>
				<li>The <strong class="source-inline">path</strong> class represents a file system path, according to the rules of the target system. A <strong class="source-inline">path</strong> object is constructed from a string or another path. It need not represent an existing path, or even a possible path. The path string is parsed to component parts, including a root name, root directory, and an optional series of filenames and directory separators.</li>
				<li>The <strong class="source-inline">directory_entry</strong> class carries a <strong class="source-inline">path</strong> object as a member, and may also store additional attributes, including hard link count, status, symbolic link, file size, and last write time.</li>
				<li>The <strong class="source-inline">file_status</strong> class carries information about the type and permissions of a file. A <strong class="source-inline">perms</strong> object may be a member of <strong class="source-inline">file_status</strong>, representing the permissions structure of a file.</li>
			</ul>
			<p>There are two <a id="_idIndexMarker1015"/>functions for retrieving a <strong class="source-inline">perms</strong> object from <strong class="source-inline">file_status</strong>. The <strong class="source-inline">status()</strong> function and the <strong class="source-inline">symlink_status()</strong> function both return a <strong class="source-inline">perms</strong> object. The <a id="_idIndexMarker1016"/>difference is in how they handle a symbolic link. The <strong class="source-inline">status()</strong> function will follow a symbolic link and return the <strong class="source-inline">perms</strong> from the target file. <strong class="source-inline">symlink_status()</strong> will return the <strong class="source-inline">perms</strong> from the symbolic link itself.</p>
			<h2 id="_idParaDest-336"><a id="_idTextAnchor335"/>There's more…</h2>
			<p>I had intended to include the last-write time of each file in the directory listing.</p>
			<p>The <strong class="source-inline">directory_entry</strong> class has a member function, <strong class="source-inline">last_write_time()</strong>, which returns a <strong class="source-inline">file_time_type</strong> object representing the timestamp of the last time the file was written.</p>
			<p>Unfortunately, at the time of writing, the available implementations lack a portable way to convert a <strong class="source-inline">file_time_type</strong> object to a standard <strong class="source-inline">chrono::sys_time</strong>, suitable for use with <strong class="source-inline">cout</strong> or <strong class="source-inline">format()</strong>.</p>
			<p>For now, here's a solution that works with GCC:</p>
			<p class="source-code">string time_string(const <strong class="bold">fs::directory_entry</strong>&amp; <strong class="bold">dir</strong>) {</p>
			<p class="source-code">    <strong class="bold">using std::chrono::file_clock;</strong></p>
			<p class="source-code">    auto file_time{ dir.last_write_time() };</p>
			<p class="source-code">    return format("{:%F %T}", </p>
			<p class="source-code">        <strong class="bold">file_clock::to_sys(dir.last_write_time())</strong>);</p>
			<p class="source-code">}</p>
			<p>It's recommended that user code should use <strong class="source-inline">std::chrono::clock_cast</strong> instead of <strong class="source-inline">file::clock::to_sys</strong> to convert time points between clocks. Unfortunately, none of the currently available implementations have a working <strong class="source-inline">std::chrono::clock_cast</strong> specialization for this purpose.</p>
			<p>Using this <strong class="source-inline">time_string()</strong> function, we can add to <strong class="source-inline">print_dir()</strong>:</p>
			<p class="source-code">const string <strong class="bold">timestr</strong>{ time_string(dir) };</p>
			<p>We can then change the <strong class="source-inline">format()</strong> string:</p>
			<p class="source-code">cout &lt;&lt; format("{} {:&gt;6} {} {}{}\n",</p>
			<p class="source-code">    permstr, sizestr, <strong class="bold">timestr</strong>, fn, suffix);</p>
			<p>And we get this output:</p>
			<p class="source-code">-rwxr-xr-x   248K 2022-03-09 09:39:49 chrono*</p>
			<p class="source-code">-rw-r--r--     2K 2022-03-09 09:33:56 chrono.cpp</p>
			<p class="source-code">-rwxr-xr-x   178K 2022-03-09 09:39:49 formatter*</p>
			<p class="source-code">-rw-r--r--   906B 2022-03-09 09:33:56 formatter.cpp</p>
			<p class="source-code">lrwxrwxrwx     0B 2022-02-04 11:39:53 include -&gt; /home/billw/include</p>
			<p class="source-code">-rw-r--r--   642B 2022-03-09 14:08:37 Makefile</p>
			<p class="source-code">drwxr-xr-x     0B 2022-03-09 10:38:39 testdir/</p>
			<p class="source-code">-rwxr-xr-x   197K 2022-03-12 17:13:46 working*</p>
			<p class="source-code">-rw-r--r--     5K 2022-03-12 17:13:40 working.cpp</p>
			<p>This works on Debian with GCC-11. Do not expect it to work without modification on any other systems.</p>
			<h1 id="_idParaDest-337"><a id="_idTextAnchor336"/>Search directories and files with a grep utility</h1>
			<p>To <a id="_idIndexMarker1017"/>demonstrate traversing and searching<a id="_idIndexMarker1018"/> directory structures, we create a simple utility<a id="_idIndexMarker1019"/> that works like Unix <em class="italic">grep</em>. This utility uses <strong class="source-inline">recursive_directory_iterator</strong> to traverse nested directories and searches files for matches with a regular expression.</p>
			<h2 id="_idParaDest-338"><a id="_idTextAnchor337"/>How to do it…</h2>
			<p>In this recipe, we write a simple <em class="italic">grep</em> utility that traverses directories to search files with a regular expression:</p>
			<ul>
				<li>We start with some convenience aliases:<p class="source-code">namespace <strong class="bold">fs</strong> = std::filesystem;</p><p class="source-code">using <strong class="bold">de</strong> = fs::directory_entry;</p><p class="source-code">using <strong class="bold">rdit</strong> = fs::recursive_directory_iterator;</p><p class="source-code">using <strong class="bold">match_v</strong> = vector&lt;std::pair&lt;size_t, std::string&gt;&gt;;</p></li>
			</ul>
			<p><strong class="source-inline">match_v</strong> is a <strong class="source-inline">vector</strong> of regular expression match results.</p>
			<ul>
				<li>We continue using our <strong class="source-inline">formatter</strong> specialization for <strong class="source-inline">path</strong> objects:<p class="source-code">template&lt;&gt;</p><p class="source-code">struct std::formatter&lt;<strong class="bold">fs::path</strong>&gt;: std::formatter&lt;std::string&gt; {</p><p class="source-code">    template&lt;typename FormatContext&gt;</p><p class="source-code">    auto format(const <strong class="bold">fs::path</strong>&amp; p, FormatContext&amp; ctx) {</p><p class="source-code">        return format_to(ctx.out(), "{}", p.string());</p><p class="source-code">    }</p><p class="source-code">};</p></li>
				<li>We<a id="_idIndexMarker1020"/> have a simple function for<a id="_idIndexMarker1021"/> getting regular expression matches from<a id="_idIndexMarker1022"/> a file:<p class="source-code"><strong class="bold">match_v</strong> matches(const fs::path&amp; <strong class="bold">fpath</strong>, const regex&amp; <strong class="bold">re</strong>) {</p><p class="source-code">    match_v <strong class="bold">matches</strong>{};</p><p class="source-code">    std::ifstream <strong class="bold">instrm</strong>(fpath.string(),</p><p class="source-code">        std::ios_base::in);</p><p class="source-code">    string s;</p><p class="source-code">    for(size_t lineno{1}; <strong class="bold">getline(instrm, s</strong>); ++lineno) {</p><p class="source-code">        if(<strong class="bold">std::regex_search(s.begin(), s.end(), re)</strong>) {</p><p class="source-code">            <strong class="bold">matches.emplace_back(lineno, move(s)</strong>);</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">    return <strong class="bold">matches</strong>;</p><p class="source-code">}</p></li>
			</ul>
			<p>In this function, we open the file with <strong class="source-inline">ifstream</strong>, read lines from the file with <strong class="source-inline">getline()</strong>, and match the regular expression with <strong class="source-inline">regex_search()</strong>. Results are collected in the <strong class="source-inline">vector</strong> and returned.</p>
			<ul>
				<li>We can now call this function from <strong class="source-inline">main()</strong>:<p class="source-code">int main() {</p><p class="source-code">    constexpr const char * <strong class="bold">fn</strong>{ "working.cpp" };</p><p class="source-code">    constexpr const char * <strong class="bold">pattern</strong>{ "path" };</p><p class="source-code">    fs::path <strong class="bold">fpath</strong>{ fn };</p><p class="source-code">    regex <strong class="bold">re</strong>{ pattern };</p><p class="source-code">    auto <strong class="bold">regmatches</strong>{ <strong class="bold">matches(fpath, re)</strong> };</p><p class="source-code">    for(const auto&amp; [<strong class="bold">lineno</strong>, <strong class="bold">line</strong>] : <strong class="bold">regmatches</strong>) {</p><p class="source-code">        cout &lt;&lt; format("{}: {}\n", lineno, line);</p><p class="source-code">    }</p><p class="source-code">    cout &lt;&lt; format("found {} matches\n", regmatches.size());</p><p class="source-code">}</p></li>
			</ul>
			<p>In this example, we use constants for the filename and the regular expression pattern. We create <strong class="source-inline">path</strong> and <strong class="source-inline">regex</strong> objects, call the <strong class="source-inline">matches()</strong> function, and print the results.</p>
			<p>Our<a id="_idIndexMarker1023"/> output has line numbers and<a id="_idIndexMarker1024"/> strings<a id="_idIndexMarker1025"/> for the matching lines:</p>
			<p class="source-code"><strong class="bold">25: struct std::formatter&lt;fs::path&gt;: std::formatter&lt;std::string&gt; {</strong></p>
			<p class="source-code"><strong class="bold">27:     auto format(const fs::path&amp; p, FormatContext&amp; ctx) {</strong></p>
			<p class="source-code"><strong class="bold">32: match_v matches(const fs::path&amp; fpath, const regex&amp; re) {</strong></p>
			<p class="source-code"><strong class="bold">34:     std::ifstream instrm(fpath.string(), std::ios_base::in);</strong></p>
			<p class="source-code"><strong class="bold">62:     constexpr const char * pattern{ "path" };</strong></p>
			<p class="source-code"><strong class="bold">64:     fs::path fpath{ fn };</strong></p>
			<p class="source-code"><strong class="bold">66:     auto regmatches{ matches(fpath, re) };</strong></p>
			<ul>
				<li>Our utility needs to take command-line arguments for the <strong class="source-inline">regex</strong> pattern and filenames. It should be able to traverse directories or take a list of filenames (which may be the result of command-line wildcard expansion). This requires a bit of logic in the <strong class="source-inline">main()</strong> function.</li>
			</ul>
			<p>First, we need one more helper function:</p>
			<p class="source-code">size_t pmatches(const regex&amp; <strong class="bold">re</strong>, const fs::path&amp; <strong class="bold">epath</strong>,</p>
			<p class="source-code">        const fs::path&amp; <strong class="bold">search_path</strong>) {</p>
			<p class="source-code">    fs::path target{epath};</p>
			<p class="source-code">    auto regmatches{ <strong class="bold">matches(epath, re)</strong> };</p>
			<p class="source-code">    auto matchcount{ regmatches.size() };</p>
			<p class="source-code">    if(!matchcount) return 0;</p>
			<p class="source-code">    if(!(search_path == epath)) {</p>
			<p class="source-code">        target = </p>
			<p class="source-code">          epath.lexically_relative(search_path);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    for (const auto&amp; [lineno, line] : regmatches) {</p>
			<p class="source-code">        cout &lt;&lt; <strong class="bold">format("{} {}: {}\n", target, lineno, </strong></p>
			<p class="source-code"><strong class="bold">          line)</strong>;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    return regmatches.size();</p>
			<p class="source-code">}</p>
			<p>This<a id="_idIndexMarker1026"/> function calls our <strong class="source-inline">matches()</strong> function<a id="_idIndexMarker1027"/> and prints the results. It takes a <strong class="source-inline">regex</strong> object<a id="_idIndexMarker1028"/> and two <strong class="source-inline">path</strong> objects. <strong class="source-inline">epath</strong> is the result of a directory search, and <strong class="source-inline">search_path</strong> is the search directory itself. We'll set these in <strong class="source-inline">main()</strong>.</p>
			<ul>
				<li>In <strong class="source-inline">main()</strong>, we use the <strong class="source-inline">argc</strong> and <strong class="source-inline">argv</strong> command-line arguments and we declare a few variables:<p class="source-code">int main(const int <strong class="bold">argc</strong>, const char** <strong class="bold">argv</strong>) {</p><p class="source-code">    const char * <strong class="bold">arg_pat</strong>{};</p><p class="source-code">    regex <strong class="bold">re</strong>{};</p><p class="source-code">    fs::path <strong class="bold">search_path</strong>{};</p><p class="source-code">    size_t <strong class="bold">matchcount</strong>{};</p><p class="source-code">    ...</p></li>
			</ul>
			<p>The <a id="_idIndexMarker1029"/>variables declared<a id="_idIndexMarker1030"/> here<a id="_idIndexMarker1031"/> are:</p>
			<ul>
				<li><strong class="source-inline">arg_pat</strong> is for the regular expression pattern from the command line</li>
				<li><strong class="source-inline">re</strong> is the <strong class="source-inline">regex</strong> object</li>
				<li><strong class="source-inline">search_path</strong> is the command-line search path argument</li>
				<li><strong class="source-inline">matchcount</strong> is for counting the matched lines</li>
			</ul>
			<ul>
				<li>Continuing in <strong class="source-inline">main()</strong>, if we have no arguments, then we print a short usage string:<p class="source-code">if(<strong class="bold">argc &lt; 2</strong>) {</p><p class="source-code">    auto <strong class="bold">cmdname</strong>{ fs::path(argv[0]).filename() };</p><p class="source-code">    cout &lt;&lt; format("usage: {} pattern [path/file]\n", </p><p class="source-code">        <strong class="bold">cmdname</strong>);</p><p class="source-code">    return 1;</p><p class="source-code">}</p></li>
			</ul>
			<p><strong class="source-inline">argv[1]</strong> is always the invoking command from the command line. <strong class="source-inline">cmdname</strong> uses the <strong class="source-inline">filename()</strong> method to return a <strong class="source-inline">path</strong> with just the filename part of the invoking command path.</p>
			<ul>
				<li>Next, we parse the regular expression. We use a <strong class="source-inline">try-catch</strong> block to capture any error from the <strong class="source-inline">regex</strong> parser:<p class="source-code">arg_pat = argv[1];</p><p class="source-code"><strong class="bold">try</strong> {</p><p class="source-code">    re = <strong class="bold">regex</strong>(<strong class="bold">arg_pat</strong>, <strong class="bold">std::regex_constants::icase</strong>);</p><p class="source-code">} <strong class="bold">catch</strong>(const std::regex_error&amp; e) {</p><p class="source-code">    cout &lt;&lt; <strong class="bold">format("{}: {}\n", e.what(), arg_pat)</strong>;</p><p class="source-code">    return 1;</p><p class="source-code">}</p></li>
			</ul>
			<p>We use the <strong class="source-inline">icase</strong> flag to tell the <strong class="source-inline">regex</strong> parser to ignore case.</p>
			<ul>
				<li>If <strong class="source-inline">argc == 2</strong>, we have just one argument, which we treat as the regular expression <a id="_idIndexMarker1032"/>pattern, and we use <a id="_idIndexMarker1033"/>the current <a id="_idIndexMarker1034"/>directory for the search path:<p class="source-code">if(argc == 2) {</p><p class="source-code">    <strong class="bold">search_path</strong> = ".";</p><p class="source-code">        for (const auto&amp; <strong class="bold">entry</strong> : <strong class="bold">rdit</strong>{ search_path }) {</p><p class="source-code">        const auto <strong class="bold">epath</strong>{ <strong class="bold">entry.path()</strong> };</p><p class="source-code">        matchcount += pmatches(<strong class="bold">re</strong>, <strong class="bold">epath</strong>, </p><p class="source-code">          <strong class="bold">search_path</strong>);</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ul>
			<p><strong class="source-inline">rdit</strong> is an alias for the <strong class="source-inline">recursive_directory_iterator</strong> class, which traverses the directory tree from the starting path, returning a <strong class="source-inline">directory_entry</strong> object for each file it encounters. We then create a <strong class="source-inline">path</strong> object and call <strong class="source-inline">pmatches()</strong> to go through the file and print any regular expression matches.</p>
			<ul>
				<li>At this point in <strong class="source-inline">main()</strong>, we know that <strong class="source-inline">argc</strong> is <strong class="source-inline">&gt;=2</strong>. Now, we handle cases where we have one or more file paths on the command line:<p class="source-code">int <strong class="bold">count</strong>{ argc - 2 };</p><p class="source-code">while(count-- &gt; 0) {</p><p class="source-code">    <strong class="bold">fs::path p</strong>{ argv[count + 2] };</p><p class="source-code">    if(!exists(p)) {</p><p class="source-code">        cout &lt;&lt; <strong class="bold">format("not found: {}\n", p)</strong>;</p><p class="source-code">        continue;</p><p class="source-code">    }</p><p class="source-code">    if(<strong class="bold">is_directory(p)</strong>) {</p><p class="source-code">        for (const auto&amp; <strong class="bold">entry</strong> : <strong class="bold">rdit</strong>{ p }) {</p><p class="source-code">            const auto <strong class="bold">epath</strong>{ entry.path() };</p><p class="source-code">            <strong class="bold">matchcount += pmatches(re, epath, p)</strong>;</p><p class="source-code">        }</p><p class="source-code">    } else {</p><p class="source-code">        <strong class="bold">matchcount += pmatches(re, p, p)</strong>;</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ul>
			<p>The <strong class="source-inline">while</strong> loop<a id="_idIndexMarker1035"/> handles one or<a id="_idIndexMarker1036"/> more arguments past the search pattern on the<a id="_idIndexMarker1037"/> command line. It checks each filename to ensure it exists. Then, if it's a directory, it uses the <strong class="source-inline">rdit</strong> alias for the <strong class="source-inline">recursive_directory_iterator</strong> class to traverse the directory and call <strong class="source-inline">pmatches()</strong> to print any pattern matches in the files.</p>
			<p>If it's a single file, it calls <strong class="source-inline">pmatches()</strong> on that file.</p>
			<ul>
				<li>We can<a id="_idIndexMarker1038"/> run our <strong class="source-inline">grep</strong> clone with <a id="_idIndexMarker1039"/>one <a id="_idIndexMarker1040"/>argument as the search pattern:<p class="source-code">$ ./bwgrep using</p><p class="source-code">dir.cpp 12: using std::format;</p><p class="source-code">dir.cpp 13: using std::cout;</p><p class="source-code">dir.cpp 14: using std::string;</p><p class="source-code">...</p><p class="source-code">formatter.cpp 10: using std::cout;</p><p class="source-code">formatter.cpp 11: using std::string;</p><p class="source-code">formatter.cpp 13: using namespace std::filesystem;</p><p class="source-code">found 33 matches</p></li>
			</ul>
			<p>We can run it with a second argument as a directory to search:</p>
			<p class="source-code">$ ./bwgrep using ..</p>
			<p class="source-code">chap04/iterator-adapters.cpp 12: using std::format;</p>
			<p class="source-code">chap04/iterator-adapters.cpp 13: using std::cout;</p>
			<p class="source-code">chap04/iterator-adapters.cpp 14: using std::cin;</p>
			<p class="source-code">...</p>
			<p class="source-code">chap01/hello-version.cpp 24: using std::print;</p>
			<p class="source-code">chap01/chrono.cpp 8: using namespace std::chrono_literals;</p>
			<p class="source-code">chap01/working.cpp 15: using std::cout;</p>
			<p class="source-code">chap01/working.cpp 34:     using std::vector;</p>
			<p class="source-code">found 529 matches</p>
			<p>Notice<a id="_idIndexMarker1041"/> that it <em class="italic">traverses the directory tree</em> to <a id="_idIndexMarker1042"/>find files in sub-directories.</p>
			<p>Or we can run<a id="_idIndexMarker1043"/> it with a single file argument:</p>
			<p class="source-code">$ ./bwgrep using bwgrep.cpp</p>
			<p class="source-code">bwgrep.cpp 13: using std::format;</p>
			<p class="source-code">bwgrep.cpp 14: using std::cout;</p>
			<p class="source-code">bwgrep.cpp 15: using std::string;</p>
			<p class="source-code">...</p>
			<p class="source-code">bwgrep.cpp 22: using rdit = fs::recursive_directory_iterator;</p>
			<p class="source-code">bwgrep.cpp 23: using match_v = vector&lt;std::pair&lt;size_t, std::string&gt;&gt;;</p>
			<p class="source-code">found 9 matches</p>
			<h2 id="_idParaDest-339"><a id="_idTextAnchor338"/>How it works…</h2>
			<p>While the<a id="_idIndexMarker1044"/> main task of this utility is the regular<a id="_idIndexMarker1045"/> expression matching, we're concentrating on the <a id="_idIndexMarker1046"/>technique of recursively processing directories of files.</p>
			<p>The <strong class="source-inline">recursive_directory_iterator</strong> object is interchangeable with <strong class="source-inline">directory_iterator</strong>, except <strong class="source-inline">recursive_directory_iterator</strong> operates recursively over all the entries of each sub-directory.</p>
			<h2 id="_idParaDest-340"><a id="_idTextAnchor339"/>See also…</h2>
			<p>For more about regular expressions, see the recipe <em class="italic">Parse strings with Regular Expressions</em> in <a href="B18267_07_ePub.xhtml#_idTextAnchor212"><em class="italic">Chapter 7</em></a>, <em class="italic">Strings, Streams, and Formatting</em>.</p>
			<h1 id="_idParaDest-341"><a id="_idTextAnchor340"/>Rename files with regex and directory_iterator</h1>
			<p>This <a id="_idIndexMarker1047"/>is a simple utility that renames files using regular expressions. It<a id="_idIndexMarker1048"/> uses <strong class="source-inline">directory_iterator</strong> to find the files in a directory<a id="_idIndexMarker1049"/> and <strong class="source-inline">fs::rename()</strong> to rename them.</p>
			<h2 id="_idParaDest-342"><a id="_idTextAnchor341"/>How to do it…</h2>
			<p>In this recipe, we create a file rename utility that uses regular expressions:</p>
			<ul>
				<li>We start by defining a few convenience aliases:<p class="source-code">namespace <strong class="bold">fs</strong> = std::filesystem;</p><p class="source-code">using <strong class="bold">dit</strong> = fs::directory_iterator;</p><p class="source-code">using <strong class="bold">pat_v</strong> = vector&lt;std::pair&lt;regex, string&gt;&gt;;</p></li>
			</ul>
			<p>The <strong class="source-inline">pat_v</strong> alias is a vector for use with our regular expressions.</p>
			<ul>
				<li>We also continue to use the <strong class="source-inline">formatter</strong> specialization for <strong class="source-inline">path</strong> objects:<p class="source-code">template&lt;&gt;</p><p class="source-code">struct std::formatter&lt;<strong class="bold">fs::path</strong>&gt;: std::formatter&lt;std::string&gt; {</p><p class="source-code">    template&lt;typename FormatContext&gt;</p><p class="source-code">    auto format(const <strong class="bold">fs::path</strong>&amp; p, FormatContext&amp; ctx) {</p><p class="source-code">        return format_to(ctx.out(), "{}", p.string());</p><p class="source-code">    }</p><p class="source-code">};</p></li>
				<li>We have a function for applying the regular expression replacement to filename strings:<p class="source-code">string <strong class="bold">replace_str</strong>(string s, const <strong class="bold">pat_v</strong>&amp; replacements) {</p><p class="source-code">    for(const auto&amp; [<strong class="bold">pattern, repl</strong>] : replacements) {</p><p class="source-code">        s = <strong class="bold">regex_replace(s, pattern, repl)</strong>;</p><p class="source-code">    }</p><p class="source-code">    return s;</p><p class="source-code">}</p></li>
			</ul>
			<p>Notice that<a id="_idIndexMarker1050"/> we loop through a <strong class="source-inline">vector</strong> of pattern/replacement<a id="_idIndexMarker1051"/> pairs, applying the regular expressions <a id="_idIndexMarker1052"/>successively. This allows us to stack our replacements.</p>
			<ul>
				<li>In <strong class="source-inline">main()</strong>, we first check the command-line arguments:<p class="source-code">int main(const int argc, const char** argv) {</p><p class="source-code">    pat_v <strong class="bold">patterns</strong>{};</p><p class="source-code">    if(<strong class="bold">argc &lt; 3 || argc % 2 != 1</strong>) {</p><p class="source-code">        fs::path cmdname{ <strong class="bold">fs::path{argv[0]}.filename()</strong> };</p><p class="source-code">        cout &lt;&lt; format(</p><p class="source-code">            "<strong class="bold">usage: {} [regex replacement] ...\n</strong>", </p><p class="source-code">            <strong class="bold">cmdname</strong>);</p><p class="source-code">        return 1;</p><p class="source-code">    }</p></li>
			</ul>
			<p>The command line accepts one or more <em class="italic">pairs of strings</em>. Each pair of strings includes a <em class="italic">regex</em> (regular expression) followed by a <em class="italic">replacement</em>.</p>
			<ul>
				<li>Now we populate the <strong class="source-inline">vector</strong> with <strong class="source-inline">regex</strong> and <strong class="source-inline">string</strong> objects:<p class="source-code">for(int i{ 1 }; i &lt; argc; <strong class="bold">i += 2</strong>) {</p><p class="source-code">    patterns.<strong class="bold">emplace_back</strong>(<strong class="bold">argv[i]</strong>, <strong class="bold">argv[i + 1]</strong>);</p><p class="source-code">}</p></li>
			</ul>
			<p>The <strong class="source-inline">pair</strong> constructor constructs the <strong class="source-inline">regex</strong> and <strong class="source-inline">string</strong> objects in place, from the C-strings passed on the command line. These are added to the <strong class="source-inline">vector</strong> with the <strong class="source-inline">emplace_back()</strong> method.</p>
			<ul>
				<li>We search the <a id="_idIndexMarker1053"/>current directory <a id="_idIndexMarker1054"/>using<a id="_idIndexMarker1055"/> a <strong class="source-inline">directory_iterator</strong> object:<p class="source-code">for(const auto&amp; entry : dit{fs::current_path()}) {</p><p class="source-code">    fs::path fpath{ entry.path() };</p><p class="source-code">    string <strong class="bold">rname</strong>{</p><p class="source-code">        <strong class="bold">replace_str</strong>(fpath.filename().string(), </p><p class="source-code"><strong class="bold">          </strong>patterns) };</p><p class="source-code">    if(fpath.filename().string() != rname) {</p><p class="source-code">        fs::path <strong class="bold">rpath</strong>{ fpath };</p><p class="source-code">        rpath.<strong class="bold">replace_filename(rname)</strong>;</p><p class="source-code">        if(exists(rpath)) {</p><p class="source-code">            cout &lt;&lt; "Error: cannot rename - destination file exists.\n";</p><p class="source-code">        } else {</p><p class="source-code">            <strong class="bold">fs::rename(fpath, rpath)</strong>;</p><p class="source-code">            cout &lt;&lt; format(</p><p class="source-code">                "{} -&gt; {}\n", </p><p class="source-code">                fpath.filename(), </p><p class="source-code">                rpath.filename());</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ul>
			<p>In this <strong class="source-inline">for</strong> loop, we call <strong class="source-inline">replace_str()</strong> to get the replacement filename and then check that the new name is not a duplicate of a file in the directory. We use the <strong class="source-inline">replace_filename()</strong> method on a <strong class="source-inline">path</strong> object to create a <strong class="source-inline">path</strong> with the new filename and use <strong class="source-inline">fs::rename()</strong> to rename the file.</p>
			<ul>
				<li>To test the<a id="_idIndexMarker1056"/> utility, I've <a id="_idIndexMarker1057"/>created a <a id="_idIndexMarker1058"/>directory with a few files in it for renaming:<p class="source-code">$ ls</p><p class="source-code">bwfoo.txt bwgrep.cpp chrono.cpp dir.cpp formatter.cpp path-ops.cpp working.cpp</p></li>
				<li>We can do something simple, like change <strong class="source-inline">.cpp</strong> to <strong class="source-inline">.Cpp</strong>:<p class="source-code">$ ../rerename .cpp .Cpp</p><p class="source-code">dir.cpp -&gt; dir.Cpp</p><p class="source-code">path-ops.cpp -&gt; path-ops.Cpp</p><p class="source-code">bwgrep.cpp -&gt; bwgrep.Cpp</p><p class="source-code">working.cpp -&gt; working.Cpp</p><p class="source-code">formatter.cpp -&gt; formatter.Cpp</p></li>
			</ul>
			<p>Let's change them back again:</p>
			<p class="source-code">$ ../rerename .Cpp .cpp</p>
			<p class="source-code">formatter.Cpp -&gt; formatter.cpp</p>
			<p class="source-code">bwgrep.Cpp -&gt; bwgrep.cpp</p>
			<p class="source-code">dir.Cpp -&gt; dir.cpp</p>
			<p class="source-code">working.Cpp -&gt; working.cpp</p>
			<p class="source-code">path-ops.Cpp -&gt; path-ops.cpp</p>
			<ul>
				<li>Using standard regular expression syntax, I can add "<strong class="source-inline">bw</strong>" to the beginning of each of the filenames:<p class="source-code">$ ../rerename '^' bw</p><p class="source-code">bwgrep.cpp -&gt; bwbwgrep.cpp</p><p class="source-code">chrono.cpp -&gt; bwchrono.cpp</p><p class="source-code">formatter.cpp -&gt; bwformatter.cpp</p><p class="source-code">bwfoo.txt -&gt; bwbwfoo.txt</p><p class="source-code">working.cpp -&gt; bwworking.cpp</p></li>
			</ul>
			<p>Notice that it <a id="_idIndexMarker1059"/>even renamed the files that already had "<strong class="source-inline">bw</strong>" at the <a id="_idIndexMarker1060"/>beginning. Let's have it not do that. First, we<a id="_idIndexMarker1061"/> restore the filenames:</p>
			<p class="source-code">$ ../rerename '^bw' ''</p>
			<p class="source-code">bwbwgrep.cpp -&gt; bwgrep.cpp</p>
			<p class="source-code">bwworking.cpp -&gt; working.cpp</p>
			<p class="source-code">bwformatter.cpp -&gt; formatter.cpp</p>
			<p class="source-code">bwchrono.cpp -&gt; chrono.cpp</p>
			<p class="source-code">bwbwfoo.txt -&gt; bwfoo.txt</p>
			<p>Now we use a <em class="italic">regex</em> that checks if the filename already begins with "<strong class="source-inline">bw</strong>":</p>
			<p class="source-code">$ ../rerename '^(?!bw)' bw</p>
			<p class="source-code">chrono.cpp -&gt; bwchrono.cpp</p>
			<p class="source-code">formatter.cpp -&gt; bwformatter.cpp</p>
			<p class="source-code">working.cpp -&gt; bwworking.cpp</p>
			<p>Because we use a <strong class="source-inline">vector</strong> of regex/replacement strings, we can stack several replacements:</p>
			<p class="source-code">$ ../rerename foo bar '\.cpp$' '.xpp' grep grok</p>
			<p class="source-code">bwgrep.cpp -&gt; bwgrok.xpp</p>
			<p class="source-code">bwworking.cpp -&gt; bwworking.xpp</p>
			<p class="source-code">bwformatter.cpp -&gt; bwformatter.xpp</p>
			<p class="source-code">bwchrono.cpp -&gt; bwchrono.xpp</p>
			<p class="source-code">bwfoo.txt -&gt; bwbar.txt</p>
			<h2 id="_idParaDest-343"><a id="_idTextAnchor342"/>How it works…</h2>
			<p>The <strong class="source-inline">filesystem</strong> part <a id="_idIndexMarker1062"/>of this recipe uses <strong class="source-inline">directory_iterator</strong> to return<a id="_idIndexMarker1063"/> a <strong class="source-inline">directory_entry</strong> object for<a id="_idIndexMarker1064"/> each file in the current directory:</p>
			<p class="source-code">for(const auto&amp; <strong class="bold">entry</strong> : <strong class="bold">dit</strong>{<strong class="bold">fs::current_path()</strong>}) {</p>
			<p class="source-code">    fs::path fpath{ <strong class="bold">entry</strong>.path() };</p>
			<p class="source-code">    ...</p>
			<p class="source-code">}</p>
			<p>We then construct a <strong class="source-inline">path</strong> object from the <strong class="source-inline">directory_entry</strong> object to process the file.</p>
			<p>We use the <strong class="source-inline">replace_filename()</strong> method on a <strong class="source-inline">path</strong> object to create the destination for the rename operation:</p>
			<p class="source-code">fs::path rpath{ fpath };</p>
			<p class="source-code">rpath.replace_filename(rname);</p>
			<p>Here, we create a duplicate and change its name, giving us both sides for the rename operation:</p>
			<p class="source-code">fs::rename(fpath, rpath);</p>
			<p>On the regular expression side of the recipe, we use <strong class="source-inline">regex_replace()</strong>, which uses regular expression syntax to perform substitutions in a string:</p>
			<p class="source-code">s = regex_replace(s, pattern, repl);</p>
			<p>Regular expression<a id="_idIndexMarker1065"/> syntax is extremely powerful. It even allows replacements to<a id="_idIndexMarker1066"/> include <a id="_idIndexMarker1067"/>sections of the search string:</p>
			<p class="source-code">$ ../rerename '(bw)(.*\.)(.*)$' '$3$2$1'</p>
			<p class="source-code">bwgrep.cpp -&gt; cppgrep.bw</p>
			<p class="source-code">bwfoo.txt -&gt; txtfoo.bw</p>
			<p>By using parentheses in the search pattern, I can easily rearrange parts of a filename.</p>
			<h2 id="_idParaDest-344"><a id="_idTextAnchor343"/>See also…</h2>
			<p>For more about regular expressions, see the recipe <em class="italic">Parse strings with Regular Expressions</em> in <a href="B18267_07_ePub.xhtml#_idTextAnchor212"><em class="italic">Chapter 7</em></a>, <em class="italic">Strings, Streams, and Formatting</em>.</p>
			<h1 id="_idParaDest-345"><a id="_idTextAnchor344"/>Create a disk usage counter</h1>
			<p>This is a simple utility that <a id="_idIndexMarker1068"/>totals the size of every file in a directory and its sub-directories. It runs on both POSIX/Unix and Windows file systems.</p>
			<h2 id="_idParaDest-346"><a id="_idTextAnchor345"/>How to do it…</h2>
			<p>This recipe is a utility to report the size of every file in a directory and its sub-directories, along with a total. We'll re-use some of the functions we've used elsewhere in this chapter:</p>
			<ul>
				<li>We start with a few convenience aliases:<p class="source-code">namespace <strong class="bold">fs</strong> = std::filesystem;</p><p class="source-code">using <strong class="bold">dit</strong> = fs::directory_iterator;</p><p class="source-code">using <strong class="bold">de</strong> = fs::directory_entry;</p></li>
				<li>We also use our <strong class="source-inline">format</strong> specialization for <strong class="source-inline">fs::path</strong> objects:<p class="source-code">template&lt;&gt;</p><p class="source-code">struct std::formatter&lt;<strong class="bold">fs::path</strong>&gt;: std::formatter&lt;std::string&gt; {</p><p class="source-code">    template&lt;typename FormatContext&gt;</p><p class="source-code">    auto format(const <strong class="bold">fs::path</strong>&amp; p, FormatContext&amp; ctx) {</p><p class="source-code">        return format_to(ctx.out(), "{}", p.string());</p><p class="source-code">    }</p><p class="source-code">};</p></li>
				<li>For reporting<a id="_idIndexMarker1069"/> the size of the directory, we'll use this <strong class="source-inline">make_commas()</strong> function:<p class="source-code">string make_commas(const uintmax_t&amp; num) {</p><p class="source-code">    string s{ std::to_string(num) };</p><p class="source-code">    for(long l = s.length() - 3; l &gt; 0; l -= 3) {</p><p class="source-code">        s.insert(l, ",");</p><p class="source-code">    }</p><p class="source-code">    return s;</p><p class="source-code">}</p></li>
			</ul>
			<p>We've used this before. It inserts a comma before every third character from the end.</p>
			<ul>
				<li>To sort our directory, we'll need a lowercase string function:<p class="source-code">string strlower(string s) {</p><p class="source-code">    auto char_lower = [](const char&amp; c) -&gt; char {</p><p class="source-code">        if(<strong class="bold">c &gt;= 'A' &amp;&amp; c &lt;= 'Z'</strong>) return <strong class="bold">c + ('a' – </strong></p><p class="source-code"><strong class="bold">           'A')</strong>;</p><p class="source-code">        else return c;</p><p class="source-code">    };</p><p class="source-code">    <strong class="bold">std::transform(s.begin(), s.end(), s.begin(), </strong></p><p class="source-code"><strong class="bold">      char_lower);</strong></p><p class="source-code">    return s;</p><p class="source-code">}</p></li>
				<li>We need a comparison predicate for sorting <strong class="source-inline">directory_entry</strong> objects by the lowercase of the <strong class="source-inline">path</strong> name:<p class="source-code">bool dircmp_lc(const de&amp; lhs, const de&amp; rhs) {</p><p class="source-code">    const auto lhstr{ lhs.path().string() };</p><p class="source-code">    const auto rhstr{ rhs.path().string() };</p><p class="source-code">    return <strong class="bold">strlower</strong>(lhstr) &lt; <strong class="bold">strlower</strong>(rhstr);</p><p class="source-code">}</p></li>
				<li><strong class="source-inline">size_string()</strong> returns<a id="_idIndexMarker1070"/> abbreviated values for reporting file size in gigabytes, megabytes, kilobytes, or bytes:<p class="source-code">string size_string(const uintmax_t fsize) {</p><p class="source-code">    constexpr const uintmax_t <strong class="bold">kilo</strong>{ 1024 };</p><p class="source-code">    constexpr const uintmax_t <strong class="bold">mega</strong>{ kilo * kilo };</p><p class="source-code">    constexpr const uintmax_t <strong class="bold">giga</strong>{ mega * kilo };</p><p class="source-code">    if(fsize &gt;= giga ) return format("{}{}",</p><p class="source-code">        (fsize + giga / 2) / giga, <strong class="bold">'G'</strong>);</p><p class="source-code">    else if (fsize &gt;= mega) return format("{}{}",</p><p class="source-code">        (fsize + mega / 2) / mega, <strong class="bold">'M'</strong>);</p><p class="source-code">    else if (fsize &gt;= kilo) return format("{}{}",</p><p class="source-code">        (fsize + kilo / 2) / kilo, <strong class="bold">'K'</strong>);</p><p class="source-code">    else return format("{}<strong class="bold">B</strong>", fsize);</p><p class="source-code">}</p></li>
				<li><strong class="source-inline">entry_size()</strong> returns the <a id="_idIndexMarker1071"/>size of a file or, if it's a directory, the recursive size of the directory:<p class="source-code"><strong class="bold">uintmax_t</strong> entry_size(const <strong class="bold">fs::path</strong>&amp; p) {</p><p class="source-code">    if(fs::is_regular_file(p)) <strong class="bold">return </strong></p><p class="source-code"><strong class="bold">       fs::file_size(p)</strong>;</p><p class="source-code">    uintmax_t <strong class="bold">accum</strong>{};</p><p class="source-code">    if(fs::is_directory(p) &amp;&amp; ! fs::is_symlink(p)) {</p><p class="source-code">        for(auto&amp; e : dit{ p }) {</p><p class="source-code">            <strong class="bold">accum += entry_size(e.path())</strong>;</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">    <strong class="bold">return accum</strong>;</p><p class="source-code">}</p></li>
				<li>In <strong class="source-inline">main()</strong>, we start with declarations and test if we have a valid directory to search:<p class="source-code">int main(const int argc, const char** argv) {</p><p class="source-code">    auto dir{ argc &gt; 1 ? </p><p class="source-code">        fs::path(<strong class="bold">argv[1]</strong>) : <strong class="bold">fs::current_path()</strong> };</p><p class="source-code">    vector&lt;de&gt; <strong class="bold">entries</strong>{};</p><p class="source-code">    uintmax_t <strong class="bold">accum</strong>{};</p><p class="source-code">    if (<strong class="bold">!exists(dir)</strong>) {</p><p class="source-code">        cout &lt;&lt; format("path {} does not exist\n", </p><p class="source-code">          dir);</p><p class="source-code">        return 1;</p><p class="source-code">    }</p><p class="source-code">    if(<strong class="bold">!is_directory(dir)</strong>) {</p><p class="source-code">        cout &lt;&lt; format("{} is not a directory\n", </p><p class="source-code">          dir);</p><p class="source-code">        return 1;</p><p class="source-code">    }</p><p class="source-code">    cout &lt;&lt; <strong class="bold">format("{}:\n", absolute(dir))</strong>;</p></li>
			</ul>
			<p>For our<a id="_idIndexMarker1072"/> directory path, <strong class="source-inline">dir</strong>, we use <strong class="source-inline">argv[1]</strong> if we have an argument; otherwise, we use <strong class="source-inline">current_path()</strong> for the current directory. Then we set up an environment for our usage counter:</p>
			<ul>
				<li>The <strong class="source-inline">vector</strong> of <strong class="source-inline">directory_entry</strong> objects is used for sorting our response.</li>
				<li><strong class="source-inline">accum</strong> is used to accumulate values for our final size total.</li>
				<li>We make sure <strong class="source-inline">dir</strong> exists and is a directory before proceeding to examine the directory.</li>
			</ul>
			<ul>
				<li>Next, a simple loop to populate the <strong class="source-inline">vector</strong>. Once populated, we sort <strong class="source-inline">entries</strong> using our <strong class="source-inline">dircmp_lc()</strong> function as a comparison predicate:<p class="source-code">for (const auto&amp; e : dit{ dir }) {</p><p class="source-code">    <strong class="bold">entries.emplace_back(e.path())</strong>;</p><p class="source-code">}</p><p class="source-code"><strong class="bold">std::sort(entries.begin(), entries.end(), dircmp_lc);</strong></p></li>
				<li>Now that everything is set up, we can accumulate results from the sorted <strong class="source-inline">vector</strong> of <strong class="source-inline">directory_entry</strong> objects:<p class="source-code">for (const auto&amp; <strong class="bold">e</strong> : <strong class="bold">entries</strong>) {</p><p class="source-code">    fs::path <strong class="bold">p</strong>{ e };</p><p class="source-code">    uintmax_t <strong class="bold">esize</strong>{ <strong class="bold">entry_size(p)</strong> };</p><p class="source-code">    string <strong class="bold">dir_flag</strong>{};</p><p class="source-code">    <strong class="bold">accum += esize;</strong></p><p class="source-code">    if(is_directory(p) &amp;&amp; !is_symlink(p)) <strong class="bold">dir_flag = </strong></p><p class="source-code">       <strong class="bold">" </strong><strong class="bold"><img src="image/6.png" alt=""/></strong><strong class="bold">"</strong>;</p><p class="source-code">    cout &lt;&lt; format("{:&gt;5} {}{}\n",</p><p class="source-code">        <strong class="bold">size_string(esize)</strong>, <strong class="bold">p.filename()</strong>, <strong class="bold">dir_flag</strong>);</p><p class="source-code">}</p><p class="source-code">cout &lt;&lt; format("{:-&gt;25}\n", "");</p><p class="source-code">cout &lt;&lt; format("<strong class="bold">total bytes:</strong> {} ({})\n",</p><p class="source-code">    <strong class="bold">make_commas(accum)</strong>, <strong class="bold">size_string(accum)</strong>);</p></li>
			</ul>
			<p>The<a id="_idIndexMarker1073"/> call to <strong class="source-inline">entry_size()</strong> returns the size of the file or directory represented in the <strong class="source-inline">directory_entry</strong> object.</p>
			<p>If the current entry is a directory (and not a <em class="italic">symbolic link</em>), we add a symbol to indicate it's a directory. I chose an inverted triangle. You may use anything here.</p>
			<p>After the loop is complete, we display the accumulated size in both bytes with commas, and the abbreviated notation from <strong class="source-inline">size_string()</strong>.</p>
			<p>Our output:</p>
			<p class="source-code"><strong class="bold">/home/billw/working/cpp-stl-wkbk/chap10:</strong></p>
			<p class="source-code"><strong class="bold"> 327K bwgrep</strong></p>
			<p class="source-code"><strong class="bold">   3K bwgrep.cpp</strong></p>
			<p class="source-code"><strong class="bold"> 199K dir</strong></p>
			<p class="source-code"><strong class="bold">   4K dir.cpp</strong></p>
			<p class="source-code"><strong class="bold"> 176K formatter</strong></p>
			<p class="source-code"><strong class="bold"> 905B formatter.cpp</strong></p>
			<p class="source-code"><strong class="bold">   0B include</strong></p>
			<p class="source-code"><strong class="bold">   1K Makefile</strong></p>
			<p class="source-code"><strong class="bold"> 181K path-ops</strong></p>
			<p class="source-code"><strong class="bold">   1K path-ops.cpp</strong></p>
			<p class="source-code"><strong class="bold"> 327K rerename</strong></p>
			<p class="source-code"><strong class="bold">   2K rerename.cpp</strong></p>
			<p class="source-code"><strong class="bold">  11K testdir </strong><strong class="bold"><img src="image/6.png" alt=""/></strong></p>
			<p class="source-code"><strong class="bold">  11K testdir-backup </strong><strong class="bold"><img src="image/6.png" alt=""/></strong></p>
			<p class="source-code"><strong class="bold"> 203K working</strong></p>
			<p class="source-code"><strong class="bold">   3K working.cpp</strong></p>
			<p class="source-code"><strong class="bold">-------------------------</strong></p>
			<p class="source-code"><strong class="bold">total bytes: 1,484,398 (1M)</strong></p>
			<h2 id="_idParaDest-347"><a id="_idTextAnchor346"/>How it works…</h2>
			<p>The <strong class="source-inline">fs::file_size()</strong> function <a id="_idIndexMarker1074"/>returns a <strong class="source-inline">uintmax_t</strong> value that represents the size of the file as the largest natural unsigned integer on a given platform. While this is normally a 64-bit integer on most 64-bit systems, a notable exception is Windows, which uses a 32-bit integer. This means that while <strong class="source-inline">size_t</strong> may work for this value on some systems, it fails to compile on Windows because it may try to promote a 64-bit value to a 32-bit value.</p>
			<p>The <strong class="source-inline">entry_size()</strong> function takes a <strong class="source-inline">path</strong> object and returns a <strong class="source-inline">uintmax_t</strong> value:</p>
			<p class="source-code"><strong class="bold">uintmax_t</strong> entry_size(const <strong class="bold">fs::path</strong>&amp; p) {</p>
			<p class="source-code">    if(<strong class="bold">fs::is_regular_file(p)</strong>) return <strong class="bold">fs::file_size(p)</strong>;</p>
			<p class="source-code">    uintmax_t accum{};</p>
			<p class="source-code">    if(<strong class="bold">fs::is_directory(p)</strong> &amp;&amp; !<strong class="bold">fs::is_symlink(p)</strong>) {</p>
			<p class="source-code">        for(auto&amp; e : <strong class="bold">dit</strong>{ p }) {</p>
			<p class="source-code">            accum += <strong class="bold">entry_size(e.path()</strong>);</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    return accum;</p>
			<p class="source-code">}</p>
			<p>The function<a id="_idIndexMarker1075"/> checks for a regular file and returns the size of the file. Otherwise, it checks for a directory that is not also a symbolic link. We just want the size of the files in a directory, so we don't want to follow symbolic links. (Symbolic links may also cause reference loops, leading to a runaway condition.)</p>
			<p>If we find a directory, we loop through it, calling <strong class="source-inline">entry_size()</strong> for each file we encounter. This is a recursive loop, so we eventually end up with the size of the directory.</p>
		</div>
	</body></html>