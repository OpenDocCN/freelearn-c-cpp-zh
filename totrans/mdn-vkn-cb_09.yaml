- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging and Performance Measurement Techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging failures and reverse engineering an implementation, as well as measuring
    the performance of a system once it has been authored, are as important as writing
    new code. Vulkan is a vast and complicated API and, more than ever, knowing how
    to debug it is paramount. In this chapter, we will explore several recipes on
    how to debug and inspect your implementation. We will also demonstrate how to
    measure the performance of your implementation once you can display an image onscreen.
    After all, graphics programming is all about extracting the last drop of performance
    from the hardware and Vulkan was designed to help you do just that.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Frame debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Naming Vulkan objects for easy debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Printing values from shaders in Vulkan
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intercepting validation layer messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving debug information from shaders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Measuring performance in Vulkan with timestamp queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you will need to make sure you have VS 2022 installed along
    with the Vulkan SDK. Please revisit [*Chapter 1*](B18491_01.xhtml#_idTextAnchor019)*,
    Vulkan Core Concepts*, under the *Technical requirements* section for details
    on setting up. Additionally, you will need RenderDoc and Tracy for this chapter.
    The steps to download and install these tools will be provided in the corresponding
    recipes within this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Frame debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Capturing and replaying a frame is very important for debugging graphics applications.
    Different than a live capture, in which results are captured and displayed as
    your application is running, capturing means recording all the commands sent to
    the GPU along with their data. This includes all the draw calls, shaders, textures,
    buffers, and other resources used to render the frame. Replaying a frame means
    executing those recorded commands again. Frame replay is a powerful feature for
    debugging because it allows developers to closely examine the rendering process,
    step by step, and see exactly what’s happening at each stage. If a bug or graphical
    glitch occurs, frame replay can help pin down exactly where and why it’s happening.
    There are multiple tools for frame debugging, such as RenderDoc, PIX, NVIDIA’s
    Nsight Graphics, and AMD Radeon GPU Profiler.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will focus on how to use **RenderDoc** since it is open source,
    cross-platform, and works on almost all GPUs.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a first step, you need to download RenderDoc from [https://renderdoc.org/builds](https://renderdoc.org/builds).
  prefs: []
  type: TYPE_NORMAL
- en: 'RenderDoc’s UI contains the following main components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Timeline**: This is typically found on the top row of RenderDoc’s user interface.
    The timeline provides a graphical representation of all the API calls (events)
    that occurred during the frame you’ve captured. It’s color-coded to indicate different
    types of events (such as draw calls or compute dispatches), making it easy to
    get a high-level overview of what’s happening in your frame. You can select any
    event in the timeline to view more detailed information in **Event Browser** (on
    the left side of the UI) and the various tabs on the right side of the UI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event Browser**: Located on the left side of the UI, **Event Browser** provides
    a detailed, hierarchical view of all the events in your frame. It shows the order
    of the API calls and allows you to navigate through them easily. When you select
    an event in **Event Browser**, RenderDoc will highlight the corresponding event
    in the timeline and update the tabs on the right side of the UI with information
    related to that event.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tabs** (**Texture Viewer**, **Mesh Viewer**, **Pipeline State**, and so on):
    These tabs are found on the right side of the UI, and they provide detailed information
    about the currently selected event. Each tab focuses on a different aspect of
    the rendering process:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Texture Viewer**: This tab allows you to view all of the textures that are
    used in your frame. You can inspect each texture’s properties, visualize their
    contents, and see how they are used in your shaders.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mesh Viewer**: This tab provides a visual and numerical view of the vertex
    and index buffers used by a draw call. You can inspect the raw buffer data, view
    the resulting geometry, and see how the vertices are transformed by your vertex
    shader.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pipeline State**: This tab shows the complete state of the GPU pipeline for
    the selected event. You can see all the bound resources (such as buffers and textures),
    inspect the shaders being used, and view the configuration of the various pipeline
    stages.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Figure 9**.1* shows RenderDoc’s main UI elements with a captured frame opened
    for inspection.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.1 – RenderDoc main screen](img/B18491_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – RenderDoc main screen
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will demonstrate how to use RenderDoc using executables
    from [*Chapter 1*](B18491_01.xhtml#_idTextAnchor019), *Vulkan Core Concepts*,
    and [*Chapter 3*](B18491_03.xhtml#_idTextAnchor217), *Implementing* *GPU-Driven
    Rendering*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Capturing a frame (or frames) with RenderDoc can be done programmatically or
    interactively, using the user interface. The next steps will explain how to capture
    frames from your application using RenderDoc’s user interface:'
  prefs: []
  type: TYPE_NORMAL
- en: As a first step, you can launch the application by selecting the application
    to launch in the **Launch Application** tab. Once the application is launched,
    click **Capture Frame(s) Immediately**. This will capture the current frame of
    the application, which we can inspect. Once the frame is captured, double-clicking
    it will open it for inspection. You can also save the frame on disk to open it
    later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the capture, we can select the draw call in `vkCmdDraw` (EID 7). Once
    you select it, you will see all the input and output textures used by this draw
    call in the **Texture Viewer** tab as depicted in *Figure 9**.2*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you’re interested in exploring the mesh data, the **Mesh Viewer** tab is
    your go-to tool. This feature provides a comprehensive view of both input and
    output vertex data, offering a deeper understanding of how your mesh is structured.
    Let’s say a specific vertex is giving you trouble, or you simply want to understand
    its behavior better. To achieve this, you need to select the vertex in question.
    A right-click will then reveal an option named **Debug this vertex**. Selecting
    this option will lead you to the vertex shader that was used in rendering your
    mesh. Note that the shader’s source code will only be available if the SPIR-V
    has been generated with debug symbols.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.2 – RenderDoc Texture Viewer](img/B18491_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – RenderDoc Texture Viewer
  prefs: []
  type: TYPE_NORMAL
- en: The **Pipeline State** tab is a crucial component in the RenderDoc UI. It offers
    an extensive view of the various stages, and their states, involved in the graphics
    pipeline, serving as a powerful tool for analyzing and debugging your rendering
    process. In the vertex shader stage, you can inspect the operations applied to
    each vertex. This includes transformations to position vertices in the correct
    3D space, as well as calculations to determine vertex colors or texture coordinates.
    You can also select V**iew** S**hader** to inspect the shader source code used
    during this draw call. Moving on to the fragment shader stage, the **Pipeline
    State** tab allows you to scrutinize how each fragment (potential pixel) is processed.
    This includes operations such as determining its final color based on lighting,
    texture, and/or other factors. Debugging this stage can help you resolve issues
    related to color computations, texture mapping, and more.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To debug a specific fragment, you’ll need to select a pixel in **Texture Viewer**.
    You can do this by clicking on the pixel you’re interested in. The values of this
    pixel represent the output of the fragment shader for that specific pixel. After
    selecting a pixel, you can debug the fragment shader that produced it. To do this,
    right-click on the pixel and select the **Debug** button shown inside the **Pixel
    Context** window. This will open a new **Shader Viewer** tab, where you can step
    through the shader code line by line. For each line, you can inspect the values
    of your variables and see how they change as the shader executes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The compute shader stage is used for performing general-purpose computations
    on the GPU. Here, you can inspect and debug the operations that aren’t directly
    related to rendering, such as physics simulations or culling. In the next step,
    we will demonstrate using the executable from [*Chapter 3*](B18491_03.xhtml#_idTextAnchor217),
    *Implementing GPU-Driven Rendering*, in the *Frustum culling using compute* *shaders*
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand how to debug the compute shader, we will first need to launch
    `Chapter03_GPU_Culling.exe` from RenderDoc. Once the application is up, we will
    take a capture. Next, navigate to the `vkCmdDispatch` call. Selecting this call
    in **Event Browser** will display the associated pipeline used by this call in
    the **Pipeline State** tab, as demonstrated in *Figure 9**.3*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Compute shader as seen in RenderDoc](img/B18491_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Compute shader as seen in RenderDoc
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to culling, we launch as many threads as there are meshes. Then,
    on the GPU, we’re simply discarding any mesh that isn’t visible in the frustum.
    Let’s assume we’re interested in understanding why mesh number 5 is outside the
    frustum. To debug this, click the **Debug** button and specify the thread ID in
    the **Debug Compute Shader** window. This window allows you to specify either
    a global thread ID or a thread group and a local thread ID. In our case, to debug
    mesh number 5, you would enter 5 in the global X dimension (in the **Dispatch
    Thread ID** section). Once you click the **Debug** button, a new window containing
    the shader source code will be launched. Here, you can inspect and debug the compute
    shader, enabling you to understand why a particular mesh was discarded. The process
    is demonstrated in *Figure 9**.4*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Debugging a compute shader in RenderDoc](img/B18491_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – Debugging a compute shader in RenderDoc
  prefs: []
  type: TYPE_NORMAL
- en: This recipe is a very brief introduction to *one* frame debugging tool. Keep
    in mind other tools exist and operate in different ways.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For a comprehensive understanding of how to utilize RenderDoc, we highly recommend
    viewing the following video tutorials. These will provide you with detailed insights
    into its usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://youtu.be/7eznPe3TyAY](https://youtu.be/7eznPe3TyAY)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://youtu.be/EMFG5wmng-M](https://youtu.be/EMFG5wmng-M)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://renderdoc.org/docs/getting_started/quick_start.html](https://renderdoc.org/docs/getting_started/quick_start.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Naming Vulkan objects for easy debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using Vulkan means you need to create and manage many Vulkan objects. By default,
    those objects are identified by their handle, a numerical ID. Although numerical
    IDs are easy to maintain from an application perspective, they are meaningless
    to humans. Consider the following error message, provided by the validation layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding message is useful, but finding which image has been created with
    the wrong number of layers is hard.
  prefs: []
  type: TYPE_NORMAL
- en: 'If, on the other hand, we give that image a name, the validation layer message
    becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that the name of the object is now part of the error message. That makes
    it much easier to know where to look in your code and fix the error.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use a Vulkan extension to give human-readable
    or meaningful names to all Vulkan objects.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To be able to assign names to a Vulkan object, you first need to enable the
    `VK_EXT_debug_utils` instance extension. This extension’s name needs to be provided
    during the creation of the Vulkan instance as either a string, `VK_EXT_debug_utils`,
    or using the `VK_EXT_DEBUG_UTILS_EXTENSION_NAME` macro. The following code snippet
    initializes a Vulkan instance with debug utilities enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now you are ready to start naming your Vulkan object. Let’s see how in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the extension has been enabled, here are the steps to name your objects:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the extension has been enabled, you may add a name to any Vulkan object,
    given its handle, by calling the `vkSetDebugUtilsObjectNameEXT` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The object type (`type`) is one of the values of the `VkObject` enumeration
    and must match the object’s type (`VK_OBJECT_TYPE_IMAGE` for a Vulkan Image, for
    example). The handle is the object’s handle, which needs to be cast to type `uint64_t`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This function is only available if the extension is also available, so make
    sure to guard it in an `#ifdef` block and check whether the extension has been
    enabled for the instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the repository, the `VulkanCore::Context:: setVkObjectname` method wraps
    this function in a templated class and does the casting for you. Also, it’s worth
    mentioning that names aren’t only displayed on validation error messages. They
    also appear in frame capture and debugging tools.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.5 - Examples of how object names appear in RenderDoc](img/B18491_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 - Examples of how object names appear in RenderDoc
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9**.5* shows how object names are displayed in RenderDoc. In the screenshot,
    one of the swapchain images is named **Image: Swapchain image 1**. The depth buffer
    is named **Image:** **depth buffer**.'
  prefs: []
  type: TYPE_NORMAL
- en: Printing values from shaders in Vulkan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As graphics programmers, we must all agree that debugging shaders is one of
    the most frustrating aspects of our jobs. Even though some frame capture software
    provides shader debugging, it may still be difficult to find the exact pixel you
    would like to debug, or you may need another piece of information about a set
    of pixels instead of just inspecting them one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, Vulkan provides a way to print values directly from shaders. The
    information can be inspected directly on RenderDoc, for example, or retrieved
    from the validation error messages (please refer to the *Retrieving debugging
    information from shaders* recipe for more details on how to do this).
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to print values from your shader code using
    a simple function that is like `printf`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To utilize the functionality of printing values from shaders, it’s a prerequisite
    to enable the `VK_KHR_shader_non_semantic_info` device extension. This can be
    achieved by adding either the `VK_KHR_shader_non_semantic_info` string or the
    `VK_KHR_SHADER_NON_SEMANTIC_INFO_EXTENSION_NAME` macro to the `VkDeviceCreateInfo`
    structure during the creation of a Vulkan device. This process is demonstrated
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now that the extension has been enabled, let’s see what the steps are to print
    values directly from shaders.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the extension has been enabled, you will also need to add a GLSL extension
    to your shaders:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enable the `GL_EXT_debug_printf` extension in your shader code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: debugPrintfEXT("gl_VertexIndex = %i", gl_VertexIndex);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The function provides specifiers for vector values as well. Here’s an example
    of a call that prints all components of a `vec3` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding function call prints the `x`, `y`, and `z` components of `position`
    as a floating-point value with 3 decimals.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here’s the abridged version of the vertex shader used in [*Chapter 1*](B18491_01.xhtml#_idTextAnchor019),
    *Vulkan Core Concepts*, with the added `debugPrintfEXT` call to print the `gl_VertexIndex`
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 9**.6* shows how the printed values can be inspected in RenderDoc:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – debugPrintfEXT values visible in RenderDoc](img/B18491_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – debugPrintfEXT values visible in RenderDoc
  prefs: []
  type: TYPE_NORMAL
- en: Intercepting validation layer messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some circumstances, validation errors are so plentiful that it becomes impossible
    to know where the cause of the problem is. For that reason, it would be ideal
    to interrupt the execution of your program as soon as an error is detected, especially
    when debugging your application. The debug utility extension (`VK_EXT_debug_utils`)
    allows you to install a callback function that is invoked whenever an error is
    detected.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to install a debug callback to intercept
    error messages emitted by the validation layer and make your debugging sessions
    more productive.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To be able to set a callback whenever an error occurs, you need to enable the
    `VK_EXT_debug_utils` extension. Please refer to the *Getting ready* section of
    the *Naming Vulkan objects for easier debugging* recipe to learn how to enable
    this extension when creating a Vulkan instance.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before installing and using the callback, you need to define one. After that,
    and once the extension has been enabled and a Vulkan instance object has been
    created, you need to install the callback using a special Vulkan function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a callback function with the following signature:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here’s the function used as a callback provided in the repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Your callback can decide how to treat the message, if at all, based on its type
    (general message, validation message, performance message) or its severity (verbose,
    info, warning, or error). The `pCallbackData` parameter (of type `VkDebugUtilsMessengerCallbackDataEXT`)
    provides a plethora of different information you can use, while the `pUserData`
    parameter may contain your own data, which is provided when installing the callback.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Install the callback once you have a valid Vulkan instance by creating an instance
    of the `VkDebugUtilsMessengerCreateInfoEXT` structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make sure to destroy the messenger once you are done with your Vulkan instance.
    This is necessary because, in Vulkan, any resources created need to be explicitly
    destroyed when they’re no longer needed to avoid memory leaks and to free up system
    resources:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The debug callback is very useful and should always be used. Make sure to have
    one as soon as possible and know how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving debug information from shaders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most difficult tasks in graphics programming is writing tests. Be
    those smoke, integration, end-to-end, or unit tests, how do you ensure that the
    output of your engine is really what you would expect? Except for simple tests,
    screenshot-like types of tests are prone to several problems. One particularly
    difficult problem is testing shader code – since you don’t usually have access
    to the hardware, testing shader code is very painful.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, Vulkan has a mechanism that allows you to capture the value output
    from shaders with the `debugPrintfEXT` function directly from the validation layer.
    This mechanism isn’t new and could be enabled using the `Vulkan SDK 1.3.275`,
    the `VK_EXT_layer_settings` instance extension allows you to enable this mechanism
    directly from your application without manually having to edit any other configuration.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to enable this feature and retrieve the output
    of `debugPrintfEXT` calls from shaders.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will need `Vulkan SDK version 1.3.275`. Although all the
    code in the repository was tested with `SDK version 1.3.265`, the `VK_EXT_layer_settings`
    extension was only available with `SDK 1.3.275`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Enabling this feature is easy and requires only a few steps. Let’s get to them:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `VK_EXT_layer_settings` extension introduces a way for you to change individual
    layer settings. Each setting must be set using an instance of the `VKLayerSettingEXT`
    structure, defined as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To enable the feature that allows you to receive output from shaders, you need
    to enable a few settings of the `VK_LAYER_KHRONOS_validation` layer. Let’s start
    by creating a constant with the layer name for which we’ll change the settings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we create arrays to store the values of the settings we’ll use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `debug_action` setting was changed to `VK_DBG_LAYER_ACTION_BREAK` so that
    the callback is called whenever there’s a new value from `debugPrintfEXT`. The
    `validate_gpu_based` setting is set to receive the `debugPrintEXT` values (`GPU_BASED_DEBUG_PRINTF`)
    and the `printf_to_stdout` setting (set to `VK_FALSE`) specifies we don’t want
    those values to go to `stdout`; we want to receive them in the callback.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We create instances of the `VkLayerSettingEXT` structure for each setting we
    would like to change. Here, we are changing the following settings of the `layer_name`
    layer: `debug_action`, `validate_gpu_based`, and `printf_to_stdout`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we add those settings to an instance of the `VkLayerSettingsCreateInfoEXT`
    structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we add this instance to the `pNext` chain of the `VkInstanceCreateInfo`
    structure used to create the Vulkan instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When enabled for [*Chapter 1*](B18491_01.xhtml#_idTextAnchor019), *Vulkan Core
    Concepts,* code in the repository, the message received by the callback looks
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'It is possible to enable a verbose output, in which case the preceding message
    would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Hopefully, this feature will help you write tests for obscure corners of your
    code that weren’t even possible to test before.
  prefs: []
  type: TYPE_NORMAL
- en: Measuring performance in Vulkan with timestamp queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Measuring the performance of CPU and GPU workloads side by side is invaluable.
    The **Tracy profiler** allows you to do just that in a cross-platform way with
    minimal intrusion. And it’s easy to use, all within a small C++ library.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to integrate Tracy Profiler into your app
    and instrument it to collect GPU performance information.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing to do is to download Tracy from [https://github.com/wolfpld/tracy](https://github.com/wolfpld/tracy)
    and include it in your project. You should also download the Tracy client/server
    to collect and inspect the data.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Instrumenting your code to use with Tracy is easy and requires only a few steps.
    To be able to collect data about the GPU performance, you will need a Tracy/Vulkan
    context along with a dedicated command buffer for it to calibrate the timestamps.
    After that, instrumenting your code is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, include the Tracy header file in your application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Second, you need a Tracy/Vulkan context that can be created by using a macro
    provided by the Tracy library. There are two options: one that creates a context
    with calibrated timestamps and one that creates a context without calibrated timestamps.
    Vulkan provides ways to correlate the time an operation happened on timelines
    of different time domains. Without calibration, Tracy can only guess when an operation
    on the device happened in relation to the ones that took place on the CPU. Here’s
    how you can initialize the context that better suits your needs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The command buffer used here is a dedicated one and it should not be shared
    with any other operations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Collecting GPU information is now easy. All you must do is use one of the macros
    provided by Tracy, such as the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the `commandBuffer` variable used in this macro is the command buffer
    you wish to capture data from, the one being recorded. This command buffer is
    *different* than the one provided during the construction of the Tracy context.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This macro should be added whenever you would like to instrument your GPU execution.
    For example, you might want to add this macro to a scope where you issue the draw
    call (such as `vkCmdDraw`). You will then get information about that command being
    processed in the GPU. In the repository, you can find examples of how this macro
    is used.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tracy also provides macros that allow you to identify the zone with a color
    or name, such as `TracyVkNamedZone`, `TracyVkNamedZoneC`, and so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Occasionally, you need to tell Tracy to collect the timestamps from the command
    buffer by calling `TracyVkCollect`. This macro can be called at the end of a frame:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After exiting the render loop, and before shutting down your application, you
    need to destroy the Tracy context by calling `TracyVkDestroy`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last step is to build your project with `TRACY_ENABLE` defined. If using
    CMake, you can do this by adding the following parameters when generating the
    project’s build files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now all you must do is compile your code and run it. Make sure to start the
    Tracy client beforehand and start a connection. The Tracy client will automatically
    detect your application and start collecting data once it starts.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you instrument your code to collect CPU data using Tracy, which you can do
    using macros such as `ZoneScoped`, `ZoneScopedC`, and so on, you will see the
    results side by side after collection. *Figure 9**.7* shows the result of capturing
    one of the executables from [*Chapter 2*](B18491_02.xhtml#_idTextAnchor126), *Working
    with Modern Vulkan*. Note the CPU and GPU zones in the screenshot.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.7 – Tracy profiler capture with GPU and CPU information side by
    side](img/B18491_09_07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 9.7 – Tracy profiler capture with GPU and CPU information side by side
  prefs: []
  type: TYPE_NORMAL
- en: Tracy is a very simple-to-use library that provides invaluable information about
    your application. It provides nanosecond resolution along with CPU and GPU performance
    tracking and is cross-platform. If you don’t already have other performance-measuring
    libraries or facilities in your code base, Tracy can get you up and running in
    no time.
  prefs: []
  type: TYPE_NORMAL
