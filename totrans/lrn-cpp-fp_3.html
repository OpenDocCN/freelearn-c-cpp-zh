<html><head></head><body>
        

                            
                    <h1 class="header-title">Applying Immutable State to the Function</h1>
                
            
            
                
<p>After discussing the first-class function and pure function in the previous chapter, now let's talk about a mutable and immutable object. As you have learned, we have to be able to pass a function to another function in a first-class function and ensure that the function returns the same value if we pass the same argument as well. The immutable object, which we will discuss, can help us make these two functional programming concepts available in our code. The topics we will discuss in this chapter are as follows:</p>
<ul>
<li>Modifying the variable in a functional programming approach</li>
<li>Demonstrating the use of <kbd>const</kbd> keyword to avoid value modification</li>
<li>Applying first-class and pure functions to immutable objects</li>
<li>Refactoring the mutable object into an immutable object</li>
<li>The benefit of an immutable object over a mutable one</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding the essential part from immutable object</h1>
                
            
            
                
<p>In object-oriented programming, we usually manipulate the variable objects many times, even inside the class itself, which we usually describe as the attributes. Also, we sometimes change the global variable from the specific function. However, to gain the immutability feature in functional programming, there are two rules we have to obey. First, we are not allowed to change the local variable. Second, we have to avoid the involvement of the global variable in the function since it will affect the function result.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Modifying a local variable</h1>
                
            
            
                
<p>When we talk about a variable, we are talking about a container to store our data. In our daily programming, we usually reuse the variable we have created. To make it clear, let's take a look at the <kbd>mutable_1.cpp</kbd> code. We have the <kbd>mutableVar</kbd> variable and store <kbd>100</kbd> to it. We then manipulate its value for the <kbd>i</kbd> variable iteration. The code is written as follows:</p>
<pre class="mce-root">
    /* mutable_1.cpp */<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[mutable_1.cpp]" &lt;&lt; endl;<br/><br/>      // Initializing an int variable<br/>      int mutableVar = 100;<br/>      cout &lt;&lt; "Initial mutableVar = " &lt;&lt; mutableVar;<br/>      cout &lt;&lt; endl;<br/><br/>      // Manipulating mutableVar<br/>      for(int i = 0; i &lt;= 10; ++i)<br/>        mutableVar = mutableVar + i;<br/><br/>      // Displaying mutableVar value<br/>      cout &lt;&lt; "After manipulating mutableVar = " &lt;&lt; mutableVar;<br/>      cout &lt;&lt; endl;<br/><br/>      return 0;<br/>    }
</pre>
<p>The result we should see on the screen will be like the following screenshot:</p>
<div><img class=" image-border" src="img/7afd04cb-5f89-48eb-b264-e8687a17bda1.png"/></div>
<p>As we can see, we have successfully manipulated the <kbd>mutableVar</kbd> variable. However, we treat the <kbd>mutableVar</kbd> variable as a mutable object. It's because we reuse the <kbd>mutableVar</kbd> variable many times. In other words, we have broken the immutable rule we discussed earlier. We can, if we want, refactor the <kbd>mutable_1.cpp</kbd> code to be the immutable one. Let's analyze the <kbd>immutable_1.cpp</kbd> code. Here, we will create a new local variable each time we intend to change the previous variable. The code is written as follows:</p>
<pre class="mce-root">
    /* immutable_1.cpp */<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[immutable_1.cpp]" &lt;&lt; endl;<br/><br/>      // Initializing an int variable<br/>      int mutableVar = 100;<br/>      cout &lt;&lt; "Initial mutableVar = " &lt;&lt; mutableVar;<br/>      cout &lt;&lt; endl;<br/><br/>      // Manipulating mutableVar using immutable approach<br/>      <strong>int mutableVar0 = mutableVar + 0;</strong><br/><strong>      int mutableVar1 = mutableVar0 + 1;</strong><br/><strong>      int mutableVar2 = mutableVar1 + 2;</strong><br/><strong>      int mutableVar3 = mutableVar2 + 3;</strong><br/><strong>      int mutableVar4 = mutableVar3 + 4;</strong><br/><strong>      int mutableVar5 = mutableVar4 + 5;</strong><br/><strong>      int mutableVar6 = mutableVar5 + 6;</strong><br/><strong>      int mutableVar7 = mutableVar6 + 7;</strong><br/><strong>      int mutableVar8 = mutableVar7 + 8;</strong><br/><strong>      int mutableVar9 = mutableVar8 + 9;</strong><br/><strong>      int mutableVar10 = mutableVar9 + 10;</strong><br/><br/>      // Displaying mutableVar value in mutable variable<br/>      cout &lt;&lt; "After manipulating mutableVar = " &lt;&lt; <strong>mutableVar10</strong>;<br/>      cout &lt;&lt; endl;<br/><br/>      return 0;<br/>    }
</pre>
<p>As we can see, to avoid changing the local variable, <kbd>mutableVar</kbd>, we create the other ten local variables. The result is stored in the <kbd>mutableVar10</kbd> variable. We then show the result to the console. Indeed, it's uncommon in our programming activities habit. However, this is the way we can do to get the immutable object. By doing this immutable approach, we never miss the previous state since we have all states. Also, the output we get by running <kbd>immutable_1.cpp</kbd> is completely the same as the output from the <kbd>mutable_1.cpp</kbd> code, as we can see in the following screenshot:</p>
<div><img class=" image-border" src="img/7fd867be-dd5e-4fa2-9b1f-e652f6ca741e.png"/></div>
<p>However, since we have more code lines in <kbd>immutable_1.cpp</kbd> compared to the <kbd>mutable_1.cpp</kbd> code, the performance of the <kbd>immutable_1.cpp</kbd> code will be slower than the <kbd>mutable_1.cpp</kbd> code. In addition, of course, the <kbd>mutable_1.cpp</kbd> code is more efficient than the <kbd>immutable_1.cpp</kbd> code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Modifying a variable passed into a function</h1>
                
            
            
                
<p>Now, we will talk about modifying the variable when it is passed to a function. Let's suppose we have a variable named <kbd>n</kbd> that contains a string data. We then pass it as a parameter to a function named <kbd>Modify()</kbd>. Inside the function, we manipulate the name variable. Let's take a look at the following <kbd>immutable_2.cpp</kbd> code and analyze it:</p>
<pre class="mce-root">
    /* immutable_2.cpp */<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    void Modify(string name)<br/>    {<br/>      name = "Alexis Andrews";<br/>    }<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[immutable_2.cpp]" &lt;&lt; endl;<br/><br/>      // Initializing a string variable<br/>      string n = "Frankie Kaur";<br/>      cout &lt;&lt; "Initial name = " &lt;&lt; n;<br/>      cout &lt;&lt; endl;<br/><br/>      // Invoking Modify() function<br/>      // to modify the n variable<br/>      Modify(n);<br/><br/>      // Displaying n value<br/>      cout &lt;&lt; "After manipulating = " &lt;&lt; n;<br/>      cout &lt;&lt; endl;<br/><br/>      return 0;<br/>    }
</pre>
<p>From the preceding code, we see that we store <kbd>Frankie Kaur</kbd> as the initial value of the <kbd>n</kbd> variable, then modify into <kbd>Alexis Andrews</kbd> inside the <kbd>Modify()</kbd> function. Now, let's see the output on the screen when we run the preceding code:</p>
<div><img class=" image-border" src="img/c35acf8e-d920-473a-9b15-c35a7f4b7f59.png"/></div>
<p>As we can see from the preceding screenshot, the name variable still contains <kbd>Frankie Kaur</kbd> as its value, although we have modified it inside the <kbd>Modify()</kbd> function. It's because we pass the <kbd>n</kbd> variable in the <kbd>main()</kbd> function and the <kbd>Modify()</kbd> function receives a copy of the value stored in the <kbd>name</kbd> variable so that the name variable remains unchanged and contains the original value. We can mutate the <kbd>n</kbd> variable if we pass it as the reference, as we can see in the following <kbd>mutable_2.cpp</kbd> code:</p>
<pre class="mce-root">
    /* mutable_2.cpp */<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    void Modify(<strong>string &amp;name</strong>)<br/>    {<br/>      name = "Alexis Andrews";<br/>    }<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[mutable_2.cpp]" &lt;&lt; endl;<br/><br/>      // Initializing a string variable<br/>      string n = "Frankie Kaur";<br/>      cout &lt;&lt; "Initial name = " &lt;&lt; n;<br/>      cout &lt;&lt; endl;<br/><br/>      // Invoking Modify() function<br/>      // to modify the n variable<br/>      Modify(n);<br/><br/>      // Displaying n value<br/>      cout &lt;&lt; "After manipulating = " &lt;&lt; n;<br/>      cout &lt;&lt; endl;<br/><br/>      return 0;<br/>    }
</pre>
<p>Just adding the ampersand symbol (<kbd>&amp;</kbd>) to the argument of the <kbd>Modify()</kbd> function now passes the parameter as a reference. The output on the screen will be like the following screenshot:</p>
<div><img class=" image-border" src="img/e2ffb9ca-57f6-4a70-83f2-ed28d0965f01.png"/></div>
<p>Based on the preceding screenshot, the <kbd>n</kbd> variable has now been changed successfully in the <kbd>Modify()</kbd> function since we pass by the reference of the <kbd>n</kbd> variable, not a value itself. There is also another best approach to mutate the variable using struct or class type, as we can see in the following <kbd>mutable_2a.cpp</kbd> code:</p>
<pre class="mce-root">
     /* mutable_2a.cpp */<br/>     #include &lt;iostream&gt;<br/><br/>     using namespace std;<br/><br/><strong>     class Name</strong><br/><strong>     {<br/>       public:</strong><br/><strong>         string str;</strong><br/><strong>     };</strong><br/><br/>     void Modify(Name &amp;name)<br/>     {<br/>       <strong>name.str = "Alexis Andrews";</strong><br/>     }<br/><br/>     auto main() -&gt; int<br/>     {<br/>       cout &lt;&lt; "[mutable_2a.cpp]" &lt;&lt; endl;<br/><br/>       // Initializing a string variable<br/>       <strong>Name n = {"Frankie Kaur"};</strong><br/>       cout &lt;&lt; "Initial name = " &lt;&lt; n.str;<br/>       cout &lt;&lt; endl;<br/><br/>       // Invoking Modify() function<br/>       // to modify the n variable<br/>       Modify(n);<br/><br/>       // Displaying n value<br/>       cout &lt;&lt; "After manipulating = " &lt;&lt; n.str;<br/>       cout &lt;&lt; endl;<br/> <br/>       return 0;<br/>    }
</pre>
<p>As we can see in the preceding code, we have a class named <kbd>Name</kbd> that contains a string variable on it. At the beginning, we instance the <kbd>Name</kbd> class with an initial value. We then modify the <kbd>str</kbd> value inside the class. If we run the code, we will get the exact same output comparing with the <kbd>mutable_2.cpp</kbd> code. However, we see that although the <kbd>n</kbd> variable didn't change, <kbd>name.str</kbd> did.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Preventing the modification of a value</h1>
                
            
            
                
<p>The essential point of immutability is preventing value modification. In C++ programming language, there is a keyword to prevent the code modifying a value. The keyword is <kbd>const</kbd> and we are going to use it in the <kbd>const.cpp</kbd> code. We have a class named <kbd>MyAge</kbd> which contains a public field named <kbd>age</kbd> and we set it as <kbd>const</kbd>. We will play with this <kbd>const</kbd> field and the code will look like following:</p>
<pre class="mce-root">
    /* const.cpp */<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    // My Age class will store an age value<br/>    class MyAge<br/>    {<br/>       public:<br/>         const int age;<br/>         MyAge(const int initAge = 20) :<br/>          age(initAge)<br/>         {<br/>         }<br/>     };<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[const.cpp]" &lt;&lt; endl;<br/><br/>      // Initializing several MyAge variables<br/>      MyAge AgeNow, AgeLater(8);<br/><br/>      // Displaying age property in AgeNow instance<br/>      cout &lt;&lt; "My current age is ";<br/>      cout &lt;&lt; AgeNow.age &lt;&lt; endl;<br/><br/>      // Displaying age property in AgeLater instance<br/>      cout &lt;&lt; "My age in eight years later is ";<br/>      cout &lt;&lt; AgeLater.age &lt;&lt; endl;<br/><br/>      return 0;<br/>    }
</pre>
<p>As we can see in the preceding code, we instantiate two <kbd>MyAge</kbd> class; they are <kbd>AgeNow</kbd> and <kbd>AgeLater</kbd>. For <kbd>AgeNow</kbd>, we use the initial value for age, while, for <kbd>AgeLater</kbd>, we give <kbd>8</kbd> to the <kbd>age</kbd> field. The output on the console will be as follow:</p>
<div><img class=" image-border" src="img/ea608d37-968f-4063-8110-67ff692584e3.png"/></div>
<p>However, it's impossible to insert the assignment to age field. The following <kbd>const_error.cpp</kbd> code will not be run since the compiler will refuse it:</p>
<pre class="mce-root">
    /* const_error.cpp */<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    // My Age class will store an age value<br/>    class MyAge<br/>    {<br/>       public:<br/>         const int age;<br/>         MyAge(const int initAge = 20) :<br/>          age(initAge)<br/>        {<br/>        }<br/>    };<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[const_error.cpp]" &lt;&lt; endl;<br/><br/>      // Initializing several MyAge variables<br/>      MyAge AgeNow, AgeLater(8);<br/><br/>      // Displaying age property in AgeNow instance<br/>      cout &lt;&lt; "My current age is ";<br/>      cout &lt;&lt; AgeNow.age &lt;&lt; endl;<br/><br/>      // Displaying age property in AgeLater instance<br/>      cout &lt;&lt; "My age in eight years later is ";<br/>      cout &lt;&lt; AgeLater.age &lt;&lt; endl;<br/><br/>      // Trying to assign age property<br/>      // in AgeLater instance<br/>      // However, the compiler will refuse it<br/>      AgeLater.age = 10;<br/><br/>      return 0;<br/>    }
</pre>
<p>As we can see, we modify the <kbd>age</kbd> value to <kbd>10</kbd>. The compiler will refuse to run since the <kbd>age</kbd> is set as <kbd>const</kbd> and will display the following error:</p>
<div><img class=" image-border" src="img/ce1c13f3-673b-4574-9687-2f511443d3cc.png"/></div>
<p>Thus, we have successfully created an immutable object by adding the <kbd>const</kbd> keyword.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Applying the first-class function and the pure function to the immutable object</h1>
                
            
            
                
<p>We gained an introduction to the immutable object from the preceding discussion. As you learned in the previous chapter, we can take advantage of the first-class function and pure function to create an immutable programming approach. Let's borrow the code from <a href="a1baf007-8f40-4616-8718-9887f95120b0.xhtml" target="_blank">Chapter <em>2</em></a>, <em>Manipulating Functions in Functional Programming</em>, that is <kbd>first_class_1.cpp</kbd>. We will have the <kbd>addition()</kbd>, <kbd>subtraction()</kbd>, <kbd>multiplication()</kbd>, and <kbd>division()</kbd> methods in our following <kbd>first_class_pure_immutable.cpp</kbd> code. We will then invoke the pure function on the class and assign the result to the variable. The code is written as follows:</p>
<pre class="mce-root">
    /* first_class_pure_immutable.cpp */<br/>    #include &lt;iostream&gt;<br/><br/>    using namespace std;<br/><br/>    // MyValue class stores the value<br/>    class MyValue<br/>    {<br/>      public:<br/>        const int value;<br/>        MyValue(int v) : value(v)<br/>       {<br/>       }<br/>    };<br/><br/>    // MyFunction class stores the methods<br/>    class MyFunction<br/>    {<br/>      public:<br/>        const int x, y;<br/><br/>        MyFunction(int _x, int _y) :<br/>        x(_x), y(_y)<br/>       {<br/>       }<br/><br/>      MyValue addition() const<br/>      {<br/>        return MyValue(x + y);<br/>      }<br/><br/>      MyValue subtraction() const<br/>     {<br/>        return MyValue(x - y);<br/>      }<br/><br/>     MyValue multiplication() const<br/>     {<br/>        return MyValue(x * y);<br/>     }<br/><br/>     MyValue division() const<br/>     {<br/>        return MyValue(x / y);<br/>     }<br/>   };<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[first_class_pure_immutable.cpp]" &lt;&lt; endl;<br/><br/>      // Setting the initial value<br/>      // for MyFunction class constructor<br/>      int a = 100;<br/>      int b = 10;<br/><br/>      // Displaying initial value<br/>      cout &lt;&lt; "Initial value" &lt;&lt; endl;<br/>      cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; endl;<br/>      cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; endl;<br/>      cout &lt;&lt; endl;<br/><br/>      // Constructing the MyFunction class<br/>      MyFunction func(a, b);<br/><br/>      // Generating wrapper for each function<br/>      // in the MyFunction class<br/>      // so it will be the first-class function<br/>      auto callableAdd = mem_fn(&amp;MyFunction::addition);<br/>      auto callableSub = mem_fn(&amp;MyFunction::subtraction);<br/>      auto callableMul = mem_fn(&amp;MyFunction::multiplication);<br/>      auto callableDiv = mem_fn(&amp;MyFunction::division);<br/><br/>      // Invoking the functions<br/>      auto value1 = callableAdd(func);<br/>      auto value2 = callableSub(func);<br/>      auto value3 = callableMul(func);<br/>      auto value4 = callableDiv(func);<br/><br/>      // Displaying result<br/>      cout &lt;&lt; "The result" &lt;&lt; endl;<br/>      cout &lt;&lt; "addition = " &lt;&lt; value1.value &lt;&lt; endl;<br/>      cout &lt;&lt; "subtraction = " &lt;&lt; value2.value &lt;&lt; endl;<br/>      cout &lt;&lt; "multiplication = " &lt;&lt; value3.value &lt;&lt; endl;<br/>      cout &lt;&lt; "division = " &lt;&lt; value4.value &lt;&lt; endl;<br/><br/>      return 0;<br/>    }
</pre>
<p>As we can see in the preceding code, the <kbd>addition()</kbd>, <kbd>subtraction()</kbd>, <kbd>multiplication()</kbd>, and <kbd>division()</kbd> methods are a pure function as they produce the same output as long as they receive the same input. We also make a class named <kbd>MyValue</kbd> and set it as <kbd>const</kbd> to make it immutable. Then, to make our function become the first-class function, we wrap each method in the <kbd>MyFunction</kbd> class using the <kbd>mem_fn()</kbd> function. Afterward, we assign four variables with the function wrapper we've got. The output on the screen should look like the following screenshot:</p>
<div><img class=" image-border" src="img/e8a3cb17-011e-4742-ac95-dd0c36683a35.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Developing the immutable object</h1>
                
            
            
                
<p>After we discuss the concept of immutability, now let's develop the immutable object. We will start with the mutable object first, then refactor it into an immutable one.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Starting with a mutable object</h1>
                
            
            
                
<p>Now, let's go further. We will create another class to design an immutable object. First, we will create a mutable class named <kbd>MutableEmployee</kbd>. We have some fields and methods in that class. The header of the class will be like the following piece of code:</p>
<pre class="mce-root">
    /* mutableemployee.h */<br/>    #ifndef __MUTABLEEMPLOYEE_H__<br/>    #define __MUTABLEEMPLOYEE_H__<br/><br/>    #include &lt;string&gt;<br/><br/>    class MutableEmployee<br/>    {<br/>      private:<br/>        int m_id;<br/>        std::string m_firstName;<br/>        std::string m_lastName;<br/>        double m_salary;<br/><br/>     public:<br/>       MutableEmployee(<br/>         int id,<br/>         const std::string&amp; firstName,<br/>         const std::string&amp; lastName,<br/>         const double&amp; salary);<br/>       MutableEmployee();<br/><br/>       void SetId(const int id);<br/>       void SetFirstName(<br/>        const std::string&amp; FirstName);<br/>       void SetLastName(<br/>        const std::string&amp; LastName);<br/>       void SetSalary(<br/>        const double&amp; Salary);<br/><br/>       int Id() const {return m_id;}<br/>       std::string FirstName() const {return m_firstName;}<br/>       std::string LastName() const {return m_lastName;}<br/>       double Salary() const {return m_salary;}<br/>     };<br/><br/>    #endif // End of __MUTABLEEMPLOYEE_H__
</pre>
<p>As we can see, we have four fields--<kbd>m_id</kbd>, <kbd>m_firstName</kbd>, <kbd>m_lastName</kbd>, and <kbd>m_salary</kbd>. We also have the definition of four methods to store any value to those fields. The implementation of those methods is as follows:</p>
<pre class="mce-root">
    /* mutableemployee.cpp */<br/>    #include "mutableemployee.h"<br/><br/>    using namespace std;<br/><br/>    MutableEmployee::MutableEmployee() :<br/>      m_id(0),<br/>      m_salary(0.0)<br/>    {<br/>    }<br/><br/>    MutableEmployee::MutableEmployee(<br/>      int id,<br/>      const string&amp; firstName,<br/>      const string&amp; lastName,<br/>      const double&amp; salary) :<br/>        m_id(id),<br/>        m_firstName(firstName),<br/>        m_lastName(lastName),<br/>        m_salary(salary)<br/>    {<br/>    }<br/><br/>    void MutableEmployee::SetId(const int id)<br/>    {<br/>      m_id = id;<br/>    }<br/><br/>    void MutableEmployee::SetFirstName(<br/>      const std::string&amp; FirstName) {<br/>        m_firstName = FirstName;<br/>      }<br/><br/>    void MutableEmployee::SetLastName(<br/>      const std::string&amp; LastName) {<br/>        m_lastName = LastName;<br/>      }<br/><br/>   void MutableEmployee::SetSalary(<br/>      const double&amp; Salary) {<br/>        m_salary = Salary;<br/>      }
</pre>
<p>As we can see in the preceding code, we have a good OOP code in which the members are private; however, we can access them through setters and getters. In other words, any code can change any value so that it is mutable. Now, let's consume the preceding class using this coming <kbd>mutable_3.cpp</kbd> code. We will instance the class with the initial value and try to mutate them. The code will look as follows:</p>
<pre class="mce-root">
    /* mutable_3.cpp */<br/>    #include &lt;iostream&gt;<br/>    #include "../mutableemployee/mutableemployee.h"<br/><br/>    using namespace std;<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[mutable_3.cpp]" &lt;&lt; endl;<br/><br/>      // Initializing several variables<br/>      string first = "Frankie";<br/>      string last = "Kaur";<br/>      double d = 1500.0;<br/><br/>      // Creating an instance of MutableEmployee<br/>      MutableEmployee me(0, first, last, d);<br/><br/>      // Displaying initial value<br/>      cout &lt;&lt; "Content of MutableEmployee instance" &lt;&lt; endl;<br/>      cout &lt;&lt; "ID : " &lt;&lt; me.Id() &lt;&lt; endl;<br/>      cout &lt;&lt; "Name : " &lt;&lt; me.FirstName();<br/>      cout &lt;&lt; " " &lt;&lt; me.LastName() &lt;&lt; endl;<br/>      cout &lt;&lt; "Salary : " &lt;&lt; me.Salary() &lt;&lt; endl &lt;&lt; endl;<br/><br/>      // Mutating the instance of MutableEmployee<br/>      me.SetId(1);<br/>      me.SetFirstName("Alexis");<br/>      me.SetLastName("Andrews");<br/>      me.SetSalary(2100.0);<br/><br/>      // Displaying mutate value<br/>      cout &lt;&lt; "Content of MutableEmployee after mutating" &lt;&lt; endl;<br/>      cout &lt;&lt; "ID : " &lt;&lt; me.Id() &lt;&lt; endl;<br/>      cout &lt;&lt; "Name : " &lt;&lt; me.FirstName();<br/>      cout &lt;&lt; " " &lt;&lt; me.LastName() &lt;&lt; endl;<br/>      cout &lt;&lt; "Salary : " &lt;&lt; me.Salary() &lt;&lt; endl;<br/><br/>      return 0;<br/>    }
</pre>
<p>As we can see in the preceding code, we have the initial value stored in three variables--<kbd>first</kbd>, <kbd>last</kbd>, and <kbd>d</kbd>. We will then successfully mutate the instance using the setter. The output should be as follows:</p>
<div><img class=" image-border" src="img/50a47674-e3af-4527-b437-7c12d7e567d3.png"/></div>
<p>The preceding screenshot shows us the mutation result of the <kbd>MutableEmployee</kbd> class. Since we need to avoid the side effect by avoiding the mutate state, we have to refactor the class to an immutable class.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Refactoring a mutable object into an immutable one</h1>
                
            
            
                
<p>As we discussed earlier, to avoid side effects, we have to design our class to be an immutable object. We will refactor the previous <kbd>MutableEmployee</kbd> class. Let's take a look at the following header class:</p>
<pre class="mce-root">
    /* immutableemployee.h */<br/>    #ifndef __IMMUTABLEEMPLOYEE_H__<br/>    #define __IMMUTABLEEMPLOYEE_H__<br/><br/>    #include &lt;string&gt;<br/><br/>    class ImmutableEmployee<br/>    {<br/>      private:<br/>        int m_id;<br/>        std::string m_firstName;<br/>        std::string m_lastName;<br/>        double m_salary;<br/><br/>     public:<br/>       ImmutableEmployee(<br/>         const int id,<br/>         const std::string&amp; firstName,<br/>         const std::string&amp; lastName,<br/>         const double&amp; _salary);<br/>       ImmutableEmployee();<br/><br/>       const int Id() const {<br/>          return m_id;<br/>       }<br/><br/>       const std::string&amp; FirstName() const {<br/>         return m_firstName;<br/>       }<br/><br/>       const std::string&amp; LastName() const {<br/>         return m_lastName;<br/>       }<br/><br/>       const double Salary() const {<br/>        return m_salary;<br/>       }<br/>    };<br/><br/>    #endif // End of __IMMUTABLEEMPLOYEE_H__
</pre>
<p>As we can see in the preceding header code, we removed the setters from the previous <kbd>MutableEmployee</kbd> class. We did that to make the <kbd>ImmutableEmployee</kbd> class immutable. The implementation of the header can be found in the following code:</p>
<pre class="mce-root">
    /* immutableemployee.cpp */<br/>    #include "immutableemployee.h"<br/><br/>    using namespace std;<br/><br/>    ImmutableEmployee::ImmutableEmployee() :<br/>      m_id(0),<br/>      m_salary(0.0)<br/>      {<br/>      }<br/><br/>    ImmutableEmployee::ImmutableEmployee(<br/>      const int id,<br/>      const string&amp; firstName,<br/>      const string&amp; lastName,<br/>      const double&amp; salary) :<br/>        m_id(id),<br/>        m_firstName(firstName),<br/>        m_lastName(lastName),<br/>        m_salary(salary)<br/>      {<br/>      }
</pre>
<p>Now, let's analyze the <kbd>ImmutableEmployee</kbd> class and compare it with the <kbd>MutableEmployee</kbd> class. The following is what we should obtain:</p>
<ul>
<li>We now set all member variables to <kbd>const</kbd>, which means the variables can be initialized in the constructor only. This would be the best approach in creating an immutable object. However, the <kbd>const</kbd> members prevent making a move operation to other members, which is a neat C++11 optimization.</li>
<li>The getter methods now return the <kbd>const</kbd> reference instead of the value. Since the immutable object cannot modify the value, it's better to return the reference to them.</li>
<li>The getters now return the <kbd>const</kbd> value to avoid the result to be modified by other statements. It also prevents some common errors, like the use of <kbd>=</kbd> rather than <kbd>==</kbd> in comparison. It declares the fact that we use an immutable type.</li>
</ul>
<p>The problem occurs if we want to change the <kbd>m_firstName</kbd> or <kbd>m_salary</kbd> fields, for instance. To solve this problem, we can add the setter to the <kbd>ImmutableEmployee</kbd> class. However, it now returns the <kbd>ImmutableEmployee</kbd> instance instead of mutating the field target. The <kbd>immutableemployee.h</kbd> code will be as follows:</p>
<pre>
    /* immutableemployee.h */<br/>    #ifndef __IMMUTABLEEMPLOYEE_H__<br/>    #define __IMMUTABLEEMPLOYEE_H__<br/><br/>    #include &lt;string&gt;<br/><br/>    class ImmutableEmployee<br/>    {<br/>      private:<br/>       int m_id;<br/>       std::string m_firstName;<br/>       std::string m_lastName;<br/>       double m_salary;<br/><br/>      public:<br/>        ImmutableEmployee(<br/>          const int id,<br/>          const std::string&amp; firstName,<br/>          const std::string&amp; lastName,<br/>          const double&amp; _salary);<br/>        ImmutableEmployee();<br/>        ~ImmutableEmployee();<br/><br/>        const int Id() const {<br/>          return m_id;<br/>        }<br/><br/>        const std::string&amp; FirstName() const {<br/>          return m_firstName;<br/>        }<br/><br/>        const std::string&amp; LastName() const {<br/>          return m_lastName;<br/>         }<br/><br/>        const double Salary() const {<br/>          return m_salary;<br/>         }<br/><br/>        const ImmutableEmployee SetId(<br/>          const int id) const {<br/>            return ImmutableEmployee(<br/>              id, m_firstName, m_lastName, m_salary);<br/>          }<br/><br/>       const ImmutableEmployee SetFirstName(<br/>          const std::string&amp; firstName) const {<br/>            return ImmutableEmployee(<br/>              m_id, firstName, m_lastName, m_salary);<br/>          }<br/>     <br/>       const ImmutableEmployee SetLastName(<br/>          const std::string&amp; lastName) const {<br/>            return ImmutableEmployee(<br/>              m_id, m_firstName, lastName, m_salary);<br/>          }<br/><br/>       const ImmutableEmployee SetSalary(<br/>          const double&amp; salary) const {<br/>            return ImmutableEmployee(<br/>              m_id, m_firstName, m_lastName, salary);<br/>          }<br/>      };<br/><br/>    #endif // End of __IMMUTABLEEMPLOYEE_H__
</pre>
<p>As we can see, now, in the <kbd>immutableemployee.h</kbd> file, we have four setters. They are <kbd>SetId</kbd>, <kbd>SetFirstName</kbd>, <kbd>SetLastName</kbd>, and <kbd>SetSalary</kbd>. Although the name of setter in the <kbd>ImmutableEmployee</kbd> class is completely the same as the <kbd>MutableEmployee</kbd> class, in the <kbd>ImmutableEmployee</kbd> class, the setters return the instance of the class, as we discussed earlier. By using this <kbd>ImmutableEmployee</kbd> class, we have to adopt the functional approach since the class is the immutable object. The following code is <kbd>immutable_3.cpp</kbd>, which we refactor from the <kbd>mutable_3.cpp</kbd> file:</p>
<pre class="mce-root">
    /* immutable_3.cpp */<br/>    #include &lt;iostream&gt;<br/>    #include "../immutableemployee/immutableemployee.h"<br/><br/>    using namespace std;<br/><br/>    auto main() -&gt; int<br/>    {<br/>      cout &lt;&lt; "[immutable_3.cpp]" &lt;&lt; endl;<br/><br/>      // Initializing several variables<br/>      string first = "Frankie";<br/>      string last = "Kaur";<br/>      double d = 1500.0;<br/><br/>      // Creating the instance of ImmutableEmployee<br/>      ImmutableEmployee me(0, first, last, d);<br/><br/>      // Displaying initial value<br/>      cout &lt;&lt; "Content of ImmutableEmployee instance" &lt;&lt; endl;<br/>      cout &lt;&lt; "ID : " &lt;&lt; me.Id() &lt;&lt; endl;<br/>      cout &lt;&lt; "Name : " &lt;&lt; me.FirstName()<br/>      &lt;&lt; " " &lt;&lt; me.LastName() &lt;&lt; endl;<br/>      cout &lt;&lt; "Salary : " &lt;&lt; me.Salary() &lt;&lt; endl &lt;&lt; endl;<br/><br/>      // Modifying the initial value<br/>      ImmutableEmployee me2 = me.SetId(1);<br/>      ImmutableEmployee me3 = me2.SetFirstName("Alexis");<br/>      ImmutableEmployee me4 = me3.SetLastName("Andrews");<br/>      ImmutableEmployee me5 = me4.SetSalary(2100.0);<br/><br/>      // Displaying the new value<br/>      cout &lt;&lt; "Content of ImmutableEmployee after modifying" &lt;&lt; endl;<br/>      cout &lt;&lt; "ID : " &lt;&lt; me5.Id() &lt;&lt; endl;<br/>      cout &lt;&lt; "Name : " &lt;&lt; me5.FirstName()<br/>      &lt;&lt; " " &lt;&lt; me5.LastName() &lt;&lt; endl;<br/>      cout &lt;&lt; "Salary : " &lt;&lt; me5.Salary() &lt;&lt; endl;<br/><br/>      return 0;<br/>    }
</pre>
<p>As we see in the preceding code, we modify the content by instancing four other <kbd>ImmutableEmployee</kbd> classes--<kbd>me2</kbd>, <kbd>me3</kbd>, <kbd>me4</kbd>, and <kbd>me5</kbd>. This resembles what we did in <kbd>immutable_1.cpp</kbd>. However, we now deal with a class. The output of the preceding code should look like the following screenshot:</p>
<div><img class=" image-border" src="img/a09d9280-17e5-4508-bcc2-af9cafd1a3eb.png"/></div>
<p>By obtaining the preceding output, we can say that we have successfully modified the instance of the <kbd>ImmutableEmployee</kbd> class without mutating it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Enumerating the benefits of being immutable</h1>
                
            
            
                
<p>After our discussion, we now know that an immutable object is an essential part of the functional programming. The following are the benefits we can get from the immutable object:</p>
<ul>
<li>We won't deal with the side effect. It's because we have ensured that no outside state is modified. We also create a new object every time we intend to change the value inside the object.</li>
<li>There is no invalid object's state. It's because we will always be in an inconsistent state. If we forget to invoke a particular method, we will definitely get the correct state since there is no connection between methods.</li>
<li>It will be thread-safe since we can run many methods together with no need to lock the first method that is run in the pool. In other words, we will never face any synchronization issues.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>First, in this chapter, we tried to modify a local variable in a functional way. We cannot reuse the variable we created; instead, we have to create another one when we need to modify it. We also discussed the technique to modify the variable we passed to another function. Instead of passing the argument by value, we have to pass it by reference to make it change.</p>
<p>Then, we dug the use of the <kbd>const</kbd> keyword to provide the immutable behavior to the function. By using this keyword, we can ensure that the variable inside the class cannot be modified. Another discussion was about applying the first-class and pure functions--things you learned in the previous chapter--to gain the power of immutability.</p>
<p>We also created the mutable class and then refactored it into an immutable class. We are now able to distinguish the mutable and immutable object and can apply it in our functional code. Lastly, in this chapter, we enumerated the benefit of the immutable object, so we are confident to use it in our daily code.</p>
<p>Another question may appear in our minds now. How do we run the recursion if we have to deal with the immutable object? We cannot even modify a single variable in the method. In the next chapter, we will sort this problem out by discussing recursion in functional programming.</p>


            

            
        
    </body></html>