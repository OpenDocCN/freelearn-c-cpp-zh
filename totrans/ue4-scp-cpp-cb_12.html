<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Multiplayer Networking in UE4</h1>
                </header>
            
            <article>
                
<p>In this chapter, we are going to cover the following topics:</p>
<ul>
<li>Testing your game as a client and a server simultaneously</li>
<li>Replicating properties over the network</li>
<li>Replicating functions over the network</li>
<li>Handling UI network events</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>Networking is one of the more complex things you can do as a programmer. Thankfully, Unreal Engine has been designed with networking in mind since the original Unreal Engine released in 1998. Unreal uses a client-server model for communication between multiple computers. In this case, the <strong>server</strong> is the person who started the game and the <strong>clients</strong> are those who are playing the game with the first person. For things that are happening in everyone's game to work correctly, we need to call certain code at certain times for certain people.</p>
<p>For example, when a client wants to shoot his/her gun, they send a message to the server, which will then determine whether they hit anything and then tells all the clients what happened using replication. This can be important because some things, such as the game mode, only exist on the server.</p>
<div class="packt_infobox">For more information on the client-server model, check out <a href="https://en.wikipedia.org/wiki/Client%E2%80%93server_model">https://en.wikipedia.org/wiki/Client%E2%80%93server_model</a>.</div>
<p>Since we are going to want to see multiple characters on the screen, in this chapter, we will be using a base project based on the <span class="packt_screen">Third Person</span> C++ template:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/641e12f8-c70e-4e03-a8df-9670db5bc80a.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p><span>This chapter requires the use of Unreal Engine 4 and uses Visual Studio 2017 as the IDE. Instructions on how to install both pieces of software and the requirements for them can be found in <a href="4adb307e-d86f-4d70-b6de-a0893102d1cf.xhtml">Chapter 1</a>, <em>UE4 Development Tools</em>, of this book.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing your game as a client and a server simultaneously</h1>
                </header>
            
            <article>
                
<p>When working on networked games, it's always a good idea to test your project often. Instead of having to use two separate computers, Unreal comes with an easy way to play a game with multiple players at the same time<span> </span><span>built in</span><span>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Generally, when we play the game, we only have one player on the screen. We can modify this with the <span class="packt_screen">Play</span> settings:</p>
<ol>
<li><span>From the Unreal Editor, with the <kbd>ThirdPersonExampleMap</kbd> open, click on the arrow drop-down next to the <span class="packt_screen">Play</span> button. Under there, set the <span class="packt_screen">Number of Players</span> property to <kbd>2</kbd>:</span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8ed662ce-096e-4c08-b745-d45fa8545243.png"/></p>
<p class="mce-root"/>
<ol start="2">
<li>Afterwards, click on the <span class="packt_screen">Play</span> button:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b9faaf92-6b73-479c-8729-74858e85eecc.png"/></p>
<p>As you can see, you now have two windows added to the screen!</p>
<div class="packt_tip">Remember that you can return mouse control from a window by pressing <em>Shift</em> + <em>F1</em>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In addition to the character that is also placed in the scene, there is another object within the world called <kbd>NetworkPlayerStart</kbd>, which is where networked players will be spawned:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/9cc559e3-4292-4166-9655-c3d333129b7b.png"/></p>
<div class="packt_tip">If you add more <span class="packt_screen">Player Start</span> objects into the scene, by default, objects will pick a <span class="packt_screen">Player Start</span> randomly from the ones available. You can quickly create new ones by holding the <em>Alt</em> key down and dragging an object in the new direction.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Replicating properties over the network</h1>
                </header>
            
            <article>
                
<p>To ensure that the values are the same on both clients and servers, we use the process of replication. In this recipe, we will see just how easy it is to do so.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>For this simple example, let's create a variable to store how many times each player jumps within the game:</p>
<ol>
<li>Open up Visual Studio and open the definition for your character for your project (in my case, it is <kbd>Chapter_12Character.h</kbd>). Add the following property and function declaration to the file:</li>
</ol>
<pre style="padding-left: 60px">UPROPERTY(Replicated, EditAnywhere)<br/>uint32 JumpCount;<br/><br/>void Jump() override;</pre>
<ol start="2">
<li>Then, go to the implementation file and add the following <kbd>#include</kbd>:</li>
</ol>
<pre style="padding-left: 60px">#include "UnrealNetwork.h" // DOREPLIFETIME</pre>
<ol start="3">
<li>Afterwards, we need to tell the <kbd>SetupPlayerInputComponent</kbd> method to use our version of <kbd>Jump</kbd> instead of the parent class's:</li>
</ol>
<pre style="padding-left: 60px">void AChapter_12Character::SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent)<br/>{<br/>  // Set up gameplay key bindings<br/>  check(PlayerInputComponent);<br/><strong>  PlayerInputComponent-&gt;BindAction("Jump", IE_Pressed, this, &amp;AChapter_12Character::Jump);</strong><br/>  PlayerInputComponent-&gt;BindAction("Jump", IE_Released, this, &amp;ACharacter::StopJumping);<br/><br/>  ...</pre>
<ol start="4">
<li>Then, we need to add the following functions:</li>
</ol>
<pre style="padding-left: 60px">void AChapter_12Character::Jump()<br/>{<br/>    Super::Jump();<br/><br/>    JumpCount++;<br/><br/>    if (Role == ROLE_Authority)<br/>    {<br/>        // Only print function once<br/>        GEngine-&gt;AddOnScreenDebugMessage(-1, 5.0f,<br/>            FColor::Green,<br/>            FString::Printf(TEXT("%s called Jump %d times!"),<br/>            *GetName(), JumpCount)<br/>        );<br/>    }<br/><br/><br/>}<br/><br/>void AChapter_12Character::GetLifetimeReplicatedProps(TArray&lt;FLifetimeProperty&gt;&amp;<br/>    OutLifetimeProps) const<br/>{<br/>    Super::GetLifetimeReplicatedProps(OutLifetimeProps);<br/><br/>    // Replicate to every client<br/>    //DOREPLIFETIME(AChapter_12Character, JumpCount);<br/>}</pre>
<ol start="5">
<li>Save your script and return to the Unreal Editor. Compile your script and play your game:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8e4c2455-67e8-4044-8670-e291b73e5eb6.png"/></p>
<p>Now, whenever either player presses the <em>spacebar</em>, you'll see a message displaying their name and the value that it will have.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Property replication is simple in theory. Whenever a variable changes its value, the network should notify all clients of the change and then update the variable. This is often used for things like health, where the value is extremely important to know.</p>
<p>When you register a variable like this, this variable should only be modified by the server and then replicated to the other clients. To mark something to be replicated, we use the <kbd>Replicated</kbd> specifier inside of the <kbd>UPROPERTY</kbd>.</p>
<p>After marking something as replicated, we have to define a new function called <kbd>GetLifetimeReplicatedProps</kbd>, which does not need to be declared in the header file. Inside of this function, we use the <kbd>DOREPLIFETIME</kbd> macro to state that whenever the <kbd>JumpCount</kbd> variable changes on the server, all clients need to modify the value as well. </p>
<p>Inside of the <kbd>Jump</kbd> function, we added in some new functionality, but we first check the <kbd>Role</kbd> variable to determine if something should happen or not. <kbd>ROLE_Authority</kbd> is the highest level, which means that you're the server. This ensures that our functionality will only happen once rather than multiple times.</p>
<div class="packt_tip">For replication to work, make sure that the <kbd>bReplicates</kbd> variable is set to <kbd>true</kbd>. This should be done in the constructor of the class.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>For those that want to add a bit of optimization to their code, instead of our current <kbd>DOREPLIFETIME</kbd> macro, you could use the following instead:</p>
<pre>void AChapter_12Character::GetLifetimeReplicatedProps(TArray&lt;FLifetimeProperty&gt;&amp;<br/>    OutLifetimeProps) const<br/>{<br/>    Super::GetLifetimeReplicatedProps(OutLifetimeProps);<br/><br/>    // Replicate to every client<br/>    <strong>//</strong>DOREPLIFETIME(AChapter_12Character, JumpCount);<br/><br/><strong>    // Value is already updated locally, so we can skip replicating <br/>    // the value for the owner</strong><br/><strong>    DOREPLIFETIME_CONDITION(AChapter_12Character, JumpCount, COND_SkipOwner);</strong><br/>}</pre>
<p>This makes it so that the value is only replicated on other clients and not the original value.</p>
<div class="packt_infobox">For more information on <kbd>DOREPLIFETIME_CONDITION</kbd> and some other tips and tricks for networking, check out <a href="https://www.unrealengine.com/en-US/blog/network-tips-and-tricks">https://www.unrealengine.com/en-US/blog/network-tips-and-tricks</a><span>.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Replicating functions over the network</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will see a nontrivial example of replication in use with a simple pickup object that we may want a player to keep track of.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>The first step in creating our collectible would be to actually create the class we are going to use:</p>
<ol>
<li>Navigate to <span class="packt_screen">File | New C++ Class</span> and from there, in the <span class="packt_screen">Choose Parent Class</span> window, select <span class="packt_screen">Actor</span> and then click on <span class="packt_screen">Next</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/8ee5323f-7efd-4090-8af0-c5b49fb19958.png" style="width:55.33em;height:33.42em;"/></p>
<p class="mce-root"/>
<ol start="2">
<li>From the next window, set the <span class="packt_screen">Name</span> property to <kbd>CollectibleObject</kbd> and click on the <span class="packt_screen">Create Class</span> button to add it to the project and compile the base code:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/80bd2ac8-2cc5-4433-ad39-c66b466c7fe1.png"/></p>
<ol start="3">
<li>Once Visual Studio opens up, update <kbd>CollectibleObject.h</kbd> to the following:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "GameFramework/Actor.h"<br/>#include "CollectibleObject.generated.h"<br/><br/>UCLASS()<br/>class CHAPTER_12_API ACollectibleObject : public AActor<br/>{<br/>    GENERATED_BODY()<br/>    <br/>public: <br/>    // Sets default values for this actor's properties<br/>    ACollectibleObject();<br/><br/><strong>    // Event called when something starts to overlaps the</strong><br/><strong>    // sphere collider</strong><br/><strong>    // Note: UFUNCTION required for replication callbacks</strong><br/><strong>    UFUNCTION() </strong><br/><strong>    void OnBeginOverlap(class UPrimitiveComponent*</strong><br/><strong>        HitComp, </strong><br/><strong>        class AActor* OtherActor,</strong><br/><strong>        class UPrimitiveComponent*</strong><br/><strong>        OtherComp,</strong><br/><strong>        int32 OtherBodyIndex, bool</strong><br/><strong>        bFromSweep,</strong><br/><strong>        const FHitResult&amp; SweepResult);</strong><br/><br/><strong>    // Our server function to update the score.</strong><br/><strong>    UFUNCTION(Reliable, Server, WithValidation)</strong><br/><strong>    void UpdateScore(int32 Amount);</strong><br/><br/><strong>    void UpdateScore_Implementation(int32 Amount);</strong><br/><strong>    bool UpdateScore_Validate(int32 Amount);</strong><br/><br/>protected:<br/>    // Called when the game starts or when spawned<br/>    virtual void BeginPlay() override;<br/><br/>public: <br/>    // Called every frame<br/>    virtual void Tick(float DeltaTime) override;<br/><br/>};</pre>
<ol start="4">
<li>Then, inside of <kbd>CollectibleObject.cpp</kbd>, update the constructor of the class to the following:</li>
</ol>
<pre style="padding-left: 60px">#include "ConstructorHelpers.h"<br/>#include "Components/SphereComponent.h"<br/><br/>// ...<br/><br/>// Sets default values<br/>ACollectibleObject::ACollectibleObject()<br/>{<br/>   // Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.<br/>  PrimaryActorTick.bCanEverTick = true;<br/><br/>   <strong> // Must be true for an Actor to replicate anything</strong><br/><strong>    bReplicates = true;</strong><br/><br/><strong>    // Create a sphere collider for players to hit</strong><br/><strong>    USphereComponent * SphereCollider = CreateDefaultSubobject&lt;USphereComponent&gt;(TEXT("SphereComponent"));</strong><br/><br/><strong>    // Sets the root of our object to be the sphere collider</strong><br/><strong>    RootComponent = SphereCollider;</strong><br/><br/><strong>    // Sets the size of our collider to have a radius of</strong><br/><strong>    // 64 units</strong><br/><strong>    SphereCollider-&gt;InitSphereRadius(64.0f);</strong><br/><br/><strong>    // Makes it so that OnBeginOverlap will be called</strong><br/><strong>    // whenever something hits this.</strong><br/><strong>    SphereCollider-&gt;OnComponentBeginOverlap.AddDynamic(this, &amp;ACollectibleObject::OnBeginOverlap);</strong><br/><br/><strong>    // Create a visual to make it easier to see</strong><br/><strong>    UStaticMeshComponent * SphereVisual = CreateDefaultSubobject&lt;UStaticMeshComponent&gt;(TEXT("Static Mesh"));</strong><br/><br/><strong>    // Attach the static mesh to the root</strong><br/><strong>    SphereVisual-&gt;SetupAttachment(RootComponent);</strong><br/><br/><strong>    // Get a reference to a sphere mesh</strong><br/><strong>    auto MeshAsset = ConstructorHelpers::FObjectFinder&lt;UStaticMesh&gt;(TEXT("StaticMesh'/Engine/BasicShapes/Sphere.Sphere'"));</strong><br/><br/><strong>    // Assign the mesh if valid</strong><br/><strong>    if (MeshAsset.Object != nullptr)</strong><br/><strong>    {</strong><br/><strong>        SphereVisual-&gt;SetStaticMesh(MeshAsset.Object);</strong><br/><strong>    }</strong><br/><br/><strong>    // Resize to be smaller than the larger sphere collider</strong><br/><strong>    SphereVisual-&gt;SetWorldScale3D(FVector(0.5f));</strong><br/><br/><br/>}</pre>
<ol start="5">
<li>Afterwards, implement the <kbd>OnBeginOverlap</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">// Event called when something starts to overlaps the<br/>// sphere collider<br/>void ACollectibleObject::OnBeginOverlap(<br/>    class UPrimitiveComponent* HitComp,<br/>    class AActor* OtherActor,<br/>    class UPrimitiveComponent* OtherComp,<br/>    int32 OtherBodyIndex,<br/>    bool bFromSweep,<br/>    const FHitResult&amp; SweepResult)<br/>{<br/>    // If I am the server<br/>    if (Role == ROLE_Authority)<br/>    {<br/>        // Then a coin will be gained!<br/>        UpdateScore(1);<br/>        Destroy();<br/>    }<br/>}</pre>
<ol start="6">
<li>Then, implement the <kbd>UpdateScore_Implementation</kbd> and <kbd>UpdateScore_Validate</kbd> methods: </li>
</ol>
<pre style="padding-left: 60px">// Do something here that modifies game state.<br/>void ACollectibleObject::UpdateScore_Implementation(int32<br/>    Amount)<br/>{<br/>    if (GEngine)<br/>    {<br/>        GEngine-&gt;AddOnScreenDebugMessage(-1, 5.0f,<br/>            FColor::Green,<br/>            "Collected!");<br/>    }<br/>}<br/><br/>// Optionally validate the request and return false if the<br/>// function should not be run.<br/>bool ACollectibleObject::UpdateScore_Validate(int32 Amount)<br/>{<br/>    return true;<br/>}</pre>
<ol start="7">
<li>Save the scripts and then return to the Unity Editor. Compile your scripts and then drag an instance of the <kbd>Collectible Object</kbd> class into a scene. Save your level and play the game using two players, as shown in the previous recipe.</li>
<li>Upon collecting the object, you should see a message displayed on the screen:</li>
</ol>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f52e7aba-4dcd-4cb2-b270-ccdc626fffa7.png"/></p>
<p>With this, you can see how we can have a message replicated from a server to the client!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In the <kbd>CollectibleObject</kbd> class's constructor, we make sure that our object is going to be replicated. After that, we create a sphere collider that we tell (via a listener) to call the <kbd>OnBeginOverlap</kbd> function when it collides with another object. To do that, we use the <kbd>OnComponentBeginOverlap</kbd> function.</p>
<p class="mce-root"/>
<div class="packt_infobox">For more information on the <kbd>OnComponentBeginOverlap</kbd> function and the function that needs to be given to it, refer to <a href="https://docs.unrealengine.com/latest/INT/API/%20Runtime/Engine/Components/UPrimitiveComponent/%20OnComponentBeginOverlap/index.html">https://docs.unrealengine.com/latest/INT/API/ Runtime/Engine/Components/UPrimitiveComponent/ OnComponentBeginOverlap/index.html</a>.</div>
<p>After this, inside our <kbd>OnBeginOverlap</kbd> function, we first check if we are currently on the server. We don't want things to get called multiple times, and we want the server to be the one that tells the other clients that we've increased our score.</p>
<p>We also call the <kbd>UpdateScore</kbd> function. This function has had the following function specifiers added to it:</p>
<ul>
<li><kbd>Reliable</kbd>: The function will be replicated over the network and make it so that it is guaranteed to arrive, regardless of network errors or bandwidth issues. It requires us to select either <kbd>Client</kbd> or <kbd>Server</kbd> as an additional specifier. </li>
<li><kbd>Server</kbd>: Specifies that the function should only be called on the server. Adds an additional function that has <kbd>_Implementation</kbd> at the end of it, which is where the implementation should happen. The automatically generated code will use this function as needed.</li>
<li><kbd>WithValidation</kbd>: Adds an additional function that needs to be implemented with <kbd>_Validate</kbd> at the end. This function will take in the same parameters as the function given, but will return a bool that indicates whether the call to the main function should happen or not.</li>
</ul>
<div class="packt_infobox"><span>For more information on the other function specifiers, such as <kbd>Unreliable</kbd>, check out <a href="https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Functions#functionspecifiers">https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Functions#functionspecifiers</a>.</span></div>
<p>Calling <kbd>UpdateScore</kbd> <span>will, in turn, call the</span> <kbd>UpdateScore_Implementation</kbd> <span>function that we created and it will display a message, saying that we've collected the object by printing out some text like we used earlier.</span></p>
<p>Finally, the <kbd>UpdateScore_Validate</kbd> function is required and just tells the game that we should always run the implementation for the <kbd>UpdateScore</kbd> function.</p>
<div class="packt_infobox">For some recommendations on performance and bandwidth settings that may be useful for working with levels with a lot of replication, check out the following link: <a href="https://docs.unrealengine.com/en-US/Gameplay/Networking/Actors/ReplicationPerformance">https://docs.unrealengine.com/en-US/Gameplay/Networking/Actors/ReplicationPerformance</a><span>.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also...</h1>
                </header>
            
            <article>
                
<p>If you're interested in seeing another example of using networking and replication, refer to <a href="https://wiki.unrealengine.com/%20Networking/Replication">https://wiki.unrealengine.com/ Networking/Replication</a>.</p>
<p>In addition, you can also check out the Shooter Game example project included with Unreal Engine 4 and read the files to get a feeling for how it's used in a complete example. To read more about that, check out <a href="https://docs.unrealengine.com/en-us/Resources/SampleGames/ShooterGame">https://docs.unrealengine.com/en-us/Resources/SampleGames/ShooterGame</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling UI network events</h1>
                </header>
            
            <article>
                
<p>Since each player has their own screen, it makes sense that their UI will only display information that is relevant to them. In this recipe, we will see how to handle UI network events.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready...</h1>
                </header>
            
            <article>
                
<p>You should complete the <em>Replication properties over the network</em> recipe in this chapter, as well as be familiar with creating HUDs, which you can learn more about in <a href="a9e9a3c4-2fde-4024-a960-7eb8cc05518b.xhtml">Chapter 14</a>, <em>User Interfaces – UI and UMG</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>From your Visual Studio project (<span class="packt_screen">File | Open Visual Studio</span>), open the<span> </span><kbd>Source\&lt;Module&gt;</kbd><span> </span>folder and from there, open the <kbd>&lt;Module&gt;.build.cs</kbd><span> </span>file (in my case, it would be<span> </span><kbd>Source\Chapter_12\Chapter_12.build.cs</kbd>) and uncomment/add the following line of code:</li>
</ol>
<pre style="padding-left: 60px">using UnrealBuildTool;<br/><br/>public class Chapter_12 : ModuleRules<br/>{<br/>  public Chapter_12(ReadOnlyTargetRules Target) : base(Target)<br/>  {<br/>    PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;<br/><br/>    PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject", "Engine", "InputCore", "HeadMountedDisplay" });<br/><br/>        <strong>PrivateDependencyModuleNames.AddRange(new string[] { "Slate", "SlateCore" });</strong><br/>    }<br/>}</pre>
<ol start="2">
<li>Create a new<span> </span><kbd>HUD</kbd><span> </span>subclass using the <span class="packt_screen">Add C++ Class</span> wizard:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7af1e6e1-6019-4ef6-9aa4-93e727b3893c.png"/></p>
<ol start="3">
<li>When asked for the name, put in <kbd>NetworkHUD</kbd>, and click on the<span> </span><span class="packt_screen">Create Class</span><span> </span>button:</li>
</ol>
<p class="mce-root"/>
<p class="CDPAlignCenter CDPAlign"><img src="assets/7409fcc2-be62-42bd-8a51-b50a2d9970f6.png"/></p>
<ol start="4">
<li>Once created, open up a <kbd>GameMode</kbd> that you are planning on using (I'm using the <kbd>Chapter_12GameMode.cpp</kbd> file) and add the following to the constructor implementation:</li>
</ol>
<pre style="padding-left: 60px">#include "Chapter_12GameMode.h"<br/>#include "Chapter_12Character.h"<br/><strong>#include "NetworkHUD.h"</strong><br/>#include "UObject/ConstructorHelpers.h"<br/><br/>AChapter_12GameMode::AChapter_12GameMode()<br/>{<br/>  // set default pawn class to our Blueprinted character<br/>  static ConstructorHelpers::FClassFinder&lt;APawn&gt; PlayerPawnBPClass(TEXT("/Game/ThirdPersonCPP/Blueprints/ThirdPersonCharacter"));<br/>  if (PlayerPawnBPClass.Class != NULL)<br/>  {<br/>    DefaultPawnClass = PlayerPawnBPClass.Class;<br/>  }<br/><br/><strong>    HUDClass = ANetworkHUD::StaticClass();</strong><br/>}</pre>
<ol start="5">
<li>Inside<span> </span><kbd>NetworkHUD.h</kbd><span>, </span>add the following function with the <kbd>override</kbd><span> </span>keyword to the class:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "GameFramework/HUD.h"<br/>#include "NetworkHUD.generated.h"<br/><br/>/**<br/> * <br/> */<br/>UCLASS()<br/>class CHAPTER_12_API ANetworkHUD : public AHUD<br/>{<br/>    GENERATED_BODY()<br/><br/>public:<br/>    virtual void DrawHUD() override;<br/>};</pre>
<ol start="6">
<li>Now, implement the function:</li>
</ol>
<pre style="padding-left: 60px">#include "NetworkHUD.h"<br/><strong>#include "Engine/Canvas.h"</strong><br/><strong>#include "Chapter_12Character.h"</strong><br/><br/><strong>void ANetworkHUD::DrawHUD()</strong><br/><strong>{</strong><br/><strong>    Super::DrawHUD();</strong><br/><br/><strong>    AChapter_12Character* PlayerCharacter = Cast&lt;AChapter_12Character&gt;(GetOwningPawn());</strong><br/><br/><strong>    if(PlayerCharacter)</strong><br/><strong>    {</strong><br/><strong>        Canvas-&gt;DrawText(GEngine-&gt;GetMediumFont(), FString::Printf(TEXT("Called Jump %d times!"), PlayerCharacter-&gt;JumpCount), 10, 10);</strong><br/><strong>    }</strong><br/><strong>}</strong></pre>
<ol start="7">
<li>Finally, we can comment out the original debug message since our HUD will handle it for us:</li>
</ol>
<pre style="padding-left: 60px">void AChapter_12Character::Jump()<br/>{<br/>    Super::Jump();<br/><br/>    JumpCount++;<br/><br/><strong>    //if (Role == ROLE_Authority)</strong><br/><strong>    //{</strong><br/><strong>    // // Only print function once</strong><br/><strong>    // GEngine-&gt;AddOnScreenDebugMessage(-1, 5.0f,</strong><br/><strong>    // FColor::Green,</strong><br/><strong>    // FString::Printf(TEXT("%s called Jump %d times!"), *GetName(), JumpCount));</strong><br/><strong>    //}</strong><br/>}</pre>
<ol start="8">
<li>Compile your code and launch the editor.</li>
<li>Within the editor, open the<span> </span><span class="packt_screen">World Settings</span><span> </span>panel from the<span> </span><span class="packt_screen">Settings</span><span> </span>drop-down menu:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a304cb34-ba25-4de7-b4d2-b76012b1d7d8.jpg" style="width:13.92em;height:13.92em;"/></p>
<ol start="10">
<li>In the<span> </span><span class="packt_screen">World Settings</span><span> </span>dialog, select<span> </span><kbd>Chapter_12GameMode</kbd><span> </span>from the list under<span> </span><span class="packt_screen">GameMode Override</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/10cffe4c-4ab4-4532-90f9-46b7331710a0.png" style="width:29.08em;height:26.00em;"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="11">
<li>Play and verify that your custom HUD is drawing to the screen and that each character has their own jump value:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/edabde91-00da-49d0-b5a1-a16ce3d0c00f.png"/></p>
<p>And with that, we can take these concepts to display any property that is being replicated!</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <kbd>GetOwningPawn</kbd> method will return a pointer to the <kbd>Pawn</kbd> class the HUD is attached to. We cast that to our custom character-derived class and then can access the properties that the class has. In our case, we are using the variable that we previously added a <kbd>Replicated</kbd> tag to, which allows the HUD to update properly, depending on which screen we are using.</p>
<div class="packt_infobox"><span>For more information and additional examples of replication in use, check out <a href="https://wiki.unrealengine.com/Replication">https://wiki.unrealengine.com/Replication</a>.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also...</h1>
                </header>
            
            <article>
                
<p>For those that would like to learn more about networking with Unreal Engine 4, Cedric 'eXi' Neukirchen has created a great guide that I recommend reading. You can find that at <a href="http://cedric-neukirchen.net/Downloads/Compendium/UE4_Network_Compendium_by_Cedric_eXi_Neukirchen.pdf">http://cedric-neukirchen.net/Downloads/Compendium/UE4_Network_Compendium_by_Cedric_eXi_Neukirchen.pdf</a>.</p>


            </article>

            
        </section>
    </body></html>