- en: Chapter 11. Taking Advantages
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。利用优势
- en: 'The following topics will be covered in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Using encrypted sprite sheets
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用加密的精灵图集
- en: Using encrypted zip files
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用加密的zip文件
- en: Using encrypted SQLite files
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用加密的SQLite文件
- en: Creating Observer Pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建观察者模式
- en: Networking with HTTP
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTTP进行网络连接
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Until now, we have explained basic technical information in Cocos2d-x. It supports
    the development of games on a smartphone. Actually, you can create your original
    games using basic functions of Cocos2d-x. However, if your game is a major hit,
    cheaters might attempt to crack the code. Therefore, there are cases where encryption
    is needed to prevent unauthorized access to your game data. Encryption is an important
    aspect in game development because it helps you to protect your code and prevent
    people from ruining the overall experience of the game, and it also prevents illegal
    hacking of game. In this chapter, you will learn how to encrypt your game resources.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经解释了Cocos2d-x中的基本技术信息。它支持在智能手机上开发游戏。实际上，您可以使用Cocos2d-x的基本功能创建您自己的游戏。然而，如果您的游戏成为热门，作弊者可能会尝试破解代码。因此，在某些情况下，加密是必要的，以防止未经授权访问您的游戏数据。加密是游戏开发中的一个重要方面，因为它可以帮助您保护代码，防止人们破坏游戏的整体体验，并且还可以防止游戏被非法破解。在本章中，您将学习如何加密您的游戏资源。
- en: Using encrypted sprite sheets
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用加密的精灵图集
- en: It is pretty easy for a hacker to extract resource files from the application.
    This is a huge concern for copyright. Sprite sheets can be encrypted very easily
    using `TexturePacker`. In this recipe, you will learn how to encrypt your sprites
    to protect them from hackers and cheaters.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于黑客来说，从应用程序中提取资源文件非常容易。这对版权来说是一个巨大的担忧。精灵图集可以使用`TexturePacker`非常容易地加密。在本食谱中，您将学习如何加密您的精灵以保护它们免受黑客和作弊者的侵害。
- en: How to do it...
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: To encrypt sprite sheets using `TexturePacker`, you need to set it on the left
    pane of `TexturePacker`. Then, you need to follow the steps written here to successfully
    encrypt your sprite.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`TexturePacker`加密精灵图集，您需要在`TexturePacker`的左侧面板上设置它。然后，您需要按照这里写的步骤操作，以成功加密您的精灵。
- en: Change the Texture format to `zlib compr. PVR(.pvr.ccz, Ver.2)`
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将纹理格式更改为`zlib compr. PVR(.pvr.ccz, Ver.2)`
- en: Click on the **ContentProtection** icon, and you will see the additional window
    in which to set the password.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**内容保护**图标，您将看到一个额外的窗口，用于设置密码。
- en: Type the encryption key in the text input area as shown in the following screenshot.
    You can type in your favorite key. However, it is difficult to type in 32 hex
    digits and thus, you can just click on the **Create new key** button. After clicking
    it, you will find that it automatically inputs the **Encryption key**.![How to
    do it...](img/B0561_11_01.jpg)
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下屏幕截图所示的文本输入区域中输入加密密钥。您可以输入您喜欢的密钥。然而，输入32个十六进制数字很难，因此，您只需点击**创建新密钥**按钮。点击后，您会发现它会自动输入**加密密钥**。![如何操作...](img/B0561_11_01.jpg)
- en: Take a note of this encryption key. This is the key you will need to decrypt
    the files that are encrypted.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记下这个加密密钥。这是您将需要用来解密加密文件的密钥。
- en: Finally, you can publish the encrypted sprite sheet.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，您可以发布加密的精灵图集。
- en: How it works...
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Now, let's have a look on how to use these encrypted sprite sheets.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用这些加密的精灵图集。
- en: Add the encrypted sprite sheet to your project as shown in the following image:![How
    it works...](img/B0561_11_02.jpg)
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下图像所示将加密的精灵图集添加到您的项目中：![如何工作...](img/B0561_11_02.jpg)
- en: Include the `ZipUtils` class in `HelloWorld.cpp` to decrypt.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`HelloWorld.cpp`中包含`ZipUtils`类以解密。
- en: '[PRE0]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Set the encrypting key that is used for encryption by `TexturePacker`.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置用于加密的`TexturePacker`的加密密钥。
- en: '[PRE1]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Finally, the sprite is created using the encrypted sprite sheet.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用加密的精灵图集创建精灵。
- en: '[PRE2]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: There's more…
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容…
- en: The application has a lot of sprite sheets normally. You can use each encryption
    key per sprite sheet. But this might create some confusion. You need to use the
    same key in all the sprite sheets in your application. The first time, you need
    to click on the **Create new key** button to create the encryption key. Then,
    you need to click on the **Save as global key** button to save the encryption
    key as the global key. Next time, when you create a new encrypted sprite sheet,
    you can set this encryption key as a global key by clicking on the **Use global
    key** button.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序通常有很多精灵图集。您可以为每个精灵图集使用不同的加密密钥。但这可能会造成一些混淆。您需要在应用程序中的所有精灵图集中使用相同的密钥。第一次，您需要单击**创建新密钥**按钮来创建加密密钥。然后，您需要单击**另存为全局密钥**按钮将加密密钥保存为全局密钥。下次，当您创建新的加密精灵图集时，您可以通过单击**使用全局密钥**按钮将此加密密钥设置为全局密钥。
- en: Now, we will move on to understanding how to check the encrypted sprite sheets.
    The encrypted sprite sheet's extension is `.ccz`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将继续了解如何检查加密的精灵图集。加密的精灵图集的扩展名是 `.ccz`。
- en: Double-click the encrypted file that has the `.ccz` extension.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击具有 `.ccz` 扩展名的加密文件。
- en: Launch Texture Packer and you will see the window where you need to enter the
    decryption key, as shown in the following screenshot:![There's more…](img/B0561_11_03.jpg)
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Texture Packer，您将看到需要输入解密密钥的窗口，如图所示：![还有更多…](img/B0561_11_03.jpg)
- en: Enter the decryption key or click on the **Use global key** button. If you have
    saved the key as the global key, then click on the **OK** button.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入解密密钥或单击**使用全局密钥**按钮。如果您已将密钥保存为全局密钥，则单击**确定**按钮。
- en: 'If the key is the correct key, you will see the sprite sheet as shown in the
    preceding screenshot:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果密钥是正确的密钥，您将看到如图所示的精灵图集：
- en: Using encrypted zip files
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用加密的 zip 文件
- en: In a smartphone, the game frequently downloads a `zip` file from the server
    to update resources. These assets are generally the main targets for hackers.
    They can decode these assets to manipulate information in a game system. Hence,
    security for these assets is very important. In this case, `zip` is encrypted
    to protect against cheaters. In this recipe, you will learn how to unzip an encrypted
    `zip` file with a password.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在智能手机中，游戏经常从服务器下载 `zip` 文件以更新资源。这些资源通常是黑客的主要目标。他们可以解密这些资源以操纵游戏系统中的信息。因此，这些资源的安全性非常重要。在这种情况下，`zip`
    文件被加密以防止作弊者。在本教程中，您将学习如何使用密码解压加密的 `zip` 文件。
- en: Getting ready
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Cocos2d-x has an unzip library. However, encryption/decryption is disabled in
    this library. That's why we have to enable the crypt option in `unzip.cpp`. This
    file's path is `cocos2d/external/unzip/unzip.cpp`. You will have to comment out
    line number 71 of `unzip.cpp` to enable the crypt option.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Cocos2d-x 有一个解压库。然而，在这个库中加密/解密是禁用的。这就是为什么我们必须在 `unzip.cpp` 中启用 crypt 选项。此文件的路径是
    `cocos2d/external/unzip/unzip.cpp`。您将不得不注释掉 `unzip.cpp` 中的第 71 行以启用 crypt 选项。
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When we tried to build in Cocos2d-x version 3.7, an error occurred in `unzip.h`
    in line 46, as shown in the following code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试在 Cocos2d-x 版本 3.7 中构建时，`unzip.h` 中的第 46 行出现了错误，如下所示：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You have to edit the following code to remove this error, as shown:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须编辑以下代码以移除此错误，如下所示：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How to do it...
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'First, include the `unzip.h` file to use the unzip library in `HelloWorld.cpp`
    as shown in the following code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在 `HelloWorld.cpp` 中包含 `unzip.h` 文件以使用解压库，如下所示：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, let''s try to unzip the encrypted zip file with the password. This can
    be done by adding the following code in `HelloWorld`.cpp:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们尝试使用密码解压加密的 zip 文件。这可以通过在 `HelloWorld.cpp` 中添加以下代码来完成：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, you can unzip the encrypted zip file to use this method by specifying
    the password. If the password is `cocos2d-x`, you can unzip with the following
    code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以通过指定密码来解压加密的 zip 文件以使用此方法。如果密码是 `cocos2d-x`，您可以使用以下代码解压：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Open the encrypted zip file using the `unzOpen` function, as shown:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `unzOpen` 函数打开加密的 zip 文件，如下所示：
- en: '[PRE9]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'After opening it with the `unzOpen` function, open it again using the `unzOpenCurrentFilePassword`
    function, as shown here:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用 `unzOpen` 函数打开它之后，再次使用 `unzOpenCurrentFilePassword` 函数打开，如下所示：
- en: '[PRE10]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: After that, you can continue in the same way that is used to unzip an unencrypted
    zip file.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，您可以继续使用与解压未加密的 zip 文件相同的方式。
- en: Using encrypted SQLite files
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用加密的 SQLite 文件
- en: We often use SQLite to save the user data or game data. SQLite is a powerful
    and useful database. However, there is a database file in your game's sand box.
    Cheaters will get it from your game and they will edit it to cheat. In this recipe,
    you will learn how to encrypt your SQLite and prevent cheaters from editing it.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常使用 SQLite 来保存用户数据或游戏数据。SQLite 是一个强大且有用的数据库。然而，在你的游戏沙盒中有一个数据库文件。作弊者会从你的游戏中获取它，并对其进行编辑以作弊。在这个菜谱中，你将学习如何加密你的
    SQLite 并防止作弊者编辑它。
- en: Getting ready
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: We will use the `wxSqlite` library to encrypt SQLite. This is free software.
    Firstly, you need to install `wxSqlite` in Cocos2d-x and edit some code and set
    files in Cocos2d-x.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `wxSqlite` 库来加密 SQLite。这是一个免费软件。首先，你需要在 Cocos2d-x 中安装 `wxSqlite` 并编辑一些代码，并在
    Cocos2d-x 中设置文件。
- en: 'Download the `wxSqlite3` project''s zip file. Visit the following url: [http://sourceforge.net/projects/wxcode/files/Components/wxSQLite3/wxsqlite3-3.1.1.zip/download](http://sourceforge.net/projects/wxcode/files/Components/wxSQLite3/wxsqlite3-3.1.1.zip/download)'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载 `wxSqlite3` 项目的 zip 文件。访问以下网址：[http://sourceforge.net/projects/wxcode/files/Components/wxSQLite3/wxsqlite3-3.1.1.zip/download](http://sourceforge.net/projects/wxcode/files/Components/wxSQLite3/wxsqlite3-3.1.1.zip/download)
- en: Expand the zip file.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解压 zip 文件。
- en: Create a new folder called `wxsqlite` under `cocos2d/external`.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `cocos2d/external` 下创建一个名为 `wxsqlite` 的新文件夹。
- en: Copy `sqlite3/secure/src` after expanding the folder to `cocos2d/external/wxsqlite`
    as shown in the following screenshot:![Getting ready](img/B0561_11_04.jpg)
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在展开文件夹后，将 `sqlite3/secure/src` 复制到 `cocos2d/external/wxsqlite`，如下截图所示：![准备中](img/B0561_11_04.jpg)
- en: Add `sqlite3.h` and `sqlite3secure.c` in `wxsqlite/src` that you added in step
    4 to your project, as shown in the following screenshot:![Getting ready](img/B0561_11_05.jpg)
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将在第 4 步中添加到 `wxsqlite/src` 的 `sqlite3.h` 和 `sqlite3secure.c` 添加到你的项目中，如下截图所示：![准备中](img/B0561_11_05.jpg)
- en: Add `-DSQLITE_HAS_CODEC` to `Other C Flags` in **Build Settings** of Xcode,
    as shown in the following screenshot:![Getting ready](img/B0561_11_06.jpg)
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Xcode 的 **构建设置** 中的 **其他 C 标志** 中添加 `-DSQLITE_HAS_CODEC`，如下截图所示：![准备中](img/B0561_11_06.jpg)
- en: 'Create a new file called `Android.mk` in `cocos2d/external/wxsqlite`, as shown
    in the following code:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `cocos2d/external/wxsqlite` 中创建一个名为 `Android.mk` 的新文件，如下代码所示：
- en: '[PRE11]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Edit `Android.mk` in `cocos2d/cocos/storage/local-storage`, as shown in the
    following code:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `cocos2d/cocos/storage/local-storage` 中编辑 `Android.mk`，如下代码所示：
- en: '[PRE12]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Edit `LocalStorage.cpp` in `cocos2d/cocos/storage/local-storage`. Comment out
    line 33 and line 180, as shown in the following code.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `cocos2d/cocos/storage/local-storage` 中编辑 `LocalStorage.cpp`。注释掉第 33 行和第 180
    行，如下代码所示。
- en: '`LocalStorage.cpp` line33:'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`LocalStorage.cpp` 第 33 行：'
- en: '[PRE13]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`LocalStorage.cpp` line180:'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`LocalStorage.cpp` 第 180 行：'
- en: '[PRE14]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Edit `Android.mk` in `proj.andorid/jni`, as shown in the following code:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `proj.andorid/jni` 中编辑 `Android.mk`，如下代码所示：
- en: '[PRE15]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: After this, SQLite is encrypted and can be used in your project.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，SQLite 被加密，可以在你的项目中使用。
- en: How to do it...
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: You have to include `sqlite3.h` to use SQLite APIs.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你必须包含 `sqlite3.h` 以使用 SQLite API。
- en: '[PRE16]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create the encrypted database, as shown in the following code:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建加密的数据库，如下代码所示：
- en: '[PRE17]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Select the data from the encrypted database, as shown in the following code:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从加密的数据库中选择数据，如下代码所示：
- en: '[PRE18]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Firstly, you have to create the encrypted database with the `pass` phrase.
    To create it, follow these three steps:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你必须使用 `pass` 语句创建加密的数据库。要创建它，请按照以下三个步骤进行：
- en: Open the database normally.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正常打开数据库。
- en: Next, set the pass phrase using the `sqlite3_key` function.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用 `sqlite3_key` 函数设置密码短语。
- en: '[PRE19]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Finally, execute sql to create tables.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，执行 SQL 语句来创建表。
- en: After this, you will need the encrypted database file in the application. You
    can get it from the path that was printed by CCLOG.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，你将需要在应用程序中使用加密的数据库文件。你可以从 CCLOG 打印的路径中获取它。
- en: To select data from there, the same method is used. You can get data from the
    encrypted database using the same pass phrase after opening the database.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要从中选择数据，使用相同的方法。在打开数据库后，你可以使用相同的密码短语从加密的数据库中获取数据。
- en: There's more…
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'You must be wondering whether this database was really encrypted. So let''s
    check it. Open the database using the command line and executing the command as
    shown:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道这个数据库是否真的被加密了。那么让我们检查一下。使用命令行打开数据库并执行以下命令：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If the database is encrypted, you will not be able to open it and an error
    message will pop up, as shown:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据库被加密，你将无法打开它，并且会弹出错误消息，如下所示：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Creating Observer Pattern
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建观察者模式
- en: Event Dispatcher is a mechanism for responding to events such as touching screen,
    keyboard events and custom events. You can get an event using Event Dispatcher.
    In addition, you can create `Observer Pattern` in the design patterns using it.
    In this recipe, you will learn how to use Event Dispatcher and how to create Observer
    Pattern in Cocos2d-x.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 事件调度器是一种响应触摸屏幕、键盘事件和自定义事件等事件的机制。你可以使用事件调度器来获取事件。此外，你可以在设计模式中使用它来创建观察者模式。在本教程中，你将学习如何使用事件调度器以及如何在Cocos2d-x中创建观察者模式。
- en: Getting ready
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Firstly, we will go through the details of Observer Pattern. Observer Pattern
    is a design pattern. When an event occurs, Observer notifies the event about the
    subjects that are registered in Observer. It is mainly used to implement distributed
    event handling. Observer Pattern is also a key part in the MVC architecture.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将详细介绍观察者模式。观察者模式是一种设计模式。当事件发生时，观察者通知观察者中注册的主题。它主要用于实现分布式事件处理。观察者模式也是MVC架构中的关键部分。
- en: '![Getting ready](img/B0561_11_07.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/B0561_11_07.jpg)'
- en: How to do it...
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We will create a count up label per second in this recipe. When touching a screen,
    count up labels are created in this position, and then, count up per second using
    Observer Pattern.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将每秒创建一个计数标签。当触摸屏幕时，计数标签将在此位置创建，然后使用观察者模式每秒进行计数。
- en: 'Create `Count` class that is extended `Label` class as shown in the following
    code:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个扩展`Label`类的`Count`类，如下面的代码所示：
- en: '[PRE22]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, when touching a screen, this label will be created at the touching position
    and will call the `HelloWorld::countUp` method per second using a scheduler as
    the following code in `HelloWorld.cpp`:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，当触摸屏幕时，此标签将在触摸位置创建，并使用调度器每秒调用`HelloWorld::countUp`方法，如以下`HelloWorld.cpp`中的代码所示：
- en: '[PRE23]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: After building and running this project, when you touch the screen, it will
    create a count up label at the touching position, and then you will see that the
    labels are counting up per second at the same time.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行此项目后，当你触摸屏幕时，它将在触摸位置创建一个计数标签，然后你会看到标签同时每秒进行计数。
- en: How it works...
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Add the custom event called `TimeCount`. If `TimeCount` event occurred, then
    the `Count::countUp` method is called.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加名为`TimeCount`的自定义事件。如果`TimeCount`事件发生，则调用`Count::countUp`方法。
- en: '[PRE24]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Don't forget that you need to remove the custom event from `EventDispatcher`
    when the instance of the `Count` class is removed. If you forget to do that, then
    the `zombie` instance will be called from `EventDispatcher` when the event occurs
    and your game will crash.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要忘记，当移除`Count`类的实例时，需要从`EventDispatcher`中移除自定义事件。如果你忘记这样做，那么当事件发生时，`EventDispatcher`将调用`zombie`实例，你的游戏将会崩溃。
- en: '[PRE25]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In `HelloWorld.cpp`, call the `HelloWorld::countUp` method using the scheduler.
    The `HelloWorld::countUp` method calls the custom event called `TimeOut`.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`HelloWorld.cpp`中，使用调度器调用`HelloWorld::countUp`方法。`HelloWorld::countUp`方法调用名为`TimeOut`的自定义事件。
- en: '[PRE26]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: And then, `EventDispatcher` will notify this event to the listed subjects. In
    this case, the `Count::countUp` method is called.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，`EventDispatcher`将通知列出的主题。在这种情况下，调用`Count::countUp`方法。
- en: '[PRE27]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: There's more…
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Using `EventDispatcher`, labels count up at the same time. If you use Scheduler
    instead of `EventDispatcher`, you will notice something different.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`EventDispatcher`，标签同时计数。如果你使用调度器而不是`EventDispatcher`，你会注意到一些不同之处。
- en: 'Change the `Count::init` method as shown in the following code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下代码更改`Count::init`方法：
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this code, use a scheduler by calling the `Count::countUp` method per second.
    You can see that the labels are not counting up at the same time in this way.
    Each label is counting up per second, however not at the same time. Using Observer
    Pattern, a lot of subjects can be called at the same time.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，通过每秒调用`Count::countUp`方法使用调度器。你可以看到，标签不是同时计数的。每个标签都是每秒进行计数，然而不是同时。使用观察者模式，可以同时调用许多主题。
- en: Networking with HTTP
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用HTTP进行网络连接
- en: In recent smartphone games, we normally use an Internet network to update data,
    download resources, and so on. There aren't any games developed without networking.
    In this recipe, you will learn how to use networking to download resources.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在最近的智能手机游戏中，我们通常使用互联网网络来更新数据、下载资源等。没有网络的游戏是不存在的。在本教程中，你将学习如何使用网络下载资源。
- en: Getting ready
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You have to include the header file of `network/HttpClient` to use networking.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用网络，必须包含`network/HttpClient`的头文件。
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If you run it on Android devices, you need to edit `proj.android/AndroidManifest.xml`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你要在Android设备上运行它，你需要编辑`proj.android/AndroidManifest.xml`。
- en: '[PRE30]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How to do it...
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: In the following code, we will get the response from [http://google.com/](http://google.com/)
    and then, print the response data as a log.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们将从[http://google.com/](http://google.com/)获取响应，然后，将响应数据作为日志打印出来。
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works...
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Firstly, create an `HttpRequest` instance. The `HttpRequest` class does not
    have a `create` method. That's why you use `new` for creating the instance.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个`HttpRequest`实例。`HttpRequest`类没有`create`方法。这就是为什么你使用`new`来创建实例。
- en: '[PRE32]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Specify URL and the request type. In this case, set [http://google.com/](http://google.com/)
    as a request URL and set GET as a request type.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定URL和请求类型。在这种情况下，将[http://google.com/](http://google.com/)设置为请求URL，并将GET设置为请求类型。
- en: '[PRE33]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Set callback function to receive the data from the server. You can check its
    success using the `HttpResponse::isSucceed` method. And then you can get the response
    data using the `HttpResponse::getResponseData` method.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置回调函数以接收来自服务器的数据。你可以使用`HttpResponse::isSucceed`方法检查其成功。然后，你可以使用`HttpResponse::getResponseData`方法获取响应数据。
- en: '[PRE34]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You can request networking by calling the `HttpClient::send` method specifying
    the instance of the `HttpRequest` class. If you are getting a response via the
    network, then call the callback function as mentioned in Step3.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过调用指定`HttpRequest`类实例的`HttpClient::send`方法来请求网络。如果你通过网络获取响应，那么调用第3步中提到的回调函数。
- en: '[PRE35]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Finally, you have to release the instance of `HttpRequest`. That's why you created
    it by using `new`.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你必须释放`HttpRequest`实例。这就是你使用`new`创建它的原因。
- en: '[PRE36]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: There's more…
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In this section, you will learn how you can get resources from the network using
    the `HttpRequest` class. In the following code, get the Google log from the network
    and display it.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何使用`HttpRequest`类从网络获取资源。在下面的代码中，从网络获取谷歌日志并显示。
- en: '[PRE37]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You can see the following window after building and running this code.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行此代码后，你可以看到以下窗口。
- en: '![There''s more…](img/B0561_11_08.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多…](img/B0561_11_08.jpg)'
- en: Tip
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You have to save the original data in the sandbox. You can get the path of the
    sandbox using the `FileUtils::getWritablePath` method.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须将原始数据保存在沙盒中。你可以使用`FileUtils::getWritablePath`方法获取沙盒的路径。
