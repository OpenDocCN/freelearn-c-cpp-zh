- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: A Comprehensive Look at RAII
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RAII 的全面审视
- en: Resource management is probably the second most frequent thing a program does,
    after computing. But just because it’s frequently done does not mean it’s visible—some
    languages hide most, or all, resource management from the user. And just because
    it is hidden, does not mean it’s not there.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 资源管理可能是程序做的第二频繁的事情，仅次于计算。但仅仅因为它是频繁进行的，并不意味着它是可见的——某些语言会隐藏大部分或全部的资源管理，不让用户看到。而且，即使它被隐藏，并不意味着它不存在。
- en: Every program needs to use some memory, and memory is a resource. A program
    would be of no use if it never interacted with the outside world in some way,
    at least to print the result, and input and output channels (files, sockets, and
    so on) are resources.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 每个程序都需要使用一些内存，而内存是一种资源。如果程序从未以某种方式与外界交互（至少要打印结果），那么它将毫无用处，输入输出通道（文件、套接字等）也是资源。
- en: 'In this chapter, we will start by answering the following questions:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先回答以下问题：
- en: What is considered a resource in a C++ program?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 C++ 程序中，什么被认为是资源？
- en: What are the key concerns for managing resources in C++?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 C++ 中管理资源的关键关注点是什么？
- en: 'Then, we will introduce **Resource Acquisition is Initialization** (**RAII**)
    and explain how it helps in efficient resource management in C++ by answering
    these questions:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将介绍**资源获取即初始化**（**RAII**）并解释它如何通过回答以下问题来帮助 C++ 中的高效资源管理：
- en: What is the standard approach for managing resources in C++ (RAII)?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 C++ 中管理资源的标准方法（RAII）是什么？
- en: How does RAII solve the problems of resource management?
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RAII 如何解决资源管理的问题？
- en: 'We will end the chapter with a discussion about the implications and possible
    concerns of using RAII by providing the answers to these questions:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将结束本章的讨论，通过回答以下问题来探讨使用 RAII 的影响和可能的关注点：
- en: What are the precautions that must be taken when writing RAII objects?
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编写 RAII 对象时必须采取哪些预防措施？
- en: What are the consequences of using RAII for resource management?
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 RAII 进行资源管理会有什么后果？
- en: C++, with its zero-overhead abstraction philosophy, does not hide resources
    or their management at the core language level. But we would do well to not confuse
    hiding resources with managing them.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 具有零开销抽象哲学，它不会在核心语言级别隐藏资源或其管理。但我们最好不要将隐藏资源与资源管理混淆。
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Here are some useful links:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些有用的链接：
- en: 'Google Test unit testing framework: [https://github.com/google/googletest](https://github.com/google/googletest)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Test 单元测试框架：[https://github.com/google/googletest](https://github.com/google/googletest)
- en: 'Google Benchmark library: [https://github.com/google/benchmark](https://github.com/google/benchmark)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Benchmark 库：[https://github.com/google/benchmark](https://github.com/google/benchmark)
- en: 'Example code: [https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter05](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter05)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码：[https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter05](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter05)
- en: Resource management in C++
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++ 中的资源管理
- en: Every program operates on resources and needs to manage them. The most commonly
    used resource is memory, of course. Hence, you often read about **memory** **management**
    in C++. But really, resources can be just about anything. Many programs exist
    specifically to manage real, tangible physical resources, or the more ephemeral
    (but no less valuable) digital ones. Money in bank accounts, airline seats, car
    parts and assembled cars, or even crates of milk—in today’s world, if it is something
    that needs to be counted and tracked, there is a piece of software somewhere that
    is doing it. But even in a program that does pure computations, there may be varied
    and complex resources, unless the program also eschews abstractions and operates
    at the level of bare numbers. For example, a physics simulation program may have
    particles as resources.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 每个程序都在操作资源，并需要管理它们。最常用的资源当然是内存。因此，你经常会在 C++ 中读到**内存****管理**。但事实上，资源可以是任何东西。许多程序专门用于管理真实的有形物理资源，或者更短暂的（但同样有价值）数字资源。银行账户中的钱、航班座位、汽车零件和组装好的汽车，甚至牛奶箱——在当今世界，如果需要计数和跟踪的东西，某个地方总有一款软件在做这件事。但即使在只做纯计算的程序中，也可能存在各种复杂资源，除非程序也放弃了抽象，在纯数字级别上操作。例如，一个物理模拟程序可能有粒子作为资源。
- en: All of these resources have one thing in common—they need to be accounted for.
    They should not vanish without a trace, and a program should not just make up
    resources that don’t really exist. Often, a specific instance of a resource is
    needed—you would not want someone else’s purchase to be debited from your bank
    account; the specific instance of the resource matters. Thus, the most important
    consideration when evaluating different approaches to resource management is correctness—how
    well does the design ensure that resources are managed properly, how easy is it
    to make a mistake, and how hard would it be to find such a mistake? It should
    come as no surprise, then, that we use a testing framework to present the coding
    examples of resource management in this chapter.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些资源有一个共同点——它们都需要被考虑在内。它们不应该无影无踪地消失，程序也不应该虚构不存在资源。通常，需要特定实例的资源——你不会希望别人的购买从你的银行账户中扣除；资源的特定实例很重要。因此，在评估不同资源管理方法时最重要的考虑因素是正确性——设计如何确保资源得到适当管理，犯错的难易程度，以及发现此类错误的难度如何？因此，我们使用测试框架来展示本章中资源管理的编码示例也就不足为奇了。
- en: Installing the microbenchmark library
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装微基准测试库
- en: 'In our case, we are interested in the efficiency of memory allocations and
    small fragments of code that may contain such allocations. The appropriate tool
    for measuring the performance of small fragments of code is a microbenchmark.
    There are many microbenchmark libraries and tools out there; in this book, we
    will use the Google Benchmark library. To follow along with the examples in this
    chapter, you must first download and install the library (follow the instructions
    in the `Readme.md` file). Then you can compile and run the examples. You can build
    the sample files included with the library to see how to build a benchmark on
    your particular system; you can also use the example benchmark from this chapter’s
    repository:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们对内存分配效率和可能包含此类分配的小段代码的效率感兴趣。测量小段代码性能的适当工具是微基准测试。市面上有许多微基准测试库和工具；在本章中，我们将使用Google
    Benchmark库。要跟随本章的示例，你必须首先下载并安装库（按照`Readme.md`文件中的说明操作）。然后你可以编译并运行示例。你可以构建库中包含的样本文件，以了解如何在你的特定系统上构建基准测试；你也可以使用本章存储库中的示例基准测试：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Note the call to `DoNotOptimize()`: it’s a special function that doesn’t generate
    any code but tricks the compiler into thinking that its argument is necessary
    and cannot be optimized away. Without this, the compiler will probably figure
    out that the entire benchmark loop has no observable effect and can be optimized
    to nothing.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意对`DoNotOptimize()`的调用：这是一个不会生成任何代码但欺骗编译器认为其参数是必要的且不能被优化掉的特殊函数。没有这个，编译器可能会推断出整个基准测试循环没有可观察的效果，可以被优化为无。
- en: 'On a Linux machine, the command to build and run a benchmark program called
    `01_benchmark.C` might look something like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux机器上，构建并运行名为`01_benchmark.C`的基准测试程序的命令可能看起来像这样：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, `$CXX` is your C++ compiler, such as `g++` or `clang++`, and `$GBENCH_DIR`
    is the directory where the benchmark is installed.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`$CXX`是你的C++编译器，例如`g++`或`clang++`，而`$GBENCH_DIR`是基准测试安装的目录。
- en: 'The preceding example should print something like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例应该打印出类似以下内容：
- en: '![](img/Figure_5.1_B19262.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_5.1_B19262.jpg)'
- en: On this particular machine, a single iteration (one pair of calls to `malloc()`
    and `free()`) takes 6.37 nanoseconds, which translates into 157 million memory
    allocations per second.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这台特定的机器上，单个迭代（一次对`malloc()`和`free()`的调用）需要6.37纳秒，这相当于每秒1.57亿次内存分配。
- en: 'Sometimes we have to benchmark very short operations:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们必须对非常短的操作进行基准测试：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We may be reasonably concerned about the overhead of the benchmark loop itself.
    In such cases, we can execute multiple copies of the benchmarked operation within
    the body of the loop. We can even get the C++ preprocessor to make copies for
    us:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会对基准测试循环本身的开销表示合理的关注。在这种情况下，我们可以在循环体中执行多个基准测试操作的副本。我们甚至可以让C++预处理器为我们复制：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The time of a “*single*” iteration now includes 32 iterations, so it is much
    easier to use the items per second value. Remember to include repeat count in
    the number of items processed:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: “*单个*”迭代的现在包括32次迭代，因此使用每秒项目数值要容易得多。请记住在处理的项目数量中包含重复计数：
- en: '![](img/Figure_5.2_B19262.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_5.2_B19262.jpg)'
- en: Writing fast programs is all well and good, but they have to be correct first.
    To that end, we need to write tests, so we also need a testing framework.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 编写快速程序固然很好，但它们首先必须是正确的。为此，我们需要编写测试，因此我们还需要一个测试框架。
- en: Installing Google Test
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Google Test
- en: 'We will be testing very small fragments of code for correctness. On the one
    hand, this is simply because each fragment illustrates a specific concept or idea.
    On the other hand, even in a large-scale software system, resource management
    is done by small building blocks of code. They may combine to form a quite complex
    resource manager, but each block performs a specific function and is testable.
    The appropriate testing system for this situation is a unit testing framework.
    There are many such frameworks to choose from; in this book, we will use the Google
    Test unit testing framework. To follow along with the examples in this chapter,
    you must first download and install the framework (follow the instructions in
    the `README` file). Once installed, you can compile and run the examples. You
    can build the sample tests included with the library to see how to build and link
    with Google Test on your particular system; you can also use the example from
    this chapter’s repository:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将测试非常小的代码片段的正确性。一方面，这仅仅是因为每个片段说明了特定的概念或想法。另一方面，即使在大型软件系统中，资源管理也是通过小的代码块来完成的。它们可能组合成一个相当复杂的资源管理器，但每个块执行特定的功能并且是可测试的。这种情况下的适当测试系统是单元测试框架。有许多这样的框架可供选择；在本章中，我们将使用
    Google Test 单元测试框架。要跟随本章中的示例，您必须首先下载并安装该框架（遵循 `README` 文件中的说明）。一旦安装，您就可以编译并运行示例。您可以构建库中包含的示例测试，以了解如何在您的特定系统上构建和链接
    Google Test；您还可以使用本章存储库中的示例：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'On a Linux machine, the command to build and run a `02_test.C` test might look
    something like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 机器上，构建和运行 `02_test.C` 测试的命令可能看起来像这样：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, `$CXX` is your C++ compiler, such as `g++` or `clang++`, and `$GTEST_DIR`
    is the directory where Google Test is installed. If all tests pass, you should
    get this output:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`$CXX` 是您的 C++ 编译器，例如 `g++` 或 `clang++`，而 `$GTEST_DIR` 是 Google Test 安装的目录。如果所有测试都通过，您应该得到以下输出：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Writing good tests is an art. We have to identify the aspects of our code that
    need to be validated and come up with ways to observe these aspects. In this chapter,
    we are interested in resource management, so let us see how we can test the utilization
    and release of resources.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 编写好的测试是一种艺术。我们必须确定代码中需要验证的方面，并想出观察这些方面的方法。在本章中，我们关注资源管理，让我们看看我们如何测试资源的利用和释放。
- en: Counting resources
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源计数
- en: A unit testing framework, such as Google Test, allows us to execute some code
    and verify that the results are what they should be. The results that we can look
    at include any variable or expression that we can access from the test program.
    That definition does not extend, for example, to the amount of memory that is
    currently in use. So, if we want to verify that resources are not disappearing,
    we have to count them.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试框架，如 Google Test，允许我们执行一些代码并验证结果是否符合预期。我们可以查看的结果包括从测试程序可以访问的任何变量或表达式。这个定义并不包括例如当前使用的内存量。因此，如果我们想验证资源没有消失，我们必须计数。
- en: 'In the following simple test fixture, we use a special resource class instead
    of, say, the `int` keyword. This class is instrumented to count how many objects
    of this type have been created, and how many are currently alive:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下简单的测试用例中，我们使用一个特殊的资源类而不是，比如说，`int` 关键字。这个类被配置为统计已创建的此类对象的数量以及当前活跃的对象数量：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now we can test that our program manages resources correctly, as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以测试我们的程序是否正确管理资源，如下所示：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In Google Test, every test is implemented as a **test fixture**. There are
    several types; the simplest one is a standalone test function, such as the one
    we use here. Running this simple test program tells us that the test has passed,
    as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Google Test 中，每个测试都实现为一个 **测试用例**。有几种类型；最简单的一种是独立的测试函数，就像我们在这里使用的那样。运行这个简单的测试程序告诉我们测试已经通过，如下所示：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The expected results are verified using one of the `EXPECT_*` macros and any
    test failures will be reported. This test verifies that, after creating and deleting
    an instance of the type `object_counter`, there are no such objects left, and
    that exactly one was constructed.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 预期结果是通过使用 `EXPECT_*` 宏之一来验证的，任何测试失败都会被报告。这个测试验证了在创建和删除 `object_counter` 类型的实例之后，没有留下这样的对象，并且恰好创建了一个实例。
- en: Dangers of manual resource management
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动资源管理的危险
- en: C++ allows us to manage resources almost at the hardware level, and someone,
    somewhere, must indeed manage them at this level. The latter is actually true
    for every language, even the high-level ones that do not expose such details to
    the programmers. But *somewhere* does not have to be in your program! Before we
    learn the C++ solutions and tools for resource management, let’s first understand
    the problems that arise from not using any such tools.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: C++允许我们在几乎硬件级别上管理资源，实际上，某处确实有人在这个级别上管理它们。对于每种语言来说，这实际上都是正确的，即使是那些不向程序员暴露此类细节的高级语言。但“某处”不必就在你的程序中！在我们学习C++的资源管理解决方案和工具之前，让我们首先了解不使用此类工具会引发的问题。
- en: Manual resource management is error-prone
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动资源管理容易出错
- en: 'The first and most obvious danger of managing every resource manually, with
    explicit calls to acquire and release each one, is that it is easy to forget the
    latter. For example, see the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 手动管理每个资源，通过显式调用获取和释放每个资源的方式，最明显的危险是很容易忘记释放。例如，看看以下情况：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We are now leaking a resource (the `object_counter` objects, in this case).
    If we did this in a unit test, it would fail, as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在正在泄露一个资源（在这种情况下是`object_counter`对象）。如果我们在一个单元测试中这样做，它将会失败，如下所示：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can see the failing tests, and the location of the failures, as reported
    by the unit test framework:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到失败的测试和失败的地点，这是由单元测试框架报告的：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In a real program, finding such errors is much harder. Memory debuggers and
    sanitizers can help with memory leaks, but they require that the program actually
    execute the buggy code, so they depend on the test coverage.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个真实程序中，找到这样的错误要困难得多。内存调试器和清理器可以帮助处理内存泄露，但它们需要程序实际执行有缺陷的代码，因此它们依赖于测试覆盖率。
- en: 'The resource leaks can be much subtler and harder to find, too. Consider this
    code, where we did not forget to release the resource:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 资源泄露可能更加微妙且难以发现。考虑以下代码，我们并没有忘记释放资源：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'During subsequent maintenance, a possible failure condition was discovered,
    and the appropriate test was added:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在后续的维护中，发现了一个可能的问题状态，并添加了相应的测试：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This change introduced a subtle bug—now, resources are leaked only if the intermediate
    computation has failed and triggered the early return. If the failure is rare
    enough, this mistake may escape all tests, even if the testing process employs
    regular memory sanitizer runs. This mistake is also all too easy to make since
    the edit could be made in a place far removed from both the construction and deletion
    of the object, and nothing in the immediate context gives the programmer a hint
    that a resource needs to be released.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个更改引入了一个微妙的错误——现在，只有在中间计算失败并触发提前返回时才会泄露资源。如果失败足够罕见，这个错误可能会逃过所有测试，即使测试过程使用了常规的内存清理器运行。这个错误也很容易犯，因为编辑可能是在远离对象构建和删除的地方进行的，而且立即的上下文中没有任何东西给程序员提示需要释放资源。
- en: 'The alternative to leaking a resource, in this case, is to release it. Note
    that this leads to some code duplication:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，资源泄露的替代方案是释放它。请注意，这会导致一些代码重复：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As with any code duplication, there comes the danger of code divergence. Let’s
    say that the next round of code enhancements required more than one `object_counter`,
    and an array of them is now allocated as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何代码重复一样，存在代码分歧的危险。假设下一轮代码增强需要多个`object_counter`，现在它们作为一个数组被分配如下：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If we change `new` to the `new` array, we must change `delete` as well; the
    thought goes, there is probably one at the end of the function. Who knew that
    there was one more in the middle? Even if the programmer had not forgotten about
    the resources, manual resource management gets disproportionately more error-prone
    as the program becomes more complex. And not all resources are as forgiving as
    a counter object. Consider the following code that performs some concurrent computation,
    and must acquire and release mutex locks. Note the very words **acquire** and
    **release**, the common terminology for locks, suggest that locks are treated
    as a kind of resource (the resource here is exclusive access to the data protected
    by the lock):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`new`改为`new`数组，我们必须也将`delete`改为数组形式的`delete`；这种想法是，函数的末尾可能有一个。谁知道中间还有一个呢？即使程序员没有忘记资源，随着程序变得更加复杂，手动资源管理会变得不成比例地容易出错。并不是所有资源都像计数器对象那样宽容。考虑以下执行一些并发计算并必须获取和释放互斥锁的代码。注意，**获取**和**释放**这两个词，作为锁的通用术语，暗示锁被当作一种资源（这里的资源是锁保护的数据的独占访问）：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This code has both duplication and divergence. It also has a bug—see if you
    can find it (hint—count how many times `m3` is unlocked, versus how many `return`
    statements there are after it’s locked). As the resources become more numerous
    and complex to manage, such bugs are going to creep up more often.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码既有重复也有分歧。它还包含一个错误——看看你是否能找到它（提示——计算`m3`解锁的次数，与它之后有多少`return`语句）。随着资源变得越来越多且管理起来越来越复杂，这样的错误将会更频繁地出现。
- en: Resource management and exception safety
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源管理和异常安全
- en: 'Remember the code at the beginning of the previous section—the one we said
    is correct, where we did not forget to release the resource? Consider the following
    code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 记得上一节开头提到的代码吗——我们说它是正确的，因为我们没有忘记释放资源？考虑以下代码：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'I have bad news for you—this code probably wasn’t correct either. If any of
    the many more lines of code can throw an exception, then `delete p` is never going
    to be executed:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我有一个坏消息要告诉你——这段代码可能也不正确。如果任何更多的代码行可以抛出异常，那么`delete p`永远不会被执行：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This looks very similar to the early `return` problem, only worse—the exception
    can be thrown by any code that the `process()` function calls. The exception can
    even be added later to some code that the `process()` function calls, without
    any changes in the function itself. It used to work fine, then one day it does
    not.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来与早期的`return`问题非常相似，但更糟糕——异常可以由`process()`函数调用的任何代码抛出。异常甚至可以添加到`process()`函数调用的某些代码中，而函数本身没有任何变化。它曾经工作得很好，然后有一天它就不行了。
- en: 'Unless we change our approach to resource management, the only solution is
    to use the `try …` `catch` blocks:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 除非我们改变资源管理的方法，否则唯一的解决方案是使用`try …` `catch`块：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The obvious problem here is code duplication again, as well as the proliferation
    of the `try … catch` blocks literally everywhere. Worse than that, this approach
    does not scale should we need to manage multiple resources, or even just manage
    anything more complex than a single acquisition with a corresponding release:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这里明显的问题是代码重复，以及`try … catch`块无处不在的泛滥。更糟糕的是，如果我们需要管理多个资源，或者只是管理比单个获取和释放更复杂的事情，这种方法就不适用了：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now, we can’t even decide whether the catch block should release the mutex or
    not—it depends on whether the exception was thrown before or after the `unlock()`
    operation that happens in the normal, non-exceptional control flow. Also, the
    `object_counter` constructor could throw an exception (not the simple one we had
    so far, but a more complex one that ours could evolve into). That would happen
    outside of the `try … catch` block, and the mutex would never get unlocked.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们甚至不能决定是否在捕获块中释放互斥锁——这取决于异常是在`unlock()`操作之前还是之后抛出的。此外，`object_counter`构造函数可能会抛出异常（不是我们之前遇到的简单异常，而是一个更复杂的异常，我们的代码可能会演变成）。这将会发生在`try
    … catch`块之外，互斥锁将永远不会被解锁。
- en: It should be clear to us by now that we need an entirely different solution
    for the resource management problem, not some patchwork. In the next section,
    we will discuss the pattern that became the golden standard of resource management
    in C++.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，我们应该很清楚，我们需要一个完全不同的解决方案来处理资源管理问题，而不仅仅是修补。在下一节中，我们将讨论成为C++中资源管理黄金标准的模式。
- en: The RAII idiom
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RAII习语
- en: We have seen in the previous section how ad hoc attempts to manage resources
    become unreliable, then error-prone, and eventually fail. What we need is to make
    sure that resource acquisition is always paired up with resource release, and
    that these two actions happen before and after the section of code that uses the
    resource respectively. In C++, this kind of bracketing of a code sequence by a
    pair of actions is known as the Execute Around design pattern.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前一节中看到了尝试管理资源是如何变得不可靠，然后是错误倾向，最终失败的。我们需要确保资源获取始终与资源释放配对，并且这两个动作分别在使用资源的代码段之前和之后发生。在
    C++ 中，这种通过一对动作括起来的代码序列称为 Execute Around 设计模式。
- en: Tip
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: For more information, see the article *C++ Patterns – Executing Around Sequences*
    by Kevlin Henney, available at [http://www.two-sdg.demon.co.uk/curbralan/papers/europlop/ExecutingAroundSequences.pdf](http://www.two-sdg.demon.co.uk/curbralan/papers/europlop/ExecutingAroundSequences.pdf).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，请参阅 Kevlin Henney 撰写的文章 *C++ Patterns – Executing Around Sequences*，可在
    [http://www.two-sdg.demon.co.uk/curbralan/papers/europlop/ExecutingAroundSequences.pdf](http://www.two-sdg.demon.co.uk/curbralan/papers/europlop/ExecutingAroundSequences.pdf)
    获取。
- en: When specifically applied to resource management, this pattern is much more
    widely known as **Resource Acquisition is** **Initialization** (**RAII**).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当具体应用于资源管理时，这种模式更广为人知的是 **资源获取即初始化**（**RAII**）。
- en: RAII in a nutshell
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RAII 简而言之
- en: The basic idea behind RAII is very simple—there is one kind of function in C++
    that is guaranteed to be called automatically, and that is the destructor of an
    object created on the stack, or the destructor of an object that is a data member
    of another object (in the latter case, the guarantee holds only if the containing
    class itself is destroyed). If we could hook up the release of the resource to
    the destructor of such an object, then the release could not be forgotten or skipped.
    It stands to reason that if releasing the resource is handled by the destructor,
    acquiring it should be handled by the constructor during the initialization of
    the object. Hence the full meaning of RAII as introduced in the title of this
    chapter—*A Comprehensive Look* *at RAII*.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: RAII（资源获取即初始化）背后的基本思想非常简单——在 C++ 中有一种函数可以保证自动调用，那就是在栈上创建的对象的析构函数，或者另一个对象的数据成员的析构函数（在后一种情况下，保证仅在包含的类本身被销毁时成立）。如果我们能将资源的释放与这种对象的析构函数挂钩，那么释放就不会被遗忘或跳过。从逻辑上讲，如果释放资源由析构函数处理，那么获取资源应该由构造函数在对象的初始化期间处理。因此，本章标题中介绍的
    RAII 的完整意义——*全面了解 RAII*。
- en: 'Let’s see how this works in the simplest case of memory allocation, via `operator
    new`. First, we need a class that can be initialized from a pointer to the newly
    allocated object, and whose destructor will delete that object:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在内存分配的最简单情况下，通过 `operator new` 是如何工作的。首先，我们需要一个可以从新分配的对象的指针初始化的类，并且其析构函数将删除该对象：
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now it is very easy to make sure that deletion is never omitted, and we can
    verify that it works as expected with a test that uses `object_counter`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在确保删除永远不会被遗漏变得非常容易，我们可以通过使用 `object_counter` 的测试来验证它是否按预期工作：
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Note that in C++17, the class template type is deduced from the constructor
    and we can simply write the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 C++17 中，类模板类型是从构造函数推导出来的，我们可以简单地写出以下内容：
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The RAII resource release happens when the owning object is destroyed for any
    reason; thus, the cleanup after an exception is thrown and automatically taken
    care of:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当拥有对象因任何原因被销毁时，RAII 资源释放就会发生；因此，在抛出异常后的清理工作会自动完成：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Of course, we probably want to use the new object for more than just creating
    and deleting it, so it would be nice to have access to the pointer stored inside
    the RAII object. There is no reason to grant such access in any way other than
    the standard pointer syntax, which makes our RAII object a kind of pointer itself:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可能希望使用新对象做更多的事情，而不仅仅是创建和删除它，因此能够访问 RAII 对象内部存储的指针会很好。没有理由以外的方式授予这种访问权限，除了标准的指针语法，这使得我们的
    RAII 对象本身就像一个指针：
- en: '[PRE26]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This pointer can be used to automatically delete, at the end of the scope,
    the object that it points to (hence the name):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个指针可以在作用域结束时自动删除它所指向的对象（因此得名）：
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The destructor is called when the scope containing the `scoped_ptr` object
    is exited. It does not matter how it is exited—an early `return` from a function,
    a `break` or `continue` statement in the loop, or an exception being thrown are
    all handled in exactly the same way, and without leaks. We can verify this with
    tests, of course:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 析构函数会在包含 `scoped_ptr` 对象的作用域退出时被调用。无论以何种方式退出——函数中的早期 `return`，循环中的 `break` 或
    `continue` 语句，或者抛出异常——都会以完全相同的方式处理，并且不会发生泄漏。当然，我们可以通过测试来验证这一点：
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'All tests pass, confirming that there is no leak:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 所有测试都通过，确认没有泄漏：
- en: '[PRE29]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Similarly, we can use a scoped pointer as a data member in another class—a
    class that has secondary storage and must release it upon destruction:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以在另一个类中将作用域指针用作数据成员——一个具有二级存储并在销毁时必须释放它的类：
- en: '[PRE30]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This way, we don’t have to delete the object manually in the destructor of class
    `A`, and, in fact, if every data member of class `A` takes care of itself in a
    similar fashion, class `A` may not even need an explicit destructor.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就不需要在类 `A` 的析构函数中手动删除对象，实际上，如果类 `A` 的每个数据成员都以类似的方式自行处理，类 `A` 甚至可能不需要显式的析构函数。
- en: 'Anyone familiar with C++11 should recognize our `scoped_ptr` as a very rudimentary
    version of `std::unique_ptr`, which can be used for the same purpose. As you might
    expect, the standard unique pointer’s implementation has a lot more to it, and
    for good reasons. We will review some of these reasons later in this chapter,
    but, to be clear: you should use `std::unique_ptr` in your code and the only reason
    we implemented our own `scoped_ptr` here is to understand how an RAII pointer
    works.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 任何熟悉C++11的人都会认出我们的 `scoped_ptr` 是 `std::unique_ptr` 的一个非常基础的版本，它可以用于相同的目的。正如你所期望的，标准唯一指针的实现要复杂得多，而且有很好的理由。我们将在本章后面回顾一些这些理由，但为了清楚起见：你应该在你的代码中使用
    `std::unique_ptr`，我们在这里实现自己的 `scoped_ptr` 的唯一原因是为了理解RAII指针的工作原理。
- en: 'One last issue to consider is that of performance. C++ strives for zero-overhead
    abstractions whenever possible. In this case, we are wrapping a raw pointer into
    a smart pointer object. However, the compiler does not need to generate any additional
    machine instructions; the wrapper only forces the compiler to generate the code
    that, in a correct program, it would have done anyway. We can confirm with a simple
    benchmark that both the construction/deletion and the dereference of our `scoped_ptr`
    (or `std::unique_ptr`, for that matter) take exactly the same time as the corresponding
    operations on a raw pointer. For example, the following microbenchmark (using
    the Google benchmark library) compares the performance of all three pointer types
    for dereferencing:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要考虑的一个问题是性能。C++在可能的情况下总是追求零开销抽象。在这种情况下，我们将原始指针包装到智能指针对象中。然而，编译器不需要生成任何额外的机器指令；包装器只是迫使编译器生成代码，在正确的程序中，它本来就会这样做。我们可以通过简单的基准测试来确认我们的
    `scoped_ptr`（或者说是 `std::unique_ptr`，无论如何）的构造/删除和解除引用操作与原始指针上的相应操作所需时间完全相同。例如，以下微基准测试（使用Google基准库）比较了三种指针类型解除引用的性能：
- en: '[PRE31]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The benchmark shows that the smart pointers indeed incur no overhead:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试显示智能指针确实没有开销：
- en: '[PRE32]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We have covered in enough detail the applications of RAII for managing memory.
    But there are other resources that a C++ program needs to manage and keep track
    of, so we have to expand our view of RAII now.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经详细介绍了RAII在管理内存中的应用。但还有其他资源需要C++程序进行管理和跟踪，因此我们现在必须扩展我们对RAII的看法。
- en: RAII for other resources
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对于其他资源的RAII
- en: The name, RAII, refers to *resources* and not *memory*, and indeed the same
    approach is applicable to other resources. For each resource type, we need a special
    object, although generic programming and lambda expressions may help us to write
    less code (we will learn more about this in [*Chapter 11*](B19262_11.xhtml#_idTextAnchor509),
    *ScopeGuard*). The resource is acquired in the constructor and released in the
    destructor. Note that there are two slightly different flavors of RAII. The first
    option is the one we have already seen—the actual acquisition of the resource
    is at initialization, but outside of the constructor of the RAII object.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 名称RAII指的是*资源*而不是*内存*，并且确实相同的策略适用于其他资源。对于每种资源类型，我们需要一个特殊对象，尽管泛型编程和lambda表达式可以帮助我们编写更少的代码（我们将在[*第11章*](B19262_11.xhtml#_idTextAnchor509)，*作用域保护者*)中了解更多）。资源在构造函数中获取，在析构函数中释放。请注意，RAII有两种略微不同的风格。第一种是我们已经看到的选择——资源的实际获取是在初始化时，但不在RAII对象的构造函数外部。
- en: 'The constructor merely captures the handle (such as a pointer) that resulted
    from this acquisition. This was the case with the `scoped_ptr` object that we
    just saw—memory allocation and object construction were both done outside of the
    constructor of the `scoped_ptr` object, but still during its initialization. The
    second option is for the constructor of the RAII object to actually acquire the
    resource. Let’s see how this works, with the example of an RAII object that manages
    mutex locks:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数仅捕获由此获取的结果句柄（例如指针）。这正是我们刚才看到的`scoped_ptr`对象的情况——内存分配和对象构造都是在`scoped_ptr`对象的构造函数之外完成的，但仍然在其初始化期间。RAII对象的构造函数的第二个选项是实际获取资源。让我们看看这是如何工作的，以下是一个管理互斥锁的RAII对象的例子：
- en: '[PRE33]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here, the constructor of the `mutex_guard` class itself acquires the resource;
    in this case, exclusive access to the shared data protected by the mutex. The
    destructor releases that resource. Again, this pattern completely removes the
    possibility of *leaking* a lock (that is, exiting a scope without releasing the
    lock), for example, when an exception is thrown:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`mutex_guard`类的构造函数本身获取资源；在这种情况下，是互斥锁保护的共享数据的独占访问。析构函数释放该资源。再次强调，这种模式完全消除了*泄漏*锁的可能性（即在没有释放锁的情况下退出作用域），例如，当抛出异常时：
- en: '[PRE34]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this test, we check whether the mutex is locked or not by calling `std::mutex::try_lock()`—we
    cannot call `lock()` if the mutex is already locked, as it will deadlock. By calling
    `try_lock()`, we can check the state of the mutex without the risk of deadlock
    (but remember to unlock the mutex if `try_lock()` succeeds since we’re using `try_lock()`
    just to test and don’t want to lock the mutex again).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们通过调用`std::mutex::try_lock()`来检查互斥锁是否被锁定——如果互斥锁已经被锁定，我们不能调用`lock()`，因为这会导致死锁。通过调用`try_lock()`，我们可以检查互斥锁的状态，而不会面临死锁的风险（但请记住，如果`try_lock()`成功，则必须解锁互斥锁，因为我们只是使用`try_lock()`来测试，不希望再次锁定互斥锁）。
- en: 'Again, the standard provides an RAII object for mutex locking, `std::lock_guard`.
    It is used in a similar manner but can be applied to any mutex type that has the
    `lock()` and `unlock()` member functions:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，标准提供了一个用于互斥锁定的RAII对象，`std::lock_guard`。它以类似的方式使用，但可以应用于任何具有`lock()`和`unlock()`成员函数的互斥锁类型：
- en: '[PRE35]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In C++17, we have a similar RAII object for locking multiple mutexes – `std::scoped_lock`.
    In addition to the RAII release, it offers a deadlock avoidance algorithm when
    locking several mutexes at once. Of course, there are many more kinds of resources
    that a C++ program may have to manage, so we often end up writing our own RAII
    objects. Sometimes, the standard helps out, such as the addition of `std::jthread`
    in C++20 (a thread is also a resource, and “*releasing*” it usually means joining
    the thread, which is what `std::jthread` does in its destructor). With the wide
    variety of resources that can be managed with RAII techniques, sometimes we have
    needs that go beyond automatically releasing resources at the end of the scope.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++17中，我们有一个用于锁定多个互斥锁的类似RAII对象——`std::scoped_lock`。除了RAII释放之外，它还提供了一种在同时锁定多个互斥锁时的死锁避免算法。当然，C++程序可能需要管理的资源种类还有很多，所以我们经常需要编写自己的RAII对象。有时，标准会提供帮助，例如C++20中添加的`std::jthread`（线程也是一种资源，“*释放*”它通常意味着连接线程，这是`std::jthread`在其析构函数中所做的）。随着可以使用RAII技术管理的资源种类繁多，有时我们的需求超出了在作用域结束时自动释放资源。
- en: Releasing early
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提前发布
- en: 'The scope of a function or a loop body does not always match the desired duration
    of the holding of the resource. If we do not want to acquire the resource at the
    very beginning of the scope, this is easy—the RAII object can be created anywhere,
    not just at the beginning of the scope. Resources are not acquired until the RAII
    object is constructed, as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 函数或循环体的作用域并不总是与持有资源的期望持续时间相匹配。如果我们不想在作用域的非常开始处获取资源，这很简单——RAII对象可以在任何地方创建，而不仅仅是作用域的开始。资源只有在RAII对象被构造时才会获取，如下所示：
- en: '[PRE36]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'However, the release still happens at the end of the function body scope. What
    if we only want to lock a short portion of code inside the function? The simplest
    answer is to create an additional scope:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，释放仍然发生在函数体作用域的末尾。如果我们只想在函数内部锁定一小段代码怎么办？最简单的答案是创建一个额外的作用域：
- en: '[PRE37]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: It may be surprising if you have never seen it before, but in C++, any sequence
    of statements can be enclosed in the curly braces, as `{ ... }`. Doing so creates
    a new scope with its own local variables. Unlike the curly braces that come after
    loops or conditional statements, the only purpose of this scope is to control
    the lifetime of these local variables. A program that uses RAII extensively often
    has many such scopes, enclosing variables with different lifetimes that are shorter
    than the overall function or loop body. This practice also improves readability
    by making it clear that some variables will not be used after a certain point,
    so the reader does not need to scan the rest of the code looking for possible
    references to these variables. Also, the user cannot accidentally add such a reference
    by mistake if the intent is to *expire* a variable and never use it again.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以前从未见过，可能会感到惊讶，但在C++中，任何语句序列都可以包含在大括号`{ ... }`中。这样做会创建一个新的作用域，它有自己的局部变量。与跟在循环或条件语句后面的花括号不同，这个作用域的唯一目的是控制这些局部变量的生命周期。广泛使用RAII的程序通常有许多这样的作用域，它们包围着生命周期比整体函数或循环体更短的不同变量。这种做法也通过明确指出某些变量在某个点之后将不再使用来提高可读性，因此读者不需要扫描代码的其余部分来寻找对这些变量的可能引用。此外，如果意图是*过期*一个变量并且不再使用它，用户也不太可能意外地添加这样的引用。
- en: 'And what if a resource may be released early, but only if certain conditions
    are met? One possibility is, again, to contain the use of the resource in a scope,
    and exit that scope when the resource is no longer needed. It would be convenient
    to be able to use `break` to get out of a scope. A common way to do just that
    is to write a *do* *once* loop:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果资源可能提前释放，但只有满足某些条件时才释放，那会怎样？一种可能的方法是，再次，将资源的使用包含在作用域内，当资源不再需要时退出该作用域。能够使用`break`来退出作用域会非常方便。实现这一点的常见方法是编写一个`do`
    `once`循环：
- en: '[PRE38]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'However, this approach does not always work (we may want to release the resources,
    but not other local variables we defined in the same scope), and the readability
    of the code suffers as the control flow gets more complex. Resist the impulse
    to accomplish this by allocating the RAII object dynamically, with `operator new`!
    This completely defeats the whole point of RAII, since you now must remember to
    invoke `operator delete`. We can enhance our resource-managing objects by adding
    a client-triggered release, in addition to the automatic release by the destructor.
    We just have to make sure that the same resource is not released twice. Consider
    the following example, using `scoped_ptr`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法并不总是有效（我们可能想要释放资源，但不是在同一作用域中定义的其他局部变量），随着控制流的复杂化，代码的可读性也受到影响。抵制通过使用`operator
    new`动态分配RAII对象来完成这一点的冲动！这完全违背了RAII的整个目的，因为你现在必须记得调用`operator delete`。我们可以通过添加客户端触发的释放，除了析构函数自动释放之外，来增强我们的资源管理对象。我们只需确保同一资源不会被释放两次。考虑以下使用`scoped_ptr`的示例：
- en: '[PRE39]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'After calling `reset()`, the object managed by the `scoped_ptr` object is deleted,
    and the pointer data member of the `scoped_ptr` object is reset to null. Note
    that we did not need to add a condition check to the destructor, because calling
    delete on a null pointer is allowed by the standard—it does nothing. The resource
    is released only once, either explicitly by the `reset()` call, or implicitly
    at the end of the scope containing the `scoped_ptr` object. As we already noted,
    you do not need to write your own `scoped_ptr` except to learn how RAII pointers
    work: `std::unique_ptr` can be reset too.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`reset()`之后，由`scoped_ptr`对象管理的对象被删除，`scoped_ptr`对象的指针数据成员被重置为null。请注意，我们不需要在析构函数中添加条件检查，因为按照标准，对null指针调用delete是允许的——它什么也不做。资源只释放一次，要么是显式地通过`reset()`调用，要么是在包含`scoped_ptr`对象的范围结束时隐式地释放。正如我们之前提到的，你不需要自己编写`scoped_ptr`，除非是为了学习RAII指针的工作原理：`std::unique_ptr`也可以重置。
- en: 'For the `mutex_guard` class, we can’t deduce from just the lock whether an
    early release was called or not, and we need an additional data member to keep
    track of that:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`mutex_guard`类，仅从锁定操作中无法推断出是否调用了提前释放，我们需要一个额外的数据成员来跟踪这一点：
- en: '[PRE40]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now we can verify that the mutex is released only once, at the right time,
    with this test:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过这个测试来验证互斥锁只被释放一次，在正确的时间：
- en: '[PRE41]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The standard `std::unique_ptr` pointer supports `reset()`, whereas `std::lock_guard`
    does not, so if you need to release a mutex early, you need to use a different
    standard RAII object, `std::unique_lock`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的`std::unique_ptr`指针支持`reset()`，而`std::lock_guard`不支持，因此如果你需要提前释放互斥锁，你需要使用不同的标准RAII对象，即`std::unique_lock`：
- en: '[PRE42]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: For other resources, you may have to write your own RAII object, which is usually
    a pretty simple class, but finish reading this chapter before you start writing,
    as there are a few *gotchas* to keep in mind.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他资源，你可能需要编写自己的RAII对象，这通常是一个相当简单的类，但在开始编写之前，请先完成本章的阅读，因为有一些需要注意的陷阱。
- en: 'Note that the `reset()` method of `std::unique_ptr` actually does more than
    just delete the object prematurely. It can also be used to **reset** the pointer
    by making it point to a new object while the old one is deleted. It works something
    like this (the actual implementation in the standard is a bit more complex, because
    of the additional functionality the unique pointer has):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`std::unique_ptr`的`reset()`方法实际上做的不仅仅是提前删除对象。它还可以通过在删除旧对象的同时使指针指向新对象来**重置**指针。它的工作方式大致如下（标准中的实际实现要复杂一些，因为唯一指针具有额外的功能）：
- en: '[PRE43]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note that this code breaks if a scoped pointer is reset to itself (for example,
    if `reset()` is called with the same value as that stored in `p_`). We could check
    for this condition and do nothing; it is worth noting that the standard does not
    require such a check for `std::unique_ptr`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果作用域指针被重置为其自身（例如，如果`reset()`被调用时使用与存储在`p_`中的相同值），则此代码会出错。我们可以检查这种条件并什么都不做；值得注意的是，标准并不要求对`std::unique_ptr`进行此类检查。
- en: Careful implementation of Resource Acquisition is Initialization objects
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源获取即初始化对象的谨慎实现
- en: It is obviously very important that the resource management objects do not mismanage
    the resources they are entrusted to guard. Unfortunately, the simple RAII objects
    we have been writing so far have several glaring holes.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，资源管理对象不误管理它们所托管的资源非常重要。不幸的是，我们迄今为止编写的简单RAII对象有几个明显的漏洞。
- en: 'The first problem arises when someone tries to copy these objects. Each of
    the RAII objects we have considered in this chapter is responsible for managing
    a unique instance of its resource, and yet, nothing prevents us from copying this
    object:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题出现在有人试图复制这些对象时。在本章中我们考虑的每个RAII对象都负责管理其资源的唯一实例，然而，没有任何东西阻止我们复制这个对象：
- en: '[PRE44]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This code invokes the default copy constructor, which simply copies the bits
    inside the object; in our case, the pointer is copied to the `object_counter`.
    Now we have two RAII objects that both control the same resource. Two destructors
    will be called, eventually, and both will attempt to delete the same object. The
    second deletion is undefined behavior (if we are very fortunate, the program will
    crash at that point).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码调用了默认的复制构造函数，它只是简单地复制对象内部的位；在我们的例子中，指针被复制到`object_counter`。现在我们有两个RAII对象，它们都控制着相同的资源。最终将调用两个析构函数，并且它们都将尝试删除相同的对象。第二次删除是未定义的行为（如果我们非常幸运，程序将在那个点崩溃）。
- en: 'Assignment of RAII objects is similarly problematic:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: RAII对象的赋值同样存在问题：
- en: '[PRE45]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The default assignment operator also copies the bits of the object. Again, we
    have two RAII objects that will delete the same managed object. Equally troublesome
    are the facts that we have no RAII objects that manage the second `object_counter`,
    the old pointer inside `p1` is gone, and there is no other reference to this object,
    so we have no way to delete it.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 默认赋值运算符也会复制对象的位。同样麻烦的是，我们没有RAII对象来管理第二个`object_counter`，`p1`内部的旧指针已经消失，而且没有其他引用指向此对象，所以我们没有删除它的方法。
- en: The `mutex_guard` does no better—an attempt to copy it results in two mutex
    guards that will unlock the same mutex. The second unlock will be done on a mutex
    that is not locked (at least not by the calling thread), which, according to the
    standard, is undefined behavior. Assignment of the `mutex_guard` object is not
    possible, though, because the default assignment operator is not generated for
    objects with reference data members.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`mutex_guard`的表现也好不到哪里去——尝试复制它会导致两个将解锁相同互斥锁的互斥锁。第二次解锁将是在一个未锁定（至少不是由调用线程锁定）的互斥锁上进行的，根据标准，这是未定义的行为。`mutex_guard`对象的赋值是不可能的，因为默认情况下不会为具有引用数据成员的对象生成赋值运算符。'
- en: 'As you may have probably noticed, the problem is created by the **default**
    copy constructor and default assignment operator. Does it mean that we should
    have implemented our own? What would they do? Only one destructor should be called
    for each object that was constructed; a mutex can only be unlocked once after
    it was locked. This suggests that an RAII object should not be copied at all,
    and we should disallow both copying and assignment:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到了，问题是由 **默认** 复制构造函数和默认赋值运算符引起的。这意味着我们应该实现自己的吗？它们会做什么？每个构造的对象应该只调用一个析构函数；互斥量在被锁定后只能解锁一次。这表明
    RAII 对象根本不应该被复制，我们应该禁止复制和赋值：
- en: '[PRE46]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: There are some RAII objects that can be copied. These are reference-counted
    resource management objects; they keep track of how many copies of the RAII object
    exist for the same instance of the managed resource. The last of the RAII objects
    has to release the resource when it is deleted. We discuss shared management of
    resources in more detail in [*Chapter 3*](B19262_03.xhtml#_idTextAnchor110), *Memory*
    *and Ownership*.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 有些 RAII 对象是可以复制的。这些是引用计数的资源管理对象；它们跟踪同一托管资源实例的 RAII 对象的副本数量。最后一个 RAII 对象在删除时必须释放资源。我们将在
    [*第 3 章*](B19262_03.xhtml#_idTextAnchor110) 中更详细地讨论资源的共享管理，*内存* *和所有权*。
- en: A different set of considerations exist for move constructor and assignment.
    Moving the object does not violate the assumption that there is only one RAII
    object that owns a particular resource. It merely changes which RAII object that
    is. In many cases, such as mutex guards, it does not make sense to move an RAII
    object (indeed, the standard does not make `std::lock_guard` or `std::scoped_lock`
    movable, but `std::unique_lock` is movable and can be used to transfer ownership
    of a mutex). Moving a unique pointer is possible and makes sense in some contexts,
    which we also explore in [*Chapter 3*](B19262_03.xhtml#_idTextAnchor110), *Memory*
    *and Ownership*.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 对于移动构造函数和赋值运算符，存在不同的考虑因素。移动对象并不违反只有一个 RAII 对象拥有特定资源的假设。它只是改变了哪个 RAII 对象。在许多情况下，例如互斥量保护，移动
    RAII 对象是没有意义的（实际上，标准不使 `std::lock_guard` 或 `std::scoped_lock` 可移动，但 `std::unique_lock`
    是可移动的，可以用来转移互斥量的所有权）。在某些情况下，移动唯一指针是可能的，并且是有意义的，我们也会在第 3 章，*内存* *和所有权* 中探讨这一点。
- en: 'However, for a scoped pointer, moving would be undesirable, as it allows the
    extension of the lifetime of the managed object beyond the scope where it was
    created. Note that we do not need to delete the move constructor or move assignment
    operators if we already deleted the copying ones (although doing so does no harm).
    On the other hand, `std::unique_ptr` is a movable object, which means using it
    as a scope-guarding smart pointer does not offer the same protection because the
    resource could be moved out. However, if you need a scoped pointer, there is a
    very simple way to make `std::unique_ptr` do this job perfectly—all you have to
    do is to declare a `const` `std::unique_ptr` object:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于作用域指针，移动是不希望的，因为它允许托管对象的生命周期扩展到创建它的作用域之外。请注意，如果我们已经删除了复制构造函数或复制赋值运算符，我们不需要删除移动构造函数或移动赋值运算符（尽管这样做没有坏处）。另一方面，`std::unique_ptr`
    是一个可移动对象，这意味着将其用作作用域保护智能指针不会提供相同的保护，因为资源可能会被移动出去。然而，如果您需要一个作用域指针，有一个非常简单的方法可以使
    `std::unique_ptr` 完美地完成这项工作——您只需声明一个 `const` `std::unique_ptr` 对象：
- en: '[PRE47]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'So far, we have protected our RAII objects against duplicating or losing resources.
    But there is one more kind of resource management mistake that we have not yet
    considered. It seems obvious that a resource should be released in a way that
    matches its acquisition. And yet, nothing protects our `scoped_ptr` object from
    such a mismatch between construction and deletion:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经保护了我们的 RAII 对象免受资源复制或丢失。但我们还没有考虑的一种资源管理错误。显然，资源应该以与获取时匹配的方式释放。然而，没有任何东西可以保护我们的
    `scoped_ptr` 对象免受构造和删除之间的这种不匹配：
- en: '[PRE48]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The problem here is that we have allocated multiple objects using an array version
    of `operator new`; it should be deleted with the array version of `operator delete`
    - `delete [] p_` must be called inside the `scoped_ptr` destructor, instead of
    `delete p_` that we have there now.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是，我们使用 `operator new` 的数组版本分配了多个对象；它应该使用 `operator delete` 的数组版本来删除 - `delete
    [] p_` 必须在 `scoped_ptr` 析构函数内部调用，而不是我们现在使用的 `delete p_`。
- en: More generally, an RAII object that accepts a resource handle during initialization,
    instead of acquiring the resource itself (like the `mutex_guard` does) must somehow
    ensure that the resource is released in the right way that matches the way it
    was acquired. Obviously, this is not possible, in general. In fact, it is impossible
    to do automatically, even for the simple case of a mismatched `new` array and
    the `delete` scalar (`std::unique_ptr` does no better than our `scoped_ptr` here,
    although facilities such as `std::make_unique` make writing such code less error-prone).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 更普遍地，一个在初始化期间接受资源句柄而不是直接获取资源的RAII对象（例如`mutex_guard`所做的那样）必须以某种方式确保资源以与获取方式相匹配的正确方式释放。显然，这在一般情况下是不可能的。事实上，即使是对于简单的`new`数组与`delete`标量的不匹配情况，自动执行也是不可能的（尽管像`std::make_unique`这样的工具使得编写此类代码的错误更少）。
- en: 'In general, either the RAII class is designed to release resources in one particular
    way, or the caller must specify how the resource must be released. The former
    is certainly easier, and in many cases is quite sufficient. In particular, if
    the RAII class also acquires a resource, such as our `mutex_guard`, it certainly
    knows how to release it. Even for the `scoped_ptr`, it would not be too hard to
    create two versions, `scoped_ptr` and `scoped_array`; the second one is for objects
    allocated by the `operator new` array. The standard handles it by specializing
    the unique pointer for arrays: you can write `std::unique_ptr<int[]>` and the
    array `delete` will be used (it is still up to the programmer to make sure that
    arrays allocated by `new[]` are owned by the correct instantiation of the pointer).'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，RAII类要么被设计为以特定方式释放资源，要么调用者必须指定资源释放的方式。前者当然更容易，在许多情况下也相当足够。特别是，如果RAII类也获取资源，例如我们的`mutex_guard`，它当然知道如何释放它。即使是对于`scoped_ptr`，创建两个版本也不会太难，即`scoped_ptr`和`scoped_array`；后者是为由`operator
    new`数组分配的对象设计的。标准通过为数组特化唯一指针来处理它：你可以写`std::unique_ptr<int[]>`，数组`delete`将被使用（程序员仍然需要确保由`new[]`分配的数组由指针的正确实例拥有）。
- en: 'A more general version of an RAII class is parameterized not just by the resource
    type, but also by a callable object used to release this type, usually known as
    the deleter. The deleter can be a function pointer, a member function pointer,
    or an object with `operator()` defined—basically, anything that can be called
    like a function. Note that the deleter has to be passed to the RAII object in
    its constructor, and stored inside the RAII object, which makes the object larger.
    Also, the type of the deleter is a template parameter of the RAII class, unless
    it is erased from the RAII type (this will be covered in [*Chapter 6*](B19262_06.xhtml#_idTextAnchor266),
    *Understanding Type Erasure*). The standard gives us examples of both: `std::unique_ptr`
    has the deleter template parameter, while `std::shared_ptr` uses type erasure.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: RAII类的更通用版本不仅由资源类型参数化，还由用于释放此类型的可调用对象参数化，通常称为删除器。删除器可以是一个函数指针、成员函数指针或定义了`operator()`的对象——基本上，任何可以像函数一样调用的东西。请注意，删除器必须在构造函数中传递给RAII对象，并存储在RAII对象内部，这使得对象更大。此外，删除器的类型是RAII类的模板参数，除非它从RAII类型中被擦除（这将在[*第6章*](B19262_06.xhtml#_idTextAnchor266)，*理解类型擦除*）中讨论）。标准为我们提供了两个示例：`std::unique_ptr`有删除器模板参数，而`std::shared_ptr`使用类型擦除。
- en: Downsides of RAII
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RAII的缺点
- en: Honestly, there aren’t any significant downsides to RAII. It is by far the most
    widely used idiom for resource management in C++. The only issue of significance
    to be aware of has to do with exceptions. Releasing a resource can fail, like
    anything else. The usual way in C++ to signal a failure is to throw an exception.
    When that is undesirable, we fall back on returning error codes from functions.
    With RAII, we can do neither of these things.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，RAII没有显著的缺点。它无疑是C++中资源管理最广泛使用的惯用法。唯一需要关注的重要问题是与异常有关。释放资源可能会失败，就像其他任何东西一样。在C++中，表示失败的一种常用方法是抛出异常。当这不可取时，我们退回到从函数返回错误代码。在RAII中，我们无法做到这两者中的任何一项。
- en: 'It is easy to understand why error codes are not an option—the destructor does
    not return anything. Also, we cannot write the error code into some status data
    member of the object, since the object is being destroyed and its data members
    are gone, as are the other local variables from the scope containing the RAII
    object. The only way to save an error code for future examination would be to
    write it into some sort of a global status variable, or at least a variable from
    the containing scope. This is possible in a bind, but such a solution is very
    inelegant and error-prone. This is exactly the problem that C++ was trying to
    solve when exceptions were introduced: manually-propagated error codes are error-prone
    and unreliable.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易理解为什么错误代码不是一种选择——析构函数不返回任何内容。此外，我们也不能将错误代码写入对象的一些状态数据成员，因为对象正在被销毁，其数据成员以及其他包含RAII对象的作用域中的局部变量都消失了。唯一保存错误代码以供将来检查的方法是将它写入某种全局状态变量，或者至少是包含作用域中的变量。这在绑定中是可能的，但这样的解决方案非常不优雅且容易出错。这正是C++在引入异常时试图解决的问题：手动传播的错误代码是容易出错且不可靠的。
- en: So, if the exceptions are the answer to error reporting in C++, why not use
    them here? The usual answer is *that the destructors in C++ cannot throw*. This
    captures the gist of it, but the real restriction is a bit more nuanced. First
    of all, prior to C++11, the destructors technically could throw, but the exception
    would propagate and (hopefully) eventually get caught and processed. In C++11,
    all destructors are, by default, `noexcept`, unless explicitly specified as `noexcept(false)`.
    If a `noexcept` function throws, the program immediately terminates.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果异常是C++中错误报告的答案，为什么不用在这里呢？通常的回答是“C++中的析构函数不能抛出异常”。这抓住了问题的关键，但实际的限制要微妙一些。首先，在C++11之前，析构函数在技术上可以抛出异常，但异常会传播，并且（希望）最终会被捕获和处理。在C++11中，所有析构函数默认都是`noexcept`，除非明确指定为`noexcept(false)`。如果一个`noexcept`函数抛出了异常，程序将立即终止。
- en: So indeed, in C++11, destructors cannot throw unless you specifically allow
    them to do so. But what’s wrong with throwing an exception in the destructor?
    If the destructor is executed because the object was deleted, or because the control
    reached the end of the scope for a stack object, then nothing is wrong. The *wrong*
    happens if the control did not reach the end of the scope normally and the destructor
    is executed because an exception was already thrown. In C++, two exceptions cannot
    propagate at the same time. If this happens, the program will immediately terminate
    (note that a destructor can throw and catch an exception, there is no problem
    with that, as long as that exception does not propagate out of the destructor).
    Of course, when writing a program, there is no way to know when some function
    called from something in a particular scope, could throw. If the resource release
    throws and the RAII object allows that exception to propagate out of its destructor,
    the program is going to terminate if that destructor was called during exception
    handling. The only safe way is never to allow exceptions to propagate from a destructor.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在C++11中，析构函数不能抛出异常，除非你明确允许它们这样做。但在析构函数中抛出异常有什么问题呢？如果析构函数被执行是因为对象被删除，或者因为控制流到达了栈对象的作用域末尾，那么就没有问题。如果控制流没有正常到达作用域的末尾，而是因为已经抛出了一个异常而执行了析构函数，那么就会出现问题。在C++中，两个异常不能同时传播。如果发生这种情况，程序将立即终止（注意，析构函数可以抛出和捕获异常，这没有问题，只要该异常不会从析构函数中传播出去）。当然，在编写程序时，没有办法知道在特定作用域中从某个地方调用的某个函数何时会抛出异常。如果资源释放抛出了异常，并且RAII对象允许该异常从其析构函数中传播出去，那么如果在异常处理期间调用了该析构函数，程序将会终止。唯一安全的方法是永远不允许异常从析构函数中传播。
- en: 'This does not mean that the function that releases the resource itself cannot
    throw, but, if it does, an RAII destructor has to catch that exception:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着释放资源的函数本身不能抛出异常，但如果它抛出了异常，RAII析构函数必须捕获该异常：
- en: '[PRE49]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This still leaves us with no way to signal that an error happened during resource
    release—an exception was thrown, and we had to catch it and not let it escape.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然没有给我们提供一种方法来指示在资源释放过程中发生了错误——抛出了一个异常，我们不得不捕获它并防止其逃逸。
- en: 'How much of a problem is this? Not that much, really. First of all, releasing
    memory—the most frequently managed resource—does not throw an exception. Usually,
    the memory is released not as just memory, but by deleting an object. But remember
    that the destructors should not throw an exception in order that the entire process
    of releasing memory by deleting an object doesn’t throw an exception either. At
    this point, the reader might, in search of a counter-example, look up in the standard
    what happens if unlocking a mutex fails (that would force the destructor of `std::lock_guard`
    to deal with the error). The answer is both surprising and enlightening—unlocking
    a mutex cannot throw, but if it fails, undefined behavior results instead. This
    is no accident; the mutex was intended to work with an RAII object. Such is, in
    general, the C++ approach to releasing the resources: an exception should not
    be thrown if the release fails, or at least not allowed to propagate. It can be
    caught and logged, for example, but the calling program will, in general, remain
    unaware of the failure, possibly at the cost of undefined behavior.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题有多严重？实际上并不严重。首先，释放内存——最常管理的资源——不会抛出异常。通常，内存不是简单地释放，而是通过删除对象来释放。但请记住，析构函数不应该抛出异常，这样通过删除对象释放内存的整个过程也不会抛出异常。在这个时候，读者可能会寻找一个反例，查看标准中如果解锁互斥锁失败会发生什么（这将迫使`std::lock_guard`的析构函数处理错误）。答案是既令人惊讶又发人深省——解锁互斥锁不能抛出异常，但如果它失败了，将产生未定义的行为。这不是偶然；互斥锁旨在与RAII对象一起工作。总的来说，这是C++释放资源的方法：如果释放失败，不应该抛出异常，或者至少不允许其传播。它可以被捕获并记录，例如，但调用程序通常不会意识到失败，这可能会以未定义行为为代价。
- en: RAII is a really successful technique that has evolved very little even as the
    language changes significantly from pre-C++11 all the way to C++20 (aside from
    minor syntactic conveniences such as constructor argument deduction). That is
    because it really doesn’t have any downsides of note. But, as the language gets
    new capabilities, sometimes we find ways to improve even the best and most established
    patterns, and here is one of those cases.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管语言从C++11之前的版本到C++20发生了显著变化，RAII仍然是一个非常成功的技巧，其发展变化很小（除了诸如构造函数参数推导等小的语法便利之外）。这是因为它实际上没有任何显著的缺点。但是，随着语言获得新的功能，有时我们发现方法来改进甚至最好的和最成熟的模式，这就是其中之一。
- en: Very modern RAII
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非常现代的RAII
- en: If we really want to be picky, we can make another complaint about RAII; realistically,
    this is only a downside when the acquisition or release code is long and complex.
    The acquisition and release are done in the constructor and the destructor of
    an RAII object, respectively, and this code can be quite removed from the place
    in the code where the resource is acquired (so we have to jump around the program
    a bit to figure out what it does).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们真的想挑剔一点，我们还可以对RAII提出另一个抱怨；在现实中，这只有在获取或释放代码很长且复杂时才是一个缺点。获取和释放分别在RAII对象的构造函数和析构函数中完成，而这段代码可能相当远离资源获取的地方（因此我们不得不在程序中跳来跳去才能弄清楚它做了什么）。
- en: 'Similarly, if the resource handling requires a lot of state (such as the appropriate
    actions depending on several factors and conditions), we have to capture all this
    state in the RAII object. An example that truly challenges the readability of
    RAII would also be completely unreadable on a book page, so we will have to condense
    it. Let us say that we want to have an RAII lock guard that performs several actions
    when locking and unlocking the mutex, and even the way it handles the resource
    depends on some external parameters:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，如果资源管理需要很多状态（例如，根据几个因素和条件采取的适当行动），我们必须在RAII对象中捕获所有这些状态。一个真正挑战RAII可读性的例子，在书页上也会完全不可读，因此我们不得不对其进行压缩。假设我们想要一个RAII锁保护器，它在锁定和解锁互斥锁时执行多个操作，甚至它处理资源的方式也取决于一些外部参数：
- en: '[PRE50]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'And here is how this guard object might be used:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何使用这个保护对象的示例：
- en: '[PRE51]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Here we perform only one possible action in addition to locking and unlocking
    – we can optionally log these events; you can already see that the implementations
    of the constructor and the destructor, the two sections of code that must be closely
    matched, are somewhat separated from each other. Also, tracking the state (do
    we need to log the events? Are we running in a multi-threaded or single-threaded
    context?) is becoming somewhat verbose. Again, you have to remember that this
    is a simplified example: in a real program, this is still a fine RAII object.
    But, if the code gets even longer, you may wish for a better way.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们除了锁定和解锁之外，只执行一个可能的行为——我们可以选择性地记录这些事件；你现在已经可以看到，构造函数和析构函数的实现，这两段必须紧密匹配的代码，已经有些分离。此外，跟踪状态（我们需要记录事件吗？我们是在多线程还是单线程上下文中运行？）变得有些冗长。再次强调，你必须记住这是一个简化的例子：在实际程序中，这仍然是一个很好的
    RAII 对象。但是，如果代码变得更长，你可能希望有更好的方法。
- en: In this case, the better way is borrowed from Python (specifically, from the
    `contextmanager` decorator). This technique used coroutines and, thus, requires
    C++20 (so we managed to couple one of the oldest tools in C++ with the most cutting-edge
    one). The detailed explanation of the coroutines in general and the C++ coroutine
    machinery in particular lies outside of the scope of this book (you can find it,
    for example, in my book “*The Art of Writing Efficient* *Programs*”, ([https://www.packtpub.com/product/the-art-of-writing-efficient-programs/9781800208117](https://www.packtpub.com/product/the-art-of-writing-efficient-programs/9781800208117))).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，更好的方法借鉴自 Python（具体来说，来自 `contextmanager` 装饰器）。这种技术使用了协程，因此需要 C++20（所以我们成功地将
    C++ 中最古老的工具之一与最前沿的工具结合在一起）。关于协程的一般解释以及 C++ 协程机制的特殊解释超出了本书的范围（你可以在我的书中找到，例如，“*高效编程的艺术*”，([https://www.packtpub.com/product/the-art-of-writing-efficient-programs/9781800208117](https://www.packtpub.com/product/the-art-of-writing-efficient-programs/9781800208117))）。
- en: 'For now, it is sufficient to remember two things:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，记住两件事就足够了：
- en: First, C++ coroutines are, essentially, regular functions except they suspend
    themselves at any time and return the control to the caller. The caller can resume
    the coroutine, and it continues to execute from the suspension point as if nothing
    happened.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，C++ 协程本质上与常规函数相同，除了它们可以在任何时候挂起自己并将控制权返回给调用者。调用者可以恢复协程，它将从挂起点继续执行，就像什么都没发生一样。
- en: Second, C++ coroutines require a lot of standard boilerplate code. In the example
    that follows, we will highlight the important fragments; you can safely assume
    that the rest of the code is required by the standard to make the coroutine machinery
    work.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，C++ 协程需要大量的标准样板代码。在接下来的示例中，我们将突出显示重要的片段；你可以安全地假设其余的代码是由标准所要求的，以便协程机制能够工作。
- en: 'Let us first see what the code for a lock guard looks like with this new coroutine-based
    RAII approach:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看使用这种基于协程的 RAII 方法编写的锁卫代码是什么样的：
- en: '[PRE52]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Instead of the `lock_guard` object, we have the `make_guard` function. This
    function is a coroutine; you can tell because it has the `co_yield` operator –
    this is one of several ways C++ coroutines return values to the caller. The code
    before `co_yield` is resource acquisition, it is executed when the resource is
    acquired and is equivalent to the constructor of our `lock_guard` object. The
    code after `co_yield` is the same as the destructor of `lock_guard`. Arguably,
    this is easier to read and maintain (at least after you stop staring at the coroutine
    syntax) because all the code is in the same place you can think of `co_yield`
    as a placeholder for the work the caller is going to do while owning the resource
    (the mutex, in our case). Also, there are no class members and member initialization
    to write – the function parameters are accessible throughout the execution of
    the coroutine.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有使用 `lock_guard` 对象，而是有 `make_guard` 函数。这个函数是一个协程；你可以通过它具有 `co_yield` 操作符来判断——这是
    C++ 协程向调用者返回值的好几种方式之一。`co_yield` 之前的代码是资源获取，它在资源获取时执行，相当于我们 `lock_guard` 对象的构造函数。`co_yield`
    之后的代码与 `lock_guard` 的析构函数相同。可以说，这更容易阅读和维护（至少在你不再盯着协程语法之后），因为所有代码都在同一个地方。你可以把 `co_yield`
    看作是调用者将要执行的工作的占位符（在我们的例子中是互斥锁）。此外，没有要写的类成员和成员初始化——协程执行期间函数参数都是可访问的。
- en: 'The coroutine returns an object of type `co_resource<std::mutex>`: that is
    our modern RAII type is implemented as the `co_resource` class template; it is
    implemented as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 协程返回一个 `co_resource<std::mutex>` 类型的对象：这就是我们的现代 RAII 类型作为 `co_resource` 类模板实现的；它的实现如下：
- en: '[PRE53]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This is the object that owns the resource, but you don’t see the resource or
    its type `T` directly: it is hidden inside the coroutine handle `coro_`. This
    handle acts like a pointer to the state of the coroutine. If you focus on the
    handle as a resource for the moment, we have a fairly routine resource-owning
    object. It acquires the resource in the constructor and maintains the exclusive
    ownership: the handle is destroyed in the destructor of the `co_resource` object
    unless the ownership is transferred via move, and copying the resource is not
    allowed.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这是拥有资源的对象，但你无法直接看到资源或其类型 `T`：它隐藏在协程句柄 `coro_` 里面。这个句柄就像指向协程状态的指针。如果你暂时将句柄视为资源，我们有一个相当常规的资源拥有对象。它在构造函数中获取资源并保持独占所有权：除非通过移动转移所有权，否则不允许复制资源，句柄在
    `co_resource` 对象的析构函数中被销毁。
- en: 'This resource-owning object is going to be returned by a coroutine function;
    every such object must contain a nested type named `promise_type`. Often, it is
    a nested class, but it can also be a separate type (in this example, we made it
    such largely to avoid a single very long code fragment). The standard imposes
    several requirements on the interface of the promise type, and here is the type
    that meets these requirements for our purposes:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这个资源拥有对象将由协程函数返回；每个这样的对象都必须包含一个名为 `promise_type` 的嵌套类型。通常，它是一个嵌套类，但也可以是一个单独的类型（在这个例子中，我们将其设置为这样的类型主要是为了避免一个非常长的代码片段）。标准对承诺类型的接口提出了几个要求，下面是我们为了这个目的满足这些要求的类型：
- en: '[PRE54]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Our promise type contains a pointer to the value returned by the coroutine.
    How does the value get there? When the coroutine returns the result via `co_yield`,
    the member function `yield_value()` is called (the compiler generates this call).
    The value returned by `co_yield` is passed to this function, which, in turn, captures
    its address (the lifetime of the value is the same as that of the coroutine itself).
    The other important member function of the promise type is `get_return_object()`:
    it is invoked by the compiler to return the `co_resource` object itself to the
    caller of the `make_guard()` coroutine. Note that it does not return a `co_resource`
    object, but a handle that is implicitly convertible to `co_resource` (it has an
    implicit constructor from `handle_type`). The rest of the `promise_type` interface
    is, for our purposes, the boilerplate code required by the standard.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的承诺类型包含一个指向协程返回值的指针。这个值是如何到达那里的？当协程通过 `co_yield` 返回结果时，会调用成员函数 `yield_value()`（编译器会生成这个调用）。`co_yield`
    返回的值被传递给这个函数，该函数反过来捕获其地址（值的生命周期与协程本身相同）。承诺类型的另一个重要成员函数是 `get_return_object()`：它由编译器调用，以将
    `co_resource` 对象本身返回给 `make_guard()` 协程的调用者。请注意，它并不返回一个 `co_resource` 对象，而是一个可以隐式转换为
    `co_resource` 的句柄（它有一个从 `handle_type` 的隐式构造函数）。对于我们的目的，`promise_type` 接口的其他部分是标准所要求的样板代码。
- en: 'Here is how the `co_resource` RAII works: first, we call the function `make_guard()`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何 `co_resource` RAII 工作的：首先，我们调用函数 `make_guard()`：
- en: '[PRE55]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'From the caller’s point of view, it starts executing like any other function,
    although the internal details are quite different. All the code we wrote before
    `co_yield` is executed, then the coroutine is suspended and the `co_resource<std::mutex>`
    object is constructed and returned to the caller, where it is moved into a stack
    variable:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 从调用者的角度来看，它就像任何其他函数一样开始执行，尽管内部细节相当不同。在执行 `co_yield` 之前的所有代码都会被执行，然后协程被挂起，并且
    `co_resource<std::mutex>` 对象被构造并返回给调用者，然后它被移动到一个栈变量中：
- en: '[PRE56]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The execution proceeds as usual, protected by the locked mutex. At the end of
    the scope, the object `lg` is destroyed; this happens no matter whether we exit
    the scope normally or by throwing an exception. In the destructor of the `co_resource`
    object, the coroutine is resumed via the call to the member function `resume()`
    of the coroutine handle `coro_`. This causes the coroutine to resume execution
    right after the point where stopped before, so the control jumps to the next line
    after `co_yield`. The resource release code we wrote there is executed, and the
    coroutine exits through the bottom of the scope, now for the last time. The destructor
    of `co_resource` has some cleanup to do, but, otherwise, we are (mostly) done.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 执行过程如常，由锁定的互斥锁保护。在作用域结束时，对象 `lg` 被销毁；这无论我们是正常退出作用域还是通过抛出异常退出都会发生。在 `co_resource`
    对象的析构函数中，通过调用协程句柄 `coro_` 的成员函数 `resume()` 来恢复协程。这导致协程在停止之前立即恢复执行，因此控制权跳转到 `co_yield`
    之后的下一行。我们编写在那里释放资源的代码被执行，协程通过作用域的底部退出，现在最后一次。`co_resource` 的析构函数有一些清理工作要做，但除此之外，我们（主要）完成了。
- en: 'There are a few things we have left out to avoid overly extending the example.
    First of all, as written, the `co_resource` template does not work if the resource
    type `T` is a reference. This may be perfectly acceptable: handling references
    by RAII is not that common. In this case, a static assert or a concept check is
    sufficient. Otherwise, we have to carefully handle dependent types inside the
    template. Second, the implicit requirement on the coroutine such as `make_guard()`
    is that it returns a value via `co_yield` exactly once (you can have more than
    one `co_yield` in the body of the coroutine, but only one can be executed for
    a particular call). To make the code robust, we have to verify that this requirement
    has been met using run-time asserts.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在避免过度扩展示例的过程中省略了一些内容。首先，按照目前的写法，如果资源类型 `T` 是引用，则 `co_resource` 模板将无法正常工作。这可能完全是可以接受的：通过
    RAII 处理引用并不常见。在这种情况下，使用静态断言或概念检查就足够了。否则，我们必须在模板内部仔细处理依赖类型。其次，对协程的隐式要求，例如 `make_guard()`，是它必须通过
    `co_yield` 返回一个值恰好一次（协程体中可以有多个 `co_yield`，但针对特定调用只能执行一个）。为了使代码健壮，我们必须使用运行时断言来验证这一要求是否得到满足。
- en: 'We now have the acquisition and release code right next to each other and we
    don’t need to convert function arguments into data members like we did when constructors
    and destructors handled RAII. The only thing that might make it even better would
    be if we didn’t have to write a separate `make_guard()` function, at least in
    cases where we have only one call to it. Turns out that we can combine coroutines
    and lambdas to just such a result:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，获取和释放代码紧挨在一起，我们不需要像构造函数和析构函数处理 RAII 那样将函数参数转换为数据成员。唯一可能使它变得更好的事情是，我们不需要为它编写单独的
    `make_guard()` 函数，至少在我们只有一个调用的情况下是这样。结果证明，我们可以将协程和 lambda 结合起来达到这样的效果：
- en: '[PRE57]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Here the coroutine is the `operator()` of a lambda expression; note that we
    have to specify the return type explicitly. The lambda is invoked immediately;
    and; as usual in such cases, the use of captures or parameters boils down to what
    is more convenient in each case.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，协程是 lambda 表达式的 `operator()`；请注意，我们必须显式指定返回类型。lambda 立即被调用；并且，像往常一样，在这种情况下，使用捕获或参数归结为每种情况下更方便的做法。
- en: 'With the coroutine-based RAII resource management, we were able to keep all
    the relevant code portions very close to each other. Of course, there is a price:
    launching, suspending, and resuming coroutines takes time (and a bit of memory).
    The basic RAII object is always going to be faster, so don’t try to replace `std::unique_pointer`
    with a `co_resource` class. But keep in mind that our original dissatisfaction
    with RAII started with the observation that when the code executed for the acquisition
    or release of resources is long, complex, and uses a lot of state variables, an
    RAII class might be hard to read. It is likely that in such cases the overhead
    of the coroutines is less important (we should also point out that the “scope
    guard” pattern described later in [*Chapter 11*](B19262_11.xhtml#_idTextAnchor509),
    *ScopeGuard*, addresses some of the same concerns and sometimes is a better option).'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 基于协程的RAII资源管理使我们能够将所有相关的代码部分保持得很近。当然，这是有代价的：启动、挂起和恢复协程需要时间（以及一点内存）。基本的RAII对象总是更快，所以不要尝试用`co_resource`类替换`std::unique_pointer`。但请记住，我们最初对RAII的不满始于观察到，当执行资源获取或释放的代码很长、很复杂且使用大量状态变量时，RAII类可能难以阅读。在这种情况下，协程的开销可能不太重要（我们也应该指出，稍后将在[*第11章*](B19262_11.xhtml#_idTextAnchor509)，*作用域保护者*模式中描述的“作用域保护者”模式解决了相同的一些问题，有时是一个更好的选择）。
- en: The RAII techniques we have learned are some of the most enduring C++ patterns;
    they were in use from the first day of C++ and continue to evolve and benefit
    from the latest language features. Throughout this book, we will casually and
    without a second thought use classes such as `std::unique_ptr` or `std::lock_guard`.
    For now, we leave you with these final thoughts.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学到的RAII技术是一些最持久的C++模式；它们从C++的第一天开始使用，并继续从最新的语言特性中受益。在这本书中，我们将随意使用类，例如`std::unique_ptr`或`std::lock_guard`，而无需再思考。现在，我们留下这些最后的思考。
- en: Summary
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: After this chapter, you should be well aware of the dangers of an ad-hoc approach
    to resource management. Fortunately, we have learned the most widely used idiom
    for resource management in C++; the RAII idiom. With this idiom, each resource
    is owned by an object. Constructing (or initializing) the object acquires the
    resource, and deleting the object releases it. We saw how using RAII addresses
    the problems of resource management, such as leaking resources, accidentally sharing
    resources, and releasing resources incorrectly. We have also learned the basics
    of writing exception-safe code, at least as far as the leaking or otherwise mishandling
    of resources is concerned. Writing RAII objects is simple enough, but there are
    several caveats to keep in mind. Finally, we reviewed the complications that arise
    when error handling has to be combined with RAII.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章之后，你应该对资源管理临时方法的风险有清醒的认识。幸运的是，我们已经学习了C++中最广泛使用的资源管理惯用语——RAII惯用语。使用这种惯用语，每个资源都由一个对象拥有。对象的构造（或初始化）会获取资源，而对象的删除会释放资源。我们看到了使用RAII如何解决资源管理的问题，例如资源泄漏、意外共享资源和不正确释放资源。我们还学习了编写异常安全代码的基础，至少就资源泄漏或其他不当处理而言。编写RAII对象足够简单，但有几个注意事项需要记住。最后，我们回顾了当错误处理必须与RAII结合时出现的复杂性。
- en: 'RAII is a resource management idiom, but it can also be viewed as an abstraction
    technique: the complex resources are hidden behind simple resource handles. The
    next chapter introduces another kind of abstraction idiom, type erasure: instead
    of complex objects, we will now hide complex types.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: RAII是一种资源管理惯用语，但它也可以被视为一种抽象技术：复杂的资源被隐藏在简单的资源句柄之后。下一章将介绍另一种抽象惯用语，类型擦除：我们将不再隐藏复杂对象，而是隐藏复杂类型。
- en: Questions
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the resources that a program can manage?
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序可以管理哪些资源？
- en: What are the main considerations when managing resources in a C++ program?
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在C++程序中管理资源时，主要考虑因素是什么？
- en: What is RAII?
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是RAII？
- en: How does RAII address the problem of leaking resources?
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RAII是如何解决资源泄漏问题的？
- en: How does RAII address the problem of dangling resource handles?
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RAII是如何解决悬挂资源句柄问题的？
- en: What RAII objects are provided by the C++ standard library?
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C++标准库提供了哪些RAII对象？
- en: What precautions must be taken when writing RAII objects?
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编写RAII对象时必须采取哪些预防措施？
- en: What happens if releasing a resource fails?
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果释放资源失败会发生什么？
- en: Further reading
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '[https://www.packtpub.com/application-development/expert-c-programming](https://www.packtpub.com/application-development/expert-c-programming)'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/application-development/expert-c-programming](https://www.packtpub.com/application-development/expert-c-programming)'
- en: '[https://www.packtpub.com/application-development/c-data-structures-and-algorithms](https://www.packtpub.com/application-development/c-data-structures-and-algorithms)'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/application-development/c-data-structures-and-algorithms](https://www.packtpub.com/application-development/c-data-structures-and-algorithms)'
- en: '[https://www.packtpub.com/application-development/rapid-c-video](https://www.packtpub.com/application-development/rapid-c-video)'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.packtpub.com/application-development/rapid-c-video](https://www.packtpub.com/application-development/rapid-c-video)'
