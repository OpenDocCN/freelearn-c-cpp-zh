<html><head></head><body>
<div id="_idContainer012">
<h1 class="chapter-number" id="_idParaDest-114"><a id="_idTextAnchor113"/><span class="koboSpan" id="kobo.1.1">7</span></h1>
<h1 id="_idParaDest-115"><a id="_idTextAnchor114"/><span class="koboSpan" id="kobo.2.1">Classes, Objects, and OOP in C++</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In this chapter, we delve into the sophisticated realm of classes, objects, and </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">object-oriented programming</span></strong><span class="koboSpan" id="kobo.5.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.6.1">OOP</span></strong><span class="koboSpan" id="kobo.7.1">) in C++. </span><span class="koboSpan" id="kobo.7.2">Tailored </span><a id="_idIndexMarker265"/><span class="koboSpan" id="kobo.8.1">for the advanced C++ practitioner, our focus will be on elevating your understanding of class design, method implementation, inheritance, and template usage, steering clear of introductory explanations of these concepts. </span><span class="koboSpan" id="kobo.8.2">Our goal is to enhance your ability to construct robust and efficient software architectures using advanced </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">object-oriented techniques.</span></span></p>
<p><span class="koboSpan" id="kobo.10.1">The discussion begins by examining the intricate considerations necessary when defining classes, guiding you through the decision-making process to determine the best candidates for class encapsulation. </span><span class="koboSpan" id="kobo.10.2">This includes distinguishing situations where a simpler data structure, such as a struct, might be more appropriate, thereby optimizing both performance </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">and readability.</span></span></p>
<p><span class="koboSpan" id="kobo.12.1">Further, we explore the design of methods within classes—highlighting various types of methods, such as accessors, mutators, and factory methods, and establishing conventions that promote code clarity and maintainability. </span><span class="koboSpan" id="kobo.12.2">Special attention is given to advanced method design practices, including const correctness and visibility scopes, which are pivotal for securing and optimizing access to </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">class data.</span></span></p>
<p><span class="koboSpan" id="kobo.14.1">Inheritance, a cornerstone of OOP, is scrutinized not only for its benefits but also its liabilities. </span><span class="koboSpan" id="kobo.14.2">To provide a balanced perspective, we present alternatives such as composition and interface segregation that might better serve your design goals in certain scenarios. </span><span class="koboSpan" id="kobo.14.3">This nuanced discussion aims to equip you with the discernment necessary to choose the best inheritance strategy or its alternatives, depending on the specific requirements and constraints of </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">your projects.</span></span></p>
<p><span class="koboSpan" id="kobo.16.1">Expanding the discussion to generic programming, we delve into sophisticated template usage, which includes advanced techniques such as template metaprogramming. </span><span class="koboSpan" id="kobo.16.2">This section aims to demonstrate how templates can be leveraged to create highly reusable and efficient code. </span><span class="koboSpan" id="kobo.16.3">Additionally, we will touch upon the design of APIs using OOP principles, emphasizing how well-crafted interfaces can significantly enhance the usability and longevity of </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">software components.</span></span></p>
<p><span class="koboSpan" id="kobo.18.1">Each topic is punctuated with practical examples and case studies drawn from real-world applications, illustrating how these advanced techniques are applied in modern software development. </span><span class="koboSpan" id="kobo.18.2">By the end of this chapter, you should possess a deeper understanding of how to utilize OOP features in C++ to craft elegant, efficient, and scalable </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">software architectures.</span></span></p>
<h1 id="_idParaDest-116"><a id="_idTextAnchor115"/><span class="koboSpan" id="kobo.20.1">Good candidates for classes</span></h1>
<p><span class="koboSpan" id="kobo.21.1">Identifying </span><a id="_idIndexMarker266"/><span class="koboSpan" id="kobo.22.1">good </span><a id="_idIndexMarker267"/><span class="koboSpan" id="kobo.23.1">candidates for classes in OOP involves looking for entities that naturally encapsulate both data </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">and behavior.</span></span></p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor116"/><span class="koboSpan" id="kobo.25.1">Cohesion</span></h2>
<p><span class="koboSpan" id="kobo.26.1">A class </span><a id="_idIndexMarker268"/><span class="koboSpan" id="kobo.27.1">should represent a set of functionalities that are tightly related to each other. </span><span class="koboSpan" id="kobo.27.2">This means all the methods and data in the class are directly related to the specific functionalities it provides. </span><span class="koboSpan" id="kobo.27.3">For example, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.28.1">Timer</span></strong><span class="koboSpan" id="kobo.29.1"> class is a good candidate because it encapsulates properties and methods related to timing (start, stop, reset times), maintaining </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">high cohesion.</span></span></p>
<h2 id="_idParaDest-118"><a id="_idTextAnchor117"/><span class="koboSpan" id="kobo.31.1">Encapsulation</span></h2>
<p><span class="koboSpan" id="kobo.32.1">Entities</span><a id="_idIndexMarker269"/><span class="koboSpan" id="kobo.33.1"> that have attributes and behaviors that should be shielded from outside interference or misuse can be encapsulated in </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">a class.</span></span></p>
<p><span class="koboSpan" id="kobo.35.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.36.1">BankAccount</span></strong><span class="koboSpan" id="kobo.37.1"> class encapsulates the balance (attribute) and behaviors such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.38.1">deposit</span></strong><span class="koboSpan" id="kobo.39.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.40.1">withdraw</span></strong><span class="koboSpan" id="kobo.41.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.42.1">transfer</span></strong><span class="koboSpan" id="kobo.43.1">, ensuring that balance manipulations are done only through controlled and </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">safe operations.</span></span></p>
<h2 id="_idParaDest-119"><a id="_idTextAnchor118"/><span class="koboSpan" id="kobo.45.1">Reusability</span></h2>
<p><span class="koboSpan" id="kobo.46.1">Classes</span><a id="_idIndexMarker270"/><span class="koboSpan" id="kobo.47.1"> should be designed to be reused across different parts of a program or even in </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">different programs.</span></span></p>
<p><span class="koboSpan" id="kobo.49.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.50.1">DatabaseConnection</span></strong><span class="koboSpan" id="kobo.51.1"> class that manages database connections can be reused in multiple applications that require database interactions, handling connection, disconnection, and </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">error management.</span></span></p>
<h2 id="_idParaDest-120"><a id="_idTextAnchor119"/><span class="koboSpan" id="kobo.53.1">Abstraction</span></h2>
<p><span class="koboSpan" id="kobo.54.1">A class</span><a id="_idIndexMarker271"/><span class="koboSpan" id="kobo.55.1"> should provide a simplified interface by hiding complex logic from the user, representing a higher level of abstraction. </span><span class="koboSpan" id="kobo.55.2">For example, the standard library has classes such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.56.1">std::vector</span></strong><span class="koboSpan" id="kobo.57.1"> that abstract the complexities of dynamic arrays, providing a simple interface for </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">array operations.</span></span></p>
<h2 id="_idParaDest-121"><a id="_idTextAnchor120"/><span class="koboSpan" id="kobo.59.1">Real-world entities</span></h2>
<p><span class="koboSpan" id="kobo.60.1">Classes </span><a id="_idIndexMarker272"/><span class="koboSpan" id="kobo.61.1">often represent objects from the real world that are relevant to the system </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">being modeled.</span></span></p>
<p><span class="koboSpan" id="kobo.63.1">In a flight reservation system, classes such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.64.1">Flight</span></strong><span class="koboSpan" id="kobo.65.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.66.1">Passenger</span></strong><span class="koboSpan" id="kobo.67.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.68.1">Ticket</span></strong><span class="koboSpan" id="kobo.69.1"> are good candidates because they directly represent real-world objects with clear attributes </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">and behaviors.</span></span></p>
<h2 id="_idParaDest-122"><a id="_idTextAnchor121"/><span class="koboSpan" id="kobo.71.1">Manage complexity</span></h2>
<p><span class="koboSpan" id="kobo.72.1">Classes </span><a id="_idIndexMarker273"/><span class="koboSpan" id="kobo.73.1">should help in managing complexity by breaking down large problems into smaller, more </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">manageable parts.</span></span></p>
<p><span class="koboSpan" id="kobo.75.1">Here is an example – in graphic editing software, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.76.1">GraphicObject</span></strong><span class="koboSpan" id="kobo.77.1"> class might serve as a base class for more specific graphic objects such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.78.1">Circle</span></strong><span class="koboSpan" id="kobo.79.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.80.1">Rectangle</span></strong><span class="koboSpan" id="kobo.81.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.82.1">Polygon</span></strong><span class="koboSpan" id="kobo.83.1">, organizing graphic properties and </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">functionalities systematically.</span></span></p>
<h2 id="_idParaDest-123"><a id="_idTextAnchor122"/><span class="koboSpan" id="kobo.85.1">Minimizing class responsibilities through encapsulation</span></h2>
<p><span class="koboSpan" id="kobo.86.1">Encapsulation </span><a id="_idIndexMarker274"/><span class="koboSpan" id="kobo.87.1">is a fundamental concept in OOP that involves bundling </span><a id="_idIndexMarker275"/><span class="koboSpan" id="kobo.88.1">the data (attributes) and the methods (functions) that operate on the data into a single unit or class. </span><span class="koboSpan" id="kobo.88.2">It not only hides the internal state of the object from the outside but also modularizes its behavior, making the software easier to manage and extend. </span><span class="koboSpan" id="kobo.88.3">However, how much functionality and data a class should encapsulate can significantly affect the maintainability and scalability of </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">your application.</span></span></p>
<h3><span class="koboSpan" id="kobo.90.1">Over-encapsulation in classes – a common pitfall</span></h3>
<p><span class="koboSpan" id="kobo.91.1">In</span><a id="_idIndexMarker276"/><span class="koboSpan" id="kobo.92.1"> practice, encapsulating too much functionality and data within a single class is a common mistake that can lead to several issues. </span><span class="koboSpan" id="kobo.92.2">This often results in a </span><strong class="bold"><span class="koboSpan" id="kobo.93.1">god object</span></strong><span class="koboSpan" id="kobo.94.1"> – a class that controls too many different parts of the application, doing too much work on its own. </span><span class="koboSpan" id="kobo.94.2">Such classes are typically hard to understand, difficult to maintain, and problematic </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">to test.</span></span></p>
<p><span class="koboSpan" id="kobo.96.1">Let’s look at an example of a badly encapsulated </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">Car</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.98.1"> class.</span></span></p>
<p><span class="koboSpan" id="kobo.99.1">Consider the following example of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">Car</span></strong><span class="koboSpan" id="kobo.101.1"> class that attempts to manage not only the car’s basic properties but also detailed aspects of its internal systems such as the engine, transmission, and </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">entertainment system:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.103.1">
#include &lt;iostream&gt;
#include &lt;string&gt;
class Car {
private:
    std::string _model;
    double _speed;
    double _fuel_level;
    int _gear;
    bool _entertainment_system_on;
public:
    Car(const std::string&amp; model) : _model(model), _speed(0), _fuel_level(50), _gear(1), _entertainment_system_on(false) {}
    void accelerate() {
        if (_fuel_level &gt; 0) {
            _speed += 10;
            _fuel_level -= 5;
            std::cout &lt;&lt; "Accelerating. </span><span class="koboSpan" id="kobo.103.2">Current speed: " &lt;&lt; _speed &lt;&lt; " km/h, Fuel level: " &lt;&lt; _fuel_level &lt;&lt; " liters" &lt;&lt; std::endl;
        } else {
            std::cout &lt;&lt; "Not enough fuel." </span><span class="koboSpan" id="kobo.103.3">&lt;&lt; std::endl;
        }
    }
    void change_gear(int new_gear) {
        _gear = new_gear;
        std::cout &lt;&lt; "Gear changed to: " &lt;&lt; _gear &lt;&lt; std::endl;
    }
    void toggle_entertainment_system() {
        _entertainment_system_on = !_entertainment_system_on;
        std::cout &lt;&lt; "Entertainment System is now " &lt;&lt; (_entertainment_system_on ? </span><span class="koboSpan" id="kobo.103.4">"on" : "off") &lt;&lt; std::endl;
    }
    void refuel(double amount) {
        _fuel_level += amount;
        std::cout &lt;&lt; "Refueling. </span><span class="koboSpan" id="kobo.103.5">Current fuel level: " &lt;&lt; _fuel_level &lt;&lt; " liters" &lt;&lt; std::endl;
    }
};</span></pre>
<p><span class="koboSpan" id="kobo.104.1">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">Car</span></strong><span class="koboSpan" id="kobo.106.1"> class is</span><a id="_idIndexMarker277"/><span class="koboSpan" id="kobo.107.1"> problematic because it tries to manage too many aspects of the car’s functionality, which are better handled by </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">specialized components.</span></span></p>
<h3><span class="koboSpan" id="kobo.109.1">Proper encapsulation using composition</span></h3>
<p><span class="koboSpan" id="kobo.110.1">A better approach</span><a id="_idIndexMarker278"/><span class="koboSpan" id="kobo.111.1"> is to use composition to delegate responsibilities to other classes, each handling a specific part of the system’s functionality. </span><span class="koboSpan" id="kobo.111.2">This not only adheres to the Single Responsibility Principle but also makes the system more modular and easier </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">to maintain.</span></span></p>
<p><span class="koboSpan" id="kobo.113.1">Here is an example of a well-designed </span><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">Car</span></strong><span class="koboSpan" id="kobo.115.1"> class </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">using composition:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.117.1">
#include &lt;iostream&gt;
#include &lt;string&gt;
class Engine {
private:
    double _fuel_level;
public:
    Engine() : _fuel_level(50) {}
    void consume_fuel(double amount) {
        _fuel_level -= amount;
        std::cout &lt;&lt; "Consuming fuel. </span><span class="koboSpan" id="kobo.117.2">Current fuel level: " &lt;&lt; _fuel_level &lt;&lt; " liters" &lt;&lt; std::endl;
    }
    void refuel(double amount) {
        _fuel_level += amount;
        std::cout &lt;&lt; "Engine refueled. </span><span class="koboSpan" id="kobo.117.3">Current fuel level: " &lt;&lt; _fuel_level &lt;&lt; " liters" &lt;&lt; std::endl;
    }
    double get_fuel_level() const {
        return _fuel_level;
    }
};
class Transmission {
private:
    int _gear;
public:
    Transmission() : _gear(1) {}
    void change_gear(int new_gear) {
        _gear = new_gear;
        std::cout &lt;&lt; "Transmission: Gear changed to " &lt;&lt; _gear &lt;&lt; std::endl;
    }
};
class EntertainmentSystem {
private:
    bool _is_on;
public:
    EntertainmentSystem() : _is_on(false) {}
    void toggle() {
        _is_on = !_is_on;
        std::cout &lt;&lt; "Entertainment System is now " &lt;&lt; (_is_on ? </span><span class="koboSpan" id="kobo.117.4">"on" : "off") &lt;&lt; std::endl;
    }
};
class Car {
private:
    std::string _model;
    double _speed;
    Engine _engine;
    Transmission _transmission;
    EntertainmentSystem _entertainment_system;
public:
    Car(const std::string&amp; model) : _model(model), _speed(0) {}
    void accelerate() {
        if (_engine.get_fuel_level() &gt; 0) {
            _speed += 10;
            _engine.consume_f
uel(5);
            std::cout &lt;&lt; "Car accelerating. </span><span class="koboSpan" id="kobo.117.5">Current speed: " &lt;&lt; _speed &lt;&lt; " km/h" &lt;&lt; std::endl;
        } else {
            std::cout &lt;&lt; "Not enough fuel to accelerate." </span><span class="koboSpan" id="kobo.117.6">&lt;&lt; std::endl;
        }
    }
    void change_gear(int gear) {
        _transmission.change_gear(gear);
    }
    void toggle_entertainment_system() {
        _entertainment_system.toggle();
    }
    void refuel(double amount) {
        _engine.refuel(amount);
    }
};</span></pre>
<p><span class="koboSpan" id="kobo.118.1">In this refined design, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">Car</span></strong><span class="koboSpan" id="kobo.120.1"> class acts as a coordinator among its components rather than </span><a id="_idIndexMarker279"/><span class="koboSpan" id="kobo.121.1">directly managing every detail. </span><span class="koboSpan" id="kobo.121.2">Each subsystem – engine, transmission, and entertainment system – handles its own state and behavior, leading to a design that is easier to maintain, test, and extend. </span><span class="koboSpan" id="kobo.121.3">This example showcases how appropriate encapsulation and composition can significantly enhance the structure and quality of </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">object-oriented software.</span></span></p>
<h2 id="_idParaDest-124"><a id="_idTextAnchor123"/><span class="koboSpan" id="kobo.123.1">Usage of structs and classes in C++</span></h2>
<p><span class="koboSpan" id="kobo.124.1">In C++, both structs and classes are used to define user-defined types that can contain data and functions. </span><span class="koboSpan" id="kobo.124.2">The primary difference between them lies in their default access levels: members of a class are private by default, while members of a struct are public. </span><span class="koboSpan" id="kobo.124.3">This distinction subtly influences their typical uses in </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">C++ programming.</span></span></p>
<h3><span class="koboSpan" id="kobo.126.1">Structs – ideal for passive data structures</span></h3>
<p><span class="koboSpan" id="kobo.127.1">Structs in C++ are</span><a id="_idIndexMarker280"/><span class="koboSpan" id="kobo.128.1"> particularly suited for</span><a id="_idIndexMarker281"/><span class="koboSpan" id="kobo.129.1"> creating passive data structures where the primary purpose is to store data without encapsulating too much behavior. </span><span class="koboSpan" id="kobo.129.2">Due to their public-by-default nature, structs are often used when you want to allow direct access to the data members, which can simplify code and reduce the need for additional functions to </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">manipulate data.</span></span></p>
<p><span class="koboSpan" id="kobo.131.1">The following list outlines the instances when you should </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">use structs:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.133.1">Data objects</span></strong><span class="koboSpan" id="kobo.134.1">: Structs </span><a id="_idIndexMarker282"/><span class="koboSpan" id="kobo.135.1">are perfect for creating </span><strong class="bold"><span class="koboSpan" id="kobo.136.1">plain old data</span></strong><span class="koboSpan" id="kobo.137.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.138.1">POD</span></strong><span class="koboSpan" id="kobo.139.1">) structures. </span><span class="koboSpan" id="kobo.139.2">These</span><a id="_idIndexMarker283"/><span class="koboSpan" id="kobo.140.1"> are simple objects that primarily hold data and have little or no functionality (methods). </span><span class="koboSpan" id="kobo.140.2">For example, structs are often used to represent coordinates in space, RGB color values, or settings configurations where direct access to data fields is more convenient than going through getters </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">and setters:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.142.1">
struct Color {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.143.1">
    int red = 0;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.144.1">
    int green = 0;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.145.1">
    int blue = 0;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.146.1">
};</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.147.1">
struct Point {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.148.1">
    double x = 0.0;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.149.1">
    double y = 0.0;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.150.1">
    double z = 0.0;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.151.1">
};</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.152.1">
Fortunately, C++ 11 and C++ 20 provide aggregate initialization and designated initializers, making it easier to initialize structs with default values.</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.153.1">
// C++ 11</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.154.1">
   auto point = Point {1.1, 2.2, 3.3};</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.155.1">
// C++ 20</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.156.1">
   auto point2 = Point {.x = 1.1, .y = 2.2, .z = 3.3};</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.157.1">If C++ 20 is not </span><a id="_idIndexMarker284"/><span class="koboSpan" id="kobo.158.1">available for your project, you can utilize C99-designated initializers to achieve a </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">similar effect:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.160.1">
   auto point3 = Point {.x = 1.1, .y = 2.2, .z = 3.3};</span></pre></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.161.1">Interoperability</span></strong><span class="koboSpan" id="kobo.162.1">: Structs </span><a id="_idIndexMarker285"/><span class="koboSpan" id="kobo.163.1">are useful in interfacing with code in C or in systems where data alignment and layout are critical. </span><span class="koboSpan" id="kobo.163.2">They ensure compatibility and performance in low-level operations, such as hardware interfacing or </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">network communication.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.165.1">Lightweight containers</span></strong><span class="koboSpan" id="kobo.166.1">: When</span><a id="_idIndexMarker286"/><span class="koboSpan" id="kobo.167.1"> you need a lightweight container to group together a few variables, structs provide a more transparent and less cumbersome way than classes. </span><span class="koboSpan" id="kobo.167.2">They are ideal for small aggregations where encapsulation isn’t a </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">primary concern.</span></span></li>
</ul>
<h3><span class="koboSpan" id="kobo.169.1">Classes – encapsulating complexity</span></h3>
<p><span class="koboSpan" id="kobo.170.1">Classes are the </span><a id="_idIndexMarker287"/><span class="koboSpan" id="kobo.171.1">backbone of C++ OOP and are used to encapsulate data and behavior into a single entity. </span><span class="koboSpan" id="kobo.171.2">The private-by-default access </span><a id="_idIndexMarker288"/><span class="koboSpan" id="kobo.172.1">specifier encourages the hiding of internal state and implementation details, promoting a more rigorous design that follows encapsulation and </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">abstraction principles.</span></span></p>
<p><span class="koboSpan" id="kobo.174.1">The following list explains when you should </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">use classes:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.176.1">Complex systems</span></strong><span class="koboSpan" id="kobo.177.1">: For</span><a id="_idIndexMarker289"/><span class="koboSpan" id="kobo.178.1"> components that involve complex data manipulations, state management, and interface control, classes are the preferred choice. </span><span class="koboSpan" id="kobo.178.2">They provide </span><a id="_idIndexMarker290"/><span class="koboSpan" id="kobo.179.1">mechanisms for data protection and interface abstraction, which are crucial for maintaining the integrity and stability of </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">software systems:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.181.1">
class Car {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.182.1">
private:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.183.1">
    int speed;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.184.1">
    double fuel_level;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.185.1">
public:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.186.1">
    void accelerate();</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.187.1">
    void brake();</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.188.1">
    void refuel(double amount);</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.189.1">
};</span></pre></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.190.1">Behavior encapsulation</span></strong><span class="koboSpan" id="kobo.191.1">: Classes are ideal when the functionality (methods) is as important as </span><a id="_idIndexMarker291"/><span class="koboSpan" id="kobo.192.1">the data. </span><span class="koboSpan" id="kobo.192.2">Encapsulating behaviors with data into classes allows for more maintainable and error-free code, as operations on the data are tightly controlled and </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">clearly defined.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.194.1">Inheritance and polymorphism</span></strong><span class="koboSpan" id="kobo.195.1">: Classes support </span><a id="_idIndexMarker292"/><span class="koboSpan" id="kobo.196.1">inheritance and polymorphism, enabling </span><a id="_idIndexMarker293"/><span class="koboSpan" id="kobo.197.1">the creation of complex object hierarchies that can be extended and modified dynamically. </span><span class="koboSpan" id="kobo.197.2">This is essential in many software design patterns and advanced </span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">system architectures.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.199.1">Choosing between a struct and a class in C++ should be guided by the intended use: structs for simple, transparent data containers where direct data access is acceptable or necessary, and classes for more complex systems where encapsulation, behavior, and interface control are required. </span><span class="koboSpan" id="kobo.199.2">Understanding and utilizing the strengths of each can lead to cleaner, more efficient, and </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">scalable code.</span></span></p>
<h2 id="_idParaDest-125"><a id="_idTextAnchor124"/><span class="koboSpan" id="kobo.201.1">Common method types in classes – getters and setters</span></h2>
<p><span class="koboSpan" id="kobo.202.1">In OOP, particularly</span><a id="_idIndexMarker294"/><span class="koboSpan" id="kobo.203.1"> in languages such as Java, </span><strong class="bold"><span class="koboSpan" id="kobo.204.1">getters</span></strong><span class="koboSpan" id="kobo.205.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.206.1">setters</span></strong><span class="koboSpan" id="kobo.207.1"> are standard methods that serve as the primary interface</span><a id="_idIndexMarker295"/><span class="koboSpan" id="kobo.208.1"> for </span><a id="_idIndexMarker296"/><span class="koboSpan" id="kobo.209.1">accessing and modifying the private data members of a class. </span><span class="koboSpan" id="kobo.209.2">These methods provide controlled access to an object’s properties, adhering to the encapsulation principle, which is a cornerstone of effective </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">object-oriented design.</span></span></p>
<h3><span class="koboSpan" id="kobo.211.1">Purpose and conventions of getters and setters</span></h3>
<p><span class="koboSpan" id="kobo.212.1">Getters (also known as accessors) are</span><a id="_idIndexMarker297"/><span class="koboSpan" id="kobo.213.1"> methods used to retrieve the value of a private field. </span><span class="koboSpan" id="kobo.213.2">They do not modify the data. </span><span class="koboSpan" id="kobo.213.3">Setters (also known as mutators) are methods</span><a id="_idIndexMarker298"/><span class="koboSpan" id="kobo.214.1"> that allow the modification of private fields based on the input they receive. </span><span class="koboSpan" id="kobo.214.2">These methods enable the internal state of an object to remain consistent and valid by potentially enforcing</span><a id="_idIndexMarker299"/><span class="koboSpan" id="kobo.215.1"> constraints or conditions when data </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">is set.</span></span></p>
<p><span class="koboSpan" id="kobo.217.1">Here are the conventions of</span><a id="_idIndexMarker300"/><span class="koboSpan" id="kobo.218.1"> getters </span><span class="No-Break"><span class="koboSpan" id="kobo.219.1">and setters:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.220.1">Naming</span></strong><span class="koboSpan" id="kobo.221.1">: Typically, a getter for a property, </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">x</span></strong><span class="koboSpan" id="kobo.223.1">, is named </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">get_x()</span></strong><span class="koboSpan" id="kobo.225.1">, and the setter is named </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">set_x(value)</span></strong><span class="koboSpan" id="kobo.227.1">. </span><span class="koboSpan" id="kobo.227.2">This naming convention is almost universal in Java and is commonly adopted in other programming languages that support </span><span class="No-Break"><span class="koboSpan" id="kobo.228.1">class-based OOP.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.229.1">Return types and parameters</span></strong><span class="koboSpan" id="kobo.230.1">: A getter for a property returns the same type as the property itself and takes no parameters, whereas a setter returns void and takes a parameter of the same type as the property </span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">it sets.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.232.1">Here is an example of this </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">in C++:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.234.1">
class Person {
private:
    std::string _name;
    int _age;
public:
    // Getter for the name property
    std::string get_name() const { return _name; }
    // Setter for the name property
    void set_name(const std::string&amp; name) { _name = name; }
    // Getter for the age property
    int get_age() const { return _age; }
    // Setter for the age property
    void set_age(int age) {
        if (age &gt;= 0) { // validate the age
            _age = age;
        }
    }
};</span></pre>
<h3><span class="koboSpan" id="kobo.235.1">Usefulness and recommendations</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.236.1">Controlled access and validation</span></strong><span class="koboSpan" id="kobo.237.1">: Getters and setters encapsulate the fields of a class, providing controlled access and validation logic. </span><span class="koboSpan" id="kobo.237.2">This helps to maintain the integrity of the data, ensuring that no invalid or inappropriate values </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">are set.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.239.1">Flexibility</span></strong><span class="koboSpan" id="kobo.240.1">: By using </span><a id="_idIndexMarker301"/><span class="koboSpan" id="kobo.241.1">getters and setters, developers can change the</span><a id="_idIndexMarker302"/><span class="koboSpan" id="kobo.242.1"> underlying implementation of how the data is stored and retrieved without changing the external interface of the class. </span><span class="koboSpan" id="kobo.242.2">This can be particularly useful in maintaining backward compatibility or when the data representation needs to be changed </span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">for optimization.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.244.1">Consistency</span></strong><span class="koboSpan" id="kobo.245.1">: These methods can enforce rules that need to be maintained consistently throughout an object’s life cycle. </span><span class="koboSpan" id="kobo.245.2">For example, ensuring that a field never holds a null value or adheres to a </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">specific format.</span></span></p>
<h3><span class="koboSpan" id="kobo.247.1">When to use getters and setters, and when not to</span></h3>
<p><span class="koboSpan" id="kobo.248.1">The rule of thumb is to use getters and setters in classes where encapsulation, business logic, or inheritance complexities are present. </span><span class="koboSpan" id="kobo.248.2">For example, for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">Car</span></strong><span class="koboSpan" id="kobo.250.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">Engine</span></strong><span class="koboSpan" id="kobo.252.1"> classes with relatively complex logic, getters and setters are essential to maintain the integrity of the data and ensure that the system functions correctly. </span><span class="koboSpan" id="kobo.252.2">On the other hand, for a simple data structure such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">Point</span></strong><span class="koboSpan" id="kobo.254.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">Color</span></strong><span class="koboSpan" id="kobo.256.1">, where the primary purpose is to hold data without much behavior, using a struct with public data members might be more appropriate. </span><span class="koboSpan" id="kobo.256.2">Note that if the struct is a part of a library or API, it might be beneficial to provide getters and setters for </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">future extensibility.</span></span></p>
<p><span class="koboSpan" id="kobo.258.1">This nuanced approach allows developers to balance between control and simplicity, choosing the most appropriate tool for the specific requirements of their </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">software components.</span></span></p>
<h1 id="_idParaDest-126"><a id="_idTextAnchor125"/><span class="koboSpan" id="kobo.260.1">Inheritance in C++</span></h1>
<p><span class="koboSpan" id="kobo.261.1">Inheritance and </span><a id="_idIndexMarker303"/><span class="koboSpan" id="kobo.262.1">composition are two fundamental OOP concepts that enable the creation of complex and reusable software designs in C++. </span><span class="koboSpan" id="kobo.262.2">They facilitate code reuse and help in modeling real-world relationships, though they </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">operate differently.</span></span></p>
<p><span class="koboSpan" id="kobo.264.1">Inheritance allows one class, known as the derived or subclass, to inherit properties and behaviors from another class, the base or superclass. </span><span class="koboSpan" id="kobo.264.2">This enables the derived class to reuse the code in the base class while extending or overriding its functionality. </span><span class="koboSpan" id="kobo.264.3">For instance, consider a </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">BaseSocket</span></strong><span class="koboSpan" id="kobo.266.1"> class and its derived classes, </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">TcpSocket</span></strong><span class="koboSpan" id="kobo.268.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">UdpSocket</span></strong><span class="koboSpan" id="kobo.270.1">. </span><span class="koboSpan" id="kobo.270.2">The derived classes inherit the basic functionality of </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">BaseSocket</span></strong><span class="koboSpan" id="kobo.272.1"> and add their </span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">specific</span></span><span class="No-Break"><a id="_idIndexMarker304"/></span><span class="No-Break"><span class="koboSpan" id="kobo.274.1"> implementations:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.275.1">
class BaseSocket {
public:
    virtual ssize_t send(const std::vector&lt;uint8_t&gt;&amp; data) = 0;
    virtual ~BaseSocket() = default;
};
class TcpSocket : public BaseSocket {
public:
    ssize_t send(const std::vector&lt;uint8_t&gt;&amp; data) override {
        // Implement TCP-specific send logic here
    }
};
class UdpSocket : public BaseSocket {
public:
    ssize_t send(const std::vector&lt;uint8_t&gt;&amp; data) override {
        // Implement UDP-specific send logic here
    }
};</span></pre>
<p><span class="koboSpan" id="kobo.276.1">In this example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">TcpSocket</span></strong><span class="koboSpan" id="kobo.278.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">UdpSocket</span></strong><span class="koboSpan" id="kobo.280.1"> classes inherit from </span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1">BaseSocket</span></strong><span class="koboSpan" id="kobo.282.1">, demonstrating how inheritance promotes code reuse and establishes an “is-a” relationship. </span><span class="koboSpan" id="kobo.282.2">Inheritance also supports polymorphism, allowing objects of the derived class to be treated as instances of the base class, enabling dynamic </span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">method binding.</span></span></p>
<p><span class="koboSpan" id="kobo.284.1">Composition, on</span><a id="_idIndexMarker305"/><span class="koboSpan" id="kobo.285.1"> the other hand, involves creating classes by including objects of other classes. </span><span class="koboSpan" id="kobo.285.2">Instead of inheriting from a base class, a class is composed of one or more objects from other classes, which are used to achieve the desired functionality. </span><span class="koboSpan" id="kobo.285.3">This represents a “has-a” relationship. </span><span class="koboSpan" id="kobo.285.4">For example, consider a </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">CommunicationChannel</span></strong><span class="koboSpan" id="kobo.287.1"> class that can own </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">BaseSocket</span></strong><span class="koboSpan" id="kobo.289.1">. </span><span class="koboSpan" id="kobo.289.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">CommunicationChannel</span></strong><span class="koboSpan" id="kobo.291.1"> class uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">BaseSocket</span></strong><span class="koboSpan" id="kobo.293.1"> object to implement its communication functionality, </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">demonstrating composition:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.295.1">
class CommunicationChannel {
public:
    CommunicationChannel(std::unique_ptr&lt;BaseSocket&gt; sock) : _socket(sock) {}
    bool transmit(const std::vector&lt;uint8_t&gt;&amp; data) {
        size_t total_sent = 0;
        size_t data_size = data.size();
        while (total_sent &lt; data_size) {
            ssize_t bytesSent = _socket-&gt;send({data.begin() + total_sent, data.end()});
            if (bytesSent &lt; 0) {
                std::cerr &lt;&lt; "Error sending data." </span><span class="koboSpan" id="kobo.295.2">&lt;&lt; std::endl;
                return false;
            }
            total_sent += bytesSent;
        }
        std::cout &lt;&lt; "Communication channel transmitted " &lt;&lt; total_sent &lt;&lt; " bytes." </span><span class="koboSpan" id="kobo.295.3">&lt;&lt; std::endl;
        return true;
    }
private:
    std::unique_ptr&lt;BaseSocket&gt; _socket;
};
int main() {
    TcpSocket tcp;
    CommunicationChannel channel(std::make_unique&lt;TcpSocket&gt;());
    std::vector&lt;uint8_t&gt; data = {1, 2, 3, 4, 5};
    if (channel.transmit(data)) {
        std::cout &lt;&lt; "Data transmitted successfully." </span><span class="koboSpan" id="kobo.295.4">&lt;&lt; std::endl;
    } else {
        std::cerr &lt;&lt; "Data transmission failed." </span><span class="koboSpan" id="kobo.295.5">&lt;&lt; std::endl;
    }
    return 0;
}</span></pre>
<p><span class="koboSpan" id="kobo.296.1">In this</span><a id="_idIndexMarker306"/><span class="koboSpan" id="kobo.297.1"> example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">CommunicationChannel</span></strong><span class="koboSpan" id="kobo.299.1"> class contains a </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">BaseSocket</span></strong><span class="koboSpan" id="kobo.301.1"> object and uses it to implement its functionality. </span><span class="koboSpan" id="kobo.301.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">transmit</span></strong><span class="koboSpan" id="kobo.303.1"> method sends data in chunks until all data is sent, checking for errors (when the return value is less than </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">0</span></strong><span class="koboSpan" id="kobo.305.1">). </span><span class="koboSpan" id="kobo.305.2">This demonstrates how composition offers flexibility, allowing objects to be dynamically assembled at runtime. </span><span class="koboSpan" id="kobo.305.3">It also promotes better encapsulation by containing objects and exposing only necessary interfaces, thereby avoiding tight coupling between classes and making the code more modular and easier </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">to maintain.</span></span></p>
<p><span class="koboSpan" id="kobo.307.1">In summary, both</span><a id="_idIndexMarker307"/><span class="koboSpan" id="kobo.308.1"> inheritance and composition are essential tools in C++ for creating reusable and maintainable code. </span><span class="koboSpan" id="kobo.308.2">Inheritance is suitable for scenarios with a clear hierarchical relationship and where polymorphism is needed, while composition is ideal for assembling complex behaviors from simpler components, offering flexibility and better encapsulation. </span><span class="koboSpan" id="kobo.308.3">Understanding when to use each approach is key to effective </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">object-oriented design.</span></span></p>
<h2 id="_idParaDest-127"><a id="_idTextAnchor126"/><span class="koboSpan" id="kobo.310.1">Evolution of inheritance in C++</span></h2>
<p><span class="koboSpan" id="kobo.311.1">Originally, inheritance </span><a id="_idIndexMarker308"/><span class="koboSpan" id="kobo.312.1">was seen as a powerful tool for reducing code duplication and enhancing the expressiveness of code. </span><span class="koboSpan" id="kobo.312.2">It allowed for the creation of a derived class that inherits properties and behavior from a base class. </span><span class="koboSpan" id="kobo.312.3">However, as the use of C++ grew in complex systems, the limitations of inheritance as a one-size-fits-all solution </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">became apparent.</span></span></p>
<h2 id="_idParaDest-128"><a id="_idTextAnchor127"/><span class="koboSpan" id="kobo.314.1">Implementation of inheritance at the binary level</span></h2>
<p><span class="koboSpan" id="kobo.315.1">Interestingly, on</span><a id="_idIndexMarker309"/><span class="koboSpan" id="kobo.316.1"> a binary level, inheritance in C++ is implemented similarly to composition. </span><span class="koboSpan" id="kobo.316.2">Essentially, the derived class contains an instance of the base class within its structure. </span><span class="koboSpan" id="kobo.316.3">This can be visualized in a simplified </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">ASCII diagram:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.318.1">
+-------------------+
|   Derived Class   |
|-------------------|
|  Base Class Part  | &lt;- Base class subobject
|-------------------|
| Derived Class Data| &lt;- Additional data members of the derived class
+-------------------+</span></pre>
<p><span class="koboSpan" id="kobo.319.1">In this layout, the base class part of the derived class object contains all the data members that </span><a id="_idIndexMarker310"/><span class="koboSpan" id="kobo.320.1">belong to the base class, and directly after it in memory, the additional data members of the derived class are placed. </span><span class="koboSpan" id="kobo.320.2">Note that the actual order of data members in memory can be influenced by factors such as alignment requirements and </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">compiler optimizations.</span></span></p>
<h2 id="_idParaDest-129"><a id="_idTextAnchor128"/><span class="koboSpan" id="kobo.322.1">Pros and cons of inheritance</span></h2>
<p><span class="koboSpan" id="kobo.323.1">Here are the</span><a id="_idIndexMarker311"/><span class="koboSpan" id="kobo.324.1"> pros </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">of inheritance:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.326.1">Code reuse</span></strong><span class="koboSpan" id="kobo.327.1">: Inheritance allows developers to create a new class based on an existing class, making it easy to reuse code and reduce redundancy. </span><span class="koboSpan" id="kobo.327.2">Let’s use an example from a media player system to demonstrate inheritance and code reuse in a different context. </span><span class="koboSpan" id="kobo.327.3">We’ll design a class hierarchy for various types of media content that a player might handle, such as audio files, video files, </span><span class="No-Break"><span class="koboSpan" id="kobo.328.1">and podcasts.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.329.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">MediaContent</span></strong><span class="koboSpan" id="kobo.331.1"> class will serve as the base class for all types of media content. </span><span class="koboSpan" id="kobo.331.2">It will encapsulate common attributes and behaviors such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">title</span></strong><span class="koboSpan" id="kobo.333.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">duration</span></strong><span class="koboSpan" id="kobo.335.1">, and basic playback controls (</span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">play</span></strong><span class="koboSpan" id="kobo.337.1">, </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">pause</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">stop</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.341.1">):</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.342.1">
#include &lt;iostream&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.343.1">
#include &lt;string&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.344.1">
// Base class for all media content</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.345.1">
class MediaContent {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.346.1">
protected:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.347.1">
    std::string _title;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.348.1">
    int _duration; // Duration in seconds</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.349.1">
public:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.350.1">
    MediaContent(const std::string&amp; title, int duration)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.351.1">
        : _title(title), _duration(duration) {}</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.352.1">
    auto title() const { return _title; }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.353.1">
    auto duration() const { return duration; }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.354.1">
    virtual void play() = 0; // Start playing the content</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.355.1">
    virtual void pause() = 0;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.356.1">
    virtual void stop() = 0;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.357.1">
    virtual ~MediaContent() = default;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.358.1">
};</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.359.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">Audio</span></strong><span class="koboSpan" id="kobo.361.1"> class</span><a id="_idIndexMarker312"/><span class="koboSpan" id="kobo.362.1"> extends </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">MediaContent</span></strong><span class="koboSpan" id="kobo.364.1">, adding specific attributes related to audio files, such </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">as bitrate:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.366.1">
class Audio : public MediaContent {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.367.1">
private:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.368.1">
    int _bitrate; // Bitrate in kbps</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.369.1">
public:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.370.1">
    Audio(const std::string&amp; title, int duration, int bitrate)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.371.1">
        : MediaContent(title, duration), _bitrate(bitrate) {}</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.372.1">
    auto bitrate() const { return _bitrate; }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.373.1">
    void play() override {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.374.1">
        std::cout &lt;&lt; "Playing audio: " &lt;&lt; title &lt;&lt; ", Duration: " &lt;&lt; duration</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.375.1">
                  &lt;&lt; "s, Bitrate: " &lt;&lt; bitrate &lt;&lt; "kbps" &lt;&lt; std::endl;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.376.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.377.1">
    void pause() override {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.378.1">
        std::cout &lt;&lt; "Audio paused: " &lt;&lt; title &lt;&lt; std::endl;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.379.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.380.1">
    void stop() override {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.381.1">
        std::cout &lt;&lt; "Audio stopped: " &lt;&lt; title &lt;&lt; std::endl;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.382.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.383.1">
};</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.384.1">Similarly, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">Video</span></strong><span class="koboSpan" id="kobo.386.1"> class extends </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">MediaContent</span></strong><span class="koboSpan" id="kobo.388.1"> and introduces additional attributes</span><a id="_idIndexMarker313"/><span class="koboSpan" id="kobo.389.1"> such </span><span class="No-Break"><span class="koboSpan" id="kobo.390.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">resolution</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.392.1">:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.393.1">
class Video : public MediaContent {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.394.1">
private:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.395.1">
    std::string _resolution; // Resolution as width x height</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.396.1">
public:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.397.1">
    Video(const std::string&amp; title, int duration, const std::string&amp; resolution)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.398.1">
        : MediaContent(title, duration), _resolution(resolution) {}</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.399.1">
    auto resolution() const { return _resolution; }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.400.1">
    void play() override {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.401.1">
        std::cout &lt;&lt; "Playing video: " &lt;&lt; title &lt;&lt; ", Duration: " &lt;&lt; duration</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.402.1">
                  &lt;&lt; "s, Resolution: " &lt;&lt; resolution &lt;&lt; std::endl;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.403.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.404.1">
    void pause() override {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.405.1">
        std::cout &lt;&lt; "Video paused: " &lt;&lt; title &lt;&lt; std::endl;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.406.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.407.1">
    void stop() override {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.408.1">
        std::cout &lt;&lt; "Video stopped: " &lt;&lt; title &lt;&lt; std::endl;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.409.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.410.1">
};</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.411.1">Here’s how </span><a id="_idIndexMarker314"/><span class="koboSpan" id="kobo.412.1">these classes could be used in a simple media </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">player system:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.414.1">
int main() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.415.1">
    Audio my_song("Song Example", 300, 320);</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.416.1">
    Video my_movie("Movie Example", 7200, "1920x1080");</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.417.1">
    my_song.play();</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.418.1">
    my_song.pause();</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.419.1">
    my_song.stop();</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.420.1">
    my_movie.play();</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.421.1">
    my_movie.pause();</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.422.1">
    my_movie.stop();</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.423.1">
    return 0;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.424.1">
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.425.1">In this example, both </span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">Audio</span></strong><span class="koboSpan" id="kobo.427.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">Video</span></strong><span class="koboSpan" id="kobo.429.1"> inherit from </span><strong class="source-inline"><span class="koboSpan" id="kobo.430.1">MediaContent</span></strong><span class="koboSpan" id="kobo.431.1">. </span><span class="koboSpan" id="kobo.431.2">This allows us to reuse the </span><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">title</span></strong><span class="koboSpan" id="kobo.433.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">duration</span></strong><span class="koboSpan" id="kobo.435.1"> attributes and requires the implementation of the playback controls (</span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">play</span></strong><span class="koboSpan" id="kobo.437.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">pause</span></strong><span class="koboSpan" id="kobo.439.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">stop</span></strong><span class="koboSpan" id="kobo.441.1">) tailored to each media type. </span><span class="koboSpan" id="kobo.441.2">This hierarchy demonstrates how inheritance facilitates code reuse and system extensibility while enabling specific behaviors for different types of media content in </span><a id="_idIndexMarker315"/><span class="koboSpan" id="kobo.442.1">a unified framework. </span><span class="koboSpan" id="kobo.442.2">Each class adds only what is unique to its type, adhering to the principle that base classes provide common functionality and derived classes extend or modify that functionality for </span><span class="No-Break"><span class="koboSpan" id="kobo.443.1">specific needs.</span></span></p></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.444.1">Polymorphism</span></strong><span class="koboSpan" id="kobo.445.1">: Through inheritance, C++ supports polymorphism, which allows for the use of a base class reference to refer to an object of a derived class. </span><span class="koboSpan" id="kobo.445.2">This enables dynamic method binding and a flexible interface to multiple derived types. </span><span class="koboSpan" id="kobo.445.3">Our media content hierarchy can be used for implementing a media player that can handle different types of media </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">content uniformly:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.447.1">
class MediaPlayer {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.448.1">
private:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.449.1">
    std::vector&lt;std::unique_ptr&lt;MediaContent&gt;&gt; _playlist;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.450.1">
public:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.451.1">
    void add_media(std::unique_ptr&lt;MediaContent&gt; media) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.452.1">
        _playlist.push_back(std::move(media));</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.453.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.454.1">
    void play_all() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.455.1">
        for (auto&amp; media : _playlist) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.456.1">
            media-&gt;play();</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.457.1">
            // Additional controls can be implemented</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.458.1">
        }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.459.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.460.1">
};</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.461.1">
int main() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.462.1">
    MediaPlayer player;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.463.1">
    player.add(std::make_unique&lt;Audio&gt;("Jazz in Paris", 192, 320));</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.464.1">
    player.add(std::make_unique&lt;Video&gt;("Tour of Paris", 1200, "1280x720"));</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.465.1">
    player.play_all();</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.466.1">
    return 0;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.467.1">
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.468.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">add</span></strong><span class="koboSpan" id="kobo.470.1"> method accepts media content of any type that derives from </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">MediaContent</span></strong><span class="koboSpan" id="kobo.472.1">, demonstrating polymorphism by using a base class pointer to refer to derived </span><a id="_idIndexMarker316"/><span class="koboSpan" id="kobo.473.1">class objects. </span><span class="koboSpan" id="kobo.473.2">This is enabled by storing the media items in </span><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">std::vector</span></strong><span class="koboSpan" id="kobo.475.1"> of </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">std::unique_ptr&lt;MediaContent&gt;</span></strong><span class="koboSpan" id="kobo.477.1">. </span><span class="koboSpan" id="kobo.477.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">play_all</span></strong><span class="koboSpan" id="kobo.479.1"> method iterates through the stored media and calls the play method on each item. </span><span class="koboSpan" id="kobo.479.2">Despite the actual media type being different (audio or video), the media player treats them all as </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">MediaContent</span></strong><span class="koboSpan" id="kobo.481.1">. </span><span class="koboSpan" id="kobo.481.2">The correct play method (from either </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">Audio</span></strong><span class="koboSpan" id="kobo.483.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">Video</span></strong><span class="koboSpan" id="kobo.485.1">) is invoked at runtime, which is an example of dynamic polymorphism (also known as </span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">dynamic dispatch).</span></span></p></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.487.1">Hierarchical structuring</span></strong><span class="koboSpan" id="kobo.488.1">: It provides a natural way to organize related classes in a hierarchical manner that models </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">real-world relationships.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.490.1">Here is the con </span><span class="No-Break"><span class="koboSpan" id="kobo.491.1">of </span></span><span class="No-Break"><a id="_idIndexMarker317"/></span><span class="No-Break"><span class="koboSpan" id="kobo.492.1">inheritance:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.493.1">Tight coupling</span></strong><span class="koboSpan" id="kobo.494.1">: Inheritance creates a tight coupling between base and derived classes. </span><span class="koboSpan" id="kobo.494.2">Changes to the base class can inadvertently affect derived classes, leading to fragile code that can break when base classes are modified. </span><span class="koboSpan" id="kobo.494.3">The following example illustrates the issue of tight coupling through inheritance in a software system. </span><span class="koboSpan" id="kobo.494.4">We’ll use a scenario involving an online store that manages different types of discounts using a </span><span class="No-Break"><span class="koboSpan" id="kobo.495.1">class hierarchy.</span></span></li>
</ul>
<h2 id="_idParaDest-130"><a id="_idTextAnchor129"/><span class="koboSpan" id="kobo.496.1">Base class – Discount</span></h2>
<p><span class="koboSpan" id="kobo.497.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">Discount</span></strong><span class="koboSpan" id="kobo.499.1"> class </span><a id="_idIndexMarker318"/><span class="koboSpan" id="kobo.500.1">provides the basic structure and functionality for all types of discounts. </span><span class="koboSpan" id="kobo.500.2">It calculates a discount based on a </span><span class="No-Break"><span class="koboSpan" id="kobo.501.1">percentage reduction;</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.502.1">
#include &lt;iostream&gt;
class Discount {
protected:
    double _discount_percent;  // Percent of discount
public:
    Discount(double percent) : _discount_percent(percent) {}
    virtual double apply_discount(double amount) {
        return amount * (1 - _discount_percent / 100);
    }
};</span></pre>
<h2 id="_idParaDest-131"><a id="_idTextAnchor130"/><span class="koboSpan" id="kobo.503.1">Derived class – SeasonalDiscount</span></h2>
<p><span class="koboSpan" id="kobo.504.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">SeasonalDiscount</span></strong><span class="koboSpan" id="kobo.506.1"> class extends </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">Discount</span></strong><span class="koboSpan" id="kobo.508.1"> and modifies the discount calculation</span><a id="_idIndexMarker319"/><span class="koboSpan" id="kobo.509.1"> based on seasonal factors, such as increasing the discount during the </span><span class="No-Break"><span class="koboSpan" id="kobo.510.1">holiday season:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.511.1">
class SeasonalDiscount : public Discount {
public:
    SeasonalDiscount(double percent) : Discount(percent) {}
    double apply_discount(double amount) override {
        // Let's assume the discount increases by an additional 5% during holidays
        double additional = 0.05;  // 5% extra during holidays
        return amount * (1 - (_discount_percent / 100 + additional));
    }
};</span></pre>
<h2 id="_idParaDest-132"><a id="_idTextAnchor131"/><span class="koboSpan" id="kobo.512.1">Derived class – ClearanceDiscount</span></h2>
<p><span class="koboSpan" id="kobo.513.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">ClearanceDiscount</span></strong><span class="koboSpan" id="kobo.515.1"> class </span><a id="_idIndexMarker320"/><span class="koboSpan" id="kobo.516.1">also extends </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">Discount</span></strong><span class="koboSpan" id="kobo.518.1">, designed for items on clearance where the discount might be </span><span class="No-Break"><span class="koboSpan" id="kobo.519.1">significantly higher:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.520.1">
class ClearanceDiscount : public Discount {
public:
    ClearanceDiscount(double percent) : Discount(percent) {}
    double apply_discount(double amount) override {
        // Clearance items get an extra 10% off beyond the configured discount
        double additional = 0.10;  // 10% extra for clearance items
        return amount * (1 - (_discount_percent / 100 + additional));
    }
};</span></pre>
<p><span class="koboSpan" id="kobo.521.1">Demonstration and tight </span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">coupling issue:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.523.1">
int main() {
    Discount regular(20); // 20% regular discount
    SeasonalDiscount holiday(20); // 20% holiday discount, plus extra
    ClearanceDiscount clearance(20); // 20% clearance discount, plus extra
    std::cout &lt;&lt; "Regular Price $100 after discount: $" &lt;&lt; regular.apply_discount(100) &lt;&lt; std::endl;
    std::cout &lt;&lt; "Holiday Price $100 after discount: $" &lt;&lt; holiday.apply_discount(100) &lt;&lt; std::endl;
    std::cout &lt;&lt; "Clearance Price $100 after discount: $" &lt;&lt; clearance.apply_discount(100) &lt;&lt; std::endl;
    return 0;
}</span></pre>
<h2 id="_idParaDest-133"><a id="_idTextAnchor132"/><span class="koboSpan" id="kobo.524.1">Tight coupling problems</span></h2>
<p><span class="koboSpan" id="kobo.525.1">The following is a</span><a id="_idIndexMarker321"/><span class="koboSpan" id="kobo.526.1"> list of </span><span class="No-Break"><span class="koboSpan" id="kobo.527.1">tight-coupling problems:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.528.1">Dependency on the base class method</span></strong><span class="koboSpan" id="kobo.529.1">: All subclasses are tightly coupled to the base class’s method structure (</span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">apply_discount</span></strong><span class="koboSpan" id="kobo.531.1">). </span><span class="koboSpan" id="kobo.531.2">Any change in the base class method’s signature or the logic within </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">apply_discount</span></strong><span class="koboSpan" id="kobo.533.1"> could necessitate changes in all </span><span class="No-Break"><span class="koboSpan" id="kobo.534.1">derived classes.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.535.1">Assumptions on internal logic</span></strong><span class="koboSpan" id="kobo.536.1">: Subclasses assume they can simply add to </span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">_discount_percent</span></strong><span class="koboSpan" id="kobo.538.1">. </span><span class="koboSpan" id="kobo.538.2">If the formula in the base class changes (say, incorporating minimum or maximum caps), all subclasses might need extensive modifications to conform to the </span><span class="No-Break"><span class="koboSpan" id="kobo.539.1">new logic.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.540.1">Inflexibility</span></strong><span class="koboSpan" id="kobo.541.1">: The coupling makes it hard to modify the behavior of one discount type without risking impacts on others. </span><span class="koboSpan" id="kobo.541.2">This design lacks flexibility where independent evolution of discount calculation strategies might </span><span class="No-Break"><span class="koboSpan" id="kobo.542.1">be necessary.</span></span></li>
</ul>
<h2 id="_idParaDest-134"><a id="_idTextAnchor133"/><span class="koboSpan" id="kobo.543.1">Solution – decouple with the strategy pattern</span></h2>
<p><span class="koboSpan" id="kobo.544.1">One way to reduce</span><a id="_idIndexMarker322"/><span class="koboSpan" id="kobo.545.1"> this coupling is to use </span><a id="_idIndexMarker323"/><span class="koboSpan" id="kobo.546.1">the </span><strong class="bold"><span class="koboSpan" id="kobo.547.1">strategy pattern</span></strong><span class="koboSpan" id="kobo.548.1">, which involves defining a family of algorithms (discount strategies), encapsulating each one, and making them interchangeable. </span><span class="koboSpan" id="kobo.548.2">This allows the discount algorithms to vary independently from the clients that </span><span class="No-Break"><span class="koboSpan" id="kobo.549.1">use them:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.550.1">
class DiscountStrategy {
public:
    virtual double calculate(double amount) = 0;
    virtual ~DiscountStrategy() {}
};
class RegularDiscountStrategy : public DiscountStrategy {
public:
    double calculate(double amount) override {
        return amount * 0.80; // 20% discount
    }
};
class HolidayDiscountStrategy : public DiscountStrategy {
public:
    double calculate(double amount) override {
        return amount * 0.75; // 25% discount
    }
};
class ClearanceDiscountStrategy : public DiscountStrategy {
public:
    double calculate(double amount) override {
        return amount * 0.70; // 30% discount
    }
};
// Use these strategies in a Discount context class
class Discount {
private:
    std::unique_ptr&lt;DiscountStrategy&gt; _strategy;
public:
    Discount(std::unique_ptr&lt;DiscountStrategy&gt; strat) : _strategy(std::move(strat)) {}
    double apply_discount(double amount) {
        return _strategy-&gt;calculate(amount);
    }
};</span></pre>
<p><span class="koboSpan" id="kobo.551.1">This</span><a id="_idIndexMarker324"/><span class="koboSpan" id="kobo.552.1"> approach decouples the discount calculation from the client (</span><strong class="source-inline"><span class="koboSpan" id="kobo.553.1">Discount</span></strong><span class="koboSpan" id="kobo.554.1">) using it, allowing each discount strategy to evolve independently without affecting others. </span><span class="koboSpan" id="kobo.554.2">A couple of others ways to reduce the </span><span class="No-Break"><span class="koboSpan" id="kobo.555.1">coupling are:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.556.1">Complexity</span></strong><span class="koboSpan" id="kobo.557.1">: Deep and complex inheritance hierarchies, along with the use of multiple inheritance, introduce a range of challenges that can complicate software design, making systems harder to understand, maintain, and evolve. </span><span class="koboSpan" id="kobo.557.2">When classes derive from multiple levels of base classes, forming extended chains of dependencies, understanding and modifying such classes demands an awareness of the entire inheritance chain. </span><span class="koboSpan" id="kobo.557.3">This depth increases complexity as changes in top-level classes can unpredictably affect functionality across all subclasses, leading to what is often referred to as “fragility” in </span><span class="No-Break"><span class="koboSpan" id="kobo.558.1">software design.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.559.1">Multiple </span><a id="_idIndexMarker325"/><span class="koboSpan" id="kobo.560.1">inheritance, where a class inherits characteristics from more than one base class, introduces its own set of problems. </span><span class="koboSpan" id="kobo.560.2">This approach can lead to the infamous “diamond problem,” where ambiguities arise if both parent classes derive from a common ancestor and provide their own implementations of the same method. </span><span class="koboSpan" id="kobo.560.3">While languages such as C++ provide mechanisms such as virtual inheritance to address such issues, these solutions add layers of complexity and can introduce inefficiencies in memory management and </span><span class="No-Break"><span class="koboSpan" id="kobo.561.1">method resolution.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.562.1">Combining multiple inheritance with multi-level inheritance hierarchies, sometimes seen in more complex or “exotic” system designs, compounds these difficulties. </span><span class="koboSpan" id="kobo.562.2">For example, a class such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">HybridFlyingElectricCar</span></strong><span class="koboSpan" id="kobo.564.1"> that inherits from both </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">ElectricCar</span></strong><span class="koboSpan" id="kobo.566.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">FlyingCar</span></strong><span class="koboSpan" id="kobo.568.1">, with each of these classes further inheriting from their respective hierarchies, results in a highly tangled class structure. </span><span class="koboSpan" id="kobo.568.2">This complexity makes the system tough to debug, extend, or reliably use, while also multiplying the challenges in testing and maintaining consistent behavior across </span><span class="No-Break"><span class="koboSpan" id="kobo.569.1">various scenarios.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.570.1">To manage the complications introduced by extensive use of inheritance, several strategies can be recommended. </span><span class="koboSpan" id="kobo.570.2">Favoring composition over inheritance often provides greater flexibility, allowing systems to be composed of well-defined, loosely coupled components rather than relying on rigid inheritance structures. </span><span class="koboSpan" id="kobo.570.3">Keeping inheritance chains short and manageable – generally no deeper than two or three levels – helps preserve system clarity and maintainability. </span><span class="koboSpan" id="kobo.570.4">Employing interfaces, particularly in languages such as Java and C#, offers a way to achieve polymorphic behavior without the overhead associated with inheritance. </span><span class="koboSpan" id="kobo.570.5">When multiple inheritance is unavoidable, it’s crucial to ensure clear documentation and consider the use of interface-like structures or mixins, which can help minimize complexity and enhance </span><span class="No-Break"><span class="koboSpan" id="kobo.571.1">system robustness.</span></span></p></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.572.1">Liskov Substitution Principle (LSP)</span></strong><span class="koboSpan" id="kobo.573.1">: We mentioned this principle earlier in this book; LSP states</span><a id="_idIndexMarker326"/><span class="koboSpan" id="kobo.574.1"> that objects of a superclass should be replaceable with objects of </span><a id="_idIndexMarker327"/><span class="koboSpan" id="kobo.575.1">its subclasses without altering the desirable properties of the program (correctness, task performed, etc.). </span><span class="koboSpan" id="kobo.575.2">Inheritance can sometimes lead to violations of this principle, especially when subclasses diverge from the behavior expected by the base class. </span><span class="koboSpan" id="kobo.575.3">The following sections include typical problems related to violations of the LSP, illustrated with </span><span class="No-Break"><span class="koboSpan" id="kobo.576.1">simple examples.</span></span></li>
</ul>
<h3><span class="koboSpan" id="kobo.577.1">Unexpected behaviors in derived classes</span></h3>
<p><span class="koboSpan" id="kobo.578.1">When </span><a id="_idIndexMarker328"/><span class="koboSpan" id="kobo.579.1">derived classes override methods of the base class in ways that change the expected behavior significantly, it can lead to unexpected results when these objects are </span><span class="No-Break"><span class="koboSpan" id="kobo.580.1">used interchangeably:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.581.1">
class Bird {
public:
    virtual void fly() {
        std::cout &lt;&lt; "This bird flies" &lt;&lt; std::endl;
    }
};
class Ostrich : public Bird {
public:
    void fly() override {
        throw std::logic_error("Ostriches can't fly!");
    }
};
void make_bird_fly(Bird&amp; b) {
    b.fly();  // Expecting all birds to fly
}</span></pre>
<p><span class="koboSpan" id="kobo.582.1">Here, replacing a </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">Bird</span></strong><span class="koboSpan" id="kobo.584.1"> object with an </span><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">Ostrich</span></strong><span class="koboSpan" id="kobo.586.1"> object in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.587.1">make_bird_fly</span></strong><span class="koboSpan" id="kobo.588.1"> function leads</span><a id="_idIndexMarker329"/><span class="koboSpan" id="kobo.589.1"> to a runtime error because ostriches can’t fly, violating LSP. </span><span class="koboSpan" id="kobo.589.2">Users of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">Bird</span></strong><span class="koboSpan" id="kobo.591.1"> class expect any subclass to fly, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">Ostrich</span></strong><span class="koboSpan" id="kobo.593.1"> breaks </span><span class="No-Break"><span class="koboSpan" id="kobo.594.1">this expectation.</span></span></p>
<h3><span class="koboSpan" id="kobo.595.1">Issues with method preconditions</span></h3>
<p><span class="koboSpan" id="kobo.596.1">If a derived class</span><a id="_idIndexMarker330"/><span class="koboSpan" id="kobo.597.1"> imposes stricter preconditions on a method than those imposed by the base class, it can limit the usability of the subclass and </span><span class="No-Break"><span class="koboSpan" id="kobo.598.1">violate LSP:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.599.1">
class Payment {
public:
    virtual void pay(int amount) {
        if (amount &lt;= 0) {
            throw std::invalid_argument("Amount must be positive");
        }
        std::cout &lt;&lt; "Paying " &lt;&lt; amount &lt;&lt; std::endl;
    }
};
class CreditPayment : public Payment {
public:
    void pay(int amount) override {
        if (amount &lt; 100) {  // Stricter precondition than the base class
            throw std::invalid_argument("Minimum amount for credit payment is 100");
        }
        std::cout &lt;&lt; "Paying " &lt;&lt; amount &lt;&lt; " with credit" &lt;&lt; std::endl;
    }
};</span></pre>
<p><span class="koboSpan" id="kobo.600.1">Here, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">CreditPayment</span></strong><span class="koboSpan" id="kobo.602.1"> class cannot be used in place of </span><strong class="source-inline"><span class="koboSpan" id="kobo.603.1">Payment</span></strong><span class="koboSpan" id="kobo.604.1"> without potentially throwing </span><a id="_idIndexMarker331"/><span class="koboSpan" id="kobo.605.1">an error for amounts below 100, even though such amounts are perfectly valid for the </span><span class="No-Break"><span class="koboSpan" id="kobo.606.1">base class.</span></span></p>
<h3><span class="koboSpan" id="kobo.607.1">Solutions to LSP violations</span></h3>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.608.1">Design with LSP in mind</span></strong><span class="koboSpan" id="kobo.609.1">: When designing your class hierarchy, ensure that any subclass</span><a id="_idIndexMarker332"/><span class="koboSpan" id="kobo.610.1"> can be used in place of a parent class without altering the desirable properties of </span><span class="No-Break"><span class="koboSpan" id="kobo.611.1">the program</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.612.1">Use composition instead of inheritance</span></strong><span class="koboSpan" id="kobo.613.1">: If it doesn’t make sense for the subclass to fully adhere to the base class’s contract, use composition instead </span><span class="No-Break"><span class="koboSpan" id="kobo.614.1">of inheritance</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.615.1">Clearly define behavioral contracts</span></strong><span class="koboSpan" id="kobo.616.1">: Document and enforce the expected behavior of base classes, and ensure that all derived classes adhere strictly to these contracts without introducing tighter preconditions or </span><span class="No-Break"><span class="koboSpan" id="kobo.617.1">altering postconditions</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.618.1">By paying close attention to these principles and potential pitfalls, developers can create more robust and maintainable </span><span class="No-Break"><span class="koboSpan" id="kobo.619.1">object-oriented designs.</span></span></p>
<p><span class="koboSpan" id="kobo.620.1">While inheritance remains a valuable feature in C++, understanding when and how to use it effectively is crucial. </span><span class="koboSpan" id="kobo.620.2">The implementation detail that inheritance is akin to composition at the binary level highlights that it is fundamentally about structuring and accessing data within an object’s memory layout. </span><span class="koboSpan" id="kobo.620.3">Practitioners must carefully consider whether inheritance or composition (or a combination of both) will best serve their design goals, especially regarding system flexibility, maintainability, and the robust application of OOP principles such as LSP. </span><span class="koboSpan" id="kobo.620.4">As with many features in software development, the key lies in using the right tool for the </span><span class="No-Break"><span class="koboSpan" id="kobo.621.1">right job.</span></span></p>
<h1 id="_idParaDest-135"><a id="_idTextAnchor134"/><span class="koboSpan" id="kobo.622.1">Templates and generic programming</span></h1>
<p><span class="koboSpan" id="kobo.623.1">Templates and generic programming are pivotal features of C++ that enable the creation of flexible and reusable components. </span><span class="koboSpan" id="kobo.623.2">While this chapter offers an overview of these powerful tools, it’s important to note that the topic of templates, particularly template metaprogramming, is vast enough to fill entire books. </span><span class="koboSpan" id="kobo.623.3">For those seeking an in-depth exploration, dedicated resources on C++ templates and metaprogramming </span><span class="No-Break"><span class="koboSpan" id="kobo.624.1">are recommended.</span></span></p>
<h2 id="_idParaDest-136"><a id="_idTextAnchor135"/><span class="koboSpan" id="kobo.625.1">What are templates good for?</span></h2>
<p><span class="koboSpan" id="kobo.626.1">Templates are </span><a id="_idIndexMarker333"/><span class="koboSpan" id="kobo.627.1">particularly useful in scenarios where similar operations need to be performed on different types of data. </span><span class="koboSpan" id="kobo.627.2">They allow you to write a single piece of code that works with any type. </span><span class="koboSpan" id="kobo.627.3">The following subsections outline some common use cases </span><span class="No-Break"><span class="koboSpan" id="kobo.628.1">with examples.</span></span></p>
<h2 id="_idParaDest-137"><a id="_idTextAnchor136"/><span class="koboSpan" id="kobo.629.1">Generic algorithms</span></h2>
<p><span class="koboSpan" id="kobo.630.1">Algorithms </span><a id="_idIndexMarker334"/><span class="koboSpan" id="kobo.631.1">can operate on different types without rewriting the code for each type. </span><span class="koboSpan" id="kobo.631.2">For instance, the standard library’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.632.1">std::sort</span></strong><span class="koboSpan" id="kobo.633.1"> function can sort elements of any type as long as the elements can </span><span class="No-Break"><span class="koboSpan" id="kobo.634.1">be compared:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.635.1">
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
template &lt;typename T&gt;
void print(const std::vector&lt;T&gt;&amp; vec) {
    for (const T&amp; elem : vec) {
        std::cout &lt;&lt; elem &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
}
int main() {
    std::vector&lt;int&gt; int_vec = {3, 1, 4, 1, 5};
    std::sort(int_vec.begin(), int_vec.end());
    print(int_vec); // Outputs: 1 1 3 4 5
    std::vector&lt;std::string&gt; string_vec = {"banana", "apple", "cherry"};
    std::sort(string_vec.begin(), string_vec.end());
    print(string_vec); // Outputs: apple banana cherry
    return 0;
}</span></pre>
<h2 id="_idParaDest-138"><a id="_idTextAnchor137"/><span class="koboSpan" id="kobo.636.1">Container classes</span></h2>
<p><span class="koboSpan" id="kobo.637.1">Templates are</span><a id="_idIndexMarker335"/><span class="koboSpan" id="kobo.638.1"> heavily used in the standard library for containers such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">std::vector</span></strong><span class="koboSpan" id="kobo.640.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.641.1">std::list</span></strong><span class="koboSpan" id="kobo.642.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.643.1">std::map</span></strong><span class="koboSpan" id="kobo.644.1">, which can store elements of </span><span class="No-Break"><span class="koboSpan" id="kobo.645.1">any type:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.646.1">
#include &lt;vector&gt;
#include &lt;iostream&gt;
int main() {
    std::vector&lt;int&gt; int_vec = {1, 2, 3};
    std::vector&lt;std::string&gt; string_vec = {"hello", "world"};
    for (int val : int_vec) {
        std::cout &lt;&lt; val &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
    for (const std::string&amp; str : string_vec) {
        std::cout &lt;&lt; str &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
    return 0;
}</span></pre>
<p><span class="koboSpan" id="kobo.647.1">Without the</span><a id="_idIndexMarker336"/><span class="koboSpan" id="kobo.648.1"> usage of templates, developer’s options in using collections would be limited to creating separate classes for each type of collection (e.g., </span><strong class="source-inline"><span class="koboSpan" id="kobo.649.1">IntVector</span></strong><span class="koboSpan" id="kobo.650.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.651.1">StringVector</span></strong><span class="koboSpan" id="kobo.652.1">, etc.), or demanding the use of a common base class, which would require type casting and lose type safety, </span><span class="No-Break"><span class="koboSpan" id="kobo.653.1">for example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.654.1">
class BaseObject {};
class Vector {
public:
    void push_back(BaseObject* obj);
};</span></pre>
<p><span class="koboSpan" id="kobo.655.1">Another option is to store some </span><strong class="source-inline"><span class="koboSpan" id="kobo.656.1">void</span></strong><span class="koboSpan" id="kobo.657.1"> pointers and cast them to the desired type when retrieving them, but this approach is even more </span><span class="No-Break"><span class="koboSpan" id="kobo.658.1">error prone.</span></span></p>
<p><span class="koboSpan" id="kobo.659.1">The standard library uses templates for smart pointers such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.660.1">std::unique_ptr</span></strong><span class="koboSpan" id="kobo.661.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.662.1">std::shared_ptr</span></strong><span class="koboSpan" id="kobo.663.1">, which manage the lifetime of dynamically </span><span class="No-Break"><span class="koboSpan" id="kobo.664.1">allocated objects:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.665.1">
#include &lt;memory&gt;
#include &lt;iostream&gt;
int main() {
    std::unique_ptr&lt;int&gt; ptr = std::make_unique&lt;int&gt;(42);
    std::cout &lt;&lt; "Value: " &lt;&lt; *ptr &lt;&lt; std::endl; // Outputs: Value: 42
    std::shared_ptr&lt;int&gt; shared_ptr = std::make_shared&lt;int&gt;(100);
    std::cout &lt;&lt; "Shared Value: " &lt;&lt; *shared_ptr &lt;&lt; std::endl; // Outputs: Shared Value: 100
    return 0;
}</span></pre>
<p><span class="koboSpan" id="kobo.666.1">Templates </span><a id="_idIndexMarker337"/><span class="koboSpan" id="kobo.667.1">ensure type safety by allowing the compiler to check types during template instantiation, reducing </span><span class="No-Break"><span class="koboSpan" id="kobo.668.1">runtime errors:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.669.1">
template &lt;typename T&gt;
T add(T a, T b) {
    return a + b;
}
int main() {
    std::cout &lt;&lt; add&lt;int&gt;(5, 3) &lt;&lt; std::endl;      // Outputs: 8
    std::cout &lt;&lt; add&lt;double&gt;(2.5, 3.5) &lt;&lt; std::endl; // Outputs: 6.0
    return 0;
}</span></pre>
<h2 id="_idParaDest-139"><a id="_idTextAnchor138"/><span class="koboSpan" id="kobo.670.1">How templates work</span></h2>
<p><span class="koboSpan" id="kobo.671.1">Templates</span><a id="_idIndexMarker338"/><span class="koboSpan" id="kobo.672.1"> in C++ are not actual code but serve as blueprints for code generation. </span><span class="koboSpan" id="kobo.672.2">When a template is instantiated with a specific type, the compiler generates a concrete instance of the template with the specified type replacing the </span><span class="No-Break"><span class="koboSpan" id="kobo.673.1">template parameters.</span></span></p>
<h3><span class="koboSpan" id="kobo.674.1">Function templates</span></h3>
<p><span class="koboSpan" id="kobo.675.1">A</span><a id="_idIndexMarker339"/><span class="koboSpan" id="kobo.676.1"> function template defines a pattern for a function that can </span><a id="_idIndexMarker340"/><span class="koboSpan" id="kobo.677.1">operate on different </span><span class="No-Break"><span class="koboSpan" id="kobo.678.1">data types:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.679.1">
template &lt;typename T&gt;
T add(T a, T b) {
    return a + b;
}
int main() {
    std::cout &lt;&lt; add&lt;int&gt;(5, 3) &lt;&lt; std::endl;      // Outputs: 8
    std::cout &lt;&lt; add&lt;double&gt;(2.5, 3.5) &lt;&lt; std::endl; // Outputs: 6.0
    return 0;
}</span></pre>
<p><span class="koboSpan" id="kobo.680.1">The actual generated functions after template instantiation would be something like this (depending on </span><span class="No-Break"><span class="koboSpan" id="kobo.681.1">the compiler):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.682.1">
int addInt(int a, int b) {
    return a + b;
}
double addDouble(double a, double b) {
    return a + b;
}</span></pre>
<h3><span class="koboSpan" id="kobo.683.1">Class templates</span></h3>
<p><span class="koboSpan" id="kobo.684.1">A </span><a id="_idIndexMarker341"/><span class="koboSpan" id="kobo.685.1">class template</span><a id="_idIndexMarker342"/><span class="koboSpan" id="kobo.686.1"> defines a pattern for a class that can operate on different </span><span class="No-Break"><span class="koboSpan" id="kobo.687.1">data types:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.688.1">
template &lt;typename T&gt;
class Box {
private:
    T content;
public:
    void set_content(const T&amp; value) {
        content = value;
    }
    T get_content() const {
        return content;
    }
};
int main() {
    Box&lt;int&gt; intBox;
    intBox.set_content(123);
    std::cout &lt;&lt; intBox.get_content() &lt;&lt; std::endl; // Outputs: 123
    Box&lt;std::string&gt; stringBox;
    stringBox.set_content("Hello Templates!");
    std::cout &lt;&lt; stringBox.get_content() &lt;&lt; std::endl; // Outputs: Hello Templates!
</span><span class="koboSpan" id="kobo.688.2">    return 0;
}</span></pre>
<p><span class="koboSpan" id="kobo.689.1">The </span><a id="_idIndexMarker343"/><span class="koboSpan" id="kobo.690.1">actual generated classes after template instantiation </span><a id="_idIndexMarker344"/><span class="koboSpan" id="kobo.691.1">would be something like this (depending on </span><span class="No-Break"><span class="koboSpan" id="kobo.692.1">the compiler):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.693.1">
class BoxInt { /*Box&lt;int&gt;*/ };
class BoxString { /*Box&lt;int&gt;*/ };</span></pre>
<h1 id="_idParaDest-140"><a id="_idTextAnchor139"/><span class="koboSpan" id="kobo.694.1">How templates are instantiated</span></h1>
<p><span class="koboSpan" id="kobo.695.1">When a template is </span><a id="_idIndexMarker345"/><span class="koboSpan" id="kobo.696.1">used with a specific type, the compiler creates a new instance of the template with the specified type. </span><span class="koboSpan" id="kobo.696.2">This process is known as </span><strong class="bold"><span class="koboSpan" id="kobo.697.1">template instantiation</span></strong><span class="koboSpan" id="kobo.698.1"> and can happen implicitly </span><span class="No-Break"><span class="koboSpan" id="kobo.699.1">or explicitly:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.700.1">Implicit instantiation</span></strong><span class="koboSpan" id="kobo.701.1">: This </span><a id="_idIndexMarker346"/><span class="koboSpan" id="kobo.702.1">occurs </span><a id="_idIndexMarker347"/><span class="koboSpan" id="kobo.703.1">when the compiler encounters a use of the template with </span><span class="No-Break"><span class="koboSpan" id="kobo.704.1">specific types:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.705.1">
int main() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.706.1">
    std::cout &lt;&lt; add(5, 3) &lt;&lt; std::endl; // The compiler infers the type as int</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.707.1">
    return 0;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.708.1">
}</span></pre></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.709.1">Explicit instantiation</span></strong><span class="koboSpan" id="kobo.710.1">: The </span><a id="_idIndexMarker348"/><span class="koboSpan" id="kobo.711.1">programmer </span><a id="_idIndexMarker349"/><span class="koboSpan" id="kobo.712.1">specifies the </span><span class="No-Break"><span class="koboSpan" id="kobo.713.1">type explicitly:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.714.1">
int main() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.715.1">
    std::cout &lt;&lt; add&lt;int&gt;(5, 3) &lt;&lt; std::endl; // Explicitly specifies the type as int</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.716.1">
    return 0;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.717.1">
}</span></pre></li>
</ul>
<h1 id="_idParaDest-141"><a id="_idTextAnchor140"/><span class="koboSpan" id="kobo.718.1">A real-world example of template usage in C++</span></h1>
<p><span class="koboSpan" id="kobo.719.1">In the </span><a id="_idIndexMarker350"/><span class="koboSpan" id="kobo.720.1">realm of financial software, handling various types of assets and currencies in a flexible, type-safe, and efficient manner is crucial. </span><span class="koboSpan" id="kobo.720.2">C++ templates offer a powerful mechanism to achieve this flexibility by allowing developers to write generic and reusable code that can operate with any </span><span class="No-Break"><span class="koboSpan" id="kobo.721.1">data type.</span></span></p>
<p><span class="koboSpan" id="kobo.722.1">Imagine developing a financial system that must handle multiple currencies such as USD and EUR, and manage various assets such as stocks or bonds. </span><span class="koboSpan" id="kobo.722.2">By using templates, we can define classes that operate generically on these types without duplicating code for each specific currency or asset type. </span><span class="koboSpan" id="kobo.722.3">This approach not only reduces redundancy but also enhances the system’s scalability </span><span class="No-Break"><span class="koboSpan" id="kobo.723.1">and maintainability.</span></span></p>
<p><span class="koboSpan" id="kobo.724.1">In the following sections, we will look at a detailed example of a financial system implemented using C++ templates. </span><span class="koboSpan" id="kobo.724.2">This example will show you how to define and manipulate prices in different currencies, how to create and manage assets, and how to ensure that operations remain type safe and efficient. </span><span class="koboSpan" id="kobo.724.3">Through this example, we aim to illustrate the practical benefits of using templates in real-world C++ applications and how they can lead to cleaner, more maintainable, and more </span><span class="No-Break"><span class="koboSpan" id="kobo.725.1">robust code.</span></span></p>
<h2 id="_idParaDest-142"><a id="_idTextAnchor141"/><span class="koboSpan" id="kobo.726.1">Defining currencies</span></h2>
<p><span class="koboSpan" id="kobo.727.1">When</span><a id="_idIndexMarker351"/><span class="koboSpan" id="kobo.728.1"> designing a financial system, it’s essential to handle multiple currencies in a way that prevents errors and ensures type safety. </span><span class="koboSpan" id="kobo.728.2">Let’s start by defining the requirements and exploring various </span><span class="No-Break"><span class="koboSpan" id="kobo.729.1">design options.</span></span></p>
<p><span class="koboSpan" id="kobo.730.1">Here are </span><span class="No-Break"><span class="koboSpan" id="kobo.731.1">the requirements:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.732.1">Type safety</span></strong><span class="koboSpan" id="kobo.733.1">: Ensure that different currencies cannot be </span><span class="No-Break"><span class="koboSpan" id="kobo.734.1">mixed inadvertently</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.735.1">Scalability</span></strong><span class="koboSpan" id="kobo.736.1">: Easily add new currencies without significant </span><span class="No-Break"><span class="koboSpan" id="kobo.737.1">code duplication</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.738.1">Flexibility</span></strong><span class="koboSpan" id="kobo.739.1">: Support various operations such as addition and subtraction on prices in a </span><span class="No-Break"><span class="koboSpan" id="kobo.740.1">type-safe manner</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.741.1">Here are the</span><a id="_idIndexMarker352"/> <span class="No-Break"><span class="koboSpan" id="kobo.742.1">design options:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.743.1">Using primitive types (int, double)</span></strong><span class="koboSpan" id="kobo.744.1">: One approach is to represent currencies using primitive types such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.745.1">int</span></strong><span class="koboSpan" id="kobo.746.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.747.1">double</span></strong><span class="koboSpan" id="kobo.748.1">. </span><span class="koboSpan" id="kobo.748.2">However, this method has significant drawbacks. </span><span class="koboSpan" id="kobo.748.3">It allows for the accidental mixing of different currencies, leading to </span><span class="No-Break"><span class="koboSpan" id="kobo.749.1">incorrect calculations:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.750.1">
double usd = 100.0;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.751.1">
double eur = 90.0;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.752.1">
double total = usd + eur; // Incorrectly adds USD and EUR</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.753.1">This approach is error prone and lacks type safety. </span><span class="koboSpan" id="kobo.753.2">Please note that using </span><strong class="source-inline"><span class="koboSpan" id="kobo.754.1">double</span></strong><span class="koboSpan" id="kobo.755.1"> for currency values is generally discouraged due to precision issues in </span><span class="No-Break"><span class="koboSpan" id="kobo.756.1">floating-point arithmetic.</span></span></p></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.757.1">Inheritance from a base currency class</span></strong><span class="koboSpan" id="kobo.758.1">: Another approach is to define a base </span><strong class="source-inline"><span class="koboSpan" id="kobo.759.1">Currency</span></strong><span class="koboSpan" id="kobo.760.1"> class and inherit specific currencies from it. </span><span class="koboSpan" id="kobo.760.2">While this approach introduces some structure, it still allows for the mixing of different currencies and requires significant effort to implement each </span><span class="No-Break"><span class="koboSpan" id="kobo.761.1">new currency:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.762.1">
class Currency {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.763.1">
public:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.764.1">
    virtual std::string name() const = 0;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.765.1">
    virtual ~Currency() = default;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.766.1">
};</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.767.1">
class USD : public Currency {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.768.1">
public:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.769.1">
    std::string name() const override { return "USD"; }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.770.1">
};</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.771.1">
class Euro : public Currency {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.772.1">
public:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.773.1">
    std::string name() const override { return "EUR"; }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.774.1">
};</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.775.1">
// USD and Euro can still be mixed inadvertently</span></pre></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.776.1">Using templates for currency definition</span></strong><span class="koboSpan" id="kobo.777.1">: The most robust solution is to use templates </span><a id="_idIndexMarker353"/><span class="koboSpan" id="kobo.778.1">to define currencies. </span><span class="koboSpan" id="kobo.778.2">This approach ensures type safety by preventing the mixing of different currencies at compile time. </span><span class="koboSpan" id="kobo.778.3">Each currency is defined as a </span><strong class="source-inline"><span class="koboSpan" id="kobo.779.1">struct</span></strong><span class="koboSpan" id="kobo.780.1">, and operations are implemented </span><span class="No-Break"><span class="koboSpan" id="kobo.781.1">using templates:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.782.1">
struct Usd {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.783.1">
    static const std::string &amp;name() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.784.1">
        static std::string name = "USD";</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.785.1">
        return name;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.786.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.787.1">
};</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.788.1">
struct Euro {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.789.1">
    static const std::string &amp;name() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.790.1">
        static std::string name = "EUR";</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.791.1">
        return name;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.792.1">
    }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.793.1">
};</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.794.1">
template &lt;typename Currency&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.795.1">
class Price {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.796.1">
public:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.797.1">
    Price(int64_t amount) : _amount(amount) {}</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.798.1">
    int64_t count() const { return _amount; }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.799.1">
private:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.800.1">
    int64_t _amount;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.801.1">
};</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.802.1">
template &lt;typename Currency&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.803.1">
std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Price&lt;Currency&gt; &amp;price) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.804.1">
    os &lt;&lt; price.count() &lt;&lt; " " &lt;&lt; Currency::name();</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.805.1">
    return os;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.806.1">
}</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.807.1">
template &lt;typename Currency&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.808.1">
Price&lt;Currency&gt; operator+(const Price&lt;Currency&gt; &amp;lhs, const Price&lt;Currency&gt; &amp;rhs) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.809.1">
    return Price&lt;Currency&gt;(lhs.count() + rhs.count());</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.810.1">
}</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.811.1">
template &lt;typename Currency&gt;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.812.1">
Price&lt;Currency&gt; operator-(const Price&lt;Currency&gt; &amp;lhs, const Price&lt;Currency&gt; &amp;rhs) {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.813.1">
    return Price&lt;Currency&gt;(lhs.count() - rhs.count());</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.814.1">
}</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.815.1">
// User can define other arithmetic operations as needed</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.816.1">This </span><a id="_idIndexMarker354"/><span class="koboSpan" id="kobo.817.1">template-based approach ensures that prices in different currencies cannot </span><span class="No-Break"><span class="koboSpan" id="kobo.818.1">be mixed:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.819.1">
int main() {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.820.1">
    Price&lt;Usd&gt; usd(100);</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.821.1">
    Price&lt;Euro&gt; euro(90);</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.822.1">
    // The following line would cause a compile-time error</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.823.1">
    // source&gt;:113:27: error: no match for 'operator+' (operand types are 'Price&lt;Usd&gt;' and 'Price&lt;Euro&gt;')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.824.1">
    // Price&lt;Usd&gt; total= usd + euro;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.825.1">
    Price&lt;Usd&gt; total = usd+ Price&lt;Usd&gt;(50); // Correct usage</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.826.1">
    std::cout &lt;&lt; total&lt;&lt; std::endl; // Outputs: 150 USD</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.827.1">
    return 0;</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.828.1">
}</span></pre></li>
</ul>
<h2 id="_idParaDest-143"><a id="_idTextAnchor142"/><span class="koboSpan" id="kobo.829.1">Defining assets</span></h2>
<p><span class="koboSpan" id="kobo.830.1">Next, we</span><a id="_idIndexMarker355"/><span class="koboSpan" id="kobo.831.1"> define assets that can be priced in different currencies. </span><span class="koboSpan" id="kobo.831.2">Using templates, we can ensure that each asset is associated with the </span><span class="No-Break"><span class="koboSpan" id="kobo.832.1">correct currency:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.833.1">
template &lt;typename TickerT&gt;
class Asset;
struct Apple {
    static const std::string &amp;name() {
        static std::string name = "AAPL";
        return name;
    }
    static const std::string &amp;exchange() {
        static std::string exchange = "NASDAQ";
        return exchange;
    }
    using Asset = class Asset&lt;Apple&gt;;
    using Currency = Usd;
};
struct Mercedes {
    static const std::string &amp;name() {
        static std::string name = "MGB";
        return name;
    }
    static const std::string &amp;exchange() {
        static std::string exchange = "FRA";
        return exchange;
    }
    using Asset = class Asset&lt;Mercedes&gt;;
    using Currency = Euro;
};
template &lt;typename TickerT&gt;
class Asset {
public:
    using Ticker   = TickerT;
    using Currency = typename Ticker::Currency;
    Asset(int64_t amount, Price&lt;Currency&gt; price)
        : _amount(amount), _price(price) {}
    auto amount() const { return _amount; }
    auto price() const { return _price; }
private:
    int64_t _amount;
    Price&lt;Currency&gt; _price;
};
template &lt;typename TickerT&gt;
std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Asset&lt;TickerT&gt; &amp;asset) {
    os &lt;&lt; TickerT::name() &lt;&lt; ", amount: " &lt;&lt; asset.amount()
       &lt;&lt; ", price: " &lt;&lt; asset.price();
    return os;
}</span></pre>
<h2 id="_idParaDest-144"><a id="_idTextAnchor143"/><span class="koboSpan" id="kobo.834.1">Using the financial system</span></h2>
<p><span class="koboSpan" id="kobo.835.1">Finally, we </span><a id="_idIndexMarker356"/><span class="koboSpan" id="kobo.836.1">demonstrate how to use the defined templates to manage assets </span><span class="No-Break"><span class="koboSpan" id="kobo.837.1">and prices:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.838.1">
int main() {
    Price&lt;Usd&gt; usd_price(100);
    usd_price = usd_price + Price&lt;Usd&gt;(1);
    std::cout &lt;&lt; usd_price &lt;&lt; std::endl; // Outputs: 101 USD
    Asset&lt;Apple&gt; apple{10, Price&lt;Usd&gt;(100)};
    Asset&lt;Mercedes&gt; mercedes{5, Price&lt;Euro&gt;(100)};
    std::cout &lt;&lt; apple &lt;&lt; std::endl; // Outputs: AAPL, amount: 10, price: 100 USD
    std::cout &lt;&lt; mercedes &lt;&lt; std::endl; // Outputs: MGB, amount: 5, price: 100 EUR
    return 0;
}</span></pre>
<h2 id="_idParaDest-145"><a id="_idTextAnchor144"/><span class="koboSpan" id="kobo.839.1">Disadvantages of using templates in system design</span></h2>
<p><span class="koboSpan" id="kobo.840.1">While</span><a id="_idIndexMarker357"/><span class="koboSpan" id="kobo.841.1"> templates in C++ offer a powerful and flexible way to create type-safe, generic components, there are several disadvantages to this approach. </span><span class="koboSpan" id="kobo.841.2">These disadvantages are particularly relevant in the context of a financial system that deals with multiple currencies and assets. </span><span class="koboSpan" id="kobo.841.3">Understanding these potential drawbacks is essential when deciding to use templates in </span><span class="No-Break"><span class="koboSpan" id="kobo.842.1">your design.</span></span></p>
<h3><span class="koboSpan" id="kobo.843.1">Code bloat</span></h3>
<p><span class="koboSpan" id="kobo.844.1">Templates can lead to code bloat, which is the increase in binary size due to the generation of multiple template instantiations. </span><span class="koboSpan" id="kobo.844.2">The compiler generates a separate version of the template code for each unique type instantiation. </span><span class="koboSpan" id="kobo.844.3">In a financial system that supports various currencies and assets, this can lead to a significant increase in the size of the </span><span class="No-Break"><span class="koboSpan" id="kobo.845.1">compiled binary.</span></span></p>
<p><span class="koboSpan" id="kobo.846.1">For example, if we have templates for </span><strong class="source-inline"><span class="koboSpan" id="kobo.847.1">Price</span></strong><span class="koboSpan" id="kobo.848.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.849.1">Asset</span></strong><span class="koboSpan" id="kobo.850.1"> instantiated with different types such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.851.1">Usd</span></strong><span class="koboSpan" id="kobo.852.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.853.1">Euro</span></strong><span class="koboSpan" id="kobo.854.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.855.1">Apple</span></strong><span class="koboSpan" id="kobo.856.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.857.1">Mercedes</span></strong><span class="koboSpan" id="kobo.858.1">, the compiler generates separate code for </span><span class="No-Break"><span class="koboSpan" id="kobo.859.1">each combination:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.860.1">
Price&lt;Usd&gt; usdPrice(100);
Price&lt;Euro&gt; euroPrice(90);
Asset&lt;Apple&gt; appleAsset(10, Price&lt;Usd&gt;(100));
Asset&lt;Mercedes&gt; mercedesAsset(5, Price&lt;Euro&gt;(100));</span></pre>
<p><span class="koboSpan" id="kobo.861.1">Each of these instantiations results in additional code, contributing to the overall binary size. </span><span class="koboSpan" id="kobo.861.2">As the number of supported currencies and assets grows, the impact of code bloat becomes more pronounced. </span><span class="koboSpan" id="kobo.861.3">Binary size can affect application performance, memory usage, and load times, especially in resource-constrained environments mostly due to lower </span><span class="No-Break"><span class="koboSpan" id="kobo.862.1">cache efficiency.</span></span></p>
<h3><span class="koboSpan" id="kobo.863.1">Increased compilation times</span></h3>
<p><span class="koboSpan" id="kobo.864.1">Templates</span><a id="_idIndexMarker358"/><span class="koboSpan" id="kobo.865.1"> can significantly increase the compilation time of a project. </span><span class="koboSpan" id="kobo.865.2">Each instantiation of a template with a new type results in the generation of new code by the compiler. </span><span class="koboSpan" id="kobo.865.3">In a financial system that supports hundreds of currencies and assets from various countries and stock exchanges, the compiler will have to instantiate all the needed combinations, leading to longer </span><span class="No-Break"><span class="koboSpan" id="kobo.866.1">build times.</span></span></p>
<p><span class="koboSpan" id="kobo.867.1">For instance, say our system supports </span><span class="No-Break"><span class="koboSpan" id="kobo.868.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.869.1">50 </span><span class="No-Break"><span class="koboSpan" id="kobo.870.1">different currencies</span></span></li>
<li><span class="koboSpan" id="kobo.871.1">10000 different asset types from various </span><span class="No-Break"><span class="koboSpan" id="kobo.872.1">stock exchanges</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.873.1">Then, the compiler will need to generate code for each </span><strong class="source-inline"><span class="koboSpan" id="kobo.874.1">Price</span></strong><span class="koboSpan" id="kobo.875.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.876.1">Asset</span></strong><span class="koboSpan" id="kobo.877.1"> combination, resulting in a substantial number of template instantiations. </span><span class="koboSpan" id="kobo.877.2">This can considerably slow down the compilation process, affecting the development workflow, and less efficient </span><span class="No-Break"><span class="koboSpan" id="kobo.878.1">feedback loop.</span></span></p>
<h3><span class="koboSpan" id="kobo.879.1">Less obvious interaction with the rest of the code</span></h3>
<p><span class="koboSpan" id="kobo.880.1">Template code can be complex and less obvious in terms of how it interacts with the rest of the code base. </span><span class="koboSpan" id="kobo.880.2">Developers who are less experienced with templates may find it challenging to understand and maintain template-heavy code. </span><span class="koboSpan" id="kobo.880.3">The syntax can be verbose, and compiler error messages can be difficult to decipher, making debugging and troubleshooting </span><span class="No-Break"><span class="koboSpan" id="kobo.881.1">more complicated.</span></span></p>
<p><span class="koboSpan" id="kobo.882.1">For example, a simple mistake in template parameters can lead to confusing </span><span class="No-Break"><span class="koboSpan" id="kobo.883.1">error messages:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.884.1">
template &lt;typename T&gt;
class Price {
    // Implementation
};
Price&lt;int&gt; price(100); // Intended to be Price&lt;Usd&gt; but mistakenly used int</span></pre>
<p><span class="koboSpan" id="kobo.885.1">In this case, the developer must understand templates and the specific error messages generated by the compiler to resolve the issue. </span><span class="koboSpan" id="kobo.885.2">This can be a barrier for less </span><span class="No-Break"><span class="koboSpan" id="kobo.886.1">experienced developers.</span></span></p>
<p><span class="koboSpan" id="kobo.887.1">C++ 20 provides </span><a id="_idIndexMarker359"/><span class="koboSpan" id="kobo.888.1">concepts to improve template error messages and constraints, which can help make template code more readable and easier to understand. </span><span class="koboSpan" id="kobo.888.2">We can create a base class called </span><strong class="source-inline"><span class="koboSpan" id="kobo.889.1">BaseCurrency</span></strong><span class="koboSpan" id="kobo.890.1"> and derive all currency classes from it. </span><span class="koboSpan" id="kobo.890.2">This way, we can ensure that all currency classes have a common interface and can be </span><span class="No-Break"><span class="koboSpan" id="kobo.891.1">used interchangeably:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.892.1">
struct BaseCurrency {
};
struct Usd : public BaseCurrency {
    static const std::string &amp;name() {
        static std::string name = "USD";
        return name;
    }
};
// Define a concept for currency classes
template&lt;class T, class U&gt;
concept Derived = std::is_base_of&lt;U, T&gt;::value;
// Make sure that template parameter is derived from BaseCurrency
template &lt;Derived&lt;BaseCurrency&gt; CurrencyT&gt;
class Price {
public:
    Price(int64_t amount) : _amount(amount) {}
    int64_t count() const { return _amount; }
private:
    int64_t _amount;
};</span></pre>
<p><span class="koboSpan" id="kobo.893.1">After these</span><a id="_idIndexMarker360"/><span class="koboSpan" id="kobo.894.1"> changes, the attempt to instantiate </span><strong class="source-inline"><span class="koboSpan" id="kobo.895.1">Price&lt;int&gt;</span></strong><span class="koboSpan" id="kobo.896.1"> will result in a compile-time error, making it clear that the type must be derived </span><span class="No-Break"><span class="koboSpan" id="kobo.897.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.898.1">BaseCurrency</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.899.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.900.1">
In function 'int main()':
error: template constraint failure for 'template&lt;class CurrencyT&gt;  requires  Derived&lt;CurrencyT, Currency&gt; class Price'
 auto p = Price&lt;int&gt;(100);
                   ^
note: constraints not satisfied
In substitution of 'template&lt;class CurrencyT&gt;  requires  Derived&lt;CurrencyT, Currency&gt; class Price [with CurrencyT = int]':</span></pre>
<p><span class="koboSpan" id="kobo.901.1">C++ versions prior to C++ 20 also provide a way to prevent unintended template instantiations by using a combination of </span><strong class="source-inline"><span class="koboSpan" id="kobo.902.1">std::enable_if</span></strong><span class="koboSpan" id="kobo.903.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.904.1">std::is_base_of</span></strong><span class="koboSpan" id="kobo.905.1"> to enforce constraints on </span><span class="No-Break"><span class="koboSpan" id="kobo.906.1">template parameters:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.907.1">
template &lt;typename CurrencyT,
          typename Unused=typename std::enable_if&lt;std::is_base_of&lt;BaseCurrency,CurrencyT&gt;::value&gt;::type&gt;
class Price {
public:
    Price(int64_t amount) : _amount(amount) {}
    int64_t count() const { return _amount; }
private:
    int64_t _amount;
};</span></pre>
<p><span class="koboSpan" id="kobo.908.1">The attempt to initialize </span><strong class="source-inline"><span class="koboSpan" id="kobo.909.1">Price&lt;int&gt;</span></strong><span class="koboSpan" id="kobo.910.1"> will now result in a compile-time error, indicating that the type must be derived from </span><strong class="source-inline"><span class="koboSpan" id="kobo.911.1">BaseCurrency</span></strong><span class="koboSpan" id="kobo.912.1">, however, the error message will be a </span><span class="No-Break"><span class="koboSpan" id="kobo.913.1">bit cryptic:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.914.1">
error: no type named 'type' in 'struct std::enable_if&lt;false, void&gt;'
auto p = Price&lt;int&gt;(100);
      |                       ^
error: template argument 2 is invalid</span></pre>
<h3><span class="koboSpan" id="kobo.915.1">Limited tool support and debugging</span></h3>
<p><span class="koboSpan" id="kobo.916.1">Debugging template code can be challenging due to limited tool support. </span><span class="koboSpan" id="kobo.916.2">Many debuggers do not handle template instantiations well, making it difficult to step through template code and inspect template parameters and instantiations. </span><span class="koboSpan" id="kobo.916.3">This can hinder the debugging process and make it harder to identify and </span><span class="No-Break"><span class="koboSpan" id="kobo.917.1">fix issues.</span></span></p>
<p><span class="koboSpan" id="kobo.918.1">For example, examining the state of a templated </span><strong class="source-inline"><span class="koboSpan" id="kobo.919.1">Price&lt;Usd&gt;</span></strong><span class="koboSpan" id="kobo.920.1"> object in a debugger might not provide clear insights into the underlying type and values, especially if the debugger does not fully support template </span><span class="No-Break"><span class="koboSpan" id="kobo.921.1">parameter inspection.</span></span></p>
<p><span class="koboSpan" id="kobo.922.1">Most autocomplete and IDE tools do not work very well with templates, because it is impossible for them to assume the type of the template parameter. </span><span class="koboSpan" id="kobo.922.2">This can make it harder to navigate and understand template-heavy </span><span class="No-Break"><span class="koboSpan" id="kobo.923.1">code bases.</span></span></p>
<h3><span class="koboSpan" id="kobo.924.1">Advanced features of templates might be hard to use</span></h3>
<p><span class="koboSpan" id="kobo.925.1">Templates in C++ provide a mechanism for writing generic and reusable code. </span><span class="koboSpan" id="kobo.925.2">However, there are situations</span><a id="_idIndexMarker361"/><span class="koboSpan" id="kobo.926.1"> where the default template behavior needs to be customized for specific types. </span><span class="koboSpan" id="kobo.926.2">This is where template specialization comes into play. </span><span class="koboSpan" id="kobo.926.3">Template specialization allows you to define a special behavior for a specific type, ensuring that the template behaves correctly for </span><span class="No-Break"><span class="koboSpan" id="kobo.927.1">that type.</span></span></p>
<h4><span class="koboSpan" id="kobo.928.1">Why use template specialization?</span></h4>
<p><span class="koboSpan" id="kobo.929.1">Template specialization</span><a id="_idIndexMarker362"/><span class="koboSpan" id="kobo.930.1"> is used when the general template implementation does not work correctly or efficiently for a particular type, or when a specific type requires a completely different implementation. </span><span class="koboSpan" id="kobo.930.2">This can happen due to various reasons, such as performance optimizations, special handling of certain data types, or compliance with </span><span class="No-Break"><span class="koboSpan" id="kobo.931.1">specific requirements.</span></span></p>
<p><span class="koboSpan" id="kobo.932.1">For example, consider a scenario where you have a general </span><strong class="source-inline"><span class="koboSpan" id="kobo.933.1">Printer</span></strong><span class="koboSpan" id="kobo.934.1"> template class that prints objects of any type. </span><span class="koboSpan" id="kobo.934.2">However, for </span><strong class="source-inline"><span class="koboSpan" id="kobo.935.1">std::string</span></strong><span class="koboSpan" id="kobo.936.1">, you might want to add quotes around the string when </span><span class="No-Break"><span class="koboSpan" id="kobo.937.1">printing it.</span></span></p>
<h4><span class="koboSpan" id="kobo.938.1">Basic template specialization example</span></h4>
<p><span class="koboSpan" id="kobo.939.1">Here is an </span><a id="_idIndexMarker363"/><span class="koboSpan" id="kobo.940.1">example of how template </span><span class="No-Break"><span class="koboSpan" id="kobo.941.1">specialization works:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.942.1">
#include &lt;iostream&gt;
#include &lt;string&gt;
// General template
template &lt;typename T&gt;
class Printer {
public:
    void print(const T&amp; value) {
        std::cout &lt;&lt; value &lt;&lt; std::endl;
    }
};
// Template specialization for std::string
template &lt;&gt;
class Printer&lt;std::string&gt; {
public:
    void print(const std::string&amp; value) {
        std::cout &lt;&lt; "\"" &lt;&lt; value &lt;&lt; "\"" &lt;&lt; std::endl;
    }
};
int main() {
    Printer&lt;int&gt; int_printer;
    int_printer.print(123); // Outputs: 123
    Printer&lt;std::string&gt; string_printer;
    string_printer.print("Hello, World!"); // Outputs: "Hello, World!" </span><span class="koboSpan" id="kobo.942.2">with quotes
    return 0;
}</span></pre>
<p><span class="koboSpan" id="kobo.943.1">In this example, the </span><a id="_idIndexMarker364"/><span class="koboSpan" id="kobo.944.1">general </span><strong class="source-inline"><span class="koboSpan" id="kobo.945.1">Printer</span></strong><span class="koboSpan" id="kobo.946.1"> template class prints any type. </span><span class="koboSpan" id="kobo.946.2">However, for </span><strong class="source-inline"><span class="koboSpan" id="kobo.947.1">std::string</span></strong><span class="koboSpan" id="kobo.948.1">, the specialized version adds quotes around the string when </span><span class="No-Break"><span class="koboSpan" id="kobo.949.1">printing it.</span></span></p>
<h4><span class="koboSpan" id="kobo.950.1">Including the specialization header</span></h4>
<p><span class="koboSpan" id="kobo.951.1">When </span><a id="_idIndexMarker365"/><span class="koboSpan" id="kobo.952.1">using template specialization, it is crucial to include the header file that contains the specialization definition. </span><span class="koboSpan" id="kobo.952.2">If the specialization header is not included, the compiler will instantiate the default version of the template, leading to </span><span class="No-Break"><span class="koboSpan" id="kobo.953.1">incorrect behavior.</span></span></p>
<p><span class="koboSpan" id="kobo.954.1">For example, consider the </span><span class="No-Break"><span class="koboSpan" id="kobo.955.1">following files:</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.956.1">printer.h</span></strong><span class="koboSpan" id="kobo.957.1"> (General </span><span class="No-Break"><span class="koboSpan" id="kobo.958.1">template definition):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.959.1">
#ifndef PRINTER_H
#define PRINTER_H
#include &lt;iostream&gt;
template &lt;typename T&gt;
class Printer {
public:
    void print(const T&amp; value) {
        std::cout &lt;&lt; value &lt;&lt; std::endl;
    }
};
#endif // PRINTER_H</span></pre>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.960.1">printer_string.h</span></strong><span class="koboSpan" id="kobo.961.1"> (Template specialization </span><span class="No-Break"><span class="koboSpan" id="kobo.962.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.963.1">std::string</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.964.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.965.1">
#ifndef PRINTER_STRING_H
#define PRINTER_STRING_H
#include "printer.h"
#include &lt;string&gt;
template &lt;&gt;
class Printer&lt;std::string&gt; {
public:
    void print(const std::string&amp; value) {
        std::cout &lt;&lt; "\"" &lt;&lt; value &lt;&lt; "\"" &lt;&lt; std::endl;
    }
};
#endif // PRINTER_STRING_H</span></pre>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.966.1">main.cpp</span></strong><span class="koboSpan" id="kobo.967.1"> (Using the template </span><span class="No-Break"><span class="koboSpan" id="kobo.968.1">and specialization):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.969.1">
#include "printer.h"
// #include "printer_string.h" // Uncomment this line to use the specialization
int main() {
    Printer&lt;int&gt; int_printer;
    int_printer.print(123); // Outputs: 123
    Printer&lt;std::string&gt; string_printer;
    string_printer.print("Hello, World!"); // Outputs: Hello, World! </span><span class="koboSpan" id="kobo.969.2">without quotes if the header is not included
    return 0;
}</span></pre>
<p><span class="koboSpan" id="kobo.970.1">In this setup, if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.971.1">printer_string.h</span></strong><span class="koboSpan" id="kobo.972.1"> header is not included in </span><strong class="source-inline"><span class="koboSpan" id="kobo.973.1">main.cpp</span></strong><span class="koboSpan" id="kobo.974.1">, the compiler will use the default </span><strong class="source-inline"><span class="koboSpan" id="kobo.975.1">Printer</span></strong><span class="koboSpan" id="kobo.976.1"> template for </span><strong class="source-inline"><span class="koboSpan" id="kobo.977.1">std::string</span></strong><span class="koboSpan" id="kobo.978.1">, resulting in incorrect behavior (printing the string </span><span class="No-Break"><span class="koboSpan" id="kobo.979.1">without quotes).</span></span></p>
<p><span class="koboSpan" id="kobo.980.1">Templates</span><a id="_idIndexMarker366"/><span class="koboSpan" id="kobo.981.1"> are a crucial part of the C++ programming language, offering powerful capabilities for creating generic, reusable, and type-safe code. </span><span class="koboSpan" id="kobo.981.2">They are indispensable in various scenarios, such as developing generic algorithms, container classes, smart pointers, and other utilities that need to work seamlessly with multiple data types. </span><span class="koboSpan" id="kobo.981.3">Templates enable developers to write flexible and efficient code, ensuring that the same functionality can be applied to different types </span><span class="No-Break"><span class="koboSpan" id="kobo.982.1">without duplication.</span></span></p>
<p><span class="koboSpan" id="kobo.983.1">However, the power of templates does not come without cost. </span><span class="koboSpan" id="kobo.983.2">The use of templates can lead to increased compilation times and code bloat, especially in systems that support a wide range of types and combinations. </span><span class="koboSpan" id="kobo.983.3">The syntax and resulting error messages can be complex and difficult to understand, posing a challenge for less experienced developers. </span><span class="koboSpan" id="kobo.983.4">Additionally, debugging template-heavy code can be cumbersome due to limited tool support and the intricate nature of </span><span class="No-Break"><span class="koboSpan" id="kobo.984.1">template instantiations.</span></span></p>
<p><span class="koboSpan" id="kobo.985.1">Moreover, templates can introduce less obvious interactions with the rest of the code base, which might cause issues if not managed properly. </span><span class="koboSpan" id="kobo.985.2">Developers must also be aware of advanced features, such as template specialization, which require careful inclusion of specialized headers to avoid </span><span class="No-Break"><span class="koboSpan" id="kobo.986.1">incorrect behavior.</span></span></p>
<p><span class="koboSpan" id="kobo.987.1">Given these caveats, it is essential for developers to think carefully before incorporating templates into their projects. </span><span class="koboSpan" id="kobo.987.2">While they provide significant benefits, the potential drawbacks necessitate a thoughtful approach to ensure that the advantages outweigh the complexities. </span><span class="koboSpan" id="kobo.987.3">Proper understanding and judicious use of templates can lead to more robust, maintainable, and efficient </span><span class="No-Break"><span class="koboSpan" id="kobo.988.1">C++ applications.</span></span></p>
<h1 id="_idParaDest-146"><a id="_idTextAnchor145"/><span class="koboSpan" id="kobo.989.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.990.1">In this chapter, we explored the intricacies of advanced C++ programming, focusing on class design, inheritance, and templates. </span><span class="koboSpan" id="kobo.990.2">We began with the principles of effective class design, emphasizing the importance of encapsulating the minimum necessary functionality and data to achieve better modularity and maintainability. </span><span class="koboSpan" id="kobo.990.3">Through practical examples, we highlighted both good and bad design practices. </span><span class="koboSpan" id="kobo.990.4">Moving on to inheritance, we examined its benefits, such as code reuse, hierarchical structuring, and polymorphism, while also addressing its drawbacks, including tight coupling, complex hierarchies, and potential violations of the LSP. </span><span class="koboSpan" id="kobo.990.5">We provided guidance on when to use inheritance and when to consider alternatives such as composition. </span><span class="koboSpan" id="kobo.990.6">In the section on templates, we delved into their role in enabling generic programming, allowing for flexible and reusable components that work with any data type. </span><span class="koboSpan" id="kobo.990.7">We discussed the advantages of templates, such as code reusability, type safety, and performance optimization, but also pointed out their disadvantages, including increased compilation times, code bloat, and the complexity of understanding and debugging template-heavy code. </span><span class="koboSpan" id="kobo.990.8">Throughout these discussions, we underscored the need for careful consideration and understanding when utilizing these powerful features to ensure robust and maintainable C++ applications. </span><span class="koboSpan" id="kobo.990.9">In the next chapter, we will shift our focus to API design, exploring best practices for creating clear, efficient, and user-friendly interfaces </span><span class="No-Break"><span class="koboSpan" id="kobo.991.1">in C++.</span></span></p>
</div>
</body></html>