<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-114"><a id="_idTextAnchor113"/>7</h1>
<h1 id="_idParaDest-115"><a id="_idTextAnchor114"/>Classes, Objects, and OOP in C++</h1>
<p>In this chapter, we delve into the sophisticated realm of classes, objects, and <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>) in C++. Tailored <a id="_idIndexMarker265"/>for the advanced C++ practitioner, our focus will be on elevating your understanding of class design, method implementation, inheritance, and template usage, steering clear of introductory explanations of these concepts. Our goal is to enhance your ability to construct robust and efficient software architectures using advanced object-oriented techniques.</p>
<p>The discussion begins by examining the intricate considerations necessary when defining classes, guiding you through the decision-making process to determine the best candidates for class encapsulation. This includes distinguishing situations where a simpler data structure, such as a struct, might be more appropriate, thereby optimizing both performance and readability.</p>
<p>Further, we explore the design of methods within classes—highlighting various types of methods, such as accessors, mutators, and factory methods, and establishing conventions that promote code clarity and maintainability. Special attention is given to advanced method design practices, including const correctness and visibility scopes, which are pivotal for securing and optimizing access to class data.</p>
<p>Inheritance, a cornerstone of OOP, is scrutinized not only for its benefits but also its liabilities. To provide a balanced perspective, we present alternatives such as composition and interface segregation that might better serve your design goals in certain scenarios. This nuanced discussion aims to equip you with the discernment necessary to choose the best inheritance strategy or its alternatives, depending on the specific requirements and constraints of your projects.</p>
<p>Expanding the discussion to generic programming, we delve into sophisticated template usage, which includes advanced techniques such as template metaprogramming. This section aims to demonstrate how templates can be leveraged to create highly reusable and efficient code. Additionally, we will touch upon the design of APIs using OOP principles, emphasizing how well-crafted interfaces can significantly enhance the usability and longevity of software components.</p>
<p>Each topic is punctuated with practical examples and case studies drawn from real-world applications, illustrating how these advanced techniques are applied in modern software development. By the end of this chapter, you should possess a deeper understanding of how to utilize OOP features in C++ to craft elegant, efficient, and scalable software architectures.</p>
<h1 id="_idParaDest-116"><a id="_idTextAnchor115"/>Good candidates for classes</h1>
<p>Identifying <a id="_idIndexMarker266"/>good <a id="_idIndexMarker267"/>candidates for classes in OOP involves looking for entities that naturally encapsulate both data and behavior.</p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor116"/>Cohesion</h2>
<p>A class <a id="_idIndexMarker268"/>should represent a set of functionalities that are tightly related to each other. This means all the methods and data in the class are directly related to the specific functionalities it provides. For example, a <code>Timer</code> class is a good candidate because it encapsulates properties and methods related to timing (start, stop, reset times), maintaining high cohesion.</p>
<h2 id="_idParaDest-118"><a id="_idTextAnchor117"/>Encapsulation</h2>
<p>Entities<a id="_idIndexMarker269"/> that have attributes and behaviors that should be shielded from outside interference or misuse can be encapsulated in a class.</p>
<p>A <code>BankAccount</code> class encapsulates the balance (attribute) and behaviors such as <code>deposit</code>, <code>withdraw</code>, and <code>transfer</code>, ensuring that balance manipulations are done only through controlled and safe operations.</p>
<h2 id="_idParaDest-119"><a id="_idTextAnchor118"/>Reusability</h2>
<p>Classes<a id="_idIndexMarker270"/> should be designed to be reused across different parts of a program or even in different programs.</p>
<p>A <code>DatabaseConnection</code> class that manages database connections can be reused in multiple applications that require database interactions, handling connection, disconnection, and error management.</p>
<h2 id="_idParaDest-120"><a id="_idTextAnchor119"/>Abstraction</h2>
<p>A class<a id="_idIndexMarker271"/> should provide a simplified interface by hiding complex logic from the user, representing a higher level of abstraction. For example, the standard library has classes such as <code>std::vector</code> that abstract the complexities of dynamic arrays, providing a simple interface for array operations.</p>
<h2 id="_idParaDest-121"><a id="_idTextAnchor120"/>Real-world entities</h2>
<p>Classes <a id="_idIndexMarker272"/>often represent objects from the real world that are relevant to the system being modeled.</p>
<p>In a flight reservation system, classes such as <code>Flight</code>, <code>Passenger</code>, and <code>Ticket</code> are good candidates because they directly represent real-world objects with clear attributes and behaviors.</p>
<h2 id="_idParaDest-122"><a id="_idTextAnchor121"/>Manage complexity</h2>
<p>Classes <a id="_idIndexMarker273"/>should help in managing complexity by breaking down large problems into smaller, more manageable parts.</p>
<p>Here is an example – in graphic editing software, a <code>GraphicObject</code> class might serve as a base class for more specific graphic objects such as <code>Circle</code>, <code>Rectangle</code>, and <code>Polygon</code>, organizing graphic properties and functionalities systematically.</p>
<h2 id="_idParaDest-123"><a id="_idTextAnchor122"/>Minimizing class responsibilities through encapsulation</h2>
<p>Encapsulation <a id="_idIndexMarker274"/>is a fundamental concept in OOP that involves bundling <a id="_idIndexMarker275"/>the data (attributes) and the methods (functions) that operate on the data into a single unit or class. It not only hides the internal state of the object from the outside but also modularizes its behavior, making the software easier to manage and extend. However, how much functionality and data a class should encapsulate can significantly affect the maintainability and scalability of your application.</p>
<h3>Over-encapsulation in classes – a common pitfall</h3>
<p>In<a id="_idIndexMarker276"/> practice, encapsulating too much functionality and data within a single class is a common mistake that can lead to several issues. This often results in a <strong class="bold">god object</strong> – a class that controls too many different parts of the application, doing too much work on its own. Such classes are typically hard to understand, difficult to maintain, and problematic to test.</p>
<p>Let’s look at an example of a badly encapsulated <code>Car</code> class.</p>
<p>Consider the following example of a <code>Car</code> class that attempts to manage not only the car’s basic properties but also detailed aspects of its internal systems such as the engine, transmission, and entertainment system:</p>
<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;string&gt;
class Car {
private:
    std::string _model;
    double _speed;
    double _fuel_level;
    int _gear;
    bool _entertainment_system_on;
public:
    Car(const std::string&amp; model) : _model(model), _speed(0), _fuel_level(50), _gear(1), _entertainment_system_on(false) {}
    void accelerate() {
        if (_fuel_level &gt; 0) {
            _speed += 10;
            _fuel_level -= 5;
            std::cout &lt;&lt; "Accelerating. Current speed: " &lt;&lt; _speed &lt;&lt; " km/h, Fuel level: " &lt;&lt; _fuel_level &lt;&lt; " liters" &lt;&lt; std::endl;
        } else {
            std::cout &lt;&lt; "Not enough fuel." &lt;&lt; std::endl;
        }
    }
    void change_gear(int new_gear) {
        _gear = new_gear;
        std::cout &lt;&lt; "Gear changed to: " &lt;&lt; _gear &lt;&lt; std::endl;
    }
    void toggle_entertainment_system() {
        _entertainment_system_on = !_entertainment_system_on;
        std::cout &lt;&lt; "Entertainment System is now " &lt;&lt; (_entertainment_system_on ? "on" : "off") &lt;&lt; std::endl;
    }
    void refuel(double amount) {
        _fuel_level += amount;
        std::cout &lt;&lt; "Refueling. Current fuel level: " &lt;&lt; _fuel_level &lt;&lt; " liters" &lt;&lt; std::endl;
    }
};</pre>
<p>This <code>Car</code> class is<a id="_idIndexMarker277"/> problematic because it tries to manage too many aspects of the car’s functionality, which are better handled by specialized components.</p>
<h3>Proper encapsulation using composition</h3>
<p>A better approach<a id="_idIndexMarker278"/> is to use composition to delegate responsibilities to other classes, each handling a specific part of the system’s functionality. This not only adheres to the Single Responsibility Principle but also makes the system more modular and easier to maintain.</p>
<p>Here is an example of a well-designed <code>Car</code> class using composition:</p>
<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;string&gt;
class Engine {
private:
    double _fuel_level;
public:
    Engine() : _fuel_level(50) {}
    void consume_fuel(double amount) {
        _fuel_level -= amount;
        std::cout &lt;&lt; "Consuming fuel. Current fuel level: " &lt;&lt; _fuel_level &lt;&lt; " liters" &lt;&lt; std::endl;
    }
    void refuel(double amount) {
        _fuel_level += amount;
        std::cout &lt;&lt; "Engine refueled. Current fuel level: " &lt;&lt; _fuel_level &lt;&lt; " liters" &lt;&lt; std::endl;
    }
    double get_fuel_level() const {
        return _fuel_level;
    }
};
class Transmission {
private:
    int _gear;
public:
    Transmission() : _gear(1) {}
    void change_gear(int new_gear) {
        _gear = new_gear;
        std::cout &lt;&lt; "Transmission: Gear changed to " &lt;&lt; _gear &lt;&lt; std::endl;
    }
};
class EntertainmentSystem {
private:
    bool _is_on;
public:
    EntertainmentSystem() : _is_on(false) {}
    void toggle() {
        _is_on = !_is_on;
        std::cout &lt;&lt; "Entertainment System is now " &lt;&lt; (_is_on ? "on" : "off") &lt;&lt; std::endl;
    }
};
class Car {
private:
    std::string _model;
    double _speed;
    Engine _engine;
    Transmission _transmission;
    EntertainmentSystem _entertainment_system;
public:
    Car(const std::string&amp; model) : _model(model), _speed(0) {}
    void accelerate() {
        if (_engine.get_fuel_level() &gt; 0) {
            _speed += 10;
            _engine.consume_f
uel(5);
            std::cout &lt;&lt; "Car accelerating. Current speed: " &lt;&lt; _speed &lt;&lt; " km/h" &lt;&lt; std::endl;
        } else {
            std::cout &lt;&lt; "Not enough fuel to accelerate." &lt;&lt; std::endl;
        }
    }
    void change_gear(int gear) {
        _transmission.change_gear(gear);
    }
    void toggle_entertainment_system() {
        _entertainment_system.toggle();
    }
    void refuel(double amount) {
        _engine.refuel(amount);
    }
};</pre>
<p>In this refined design, the <code>Car</code> class acts as a coordinator among its components rather than <a id="_idIndexMarker279"/>directly managing every detail. Each subsystem – engine, transmission, and entertainment system – handles its own state and behavior, leading to a design that is easier to maintain, test, and extend. This example showcases how appropriate encapsulation and composition can significantly enhance the structure and quality of object-oriented software.</p>
<h2 id="_idParaDest-124"><a id="_idTextAnchor123"/>Usage of structs and classes in C++</h2>
<p>In C++, both structs and classes are used to define user-defined types that can contain data and functions. The primary difference between them lies in their default access levels: members of a class are private by default, while members of a struct are public. This distinction subtly influences their typical uses in C++ programming.</p>
<h3>Structs – ideal for passive data structures</h3>
<p>Structs in C++ are<a id="_idIndexMarker280"/> particularly suited for<a id="_idIndexMarker281"/> creating passive data structures where the primary purpose is to store data without encapsulating too much behavior. Due to their public-by-default nature, structs are often used when you want to allow direct access to the data members, which can simplify code and reduce the need for additional functions to manipulate data.</p>
<p>The following list outlines the instances when you should use structs:</p>
<ul>
<li><strong class="bold">Data objects</strong>: Structs <a id="_idIndexMarker282"/>are perfect for creating <strong class="bold">plain old data</strong> (<strong class="bold">POD</strong>) structures. These<a id="_idIndexMarker283"/> are simple objects that primarily hold data and have little or no functionality (methods). For example, structs are often used to represent coordinates in space, RGB color values, or settings configurations where direct access to data fields is more convenient than going through getters and setters:<pre class="source-code">
struct Color {</pre><pre class="source-code">
    int red = 0;</pre><pre class="source-code">
    int green = 0;</pre><pre class="source-code">
    int blue = 0;</pre><pre class="source-code">
};</pre><pre class="source-code">
struct Point {</pre><pre class="source-code">
    double x = 0.0;</pre><pre class="source-code">
    double y = 0.0;</pre><pre class="source-code">
    double z = 0.0;</pre><pre class="source-code">
};</pre><pre class="source-code">
Fortunately, C++ 11 and C++ 20 provide aggregate initialization and designated initializers, making it easier to initialize structs with default values.</pre><pre class="source-code">
// C++ 11</pre><pre class="source-code">
   auto point = Point {1.1, 2.2, 3.3};</pre><pre class="source-code">
// C++ 20</pre><pre class="source-code">
   auto point2 = Point {.x = 1.1, .y = 2.2, .z = 3.3};</pre><p class="list-inset">If C++ 20 is not <a id="_idIndexMarker284"/>available for your project, you can utilize C99-designated initializers to achieve a similar effect:</p><pre class="source-code">
   auto point3 = Point {.x = 1.1, .y = 2.2, .z = 3.3};</pre></li>
<li><strong class="bold">Interoperability</strong>: Structs <a id="_idIndexMarker285"/>are useful in interfacing with code in C or in systems where data alignment and layout are critical. They ensure compatibility and performance in low-level operations, such as hardware interfacing or network communication.</li>
<li><strong class="bold">Lightweight containers</strong>: When<a id="_idIndexMarker286"/> you need a lightweight container to group together a few variables, structs provide a more transparent and less cumbersome way than classes. They are ideal for small aggregations where encapsulation isn’t a primary concern.</li>
</ul>
<h3>Classes – encapsulating complexity</h3>
<p>Classes are the <a id="_idIndexMarker287"/>backbone of C++ OOP and are used to encapsulate data and behavior into a single entity. The private-by-default access <a id="_idIndexMarker288"/>specifier encourages the hiding of internal state and implementation details, promoting a more rigorous design that follows encapsulation and abstraction principles.</p>
<p>The following list explains when you should use classes:</p>
<ul>
<li><strong class="bold">Complex systems</strong>: For<a id="_idIndexMarker289"/> components that involve complex data manipulations, state management, and interface control, classes are the preferred choice. They provide <a id="_idIndexMarker290"/>mechanisms for data protection and interface abstraction, which are crucial for maintaining the integrity and stability of software systems:<pre class="source-code">
class Car {</pre><pre class="source-code">
private:</pre><pre class="source-code">
    int speed;</pre><pre class="source-code">
    double fuel_level;</pre><pre class="source-code">
public:</pre><pre class="source-code">
    void accelerate();</pre><pre class="source-code">
    void brake();</pre><pre class="source-code">
    void refuel(double amount);</pre><pre class="source-code">
};</pre></li>
<li><strong class="bold">Behavior encapsulation</strong>: Classes are ideal when the functionality (methods) is as important as <a id="_idIndexMarker291"/>the data. Encapsulating behaviors with data into classes allows for more maintainable and error-free code, as operations on the data are tightly controlled and clearly defined.</li>
<li><strong class="bold">Inheritance and polymorphism</strong>: Classes support <a id="_idIndexMarker292"/>inheritance and polymorphism, enabling <a id="_idIndexMarker293"/>the creation of complex object hierarchies that can be extended and modified dynamically. This is essential in many software design patterns and advanced system architectures.</li>
</ul>
<p>Choosing between a struct and a class in C++ should be guided by the intended use: structs for simple, transparent data containers where direct data access is acceptable or necessary, and classes for more complex systems where encapsulation, behavior, and interface control are required. Understanding and utilizing the strengths of each can lead to cleaner, more efficient, and scalable code.</p>
<h2 id="_idParaDest-125"><a id="_idTextAnchor124"/>Common method types in classes – getters and setters</h2>
<p>In OOP, particularly<a id="_idIndexMarker294"/> in languages such as Java, <strong class="bold">getters</strong> and <strong class="bold">setters</strong> are standard methods that serve as the primary interface<a id="_idIndexMarker295"/> for <a id="_idIndexMarker296"/>accessing and modifying the private data members of a class. These methods provide controlled access to an object’s properties, adhering to the encapsulation principle, which is a cornerstone of effective object-oriented design.</p>
<h3>Purpose and conventions of getters and setters</h3>
<p>Getters (also known as accessors) are<a id="_idIndexMarker297"/> methods used to retrieve the value of a private field. They do not modify the data. Setters (also known as mutators) are methods<a id="_idIndexMarker298"/> that allow the modification of private fields based on the input they receive. These methods enable the internal state of an object to remain consistent and valid by potentially enforcing<a id="_idIndexMarker299"/> constraints or conditions when data is set.</p>
<p>Here are the conventions of<a id="_idIndexMarker300"/> getters and setters:</p>
<ul>
<li><code>x</code>, is named <code>get_x()</code>, and the setter is named <code>set_x(value)</code>. This naming convention is almost universal in Java and is commonly adopted in other programming languages that support class-based OOP.</li>
<li><strong class="bold">Return types and parameters</strong>: A getter for a property returns the same type as the property itself and takes no parameters, whereas a setter returns void and takes a parameter of the same type as the property it sets.</li>
</ul>
<p>Here is an example of this in C++:</p>
<pre class="source-code">
class Person {
private:
    std::string _name;
    int _age;
public:
    // Getter for the name property
    std::string get_name() const { return _name; }
    // Setter for the name property
    void set_name(const std::string&amp; name) { _name = name; }
    // Getter for the age property
    int get_age() const { return _age; }
    // Setter for the age property
    void set_age(int age) {
        if (age &gt;= 0) { // validate the age
            _age = age;
        }
    }
};</pre>
<h3>Usefulness and recommendations</h3>
<p><strong class="bold">Controlled access and validation</strong>: Getters and setters encapsulate the fields of a class, providing controlled access and validation logic. This helps to maintain the integrity of the data, ensuring that no invalid or inappropriate values are set.</p>
<p><strong class="bold">Flexibility</strong>: By using <a id="_idIndexMarker301"/>getters and setters, developers can change the<a id="_idIndexMarker302"/> underlying implementation of how the data is stored and retrieved without changing the external interface of the class. This can be particularly useful in maintaining backward compatibility or when the data representation needs to be changed for optimization.</p>
<p><strong class="bold">Consistency</strong>: These methods can enforce rules that need to be maintained consistently throughout an object’s life cycle. For example, ensuring that a field never holds a null value or adheres to a specific format.</p>
<h3>When to use getters and setters, and when not to</h3>
<p>The rule of thumb is to use getters and setters in classes where encapsulation, business logic, or inheritance complexities are present. For example, for the <code>Car</code> and <code>Engine</code> classes with relatively complex logic, getters and setters are essential to maintain the integrity of the data and ensure that the system functions correctly. On the other hand, for a simple data structure such as <code>Point</code> or <code>Color</code>, where the primary purpose is to hold data without much behavior, using a struct with public data members might be more appropriate. Note that if the struct is a part of a library or API, it might be beneficial to provide getters and setters for future extensibility.</p>
<p>This nuanced approach allows developers to balance between control and simplicity, choosing the most appropriate tool for the specific requirements of their software components.</p>
<h1 id="_idParaDest-126"><a id="_idTextAnchor125"/>Inheritance in C++</h1>
<p>Inheritance and <a id="_idIndexMarker303"/>composition are two fundamental OOP concepts that enable the creation of complex and reusable software designs in C++. They facilitate code reuse and help in modeling real-world relationships, though they operate differently.</p>
<p>Inheritance allows one class, known as the derived or subclass, to inherit properties and behaviors from another class, the base or superclass. This enables the derived class to reuse the code in the base class while extending or overriding its functionality. For instance, consider a <code>BaseSocket</code> class and its derived classes, <code>TcpSocket</code> and <code>UdpSocket</code>. The derived classes inherit the basic functionality of <code>BaseSocket</code> and add their specific<a id="_idIndexMarker304"/> implementations:</p>
<pre class="source-code">
class BaseSocket {
public:
    virtual ssize_t send(const std::vector&lt;uint8_t&gt;&amp; data) = 0;
    virtual ~BaseSocket() = default;
};
class TcpSocket : public BaseSocket {
public:
    ssize_t send(const std::vector&lt;uint8_t&gt;&amp; data) override {
        // Implement TCP-specific send logic here
    }
};
class UdpSocket : public BaseSocket {
public:
    ssize_t send(const std::vector&lt;uint8_t&gt;&amp; data) override {
        // Implement UDP-specific send logic here
    }
};</pre>
<p>In this example, the <code>TcpSocket</code> and <code>UdpSocket</code> classes inherit from <code>BaseSocket</code>, demonstrating how inheritance promotes code reuse and establishes an “is-a” relationship. Inheritance also supports polymorphism, allowing objects of the derived class to be treated as instances of the base class, enabling dynamic method binding.</p>
<p>Composition, on<a id="_idIndexMarker305"/> the other hand, involves creating classes by including objects of other classes. Instead of inheriting from a base class, a class is composed of one or more objects from other classes, which are used to achieve the desired functionality. This represents a “has-a” relationship. For example, consider a <code>CommunicationChannel</code> class that can own <code>BaseSocket</code>. The <code>CommunicationChannel</code> class uses the <code>BaseSocket</code> object to implement its communication functionality, demonstrating composition:</p>
<pre class="source-code">
class CommunicationChannel {
public:
    CommunicationChannel(std::unique_ptr&lt;BaseSocket&gt; sock) : _socket(sock) {}
    bool transmit(const std::vector&lt;uint8_t&gt;&amp; data) {
        size_t total_sent = 0;
        size_t data_size = data.size();
        while (total_sent &lt; data_size) {
            ssize_t bytesSent = _socket-&gt;send({data.begin() + total_sent, data.end()});
            if (bytesSent &lt; 0) {
                std::cerr &lt;&lt; "Error sending data." &lt;&lt; std::endl;
                return false;
            }
            total_sent += bytesSent;
        }
        std::cout &lt;&lt; "Communication channel transmitted " &lt;&lt; total_sent &lt;&lt; " bytes." &lt;&lt; std::endl;
        return true;
    }
private:
    std::unique_ptr&lt;BaseSocket&gt; _socket;
};
int main() {
    TcpSocket tcp;
    CommunicationChannel channel(std::make_unique&lt;TcpSocket&gt;());
    std::vector&lt;uint8_t&gt; data = {1, 2, 3, 4, 5};
    if (channel.transmit(data)) {
        std::cout &lt;&lt; "Data transmitted successfully." &lt;&lt; std::endl;
    } else {
        std::cerr &lt;&lt; "Data transmission failed." &lt;&lt; std::endl;
    }
    return 0;
}</pre>
<p>In this<a id="_idIndexMarker306"/> example, the <code>CommunicationChannel</code> class contains a <code>BaseSocket</code> object and uses it to implement its functionality. The <code>transmit</code> method sends data in chunks until all data is sent, checking for errors (when the return value is less than <code>0</code>). This demonstrates how composition offers flexibility, allowing objects to be dynamically assembled at runtime. It also promotes better encapsulation by containing objects and exposing only necessary interfaces, thereby avoiding tight coupling between classes and making the code more modular and easier to maintain.</p>
<p>In summary, both<a id="_idIndexMarker307"/> inheritance and composition are essential tools in C++ for creating reusable and maintainable code. Inheritance is suitable for scenarios with a clear hierarchical relationship and where polymorphism is needed, while composition is ideal for assembling complex behaviors from simpler components, offering flexibility and better encapsulation. Understanding when to use each approach is key to effective object-oriented design.</p>
<h2 id="_idParaDest-127"><a id="_idTextAnchor126"/>Evolution of inheritance in C++</h2>
<p>Originally, inheritance <a id="_idIndexMarker308"/>was seen as a powerful tool for reducing code duplication and enhancing the expressiveness of code. It allowed for the creation of a derived class that inherits properties and behavior from a base class. However, as the use of C++ grew in complex systems, the limitations of inheritance as a one-size-fits-all solution became apparent.</p>
<h2 id="_idParaDest-128"><a id="_idTextAnchor127"/>Implementation of inheritance at the binary level</h2>
<p>Interestingly, on<a id="_idIndexMarker309"/> a binary level, inheritance in C++ is implemented similarly to composition. Essentially, the derived class contains an instance of the base class within its structure. This can be visualized in a simplified ASCII diagram:</p>
<pre class="source-code">
+-------------------+
|   Derived Class   |
|-------------------|
|  Base Class Part  | &lt;- Base class subobject
|-------------------|
| Derived Class Data| &lt;- Additional data members of the derived class
+-------------------+</pre>
<p>In this layout, the base class part of the derived class object contains all the data members that <a id="_idIndexMarker310"/>belong to the base class, and directly after it in memory, the additional data members of the derived class are placed. Note that the actual order of data members in memory can be influenced by factors such as alignment requirements and compiler optimizations.</p>
<h2 id="_idParaDest-129"><a id="_idTextAnchor128"/>Pros and cons of inheritance</h2>
<p>Here are the<a id="_idIndexMarker311"/> pros of inheritance:</p>
<ul>
<li><code>MediaContent</code> class will serve as the base class for all types of media content. It will encapsulate common attributes and behaviors such as <code>title</code>, <code>duration</code>, and basic playback controls (<code>play</code>, <code>pause</code>, <code>stop</code>):</p><pre class="source-code">
#include &lt;iostream&gt;</pre><pre class="source-code">
#include &lt;string&gt;</pre><pre class="source-code">
// Base class for all media content</pre><pre class="source-code">
class MediaContent {</pre><pre class="source-code">
protected:</pre><pre class="source-code">
    std::string _title;</pre><pre class="source-code">
    int _duration; // Duration in seconds</pre><pre class="source-code">
public:</pre><pre class="source-code">
    MediaContent(const std::string&amp; title, int duration)</pre><pre class="source-code">
        : _title(title), _duration(duration) {}</pre><pre class="source-code">
    auto title() const { return _title; }</pre><pre class="source-code">
    auto duration() const { return duration; }</pre><pre class="source-code">
    virtual void play() = 0; // Start playing the content</pre><pre class="source-code">
    virtual void pause() = 0;</pre><pre class="source-code">
    virtual void stop() = 0;</pre><pre class="source-code">
    virtual ~MediaContent() = default;</pre><pre class="source-code">
};</pre><p class="list-inset">The <code>Audio</code> class<a id="_idIndexMarker312"/> extends <code>MediaContent</code>, adding specific attributes related to audio files, such as bitrate:</p><pre class="source-code">
class Audio : public MediaContent {</pre><pre class="source-code">
private:</pre><pre class="source-code">
    int _bitrate; // Bitrate in kbps</pre><pre class="source-code">
public:</pre><pre class="source-code">
    Audio(const std::string&amp; title, int duration, int bitrate)</pre><pre class="source-code">
        : MediaContent(title, duration), _bitrate(bitrate) {}</pre><pre class="source-code">
    auto bitrate() const { return _bitrate; }</pre><pre class="source-code">
    void play() override {</pre><pre class="source-code">
        std::cout &lt;&lt; "Playing audio: " &lt;&lt; title &lt;&lt; ", Duration: " &lt;&lt; duration</pre><pre class="source-code">
                  &lt;&lt; "s, Bitrate: " &lt;&lt; bitrate &lt;&lt; "kbps" &lt;&lt; std::endl;</pre><pre class="source-code">
    }</pre><pre class="source-code">
    void pause() override {</pre><pre class="source-code">
        std::cout &lt;&lt; "Audio paused: " &lt;&lt; title &lt;&lt; std::endl;</pre><pre class="source-code">
    }</pre><pre class="source-code">
    void stop() override {</pre><pre class="source-code">
        std::cout &lt;&lt; "Audio stopped: " &lt;&lt; title &lt;&lt; std::endl;</pre><pre class="source-code">
    }</pre><pre class="source-code">
};</pre><p class="list-inset">Similarly, the <code>Video</code> class extends <code>MediaContent</code> and introduces additional attributes<a id="_idIndexMarker313"/> such as <code>resolution</code>:</p><pre class="source-code">
class Video : public MediaContent {</pre><pre class="source-code">
private:</pre><pre class="source-code">
    std::string _resolution; // Resolution as width x height</pre><pre class="source-code">
public:</pre><pre class="source-code">
    Video(const std::string&amp; title, int duration, const std::string&amp; resolution)</pre><pre class="source-code">
        : MediaContent(title, duration), _resolution(resolution) {}</pre><pre class="source-code">
    auto resolution() const { return _resolution; }</pre><pre class="source-code">
    void play() override {</pre><pre class="source-code">
        std::cout &lt;&lt; "Playing video: " &lt;&lt; title &lt;&lt; ", Duration: " &lt;&lt; duration</pre><pre class="source-code">
                  &lt;&lt; "s, Resolution: " &lt;&lt; resolution &lt;&lt; std::endl;</pre><pre class="source-code">
    }</pre><pre class="source-code">
    void pause() override {</pre><pre class="source-code">
        std::cout &lt;&lt; "Video paused: " &lt;&lt; title &lt;&lt; std::endl;</pre><pre class="source-code">
    }</pre><pre class="source-code">
    void stop() override {</pre><pre class="source-code">
        std::cout &lt;&lt; "Video stopped: " &lt;&lt; title &lt;&lt; std::endl;</pre><pre class="source-code">
    }</pre><pre class="source-code">
};</pre><p class="list-inset">Here’s how <a id="_idIndexMarker314"/>these classes could be used in a simple media player system:</p><pre class="source-code">
int main() {</pre><pre class="source-code">
    Audio my_song("Song Example", 300, 320);</pre><pre class="source-code">
    Video my_movie("Movie Example", 7200, "1920x1080");</pre><pre class="source-code">
    my_song.play();</pre><pre class="source-code">
    my_song.pause();</pre><pre class="source-code">
    my_song.stop();</pre><pre class="source-code">
    my_movie.play();</pre><pre class="source-code">
    my_movie.pause();</pre><pre class="source-code">
    my_movie.stop();</pre><pre class="source-code">
    return 0;</pre><pre class="source-code">
}</pre><p class="list-inset">In this example, both <code>Audio</code> and <code>Video</code> inherit from <code>MediaContent</code>. This allows us to reuse the <code>title</code> and <code>duration</code> attributes and requires the implementation of the playback controls (<code>play</code>, <code>pause</code>, <code>stop</code>) tailored to each media type. This hierarchy demonstrates how inheritance facilitates code reuse and system extensibility while enabling specific behaviors for different types of media content in <a id="_idIndexMarker315"/>a unified framework. Each class adds only what is unique to its type, adhering to the principle that base classes provide common functionality and derived classes extend or modify that functionality for specific needs.</p></li>
<li><strong class="bold">Polymorphism</strong>: Through inheritance, C++ supports polymorphism, which allows for the use of a base class reference to refer to an object of a derived class. This enables dynamic method binding and a flexible interface to multiple derived types. Our media content hierarchy can be used for implementing a media player that can handle different types of media content uniformly:<pre class="source-code">
class MediaPlayer {</pre><pre class="source-code">
private:</pre><pre class="source-code">
    std::vector&lt;std::unique_ptr&lt;MediaContent&gt;&gt; _playlist;</pre><pre class="source-code">
public:</pre><pre class="source-code">
    void add_media(std::unique_ptr&lt;MediaContent&gt; media) {</pre><pre class="source-code">
        _playlist.push_back(std::move(media));</pre><pre class="source-code">
    }</pre><pre class="source-code">
    void play_all() {</pre><pre class="source-code">
        for (auto&amp; media : _playlist) {</pre><pre class="source-code">
            media-&gt;play();</pre><pre class="source-code">
            // Additional controls can be implemented</pre><pre class="source-code">
        }</pre><pre class="source-code">
    }</pre><pre class="source-code">
};</pre><pre class="source-code">
int main() {</pre><pre class="source-code">
    MediaPlayer player;</pre><pre class="source-code">
    player.add(std::make_unique&lt;Audio&gt;("Jazz in Paris", 192, 320));</pre><pre class="source-code">
    player.add(std::make_unique&lt;Video&gt;("Tour of Paris", 1200, "1280x720"));</pre><pre class="source-code">
    player.play_all();</pre><pre class="source-code">
    return 0;</pre><pre class="source-code">
}</pre><p class="list-inset">The <code>add</code> method accepts media content of any type that derives from <code>MediaContent</code>, demonstrating polymorphism by using a base class pointer to refer to derived <a id="_idIndexMarker316"/>class objects. This is enabled by storing the media items in <code>std::vector</code> of <code>std::unique_ptr&lt;MediaContent&gt;</code>. The <code>play_all</code> method iterates through the stored media and calls the play method on each item. Despite the actual media type being different (audio or video), the media player treats them all as <code>MediaContent</code>. The correct play method (from either <code>Audio</code> or <code>Video</code>) is invoked at runtime, which is an example of dynamic polymorphism (also known as dynamic dispatch).</p></li>
<li><strong class="bold">Hierarchical structuring</strong>: It provides a natural way to organize related classes in a hierarchical manner that models real-world relationships.</li>
</ul>
<p>Here is the con of <a id="_idIndexMarker317"/>inheritance:</p>
<ul>
<li><strong class="bold">Tight coupling</strong>: Inheritance creates a tight coupling between base and derived classes. Changes to the base class can inadvertently affect derived classes, leading to fragile code that can break when base classes are modified. The following example illustrates the issue of tight coupling through inheritance in a software system. We’ll use a scenario involving an online store that manages different types of discounts using a class hierarchy.</li>
</ul>
<h2 id="_idParaDest-130"><a id="_idTextAnchor129"/>Base class – Discount</h2>
<p>The <code>Discount</code> class <a id="_idIndexMarker318"/>provides the basic structure and functionality for all types of discounts. It calculates a discount based on a percentage reduction;</p>
<pre class="source-code">
#include &lt;iostream&gt;
class Discount {
protected:
    double _discount_percent;  // Percent of discount
public:
    Discount(double percent) : _discount_percent(percent) {}
    virtual double apply_discount(double amount) {
        return amount * (1 - _discount_percent / 100);
    }
};</pre>
<h2 id="_idParaDest-131"><a id="_idTextAnchor130"/>Derived class – SeasonalDiscount</h2>
<p>The <code>SeasonalDiscount</code> class extends <code>Discount</code> and modifies the discount calculation<a id="_idIndexMarker319"/> based on seasonal factors, such as increasing the discount during the holiday season:</p>
<pre class="source-code">
class SeasonalDiscount : public Discount {
public:
    SeasonalDiscount(double percent) : Discount(percent) {}
    double apply_discount(double amount) override {
        // Let's assume the discount increases by an additional 5% during holidays
        double additional = 0.05;  // 5% extra during holidays
        return amount * (1 - (_discount_percent / 100 + additional));
    }
};</pre>
<h2 id="_idParaDest-132"><a id="_idTextAnchor131"/>Derived class – ClearanceDiscount</h2>
<p>The <code>ClearanceDiscount</code> class <a id="_idIndexMarker320"/>also extends <code>Discount</code>, designed for items on clearance where the discount might be significantly higher:</p>
<pre class="source-code">
class ClearanceDiscount : public Discount {
public:
    ClearanceDiscount(double percent) : Discount(percent) {}
    double apply_discount(double amount) override {
        // Clearance items get an extra 10% off beyond the configured discount
        double additional = 0.10;  // 10% extra for clearance items
        return amount * (1 - (_discount_percent / 100 + additional));
    }
};</pre>
<p>Demonstration and tight coupling issue:</p>
<pre class="source-code">
int main() {
    Discount regular(20); // 20% regular discount
    SeasonalDiscount holiday(20); // 20% holiday discount, plus extra
    ClearanceDiscount clearance(20); // 20% clearance discount, plus extra
    std::cout &lt;&lt; "Regular Price $100 after discount: $" &lt;&lt; regular.apply_discount(100) &lt;&lt; std::endl;
    std::cout &lt;&lt; "Holiday Price $100 after discount: $" &lt;&lt; holiday.apply_discount(100) &lt;&lt; std::endl;
    std::cout &lt;&lt; "Clearance Price $100 after discount: $" &lt;&lt; clearance.apply_discount(100) &lt;&lt; std::endl;
    return 0;
}</pre>
<h2 id="_idParaDest-133"><a id="_idTextAnchor132"/>Tight coupling problems</h2>
<p>The following is a<a id="_idIndexMarker321"/> list of tight-coupling problems:</p>
<ul>
<li><code>apply_discount</code>). Any change in the base class method’s signature or the logic within <code>apply_discount</code> could necessitate changes in all derived classes.</li>
<li><code>_discount_percent</code>. If the formula in the base class changes (say, incorporating minimum or maximum caps), all subclasses might need extensive modifications to conform to the new logic.</li>
<li><strong class="bold">Inflexibility</strong>: The coupling makes it hard to modify the behavior of one discount type without risking impacts on others. This design lacks flexibility where independent evolution of discount calculation strategies might be necessary.</li>
</ul>
<h2 id="_idParaDest-134"><a id="_idTextAnchor133"/>Solution – decouple with the strategy pattern</h2>
<p>One way to reduce<a id="_idIndexMarker322"/> this coupling is to use <a id="_idIndexMarker323"/>the <strong class="bold">strategy pattern</strong>, which involves defining a family of algorithms (discount strategies), encapsulating each one, and making them interchangeable. This allows the discount algorithms to vary independently from the clients that use them:</p>
<pre class="source-code">
class DiscountStrategy {
public:
    virtual double calculate(double amount) = 0;
    virtual ~DiscountStrategy() {}
};
class RegularDiscountStrategy : public DiscountStrategy {
public:
    double calculate(double amount) override {
        return amount * 0.80; // 20% discount
    }
};
class HolidayDiscountStrategy : public DiscountStrategy {
public:
    double calculate(double amount) override {
        return amount * 0.75; // 25% discount
    }
};
class ClearanceDiscountStrategy : public DiscountStrategy {
public:
    double calculate(double amount) override {
        return amount * 0.70; // 30% discount
    }
};
// Use these strategies in a Discount context class
class Discount {
private:
    std::unique_ptr&lt;DiscountStrategy&gt; _strategy;
public:
    Discount(std::unique_ptr&lt;DiscountStrategy&gt; strat) : _strategy(std::move(strat)) {}
    double apply_discount(double amount) {
        return _strategy-&gt;calculate(amount);
    }
};</pre>
<p>This<a id="_idIndexMarker324"/> approach decouples the discount calculation from the client (<code>Discount</code>) using it, allowing each discount strategy to evolve independently without affecting others. A couple of others ways to reduce the coupling are:</p>
<ul>
<li><code>HybridFlyingElectricCar</code> that inherits from both <code>ElectricCar</code> and <code>FlyingCar</code>, with each of these classes further inheriting from their respective hierarchies, results in a highly tangled class structure. This complexity makes the system tough to debug, extend, or reliably use, while also multiplying the challenges in testing and maintaining consistent behavior across various scenarios.</p><p class="list-inset">To manage the complications introduced by extensive use of inheritance, several strategies can be recommended. Favoring composition over inheritance often provides greater flexibility, allowing systems to be composed of well-defined, loosely coupled components rather than relying on rigid inheritance structures. Keeping inheritance chains short and manageable – generally no deeper than two or three levels – helps preserve system clarity and maintainability. Employing interfaces, particularly in languages such as Java and C#, offers a way to achieve polymorphic behavior without the overhead associated with inheritance. When multiple inheritance is unavoidable, it’s crucial to ensure clear documentation and consider the use of interface-like structures or mixins, which can help minimize complexity and enhance system robustness.</p></li>
<li><strong class="bold">Liskov Substitution Principle (LSP)</strong>: We mentioned this principle earlier in this book; LSP states<a id="_idIndexMarker326"/> that objects of a superclass should be replaceable with objects of <a id="_idIndexMarker327"/>its subclasses without altering the desirable properties of the program (correctness, task performed, etc.). Inheritance can sometimes lead to violations of this principle, especially when subclasses diverge from the behavior expected by the base class. The following sections include typical problems related to violations of the LSP, illustrated with simple examples.</li>
</ul>
<h3>Unexpected behaviors in derived classes</h3>
<p>When <a id="_idIndexMarker328"/>derived classes override methods of the base class in ways that change the expected behavior significantly, it can lead to unexpected results when these objects are used interchangeably:</p>
<pre class="source-code">
class Bird {
public:
    virtual void fly() {
        std::cout &lt;&lt; "This bird flies" &lt;&lt; std::endl;
    }
};
class Ostrich : public Bird {
public:
    void fly() override {
        throw std::logic_error("Ostriches can't fly!");
    }
};
void make_bird_fly(Bird&amp; b) {
    b.fly();  // Expecting all birds to fly
}</pre>
<p>Here, replacing a <code>Bird</code> object with an <code>Ostrich</code> object in the <code>make_bird_fly</code> function leads<a id="_idIndexMarker329"/> to a runtime error because ostriches can’t fly, violating LSP. Users of the <code>Bird</code> class expect any subclass to fly, and <code>Ostrich</code> breaks this expectation.</p>
<h3>Issues with method preconditions</h3>
<p>If a derived class<a id="_idIndexMarker330"/> imposes stricter preconditions on a method than those imposed by the base class, it can limit the usability of the subclass and violate LSP:</p>
<pre class="source-code">
class Payment {
public:
    virtual void pay(int amount) {
        if (amount &lt;= 0) {
            throw std::invalid_argument("Amount must be positive");
        }
        std::cout &lt;&lt; "Paying " &lt;&lt; amount &lt;&lt; std::endl;
    }
};
class CreditPayment : public Payment {
public:
    void pay(int amount) override {
        if (amount &lt; 100) {  // Stricter precondition than the base class
            throw std::invalid_argument("Minimum amount for credit payment is 100");
        }
        std::cout &lt;&lt; "Paying " &lt;&lt; amount &lt;&lt; " with credit" &lt;&lt; std::endl;
    }
};</pre>
<p>Here, the <code>CreditPayment</code> class cannot be used in place of <code>Payment</code> without potentially throwing <a id="_idIndexMarker331"/>an error for amounts below 100, even though such amounts are perfectly valid for the base class.</p>
<h3>Solutions to LSP violations</h3>
<ul>
<li><strong class="bold">Design with LSP in mind</strong>: When designing your class hierarchy, ensure that any subclass<a id="_idIndexMarker332"/> can be used in place of a parent class without altering the desirable properties of the program</li>
<li><strong class="bold">Use composition instead of inheritance</strong>: If it doesn’t make sense for the subclass to fully adhere to the base class’s contract, use composition instead of inheritance</li>
<li><strong class="bold">Clearly define behavioral contracts</strong>: Document and enforce the expected behavior of base classes, and ensure that all derived classes adhere strictly to these contracts without introducing tighter preconditions or altering postconditions</li>
</ul>
<p>By paying close attention to these principles and potential pitfalls, developers can create more robust and maintainable object-oriented designs.</p>
<p>While inheritance remains a valuable feature in C++, understanding when and how to use it effectively is crucial. The implementation detail that inheritance is akin to composition at the binary level highlights that it is fundamentally about structuring and accessing data within an object’s memory layout. Practitioners must carefully consider whether inheritance or composition (or a combination of both) will best serve their design goals, especially regarding system flexibility, maintainability, and the robust application of OOP principles such as LSP. As with many features in software development, the key lies in using the right tool for the right job.</p>
<h1 id="_idParaDest-135"><a id="_idTextAnchor134"/>Templates and generic programming</h1>
<p>Templates and generic programming are pivotal features of C++ that enable the creation of flexible and reusable components. While this chapter offers an overview of these powerful tools, it’s important to note that the topic of templates, particularly template metaprogramming, is vast enough to fill entire books. For those seeking an in-depth exploration, dedicated resources on C++ templates and metaprogramming are recommended.</p>
<h2 id="_idParaDest-136"><a id="_idTextAnchor135"/>What are templates good for?</h2>
<p>Templates are <a id="_idIndexMarker333"/>particularly useful in scenarios where similar operations need to be performed on different types of data. They allow you to write a single piece of code that works with any type. The following subsections outline some common use cases with examples.</p>
<h2 id="_idParaDest-137"><a id="_idTextAnchor136"/>Generic algorithms</h2>
<p>Algorithms <a id="_idIndexMarker334"/>can operate on different types without rewriting the code for each type. For instance, the standard library’s <code>std::sort</code> function can sort elements of any type as long as the elements can be compared:</p>
<pre class="source-code">
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
template &lt;typename T&gt;
void print(const std::vector&lt;T&gt;&amp; vec) {
    for (const T&amp; elem : vec) {
        std::cout &lt;&lt; elem &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
}
int main() {
    std::vector&lt;int&gt; int_vec = {3, 1, 4, 1, 5};
    std::sort(int_vec.begin(), int_vec.end());
    print(int_vec); // Outputs: 1 1 3 4 5
    std::vector&lt;std::string&gt; string_vec = {"banana", "apple", "cherry"};
    std::sort(string_vec.begin(), string_vec.end());
    print(string_vec); // Outputs: apple banana cherry
    return 0;
}</pre>
<h2 id="_idParaDest-138"><a id="_idTextAnchor137"/>Container classes</h2>
<p>Templates are<a id="_idIndexMarker335"/> heavily used in the standard library for containers such as <code>std::vector</code>, <code>std::list</code>, and <code>std::map</code>, which can store elements of any type:</p>
<pre class="source-code">
#include &lt;vector&gt;
#include &lt;iostream&gt;
int main() {
    std::vector&lt;int&gt; int_vec = {1, 2, 3};
    std::vector&lt;std::string&gt; string_vec = {"hello", "world"};
    for (int val : int_vec) {
        std::cout &lt;&lt; val &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
    for (const std::string&amp; str : string_vec) {
        std::cout &lt;&lt; str &lt;&lt; " ";
    }
    std::cout &lt;&lt; std::endl;
    return 0;
}</pre>
<p>Without the<a id="_idIndexMarker336"/> usage of templates, developer’s options in using collections would be limited to creating separate classes for each type of collection (e.g., <code>IntVector</code>, <code>StringVector</code>, etc.), or demanding the use of a common base class, which would require type casting and lose type safety, for example:</p>
<pre class="source-code">
class BaseObject {};
class Vector {
public:
    void push_back(BaseObject* obj);
};</pre>
<p>Another option is to store some <code>void</code> pointers and cast them to the desired type when retrieving them, but this approach is even more error prone.</p>
<p>The standard library uses templates for smart pointers such as <code>std::unique_ptr</code> and <code>std::shared_ptr</code>, which manage the lifetime of dynamically allocated objects:</p>
<pre class="source-code">
#include &lt;memory&gt;
#include &lt;iostream&gt;
int main() {
    std::unique_ptr&lt;int&gt; ptr = std::make_unique&lt;int&gt;(42);
    std::cout &lt;&lt; "Value: " &lt;&lt; *ptr &lt;&lt; std::endl; // Outputs: Value: 42
    std::shared_ptr&lt;int&gt; shared_ptr = std::make_shared&lt;int&gt;(100);
    std::cout &lt;&lt; "Shared Value: " &lt;&lt; *shared_ptr &lt;&lt; std::endl; // Outputs: Shared Value: 100
    return 0;
}</pre>
<p>Templates <a id="_idIndexMarker337"/>ensure type safety by allowing the compiler to check types during template instantiation, reducing runtime errors:</p>
<pre class="source-code">
template &lt;typename T&gt;
T add(T a, T b) {
    return a + b;
}
int main() {
    std::cout &lt;&lt; add&lt;int&gt;(5, 3) &lt;&lt; std::endl;      // Outputs: 8
    std::cout &lt;&lt; add&lt;double&gt;(2.5, 3.5) &lt;&lt; std::endl; // Outputs: 6.0
    return 0;
}</pre>
<h2 id="_idParaDest-139"><a id="_idTextAnchor138"/>How templates work</h2>
<p>Templates<a id="_idIndexMarker338"/> in C++ are not actual code but serve as blueprints for code generation. When a template is instantiated with a specific type, the compiler generates a concrete instance of the template with the specified type replacing the template parameters.</p>
<h3>Function templates</h3>
<p>A<a id="_idIndexMarker339"/> function template defines a pattern for a function that can <a id="_idIndexMarker340"/>operate on different data types:</p>
<pre class="source-code">
template &lt;typename T&gt;
T add(T a, T b) {
    return a + b;
}
int main() {
    std::cout &lt;&lt; add&lt;int&gt;(5, 3) &lt;&lt; std::endl;      // Outputs: 8
    std::cout &lt;&lt; add&lt;double&gt;(2.5, 3.5) &lt;&lt; std::endl; // Outputs: 6.0
    return 0;
}</pre>
<p>The actual generated functions after template instantiation would be something like this (depending on the compiler):</p>
<pre class="source-code">
int addInt(int a, int b) {
    return a + b;
}
double addDouble(double a, double b) {
    return a + b;
}</pre>
<h3>Class templates</h3>
<p>A <a id="_idIndexMarker341"/>class template<a id="_idIndexMarker342"/> defines a pattern for a class that can operate on different data types:</p>
<pre class="source-code">
template &lt;typename T&gt;
class Box {
private:
    T content;
public:
    void set_content(const T&amp; value) {
        content = value;
    }
    T get_content() const {
        return content;
    }
};
int main() {
    Box&lt;int&gt; intBox;
    intBox.set_content(123);
    std::cout &lt;&lt; intBox.get_content() &lt;&lt; std::endl; // Outputs: 123
    Box&lt;std::string&gt; stringBox;
    stringBox.set_content("Hello Templates!");
    std::cout &lt;&lt; stringBox.get_content() &lt;&lt; std::endl; // Outputs: Hello Templates!
    return 0;
}</pre>
<p>The <a id="_idIndexMarker343"/>actual generated classes after template instantiation <a id="_idIndexMarker344"/>would be something like this (depending on the compiler):</p>
<pre class="source-code">
class BoxInt { /*Box&lt;int&gt;*/ };
class BoxString { /*Box&lt;int&gt;*/ };</pre>
<h1 id="_idParaDest-140"><a id="_idTextAnchor139"/>How templates are instantiated</h1>
<p>When a template is <a id="_idIndexMarker345"/>used with a specific type, the compiler creates a new instance of the template with the specified type. This process is known as <strong class="bold">template instantiation</strong> and can happen implicitly or explicitly:</p>
<ul>
<li><strong class="bold">Implicit instantiation</strong>: This <a id="_idIndexMarker346"/>occurs <a id="_idIndexMarker347"/>when the compiler encounters a use of the template with specific types:<pre class="source-code">
int main() {</pre><pre class="source-code">
    std::cout &lt;&lt; add(5, 3) &lt;&lt; std::endl; // The compiler infers the type as int</pre><pre class="source-code">
    return 0;</pre><pre class="source-code">
}</pre></li>
<li><strong class="bold">Explicit instantiation</strong>: The <a id="_idIndexMarker348"/>programmer <a id="_idIndexMarker349"/>specifies the type explicitly:<pre class="source-code">
int main() {</pre><pre class="source-code">
    std::cout &lt;&lt; add&lt;int&gt;(5, 3) &lt;&lt; std::endl; // Explicitly specifies the type as int</pre><pre class="source-code">
    return 0;</pre><pre class="source-code">
}</pre></li>
</ul>
<h1 id="_idParaDest-141"><a id="_idTextAnchor140"/>A real-world example of template usage in C++</h1>
<p>In the <a id="_idIndexMarker350"/>realm of financial software, handling various types of assets and currencies in a flexible, type-safe, and efficient manner is crucial. C++ templates offer a powerful mechanism to achieve this flexibility by allowing developers to write generic and reusable code that can operate with any data type.</p>
<p>Imagine developing a financial system that must handle multiple currencies such as USD and EUR, and manage various assets such as stocks or bonds. By using templates, we can define classes that operate generically on these types without duplicating code for each specific currency or asset type. This approach not only reduces redundancy but also enhances the system’s scalability and maintainability.</p>
<p>In the following sections, we will look at a detailed example of a financial system implemented using C++ templates. This example will show you how to define and manipulate prices in different currencies, how to create and manage assets, and how to ensure that operations remain type safe and efficient. Through this example, we aim to illustrate the practical benefits of using templates in real-world C++ applications and how they can lead to cleaner, more maintainable, and more robust code.</p>
<h2 id="_idParaDest-142"><a id="_idTextAnchor141"/>Defining currencies</h2>
<p>When<a id="_idIndexMarker351"/> designing a financial system, it’s essential to handle multiple currencies in a way that prevents errors and ensures type safety. Let’s start by defining the requirements and exploring various design options.</p>
<p>Here are the requirements:</p>
<ul>
<li><strong class="bold">Type safety</strong>: Ensure that different currencies cannot be mixed inadvertently</li>
<li><strong class="bold">Scalability</strong>: Easily add new currencies without significant code duplication</li>
<li><strong class="bold">Flexibility</strong>: Support various operations such as addition and subtraction on prices in a type-safe manner</li>
</ul>
<p>Here are the<a id="_idIndexMarker352"/> design options:</p>
<ul>
<li><code>int</code> or <code>double</code>. However, this method has significant drawbacks. It allows for the accidental mixing of different currencies, leading to incorrect calculations:<pre class="source-code">
double usd = 100.0;</pre><pre class="source-code">
double eur = 90.0;</pre><pre class="source-code">
double total = usd + eur; // Incorrectly adds USD and EUR</pre><p class="list-inset">This approach is error prone and lacks type safety. Please note that using <code>double</code> for currency values is generally discouraged due to precision issues in floating-point arithmetic.</p></li>
<li><code>Currency</code> class and inherit specific currencies from it. While this approach introduces some structure, it still allows for the mixing of different currencies and requires significant effort to implement each new currency:<pre class="source-code">
class Currency {</pre><pre class="source-code">
public:</pre><pre class="source-code">
    virtual std::string name() const = 0;</pre><pre class="source-code">
    virtual ~Currency() = default;</pre><pre class="source-code">
};</pre><pre class="source-code">
class USD : public Currency {</pre><pre class="source-code">
public:</pre><pre class="source-code">
    std::string name() const override { return "USD"; }</pre><pre class="source-code">
};</pre><pre class="source-code">
class Euro : public Currency {</pre><pre class="source-code">
public:</pre><pre class="source-code">
    std::string name() const override { return "EUR"; }</pre><pre class="source-code">
};</pre><pre class="source-code">
// USD and Euro can still be mixed inadvertently</pre></li>
<li><code>struct</code>, and operations are implemented using templates:<pre class="source-code">
struct Usd {</pre><pre class="source-code">
    static const std::string &amp;name() {</pre><pre class="source-code">
        static std::string name = "USD";</pre><pre class="source-code">
        return name;</pre><pre class="source-code">
    }</pre><pre class="source-code">
};</pre><pre class="source-code">
struct Euro {</pre><pre class="source-code">
    static const std::string &amp;name() {</pre><pre class="source-code">
        static std::string name = "EUR";</pre><pre class="source-code">
        return name;</pre><pre class="source-code">
    }</pre><pre class="source-code">
};</pre><pre class="source-code">
template &lt;typename Currency&gt;</pre><pre class="source-code">
class Price {</pre><pre class="source-code">
public:</pre><pre class="source-code">
    Price(int64_t amount) : _amount(amount) {}</pre><pre class="source-code">
    int64_t count() const { return _amount; }</pre><pre class="source-code">
private:</pre><pre class="source-code">
    int64_t _amount;</pre><pre class="source-code">
};</pre><pre class="source-code">
template &lt;typename Currency&gt;</pre><pre class="source-code">
std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Price&lt;Currency&gt; &amp;price) {</pre><pre class="source-code">
    os &lt;&lt; price.count() &lt;&lt; " " &lt;&lt; Currency::name();</pre><pre class="source-code">
    return os;</pre><pre class="source-code">
}</pre><pre class="source-code">
template &lt;typename Currency&gt;</pre><pre class="source-code">
Price&lt;Currency&gt; operator+(const Price&lt;Currency&gt; &amp;lhs, const Price&lt;Currency&gt; &amp;rhs) {</pre><pre class="source-code">
    return Price&lt;Currency&gt;(lhs.count() + rhs.count());</pre><pre class="source-code">
}</pre><pre class="source-code">
template &lt;typename Currency&gt;</pre><pre class="source-code">
Price&lt;Currency&gt; operator-(const Price&lt;Currency&gt; &amp;lhs, const Price&lt;Currency&gt; &amp;rhs) {</pre><pre class="source-code">
    return Price&lt;Currency&gt;(lhs.count() - rhs.count());</pre><pre class="source-code">
}</pre><pre class="source-code">
// User can define other arithmetic operations as needed</pre><p class="list-inset">This <a id="_idIndexMarker354"/>template-based approach ensures that prices in different currencies cannot be mixed:</p><pre class="source-code">
int main() {</pre><pre class="source-code">
    Price&lt;Usd&gt; usd(100);</pre><pre class="source-code">
    Price&lt;Euro&gt; euro(90);</pre><pre class="source-code">
    // The following line would cause a compile-time error</pre><pre class="source-code">
    // source&gt;:113:27: error: no match for 'operator+' (operand types are 'Price&lt;Usd&gt;' and 'Price&lt;Euro&gt;')</pre><pre class="source-code">
    // Price&lt;Usd&gt; total= usd + euro;</pre><pre class="source-code">
    Price&lt;Usd&gt; total = usd+ Price&lt;Usd&gt;(50); // Correct usage</pre><pre class="source-code">
    std::cout &lt;&lt; total&lt;&lt; std::endl; // Outputs: 150 USD</pre><pre class="source-code">
    return 0;</pre><pre class="source-code">
}</pre></li>
</ul>
<h2 id="_idParaDest-143"><a id="_idTextAnchor142"/>Defining assets</h2>
<p>Next, we<a id="_idIndexMarker355"/> define assets that can be priced in different currencies. Using templates, we can ensure that each asset is associated with the correct currency:</p>
<pre class="source-code">
template &lt;typename TickerT&gt;
class Asset;
struct Apple {
    static const std::string &amp;name() {
        static std::string name = "AAPL";
        return name;
    }
    static const std::string &amp;exchange() {
        static std::string exchange = "NASDAQ";
        return exchange;
    }
    using Asset = class Asset&lt;Apple&gt;;
    using Currency = Usd;
};
struct Mercedes {
    static const std::string &amp;name() {
        static std::string name = "MGB";
        return name;
    }
    static const std::string &amp;exchange() {
        static std::string exchange = "FRA";
        return exchange;
    }
    using Asset = class Asset&lt;Mercedes&gt;;
    using Currency = Euro;
};
template &lt;typename TickerT&gt;
class Asset {
public:
    using Ticker   = TickerT;
    using Currency = typename Ticker::Currency;
    Asset(int64_t amount, Price&lt;Currency&gt; price)
        : _amount(amount), _price(price) {}
    auto amount() const { return _amount; }
    auto price() const { return _price; }
private:
    int64_t _amount;
    Price&lt;Currency&gt; _price;
};
template &lt;typename TickerT&gt;
std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Asset&lt;TickerT&gt; &amp;asset) {
    os &lt;&lt; TickerT::name() &lt;&lt; ", amount: " &lt;&lt; asset.amount()
       &lt;&lt; ", price: " &lt;&lt; asset.price();
    return os;
}</pre>
<h2 id="_idParaDest-144"><a id="_idTextAnchor143"/>Using the financial system</h2>
<p>Finally, we <a id="_idIndexMarker356"/>demonstrate how to use the defined templates to manage assets and prices:</p>
<pre class="source-code">
int main() {
    Price&lt;Usd&gt; usd_price(100);
    usd_price = usd_price + Price&lt;Usd&gt;(1);
    std::cout &lt;&lt; usd_price &lt;&lt; std::endl; // Outputs: 101 USD
    Asset&lt;Apple&gt; apple{10, Price&lt;Usd&gt;(100)};
    Asset&lt;Mercedes&gt; mercedes{5, Price&lt;Euro&gt;(100)};
    std::cout &lt;&lt; apple &lt;&lt; std::endl; // Outputs: AAPL, amount: 10, price: 100 USD
    std::cout &lt;&lt; mercedes &lt;&lt; std::endl; // Outputs: MGB, amount: 5, price: 100 EUR
    return 0;
}</pre>
<h2 id="_idParaDest-145"><a id="_idTextAnchor144"/>Disadvantages of using templates in system design</h2>
<p>While<a id="_idIndexMarker357"/> templates in C++ offer a powerful and flexible way to create type-safe, generic components, there are several disadvantages to this approach. These disadvantages are particularly relevant in the context of a financial system that deals with multiple currencies and assets. Understanding these potential drawbacks is essential when deciding to use templates in your design.</p>
<h3>Code bloat</h3>
<p>Templates can lead to code bloat, which is the increase in binary size due to the generation of multiple template instantiations. The compiler generates a separate version of the template code for each unique type instantiation. In a financial system that supports various currencies and assets, this can lead to a significant increase in the size of the compiled binary.</p>
<p>For example, if we have templates for <code>Price</code> and <code>Asset</code> instantiated with different types such as <code>Usd</code>, <code>Euro</code>, <code>Apple</code>, and <code>Mercedes</code>, the compiler generates separate code for each combination:</p>
<pre class="source-code">
Price&lt;Usd&gt; usdPrice(100);
Price&lt;Euro&gt; euroPrice(90);
Asset&lt;Apple&gt; appleAsset(10, Price&lt;Usd&gt;(100));
Asset&lt;Mercedes&gt; mercedesAsset(5, Price&lt;Euro&gt;(100));</pre>
<p>Each of these instantiations results in additional code, contributing to the overall binary size. As the number of supported currencies and assets grows, the impact of code bloat becomes more pronounced. Binary size can affect application performance, memory usage, and load times, especially in resource-constrained environments mostly due to lower cache efficiency.</p>
<h3>Increased compilation times</h3>
<p>Templates<a id="_idIndexMarker358"/> can significantly increase the compilation time of a project. Each instantiation of a template with a new type results in the generation of new code by the compiler. In a financial system that supports hundreds of currencies and assets from various countries and stock exchanges, the compiler will have to instantiate all the needed combinations, leading to longer build times.</p>
<p>For instance, say our system supports the following:</p>
<ul>
<li>50 different currencies</li>
<li>10000 different asset types from various stock exchanges</li>
</ul>
<p>Then, the compiler will need to generate code for each <code>Price</code> and <code>Asset</code> combination, resulting in a substantial number of template instantiations. This can considerably slow down the compilation process, affecting the development workflow, and less efficient feedback loop.</p>
<h3>Less obvious interaction with the rest of the code</h3>
<p>Template code can be complex and less obvious in terms of how it interacts with the rest of the code base. Developers who are less experienced with templates may find it challenging to understand and maintain template-heavy code. The syntax can be verbose, and compiler error messages can be difficult to decipher, making debugging and troubleshooting more complicated.</p>
<p>For example, a simple mistake in template parameters can lead to confusing error messages:</p>
<pre class="source-code">
template &lt;typename T&gt;
class Price {
    // Implementation
};
Price&lt;int&gt; price(100); // Intended to be Price&lt;Usd&gt; but mistakenly used int</pre>
<p>In this case, the developer must understand templates and the specific error messages generated by the compiler to resolve the issue. This can be a barrier for less experienced developers.</p>
<p>C++ 20 provides <a id="_idIndexMarker359"/>concepts to improve template error messages and constraints, which can help make template code more readable and easier to understand. We can create a base class called <code>BaseCurrency</code> and derive all currency classes from it. This way, we can ensure that all currency classes have a common interface and can be used interchangeably:</p>
<pre class="source-code">
struct BaseCurrency {
};
struct Usd : public BaseCurrency {
    static const std::string &amp;name() {
        static std::string name = "USD";
        return name;
    }
};
// Define a concept for currency classes
template&lt;class T, class U&gt;
concept Derived = std::is_base_of&lt;U, T&gt;::value;
// Make sure that template parameter is derived from BaseCurrency
template &lt;Derived&lt;BaseCurrency&gt; CurrencyT&gt;
class Price {
public:
    Price(int64_t amount) : _amount(amount) {}
    int64_t count() const { return _amount; }
private:
    int64_t _amount;
};</pre>
<p>After these<a id="_idIndexMarker360"/> changes, the attempt to instantiate <code>Price&lt;int&gt;</code> will result in a compile-time error, making it clear that the type must be derived from <code>BaseCurrency</code>:</p>
<pre class="source-code">
In function 'int main()':
error: template constraint failure for 'template&lt;class CurrencyT&gt;  requires  Derived&lt;CurrencyT, Currency&gt; class Price'
 auto p = Price&lt;int&gt;(100);
                   ^
note: constraints not satisfied
In substitution of 'template&lt;class CurrencyT&gt;  requires  Derived&lt;CurrencyT, Currency&gt; class Price [with CurrencyT = int]':</pre>
<p>C++ versions prior to C++ 20 also provide a way to prevent unintended template instantiations by using a combination of <code>std::enable_if</code> and <code>std::is_base_of</code> to enforce constraints on template parameters:</p>
<pre class="source-code">
template &lt;typename CurrencyT,
          typename Unused=typename std::enable_if&lt;std::is_base_of&lt;BaseCurrency,CurrencyT&gt;::value&gt;::type&gt;
class Price {
public:
    Price(int64_t amount) : _amount(amount) {}
    int64_t count() const { return _amount; }
private:
    int64_t _amount;
};</pre>
<p>The attempt to initialize <code>Price&lt;int&gt;</code> will now result in a compile-time error, indicating that the type must be derived from <code>BaseCurrency</code>, however, the error message will be a bit cryptic:</p>
<pre class="source-code">
error: no type named 'type' in 'struct std::enable_if&lt;false, void&gt;'
auto p = Price&lt;int&gt;(100);
      |                       ^
error: template argument 2 is invalid</pre>
<h3>Limited tool support and debugging</h3>
<p>Debugging template code can be challenging due to limited tool support. Many debuggers do not handle template instantiations well, making it difficult to step through template code and inspect template parameters and instantiations. This can hinder the debugging process and make it harder to identify and fix issues.</p>
<p>For example, examining the state of a templated <code>Price&lt;Usd&gt;</code> object in a debugger might not provide clear insights into the underlying type and values, especially if the debugger does not fully support template parameter inspection.</p>
<p>Most autocomplete and IDE tools do not work very well with templates, because it is impossible for them to assume the type of the template parameter. This can make it harder to navigate and understand template-heavy code bases.</p>
<h3>Advanced features of templates might be hard to use</h3>
<p>Templates in C++ provide a mechanism for writing generic and reusable code. However, there are situations<a id="_idIndexMarker361"/> where the default template behavior needs to be customized for specific types. This is where template specialization comes into play. Template specialization allows you to define a special behavior for a specific type, ensuring that the template behaves correctly for that type.</p>
<h4>Why use template specialization?</h4>
<p>Template specialization<a id="_idIndexMarker362"/> is used when the general template implementation does not work correctly or efficiently for a particular type, or when a specific type requires a completely different implementation. This can happen due to various reasons, such as performance optimizations, special handling of certain data types, or compliance with specific requirements.</p>
<p>For example, consider a scenario where you have a general <code>Printer</code> template class that prints objects of any type. However, for <code>std::string</code>, you might want to add quotes around the string when printing it.</p>
<h4>Basic template specialization example</h4>
<p>Here is an <a id="_idIndexMarker363"/>example of how template specialization works:</p>
<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;string&gt;
// General template
template &lt;typename T&gt;
class Printer {
public:
    void print(const T&amp; value) {
        std::cout &lt;&lt; value &lt;&lt; std::endl;
    }
};
// Template specialization for std::string
template &lt;&gt;
class Printer&lt;std::string&gt; {
public:
    void print(const std::string&amp; value) {
        std::cout &lt;&lt; "\"" &lt;&lt; value &lt;&lt; "\"" &lt;&lt; std::endl;
    }
};
int main() {
    Printer&lt;int&gt; int_printer;
    int_printer.print(123); // Outputs: 123
    Printer&lt;std::string&gt; string_printer;
    string_printer.print("Hello, World!"); // Outputs: "Hello, World!" with quotes
    return 0;
}</pre>
<p>In this example, the <a id="_idIndexMarker364"/>general <code>Printer</code> template class prints any type. However, for <code>std::string</code>, the specialized version adds quotes around the string when printing it.</p>
<h4>Including the specialization header</h4>
<p>When <a id="_idIndexMarker365"/>using template specialization, it is crucial to include the header file that contains the specialization definition. If the specialization header is not included, the compiler will instantiate the default version of the template, leading to incorrect behavior.</p>
<p>For example, consider the following files:</p>
<p><code>printer.h</code> (General template definition):</p>
<pre class="source-code">
#ifndef PRINTER_H
#define PRINTER_H
#include &lt;iostream&gt;
template &lt;typename T&gt;
class Printer {
public:
    void print(const T&amp; value) {
        std::cout &lt;&lt; value &lt;&lt; std::endl;
    }
};
#endif // PRINTER_H</pre>
<p><code>printer_string.h</code> (Template specialization for <code>std::string</code>):</p>
<pre class="source-code">
#ifndef PRINTER_STRING_H
#define PRINTER_STRING_H
#include "printer.h"
#include &lt;string&gt;
template &lt;&gt;
class Printer&lt;std::string&gt; {
public:
    void print(const std::string&amp; value) {
        std::cout &lt;&lt; "\"" &lt;&lt; value &lt;&lt; "\"" &lt;&lt; std::endl;
    }
};
#endif // PRINTER_STRING_H</pre>
<p><code>main.cpp</code> (Using the template and specialization):</p>
<pre class="source-code">
#include "printer.h"
// #include "printer_string.h" // Uncomment this line to use the specialization
int main() {
    Printer&lt;int&gt; int_printer;
    int_printer.print(123); // Outputs: 123
    Printer&lt;std::string&gt; string_printer;
    string_printer.print("Hello, World!"); // Outputs: Hello, World! without quotes if the header is not included
    return 0;
}</pre>
<p>In this setup, if the <code>printer_string.h</code> header is not included in <code>main.cpp</code>, the compiler will use the default <code>Printer</code> template for <code>std::string</code>, resulting in incorrect behavior (printing the string without quotes).</p>
<p>Templates<a id="_idIndexMarker366"/> are a crucial part of the C++ programming language, offering powerful capabilities for creating generic, reusable, and type-safe code. They are indispensable in various scenarios, such as developing generic algorithms, container classes, smart pointers, and other utilities that need to work seamlessly with multiple data types. Templates enable developers to write flexible and efficient code, ensuring that the same functionality can be applied to different types without duplication.</p>
<p>However, the power of templates does not come without cost. The use of templates can lead to increased compilation times and code bloat, especially in systems that support a wide range of types and combinations. The syntax and resulting error messages can be complex and difficult to understand, posing a challenge for less experienced developers. Additionally, debugging template-heavy code can be cumbersome due to limited tool support and the intricate nature of template instantiations.</p>
<p>Moreover, templates can introduce less obvious interactions with the rest of the code base, which might cause issues if not managed properly. Developers must also be aware of advanced features, such as template specialization, which require careful inclusion of specialized headers to avoid incorrect behavior.</p>
<p>Given these caveats, it is essential for developers to think carefully before incorporating templates into their projects. While they provide significant benefits, the potential drawbacks necessitate a thoughtful approach to ensure that the advantages outweigh the complexities. Proper understanding and judicious use of templates can lead to more robust, maintainable, and efficient C++ applications.</p>
<h1 id="_idParaDest-146"><a id="_idTextAnchor145"/>Summary</h1>
<p>In this chapter, we explored the intricacies of advanced C++ programming, focusing on class design, inheritance, and templates. We began with the principles of effective class design, emphasizing the importance of encapsulating the minimum necessary functionality and data to achieve better modularity and maintainability. Through practical examples, we highlighted both good and bad design practices. Moving on to inheritance, we examined its benefits, such as code reuse, hierarchical structuring, and polymorphism, while also addressing its drawbacks, including tight coupling, complex hierarchies, and potential violations of the LSP. We provided guidance on when to use inheritance and when to consider alternatives such as composition. In the section on templates, we delved into their role in enabling generic programming, allowing for flexible and reusable components that work with any data type. We discussed the advantages of templates, such as code reusability, type safety, and performance optimization, but also pointed out their disadvantages, including increased compilation times, code bloat, and the complexity of understanding and debugging template-heavy code. Throughout these discussions, we underscored the need for careful consideration and understanding when utilizing these powerful features to ensure robust and maintainable C++ applications. In the next chapter, we will shift our focus to API design, exploring best practices for creating clear, efficient, and user-friendly interfaces in C++.</p>
</div>
</body></html>