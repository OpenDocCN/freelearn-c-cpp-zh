- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Classes, Objects, and OOP in C++
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++ 中的类、对象和面向对象编程（OOP）
- en: In this chapter, we delve into the sophisticated realm of classes, objects,
    and **object-oriented programming** (**OOP**) in C++. Tailored for the advanced
    C++ practitioner, our focus will be on elevating your understanding of class design,
    method implementation, inheritance, and template usage, steering clear of introductory
    explanations of these concepts. Our goal is to enhance your ability to construct
    robust and efficient software architectures using advanced object-oriented techniques.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了 C++ 中类、对象和面向对象编程（OOP）的复杂领域。针对高级 C++ 实践者，我们的重点是提高你对类设计、方法实现、继承和模板使用的理解，避免对这些概念进行入门级解释。我们的目标是提高你使用高级面向对象技术构建健壮和高效软件架构的能力。
- en: The discussion begins by examining the intricate considerations necessary when
    defining classes, guiding you through the decision-making process to determine
    the best candidates for class encapsulation. This includes distinguishing situations
    where a simpler data structure, such as a struct, might be more appropriate, thereby
    optimizing both performance and readability.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论从检查定义类时必要的复杂考虑开始，引导你通过决策过程来确定类封装的最佳候选者。这包括区分简单数据结构（如结构体）可能更合适的情况，从而优化性能和可读性。
- en: Further, we explore the design of methods within classes—highlighting various
    types of methods, such as accessors, mutators, and factory methods, and establishing
    conventions that promote code clarity and maintainability. Special attention is
    given to advanced method design practices, including const correctness and visibility
    scopes, which are pivotal for securing and optimizing access to class data.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们探讨了类内方法的设计——突出各种类型的方法，如访问器、修改器和工厂方法，并建立促进代码清晰性和可维护性的约定。特别关注高级方法设计实践，包括
    const 正确性和可见性范围，这对于确保和优化对类数据的访问至关重要。
- en: Inheritance, a cornerstone of OOP, is scrutinized not only for its benefits
    but also its liabilities. To provide a balanced perspective, we present alternatives
    such as composition and interface segregation that might better serve your design
    goals in certain scenarios. This nuanced discussion aims to equip you with the
    discernment necessary to choose the best inheritance strategy or its alternatives,
    depending on the specific requirements and constraints of your projects.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 继承，作为面向对象（OOP）的基石，不仅被审查其优点，还被审查其缺点。为了提供一个平衡的视角，我们提出了如组合和接口隔离等替代方案，这些方案可能在某些情况下更好地服务于你的设计目标。这种细微的讨论旨在为你提供必要的洞察力，以便根据项目的具体需求和约束选择最佳的继承策略或其替代方案。
- en: Expanding the discussion to generic programming, we delve into sophisticated
    template usage, which includes advanced techniques such as template metaprogramming.
    This section aims to demonstrate how templates can be leveraged to create highly
    reusable and efficient code. Additionally, we will touch upon the design of APIs
    using OOP principles, emphasizing how well-crafted interfaces can significantly
    enhance the usability and longevity of software components.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 将讨论扩展到泛型编程，我们深入探讨了复杂的模板使用，包括模板元编程等高级技术。本节旨在展示如何利用模板创建高度可重用和高效的代码。此外，我们还将简要介绍使用面向对象原则设计
    API，强调精心设计的接口可以显著提高软件组件的可使用性和持久性。
- en: Each topic is punctuated with practical examples and case studies drawn from
    real-world applications, illustrating how these advanced techniques are applied
    in modern software development. By the end of this chapter, you should possess
    a deeper understanding of how to utilize OOP features in C++ to craft elegant,
    efficient, and scalable software architectures.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 每个主题都配有来自现实应用中的实际例子和案例研究，展示了这些高级技术在现代软件开发中的应用。到本章结束时，你应该对如何利用 C++ 中的面向对象（OOP）特性来构建优雅、高效和可扩展的软件架构有更深入的理解。
- en: Good candidates for classes
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类的好候选者
- en: Identifying good candidates for classes in OOP involves looking for entities
    that naturally encapsulate both data and behavior.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象（OOP）中识别类的好候选者涉及寻找自然封装数据和行为的实体。
- en: Cohesion
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内聚性
- en: A class should represent a set of functionalities that are tightly related to
    each other. This means all the methods and data in the class are directly related
    to the specific functionalities it provides. For example, a `Timer` class is a
    good candidate because it encapsulates properties and methods related to timing
    (start, stop, reset times), maintaining high cohesion.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类应该代表一组紧密相关的功能。这意味着类中的所有方法和数据都直接与其提供的特定功能相关。例如，一个`Timer`类是一个很好的候选者，因为它封装了与计时相关的属性和方法（开始、停止、重置时间），保持了高度的聚合性。
- en: Encapsulation
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 封装
- en: Entities that have attributes and behaviors that should be shielded from outside
    interference or misuse can be encapsulated in a class.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 具有应从外部干扰或误用中屏蔽的属性和行为实体可以封装在类中。
- en: A `BankAccount` class encapsulates the balance (attribute) and behaviors such
    as `deposit`, `withdraw`, and `transfer`, ensuring that balance manipulations
    are done only through controlled and safe operations.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`BankAccount`类封装了余额（属性）以及如`deposit`、`withdraw`和`transfer`之类的行为，确保余额操作仅通过受控和安全操作进行。
- en: Reusability
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可重用性
- en: Classes should be designed to be reused across different parts of a program
    or even in different programs.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 类应该设计成可以在程序的不同部分或甚至在不同程序中重用。
- en: A `DatabaseConnection` class that manages database connections can be reused
    in multiple applications that require database interactions, handling connection,
    disconnection, and error management.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一个管理数据库连接的`DatabaseConnection`类可以在需要数据库交互的多个应用程序中重用，处理连接、断开连接和错误管理。
- en: Abstraction
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象
- en: A class should provide a simplified interface by hiding complex logic from the
    user, representing a higher level of abstraction. For example, the standard library
    has classes such as `std::vector` that abstract the complexities of dynamic arrays,
    providing a simple interface for array operations.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类应该通过隐藏复杂的逻辑来提供一个简化的接口，代表更高层次的抽象。例如，标准库中有如`std::vector`之类的类，它们抽象了动态数组的复杂性，为数组操作提供了一个简单的接口。
- en: Real-world entities
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实际实体
- en: Classes often represent objects from the real world that are relevant to the
    system being modeled.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 类通常代表与正在建模的系统相关的现实世界中的对象。
- en: In a flight reservation system, classes such as `Flight`, `Passenger`, and `Ticket`
    are good candidates because they directly represent real-world objects with clear
    attributes and behaviors.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在航班预订系统中，如`Flight`、`Passenger`和`Ticket`之类的类是很好的候选者，因为它们直接代表具有清晰属性和行为的现实世界对象。
- en: Manage complexity
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理复杂性
- en: Classes should help in managing complexity by breaking down large problems into
    smaller, more manageable parts.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 类应该通过将大问题分解成更小、更易于管理的部分来帮助管理复杂性。
- en: Here is an example – in graphic editing software, a `GraphicObject` class might
    serve as a base class for more specific graphic objects such as `Circle`, `Rectangle`,
    and `Polygon`, organizing graphic properties and functionalities systematically.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子——在图形编辑软件中，一个`GraphicObject`类可能作为更具体图形对象（如`Circle`、`Rectangle`和`Polygon`）的基类，系统地组织图形属性和功能。
- en: Minimizing class responsibilities through encapsulation
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过封装最小化类的职责
- en: Encapsulation is a fundamental concept in OOP that involves bundling the data
    (attributes) and the methods (functions) that operate on the data into a single
    unit or class. It not only hides the internal state of the object from the outside
    but also modularizes its behavior, making the software easier to manage and extend.
    However, how much functionality and data a class should encapsulate can significantly
    affect the maintainability and scalability of your application.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 封装是面向对象编程中的一个基本概念，它涉及将数据（属性）和操作数据的方法（函数）捆绑成一个单一单元或类。它不仅隐藏了对象的内部状态，还模块化了其行为，使软件更容易管理和扩展。然而，一个类应该封装多少功能和数据可以显著影响应用程序的可维护性和可扩展性。
- en: Over-encapsulation in classes – a common pitfall
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类中的过度封装——一个常见的陷阱
- en: In practice, encapsulating too much functionality and data within a single class
    is a common mistake that can lead to several issues. This often results in a **god
    object** – a class that controls too many different parts of the application,
    doing too much work on its own. Such classes are typically hard to understand,
    difficult to maintain, and problematic to test.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，在单个类中封装过多的功能和数据是一个常见的错误，可能导致多个问题。这通常会导致一个**神对象**——一个控制应用程序中太多不同部分的类，自己承担了太多工作。这样的类通常难以理解，难以维护，且测试起来有问题。
- en: Let’s look at an example of a badly encapsulated `Car` class.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个封装不良的`Car`类的例子。
- en: 'Consider the following example of a `Car` class that attempts to manage not
    only the car’s basic properties but also detailed aspects of its internal systems
    such as the engine, transmission, and entertainment system:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下`Car`类的示例，它试图管理汽车的基本属性以及其内部系统的详细方面，如发动机、变速箱和娱乐系统：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This `Car` class is problematic because it tries to manage too many aspects
    of the car’s functionality, which are better handled by specialized components.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Car`类有问题，因为它试图管理汽车功能太多的方面，这些方面最好由专门的组件来处理。
- en: Proper encapsulation using composition
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用组合进行适当的封装
- en: A better approach is to use composition to delegate responsibilities to other
    classes, each handling a specific part of the system’s functionality. This not
    only adheres to the Single Responsibility Principle but also makes the system
    more modular and easier to maintain.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的方法是使用组合将责任委托给其他类，每个类处理系统功能的一个特定部分。这不仅遵循单一职责原则，而且使系统更加模块化，更容易维护。
- en: 'Here is an example of a well-designed `Car` class using composition:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个使用组合设计良好的`Car`类的示例：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this refined design, the `Car` class acts as a coordinator among its components
    rather than directly managing every detail. Each subsystem – engine, transmission,
    and entertainment system – handles its own state and behavior, leading to a design
    that is easier to maintain, test, and extend. This example showcases how appropriate
    encapsulation and composition can significantly enhance the structure and quality
    of object-oriented software.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个改进的设计中，`Car`类充当其组件之间的协调者，而不是直接管理每个细节。每个子系统——发动机、变速箱和娱乐系统——处理自己的状态和行为，导致一个更容易维护、测试和扩展的设计。这个例子展示了适当的封装和组合如何显著提高面向对象软件的结构和质量。
- en: Usage of structs and classes in C++
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++中结构和类的使用
- en: 'In C++, both structs and classes are used to define user-defined types that
    can contain data and functions. The primary difference between them lies in their
    default access levels: members of a class are private by default, while members
    of a struct are public. This distinction subtly influences their typical uses
    in C++ programming.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，结构和类都用于定义用户定义的类型，可以包含数据和函数。它们之间的主要区别在于它们的默认访问级别：类的成员默认是私有的，而结构体的成员默认是公开的。这种区别微妙地影响了它们在C++编程中的典型用途。
- en: Structs – ideal for passive data structures
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结构体——理想的被动数据结构
- en: Structs in C++ are particularly suited for creating passive data structures
    where the primary purpose is to store data without encapsulating too much behavior.
    Due to their public-by-default nature, structs are often used when you want to
    allow direct access to the data members, which can simplify code and reduce the
    need for additional functions to manipulate data.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，结构体特别适合创建被动数据结构，其主要目的是存储数据而不需要封装太多行为。由于它们的默认公开性质，结构体通常用于当你想要允许直接访问数据成员时，这可以简化代码并减少操作数据所需额外函数的需求。
- en: 'The following list outlines the instances when you should use structs:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表概述了你应该使用结构体的实例：
- en: '**Data objects**: Structs are perfect for creating **plain old data** (**POD**)
    structures. These are simple objects that primarily hold data and have little
    or no functionality (methods). For example, structs are often used to represent
    coordinates in space, RGB color values, or settings configurations where direct
    access to data fields is more convenient than going through getters and setters:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据对象**：结构体非常适合创建**纯数据**（**POD**）结构。这些是主要持有数据且功能很少或没有的方法简单对象。例如，结构体通常用于表示空间中的坐标、RGB颜色值或设置配置，在这些情况下，直接访问数据字段比通过获取器和设置器更方便：'
- en: '[PRE2]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If C++ 20 is not available for your project, you can utilize C99-designated
    initializers to achieve a similar effect:'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你的项目不支持C++ 20，你可以利用C99指定的初始化器来实现类似的效果：
- en: '[PRE17]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**Interoperability**: Structs are useful in interfacing with code in C or in
    systems where data alignment and layout are critical. They ensure compatibility
    and performance in low-level operations, such as hardware interfacing or network
    communication.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**互操作性**：结构体在接口C或数据对齐和布局至关重要的系统中很有用。它们确保在底层操作（如硬件接口或网络通信）中的兼容性和性能。'
- en: '**Lightweight containers**: When you need a lightweight container to group
    together a few variables, structs provide a more transparent and less cumbersome
    way than classes. They are ideal for small aggregations where encapsulation isn’t
    a primary concern.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轻量级容器**：当你需要轻量级容器来组合几个变量时，结构体比类提供更透明和更不繁琐的方法。它们对于封装不是主要关注的小聚合来说很理想。'
- en: Classes – encapsulating complexity
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类 – 封装复杂性
- en: Classes are the backbone of C++ OOP and are used to encapsulate data and behavior
    into a single entity. The private-by-default access specifier encourages the hiding
    of internal state and implementation details, promoting a more rigorous design
    that follows encapsulation and abstraction principles.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 类是C++面向对象编程的支柱，用于将数据和行为封装成一个单一实体。默认的私有访问修饰符鼓励隐藏内部状态和实现细节，促进遵循封装和抽象原则的更严格设计。
- en: 'The following list explains when you should use classes:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表解释了何时应该使用类：
- en: '**Complex systems**: For components that involve complex data manipulations,
    state management, and interface control, classes are the preferred choice. They
    provide mechanisms for data protection and interface abstraction, which are crucial
    for maintaining the integrity and stability of software systems:'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂系统**：对于涉及复杂数据处理、状态管理和接口控制的组件，类是首选选择。它们提供了数据保护和接口抽象的机制，这对于维护软件系统的完整性和稳定性至关重要：'
- en: '[PRE18]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '**Behavior encapsulation**: Classes are ideal when the functionality (methods)
    is as important as the data. Encapsulating behaviors with data into classes allows
    for more maintainable and error-free code, as operations on the data are tightly
    controlled and clearly defined.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行为封装**：当功能（方法）与数据一样重要时，类是理想的。将行为与数据封装到类中可以允许更易于维护和更无错误的代码，因为对数据的操作是紧密控制和明确定义的。'
- en: '**Inheritance and polymorphism**: Classes support inheritance and polymorphism,
    enabling the creation of complex object hierarchies that can be extended and modified
    dynamically. This is essential in many software design patterns and advanced system
    architectures.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**继承和多态**：类支持继承和多态，能够创建可以动态扩展和修改的复杂对象层次结构。这在许多软件设计模式和高级系统架构中是必不可少的。'
- en: 'Choosing between a struct and a class in C++ should be guided by the intended
    use: structs for simple, transparent data containers where direct data access
    is acceptable or necessary, and classes for more complex systems where encapsulation,
    behavior, and interface control are required. Understanding and utilizing the
    strengths of each can lead to cleaner, more efficient, and scalable code.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中选择结构体和类应根据预期用途进行指导：结构体用于简单、透明的数据容器，其中直接数据访问是可以接受或必要的，而类用于需要封装、行为和接口控制的更复杂系统。理解和利用每个的优点可以导致更干净、更高效和可扩展的代码。
- en: Common method types in classes – getters and setters
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类中的常见方法类型 – 获取器和设置器
- en: In OOP, particularly in languages such as Java, **getters** and **setters**
    are standard methods that serve as the primary interface for accessing and modifying
    the private data members of a class. These methods provide controlled access to
    an object’s properties, adhering to the encapsulation principle, which is a cornerstone
    of effective object-oriented design.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程（OOP）中，尤其是在像Java这样的语言中，**获取器**和**设置器**是标准方法，它们作为访问和修改类私有数据成员的主要接口。这些方法提供了对对象属性的受控访问，遵循封装原则，这是有效面向对象设计的基石。
- en: Purpose and conventions of getters and setters
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取器和设置器的目的和约定
- en: Getters (also known as accessors) are methods used to retrieve the value of
    a private field. They do not modify the data. Setters (also known as mutators)
    are methods that allow the modification of private fields based on the input they
    receive. These methods enable the internal state of an object to remain consistent
    and valid by potentially enforcing constraints or conditions when data is set.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 获取器（也称为访问器）是用于检索私有字段值的函数。它们不会修改数据。设置器（也称为修改器）是允许根据接收到的输入修改私有字段的函数。这些方法通过在设置数据时可能强制执行约束或条件，使对象的内部状态保持一致和有效。
- en: 'Here are the conventions of getters and setters:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是获取器和设置器的约定：
- en: '`x`, is named `get_x()`, and the setter is named `set_x(value)`. This naming
    convention is almost universal in Java and is commonly adopted in other programming
    languages that support class-based OOP.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x`的getter命名为`get_x()`，setter命名为`set_x(value)`。这种命名约定在Java中几乎是通用的，并且在支持基于类的OOP的其他编程语言中也普遍采用。'
- en: '**Return types and parameters**: A getter for a property returns the same type
    as the property itself and takes no parameters, whereas a setter returns void
    and takes a parameter of the same type as the property it sets.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**返回类型和参数**：属性的getter返回与属性本身相同的类型，并且不接受任何参数，而setter返回void，并接受与设置的属性相同类型的参数。'
- en: 'Here is an example of this in C++:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个C++中的例子：
- en: '[PRE27]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Usefulness and recommendations
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有用性和建议
- en: '**Controlled access and validation**: Getters and setters encapsulate the fields
    of a class, providing controlled access and validation logic. This helps to maintain
    the integrity of the data, ensuring that no invalid or inappropriate values are
    set.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**受控访问和验证**：getter和setter封装了类的字段，提供了受控访问和验证逻辑。这有助于维护数据的完整性，确保不会设置无效或不适当的值。'
- en: '**Flexibility**: By using getters and setters, developers can change the underlying
    implementation of how the data is stored and retrieved without changing the external
    interface of the class. This can be particularly useful in maintaining backward
    compatibility or when the data representation needs to be changed for optimization.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**灵活性**：通过使用getter和setter，开发者可以在不改变类的外部接口的情况下更改数据存储和检索的底层实现。这在维护向后兼容性或需要为优化更改数据表示时特别有用。'
- en: '**Consistency**: These methods can enforce rules that need to be maintained
    consistently throughout an object’s life cycle. For example, ensuring that a field
    never holds a null value or adheres to a specific format.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**一致性**：这些方法可以强制执行需要在对象生命周期内持续维护的规则。例如，确保字段永远不会持有null值或遵循特定的格式。'
- en: When to use getters and setters, and when not to
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 何时使用getter和setter，何时不使用
- en: The rule of thumb is to use getters and setters in classes where encapsulation,
    business logic, or inheritance complexities are present. For example, for the
    `Car` and `Engine` classes with relatively complex logic, getters and setters
    are essential to maintain the integrity of the data and ensure that the system
    functions correctly. On the other hand, for a simple data structure such as `Point`
    or `Color`, where the primary purpose is to hold data without much behavior, using
    a struct with public data members might be more appropriate. Note that if the
    struct is a part of a library or API, it might be beneficial to provide getters
    and setters for future extensibility.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 常规做法是在存在封装、业务逻辑或继承复杂性的类中使用getter和setter。例如，对于具有相对复杂逻辑的`Car`和`Engine`类，getter和setter对于维护数据的完整性和确保系统正确运行是必不可少的。另一方面，对于像`Point`或`Color`这样的简单数据结构，其主要目的是存储数据而不涉及太多行为，使用具有公共数据成员的结构体可能更合适。请注意，如果结构体是库或API的一部分，为了未来的可扩展性，提供getter和setter可能是有益的。
- en: This nuanced approach allows developers to balance between control and simplicity,
    choosing the most appropriate tool for the specific requirements of their software
    components.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这种细微的方法允许开发者平衡控制与简单性，为软件组件的具体需求选择最合适的工具。
- en: Inheritance in C++
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++中的继承
- en: Inheritance and composition are two fundamental OOP concepts that enable the
    creation of complex and reusable software designs in C++. They facilitate code
    reuse and help in modeling real-world relationships, though they operate differently.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 继承和组合是C++中两个基本面向对象编程概念，它们使得创建复杂且可重用的软件设计成为可能。它们促进了代码重用，并有助于模拟现实世界的关系，尽管它们的工作方式不同。
- en: 'Inheritance allows one class, known as the derived or subclass, to inherit
    properties and behaviors from another class, the base or superclass. This enables
    the derived class to reuse the code in the base class while extending or overriding
    its functionality. For instance, consider a `BaseSocket` class and its derived
    classes, `TcpSocket` and `UdpSocket`. The derived classes inherit the basic functionality
    of `BaseSocket` and add their specific implementations:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 继承允许一个类（称为派生类或子类）从另一个类（称为基类或超类）继承属性和行为。这使得派生类可以重用基类中的代码，同时扩展或覆盖其功能。例如，考虑一个`BaseSocket`类及其派生类`TcpSocket`和`UdpSocket`。派生类继承了`BaseSocket`的基本功能，并添加了它们特定的实现：
- en: '[PRE28]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this example, the `TcpSocket` and `UdpSocket` classes inherit from `BaseSocket`,
    demonstrating how inheritance promotes code reuse and establishes an “is-a” relationship.
    Inheritance also supports polymorphism, allowing objects of the derived class
    to be treated as instances of the base class, enabling dynamic method binding.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`TcpSocket` 和 `UdpSocket` 类继承自 `BaseSocket`，展示了继承如何促进代码重用并建立“是一种”关系。继承还支持多态，允许派生类的对象被当作基类的实例来处理，从而实现动态方法绑定。
- en: 'Composition, on the other hand, involves creating classes by including objects
    of other classes. Instead of inheriting from a base class, a class is composed
    of one or more objects from other classes, which are used to achieve the desired
    functionality. This represents a “has-a” relationship. For example, consider a
    `CommunicationChannel` class that can own `BaseSocket`. The `CommunicationChannel`
    class uses the `BaseSocket` object to implement its communication functionality,
    demonstrating composition:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，组合涉及通过包含其他类的对象来创建类。而不是从基类继承，一个类由一个或多个其他类的对象组成，这些对象用于实现所需的功能。这代表了一种“有”的关系。例如，考虑一个可以拥有
    `BaseSocket` 的 `CommunicationChannel` 类。`CommunicationChannel` 类使用 `BaseSocket`
    对象来实现其通信功能，展示了组合：
- en: '[PRE29]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this example, the `CommunicationChannel` class contains a `BaseSocket` object
    and uses it to implement its functionality. The `transmit` method sends data in
    chunks until all data is sent, checking for errors (when the return value is less
    than `0`). This demonstrates how composition offers flexibility, allowing objects
    to be dynamically assembled at runtime. It also promotes better encapsulation
    by containing objects and exposing only necessary interfaces, thereby avoiding
    tight coupling between classes and making the code more modular and easier to
    maintain.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`CommunicationChannel` 类包含一个 `BaseSocket` 对象，并使用它来实现其功能。`transmit` 方法将数据分块发送，直到所有数据发送完毕，并检查错误（当返回值小于
    `0` 时）。这展示了组合如何提供灵活性，允许对象在运行时动态组装。它还通过包含对象并仅暴露必要的接口来促进更好的封装，从而避免类之间的紧密耦合，使代码更模块化且易于维护。
- en: In summary, both inheritance and composition are essential tools in C++ for
    creating reusable and maintainable code. Inheritance is suitable for scenarios
    with a clear hierarchical relationship and where polymorphism is needed, while
    composition is ideal for assembling complex behaviors from simpler components,
    offering flexibility and better encapsulation. Understanding when to use each
    approach is key to effective object-oriented design.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，继承和组合都是 C++ 中创建可重用和维护性代码的重要工具。继承适用于具有明确层次关系且需要多态的场景，而组合则是从更简单的组件组装复杂行为时的理想选择，提供了灵活性和更好的封装。理解何时使用每种方法对于有效的面向对象设计至关重要。
- en: Evolution of inheritance in C++
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C++ 中继承的演变
- en: Originally, inheritance was seen as a powerful tool for reducing code duplication
    and enhancing the expressiveness of code. It allowed for the creation of a derived
    class that inherits properties and behavior from a base class. However, as the
    use of C++ grew in complex systems, the limitations of inheritance as a one-size-fits-all
    solution became apparent.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，继承被视为一种强大的工具，可以减少代码重复并增强代码的表达性。它允许创建一个派生类，该类从基类继承属性和行为。然而，随着 C++ 在复杂系统中的应用增长，继承作为一刀切解决方案的局限性变得明显。
- en: Implementation of inheritance at the binary level
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二进制级别的继承实现
- en: 'Interestingly, on a binary level, inheritance in C++ is implemented similarly
    to composition. Essentially, the derived class contains an instance of the base
    class within its structure. This can be visualized in a simplified ASCII diagram:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，在二进制级别，C++ 中的继承实现与组合类似。本质上，派生类在其结构中包含基类的一个实例。这可以通过一个简化的 ASCII 图表来可视化：
- en: '[PRE30]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this layout, the base class part of the derived class object contains all
    the data members that belong to the base class, and directly after it in memory,
    the additional data members of the derived class are placed. Note that the actual
    order of data members in memory can be influenced by factors such as alignment
    requirements and compiler optimizations.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种布局中，派生类对象中的基类部分包含属于基类的所有数据成员，并在内存中直接跟在其后的是派生类的附加数据成员。请注意，内存中数据成员的实际顺序可能受到对齐要求、编译器优化等因素的影响。
- en: Pros and cons of inheritance
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承的优缺点
- en: 'Here are the pros of inheritance:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是继承的优点：
- en: '`MediaContent` class will serve as the base class for all types of media content.
    It will encapsulate common attributes and behaviors such as `title`, `duration`,
    and basic playback controls (`play`, `pause`, `stop`):'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MediaContent` 类将作为所有类型媒体内容的基类。它将封装常见的属性和行为，例如 `title`（标题）、`duration`（时长）和基本的播放控制（`play`（播放）、`pause`（暂停）、`stop`（停止））：'
- en: '[PRE31]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `Audio` class extends `MediaContent`, adding specific attributes related
    to audio files, such as bitrate:'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Audio` 类扩展了 `MediaContent`，添加了与音频文件相关的特定属性，例如比特率：'
- en: '[PRE48]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Similarly, the `Video` class extends `MediaContent` and introduces additional
    attributes such as `resolution`:'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 同样，`Video` 类扩展了 `MediaContent` 并引入了额外的属性，例如 `resolution`（分辨率）：
- en: '[PRE66]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Here’s how these classes could be used in a simple media player system:'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面是如何在简单的媒体播放器系统中使用这些类：
- en: '[PRE84]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: In this example, both `Audio` and `Video` inherit from `MediaContent`. This
    allows us to reuse the `title` and `duration` attributes and requires the implementation
    of the playback controls (`play`, `pause`, `stop`) tailored to each media type.
    This hierarchy demonstrates how inheritance facilitates code reuse and system
    extensibility while enabling specific behaviors for different types of media content
    in a unified framework. Each class adds only what is unique to its type, adhering
    to the principle that base classes provide common functionality and derived classes
    extend or modify that functionality for specific needs.
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个例子中，`Audio` 和 `Video` 都继承自 `MediaContent`。这使我们能够重用 `title` 和 `duration` 属性，并需要实现针对每种媒体类型的播放控制（`play`、`pause`、`stop`）。这个层次结构展示了继承如何促进代码重用和系统可扩展性，同时在一个统一的框架中为不同类型的媒体内容启用特定的行为。每个类只添加其类型独有的内容，遵循基类提供通用功能，派生类为特定需求扩展或修改该功能的原理。
- en: '**Polymorphism**: Through inheritance, C++ supports polymorphism, which allows
    for the use of a base class reference to refer to an object of a derived class.
    This enables dynamic method binding and a flexible interface to multiple derived
    types. Our media content hierarchy can be used for implementing a media player
    that can handle different types of media content uniformly:'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多态性**：通过继承，C++ 支持多态性，允许使用基类引用来引用派生类对象。这实现了动态方法绑定和对多个派生类型的灵活接口。我们的媒体内容层次结构可以用于实现一个可以统一处理不同类型媒体内容的媒体播放器：'
- en: '[PRE95]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: The `add` method accepts media content of any type that derives from `MediaContent`,
    demonstrating polymorphism by using a base class pointer to refer to derived class
    objects. This is enabled by storing the media items in `std::vector` of `std::unique_ptr<MediaContent>`.
    The `play_all` method iterates through the stored media and calls the play method
    on each item. Despite the actual media type being different (audio or video),
    the media player treats them all as `MediaContent`. The correct play method (from
    either `Audio` or `Video`) is invoked at runtime, which is an example of dynamic
    polymorphism (also known as dynamic dispatch).
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`add` 方法接受任何从 `MediaContent` 派生的媒体内容类型，通过使用基类指针来引用派生类对象，展示了多态性。这是通过将媒体项存储在
    `std::vector` 的 `std::unique_ptr<MediaContent>` 中实现的。`play_all` 方法遍历存储的媒体，并对每个项目调用播放方法。尽管实际的媒体类型不同（音频或视频），媒体播放器将它们都视为
    `MediaContent`。正确的播放方法（来自 `Audio` 或 `Video`）在运行时被调用，这是动态多态性（也称为动态分派）的一个例子。'
- en: '**Hierarchical structuring**: It provides a natural way to organize related
    classes in a hierarchical manner that models real-world relationships.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分层结构**：它提供了一种自然的方式，以分层的方式组织相关类，从而模拟现实世界的关系。'
- en: 'Here is the con of inheritance:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是继承的缺点：
- en: '**Tight coupling**: Inheritance creates a tight coupling between base and derived
    classes. Changes to the base class can inadvertently affect derived classes, leading
    to fragile code that can break when base classes are modified. The following example
    illustrates the issue of tight coupling through inheritance in a software system.
    We’ll use a scenario involving an online store that manages different types of
    discounts using a class hierarchy.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**紧密耦合**：继承在基类和派生类之间创建了一种紧密耦合。基类中的更改可能会无意中影响派生类，导致代码脆弱，当修改基类时可能会崩溃。以下示例通过继承在软件系统中说明了紧密耦合的问题。我们将使用一个涉及在线商店的场景，该商店使用类层次结构管理不同类型的折扣。'
- en: Base class – Discount
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基类 – 折扣
- en: The `Discount` class provides the basic structure and functionality for all
    types of discounts. It calculates a discount based on a percentage reduction;
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`Discount` 类为所有类型的折扣提供了基本的结构和功能。它根据百分比减少来计算折扣；'
- en: '[PRE116]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Derived class – SeasonalDiscount
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 派生类 – 季节性折扣
- en: 'The `SeasonalDiscount` class extends `Discount` and modifies the discount calculation
    based on seasonal factors, such as increasing the discount during the holiday
    season:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`SeasonalDiscount`类扩展了`Discount`，并根据季节因素修改折扣计算，例如在假日季节增加折扣：'
- en: '[PRE117]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Derived class – ClearanceDiscount
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 派生类 – ClearanceDiscount
- en: 'The `ClearanceDiscount` class also extends `Discount`, designed for items on
    clearance where the discount might be significantly higher:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClearanceDiscount`类也扩展了`Discount`，用于处理折扣可能显著更高的清仓商品：'
- en: '[PRE118]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Demonstration and tight coupling issue:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 演示和紧耦合问题：
- en: '[PRE119]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Tight coupling problems
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 紧耦合问题
- en: 'The following is a list of tight-coupling problems:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个紧耦合问题的列表：
- en: '`apply_discount`). Any change in the base class method’s signature or the logic
    within `apply_discount` could necessitate changes in all derived classes.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apply_discount`)。任何对基类方法签名或`apply_discount`内部逻辑的更改都可能需要修改所有派生类。'
- en: '`_discount_percent`. If the formula in the base class changes (say, incorporating
    minimum or maximum caps), all subclasses might need extensive modifications to
    conform to the new logic.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_discount_percent`。如果基类中的公式发生变化（例如，包含最小或最大限制），所有子类可能需要进行大量修改以符合新的逻辑。'
- en: '**Inflexibility**: The coupling makes it hard to modify the behavior of one
    discount type without risking impacts on others. This design lacks flexibility
    where independent evolution of discount calculation strategies might be necessary.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不灵活性**：这种耦合使得在不影响其他类型的情况下修改一种折扣类型的行为变得困难。这种设计在可能需要独立演变折扣计算策略的地方缺乏灵活性。'
- en: Solution – decouple with the strategy pattern
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案 – 使用策略模式解耦
- en: 'One way to reduce this coupling is to use the **strategy pattern**, which involves
    defining a family of algorithms (discount strategies), encapsulating each one,
    and making them interchangeable. This allows the discount algorithms to vary independently
    from the clients that use them:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 减少这种耦合的一种方法是通过使用**策略模式**，它涉及定义一组算法（折扣策略），封装每个算法，并使它们可互换。这允许折扣算法独立于使用它们的客户端而变化：
- en: '[PRE120]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'This approach decouples the discount calculation from the client (`Discount`)
    using it, allowing each discount strategy to evolve independently without affecting
    others. A couple of others ways to reduce the coupling are:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法通过将折扣计算与使用它的客户端（`Discount`）解耦，允许每个折扣策略独立演变而不影响其他策略。减少耦合的其他几种方法包括：
- en: '`HybridFlyingElectricCar` that inherits from both `ElectricCar` and `FlyingCar`,
    with each of these classes further inheriting from their respective hierarchies,
    results in a highly tangled class structure. This complexity makes the system
    tough to debug, extend, or reliably use, while also multiplying the challenges
    in testing and maintaining consistent behavior across various scenarios.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HybridFlyingElectricCar`类继承自`ElectricCar`和`FlyingCar`，每个这些类进一步继承自它们各自的层次结构，导致高度纠缠的类结构。这种复杂性使得系统难以调试、扩展或可靠地使用，同时也增加了在各种场景下测试和维护一致行为所面临的挑战。'
- en: To manage the complications introduced by extensive use of inheritance, several
    strategies can be recommended. Favoring composition over inheritance often provides
    greater flexibility, allowing systems to be composed of well-defined, loosely
    coupled components rather than relying on rigid inheritance structures. Keeping
    inheritance chains short and manageable – generally no deeper than two or three
    levels – helps preserve system clarity and maintainability. Employing interfaces,
    particularly in languages such as Java and C#, offers a way to achieve polymorphic
    behavior without the overhead associated with inheritance. When multiple inheritance
    is unavoidable, it’s crucial to ensure clear documentation and consider the use
    of interface-like structures or mixins, which can help minimize complexity and
    enhance system robustness.
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了管理由广泛使用继承引入的复杂性，可以推荐几种策略。优先考虑组合而非继承通常提供更大的灵活性，允许系统由定义良好、松散耦合的组件组成，而不是依赖于僵化的继承结构。保持继承链短且可管理——通常不超过两到三级——有助于保持系统清晰性和可维护性。在Java和C#等语言中使用接口提供了一种实现多态行为的方法，而不需要与继承相关的开销。当多继承不可避免时，确保清晰的文档并考虑使用类似接口的结构或混入（mixins）至关重要，这有助于最小化复杂性并增强系统健壮性。
- en: '**Liskov Substitution Principle (LSP)**: We mentioned this principle earlier
    in this book; LSP states that objects of a superclass should be replaceable with
    objects of its subclasses without altering the desirable properties of the program
    (correctness, task performed, etc.). Inheritance can sometimes lead to violations
    of this principle, especially when subclasses diverge from the behavior expected
    by the base class. The following sections include typical problems related to
    violations of the LSP, illustrated with simple examples.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Liskov 替换原则 (LSP)**：我们在本书中较早提到了这个原则；LSP 声明，超类对象应该可以替换为其子类对象，而不会改变程序的可取属性（正确性、执行的任务等）。继承有时可能导致违反此原则，特别是当子类偏离基类预期的行为时。以下各节包括与
    LSP 违反相关的典型问题，通过简单的示例进行说明。'
- en: Unexpected behaviors in derived classes
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 派生类中的意外行为
- en: 'When derived classes override methods of the base class in ways that change
    the expected behavior significantly, it can lead to unexpected results when these
    objects are used interchangeably:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当派生类以改变预期行为的方式覆盖基类的方法时，这些对象被互换使用时可能会导致意外结果：
- en: '[PRE121]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Here, replacing a `Bird` object with an `Ostrich` object in the `make_bird_fly`
    function leads to a runtime error because ostriches can’t fly, violating LSP.
    Users of the `Bird` class expect any subclass to fly, and `Ostrich` breaks this
    expectation.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，将 `Bird` 对象替换为 `Ostrich` 对象在 `make_bird_fly` 函数中会导致运行时错误，因为鸵鸟不能飞，违反了 LSP。`Bird`
    类的用户期望任何子类都能飞行，而 `Ostrich` 打破了这一期望。
- en: Issues with method preconditions
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法先决条件问题
- en: 'If a derived class imposes stricter preconditions on a method than those imposed
    by the base class, it can limit the usability of the subclass and violate LSP:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果派生类对方法施加的先决条件比基类施加的更严格，它可能会限制子类的可用性并违反 LSP：
- en: '[PRE122]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Here, the `CreditPayment` class cannot be used in place of `Payment` without
    potentially throwing an error for amounts below 100, even though such amounts
    are perfectly valid for the base class.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`CreditPayment` 类不能替代 `Payment` 类，否则可能会因为金额低于 100 而抛出错误，尽管这样的金额对于基类来说是完全有效的。
- en: Solutions to LSP violations
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LSP 违反的解决方案
- en: '**Design with LSP in mind**: When designing your class hierarchy, ensure that
    any subclass can be used in place of a parent class without altering the desirable
    properties of the program'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**以 LSP 为设计理念**：在设计你的类层次结构时，确保任何子类都可以替代父类而不改变程序的可取属性'
- en: '**Use composition instead of inheritance**: If it doesn’t make sense for the
    subclass to fully adhere to the base class’s contract, use composition instead
    of inheritance'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用组合而非继承**：如果子类完全遵守基类契约没有意义，请使用组合而非继承'
- en: '**Clearly define behavioral contracts**: Document and enforce the expected
    behavior of base classes, and ensure that all derived classes adhere strictly
    to these contracts without introducing tighter preconditions or altering postconditions'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**明确定义行为契约**：记录并强制执行基类的预期行为，并确保所有派生类严格遵循这些契约，不引入更严格的先决条件或改变后置条件'
- en: By paying close attention to these principles and potential pitfalls, developers
    can create more robust and maintainable object-oriented designs.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 通过密切关注这些原则和潜在陷阱，开发者可以创建更稳健和可维护的面向对象设计。
- en: While inheritance remains a valuable feature in C++, understanding when and
    how to use it effectively is crucial. The implementation detail that inheritance
    is akin to composition at the binary level highlights that it is fundamentally
    about structuring and accessing data within an object’s memory layout. Practitioners
    must carefully consider whether inheritance or composition (or a combination of
    both) will best serve their design goals, especially regarding system flexibility,
    maintainability, and the robust application of OOP principles such as LSP. As
    with many features in software development, the key lies in using the right tool
    for the right job.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 C++ 中的继承仍然是一个有价值的特性，但理解何时以及如何有效地使用它至关重要。继承在二进制层面上类似于组合的实现细节突显了它本质上是在对象内存布局中结构和访问数据。从业者必须仔细考虑是否继承或组合（或两者的组合）将最好地服务于他们的设计目标，特别是在系统灵活性、可维护性和对
    OOP 原则（如 LSP）的稳健应用方面。与软件开发中的许多特性一样，关键在于为正确的工作使用正确的工具。
- en: Templates and generic programming
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板和泛型编程
- en: Templates and generic programming are pivotal features of C++ that enable the
    creation of flexible and reusable components. While this chapter offers an overview
    of these powerful tools, it’s important to note that the topic of templates, particularly
    template metaprogramming, is vast enough to fill entire books. For those seeking
    an in-depth exploration, dedicated resources on C++ templates and metaprogramming
    are recommended.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 模板和泛型编程是C++的关键特性，它们使得创建灵活且可重用的组件成为可能。虽然本章提供了这些强大工具的概述，但重要的是要注意，模板的主题，尤其是模板元编程，内容丰富到足以填满整本书。对于那些寻求深入探索的人，推荐阅读关于C++模板和元编程的专门资源。
- en: What are templates good for?
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板有什么好处？
- en: Templates are particularly useful in scenarios where similar operations need
    to be performed on different types of data. They allow you to write a single piece
    of code that works with any type. The following subsections outline some common
    use cases with examples.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 模板在需要在不同类型的数据上执行相似操作的场景中特别有用。它们允许你编写一段可以与任何类型一起工作的代码。以下小节概述了一些常见的用例和示例。
- en: Generic algorithms
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型算法
- en: 'Algorithms can operate on different types without rewriting the code for each
    type. For instance, the standard library’s `std::sort` function can sort elements
    of any type as long as the elements can be compared:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 算法可以在不重写针对每种类型的代码的情况下作用于不同的类型。例如，标准库中的`std::sort`函数可以排序任何类型的元素，只要元素可以进行比较：
- en: '[PRE123]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Container classes
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器类
- en: 'Templates are heavily used in the standard library for containers such as `std::vector`,
    `std::list`, and `std::map`, which can store elements of any type:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 模板在标准库中大量使用，例如`std::vector`、`std::list`和`std::map`，这些容器可以存储任何类型的元素：
- en: '[PRE124]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Without the usage of templates, developer’s options in using collections would
    be limited to creating separate classes for each type of collection (e.g., `IntVector`,
    `StringVector`, etc.), or demanding the use of a common base class, which would
    require type casting and lose type safety, for example:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不使用模板，开发者在使用集合时的选择将限于为每种类型的集合创建单独的类（例如，`IntVector`、`StringVector`等），或者要求使用一个公共基类，这会需要类型转换并失去类型安全性，例如：
- en: '[PRE125]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Another option is to store some `void` pointers and cast them to the desired
    type when retrieving them, but this approach is even more error prone.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是存储一些`void`指针，并在检索时将它们转换为所需的类型，但这种方法更容易出错。
- en: 'The standard library uses templates for smart pointers such as `std::unique_ptr`
    and `std::shared_ptr`, which manage the lifetime of dynamically allocated objects:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库使用模板为智能指针如`std::unique_ptr`和`std::shared_ptr`，它们管理动态分配对象的生存期：
- en: '[PRE126]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Templates ensure type safety by allowing the compiler to check types during
    template instantiation, reducing runtime errors:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 模板通过允许编译器在模板实例化期间检查类型来确保类型安全性，从而减少运行时错误：
- en: '[PRE127]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: How templates work
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板的工作原理
- en: Templates in C++ are not actual code but serve as blueprints for code generation.
    When a template is instantiated with a specific type, the compiler generates a
    concrete instance of the template with the specified type replacing the template
    parameters.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: C++中的模板不是实际的代码，而是作为代码生成的蓝图。当模板用特定类型实例化时，编译器会生成一个具体的模板实例，其中模板参数被指定的类型所替换。
- en: Function templates
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数模板
- en: 'A function template defines a pattern for a function that can operate on different
    data types:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 函数模板定义了一个函数的模式，该函数可以作用于不同的数据类型：
- en: '[PRE128]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'The actual generated functions after template instantiation would be something
    like this (depending on the compiler):'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 模板实例化后实际生成的函数可能如下所示（取决于编译器）：
- en: '[PRE129]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Class templates
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类模板
- en: 'A class template defines a pattern for a class that can operate on different
    data types:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 类模板定义了一个可以作用于不同数据类型的类的模式：
- en: '[PRE130]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'The actual generated classes after template instantiation would be something
    like this (depending on the compiler):'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 模板实例化后实际生成的类可能如下所示（取决于编译器）：
- en: '[PRE131]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: How templates are instantiated
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板的实例化方式
- en: 'When a template is used with a specific type, the compiler creates a new instance
    of the template with the specified type. This process is known as **template instantiation**
    and can happen implicitly or explicitly:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 当模板与特定类型一起使用时，编译器会创建一个新实例的模板，其中指定的类型替换了模板参数。这个过程被称为**模板实例化**，可以隐式或显式地发生：
- en: '**Implicit instantiation**: This occurs when the compiler encounters a use
    of the template with specific types:'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隐式实例化**：这发生在编译器遇到使用特定类型的模板时：'
- en: '[PRE132]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '**Explicit instantiation**: The programmer specifies the type explicitly:'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显式实例化**：程序员明确指定类型：'
- en: '[PRE136]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: A real-world example of template usage in C++
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++ 中模板使用的真实世界示例
- en: In the realm of financial software, handling various types of assets and currencies
    in a flexible, type-safe, and efficient manner is crucial. C++ templates offer
    a powerful mechanism to achieve this flexibility by allowing developers to write
    generic and reusable code that can operate with any data type.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在金融软件领域，以灵活、类型安全和高效的方式处理各种类型的资产和货币至关重要。C++ 模板提供了一种强大的机制，通过允许开发者编写通用和可重用的代码，这些代码可以与任何数据类型一起操作。
- en: Imagine developing a financial system that must handle multiple currencies such
    as USD and EUR, and manage various assets such as stocks or bonds. By using templates,
    we can define classes that operate generically on these types without duplicating
    code for each specific currency or asset type. This approach not only reduces
    redundancy but also enhances the system’s scalability and maintainability.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下开发一个必须处理多种货币（如 USD 和 EUR）以及管理各种资产（如股票或债券）的金融系统。通过使用模板，我们可以定义操作这些类型的通用类，而无需为每种特定货币或资产类型重复代码。这种方法不仅减少了冗余，还增强了系统的可扩展性和可维护性。
- en: In the following sections, we will look at a detailed example of a financial
    system implemented using C++ templates. This example will show you how to define
    and manipulate prices in different currencies, how to create and manage assets,
    and how to ensure that operations remain type safe and efficient. Through this
    example, we aim to illustrate the practical benefits of using templates in real-world
    C++ applications and how they can lead to cleaner, more maintainable, and more
    robust code.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，我们将详细探讨使用 C++ 模板实现的金融系统示例。这个示例将向您展示如何定义和操作不同货币的价格，如何创建和管理资产，以及如何确保操作保持类型安全和高效。通过这个示例，我们旨在说明在现实世界的
    C++ 应用中使用模板的实际好处，以及它们如何导致代码更加清晰、易于维护和更健壮。
- en: Defining currencies
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义货币
- en: When designing a financial system, it’s essential to handle multiple currencies
    in a way that prevents errors and ensures type safety. Let’s start by defining
    the requirements and exploring various design options.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计金融系统时，处理多种货币的方式必须防止错误并确保类型安全性。让我们首先定义需求并探讨各种设计选项。
- en: 'Here are the requirements:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是需求：
- en: '**Type safety**: Ensure that different currencies cannot be mixed inadvertently'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型安全性**：确保不同货币不会意外混合'
- en: '**Scalability**: Easily add new currencies without significant code duplication'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：轻松添加新货币而无需大量代码重复'
- en: '**Flexibility**: Support various operations such as addition and subtraction
    on prices in a type-safe manner'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性**：以类型安全的方式支持对价格进行加法和减法等操作'
- en: 'Here are the design options:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是设计选项：
- en: '`int` or `double`. However, this method has significant drawbacks. It allows
    for the accidental mixing of different currencies, leading to incorrect calculations:'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int` 或 `double`。然而，这种方法有显著的缺点。它允许意外混合不同的货币，导致计算错误：'
- en: '[PRE140]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: This approach is error prone and lacks type safety. Please note that using `double`
    for currency values is generally discouraged due to precision issues in floating-point
    arithmetic.
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种方法容易出错且缺乏类型安全性。请注意，由于浮点运算中的精度问题，通常不建议使用 `double` 来表示货币值。
- en: '`Currency` class and inherit specific currencies from it. While this approach
    introduces some structure, it still allows for the mixing of different currencies
    and requires significant effort to implement each new currency:'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Currency` 类并从中继承特定的货币。虽然这种方法引入了一些结构，但它仍然允许混合不同的货币，并且需要大量努力来实现每种新货币：'
- en: '[PRE143]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '`struct`, and operations are implemented using templates:'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct`，并且操作是通过模板实现的：'
- en: '[PRE157]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'This template-based approach ensures that prices in different currencies cannot
    be mixed:'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 基于模板的这种方法确保不同货币的价格不能混合：
- en: '[PRE191]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE200]'
- en: Defining assets
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义资产
- en: 'Next, we define assets that can be priced in different currencies. Using templates,
    we can ensure that each asset is associated with the correct currency:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义可以以不同货币计价的资产。使用模板，我们可以确保每个资产都与正确的货币相关联：
- en: '[PRE201]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: Using the financial system
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用金融系统
- en: 'Finally, we demonstrate how to use the defined templates to manage assets and
    prices:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们演示如何使用定义的模板来管理资产和价格：
- en: '[PRE202]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: Disadvantages of using templates in system design
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用模板在系统设计中的缺点
- en: While templates in C++ offer a powerful and flexible way to create type-safe,
    generic components, there are several disadvantages to this approach. These disadvantages
    are particularly relevant in the context of a financial system that deals with
    multiple currencies and assets. Understanding these potential drawbacks is essential
    when deciding to use templates in your design.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然C++中的模板提供了一种强大且灵活的方式来创建类型安全的通用组件，但这种方法有几个缺点。这些缺点在处理多种货币和资产的金融系统背景下尤其相关。在决定在设计中使用模板时，了解这些潜在的缺点是至关重要的。
- en: Code bloat
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码膨胀
- en: Templates can lead to code bloat, which is the increase in binary size due to
    the generation of multiple template instantiations. The compiler generates a separate
    version of the template code for each unique type instantiation. In a financial
    system that supports various currencies and assets, this can lead to a significant
    increase in the size of the compiled binary.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 模板可能导致代码膨胀，这是由于生成多个模板实例化而导致的二进制文件大小增加。编译器为每个唯一的类型实例化生成模板代码的单独版本。在一个支持各种货币和资产的金融系统中，这可能导致编译的二进制文件大小显著增加。
- en: 'For example, if we have templates for `Price` and `Asset` instantiated with
    different types such as `Usd`, `Euro`, `Apple`, and `Mercedes`, the compiler generates
    separate code for each combination:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们为 `Price` 和 `Asset` 实例化了不同的类型，如 `Usd`、`Euro`、`Apple` 和 `Mercedes`，编译器将为每个组合生成单独的代码：
- en: '[PRE203]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: Each of these instantiations results in additional code, contributing to the
    overall binary size. As the number of supported currencies and assets grows, the
    impact of code bloat becomes more pronounced. Binary size can affect application
    performance, memory usage, and load times, especially in resource-constrained
    environments mostly due to lower cache efficiency.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 每个实例化都会产生额外的代码，从而增加整体二进制文件的大小。随着支持的货币和资产数量的增加，代码膨胀的影响变得更加明显。二进制文件大小会影响应用程序的性能、内存使用和加载时间，尤其是在资源受限的环境中，这主要是由于缓存效率较低。
- en: Increased compilation times
  id: totrans-376
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编译时间增加
- en: Templates can significantly increase the compilation time of a project. Each
    instantiation of a template with a new type results in the generation of new code
    by the compiler. In a financial system that supports hundreds of currencies and
    assets from various countries and stock exchanges, the compiler will have to instantiate
    all the needed combinations, leading to longer build times.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 模板可以显著增加项目的编译时间。每次模板与新类型的实例化都会导致编译器生成新的代码。在一个支持数百种货币和来自不同国家和证券交易所的资产的金融系统中，编译器必须实例化所有需要的组合，从而导致构建时间更长。
- en: 'For instance, say our system supports the following:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们的系统支持以下内容：
- en: 50 different currencies
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 50种不同的货币
- en: 10000 different asset types from various stock exchanges
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自各种证券交易所的10000种不同的资产类型
- en: Then, the compiler will need to generate code for each `Price` and `Asset` combination,
    resulting in a substantial number of template instantiations. This can considerably
    slow down the compilation process, affecting the development workflow, and less
    efficient feedback loop.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，编译器将为每个 `Price` 和 `Asset` 的组合生成代码，导致大量的模板实例化。这可能会显著减慢编译过程，影响开发工作流程，并降低反馈循环的效率。
- en: Less obvious interaction with the rest of the code
  id: totrans-382
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与其他代码的交互不太明显
- en: Template code can be complex and less obvious in terms of how it interacts with
    the rest of the code base. Developers who are less experienced with templates
    may find it challenging to understand and maintain template-heavy code. The syntax
    can be verbose, and compiler error messages can be difficult to decipher, making
    debugging and troubleshooting more complicated.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 模板代码可能很复杂，在与其他代码库的交互方面不太明显。对模板不太熟悉的开发者可能会发现理解和维护模板密集型代码具有挑战性。语法可能很冗长，编译器错误信息可能难以理解，这使得调试和故障排除变得更加复杂。
- en: 'For example, a simple mistake in template parameters can lead to confusing
    error messages:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，模板参数中的简单错误可能导致令人困惑的错误信息：
- en: '[PRE204]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: In this case, the developer must understand templates and the specific error
    messages generated by the compiler to resolve the issue. This can be a barrier
    for less experienced developers.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，开发者必须理解模板和编译器生成的特定错误信息，以解决问题。这可能成为经验不足的开发者的障碍。
- en: 'C++ 20 provides concepts to improve template error messages and constraints,
    which can help make template code more readable and easier to understand. We can
    create a base class called `BaseCurrency` and derive all currency classes from
    it. This way, we can ensure that all currency classes have a common interface
    and can be used interchangeably:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 20 提供了概念来改进模板错误消息和约束，这可以帮助使模板代码更易于阅读和理解。我们可以创建一个名为 `BaseCurrency` 的基类，并从它派生所有货币类。这样，我们可以确保所有货币类都有一个共同的接口，并且可以互换使用：
- en: '[PRE205]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: 'After these changes, the attempt to instantiate `Price<int>` will result in
    a compile-time error, making it clear that the type must be derived from `BaseCurrency`:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些更改之后，尝试实例化 `Price<int>` 将导致编译时错误，从而清楚地表明类型必须从 `BaseCurrency` 派生：
- en: '[PRE206]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: 'C++ versions prior to C++ 20 also provide a way to prevent unintended template
    instantiations by using a combination of `std::enable_if` and `std::is_base_of`
    to enforce constraints on template parameters:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 20 之前的版本也提供了一种方法，通过使用 `std::enable_if` 和 `std::is_base_of` 的组合来强制模板参数的约束，从而防止意外的模板实例化：
- en: '[PRE207]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: 'The attempt to initialize `Price<int>` will now result in a compile-time error,
    indicating that the type must be derived from `BaseCurrency`, however, the error
    message will be a bit cryptic:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试初始化 `Price<int>` 将导致编译时错误，表明类型必须从 `BaseCurrency` 派生，然而，错误信息将有点晦涩难懂：
- en: '[PRE208]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: Limited tool support and debugging
  id: totrans-395
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工具支持有限和调试
- en: Debugging template code can be challenging due to limited tool support. Many
    debuggers do not handle template instantiations well, making it difficult to step
    through template code and inspect template parameters and instantiations. This
    can hinder the debugging process and make it harder to identify and fix issues.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 调试模板代码可能具有挑战性，因为工具支持有限。许多调试器处理模板实例化不佳，使得难以逐步执行模板代码并检查模板参数和实例化。这可能会阻碍调试过程，并使识别和修复问题变得更加困难。
- en: For example, examining the state of a templated `Price<Usd>` object in a debugger
    might not provide clear insights into the underlying type and values, especially
    if the debugger does not fully support template parameter inspection.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在调试器中检查模板化的 `Price<Usd>` 对象的状态可能无法提供对底层类型和值的清晰洞察，尤其是如果调试器不完全支持模板参数检查。
- en: Most autocomplete and IDE tools do not work very well with templates, because
    it is impossible for them to assume the type of the template parameter. This can
    make it harder to navigate and understand template-heavy code bases.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数自动完成和 IDE 工具与模板配合得不是很好，因为它们无法假设模板参数的类型。这可能会使导航和理解模板密集型代码库变得更加困难。
- en: Advanced features of templates might be hard to use
  id: totrans-399
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模板的高级特性可能难以使用
- en: Templates in C++ provide a mechanism for writing generic and reusable code.
    However, there are situations where the default template behavior needs to be
    customized for specific types. This is where template specialization comes into
    play. Template specialization allows you to define a special behavior for a specific
    type, ensuring that the template behaves correctly for that type.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 中的模板提供了编写通用和可重用代码的机制。然而，在某些情况下，需要针对特定类型自定义默认模板行为。这就是模板特化的用武之地。模板特化允许你为特定类型定义特殊行为，确保模板对该类型的行为正确。
- en: Why use template specialization?
  id: totrans-401
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为什么使用模板特化？
- en: Template specialization is used when the general template implementation does
    not work correctly or efficiently for a particular type, or when a specific type
    requires a completely different implementation. This can happen due to various
    reasons, such as performance optimizations, special handling of certain data types,
    or compliance with specific requirements.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 当通用模板实现对于特定类型不正确或不高效，或者特定类型需要完全不同的实现时，会使用模板特化。这可能是由于各种原因，例如性能优化、对某些数据类型的特殊处理，或符合特定要求。
- en: For example, consider a scenario where you have a general `Printer` template
    class that prints objects of any type. However, for `std::string`, you might want
    to add quotes around the string when printing it.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个场景，你有一个通用的 `Printer` 模板类，它可以打印任何类型的对象。然而，对于 `std::string`，你可能希望在打印时在字符串周围添加引号。
- en: Basic template specialization example
  id: totrans-404
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 基本模板特化示例
- en: 'Here is an example of how template specialization works:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个模板特化工作方式的示例：
- en: '[PRE209]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: In this example, the general `Printer` template class prints any type. However,
    for `std::string`, the specialized version adds quotes around the string when
    printing it.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，通用的`Printer`模板类可以打印任何类型。然而，对于`std::string`，特化版本在打印字符串时会添加引号。
- en: Including the specialization header
  id: totrans-408
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 包含特化头文件
- en: When using template specialization, it is crucial to include the header file
    that contains the specialization definition. If the specialization header is not
    included, the compiler will instantiate the default version of the template, leading
    to incorrect behavior.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用模板特化时，包含包含特化定义的头文件至关重要。如果没有包含特化头文件，编译器将实例化模板的默认版本，从而导致行为不正确。
- en: 'For example, consider the following files:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下文件：
- en: '`printer.h` (General template definition):'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '`printer.h`（通用模板定义）：'
- en: '[PRE210]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '`printer_string.h` (Template specialization for `std::string`):'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '`printer_string.h`（针对`std::string`的模板特化）：'
- en: '[PRE211]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '`main.cpp` (Using the template and specialization):'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.cpp`（使用模板和特化）：'
- en: '[PRE212]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: In this setup, if the `printer_string.h` header is not included in `main.cpp`,
    the compiler will use the default `Printer` template for `std::string`, resulting
    in incorrect behavior (printing the string without quotes).
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配置中，如果`main.cpp`中没有包含`printer_string.h`头文件，编译器将使用默认的`Printer`模板为`std::string`，从而导致行为不正确（打印字符串时不加引号）。
- en: Templates are a crucial part of the C++ programming language, offering powerful
    capabilities for creating generic, reusable, and type-safe code. They are indispensable
    in various scenarios, such as developing generic algorithms, container classes,
    smart pointers, and other utilities that need to work seamlessly with multiple
    data types. Templates enable developers to write flexible and efficient code,
    ensuring that the same functionality can be applied to different types without
    duplication.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 模板是C++编程语言的重要组成部分，提供了创建通用、可重用和类型安全的代码的强大功能。在各种场景中都是必不可少的，例如开发通用算法、容器类、智能指针和其他需要与多种数据类型无缝工作的实用工具。模板使开发者能够编写灵活且高效的代码，确保相同的功能可以应用于不同的类型而无需重复。
- en: However, the power of templates does not come without cost. The use of templates
    can lead to increased compilation times and code bloat, especially in systems
    that support a wide range of types and combinations. The syntax and resulting
    error messages can be complex and difficult to understand, posing a challenge
    for less experienced developers. Additionally, debugging template-heavy code can
    be cumbersome due to limited tool support and the intricate nature of template
    instantiations.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，模板的强大功能并非没有代价。模板的使用可能导致编译时间增加和代码膨胀，尤其是在支持广泛类型和组合的系统中。语法和产生的错误信息可能很复杂，难以理解，这对经验不足的开发者来说是一个挑战。此外，由于工具支持有限和模板实例化的复杂性质，调试模板密集型代码可能很繁琐。
- en: Moreover, templates can introduce less obvious interactions with the rest of
    the code base, which might cause issues if not managed properly. Developers must
    also be aware of advanced features, such as template specialization, which require
    careful inclusion of specialized headers to avoid incorrect behavior.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，模板可能会引入与代码库的其他部分不太明显的交互，如果不妥善管理，可能会引起问题。开发者还必须意识到需要谨慎包含特化头文件的高级特性，如模板特化，以避免不正确的行为。
- en: Given these caveats, it is essential for developers to think carefully before
    incorporating templates into their projects. While they provide significant benefits,
    the potential drawbacks necessitate a thoughtful approach to ensure that the advantages
    outweigh the complexities. Proper understanding and judicious use of templates
    can lead to more robust, maintainable, and efficient C++ applications.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些注意事项，开发者在将模板纳入其项目之前必须仔细思考。虽然它们提供了显著的好处，但潜在的缺点需要深思熟虑的方法，以确保优势超过复杂性。正确理解和审慎使用模板可以导致更健壮、可维护和高效的C++应用程序。
- en: Summary
  id: totrans-422
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we explored the intricacies of advanced C++ programming, focusing
    on class design, inheritance, and templates. We began with the principles of effective
    class design, emphasizing the importance of encapsulating the minimum necessary
    functionality and data to achieve better modularity and maintainability. Through
    practical examples, we highlighted both good and bad design practices. Moving
    on to inheritance, we examined its benefits, such as code reuse, hierarchical
    structuring, and polymorphism, while also addressing its drawbacks, including
    tight coupling, complex hierarchies, and potential violations of the LSP. We provided
    guidance on when to use inheritance and when to consider alternatives such as
    composition. In the section on templates, we delved into their role in enabling
    generic programming, allowing for flexible and reusable components that work with
    any data type. We discussed the advantages of templates, such as code reusability,
    type safety, and performance optimization, but also pointed out their disadvantages,
    including increased compilation times, code bloat, and the complexity of understanding
    and debugging template-heavy code. Throughout these discussions, we underscored
    the need for careful consideration and understanding when utilizing these powerful
    features to ensure robust and maintainable C++ applications. In the next chapter,
    we will shift our focus to API design, exploring best practices for creating clear,
    efficient, and user-friendly interfaces in C++.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了高级C++编程的复杂性，重点关注类设计、继承和模板。我们首先介绍了有效类设计的原则，强调封装最小必要功能和数据以实现更好的模块化和可维护性的重要性。通过实际示例，我们突出了良好的和不良的设计实践。接着转向继承，我们探讨了它的好处，如代码重用、层次结构化和多态性，同时也指出了其缺点，包括紧密耦合、复杂的层次结构和可能违反LSP（里氏替换原则）的风险。我们提供了何时使用继承以及何时考虑替代方案如组合的建议。在模板部分，我们深入探讨了它们在启用泛型编程中的作用，允许灵活且可重用的组件与任何数据类型一起工作。我们讨论了模板的优势，如代码重用性、类型安全和性能优化，但也指出了它们的缺点，包括编译时间增加、代码膨胀以及理解和调试模板密集型代码的复杂性。在这些讨论中，我们强调了在利用这些强大功能时进行仔细考虑和理解的需要，以确保构建健壮且可维护的C++应用程序。在下一章中，我们将把重点转向API设计，探讨在C++中创建清晰、高效和用户友好界面的最佳实践。
