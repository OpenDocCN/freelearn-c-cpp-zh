- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Classes, Objects, and OOP in C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we delve into the sophisticated realm of classes, objects,
    and **object-oriented programming** (**OOP**) in C++. Tailored for the advanced
    C++ practitioner, our focus will be on elevating your understanding of class design,
    method implementation, inheritance, and template usage, steering clear of introductory
    explanations of these concepts. Our goal is to enhance your ability to construct
    robust and efficient software architectures using advanced object-oriented techniques.
  prefs: []
  type: TYPE_NORMAL
- en: The discussion begins by examining the intricate considerations necessary when
    defining classes, guiding you through the decision-making process to determine
    the best candidates for class encapsulation. This includes distinguishing situations
    where a simpler data structure, such as a struct, might be more appropriate, thereby
    optimizing both performance and readability.
  prefs: []
  type: TYPE_NORMAL
- en: Further, we explore the design of methods within classes—highlighting various
    types of methods, such as accessors, mutators, and factory methods, and establishing
    conventions that promote code clarity and maintainability. Special attention is
    given to advanced method design practices, including const correctness and visibility
    scopes, which are pivotal for securing and optimizing access to class data.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance, a cornerstone of OOP, is scrutinized not only for its benefits
    but also its liabilities. To provide a balanced perspective, we present alternatives
    such as composition and interface segregation that might better serve your design
    goals in certain scenarios. This nuanced discussion aims to equip you with the
    discernment necessary to choose the best inheritance strategy or its alternatives,
    depending on the specific requirements and constraints of your projects.
  prefs: []
  type: TYPE_NORMAL
- en: Expanding the discussion to generic programming, we delve into sophisticated
    template usage, which includes advanced techniques such as template metaprogramming.
    This section aims to demonstrate how templates can be leveraged to create highly
    reusable and efficient code. Additionally, we will touch upon the design of APIs
    using OOP principles, emphasizing how well-crafted interfaces can significantly
    enhance the usability and longevity of software components.
  prefs: []
  type: TYPE_NORMAL
- en: Each topic is punctuated with practical examples and case studies drawn from
    real-world applications, illustrating how these advanced techniques are applied
    in modern software development. By the end of this chapter, you should possess
    a deeper understanding of how to utilize OOP features in C++ to craft elegant,
    efficient, and scalable software architectures.
  prefs: []
  type: TYPE_NORMAL
- en: Good candidates for classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Identifying good candidates for classes in OOP involves looking for entities
    that naturally encapsulate both data and behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Cohesion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A class should represent a set of functionalities that are tightly related to
    each other. This means all the methods and data in the class are directly related
    to the specific functionalities it provides. For example, a `Timer` class is a
    good candidate because it encapsulates properties and methods related to timing
    (start, stop, reset times), maintaining high cohesion.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Entities that have attributes and behaviors that should be shielded from outside
    interference or misuse can be encapsulated in a class.
  prefs: []
  type: TYPE_NORMAL
- en: A `BankAccount` class encapsulates the balance (attribute) and behaviors such
    as `deposit`, `withdraw`, and `transfer`, ensuring that balance manipulations
    are done only through controlled and safe operations.
  prefs: []
  type: TYPE_NORMAL
- en: Reusability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Classes should be designed to be reused across different parts of a program
    or even in different programs.
  prefs: []
  type: TYPE_NORMAL
- en: A `DatabaseConnection` class that manages database connections can be reused
    in multiple applications that require database interactions, handling connection,
    disconnection, and error management.
  prefs: []
  type: TYPE_NORMAL
- en: Abstraction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A class should provide a simplified interface by hiding complex logic from the
    user, representing a higher level of abstraction. For example, the standard library
    has classes such as `std::vector` that abstract the complexities of dynamic arrays,
    providing a simple interface for array operations.
  prefs: []
  type: TYPE_NORMAL
- en: Real-world entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Classes often represent objects from the real world that are relevant to the
    system being modeled.
  prefs: []
  type: TYPE_NORMAL
- en: In a flight reservation system, classes such as `Flight`, `Passenger`, and `Ticket`
    are good candidates because they directly represent real-world objects with clear
    attributes and behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: Manage complexity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Classes should help in managing complexity by breaking down large problems into
    smaller, more manageable parts.
  prefs: []
  type: TYPE_NORMAL
- en: Here is an example – in graphic editing software, a `GraphicObject` class might
    serve as a base class for more specific graphic objects such as `Circle`, `Rectangle`,
    and `Polygon`, organizing graphic properties and functionalities systematically.
  prefs: []
  type: TYPE_NORMAL
- en: Minimizing class responsibilities through encapsulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Encapsulation is a fundamental concept in OOP that involves bundling the data
    (attributes) and the methods (functions) that operate on the data into a single
    unit or class. It not only hides the internal state of the object from the outside
    but also modularizes its behavior, making the software easier to manage and extend.
    However, how much functionality and data a class should encapsulate can significantly
    affect the maintainability and scalability of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Over-encapsulation in classes – a common pitfall
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In practice, encapsulating too much functionality and data within a single class
    is a common mistake that can lead to several issues. This often results in a **god
    object** – a class that controls too many different parts of the application,
    doing too much work on its own. Such classes are typically hard to understand,
    difficult to maintain, and problematic to test.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at an example of a badly encapsulated `Car` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example of a `Car` class that attempts to manage not
    only the car’s basic properties but also detailed aspects of its internal systems
    such as the engine, transmission, and entertainment system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This `Car` class is problematic because it tries to manage too many aspects
    of the car’s functionality, which are better handled by specialized components.
  prefs: []
  type: TYPE_NORMAL
- en: Proper encapsulation using composition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A better approach is to use composition to delegate responsibilities to other
    classes, each handling a specific part of the system’s functionality. This not
    only adheres to the Single Responsibility Principle but also makes the system
    more modular and easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a well-designed `Car` class using composition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this refined design, the `Car` class acts as a coordinator among its components
    rather than directly managing every detail. Each subsystem – engine, transmission,
    and entertainment system – handles its own state and behavior, leading to a design
    that is easier to maintain, test, and extend. This example showcases how appropriate
    encapsulation and composition can significantly enhance the structure and quality
    of object-oriented software.
  prefs: []
  type: TYPE_NORMAL
- en: Usage of structs and classes in C++
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In C++, both structs and classes are used to define user-defined types that
    can contain data and functions. The primary difference between them lies in their
    default access levels: members of a class are private by default, while members
    of a struct are public. This distinction subtly influences their typical uses
    in C++ programming.'
  prefs: []
  type: TYPE_NORMAL
- en: Structs – ideal for passive data structures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Structs in C++ are particularly suited for creating passive data structures
    where the primary purpose is to store data without encapsulating too much behavior.
    Due to their public-by-default nature, structs are often used when you want to
    allow direct access to the data members, which can simplify code and reduce the
    need for additional functions to manipulate data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list outlines the instances when you should use structs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data objects**: Structs are perfect for creating **plain old data** (**POD**)
    structures. These are simple objects that primarily hold data and have little
    or no functionality (methods). For example, structs are often used to represent
    coordinates in space, RGB color values, or settings configurations where direct
    access to data fields is more convenient than going through getters and setters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If C++ 20 is not available for your project, you can utilize C99-designated
    initializers to achieve a similar effect:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Interoperability**: Structs are useful in interfacing with code in C or in
    systems where data alignment and layout are critical. They ensure compatibility
    and performance in low-level operations, such as hardware interfacing or network
    communication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lightweight containers**: When you need a lightweight container to group
    together a few variables, structs provide a more transparent and less cumbersome
    way than classes. They are ideal for small aggregations where encapsulation isn’t
    a primary concern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes – encapsulating complexity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Classes are the backbone of C++ OOP and are used to encapsulate data and behavior
    into a single entity. The private-by-default access specifier encourages the hiding
    of internal state and implementation details, promoting a more rigorous design
    that follows encapsulation and abstraction principles.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list explains when you should use classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Complex systems**: For components that involve complex data manipulations,
    state management, and interface control, classes are the preferred choice. They
    provide mechanisms for data protection and interface abstraction, which are crucial
    for maintaining the integrity and stability of software systems:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Behavior encapsulation**: Classes are ideal when the functionality (methods)
    is as important as the data. Encapsulating behaviors with data into classes allows
    for more maintainable and error-free code, as operations on the data are tightly
    controlled and clearly defined.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inheritance and polymorphism**: Classes support inheritance and polymorphism,
    enabling the creation of complex object hierarchies that can be extended and modified
    dynamically. This is essential in many software design patterns and advanced system
    architectures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Choosing between a struct and a class in C++ should be guided by the intended
    use: structs for simple, transparent data containers where direct data access
    is acceptable or necessary, and classes for more complex systems where encapsulation,
    behavior, and interface control are required. Understanding and utilizing the
    strengths of each can lead to cleaner, more efficient, and scalable code.'
  prefs: []
  type: TYPE_NORMAL
- en: Common method types in classes – getters and setters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In OOP, particularly in languages such as Java, **getters** and **setters**
    are standard methods that serve as the primary interface for accessing and modifying
    the private data members of a class. These methods provide controlled access to
    an object’s properties, adhering to the encapsulation principle, which is a cornerstone
    of effective object-oriented design.
  prefs: []
  type: TYPE_NORMAL
- en: Purpose and conventions of getters and setters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Getters (also known as accessors) are methods used to retrieve the value of
    a private field. They do not modify the data. Setters (also known as mutators)
    are methods that allow the modification of private fields based on the input they
    receive. These methods enable the internal state of an object to remain consistent
    and valid by potentially enforcing constraints or conditions when data is set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the conventions of getters and setters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`x`, is named `get_x()`, and the setter is named `set_x(value)`. This naming
    convention is almost universal in Java and is commonly adopted in other programming
    languages that support class-based OOP.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Return types and parameters**: A getter for a property returns the same type
    as the property itself and takes no parameters, whereas a setter returns void
    and takes a parameter of the same type as the property it sets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of this in C++:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Usefulness and recommendations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Controlled access and validation**: Getters and setters encapsulate the fields
    of a class, providing controlled access and validation logic. This helps to maintain
    the integrity of the data, ensuring that no invalid or inappropriate values are
    set.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Flexibility**: By using getters and setters, developers can change the underlying
    implementation of how the data is stored and retrieved without changing the external
    interface of the class. This can be particularly useful in maintaining backward
    compatibility or when the data representation needs to be changed for optimization.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Consistency**: These methods can enforce rules that need to be maintained
    consistently throughout an object’s life cycle. For example, ensuring that a field
    never holds a null value or adheres to a specific format.'
  prefs: []
  type: TYPE_NORMAL
- en: When to use getters and setters, and when not to
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The rule of thumb is to use getters and setters in classes where encapsulation,
    business logic, or inheritance complexities are present. For example, for the
    `Car` and `Engine` classes with relatively complex logic, getters and setters
    are essential to maintain the integrity of the data and ensure that the system
    functions correctly. On the other hand, for a simple data structure such as `Point`
    or `Color`, where the primary purpose is to hold data without much behavior, using
    a struct with public data members might be more appropriate. Note that if the
    struct is a part of a library or API, it might be beneficial to provide getters
    and setters for future extensibility.
  prefs: []
  type: TYPE_NORMAL
- en: This nuanced approach allows developers to balance between control and simplicity,
    choosing the most appropriate tool for the specific requirements of their software
    components.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance in C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inheritance and composition are two fundamental OOP concepts that enable the
    creation of complex and reusable software designs in C++. They facilitate code
    reuse and help in modeling real-world relationships, though they operate differently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inheritance allows one class, known as the derived or subclass, to inherit
    properties and behaviors from another class, the base or superclass. This enables
    the derived class to reuse the code in the base class while extending or overriding
    its functionality. For instance, consider a `BaseSocket` class and its derived
    classes, `TcpSocket` and `UdpSocket`. The derived classes inherit the basic functionality
    of `BaseSocket` and add their specific implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `TcpSocket` and `UdpSocket` classes inherit from `BaseSocket`,
    demonstrating how inheritance promotes code reuse and establishes an “is-a” relationship.
    Inheritance also supports polymorphism, allowing objects of the derived class
    to be treated as instances of the base class, enabling dynamic method binding.
  prefs: []
  type: TYPE_NORMAL
- en: 'Composition, on the other hand, involves creating classes by including objects
    of other classes. Instead of inheriting from a base class, a class is composed
    of one or more objects from other classes, which are used to achieve the desired
    functionality. This represents a “has-a” relationship. For example, consider a
    `CommunicationChannel` class that can own `BaseSocket`. The `CommunicationChannel`
    class uses the `BaseSocket` object to implement its communication functionality,
    demonstrating composition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `CommunicationChannel` class contains a `BaseSocket` object
    and uses it to implement its functionality. The `transmit` method sends data in
    chunks until all data is sent, checking for errors (when the return value is less
    than `0`). This demonstrates how composition offers flexibility, allowing objects
    to be dynamically assembled at runtime. It also promotes better encapsulation
    by containing objects and exposing only necessary interfaces, thereby avoiding
    tight coupling between classes and making the code more modular and easier to
    maintain.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, both inheritance and composition are essential tools in C++ for
    creating reusable and maintainable code. Inheritance is suitable for scenarios
    with a clear hierarchical relationship and where polymorphism is needed, while
    composition is ideal for assembling complex behaviors from simpler components,
    offering flexibility and better encapsulation. Understanding when to use each
    approach is key to effective object-oriented design.
  prefs: []
  type: TYPE_NORMAL
- en: Evolution of inheritance in C++
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Originally, inheritance was seen as a powerful tool for reducing code duplication
    and enhancing the expressiveness of code. It allowed for the creation of a derived
    class that inherits properties and behavior from a base class. However, as the
    use of C++ grew in complex systems, the limitations of inheritance as a one-size-fits-all
    solution became apparent.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation of inheritance at the binary level
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Interestingly, on a binary level, inheritance in C++ is implemented similarly
    to composition. Essentially, the derived class contains an instance of the base
    class within its structure. This can be visualized in a simplified ASCII diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In this layout, the base class part of the derived class object contains all
    the data members that belong to the base class, and directly after it in memory,
    the additional data members of the derived class are placed. Note that the actual
    order of data members in memory can be influenced by factors such as alignment
    requirements and compiler optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: Pros and cons of inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are the pros of inheritance:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MediaContent` class will serve as the base class for all types of media content.
    It will encapsulate common attributes and behaviors such as `title`, `duration`,
    and basic playback controls (`play`, `pause`, `stop`):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `Audio` class extends `MediaContent`, adding specific attributes related
    to audio files, such as bitrate:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similarly, the `Video` class extends `MediaContent` and introduces additional
    attributes such as `resolution`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here’s how these classes could be used in a simple media player system:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this example, both `Audio` and `Video` inherit from `MediaContent`. This
    allows us to reuse the `title` and `duration` attributes and requires the implementation
    of the playback controls (`play`, `pause`, `stop`) tailored to each media type.
    This hierarchy demonstrates how inheritance facilitates code reuse and system
    extensibility while enabling specific behaviors for different types of media content
    in a unified framework. Each class adds only what is unique to its type, adhering
    to the principle that base classes provide common functionality and derived classes
    extend or modify that functionality for specific needs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Polymorphism**: Through inheritance, C++ supports polymorphism, which allows
    for the use of a base class reference to refer to an object of a derived class.
    This enables dynamic method binding and a flexible interface to multiple derived
    types. Our media content hierarchy can be used for implementing a media player
    that can handle different types of media content uniformly:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `add` method accepts media content of any type that derives from `MediaContent`,
    demonstrating polymorphism by using a base class pointer to refer to derived class
    objects. This is enabled by storing the media items in `std::vector` of `std::unique_ptr<MediaContent>`.
    The `play_all` method iterates through the stored media and calls the play method
    on each item. Despite the actual media type being different (audio or video),
    the media player treats them all as `MediaContent`. The correct play method (from
    either `Audio` or `Video`) is invoked at runtime, which is an example of dynamic
    polymorphism (also known as dynamic dispatch).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Hierarchical structuring**: It provides a natural way to organize related
    classes in a hierarchical manner that models real-world relationships.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the con of inheritance:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tight coupling**: Inheritance creates a tight coupling between base and derived
    classes. Changes to the base class can inadvertently affect derived classes, leading
    to fragile code that can break when base classes are modified. The following example
    illustrates the issue of tight coupling through inheritance in a software system.
    We’ll use a scenario involving an online store that manages different types of
    discounts using a class hierarchy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Base class – Discount
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Discount` class provides the basic structure and functionality for all
    types of discounts. It calculates a discount based on a percentage reduction;
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Derived class – SeasonalDiscount
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `SeasonalDiscount` class extends `Discount` and modifies the discount calculation
    based on seasonal factors, such as increasing the discount during the holiday
    season:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Derived class – ClearanceDiscount
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ClearanceDiscount` class also extends `Discount`, designed for items on
    clearance where the discount might be significantly higher:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Demonstration and tight coupling issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: Tight coupling problems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following is a list of tight-coupling problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '`apply_discount`). Any change in the base class method’s signature or the logic
    within `apply_discount` could necessitate changes in all derived classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_discount_percent`. If the formula in the base class changes (say, incorporating
    minimum or maximum caps), all subclasses might need extensive modifications to
    conform to the new logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inflexibility**: The coupling makes it hard to modify the behavior of one
    discount type without risking impacts on others. This design lacks flexibility
    where independent evolution of discount calculation strategies might be necessary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solution – decouple with the strategy pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One way to reduce this coupling is to use the **strategy pattern**, which involves
    defining a family of algorithms (discount strategies), encapsulating each one,
    and making them interchangeable. This allows the discount algorithms to vary independently
    from the clients that use them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'This approach decouples the discount calculation from the client (`Discount`)
    using it, allowing each discount strategy to evolve independently without affecting
    others. A couple of others ways to reduce the coupling are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`HybridFlyingElectricCar` that inherits from both `ElectricCar` and `FlyingCar`,
    with each of these classes further inheriting from their respective hierarchies,
    results in a highly tangled class structure. This complexity makes the system
    tough to debug, extend, or reliably use, while also multiplying the challenges
    in testing and maintaining consistent behavior across various scenarios.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To manage the complications introduced by extensive use of inheritance, several
    strategies can be recommended. Favoring composition over inheritance often provides
    greater flexibility, allowing systems to be composed of well-defined, loosely
    coupled components rather than relying on rigid inheritance structures. Keeping
    inheritance chains short and manageable – generally no deeper than two or three
    levels – helps preserve system clarity and maintainability. Employing interfaces,
    particularly in languages such as Java and C#, offers a way to achieve polymorphic
    behavior without the overhead associated with inheritance. When multiple inheritance
    is unavoidable, it’s crucial to ensure clear documentation and consider the use
    of interface-like structures or mixins, which can help minimize complexity and
    enhance system robustness.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Liskov Substitution Principle (LSP)**: We mentioned this principle earlier
    in this book; LSP states that objects of a superclass should be replaceable with
    objects of its subclasses without altering the desirable properties of the program
    (correctness, task performed, etc.). Inheritance can sometimes lead to violations
    of this principle, especially when subclasses diverge from the behavior expected
    by the base class. The following sections include typical problems related to
    violations of the LSP, illustrated with simple examples.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unexpected behaviors in derived classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When derived classes override methods of the base class in ways that change
    the expected behavior significantly, it can lead to unexpected results when these
    objects are used interchangeably:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Here, replacing a `Bird` object with an `Ostrich` object in the `make_bird_fly`
    function leads to a runtime error because ostriches can’t fly, violating LSP.
    Users of the `Bird` class expect any subclass to fly, and `Ostrich` breaks this
    expectation.
  prefs: []
  type: TYPE_NORMAL
- en: Issues with method preconditions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If a derived class imposes stricter preconditions on a method than those imposed
    by the base class, it can limit the usability of the subclass and violate LSP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `CreditPayment` class cannot be used in place of `Payment` without
    potentially throwing an error for amounts below 100, even though such amounts
    are perfectly valid for the base class.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to LSP violations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Design with LSP in mind**: When designing your class hierarchy, ensure that
    any subclass can be used in place of a parent class without altering the desirable
    properties of the program'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use composition instead of inheritance**: If it doesn’t make sense for the
    subclass to fully adhere to the base class’s contract, use composition instead
    of inheritance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clearly define behavioral contracts**: Document and enforce the expected
    behavior of base classes, and ensure that all derived classes adhere strictly
    to these contracts without introducing tighter preconditions or altering postconditions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By paying close attention to these principles and potential pitfalls, developers
    can create more robust and maintainable object-oriented designs.
  prefs: []
  type: TYPE_NORMAL
- en: While inheritance remains a valuable feature in C++, understanding when and
    how to use it effectively is crucial. The implementation detail that inheritance
    is akin to composition at the binary level highlights that it is fundamentally
    about structuring and accessing data within an object’s memory layout. Practitioners
    must carefully consider whether inheritance or composition (or a combination of
    both) will best serve their design goals, especially regarding system flexibility,
    maintainability, and the robust application of OOP principles such as LSP. As
    with many features in software development, the key lies in using the right tool
    for the right job.
  prefs: []
  type: TYPE_NORMAL
- en: Templates and generic programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Templates and generic programming are pivotal features of C++ that enable the
    creation of flexible and reusable components. While this chapter offers an overview
    of these powerful tools, it’s important to note that the topic of templates, particularly
    template metaprogramming, is vast enough to fill entire books. For those seeking
    an in-depth exploration, dedicated resources on C++ templates and metaprogramming
    are recommended.
  prefs: []
  type: TYPE_NORMAL
- en: What are templates good for?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Templates are particularly useful in scenarios where similar operations need
    to be performed on different types of data. They allow you to write a single piece
    of code that works with any type. The following subsections outline some common
    use cases with examples.
  prefs: []
  type: TYPE_NORMAL
- en: Generic algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Algorithms can operate on different types without rewriting the code for each
    type. For instance, the standard library’s `std::sort` function can sort elements
    of any type as long as the elements can be compared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: Container classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Templates are heavily used in the standard library for containers such as `std::vector`,
    `std::list`, and `std::map`, which can store elements of any type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'Without the usage of templates, developer’s options in using collections would
    be limited to creating separate classes for each type of collection (e.g., `IntVector`,
    `StringVector`, etc.), or demanding the use of a common base class, which would
    require type casting and lose type safety, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: Another option is to store some `void` pointers and cast them to the desired
    type when retrieving them, but this approach is even more error prone.
  prefs: []
  type: TYPE_NORMAL
- en: 'The standard library uses templates for smart pointers such as `std::unique_ptr`
    and `std::shared_ptr`, which manage the lifetime of dynamically allocated objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'Templates ensure type safety by allowing the compiler to check types during
    template instantiation, reducing runtime errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: How templates work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Templates in C++ are not actual code but serve as blueprints for code generation.
    When a template is instantiated with a specific type, the compiler generates a
    concrete instance of the template with the specified type replacing the template
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Function templates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A function template defines a pattern for a function that can operate on different
    data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'The actual generated functions after template instantiation would be something
    like this (depending on the compiler):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: Class templates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A class template defines a pattern for a class that can operate on different
    data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'The actual generated classes after template instantiation would be something
    like this (depending on the compiler):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: How templates are instantiated
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When a template is used with a specific type, the compiler creates a new instance
    of the template with the specified type. This process is known as **template instantiation**
    and can happen implicitly or explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Implicit instantiation**: This occurs when the compiler encounters a use
    of the template with specific types:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE133]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE135]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Explicit instantiation**: The programmer specifies the type explicitly:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE137]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE138]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE139]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A real-world example of template usage in C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the realm of financial software, handling various types of assets and currencies
    in a flexible, type-safe, and efficient manner is crucial. C++ templates offer
    a powerful mechanism to achieve this flexibility by allowing developers to write
    generic and reusable code that can operate with any data type.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine developing a financial system that must handle multiple currencies such
    as USD and EUR, and manage various assets such as stocks or bonds. By using templates,
    we can define classes that operate generically on these types without duplicating
    code for each specific currency or asset type. This approach not only reduces
    redundancy but also enhances the system’s scalability and maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will look at a detailed example of a financial
    system implemented using C++ templates. This example will show you how to define
    and manipulate prices in different currencies, how to create and manage assets,
    and how to ensure that operations remain type safe and efficient. Through this
    example, we aim to illustrate the practical benefits of using templates in real-world
    C++ applications and how they can lead to cleaner, more maintainable, and more
    robust code.
  prefs: []
  type: TYPE_NORMAL
- en: Defining currencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When designing a financial system, it’s essential to handle multiple currencies
    in a way that prevents errors and ensures type safety. Let’s start by defining
    the requirements and exploring various design options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Type safety**: Ensure that different currencies cannot be mixed inadvertently'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability**: Easily add new currencies without significant code duplication'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexibility**: Support various operations such as addition and subtraction
    on prices in a type-safe manner'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the design options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int` or `double`. However, this method has significant drawbacks. It allows
    for the accidental mixing of different currencies, leading to incorrect calculations:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE141]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE142]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This approach is error prone and lacks type safety. Please note that using `double`
    for currency values is generally discouraged due to precision issues in floating-point
    arithmetic.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Currency` class and inherit specific currencies from it. While this approach
    introduces some structure, it still allows for the mixing of different currencies
    and requires significant effort to implement each new currency:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE144]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE145]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE146]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE147]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE148]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE149]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE150]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE151]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE152]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE153]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE154]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE155]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE156]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`struct`, and operations are implemented using templates:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE158]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE159]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE160]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE161]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE162]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE163]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE164]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE165]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE166]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE167]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE168]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE169]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE170]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE171]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE172]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE173]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE174]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE175]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE176]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE177]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE178]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE179]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE180]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE181]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE182]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE183]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE184]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE185]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE186]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE187]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE188]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE189]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE190]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This template-based approach ensures that prices in different currencies cannot
    be mixed:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE192]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE193]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE194]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE195]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE196]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE197]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE198]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE199]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE200]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Defining assets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we define assets that can be priced in different currencies. Using templates,
    we can ensure that each asset is associated with the correct currency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: Using the financial system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, we demonstrate how to use the defined templates to manage assets and
    prices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: Disadvantages of using templates in system design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While templates in C++ offer a powerful and flexible way to create type-safe,
    generic components, there are several disadvantages to this approach. These disadvantages
    are particularly relevant in the context of a financial system that deals with
    multiple currencies and assets. Understanding these potential drawbacks is essential
    when deciding to use templates in your design.
  prefs: []
  type: TYPE_NORMAL
- en: Code bloat
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Templates can lead to code bloat, which is the increase in binary size due to
    the generation of multiple template instantiations. The compiler generates a separate
    version of the template code for each unique type instantiation. In a financial
    system that supports various currencies and assets, this can lead to a significant
    increase in the size of the compiled binary.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we have templates for `Price` and `Asset` instantiated with
    different types such as `Usd`, `Euro`, `Apple`, and `Mercedes`, the compiler generates
    separate code for each combination:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: Each of these instantiations results in additional code, contributing to the
    overall binary size. As the number of supported currencies and assets grows, the
    impact of code bloat becomes more pronounced. Binary size can affect application
    performance, memory usage, and load times, especially in resource-constrained
    environments mostly due to lower cache efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: Increased compilation times
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Templates can significantly increase the compilation time of a project. Each
    instantiation of a template with a new type results in the generation of new code
    by the compiler. In a financial system that supports hundreds of currencies and
    assets from various countries and stock exchanges, the compiler will have to instantiate
    all the needed combinations, leading to longer build times.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, say our system supports the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 50 different currencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 10000 different asset types from various stock exchanges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, the compiler will need to generate code for each `Price` and `Asset` combination,
    resulting in a substantial number of template instantiations. This can considerably
    slow down the compilation process, affecting the development workflow, and less
    efficient feedback loop.
  prefs: []
  type: TYPE_NORMAL
- en: Less obvious interaction with the rest of the code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Template code can be complex and less obvious in terms of how it interacts with
    the rest of the code base. Developers who are less experienced with templates
    may find it challenging to understand and maintain template-heavy code. The syntax
    can be verbose, and compiler error messages can be difficult to decipher, making
    debugging and troubleshooting more complicated.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a simple mistake in template parameters can lead to confusing
    error messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the developer must understand templates and the specific error
    messages generated by the compiler to resolve the issue. This can be a barrier
    for less experienced developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'C++ 20 provides concepts to improve template error messages and constraints,
    which can help make template code more readable and easier to understand. We can
    create a base class called `BaseCurrency` and derive all currency classes from
    it. This way, we can ensure that all currency classes have a common interface
    and can be used interchangeably:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: 'After these changes, the attempt to instantiate `Price<int>` will result in
    a compile-time error, making it clear that the type must be derived from `BaseCurrency`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: 'C++ versions prior to C++ 20 also provide a way to prevent unintended template
    instantiations by using a combination of `std::enable_if` and `std::is_base_of`
    to enforce constraints on template parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: 'The attempt to initialize `Price<int>` will now result in a compile-time error,
    indicating that the type must be derived from `BaseCurrency`, however, the error
    message will be a bit cryptic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: Limited tool support and debugging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Debugging template code can be challenging due to limited tool support. Many
    debuggers do not handle template instantiations well, making it difficult to step
    through template code and inspect template parameters and instantiations. This
    can hinder the debugging process and make it harder to identify and fix issues.
  prefs: []
  type: TYPE_NORMAL
- en: For example, examining the state of a templated `Price<Usd>` object in a debugger
    might not provide clear insights into the underlying type and values, especially
    if the debugger does not fully support template parameter inspection.
  prefs: []
  type: TYPE_NORMAL
- en: Most autocomplete and IDE tools do not work very well with templates, because
    it is impossible for them to assume the type of the template parameter. This can
    make it harder to navigate and understand template-heavy code bases.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced features of templates might be hard to use
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Templates in C++ provide a mechanism for writing generic and reusable code.
    However, there are situations where the default template behavior needs to be
    customized for specific types. This is where template specialization comes into
    play. Template specialization allows you to define a special behavior for a specific
    type, ensuring that the template behaves correctly for that type.
  prefs: []
  type: TYPE_NORMAL
- en: Why use template specialization?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Template specialization is used when the general template implementation does
    not work correctly or efficiently for a particular type, or when a specific type
    requires a completely different implementation. This can happen due to various
    reasons, such as performance optimizations, special handling of certain data types,
    or compliance with specific requirements.
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider a scenario where you have a general `Printer` template
    class that prints objects of any type. However, for `std::string`, you might want
    to add quotes around the string when printing it.
  prefs: []
  type: TYPE_NORMAL
- en: Basic template specialization example
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here is an example of how template specialization works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the general `Printer` template class prints any type. However,
    for `std::string`, the specialized version adds quotes around the string when
    printing it.
  prefs: []
  type: TYPE_NORMAL
- en: Including the specialization header
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When using template specialization, it is crucial to include the header file
    that contains the specialization definition. If the specialization header is not
    included, the compiler will instantiate the default version of the template, leading
    to incorrect behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`printer.h` (General template definition):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '`printer_string.h` (Template specialization for `std::string`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '`main.cpp` (Using the template and specialization):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: In this setup, if the `printer_string.h` header is not included in `main.cpp`,
    the compiler will use the default `Printer` template for `std::string`, resulting
    in incorrect behavior (printing the string without quotes).
  prefs: []
  type: TYPE_NORMAL
- en: Templates are a crucial part of the C++ programming language, offering powerful
    capabilities for creating generic, reusable, and type-safe code. They are indispensable
    in various scenarios, such as developing generic algorithms, container classes,
    smart pointers, and other utilities that need to work seamlessly with multiple
    data types. Templates enable developers to write flexible and efficient code,
    ensuring that the same functionality can be applied to different types without
    duplication.
  prefs: []
  type: TYPE_NORMAL
- en: However, the power of templates does not come without cost. The use of templates
    can lead to increased compilation times and code bloat, especially in systems
    that support a wide range of types and combinations. The syntax and resulting
    error messages can be complex and difficult to understand, posing a challenge
    for less experienced developers. Additionally, debugging template-heavy code can
    be cumbersome due to limited tool support and the intricate nature of template
    instantiations.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, templates can introduce less obvious interactions with the rest of
    the code base, which might cause issues if not managed properly. Developers must
    also be aware of advanced features, such as template specialization, which require
    careful inclusion of specialized headers to avoid incorrect behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Given these caveats, it is essential for developers to think carefully before
    incorporating templates into their projects. While they provide significant benefits,
    the potential drawbacks necessitate a thoughtful approach to ensure that the advantages
    outweigh the complexities. Proper understanding and judicious use of templates
    can lead to more robust, maintainable, and efficient C++ applications.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the intricacies of advanced C++ programming, focusing
    on class design, inheritance, and templates. We began with the principles of effective
    class design, emphasizing the importance of encapsulating the minimum necessary
    functionality and data to achieve better modularity and maintainability. Through
    practical examples, we highlighted both good and bad design practices. Moving
    on to inheritance, we examined its benefits, such as code reuse, hierarchical
    structuring, and polymorphism, while also addressing its drawbacks, including
    tight coupling, complex hierarchies, and potential violations of the LSP. We provided
    guidance on when to use inheritance and when to consider alternatives such as
    composition. In the section on templates, we delved into their role in enabling
    generic programming, allowing for flexible and reusable components that work with
    any data type. We discussed the advantages of templates, such as code reusability,
    type safety, and performance optimization, but also pointed out their disadvantages,
    including increased compilation times, code bloat, and the complexity of understanding
    and debugging template-heavy code. Throughout these discussions, we underscored
    the need for careful consideration and understanding when utilizing these powerful
    features to ensure robust and maintainable C++ applications. In the next chapter,
    we will shift our focus to API design, exploring best practices for creating clear,
    efficient, and user-friendly interfaces in C++.
  prefs: []
  type: TYPE_NORMAL
