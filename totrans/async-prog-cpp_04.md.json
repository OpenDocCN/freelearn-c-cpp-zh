["```cpp\n#include <iostream>\n#include <thread>\nint counter = 0;\nint main() {\n    auto func = [] {\n        for (int i = 0; i < 1000000; ++i) {\n            counter++;\n        }\n    };\n    std::thread t1(func);\n    std::thread t2(func);\n    t1.join();\n    t2.join();\n    std::cout << counter << std::endl;\n    return 0;\n}\n```", "```cpp\n1056205\n1217311\n1167474\n```", "```cpp\n        counter++;\n```", "```cpp\n#include <iostream>\n#include <mutex>\n#include <thread>\nstd::mutex mtx;\nint counter = 0;\nint main() {\n    auto funcWithoutLocks = [] {\n        for (int i = 0; i < 1000000; ++i) {\n            ++counter;\n        };\n    };\n    auto funcWithLocks = [] {\n        for (int i = 0; i < 1000000; ++i) {\n            mtx.lock();\n            ++counter;\n            mtx.unlock();\n        };\n    };\n    {\n        counter = 0;\n        std::thread t1(funcWithoutLocks);\n        std::thread t2(funcWithoutLocks);\n        t1.join();\n        t2.join();\n        std::cout << \"Counter without using locks: \" << counter << std::endl;\n    }\n    {\n        counter = 0;\n        std::thread t1(funcWithLocks);\n        std::thread t2(funcWithLocks);\n        t1.join();\n        t2.join();\n        std::cout << \"Counter using locks: \" << counter << std::endl;\n    }\n    return 0;\n}\n```", "```cpp\n#include <algorithm>\n#include <chrono>\n#include <iostream>\n#include <shared_mutex>\n#include <thread>\nint counter = 0;\nint main() {\n    using namespace std::chrono_literals;\n    std::shared_mutex mutex;\n    auto reader = [&] {\n        for (int i = 0; i < 10; ++i) {\n            mutex.lock_shared();\n            // Read the counter and do something\n            mutex.unlock_shared();\n        }\n    };\n    auto writer = [&] {\n        for (int i = 0; i < 10; ++i) {\n            mutex.lock();\n            ++counter;\n            std::cout << \"Counter: \" << counter << std::endl;\n            mutex.unlock();\n            std::this_thread::sleep_for(10ms);\n        }\n    };\n    std::thread t1(reader);\n    std::thread t2(reader);\n    std::thread t3(writer);\n    std::thread t4(reader);\n    std::thread t5(reader);\n    std::thread t6(writer);\n    t1.join();\n    t2.join();\n    t3.join();\n    t4.join();\n    t5.join();\n    t6.join();\n    return 0;\n}\n```", "```cpp\n#include <algorithm>\n#include <chrono>\n#include <iostream>\n#include <mutex>\n#include <thread>\n#include <vector>\nconstexpr int NUM_THREADS = 8;\nint counter = 0;\nint failed = 0;\nint main() {\n    using namespace std::chrono_literals;\n    std::timed_mutex tm;\n    std::mutex m;\n    auto worker = [&] {\n        for (int i = 0; i < 10; ++i) {\n            if (tm.try_lock_for(10ms)) {\n                ++counter;\n                std::cout << \"Counter: \" << counter << std::endl;\n                std::this_thread::sleep_for(10ms);\n                m.unlock();\n            }\n            else {\n                m.lock();\n                ++failed;\n                std::cout << \"Thread \" << std::this_thread::get_id() << \" failed to lock\" << std::endl;\n                m.unlock();\n            }\n            std::this_thread::sleep_for(12ms);\n        }\n    };\n    std::vector<std::thread> threads;\n    for (int i = 0; i < NUM_THREADS; ++i) {\n        threads.emplace_back(worker);\n    }\n    for (auto& t : threads) {\n        t.join();\n    }\n    std::cout << \"Counter: \" << counter << std::endl;\n    std::cout << \"Failed: \" << failed << std::endl;\n    return 0;\n}\n```", "```cpp\n#include <format>\n#include <iostream>\n#include <mutex>\n#include <thread>\nstd::mutex mtx;\nuint32_t counter{};\nvoid function_throws() { throw std::runtime_error(\"Error\"); }\nint main() {\n    auto worker = [] {\n        for (int i = 0; i < 1000000; ++i) {\n            mtx.lock();\n            counter++;\n            mtx.unlock();\n        }\n    };\n    auto worker_exceptions = [] {\n        for (int i = 0; i < 1000000; ++i) {\n            try {\n                std::lock_guard<std::mutex> lock(mtx);\n                counter++;\n                function_throws();\n            } catch (std::system_error& e) {\n                std::cout << e.what() << std::endl;\n                return;\n            } catch (...) {\n                return;\n            }\n        }\n    };\n    std::thread t1(worker_exceptions);\n    std::thread t2(worker);\n    t1.join();\n    t2.join();\n    std::cout << \"Final counter value: \" << counter << std::endl;\n}\n```", "```cpp\nstd::mutex mtx1;\nstd::mutex mtx2;\n// Acquire both mutexes avoiding deadlock\nstd::scoped_lock lock(mtx1, mtx2);\n// Same as doing this\n// std::lock(mtx1, mtx2);\n// std::lock_guard<std::mutex> lock1(mtx1, std::adopt_lock);\n// std::lock_guard<std::mutex> lock2(mtx2, std::adopt_lock);\n```", "```cpp\n#include <chrono>\n#include <condition_variable>\n#include <iostream>\n#include <mutex>\n#include <thread>\n#include <vector>\nint counter = 0;\nint main() {\n    using namespace std::chrono_literals;\n    std::mutex mtx;\n    std::mutex cout_mtx;\n    std::condition_variable cv;\n    auto increment_counter = [&] {\n        for (int i = 0; i < 20; ++i) {\n            std::this_thread::sleep_for(100ms);\n            mtx.lock();\n            ++counter;\n            mtx.unlock();\n            cv.notify_one();\n        }\n    };\n    auto wait_for_counter_non_zero_mtx = [&] {\n        mtx.lock();\n        while (counter == 0) {\n            mtx.unlock();\n            std::this_thread::sleep_for(10ms);\n            mtx.lock();\n        }\n        mtx.unlock();\n        std::lock_guard<std::mutex> cout_lck(cout_mtx);\n        std::cout << \"Counter is non-zero\" << std::endl;\n    };\n    auto wait_for_counter_10_cv = [&] {\n        std::unique_lock<std::mutex> lck(mtx);\n        cv.wait(lck, [] { return counter == 10; });\n        std::lock_guard<std::mutex> cout_lck(cout_mtx);\n        std::cout << \"Counter is: \" << counter << std::endl;\n    };\n    std::thread t1(wait_for_counter_non_zero_mtx);\n    std::thread t2(wait_for_counter_10_cv);\n    std::thread t3(increment_counter);\n    t1.join();\n    t2.join();\n    t3.join();\n    return 0;\n}\n```", "```cpp\ntemplate <typename T>\nclass synchronized_queue {\npublic:\n    explicit synchronized_queue(size_t size) :\n        capacity_{ size }, buffer_(capacity_)\n        {}\nprivate:\n    std::size_t head_{ 0 };\n    std::size_t tail_{ 0 };\n    std::size_t capacity_;\n    std::vector<T> buffer_;\n};\n```", "```cpp\ntemplate <typename T>\nclass synchronized_queue {\npublic:\n    explicit synchronized_queue(size_t size) :\n        capacity_{ size }, buffer_(capacity_) {\n    }\nprivate:\n    std::size_t next(std::size_t index) {\n        return (index + 1)% capacity_;\n    }\n    bool is_full() const {\n        return next(tail_) == head_;\n    }\n    bool is_empty() const {\n        return tail_ == head_;\n    }\n    std::size_t head_{ 0 };\n    std::size_t tail_{ 0 };\n    std::size_t capacity_;\n    std::vector<T> buffer_;\n};\n```", "```cpp\nvoid push(const T& item);\nvoid pop(T& item);\n```", "```cpp\nstd::mutex mtx_;\nstd::condition_variable not_full_;\nStd::condition_variable not_empty_;\n```", "```cpp\nvoid push(const T& item) {\n    std::unique_lock<std::mutex> lock(mtx_);\n    not_full_.wait(lock, [this]{ return !is_full(); });\n    buffer_[tail_] = T;\n    tail_ = increment(tail_);\n    lock.unlock();\n    not_empty_.notify_one();\n}\n```", "```cpp\nvoid pop(T& item)\n{\n    std::unique_lock<std::mutex> lock(mtx_);\n    not_empty_.wait(lock, [this]{return !is_empty()});\n    item = buffer_[head_];\n    head_ = increment(head_);\n    lock.unlock();\n    not_full_.notify_one();\n}\n```", "```cpp\nbool try_push(const T& item) {\n    std::unique_lock<std::mutex> lock(mtx_, std::try_to_lock);\n    if (!lock || is_full()) {\n        return false;\n    }\n    buffer_[tail_] = item;\n    tail_ = next(tail_);\n    lock.unlock();\n    not_empty_.notify_one();\n    return true;\n}\n```", "```cpp\nbool try_pop(T& item) {\n     std::unique_lock<std::mutex> lock(mtx_, std::try_to_lock);\n     if (!lock || is_empty()) {\n         return false;\n     }\n     item = buffer_[head_];\n     head_ = next(head_);\n     lock.unlock();\n     not_empty_.notify_one();\n     return true;\n }\n```", "```cpp\n#pragma once\n#include <condition_variable>\n#include <mutex>\n#include <vector>\nnamespace async_prog {\ntemplate <typename T>\nclass queue {\npublic:\n    queue(std::size_t capacity) : capacity_{capacity}, buffer_(capacity) {}\n    void push(const T& item) {\n        std::unique_lock<std::mutex> lock(mtx_);\n        not_full_.wait(lock, [this] { return !is_full(); });\n        buffer_[tail_] = item;\n        tail_ = next(tail_);\n        lock.unlock();\n        not_empty_.notify_one();\n    }\n    bool try_push(const T& item) {\n        std::unique_lock<std::mutex> lock(mtx_, std::try_to_lock);\n        if (!lock || is_full()) {\n            return false;\n        }\n        buffer_[tail_] = item;\n        tail_ = next(tail_);\n        lock.unlock();\n        not_empty_.notify_one();\n        return true;\n    }\n    void pop(T& item) {\n        std::unique_lock<std::mutex> lock(mtx_);\n        not_empty_.wait(lock, [this] { return !is_empty(); });\n        item = buffer_[head_];\n        head_ = next(head_);\n        lock.unlock();\n        not_full_.notify_one();\n    }\n    bool try_pop(T& item) {\n        std::unique_lock<std::mutex> lock(mtx_, std::try_to_lock);\n        if (!lock || is_empty()) {\n            return false;\n        }\n        item = buffer_[head_];\n        head_ = next(head_);\n        lock.unlock();\n        not_empty_.notify_one();\n        return true;\n    }\nprivate:\n    [[nodiscard]] std::size_t next(std::size_t idx) const noexcept {\n        return ((idx + 1) % capacity_);\n    }\n    [[nodiscard]] bool is_empty() const noexcept { return (head_ == tail_); }\n    [[nodiscard]] bool is_full() const noexcept { return (next(tail_) == head_); }\n   private:\n    std::mutex mtx_;\n    std::condition_variable not_empty_;\n    std::condition_variable not_full_;\n    std::size_t head_{0};\n    std::size_t tail_{0};\n    std::size_t capacity_;\n    std::vector<T> buffer_;\n};\n}\n```", "```cpp\nstd::binary_semaphore sm1{ 0 };\nstd::binary_semaphore sm2{ 1 };\n```", "```cpp\ntemplate <typename T>\nclass queue {\n // public methods and private helper methods\nprivate:\n    std::counting_semaphore<> sem_empty_;\n    std::counting_semaphore<> sem_full_;\n    std::size_t head_{ 0 };\n    std::size_t tail_{ 0 };\n    std::size_t capacity_;\n    std::vector<T> buffer_;\n};\n```", "```cpp\nvoid push(const T& item) {\n    sem_empty_.acquire();\n    buffer_[tail_] = item;\n    tail_ = next(tail_);\n    sem_full_.release();\n}\n```", "```cpp\nvoid pop(T& item) {\n    sem_full_.acquire();\n    item = buffer_[head_];\n    head_ = next(head_);\n    sem_empty_.release();\n}\n```", "```cpp\nvoid push(const T& item)\n{\n    sem_empty_.acquire();\n    std::unique_lock<std::mutex> lock(mtx_);\n    buffer_[tail_] = item;\n    tail_ = next(tail_);\n    lock.unlock();\n    sem_full_.release();\n}\n```", "```cpp\nbool try_push(const T& item) {\n    if (!sem_empty_.try acquire()) {\n        return false;\n    }\n    std::unique_lock<std::mutex> lock(mtx_);\n    buffer_[tail_] = item;\n    tail_ = next(tail_);\n    lock.unlock();\n    sem_full_.release();\n    return true;\n}\n```", "```cpp\n#pragma once\n#include <mutex>\n#include <semaphore>\n#include <vector>\nnamespace async_prog {\ntemplate <typename T>\nclass semaphore_queue {\n   public:\n    semaphore_queue(std::size_t capacity)\n        : sem_empty_(capacity), sem_full_(0), capacity_{capacity}, buffer_(capacity)\n    {}\n    void push(const T& item) {\n        sem_empty_.acquire();\n        std::unique_lock<std::mutex> lock(mtx_);\n        buffer_[tail_] = item;\n        tail_ = next(tail_);\n        lock.unlock();\n        sem_full_.release();\n    }\n    bool try_push(const T& item) {\n        if (!sem_empty_.try_acquire()) {\n            return false;\n        }\n        std::unique_lock<std::mutex> lock(mtx_);\n        buffer_[tail_] = item;\n        tail_ = next(tail_);\n        lock.unlock();\n        sem_full_.release();\n        return true;\n    }\n    void pop(T& item) {\n        sem_full_.acquire();\n        std::unique_lock<std::mutex> lock(mtx_);\n        item = buffer_[head_];\n        head_ = next(head_);\n        lock.unlock();\n        sem_empty_.release();\n    }\n    bool try_pop(T& item) {\n        if (!sem_full_.try_acquire()) {\n            return false;\n        }\n        std::unique_lock<std::mutex> lock(mtx_);\n        item = buffer_[head_];\n        head_ = next(head_);\n        lock.unlock();\n        sem_empty_.release();\n        return true;\n    }\nprivate:\n    [[nodiscard]] std::size_t next(std::size_t idx) const noexcept {\n        return ((idx + 1) % capacity_);\n    }\nprivate:\n    std::mutex mtx_;\n    std::counting_semaphore<> sem_empty_;\n    std::counting_semaphore<> sem_full_;\n    std::size_t head_{0};\n    std::size_t tail_{0};\n    std::size_t capacity_;\n    std::vector<T> buffer_;\n};\n```", "```cpp\nstd::latch map_latch{ 3 };\nauto map_thread = [&](std::vector<int>& numbers, int start, int end) {\n    for (int i = start; i < end; ++i) {\n        numbers[i] *= 2;\n    }\n    map_latch.count_down();\n};\n```", "```cpp\nstd::latch reduce_latch{ 1 };\nauto reduce_thread = [&](const std::vector<int>& numbers, int& sum) {\n    map_latch.wait();\n    sum = std::accumulate(numbers.begin(), numbers.end(), 0);\n    reduce_latch.count_down();\n};\n```", "```cpp\nreduce_latch.wait();\nstd::cout << \"All threads finished. The sum is: \" << sum << '\\n';\n```", "```cpp\nstd::barrier map_barrier{ 3 };\nauto worker_thread = [&](std::vector<int>& numbers, int start, int end, int id) {\n    std::cout << std::format(\"Thread {0} is starting...\\n\", id);\n    for (int i = start; i < end; ++i) {\n        numbers[i] *= 2;\n    }\n    map_barrier.arrive_and_wait();\n    for (int i = start; i < end; ++i) {\n        sum[id] += numbers[i];\n    }\n    map_barrier.arrive();\n};\n```", "```cpp\nfor (auto& t : workers) {\n    t.join();\n}\nstd::cout << std::format(\"The total sum is {0}\\n\",\n                         std::accumulate(sum.begin(), sum. End(), 0));\n```", "```cpp\n#include <algorithm>\n#include <barrier>\n#include <format>\n#include <iostream>\n#include <latch>\n#include <numeric>\n#include <thread>\n#include <vector>\nvoid multiply_add_latch() {\n    const int NUM_THREADS{3};\n    std::latch map_latch{NUM_THREADS};\n    std::latch reduce_latch{1};\n    std::vector<int> numbers(3000);\n    int sum{};\n    std::iota(numbers.begin(), numbers.end(), 0);\n    auto map_thread = [&](std::vector<int>& numbers, int start, int end) {\n        for (int i = start; i < end; ++i) {\n            numbers[i] *= 2;\n        }\n        map_latch.count_down();\n    };\n    auto reduce_thread = [&](const std::vector<int>& numbers, int& sum) {\n        map_latch.wait();\n        sum = std::accumulate(numbers.begin(), numbers.end(), 0);\n        reduce_latch.count_down();\n    };\n    for (int i = 0; i < NUM_THREADS; ++i) {\n        std::jthread t(map_thread, std::ref(numbers), 1000 * i, 1000 * (i + 1));\n    }\n    std::jthread t(reduce_thread, numbers, std::ref(sum));\n    reduce_latch.wait();\n    std::cout << \"All threads finished. The total sum is: \" << sum << '\\n';\n}\nvoid multiply_add_barrier() {\n    const int NUM_THREADS{3};\n    std::vector<int> sum(3, 0);\n    std::vector<int> numbers(3000);\n    std::iota(numbers.begin(), numbers.end(), 0);\n    std::barrier map_barrier{NUM_THREADS};\n    auto worker_thread = [&](std::vector<int>& numbers, int start, int end, int id) {\n        std::cout << std::format(\"Thread {0} is starting...\\n\", id);\n        for (int i = start; i < end; ++i) {\n            numbers[i] *= 2;\n        }\n        map_barrier.arrive_and_wait();\n        for (int i = start; i < end; ++i) {\n            sum[id] += numbers[i];\n        }\n        map_barrier.arrive();\n    };\n    std::vector<std::jthread> workers;\n    for (int i = 0; i < NUM_THREADS; ++i) {\n        workers.emplace_back(worker_thread, std::ref(numbers), 1000 * i,\n                             1000 * (i + 1), i);\n    }\n    for (auto& t : workers) {\n        t.join();\n    }\n    std::cout << std::format(\"All threads finished. The total sum is: {0}\\n\",\n     std::accumulate(sum.begin(), sum.end(), 0));\n}\nint main() {\n    std::cout << \"Multiplying and reducing vector using barriers...\" << std::endl;\n    multiply_add_barrier();\n    std::cout << \"Multiplying and reducing vector using latches...\" << std::endl;\n    multiply_add_latch();\n    return 0;\n}\n```", "```cpp\n#include <exception>\n#include <iostream>\n#include <mutex>\n#include <thread>\nint main() {\n    std::once_flag run_once_flag;\n    std::once_flag run_once_exceptions_flag;\n    auto thread_function = [&] {\n        std::call_once(run_once_flag, []{\n            std::cout << \"This must run just once\\n\";\n        });\n    };\n    std::jthread t1(thread_function);\n    std::jthread t2(thread_function);\n    std::jthread t3(thread_function);\n    auto function_throws = [&](bool throw_exception) {\n        if (throw_exception) {\n            std::cout << \"Throwing exception\\n\";\n            throw std::runtime_error(\"runtime error\");\n        }\n        std::cout << \"No exception was thrown\\n\";\n    };\n    auto thread_function_1 = [&](bool throw_exception) {\n        try {\n            std::call_once(run_once_exceptions_flag,\n                           function_throws,\n                           throw_exception);\n        }\n        catch (...) {\n        }\n    };\n    std::jthread t4(thread_function_1, true);\n    std::jthread t5(thread_function_1, true);\n    std::jthread t6(thread_function_1, false);\n    return 0;\n}\n```"]