<html><head></head><body>
  <div id="_idContainer030">
   <h1 class="chapter-number" id="_idParaDest-75">
    <a id="_idTextAnchor074">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     4
    </span>
   </h1>
   <h1 id="_idParaDest-76">
    <a id="_idTextAnchor075">
    </a>
    <span class="koboSpan" id="kobo.2.1">
     Thread Synchronization  with Locks
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.3.1">
     In
    </span>
    <a href="B22219_02.xhtml#_idTextAnchor035">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.4.1">
        Chapter 2
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.5.1">
     , we learned that threads can read and write memory shared by the process they belong to.
    </span>
    <span class="koboSpan" id="kobo.5.2">
     While the operating system implements process memory access protection, there is no such protection for threads accessing shared memory in the same process.
    </span>
    <span class="koboSpan" id="kobo.5.3">
     Concurrent memory write operations to the same memory address from multiple threads require synchronization mechanisms to avoid data races and ensure
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.6.1">
      data integrity.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.7.1">
     In this chapter, we will describe in detail the problems created by concurrent access to shared memory by multiple threads and how to fix them.
    </span>
    <span class="koboSpan" id="kobo.7.2">
     We are going to study in detail the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.8.1">
      following topics:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.9.1">
      Race conditions – what they are and how they
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.10.1">
       can happen
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.11.1">
      Mutual exclusion as a synchronization mechanism and how it is implemented in C++
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.12.1">
       by
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.13.1">
        std::mutex
       </span>
      </strong>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.14.1">
      Generic
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.15.1">
       lock management
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.16.1">
      What condition variables are and how to use them
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.17.1">
       with mutexes
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.18.1">
      Implementing a fully synchronized queue using
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.19.1">
       std::mutex
      </span>
     </strong>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.20.1">
       and
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.21.1">
        std::condition_variable
       </span>
      </strong>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.22.1">
      The new synchronization primitives introduced with C++20 – semaphores, barriers,
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.23.1">
       and latches
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.24.1">
     These are all lock-based synchronization mechanisms.
    </span>
    <span class="koboSpan" id="kobo.24.2">
     Lock-free techniques are the subject of the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.25.1">
      next chapter.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-77">
    <a id="_idTextAnchor076">
    </a>
    <span class="koboSpan" id="kobo.26.1">
     Technical requirements
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.27.1">
     The technical requirements for this chapter are the same as for the concepts explained in the previous chapter, and to compile and run the examples, a C++ compiler with C++20 support is required (for semaphores, latches, and barriers examples).
    </span>
    <span class="koboSpan" id="kobo.27.2">
     Most of the examples require just C++11.
    </span>
    <span class="koboSpan" id="kobo.27.3">
     Examples have been tested on Linux Ubuntu
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.28.1">
      LTS 24.04.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.29.1">
     The code in this chapter can be found
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.30.1">
      on GitHub:
     </span>
    </span>
   </p>
   <p>
    <a href="https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.31.1">
       https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP
      </span>
     </span>
    </a>
   </p>
   <h1 id="_idParaDest-78">
    <a id="_idTextAnchor077">
    </a>
    <span class="koboSpan" id="kobo.32.1">
     Understanding race conditions
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.33.1">
     A race condition
    </span>
    <a id="_idIndexMarker218">
    </a>
    <span class="koboSpan" id="kobo.34.1">
     happens when the outcome of running a program depends on the sequence in which its instructions are executed.
    </span>
    <span class="koboSpan" id="kobo.34.2">
     We will begin with a very simple example to show how race conditions happen, and later in this chapter, we will learn how to resolve
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.35.1">
      this problem.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.36.1">
     In the following code, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.37.1">
      counter
     </span>
    </strong>
    <span class="koboSpan" id="kobo.38.1">
     global variable is incremented by two threads
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.39.1">
      running concurrently:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.40.1">
#include &lt;iostream&gt;
#include &lt;thread&gt;
int counter = 0;
int main() {
    auto func = [] {
        for (int i = 0; i &lt; 1000000; ++i) {
            counter++;
        }
    };
    std::thread t1(func);
    std::thread t2(func);
    t1.join();
    t2.join();
    std::cout &lt;&lt; counter &lt;&lt; std::endl;
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.41.1">
     After running the preceding code three times, we get the following
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.42.1">
       counter
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.43.1">
      values:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.44.1">
1056205
1217311
1167474</span></pre>
   <p>
    <span class="koboSpan" id="kobo.45.1">
     We see two main issues here: first, the value of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.46.1">
      counter
     </span>
    </strong>
    <span class="koboSpan" id="kobo.47.1">
     is incorrect; second, every execution of the program ends with a different value of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.48.1">
      counter
     </span>
    </strong>
    <span class="koboSpan" id="kobo.49.1">
     .
    </span>
    <span class="koboSpan" id="kobo.49.2">
     The results are non-deterministic and most frequently incorrect.
    </span>
    <span class="koboSpan" id="kobo.49.3">
     If you are very lucky, you may get the right values, but that is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.50.1">
      very unlikely.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.51.1">
     This scenario involves two threads,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.52.1">
      t1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.53.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.54.1">
      t2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.55.1">
     , that run concurrently and modify the same variable, which is essentially some memory region.
    </span>
    <span class="koboSpan" id="kobo.55.2">
     It seems like it should work fine because there is only one line of code that increases the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.56.1">
      counter
     </span>
    </strong>
    <span class="koboSpan" id="kobo.57.1">
     value and thus modifies the memory content (by the way, it doesn’t matter if we use the post-increment operator like in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.58.1">
      counter++
     </span>
    </strong>
    <span class="koboSpan" id="kobo.59.1">
     or the pre-increment operator like in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.60.1">
      ++counter
     </span>
    </strong>
    <span class="koboSpan" id="kobo.61.1">
     ; the results will be
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.62.1">
      equally wrong).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.63.1">
     Looking closer at the
    </span>
    <a id="_idIndexMarker219">
    </a>
    <span class="koboSpan" id="kobo.64.1">
     preceding code, let’s study the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.65.1">
      line carefully:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.66.1">
        counter++;</span></pre>
   <p>
    <span class="koboSpan" id="kobo.67.1">
     It increments
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.68.1">
      counter
     </span>
    </strong>
    <span class="koboSpan" id="kobo.69.1">
     in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.70.1">
      three steps:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.71.1">
      The contents of the memory address where the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.72.1">
       counter
      </span>
     </strong>
     <span class="koboSpan" id="kobo.73.1">
      variable is stored are loaded into a CPU register.
     </span>
     <span class="koboSpan" id="kobo.73.2">
      In this case, an
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.74.1">
       int
      </span>
     </strong>
     <span class="koboSpan" id="kobo.75.1">
      data type is loaded from memory into a
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.76.1">
       CPU register.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.77.1">
      The value in the register is incremented
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.78.1">
       by one.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.79.1">
      The value in the register is stored in the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.80.1">
       counter
      </span>
     </strong>
     <span class="koboSpan" id="kobo.81.1">
      variable
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.82.1">
       memory address.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.83.1">
     Now, let us consider a possible scenario when two threads attempt to increment the counter concurrently.
    </span>
    <span class="koboSpan" id="kobo.83.2">
     Let us look at
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.84.1">
       Table 4.1
      </span>
     </em>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.85.1">
      :
     </span>
    </span>
   </p>
   <table class="No-Table-Style _idGenTablePara-1" id="table001-1">
    <colgroup>
     <col/>
     <col/>
    </colgroup>
    <thead>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="bold">
          <span class="koboSpan" id="kobo.86.1">
           THREAD 1
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="bold">
          <span class="koboSpan" id="kobo.87.1">
           THREAD 2
          </span>
         </strong>
        </span>
       </p>
      </td>
     </tr>
    </thead>
    <tbody>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.88.1">
         [1] Load counter value
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.89.1">
          into register
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.90.1">
         [3] Load counter value
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.91.1">
          into register
         </span>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.92.1">
         [2] Increment
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.93.1">
          register value
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.94.1">
         [5] Increment
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.95.1">
          register value
         </span>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.96.1">
         [4] Store register
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.97.1">
          in counter
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.98.1">
         [6] Store register
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.99.1">
          in counter
         </span>
        </span>
       </p>
      </td>
     </tr>
    </tbody>
   </table>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.100.1">
     Table 4.1: Two threads incrementing the counter concurrently
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.101.1">
     Thread 1 executes [1] and loads the current value of the counter (let’s assume it is 1) into a CPU register.
    </span>
    <span class="koboSpan" id="kobo.101.2">
     Then, it increments the value in the register by one [2] (now, the register value
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.102.1">
      is 2).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.103.1">
     Thread 2 is scheduled for execution and [3] loads the current value of the counter (remember – it has not been modified yet, so it is still 1) into a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.104.1">
      CPU register.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.105.1">
     Now, thread 1 is scheduled again for execution and [4] stores the updated value into memory.
    </span>
    <span class="koboSpan" id="kobo.105.2">
     The value of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.106.1">
      counter
     </span>
    </strong>
    <span class="koboSpan" id="kobo.107.1">
     is now equal
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.108.1">
      to two.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.109.1">
     Finally, thread 2 is scheduled again, and [5] and [6] are executed.
    </span>
    <span class="koboSpan" id="kobo.109.2">
     The register value is incremented by one and then the value two is stored in memory.
    </span>
    <span class="koboSpan" id="kobo.109.3">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.110.1">
      counter
     </span>
    </strong>
    <span class="koboSpan" id="kobo.111.1">
     variable has been incremented just once when it should have been incremented twice and its value should
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.112.1">
      be three.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.113.1">
     The previous issue happened because the increment operation on the counter is not atomic.
    </span>
    <span class="koboSpan" id="kobo.113.2">
     If each thread could execute the three instructions required to increment the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.114.1">
      counter
     </span>
    </strong>
    <span class="koboSpan" id="kobo.115.1">
     variable
    </span>
    <a id="_idIndexMarker220">
    </a>
    <span class="koboSpan" id="kobo.116.1">
     without being interrupted,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.117.1">
      counter
     </span>
    </strong>
    <span class="koboSpan" id="kobo.118.1">
     would be incremented twice as expected.
    </span>
    <span class="koboSpan" id="kobo.118.2">
     However, depending on the order in which the operations are executed, the result can be different.
    </span>
    <span class="koboSpan" id="kobo.118.3">
     This is called a
    </span>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.119.1">
       race condition
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.120.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.121.1">
     To avoid race conditions, we need to ensure that shared resources are accessed and modified in a controlled manner.
    </span>
    <span class="koboSpan" id="kobo.121.2">
     One way to achieve this is by using locks.
    </span>
    <span class="koboSpan" id="kobo.121.3">
     A
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.122.1">
      lock
     </span>
    </strong>
    <span class="koboSpan" id="kobo.123.1">
     is a synchronization
    </span>
    <a id="_idIndexMarker221">
    </a>
    <span class="koboSpan" id="kobo.124.1">
     primitive that allows only one thread to access a shared resource at a time.
    </span>
    <span class="koboSpan" id="kobo.124.2">
     When a thread wants to access a shared resource, it must first acquire the lock.
    </span>
    <span class="koboSpan" id="kobo.124.3">
     Once the thread has acquired the lock, it can access the shared resource without interference from other threads.
    </span>
    <span class="koboSpan" id="kobo.124.4">
     When the thread has finished accessing the shared resource, it must release the lock so that other threads can
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.125.1">
      access it.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.126.1">
     Another way to avoid race conditions is
    </span>
    <a id="_idIndexMarker222">
    </a>
    <span class="koboSpan" id="kobo.127.1">
     by using
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.128.1">
      atomic operations
     </span>
    </strong>
    <span class="koboSpan" id="kobo.129.1">
     .
    </span>
    <span class="koboSpan" id="kobo.129.2">
     An atomic operation is an operation that is guaranteed to be executed in a single, indivisible step.
    </span>
    <span class="koboSpan" id="kobo.129.3">
     This means that no other thread can interfere with an atomic operation while it is being executed.
    </span>
    <span class="koboSpan" id="kobo.129.4">
     Atomic operations are typically implemented using hardware instructions that are designed to be indivisible.
    </span>
    <span class="koboSpan" id="kobo.129.5">
     Atomic operations will be explained in
    </span>
    <a href="B22219_05.xhtml#_idTextAnchor097">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.130.1">
        Chapter 5
       </span>
      </em>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.131.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.132.1">
     In this section, we have seen the most common and important problem created by multithreaded code: race conditions.
    </span>
    <span class="koboSpan" id="kobo.132.2">
     We have seen how, depending on the order of the operations performed, the
    </span>
    <a id="_idIndexMarker223">
    </a>
    <span class="koboSpan" id="kobo.133.1">
     results can be different.
    </span>
    <span class="koboSpan" id="kobo.133.2">
     With this problem in mind, we are going to study how to solve it in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.134.1">
      next section.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-79">
    <a id="_idTextAnchor078">
    </a>
    <span class="koboSpan" id="kobo.135.1">
     Why do we need mutual exclusion?
    </span>
   </h1>
   <p>
    <strong class="bold">
     <span class="koboSpan" id="kobo.136.1">
      Mutual exclusion
     </span>
    </strong>
    <span class="koboSpan" id="kobo.137.1">
     is a fundamental
    </span>
    <a id="_idIndexMarker224">
    </a>
    <span class="koboSpan" id="kobo.138.1">
     concept in concurrent programming that ensures that multiple threads or processes do not simultaneously access a shared resource such as a shared variable, a critical section of code, or a file or network connection.
    </span>
    <span class="koboSpan" id="kobo.138.2">
     Mutual exclusion is crucial for preventing race conditions such as the one we have seen in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.139.1">
      previous section.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.140.1">
     Imagine a small coffee shop with a single espresso machine.
    </span>
    <span class="koboSpan" id="kobo.140.2">
     The machine can only make one espresso at a time.
    </span>
    <span class="koboSpan" id="kobo.140.3">
     This means the machine is a critical resource that all baristas
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.141.1">
      must share.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.142.1">
     The coffee shop is attended by three baristas: Alice, Bob, and Carol.
    </span>
    <span class="koboSpan" id="kobo.142.2">
     They use the coffee machine
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.143.1">
      concurrently
     </span>
    </em>
    <span class="koboSpan" id="kobo.144.1">
     , but they cannot use it simultaneously because that could create problems: Bob puts the right amount of freshly ground coffee in the machine and starts making an espresso.
    </span>
    <span class="koboSpan" id="kobo.144.2">
     Then, Alice does the same but first removes the coffee from the machine, thinking that Bob just forgot to do it.
    </span>
    <span class="koboSpan" id="kobo.144.3">
     Bob then takes the espresso from the machine, and after that, Alice finds that there is no espresso!
    </span>
    <span class="koboSpan" id="kobo.144.4">
     This is a disaster – a real-life version of our
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.145.1">
      counter program.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.146.1">
     To fix the problems in the coffee shop, they may appoint Carol as a machine manager.
    </span>
    <span class="koboSpan" id="kobo.146.2">
     Before using the machine, both Alice and Bob ask her if they can start making a new espresso.
    </span>
    <span class="koboSpan" id="kobo.146.3">
     That would solve
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.147.1">
      the issue.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.148.1">
     Back to our counter program, if we could allow just one thread at a time to access
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.149.1">
      counter
     </span>
    </strong>
    <span class="koboSpan" id="kobo.150.1">
     (what Carol did in the coffee shop), our software problem would be solved too.
    </span>
    <span class="koboSpan" id="kobo.150.2">
     Mutual exclusion is a mechanism that can be used to control concurrent thread access to memory.
    </span>
    <span class="koboSpan" id="kobo.150.3">
     The C++ Standard Library provides the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.151.1">
      std::mutex
     </span>
    </strong>
    <span class="koboSpan" id="kobo.152.1">
     class, a synchronization primitive used to protect shared data from being simultaneously accessed by two or
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.153.1">
      more threads.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.154.1">
     This new version of the code we saw in the previous section implements two ways of concurrently incrementing
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.155.1">
      counter
     </span>
    </strong>
    <span class="koboSpan" id="kobo.156.1">
     : free access, as in the previous section, and synchronized
    </span>
    <a id="_idIndexMarker225">
    </a>
    <span class="koboSpan" id="kobo.157.1">
     access using
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.158.1">
      mutual exclusion:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.159.1">
#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;
std::mutex mtx;
int counter = 0;
int main() {
    auto funcWithoutLocks = [] {
        for (int i = 0; i &lt; 1000000; ++i) {
            ++counter;
        };
    };
    auto funcWithLocks = [] {
        for (int i = 0; i &lt; 1000000; ++i) {
            mtx.lock();
            ++counter;
            mtx.unlock();
        };
    };
    {
        counter = 0;
        std::thread t1(funcWithoutLocks);
        std::thread t2(funcWithoutLocks);
        t1.join();
        t2.join();
        std::cout &lt;&lt; "Counter without using locks: " &lt;&lt; counter &lt;&lt; std::endl;
    }
    {
        counter = 0;
        std::thread t1(funcWithLocks);
        std::thread t2(funcWithLocks);
        t1.join();
        t2.join();
        std::cout &lt;&lt; "Counter using locks: " &lt;&lt; counter &lt;&lt; std::endl;
    }
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.160.1">
     When a thread runs
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.161.1">
      funcWithLocks
     </span>
    </strong>
    <span class="koboSpan" id="kobo.162.1">
     , it acquires a lock with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.163.1">
      mtx.lock()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.164.1">
     before incrementing
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.165.1">
      counter
     </span>
    </strong>
    <span class="koboSpan" id="kobo.166.1">
     .
    </span>
    <span class="koboSpan" id="kobo.166.2">
     Once
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.167.1">
      counter
     </span>
    </strong>
    <span class="koboSpan" id="kobo.168.1">
     has been incremented, the thread releases the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.169.1">
      lock (
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.170.1">
       mtx.unlock()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.171.1">
      ).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.172.1">
     The lock can only be owned by one thread.
    </span>
    <span class="koboSpan" id="kobo.172.2">
     If, for example,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.173.1">
      t1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.174.1">
     acquires the lock and then
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.175.1">
      t2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.176.1">
     tries to acquire it too,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.177.1">
      t2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.178.1">
     will be blocked and will wait until the lock is available.
    </span>
    <span class="koboSpan" id="kobo.178.2">
     Because only one thread can own the lock at any time, this synchronization primitive is called a
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.179.1">
      mutex
     </span>
    </strong>
    <span class="koboSpan" id="kobo.180.1">
     (from
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.181.1">
      mutual exclusion
     </span>
    </em>
    <span class="koboSpan" id="kobo.182.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.182.2">
     If you
    </span>
    <a id="_idIndexMarker226">
    </a>
    <span class="koboSpan" id="kobo.183.1">
     run this program a few times, you will always get the correct
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.184.1">
      result:
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.185.1">
       2000000
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.186.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.187.1">
     In this section, we introduced the concept of mutual exclusion and learned that the C++ Standard Library
    </span>
    <a id="_idIndexMarker227">
    </a>
    <span class="koboSpan" id="kobo.188.1">
     provides the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.189.1">
      std::mutex
     </span>
    </strong>
    <span class="koboSpan" id="kobo.190.1">
     class as a primitive for thread synchronization.
    </span>
    <span class="koboSpan" id="kobo.190.2">
     In the next section, we will study
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.191.1">
      std::mutex
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.192.1">
      in detail.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-80">
    <a id="_idTextAnchor079">
    </a>
    <span class="koboSpan" id="kobo.193.1">
     C++ Standard Library mutual exclusion implementation
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.194.1">
     In the previous section, we
    </span>
    <a id="_idIndexMarker228">
    </a>
    <span class="koboSpan" id="kobo.195.1">
     introduced the concept of mutual exclusion and mutexes and why they are needed to synchronize concurrent memory access.
    </span>
    <span class="koboSpan" id="kobo.195.2">
     In this section, we will see the classes provided by the C++ Standard Library to implement mutual exclusion.
    </span>
    <span class="koboSpan" id="kobo.195.3">
     We will also see some helper classes the C++ Standard Library provides to make the use of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.196.1">
      mutexes easier.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.197.1">
     The following table summarizes the mutex classes provided by the C++ Standard Library and their
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.198.1">
      main features:
     </span>
    </span>
   </p>
   <table class="No-Table-Style _idGenTablePara-1" id="table002">
    <colgroup>
     <col/>
     <col/>
     <col/>
     <col/>
    </colgroup>
    <tbody>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="bold">
          <span class="koboSpan" id="kobo.199.1">
           Mutex Type
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="bold">
          <span class="koboSpan" id="kobo.200.1">
           Access
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="bold">
          <span class="koboSpan" id="kobo.201.1">
           Recursive
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="bold">
          <span class="koboSpan" id="kobo.202.1">
           Timeout
          </span>
         </strong>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.203.1">
           std::mutex
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.204.1">
          EXCLUSIVE
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.205.1">
          NO
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.206.1">
          NO
         </span>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.207.1">
           std::recursive_mutex
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.208.1">
          EXCLUSIVE
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.209.1">
          YES
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.210.1">
          NO
         </span>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.211.1">
           std::shared_mutex
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.212.1">
         1 -
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.213.1">
          EXCLUSIVE
         </span>
        </span>
       </p>
       <p>
        <span class="koboSpan" id="kobo.214.1">
         N -
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.215.1">
          SHARED
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.216.1">
          NO
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.217.1">
          NO
         </span>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.218.1">
           std::timed_mutex
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.219.1">
          EXCLUSIVE
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.220.1">
          NO
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.221.1">
          YES
         </span>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.222.1">
           std::recursive_timed_mutex
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.223.1">
          EXCLUSIVE
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.224.1">
          YES
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.225.1">
          YES
         </span>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.226.1">
           std::shared_timed_mutex
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.227.1">
         1 -
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.228.1">
          EXCLUSIVE
         </span>
        </span>
       </p>
       <p>
        <span class="koboSpan" id="kobo.229.1">
         N -
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.230.1">
          SHARED
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.231.1">
          NO
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.232.1">
          YES
         </span>
        </span>
       </p>
      </td>
     </tr>
    </tbody>
   </table>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.233.1">
     Table 4.2: Mutex classes in C++ Standard Library
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.234.1">
     Let us
    </span>
    <a id="_idIndexMarker229">
    </a>
    <span class="koboSpan" id="kobo.235.1">
     explore these classes one
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.236.1">
      by one.
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.237.1">
     std::mutex
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.238.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.239.1">
      std::mutex
     </span>
    </strong>
    <span class="koboSpan" id="kobo.240.1">
     class was
    </span>
    <a id="_idIndexMarker230">
    </a>
    <span class="koboSpan" id="kobo.241.1">
     introduced
    </span>
    <a id="_idIndexMarker231">
    </a>
    <span class="koboSpan" id="kobo.242.1">
     in C++11 and is one of the most important and most frequently used synchronization primitives provided by the C++
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.243.1">
      Standard Library.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.244.1">
     As we have seen earlier in this chapter,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.245.1">
      std::mutex
     </span>
    </strong>
    <span class="koboSpan" id="kobo.246.1">
     is a synchronization primitive that can be used to protect shared data from being simultaneously accessed by
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.247.1">
      multiple threads.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.248.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.249.1">
      std::mutex
     </span>
    </strong>
    <span class="koboSpan" id="kobo.250.1">
     class offers exclusive, non-recursive
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.251.1">
      ownership semantics.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.252.1">
     The main features of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.253.1">
      std::mutex
     </span>
    </strong>
    <span class="koboSpan" id="kobo.254.1">
     are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.255.1">
      the following:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.256.1">
      A calling thread owns the mutex from the time it successfully calls
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.257.1">
       lock()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.258.1">
      or
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.259.1">
       try_lock()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.260.1">
      until it
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.261.1">
       calls
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.262.1">
        unlock()
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.263.1">
       .
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.264.1">
      A calling thread must not own the mutex before calling
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.265.1">
       lock()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.266.1">
      or
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.267.1">
       try_lock(
      </span>
     </strong>
     <span class="koboSpan" id="kobo.268.1">
      ).
     </span>
     <span class="koboSpan" id="kobo.268.2">
      This is the non-recursive ownership semantics property
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.269.1">
       of
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.270.1">
        std::mutex
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.271.1">
       .
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.272.1">
      When a thread owns a mutex, all other threads will block (when calling
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.273.1">
       lock())
      </span>
     </strong>
     <span class="koboSpan" id="kobo.274.1">
      or receive a
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.275.1">
       false
      </span>
     </strong>
     <span class="koboSpan" id="kobo.276.1">
      return value (when calling
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.277.1">
       try_lock()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.278.1">
      ).
     </span>
     <span class="koboSpan" id="kobo.278.2">
      This is the exclusive ownership semantics
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.279.1">
       of
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.280.1">
        std::mutex
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.281.1">
       .
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.282.1">
     If a thread owning a mutex tries to acquire it again, the resulting behavior is undefined.
    </span>
    <span class="koboSpan" id="kobo.282.2">
     Usually, an exception is thrown when this happens, but this
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.283.1">
      is implementation-defined.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.284.1">
     If, after a thread releases a mutex, it tries to release it again, this is also undefined behavior (as in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.285.1">
      previous case).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.286.1">
     A mutex being destroyed while a thread has it locked or a thread terminating without releasing the lock are also causes of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.287.1">
      undefined behavior.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.288.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.289.1">
      std::mutex
     </span>
    </strong>
    <span class="koboSpan" id="kobo.290.1">
     class has
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.291.1">
      three methods:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.292.1">
       lock()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.293.1">
      : Calling
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.294.1">
       lock()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.295.1">
      acquires the mutex.
     </span>
     <span class="koboSpan" id="kobo.295.2">
      If the mutex is already locked, then the calling thread is blocked until the mutex is unlocked.
     </span>
     <span class="koboSpan" id="kobo.295.3">
      From the application’s point of view, it is as if the calling thread waits for the mutex to
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.296.1">
       be available.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.297.1">
       try_lock()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.298.1">
      : When called, this function returns either
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.299.1">
       true
      </span>
     </strong>
     <span class="koboSpan" id="kobo.300.1">
      , indicating that the mutex has been successfully locked, or
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.301.1">
       false
      </span>
     </strong>
     <span class="koboSpan" id="kobo.302.1">
      in the event of the mutex being already locked.
     </span>
     <span class="koboSpan" id="kobo.302.2">
      Note that
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.303.1">
       try_lock
      </span>
     </strong>
     <span class="koboSpan" id="kobo.304.1">
      is non-blocking, and the calling thread either acquires the mutex or not, but it is not blocked like when calling
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.305.1">
       lock()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.306.1">
      .
     </span>
     <span class="koboSpan" id="kobo.306.2">
      The
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.307.1">
       try_lock()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.308.1">
      method is generally used when we don’t want the thread to wait until the mutex is available.
     </span>
     <span class="koboSpan" id="kobo.308.2">
      We will call
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.309.1">
       try_lock()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.310.1">
      when we want the thread
     </span>
     <a id="_idIndexMarker232">
     </a>
     <span class="koboSpan" id="kobo.311.1">
      to proceed with
     </span>
     <a id="_idIndexMarker233">
     </a>
     <span class="koboSpan" id="kobo.312.1">
      some processing and try to acquire the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.313.1">
       mutex later.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.314.1">
       unlock()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.315.1">
      : Calling
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.316.1">
       unlock()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.317.1">
      releases
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.318.1">
       the mutex.
      </span>
     </span>
    </li>
   </ul>
   <h3>
    <span class="koboSpan" id="kobo.319.1">
     std::recursive_mutex
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.320.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.321.1">
      std::mutex
     </span>
    </strong>
    <span class="koboSpan" id="kobo.322.1">
     class offers
    </span>
    <a id="_idIndexMarker234">
    </a>
    <span class="koboSpan" id="kobo.323.1">
     exclusive, non-recursive
    </span>
    <a id="_idIndexMarker235">
    </a>
    <span class="koboSpan" id="kobo.324.1">
     ownership semantics.
    </span>
    <span class="koboSpan" id="kobo.324.2">
     While exclusive ownership semantics are always required at least for a thread (it is a mutual exclusion mechanism, after all), in some instances, we may need to recursively acquire the mutex.
    </span>
    <span class="koboSpan" id="kobo.324.3">
     For example, a recursive function may need to acquire a mutex.
    </span>
    <span class="koboSpan" id="kobo.324.4">
     We may also need to acquire a mutex in function
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.325.1">
      g()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.326.1">
     called from another function
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.327.1">
      f()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.328.1">
     , which acquired the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.329.1">
      same mutex.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.330.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.331.1">
      std::recursive_mutex
     </span>
    </strong>
    <span class="koboSpan" id="kobo.332.1">
     class offers exclusive, recursive semantics.
    </span>
    <span class="koboSpan" id="kobo.332.2">
     Its main features are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.333.1">
      the following:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.334.1">
      A calling thread may acquire the same mutex more than once.
     </span>
     <span class="koboSpan" id="kobo.334.2">
      It will own the mutex until it releases the mutex the same number of times it acquired it.
     </span>
     <span class="koboSpan" id="kobo.334.3">
      For example, if a thread recursively acquires a mutex three times, it will own the mutex until it releases it for the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.335.1">
       third time.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.336.1">
      The maximum number of times a recursive mutex can be recursively acquired is unspecified and hence implementation-defined.
     </span>
     <span class="koboSpan" id="kobo.336.2">
      Once a mutex has been acquired for the maximum number of times, calls to
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.337.1">
       lock()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.338.1">
      will throw
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.339.1">
       std::system_error
      </span>
     </strong>
     <span class="koboSpan" id="kobo.340.1">
      , and calls to
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.341.1">
       try_lock()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.342.1">
      will
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.343.1">
       return
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.344.1">
        false
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.345.1">
       .
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.346.1">
      Ownership is the same as for
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.347.1">
       std::mutex
      </span>
     </strong>
     <span class="koboSpan" id="kobo.348.1">
      : if a thread owns a
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.349.1">
       std::recursive_mutex
      </span>
     </strong>
     <span class="koboSpan" id="kobo.350.1">
      class, any other threads will block if they try to acquire it by calling
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.351.1">
       lock()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.352.1">
      , or they will get false as a return when
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.353.1">
       calling
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.354.1">
        try_lock()
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.355.1">
       .
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.356.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.357.1">
      std::recursive_mutex
     </span>
    </strong>
    <span class="koboSpan" id="kobo.358.1">
     interface
    </span>
    <a id="_idIndexMarker236">
    </a>
    <span class="koboSpan" id="kobo.359.1">
     is exactly
    </span>
    <a id="_idIndexMarker237">
    </a>
    <span class="koboSpan" id="kobo.360.1">
     the same as
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.361.1">
      for
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.362.1">
       std::mutex
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.363.1">
      .
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.364.1">
     std::shared_mutex
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.365.1">
     Both
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.366.1">
      std::mutex
     </span>
    </strong>
    <span class="koboSpan" id="kobo.367.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.368.1">
      std::shared_mutex
     </span>
    </strong>
    <span class="koboSpan" id="kobo.369.1">
     have exclusive ownership semantics, and just one
    </span>
    <a id="_idIndexMarker238">
    </a>
    <span class="koboSpan" id="kobo.370.1">
     thread can be
    </span>
    <a id="_idIndexMarker239">
    </a>
    <span class="koboSpan" id="kobo.371.1">
     the mutex owner at any given time.
    </span>
    <span class="koboSpan" id="kobo.371.2">
     There are some cases, though, when we may need to let several threads simultaneously access the protected data and give just one thread
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.372.1">
      exclusive access.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.373.1">
     The counter example required exclusive access to a single variable for every thread because they were all updating
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.374.1">
      counter
     </span>
    </strong>
    <span class="koboSpan" id="kobo.375.1">
     values.
    </span>
    <span class="koboSpan" id="kobo.375.2">
     Now, if we have threads that only require reading the current value in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.376.1">
      counter
     </span>
    </strong>
    <span class="koboSpan" id="kobo.377.1">
     and just one thread to increment its value, it would be much better to let the reader threads access
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.378.1">
      counter
     </span>
    </strong>
    <span class="koboSpan" id="kobo.379.1">
     concurrently and give the writer
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.380.1">
      exclusive access.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.381.1">
     This functionality is implemented using what is called a Readers-Writer lock.
    </span>
    <span class="koboSpan" id="kobo.381.2">
     The C++ Standard Library implements the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.382.1">
      std::shared_mutex
     </span>
    </strong>
    <span class="koboSpan" id="kobo.383.1">
     class, with a similar (but not exactly the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.384.1">
      same) functionality.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.385.1">
     The main difference between
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.386.1">
      std::shared_mutex
     </span>
    </strong>
    <span class="koboSpan" id="kobo.387.1">
     and other mutex types is that it has two
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.388.1">
      access levels:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.389.1">
       Shared
      </span>
     </strong>
     <span class="koboSpan" id="kobo.390.1">
      : Several threads can share the ownership of the same mutex.
     </span>
     <span class="koboSpan" id="kobo.390.2">
      Shared ownership is acquired/released calling
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.391.1">
       lock_shared()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.392.1">
      ,
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.393.1">
       try_lock_shared()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.394.1">
      /
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.395.1">
       unlock shared()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.396.1">
      .
     </span>
     <span class="koboSpan" id="kobo.396.2">
      While at least one thread has acquired shared access to the lock, no other thread can get exclusive access to it, but it can acquire
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.397.1">
       shared access.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.398.1">
       Exclusive
      </span>
     </strong>
     <span class="koboSpan" id="kobo.399.1">
      : Only one thread can own the mutex.
     </span>
     <span class="koboSpan" id="kobo.399.2">
      Exclusive ownership is acquired/released by calling
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.400.1">
       lock()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.401.1">
      ,
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.402.1">
       try_lock()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.403.1">
      /
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.404.1">
       unlock()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.405.1">
      .
     </span>
     <span class="koboSpan" id="kobo.405.2">
      While a thread has acquired exclusive access to the lock, no other thread can acquire either shared or exclusive access
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.406.1">
       to it.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.407.1">
     Let’s see a
    </span>
    <a id="_idIndexMarker240">
    </a>
    <span class="koboSpan" id="kobo.408.1">
     simple example
    </span>
    <a id="_idIndexMarker241">
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.409.1">
      using
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.410.1">
       std::shared_mutex
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.411.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.412.1">
#include &lt;algorithm&gt;
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;shared_mutex&gt;
#include &lt;thread&gt;
int counter = 0;
int main() {
    using namespace std::chrono_literals;
    std::shared_mutex mutex;
    auto reader = [&amp;] {
        for (int i = 0; i &lt; 10; ++i) {
            mutex.lock_shared();
            // Read the counter and do something
            mutex.unlock_shared();
        }
    };
    auto writer = [&amp;] {
        for (int i = 0; i &lt; 10; ++i) {
            mutex.lock();
            ++counter;
            std::cout &lt;&lt; "Counter: " &lt;&lt; counter &lt;&lt; std::endl;
            mutex.unlock();
            std::this_thread::sleep_for(10ms);
        }
    };
    std::thread t1(reader);
    std::thread t2(reader);
    std::thread t3(writer);
    std::thread t4(reader);
    std::thread t5(reader);
    std::thread t6(writer);
    t1.join();
    t2.join();
    t3.join();
    t4.join();
    t5.join();
    t6.join();
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.413.1">
     The example uses
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.414.1">
      std::shared_mutex
     </span>
    </strong>
    <span class="koboSpan" id="kobo.415.1">
     to synchronize six threads: two threads are writers, and they increment the value of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.416.1">
      counter
     </span>
    </strong>
    <span class="koboSpan" id="kobo.417.1">
     and require exclusive access.
    </span>
    <span class="koboSpan" id="kobo.417.2">
     The remaining four threads just read
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.418.1">
      counter
     </span>
    </strong>
    <span class="koboSpan" id="kobo.419.1">
     and only require shared access.
    </span>
    <span class="koboSpan" id="kobo.419.2">
     Also, note that in order to
    </span>
    <a id="_idIndexMarker242">
    </a>
    <span class="koboSpan" id="kobo.420.1">
     use
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.421.1">
      std::shared_mutex
     </span>
    </strong>
    <span class="koboSpan" id="kobo.422.1">
     , we
    </span>
    <a id="_idIndexMarker243">
    </a>
    <span class="koboSpan" id="kobo.423.1">
     need to include the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.424.1">
      &lt;shared_mutex&gt;
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.425.1">
      header file.
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.426.1">
     Timed mutex types
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.427.1">
     The mutex types
    </span>
    <a id="_idIndexMarker244">
    </a>
    <span class="koboSpan" id="kobo.428.1">
     we have seen until now behave in the same way when we want to acquire the lock for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.429.1">
      exclusive use:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.430.1">
       std::lock()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.431.1">
      : The calling thread blocks until the lock
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.432.1">
       is available
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.433.1">
       std::try_lock()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.434.1">
      : Returns
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.435.1">
       false
      </span>
     </strong>
     <span class="koboSpan" id="kobo.436.1">
      if the lock is
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.437.1">
       not available
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.438.1">
     In the case of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.439.1">
      std::lock()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.440.1">
     , the calling thread may be waiting for a long time, and we may need to just wait for a certain period of time and then let the thread proceed with some processing if it has not been able to acquire
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.441.1">
      the lock.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.442.1">
     To achieve this goal, we can use the timed mutexes provided by the C++ Standard Library:
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.443.1">
      std::timed_mutex
     </span>
    </strong>
    <span class="koboSpan" id="kobo.444.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.445.1">
      std::recursive_timed_mutex
     </span>
    </strong>
    <span class="koboSpan" id="kobo.446.1">
     ,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.447.1">
      and
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.448.1">
       std::shared_time_mutex
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.449.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.450.1">
     They are similar to their non-timed counterparts and implement the following additional functions to allow waiting for the lock to be available for a specific period
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.451.1">
      of time:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.452.1">
       try_lock_for()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.453.1">
      : Tries to lock the mutex and blocks the thread until the specified time duration has elapsed (timed out).
     </span>
     <span class="koboSpan" id="kobo.453.2">
      If the mutex is locked before the specified time duration, then it returns
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.454.1">
       true
      </span>
     </strong>
     <span class="koboSpan" id="kobo.455.1">
      ; otherwise, it
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.456.1">
       returns
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.457.1">
        false
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.458.1">
       .
      </span>
     </span>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.459.1">
       If the specified time duration is less than or equal to zero (
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.460.1">
        timeout_duration.zero()
       </span>
      </strong>
      <span class="koboSpan" id="kobo.461.1">
       ), then the function behaves exactly
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.462.1">
        like
       </span>
      </span>
      <span class="No-Break">
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.463.1">
         try_lock()
        </span>
       </strong>
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.464.1">
        .
       </span>
      </span>
     </p>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.465.1">
       This function may block for longer than the specified duration due to scheduling or
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.466.1">
        contention delays.
       </span>
      </span>
     </p>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.467.1">
       try_lock_until()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.468.1">
      : Tries to lock the mutex until the specified timeout time or the mutex is locked, whichever comes first.
     </span>
     <span class="koboSpan" id="kobo.468.2">
      In this case, we specify an instance in the future as a limit for
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.469.1">
       the waiting.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.470.1">
     The following
    </span>
    <a id="_idIndexMarker245">
    </a>
    <span class="koboSpan" id="kobo.471.1">
     example shows how to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.472.1">
      use
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.473.1">
       std::try_lock_for()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.474.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.475.1">
#include &lt;algorithm&gt;
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;
constexpr int NUM_THREADS = 8;
int counter = 0;
int failed = 0;
int main() {
    using namespace std::chrono_literals;
    std::timed_mutex tm;
    std::mutex m;
    auto worker = [&amp;] {
        for (int i = 0; i &lt; 10; ++i) {
            if (tm.try_lock_for(10ms)) {
                ++counter;
                std::cout &lt;&lt; "Counter: " &lt;&lt; counter &lt;&lt; std::endl;
                std::this_thread::sleep_for(10ms);
                m.unlock();
            }
            else {
                m.lock();
                ++failed;
                std::cout &lt;&lt; "Thread " &lt;&lt; std::this_thread::get_id() &lt;&lt; " failed to lock" &lt;&lt; std::endl;
                m.unlock();
            }
            std::this_thread::sleep_for(12ms);
        }
    };
    std::vector&lt;std::thread&gt; threads;
    for (int i = 0; i &lt; NUM_THREADS; ++i) {
        threads.emplace_back(worker);
    }
    for (auto&amp; t : threads) {
        t.join();
    }
    std::cout &lt;&lt; "Counter: " &lt;&lt; counter &lt;&lt; std::endl;
    std::cout &lt;&lt; "Failed: " &lt;&lt; failed &lt;&lt; std::endl;
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.476.1">
     The preceding code uses two locks:
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.477.1">
      tm
     </span>
    </strong>
    <span class="koboSpan" id="kobo.478.1">
     , a timed mutex, to synchronize access to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.479.1">
      counter
     </span>
    </strong>
    <span class="koboSpan" id="kobo.480.1">
     and writing to the screen if acquiring
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.481.1">
      tm
     </span>
    </strong>
    <span class="koboSpan" id="kobo.482.1">
     is successful, and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.483.1">
      m
     </span>
    </strong>
    <span class="koboSpan" id="kobo.484.1">
     , a non-timed mutex, to synchronize
    </span>
    <a id="_idIndexMarker246">
    </a>
    <span class="koboSpan" id="kobo.485.1">
     access to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.486.1">
      failed
     </span>
    </strong>
    <span class="koboSpan" id="kobo.487.1">
     and writing to the screen if acquiring
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.488.1">
      tm
     </span>
    </strong>
    <span class="koboSpan" id="kobo.489.1">
     is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.490.1">
      not successful.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-81">
    <a id="_idTextAnchor080">
    </a>
    <span class="koboSpan" id="kobo.491.1">
     Problems when using locks
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.492.1">
     We have seen examples
    </span>
    <a id="_idIndexMarker247">
    </a>
    <span class="koboSpan" id="kobo.493.1">
     using just a mutex (lock).
    </span>
    <span class="koboSpan" id="kobo.493.2">
     If we only need one mutex and we acquire and release it properly, in general is not very difficult to write correct multithreaded code.
    </span>
    <span class="koboSpan" id="kobo.493.3">
     Once we need more than one lock, the code complexity increases.
    </span>
    <span class="koboSpan" id="kobo.493.4">
     Two common problems when using multiple locks are
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.494.1">
      deadlock
     </span>
    </em>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.495.1">
      and
     </span>
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.496.1">
       livelock
      </span>
     </em>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.497.1">
      .
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.498.1">
     Deadlock
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.499.1">
     Let’s consider the
    </span>
    <a id="_idIndexMarker248">
    </a>
    <span class="koboSpan" id="kobo.500.1">
     following scenario: to perform a certain task, a thread
    </span>
    <a id="_idIndexMarker249">
    </a>
    <span class="koboSpan" id="kobo.501.1">
     needs to access two resources, and they cannot be accessed simultaneously by two or more threads (we need mutual exclusion to properly synchronize access to the required resources).
    </span>
    <span class="koboSpan" id="kobo.501.2">
     Each resource is synchronized with a different
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.502.1">
      std::mutex
     </span>
    </strong>
    <span class="koboSpan" id="kobo.503.1">
     class.
    </span>
    <span class="koboSpan" id="kobo.503.2">
     In this case, a thread must acquire the first resource mutex then acquire the second resource mutex, and finally process the resources and release
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.504.1">
      both mutexes.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.505.1">
     When two threads try performing the aforementioned processing, something like this
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.506.1">
      may happen:
     </span>
    </span>
   </p>
   <p>
    <em class="italic">
     <span class="koboSpan" id="kobo.507.1">
      Thread 1
     </span>
    </em>
    <span class="koboSpan" id="kobo.508.1">
     and
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.509.1">
      thread 2
     </span>
    </em>
    <span class="koboSpan" id="kobo.510.1">
     need to acquire two mutexes to perform the required processing.
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.511.1">
      Thread 1
     </span>
    </em>
    <span class="koboSpan" id="kobo.512.1">
     acquires the first mutex and
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.513.1">
      thread 2
     </span>
    </em>
    <span class="koboSpan" id="kobo.514.1">
     acquires the second mutex.
    </span>
    <span class="koboSpan" id="kobo.514.2">
     Then,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.515.1">
      thread 1
     </span>
    </em>
    <span class="koboSpan" id="kobo.516.1">
     will be blocked forever waiting for the second mutex to be available, and
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.517.1">
      thread 2
     </span>
    </em>
    <span class="koboSpan" id="kobo.518.1">
     will be blocked forever waiting for the first mutex to be available.
    </span>
    <span class="koboSpan" id="kobo.518.2">
     This is called a
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.519.1">
      deadlock
     </span>
    </strong>
    <span class="koboSpan" id="kobo.520.1">
     because both threads will be blocked forever waiting for each other to release the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.521.1">
      required mutex.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.522.1">
     This is one of the most common issues in multithreaded code.
    </span>
    <span class="koboSpan" id="kobo.522.2">
     In
    </span>
    <a href="B22219_11.xhtml#_idTextAnchor228">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.523.1">
        Chapter 11
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.524.1">
     , about debugging, we will
    </span>
    <a id="_idIndexMarker250">
    </a>
    <span class="koboSpan" id="kobo.525.1">
     learn how to spot this problem by inspecting the running (deadlocked) program
    </span>
    <a id="_idIndexMarker251">
    </a>
    <span class="koboSpan" id="kobo.526.1">
     with
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.527.1">
      a debugger.
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.528.1">
     Livelock
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.529.1">
     A possible solution for
    </span>
    <a id="_idIndexMarker252">
    </a>
    <span class="koboSpan" id="kobo.530.1">
     deadlock could be the following: when
    </span>
    <a id="_idIndexMarker253">
    </a>
    <span class="koboSpan" id="kobo.531.1">
     a thread tries to acquire the lock, it will block just for a limited time, and if still unsuccessful, it will release any lock it may
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.532.1">
      have acquired.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.533.1">
     For example,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.534.1">
      thread 1
     </span>
    </em>
    <span class="koboSpan" id="kobo.535.1">
     acquires the first lock and
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.536.1">
      thread 2
     </span>
    </em>
    <span class="koboSpan" id="kobo.537.1">
     acquires the second lock.
    </span>
    <span class="koboSpan" id="kobo.537.2">
     After a certain time,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.538.1">
      thread 1
     </span>
    </em>
    <span class="koboSpan" id="kobo.539.1">
     still has not acquired the second lock, so it releases the first one.
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.540.1">
      Thread 2
     </span>
    </em>
    <span class="koboSpan" id="kobo.541.1">
     may finish waiting too and release the lock it acquired (in this example, the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.542.1">
      second lock).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.543.1">
     This solution may work sometimes, but it is not right.
    </span>
    <span class="koboSpan" id="kobo.543.2">
     Imagine this scenario:
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.544.1">
      Thread 1
     </span>
    </em>
    <span class="koboSpan" id="kobo.545.1">
     has acquired the first lock and has acquired the second lock.
    </span>
    <span class="koboSpan" id="kobo.545.2">
     After some time, both threads release their already acquired locks, and then they acquire the same locks again.
    </span>
    <span class="koboSpan" id="kobo.545.3">
     Then, the threads release the locks, then acquire them again, and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.546.1">
      so on.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.547.1">
     The threads are unable to do anything but acquire a lock, wait, release the lock, and do the same again.
    </span>
    <span class="koboSpan" id="kobo.547.2">
     This situation is called
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.548.1">
      livelock
     </span>
    </strong>
    <span class="koboSpan" id="kobo.549.1">
     because the threads are not just waiting forever (as in the deadlock case), but they are kind of alive and acquire and release a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.550.1">
      lock continuously.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.551.1">
     The most common solution for both deadlock and livelock situations is acquiring the locks in a consistent order.
    </span>
    <span class="koboSpan" id="kobo.551.2">
     For example, if a thread needs to acquire two locks, it will always acquire the first lock first, and then it will acquire the second lock.
    </span>
    <span class="koboSpan" id="kobo.551.3">
     The locks will be released in the opposite order (first releasing the second lock and then the first).
    </span>
    <span class="koboSpan" id="kobo.551.4">
     If a second thread tries to acquire the first lock, it will have to wait until the first thread releases both locks, and deadlock will
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.552.1">
      never happen.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.553.1">
     In this section, we have seen the mutex classes provided by the C++ Standard Library.
    </span>
    <span class="koboSpan" id="kobo.553.2">
     We have studied their main features and the issues we may experience when using more than one lock.
    </span>
    <span class="koboSpan" id="kobo.553.3">
     In the next section, we will see the mechanisms that the C++ Standard Library
    </span>
    <a id="_idIndexMarker254">
    </a>
    <span class="koboSpan" id="kobo.554.1">
     provides to make acquiring and releasing
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.555.1">
      mutexes.
     </span>
    </span>
    <span class="No-Break">
     <a id="_idIndexMarker255">
     </a>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.556.1">
      easier.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-82">
    <a id="_idTextAnchor081">
    </a>
    <span class="koboSpan" id="kobo.557.1">
     Generic lock management
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.558.1">
     In the previous
    </span>
    <a id="_idIndexMarker256">
    </a>
    <span class="koboSpan" id="kobo.559.1">
     section, we saw the different types of mutexes provided by the C++ Standard Library.
    </span>
    <span class="koboSpan" id="kobo.559.2">
     In this section, we will see the provided classes to make the use of mutexes easier.
    </span>
    <span class="koboSpan" id="kobo.559.3">
     This is done by using different wrapper classes.
    </span>
    <span class="koboSpan" id="kobo.559.4">
     The following table summarizes the lock management classes and their
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.560.1">
      main features:
     </span>
    </span>
   </p>
   <table class="No-Table-Style _idGenTablePara-1" id="table003">
    <colgroup>
     <col/>
     <col/>
     <col/>
    </colgroup>
    <thead>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <strong class="bold">
         <span class="koboSpan" id="kobo.561.1">
          Mutex
         </span>
        </strong>
        <span class="No-Break">
         <strong class="bold">
          <span class="koboSpan" id="kobo.562.1">
           Manager Class
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <strong class="bold">
         <span class="koboSpan" id="kobo.563.1">
          Supported
         </span>
        </strong>
        <span class="No-Break">
         <strong class="bold">
          <span class="koboSpan" id="kobo.564.1">
           Mutex Types
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="bold">
          <span class="koboSpan" id="kobo.565.1">
           Mutexes Managed
          </span>
         </strong>
        </span>
       </p>
      </td>
     </tr>
    </thead>
    <tbody>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.566.1">
           std::lock_guard
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.567.1">
          All
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.568.1">
         1
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.569.1">
           std::scoped_lock
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.570.1">
          All
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.571.1">
         Zero
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.572.1">
          or more
         </span>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.573.1">
           std::unique_lock
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.574.1">
          All
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.575.1">
         1
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.576.1">
           std::shared_lock
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.577.1">
           std::shared_mutex
          </span>
         </strong>
        </span>
       </p>
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.578.1">
           std::shared_timed_mutex
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.579.1">
         1
        </span>
       </p>
      </td>
     </tr>
    </tbody>
   </table>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.580.1">
     Table 4.3: Lock management classes and their features
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.581.1">
     Let’s see each of the mutex management classes and their
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.582.1">
      main features.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-83">
    <a id="_idTextAnchor082">
    </a>
    <span class="koboSpan" id="kobo.583.1">
     std::lock_guard
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.584.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.585.1">
      std::lock_guard
     </span>
    </strong>
    <span class="koboSpan" id="kobo.586.1">
     class is
    </span>
    <a id="_idIndexMarker257">
    </a>
    <span class="koboSpan" id="kobo.587.1">
     a
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.588.1">
      Resource Acquisition Is Initialization
     </span>
    </strong>
    <span class="koboSpan" id="kobo.589.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.590.1">
      RAII
     </span>
    </strong>
    <span class="koboSpan" id="kobo.591.1">
     ) class
    </span>
    <a id="_idIndexMarker258">
    </a>
    <span class="koboSpan" id="kobo.592.1">
     that
    </span>
    <a id="_idIndexMarker259">
    </a>
    <span class="koboSpan" id="kobo.593.1">
     makes it easier to use mutexes and guarantees that a mutex will be released when the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.594.1">
      lock_guard
     </span>
    </strong>
    <span class="koboSpan" id="kobo.595.1">
     destructor is called.
    </span>
    <span class="koboSpan" id="kobo.595.2">
     This is very useful, for example, when dealing
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.596.1">
      with exceptions.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.597.1">
     The following code shows the use of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.598.1">
      std::lock_guard
     </span>
    </strong>
    <span class="koboSpan" id="kobo.599.1">
     and how it makes handling exceptions easier
    </span>
    <a id="_idIndexMarker260">
    </a>
    <span class="koboSpan" id="kobo.600.1">
     when a lock is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.601.1">
      already
     </span>
    </span>
    <span class="No-Break">
     <a id="_idIndexMarker261">
     </a>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.602.1">
      acquired:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.603.1">
#include &lt;format&gt;
#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;
std::mutex mtx;
uint32_t counter{};
void function_throws() { throw std::runtime_error("Error"); }
int main() {
    auto worker = [] {
        for (int i = 0; i &lt; 1000000; ++i) {
            mtx.lock();
            counter++;
            mtx.unlock();
        }
    };
    auto worker_exceptions = [] {
        for (int i = 0; i &lt; 1000000; ++i) {
            try {
                std::lock_guard&lt;std::mutex&gt; lock(mtx);
                counter++;
                function_throws();
            } catch (std::system_error&amp; e) {
                std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
                return;
            } catch (...) {
                return;
            }
        }
    };
    std::thread t1(worker_exceptions);
    std::thread t2(worker);
    t1.join();
    t2.join();
    std::cout &lt;&lt; "Final counter value: " &lt;&lt; counter &lt;&lt; std::endl;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.604.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.605.1">
      function_throws()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.606.1">
     function is just a utility function that will throw
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.607.1">
      an exception.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.608.1">
     In the previous code
    </span>
    <a id="_idIndexMarker262">
    </a>
    <span class="koboSpan" id="kobo.609.1">
     example, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.610.1">
      worker_exceptions()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.611.1">
     function is
    </span>
    <a id="_idIndexMarker263">
    </a>
    <span class="koboSpan" id="kobo.612.1">
     executed by
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.613.1">
      t1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.614.1">
     .
    </span>
    <span class="koboSpan" id="kobo.614.2">
     In this case, the exception is handled to print meaningful messages.
    </span>
    <span class="koboSpan" id="kobo.614.3">
     The lock is not explicitly acquired/released.
    </span>
    <span class="koboSpan" id="kobo.614.4">
     This is delegated to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.615.1">
      lock
     </span>
    </strong>
    <span class="koboSpan" id="kobo.616.1">
     , a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.617.1">
      std::lock_guard
     </span>
    </strong>
    <span class="koboSpan" id="kobo.618.1">
     object.
    </span>
    <span class="koboSpan" id="kobo.618.2">
     When the lock is constructed, it wraps the mutex and calls
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.619.1">
      mtx.lock()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.620.1">
     , acquiring the lock.
    </span>
    <span class="koboSpan" id="kobo.620.2">
     When
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.621.1">
      lock
     </span>
    </strong>
    <span class="koboSpan" id="kobo.622.1">
     is destroyed, the mutex is released automatically.
    </span>
    <span class="koboSpan" id="kobo.622.2">
     In the event of an exception, the mutex will also be released because the scope where
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.623.1">
      lock
     </span>
    </strong>
    <span class="koboSpan" id="kobo.624.1">
     was defined
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.625.1">
      is exited.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.626.1">
     There is another constructor implemented for
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.627.1">
      std::lock_guard
     </span>
    </strong>
    <span class="koboSpan" id="kobo.628.1">
     , receiving a parameter of type
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.629.1">
      std::adopt_lock_t
     </span>
    </strong>
    <span class="koboSpan" id="kobo.630.1">
     .
    </span>
    <span class="koboSpan" id="kobo.630.2">
     Basically, this constructor makes it possible to wrap an already acquired
    </span>
    <a id="_idIndexMarker264">
    </a>
    <span class="koboSpan" id="kobo.631.1">
     non-shared mutex, which will be
    </span>
    <a id="_idIndexMarker265">
    </a>
    <span class="koboSpan" id="kobo.632.1">
     released automatically in the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.633.1">
       std::lock_guard
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.634.1">
      destructor.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-84">
    <a id="_idTextAnchor083">
    </a>
    <span class="koboSpan" id="kobo.635.1">
     std::unique_lock
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.636.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.637.1">
      std::lock_guard
     </span>
    </strong>
    <span class="koboSpan" id="kobo.638.1">
     class is
    </span>
    <a id="_idIndexMarker266">
    </a>
    <span class="koboSpan" id="kobo.639.1">
     just a simple
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.640.1">
      std::mutex
     </span>
    </strong>
    <span class="koboSpan" id="kobo.641.1">
     wrapper
    </span>
    <a id="_idIndexMarker267">
    </a>
    <span class="koboSpan" id="kobo.642.1">
     that automatically acquires the mutex in its constructor (the thread will be blocked, waiting until the mutex is released by another thread) and releases the mutex in its destructor.
    </span>
    <span class="koboSpan" id="kobo.642.2">
     This is very useful, but sometimes we need more control.
    </span>
    <span class="koboSpan" id="kobo.642.3">
     For example,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.643.1">
      std::lock_guard
     </span>
    </strong>
    <span class="koboSpan" id="kobo.644.1">
     will either call
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.645.1">
      lock()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.646.1">
     on the mutex or assume the mutex is already acquired.
    </span>
    <span class="koboSpan" id="kobo.646.2">
     We may prefer or really need to call
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.647.1">
      try_lock
     </span>
    </strong>
    <span class="koboSpan" id="kobo.648.1">
     .
    </span>
    <span class="koboSpan" id="kobo.648.2">
     We also may want the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.649.1">
      std::mutex
     </span>
    </strong>
    <span class="koboSpan" id="kobo.650.1">
     wrapper not to acquire the lock in its constructor; that is, we may want to defer the locking until a later moment.
    </span>
    <span class="koboSpan" id="kobo.650.2">
     All this functionality is implemented
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.651.1">
      by
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.652.1">
       std::unique_lock
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.653.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.654.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.655.1">
      std::unique_lock
     </span>
    </strong>
    <span class="koboSpan" id="kobo.656.1">
     constructor accepts a tag as its second parameter to indicate what we want to do with the underlying mutex.
    </span>
    <span class="koboSpan" id="kobo.656.2">
     There are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.657.1">
      three options:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.658.1">
       std::defer_lock
      </span>
     </strong>
     <span class="koboSpan" id="kobo.659.1">
      : Does not acquire ownership of the mutex.
     </span>
     <span class="koboSpan" id="kobo.659.2">
      The mutex is not locked in the constructor, and it will not be unlocked in the destructor if it is
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.660.1">
       never acquired.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.661.1">
       std::adopt_lock
      </span>
     </strong>
     <span class="koboSpan" id="kobo.662.1">
      : Assumes that the mutex has been acquired by the calling thread.
     </span>
     <span class="koboSpan" id="kobo.662.2">
      It will be released in the destructor.
     </span>
     <span class="koboSpan" id="kobo.662.3">
      This option is also available
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.663.1">
       for
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.664.1">
        std::lock_guard
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.665.1">
       .
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.666.1">
       std::try_to_lock
      </span>
     </strong>
     <span class="koboSpan" id="kobo.667.1">
      : Try to acquire the mutex
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.668.1">
       without blocking.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.669.1">
     If we just pass the mutex as the only parameter to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.670.1">
      std::unique_lock
     </span>
    </strong>
    <span class="koboSpan" id="kobo.671.1">
     constructor, the behavior is the same as in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.672.1">
      std::lock_guard
     </span>
    </strong>
    <span class="koboSpan" id="kobo.673.1">
     : it will block until the mutex is available and then acquire it.
    </span>
    <span class="koboSpan" id="kobo.673.2">
     It will release the mutex in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.674.1">
      the destructor.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.675.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.676.1">
      std::unique_lock
     </span>
    </strong>
    <span class="koboSpan" id="kobo.677.1">
     class, unlike
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.678.1">
      std::lock_guard
     </span>
    </strong>
    <span class="koboSpan" id="kobo.679.1">
     , allows you to call
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.680.1">
      lock()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.681.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.682.1">
      unlock()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.683.1">
     to respectively acquire and release
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.684.1">
      the mutex.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-85">
    <a id="_idTextAnchor084">
    </a>
    <span class="koboSpan" id="kobo.685.1">
     std::scoped_lock
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.686.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.687.1">
      std::scoped_lock
     </span>
    </strong>
    <span class="koboSpan" id="kobo.688.1">
     class, as with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.689.1">
      std::unique_lock
     </span>
    </strong>
    <span class="koboSpan" id="kobo.690.1">
     , is a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.691.1">
      std::mutex
     </span>
    </strong>
    <span class="koboSpan" id="kobo.692.1">
     wrapper
    </span>
    <a id="_idIndexMarker268">
    </a>
    <span class="koboSpan" id="kobo.693.1">
     implementing
    </span>
    <a id="_idIndexMarker269">
    </a>
    <span class="koboSpan" id="kobo.694.1">
     an RAII mechanism (remember – the mutexes will be released in the destructor if they are acquired).
    </span>
    <span class="koboSpan" id="kobo.694.2">
     The main difference is that
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.695.1">
      std::unique_lock
     </span>
    </strong>
    <span class="koboSpan" id="kobo.696.1">
     , as its name implies, just wraps one mutex, but
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.697.1">
      std::scoped_lock
     </span>
    </strong>
    <span class="koboSpan" id="kobo.698.1">
     wraps zero or more mutexes.
    </span>
    <span class="koboSpan" id="kobo.698.2">
     Also, the mutexes are acquired in the order they are passed to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.699.1">
      std::scoped_lock
     </span>
    </strong>
    <span class="koboSpan" id="kobo.700.1">
     constructor, hence
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.701.1">
      avoiding deadlock.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.702.1">
     Let’s look at the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.703.1">
      following code:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.704.1">
std::mutex mtx1;
std::mutex mtx2;
// Acquire both mutexes avoiding deadlock
std::scoped_lock lock(mtx1, mtx2);
// Same as doing this
// std::lock(mtx1, mtx2);
// std::lock_guard&lt;std::mutex&gt; lock1(mtx1, std::adopt_lock);
// std::lock_guard&lt;std::mutex&gt; lock2(mtx2, std::adopt_lock);</span></pre>
   <p>
    <span class="koboSpan" id="kobo.705.1">
     The preceding code snippet shows how we can work with two mutex locks
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.706.1">
      very easily.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-86">
    <a id="_idTextAnchor085">
    </a>
    <span class="koboSpan" id="kobo.707.1">
     std::shared_lock
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.708.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.709.1">
      std::shared_lock
     </span>
    </strong>
    <span class="koboSpan" id="kobo.710.1">
     class is
    </span>
    <a id="_idIndexMarker270">
    </a>
    <span class="koboSpan" id="kobo.711.1">
     another
    </span>
    <a id="_idIndexMarker271">
    </a>
    <span class="koboSpan" id="kobo.712.1">
     general-purpose mutex ownership wrapper.
    </span>
    <span class="koboSpan" id="kobo.712.2">
     As with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.713.1">
      std::unique_lock
     </span>
    </strong>
    <span class="koboSpan" id="kobo.714.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.715.1">
      std::scoped_lock
     </span>
    </strong>
    <span class="koboSpan" id="kobo.716.1">
     , it allows deferred locking and transferring the lock ownership.
    </span>
    <span class="koboSpan" id="kobo.716.2">
     The main difference between
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.717.1">
      std::unique_lock
     </span>
    </strong>
    <span class="koboSpan" id="kobo.718.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.719.1">
      std::shared_lock
     </span>
    </strong>
    <span class="koboSpan" id="kobo.720.1">
     is that the latter is used to acquire/release the wrapped mutex in shared mode while the former is used to do the same in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.721.1">
      exclusive mode.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.722.1">
     In this section, we saw mutex wrapper classes and their main features.
    </span>
    <span class="koboSpan" id="kobo.722.2">
     Next, we will introduce another
    </span>
    <a id="_idIndexMarker272">
    </a>
    <span class="koboSpan" id="kobo.723.1">
     synchronization
    </span>
    <a id="_idIndexMarker273">
    </a>
    <span class="koboSpan" id="kobo.724.1">
     mechanism:
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.725.1">
      condition variables.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-87">
    <a id="_idTextAnchor086">
    </a>
    <span class="koboSpan" id="kobo.726.1">
     Condition variables
    </span>
   </h1>
   <p>
    <strong class="bold">
     <span class="koboSpan" id="kobo.727.1">
      Condition variables
     </span>
    </strong>
    <span class="koboSpan" id="kobo.728.1">
     are
    </span>
    <a id="_idIndexMarker274">
    </a>
    <span class="koboSpan" id="kobo.729.1">
     another synchronization primitive provided by the C++ Standard Library.
    </span>
    <span class="koboSpan" id="kobo.729.2">
     They allow multiple threads to communicate with each other.
    </span>
    <span class="koboSpan" id="kobo.729.3">
     They also allow for several threads to wait for a notification from another thread.
    </span>
    <span class="koboSpan" id="kobo.729.4">
     Condition variables are always associated with
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.730.1">
      a mutex.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.731.1">
     In the following example, a thread must wait for a counter to be equal to a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.732.1">
      certain value:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.733.1">
#include &lt;chrono&gt;
#include &lt;condition_variable&gt;
#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;
int counter = 0;
int main() {
    using namespace std::chrono_literals;
    std::mutex mtx;
    std::mutex cout_mtx;
    std::condition_variable cv;
    auto increment_counter = [&amp;] {
        for (int i = 0; i &lt; 20; ++i) {
            std::this_thread::sleep_for(100ms);
            mtx.lock();
            ++counter;
            mtx.unlock();
            cv.notify_one();
        }
    };
    auto wait_for_counter_non_zero_mtx = [&amp;] {
        mtx.lock();
        while (counter == 0) {
            mtx.unlock();
            std::this_thread::sleep_for(10ms);
            mtx.lock();
        }
        mtx.unlock();
        std::lock_guard&lt;std::mutex&gt; cout_lck(cout_mtx);
        std::cout &lt;&lt; "Counter is non-zero" &lt;&lt; std::endl;
    };
    auto wait_for_counter_10_cv = [&amp;] {
        std::unique_lock&lt;std::mutex&gt; lck(mtx);
        cv.wait(lck, [] { return counter == 10; });
        std::lock_guard&lt;std::mutex&gt; cout_lck(cout_mtx);
        std::cout &lt;&lt; "Counter is: " &lt;&lt; counter &lt;&lt; std::endl;
    };
    std::thread t1(wait_for_counter_non_zero_mtx);
    std::thread t2(wait_for_counter_10_cv);
    std::thread t3(increment_counter);
    t1.join();
    t2.join();
    t3.join();
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.734.1">
     There are two ways to wait for a certain condition: one is waiting in a loop and using a mutex as a synchronization mechanism.
    </span>
    <span class="koboSpan" id="kobo.734.2">
     This is implemented in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.735.1">
      wait_for_counter_non_zero_mtx
     </span>
    </strong>
    <span class="koboSpan" id="kobo.736.1">
     .
    </span>
    <span class="koboSpan" id="kobo.736.2">
     The function acquires the lock, reads the value in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.737.1">
      counter
     </span>
    </strong>
    <span class="koboSpan" id="kobo.738.1">
     , and releases the lock.
    </span>
    <span class="koboSpan" id="kobo.738.2">
     Then, it sleeps for 10 milliseconds, and the lock is acquired again.
    </span>
    <span class="koboSpan" id="kobo.738.3">
     This is done in a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.739.1">
      while
     </span>
    </strong>
    <span class="koboSpan" id="kobo.740.1">
     loop until
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.741.1">
      counter
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.742.1">
      is nonzero.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.743.1">
     Condition variables
    </span>
    <a id="_idIndexMarker275">
    </a>
    <span class="koboSpan" id="kobo.744.1">
     help us to simplify the previous code.
    </span>
    <span class="koboSpan" id="kobo.744.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.745.1">
      wait_for_counter_10_cv
     </span>
    </strong>
    <span class="koboSpan" id="kobo.746.1">
     function waits until
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.747.1">
      counter
     </span>
    </strong>
    <span class="koboSpan" id="kobo.748.1">
     is equal to 10.
    </span>
    <span class="koboSpan" id="kobo.748.2">
     The thread will wait on the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.749.1">
      cv
     </span>
    </strong>
    <span class="koboSpan" id="kobo.750.1">
     condition variable until it is notified by
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.751.1">
      t1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.752.1">
     , the thread increasing
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.753.1">
      counter
     </span>
    </strong>
    <span class="koboSpan" id="kobo.754.1">
     in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.755.1">
      a loop.
     </span>
    </span>
   </p>
   <p>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.756.1">
      The wait_for_counter_10_cv
     </span>
    </strong>
    <span class="koboSpan" id="kobo.757.1">
     function works like this: a condition variable,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.758.1">
      cv
     </span>
    </strong>
    <span class="koboSpan" id="kobo.759.1">
     , waits on a mutex,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.760.1">
      mtx
     </span>
    </strong>
    <span class="koboSpan" id="kobo.761.1">
     .
    </span>
    <span class="koboSpan" id="kobo.761.2">
     After calling
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.762.1">
      wait()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.763.1">
     , the condition variable locks the mutex and waits until the condition is
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.764.1">
      true
     </span>
    </strong>
    <span class="koboSpan" id="kobo.765.1">
     (the condition is implemented in the lambda passed as a second parameter to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.766.1">
      wait
     </span>
    </strong>
    <span class="koboSpan" id="kobo.767.1">
     function).
    </span>
    <span class="koboSpan" id="kobo.767.2">
     If the condition is not
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.768.1">
      true
     </span>
    </strong>
    <span class="koboSpan" id="kobo.769.1">
     , the condition variable remains in a
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.770.1">
      waiting
     </span>
    </em>
    <span class="koboSpan" id="kobo.771.1">
     state until it is signaled and releases the mutex.
    </span>
    <span class="koboSpan" id="kobo.771.2">
     Once the condition is met, the condition variable ends its waiting state and locks the mutex again to synchronize its access
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.772.1">
      to
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.773.1">
       counter
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.774.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.775.1">
     One important issue is that the conditional variable may be signaled by an unrelated thread.
    </span>
    <span class="koboSpan" id="kobo.775.2">
     This is
    </span>
    <a id="_idIndexMarker276">
    </a>
    <span class="koboSpan" id="kobo.776.1">
     called
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.777.1">
      spurious wakeup
     </span>
    </strong>
    <span class="koboSpan" id="kobo.778.1">
     .
    </span>
    <span class="koboSpan" id="kobo.778.2">
     To avoid errors due to spurious wakeups, the condition is checked in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.779.1">
      wait
     </span>
    </strong>
    <span class="koboSpan" id="kobo.780.1">
     .
    </span>
    <span class="koboSpan" id="kobo.780.2">
     When the condition variable is signaled, the condition is checked again.
    </span>
    <span class="koboSpan" id="kobo.780.3">
     In the event of a spurious wakeup and the counter being zero (the condition check returns
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.781.1">
      false
     </span>
    </strong>
    <span class="koboSpan" id="kobo.782.1">
     ), the waiting
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.783.1">
      would resume.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.784.1">
     A different thread increments the counter by running
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.785.1">
      increment_counter
     </span>
    </strong>
    <span class="koboSpan" id="kobo.786.1">
     .
    </span>
    <span class="koboSpan" id="kobo.786.2">
     Once
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.787.1">
      counter
     </span>
    </strong>
    <span class="koboSpan" id="kobo.788.1">
     has the desired value (in the example, this value is 10), it signals the waiting thread
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.789.1">
      condition variable.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.790.1">
     There are two functions provided to signal a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.791.1">
      condition variable:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.792.1">
       cv.notify_one()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.793.1">
      : Signal only one of the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.794.1">
       waiting threads
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.795.1">
       cv.notify_all()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.796.1">
      : Signal all of the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.797.1">
       waiting threads
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.798.1">
     In this section, we have introduced condition variables, and we have seen a simple example of synchronization using condition variables and how in some cases it can simplify the
    </span>
    <a id="_idIndexMarker277">
    </a>
    <span class="koboSpan" id="kobo.799.1">
     synchronization/waiting code.
    </span>
    <span class="koboSpan" id="kobo.799.2">
     Now, let us turn our attention to implementing a synchronized queue using a mutex and two
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.800.1">
      condition variables.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-88">
    <a id="_idTextAnchor087">
    </a>
    <span class="koboSpan" id="kobo.801.1">
     Implementing a multithreaded safe queue
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.802.1">
     In this section, we will see how to implement a
    </span>
    <a id="_idIndexMarker278">
    </a>
    <span class="koboSpan" id="kobo.803.1">
     simple
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.804.1">
      multithreaded safe queue
     </span>
    </strong>
    <span class="koboSpan" id="kobo.805.1">
     .
    </span>
    <span class="koboSpan" id="kobo.805.2">
     The queue will be accessed by multiple threads, some of them adding elements to
    </span>
    <a id="_idIndexMarker279">
    </a>
    <span class="koboSpan" id="kobo.806.1">
     it (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.807.1">
      producer threads
     </span>
    </strong>
    <span class="koboSpan" id="kobo.808.1">
     ) and some of them removing elements
    </span>
    <a id="_idIndexMarker280">
    </a>
    <span class="koboSpan" id="kobo.809.1">
     from it (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.810.1">
      consumer threads
     </span>
    </strong>
    <span class="koboSpan" id="kobo.811.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.811.2">
     For starters, we are going to assume just two threads: one producer and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.812.1">
      one consumer.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.813.1">
     Queues or
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.814.1">
      first-in-first-outs
     </span>
    </strong>
    <span class="koboSpan" id="kobo.815.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.816.1">
      FIFOs
     </span>
    </strong>
    <span class="koboSpan" id="kobo.817.1">
     ) are
    </span>
    <a id="_idIndexMarker281">
    </a>
    <span class="koboSpan" id="kobo.818.1">
     a standard way of communication between threads.
    </span>
    <span class="koboSpan" id="kobo.818.2">
     For example, if we need to receive packets containing data from a network connection as fast as possible, we may not have enough time in just one thread to receive all the packets and process them.
    </span>
    <span class="koboSpan" id="kobo.818.3">
     In this case, we use a second thread to process the packets read by the first thread.
    </span>
    <span class="koboSpan" id="kobo.818.4">
     Using just one consumer thread is simpler to synchronize (we will see how this is the case in
    </span>
    <a href="B22219_05.xhtml#_idTextAnchor097">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.819.1">
        Chapter 5
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.820.1">
     ), and we have a guarantee that the packets will be processed in the same order as they arrived and were copied to the queue by the producer thread.
    </span>
    <span class="koboSpan" id="kobo.820.2">
     It is true that the packets will really be read in the same order they were copied to the queue irrespective of the number of threads we have as consumers, but the consumer threads may be scheduled in and out by the operating system, and the full sequence of processed packets could be in a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.821.1">
      different order.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.822.1">
     In general, the easiest problem is that of a
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.823.1">
      single-producer-single-consumer
     </span>
    </strong>
    <span class="koboSpan" id="kobo.824.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.825.1">
      SPSC
     </span>
    </strong>
    <span class="koboSpan" id="kobo.826.1">
     ) queue.
    </span>
    <span class="koboSpan" id="kobo.826.2">
     Different
    </span>
    <a id="_idIndexMarker282">
    </a>
    <span class="koboSpan" id="kobo.827.1">
     problems may require multiple consumers if the processing of each item is too costly for just a thread, and we may have different sources of data to be processed and need multiple producer threads.
    </span>
    <span class="koboSpan" id="kobo.827.2">
     The queue described in this section will work in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.828.1">
      every case.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.829.1">
     The first step in designing the queue is deciding what data structure we will use to store the queued items.
    </span>
    <span class="koboSpan" id="kobo.829.2">
     We want the queue to contain elements of any type
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.830.1">
      T
     </span>
    </em>
    <span class="koboSpan" id="kobo.831.1">
     , so we will implement it as a template class.
    </span>
    <span class="koboSpan" id="kobo.831.2">
     Also, we are going to limit the capacity of the queue so that the maximum number of elements we can store in the queue will be fixed and set in the class constructor.
    </span>
    <span class="koboSpan" id="kobo.831.3">
     It is possible, for example, to use a linked list and make the queue unbounded, or even
    </span>
    <a id="_idIndexMarker283">
    </a>
    <span class="koboSpan" id="kobo.832.1">
     use a
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.833.1">
      Standard Template Library
     </span>
    </strong>
    <span class="koboSpan" id="kobo.834.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.835.1">
      STL
     </span>
    </strong>
    <span class="koboSpan" id="kobo.836.1">
     ) queue,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.837.1">
      std::queue
     </span>
    </strong>
    <span class="koboSpan" id="kobo.838.1">
     , and let the queue grow to an arbitrary size.
    </span>
    <span class="koboSpan" id="kobo.838.2">
     In this chapter, we will implement a fixed-size queue.
    </span>
    <span class="koboSpan" id="kobo.838.3">
     We will revisit the implementation in
    </span>
    <a href="B22219_05.xhtml#_idTextAnchor097">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.839.1">
        Chapter 5
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.840.1">
     and implement it in a very different way (we won’t be using any mutex or waiting on condition variables).
    </span>
    <span class="koboSpan" id="kobo.840.2">
     For our current implementation, we will use an STL vector,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.841.1">
      std::vector&lt;T&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.842.1">
     , to store the queued items.
    </span>
    <span class="koboSpan" id="kobo.842.2">
     The vector will allocate memory for all the elements in the
    </span>
    <a id="_idIndexMarker284">
    </a>
    <span class="koboSpan" id="kobo.843.1">
     queue class constructor, so there will be no memory allocations after that.
    </span>
    <span class="koboSpan" id="kobo.843.2">
     When the queue is destroyed, the vector will destroy itself and will free the allocated memory.
    </span>
    <span class="koboSpan" id="kobo.843.3">
     This is convenient and simplifies
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.844.1">
      the implementation.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.845.1">
     We will use the vector
    </span>
    <a id="_idIndexMarker285">
    </a>
    <span class="koboSpan" id="kobo.846.1">
     as a
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.847.1">
      ring buffer
     </span>
    </strong>
    <span class="koboSpan" id="kobo.848.1">
     .
    </span>
    <span class="koboSpan" id="kobo.848.2">
     This means that, once we store an element at the end of the vector, the next one will be stored at the beginning, so we
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.849.1">
      wrap around
     </span>
    </em>
    <span class="koboSpan" id="kobo.850.1">
     both locations to write and read elements from
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.851.1">
      the vector.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.852.1">
     This is the first version of the queue class, quite simple and not
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.853.1">
      useful yet:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.854.1">
template &lt;typename T&gt;
class synchronized_queue {
public:
    explicit synchronized_queue(size_t size) :
        capacity_{ size }, buffer_(capacity_)
        {}
private:
    std::size_t head_{ 0 };
    std::size_t tail_{ 0 };
    std::size_t capacity_;
    std::vector&lt;T&gt; buffer_;
};</span></pre>
   <p>
    <span class="koboSpan" id="kobo.855.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.856.1">
      head
     </span>
    </strong>
    <span class="koboSpan" id="kobo.857.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.858.1">
      tail
     </span>
    </strong>
    <span class="koboSpan" id="kobo.859.1">
     variables are used to indicate where to read or write the next element respectively.
    </span>
    <span class="koboSpan" id="kobo.859.2">
     We also need to know when the queue is empty or full.
    </span>
    <span class="koboSpan" id="kobo.859.3">
     If the queue is empty, the consumer thread won’t be able to get any item from the queue.
    </span>
    <span class="koboSpan" id="kobo.859.4">
     If the queue is full, the producer thread will not be able to put any items in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.860.1">
      the queue.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.861.1">
     There are different ways to indicate when a queue is empty and when it is full.
    </span>
    <span class="koboSpan" id="kobo.861.2">
     In this example, we follow
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.862.1">
      this convention:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.863.1">
      If
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.864.1">
       tail_ == head_
      </span>
     </strong>
     <span class="koboSpan" id="kobo.865.1">
      , then the queue
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.866.1">
       is empty
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.867.1">
      If
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.868.1">
       (tail_ + 1) % capacity_ == head_
      </span>
     </strong>
     <span class="koboSpan" id="kobo.869.1">
      , then the queue
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.870.1">
       is full
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.871.1">
     Another way to
    </span>
    <a id="_idIndexMarker286">
    </a>
    <span class="koboSpan" id="kobo.872.1">
     implement it would require just checking if
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.873.1">
      tail_ == head_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.874.1">
     and using an extra flag to indicate if the queue is full or not (or using a counter to know how many items there are in the queue).
    </span>
    <span class="koboSpan" id="kobo.874.2">
     We avoid any extra flag or counter in this example because the flag will be read and written by both the consumer and the producer threads, and we aim to minimize sharing data among threads as much as we can.
    </span>
    <span class="koboSpan" id="kobo.874.3">
     Also, reducing sharing data will be the only option when we revisit the implementation of the queue in
    </span>
    <a href="B22219_05.xhtml#_idTextAnchor097">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.875.1">
        Chapter 5
       </span>
      </em>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.876.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.877.1">
     There is a small issue here.
    </span>
    <span class="koboSpan" id="kobo.877.2">
     Because of the way we check if the queue is full, we lose one slot in the buffer, so the real capacity is
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.878.1">
      capacity_ - 1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.879.1">
     .
    </span>
    <span class="koboSpan" id="kobo.879.2">
     We will consider the queue as full when there is just one empty slot.
    </span>
    <span class="koboSpan" id="kobo.879.3">
     Because of this, we lose one queue slot (note that the slot will be used, but the queue will still be full when the number of items is
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.880.1">
      capacity_ - 1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.881.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.881.2">
     In general, this is not
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.882.1">
      an issue.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.883.1">
     The queue we are going to implement is a bounded queue (fixed size) implemented as a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.884.1">
      ring buffer.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.885.1">
     There is another detail to be considered here:
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.886.1">
      head_ + 1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.887.1">
     must take into account that we wrap around the indices to the buffer (it is a ring buffer).
    </span>
    <span class="koboSpan" id="kobo.887.2">
     So, we must do
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.888.1">
      (head_ + 1) % capacity_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.889.1">
     .
    </span>
    <span class="koboSpan" id="kobo.889.2">
     The modulo operator calculates the remainder of the index value divided by the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.890.1">
      queue capacity.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.891.1">
     The following code
    </span>
    <a id="_idIndexMarker287">
    </a>
    <span class="koboSpan" id="kobo.892.1">
     shows the basic utility functions implemented as helper functions in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.893.1">
      synchronized queue:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.894.1">
template &lt;typename T&gt;
class synchronized_queue {
public:
    explicit synchronized_queue(size_t size) :
        capacity_{ size }, buffer_(capacity_) {
    }
private:
    std::size_t next(std::size_t index) {
        return (index + 1)% capacity_;
    }
    bool is_full() const {
        return next(tail_) == head_;
    }
    bool is_empty() const {
        return tail_ == head_;
    }
    std::size_t head_{ 0 };
    std::size_t tail_{ 0 };
    std::size_t capacity_;
    std::vector&lt;T&gt; buffer_;
};</span></pre>
   <p>
    <span class="koboSpan" id="kobo.895.1">
     We have implemented a few useful functions to update both the head and the tail of the ring buffer and to check if the buffer is full or empty.
    </span>
    <span class="koboSpan" id="kobo.895.2">
     Now, we can start implementing the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.896.1">
      queue functionality.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.897.1">
     The code for the full queue implementation is in the accompanying GitHub repo for the book.
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.898.1">
      Here, we only show the important bits
     </span>
    </em>
    <span class="koboSpan" id="kobo.899.1">
     for the sake of simplicity and focus just on the synchronization aspects of the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.900.1">
      queue implementation.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.901.1">
     The interface to the queue has the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.902.1">
      two functions:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.903.1">
void push(const T&amp; item);
void pop(T&amp; item);</span></pre>
   <p>
    <span class="koboSpan" id="kobo.904.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.905.1">
      push
     </span>
    </strong>
    <span class="koboSpan" id="kobo.906.1">
     function inserts an element in the queue, while
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.907.1">
      pop
     </span>
    </strong>
    <span class="koboSpan" id="kobo.908.1">
     gets an element from
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.909.1">
      the queue.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.910.1">
     Let’s start with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.911.1">
      push
     </span>
    </strong>
    <span class="koboSpan" id="kobo.912.1">
     .
    </span>
    <span class="koboSpan" id="kobo.912.2">
     It inserts an item in the queue.
    </span>
    <span class="koboSpan" id="kobo.912.3">
     If the queue is full,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.913.1">
      push
     </span>
    </strong>
    <span class="koboSpan" id="kobo.914.1">
     will wait until the queue has at least an empty slot (a consumer removed an element from the queue).
    </span>
    <span class="koboSpan" id="kobo.914.2">
     This way, the producer thread will be blocked until the queue has at least one empty slot (the not-full condition
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.915.1">
      is met).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.916.1">
     We have seen earlier in this chapter that there is a synchronization mechanism called a condition variable that does just that.
    </span>
    <span class="koboSpan" id="kobo.916.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.917.1">
      push
     </span>
    </strong>
    <span class="koboSpan" id="kobo.918.1">
     function will check if the condition is met, and when it is met, it will insert an item in the queue.
    </span>
    <span class="koboSpan" id="kobo.918.2">
     If the condition is not met, the lock associated with the condition variable will be released, and the thread will wait on the condition variable until the condition
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.919.1">
      is satisfied.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.920.1">
     It is possible for the
    </span>
    <a id="_idIndexMarker288">
    </a>
    <span class="koboSpan" id="kobo.921.1">
     condition variable to just wait until the lock is released.
    </span>
    <span class="koboSpan" id="kobo.921.2">
     We still need to check if the queue is full because a condition variable may end its waiting due to a spurious wakeup.
    </span>
    <span class="koboSpan" id="kobo.921.3">
     This happens when the condition variable receives a notification not sent explicitly by any
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.922.1">
      other thread.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.923.1">
     We add the following three member variables to the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.924.1">
      queue class:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.925.1">
std::mutex mtx_;
std::condition_variable not_full_;
Std::condition_variable not_empty_;</span></pre>
   <p>
    <span class="koboSpan" id="kobo.926.1">
     We need two condition variables – one to notify the consumers that the queue is not full (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.927.1">
      not_full_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.928.1">
     ) and another to notify the producers that the queue is not
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.929.1">
      empty (
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.930.1">
       not_empty_
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.931.1">
      ).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.932.1">
     This is the code
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.933.1">
      implementing
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.934.1">
       push
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.935.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.936.1">
void push(const T&amp; item) {
    std::unique_lock&lt;std::mutex&gt; lock(mtx_);
    not_full_.wait(lock, [this]{ return !is_full(); });
    buffer_[tail_] = T;
    tail_ = increment(tail_);
    lock.unlock();
    not_empty_.notify_one();
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.937.1">
     Let’s think about a scenario with a single producer and a single consumer.
    </span>
    <span class="koboSpan" id="kobo.937.2">
     We will see the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.938.1">
      pop
     </span>
    </strong>
    <span class="koboSpan" id="kobo.939.1">
     function later, but as an advance, it also synchronizes with the mutex/condition variable.
    </span>
    <span class="koboSpan" id="kobo.939.2">
     Both threads try to access the queue at the same time – the producer when inserting an element and the consumer when
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.940.1">
      removing it.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.941.1">
     Let’s assume the consumer
    </span>
    <a id="_idIndexMarker289">
    </a>
    <span class="koboSpan" id="kobo.942.1">
     acquires the lock first.
    </span>
    <span class="koboSpan" id="kobo.942.2">
     This happens in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.943.1">
      [1]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.944.1">
     .
    </span>
    <span class="koboSpan" id="kobo.944.2">
     The use of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.945.1">
      std::unique_lock
     </span>
    </strong>
    <span class="koboSpan" id="kobo.946.1">
     is required by condition variables to use a mutex.
    </span>
    <span class="koboSpan" id="kobo.946.2">
     In
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.947.1">
      [2]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.948.1">
     , we wait on the condition variable until the condition in the predicate of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.949.1">
      wait
     </span>
    </strong>
    <span class="koboSpan" id="kobo.950.1">
     function is met.
    </span>
    <span class="koboSpan" id="kobo.950.2">
     If it is not met, the lock is released for the consumer thread to be able to access
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.951.1">
      the queue.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.952.1">
     Once the condition is met, the lock is acquired again, and the queue is updated in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.953.1">
      [3]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.954.1">
     .
    </span>
    <span class="koboSpan" id="kobo.954.2">
     After updating the queue,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.955.1">
      [4]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.956.1">
     releases the lock and then
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.957.1">
      [5]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.958.1">
     notifies one consumer thread that may be waiting on
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.959.1">
      not_empty
     </span>
    </strong>
    <span class="koboSpan" id="kobo.960.1">
     that the queue is effectively not
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.961.1">
      empty now.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.962.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.963.1">
      std::unique_lock
     </span>
    </strong>
    <span class="koboSpan" id="kobo.964.1">
     class could release the mutex lock in its destructor, but we needed to release it in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.965.1">
      [4]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.966.1">
     because we didn’t want to release the lock after notifying the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.967.1">
      condition variable.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.968.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.969.1">
      pop()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.970.1">
     function follows a similar logic, as shown in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.971.1">
      following code:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.972.1">
void pop(T&amp; item)
{
    std::unique_lock&lt;std::mutex&gt; lock(mtx_);
    not_empty_.wait(lock, [this]{return !is_empty()});
    item = buffer_[head_];
    head_ = increment(head_);
    lock.unlock();
    not_full_.notify_one();
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.973.1">
     The code is very similar to that in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.974.1">
      push
     </span>
    </strong>
    <span class="koboSpan" id="kobo.975.1">
     function.
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.976.1">
      [1]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.977.1">
     creates the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.978.1">
      std::unique_lock
     </span>
    </strong>
    <span class="koboSpan" id="kobo.979.1">
     class required to use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.980.1">
      not_empty_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.981.1">
     condition variable.
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.982.1">
      [2]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.983.1">
     waits on
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.984.1">
      not_empty_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.985.1">
     until it is notified that the queue is not empty.
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.986.1">
      [3]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.987.1">
     reads the item from the queue, assigning it to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.988.1">
      item
     </span>
    </strong>
    <span class="koboSpan" id="kobo.989.1">
     variable, and then in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.990.1">
      [4]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.991.1">
     , the lock is released.
    </span>
    <span class="koboSpan" id="kobo.991.2">
     Finally, in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.992.1">
      [5]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.993.1">
     , the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.994.1">
      not_full_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.995.1">
     condition variable is notified to indicate to the consumer that the queue is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.996.1">
      not full.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.997.1">
     Both
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.998.1">
      push
     </span>
    </strong>
    <span class="koboSpan" id="kobo.999.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1000.1">
      pop
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1001.1">
     functions
    </span>
    <a id="_idIndexMarker290">
    </a>
    <span class="koboSpan" id="kobo.1002.1">
     are blocking and waiting until the queue is not full or not empty respectively.
    </span>
    <span class="koboSpan" id="kobo.1002.2">
     We may need the thread to keep on running in the event of not being able to either insert or get a message to/from the queue – for example, to let it do some independent processing – and then try again to access
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1003.1">
      the queue.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1004.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1005.1">
      try_push
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1006.1">
     function does exactly that.
    </span>
    <span class="koboSpan" id="kobo.1006.2">
     If the mutex is free to be acquired and the queue is not full, then the functionality is the same as the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1007.1">
      push
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1008.1">
     function, but in this case,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1009.1">
      try_push
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1010.1">
     doesn’t need to use any condition variable for synchronization (but it must notify the consumer).
    </span>
    <span class="koboSpan" id="kobo.1010.2">
     This is the code
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1011.1">
      for
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1012.1">
       try_push
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1013.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1014.1">
bool try_push(const T&amp; item) {
    std::unique_lock&lt;std::mutex&gt; lock(mtx_, std::try_to_lock);
    if (!lock || is_full()) {
        return false;
    }
    buffer_[tail_] = item;
    tail_ = next(tail_);
    lock.unlock();
    not_empty_.notify_one();
    return true;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1015.1">
     The code works like this:
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1016.1">
      [1]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1017.1">
     tries to acquire the lock and returns without blocking the calling thread.
    </span>
    <span class="koboSpan" id="kobo.1017.2">
     If the lock was already acquired, then it will evaluate to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1018.1">
      false
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1019.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1019.2">
     In
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1020.1">
      [2]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1021.1">
     , in case the lock has not been acquired or the queue is full,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1022.1">
      try_push
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1023.1">
     returns
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1024.1">
      false
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1025.1">
     to indicate to the caller that no item was inserted in the queue and delegates the waiting/blocking to the caller.
    </span>
    <span class="koboSpan" id="kobo.1025.2">
     Note that
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1026.1">
      [3]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1027.1">
     returns
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1028.1">
      false
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1029.1">
     and the function terminates.
    </span>
    <span class="koboSpan" id="kobo.1029.2">
     If the lock was acquired, it will be released when the function exits and the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1030.1">
      std::unique_lock
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1031.1">
     destructor
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1032.1">
      is called.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1033.1">
     After the lock is
    </span>
    <a id="_idIndexMarker291">
    </a>
    <span class="koboSpan" id="kobo.1034.1">
     acquired and has checked that the queue is not full, then the item is inserted in the queue, and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1035.1">
      tail_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1036.1">
     is updated.
    </span>
    <span class="koboSpan" id="kobo.1036.2">
     In
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1037.1">
      [5]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1038.1">
     , the lock is released, and in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1039.1">
      [6]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1040.1">
     , the consumer is notified that the queue is not empty anymore.
    </span>
    <span class="koboSpan" id="kobo.1040.2">
     This notification is required because the consumer may call
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1041.1">
      pop
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1042.1">
     instead
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1043.1">
      of
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1044.1">
       try_pop
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1045.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1046.1">
     Finally, the function returns
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1047.1">
      true
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1048.1">
     to indicate to the caller that the item was successfully inserted in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1049.1">
      the queue.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1050.1">
     The code for the corresponding
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1051.1">
      try_pop
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1052.1">
     function is shown next.
    </span>
    <span class="koboSpan" id="kobo.1052.2">
     As an exercise, try to understand how
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1053.1">
      it works:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1054.1">
bool try_pop(T&amp; item) {
     std::unique_lock&lt;std::mutex&gt; lock(mtx_, std::try_to_lock);
     if (!lock || is_empty()) {
         return false;
     }
     item = buffer_[head_];
     head_ = next(head_);
     lock.unlock();
     not_empty_.notify_one();
     return true;
 }</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1055.1">
     This is the full code
    </span>
    <a id="_idIndexMarker292">
    </a>
    <span class="koboSpan" id="kobo.1056.1">
     for the queue we have implemented in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1057.1">
      this section:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1058.1">
#pragma once
#include &lt;condition_variable&gt;
#include &lt;mutex&gt;
#include &lt;vector&gt;
namespace async_prog {
template &lt;typename T&gt;
class queue {
public:
    queue(std::size_t capacity) : capacity_{capacity}, buffer_(capacity) {}
    void push(const T&amp; item) {
        std::unique_lock&lt;std::mutex&gt; lock(mtx_);
        not_full_.wait(lock, [this] { return !is_full(); });
        buffer_[tail_] = item;
        tail_ = next(tail_);
        lock.unlock();
        not_empty_.notify_one();
    }
    bool try_push(const T&amp; item) {
        std::unique_lock&lt;std::mutex&gt; lock(mtx_, std::try_to_lock);
        if (!lock || is_full()) {
            return false;
        }
        buffer_[tail_] = item;
        tail_ = next(tail_);
        lock.unlock();
        not_empty_.notify_one();
        return true;
    }
    void pop(T&amp; item) {
        std::unique_lock&lt;std::mutex&gt; lock(mtx_);
        not_empty_.wait(lock, [this] { return !is_empty(); });
        item = buffer_[head_];
        head_ = next(head_);
        lock.unlock();
        not_full_.notify_one();
    }
    bool try_pop(T&amp; item) {
        std::unique_lock&lt;std::mutex&gt; lock(mtx_, std::try_to_lock);
        if (!lock || is_empty()) {
            return false;
        }
        item = buffer_[head_];
        head_ = next(head_);
        lock.unlock();
        not_empty_.notify_one();
        return true;
    }
private:
    [[nodiscard]] std::size_t next(std::size_t idx) const noexcept {
        return ((idx + 1) % capacity_);
    }
    [[nodiscard]] bool is_empty() const noexcept { return (head_ == tail_); }
    [[nodiscard]] bool is_full() const noexcept { return (next(tail_) == head_); }
   private:
    std::mutex mtx_;
    std::condition_variable not_empty_;
    std::condition_variable not_full_;
    std::size_t head_{0};
    std::size_t tail_{0};
    std::size_t capacity_;
    std::vector&lt;T&gt; buffer_;
};
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1059.1">
     In this section, we have introduced condition variables and implemented a basic queue synchronized with a mutex and two condition variables, the two basic synchronization primitives provided by the C++ Standard Library
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1060.1">
      since C++11.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1061.1">
     The queue example shows how synchronization is implemented using these synchronization
    </span>
    <a id="_idIndexMarker293">
    </a>
    <span class="koboSpan" id="kobo.1062.1">
     primitives and can be used as a basic building block for more elaborate utilities such as, for example, a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1063.1">
      thread pool.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-89">
    <a id="_idTextAnchor088">
    </a>
    <span class="koboSpan" id="kobo.1064.1">
     Semaphores
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.1065.1">
     C++20 introduces new
    </span>
    <a id="_idIndexMarker294">
    </a>
    <span class="koboSpan" id="kobo.1066.1">
     synchronization primitives to write multithreaded applications.
    </span>
    <span class="koboSpan" id="kobo.1066.2">
     In this section, we will look
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1067.1">
      at semaphores.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1068.1">
     A
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.1069.1">
      semaphore
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1070.1">
     is a counter that manages the number of permits available for accessing a shared resource.
    </span>
    <span class="koboSpan" id="kobo.1070.2">
     Semaphores can be classified into two
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1071.1">
      main types:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.1072.1">
      A
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.1073.1">
       binary semaphore
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1074.1">
      is like a mutex.
     </span>
     <span class="koboSpan" id="kobo.1074.2">
      It has only two states: 0 and 1.
     </span>
     <span class="koboSpan" id="kobo.1074.3">
      Even though a binary semaphore is conceptually like a mutex, there are some differences between a binary semaphore and a mutex that we will see later in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1075.1">
       this section.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1076.1">
      A
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.1077.1">
       counting semaphore
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1078.1">
      can have a value greater than 1 and is used to control access to a resource that has a limited number
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1079.1">
       of instances.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.1080.1">
     C++20 implements both binary and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1081.1">
      counting semaphores.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-90">
    <a id="_idTextAnchor089">
    </a>
    <span class="koboSpan" id="kobo.1082.1">
     Binary semaphores
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.1083.1">
     A binary semaphore is
    </span>
    <a id="_idIndexMarker295">
    </a>
    <span class="koboSpan" id="kobo.1084.1">
     a synchronization primitive
    </span>
    <a id="_idIndexMarker296">
    </a>
    <span class="koboSpan" id="kobo.1085.1">
     that can be used to control access to a shared resource.
    </span>
    <span class="koboSpan" id="kobo.1085.2">
     It has two states: 0 and 1.
    </span>
    <span class="koboSpan" id="kobo.1085.3">
     A semaphore with a value of 0 indicates that the resource is unavailable, while a semaphore with a value of 1 indicates that the resource
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1086.1">
      is available.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1087.1">
     Binary semaphores can be used to implement mutual exclusion.
    </span>
    <span class="koboSpan" id="kobo.1087.2">
     This is achieved by using a binary semaphore to control access to the resource.
    </span>
    <span class="koboSpan" id="kobo.1087.3">
     When a thread wants to access the resource, it first checks the semaphore.
    </span>
    <span class="koboSpan" id="kobo.1087.4">
     If the semaphore is 1, the thread can access the resource.
    </span>
    <span class="koboSpan" id="kobo.1087.5">
     If the semaphore is 0, the thread must wait until the semaphore is 1 before it can access
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1088.1">
      the resource.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1089.1">
     The most significant difference between mutexes and semaphores is that mutexes have exclusive ownership, whereas binary semaphores do not.
    </span>
    <span class="koboSpan" id="kobo.1089.2">
     Only the thread owning the mutex can release it.
    </span>
    <span class="koboSpan" id="kobo.1089.3">
     Semaphores can be signaled by any thread.
    </span>
    <span class="koboSpan" id="kobo.1089.4">
     A mutex is a locking mechanism for a critical section, and a semaphore is more like a signaling mechanism.
    </span>
    <span class="koboSpan" id="kobo.1089.5">
     In this respect, a semaphore is closer to a condition variable than a mutex.
    </span>
    <span class="koboSpan" id="kobo.1089.6">
     For this reason, semaphores are commonly used for signaling rather than for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1090.1">
      mutual exclusion.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1091.1">
     In C++20,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1092.1">
      std::binary_semaphore
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1093.1">
     is an alias for the specialization of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1094.1">
      std::counting_semaphore
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1095.1">
     , with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1096.1">
      LeastMaxValue
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1097.1">
      being 1.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1098.1">
     Binary semaphores must be initialized with either 1 or 0, such
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1099.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1100.1">
std::binary_semaphore sm1{ 0 };
std::binary_semaphore sm2{ 1 };</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1101.1">
     If the initial value is
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1102.1">
      0
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1103.1">
     , acquiring the semaphore will block the thread trying to acquire it, and before it can be acquired, it must be released by another thread.
    </span>
    <span class="koboSpan" id="kobo.1103.2">
     Acquiring a semaphore decreases
    </span>
    <a id="_idIndexMarker297">
    </a>
    <span class="koboSpan" id="kobo.1104.1">
     the counter, and releasing it increases the
    </span>
    <a id="_idIndexMarker298">
    </a>
    <span class="koboSpan" id="kobo.1105.1">
     counter.
    </span>
    <span class="koboSpan" id="kobo.1105.2">
     As previously stated, if the counter is
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1106.1">
      0
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1107.1">
     and a thread tries to acquire the lock (semaphore), the thread will be blocked until the semaphore counter is greater
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1108.1">
      than
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1109.1">
       0
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1110.1">
      .
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-91">
    <a id="_idTextAnchor090">
    </a>
    <span class="koboSpan" id="kobo.1111.1">
     Counting semaphores
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.1112.1">
     A counting semaphore
    </span>
    <a id="_idIndexMarker299">
    </a>
    <span class="koboSpan" id="kobo.1113.1">
     allows access to a shared resource by
    </span>
    <a id="_idIndexMarker300">
    </a>
    <span class="koboSpan" id="kobo.1114.1">
     more than one thread.
    </span>
    <span class="koboSpan" id="kobo.1114.2">
     The counter can be initialized to an arbitrary number, and it will be decreased every time a thread acquires the semaphore.
    </span>
    <span class="koboSpan" id="kobo.1114.3">
     As an example of how to use counting semaphores, we will modify the multithread safe queue we implemented in the previous section and use semaphores instead of condition variables to synchronize access to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1115.1">
      the queue.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1116.1">
     The member variables of the new class are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1117.1">
      the following:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1118.1">
template &lt;typename T&gt;
class queue {
 // public methods and private helper methods
private:
    std::counting_semaphore&lt;&gt; sem_empty_;
    std::counting_semaphore&lt;&gt; sem_full_;
    std::size_t head_{ 0 };
    std::size_t tail_{ 0 };
    std::size_t capacity_;
    std::vector&lt;T&gt; buffer_;
};</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1119.1">
     We still need
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1120.1">
      head_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1121.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1122.1">
      tail_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1123.1">
     to know where to read and write an element,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1124.1">
      capacity_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1125.1">
     for the wraparound of the indices, and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1126.1">
      buffer_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1127.1">
     , a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1128.1">
      std::vector&lt;T&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1129.1">
     vector.
    </span>
    <span class="koboSpan" id="kobo.1129.2">
     But for now, we are not using a mutex, and we will use counting semaphores instead of condition variables.
    </span>
    <span class="koboSpan" id="kobo.1129.3">
     We will use two of them:
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1130.1">
      sem_empty_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1131.1">
     to count the empty slots in the buffer (initially set to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1132.1">
      capacity_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1133.1">
     ) and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1134.1">
      sem_full_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1135.1">
     to count the non-empty slots in the buffer, initially set
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1136.1">
      to 0.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1137.1">
     Now, let’s see
    </span>
    <a id="_idIndexMarker301">
    </a>
    <span class="koboSpan" id="kobo.1138.1">
     how
    </span>
    <a id="_idIndexMarker302">
    </a>
    <span class="koboSpan" id="kobo.1139.1">
     to implement
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1140.1">
      push
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1141.1">
     , the function used to insert items in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1142.1">
      a queue.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1143.1">
     In
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1144.1">
      [1]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1145.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1146.1">
      sem_empty_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1147.1">
     is acquired, decreasing the semaphore counter.
    </span>
    <span class="koboSpan" id="kobo.1147.2">
     If the queue is full, then the thread will block until
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1148.1">
      sem_empty_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1149.1">
     is released (signaled) by another thread.
    </span>
    <span class="koboSpan" id="kobo.1149.2">
     If the queue is not full, then the item is copied to the buffer, and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1150.1">
      tail_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1151.1">
     is updated in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1152.1">
      [2]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1153.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1154.1">
      [3]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1155.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1155.2">
     Finally,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1156.1">
      sem_full_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1157.1">
     is released in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1158.1">
      [4]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1159.1">
     , signaling another thread that the queue is not empty and there is at least one item in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1160.1">
      the buffer:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1161.1">
void push(const T&amp; item) {
    sem_empty_.acquire();
    buffer_[tail_] = item;
    tail_ = next(tail_);
    sem_full_.release();
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1162.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1163.1">
      pop
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1164.1">
     function is used to get elements from
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1165.1">
      a queue:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1166.1">
void pop(T&amp; item) {
    sem_full_.acquire();
    item = buffer_[head_];
    head_ = next(head_);
    sem_empty_.release();
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1167.1">
     Here, in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1168.1">
      [1]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1169.1">
     , we successfully acquire
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1170.1">
      sem_full_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1171.1">
     if the queue is not empty.
    </span>
    <span class="koboSpan" id="kobo.1171.2">
     Then, the item is read and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1172.1">
      head_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1173.1">
     updated in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1174.1">
      [2]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1175.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1176.1">
      [3]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1177.1">
     respectively.
    </span>
    <span class="koboSpan" id="kobo.1177.2">
     Finally, we signal the consumer thread that the queue is not full,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1178.1">
      releasing
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1179.1">
       sem_empty
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1180.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1181.1">
     There are several
    </span>
    <a id="_idIndexMarker303">
    </a>
    <span class="koboSpan" id="kobo.1182.1">
     issues in our first version of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1183.1">
      push
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1184.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1184.2">
     The first and
    </span>
    <a id="_idIndexMarker304">
    </a>
    <span class="koboSpan" id="kobo.1185.1">
     most important one is that
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1186.1">
      sem_empty_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1187.1">
     allows more than one thread to access the critical section in the queue (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1188.1">
      [2]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1189.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1190.1">
      [3]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1191.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.1191.2">
     We need to synchronize this critical section and use
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1192.1">
      a mutex.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1193.1">
     Here is the new version of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1194.1">
      push
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1195.1">
     using a mutex
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1196.1">
      for synchronization.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1197.1">
     In
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1198.1">
      [2]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1199.1">
     , the lock is acquired (using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1200.1">
      std::unique_lock
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1201.1">
     ), and in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1202.1">
      [5]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1203.1">
     , it is released.
    </span>
    <span class="koboSpan" id="kobo.1203.2">
     Using the lock will synchronize the critical section, preventing several threads from simultaneously accessing it and updating the queue concurrently without
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1204.1">
      any synchronization:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1205.1">
void push(const T&amp; item)
{
    sem_empty_.acquire();
    std::unique_lock&lt;std::mutex&gt; lock(mtx_);
    buffer_[tail_] = item;
    tail_ = next(tail_);
    lock.unlock();
    sem_full_.release();
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1206.1">
     A second issue is that acquiring a semaphore is blocking, and as we have seen previously, sometimes the caller thread can do some processing instead of just waiting.
    </span>
    <span class="koboSpan" id="kobo.1206.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1207.1">
      try_push
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1208.1">
     function (and its corresponding
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1209.1">
      try_pop
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1210.1">
     function) implements this functionality.
    </span>
    <span class="koboSpan" id="kobo.1210.2">
     Let’s study
    </span>
    <a id="_idIndexMarker305">
    </a>
    <span class="koboSpan" id="kobo.1211.1">
     the code of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1212.1">
      try_push
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1213.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1213.2">
     Note
    </span>
    <a id="_idIndexMarker306">
    </a>
    <span class="koboSpan" id="kobo.1214.1">
     that
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1215.1">
      try_push
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1216.1">
     may still block on
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1217.1">
      the mutex:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1218.1">
bool try_push(const T&amp; item) {
    if (!sem_empty_.try acquire()) {
        return false;
    }
    std::unique_lock&lt;std::mutex&gt; lock(mtx_);
    buffer_[tail_] = item;
    tail_ = next(tail_);
    lock.unlock();
    sem_full_.release();
    return true;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1219.1">
     The only changes are
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1220.1">
      [1]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1221.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1222.1">
      [2]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1223.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1223.2">
     Instead of blocking when acquiring the semaphore, we just try to acquire it, and if we fail, we return
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1224.1">
      false
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1225.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1225.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1226.1">
      try_acquire
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1227.1">
     function may spuriously fail and return
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1228.1">
      false
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1229.1">
     even if the semaphore can be acquired (count is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1230.1">
      not zero).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1231.1">
     Here is the complete
    </span>
    <a id="_idIndexMarker307">
    </a>
    <span class="koboSpan" id="kobo.1232.1">
     code for the queue synchronized
    </span>
    <a id="_idIndexMarker308">
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1233.1">
      with semaphores:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1234.1">
#pragma once
#include &lt;mutex&gt;
#include &lt;semaphore&gt;
#include &lt;vector&gt;
namespace async_prog {
template &lt;typename T&gt;
class semaphore_queue {
   public:
    semaphore_queue(std::size_t capacity)
        : sem_empty_(capacity), sem_full_(0), capacity_{capacity}, buffer_(capacity)
    {}
    void push(const T&amp; item) {
        sem_empty_.acquire();
        std::unique_lock&lt;std::mutex&gt; lock(mtx_);
        buffer_[tail_] = item;
        tail_ = next(tail_);
        lock.unlock();
        sem_full_.release();
    }
    bool try_push(const T&amp; item) {
        if (!sem_empty_.try_acquire()) {
            return false;
        }
        std::unique_lock&lt;std::mutex&gt; lock(mtx_);
        buffer_[tail_] = item;
        tail_ = next(tail_);
        lock.unlock();
        sem_full_.release();
        return true;
    }
    void pop(T&amp; item) {
        sem_full_.acquire();
        std::unique_lock&lt;std::mutex&gt; lock(mtx_);
        item = buffer_[head_];
        head_ = next(head_);
        lock.unlock();
        sem_empty_.release();
    }
    bool try_pop(T&amp; item) {
        if (!sem_full_.try_acquire()) {
            return false;
        }
        std::unique_lock&lt;std::mutex&gt; lock(mtx_);
        item = buffer_[head_];
        head_ = next(head_);
        lock.unlock();
        sem_empty_.release();
        return true;
    }
private:
    [[nodiscard]] std::size_t next(std::size_t idx) const noexcept {
        return ((idx + 1) % capacity_);
    }
private:
    std::mutex mtx_;
    std::counting_semaphore&lt;&gt; sem_empty_;
    std::counting_semaphore&lt;&gt; sem_full_;
    std::size_t head_{0};
    std::size_t tail_{0};
    std::size_t capacity_;
    std::vector&lt;T&gt; buffer_;
};</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1235.1">
     In this section, we have seen semaphores, a new synchronization primitive included in the C++ Standard Library since C++20.
    </span>
    <span class="koboSpan" id="kobo.1235.2">
     We learned how to use them to implement the same queue we implemented before but using semaphores as
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1236.1">
      synchronization primitives.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1237.1">
     In the next section, we
    </span>
    <a id="_idIndexMarker309">
    </a>
    <span class="koboSpan" id="kobo.1238.1">
     will introduce
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.1239.1">
      barriers
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1240.1">
     and
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.1241.1">
      latches
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1242.1">
     , two new
    </span>
    <a id="_idIndexMarker310">
    </a>
    <span class="koboSpan" id="kobo.1243.1">
     synchronization mechanisms included in the C++ Standard Library
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1244.1">
      since C++20.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-92">
    <a id="_idTextAnchor091">
    </a>
    <span class="koboSpan" id="kobo.1245.1">
     Barriers and latches
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.1246.1">
     In this section, we
    </span>
    <a id="_idIndexMarker311">
    </a>
    <span class="koboSpan" id="kobo.1247.1">
     will introduce
    </span>
    <a id="_idIndexMarker312">
    </a>
    <span class="koboSpan" id="kobo.1248.1">
     barriers and latches, two new synchronization primitives introduced in C++20.
    </span>
    <span class="koboSpan" id="kobo.1248.2">
     These mechanisms allow threads to wait for each other, thereby coordinating the execution of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1249.1">
      concurrent tasks.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-93">
    <a id="_idTextAnchor092">
    </a>
    <span class="koboSpan" id="kobo.1250.1">
     std::latch
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.1251.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1252.1">
      std::latch
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1253.1">
     latch is a
    </span>
    <a id="_idIndexMarker313">
    </a>
    <span class="koboSpan" id="kobo.1254.1">
     synchronization primitive that allows one or more threads to block until a specified number of operations are completed.
    </span>
    <span class="koboSpan" id="kobo.1254.2">
     It is a single-use object, and once the count reaches zero, it cannot
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1255.1">
      be reset.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1256.1">
     The following example is a simple illustration of the use of latches in a multithreaded application.
    </span>
    <span class="koboSpan" id="kobo.1256.2">
     We want to write a function to multiply by two each element of a vector and then add all the elements of the vector.
    </span>
    <span class="koboSpan" id="kobo.1256.3">
     We will use three threads to multiply the vector elements by two and then one thread to add all the elements of the vector and obtain
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1257.1">
      the result.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1258.1">
     We need two latches.
    </span>
    <span class="koboSpan" id="kobo.1258.2">
     The first one will be decremented by each of the three threads multiplying by two vector elements.
    </span>
    <span class="koboSpan" id="kobo.1258.3">
     The adding thread will wait for this latch to be zero.
    </span>
    <span class="koboSpan" id="kobo.1258.4">
     Then, the main thread will wait on the second latch to synchronize printing the result of adding all the vector’s elements.
    </span>
    <span class="koboSpan" id="kobo.1258.5">
     We can also wait for the thread performing the additions calling
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1259.1">
      join
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1260.1">
     on it, but this can be done with a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1261.1">
      latch too.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1262.1">
     Now, let’s analyze the code in functional blocks.
    </span>
    <span class="koboSpan" id="kobo.1262.2">
     We will include the full code for the latches and barriers example later in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1263.1">
      this section:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1264.1">
std::latch map_latch{ 3 };
auto map_thread = [&amp;](std::vector&lt;int&gt;&amp; numbers, int start, int end) {
    for (int i = start; i &lt; end; ++i) {
        numbers[i] *= 2;
    }
    map_latch.count_down();
};</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1265.1">
     Each multiplying thread will run this lambda function, multiplying by two elements of a certain range in the vector (from
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1266.1">
      start
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1267.1">
     to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1268.1">
      end
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1269.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.1269.2">
     Once the thread is done, it will decrease the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1270.1">
      map_latch
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1271.1">
     counter by one.
    </span>
    <span class="koboSpan" id="kobo.1271.2">
     Once all the threads finish their tasks, the latch counter will be zero, and the thread blocked waiting on
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1272.1">
      map_latch
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1273.1">
     will be able to go on and add all the elements of the vector together.
    </span>
    <span class="koboSpan" id="kobo.1273.2">
     Note that the threads access different elements of the vector, so we don’t need to synchronize access to the vector itself, but we cannot start adding the numbers until all the multiplications
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1274.1">
      are done.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1275.1">
     The code for the adding thread is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1276.1">
      the following:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1277.1">
std::latch reduce_latch{ 1 };
auto reduce_thread = [&amp;](const std::vector&lt;int&gt;&amp; numbers, int&amp; sum) {
    map_latch.wait();
    sum = std::accumulate(numbers.begin(), numbers.end(), 0);
    reduce_latch.count_down();
};</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1278.1">
     This thread waits until the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1279.1">
      map_latch
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1280.1">
     counter goes down to zero, then adds all the elements of the vector, and finally decrements the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1281.1">
      reduce_latch
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1282.1">
     counter (it will go down to zero) for the main thread to be able to print the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1283.1">
      final result:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1284.1">
reduce_latch.wait();
std::cout &lt;&lt; "All threads finished. </span><span class="koboSpan" id="kobo.1284.2">The sum is: " &lt;&lt; sum &lt;&lt; '\n';</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1285.1">
     Having seen a basic
    </span>
    <a id="_idIndexMarker314">
    </a>
    <span class="koboSpan" id="kobo.1286.1">
     application of latches, next, let’s learn
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1287.1">
      about barriers.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-94">
    <a id="_idTextAnchor093">
    </a>
    <span class="koboSpan" id="kobo.1288.1">
     std::barrier
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.1289.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1290.1">
      std::barrier
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1291.1">
     barrier is
    </span>
    <a id="_idIndexMarker315">
    </a>
    <span class="koboSpan" id="kobo.1292.1">
     another synchronization primitive used to synchronize a group of threads.
    </span>
    <span class="koboSpan" id="kobo.1292.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1293.1">
      std::barrier
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1294.1">
     barrier is reusable.
    </span>
    <span class="koboSpan" id="kobo.1294.2">
     Each thread reaches the barrier and waits until all participating threads reach the same barrier point (like what happens when we
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1295.1">
      use latches).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1296.1">
     The main difference between
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1297.1">
      std::barrier
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1298.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1299.1">
      std::latch
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1300.1">
     is the reset capability.
    </span>
    <span class="koboSpan" id="kobo.1300.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1301.1">
      std::latch
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1302.1">
     latch is a single-use barrier with a countdown mechanism that cannot be reset.
    </span>
    <span class="koboSpan" id="kobo.1302.2">
     Once it reaches zero, it stays at zero.
    </span>
    <span class="koboSpan" id="kobo.1302.3">
     In contrast,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1303.1">
      std::barrier
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1304.1">
     is reusable.
    </span>
    <span class="koboSpan" id="kobo.1304.2">
     It resets after all threads have reached the barrier, allowing the same set of threads to synchronize at the same barrier
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1305.1">
      multiple times.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1306.1">
     When to use latches and when to use barriers?
    </span>
    <span class="koboSpan" id="kobo.1306.2">
     Use
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1307.1">
      std::latch
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1308.1">
     when you have a one-time gathering point for threads, such as waiting for multiple initializations to complete before proceeding.
    </span>
    <span class="koboSpan" id="kobo.1308.2">
     Use
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1309.1">
      std::barrier
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1310.1">
     when you need to synchronize threads repeatedly through multiple phases of a task or
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1311.1">
      iterative computations.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1312.1">
     We will now rewrite the previous example, this time using barriers instead of latches.
    </span>
    <span class="koboSpan" id="kobo.1312.2">
     Each thread will multiply by two its corresponding range of vector elements, and then it will add them.
    </span>
    <span class="koboSpan" id="kobo.1312.3">
     The main thread will use
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1313.1">
      join()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1314.1">
     in this example to wait for the processing to be finished and then add the results obtained by each of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1315.1">
      the threads.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1316.1">
     The code for the worker
    </span>
    <a id="_idIndexMarker316">
    </a>
    <span class="koboSpan" id="kobo.1317.1">
     thread is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1318.1">
      the following:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1319.1">
std::barrier map_barrier{ 3 };
auto worker_thread = [&amp;](std::vector&lt;int&gt;&amp; numbers, int start, int end, int id) {
    std::cout &lt;&lt; std::format("Thread {0} is starting...\n", id);
    for (int i = start; i &lt; end; ++i) {
        numbers[i] *= 2;
    }
    map_barrier.arrive_and_wait();
    for (int i = start; i &lt; end; ++i) {
        sum[id] += numbers[i];
    }
    map_barrier.arrive();
};</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1320.1">
     The code is synchronized with a barrier.
    </span>
    <span class="koboSpan" id="kobo.1320.2">
     When a worker thread finishes doing the multiplications, it decreases the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1321.1">
      map_barrier
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1322.1">
     counter and waits for the barrier counter to be zero.
    </span>
    <span class="koboSpan" id="kobo.1322.2">
     Once it goes down to zero, the threads end their waiting and start doing the additions.
    </span>
    <span class="koboSpan" id="kobo.1322.3">
     The barrier counter is reset, and its value is again equal to three.
    </span>
    <span class="koboSpan" id="kobo.1322.4">
     Once the additions are done, the barrier counter is decremented again, but this time, the threads won’t wait because their task
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1323.1">
      is done.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1324.1">
     Sure – each thread could have done the additions and then multiplied by two.
    </span>
    <span class="koboSpan" id="kobo.1324.2">
     They don’t need to wait for each other because the work done by any thread is independent of the work done by any other thread, but this is a good way of explaining how barriers work with an
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1325.1">
      easy example.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1326.1">
     The main thread just
    </span>
    <a id="_idIndexMarker317">
    </a>
    <span class="koboSpan" id="kobo.1327.1">
     waits with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1328.1">
      join
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1329.1">
     for the worker threads to finish and then prints
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1330.1">
      the result:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1331.1">
for (auto&amp; t : workers) {
    t.join();
}
std::cout &lt;&lt; std::format("The total sum is {0}\n",
                         std::accumulate(sum.begin(), sum. </span><span class="koboSpan" id="kobo.1331.2">End(), 0));</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1332.1">
     Here is the full code for the latches and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1333.1">
      barriers example:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1334.1">
#include &lt;algorithm&gt;
#include &lt;barrier&gt;
#include &lt;format&gt;
#include &lt;iostream&gt;
#include &lt;latch&gt;
#include &lt;numeric&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;
void multiply_add_latch() {
    const int NUM_THREADS{3};
    std::latch map_latch{NUM_THREADS};
    std::latch reduce_latch{1};
    std::vector&lt;int&gt; numbers(3000);
    int sum{};
    std::iota(numbers.begin(), numbers.end(), 0);
    auto map_thread = [&amp;](std::vector&lt;int&gt;&amp; numbers, int start, int end) {
        for (int i = start; i &lt; end; ++i) {
            numbers[i] *= 2;
        }
        map_latch.count_down();
    };
    auto reduce_thread = [&amp;](const std::vector&lt;int&gt;&amp; numbers, int&amp; sum) {
        map_latch.wait();
        sum = std::accumulate(numbers.begin(), numbers.end(), 0);
        reduce_latch.count_down();
    };
    for (int i = 0; i &lt; NUM_THREADS; ++i) {
        std::jthread t(map_thread, std::ref(numbers), 1000 * i, 1000 * (i + 1));
    }
    std::jthread t(reduce_thread, numbers, std::ref(sum));
    reduce_latch.wait();
    std::cout &lt;&lt; "All threads finished. </span><span class="koboSpan" id="kobo.1334.2">The total sum is: " &lt;&lt; sum &lt;&lt; '\n';
}
void multiply_add_barrier() {
    const int NUM_THREADS{3};
    std::vector&lt;int&gt; sum(3, 0);
    std::vector&lt;int&gt; numbers(3000);
    std::iota(numbers.begin(), numbers.end(), 0);
    std::barrier map_barrier{NUM_THREADS};
    auto worker_thread = [&amp;](std::vector&lt;int&gt;&amp; numbers, int start, int end, int id) {
        std::cout &lt;&lt; std::format("Thread {0} is starting...\n", id);
        for (int i = start; i &lt; end; ++i) {
            numbers[i] *= 2;
        }
        map_barrier.arrive_and_wait();
        for (int i = start; i &lt; end; ++i) {
            sum[id] += numbers[i];
        }
        map_barrier.arrive();
    };
    std::vector&lt;std::jthread&gt; workers;
    for (int i = 0; i &lt; NUM_THREADS; ++i) {
        workers.emplace_back(worker_thread, std::ref(numbers), 1000 * i,
                             1000 * (i + 1), i);
    }
    for (auto&amp; t : workers) {
        t.join();
    }
    std::cout &lt;&lt; std::format("All threads finished. </span><span class="koboSpan" id="kobo.1334.3">The total sum is: {0}\n",
     std::accumulate(sum.begin(), sum.end(), 0));
}
int main() {
    std::cout &lt;&lt; "Multiplying and reducing vector using barriers..." </span><span class="koboSpan" id="kobo.1334.4">&lt;&lt; std::endl;
    multiply_add_barrier();
    std::cout &lt;&lt; "Multiplying and reducing vector using latches..." </span><span class="koboSpan" id="kobo.1334.5">&lt;&lt; std::endl;
    multiply_add_latch();
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1335.1">
     In this section, we have seen barriers and latches.
    </span>
    <span class="koboSpan" id="kobo.1335.2">
     Though they are not so commonly used as mutexes, condition variables, and semaphores, it is always useful to know what they are.
    </span>
    <span class="koboSpan" id="kobo.1335.3">
     The simple examples presented here have illustrated a common use of barriers and latches: synchronizing
    </span>
    <a id="_idIndexMarker318">
    </a>
    <span class="koboSpan" id="kobo.1336.1">
     threads performing processing in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1337.1">
      different stages.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1338.1">
     Finally, we will see a mechanism to execute code just once, even if the code is called more than once from
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1339.1">
      different threads.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-95">
    <a id="_idTextAnchor094">
    </a>
    <span class="koboSpan" id="kobo.1340.1">
     Performing a task only once
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.1341.1">
     Sometimes, we need to
    </span>
    <a id="_idIndexMarker319">
    </a>
    <span class="koboSpan" id="kobo.1342.1">
     perform a certain task just one time.
    </span>
    <span class="koboSpan" id="kobo.1342.2">
     For example, in a multithreaded application, several threads may run the same function to initialize a variable.
    </span>
    <span class="koboSpan" id="kobo.1342.3">
     Any of the running threads may do it, but we want the initialization to be done
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1343.1">
      exactly once.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1344.1">
     The C++ Standard Library provides both
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1345.1">
      std::once_flag
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1346.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1347.1">
      std::call_once
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1348.1">
     to implement exactly that functionality.
    </span>
    <span class="koboSpan" id="kobo.1348.2">
     We will see how to implement this functionality using atomic operations in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1349.1">
      next chapter.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1350.1">
     The following example will help us to understand how to use
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1351.1">
      std::once_flag
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1352.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1353.1">
      std::call_once
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1354.1">
     to achieve our goal of performing a task just one time when more than one thread tries to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1355.1">
      do it:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1356.1">
#include &lt;exception&gt;
#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;
int main() {
    std::once_flag run_once_flag;
    std::once_flag run_once_exceptions_flag;
    auto thread_function = [&amp;] {
        std::call_once(run_once_flag, []{
            std::cout &lt;&lt; "This must run just once\n";
        });
    };
    std::jthread t1(thread_function);
    std::jthread t2(thread_function);
    std::jthread t3(thread_function);
    auto function_throws = [&amp;](bool throw_exception) {
        if (throw_exception) {
            std::cout &lt;&lt; "Throwing exception\n";
            throw std::runtime_error("runtime error");
        }
        std::cout &lt;&lt; "No exception was thrown\n";
    };
    auto thread_function_1 = [&amp;](bool throw_exception) {
        try {
            std::call_once(run_once_exceptions_flag,
                           function_throws,
                           throw_exception);
        }
        catch (...) {
        }
    };
    std::jthread t4(thread_function_1, true);
    std::jthread t5(thread_function_1, true);
    std::jthread t6(thread_function_1, false);
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1357.1">
     In the first part of the example, three threads,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1358.1">
      t1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1359.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1360.1">
      t2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1361.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1362.1">
      t3
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1363.1">
     , run the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1364.1">
      thread_function
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1365.1">
     function.
    </span>
    <span class="koboSpan" id="kobo.1365.2">
     This function calls a lambda from
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1366.1">
      std::call_once
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1367.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1367.2">
     If you run the example, you
    </span>
    <a id="_idIndexMarker320">
    </a>
    <span class="koboSpan" id="kobo.1368.1">
     will see that the message
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1369.1">
      This must run just once
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1370.1">
     is printed only one time,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1371.1">
      as expected.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1372.1">
     In the second part of the example, again, three threads,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1373.1">
      t4
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1374.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1375.1">
      t5
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1376.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1377.1">
      t6
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1378.1">
     , run the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1379.1">
      thread_function_1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1380.1">
     function.
    </span>
    <span class="koboSpan" id="kobo.1380.2">
     This function calls
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1381.1">
      function_throws
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1382.1">
     , which depending on a parameter may throw or not throw an exception.
    </span>
    <span class="koboSpan" id="kobo.1382.2">
     This code shows that, if the function called from
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1383.1">
      std::call_once
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1384.1">
     does not terminate successfully, then it doesn’t count as done and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1385.1">
      std::call_once
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1386.1">
     should be called again.
    </span>
    <span class="koboSpan" id="kobo.1386.2">
     Only a successful function counts as a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1387.1">
      run function.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1388.1">
     This final section showed a simple mechanism we can use to ensure that a function is executed exactly once, even
    </span>
    <a id="_idIndexMarker321">
    </a>
    <span class="koboSpan" id="kobo.1389.1">
     if it is called more than once from the same or a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1390.1">
      different thread.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-96">
    <a id="_idTextAnchor095">
    </a>
    <span class="koboSpan" id="kobo.1391.1">
     Summary
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.1392.1">
     In this chapter, we learned how to use the lock-based synchronization primitives provided by the C++
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1393.1">
      Standard Library.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1394.1">
     We started with an explanation of race conditions and the need for mutual exclusion.
    </span>
    <span class="koboSpan" id="kobo.1394.2">
     Then, we studied
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1395.1">
      std::mutex
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1396.1">
     and how to use it to solve race conditions.
    </span>
    <span class="koboSpan" id="kobo.1396.2">
     We also learned about the main problems when synchronizing with locks: deadlock
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1397.1">
      and livelock.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1398.1">
     After learning about mutexes, we studied condition variables and implemented a synchronized queue using mutex and condition variables.
    </span>
    <span class="koboSpan" id="kobo.1398.2">
     Finally, we saw the new synchronization primitives introduced in C++20: semaphores, latches,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1399.1">
      and barriers.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1400.1">
     Finally, we studied the mechanisms provided by the C++ Standard Library to run a function just
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1401.1">
      one time.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1402.1">
     In this chapter, we learned about the basic building blocks of thread synchronization and the foundation of asynchronous programming with multiple threads.
    </span>
    <span class="koboSpan" id="kobo.1402.2">
     Lock-based thread synchronization is the most used method to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1403.1">
      synchronize threads.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1404.1">
     In the next chapter, we will study lock-free thread synchronization.
    </span>
    <span class="koboSpan" id="kobo.1404.2">
     We will start with a review of atomicity, atomic operations, and atomic types provided by the C++20 Standard Library.
    </span>
    <span class="koboSpan" id="kobo.1404.3">
     We will show an implementation of a lock-free bound single-producer-single-consumer queue.
    </span>
    <span class="koboSpan" id="kobo.1404.4">
     We will also introduce the C++
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1405.1">
      memory model.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-97">
    <a id="_idTextAnchor096">
    </a>
    <span class="koboSpan" id="kobo.1406.1">
     Further reading
    </span>
   </h1>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.1407.1">
      David R.
     </span>
     <span class="koboSpan" id="kobo.1407.2">
      Butenhof,
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.1408.1">
       Programming with POSIX Threads
      </span>
     </em>
     <span class="koboSpan" id="kobo.1409.1">
      , Addison
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1410.1">
       Wesley, 1997.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1411.1">
      Anthony Williams,
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.1412.1">
       C++ Concurrency in Action
      </span>
     </em>
     <span class="koboSpan" id="kobo.1413.1">
      , Second Edition,
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1414.1">
       Manning, 2019.
      </span>
     </span>
    </li>
   </ul>
  </div>
 </body></html>