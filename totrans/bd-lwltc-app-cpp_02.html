<html><head></head><body>
<div id="_idContainer019">
<h1 class="chapter-number" id="_idParaDest-36"><a id="_idTextAnchor035"/><span class="koboSpan" id="kobo.1.1">2</span></h1>
<h1 id="_idParaDest-37"><a id="_idTextAnchor036"/><span class="koboSpan" id="kobo.2.1">Designing Some Common Low Latency Applications in C++</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In this chapter, we will look at some applications in different fields from video streaming, online gaming, real-time data analysis, and electronic trading. </span><span class="koboSpan" id="kobo.3.2">We will understand their behavior, and what features need to be executed in real time under extremely low-latency considerations. </span><span class="koboSpan" id="kobo.3.3">We will introduce the electronic trading ecosystem, since we will use that as a case study in the rest of the book, and build a system from scratch in C++, with a focus on understanding and using low </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">latency ideas.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">Understanding low latency performance in live video </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">streaming applications</span></span></li>
<li><span class="koboSpan" id="kobo.9.1">Understanding which low latency constraints matter in </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">gaming applications</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Discussing the design of Internet-of-Things (IoT) and retail </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">analytics systems</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Exploring low latency </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">electronic trading</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.15.1">This chapter’s goal is to dig into some of the technical aspects of low latency applications in different business areas. </span><span class="koboSpan" id="kobo.15.2">By the end of this chapter, you should be able to understand and appreciate the technical challenges that applications such as real-time video streaming, offline and online gaming applications, IoT machines and applications, and electronic trading face. </span><span class="koboSpan" id="kobo.15.3">You will be able to understand the different solutions that advancements in technology provide to solve these problems and make these businesses viable </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">and profitable.</span></span></p>
<h1 id="_idParaDest-38"><a id="_idTextAnchor037"/><span class="koboSpan" id="kobo.17.1">Understanding low latency performance in live video streaming applications</span></h1>
<p><span class="koboSpan" id="kobo.18.1">In this section, we will </span><a id="_idIndexMarker128"/><span class="koboSpan" id="kobo.19.1">first discuss</span><a id="_idIndexMarker129"/><span class="koboSpan" id="kobo.20.1"> the details behind low latency performance in the context of video streaming applications. </span><span class="koboSpan" id="kobo.20.2">We will define the important concepts and terms relevant to live video streaming to build an understanding of the field and business use cases. </span><span class="koboSpan" id="kobo.20.3">We will understand what causes latencies in these applications and the business impact of those. </span><span class="koboSpan" id="kobo.20.4">Finally, we </span><a id="_idIndexMarker130"/><span class="koboSpan" id="kobo.21.1">will discuss</span><a id="_idIndexMarker131"/><span class="koboSpan" id="kobo.22.1"> technologies, platforms, and solutions to build and support low latency video </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">streaming applications.</span></span></p>
<h2 id="_idParaDest-39"><a id="_idTextAnchor038"/><span class="koboSpan" id="kobo.24.1">Defining important concepts in low latency streaming</span></h2>
<p><span class="koboSpan" id="kobo.25.1">Here, we will first</span><a id="_idIndexMarker132"/><span class="koboSpan" id="kobo.26.1"> define a few important concepts and terms when it comes to low latency streaming applications. </span><span class="koboSpan" id="kobo.26.2">Let us get started with a few basics and build up from there into more </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">complex concepts.</span></span></p>
<h3><span class="koboSpan" id="kobo.28.1">Latency in video streaming</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.29.1">Video streaming</span></strong><span class="koboSpan" id="kobo.30.1"> is </span><a id="_idIndexMarker133"/><span class="koboSpan" id="kobo.31.1">defined as audio-video content delivered in real time or near real time. </span><span class="koboSpan" id="kobo.31.2">Latency in general refers to the time delay between an input event and the output event. </span><span class="koboSpan" id="kobo.31.3">In the context of live video streaming applications, latency refers specifically to the time from when a live video stream hits the camera on the recording device and then gets transported to the target audience’s screens and gets rendered and displayed there. </span><span class="koboSpan" id="kobo.31.4">It should be easy to intuitively understand why this is also referred to as </span><strong class="bold"><span class="koboSpan" id="kobo.32.1">glass-to-glass latency</span></strong><span class="koboSpan" id="kobo.33.1"> in </span><a id="_idIndexMarker134"/><span class="koboSpan" id="kobo.34.1">the context of live video streaming applications. </span><span class="koboSpan" id="kobo.34.2">Glass-to-glass latency in video streaming applications is quite important regardless of the actual application, whether it be a video call, live video streams for other applications, or online video game rendering. </span><span class="koboSpan" id="kobo.34.3">In live streaming, video latency</span><a id="_idIndexMarker135"/><span class="koboSpan" id="kobo.35.1"> is basically the delay between when the video frame</span><a id="_idIndexMarker136"/><span class="koboSpan" id="kobo.36.1"> captures at the recorder’s side to when the video frame is displayed at the viewer’s side. </span><span class="koboSpan" id="kobo.36.2">Another commonly encountered term is </span><strong class="bold"><span class="koboSpan" id="kobo.37.1">lag</span></strong><span class="koboSpan" id="kobo.38.1">, which </span><a id="_idIndexMarker137"/><span class="koboSpan" id="kobo.39.1">often just refers to a higher-than-expected glass-to-glass latency, which the user may perceive as reduced or </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">jittery performance.</span></span></p>
<h3><span class="koboSpan" id="kobo.41.1">Video distribution services and content delivery networks</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.42.1">Video distribution service</span></strong><span class="koboSpan" id="kobo.43.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.44.1">VDS</span></strong><span class="koboSpan" id="kobo.45.1">) is a</span><a id="_idIndexMarker138"/><span class="koboSpan" id="kobo.46.1"> fancy term for a relatively easy-to-understand concept. </span><span class="koboSpan" id="kobo.46.2">A VDS basically means the system responsible for taking multiple incoming streams of video and audio from the sources and presenting them to the viewers. </span><span class="koboSpan" id="kobo.46.3">One of the most well-known examples of a VDS would be a </span><strong class="bold"><span class="koboSpan" id="kobo.47.1">content delivery network</span></strong><span class="koboSpan" id="kobo.48.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.49.1">CDN</span></strong><span class="koboSpan" id="kobo.50.1">). </span><span class="koboSpan" id="kobo.50.2">A CDN is a means of efficiently distributing</span><a id="_idIndexMarker139"/><span class="koboSpan" id="kobo.51.1"> context across </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">the globe.</span></span></p>
<h3><span class="koboSpan" id="kobo.53.1">Transcoding, transmuxing, and transrating</span></h3>
<p><span class="koboSpan" id="kobo.54.1">Let us discuss three concepts that relate to encoding the </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">audio-video stream:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.56.1">Transcoding</span></strong><span class="koboSpan" id="kobo.57.1"> refers to the </span><a id="_idIndexMarker140"/><span class="koboSpan" id="kobo.58.1">process of decoding a media stream from one format (so lower-level details such as codec, video size, sampling rates, encoder formats, etc.) and possibly recoding it in a different format or with </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">different parameters.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.60.1">Transmuxing</span></strong><span class="koboSpan" id="kobo.61.1"> is similar to</span><a id="_idIndexMarker141"/><span class="koboSpan" id="kobo.62.1"> transcoding but here, the delivery format changes without any changes to the encoding, as in the case </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">of transcoding.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.64.1">Transrating</span></strong><span class="koboSpan" id="kobo.65.1"> is also </span><a id="_idIndexMarker142"/><span class="koboSpan" id="kobo.66.1">similar to transcoding, but we change the video bitrate; usually, it is compressed to a lower value. </span><span class="koboSpan" id="kobo.66.2">The video bitrate is the number of bits (or kilobits) being transferred per second and captures the information and quality in the </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">video stream.</span></span></li>
<li><span class="koboSpan" id="kobo.68.1">In the next section, we will understand the sources of latencies in low latency video </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">streaming applications.</span></span></li>
</ul>
<h2 id="_idParaDest-40"><a id="_idTextAnchor039"/><span class="koboSpan" id="kobo.70.1">Understanding sources of latency in video streaming applications</span></h2>
<p><span class="koboSpan" id="kobo.71.1">Let us look at the</span><a id="_idIndexMarker143"/><span class="koboSpan" id="kobo.72.1"> details of what happens in the glass-to-glass journey. </span><span class="koboSpan" id="kobo.72.2">Our ultimate motivation in this section is to understand the sources of latencies in video streaming applications. </span><span class="koboSpan" id="kobo.72.3">This figure describes at a high level what happens in the glass-to-glass journey from the camera to </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">the display:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer015">
<span class="koboSpan" id="kobo.74.1"><img alt="Figure 2.1 – Glass-to-glass journey in live video streaming applications" src="image/Figure_2.1_B19434.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.75.1">Figure 2.1 – Glass-to-glass journey in live video streaming applications</span></p>
<h3><span class="koboSpan" id="kobo.76.1">Discussing the steps in the glass-to-glass journey</span></h3>
<p><span class="koboSpan" id="kobo.77.1">We will begin by understanding all the steps and components involved in the glass-to-glass journey of low latency video streaming applications. </span><span class="koboSpan" id="kobo.77.2">There are two forms of latency – the initial startup latency and then the lag between video frames once the live stream starts. </span><span class="koboSpan" id="kobo.77.3">Typically for the</span><a id="_idIndexMarker144"/><span class="koboSpan" id="kobo.78.1"> user experience, a slightly longer startup latency is much preferred over lag between video frames, but there is usually a trade-off in trying to reduce one latency over the other. </span><span class="koboSpan" id="kobo.78.2">So, we need to understand which metric is more important for a specific use case and adjust the design and technical details appropriately. </span><span class="koboSpan" id="kobo.78.3">The following are the steps in the glass-to-glass journey from the broadcaster to </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">the receivers:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.80.1">Camera capturing and processing the audio and video at </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">the broadcaster</span></span></li>
<li><span class="koboSpan" id="kobo.82.1">Video consumption and packaging at </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">the broadcaster</span></span></li>
<li><span class="koboSpan" id="kobo.84.1">Encoders transcoding, transmuxing, and transrating </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">the content</span></span></li>
<li><span class="koboSpan" id="kobo.86.1">Sending the data over the network over the </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">appropriate protocol(s)</span></span></li>
<li><span class="koboSpan" id="kobo.88.1">Distribution over a VDS such as </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">a CDN</span></span></li>
<li><span class="koboSpan" id="kobo.90.1">Reception at the receivers </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">and buffering</span></span></li>
<li><span class="koboSpan" id="kobo.92.1">Decoding the content on the </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">viewer’s device</span></span></li>
<li><span class="koboSpan" id="kobo.94.1">Dealing with packet drops, network changes, and so on at the </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">receiver end</span></span></li>
<li><span class="koboSpan" id="kobo.96.1">Rendering of the audio-video content on the viewer’s device </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">of choice</span></span></li>
<li><span class="koboSpan" id="kobo.98.1">Possibly collecting interactive inputs (selections, audio, video, etc.) from the viewer for interactive applications and sending them back to the broadcaster </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">where</span></span><span class="No-Break"><a id="_idIndexMarker145"/></span><span class="No-Break"><span class="koboSpan" id="kobo.100.1"> needed</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.101.1">Now that we have described the details behind content delivery from the sender to the receiver and possibly back to the sender, in the next section, we will describe where we have possibilities of latencies on that path. </span><span class="koboSpan" id="kobo.101.2">Typically, each step does not take a long time, but higher latencies in multiple components can accumulate and cause significant degradation in </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">user performance.</span></span></p>
<h3><span class="koboSpan" id="kobo.103.1">Describing possibilities of high latencies on the path</span></h3>
<p><span class="koboSpan" id="kobo.104.1">We will look at the reasons for</span><a id="_idIndexMarker146"/><span class="koboSpan" id="kobo.105.1"> high latencies in low latency video streaming applications. </span><span class="koboSpan" id="kobo.105.2">There are numerous reasons for this on each of the components of the glass-to-glass path we discussed in the </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">previous subsection.</span></span></p>
<h4><span class="koboSpan" id="kobo.107.1">Physical distance, server load, and internet quality</span></h4>
<ul>
<li><span class="koboSpan" id="kobo.108.1">This is an</span><a id="_idIndexMarker147"/><span class="koboSpan" id="kobo.109.1"> obvious one: the physical distance between the source and destination will affect the glass-to-glass latency. </span><span class="koboSpan" id="kobo.109.2">This is sometimes very obvious when streaming videos from a </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">different country.</span></span></li>
<li><span class="koboSpan" id="kobo.111.1">In addition to the distance, the quality of the internet connection itself can affect the streaming latency. </span><span class="koboSpan" id="kobo.111.2">Slow or limited bandwidth connections lead to instability, buffering, </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">and lags.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.113.1">Depending on how many </span><a id="_idIndexMarker148"/><span class="koboSpan" id="kobo.114.1">users are simultaneously streaming the videos and how much load that puts on the servers involved in the streaming path, the latency and user experience can vary. </span><span class="koboSpan" id="kobo.114.2">Overloaded servers </span><a id="_idIndexMarker149"/><span class="koboSpan" id="kobo.115.1">lead to slower response times, higher latencies, buffering, and lag and can even make the streaming come to a </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">grinding halt.</span></span></p>
<h4><span class="koboSpan" id="kobo.117.1">Capture equipment and hardware</span></h4>
<p><span class="koboSpan" id="kobo.118.1">The video and </span><a id="_idIndexMarker150"/><span class="koboSpan" id="kobo.119.1">audio capture devices have a big impact on the glass-to-glass latencies. </span><span class="koboSpan" id="kobo.119.2">Taking an audio and video frame and turning it into digital signals takes time. </span><span class="koboSpan" id="kobo.119.3">Advanced systems such as recorders, encoders, processors, re-encoders, decoders, and re-transmitters have a significant impact on the final user experience. </span><span class="koboSpan" id="kobo.119.4">The capture equipment and hardware will determine the </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">latency values.</span></span></p>
<h4><span class="koboSpan" id="kobo.121.1">Streaming protocol, transmission, and jitter buffer</span></h4>
<p><span class="koboSpan" id="kobo.122.1">Given the availability of different streaming protocols (as we will discuss shortly), the final choice can determine the latency of video streaming applications. </span><span class="koboSpan" id="kobo.122.2">If the protocol is not optimized for dynamic adaptive streaming, it can increase delays. </span><span class="koboSpan" id="kobo.122.3">Overall, there are two</span><a id="_idIndexMarker151"/><span class="koboSpan" id="kobo.123.1"> categories of protocols for live video streaming – HTTP-based and non-HTTP-based – and there are differences in latencies and scalability between the two broad options, which will change the performance of the </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">final system.</span></span></p>
<p><span class="koboSpan" id="kobo.125.1">The internet routes</span><a id="_idIndexMarker152"/><span class="koboSpan" id="kobo.126.1"> chosen on the way through the VDS can change the glass-to-glass latency. </span><span class="koboSpan" id="kobo.126.2">These routes can also change over time, and packets can be queued on some hops and can even arrive out of order at the receiver. </span><span class="koboSpan" id="kobo.126.3">The software that handles these issues is known as a </span><strong class="bold"><span class="koboSpan" id="kobo.127.1">jitter buffer</span></strong><span class="koboSpan" id="kobo.128.1">. </span><span class="koboSpan" id="kobo.128.2">If the</span><a id="_idIndexMarker153"/><span class="koboSpan" id="kobo.129.1"> CDN has</span><a id="_idIndexMarker154"/><span class="koboSpan" id="kobo.130.1"> issues, that can also cause additional delays. </span><span class="koboSpan" id="kobo.130.2">Then, there are constraints such as the encoded bitrate (lower bitrates mean less data being transferred per unit time and lead to lower latencies), which can change the </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">latencies encountered.</span></span></p>
<h4><span class="koboSpan" id="kobo.132.1">Encoding – transcoding and transrating</span></h4>
<p><span class="koboSpan" id="kobo.133.1">The encoding </span><a id="_idIndexMarker155"/><span class="koboSpan" id="kobo.134.1">process determines the compression, format, and so on of the final video output, and the choice and quality of encoding protocols will have a huge impact on the performance. </span><span class="koboSpan" id="kobo.134.2">Also, there are many options for viewer devices (TVs, phones, PCs, Macs, etc.) and networks (3G, 4G, 5G, LAN, Wi-Fi, etc.) and a streaming provider needs to implement </span><strong class="bold"><span class="koboSpan" id="kobo.135.1">adaptive bitrate</span></strong><span class="koboSpan" id="kobo.136.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.137.1">ABR</span></strong><span class="koboSpan" id="kobo.138.1">) to </span><a id="_idIndexMarker156"/><span class="koboSpan" id="kobo.139.1">handle these efficiently. </span><span class="koboSpan" id="kobo.139.2">The computer or server running the encoder needs to have adequate CPU and memory resources for the encoding process to keep up with the incoming audio-video data. </span><span class="koboSpan" id="kobo.139.3">Whether we use encoding software on a computer or encoding hardware such</span><a id="_idIndexMarker157"/><span class="koboSpan" id="kobo.140.1"> as </span><em class="italic"><span class="koboSpan" id="kobo.141.1">BoxCaster</span></em><span class="koboSpan" id="kobo.142.1"> or </span><em class="italic"><span class="koboSpan" id="kobo.143.1">Teradek</span></em><span class="koboSpan" id="kobo.144.1">, we</span><a id="_idIndexMarker158"/><span class="koboSpan" id="kobo.145.1"> incur processing latencies ranging from a few milliseconds to seconds. </span><span class="koboSpan" id="kobo.145.2">The tasks that the encoder needs to perform are to ingest the raw</span><a id="_idIndexMarker159"/><span class="koboSpan" id="kobo.146.1"> video data, buffer the content, and decode, process, and re-encode it before </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">forwarding it.</span></span></p>
<h4><span class="koboSpan" id="kobo.148.1">Decoded and played on the viewer’s device</span></h4>
<p><span class="koboSpan" id="kobo.149.1">Assuming the</span><a id="_idIndexMarker160"/><span class="koboSpan" id="kobo.150.1"> content makes it to the viewer’s device without incurring noticeable latencies, the client still must decode, playback, and render the content. </span><span class="koboSpan" id="kobo.150.2">Video players do not render video segments one at a time as they receive them, but instead, have a buffer of received segments, usually in memory. </span><span class="koboSpan" id="kobo.150.3">This means several segments are buffered before the video begins to play and, depending on the actual size of the segment chosen, can cause latency on the end user side. </span><span class="koboSpan" id="kobo.150.4">For instance, if we choose a segment length that contains 10 seconds of video, the player at the end user must at least receive a complete segment before it can play it and will introduce an extra 10-second delay between the sender and receiver. </span><span class="koboSpan" id="kobo.150.5">Typically, these segments are between 2 and 10 seconds, trying to balance between optimizing network efficiency and glass-to-glass latency. </span><span class="koboSpan" id="kobo.150.6">Obviously, factors such as the viewer’s device, platform, hardware, CPU, memory, and player efficiency can add to the </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">glass-to-glass latencies.</span></span></p>
<h2 id="_idParaDest-41"><a id="_idTextAnchor040"/><span class="koboSpan" id="kobo.152.1">Measuring latencies in low latency video streaming</span></h2>
<p><span class="koboSpan" id="kobo.153.1">Measuring </span><a id="_idIndexMarker161"/><span class="koboSpan" id="kobo.154.1">latencies in low latency video</span><a id="_idIndexMarker162"/><span class="koboSpan" id="kobo.155.1"> streaming applications is not extremely complicated, since the latency range we care about should at least be a few seconds to be perceptible to the end user as a delay or lag. </span><span class="koboSpan" id="kobo.155.2">The easiest ways to measure end-to-end video latency are </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.157.1">The first place to start would be to use </span><a id="_idIndexMarker163"/><span class="koboSpan" id="kobo.158.1">a </span><strong class="bold"><span class="koboSpan" id="kobo.159.1">clapperboard</span></strong><span class="koboSpan" id="kobo.160.1"> application. </span><span class="koboSpan" id="kobo.160.2">A clapperboard is a tool used to synchronize video and audio during filmmaking, and apps are available to detect synchronization issues between two streams due </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">to latency.</span></span></li>
<li><span class="koboSpan" id="kobo.162.1">Another option is to publish the video stream back to yourself to measure whether there are any latencies in the capturing, encoding, decoding, and rendering steps by taking the network out </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">of it.</span></span></li>
<li><span class="koboSpan" id="kobo.164.1">An obvious solution is to take a screenshot of two screens running the same live stream to </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">spot differences.</span></span></li>
<li><span class="koboSpan" id="kobo.166.1">The best</span><a id="_idIndexMarker164"/><span class="koboSpan" id="kobo.167.1"> solution to measure live</span><a id="_idIndexMarker165"/><span class="koboSpan" id="kobo.168.1"> video streaming latencies is to add a timestamp to the video stream itself at the source and then the receiver can use that to determine the glass-to-glass latencies. </span><span class="koboSpan" id="kobo.168.2">Obviously, the clocks used by the sender and the receiver need to be synchronized with each other </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">reasonably well.</span></span></li>
</ul>
<h2 id="_idParaDest-42"><a id="_idTextAnchor041"/><span class="koboSpan" id="kobo.170.1">Understanding the impact of high latencies</span></h2>
<p><span class="koboSpan" id="kobo.171.1">Before we understand the impact of high latencies on low latency video streaming applications, first, we need to define what the acceptable latency is for different applications. </span><span class="koboSpan" id="kobo.171.2">For video streaming applications that do not require a lot of real-time interactions, anything up to 5 seconds is acceptable. </span><span class="koboSpan" id="kobo.171.3">For streaming applications that need to support live and interactive use cases, anything up to 1 second is enough for the users. </span><span class="koboSpan" id="kobo.171.4">Obviously, for video-on-demand, latency is not an issue since it is pre-recorded and there is no live-streaming component. </span><span class="koboSpan" id="kobo.171.5">Overall, high latency in real-time live-streaming applications negatively impacts an end user’s experience. </span><span class="koboSpan" id="kobo.171.6">The key motivation for real time is that viewers want to feel connected and get the feeling of being in person. </span><span class="koboSpan" id="kobo.171.7">Large delays in receiving and rendering the content destroy the feeling of watching something in real time. </span><span class="koboSpan" id="kobo.171.8">One of the most annoying experiences occurs when a real-time video regularly pauses and buffers due </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">to latencies.</span></span></p>
<p><span class="koboSpan" id="kobo.173.1">Let us briefly discuss the main negative impacts of real-time video streaming applications due </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">to latency.</span></span></p>
<h3><span class="koboSpan" id="kobo.175.1">Low audio-video quality</span></h3>
<p><span class="koboSpan" id="kobo.176.1">If the</span><a id="_idIndexMarker166"/><span class="koboSpan" id="kobo.177.1"> components of the streaming system cannot achieve real-time latencies, that usually leads to higher levels of compression. </span><span class="koboSpan" id="kobo.177.2">Due to the high levels of compression on the audio-video data, the audio quality can sound scrambled and scratchy at times and the video quality can be blurry and pixelated, so it's just a worse user </span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">experience overall.</span></span></p>
<h3><span class="koboSpan" id="kobo.179.1">Buffering pauses and delays</span></h3>
<p><span class="koboSpan" id="kobo.180.1">Buffering is one </span><a id="_idIndexMarker167"/><span class="koboSpan" id="kobo.181.1">of the worst things that can ruin the user experience since the viewer experiences a jittery performance with constant pauses instead of having a smooth experience. </span><span class="koboSpan" id="kobo.181.2">This is very frustrating for viewers if a video keeps pausing to buffer and catch up, and will likely lead to the viewer quitting the video, the platform, or the business itself and </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">never returning.</span></span></p>
<h3><span class="koboSpan" id="kobo.183.1">Audio-video synchronization issues</span></h3>
<p><span class="koboSpan" id="kobo.184.1">In many</span><a id="_idIndexMarker168"/><span class="koboSpan" id="kobo.185.1"> implementations of real-time audio-video streaming applications, the audio data is sent separately from the video data and thus the audio data can reach the receiver faster than the video data. </span><span class="koboSpan" id="kobo.185.2">This is because by its nature, audio data is smaller in size than video data, and due to high latencies, video data might lag behind audio data at the receiver’s end. </span><span class="koboSpan" id="kobo.185.3">This leads to problems with synchronization and hurts the viewer’s experience with real-time </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">video streaming.</span></span></p>
<h3><span class="koboSpan" id="kobo.187.1">Playback – rewinding and fast-forwarding</span></h3>
<p><span class="koboSpan" id="kobo.188.1">High</span><a id="_idIndexMarker169"/><span class="koboSpan" id="kobo.189.1"> latencies can cause issues with rewinding and fast-forwarding, even when the applications aren’t necessarily in 100% real time. </span><span class="koboSpan" id="kobo.189.2">This is because the audio-video data will have to be resent so that the end user’s player can re-sync with the newly </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">selected location.</span></span></p>
<h2 id="_idParaDest-43"><a id="_idTextAnchor042"/><span class="koboSpan" id="kobo.191.1">Exploring technologies for low latency video streaming</span></h2>
<p><span class="koboSpan" id="kobo.192.1">In this section, we will look at </span><a id="_idIndexMarker170"/><span class="koboSpan" id="kobo.193.1">different technology protocols that apply to the encoding, decoding, streaming, and distribution of audio-video data. </span><span class="koboSpan" id="kobo.193.2">These protocols are specially designed for low latency video streaming applications and platforms. </span><span class="koboSpan" id="kobo.193.3">These protocols fall into one of two broad categories – HTTP-based protocols </span><a id="_idIndexMarker171"/><span class="koboSpan" id="kobo.194.1">and non-HTTP-based protocols – but for low latency video streaming, typically, HTTP-based protocols are the way to go, as we will see in </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">this section.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer016">
<span class="koboSpan" id="kobo.196.1"><img alt="Figure 2.2 – Live video streaming latencies and technologies" src="image/Figure_2.2_B19434.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.197.1">Figure 2.2 – Live video streaming latencies and technologies</span></p>
<h3><span class="koboSpan" id="kobo.198.1">Non-HTTP-based protocols</span></h3>
<p><span class="koboSpan" id="kobo.199.1">Non-HTTP-based protocols use</span><a id="_idIndexMarker172"/><span class="koboSpan" id="kobo.200.1"> a combination </span><a id="_idIndexMarker173"/><span class="koboSpan" id="kobo.201.1">of </span><strong class="bold"><span class="koboSpan" id="kobo.202.1">User Datagram Protocol</span></strong><span class="koboSpan" id="kobo.203.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.204.1">UDP</span></strong><span class="koboSpan" id="kobo.205.1">) and </span><strong class="bold"><span class="koboSpan" id="kobo.206.1">Transmission Control Protocol</span></strong><span class="koboSpan" id="kobo.207.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.208.1">TCP</span></strong><span class="koboSpan" id="kobo.209.1">) to </span><a id="_idIndexMarker174"/><span class="koboSpan" id="kobo.210.1">transfer data from the sender to the receiver. </span><span class="koboSpan" id="kobo.210.2">These protocols can be</span><a id="_idIndexMarker175"/><span class="koboSpan" id="kobo.211.1"> used for low latency applications, but many do not have advanced support for adaptive streaming technology and</span><a id="_idIndexMarker176"/><span class="koboSpan" id="kobo.212.1"> suffer from limited</span><a id="_idIndexMarker177"/><span class="koboSpan" id="kobo.213.1"> scalability. </span><span class="koboSpan" id="kobo.213.2">Two </span><a id="_idIndexMarker178"/><span class="koboSpan" id="kobo.214.1">examples of these protocols are </span><strong class="bold"><span class="koboSpan" id="kobo.215.1">Real-Time Streaming Protocol</span></strong><span class="koboSpan" id="kobo.216.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.217.1">RTSP</span></strong><span class="koboSpan" id="kobo.218.1">) and </span><strong class="bold"><span class="koboSpan" id="kobo.219.1">Real-Time Messaging Protocol</span></strong><span class="koboSpan" id="kobo.220.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.221.1">RTMP</span></strong><span class="koboSpan" id="kobo.222.1">), which we </span><a id="_idIndexMarker179"/><span class="koboSpan" id="kobo.223.1">will </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">discuss next.</span></span></p>
<h4><span class="koboSpan" id="kobo.225.1">RTSP</span></h4>
<p><span class="koboSpan" id="kobo.226.1">RTSP is an </span><a id="_idIndexMarker180"/><span class="koboSpan" id="kobo.227.1">application layer protocol that was used for the low latency</span><a id="_idIndexMarker181"/><span class="koboSpan" id="kobo.228.1"> streaming of videos. </span><span class="koboSpan" id="kobo.228.2">It also has playback capabilities to allow playing and pausing the video content and can handle multiple data streams. </span><span class="koboSpan" id="kobo.228.3">This, however, is no longer popular today and has been replaced by other more modern protocols, which we will see in later sections. </span><span class="koboSpan" id="kobo.228.4">RTSP was replaced by modern protocols such as HLS and DASH because a lot of receivers did not support RTSP; it was incompatible with HTTP and lost popularity with the advent of web-based </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">streaming applications.</span></span></p>
<h4><span class="koboSpan" id="kobo.230.1">Flash and RTMP</span></h4>
<p><span class="koboSpan" id="kobo.231.1">Flash-based applications were very popular once upon a time. </span><span class="koboSpan" id="kobo.231.2">They use RTMP and work well for low latency </span><a id="_idIndexMarker182"/><span class="koboSpan" id="kobo.232.1">streaming use cases. </span><span class="koboSpan" id="kobo.232.2">However, Flash</span><a id="_idIndexMarker183"/><span class="koboSpan" id="kobo.233.1"> as a technology has declined a lot in popularity for many </span><a id="_idIndexMarker184"/><span class="koboSpan" id="kobo.234.1">reasons, mostly security-related. </span><span class="koboSpan" id="kobo.234.2">Web browsers as well as CDNs have removed support</span><a id="_idIndexMarker185"/><span class="koboSpan" id="kobo.235.1"> for RTMP because it did not scale too well as demand grew. </span><span class="koboSpan" id="kobo.235.2">RTMP is a streaming protocol that accomplishes low latencies in streaming but, as mentioned before, is being replaced by other </span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">technologies now.</span></span></p>
<h3><span class="koboSpan" id="kobo.237.1">HTTP-based protocols</span></h3>
<p><span class="koboSpan" id="kobo.238.1">HTTP-based </span><a id="_idIndexMarker186"/><span class="koboSpan" id="kobo.239.1">protocols typically </span><a id="_idIndexMarker187"/><span class="koboSpan" id="kobo.240.1">break down the continuous stream of audio-video data into small segments of 2 to 10 seconds in length. </span><span class="koboSpan" id="kobo.240.2">These segments are then transported through a CDN or a web service. </span><span class="koboSpan" id="kobo.240.3">These are the preferred protocols for low latency live streaming applications since they are still acceptably low latency but also feature-rich and scale better. </span><span class="koboSpan" id="kobo.240.4">These protocols, however, do have a disadvantage that we have mentioned before: the latency incurred depends on the length of the segments. </span><span class="koboSpan" id="kobo.240.5">The minimum latency is at least the length of the segment because the receiver needs to receive at least one full segment before it can play it. </span><span class="koboSpan" id="kobo.240.6">In some cases, the latency can be in the order of multiples of segment length depending on the video player devices’ implementation. </span><span class="koboSpan" id="kobo.240.7">For example, iOS buffers at least three to five segments before playing the first segment to ensure </span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">smooth rendering.</span></span></p>
<p><span class="koboSpan" id="kobo.242.1">Some examples</span><a id="_idIndexMarker188"/><span class="koboSpan" id="kobo.243.1"> of HTTP-based protocols are </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">as follows:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.245.1">HTTP Live </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.246.1">Streaming</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.247.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.248.1">HLS</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.249.1">)</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.250.1">HTTP Dynamic </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.251.1">Streaming</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.252.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.253.1">HDS</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">)</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.255.1">Microsoft Smooth </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.256.1">Streaming</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.257.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.258.1">MSS</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">)</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.260.1">Dynamic Adaptive Streaming over </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.261.1">HTTP</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.262.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.263.1">DASH</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">)</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.265.1">Common Media Application </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.266.1">Format</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.267.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.268.1">CMAF</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">)</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.270.1">High-Efficiency Stream </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.271.1">Protocol</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.272.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.273.1">HESP</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.274.1">)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.275.1">We will discuss some of these protocols in this section to understand how they work and how they achieve low latency performance in real-time video streaming applications. </span><span class="koboSpan" id="kobo.275.2">Overall, these protocols are designed to scale to millions of simultaneous receivers and support adaptive streaming and playback. </span><span class="koboSpan" id="kobo.275.3">HTTP-based streaming protocols use </span><a id="_idIndexMarker189"/><span class="koboSpan" id="kobo.276.1">communication over standard HTTP protocol and require a server for distribution. </span><span class="koboSpan" id="kobo.276.2">In </span><a id="_idIndexMarker190"/><span class="koboSpan" id="kobo.277.1">contrast to that, </span><strong class="bold"><span class="koboSpan" id="kobo.278.1">Web Real-Time Communication</span></strong><span class="koboSpan" id="kobo.279.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.280.1">WebRTC</span></strong><span class="koboSpan" id="kobo.281.1">), which we will explore </span><a id="_idIndexMarker191"/><span class="koboSpan" id="kobo.282.1">later, is a </span><strong class="bold"><span class="koboSpan" id="kobo.283.1">Peer-to-Peer</span></strong><span class="koboSpan" id="kobo.284.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.285.1">P2P</span></strong><span class="koboSpan" id="kobo.286.1">) protocol that can technically establish direct communication between two machines and skip the need for an intermediate machine </span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">or server.</span></span></p>
<h4><span class="koboSpan" id="kobo.288.1">HLS</span></h4>
<p><span class="koboSpan" id="kobo.289.1">HLS is</span><a id="_idIndexMarker192"/><span class="koboSpan" id="kobo.290.1"> used both for real-time and on-demand</span><a id="_idIndexMarker193"/><span class="koboSpan" id="kobo.291.1"> audio-video content delivery and can scale tremendously well. </span><span class="koboSpan" id="kobo.291.2">HLS is generally converted from RTMP by the video delivery platform. </span><span class="koboSpan" id="kobo.291.3">Using both RTMP and HLS is the best way to achieve low latency and stream to all devices. </span><span class="koboSpan" id="kobo.291.4">There is a variant of </span><strong class="bold"><span class="koboSpan" id="kobo.292.1">Low Latency HLS</span></strong><span class="koboSpan" id="kobo.293.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.294.1">LL-HLS</span></strong><span class="koboSpan" id="kobo.295.1">) that</span><a id="_idIndexMarker194"/><span class="koboSpan" id="kobo.296.1"> can get latencies down to under 2 seconds, but it is still experimental. </span><span class="koboSpan" id="kobo.296.2">LL-HLS enables low latency audio-video real-time streaming by exploiting the ability to stream and render partial segments instead of requiring a full segment. </span><span class="koboSpan" id="kobo.296.3">The success of HLS and LL-HLS as the most widely used ABR streaming protocols comes from scalability to many users and compatibility with most kinds of devices, browsers, </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">and players.</span></span></p>
<h4><span class="koboSpan" id="kobo.298.1">CMAF</span></h4>
<p><span class="koboSpan" id="kobo.299.1">CMAF is </span><a id="_idIndexMarker195"/><span class="koboSpan" id="kobo.300.1">relatively new; strictly speaking, it is not really a new </span><a id="_idIndexMarker196"/><span class="koboSpan" id="kobo.301.1">format but instead packages and delivers various forms of protocols for video streaming. </span><span class="koboSpan" id="kobo.301.2">It works with HTTP-based protocols such as HLS and DASH to encode, package, and decode video segments. </span><span class="koboSpan" id="kobo.301.3">This typically helps businesses by reducing storage costs and audio-video </span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">streaming latencies.</span></span></p>
<h4><span class="koboSpan" id="kobo.303.1">DASH</span></h4>
<p><span class="koboSpan" id="kobo.304.1">DASH was created from the work of</span><a id="_idIndexMarker197"/><span class="koboSpan" id="kobo.305.1"> the </span><strong class="bold"><span class="koboSpan" id="kobo.306.1">Moving Picture Experts Group</span></strong><span class="koboSpan" id="kobo.307.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.308.1">MPEG</span></strong><span class="koboSpan" id="kobo.309.1">) and is an alternative to the HLS protocol we discussed</span><a id="_idIndexMarker198"/><span class="koboSpan" id="kobo.310.1"> before. </span><span class="koboSpan" id="kobo.310.2">It</span><a id="_idIndexMarker199"/><span class="koboSpan" id="kobo.311.1"> is quite similar to HLS because it prepares different quality levels of the audio-video content and divides them into small segments to enable ABR streaming. </span><span class="koboSpan" id="kobo.311.2">Under the hood, DASH still relies on CMAF and, to be specific, one of the features it relies on is </span><strong class="bold"><span class="koboSpan" id="kobo.312.1">chunked encoding</span></strong><span class="koboSpan" id="kobo.313.1">, which</span><a id="_idIndexMarker200"/><span class="koboSpan" id="kobo.314.1"> facilitates breaking a segment into even smaller subsegments of a few milliseconds. </span><span class="koboSpan" id="kobo.314.2">The other feature it relies on is </span><strong class="bold"><span class="koboSpan" id="kobo.315.1">chunked transfer encoding</span></strong><span class="koboSpan" id="kobo.316.1">, which </span><a id="_idIndexMarker201"/><span class="koboSpan" id="kobo.317.1">takes these subsegments sent to the distribution layer and distributes them in </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">real time.</span></span></p>
<h4><span class="koboSpan" id="kobo.319.1">HESP</span></h4>
<p><span class="koboSpan" id="kobo.320.1">HESP is </span><a id="_idIndexMarker202"/><span class="koboSpan" id="kobo.321.1">another ABR </span><a id="_idIndexMarker203"/><span class="koboSpan" id="kobo.322.1">HTTP-based streaming protocol. </span><span class="koboSpan" id="kobo.322.2">This protocol has the ambitious goals of ultra-low latencies, increasing scalability, supporting currently popular CDNs, reducing bandwidth requirements, and reducing times to switch between streams (i.e., the latency to start a new audio video stream). </span><span class="koboSpan" id="kobo.322.3">Since it is extremely low latency (&lt;500 milliseconds) it is a competitor to the WebRTC protocol, but HESP can be expensive since it is not an open </span><span class="No-Break"><span class="koboSpan" id="kobo.323.1">source protocol.</span></span></p>
<p><span class="koboSpan" id="kobo.324.1">Fundamentally, the major difference in HESP relative to other protocols is that HESP relies on two streams rather than one. </span><span class="koboSpan" id="kobo.324.2">One of the streams (which only contains keyframes or snapshot frames) is known as </span><a id="_idIndexMarker204"/><span class="koboSpan" id="kobo.325.1">the </span><strong class="bold"><span class="koboSpan" id="kobo.326.1">initialization stream</span></strong><span class="koboSpan" id="kobo.327.1">. </span><span class="koboSpan" id="kobo.327.2">The other stream contains data that applies incremental changes to the frames in the initialization stream, and this stream is known as the </span><strong class="bold"><span class="koboSpan" id="kobo.328.1">continuation stream</span></strong><span class="koboSpan" id="kobo.329.1">. </span><span class="koboSpan" id="kobo.329.2">So, while</span><a id="_idIndexMarker205"/><span class="koboSpan" id="kobo.330.1"> the keyframes from the initialization stream contain snapshot data and require higher bandwidth, they support the ability to quickly seek various locations in the video during playback. </span><span class="koboSpan" id="kobo.330.2">But the continuation stream is lower-bandwidth since it only contains changes and can be used to quickly play back once the receiver video player synchronizes with the </span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">initialization stream.</span></span></p>
<p><span class="koboSpan" id="kobo.332.1">While, on </span><a id="_idIndexMarker206"/><span class="koboSpan" id="kobo.333.1">paper, HESP might </span><a id="_idIndexMarker207"/><span class="koboSpan" id="kobo.334.1">sound perfect, it has a few drawbacks such as higher costs for encoding and storing two streams instead of one, the need to encode and distribute two streams instead of one, and the need to update the players on the receivers’ platforms to decode and render the </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">two streams.</span></span></p>
<h3><span class="koboSpan" id="kobo.336.1">WebRTC</span></h3>
<p><span class="koboSpan" id="kobo.337.1">WebRTC is </span><a id="_idIndexMarker208"/><span class="koboSpan" id="kobo.338.1">regarded as the new standard in the</span><a id="_idIndexMarker209"/><span class="koboSpan" id="kobo.339.1"> real-time video streaming industry and allows subsecond latencies so can be played back on most platforms and almost every browser (such as Safari, Chrome, Opera, Firefox, etc.). </span><span class="koboSpan" id="kobo.339.2">It is a P2P protocol (i.e., it creates a direct communication channel between devices or streaming applications). </span><span class="koboSpan" id="kobo.339.3">A big advantage of WebRTC is that it does not need additional plugins to support audio-video streaming and playback. </span><span class="koboSpan" id="kobo.339.4">It also supports ABR and adaptive video quality changes for bi-directional and real-time audio-video streaming. </span><span class="koboSpan" id="kobo.339.5">Even though WebRTC uses a P2P protocol and so can establish a direct connection for conferencing, the performance is still dependent on the hardware and network quality because that is still a consideration for all protocols, regardless of whether they're P2P </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">or not.</span></span></p>
<p><span class="koboSpan" id="kobo.341.1">WebRTC does have some challenges, such as needing its own multimedia server infrastructure, the need to encrypt data that is exchanged, security protocols to handle the gaps in UDP, trying to scale worldwide cost-effectively, and the engineering complexity that comes with dealing with the several protocols that WebRTC is a </span><span class="No-Break"><span class="koboSpan" id="kobo.342.1">combination of.</span></span></p>
<h2 id="_idParaDest-44"><a id="_idTextAnchor043"/><span class="koboSpan" id="kobo.343.1">Exploring solutions and platforms for low latency streaming</span></h2>
<p><span class="koboSpan" id="kobo.344.1">In this section, we will </span><a id="_idIndexMarker210"/><span class="koboSpan" id="kobo.345.1">explore some of the most popular solutions and commercially available platforms for low latency video streaming. </span><span class="koboSpan" id="kobo.345.2">These platforms build on all the technologies we discussed in the previous section to solve a lot of the business problems associated with high latencies in real-time audio-video streaming applications. </span><span class="koboSpan" id="kobo.345.3">Note that a lot of these platforms support and use multiple underlying streaming protocols, but we will mention the ones that are primarily used for </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">these platforms.</span></span></p>
<h3><span class="koboSpan" id="kobo.347.1">Twitch</span></h3>
<p><span class="koboSpan" id="kobo.348.1">Twitch is a very</span><a id="_idIndexMarker211"/><span class="koboSpan" id="kobo.349.1"> popular online </span><a id="_idIndexMarker212"/><span class="koboSpan" id="kobo.350.1">platform, mostly used by video gamers who want to live-stream their gameplay in real time as well as interact with their target audience via chats, comments, donations, and so on. </span><span class="koboSpan" id="kobo.350.2">It goes without saying, but this requires low latency streaming as well as the ability to scale to a large community, which Twitch provides. </span><span class="koboSpan" id="kobo.350.3">Twitch uses RTMP for its </span><span class="No-Break"><span class="koboSpan" id="kobo.351.1">broadcasting needs.</span></span></p>
<h3><span class="koboSpan" id="kobo.352.1">Zoom</span></h3>
<p><span class="koboSpan" id="kobo.353.1">Zoom is one of the </span><a id="_idIndexMarker213"/><span class="koboSpan" id="kobo.354.1">real-time</span><a id="_idIndexMarker214"/><span class="koboSpan" id="kobo.355.1"> video conferencing platforms that exploded in popularity during the COVID pandemic and working-from-home era. </span><span class="koboSpan" id="kobo.355.2">Zoom provides real-time low latency audio and video conferencing with little delays and supports many simultaneous users. </span><span class="koboSpan" id="kobo.355.3">It also provides features such as screen sharing and group chats while on video conferencing. </span><span class="koboSpan" id="kobo.355.4">Zoom primarily uses the WebRTC streaming </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">protocol technology.</span></span></p>
<h3><span class="koboSpan" id="kobo.357.1">Dacast</span></h3>
<p><span class="koboSpan" id="kobo.358.1">Dacast is a </span><a id="_idIndexMarker215"/><span class="koboSpan" id="kobo.359.1">platform for</span><a id="_idIndexMarker216"/><span class="koboSpan" id="kobo.360.1"> broadcasting events, and even though it is not as low latency as some other real-time streaming applications, it still has acceptable performance when it comes to broadcasting purposes. </span><span class="koboSpan" id="kobo.360.2">It is affordable and works well but does not allow for a lot of interactive workflows. </span><span class="koboSpan" id="kobo.360.3">Dacast uses the RTMP streaming protocol </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">as well.</span></span></p>
<h3><span class="koboSpan" id="kobo.362.1">Ant Media Server</span></h3>
<p><span class="koboSpan" id="kobo.363.1">Ant Media Server uses </span><a id="_idIndexMarker217"/><span class="koboSpan" id="kobo.364.1">WebRTC technology to provide an extremely low latency video streaming platform and is intended to be used at an enterprise level </span><a id="_idIndexMarker218"/><span class="koboSpan" id="kobo.365.1">on-premises or on the cloud. </span><span class="koboSpan" id="kobo.365.2">It is also used for live video monitoring and surveillance-based applications that require real-time video streaming at </span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">their core.</span></span></p>
<h3><span class="koboSpan" id="kobo.367.1">Vimeo</span></h3>
<p><span class="koboSpan" id="kobo.368.1">Vimeo is </span><a id="_idIndexMarker219"/><span class="koboSpan" id="kobo.369.1">another </span><a id="_idIndexMarker220"/><span class="koboSpan" id="kobo.370.1">very popular video streaming platform that, while not the fastest in the business, is still used quite extensively. </span><span class="koboSpan" id="kobo.370.2">It is mostly used to house real-time live event broadcasts and on-demand video distribution applications. </span><span class="koboSpan" id="kobo.370.3">Vimeo uses RTMP streaming by default but also supports others, </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">including HLS.</span></span></p>
<h3><span class="koboSpan" id="kobo.372.1">Wowza</span></h3>
<p><span class="koboSpan" id="kobo.373.1">Wowza has</span><a id="_idIndexMarker221"/><span class="koboSpan" id="kobo.374.1"> been</span><a id="_idIndexMarker222"/><span class="koboSpan" id="kobo.375.1"> around for a long time in the field of online real-time video streaming and is quite reliable and widely used. </span><span class="koboSpan" id="kobo.375.2">It is used by many large corporations such as Sony, Vimeo, and Facebook and focuses on providing video streaming services at a commercial and enterprise level on a very large scale. </span><span class="koboSpan" id="kobo.375.3">Wowza is another platform that uses RTMP streaming </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">protocol technology.</span></span></p>
<h3><span class="koboSpan" id="kobo.377.1">Evercast</span></h3>
<p><span class="koboSpan" id="kobo.378.1">Evercast is an </span><a id="_idIndexMarker223"/><span class="koboSpan" id="kobo.379.1">ultra-low </span><a id="_idIndexMarker224"/><span class="koboSpan" id="kobo.380.1">latency streaming platform that has found a lot of uses for collaborative content creation and editing applications, as well as live streaming applications. </span><span class="koboSpan" id="kobo.380.2">Since it can support ultra-low latency performance, multiple collaborators are able to stream their workspaces and create an environment of real-time and collaborative editing. </span><span class="koboSpan" id="kobo.380.3">The demand for such use cases has exploded in recent years due to the COVID pandemic, remote work and collaboration, and online collaboration education systems. </span><span class="koboSpan" id="kobo.380.4">Evercast primarily uses WebRTC on its </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">streaming servers.</span></span></p>
<h3><span class="koboSpan" id="kobo.382.1">CacheFly</span></h3>
<p><span class="koboSpan" id="kobo.383.1">CacheFly is </span><a id="_idIndexMarker225"/><span class="koboSpan" id="kobo.384.1">another</span><a id="_idIndexMarker226"/><span class="koboSpan" id="kobo.385.1"> platform that provides live video streaming for live event broadcast purposes. </span><span class="koboSpan" id="kobo.385.2">It provides an acceptably low latency of single digit seconds and scales very well for real-time audio-video broadcasting applications. </span><span class="koboSpan" id="kobo.385.3">CacheFly uses a custom Websocket-based end-to-end </span><span class="No-Break"><span class="koboSpan" id="kobo.386.1">streaming solution.</span></span></p>
<h3><span class="koboSpan" id="kobo.387.1">Vonage Video API</span></h3>
<p><span class="koboSpan" id="kobo.388.1">Vonage Video</span><a id="_idIndexMarker227"/><span class="koboSpan" id="kobo.389.1"> API (previously known </span><a id="_idIndexMarker228"/><span class="koboSpan" id="kobo.390.1">as </span><strong class="bold"><span class="koboSpan" id="kobo.391.1">TokBox</span></strong><span class="koboSpan" id="kobo.392.1">) is another platform that provides live video streaming capabilities and targets large corporations to support </span><a id="_idIndexMarker229"/><span class="koboSpan" id="kobo.393.1">enterprise-level applications. </span><span class="koboSpan" id="kobo.393.2">It supports data encryption, which is what makes it a preferred choice for enterprises, corporations, and healthcare companies looking for audio-video conferencing, meetings, and training online. </span><span class="koboSpan" id="kobo.393.3">Vonage uses RTMP as well as HLS as its </span><span class="No-Break"><span class="koboSpan" id="kobo.394.1">broadcasting technologies.</span></span></p>
<h3><span class="koboSpan" id="kobo.395.1">Open Broadcast Software (OBS)</span></h3>
<p><span class="koboSpan" id="kobo.396.1">OBS is another low </span><a id="_idIndexMarker230"/><span class="koboSpan" id="kobo.397.1">latency video</span><a id="_idIndexMarker231"/><span class="koboSpan" id="kobo.398.1"> streaming platform that is also open source, which makes it popular in a lot of circles where enterprise-level solutions might be a deterrent. </span><span class="koboSpan" id="kobo.398.2">Many live streamers who stream several types of content use OBS, and even some platforms such as Facebook Live and Twitch use some parts of OBS. </span><span class="koboSpan" id="kobo.398.3">OBS supports </span><a id="_idIndexMarker232"/><span class="koboSpan" id="kobo.399.1">multiple protocols such as RTMP and </span><strong class="bold"><span class="koboSpan" id="kobo.400.1">Secure Reliable </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.401.1">Transport</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.402.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.403.1">SRT</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.405.1">Here, we conclude our discussion of low latency considerations for live video streaming applications. </span><span class="koboSpan" id="kobo.405.2">Next, we will transition into video gaming applications, which share some common traits when compared to live video streaming applications, especially when it comes to online </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">video games.</span></span></p>
<h1 id="_idParaDest-45"><a id="_idTextAnchor044"/><span class="koboSpan" id="kobo.407.1">Understanding what low latency constraints matter in gaming applications</span></h1>
<p><span class="koboSpan" id="kobo.408.1">Video gaming has </span><a id="_idIndexMarker233"/><span class="koboSpan" id="kobo.409.1">evolved greatly since it was first born in the 1960s and, these days, video games are not about playing alone or even playing along with or against the person physically next to you. </span><span class="koboSpan" id="kobo.409.2">These days, gaming involves many players all over the globe, and even the quality and complexity of these games have increased tremendously. </span><span class="koboSpan" id="kobo.409.3">It is no surprise that ultra-low latency and high scalability are non-negotiable requirements when it comes to modern gaming applications. </span><span class="koboSpan" id="kobo.409.4">With new technologies such as AR and VR, this only further increases the need for ultra-low latency performance. </span><span class="koboSpan" id="kobo.409.5">Additionally, with the advent of mobile gaming combined with online gaming, complex gaming applications have been ported to smartphones and need ultra-low latency content delivery systems, multiplayer systems, and super-fast </span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">processing speeds.</span></span></p>
<p><span class="koboSpan" id="kobo.411.1">In the previous section, we discussed low latency real-time video streaming applications in detail, including streaming applications that are interactive. </span><span class="koboSpan" id="kobo.411.2">In this section, we will look at low latency considerations, high-latency impact, and techniques to facilitate low latency performance in video gaming applications. </span><span class="koboSpan" id="kobo.411.3">Since a lot of modern video games are either online or in the cloud, or have a strong online presence due to multiplayer features, a lot of what we learned in the previous section is still important here. </span><span class="koboSpan" id="kobo.411.4">Streaming and rendering video games in real time, preventing lag, and responding to player interactions </span><a id="_idIndexMarker234"/><span class="koboSpan" id="kobo.412.1">quickly and efficiently are necessities when it comes to gaming applications. </span><span class="koboSpan" id="kobo.412.2">Additionally, there are some extra concepts, considerations, and techniques to maximize low latency </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">gaming performance.</span></span></p>
<h2 id="_idParaDest-46"><a id="_idTextAnchor045"/><span class="koboSpan" id="kobo.414.1">Concepts in low latency gaming applications</span></h2>
<p><span class="koboSpan" id="kobo.415.1">Before we understand the</span><a id="_idIndexMarker235"/><span class="koboSpan" id="kobo.416.1"> impact of high latency in gaming applications and how to improve the latencies in these applications, we will define and explain a few concepts related to gaming applications and their performance. </span><span class="koboSpan" id="kobo.416.2">When it comes to low latency gaming applications, the most important concepts </span><a id="_idIndexMarker236"/><span class="koboSpan" id="kobo.417.1">are the </span><strong class="bold"><span class="koboSpan" id="kobo.418.1">refresh rate</span></strong><span class="koboSpan" id="kobo.419.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.420.1">response time</span></strong><span class="koboSpan" id="kobo.421.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.422.1">input lag</span></strong><span class="koboSpan" id="kobo.423.1">. </span><span class="koboSpan" id="kobo.423.2">The </span><a id="_idIndexMarker237"/><span class="koboSpan" id="kobo.424.1">main goal of these applications is to minimize the delay</span><a id="_idIndexMarker238"/><span class="koboSpan" id="kobo.425.1"> between the player and the character on screen that the player controls. </span><span class="koboSpan" id="kobo.425.2">Really, what this means is that any user input reflects the impact on the screen right away, and any changes to the character due to the gameplay environment are rendered on the screen right away. </span><span class="koboSpan" id="kobo.425.3">The optimal user experience is achieved when the gameplay feels very smooth, and the player feels like they really are inside the game world being rendered on screen. </span><span class="koboSpan" id="kobo.425.4">Now, let us jump into a discussion of the important concepts with regard to low latency </span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">gaming applications.</span></span></p>
<h3><span class="koboSpan" id="kobo.427.1">Ping</span></h3>
<p><span class="koboSpan" id="kobo.428.1">In computer science and </span><a id="_idIndexMarker239"/><span class="koboSpan" id="kobo.429.1">online video gaming applications, </span><strong class="bold"><span class="koboSpan" id="kobo.430.1">ping</span></strong><span class="koboSpan" id="kobo.431.1"> is the </span><a id="_idIndexMarker240"/><span class="koboSpan" id="kobo.432.1">latency from when data is sent from the user’s computer to a server (or possibly a different player’s computer) until when the data is received back at the original user’s computer. </span><span class="koboSpan" id="kobo.432.2">Typically, the magnitude of the ping latency depends on the application; for low latency electronic trading, this will be in hundreds of microseconds, and for gaming applications, it is usually tens to hundreds of milliseconds. </span><span class="koboSpan" id="kobo.432.3">Ping latency basically measures how fast a server and client communicate with each other in the absence of any processing delays at the server or </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">client machines.</span></span></p>
<p><span class="koboSpan" id="kobo.434.1">The closer to real-time the requirements for the gaming application are, the lower the ping times need to be. </span><span class="koboSpan" id="kobo.434.2">This is typically required for games such as </span><strong class="bold"><span class="koboSpan" id="kobo.435.1">first-person shooters</span></strong><span class="koboSpan" id="kobo.436.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.437.1">FPS</span></strong><span class="koboSpan" id="kobo.438.1">) and</span><a id="_idIndexMarker241"/><span class="koboSpan" id="kobo.439.1"> sports and racing games, while other games such as </span><strong class="bold"><span class="koboSpan" id="kobo.440.1">massive multiplayer online</span></strong><span class="koboSpan" id="kobo.441.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.442.1">MMO</span></strong><span class="koboSpan" id="kobo.443.1">) games</span><a id="_idIndexMarker242"/><span class="koboSpan" id="kobo.444.1"> and some </span><strong class="bold"><span class="koboSpan" id="kobo.445.1">real-time strategy</span></strong><span class="koboSpan" id="kobo.446.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.447.1">RTS</span></strong><span class="koboSpan" id="kobo.448.1">) games</span><a id="_idIndexMarker243"/><span class="koboSpan" id="kobo.449.1"> can tolerate higher ping latencies. </span><span class="koboSpan" id="kobo.449.2">It is common for the game interface itself to have a ping functionality or display ping statistics in real time. </span><span class="koboSpan" id="kobo.449.3">In general, 50 to 100 milliseconds is an</span><a id="_idIndexMarker244"/><span class="koboSpan" id="kobo.450.1"> acceptable ping time, above 100 milliseconds can cause noticeable</span><a id="_idIndexMarker245"/><span class="koboSpan" id="kobo.451.1"> delays during gameplay, and any higher than that degrades the player’s experience too much to be viable. </span><span class="koboSpan" id="kobo.451.2">Typically, less than 25 milliseconds is the ideal ping latency for good responsiveness, crisp rendering of visuals, and no </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">gameplay lags.</span></span></p>
<h3><span class="koboSpan" id="kobo.453.1">Frames per second (FPS)</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.454.1">FPS</span></strong><span class="koboSpan" id="kobo.455.1"> (not to be confused with </span><em class="italic"><span class="koboSpan" id="kobo.456.1">first-person shooters</span></em><span class="koboSpan" id="kobo.457.1">) is another important concept when it comes to </span><a id="_idIndexMarker246"/><span class="koboSpan" id="kobo.458.1">online gaming applications. </span><span class="koboSpan" id="kobo.458.2">FPS measures how many frames or images can be rendered each second by the</span><a id="_idIndexMarker247"/><span class="koboSpan" id="kobo.459.1"> graphics card. </span><span class="koboSpan" id="kobo.459.2">FPS can also be measured for the monitor hardware itself instead of the graphics card (i.e., how many frames can be displayed or updated by the monitor hardware itself). </span><span class="koboSpan" id="kobo.459.3">Higher FPS typically leads to the smoother rendering of game worlds and the user experience feels more responsive to inputs and gameplay events. </span><span class="koboSpan" id="kobo.459.4">Lower FPS leads to the gameplay and rendering feeling like it is rigid, stuttering, and flickering, and overall, just leads to significantly reduced enjoyment </span><span class="No-Break"><span class="koboSpan" id="kobo.460.1">and adoption.</span></span></p>
<p><span class="koboSpan" id="kobo.461.1">For a game to be functional or even playable, 30 FPS is the bare minimum necessity, and this can support console games and some PC games. </span><span class="koboSpan" id="kobo.461.2">As long as the FPS stays above 20 FPS, these games can continue to be playable without any noticeable lag and degradation. </span><span class="koboSpan" id="kobo.461.3">For most games, 60 FPS or more is the ideal performance range that is easily supported by most graphics cards, PCs, monitors, and TVs. </span><span class="koboSpan" id="kobo.461.4">Beyond 60 FPS, the next milestone is 120 FPS, which is only needed and available for high-end gaming hardware connected to monitors that support at least 144-Hz refresh rates. </span><span class="koboSpan" id="kobo.461.5">Beyond this, 240 FPS is the maximum frame rate achievable and needs to be paired with 240-Hz refresh rate monitors. </span><span class="koboSpan" id="kobo.461.6">This </span><a id="_idIndexMarker248"/><span class="koboSpan" id="kobo.462.1">high-end configuration is typically only needed for the biggest gaming enthusiasts </span><span class="No-Break"><span class="koboSpan" id="kobo.463.1">out there.</span></span></p>
<h3><span class="koboSpan" id="kobo.464.1">Refresh rate</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.465.1">The refresh rate</span></strong><span class="koboSpan" id="kobo.466.1"> is </span><a id="_idIndexMarker249"/><span class="koboSpan" id="kobo.467.1">a concept that is very closely related to FPS, and even though technically they are slightly different, they do impact each</span><a id="_idIndexMarker250"/><span class="koboSpan" id="kobo.468.1"> other. </span><span class="koboSpan" id="kobo.468.2">The refresh rate also measures how quickly the screen refreshes and impacts the maximum possible FPS that hardware can support. </span><span class="koboSpan" id="kobo.468.3">Like FPS, the higher the refresh rate, the smoother the rendering transition when animating motion during gameplay on the screen. </span><span class="koboSpan" id="kobo.468.4">The maximum refresh rate controls the maximum FPS achievable because even though the graphics card can render faster than a monitor screen can refresh, the bottleneck then becomes the monitor screen refresh rate. </span><span class="koboSpan" id="kobo.468.5">When there are cases where the FPS exceeds the refresh rate, one of the display artifacts that we encounter is </span><a id="_idIndexMarker251"/><span class="koboSpan" id="kobo.469.1">called </span><strong class="bold"><span class="koboSpan" id="kobo.470.1">screen tearing</span></strong><span class="koboSpan" id="kobo.471.1">. </span><span class="koboSpan" id="kobo.471.2">Screen tearing is when the graphics card (GPU) is not synchronized with the monitor, so there are cases where the monitor paints an incomplete frame on top of the current frame, resulting in horizontal or vertical splits where the partial and full frames overlap on the screen. </span><span class="koboSpan" id="kobo.471.3">This does not completely break down the gameplay but, at the</span><a id="_idIndexMarker252"/><span class="koboSpan" id="kobo.472.1"> very least, can be distracting if it happens rarely, </span><a id="_idIndexMarker253"/><span class="koboSpan" id="kobo.473.1">all the way to completely ruining the visual quality of the gameplay if quite </span><a id="_idIndexMarker254"/><span class="koboSpan" id="kobo.474.1">frequent. </span><span class="koboSpan" id="kobo.474.2">There </span><a id="_idIndexMarker255"/><span class="koboSpan" id="kobo.475.1">are various techniques to deal with screen tearing, which</span><a id="_idIndexMarker256"/><span class="koboSpan" id="kobo.476.1"> we will look at</span><a id="_idIndexMarker257"/><span class="koboSpan" id="kobo.477.1"> shortly, such as </span><strong class="bold"><span class="koboSpan" id="kobo.478.1">vertical synchronization</span></strong><span class="koboSpan" id="kobo.479.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.480.1">V-Sync</span></strong><span class="koboSpan" id="kobo.481.1">), </span><strong class="bold"><span class="koboSpan" id="kobo.482.1">adaptive sync</span></strong><span class="koboSpan" id="kobo.483.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.484.1">FreeSync</span></strong><span class="koboSpan" id="kobo.485.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.486.1">Fast Sync</span></strong><span class="koboSpan" id="kobo.487.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.488.1">G-Sync</span></strong><span class="koboSpan" id="kobo.489.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.490.1">variable refresh </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.491.1">rate</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.492.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.493.1">VRR</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">).</span></span></p>
<h3><span class="koboSpan" id="kobo.495.1">Input lag</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.496.1">Input lag</span></strong><span class="koboSpan" id="kobo.497.1"> measures</span><a id="_idIndexMarker258"/><span class="koboSpan" id="kobo.498.1"> the latency between when a user generates an input (such as a keystroke, mouse movement, or a mouse click) to when the response to that input is</span><a id="_idIndexMarker259"/><span class="koboSpan" id="kobo.499.1"> rendered on the screen. </span><span class="koboSpan" id="kobo.499.2">This is basically the responsiveness of the hardware and the game to user inputs and interactions. </span><span class="koboSpan" id="kobo.499.3">Obviously, for all games, this is a non-zero value and is the sum of the hardware itself (the controller, mouse, keyboard, internet connection, processor, display monitor, etc.) or the game software itself (processing input, updating the game and character states, dispatching the graphics updates, rendering them via the graphics card, and refreshing the monitor). </span><span class="koboSpan" id="kobo.499.4">When there is high input lag, the game feels unresponsive and lagging, which can affect the player’s performance during multiplayer or online gameplay and even ruin the game completely for </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">the user.</span></span></p>
<h3><span class="koboSpan" id="kobo.501.1">Response time</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.502.1">Response time</span></strong><span class="koboSpan" id="kobo.503.1"> is </span><a id="_idIndexMarker260"/><span class="koboSpan" id="kobo.504.1">often mistaken for input lag, but </span><a id="_idIndexMarker261"/><span class="koboSpan" id="kobo.505.1">they are different terms. </span><span class="koboSpan" id="kobo.505.2">Response time refers to the pixel response time, which basically means the time it takes for pixels to change colors. </span><span class="koboSpan" id="kobo.505.3">While input lag impacts the gameplay’s responsiveness, response time impacts the blurriness of rendered animations on the screen. </span><span class="koboSpan" id="kobo.505.4">Intuitively, if the pixel response time is high, the pixels take longer to change colors when rendering motion or animation on screen, thus causing blurriness. </span><span class="koboSpan" id="kobo.505.5">Lower pixel response times (1 millisecond or lower) lead to crisp and sharp image and animation quality, even for games that have fast camera movements. </span><span class="koboSpan" id="kobo.505.6">Good examples of such games would be first-person shooters and racing games. </span><span class="koboSpan" id="kobo.505.7">In cases where the response time is high, we encounter an artifact known</span><a id="_idIndexMarker262"/><span class="koboSpan" id="kobo.506.1"> as </span><strong class="bold"><span class="koboSpan" id="kobo.507.1">ghosting</span></strong><span class="koboSpan" id="kobo.508.1">, which refers to trails and artifacts slowly fading off the screen when there is motion. </span><span class="koboSpan" id="kobo.508.2">Usually, ghosting and high pixel response times are not a problem, and modern hardware can easily provide response times of less than 5 milliseconds and render </span><span class="No-Break"><span class="koboSpan" id="kobo.509.1">sharp animations.</span></span></p>
<h3><span class="koboSpan" id="kobo.510.1">Network bandwidth</span></h3>
<p><span class="koboSpan" id="kobo.511.1">Network bandwidth </span><a id="_idIndexMarker263"/><span class="koboSpan" id="kobo.512.1">affects online gaming applications in the same way as it would affect </span><a id="_idIndexMarker264"/><span class="koboSpan" id="kobo.513.1">real-time video streaming applications. </span><span class="koboSpan" id="kobo.513.2">Bandwidth measures how many megabits per second can be uploaded to or downloaded from the gaming application server. </span><span class="koboSpan" id="kobo.513.3">Bandwidth is also affected by packet losses, which we will look at next, and varies depending on the location of the players and the gaming server they connect to. </span><strong class="bold"><span class="koboSpan" id="kobo.514.1">Contention</span></strong><span class="koboSpan" id="kobo.515.1"> is</span><a id="_idIndexMarker265"/><span class="koboSpan" id="kobo.516.1"> another term to think about when it comes to network bandwidth. </span><span class="koboSpan" id="kobo.516.2">Contention is a measure of how many simultaneous users are trying to access the same server or shared resource and whether that causes the server to be overloaded </span><span class="No-Break"><span class="koboSpan" id="kobo.517.1">or not.</span></span></p>
<h3><span class="koboSpan" id="kobo.518.1">Network packet loss and jitter</span></h3>
<p><span class="koboSpan" id="kobo.519.1">Network packet </span><a id="_idIndexMarker266"/><span class="koboSpan" id="kobo.520.1">loss is</span><a id="_idIndexMarker267"/><span class="koboSpan" id="kobo.521.1"> an inescapable fact of transmitting packets over the network. </span><span class="koboSpan" id="kobo.521.2">Network packet loss reduces the effective bandwidth and causes retransmission and recovery protocols, which introduce additional delays. </span><span class="koboSpan" id="kobo.521.3">Some packet losses are tolerable, but when the network packet losses are very high, they can degrade the user experience of online gaming applications and can even bring it to a grinding halt. </span><strong class="bold"><span class="koboSpan" id="kobo.522.1">Jitter</span></strong><span class="koboSpan" id="kobo.523.1"> is like packet losses except, in this case, packets arrive</span><a id="_idIndexMarker268"/><span class="koboSpan" id="kobo.524.1"> out of order. </span><span class="koboSpan" id="kobo.524.2">This </span><a id="_idIndexMarker269"/><span class="koboSpan" id="kobo.525.1">introduces additional delays as the game software is on the user’s end because the receiver must save the out-of-order packets and wait for packets that have not arrived yet and then process the packets </span><span class="No-Break"><span class="koboSpan" id="kobo.526.1">in order.</span></span></p>
<h3><span class="koboSpan" id="kobo.527.1">Networking protocols</span></h3>
<p><span class="koboSpan" id="kobo.528.1">When it comes to</span><a id="_idIndexMarker270"/><span class="koboSpan" id="kobo.529.1"> networking protocols, there are</span><a id="_idIndexMarker271"/><span class="koboSpan" id="kobo.530.1"> broadly two protocols to transfer data across the internet: </span><strong class="bold"><span class="koboSpan" id="kobo.531.1">TCP</span></strong><span class="koboSpan" id="kobo.532.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.533.1">UDP</span></strong><span class="koboSpan" id="kobo.534.1">. </span><span class="koboSpan" id="kobo.534.2">TCP provides a reliable transport protocol by tracking packets </span><a id="_idIndexMarker272"/><span class="koboSpan" id="kobo.535.1">successfully delivered to the receiver and having </span><a id="_idIndexMarker273"/><span class="koboSpan" id="kobo.536.1">mechanisms to retransmit lost packets. </span><span class="koboSpan" id="kobo.536.2">The advantage here is obvious where applications cannot operate with packet and information losses. </span><span class="koboSpan" id="kobo.536.3">The disadvantage here is that these additional mechanisms to detect and handle packet drops cause additional latencies (additional milliseconds) and use the available bandwidth less effectively. </span><span class="koboSpan" id="kobo.536.4">Examples of applications that must rely on TCP are online shopping and online banking, where it is critical to make sure the data is delivered correctly, even if it is delivered late. </span><span class="koboSpan" id="kobo.536.5">UDP instead focuses on making sure that the data is delivered as quickly as possible and with greater bandwidth effectiveness. </span><span class="koboSpan" id="kobo.536.6">However, it does so at the cost of not guaranteeing delivery or even guaranteeing in-order delivery of packets since it does not have mechanisms to retransmit dropped packets. </span><span class="koboSpan" id="kobo.536.7">UDP works well for applications that can tolerate some packet losses without completely breaking down and some dropped information is preferred over delayed information. </span><span class="koboSpan" id="kobo.536.8">Some examples of such applications are real-time video streaming and some components of online gaming applications. </span><span class="koboSpan" id="kobo.536.9">For instance, some video components or rendering components in online video games can be transported over UDP, but some components such as user input and game and player state updates need to be sent </span><span class="No-Break"><span class="koboSpan" id="kobo.537.1">over TCP.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer017">
<span class="koboSpan" id="kobo.538.1"><img alt="Figure 2.3 – Components in an end-to-end video gaming system" src="image/Figure_2.3_B19434.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.539.1">Figure 2.3 – Components in an end-to-end video gaming system</span></p>
<h2 id="_idParaDest-47"><a id="_idTextAnchor046"/><span class="koboSpan" id="kobo.540.1">Improving gaming application performance</span></h2>
<p><span class="koboSpan" id="kobo.541.1">In the previous </span><a id="_idIndexMarker274"/><span class="koboSpan" id="kobo.542.1">section, we discussed some concepts that apply to low latency gaming applications and their impact on the application and the user experience. </span><span class="koboSpan" id="kobo.542.2">In this section, we will explore additional details about the sources of high latency in gaming applications and discuss the steps we can take to improve gaming application latencies and performance and thus improve the </span><span class="No-Break"><span class="koboSpan" id="kobo.543.1">user experience.</span></span></p>
<h3><span class="koboSpan" id="kobo.544.1">Approaching gaming application optimization from the developer’s perspective</span></h3>
<p><span class="koboSpan" id="kobo.545.1">First, we look at</span><a id="_idIndexMarker275"/><span class="koboSpan" id="kobo.546.1"> the approach and techniques that game developers use to optimize gaming application performance. </span><span class="koboSpan" id="kobo.546.2">Let us quickly describe a few optimization techniques employed by developers – some that apply to all applications and some that only apply to </span><span class="No-Break"><span class="koboSpan" id="kobo.547.1">gaming applications.</span></span></p>
<h4><span class="koboSpan" id="kobo.548.1">Managing memory, optimizing cache access, and optimizing the hot path</span></h4>
<p><span class="koboSpan" id="kobo.549.1">Gaming </span><a id="_idIndexMarker276"/><span class="koboSpan" id="kobo.550.1">applications, like other low latency applications, must use the available resources efficiently and maximize runtime performance. </span><span class="koboSpan" id="kobo.550.2">This includes managing the memory correctly to avoid memory leaks and pre-allocating and pre-initializing as many things as possible. </span><span class="koboSpan" id="kobo.550.3">Avoiding mechanisms such as garbage collection and dynamic memory allocations and deallocation on the critical path are also important to meet a certain runtime performance expectation. </span><span class="koboSpan" id="kobo.550.4">This is especially relevant to gaming applications because there are many objects in video games, especially ones that create and deal with </span><span class="No-Break"><span class="koboSpan" id="kobo.551.1">large worlds.</span></span></p>
<p><span class="koboSpan" id="kobo.552.1">Another important aspect of most low latency applications is using the data and instruction cache as efficiently as possible. </span><span class="koboSpan" id="kobo.552.2">Gaming applications are no different, especially given the large amount of data that they must </span><span class="No-Break"><span class="koboSpan" id="kobo.553.1">deal with.</span></span></p>
<p><span class="koboSpan" id="kobo.554.1">A lot of applications, including</span><a id="_idIndexMarker277"/><span class="koboSpan" id="kobo.555.1"> gaming applications, spend a lot of their time in a critical loop. </span><span class="koboSpan" id="kobo.555.2">For gaming applications, this can be a loop that checks for inputs, updates the game state, character states, and so on based on the physics engine ,and renders on screen, as well as </span><a id="_idIndexMarker278"/><span class="koboSpan" id="kobo.556.1">generates audio output. </span><span class="koboSpan" id="kobo.556.2">Gaming developers typically spend a lot of time focusing on the operations performed in this critical path, like what we would do with any low latency application running in a </span><span class="No-Break"><span class="koboSpan" id="kobo.557.1">tight loop.</span></span></p>
<h4><span class="koboSpan" id="kobo.558.1">Frustum culling</span></h4>
<p><span class="koboSpan" id="kobo.559.1">In </span><a id="_idIndexMarker279"/><span class="koboSpan" id="kobo.560.1">computer graphics, the term view </span><strong class="bold"><span class="koboSpan" id="kobo.561.1">frustum</span></strong><span class="koboSpan" id="kobo.562.1"> refers to the part of the game world</span><a id="_idIndexMarker280"/><span class="koboSpan" id="kobo.563.1"> that is</span><a id="_idIndexMarker281"/><span class="koboSpan" id="kobo.564.1"> currently visible on the screen. </span><strong class="bold"><span class="koboSpan" id="kobo.565.1">Frustum culling</span></strong><span class="koboSpan" id="kobo.566.1"> is a term that refers to the technique of determining which objects are visible on the screen and only rendering those objects on the screen. </span><span class="koboSpan" id="kobo.566.2">Another way to think about this is that most game engines minimize the amount of processing power being directed toward off-screen objects. </span><span class="koboSpan" id="kobo.566.3">This is typically achieved by separating the display or rendering functionality of an object from its data and logic management, such as the location, state, next move, and so on. </span><span class="koboSpan" id="kobo.566.4">Eliminating the overhead of rendering objects not currently on the screen reduces the processing cost to a fraction of what it would be. </span><span class="koboSpan" id="kobo.566.5">Another way to introduce this separation would be to have an update method that is used when the object is on screen and another update method to be used when the object </span><span class="No-Break"><span class="koboSpan" id="kobo.567.1">is off-screen.</span></span></p>
<h4><span class="koboSpan" id="kobo.568.1">Caching calculations and using mathematical approximations</span></h4>
<p><span class="koboSpan" id="kobo.569.1">This</span><a id="_idIndexMarker282"/><span class="koboSpan" id="kobo.570.1"> is an easy-to-understand optimization technique that applies to applications that need to perform a lot of expensive mathematical computations. </span><span class="koboSpan" id="kobo.570.2">Gaming</span><a id="_idIndexMarker283"/><span class="koboSpan" id="kobo.571.1"> applications especially are heavy on mathematical computations in their physics engines, especially for 3D games with large worlds and lots of objects in the world. </span><span class="koboSpan" id="kobo.571.2">Optimization techniques such as caching values instead of recomputing them each time, using lookup tables to trade memory usage for CPU usage to lookup values, and using mathematical approximations instead of extremely accurate but expensive expressions are used in such cases. </span><span class="koboSpan" id="kobo.571.3">These optimization techniques have been used for a very long time in the world of video games because, for a long time, hardware resources were extremely limited, and developing such systems needed to rely on </span><span class="No-Break"><span class="koboSpan" id="kobo.572.1">these techniques.</span></span></p>
<p><span class="koboSpan" id="kobo.573.1">The raycasting engine</span><a id="_idIndexMarker284"/><span class="koboSpan" id="kobo.574.1"> from </span><strong class="bold"><span class="koboSpan" id="kobo.575.1">id Software</span></strong><span class="koboSpan" id="kobo.576.1"> (which pioneered and powered games such as Wolfenstein, Doom, Quake, etc.) is an impressive masterpiece of low latency</span><a id="_idIndexMarker285"/><span class="koboSpan" id="kobo.577.1"> software development from back in the old days. </span><span class="koboSpan" id="kobo.577.2">Another example would be cases where we have side scrollers or top-down shooters where there are a lot of enemies on screen</span><a id="_idIndexMarker286"/><span class="koboSpan" id="kobo.578.1"> but a lot of them have similar movement patterns and can be reused instead of </span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">being recalculated.</span></span></p>
<h4><span class="koboSpan" id="kobo.580.1">Prioritizing critical tasks and leveraging CPU idle time</span></h4>
<p><span class="koboSpan" id="kobo.581.1">A </span><a id="_idIndexMarker287"/><span class="koboSpan" id="kobo.582.1">game engine that deals with many objects in a huge game world typically has many objects that update frequently. </span><span class="koboSpan" id="kobo.582.2">Instead of updating every object on every frame update, a game engine needs to prioritize tasks that need to be performed in </span><a id="_idIndexMarker288"/><span class="koboSpan" id="kobo.583.1">the critical section (for example, objects whose visual properties have changed since the last frame). </span><span class="koboSpan" id="kobo.583.2">A simple implementation would be to have a member method for each object that the game engine can use to check whether it has changed since the last frame and prioritize the updates for those objects. </span><span class="koboSpan" id="kobo.583.3">For instance, some game components such as the scenery (stationary environment objects, weather, lighting, etc.) and </span><strong class="bold"><span class="koboSpan" id="kobo.584.1">heads-up display</span></strong><span class="koboSpan" id="kobo.585.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.586.1">HUD</span></strong><span class="koboSpan" id="kobo.587.1">) do not change very frequently and typically have extremely </span><a id="_idIndexMarker289"/><span class="koboSpan" id="kobo.588.1">limited animation sequences. </span><span class="koboSpan" id="kobo.588.2">The tasks related to updating these components are slightly lower-priority than some other </span><span class="No-Break"><span class="koboSpan" id="kobo.589.1">game components.</span></span></p>
<p><span class="koboSpan" id="kobo.590.1">Classifying tasks into high-priority and low-priority tasks also means that the game engine has the option of guaranteeing a good gameplay experience by making sure high-priority tasks are performed in all hardware and game settings. </span><span class="koboSpan" id="kobo.590.2">If the game engine detects a lot of CPU idle time, it can add additional low-priority features (such as particle engines, lighting, shading, atmospheric </span><span class="No-Break"><span class="koboSpan" id="kobo.591.1">effects, etc.).</span></span></p>
<h4><span class="koboSpan" id="kobo.592.1">Ordering draw calls depending on layer, depth, and texture</span></h4>
<p><span class="koboSpan" id="kobo.593.1">A </span><a id="_idIndexMarker290"/><span class="koboSpan" id="kobo.594.1">game engine needs to determine which rendering or draw calls to issue to the graphics card. </span><span class="koboSpan" id="kobo.594.2">To optimize performance, the goal here is to not only minimize the number of draw calls issued but also to order and group these draw calls to perform them optimally. </span><span class="koboSpan" id="kobo.594.3">When rendering objects to the screen, we must think about the following layers </span><span class="No-Break"><span class="koboSpan" id="kobo.595.1">or considerations:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.596.1">The fullscreen layer</span></strong><span class="koboSpan" id="kobo.597.1">: This comprises the HUD, the game layer, the translucent effects layer, and </span><span class="No-Break"><span class="koboSpan" id="kobo.598.1">so on</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.599.1">The viewport layer</span></strong><span class="koboSpan" id="kobo.600.1">: These exist if there are mirrors, portals, split screens, and </span><span class="No-Break"><span class="koboSpan" id="kobo.601.1">so on</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.602.1">Depth considerations</span></strong><span class="koboSpan" id="kobo.603.1">: We need to draw objects in back-to-front order or </span><span class="No-Break"><span class="koboSpan" id="kobo.604.1">farthest-to-closest order</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.605.1">Texturing considerations</span></strong><span class="koboSpan" id="kobo.606.1">: These comprise textures, shading, lighting, and </span><span class="No-Break"><span class="koboSpan" id="kobo.607.1">so on</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.608.1">There are various decisions to be made about the ordering of these different layers and components and in which order the draw calls are sent to the graphics card. </span><span class="koboSpan" id="kobo.608.2">An example would be in cases where translucent objects might be ordered back-to-front (i.e., sorted by depth first and texture second). </span><span class="koboSpan" id="kobo.608.3">For opaque objects, it might sort by texture first and eliminate draw calls for objects that are behind </span><span class="No-Break"><span class="koboSpan" id="kobo.609.1">opaque objects.</span></span></p>
<h3><span class="koboSpan" id="kobo.610.1">Approaching gaming application optimization from the gamer’s perspective</span></h3>
<p><span class="koboSpan" id="kobo.611.1">For </span><a id="_idIndexMarker291"/><span class="koboSpan" id="kobo.612.1">gaming applications, a lot of the performance depends on the end user’s hardware, OS, and game settings. </span><span class="koboSpan" id="kobo.612.2">This section describes a few things that end users can do to maximize gaming performance under different settings and different </span><span class="No-Break"><span class="koboSpan" id="kobo.613.1">resource availability.</span></span></p>
<h4><span class="koboSpan" id="kobo.614.1">Upgrading hardware</span></h4>
<p><span class="koboSpan" id="kobo.615.1">The </span><a id="_idIndexMarker292"/><span class="koboSpan" id="kobo.616.1">first obvious method to improve gaming application performance is to improve the hardware the end user’s game runs on. </span><span class="koboSpan" id="kobo.616.2">Some important candidates would be the gaming monitor, mouse, keyboard, and controllers used. </span><span class="koboSpan" id="kobo.616.3">Gaming monitors with higher refresh rates (such as 360-Hz monitors that support 1920 x 1080p (pixels) resolution and 240-Hz monitors that support 2560 x 1440p resolution) can provide high-quality rendering and fluid animations and enhance gameplay. </span><span class="koboSpan" id="kobo.616.4">We can also use a mouse with an extremely high polling rate, which allows for clicks and movements to be registered faster than before and reduce latency and lag. </span><span class="koboSpan" id="kobo.616.5">Similarly, for keyboards, gaming keyboards have much higher polling rates and can improve response times, especially for games where there are a lot of constant keystrokes, which can often be the case for RTS games. </span><span class="koboSpan" id="kobo.616.6">Another important point to mention here would be that using official and reputable controllers for specific consoles and platforms usually results in the </span><span class="No-Break"><span class="koboSpan" id="kobo.617.1">best performance.</span></span></p>
<h4><span class="koboSpan" id="kobo.618.1">Gaming monitor refresh rates</span></h4>
<p><span class="koboSpan" id="kobo.619.1">We </span><a id="_idIndexMarker293"/><span class="koboSpan" id="kobo.620.1">have discussed this aspect a few times before but with the rise of very high-quality images and animations, the quality and capacity of gaming monitors themselves have become quite important. </span><span class="koboSpan" id="kobo.620.2">Here, the key is to have a high refresh rate monitor that also has a low pixel response time so that animations can be rendered and updated quickly as well as smoothly. </span><span class="koboSpan" id="kobo.620.3">The configuration must also avoid the screen-tearing, ghosting, and blurring artifacts that we </span><span class="No-Break"><span class="koboSpan" id="kobo.621.1">discussed before.</span></span></p>
<h4><span class="koboSpan" id="kobo.622.1">Upgrading your graphics card</span></h4>
<p><span class="koboSpan" id="kobo.623.1">Upgrading the</span><a id="_idIndexMarker294"/><span class="koboSpan" id="kobo.624.1"> graphics card is another option that can result in significant improvements by increasing the frame rate and thus improving the gaming performance. </span><span class="koboSpan" id="kobo.624.2">NVIDIA found that upgrading the graphics card and the GPU drivers can help improve gaming performance by more than 20% in some cases. </span><span class="koboSpan" id="kobo.624.3">NVIDIA GeForce, ATI Radeon, Intel HD graphics, and so on are popular vendors that provide updated and optimized drivers that can be used to boost your gaming performance depending on which graphics cards are installed on the </span><span class="No-Break"><span class="koboSpan" id="kobo.625.1">user’s platform.</span></span></p>
<h4><span class="koboSpan" id="kobo.626.1">Overclocking the graphics card</span></h4>
<p><span class="koboSpan" id="kobo.627.1">Another </span><a id="_idIndexMarker295"/><span class="koboSpan" id="kobo.628.1">possible area of improvement instead of, or in addition to, upgrading the GPU is attempting to overclock the GPU with the aim of adding FPS. </span><strong class="bold"><span class="koboSpan" id="kobo.629.1">Overclocking</span></strong><span class="koboSpan" id="kobo.630.1"> the </span><a id="_idIndexMarker296"/><span class="koboSpan" id="kobo.631.1">GPU works by increasing the frequency of the GPU and ultimately increasing the FPS output of the GPU. </span><span class="koboSpan" id="kobo.631.2">The one drawback of overclocking the GPU is increased internal temperatures, which can lead to overheating in extreme cases. </span><span class="koboSpan" id="kobo.631.3">So, when overclocking, you should monitor the increase in temperatures, increase the overclock levels gradually, monitor along the way, and make sure that the PC, laptop, or console has sufficient cooling in place. </span><span class="koboSpan" id="kobo.631.4">GPU overclocking can yield a performance boost of </span><span class="No-Break"><span class="koboSpan" id="kobo.632.1">around 10%.</span></span></p>
<h4><span class="koboSpan" id="kobo.633.1">Upgrading your RAM</span></h4>
<p><span class="koboSpan" id="kobo.634.1">This is </span><a id="_idIndexMarker297"/><span class="koboSpan" id="kobo.635.1">another obvious general-purpose improvement technique that applies to low latency gaming applications as well. </span><span class="koboSpan" id="kobo.635.2">Adding additional RAM to the PC, smartphone, tablet, or console gives the game applications and graphics rendering tasks to perform their best. </span><span class="koboSpan" id="kobo.635.3">Thankfully, RAM costs have dropped tremendously over the last decade, so this is an easy way to boost the performance of gaming applications and is </span><span class="No-Break"><span class="koboSpan" id="kobo.636.1">highly recommended.</span></span></p>
<h4><span class="koboSpan" id="kobo.637.1">Tweaking the hardware, OS, and game settings</span></h4>
<p><span class="koboSpan" id="kobo.638.1">In the </span><a id="_idIndexMarker298"/><span class="koboSpan" id="kobo.639.1">previous subsection, we discussed some options for upgrading the</span><a id="_idIndexMarker299"/><span class="koboSpan" id="kobo.640.1"> hardware resources that lead to improved gaming applications </span><a id="_idIndexMarker300"/><span class="koboSpan" id="kobo.641.1">performance. </span><span class="koboSpan" id="kobo.641.2">In this subsection, we will discuss settings that can be optimized for the hardware, the platform, the OS, and the game settings themselves to further push gaming </span><span class="No-Break"><span class="koboSpan" id="kobo.642.1">application performance.</span></span></p>
<h4><span class="koboSpan" id="kobo.643.1">Enabling game mode</span></h4>
<p><span class="koboSpan" id="kobo.644.1">Game</span><a id="_idIndexMarker301"/><span class="koboSpan" id="kobo.645.1"> mode is a setting available for displays such as high-end TVs and similar high-end display monitors. </span><span class="koboSpan" id="kobo.645.2">Enabling game mode disables extra functionality in the display, which improves image and animation quality but comes at the price of higher latency. </span><span class="koboSpan" id="kobo.645.3">Enabling game mode will cause a slight deterioration in image quality but can help improve the low latency gaming application end user experience by reducing rendering latencies. </span><span class="koboSpan" id="kobo.645.4">An example of game mode is the Windows game mode on Windows 10, which optimizes gaming performance </span><span class="No-Break"><span class="koboSpan" id="kobo.646.1">when enabled.</span></span></p>
<h4><span class="koboSpan" id="kobo.647.1">Using high-performance mode</span></h4>
<p><span class="koboSpan" id="kobo.648.1">The </span><a id="_idIndexMarker302"/><span class="koboSpan" id="kobo.649.1">high-performance mode we discuss here refers to power settings. </span><span class="koboSpan" id="kobo.649.2">Different power settings try to optimize between battery usage and performance; high-performance mode drains battery power faster and possibly raises the internal temperature more than low-performance mode but it boosts the performance of the </span><span class="No-Break"><span class="koboSpan" id="kobo.650.1">applications running.</span></span></p>
<h4><span class="koboSpan" id="kobo.651.1">Delaying automatic updates</span></h4>
<p><span class="koboSpan" id="kobo.652.1">Automatic</span><a id="_idIndexMarker303"/><span class="koboSpan" id="kobo.653.1"> updates are a feature most notably available in Windows, which downloads and installs security fixes automatically. </span><span class="koboSpan" id="kobo.653.2">While this is typically not a major problem, if a particularly large automatic update download and install starts while we are in the middle of an online gaming session, then it can affect the gaming performance and experience. </span><span class="koboSpan" id="kobo.653.3">Automatic updates can spike processor usage and bandwidth consumption if this coincides with a gaming session utilizing high processor usage and bandwidth, and can degrade the gaming performance. </span><span class="koboSpan" id="kobo.653.4">So, turning off or delaying automatic Windows updates is usually a good idea when running latency-sensitive and resource-intensive </span><span class="No-Break"><span class="koboSpan" id="kobo.654.1">gaming applications.</span></span></p>
<h4><span class="koboSpan" id="kobo.655.1">Turning off background services</span></h4>
<p><span class="koboSpan" id="kobo.656.1">This is </span><a id="_idIndexMarker304"/><span class="koboSpan" id="kobo.657.1">another option similar to delaying automatic updates we just discussed. </span><span class="koboSpan" id="kobo.657.2">Here, we find and turn off apps and services that might be running in the background but are not necessarily needed for a low latency gaming session to function properly. </span><span class="koboSpan" id="kobo.657.3">In fact, turning these off prevents these applications from consuming hardware resources unexpectedly and non-deterministically during gaming sessions. </span><span class="koboSpan" id="kobo.657.4">This maximizes the low latency gaming application performance by making the maximum amount of resources available to </span><span class="No-Break"><span class="koboSpan" id="kobo.658.1">that application.</span></span></p>
<h4><span class="koboSpan" id="kobo.659.1">Meeting or exceeding refresh rates</span></h4>
<p><span class="koboSpan" id="kobo.660.1">We have</span><a id="_idIndexMarker305"/><span class="koboSpan" id="kobo.661.1"> discussed the concept of screen tearing before, so we at least need a system where the FPS meets or exceeds the refresh rate to prevent it. </span><span class="koboSpan" id="kobo.661.2">Technologies</span><a id="_idIndexMarker306"/><span class="koboSpan" id="kobo.662.1"> such as FreeSync and G-Sync facilitate smooth rendering without any screen tearing while still providing low latency performance. </span><span class="koboSpan" id="kobo.662.2">When frame rates exceed refresh rates, the latency continues to remain low, but if frame rates start exceeding refresh rates by a large magnitude, screen tearing can show up again. </span><span class="koboSpan" id="kobo.662.3">This can be addressed by using V-Sync technology or limiting FPS intentionally. </span><span class="koboSpan" id="kobo.662.4">FreeSync and G-Sync need hardware support, so you need a compatible GPU to use these technologies. </span><span class="koboSpan" id="kobo.662.5">But the upside with FreeSync and G-Sync is that you can completely disable V-Sync, which introduces latencies, and instead have a low latency and tear-free rendering experience as long as you have the hardware support </span><span class="No-Break"><span class="koboSpan" id="kobo.663.1">for it.</span></span></p>
<h4><span class="koboSpan" id="kobo.664.1">Disabling triple buffering and V-Sync and running exclusively in full-screen mode</span></h4>
<p><span class="koboSpan" id="kobo.665.1">We have</span><a id="_idIndexMarker307"/><span class="koboSpan" id="kobo.666.1"> explained before that V-Sync can introduce additional latency due to the need to synchronize the frames rendered by the GPU with the display device. </span><strong class="bold"><span class="koboSpan" id="kobo.667.1">Triple buffering</span></strong><span class="koboSpan" id="kobo.668.1"> is just</span><a id="_idIndexMarker308"/><span class="koboSpan" id="kobo.669.1"> another form of V-Sync and has the same goal of reducing screen tearing. </span><span class="koboSpan" id="kobo.669.2">Triple buffering especially comes into play when running a game in windowed mode, in which the game runs inside a window instead of full screen. </span><span class="koboSpan" id="kobo.669.3">The key takeaway here is that to disable V-Sync and triple buffering to improve latency and performance, we have to run exclusively in </span><span class="No-Break"><span class="koboSpan" id="kobo.670.1">full-screen mode.</span></span></p>
<h4><span class="koboSpan" id="kobo.671.1">Optimizing game settings for low latency and high frame rate</span></h4>
<p><span class="koboSpan" id="kobo.672.1">Modern </span><a id="_idIndexMarker309"/><span class="koboSpan" id="kobo.673.1">games come with a plethora of options and settings designed to maximize performance (sometimes at the cost of rendering quality), and the end user can optimize these parameters for their target hardware, platform, network resources, and performance requirements. </span><span class="koboSpan" id="kobo.673.2">Reducing settings such </span><a id="_idIndexMarker310"/><span class="koboSpan" id="kobo.674.1">as </span><strong class="bold"><span class="koboSpan" id="kobo.675.1">anti-aliasing</span></strong><span class="koboSpan" id="kobo.676.1"> would be an example, and reducing resolution is another option. </span><span class="koboSpan" id="kobo.676.2">Finally, adjusting settings related to the viewing distance, texture rendering, shadows, and lighting can also maximize performance at the cost of lower rendering quality. </span><span class="koboSpan" id="kobo.676.3">Anti-aliasing seeks to render smooth edges instead of jagged edges when we try to render high-resolution images in low-resolution environments, so turning it down deteriorates image smoothness but accelerates low latency performance. </span><span class="koboSpan" id="kobo.676.4">Advanced rendering effects such as fire, water, motion blur, and lens flares can also be turned down if additional performance </span><span class="No-Break"><span class="koboSpan" id="kobo.677.1">is required.</span></span></p>
<h3><span class="koboSpan" id="kobo.678.1">Further optimizing your hardware</span></h3>
<p><span class="koboSpan" id="kobo.679.1">In the last two subsections, we discussed options for optimizing low latency gaming applications by upgrading hardware resources and tweaking the hardware, OS, and game settings. </span><span class="koboSpan" id="kobo.679.2">In this final subsection, we will discuss how to squeeze the performance even further and what our options are to further optimize online low latency gaming </span><span class="No-Break"><span class="koboSpan" id="kobo.680.1">application performance.</span></span></p>
<h4><span class="koboSpan" id="kobo.681.1">Installing DirectX 12 Ultimate</span></h4>
<p><span class="koboSpan" id="kobo.682.1">DirectX</span><a id="_idIndexMarker311"/><span class="koboSpan" id="kobo.683.1"> is a Windows graphics and gaming API developed by Microsoft. </span><span class="koboSpan" id="kobo.683.2">Upgrading DirectX to the latest version means the gaming platform gets access to the latest fixes and improvements and</span><a id="_idIndexMarker312"/><span class="koboSpan" id="kobo.684.1"> better performance. </span><span class="koboSpan" id="kobo.684.2">At this time, DirectX 12 Ultimate is the latest version, with DirectX 13 expected to be released at the end of 2022 or </span><span class="No-Break"><span class="koboSpan" id="kobo.685.1">early 2023.</span></span></p>
<h4><span class="koboSpan" id="kobo.686.1">Defragmenting and optimizing disks</span></h4>
<p><span class="koboSpan" id="kobo.687.1">Defragmentation</span><a id="_idIndexMarker313"/><span class="koboSpan" id="kobo.688.1"> of disks occurs as files are created and deleted on the hard disk and the free and used disk space blocks are spread out or fragmented causing lower driver performance. </span><strong class="bold"><span class="koboSpan" id="kobo.689.1">Hard Disk Drives</span></strong><span class="koboSpan" id="kobo.690.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.691.1">HDD</span></strong><span class="koboSpan" id="kobo.692.1">) and </span><strong class="bold"><span class="koboSpan" id="kobo.693.1">Solid State Drives</span></strong><span class="koboSpan" id="kobo.694.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.695.1">SSD</span></strong><span class="koboSpan" id="kobo.696.1">) are </span><a id="_idIndexMarker314"/><span class="koboSpan" id="kobo.697.1">typically the two commonly used storage options</span><a id="_idIndexMarker315"/><span class="koboSpan" id="kobo.698.1"> for most gaming platforms. </span><span class="koboSpan" id="kobo.698.2">SSDs are significantly faster than HDDs and do not typically suffer from a lot of fragmentation-related issues but can still become suboptimal over time. </span><span class="koboSpan" id="kobo.698.3">Windows, for instance, has a defragmentation and optimization application to optimize the performance of the drives, which can improve gaming application performance </span><span class="No-Break"><span class="koboSpan" id="kobo.699.1">as well.</span></span></p>
<h4><span class="koboSpan" id="kobo.700.1">Ensuring the laptop cools optimally</span></h4>
<p><span class="koboSpan" id="kobo.701.1">When under heavy loads</span><a id="_idIndexMarker316"/><span class="koboSpan" id="kobo.702.1"> due to high processor, network, memory, and disk usage, the internal temperatures of the laptop or PC are raised. </span><span class="koboSpan" id="kobo.702.2">Other than being dangerous, it also forces the laptop to try and cool itself down by limiting resource consumption and thus, ultimately, performance. </span><span class="koboSpan" id="kobo.702.3">We mention laptops specifically to explain this issue because PCs typically have better airflow and cooling abilities than laptops. </span><span class="koboSpan" id="kobo.702.4">Ensuring that laptops cool effectively by clearing the vents and fans, removing dirt and dust, placing them on a hard, smooth, and flat surface, using an external power supply to not drain the battery, and possibly even using additional cooling stands can boost gaming performance </span><span class="No-Break"><span class="koboSpan" id="kobo.703.1">on laptops.</span></span></p>
<h4><span class="koboSpan" id="kobo.704.1">Using NVIDIA Reflex low latency technology</span></h4>
<p><strong class="bold"><span class="koboSpan" id="kobo.705.1">NVIDIA Reflex</span></strong><span class="koboSpan" id="kobo.706.1"> low latency technology</span><a id="_idIndexMarker317"/><span class="koboSpan" id="kobo.707.1"> seeks to minimize the input lag measured from the moment the user clicks the mouse or hits a key on the keyboard or controller to the time at which the impact of that action is rendered on screen. </span><span class="koboSpan" id="kobo.707.2">We have already discussed the sources of latency here, and NVIDIA breaks this down into nine chunks from the input device to the processors and the display. </span><span class="koboSpan" id="kobo.707.3">The NVIDIA Reflex software speeds up this critical path performance by improving communication paths between CPUs and GPUs, optimizing frame delivery and rendering by skipping unnecessary tasks and pauses, and accelerating the GPU rendering time. </span><span class="koboSpan" id="kobo.707.4">NVIDIA also provides an NVIDIA Reflex Latency Analyzer to measure the speed-up achieved by using these low </span><span class="No-Break"><span class="koboSpan" id="kobo.708.1">latency enhancements.</span></span></p>
<h1 id="_idParaDest-48"><a id="_idTextAnchor047"/><span class="koboSpan" id="kobo.709.1">Discussing the design of IoT and retail analytics systems</span></h1>
<p><span class="koboSpan" id="kobo.710.1">In the previous chapter, we discussed </span><strong class="bold"><span class="koboSpan" id="kobo.711.1">IoT</span></strong><span class="koboSpan" id="kobo.712.1"> and </span><a id="_idIndexMarker318"/><span class="koboSpan" id="kobo.713.1">retail analytics and many of the different use cases that they create. </span><span class="koboSpan" id="kobo.713.2">Our focus in this section will be to have a brief discussion about the technologies being used to achieve low latency performance for these applications and use cases. </span><span class="koboSpan" id="kobo.713.3">Note that IoT is a technology space that is still actively growing and evolving, so there are going to be a lot of breakthroughs and advancements in the coming years. </span><span class="koboSpan" id="kobo.713.4">Let us quickly recap some important use cases of IoT and retail data analytics. </span><span class="koboSpan" id="kobo.713.5">A lot of these new applications and future possibilities are</span><a id="_idIndexMarker319"/><span class="koboSpan" id="kobo.714.1"> fueled by the research and advancements in 5G wireless technology, </span><strong class="bold"><span class="koboSpan" id="kobo.715.1">edge computing</span></strong><span class="koboSpan" id="kobo.716.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.717.1">artificial intelligence</span></strong><span class="koboSpan" id="kobo.718.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.719.1">AI</span></strong><span class="koboSpan" id="kobo.720.1">). </span><span class="koboSpan" id="kobo.720.2">We will</span><a id="_idIndexMarker320"/><span class="koboSpan" id="kobo.721.1"> look at those aspects in the next section, along with other technologies that facilitate applications using low latency IoT and retail </span><span class="No-Break"><span class="koboSpan" id="kobo.722.1">data analytics.</span></span></p>
<p><span class="koboSpan" id="kobo.723.1">A lot of applications fall under the remote inspection/analysis category, where drones can replace humans when it comes to being the first line of defense in fields such as remote technicians, monitoring infrastructure such as bridges, tunnels, railways, highways, and waterways, and even things such as transformers, utility wires, gas pipelines, and electricity and telephone lines. </span><span class="koboSpan" id="kobo.723.2">Incorporating AI into such applications enhances the complexity of the data analysis possible and thus creates new opportunities and use cases. </span><span class="koboSpan" id="kobo.723.3">Incorporating AR technology also increases the possibilities. </span><span class="koboSpan" id="kobo.723.4">Modern automobiles collect large amounts of data and, with the possibility of having autonomous driving vehicles at some point, the use cases for IoT only expand further. </span><span class="koboSpan" id="kobo.723.5">Automation in agriculture, shipping and logistics, supply chain management, inventory, and warehouse management, and managing fleets of vehicles creates numerous additional use cases for IoT technology and analyzes data generated from and collected by </span><span class="No-Break"><span class="koboSpan" id="kobo.724.1">these devices.</span></span></p>
<h2 id="_idParaDest-49"><a id="_idTextAnchor048"/><span class="koboSpan" id="kobo.725.1">Ensuring low latency in IoT devices</span></h2>
<p><span class="koboSpan" id="kobo.726.1">In this section, we will look at some </span><a id="_idIndexMarker321"/><span class="koboSpan" id="kobo.727.1">considerations to facilitate low latency performance in IoT applications and retail analytics. </span><span class="koboSpan" id="kobo.727.2">Note that a lot of the considerations we discussed for real-time video streaming and online video gaming use cases apply here as well, such as hardware resources, encoding and decoding data streams, content delivery mechanisms, and hardware and system-level optimizations. </span><span class="koboSpan" id="kobo.727.3">We will not repeat those techniques here in the interest of brevity, but we will present additional low latency considerations that apply specifically to IoT and retail </span><span class="No-Break"><span class="koboSpan" id="kobo.728.1">data analysis.</span></span></p>
<h3><span class="koboSpan" id="kobo.729.1">P2P connectivity</span></h3>
<p><span class="koboSpan" id="kobo.730.1">P2P connectivity for IoT</span><a id="_idIndexMarker322"/><span class="koboSpan" id="kobo.731.1"> devices establishes direct connectivity between different IoT devices or between an IoT device and the end user application. </span><span class="koboSpan" id="kobo.731.2">The user’s input from their device is directly sent to the IoT device that it is meant for without any third-party service or server in between to minimize latencies. </span><span class="koboSpan" id="kobo.731.3">Similarly, data from the IoT devices is streamed back to the other devices directly from the device. </span><span class="koboSpan" id="kobo.731.4">The P2P approach is an alternative to connecting to the IoT device through a cloud, which has extra latencies due to additional server databases, cloud worker instances, and</span><a id="_idIndexMarker323"/><span class="koboSpan" id="kobo.732.1"> so on. </span><span class="koboSpan" id="kobo.732.2">P2P is also referred to as a decentralized </span><strong class="bold"><span class="koboSpan" id="kobo.733.1">Application Enablement Platform</span></strong><span class="koboSpan" id="kobo.734.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.735.1">AEP</span></strong><span class="koboSpan" id="kobo.736.1">) for IoT, which is an alternative to the </span><span class="No-Break"><span class="koboSpan" id="kobo.737.1">cloud-based AEPs.</span></span></p>
<h3><span class="koboSpan" id="kobo.738.1">Using fifth-generation wireless (5G)</span></h3>
<p><span class="koboSpan" id="kobo.739.1">5G wireless </span><a id="_idIndexMarker324"/><span class="koboSpan" id="kobo.740.1">technology delivers higher bandwidth, ultra-low latency, reliability, and scalability. </span><span class="koboSpan" id="kobo.740.2">Not only do the end users benefit from 5G but it also helps each step of the IoT devices and applications that require low latency and real-time data streaming and processing. </span><span class="koboSpan" id="kobo.740.3">5G’s low latency facilitates faster and more reliable inventory tracking, transportation services and monitoring, real-time visibility into distribution logistics, and more. </span><span class="koboSpan" id="kobo.740.4">The 5G network was designed keeping all the different IoT use cases in mind, so it is an excellent fit for all kinds of IoT applications </span><span class="No-Break"><span class="koboSpan" id="kobo.741.1">and more.</span></span></p>
<h3><span class="koboSpan" id="kobo.742.1">Understanding edge computing</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.743.1">Edge computing</span></strong><span class="koboSpan" id="kobo.744.1"> is a distributed </span><a id="_idIndexMarker325"/><span class="koboSpan" id="kobo.745.1">processing technology</span><a id="_idIndexMarker326"/><span class="koboSpan" id="kobo.746.1"> where the key point is to bring the processing application and the data storage components as close to the source of data as possible, which, in this case, is the IoT devices that capture the data. </span><span class="koboSpan" id="kobo.746.2">Edge computing breaks the older paradigm where the data is recorded by remote devices and then transferred to a central storage and processing location and then results are transported back to the devices and client applications. </span><span class="koboSpan" id="kobo.746.3">This exciting new technology is revolutionizing how massive amounts of data generated by a lot of IoT devices are transported, stored, and processed. </span><span class="koboSpan" id="kobo.746.4">The main goals for edge computing are to reduce bandwidth costs to transfer massive amounts of data across wide distances and to support ultra-low latency to facilitate real-time applications that need to process massive amounts of data as quickly and efficiently as possible. </span><span class="koboSpan" id="kobo.746.5">Additionally, it also reduces costs for businesses because they do not necessarily need a centralized and cloud-based storage and processing solution. </span><span class="koboSpan" id="kobo.746.6">This point is especially important when it comes to IoT applications because the sheer scale of how many devices generate data means the bandwidth consumption will </span><span class="No-Break"><span class="koboSpan" id="kobo.747.1">increase exponentially.</span></span></p>
<p><span class="koboSpan" id="kobo.748.1">Understanding </span><a id="_idIndexMarker327"/><span class="koboSpan" id="kobo.749.1">all the details of the physical architecture of an edge computing system is difficult and outside the scope of this book. </span><span class="koboSpan" id="kobo.749.2">However, at a very high level, the client devices and IoT devices connect to edge modules that are available nearby. </span><span class="koboSpan" id="kobo.749.3">Typically, there are many gateways and servers that are deployed by service providers or enterprises looking to build their own edge network to support such edge computing operations. </span><span class="koboSpan" id="kobo.749.4">The devices that can use these edge modules range from IoT sensors, laptops and computers, smartphones and tablets, cameras, microphones, and anything else you </span><span class="No-Break"><span class="koboSpan" id="kobo.750.1">can imagine.</span></span></p>
<h4><span class="koboSpan" id="kobo.751.1">Understanding the relationship between 5G and edge computing</span></h4>
<p><span class="koboSpan" id="kobo.752.1">We mentioned before that</span><a id="_idIndexMarker328"/><span class="koboSpan" id="kobo.753.1"> 5G was designed and developed keeping IoT and edge computing in mind. </span><span class="koboSpan" id="kobo.753.2">So IoT, 5G, and edge computing are all related to each other and work with each other to maximize the use cases and performance of these IoT applications. </span><span class="koboSpan" id="kobo.753.3">Theoretically, edge computing could be deployed to non-5G networks, but obviously, 5G is the preferred network. </span><span class="koboSpan" id="kobo.753.4">However, the reverse is not true; to leverage 5G’s true power, you need an edge computing infrastructure to really maximize the use of everything 5G offers. </span><span class="koboSpan" id="kobo.753.5">This is intuitive because, without an edge computing infrastructure, the data from the devices must travel long distances to get processed, and then results must travel a long distance to reach the end user’s applications or other devices. </span><span class="koboSpan" id="kobo.753.6">In those cases, even if you have a 5G network, the latency due to the data’s travel distance far outweighs the latency improvements gained by using 5G. </span><span class="koboSpan" id="kobo.753.7">So, edge computing is necessary when it comes to IoT applications and applications that need to analyze retail data in </span><span class="No-Break"><span class="koboSpan" id="kobo.754.1">real time.</span></span></p>
<h4><span class="koboSpan" id="kobo.755.1">Understanding the relationship between edge computing and AI</span></h4>
<p><span class="koboSpan" id="kobo.756.1">Data analytics </span><a id="_idIndexMarker329"/><span class="koboSpan" id="kobo.757.1">techniques, machine learning, and AI have revolutionized how the retail and non-retail data collected from IoT devices is analyzed to derive meaningful insights. </span><span class="koboSpan" id="kobo.757.2">NVIDIA is a pioneer when it comes to developing new hardware solutions to push not only edge computing but also AI processing to the maximum. </span><span class="koboSpan" id="kobo.757.3">Jetson AGX Orin is a particularly good example of how NVIDIA packages AI and robotics functionality together into a </span><span class="No-Break"><span class="koboSpan" id="kobo.758.1">single product.</span></span></p>
<p><span class="koboSpan" id="kobo.759.1">We will not go into too many details about the Jetson AGX Orin since that is neither the focus nor within the scope of this book. </span><span class="koboSpan" id="kobo.759.2">The Jetson AGX Orin has a few qualities that make it excellent for AI, robotics, and autonomous vehicles – it is compact, enormously powerful, and energy-efficient. </span><span class="koboSpan" id="kobo.759.3">The power and energy efficiency allows it to be used for AI applications and </span><a id="_idIndexMarker330"/><span class="koboSpan" id="kobo.760.1">enable edge computing. </span><span class="koboSpan" id="kobo.760.2">This latest model in particular lets developers combine AI, robotics, </span><strong class="bold"><span class="koboSpan" id="kobo.761.1">natural language processing</span></strong><span class="koboSpan" id="kobo.762.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.763.1">NLP</span></strong><span class="koboSpan" id="kobo.764.1">), computer</span><a id="_idIndexMarker331"/><span class="koboSpan" id="kobo.765.1"> vision, and so on into a compact package, making it excellent for robotics. </span><span class="koboSpan" id="kobo.765.2">This device also has multiple I/O connectors and is compatible with many different sensors (MIPI, USB, cameras, etc.). </span><span class="koboSpan" id="kobo.765.3">There are also additional hardware expansion slots to support storage, wireless, and so on. </span><span class="koboSpan" id="kobo.765.4">This powerful GPU-powered device makes it perfect for deep learning (in addition to classic machine learning) and computer vision applications such </span><span class="No-Break"><span class="koboSpan" id="kobo.766.1">as robotics.</span></span></p>
<h4><span class="koboSpan" id="kobo.767.1">Buying and deploying edge computing systems</span></h4>
<p><span class="koboSpan" id="kobo.768.1">When it </span><a id="_idIndexMarker332"/><span class="koboSpan" id="kobo.769.1">comes to purchasing and setting up an edge computing infrastructure, businesses generally go down one of two routes: customize the components and build and manage the infrastructure in-house or use a vendor that provides and manages edge services for </span><span class="No-Break"><span class="koboSpan" id="kobo.770.1">the enterprise.</span></span></p>
<p><span class="koboSpan" id="kobo.771.1">Building and managing the edge</span><a id="_idIndexMarker333"/><span class="koboSpan" id="kobo.772.1"> computing infrastructure in-house needs expertise from the IT, network, and business departments. </span><span class="koboSpan" id="kobo.772.2">Then, they can select the edge devices from hardware vendors (such as IBM, Dell, etc.) and architect and manage the 5G network infrastructure for the specific use case. </span><span class="koboSpan" id="kobo.772.3">This option only makes sense for a large enterprise that sees value in customizing its edge computing infrastructure for a specific use case. </span><span class="koboSpan" id="kobo.772.4">When it comes to the option of having a third-party vendor facilitate and manage the edge computing infrastructure, the vendor sets up the hardware, software, and networking architecture for a fee. </span><span class="koboSpan" id="kobo.772.5">This leaves the management of a complicated system such as edge computing infrastructure to firms such as GE and Siemens with expertise in this field and allows the client business to focus on building on top of </span><span class="No-Break"><span class="koboSpan" id="kobo.773.1">this infrastructure.</span></span></p>
<h3><span class="koboSpan" id="kobo.774.1">Leveraging proximity</span></h3>
<p><span class="koboSpan" id="kobo.775.1">We have</span><a id="_idIndexMarker334"/><span class="koboSpan" id="kobo.776.1"> implicitly discussed this point in the previous sections, but now we will explicitly discuss it here. </span><span class="koboSpan" id="kobo.776.2">A key requirement of IoT applications is achieving ultra-low latency performance, and the key to achieving that is leveraging proximity between the different devices and applications involved in the IoT use case. </span><span class="koboSpan" id="kobo.776.3">It is no surprise that edge computing is the key to leveraging proximity for IoT applications to minimize latencies from capturing data to processing it and sharing results with other devices or client applications. </span><span class="koboSpan" id="kobo.776.4">As we have seen before, the biggest bottleneck with a non-edge computing infrastructure is the distance of data centers and processing resources from the source of the data and the destination of the results. </span><span class="koboSpan" id="kobo.776.5">This gets worse with additional distributed data centers spread out miles away from each other, and ultimately leads to critically high latencies and lags. </span><span class="koboSpan" id="kobo.776.6">Clearly, placing edge computing resources closer to the data sources is the key to driving IoT adoption, IoT use cases, and scaling IoT businesses to a huge number of devices </span><span class="No-Break"><span class="koboSpan" id="kobo.777.1">and users.</span></span></p>
<h3><span class="koboSpan" id="kobo.778.1">Reducing cloud costs</span></h3>
<p><span class="koboSpan" id="kobo.779.1">This is another</span><a id="_idIndexMarker335"/><span class="koboSpan" id="kobo.780.1"> point we have discussed before, but we will have a formal conversation about it in this section. </span><span class="koboSpan" id="kobo.780.2">There are billions of IoT devices out there and they generate a continuous stream of data. </span><span class="koboSpan" id="kobo.780.3">Any effective IoT-driven business will need to scale extremely well to large increases in the number of devices and clients involved, which leads to exponential increases in the amount of data recorded and data processed by edge computing, and the results being transferred to other devices and clients. </span><span class="koboSpan" id="kobo.780.4">Data-heavy infrastructures that rely on centralized cloud infrastructure cannot support IoT applications in a cost-effective manner and the data and cloud infrastructure itself becomes a significant fraction of an enterprise’s expenses. </span><span class="koboSpan" id="kobo.780.5">The clear solution here is to find a low-cost edge solution (third-party or in-house) and use it to facilitate the IoT data capture, storage, and processing needs. </span><span class="koboSpan" id="kobo.780.6">This removes the costs associated with transferring data in and out of cloud solutions and can improve edge computing reliability and cut </span><span class="No-Break"><span class="koboSpan" id="kobo.781.1">costs significantly.</span></span></p>
<p><span class="koboSpan" id="kobo.782.1">We will conclude our discussion of low latency IoT applications by summarizing the current and future state of IoT applications in the </span><span class="No-Break"><span class="koboSpan" id="kobo.783.1">following figure:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer018">
<span class="koboSpan" id="kobo.784.1"><img alt="Figure 2.4 – Current and future states of IoT applications" src="image/Figure_2.4_B19434.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.785.1">Figure 2.4 – Current and future states of IoT applications</span></p>
<h1 id="_idParaDest-50"><a id="_idTextAnchor049"/><span class="koboSpan" id="kobo.786.1">Exploring low latency electronic trading</span></h1>
<p><span class="koboSpan" id="kobo.787.1">The final example of low latency</span><a id="_idIndexMarker336"/><span class="koboSpan" id="kobo.788.1"> applications is the applications used in low latency electronic trading and ultra-low latency electronic trading, also known as HFT. </span><span class="koboSpan" id="kobo.788.2">We will build a full end-to-end low latency electronic trading system from scratch in C++ in the rest of this book. </span><span class="koboSpan" id="kobo.788.3">So, in this section, we will briefly discuss the important considerations for electronic trading applications to achieve low latency performance and then build out the low-level details in the remaining chapters. </span><em class="italic"><span class="koboSpan" id="kobo.789.1">Developing High-Frequency Trading Systems</span></em><span class="koboSpan" id="kobo.790.1"> by Sebastian Donadio, Sourav Ghosh, and Romain Rossier would be an excellent book for understanding low latency electronic trading systems in greater detail for interested readers. </span><span class="koboSpan" id="kobo.790.2">Our focus in this book will be to design and build each component from scratch in C++ to learn about low latency application development, but that book can be used as a good reference for the additional theory behind the </span><span class="No-Break"><span class="koboSpan" id="kobo.791.1">HFT business.</span></span></p>
<h2 id="_idParaDest-51"><a id="_idTextAnchor050"/><span class="koboSpan" id="kobo.792.1">Understanding the need for low latency in modern electronic trading</span></h2>
<p><span class="koboSpan" id="kobo.793.1">With the </span><a id="_idIndexMarker337"/><span class="koboSpan" id="kobo.794.1">modernization of electronic trading and the rise of</span><a id="_idIndexMarker338"/><span class="koboSpan" id="kobo.795.1"> HFT, low latencies are more important than ever before for these applications. </span><span class="koboSpan" id="kobo.795.2">In many cases, achieving lower latency leads to a direct increase in trading revenue. </span><span class="koboSpan" id="kobo.795.3">In some cases, there is a constant race to try and reduce latencies more and more to maintain a competitive edge in the markets. </span><span class="koboSpan" id="kobo.795.4">And in extreme cases, if a participant falls behind in the arms race to the lowest possible laten</span><a id="_idTextAnchor051"/><span class="koboSpan" id="kobo.796.1">cies, they may go out </span><span class="No-Break"><span class="koboSpan" id="kobo.797.1">of business.</span></span></p>
<p><span class="koboSpan" id="kobo.798.1">Trading opportunities in modern electronic markets are extremely short-lived, so only the market participants that can process market data and find such an opportunity and quickly send orders in reaction to this can be profitable. </span><span class="koboSpan" id="kobo.798.2">Failure to react quickly enough means you get a smaller piece of the opportunity, and it is common for only the fastest participant to get all the profit, and for all other slower participants to get nothing. </span><span class="koboSpan" id="kobo.798.3">Another nuance here is that if a participant is not quick enough to react to a market event, they can also be caught on the wrong side of the trade and lose money to people who were able to react to the event quickly enough. </span><span class="koboSpan" id="kobo.798.4">In such a case, trading profits are not just lower, but trading revenue can be negative (i.e., losses). </span><span class="koboSpan" id="kobo.798.5">To understand this better, let us present an example of something we will build in this book: market-making and </span><span class="No-Break"><span class="koboSpan" id="kobo.799.1">liquidity-taking algorithms.</span></span></p>
<p><span class="koboSpan" id="kobo.800.1">Without going into too many details, a market-making algorithm has orders in the market that other participants can trade against when needed. </span><span class="koboSpan" id="kobo.800.2">A market-making algorithm thus needs to constantly re-evaluate its active orders and change the prices and quantities </span><a id="_idIndexMarker339"/><span class="koboSpan" id="kobo.801.1">for them depending on the market conditions. </span><span class="koboSpan" id="kobo.801.2">A liquidity-taking algorithm, however, does not always have active orders in the market. </span><span class="koboSpan" id="kobo.801.3">This algorithm instead waits for an opportunity to present itself and then trades against a market-making algorithm’s active order in the book. </span><span class="koboSpan" id="kobo.801.4">A simple view of the HFT </span><a id="_idIndexMarker340"/><span class="koboSpan" id="kobo.802.1">market would be a constant battle between market-making and liquidity-taking algorithms because they naturally take </span><span class="No-Break"><span class="koboSpan" id="kobo.803.1">opposite sides.</span></span></p>
<p><span class="koboSpan" id="kobo.804.1">In this setup, a market-making algorithm loses money when it is slow at modifying its active orders in the market. </span><span class="koboSpan" id="kobo.804.2">For instance, say depending on market conditions, it is quite clear that the market prices are going to go up in the short term; a market-making algorithm will try to move or cancel its sell orders if they are at risk of being executed since it no longer wants to sell at those prices. </span><span class="koboSpan" id="kobo.804.3">A liquidity-taking algorithm, at the same time, will try to see whether it can send a buy order to trade against a market maker’s sell order at that price. </span><span class="koboSpan" id="kobo.804.4">In this race, if the market-making algorithm is slower than the liquidity-taking algorithms, it will not be able to modify or cancel its sell order. </span><span class="koboSpan" id="kobo.804.5">If the liquidity-taking algorithm is slow, it will not be able to execute against the orders it wanted to either because a different (and faster) algorithm was able to execute before it or because the market maker was able to move out of the way. </span><span class="koboSpan" id="kobo.804.6">This example should make it clear to you that latency directly affects trading revenue in </span><span class="No-Break"><span class="koboSpan" id="kobo.805.1">electronic trading.</span></span></p>
<p><span class="koboSpan" id="kobo.806.1">For HFT, trading applications on the client’s side can receive and process market data, analyze the information, look for opportunities, and send an order out to the exchange, all within sub-10-microsecond latency, and using </span><strong class="bold"><span class="koboSpan" id="kobo.807.1">Field-Programmable Gate Arrays</span></strong><span class="koboSpan" id="kobo.808.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.809.1">FPGAs</span></strong><span class="koboSpan" id="kobo.810.1">), can reduce </span><a id="_idIndexMarker341"/><span class="koboSpan" id="kobo.811.1">that to sub-1-microsecond latency. </span><span class="koboSpan" id="kobo.811.2">FPGAs are special hardware chips that are re-programmable and can be used to build extremely specialized and low latency functionality directly onto the chip itself. </span><span class="koboSpan" id="kobo.811.3">Understanding the details and developing and using FPGAs is an advanced topic beyond this </span><span class="No-Break"><span class="koboSpan" id="kobo.812.1">book’s scope.</span></span></p>
<p><span class="koboSpan" id="kobo.813.1">While we </span><a id="_idIndexMarker342"/><span class="koboSpan" id="kobo.814.1">have referred to trading performance and</span><a id="_idIndexMarker343"/><span class="koboSpan" id="kobo.815.1"> revenue in the previous example, low latencies are also important in other aspects of electronic trading businesses that might not be immediately obvious. </span><span class="koboSpan" id="kobo.815.2">Obviously, trading revenues and performance are still the primary focus for trading applications; another important requirement for long-term business continuity is real-time risk management. </span><span class="koboSpan" id="kobo.815.3">Since each electronic market has many trading instruments and each of those continuously changes prices throughout the day, there is a tremendous amount of data that the risk management system needs to keep up with, across all the exchanges and all the products available throughout </span><span class="No-Break"><span class="koboSpan" id="kobo.816.1">the day.</span></span></p>
<p><span class="koboSpan" id="kobo.817.1">Additionally, since a firm employs HFT strategies across all these products and exchanges, the firm’s position on each of these products changes rapidly all day long. </span><span class="koboSpan" id="kobo.817.2">A real-time risk management system needs to evaluate the firm’s constantly evolving exposure across all these products against market prices to track profits and losses and risk throughout the day. </span><span class="koboSpan" id="kobo.817.3">The risk evaluation metrics and systems can themselves be quite complicated; for instance, in options trading, it is common to run Monte Carlo simulations to try and find worst-case risk evaluations in real time or very close to real time. </span><span class="koboSpan" id="kobo.817.4">Some risk management systems are also in charge of shutting down automated trading strategies if they exceed any of their risk limits. </span><span class="koboSpan" id="kobo.817.5">These risk systems are often added to multiple </span><a id="_idIndexMarker344"/><span class="koboSpan" id="kobo.818.1">components – a central risk system, the</span><a id="_idIndexMarker345"/><span class="koboSpan" id="kobo.819.1"> order gateways, and the trading strategies themselves – but we will understand these details later in </span><span class="No-Break"><span class="koboSpan" id="kobo.820.1">this book.</span></span></p>
<h2 id="_idParaDest-52"><a id="_idTextAnchor052"/><span class="koboSpan" id="kobo.821.1">Achieving the lowest latencies in electronic trading</span></h2>
<p><span class="koboSpan" id="kobo.822.1">In this section, we will </span><a id="_idIndexMarker346"/><span class="koboSpan" id="kobo.823.1">briefly discuss some of the higher-level ideas and concepts when it comes to implementing low latency electronic trading systems. </span><span class="koboSpan" id="kobo.823.2">We will, of course, revisit these with examples in greater detail as we work on building our electronic trading ecosystem in the </span><span class="No-Break"><span class="koboSpan" id="kobo.824.1">coming chapters.</span></span></p>
<h3><span class="koboSpan" id="kobo.825.1">Optimizing trading server hardware</span></h3>
<p><span class="koboSpan" id="kobo.826.1">Getting</span><a id="_idIndexMarker347"/><span class="koboSpan" id="kobo.827.1"> powerful trading servers to support the low latency trading operations is a first step. </span><span class="koboSpan" id="kobo.827.2">Typically, the processing power of these servers depends on the architecture of the trading system processes, such as how many processes we expect to run, how many network res</span><a id="_idTextAnchor053"/><span class="koboSpan" id="kobo.828.1">ources we expect to consume, and how much memory we expect these applications to consume. </span><span class="koboSpan" id="kobo.828.2">Typically, low latency trading applications have high CPU usage, low kernel usage (system calls), low memory consumption, and relatively high network resource usage during busy trading periods. </span><span class="koboSpan" id="kobo.828.3">CPU registers, cache architecture, and capacity matter as well, and typically, we try to get larger sizes, if possible, but these can be quite expensive. </span><span class="koboSpan" id="kobo.828.4">Advanced considerations such as </span><strong class="bold"><span class="koboSpan" id="kobo.829.1">Non-Uniform Memory Access</span></strong><span class="koboSpan" id="kobo.830.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.831.1">NUMA</span></strong><span class="koboSpan" id="kobo.832.1">), processor</span><a id="_idIndexMarker348"/><span class="koboSpan" id="kobo.833.1"> instruction sets, instruction pipelines and instruction parallelism, cache hierarchy architecture details, hyperthreading, and overclocked CPUs are often considered, but those are extremely advanced optimization techniques and outside the scope of </span><span class="No-Break"><span class="koboSpan" id="kobo.834.1">this book.</span></span></p>
<h3><span class="koboSpan" id="kobo.835.1">Network Interface Cards, switches, and kernel bypass</span></h3>
<p><span class="koboSpan" id="kobo.836.1">Trading </span><a id="_idIndexMarker349"/><span class="koboSpan" id="kobo.837.1">servers that need to support ultra-low latency trading applications (especially ones that must read massive amounts of market data, update packets from the network, and process them) need </span><a id="_idIndexMarker350"/><span class="koboSpan" id="kobo.838.1">specialized </span><strong class="bold"><span class="koboSpan" id="kobo.839.1">Network Interface Cards</span></strong><span class="koboSpan" id="kobo.840.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.841.1">NICs</span></strong><span class="koboSpan" id="kobo.842.1">) and switches. </span><span class="koboSpan" id="kobo.842.2">The NICs preferred for such applications need to have very low latency performance, low jitter, and large buffer capacities to handle market data bursts without dropping packets. </span><span class="koboSpan" id="kobo.842.3">Also, optimal NICs for modern electronic trading applications support an especially low-latency path that avoids system calls </span><a id="_idIndexMarker351"/><span class="koboSpan" id="kobo.843.1">and buffer copies, known</span><a id="_idIndexMarker352"/><span class="koboSpan" id="kobo.844.1"> as </span><strong class="bold"><span class="koboSpan" id="kobo.845.1">kernel bypass</span></strong><span class="koboSpan" id="kobo.846.1">. </span><span class="koboSpan" id="kobo.846.2">One </span><a id="_idIndexMarker353"/><span class="koboSpan" id="kobo.847.1">example is </span><strong class="bold"><span class="koboSpan" id="kobo.848.1">Solarflare</span></strong><span class="koboSpan" id="kobo.849.1">, which</span><a id="_idIndexMarker354"/><span class="koboSpan" id="kobo.850.1"> provides </span><strong class="bold"><span class="koboSpan" id="kobo.851.1">OpenOnload</span></strong><span class="koboSpan" id="kobo.852.1"> and APIs such as </span><strong class="bold"><span class="koboSpan" id="kobo.853.1">ef_vi</span></strong><span class="koboSpan" id="kobo.854.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.855.1">TCPDirect, which</span></strong> <a id="_idIndexMarker355"/><span class="koboSpan" id="kobo.856.1">bypass the kernel when </span><a id="_idIndexMarker356"/><span class="koboSpan" id="kobo.857.1">using their NICs; </span><strong class="bold"><span class="koboSpan" id="kobo.858.1">Exablaze</span></strong><span class="koboSpan" id="kobo.859.1"> is </span><a id="_idIndexMarker357"/><span class="koboSpan" id="kobo.860.1">another example of a specialized NIC that </span><a id="_idIndexMarker358"/><span class="koboSpan" id="kobo.861.1">supports kernel bypass. </span><span class="koboSpan" id="kobo.861.2">Network switches show up in various places in the network topology, which support interconnectivity between trading servers and trading servers that are located far away from each other and between trading servers and electronic exchange servers. </span><span class="koboSpan" id="kobo.861.3">For network switches, one of the important considerations is the size of the buffer that the switch can support to buffer packets that need to be forwarded. </span><span class="koboSpan" id="kobo.861.4">Another important requirement is the latency between a switch receiving a packet and forwarding it to the correct interface known </span><a id="_idIndexMarker359"/><span class="koboSpan" id="kobo.862.1">as </span><strong class="bold"><span class="koboSpan" id="kobo.863.1">switching latency</span></strong><span class="koboSpan" id="kobo.864.1">. </span><span class="koboSpan" id="kobo.864.2">Switching latencies are generally very low, in the order of tens of hundreds of nanoseconds, but this applies to all inbound or outbound traffic going through the switch, so needs to be consistently low to not have a negative impact on </span><span class="No-Break"><span class="koboSpan" id="kobo.865.1">trading performance.</span></span></p>
<h3><span class="koboSpan" id="kobo.866.1">Understanding multithreading, locks, context switches, and CPU scheduling</span></h3>
<p><span class="koboSpan" id="kobo.867.1">We have discussed the closely related but technically different concepts of bandwidth and low latency in the previous chapter. </span><span class="koboSpan" id="kobo.867.2">It is sometimes incorrectly assumed that having an architecture with a larger number of threads is always lower-latency, but this is not always true. </span><span class="koboSpan" id="kobo.867.3">Multithreading</span><a id="_idIndexMarker360"/><span class="koboSpan" id="kobo.868.1"> adds value in certain areas of low </span><a id="_idTextAnchor054"/><span class="koboSpan" id="kobo.869.1">latency electronic trading systems, and we will make use of it in the system we build in this book. </span><span class="koboSpan" id="kobo.869.2">But the point here is that we need to be</span><a id="_idIndexMarker361"/><span class="koboSpan" id="kobo.870.1"> careful when using additional threads in HFT systems because, while adding threads generally boosts throughput for applications that need it, it can sometimes end up increasing latencies in applications as well. </span><span class="koboSpan" id="kobo.870.2">As we increase the number of threads, we must think about concurrency and thread safety, and if we need to use locks for synchronization and concurrency between threads, that adds additional latencies and context switches. </span><span class="koboSpan" id="kobo.870.3">Context switches </span><a id="_idIndexMarker362"/><span class="koboSpan" id="kobo.871.1">are not free because the scheduler and OS must save the state of the thread or process being switched out and load the state of the thread or process that will be run next. </span><span class="koboSpan" id="kobo.871.2">Many lock implementations are built on top of kernel system calls, which are more expensive than user space routines, thus increasing the latencies in a heavily multithreaded application even further. </span><span class="koboSpan" id="kobo.871.3">For optimal performance, we try to get the</span><a id="_idIndexMarker363"/><span class="koboSpan" id="kobo.872.1"> CPU scheduler to do little to no work (i.e., processes and threads that are scheduled to run are never context switched out and keep running in user space). </span><span class="koboSpan" id="kobo.872.2">Additionally, it is quite common to pin specific threads and processes to specific CPU cores, which eliminates context switching and the OS needing to find free cores to schedule tasks, and additionally, improves memory </span><span class="No-Break"><span class="koboSpan" id="kobo.873.1">access efficiency.</span></span></p>
<h3><span class="koboSpan" id="kobo.874.1">Dynamically allocating memory and managing memory</span></h3>
<p><span class="koboSpan" id="kobo.875.1">Dynamic</span><a id="_idIndexMarker364"/><span class="koboSpan" id="kobo.876.1"> memory allocation is a request for memory blocks of arbitrary sizes made at runtime. </span><span class="koboSpan" id="kobo.876.2">At a very high level, dynamic memory allocations and deallocations are handled by the OS by looking through a list of free memory blocks and trying to allocate a contiguous block as large as the program requested. </span><span class="koboSpan" id="kobo.876.3">Dynamic memory deallocations are handled by appending the freed blocks to the list of free blocks managed by the OS. </span><span class="koboSpan" id="kobo.876.4">Searching through this list can incur higher and higher latencies as the program runs through the day and memory gets increasingly fragmented. </span><span class="koboSpan" id="kobo.876.5">Additionally, if dynamic memory</span><a id="_idIndexMarker365"/><span class="koboSpan" id="kobo.877.1"> allocations and deallocations are on the same critical path, then they incur an additional overhead every single time. </span><span class="koboSpan" id="kobo.877.2">This is one of the major reasons we discussed before that led us to choose C++ as our preferred language for building low latency and resource-constrained applications. </span><span class="koboSpan" id="kobo.877.3">We will explore the performance impact of dynamic memory allocation and techniques to avoid it during later chapters in this book as we build our own </span><span class="No-Break"><span class="koboSpan" id="kobo.878.1">trading system.</span></span></p>
<h3><span class="koboSpan" id="kobo.879.1">Static versus dynamic linking and compile time versus runtime</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.880.1">Linking</span></strong><span class="koboSpan" id="kobo.881.1"> is the </span><a id="_idIndexMarker366"/><span class="koboSpan" id="kobo.882.1">compilation or translation step in the process of converting high-level programming language source code into machine code for the target architecture. </span><span class="koboSpan" id="kobo.882.2">Linking ties together pieces of code that might be in different libraries – these can be libraries internal to the code base or external standalone libraries. </span><span class="koboSpan" id="kobo.882.3">During the</span><a id="_idIndexMarker367"/><span class="koboSpan" id="kobo.883.1"> linking step, we have two choices: </span><strong class="bold"><span class="koboSpan" id="kobo.884.1">static linking</span></strong><span class="koboSpan" id="kobo.885.1"> or </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.886.1">dynamic linking</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.887.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.888.1">Dynamic linking</span><a id="_idIndexMarker368"/><span class="koboSpan" id="kobo.889.1"> is when the linker does not incorporate the code from libraries into the final binary at linking time. </span><span class="koboSpan" id="kobo.889.2">Instead, when the main application requires code from the shared libraries for the first time, then the resolution is performed at runtime. </span><span class="koboSpan" id="kobo.889.3">Obviously, there is a particularly large extra cost incurred at runtime the first time the shared library code is called. </span><span class="koboSpan" id="kobo.889.4">The bigger downside is that since the compiler and linker do not incorporate the code at compilation and linking time, they are unable to perform possible optimizations, resulting in an application that can be </span><span class="No-Break"><span class="koboSpan" id="kobo.890.1">inefficient overall.</span></span></p>
<p><span class="koboSpan" id="kobo.891.1">Static linking is </span><a id="_idIndexMarker369"/><span class="koboSpan" id="kobo.892.1">when the linker arranges the application code and the code for the library dependencies into a single binary executable file. </span><span class="koboSpan" id="kobo.892.2">The upside here is that the libraries are already linked at compile time so there is no need for the OS to find and resolve the dependencies at runtime startup by loading the dependent libraries before the application starts executing. </span><span class="koboSpan" id="kobo.892.3">The even bigger upside is that this creates an opportunity for the program to be super-optimized at compile and linking time to yield lower latencies at runtime. </span><span class="koboSpan" id="kobo.892.4">The downside to static linking over dynamic linking is that the application binary is much larger and each application binary that relies on the same set of external libraries has a copy of all the external library code compiled and linked into the binary. </span><span class="koboSpan" id="kobo.892.5">It is common for ultra-low latency electronic trading systems to link all dependent libraries statically to minimize runtime </span><span class="No-Break"><span class="koboSpan" id="kobo.893.1">performance latencies.</span></span></p>
<p><span class="koboSpan" id="kobo.894.1">We have discussed compile time versus runtime processing in the previous chapter, and that approach tries to move the maximum amount of processing to the compilation step instead of at runtime. </span><span class="koboSpan" id="kobo.894.2">This increases compile times, but the runtime performance latencies are much lower because a lot of the work is already done at compile time. </span><span class="koboSpan" id="kobo.894.3">We will look at this aspect in detail specifically for C++ in the next few chapters and throughout the course of this book as we build our electronic trading system </span><span class="No-Break"><span class="koboSpan" id="kobo.895.1">in C++.</span></span></p>
<h1 id="_idParaDest-53"><a id="_idTextAnchor055"/><span class="koboSpan" id="kobo.896.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.897.1">In this chapter, we looked at different low latency applications in different business areas. </span><span class="koboSpan" id="kobo.897.2">The goals were to understand how low latency applications impact businesses in different areas and the similarities that some of these applications share, such as the hardware requirements and optimization, software design, performance optimization, and different revolutionary technologies being used to achieve these </span><span class="No-Break"><span class="koboSpan" id="kobo.898.1">performance requirements.</span></span></p>
<p><span class="koboSpan" id="kobo.899.1">The first applications we looked at in detail were real-time, low latency, online video streaming applications. </span><span class="koboSpan" id="kobo.899.2">We discussed different concepts and investigated where high latencies come from, and how that affects performance and businesses. </span><span class="koboSpan" id="kobo.899.3">Finally, we discussed different technologies and solutions, and platforms that facilitate low latency video streaming applications to be </span><span class="No-Break"><span class="koboSpan" id="kobo.900.1">a success.</span></span></p>
<p><span class="koboSpan" id="kobo.901.1">The next applications we looked at had a lot of overlap with video streaming applications – offline and online video gaming applications. </span><span class="koboSpan" id="kobo.901.2">We introduced some additional concepts and considerations that apply to offline and online gaming applications and explained their impact on the user experience and thus, ultimately, on business performance. </span><span class="koboSpan" id="kobo.901.3">We discussed a myriad of things to consider when trying to maximize the performance of these applications, ranging from a lot of factors that apply to live video streaming applications to additional hardware and software considerations for </span><span class="No-Break"><span class="koboSpan" id="kobo.902.1">gaming applications.</span></span></p>
<p><span class="koboSpan" id="kobo.903.1">We then briefly discussed the requirement of low latency performance when it comes to IoT devices and retail data collection and analysis applications. </span><span class="koboSpan" id="kobo.903.2">This is a relatively new and fast-improving technology and is likely to continue growing aggressively over the next decade. </span><span class="koboSpan" id="kobo.903.3">Lots of research and advancements are being made for IoT devices and we find new business ideas and use cases as we make progress here. </span><span class="koboSpan" id="kobo.903.4">We discussed how 5G wireless and edge computing technologies are breaking the old paradigm of central data storage and processing and why that is critical for IoT devices </span><span class="No-Break"><span class="koboSpan" id="kobo.904.1">and applications.</span></span></p>
<p><span class="koboSpan" id="kobo.905.1">The last applications we also discussed briefly in this chapter were low latency electronic trading and HFT applications. </span><span class="koboSpan" id="kobo.905.2">We kept the discussion short and focused on the higher-level ideas when it comes to maximizing the performance of low latency and ultra-low latency electronic trading applications. </span><span class="koboSpan" id="kobo.905.3">We did so because we will build a full end-to-end C++ low latency electronic trading ecosystem from scratch in the remaining chapters of this book. </span><span class="koboSpan" id="kobo.905.4">When we do that, we will discuss, understand, and implement all the different low latency C++ concepts and ideas with examples and performance data, so there is a lot more to come on </span><span class="No-Break"><span class="koboSpan" id="kobo.906.1">this application.</span></span></p>
<p><span class="koboSpan" id="kobo.907.1">We will move on from this discussion of different low latency applications to a more in-depth discussion of the C++ programming language. </span><span class="koboSpan" id="kobo.907.2">We will discuss the correct approach to using C++ for low latency performance, the different modern C++ features, and how to unleash the power of modern C++ </span><span class="No-Break"><span class="koboSpan" id="kobo.908.1">compiler optimizations.</span></span></p>
</div>
</body></html>