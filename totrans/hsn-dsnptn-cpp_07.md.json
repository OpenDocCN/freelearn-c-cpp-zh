["```cpp\n// Example 01\nvoid f(int i) { cout << “f(int)” << endl; }        // 1\nvoid f(long i) { cout << “f(long)” << endl; }    // 2\nvoid f(double i) { cout << “f(double)” << endl; }    // 3\nf(5);        // 1\nf(5l);    // 2\nf(5.0);    // 3\n```", "```cpp\nf(5.0f);\n```", "```cpp\nf(5u);\n```", "```cpp\nunsigned int i = 5u;\nf(static_cast<int>(i));\n```", "```cpp\nvoid f(int i) { cout << “f(int)” << endl; }            // 1\nvoid f(long i, long j) { cout << “f(long2)” << endl; }    // 2\nf(5.0, 7);\n```", "```cpp\n// Example 02\nvoid f(int i, int j) { cout << “f(int, int)” << endl; }// 1\nvoid f(long i, long j) { cout << “f(long2)” << endl; }    // 2\nvoid f(double i) { cout << “f(double)” << endl; }      // 3\nf(5, 5);    // 1\nf(5l, 5l);    // 2\nf(5, 5.0);    // 1\nf(5, 5l);    // ?\n```", "```cpp\n// Example 03\nvoid f(int i) { cout << “f(int)” << endl; }            // 1\nvoid f(long i, long j) { cout << “f(long2)” << endl; }    // 2\nvoid f(double i, double j = 0) {                    // 3\n  cout << “f(double, double = 0)” << endl;\n}\nf(5);        // 1\nf(5l, 5);    // 2\nf(5, 5);    // ?\nf(5.0);    // 3\nf(5.0f);    // 3\nf(5l);    // ?\n```", "```cpp\n// Example 04\nvoid f(int i) { cout << “f(int)” << endl; }        // 1\nvoid f(long i) { cout << “f(long)” << endl; }    // 2\ntemplate <typename T>\nvoid f(T i) { cout << “f(T)” << endl; }        // 3\nf(5);        // 1\nf(5l);    // 2\nf(5.0);    // 3\n```", "```cpp\n// Example 05\nvoid f(int i) { cout << “f(int)” << endl; }    // 1\ntemplate <typename T>\nvoid f(T i) { cout << “f(T)” << endl; }    // 2\ntemplate <typename T>\nvoid f(T* i) { cout << “f(T*)” << endl; }    // 3\nf(5);        // 1\nf(5l);    // 2\nint i = 0;\nf(&i);    // 3\n```", "```cpp\n#define NULL 0 // Or 0L\n```", "```cpp\n// Example 06\nvoid f(int i) { cout << “f(int)” << endl; }    // 1\nvoid f(...) { cout << “f(...)” << endl; }    // 2\nf(5);        // 1\nf(5l);    // 1\nf(5.0);    // 1\nstruct A {};\nA a;\nf(a);    {};    // 2\n```", "```cpp\nstruct B {\n  operator int() const { return 0; }\n};\nB b;\nf(b);        // 1\n```", "```cpp\n// Example 07\ntemplate <typename T>\nvoid f(T i, T* p) { std::cout << “f(T, T*)” << std::endl; }\nint i;\nf(5, &i);    // T == int\nf(5l, &i);    // ?\n```", "```cpp\nf<int>(5l, &i);    // T == int\n```", "```cpp\nf<long>(5l, &i);    // T == long\n```", "```cpp\n// Example 08\nvoid f(int i, int j = 1) {                      // 1\n  cout << “f(int2)” << endl;\n}\ntemplate <typename T> void f(T i, T* p = nullptr) {    // 2\n  cout << “f(T, T*)” << endl;\n}\nint i;\nf(5);        // 1\nf(5l);    // 2\n```", "```cpp\n// Example 09\ntemplate <typename T> T* f(T i, T& j) {\n  j = 2*i;\n  return new T(i);\n}\nint i = 5, j = 7;\nconst int* p = f(i, j);\n```", "```cpp\nint* f(int i, int& j) {\n  j = 2*i;\n  return new int(i);\n}\n```", "```cpp\n// Example 10\ntemplate <typename T>\nvoid f(T i, typename T::t& j) {\n  std::cout << “f(T, T::t)” << std::endl;\n}\ntemplate <typename T>\nvoid f(T i, T j) {\n  std::cout << “f(T, T)” << std::endl;\n}\nstruct A {\nstruct t { int i; }; t i; };\nA a{5};\nf(a, a.i);    // T == A\nf(5, 7);    // T == int\n```", "```cpp\nf<int>(5, 7);    // T == int\n```", "```cpp\n// Example 11\ntemplate <typename T> void f(T* i) {        // 1\n  std::cout << “f(T*)” << std::endl;\n}\ntemplate <typename T> void f(int T::* p) {    // 2\n  std::cout << “f(T::*)” << std::endl;\n}\nstruct A { int i; };\nA a;\nf(&a.i);    // 1\nf(&A::i);    // 2\n```", "```cpp\nint i;\nf(&i);    // 1\n```", "```cpp\n// Example 12\ntemplate <size_t N>\nvoid f(char(*)[N % 2] = nullptr) {    // 1\n  std::cout << “N=” << N << “ is odd” << std::endl;\n}\ntemplate <size_t N>\nvoid f(char(*)[1 - N % 2] = nullptr) { // 2\n  std::cout << “N=” << N << “ is even” << std::endl;\n}\nf<5>();\nf<8>();\n```", "```cpp\n// Example 13\ntemplate <typename T, size_t N = T::N>\nvoid f(T t, char(*)[N % 2] = NULL) {\n  std::cout << “N=” << N << “ is odd” << std::endl;\n}\ntemplate <typename T, size_t N = T::N>\nvoid f(T t, char(*)[1 - N % 2] = NULL) {\n  std::cout << “N=” << N << “ is even” << std::endl;\n}\nstruct A { enum {N = 5}; };\nstruct B { enum {N = 8}; };\nA a;\nB b;\nf(a);\nf(b);\n```", "```cpp\ntemplate <typename T> void f(T i, typename T::t& j);\n```", "```cpp\n// Example 14\ntemplate <typename T> void f(T) {\n  std::cout << sizeof(T::i) << std::endl;\n}\nvoid f(...) { std::cout << “f(...)” << std::endl; }\nf(0);\n```", "```cpp\n// Example 15a\ntemplate <typename T> struct S {\n  typename T::value_type f();\n};\n```", "```cpp\ntemplate <typename T> struct S {\n  template <typename U> typename T::value_type f();\n};\n```", "```cpp\n// Example 15b\ntemplate <typename T> struct S {\n  template <typename U = T>\n  std::enable_if_t<std::is_same_v<U, T>\n  typename U::value_type f();\n};\n```", "```cpp\n// Example 16\ntemplate <typename T>\nbool find(const T& cont, typename T::value_type val);\n```", "```cpp\n// Example 16\ntemplate <typename U, typename V>\nstd::common_type_t<U, V> compute(U u, V v);\n```", "```cpp\n// Example 15\ntemplate <typename T>\nauto process(T p) -> decltype(*p);\n```", "```cpp\ntemplate <typename T> T process(T* p);\n```", "```cpp\n// Example 17\ntemplate <typename T, typename V>\nbool find(const T& cont, V val) {\n  for (typename T::value_type x : cont) {\n    if (x == val) return true;\n  }\n  return false;\n}\n```", "```cpp\n// Example 17\ntemplate <typename U, typename V>\nauto compute(U u, V v) {\n  std::common_type_t<U, V> res = (u > v) ? u : v;\n  return res;\n}\n```", "```cpp\n// Example 18\ntemplate <typename U, typename V>\nauto compare(U pu, V pv) -> decltype(bool(*pu == *pv)) {\n  return *pu < *pv;\n}\n```", "```cpp\nrequires(constant-boolean-expression)\n```", "```cpp\n// Example 19\ntemplate <typename T> requires(sizeof(T) == 8) void f();\ntemplate <typename T> void g(T p) requires(sizeof(*p) < 8);\n```", "```cpp\ntemplate <typename V> constexpr bool valid_type() {\n  return sizeof(T) == 8 && alignof(T) == 8 &&\n    std::is_default_constructible_v<T>;\n}\ntemplate <typename T> requires(valid_type<T>()) void f();\n```", "```cpp\nrequires { a + b; }\n```", "```cpp\nrequires(A a, B b) { a + b; }\n```", "```cpp\nrequires(C cont) { for (auto x: cont) {}; }\n```", "```cpp\nrequires(C cont) {\n  [](auto&& c) {\n    for (auto x: cont) { return x; };\n  }(cont);\n}\n```", "```cpp\n// Example 20\ntemplate <typename T, typename P>\nvoid f(T i, P p) requires( requires { i = *p; } );\ntemplate <typename T, typename P>\nvoid f(T i, P p) requires( requires { i.*p; } );\n```", "```cpp\n// Example 20\ntemplate <typename T, typename P>\nrequires(requires(T t, P p) { t = *p; }) void f(T i, P p);\ntemplate <typename T, typename P>\nrequires(requires(T t, P p) { t.*p; }) void f(T i, P p);\n```", "```cpp\nrequires { typename T::value_type; }\n```", "```cpp\nrequires(\n  requires { typename T::value_type; } &&\n  sizeof(T) <= 32\n)\n```", "```cpp\nrequires(T t) { typename T::value_type; t[0]; }\n```", "```cpp\nrequires(T t) { { t + 1 } -> std::same_as<T>; }\n```", "```cpp\n// Example 21\ntemplate <typename R> concept Range = requires(R r) {\n  std::begin(r);\n  std::end(r);\n};\n```", "```cpp\n// Example 21\ntemplate <typename R> requires(Range<R>) void sort(R&& r);\n```", "```cpp\nstatic_assert(Range<std::vector<int>>);\nstatic_assert(!Range<int>);\n```", "```cpp\n// Example 21\ntemplate <Range R> void sort(R&& r);\n```", "```cpp\n// Example 21\nvoid sort(Range auto&& r);\n```", "```cpp\nstatic_assert(!requires{ typename T::value_type; });\n```", "```cpp\n// Example 21\ntemplate <Range R> class C { … };\n```", "```cpp\n// Example 21\ntemplate <typename T> struct holder {\n  T& value;\n  holder(T& t) : value(t) {}\n  void sort() requires(Range<T>) {\n    std::sort(std::begin(value), std::end(value));\n  }\n};\n```", "```cpp\ntemplate <typename T> typename T::value_type f(T&& t);\n```", "```cpp\ntemplate <typename T> auto f(T&& t)\nrequires( requires { *t.begin(); t.begin() != t.end(); } );\n```", "```cpp\ntemplate <typename T> auto f(T&& t)->decltype(*t.begin())\nrequires( requires {\n  *t.begin();\n  t.begin() != t.end();\n  ++t.begin();\n} );\n```", "```cpp\ntemplate <typename T>\nbool find(const T& t, typename T::value_type x);\n```", "```cpp\ntemplate <typename T, typename X>\nbool find(const T& t, X x)\nrequires( requires {\n  *t.begin() == x;\n  t.begin() == t.end();\n  ++t.begin();\n} );\n```", "```cpp\ntemplate <typename T, typename = T::value_type> void f();\n```", "```cpp\ntemplate <typename T> void f(…);\n```", "```cpp\ntemplate <typename T, typename = T::value_type>\nvoid f(int);\ntemplate <typename T> void f(…);\n```", "```cpp\n// Example 22\nnamespace detail {\ntemplate <typename T, typename = T::value_type>\nvoid test_value_type(int);\ntemplate <typename T> void test_value_type (…);\n}\ntemplate <typename T> using has_value_type =\n  decltype(detail::test_value_type <T>(0));\n```", "```cpp\ntemplate <typename T>\nusing has_value_type_t = has_value_type<T>::type;\ntemplate <typename T> inline constexpr\nbool has_value_type_v = has_value_type<T>::value;\n```", "```cpp\nstatic_assert(has_value_type_v<T>, “I require value_type”);\n```", "```cpp\n// Example 22a\ntemplate <typename T, std::enable_if_t<\n  sizeof(typename T::value_type) !=0, bool> = true>\nstd::true_type test_value_type(int);\n```", "```cpp\ntemplate <typename T, std::enable_if_t<\n  sizeof(typename T::value_type) !=0 &&\n  sizeof(typename T::size_type) !=0, bool> = true>\nstd::true_type test_value_type(int);\n```", "```cpp\ntemplate <typename T,\n          bool = sizeof(typename T::value_type)>\nstd::true_type test_value_type(int);\n```", "```cpp\ntemplate <typename T, std::enable_if_t<cond1, bool> = true>\nres_t func();\ntemplate <typename T, std::enable_if_t<cond2, bool> = true>\nres_t func(); // OK as long as only one cond1,2 is true\n```", "```cpp\ntemplate <typename T, bool = cond1> = true>\nres_t func();\ntemplate <typename T, bool = cond2 > = true>\nres_t func();\n```", "```cpp\n// Example 23\nnamespace detail {\ntemplate <typename T> std::true_type test(int T::*);\ntemplate <typename T> std::false_type test(...);\n}\ntemplate <typename T>\nusing is_class = decltype(detail::test<T>(nullptr));\n```", "```cpp\ntemplate <typename R> concept Range = …;\ntemplate <typename R> requires(Range<R>) void sort(…);\n```", "```cpp\ntemplate <typename R> constexpr yes_t RangeTest(some-args);\ntemplate <typename R> constexpr no_t RangeTest(...);\n```", "```cpp\ntemplate <typename R> constexpr bool RangeTest(some-args) {\n  return true;\n}\ntemplate <typename R> constexpr bool RangeTest(...) {\n  return false;\n}\ntemplate <typename R>\nconstexpr inline bool Range = RangeTest<R>(0);\n```", "```cpp\ntemplate <typename R>\nconstexpr auto RangeTest(??? r) -> decltype(\n  std::begin(r),        // Ranges have begin()\n  std::end(r),         // Ranges have end()\n  bool{}            // But return type should be bool\n) { return true; }\n```", "```cpp\n// Example 24\ntemplate <typename R>\nconstexpr auto RangeTest(R* r) -> decltype(\n  std::begin(*r),    // Ranges have begin()\n  std::end(*r),         // Ranges have end()\n  bool{}            // But return type should be bool\n) { return true; }\ntemplate <typename R> constexpr bool RangeTest(...) {\n  return false;\n}\ntemplate <typename R>\nconstexpr inline bool Range = RangeTest<R>(nullptr);\n```", "```cpp\nstatic_assert(Range<std::vector<int>>);\nstatic_assert(!Range<int>);\n```", "```cpp\ntemplate <typename R,\n    std::enable_if_t<Range<R>, bool> = true>\nvoid sort(R&& r);\n```", "```cpp\n// Example 24\n#define REQUIRES(...) \\\n  std::enable_if_t<(__VA_ARGS__), bool> = true\ntemplate <typename R, REQUIRES(Range<R>)> void sort(R&& r);\n```", "```cpp\n// Example 24\ntemplate <typename R, REQUIRES(Range<std::decay_t<R>>)>\nvoid sort(R&& r);\n```", "```cpp\ntemplate <typename R>\nconstexpr static auto RangeTest(R& r = ???) ->\n  decltype(std::begin(r), std::end(r));\ntemplate <typename R>        // Overload for success\nconstexpr static auto RangeTest(int) ->\n  decltype(RangeTest<R>(), bool{}) { return true; }\ntemplate <typename R>        // Fallback overload\nconstexpr bool RangeTest(...) { return false; }\ntemplate <typename R>\nconstexpr static bool Range = RangeTest<R>(0);\n```", "```cpp\ntemplate <typename R>\nconstexpr static auto RangeTest(R& r=std::declval<R>()) ->\n  decltype(std::begin(r), std::end(r));\n```", "```cpp\ntemplate <typename T> constexpr T& lvalue();\ntemplate <typename R>\nconstexpr static auto RangeTest(R& r = lvalue<R>()) ->\n  decltype(std::begin(r), std::end(r));\n```", "```cpp\ninline function 'lvalue<std::vector<int>>' is used but not defined.\"\n```", "```cpp\ntemplate <typename T> constexpr T& lvalue() { abort(); }\ntemplate <typename R>\nconstexpr static auto RangeTest(R& r = lvalue<R>()) ->\n  decltype(std::begin(r), std::end(r));\n```", "```cpp\nnamespace concept_detail {\ntemplate <typename T>\n  constexpr const T& clvalue() { abort(); }\ntemplate <typename T> constexpr T& lvalue() { abort(); }\ntemplate <typename T> constexpr T&& rvalue() { abort(); }\n}\n```", "```cpp\n// Example 24a\ntemplate <typename R>\nconstexpr static auto RangeTest(\n  R& r = concept_detail::lvalue<R>()) ->\n  decltype(std::begin(r), std::end(r));\ntemplate <typename R>\nconstexpr static auto RangeTest(int) ->\n  decltype(RangeTest<R>(), bool{}) { return true; }\ntemplate <typename R>\nconstexpr bool RangeTest(...) { return false; }\ntemplate <typename R>\nconstexpr static bool Range = RangeTest<R>(0);\n```", "```cpp\n// Example 25\n#define CLVALUE(TYPE, NAME) const TYPE& NAME = \\\n  Concepts::concept_detail::clvalue<TYPE>()\n#define LVALUE(TYPE, NAME) TYPE& NAME = \\\n  Concepts::concept_detail::lvalue<TYPE>()\n#define RVALUE(TYPE, NAME) TYPE&& NAME = \\\n  Concepts::concept_detail::rvalue<TYPE>()\n```", "```cpp\n// Example 25\ntemplate <typename R> CONCEPT RangeTest(RVALUE(R, r)) ->\n  decltype(std::begin(r), std::end(r));\n```", "```cpp\n#define CONCEPT constexpr inline auto\n```", "```cpp\ntemplate <typename R> concept Range =\n  requires(R r) { std::begin(r); std::end(r); };\n```", "```cpp\ntemplate <typename R>\nconstexpr static auto RangeTest(int) ->\n  decltype(RangeTest<R>(), bool{}) { return true; }\n```", "```cpp\n// Example 25\ntemplate <typename… T>\nconstexpr static auto RangeTest(int) ->\n  decltype(RangeTest<T…>(), bool{}) { return true; }\n```", "```cpp\n// Example 25\nstruct ConceptArg {};\ntemplate <typename… T>\nconstexpr static auto RangeTest(ConceptArg, int) ->\n  decltype(RangeTest<T…>(), bool{}) { return true; }\ntemplate <typename T>\nconstexpr bool RangeTest(ConceptArg, ...) { return false; }\ntemplate <typename R>\nconstexpr static bool Range = RangeTest<R>(ConceptArg{},0);\n```", "```cpp\n// Example 25\n#define DECLARE_CONCEPT(NAME, SUFFIX) \\\ntemplate <typename... T> constexpr inline auto     \\\n  NAME ## SUFFIX(ConceptArg, int) -> \\\n  decltype(NAME ## SUFFIX<T...>(), bool{}){return true;} \\\ntemplate <typename... T> constexpr inline bool \\\n  NAME ## SUFFIX(ConceptArg, ...) { return false; } \\\ntemplate <typename... T> constexpr static bool NAME = \\\n  NAME ## SUFFIX<T...>(ConceptArg{}, 0)\n```", "```cpp\n// Example 25\ntemplate <typename R> CONCEPT RangeTest(RVALUE(R, r)) ->\n  decltype(std::begin(r), std::end(r));\nDECLARE_CONCEPT(Range, Test);\n```", "```cpp\n// Example 25\ntemplate <typename U, typename V> CONCEPT\n  AddableTest(CLVALUE(U, u), CLVALUE(V, v)) ->\n  decltype(u + v);\nDECLARE_CONCEPT(Addable, Test);\n```", "```cpp\ntemplate <typename U, typename V> concept Addable =\n  require(U u, V v) { u + v; }\n```", "```cpp\n // Example 25\ntemplate <typename R, REQUIRES(Range<R>)> void sort(R&& r);\n```", "```cpp\ntemplate <typename T> class C {\n  template <typename U = T, REQUIRE(Range<U>)> void f(T&);\n  …\n};\n```", "```cpp\nstd::vector<int> v = …;\nsort(v);         // OK\nsort(0);        // Does not compile\n```", "```cpp\n// Example 25\ntemplate <typename R>\nCONCEPT SortCompilesTest(RVALUE(R, r))->decltype(sort(r));\nDECLARE_CONCEPT(SortCompiles, Test);\nstatic_assert(SortCompiles<std::vector<int>>);\nstatic_assert(!SortCompiles<int>);\n```"]