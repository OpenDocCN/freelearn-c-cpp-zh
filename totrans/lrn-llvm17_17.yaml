- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Beyond Instruction Selection
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超出指令选择
- en: Now that we’ve learned about instruction selection using the SelectionDAG and
    GlobalISel LLVM-based frameworks in the previous chapters, we can explore other
    interesting concepts beyond instruction selection. This chapter encapsulates some
    more advanced topics outside of the backend that can be interesting for a highly
    optimizing compiler. For instance, some passes run beyond instruction selection
    and can perform different optimizations on various instructions, which can mean
    that developers have the luxury to introduce their own passes to perform meaningful
    target-specific tasks at this point in the compiler.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在前几章学习了使用 SelectionDAG 和 GlobalISel 基于LLVM的框架进行指令选择，我们可以探索指令选择之外的其它有趣概念。本章包含了一些对于高度优化编译器来说可能很有趣的后端之外的高级主题。例如，一些遍历操作会超出指令选择，并且可以对各种指令执行不同的优化，这意味着开发者有足够的自由在这个编译器的这个阶段引入他们自己的遍历操作来执行有意义的特定目标任务。
- en: 'Ultimately, within this chapter, we will dive into the following concepts:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，在本章中，我们将深入研究以下概念：
- en: Adding a new machine function pass to LLVM
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将新的机器函数遍历操作添加到LLVM中
- en: Integrating a new target into the clang frontend
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将新的目标集成到clang前端
- en: How to target a different CPU architecture
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何针对不同的CPU架构
- en: Adding a new machine function pass to LLVM
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将新的机器函数遍历操作添加到LLVM中
- en: In this section, we will explore how to implement a new machine function pass
    within LLVM that runs after instruction selection. Specifically, a `MachineFunctionPass`
    class will be created, which is a subset of the original `FunctionPass` class
    within LLVM that can be run with `opt`. This class adapts the original infrastructure
    to allow for the implementation of passes that operate on the `MachineFunction`
    representation in the backend through `llc`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何在LLVM中实现一个新的机器函数遍历操作，该操作在指令选择之后运行。具体来说，将创建一个 `MachineFunctionPass`
    类，它是LLVM中原始 `FunctionPass` 类的一个子集，可以通过 `opt` 运行。这个类通过 `llc` 适配原始基础设施，允许实现操作在 `MachineFunction`
    表示形式上运行的遍历操作。
- en: It is important to note that the implementation of passes within the backend
    utilizes the interfaces of the legacy pass manager, rather than the new pass manager.
    This is because LLVM currently does not have a complete working implementation
    of the new pass manager within the backend. Due to this, this chapter will follow
    the method of adding a new pass within the legacy pass manager pipeline.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，后端中遍历的实现使用了旧遍历管理器的接口，而不是新遍历管理器。这是因为LLVM目前在后端没有完整的可工作的新遍历管理器实现。因此，本章将遵循在旧遍历管理器管道中添加新遍历的方法。
- en: In terms of the actual implementation, such as function passes, machine function
    passes optimize a single (machine) function at a time, but instead of overriding
    the `runOnFunction()` method, machine function passes override the `runOnMachineFunction()`
    method. The machine function pass that will be implemented in this section is
    a pass that checks for when a division by zero occurs, specifically, to insert
    code that traps in the backend. This type of pass is important for the M88k target
    due to hardware limitations on MC88100 as this CPU does not reliably detect division
    by zero situations.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际实现方面，例如函数遍历操作，机器函数遍历操作一次优化一个（机器）函数，但不是覆盖 `runOnFunction()` 方法，而是覆盖 `runOnMachineFunction()`
    方法。本节将要实现的机器函数遍历操作是一个检查除零发生的遍历操作，具体来说，是在后端中插入陷阱代码。这种类型的遍历操作对于M88k目标很重要，因为MC88100硬件在检测除零情况上存在限制。
- en: Continuing from the previous chapter’s implementation of the backend, let’s
    examine how a backend machine function pass is implemented!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一章的后端实现继续，让我们看看后端机器函数遍历操作是如何实现的！
- en: Implementing the top-level interface for the M88k target
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现M88k目标的顶层接口
- en: 'Firstly, within `llvm/lib/Target/M88k/M88k.h`, let’s add two prototypes inside
    the `llvm` namespace declaration that will be used later:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在 `llvm/lib/Target/M88k/M88k.h` 中，让我们在 `llvm` 命名空间声明内添加两个原型，这些原型将在以后使用：
- en: 'The machine function pass that will be implemented will be called `M88kDivInstrPass`.
    We will add a function declaration that initializes this pass and takes in the
    pass registry, which is a class that manages the registration and initialization
    of all passes:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将要实现的机器函数遍历操作将被命名为 `M88kDivInstrPass`。我们将添加一个函数声明来初始化这个遍历操作，并接收遍历注册表，这是一个管理所有遍历注册和初始化的类：
- en: '[PRE0]'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, the actual function that creates the `M88kDivInstr` pass is declared,
    with the M88k target machine information as its argument:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，声明实际创建 `M88kDivInstr` 遍历的函数，其参数为 M88k 目标机信息：
- en: '[PRE1]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Adding the TargetMachine implementation for machine function passes
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加机器函数遍历的 TargetMachine 实现
- en: 'Next, we will analyze some of the changes that are required in `llvm/lib/Target/M88k/M88kTargetMachine.cpp`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将分析在 `llvm/lib/Target/M88k/M88kTargetMachine.cpp` 中需要进行的某些更改：
- en: 'Within LLVM, it’s common to give the user the option to toggle passes on or
    off. So, let’s provide the user the same flexibility with our machine function
    pass. We’ll start by declaring a command-line option called `m88k-no-check-zero-division`
    and initializing it to `false`, which implies that there will always be a check
    for zero division unless the user explicitly turns this off. We’ll add this under
    the `llvm` namespace declaration and is an option for `llc`:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 LLVM 中，通常会给用户提供切换遍历开/关的选项。因此，让我们为我们的机器函数遍历提供相同的灵活性。我们首先声明一个名为 `m88k-no-check-zero-division`
    的命令行选项，并将其初始化为 `false`，这意味着除非用户明确将其关闭，否则总会进行零除检查。我们将在 `llvm` 命名空间声明下添加此选项，并且它是
    `llc` 的一个选项：
- en: '[PRE2]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It is also customary to create a formal method that returns the command-line
    value so that we can query it to determine whether the pass will be run. Our original
    command-line option will be wrapped in the `noZeroDivCheck()` method so that we
    can utilize the command-line result later:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还有一个惯例是创建一个正式的方法来返回命令行值，这样我们就可以查询它以确定是否运行遍历。我们的原始命令行选项将被 `noZeroDivCheck()`
    方法包装起来，这样我们就可以在以后利用命令行结果：
- en: '[PRE3]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, inside `LLVMInitializeM88kTarget()`, where the M88k target and passes
    are registered and initialized, we will insert a call to the `initializeM88kDivInstrPass()`
    method that was declared earlier in `llvm/lib/Target/M88k/M88k.h`:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在 `LLVMInitializeM88kTarget()` 中，我们将注册和初始化 M88k 目标和遍历的地方，插入对之前在 `llvm/lib/Target/M88k/M88k.h`
    中声明的 `initializeM88kDivInstrPass()` 方法的调用：
- en: '[PRE4]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The M88k target also needs to override `addMachineSSAOptimization()`, which
    is a method that adds passes to optimize machine instructions when they are in
    SSA form. Essentially, our machine function pass is added as a type of machine
    SSA optimization. This method is declared as a function that is to be overridden.
    We will add the full implementation at the end of `M88kTargetMachine.cpp`:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: M88k 目标还需要重写 `addMachineSSAOptimization()` 方法，这是一个在指令处于 SSA 形式时添加优化指令的遍历的方法。本质上，我们的机器函数遍历被添加为一种机器
    SSA 优化。该方法被声明为一个需要重写的方法。我们将在 `M88kTargetMachine.cpp` 的末尾添加完整的实现：
- en: '[PRE5]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Our method that returns the command-line option to toggle the machine function
    pass on and off (the `noZeroDivCheck()` method) is also declared in `M88kTargetMachine.h`:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们返回用于切换机器函数遍历开/关的命令行选项的方法（`noZeroDivCheck()` 方法）也声明在 `M88kTargetMachine.h`
    中：
- en: '[PRE6]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Developing the specifics of the machine function pass
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发机器函数遍历的细节
- en: 'Now that the implementation in the M88k target machine is completed, the next
    step will be to develop the machine function pass itself. The implementation is
    contained within the new file, `llvm/lib/Target/M88k/M88kDivInstr.cpp`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，M88k 目标机的实现已经完成，下一步将是开发机器函数遍历本身。实现包含在新文件 `llvm/lib/Target/M88k/M88kDivInstr.cpp`
    中：
- en: 'The necessary headers for our machine function pass are added first. This includes
    headers that give us access to the M88k target information and headers that allow
    us to operate on machine functions and machine instructions:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们的机器函数遍历添加必要的头文件。这包括提供访问 M88k 目标信息的头文件，以及允许我们对机器函数和机器指令进行操作的头文件：
- en: '[PRE7]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After that, we will add some code to prepare for our machine function pass.
    The first is a `DEBUG_TYPE` definition that is named `m88k-div-instr`, which is
    used for fine-grained control when debugging. Specifically, defining this `DEBUG_TYPE`
    allows users to specify the machine function pass name and view any debugging
    information that is pertinent to the pass when debug information is enabled:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们将添加一些代码来为我们的机器函数遍历做准备。首先是 `DEBUG_TYPE` 定义，命名为 `m88k-div-instr`，用于调试时的细粒度控制。具体来说，定义这个
    `DEBUG_TYPE` 允许用户指定机器函数遍历的名称，并在启用调试信息时查看与遍历相关的任何调试信息：
- en: '[PRE8]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We also specify that the `llvm` namespace is being used, and a `STATISTIC`
    value for our machine function is also declared. This statistic, called `InsertedChecks`,
    keeps track of how many division-by-zero checks are inserted by the compiler.
    Finally, an anonymous namespace is declared to encapsulate the subsequent machine
    function pass implementation:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还指定了正在使用`llvm`命名空间，并为我们的机器函数声明了一个`STATISTIC`值。这个统计值称为`InsertedChecks`，它跟踪编译器插入的除以零检查的数量。最后，声明了一个匿名命名空间来封装随后的机器函数传递实现：
- en: '[PRE9]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As mentioned previously, this machine function pass aims to check for division
    by zero cases and inserts instructions that will cause the CPU to trap. These
    instructions require condition codes, so an `enum` value that we call `CC0` is
    defined with condition codes that are valid for the M88k target, along with their
    encodings:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，这个机器函数传递旨在检查除以零的情况，并插入会导致CPU陷阱的指令。这些指令需要条件码，因此我们定义了一个名为`CC0`的`enum`值，其中包含了适用于M88k目标的条件码及其编码：
- en: '[PRE10]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let’s create the actual class for our machine function pass next, called `M88kDivInstr`.
    Firstly, we create it as an instance that inherits and is of the `MachineFunctionPass`
    type. Next, we declare various necessary instances that our `M88kDivInstr` pass
    will require. This includes `M88kBuilder`, which we will create and elaborate
    on later, and `M88kTargetMachine`, which contains target instruction and register
    information. Furthermore, we also require the register bank information and the
    machine register information when emitting instructions. An `AddZeroDivCheck`
    Boolean is also added to represent the previous command-line option, which turns
    our pass on or off:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建我们的机器函数传递的实际类，称为`M88kDivInstr`。首先，我们创建它作为一个继承并属于`MachineFunctionPass`类型的实例。接下来，我们声明了`M88kDivInstr`传递所需的各个必要实例。这包括我们将在稍后创建和详细说明的`M88kBuilder`，以及包含目标指令和寄存器信息的`M88kTargetMachine`。此外，我们在发出指令时还需要寄存器银行信息和机器寄存器信息。还添加了一个`AddZeroDivCheck`布尔值来表示之前的命令行选项，它打开或关闭我们的传递：
- en: '[PRE11]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For the public variables and methods of the `M88kDivInstr` class, we declare
    an identification number that LLVM will use to identify our pass, as well as the
    `M88kDivInstr` constructor, which takes in `M88kTargetMachine`. Next, we override
    the `getRequiredProperties()` method, which represents the properties that `MachineFunction`
    may have at any time during the optimization, and we also override the `runOnMachineFunction()`
    method, which will be one of the primary methods that our pass will run when checking
    for any division by zero. The second important function that is publicly declared
    is the `runOnMachineBasicBlock()` function, which will be executed from inside
    `runOnMachineFunction()`:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`M88kDivInstr`类的公共变量和方法，我们声明了一个识别号，LLVM将使用它来识别我们的传递，以及`M88kDivInstr`构造函数，它接受`M88kTargetMachine`。接下来，我们重写了`getRequiredProperties()`方法，它代表了`MachineFunction`在优化过程中可能拥有的属性，我们还重写了`runOnMachineFunction()`方法，这将是我们的传递在检查任何除以零时运行的主要方法之一。公开声明的第二个重要函数是`runOnMachineBasicBlock()`函数，它将在`runOnMachineFunction()`内部执行：
- en: '[PRE12]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, the last part is declaring the private methods and closing off the
    class. The only private method we declare within the `M88kDivInstr` class is the
    `addZeroDivCheck()` method, which inserts the checks for division by zero after
    any divide instruction. As we will see later, `MachineInstr` will need to point
    to specific divide instructions on the M88k target:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，最后一部分是声明私有方法和关闭类。在`M88kDivInstr`类中，我们声明的唯一私有方法是`addZeroDivCheck()`方法，它会在任何除法指令之后插入除以零的检查。正如我们稍后将会看到的，`MachineInstr`需要在M88k目标上指向特定的除法指令：
- en: '[PRE13]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'An `M88kBuilder` class is created next, which is a specialized builder instance
    that creates M88k-specific instructions. This class keeps an instance of `MachineBasicBlock`
    (and a corresponding iterator), and `DebugLoc` to keep track of the debug location
    of this builder class. Other necessary instances include the target instruction
    information, the target register information, and the register bank information
    of the M88k target:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来创建了一个`M88kBuilder`类，这是一个专门化的构建实例，用于创建M88k特定的指令。这个类保持了一个`MachineBasicBlock`实例（以及相应的迭代器）和`DebugLoc`，以跟踪这个构建类的调试位置。其他必要的实例包括目标指令信息、目标寄存器信息和M88k目标寄存器银行信息：
- en: '[PRE14]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'For public methods of the `M88kBuilder` class, we must implement the constructor
    for this builder. Upon initialization, our specialized builder requires an instance
    of the `M88kDivInstr` pass to initialize the target instruction, register information,
    and the register bank information, as well as `MachineBasicBlock` and a debug
    location:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 `M88kBuilder` 类的公共方法，我们必须实现这个构建器的构造函数。在初始化时，我们的专用构建器需要一个 `M88kDivInstr` 传递的实例来初始化目标指令、寄存器信息以及寄存器银行信息，以及
    `MachineBasicBlock` 和一个调试位置：
- en: '[PRE15]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, a method to set `MachineBasicBlock` inside the M88k builder is created,
    and the `MachineBasicBlock` iterator is also set accordingly:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建了一个在 M88k 构建器内部设置 `MachineBasicBlock` 的方法，并且相应地设置了 `MachineBasicBlock`
    迭代器：
- en: '[PRE16]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `constrainInst()` function needs to be implemented next and is needed for
    when `MachineInstr` instances are processed. For a given `MachineInstr`, we check
    if the register class of the `MachineInstr` instance’s operands can be constrained
    through the pre-existing function, `constrainSelectedInstRegOperands()`. As shown
    here, this machine function pass requires that the register operands of the machine
    instruction can be constrained:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来需要实现 `constrainInst()` 函数，它是在处理 `MachineInstr` 实例时需要的。对于一个给定的 `MachineInstr`，我们检查
    `MachineInstr` 实例的操作数的寄存器类是否可以通过现有的函数 `constrainSelectedInstRegOperands()` 进行约束。如图所示，这个机器函数传递要求机器指令的寄存器操作数可以约束：
- en: '[PRE17]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'One of the instructions that this pass inserts is a `BCND` instruction, as
    defined in `M88kInstrInfo.td`, which is a conditional branch on the M88k target.
    To create this instruction, we require a condition code, which are the `CC0` enums
    that were implemented at the beginning of `M88kDivInstr.cpp` – that is, a register
    and `MachineBasicBlock`. The `BCND` instruction is simply returned upon creation
    and after checking if the newly created instruction can be constrained:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个传递插入的指令之一是一个 `BCND` 指令，它在 `M88kInstrInfo.td` 中定义，是 M88k 目标上的条件分支。为了创建这个指令，我们需要一个条件码，即
    `CC0` 枚举，这些枚举在 `M88kDivInstr.cpp` 的开头实现——即一个寄存器和 `MachineBasicBlock`。创建 `BCND`
    指令后，简单地返回，并在检查新创建的指令是否可以约束之后返回。此外，这完成了 `M88kBuilder` 类的类实现并完成了之前声明的匿名命名空间：
- en: '[PRE18]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Similarly, we also require a trap instruction for our machine function pass,
    which is a `TRAP503` instruction. This instruction requires a register and raises
    a trap with vector 503 if the 0-th bit of the register is not set, which will
    be raised after a zero division. Upon creating the `TRAP503` instruction, `TRAP503`
    is checked for constraints before being returned. Moreover, this concludes the
    class implementation of the `M88kBuilder` class and completes the previously declared
    anonymous namespace:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于机器函数传递，我们还需要一个陷阱指令，这是一个 `TRAP503` 指令。这个指令需要一个寄存器，如果寄存器的 0 位没有被设置，则会引发一个带有向量
    503 的陷阱，这将在零除之后发生。在创建 `TRAP503` 指令后，在返回之前检查 `TRAP503` 的约束。此外，这也完成了 `M88kBuilder`
    类的实现和之前声明的匿名命名空间：
- en: '[PRE19]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can now start implementing the functions that perform the actual checks
    in the machine function pass. First, let’s explore how `addZeroDivCheck()` is
    implemented. This function simply inserts a check for division by zero between
    the current machine instruction, which is expected to point to either `DIVSrr`
    or `DIVUrr`; these are mnemonics for signed and unsigned divisions, respectively.
    The `BCND` and `TRAP503` instructions are inserted, and the `InsertedChecks` statistic
    is incremented to indicate the addition of the two instructions:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以开始实现机器函数传递中执行实际检查的函数了。首先，让我们探索一下 `addZeroDivCheck()` 函数是如何实现的。这个函数简单地在一个当前机器指令（预期指向
    `DIVSrr` 或 `DIVUrr`）之间插入一个除以零的检查；这些是分别表示有符号和无符号除法的助记符。插入 `BCND` 和 `TRAP503` 指令，并将
    `InsertedChecks` 统计量增加以指示两个指令的添加：
- en: '[PRE20]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`runOnMachineFunction()` is implemented next and is one of the important functions
    to override when creating a type of function pass within LLVM. This function returns
    true or false, depending on if any changes have been made during the duration
    of the machine function pass. Furthermore, for a given machine function, we gather
    all the relevant M88k subtarget information, including the target instruction,
    target register, register bank, and machine register information. Details regarding
    whether or not the user turns the `M88kDivInstr` machine function pass on or off
    are also queried and stored in the `AddZeroDivCheck` variable. Additionally, all
    machine basic blocks in the machine function are analyzed for the division by
    zero. The function that performs the machine basic block analysis is `runOnMachineBasicBlock()`;
    we will implement this next. Finally, if the machine function has changed, this
    is indicated by the `Changed` variable that is returned:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`runOnMachineFunction()` 函数接下来被实现，并且是创建 LLVM 中的一种函数传递类型时需要重写的重要函数之一。这个函数返回
    true 或 false，取决于在机器函数传递期间是否进行了任何更改。此外，对于给定的机器函数，我们收集所有相关的 M88k 子目标信息，包括目标指令、目标寄存器、寄存器银行和机器寄存器信息。是否启用或禁用
    `M88kDivInstr` 机器函数传递的详细信息也被查询并存储在 `AddZeroDivCheck` 变量中。此外，对机器函数中的所有机器基本块进行分析，以检查除以零的情况。执行机器基本块分析的功能是
    `runOnMachineBasicBlock()`；我们将在接下来实现这个功能。最后，如果机器函数已更改，这通过返回的 `Changed` 变量来指示：'
- en: '[PRE21]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: For the `runOnMachineBasicBlock()` function, a `Changed` Boolean flag is also
    returned to indicate if the machine basic block has been changed; however, it
    is initially set to `false`. Furthermore, within a machine basic block, we need
    to analyze all the machine instructions and check if the instructions are the
    `DIVUrr` or `DIVSrr` opcodes, respectively. In addition to checking if the opcodes
    are divide instructions, we need to check if the user has turned our machine function
    pass on or off. If all of these conditions are satisfied, the division by zero
    checks with the conditional branch and the trap instructions are added accordingly
    through the `addZeroDivCheck()` function, which was implemented previously.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 `runOnMachineBasicBlock()` 函数，也返回一个 `Changed` 布尔标志，以指示机器基本块是否已更改；然而，它最初被设置为
    `false`。此外，在机器基本块内，我们需要分析所有机器指令并检查指令是否是 `DIVUrr` 或 `DIVSrr` 操作码。除了检查操作码是否是除法指令外，我们还需要检查用户是否已启用或禁用我们的机器函数传递。如果所有这些条件都满足，将通过之前实现的
    `addZeroDivCheck()` 函数相应地添加带有条件分支和陷阱指令的除以零检查。
- en: '[PRE22]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'After, we need to implement the constructor to initialize our function pass
    and set the appropriate machine function properties. This can be achieved by calling
    the `initializeM88kDivInstrPass()` function with the `PassRegistry` instance inside
    the constructor of the `M88kDivInstr` class, and also by setting the machine function
    properties to indicate that our pass requires machine functions to be in SSA form:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们需要实现构造函数以初始化我们的函数传递并设置适当的机器函数属性。这可以通过在 `M88kDivInstr` 类的构造函数中调用 `initializeM88kDivInstrPass()`
    函数并设置机器函数属性以指示我们的传递需要机器函数处于 SSA 形式来实现：
- en: '[PRE23]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The next step is to initialize the ID for our machine function pass and to
    instantiate the `INITIALIZE_PASS` macro with the details of our machine function
    pass. This requires the pass instance, naming information, and two Boolean arguments
    that indicate if the pass only examines the CFG and if the pass is an analysis
    pass. Since `M88kDivInstr` performs neither of those, two `false` arguments are
    specified to the pass initialization macro:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是初始化我们的机器函数传递的 ID，并使用我们的机器函数传递的详细信息实例化 `INITIALIZE_PASS` 宏。这需要传递实例、命名信息以及两个布尔参数，指示传递是否仅检查
    CFG 以及传递是否是分析传递。由于 `M88kDivInstr` 不执行这些操作，因此将两个 `false` 参数指定给传递初始化宏：
- en: '[PRE24]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, the `createM88kDivInstr()` function creates a new instance of the
    `M88kDivInstr` pass, with a `M88kTargetMachine` instance. This is encapsulated
    into an `llvm` namespace, and the namespace is ended after finishing this function:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`createM88kDivInstr()` 函数创建 `M88kDivInstr` 传递的新实例，并带有 `M88kTargetMachine`
    实例。这被封装在 `llvm` 命名空间中，并在完成此函数后结束命名空间：
- en: '[PRE25]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Building newly implemented machine function passes
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建新实现的机器函数传递
- en: 'We’re almost done with implementing our new machine function pass! Now, we
    need to ensure CMake is aware of the new machine function pass within `M88kDivinstr.cpp`.
    This file is then added to `llvm/lib/Target/M88k/CMakeLists.txt`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了我们新的机器函数传递的实现！现在，我们需要确保 CMake 意识到 `M88kDivinstr.cpp` 中的新机器函数传递。然后，此文件被添加到
    `llvm/lib/Target/M88k/CMakeLists.txt`：
- en: '[PRE26]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The last step is to build LLVM with our new machine function pass implementation
    with the following commands. We require the `-DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD=M88k`
    CMake option to build the M88k target:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是使用以下命令构建带有我们新的机器函数传递实现的 LLVM。我们需要 `-DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD=M88k`
    CMake 选项来构建 M88k 目标：
- en: '[PRE27]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: With that, we’ve implemented the machine function pass, but wouldn’t it be interesting
    to see how it works? We can demonstrate the result of this pass by passing LLVM
    IR through `llc`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经实现了机器函数传递，但不是很有趣吗？我们可以通过通过 `llc` 传递 LLVM IR 来演示此传递的结果。
- en: A glimpse of running a machine function pass with llc
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 llc 运行机器函数传递的快照
- en: 'We have the following IR, which contains a division by zero:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有以下 IR，其中包含除以零的操作：
- en: '[PRE28]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let’s feed it into llc:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其输入到 llc 中：
- en: '[PRE29]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'By doing this, we’ll see that, in the resulting assembly, by default, the division
    by zero checks, which are represented by `bcnd.n` (`BCND`) and `tb0` (`TRAP503`),
    are inserted by our new machine function pass:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们会看到，在生成的汇编中，默认情况下，除以零检查（由 `bcnd.n` (`BCND`) 和 `tb0` (`TRAP503`) 表示）是由我们新的机器函数传递插入的：
- en: '[PRE30]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'However, let’s see what happens when we specify `--m88k-no-check-zero-division`
    to `llc`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，让我们看看当我们指定 `--m88k-no-check-zero-division` 给 `llc` 时会发生什么：
- en: '[PRE31]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This option to the backend instructs `llc` not to run the pass that checks
    for the division by zero. The resulting assembly will not contain any `BCND` or
    `TRAP503` instructions. Here’s an example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项通知后端 `llc` 不要运行检查除以零的传递。生成的汇编将不包含任何 `BCND` 或 `TRAP503` 指令。以下是一个示例：
- en: '[PRE32]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As we can see, implementing a machine function pass requires several steps,
    but these procedures can be used as a guideline for you to implement any type
    of machine function pass that fits your needs. Since we have extensively explored
    the backend within this section, let’s switch gears and see how we can teach the
    frontend about the M88k target.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，实现机器函数传递需要几个步骤，但这些程序可以作为你实现任何适合你需求的机器函数传递的指南。由于我们已经在本节中广泛探讨了后端，让我们转换方向，看看我们如何让前端了解
    M88k 目标。
- en: Integrating a new target into the clang frontend
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将新目标集成到 clang 前端
- en: In the previous chapters, we developed the M88k target’s backend implementation
    within LLVM. To complete the compiler implementation for the M88k target, we will
    investigate connecting our new target to the frontend by adding a clang implementation
    for our M88k target.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们在 LLVM 中开发了 M88k 目标的后端实现。为了完成 M88k 目标的编译器实现，我们将研究通过添加 clang 的 M88k
    目标实现来将我们的新目标连接到前端。
- en: Implementing the driver integration within clang
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 clang 中实现驱动集成
- en: 'Let’s start by adding driver integration into clang for M88k:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从将驱动集成添加到 M88k 的 clang 开始：
- en: 'The first change we will be making is inside the `clang/include/clang/Basic/TargetInfo.h`
    file. The `BuiltinVaListKind` enum lists the different kinds of `__builtin_va_list`
    types for each target, which is used for variadic functions support, so a corresponding
    type for M88k is added:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将要做的第一个更改是在 `clang/include/clang/Basic/TargetInfo.h` 文件内部。`BuiltinVaListKind`
    枚举列出了每个目标的不同类型的 `__builtin_va_list`，这用于变长函数支持，因此为 M88k 添加了一个相应的类型：
- en: '[PRE33]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, we must add a new header file, `clang/lib/Basic/Targets/M88k.h`. This
    file is a header for the M88k target feature support within the frontend. The
    first step is to define a new macro, to prevent multiple inclusive of the same
    header files, types, variables, and more. We must also include various headers
    that we require for the implementation to follow:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须添加一个新的头文件，`clang/lib/Basic/Targets/M88k.h`。此文件是前端 M88k 目标功能支持的头部文件。第一步是定义一个新的宏，以防止多次包含相同的头文件、类型、变量等。我们还需要包含实现所需的各个头文件：
- en: '[PRE34]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The methods we will declare will be added to the `clang` and `targets` namespaces
    accordingly, much like the other targets within `llvm-project`:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将要声明的函数将被添加到 `clang` 和 `targets` 命名空间中，就像 `llvm-project` 内的其他目标一样：
- en: '[PRE35]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let’s declare the actual `M88kTargetInfo` class now, and have it extend the
    original `TargetInfo` class. This class is marked with `LLVM_LIBRARY_VISIBILITY`
    because if this class is linked to a shared library, this attribute allows the
    `M88kTargetInfo` class to only be visible from within the library, and inaccessible
    externally:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们声明实际的`M88kTargetInfo`类，并让它扩展原始的`TargetInfo`类。这个类被标记为`LLVM_LIBRARY_VISIBILITY`，因为如果这个类链接到共享库，这个属性允许`M88kTargetInfo`类仅在库内部可见，外部不可访问：
- en: '[PRE36]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Additionally, we must declare two variables – an array of characters to represent
    the register names and an `enum` value containing the type of CPUs available in
    the M88k target that can be selected. The default CPU that we set is the `CK_Unknown`
    CPU. Later, we will see that this can be overwritten by user options:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们必须声明两个变量——一个字符数组来表示寄存器名称，以及一个`enum`值，包含M88k目标中可选择的CPU类型。我们设置的默认CPU是`CK_Unknown`
    CPU。稍后，我们将看到这可以被用户选项覆盖：
- en: '[PRE37]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'After, we begin by declaring the public methods that will be needed in our
    class implementation. Aside from the constructor of our class, we define various
    getter methods. This includes methods that get target-specific `#define` values,
    ones that get a list of built-ins supported by the target, methods that return
    the GCC register names along with their aliases, and finally, a method that returns
    our M88k `BuiltinVaListKind` that we previously added to `clang/include/clang/Basic/TargetInfo.h`:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们开始声明在我们的类实现中需要的公共方法。除了我们类的构造函数外，我们还定义了各种getter方法。这包括获取特定目标`#define`值的函数，获取目标支持的内置函数列表的函数，返回GCC寄存器名称及其别名的函数，以及最终返回我们之前添加到`clang/include/clang/Basic/TargetInfo.h`中的M88k
    `BuiltinVaListKind`的函数：
- en: '[PRE38]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Following the getter methods, we must also define methods that perform various
    checks on the M88k target. The first one checks if the M88k target has a particular
    target feature, supplied in the form of a string. Secondly, we add a function
    to validate the constraints when inline assembly is used. Finally, we have a function
    that checks if a specific CPU is valid for the M88k target, also supplied in the
    form of a string:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在getter方法之后，我们还必须定义执行对M88k目标进行各种检查的方法。第一个方法检查M88k目标是否具有特定的目标特性，以字符串的形式提供。其次，我们添加了一个函数来验证内联汇编时使用的约束条件。最后，我们有一个函数检查特定的CPU是否适用于M88k目标，也以字符串的形式提供：
- en: '[PRE39]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, let’s declare setter methods for our `M88kTargetInfo` class. The first
    one simply sets the specific M88k CPU that we want to target, while the second
    method sets a vector to contain all of the valid supported CPUs for M88k:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们声明`M88kTargetInfo`类的setter方法。第一个方法简单地设置我们想要针对的特定M88k CPU，而第二个方法设置一个向量，包含所有有效的支持M88k的CPU：
- en: '[PRE40]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To complete our header for the driver implementation, let’s conclude our namespaces
    and macro definition that we added in the beginning:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成驱动程序的头部实现，让我们总结一下我们在开始时添加的命名空间和宏定义：
- en: '[PRE41]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now that we’ve completed the M88k header file within `clang/lib/Basic/Targets`,
    we must add the corresponding `TargetInfo` C++ implementation within `clang/lib/Basic/Targets/M88k.cpp`.
    We’ll start by including the required header files, especially the new `M88k.h`
    header we have just created:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经完成了`clang/lib/Basic/Targets`中的M88k头文件，我们必须在`clang/lib/Basic/Targets/M88k.cpp`中添加相应的`TargetInfo`
    C++实现。我们将首先包含所需的头文件，特别是我们刚刚创建的新`M88k.h`头文件：
- en: '[PRE42]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'As we did previously in the header, we start with the `clang` and `targets`
    namespaces, and then also begin implementing the constructor for the `M88kTargetInfo`
    class:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像我们在标题中之前做的那样，我们从`clang`和`targets`命名空间开始，然后也开始实现`M88kTargetInfo`类的构造函数：
- en: '[PRE43]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Within the constructor, we set the data layout string for the M88k target.
    As you may have seen before, this data layout string is seen at the top of the
    emitted LLVM IR files. An explanation of each section of the data layout string
    is described here:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，我们为M88k目标设置数据布局字符串。正如你可能之前看到的，这个数据布局字符串出现在生成的LLVM IR文件顶部。数据布局字符串每个部分的解释在这里描述：
- en: '[PRE44]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The constructor for the `M88kTargetInfo` class concludes by setting the various
    variable types as `signed long long`, `unsigned long`, or `signed int`:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`M88kTargetInfo`类的构造函数通过设置各种变量类型为`signed long long`、`unsigned long`或`signed
    int`来结束：'
- en: '[PRE45]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'After that, the function to set the CPU for the target is implemented. This
    function takes a string and sets the CPU to be the particular CPU string that
    is supplied by the user within `llvm::StringSwitch`, which is essentially just
    a regular switch but specifically for strings with LLVM. We can see that there
    are three supported CPU types on the M88k target, and there is a `CK_Unknown`
    type for if the supplied string does not match any of the expected types:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，实现了设置目标CPU的函数。这个函数接受一个字符串，并将CPU设置为用户在`llvm::StringSwitch`中提供的特定CPU字符串，这实际上只是一个常规的switch语句，但专门用于LLVM中的字符串。我们可以看到，在M88k目标上有三种支持的CPU类型，还有一个`CK_Unknown`类型，用于如果提供的字符串与任何预期的类型都不匹配：
- en: '[PRE46]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'It was previously stated that there are three supported and valid CPU types
    on the M88k target: `mc88000`, `mc88100`, and `mc88110`, with the `generic` type
    simply being the `mc88000` CPU. We must implement the following functions to enforce
    these valid CPUs within clang. First, we must declare an array of strings, `ValidCPUNames[]`,
    to denote the valid CPU names on M88k. Secondly, the `fillValidCPUList()` method
    populates the array of valid CPU names into a vector. This vector is then used
    in the `isValidCPUName()` method, to check whether a particular CPU name supplied
    is indeed valid for our M88k target:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之前已经提到，在M88k目标上支持并有效的CPU类型有三种：`mc88000`、`mc88100`和`mc88110`，其中`generic`类型简单地就是`mc88000`
    CPU。我们必须实现以下函数来在clang中强制执行这些有效的CPU：首先，我们必须声明一个字符串数组`ValidCPUNames[]`，以表示M88k上的有效CPU名称。其次，`fillValidCPUList()`方法将有效CPU名称数组填充到一个向量中。然后，这个向量在`isValidCPUName()`方法中使用，以检查提供的特定CPU名称是否确实适用于我们的M88k目标：
- en: '[PRE47]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Next, the `getTargetDefines()` method is implemented. This function defines
    the macros that are necessary for the frontend, such as the valid CPU types. Aside
    from the `__m88k__` and `__m88k` macros, we must also define corresponding CPU
    macros for the valid CPUs:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，实现`getTargetDefines()`方法。这个函数定义了前端必需的宏，例如有效CPU类型。除了`__m88k__`和`__m88k`宏之外，我们还必须为有效CPU定义相应的CPU宏：
- en: '[PRE48]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The next few functions are stub functions but are required for the frontend
    for basic support. This includes the functions to get builtins from a target and
    a function to query the target if a specific feature of the target is supported.
    For now, we’ll leave them unimplemented and set default return values for these
    functions so that they can be implemented later:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来的几个函数是存根函数，但它们对于前端的基本支持是必需的。这包括从目标获取内置函数的函数以及查询目标是否支持特定功能的函数。目前，我们将它们留空实现，并为这些函数设置默认返回值，以便以后实现：
- en: '[PRE49]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Following these functions, we will add an implementation for the register names
    on M88k. Usually, the list of supported register names and their purposes can
    be found on the ABI of the specific platform of interest. Within this implementation,
    we’ll implement the main general-purpose registers from 0-31 and also create an
    array to store this information in. In terms of register aliases, note that there
    are no aliases for the registers that we implement currently:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这些函数之后，我们将为M88k上的寄存器名称添加一个实现。通常，支持的寄存器名称列表及其用途可以在感兴趣的具体平台的ABI中找到。在这个实现中，我们将实现0-31号的主要通用寄存器，并创建一个数组来存储这些信息。至于寄存器别名，请注意，我们目前实现的寄存器没有别名：
- en: '[PRE50]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The last function we’ll implement is a function that validates the inline assembly
    constraints on our target. This function simply takes a character, which represents
    the inline assembly constraint, and handles the constraint accordingly. A few
    inline assembly register constraints are implemented, such as for the address,
    data, and floating-point registers, and a select few constraints for constants
    are also accounted for:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将实现的最后一个函数是验证目标内联汇编约束的函数。这个函数简单地接受一个字符，它代表内联汇编约束，并相应地处理这个约束。实现了一些内联汇编寄存器约束，例如地址、数据和浮点寄存器，以及一些常数的约束：
- en: '[PRE51]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We conclude the file by closing off the `clang` and `targets` namespaces that
    we initiated at the beginning of the file:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过关闭文件开始时启动的`clang`和`targets`命名空间来结束文件：
- en: '[PRE52]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: After completing the implementation for `clang/lib/Basic/Targets/M88k.cpp`,
    the following implementation of adding the M88k features group and valid CPU types
    within `clang/include/clang/Driver/Options.td`. is required.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成`clang/lib/Basic/Targets/M88k.cpp`的实现后，需要在`clang/include/clang/Driver/Options.td`中添加M88k功能组和有效CPU类型的实现：
- en: 'Recall from earlier that we previously defined three valid CPU types for our
    M88k target: `mc88000`, `mc88100`, and `mc88110`. These CPU types also need to
    be defined in `Options.td` since this file is the central place that defines all
    options and flags that will be accepted by clang:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们之前为我们的 M88k 目标定义了三种有效的 CPU 类型：`mc88000`、`mc88100` 和 `mc88110`。这些 CPU
    类型也需要在 `Options.td` 中定义，因为该文件是定义所有将被 clang 接受的选项和标志的中心位置：
- en: 'First, we must add `m_m88k_Features_Group`, which represents a group of features
    that will be available to the M88k target:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须添加 `m_m88k_Features_Group`，它代表一组将可用于 M88k 目标的特性：
- en: '[PRE53]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Next, we must define the three valid M88k CPU types as a feature in the M88k
    features group:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们必须在 M88k 特性组中定义三种有效的 M88k CPU 类型作为一个特性：
- en: '[PRE54]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: With that, we have implemented the driver integration portion for connecting
    the M88k target with clang.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就实现了将 M88k 目标与 clang 连接的驱动程序集成部分。
- en: Implementing ABI support for M88k within clang
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 clang 中实现 M88k 的 ABI 支持
- en: 'Now, we need to add ABI support within the frontend for clang, which allows
    us to produce code specific to the M88k target from the frontend:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在 clang 的前端添加 ABI 支持，这允许我们从前端生成针对 M88k 目标的特定代码：
- en: 'Let’s start by adding the following `clang/lib/CodeGen/TargetInfo.h`. This
    is a prototype that creates the code generation information for the M88k target:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从添加以下 `clang/lib/CodeGen/TargetInfo.h` 开始。这是一个原型，用于为 M88k 目标创建代码生成信息：
- en: '[PRE55]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We also need to add the following code to `clang/lib/Basic/Targets.cpp`, which
    will help teach clang the acceptable target triples for M88k. As we can see, for
    the M88k target, the acceptable operating system is OpenBSD. This means that clang
    accepts `m88k-openbsd` as a target triple:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要将以下代码添加到 `clang/lib/Basic/Targets.cpp` 中，这将帮助 clang 学习 M88k 可接受的目标三元组。正如我们所见，对于
    M88k 目标，可接受的操作系统是 OpenBSD。这意味着 clang 接受 `m88k-openbsd` 作为目标三元组：
- en: '[PRE56]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Now, we need to create a file called `clang/lib/CodeGen/Targets/M88k.cpp` so
    that we can continue the code generation information and ABI implementation for
    M88k.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个名为 `clang/lib/CodeGen/Targets/M88k.cpp` 的文件，这样我们就可以继续为 M88k 进行代码生成信息和
    ABI 实现了。
- en: 'Within `clang/lib/CodeGen/Targets/M88k.cpp`, we must add the following necessary
    headers, one of which is the `TargetInfo.h` header that we have just modified.
    Then, we must specify that we’re using the `clang` and `clang::codegen` namespaces:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `clang/lib/CodeGen/Targets/M88k.cpp` 中，我们必须添加以下必要的头文件，其中之一是我们刚刚修改的 `TargetInfo.h`
    头文件。然后，我们必须指定我们正在使用 `clang` 和 `clang::codegen` 命名空间：
- en: '[PRE57]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Next, we must declare a new anonymous namespace and place our `M88kABIInfo`
    inside of it. `M88kABIInfo` inherits from the existing `ABIInfo` from clang and
    contains `DefaultABIInfo` inside it. For our target, we rely heavily on the existing
    `ABIInfo` and `DefaultABIInfo`, which simplifies the `M88kABIInfo` class significantly:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们必须声明一个新的匿名命名空间，并将我们的 `M88kABIInfo` 放入其中。`M88kABIInfo` 从 clang 的现有 `ABIInfo`
    继承，并在其中包含 `DefaultABIInfo`。对于我们的目标，我们严重依赖现有的 `ABIInfo` 和 `DefaultABIInfo`，这显著简化了
    `M88kABIInfo` 类：
- en: '[PRE58]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Furthermore, aside from adding the constructor for the `M88kABIInfo` class,
    a couple of methods are also added. `computeInfo()` implements the default `clang::CodeGen::ABIInfo`
    class. There’s also the `EmitVAArg()` function, which generates code that retrieves
    an argument from a pointer that is passed in; this is updated after. This is primarily
    used for variadic function support:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，除了添加 `M88kABIInfo` 类的构造函数之外，还添加了一些方法。`computeInfo()` 实现了默认的 `clang::CodeGen::ABIInfo`
    类。还有一个 `EmitVAArg()` 函数，它生成从传入的指针中检索参数的代码；稍后更新。这主要用于变长函数支持：
- en: '[PRE59]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The class constructor for the `M88kTargetCodeGenInfo` class is added next,
    which extends from the original `TargetCodeGenInfo`. After, we must close off
    the anonymous namespace that was created initially:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们添加 `M88kTargetCodeGenInfo` 类的构造函数，它扩展了原始的 `TargetCodeGenInfo`。之后，我们必须关闭最初创建的匿名命名空间：
- en: '[PRE60]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Finally, we must add the implementation to create the actual `M88kTargetCodeGenInfo`
    class as `std::unique_ptr`, which takes in a single `CodeGenModule` that generates
    LLVM IR code. This directly corresponds to what was originally added to `TargetInfo.h`:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们必须添加实现来创建实际的 `M88kTargetCodeGenInfo` 类，并将其作为 `std::unique_ptr` 使用，它接受一个生成
    LLVM IR 代码的 `CodeGenModule`。这直接对应于最初添加到 `TargetInfo.h` 中的内容：
- en: '[PRE61]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: That concludes the ABI support for the M88k in the frontend.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了前端对 M88k 的 ABI 支持。
- en: Implementing the toolchain support for M88k within clang
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 clang 中实现 M88k 的工具链支持
- en: 'The final portion of the M88k target integration within clang will be to implement
    toolchain support for our target. Like before, we’ll need to create a header file
    for toolchain support. We call this header `clang/lib/Driver/ToolChains/Arch/M88k.h`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在 clang 中 M88k 目标集成的最后部分是实现针对我们的目标的工具链支持。像之前一样，我们需要为工具链支持创建一个头文件。我们称这个头文件为 `clang/lib/Driver/ToolChains/Arch/M88k.h`：
- en: 'First, we must define `LLVM_CLANG_LIB_DRIVER_TOOLCHAINS_ARCH_M88K_H` to prevent
    multiple inclusion later, and also add any necessary headers for later use. Following
    this, we must declare the `clang`, `driver`, `tools`, and `m88k` namespaces, with
    each nesting inside the other:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须定义 `LLVM_CLANG_LIB_DRIVER_TOOLCHAINS_ARCH_M88K_H` 以防止以后多次包含，并添加任何必要的头文件以供以后使用。在此之后，我们必须声明
    `clang`、`driver`、`tools` 和 `m88k` 命名空间，每个嵌套在另一个内部：
- en: '[PRE62]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Next, we must declare an `enum` value that depicts the floating-point ABI,
    which is for soft and hard floating points. This means that floating-point computations
    can either be done by the floating-point hardware itself, which is fast, or through
    software emulation, which would be slower:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须声明一个 `enum` 值来描述浮点 ABI，这是用于软浮点和硬浮点的。这意味着浮点计算可以由浮点硬件本身完成，这很快，或者通过软件仿真，这会慢一些：
- en: '[PRE63]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Following this, we must add definitions to get the float ABI through the driver,
    and the CPU through clang’s `-mcpu=` and `-mtune=` options. We must also declare
    a function that retrieves the target features from the driver:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此之后，我们必须添加定义以通过驱动程序获取浮点 ABI，并通过 clang 的 `-mcpu=` 和 `-mtune=` 选项获取 CPU。我们还必须声明一个从驱动程序检索目标功能的函数：
- en: '[PRE64]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Finally, we conclude the header file by ending the namespaces and the macro
    that we originally defined:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们通过结束命名空间和我们最初定义的宏来结束头文件：
- en: '[PRE65]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The last file we will implement is the C++ implementation for the toolchain
    support, within `clang/lib/Driver/ToolChains/Arch/M88k.cpp`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要实现的最后一个文件是工具链支持的 C++ 实现，位于 `clang/lib/Driver/ToolChains/Arch/M88k.cpp`：
- en: 'Once again, we’ll begin the implementation by including the necessary headers
    and namespaces that we will use later. We must also include the `M88k.h` header
    that we created earlier:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将再次从包括我们稍后将要使用的必要头文件和命名空间开始实现。我们还必须包括我们之前创建的 `M88k.h` 头文件：
- en: '[PRE66]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The `normalizeCPU()` function is implemented next, which processes the CPU
    name into the `-mcpu=` option in clang. As we can see, each CPU name has several
    accepted variations. Furthermore, when a user specifies `-mcpu=native`, it allows
    them to compile for the current host’s CPU type:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来实现的是 `normalizeCPU()` 函数，该函数将 CPU 名称处理为 clang 中的 `-mcpu=` 选项。正如我们所见，每个 CPU
    名称都有几个可接受的变体。此外，当用户指定 `-mcpu=native` 时，它允许他们为当前主机的 CPU 类型进行编译：
- en: '[PRE67]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Next up, we must implement the `getM88kTargetCPU()` function, in which, given
    the clang CPU name that we implemented earlier in `clang/include/clang/Driver/Options.td`,
    we get the corresponding LLVM name for the M88k CPU we are targeting:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须实现 `getM88kTargetCPU()` 函数，其中，给定我们在 `clang/include/clang/Driver/Options.td`
    中之前实现的 clang CPU 名称，我们获取我们针对的 M88k CPU 的相应 LLVM 名称：
- en: '[PRE68]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The `getM88kTuneCPU()` function is implemented after. This is the behavior
    of the clang `-mtune=` option, which changes the instruction scheduling model
    to use data from a given CPU for M88k. We simply tune for whatever CPU that we
    are currently targeting:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在之后实现的是 `getM88kTuneCPU()` 函数。这是 clang `-mtune=` 选项的行为，它将指令调度模型更改为使用给定 CPU 的数据来针对
    M88k。我们简单地针对我们当前正在针对的任何 CPU 进行调整：
- en: '[PRE69]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'We’ll also implement the `getM88kFloatABI()` method, which gets the floating-point
    ABI. Initially, we’ll set the ABI to be `m88k::FloatABI::Invalid` as a default
    value. Next, we must check if any of the `-msoft-float` or `-mhard-float` options
    are passed to the command line. If `-msoft-float` is specified, then we set the
    ABI to `m88k::FloatABI::Soft` accordingly. Likewise, we set `m88k::FloatABI::Hard`
    when `-mhard-float` is specified to clang. Finally, if none of these options are
    specified, we choose the default on the current platform, which would be a hard
    floating-point value for M88k:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将实现 `getM88kFloatABI()` 方法，该方法获取浮点 ABI。最初，我们将 ABI 设置为 `m88k::FloatABI::Invalid`
    作为默认值。接下来，我们必须检查命令行是否传递了任何 `-msoft-float` 或 `-mhard-float` 选项。如果指定了 `-msoft-float`，则相应地将
    ABI 设置为 `m88k::FloatABI::Soft`。同样，当指定 `-mhard-float` 时，我们将 `m88k::FloatABI::Hard`
    设置为 clang。最后，如果没有指定这些选项中的任何一个，我们将选择当前平台上的默认值，对于 M88k 来说这将是一个硬浮点值：
- en: '[PRE70]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We’ll add the implementation for `getM88kTargetFeatures()` next. The important
    part of this function is the vector of `Features` that are passed as a parameter.
    As we can see, the only target features that are handled are the floating-point
    ABI. From the driver and arguments passed to it, we’ll get the appropriate floating-point
    ABI from what we implemented in the previous step. Note that we add the `-hard-float`
    target features to the `Features` vector for soft float ABI as well, which means
    that currently, M88k only supports hard float:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们接下来将添加`getM88kTargetFeatures()`的实现。这个函数的重要部分是作为参数传递的`Features`向量。正如我们所见，唯一处理的目标特性是浮点ABI。从驱动程序及其传递的参数中，我们将从之前步骤中实现的浮点ABI中获取适当的浮点ABI。请注意，我们还将`-hard-float`目标特性添加到`Features`向量中，以支持软浮点ABI，这意味着目前M88k只支持硬浮点：
- en: '[PRE71]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Building the M88k target with clang integration
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建具有clang集成的M88k目标
- en: 'We’re almost done with the implementation for integrating M88k into clang.
    The last step is to add the new clang files that we have added into their corresponding
    `CMakeLists.txt` file, which allows us to build the clang project with our M88k
    target implementation:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了将M88k集成到clang中的实现。最后一步是将我们添加的新clang文件添加到相应的`CMakeLists.txt`文件中，这样我们就可以使用我们的M88k目标实现来构建clang项目：
- en: First, add the `Targets/M88k.cpp` line to `clang/lib/Basic/CMakeLists.txt`.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将`Targets/M88k.cpp`行添加到`clang/lib/Basic/CMakeLists.txt`。
- en: Next, add `Targets/M88k.cpp` to `clang/lib/CodeGen/CMakeLists.txt`.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将`Targets/M88k.cpp`添加到`clang/lib/CodeGen/CMakeLists.txt`。
- en: Finally, add `ToolChains/Arch/M88k.cpp` to `clang/lib/Driver/CMakeLists.txt`.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将`ToolChains/Arch/M88k.cpp`添加到`clang/lib/Driver/CMakeLists.txt`。
- en: There we have it! That concludes our toolchain implementation for the toolchain
    support for the M88k target, which subsequently means we’ve completed the integration
    into clang for M88k!
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！这标志着我们为M88k目标工具链支持的工具链实现完成，这也意味着我们已经完成了M88k对clang的集成！
- en: 'The last step we need to do is build clang with the M88k target. The following
    commands will build the clang and LLVM project. For clang, be aware of the M88k
    target. Here, the `-DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD=M88k` CMake option must
    be added, as in the previous section:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一步是用M88k目标构建clang。以下命令将构建clang和LLVM项目。对于clang，请注意M88k目标。在这里，必须添加与上一节相同的CMake选项`-DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD=M88k`：
- en: '[PRE72]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We should now have a version of clang that recognizes the M88k target! We can
    confirm this by checking the list of targets that clang supports, through the
    `–``print-targets` option:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该有一个可以识别M88k目标的clang版本！我们可以通过检查clang支持的目标列表来确认这一点，通过`--print-targets`选项：
- en: '[PRE73]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In this section, we delved into the technical details of integrating a new backend
    target into clang and having it recognized. In the next section, we’ll explore
    the concept of cross-compiling, where we detail the procedure of targeting a different
    CPU architecture from the current host.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们深入探讨了将新的后端目标集成到clang中并使其被识别的技术细节。在下一节中，我们将探讨交叉编译的概念，我们将详细说明从当前主机针对不同CPU架构的流程。
- en: Targeting a different CPU architecture
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 针对不同的CPU架构
- en: Today, many small computers, such as the Raspberry Pi, are in use despite having
    only limited resources. Running a compiler on such a computer is often not possible
    or it takes too much time. Thus, a common requirement for a compiler is to generate
    code for a different CPU architecture. The whole process of having a host compile
    an executable for a different target is called cross-compiling.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，尽管资源有限，许多小型计算机，如树莓派（Raspberry Pi），仍在使用中。在这样的计算机上运行编译器通常是不可能的，或者需要花费太多时间。因此，编译器的一个常见要求是为不同的CPU架构生成代码。为主机编译不同目标可执行文件的全过程被称为交叉编译。
- en: 'In cross-compiling, two systems are involved: the host system and the target
    system. The compiler runs on the host system and produces code for the target
    system. To denote the systems, the so-called triple is used. This is a configuration
    string that usually consists of the CPU architecture, the vendor, and the operating
    system. Furthermore, additional information about the environment is often added
    to the configuration string. For example, the `x86_64-pc-win32` triple is used
    for a Windows system running on a 64-bit X86 CPU. The CPU architecture is `x86_64`,
    `pc` is a generic vendor, and `win32` is the operating system, and all of these
    pieces are connected by a hyphen. A Linux system running on an ARMv8 CPU uses
    `aarch64-unknown-linux-gnu` as the triple, with `aarch64` as the CPU architecture.
    Moreover, the operating system is `linux`, running a `gnu` environment. There
    is no real vendor for a Linux-based system, so this part is `unknown`. Additionally,
    parts that are not known or unimportant for a specific purpose are often omitted:
    the `aarch64-linux-gnu` triple describes the same Linux system.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在交叉编译中，涉及两个系统：主机系统和目标系统。编译器在主机系统上运行，为目标系统生成代码。为了表示系统，使用所谓的三元组。这是一个配置字符串，通常由
    CPU 架构、供应商和操作系统组成。此外，通常还会将有关环境的附加信息添加到配置字符串中。例如，`x86_64-pc-win32` 三元组用于在 64 位
    X86 CPU 上运行的 Windows 系统。CPU 架构是 `x86_64`，`pc` 是一个通用的供应商，`win32` 是操作系统，所有这些部分都由连字符连接。在
    ARMv8 CPU 上运行的 Linux 系统使用 `aarch64-unknown-linux-gnu` 作为三元组，其中 `aarch64` 是 CPU
    架构。此外，操作系统是 `linux`，运行 `gnu` 环境。基于 Linux 的系统没有真正的供应商，因此这部分是 `unknown`。此外，对于特定目的而言不明确或不重要的部分通常会被省略：`aarch64-linux-gnu`
    三元组描述了相同的 Linux 系统。
- en: 'Let’s assume your development machine runs Linux on an X86 64-bit CPU and you
    want to cross-compile to an ARMv8 CPU system running Linux. The host triple is
    `x86_64-linux-gnu` and the target triple is `aarch64-linux-gnu`. Different systems
    have different characteristics. Thus, your application must be written in a portable
    fashion; otherwise, complications may arise. Some common pitfalls are as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的开发机器运行的是基于 X86 64 位 CPU 的 Linux 系统，并且你想要交叉编译到运行 Linux 的 ARMv8 CPU 系统上。主机三元组是
    `x86_64-linux-gnu`，目标三元组是 `aarch64-linux-gnu`。不同的系统有不同的特性。因此，你的应用程序必须以可移植的方式编写；否则，可能会出现复杂情况。一些常见的问题如下：
- en: '**Endianness**: The order in which multi-byte values are stored in memory can
    be different.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字节序（Endianness）**：多字节值在内存中存储的顺序可能不同。'
- en: '`int` type may not be large enough to hold a pointer.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int` 类型可能不足以容纳指针。'
- en: '`long double` type can use 64-bit (ARM), 80-bit (X86), or 128-bit (ARMv8).
    PowerPC systems may use double-double arithmetic for `long double`, which gives
    more precision by using a combination of two 64-bit `double` values.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long double` 类型可以使用 64 位（ARM）、80 位（X86）或 128 位（ARMv8）。PowerPC 系统可能使用双双精度算术来表示
    `long double`，通过组合两个 64 位的 `double` 值来提供更高的精度。'
- en: If you do not pay attention to these points, then your application can act surprisingly
    or crash on the target platform, even if it runs perfectly on your host system.
    The LLVM libraries are tested on different platforms and also contain portable
    solutions to the aforementioned issues.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有注意这些要点，那么你的应用程序在目标平台上可能会表现出意外的行为或崩溃，即使它在主机系统上运行得很好。LLVM 库在不同的平台上进行了测试，并且还包含对上述问题的可移植解决方案。
- en: 'For cross-compiling, the following tools are required:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 对于交叉编译，需要以下工具：
- en: A compiler that generates code for the target
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够为目标生成代码的编译器
- en: A linker capable of generating binaries for the target
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够为目标生成二进制文件的可链接器
- en: Header files and libraries for the target
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标系统的头文件和库
- en: 'Fortunately, the Ubuntu and Debian distributions have packages that support
    cross-compiling. We’re taking advantage of this in the following setup. The `gcc`
    and `g++` compilers, the linker, `ld`, and the libraries are available as precompiled
    binaries that produce ARMv8 code and executables. The following command installs
    all of these packages:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Ubuntu 和 Debian 发行版有支持交叉编译的软件包。我们在以下设置中利用了这一点。`gcc` 和 `g++` 编译器、链接器 `ld`
    以及库都作为预编译的二进制文件提供，这些二进制文件生成 ARMv8 代码和可执行文件。以下命令安装了所有这些软件包：
- en: '[PRE74]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The new files are installed under the `/usr/aarch64-linux-gnu` directory. This
    directory is the (logical) root directory of the target system. It contains the
    usual `bin`, `lib`, and `include` directories. The cross-compilers (`aarch64-linux-gnu-gcc-8`
    and `aarch64-linux-gnu-g++-8`) are aware of this directory.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 新文件安装于 `/usr/aarch64-linux-gnu` 目录下。此目录是目标系统的（逻辑）根目录。它包含通常的 `bin`、`lib` 和 `include`
    目录。交叉编译器（`aarch64-linux-gnu-gcc-8` 和 `aarch64-linux-gnu-g++-8`）了解此目录。
- en: Cross-compiling on other systems
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他系统上交叉编译
- en: Some distributions, such as Fedora, only provide cross-compiling support for
    bare-metal targets such as the Linux kernel, but the header and library files
    needed for user land applications are not provided. In such a case, you can simply
    copy the missing files from your target system.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 一些发行版，如 Fedora，只为裸机目标（如 Linux 内核）提供交叉编译支持，但未提供用户空间应用程序所需的头文件和库文件。在这种情况下，你可以简单地从目标系统复制缺少的文件。
- en: If your distribution does not come with the required toolchain, then you can
    build it from source. For the compiler, you can use clang or gcc/g++. The gcc
    and g++ compilers must be configured to produce code for the target system and
    the binutils tools need to handle files for the target system. Moreover, the C
    and C++ libraries need to be compiled with this toolchain. The steps vary by operating
    system and host and target architecture. On the web, you can find instructions
    if you search for `gcc` `cross-compile <architecture>`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的发行版没有包含所需的工具链，则可以从源代码构建它。对于编译器，你可以使用 clang 或 gcc/g++。gcc 和 g++ 编译器必须配置为为目标系统生成代码，而
    binutils 工具需要处理目标系统的文件。此外，C 和 C++ 库需要使用此工具链进行编译。步骤因操作系统、主机和目标架构而异。在网上，如果你搜索 `gcc`
    `cross-compile <架构>`，你可以找到说明。
- en: 'With this preparation, you are almost ready to cross-compile the sample application
    (including the LLVM libraries) except for one little detail. LLVM uses the `llvm-tblgen`
    from the build in [*Chapter 1*](B19561_01.xhtml#_idTextAnchor017) or you can compile
    only this tool. Assuming you are in the directory that contains the clone of this
    book’s GitHub repository, type the following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 准备就绪后，你几乎可以开始交叉编译示例应用程序（包括 LLVM 库）了，除了一个小细节。LLVM 使用 [*第 1 章*](B19561_01.xhtml#_idTextAnchor017)
    中的 `llvm-tblgen` 或你可以只编译此工具。假设你在这个包含本书 GitHub 仓库克隆的目录中，输入以下命令：
- en: '[PRE75]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: These steps should be familiar by now. A build directory is created and entered.
    The `cmake` command creates the build files for LLVM only for the X86 target.
    To save space and time, a release build is done but assertions are enabled to
    catch possible errors. Only the `llvm-tblgen` tool is compiled with `ninja`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤现在应该很熟悉了。创建并进入一个构建目录。`cmake` 命令只为 X86 目标创建 LLVM 的构建文件。为了节省空间和时间，执行了发布构建，但启用了断言以捕获可能的错误。只有
    `llvm-tblgen` 工具使用 `ninja` 进行编译。
- en: 'With the `llvm-tblgen` tool at hand, you can now start the cross-compilation
    process. The CMake command line is very long, so you may want to store the command
    in a script file. The difference from previous builds is that more information
    must be provided:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `llvm-tblgen` 工具后，你现在可以开始交叉编译过程。CMake 命令行非常长，所以你可能想将命令存储在脚本文件中。与之前的构建相比，差异在于必须提供更多信息：
- en: '[PRE76]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Again, you create a build directory and enter it before running the CMake command.
    Some of these CMake parameters have not been used before and require some explanation:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，在运行 CMake 命令之前，创建一个构建目录并进入它。其中一些这些 CMake 参数之前未使用过，需要一些解释：
- en: '`CMAKE_CROSSCOMPILING` set to `ON` tells CMake that we are cross-compiling.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `CMAKE_CROSSCOMPILING` 设置为 `ON` 告诉 CMake 我们正在进行交叉编译。
- en: '`LLVM_TABLEGEN` specifies the path to the `llvm-tblgen` tool to use. This is
    the one from the previous build.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LLVM_TABLEGEN` 指定了要使用的 `llvm-tblgen` 工具的路径。这是之前构建中使用的版本。'
- en: '`LLVM_DEFAULT_TARGET_TRIPLE` is the triple of the target architecture.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LLVM_DEFAULT_TARGET_TRIPLE` 是目标架构的三元组。'
- en: '`LLVM_TARGET_ARCH` is used for **JIT** code generation. It defaults to the
    architecture of the host. For cross-compiling, this must be set to the target
    architecture.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LLVM_TARGET_ARCH` 用于 **JIT** 代码生成。它默认为主机架构。对于交叉编译，这必须设置为目标架构。'
- en: '`LLVM_TARGETS_TO_BUILD` is the list of targets for which LLVM should include
    code generators. The list should at least include the target architecture.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LLVM_TARGETS_TO_BUILD` 是 LLVM 应该包含代码生成器的目标列表。该列表至少应包括目标架构。'
- en: '`CMAKE_C_COMPILER` and `CMAKE_CXX_COMPILER` specify the C and C++ compilers
    used for the build, respectively. The binaries of the cross-compilers are prefixed
    with the target triple and are not found automatically by CMake.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMAKE_C_COMPILER` 和 `CMAKE_CXX_COMPILER` 分别指定用于构建的 C 和 C++ 编译器。交叉编译器的二进制文件以目标三元组为前缀，并且
    CMake 不会自动找到它们。'
- en: With the other parameters, a release build with assertions enabled is requested
    and our tinylang application is built as part of LLVM. Once the compilation process
    has finished, the `file` command can demonstrate that we have created a binary
    for ARMv8\. Specifically, we can run `$ file bin/tinylang` and check that the
    output says `ELF 64-bit object for the ARM` `aarch64 architecture`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 使用其他参数，请求启用断言的发布构建，并且我们的 tinylang 应用程序作为 LLVM 的一部分构建。一旦编译过程完成，`file` 命令可以证明我们已经为
    ARMv8 创建了一个二进制文件。具体来说，我们可以运行 `$ file bin/tinylang` 并检查输出是否显示 `ELF 64-bit object
    for the ARM` `aarch64 architecture`。
- en: Cross-compiling with clang
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 clang 进行交叉编译
- en: 'As LLVM generates code for different architectures, it seems obvious to use
    clang to cross-compile. The obstacle here is that LLVM does not provide all the
    required parts – for example, the C library is missing. Because of this, you must
    use a mix of LLVM and GNU tools and as a result, you need to tell CMake even more
    about the environment you are using. As a minimum, you need to specify the following
    options for clang and clang++: `--target=<target-triple>` (enables code generation
    for a different target), `--sysroot=<path>` (path to the root directory for the
    target), `I` (search path for header files), and `–L` (search path for libraries).
    During the CMake run, a small application is compiled and CMake complains if something
    is wrong with your setup. This step is sufficient to check if you have a working
    environment. Common problems are picking the wrong header files or link failures
    due to different library names or wrong search paths.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 LLVM 为不同的架构生成代码，使用 clang 进行交叉编译似乎是显而易见的。这里的障碍是 LLVM 并不提供所有必需的部分——例如，C 库缺失。因此，您必须混合使用
    LLVM 和 GNU 工具，结果您需要告诉 CMake 更多关于您使用环境的细节。至少，您需要为 clang 和 clang++ 指定以下选项：`--target=<target-triple>`（启用针对不同目标的代码生成），`--sysroot=<path>`（目标根目录的路径），`I`（头文件的搜索路径），和
    `--L`（库的搜索路径）。在 CMake 运行期间，一个小型应用程序被编译，如果您的设置有问题，CMake 会抱怨。这一步足以检查您是否有正常工作的环境。常见问题包括选择错误的头文件或由于库名称不同或搜索路径错误导致的链接失败。
- en: Cross-compiling is surprisingly complex. With the instructions from this section,
    you will be able to cross-compile your application for a target architecture of
    your choice.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 跨平台编译令人惊讶地复杂。通过本节中的说明，您将能够为所选的目标架构交叉编译您的应用程序。
- en: Summary
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about creating passes that run beyond instruction
    selection, specifically exploring the creation behind machine function passes
    in the backend! You also discovered how to add a new experimental target into
    clang, and some of the driver, ABI, and toolchain changes that are required. Finally,
    while considering the supreme discipline of compiler construction, you learned
    how to cross-compile your application for another target architecture.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了创建运行在指令选择之外的传递，特别是探索了后端中机器函数传递背后的创建！您还发现了如何将一个新的实验性目标添加到 clang 中，以及一些所需的驱动程序、ABI
    和工具链更改。最后，在考虑编译器构建的最高准则时，您学习了如何为另一个目标架构交叉编译您的应用程序。
- en: Now that we’re at the end of *Learn LLVM 17*, you are equipped with the knowledge
    to use LLVM in creative ways in your projects and have explored many interesting
    topics. The LLVM ecosystem is very active, and new features are added all the
    time, so be sure to follow its development!
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经到达了《学习 LLVM 17》的尾声，您已经具备了在项目中以创新方式使用 LLVM 的知识，并探索了许多有趣的主题。LLVM 生态系统非常活跃，新功能不断添加，因此请务必关注其发展！
- en: As compiler developers ourselves, it was a pleasure for us to write about LLVM
    and discover some new features along the way. Have fun with LLVM!
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 作为编译器开发者，我们很高兴能撰写关于 LLVM 的文章，并在过程中发现了一些新功能。享受使用 LLVM 的乐趣吧！
