- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Beyond Instruction Selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we’ve learned about instruction selection using the SelectionDAG and
    GlobalISel LLVM-based frameworks in the previous chapters, we can explore other
    interesting concepts beyond instruction selection. This chapter encapsulates some
    more advanced topics outside of the backend that can be interesting for a highly
    optimizing compiler. For instance, some passes run beyond instruction selection
    and can perform different optimizations on various instructions, which can mean
    that developers have the luxury to introduce their own passes to perform meaningful
    target-specific tasks at this point in the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ultimately, within this chapter, we will dive into the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new machine function pass to LLVM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating a new target into the clang frontend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to target a different CPU architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a new machine function pass to LLVM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will explore how to implement a new machine function pass
    within LLVM that runs after instruction selection. Specifically, a `MachineFunctionPass`
    class will be created, which is a subset of the original `FunctionPass` class
    within LLVM that can be run with `opt`. This class adapts the original infrastructure
    to allow for the implementation of passes that operate on the `MachineFunction`
    representation in the backend through `llc`.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that the implementation of passes within the backend
    utilizes the interfaces of the legacy pass manager, rather than the new pass manager.
    This is because LLVM currently does not have a complete working implementation
    of the new pass manager within the backend. Due to this, this chapter will follow
    the method of adding a new pass within the legacy pass manager pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of the actual implementation, such as function passes, machine function
    passes optimize a single (machine) function at a time, but instead of overriding
    the `runOnFunction()` method, machine function passes override the `runOnMachineFunction()`
    method. The machine function pass that will be implemented in this section is
    a pass that checks for when a division by zero occurs, specifically, to insert
    code that traps in the backend. This type of pass is important for the M88k target
    due to hardware limitations on MC88100 as this CPU does not reliably detect division
    by zero situations.
  prefs: []
  type: TYPE_NORMAL
- en: Continuing from the previous chapter’s implementation of the backend, let’s
    examine how a backend machine function pass is implemented!
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the top-level interface for the M88k target
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Firstly, within `llvm/lib/Target/M88k/M88k.h`, let’s add two prototypes inside
    the `llvm` namespace declaration that will be used later:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The machine function pass that will be implemented will be called `M88kDivInstrPass`.
    We will add a function declaration that initializes this pass and takes in the
    pass registry, which is a class that manages the registration and initialization
    of all passes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, the actual function that creates the `M88kDivInstr` pass is declared,
    with the M88k target machine information as its argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Adding the TargetMachine implementation for machine function passes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we will analyze some of the changes that are required in `llvm/lib/Target/M88k/M88kTargetMachine.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Within LLVM, it’s common to give the user the option to toggle passes on or
    off. So, let’s provide the user the same flexibility with our machine function
    pass. We’ll start by declaring a command-line option called `m88k-no-check-zero-division`
    and initializing it to `false`, which implies that there will always be a check
    for zero division unless the user explicitly turns this off. We’ll add this under
    the `llvm` namespace declaration and is an option for `llc`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It is also customary to create a formal method that returns the command-line
    value so that we can query it to determine whether the pass will be run. Our original
    command-line option will be wrapped in the `noZeroDivCheck()` method so that we
    can utilize the command-line result later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, inside `LLVMInitializeM88kTarget()`, where the M88k target and passes
    are registered and initialized, we will insert a call to the `initializeM88kDivInstrPass()`
    method that was declared earlier in `llvm/lib/Target/M88k/M88k.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The M88k target also needs to override `addMachineSSAOptimization()`, which
    is a method that adds passes to optimize machine instructions when they are in
    SSA form. Essentially, our machine function pass is added as a type of machine
    SSA optimization. This method is declared as a function that is to be overridden.
    We will add the full implementation at the end of `M88kTargetMachine.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our method that returns the command-line option to toggle the machine function
    pass on and off (the `noZeroDivCheck()` method) is also declared in `M88kTargetMachine.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Developing the specifics of the machine function pass
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that the implementation in the M88k target machine is completed, the next
    step will be to develop the machine function pass itself. The implementation is
    contained within the new file, `llvm/lib/Target/M88k/M88kDivInstr.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The necessary headers for our machine function pass are added first. This includes
    headers that give us access to the M88k target information and headers that allow
    us to operate on machine functions and machine instructions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, we will add some code to prepare for our machine function pass.
    The first is a `DEBUG_TYPE` definition that is named `m88k-div-instr`, which is
    used for fine-grained control when debugging. Specifically, defining this `DEBUG_TYPE`
    allows users to specify the machine function pass name and view any debugging
    information that is pertinent to the pass when debug information is enabled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also specify that the `llvm` namespace is being used, and a `STATISTIC`
    value for our machine function is also declared. This statistic, called `InsertedChecks`,
    keeps track of how many division-by-zero checks are inserted by the compiler.
    Finally, an anonymous namespace is declared to encapsulate the subsequent machine
    function pass implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As mentioned previously, this machine function pass aims to check for division
    by zero cases and inserts instructions that will cause the CPU to trap. These
    instructions require condition codes, so an `enum` value that we call `CC0` is
    defined with condition codes that are valid for the M88k target, along with their
    encodings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s create the actual class for our machine function pass next, called `M88kDivInstr`.
    Firstly, we create it as an instance that inherits and is of the `MachineFunctionPass`
    type. Next, we declare various necessary instances that our `M88kDivInstr` pass
    will require. This includes `M88kBuilder`, which we will create and elaborate
    on later, and `M88kTargetMachine`, which contains target instruction and register
    information. Furthermore, we also require the register bank information and the
    machine register information when emitting instructions. An `AddZeroDivCheck`
    Boolean is also added to represent the previous command-line option, which turns
    our pass on or off:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the public variables and methods of the `M88kDivInstr` class, we declare
    an identification number that LLVM will use to identify our pass, as well as the
    `M88kDivInstr` constructor, which takes in `M88kTargetMachine`. Next, we override
    the `getRequiredProperties()` method, which represents the properties that `MachineFunction`
    may have at any time during the optimization, and we also override the `runOnMachineFunction()`
    method, which will be one of the primary methods that our pass will run when checking
    for any division by zero. The second important function that is publicly declared
    is the `runOnMachineBasicBlock()` function, which will be executed from inside
    `runOnMachineFunction()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, the last part is declaring the private methods and closing off the
    class. The only private method we declare within the `M88kDivInstr` class is the
    `addZeroDivCheck()` method, which inserts the checks for division by zero after
    any divide instruction. As we will see later, `MachineInstr` will need to point
    to specific divide instructions on the M88k target:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'An `M88kBuilder` class is created next, which is a specialized builder instance
    that creates M88k-specific instructions. This class keeps an instance of `MachineBasicBlock`
    (and a corresponding iterator), and `DebugLoc` to keep track of the debug location
    of this builder class. Other necessary instances include the target instruction
    information, the target register information, and the register bank information
    of the M88k target:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For public methods of the `M88kBuilder` class, we must implement the constructor
    for this builder. Upon initialization, our specialized builder requires an instance
    of the `M88kDivInstr` pass to initialize the target instruction, register information,
    and the register bank information, as well as `MachineBasicBlock` and a debug
    location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, a method to set `MachineBasicBlock` inside the M88k builder is created,
    and the `MachineBasicBlock` iterator is also set accordingly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `constrainInst()` function needs to be implemented next and is needed for
    when `MachineInstr` instances are processed. For a given `MachineInstr`, we check
    if the register class of the `MachineInstr` instance’s operands can be constrained
    through the pre-existing function, `constrainSelectedInstRegOperands()`. As shown
    here, this machine function pass requires that the register operands of the machine
    instruction can be constrained:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'One of the instructions that this pass inserts is a `BCND` instruction, as
    defined in `M88kInstrInfo.td`, which is a conditional branch on the M88k target.
    To create this instruction, we require a condition code, which are the `CC0` enums
    that were implemented at the beginning of `M88kDivInstr.cpp` – that is, a register
    and `MachineBasicBlock`. The `BCND` instruction is simply returned upon creation
    and after checking if the newly created instruction can be constrained:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similarly, we also require a trap instruction for our machine function pass,
    which is a `TRAP503` instruction. This instruction requires a register and raises
    a trap with vector 503 if the 0-th bit of the register is not set, which will
    be raised after a zero division. Upon creating the `TRAP503` instruction, `TRAP503`
    is checked for constraints before being returned. Moreover, this concludes the
    class implementation of the `M88kBuilder` class and completes the previously declared
    anonymous namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now start implementing the functions that perform the actual checks
    in the machine function pass. First, let’s explore how `addZeroDivCheck()` is
    implemented. This function simply inserts a check for division by zero between
    the current machine instruction, which is expected to point to either `DIVSrr`
    or `DIVUrr`; these are mnemonics for signed and unsigned divisions, respectively.
    The `BCND` and `TRAP503` instructions are inserted, and the `InsertedChecks` statistic
    is incremented to indicate the addition of the two instructions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`runOnMachineFunction()` is implemented next and is one of the important functions
    to override when creating a type of function pass within LLVM. This function returns
    true or false, depending on if any changes have been made during the duration
    of the machine function pass. Furthermore, for a given machine function, we gather
    all the relevant M88k subtarget information, including the target instruction,
    target register, register bank, and machine register information. Details regarding
    whether or not the user turns the `M88kDivInstr` machine function pass on or off
    are also queried and stored in the `AddZeroDivCheck` variable. Additionally, all
    machine basic blocks in the machine function are analyzed for the division by
    zero. The function that performs the machine basic block analysis is `runOnMachineBasicBlock()`;
    we will implement this next. Finally, if the machine function has changed, this
    is indicated by the `Changed` variable that is returned:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For the `runOnMachineBasicBlock()` function, a `Changed` Boolean flag is also
    returned to indicate if the machine basic block has been changed; however, it
    is initially set to `false`. Furthermore, within a machine basic block, we need
    to analyze all the machine instructions and check if the instructions are the
    `DIVUrr` or `DIVSrr` opcodes, respectively. In addition to checking if the opcodes
    are divide instructions, we need to check if the user has turned our machine function
    pass on or off. If all of these conditions are satisfied, the division by zero
    checks with the conditional branch and the trap instructions are added accordingly
    through the `addZeroDivCheck()` function, which was implemented previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After, we need to implement the constructor to initialize our function pass
    and set the appropriate machine function properties. This can be achieved by calling
    the `initializeM88kDivInstrPass()` function with the `PassRegistry` instance inside
    the constructor of the `M88kDivInstr` class, and also by setting the machine function
    properties to indicate that our pass requires machine functions to be in SSA form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is to initialize the ID for our machine function pass and to
    instantiate the `INITIALIZE_PASS` macro with the details of our machine function
    pass. This requires the pass instance, naming information, and two Boolean arguments
    that indicate if the pass only examines the CFG and if the pass is an analysis
    pass. Since `M88kDivInstr` performs neither of those, two `false` arguments are
    specified to the pass initialization macro:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, the `createM88kDivInstr()` function creates a new instance of the
    `M88kDivInstr` pass, with a `M88kTargetMachine` instance. This is encapsulated
    into an `llvm` namespace, and the namespace is ended after finishing this function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Building newly implemented machine function passes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’re almost done with implementing our new machine function pass! Now, we
    need to ensure CMake is aware of the new machine function pass within `M88kDivinstr.cpp`.
    This file is then added to `llvm/lib/Target/M88k/CMakeLists.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step is to build LLVM with our new machine function pass implementation
    with the following commands. We require the `-DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD=M88k`
    CMake option to build the M88k target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: With that, we’ve implemented the machine function pass, but wouldn’t it be interesting
    to see how it works? We can demonstrate the result of this pass by passing LLVM
    IR through `llc`.
  prefs: []
  type: TYPE_NORMAL
- en: A glimpse of running a machine function pass with llc
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have the following IR, which contains a division by zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s feed it into llc:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'By doing this, we’ll see that, in the resulting assembly, by default, the division
    by zero checks, which are represented by `bcnd.n` (`BCND`) and `tb0` (`TRAP503`),
    are inserted by our new machine function pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'However, let’s see what happens when we specify `--m88k-no-check-zero-division`
    to `llc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This option to the backend instructs `llc` not to run the pass that checks
    for the division by zero. The resulting assembly will not contain any `BCND` or
    `TRAP503` instructions. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, implementing a machine function pass requires several steps,
    but these procedures can be used as a guideline for you to implement any type
    of machine function pass that fits your needs. Since we have extensively explored
    the backend within this section, let’s switch gears and see how we can teach the
    frontend about the M88k target.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating a new target into the clang frontend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we developed the M88k target’s backend implementation
    within LLVM. To complete the compiler implementation for the M88k target, we will
    investigate connecting our new target to the frontend by adding a clang implementation
    for our M88k target.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the driver integration within clang
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start by adding driver integration into clang for M88k:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first change we will be making is inside the `clang/include/clang/Basic/TargetInfo.h`
    file. The `BuiltinVaListKind` enum lists the different kinds of `__builtin_va_list`
    types for each target, which is used for variadic functions support, so a corresponding
    type for M88k is added:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we must add a new header file, `clang/lib/Basic/Targets/M88k.h`. This
    file is a header for the M88k target feature support within the frontend. The
    first step is to define a new macro, to prevent multiple inclusive of the same
    header files, types, variables, and more. We must also include various headers
    that we require for the implementation to follow:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The methods we will declare will be added to the `clang` and `targets` namespaces
    accordingly, much like the other targets within `llvm-project`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s declare the actual `M88kTargetInfo` class now, and have it extend the
    original `TargetInfo` class. This class is marked with `LLVM_LIBRARY_VISIBILITY`
    because if this class is linked to a shared library, this attribute allows the
    `M88kTargetInfo` class to only be visible from within the library, and inaccessible
    externally:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Additionally, we must declare two variables – an array of characters to represent
    the register names and an `enum` value containing the type of CPUs available in
    the M88k target that can be selected. The default CPU that we set is the `CK_Unknown`
    CPU. Later, we will see that this can be overwritten by user options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After, we begin by declaring the public methods that will be needed in our
    class implementation. Aside from the constructor of our class, we define various
    getter methods. This includes methods that get target-specific `#define` values,
    ones that get a list of built-ins supported by the target, methods that return
    the GCC register names along with their aliases, and finally, a method that returns
    our M88k `BuiltinVaListKind` that we previously added to `clang/include/clang/Basic/TargetInfo.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Following the getter methods, we must also define methods that perform various
    checks on the M88k target. The first one checks if the M88k target has a particular
    target feature, supplied in the form of a string. Secondly, we add a function
    to validate the constraints when inline assembly is used. Finally, we have a function
    that checks if a specific CPU is valid for the M88k target, also supplied in the
    form of a string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let’s declare setter methods for our `M88kTargetInfo` class. The first
    one simply sets the specific M88k CPU that we want to target, while the second
    method sets a vector to contain all of the valid supported CPUs for M88k:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To complete our header for the driver implementation, let’s conclude our namespaces
    and macro definition that we added in the beginning:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we’ve completed the M88k header file within `clang/lib/Basic/Targets`,
    we must add the corresponding `TargetInfo` C++ implementation within `clang/lib/Basic/Targets/M88k.cpp`.
    We’ll start by including the required header files, especially the new `M88k.h`
    header we have just created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As we did previously in the header, we start with the `clang` and `targets`
    namespaces, and then also begin implementing the constructor for the `M88kTargetInfo`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within the constructor, we set the data layout string for the M88k target.
    As you may have seen before, this data layout string is seen at the top of the
    emitted LLVM IR files. An explanation of each section of the data layout string
    is described here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The constructor for the `M88kTargetInfo` class concludes by setting the various
    variable types as `signed long long`, `unsigned long`, or `signed int`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, the function to set the CPU for the target is implemented. This
    function takes a string and sets the CPU to be the particular CPU string that
    is supplied by the user within `llvm::StringSwitch`, which is essentially just
    a regular switch but specifically for strings with LLVM. We can see that there
    are three supported CPU types on the M88k target, and there is a `CK_Unknown`
    type for if the supplied string does not match any of the expected types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It was previously stated that there are three supported and valid CPU types
    on the M88k target: `mc88000`, `mc88100`, and `mc88110`, with the `generic` type
    simply being the `mc88000` CPU. We must implement the following functions to enforce
    these valid CPUs within clang. First, we must declare an array of strings, `ValidCPUNames[]`,
    to denote the valid CPU names on M88k. Secondly, the `fillValidCPUList()` method
    populates the array of valid CPU names into a vector. This vector is then used
    in the `isValidCPUName()` method, to check whether a particular CPU name supplied
    is indeed valid for our M88k target:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, the `getTargetDefines()` method is implemented. This function defines
    the macros that are necessary for the frontend, such as the valid CPU types. Aside
    from the `__m88k__` and `__m88k` macros, we must also define corresponding CPU
    macros for the valid CPUs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next few functions are stub functions but are required for the frontend
    for basic support. This includes the functions to get builtins from a target and
    a function to query the target if a specific feature of the target is supported.
    For now, we’ll leave them unimplemented and set default return values for these
    functions so that they can be implemented later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Following these functions, we will add an implementation for the register names
    on M88k. Usually, the list of supported register names and their purposes can
    be found on the ABI of the specific platform of interest. Within this implementation,
    we’ll implement the main general-purpose registers from 0-31 and also create an
    array to store this information in. In terms of register aliases, note that there
    are no aliases for the registers that we implement currently:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last function we’ll implement is a function that validates the inline assembly
    constraints on our target. This function simply takes a character, which represents
    the inline assembly constraint, and handles the constraint accordingly. A few
    inline assembly register constraints are implemented, such as for the address,
    data, and floating-point registers, and a select few constraints for constants
    are also accounted for:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We conclude the file by closing off the `clang` and `targets` namespaces that
    we initiated at the beginning of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After completing the implementation for `clang/lib/Basic/Targets/M88k.cpp`,
    the following implementation of adding the M88k features group and valid CPU types
    within `clang/include/clang/Driver/Options.td`. is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall from earlier that we previously defined three valid CPU types for our
    M88k target: `mc88000`, `mc88100`, and `mc88110`. These CPU types also need to
    be defined in `Options.td` since this file is the central place that defines all
    options and flags that will be accepted by clang:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must add `m_m88k_Features_Group`, which represents a group of features
    that will be available to the M88k target:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we must define the three valid M88k CPU types as a feature in the M88k
    features group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With that, we have implemented the driver integration portion for connecting
    the M88k target with clang.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing ABI support for M88k within clang
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we need to add ABI support within the frontend for clang, which allows
    us to produce code specific to the M88k target from the frontend:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by adding the following `clang/lib/CodeGen/TargetInfo.h`. This
    is a prototype that creates the code generation information for the M88k target:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also need to add the following code to `clang/lib/Basic/Targets.cpp`, which
    will help teach clang the acceptable target triples for M88k. As we can see, for
    the M88k target, the acceptable operating system is OpenBSD. This means that clang
    accepts `m88k-openbsd` as a target triple:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we need to create a file called `clang/lib/CodeGen/Targets/M88k.cpp` so
    that we can continue the code generation information and ABI implementation for
    M88k.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Within `clang/lib/CodeGen/Targets/M88k.cpp`, we must add the following necessary
    headers, one of which is the `TargetInfo.h` header that we have just modified.
    Then, we must specify that we’re using the `clang` and `clang::codegen` namespaces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we must declare a new anonymous namespace and place our `M88kABIInfo`
    inside of it. `M88kABIInfo` inherits from the existing `ABIInfo` from clang and
    contains `DefaultABIInfo` inside it. For our target, we rely heavily on the existing
    `ABIInfo` and `DefaultABIInfo`, which simplifies the `M88kABIInfo` class significantly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Furthermore, aside from adding the constructor for the `M88kABIInfo` class,
    a couple of methods are also added. `computeInfo()` implements the default `clang::CodeGen::ABIInfo`
    class. There’s also the `EmitVAArg()` function, which generates code that retrieves
    an argument from a pointer that is passed in; this is updated after. This is primarily
    used for variadic function support:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The class constructor for the `M88kTargetCodeGenInfo` class is added next,
    which extends from the original `TargetCodeGenInfo`. After, we must close off
    the anonymous namespace that was created initially:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we must add the implementation to create the actual `M88kTargetCodeGenInfo`
    class as `std::unique_ptr`, which takes in a single `CodeGenModule` that generates
    LLVM IR code. This directly corresponds to what was originally added to `TargetInfo.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That concludes the ABI support for the M88k in the frontend.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the toolchain support for M88k within clang
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The final portion of the M88k target integration within clang will be to implement
    toolchain support for our target. Like before, we’ll need to create a header file
    for toolchain support. We call this header `clang/lib/Driver/ToolChains/Arch/M88k.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must define `LLVM_CLANG_LIB_DRIVER_TOOLCHAINS_ARCH_M88K_H` to prevent
    multiple inclusion later, and also add any necessary headers for later use. Following
    this, we must declare the `clang`, `driver`, `tools`, and `m88k` namespaces, with
    each nesting inside the other:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we must declare an `enum` value that depicts the floating-point ABI,
    which is for soft and hard floating points. This means that floating-point computations
    can either be done by the floating-point hardware itself, which is fast, or through
    software emulation, which would be slower:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Following this, we must add definitions to get the float ABI through the driver,
    and the CPU through clang’s `-mcpu=` and `-mtune=` options. We must also declare
    a function that retrieves the target features from the driver:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we conclude the header file by ending the namespaces and the macro
    that we originally defined:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last file we will implement is the C++ implementation for the toolchain
    support, within `clang/lib/Driver/ToolChains/Arch/M88k.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, we’ll begin the implementation by including the necessary headers
    and namespaces that we will use later. We must also include the `M88k.h` header
    that we created earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `normalizeCPU()` function is implemented next, which processes the CPU
    name into the `-mcpu=` option in clang. As we can see, each CPU name has several
    accepted variations. Furthermore, when a user specifies `-mcpu=native`, it allows
    them to compile for the current host’s CPU type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next up, we must implement the `getM88kTargetCPU()` function, in which, given
    the clang CPU name that we implemented earlier in `clang/include/clang/Driver/Options.td`,
    we get the corresponding LLVM name for the M88k CPU we are targeting:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `getM88kTuneCPU()` function is implemented after. This is the behavior
    of the clang `-mtune=` option, which changes the instruction scheduling model
    to use data from a given CPU for M88k. We simply tune for whatever CPU that we
    are currently targeting:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll also implement the `getM88kFloatABI()` method, which gets the floating-point
    ABI. Initially, we’ll set the ABI to be `m88k::FloatABI::Invalid` as a default
    value. Next, we must check if any of the `-msoft-float` or `-mhard-float` options
    are passed to the command line. If `-msoft-float` is specified, then we set the
    ABI to `m88k::FloatABI::Soft` accordingly. Likewise, we set `m88k::FloatABI::Hard`
    when `-mhard-float` is specified to clang. Finally, if none of these options are
    specified, we choose the default on the current platform, which would be a hard
    floating-point value for M88k:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll add the implementation for `getM88kTargetFeatures()` next. The important
    part of this function is the vector of `Features` that are passed as a parameter.
    As we can see, the only target features that are handled are the floating-point
    ABI. From the driver and arguments passed to it, we’ll get the appropriate floating-point
    ABI from what we implemented in the previous step. Note that we add the `-hard-float`
    target features to the `Features` vector for soft float ABI as well, which means
    that currently, M88k only supports hard float:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Building the M88k target with clang integration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’re almost done with the implementation for integrating M88k into clang.
    The last step is to add the new clang files that we have added into their corresponding
    `CMakeLists.txt` file, which allows us to build the clang project with our M88k
    target implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: First, add the `Targets/M88k.cpp` line to `clang/lib/Basic/CMakeLists.txt`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, add `Targets/M88k.cpp` to `clang/lib/CodeGen/CMakeLists.txt`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, add `ToolChains/Arch/M88k.cpp` to `clang/lib/Driver/CMakeLists.txt`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There we have it! That concludes our toolchain implementation for the toolchain
    support for the M88k target, which subsequently means we’ve completed the integration
    into clang for M88k!
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step we need to do is build clang with the M88k target. The following
    commands will build the clang and LLVM project. For clang, be aware of the M88k
    target. Here, the `-DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD=M88k` CMake option must
    be added, as in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'We should now have a version of clang that recognizes the M88k target! We can
    confirm this by checking the list of targets that clang supports, through the
    `–``print-targets` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we delved into the technical details of integrating a new backend
    target into clang and having it recognized. In the next section, we’ll explore
    the concept of cross-compiling, where we detail the procedure of targeting a different
    CPU architecture from the current host.
  prefs: []
  type: TYPE_NORMAL
- en: Targeting a different CPU architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Today, many small computers, such as the Raspberry Pi, are in use despite having
    only limited resources. Running a compiler on such a computer is often not possible
    or it takes too much time. Thus, a common requirement for a compiler is to generate
    code for a different CPU architecture. The whole process of having a host compile
    an executable for a different target is called cross-compiling.
  prefs: []
  type: TYPE_NORMAL
- en: 'In cross-compiling, two systems are involved: the host system and the target
    system. The compiler runs on the host system and produces code for the target
    system. To denote the systems, the so-called triple is used. This is a configuration
    string that usually consists of the CPU architecture, the vendor, and the operating
    system. Furthermore, additional information about the environment is often added
    to the configuration string. For example, the `x86_64-pc-win32` triple is used
    for a Windows system running on a 64-bit X86 CPU. The CPU architecture is `x86_64`,
    `pc` is a generic vendor, and `win32` is the operating system, and all of these
    pieces are connected by a hyphen. A Linux system running on an ARMv8 CPU uses
    `aarch64-unknown-linux-gnu` as the triple, with `aarch64` as the CPU architecture.
    Moreover, the operating system is `linux`, running a `gnu` environment. There
    is no real vendor for a Linux-based system, so this part is `unknown`. Additionally,
    parts that are not known or unimportant for a specific purpose are often omitted:
    the `aarch64-linux-gnu` triple describes the same Linux system.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume your development machine runs Linux on an X86 64-bit CPU and you
    want to cross-compile to an ARMv8 CPU system running Linux. The host triple is
    `x86_64-linux-gnu` and the target triple is `aarch64-linux-gnu`. Different systems
    have different characteristics. Thus, your application must be written in a portable
    fashion; otherwise, complications may arise. Some common pitfalls are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Endianness**: The order in which multi-byte values are stored in memory can
    be different.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int` type may not be large enough to hold a pointer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`long double` type can use 64-bit (ARM), 80-bit (X86), or 128-bit (ARMv8).
    PowerPC systems may use double-double arithmetic for `long double`, which gives
    more precision by using a combination of two 64-bit `double` values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you do not pay attention to these points, then your application can act surprisingly
    or crash on the target platform, even if it runs perfectly on your host system.
    The LLVM libraries are tested on different platforms and also contain portable
    solutions to the aforementioned issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'For cross-compiling, the following tools are required:'
  prefs: []
  type: TYPE_NORMAL
- en: A compiler that generates code for the target
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A linker capable of generating binaries for the target
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Header files and libraries for the target
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Fortunately, the Ubuntu and Debian distributions have packages that support
    cross-compiling. We’re taking advantage of this in the following setup. The `gcc`
    and `g++` compilers, the linker, `ld`, and the libraries are available as precompiled
    binaries that produce ARMv8 code and executables. The following command installs
    all of these packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The new files are installed under the `/usr/aarch64-linux-gnu` directory. This
    directory is the (logical) root directory of the target system. It contains the
    usual `bin`, `lib`, and `include` directories. The cross-compilers (`aarch64-linux-gnu-gcc-8`
    and `aarch64-linux-gnu-g++-8`) are aware of this directory.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-compiling on other systems
  prefs: []
  type: TYPE_NORMAL
- en: Some distributions, such as Fedora, only provide cross-compiling support for
    bare-metal targets such as the Linux kernel, but the header and library files
    needed for user land applications are not provided. In such a case, you can simply
    copy the missing files from your target system.
  prefs: []
  type: TYPE_NORMAL
- en: If your distribution does not come with the required toolchain, then you can
    build it from source. For the compiler, you can use clang or gcc/g++. The gcc
    and g++ compilers must be configured to produce code for the target system and
    the binutils tools need to handle files for the target system. Moreover, the C
    and C++ libraries need to be compiled with this toolchain. The steps vary by operating
    system and host and target architecture. On the web, you can find instructions
    if you search for `gcc` `cross-compile <architecture>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this preparation, you are almost ready to cross-compile the sample application
    (including the LLVM libraries) except for one little detail. LLVM uses the `llvm-tblgen`
    from the build in [*Chapter 1*](B19561_01.xhtml#_idTextAnchor017) or you can compile
    only this tool. Assuming you are in the directory that contains the clone of this
    book’s GitHub repository, type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: These steps should be familiar by now. A build directory is created and entered.
    The `cmake` command creates the build files for LLVM only for the X86 target.
    To save space and time, a release build is done but assertions are enabled to
    catch possible errors. Only the `llvm-tblgen` tool is compiled with `ninja`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `llvm-tblgen` tool at hand, you can now start the cross-compilation
    process. The CMake command line is very long, so you may want to store the command
    in a script file. The difference from previous builds is that more information
    must be provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, you create a build directory and enter it before running the CMake command.
    Some of these CMake parameters have not been used before and require some explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CMAKE_CROSSCOMPILING` set to `ON` tells CMake that we are cross-compiling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LLVM_TABLEGEN` specifies the path to the `llvm-tblgen` tool to use. This is
    the one from the previous build.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LLVM_DEFAULT_TARGET_TRIPLE` is the triple of the target architecture.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LLVM_TARGET_ARCH` is used for **JIT** code generation. It defaults to the
    architecture of the host. For cross-compiling, this must be set to the target
    architecture.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LLVM_TARGETS_TO_BUILD` is the list of targets for which LLVM should include
    code generators. The list should at least include the target architecture.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMAKE_C_COMPILER` and `CMAKE_CXX_COMPILER` specify the C and C++ compilers
    used for the build, respectively. The binaries of the cross-compilers are prefixed
    with the target triple and are not found automatically by CMake.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the other parameters, a release build with assertions enabled is requested
    and our tinylang application is built as part of LLVM. Once the compilation process
    has finished, the `file` command can demonstrate that we have created a binary
    for ARMv8\. Specifically, we can run `$ file bin/tinylang` and check that the
    output says `ELF 64-bit object for the ARM` `aarch64 architecture`.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-compiling with clang
  prefs: []
  type: TYPE_NORMAL
- en: 'As LLVM generates code for different architectures, it seems obvious to use
    clang to cross-compile. The obstacle here is that LLVM does not provide all the
    required parts – for example, the C library is missing. Because of this, you must
    use a mix of LLVM and GNU tools and as a result, you need to tell CMake even more
    about the environment you are using. As a minimum, you need to specify the following
    options for clang and clang++: `--target=<target-triple>` (enables code generation
    for a different target), `--sysroot=<path>` (path to the root directory for the
    target), `I` (search path for header files), and `–L` (search path for libraries).
    During the CMake run, a small application is compiled and CMake complains if something
    is wrong with your setup. This step is sufficient to check if you have a working
    environment. Common problems are picking the wrong header files or link failures
    due to different library names or wrong search paths.'
  prefs: []
  type: TYPE_NORMAL
- en: Cross-compiling is surprisingly complex. With the instructions from this section,
    you will be able to cross-compile your application for a target architecture of
    your choice.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about creating passes that run beyond instruction
    selection, specifically exploring the creation behind machine function passes
    in the backend! You also discovered how to add a new experimental target into
    clang, and some of the driver, ABI, and toolchain changes that are required. Finally,
    while considering the supreme discipline of compiler construction, you learned
    how to cross-compile your application for another target architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’re at the end of *Learn LLVM 17*, you are equipped with the knowledge
    to use LLVM in creative ways in your projects and have explored many interesting
    topics. The LLVM ecosystem is very active, and new features are added all the
    time, so be sure to follow its development!
  prefs: []
  type: TYPE_NORMAL
- en: As compiler developers ourselves, it was a pleasure for us to write about LLVM
    and discover some new features along the way. Have fun with LLVM!
  prefs: []
  type: TYPE_NORMAL
