- en: Object-Oriented Software Engineering Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象软件工程模式
- en: 'Object-oriented (OO) concepts in software engineering are not new, and let''s
    start this chapter with a brief introduction before we dive into OO design patterns.
    While you are reading this chapter, look around you; whatever you see is an object:
    the book, bookshelves, reading lamp, table, chair, and so on. Everything around
    you can be imagined as an object, and all of them share two primary characteristics,
    as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 软件工程中的面向对象（OO）概念并不新鲜，在我们深入探讨面向对象设计模式之前，让我们先简要介绍面向对象的概念。当你阅读本章时，环顾四周；你所看到的一切都是对象：书籍、书架、阅读灯、桌子、椅子等等。你周围的一切都可以想象成对象，它们都具备两个主要特征，如下：
- en: State
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态
- en: Behavior
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为
- en: A reading lamp has *off and on* as states, and *turn on and turn off* as behaviors.
    Objects may also have many states and many behaviors, sometimes even other objects
    as well.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读灯有“关闭”和“开启”两种状态，以及“开启”和“关闭”两种行为。对象也可能有多个状态和多个行为，有时甚至还有其他对象。
- en: '**Object-oriented design** (**OOD**) intends to provide modularity, abstraction
    (information hiding), code reuse, and pluggable (plug and play) and easy code
    debug.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向对象设计**（**OOD**）旨在提供模块化、抽象（信息隐藏）、代码重用以及可插拔（即插即用）和易于代码调试。'
- en: 'Grady Booch defined OOD in his book titled *Object Oriented Analysis and Design
    with Application* as follows:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Grady Booch 在其名为《面向对象分析与设计与应用》的书中定义了 OOD，如下所述：
- en: '"OOD is a method of design encompassing the process of object-oriented decomposition
    and a notation for depicting both logical and physical as well as static and dynamic
    models of the system under design."'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '"OOD 是一种设计方法，包括面向对象分解的过程，以及用于表示正在设计中的系统的逻辑、物理以及静态和动态模型的符号。"'
- en: 'This chapter covers the following elements of OOD:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下 OOD 的要素：
- en: Essential and non-essential elements of OOD
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OOD 的基本和非基本要素
- en: Primary characteristics of OOD
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OOD 的主要特性
- en: Core principles of OOD
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OOD 的核心原则
- en: Most common design patterns of OOD
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OOD 最常见的设计模式
- en: Cross-reference of OO design patterns
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象设计模式的交叉引用
- en: Key elements of OOD
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OOD 的关键要素
- en: 'There are four key elements of OOD. They are as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: OOD 有四个关键要素。具体如下：
- en: '**Abstraction**: Hiding the complexity and low-level implementation details
    of internals.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象**：隐藏内部复杂性和低级实现细节。'
- en: For instance, you see electrical switch buttons that can toggle on and off,
    but how it is achieving on and off is not shown to outside world, and in fact,
    it is not necessary for the common users.
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，你看到可以切换开启和关闭的电气开关按钮，但它如何实现开启和关闭并未向外界展示，实际上，对于普通用户来说，这并不必要。
- en: '**Encapsulation**: Bundling of the data with the methods that operate on that
    data, preventing accidental or unauthorized access to the data.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**封装**：将数据与其操作方法捆绑在一起，防止数据被意外或未经授权访问。'
- en: For example, switching off function should turn only the targeted element off,
    say a reading lamp, and it should not affect any other electrical functions that
    are part of the same electrical system.
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，关闭功能应仅关闭目标元素，例如阅读灯，而不应影响同一电气系统中的其他任何电气功能。
- en: '**Modularization**: The process of decomposing and making it as modules to
    reduce the complexity of the overall program/function.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块化**：将程序/函数分解成模块的过程，以降低整体复杂度。'
- en: For example, switch off and on is a common functionality of an electrical system.
    Switching a reading lamp on and off may be a separate module and decoupled from
    other complex functions such as switching off washing machine and AC.
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，开关开启和关闭是电气系统的常见功能。开关阅读灯的开启和关闭可能是一个独立的模块，并且与关闭洗衣机和空调等其他复杂功能解耦。
- en: '**Hierarchy**: It is ordering of abstraction and hierarchy of an interrelated
    system with other subsystems. Those subsystems might own other subsystems as well,
    so hierarchy helps reach the smallest possible level of components in a given
    system.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**层次结构**：抽象的排序和与子系统相关联的系统的层次结构。这些子系统可能还拥有其他子系统，因此层次结构有助于达到给定系统中组件的最小可能级别。'
- en: Additional elements of OOD
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OOD 的其他要素
- en: 'There are three additional elements of OOD. They are as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: OOD 有三个其他要素。具体如下：
- en: '**Typing**: Characterization of a set of items. A Class (in object-oriented
    programming) is a distinct type. It has two subtypes. They are as follows:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型**：一组项目的特征。在面向对象编程中，类是一个独特的类型。它有两个子类型。具体如下：'
- en: Strong Typing
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强类型
- en: Weak Typing
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弱类型
- en: '**Concurrency**: Operating system allows Performing multiple tasks or process
    simultaneously.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发性**: 操作系统允许同时执行多个任务或进程。'
- en: '**Persistence**: Class or object occupies space and exists for a particular
    time.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**坚持**: 类或对象占据空间并在特定时间内存在。'
- en: Design principles
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计原则
- en: This chapter and the following sections cover object-oriented design principles,
    its characteristics, and the design patterns in detail. Each pattern section covers
    its need, design considerations, and best practices so that readers get the idea
    of patterns and its applications.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 本章和以下各节详细介绍了面向对象设计原则、其特征以及设计模式。每个模式部分都涵盖了其需求、设计考虑因素和最佳实践，以便读者了解模式及其应用。
- en: Let's start with a core principle usually referred to as an acronym "SOLID,"
    in detail.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从通常被称为缩写“SOLID”的核心原则开始详细说明。
- en: Single responsibility principle (SRP) – SOLID
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单一职责原则（SRP）- SOLID
- en: In object-oriented programming style, the *single responsibility* enforces that
    each class should represent one and only one responsibility and so if it needs
    to undergo changes, that should be for only one reason, that is, a class should
    have one and only one reason to change.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象的编程风格中，*单一职责*强制每个类应代表一个且仅代表一个职责，因此如果它需要更改，那应该是只有一个原因，即一个类应该只有一个且仅有一个更改的原因。
- en: When we design a class or refactor a class and if it needs more than one reason
    to change, split the functionality into as many parts as there are classes and
    so, each class represents only one responsibility.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们设计一个类或重构一个类，并且如果它需要多个原因来更改，那么将功能拆分为与类数量一样多的部分，因此每个类只代表一个职责。
- en: 'Responsibility in this context is any changes to the function/business rules
    that causes the class to change; any changes to the connected database schema,
    user interfaces, report format, or any other system should not force that class
    also to change:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，职责是对功能/业务规则的任何更改，这会导致类发生变化；对连接的数据库模式、用户界面、报告格式或任何其他系统的任何更改都不应迫使该类也发生变化：
- en: '![](img/a2e91c5f-a337-4475-af95-9423ab1932cc.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a2e91c5f-a337-4475-af95-9423ab1932cc.png)'
- en: 'The preceding class diagram depicts a **Person** class having two responsibilities:
    one responsibility is to greet the user with their last name or surname, and another
    responsibility is to validate the email. If we need to apply SRP on the **Person**
    class, we can separate it into two; **Person** has a method greet, and **Email**
    has email validation.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 上述类图描述了一个**Person**类有两个职责：一个职责是用用户的姓氏或姓问候用户，另一个职责是验证电子邮件。如果我们需要在**Person**类上应用SRP，我们可以将其分为两个；**Person**有一个问候方法，而**Email**有电子邮件验证。
- en: The SRP applies not only at the class level, but also on methods, packages,
    and the modules.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: SRP不仅适用于类级别，也适用于方法、包和模块。
- en: Open and close principle – SOLID
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开放和封闭原则 – SOLID
- en: The open and close principle of OO programming suggests that the OO software
    entities such as classes, methods or functions, and modules, should be open for
    extensions, but closed for any modifications.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程的开放和封闭原则建议，面向对象的软件实体，如类、方法或函数以及模块，应该对扩展是开放的，但对任何修改是封闭的。
- en: Imagine a class that you never need to change, and any new functionality gets
    added only by adding new methods or subclasses, or by reusing the existing code,
    and so we can prevent any new defects to the existing code or functionality.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个你永远不会更改的类，并且任何新功能都只能通过添加新方法或子类，或者通过重用现有代码来添加，因此我们可以防止对现有代码或功能引入任何新缺陷。
- en: '![](img/07114d55-b27f-400d-8902-18a99699cc7d.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/07114d55-b27f-400d-8902-18a99699cc7d.png)'
- en: The preceding class diagram shows the application of the open and close principle
    on the **Account** class and its subclasses. The account can be any type, savings
    or current. A **SavingsAccount** may categorize as **GeneralAccount**, **KidsAccount**,
    and so on, so we can enforce that Account and other subclasses are available for
    Enhancements but closed for modifications.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 上述类图展示了在**Account**类及其子类上应用开放和封闭原则。账户可以是任何类型，如储蓄或活期。**SavingsAccount**可能被分类为**GeneralAccount**、**KidsAccount**等，因此我们可以强制Account和其他子类对增强是可用的，但对修改是封闭的。
- en: The open and close principle brings benefits of no changes to the code, no introduction
    of any new defects but perhaps a disadvantage that the existing defects never
    get addressed as well.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 开放和封闭原则带来了代码无需更改、不引入任何新缺陷的好处，但可能存在一个缺点，即现有的缺陷从未得到解决。
- en: Liskov substitution principle (LSP) – SOLID
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 李斯克替换原则（LSP）- SOLID
- en: This principle states that any of the child classes should not break the parent
    class's type definitions or, in other words, derived classes should be substitutable
    for their base classes.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则指出，任何子类都不应该破坏父类的类型定义，换句话说，派生类应该可以替代其基类。
- en: 'Let''s first understand the violation of substitution principle, and then we
    see how we can resolve the same by taking our earlier example of account classes
    as LSP is a prime enabler of OCP:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们了解替代性原则的违反，然后我们看看如何通过使用我们之前关于账户类作为LSP是OCP主要启用者的例子来解决这个问题：
- en: '![](img/f201284f-16ac-4eb5-9417-efae901abc89.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f201284f-16ac-4eb5-9417-efae901abc89.png)'
- en: 'Let''s assume that withdrawal from kids account is not allowed, unlike general
    account. As you see in the preceding class diagram, a *withdraw* method in the
    kids account class is a breach of LSP, so by introducing other withdrawable and
    non-withdrawable classes inherited from **SavingsAccount** class to handle non-withdrawable
    behavior, we can get rid of the breach and the subclass does not change the base
    class behavior:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 假设从儿童账户的提款是不允许的，与普通账户不同。正如你在前面的类图中看到的，儿童账户类中的*withdraw*方法违反了LSP，因此通过引入从**SavingsAccount**类继承的其它可提款和非提款类来处理不可提款行为，我们可以消除这种违反，并且子类不会改变基类的行为：
- en: '![](img/fe87bbb2-9dd8-4bcd-813b-be4e1e66cb87.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fe87bbb2-9dd8-4bcd-813b-be4e1e66cb87.png)'
- en: So, the behavior of **SavingsAccount** is preserved while inheriting it for
    **KidsAccount**. The preceding code snippet proves the same.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，**SavingsAccount**的行为在继承给**KidsAccount**时被保留。前面的代码片段证明了这一点。
- en: Interface segregation principle (ISP) – SOLID
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口分离原则（ISP）- SOLID
- en: Imagine that you are implementing an interface of a class pets, and the compiler
    complains about the non-inclusion of bark method in your **Cat** class; strange,
    isn't it?
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你正在实现一个名为pets的类的接口，编译器抱怨你的**Cat**类中没有包含bark方法；这很奇怪，不是吗？
- en: 'ISP suggests a*ny interface of a class should not force the clients to include
    any unrequired methods by that client*; in our example, **Cat** does not need
    to implement bark method, and it is exclusive to **Dog** class:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ISP建议“任何类的接口都不应该强迫客户端包含任何对该客户端来说不必要的方 法”；在我们的例子中，**Cat**不需要实现bark方法，这是**Dog**类的专属：
- en: '![](img/1e387677-582b-4bbc-9178-5c645a43eba0.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1e387677-582b-4bbc-9178-5c645a43eba0.png)'
- en: The preceding diagram depicts ISP violation and how to get rid of the same by
    splitting the **<<IPets>>** interface to represent the **Cat** and **Dog** interface
    explicitly.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图描述了ISP的违反以及如何通过将**<<IPets>>**接口拆分来表示**Cat**和**Dog**接口来消除这种违反。
- en: Dependency inversion principle (DIP) – SOLID
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖倒置原则（DIP）- SOLID
- en: 'The DIP enforces two points, as listed:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: DIP强制执行以下两点：
- en: Any higher-level modules should not depend on lower-level modules, and both
    should depend on abstract modules
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何高级模块都不应该依赖于低级模块，而两者都应该依赖于抽象模块
- en: Abstraction of modules should not depend on its implementation or details, but
    the implementation should depend on abstraction
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块的抽象不应依赖于其实施或细节，而实现应依赖于抽象
- en: Please refer to the earlier *Interface segregation principle (ISP) – SOLID*
    section, and the example classes (Figure 3.5) Pets classes and its abstract classes.
    **Dog** and **Cat** depend on abstractions (interface), and any changes to any
    of the underlying implementation do not impact any other implementations.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考前面的*接口分离原则（ISP）- SOLID*部分，以及示例类（图3.5）Pets类及其抽象类。**Dog**和**Cat**依赖于抽象（接口），并且任何对底层实现的任何更改都不会影响其他实现。
- en: Other common design principles
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他常见设计原则
- en: 'Other common principles are as follows; however, detailing of each principle
    is not in the scope of this chapter, and we request you to refer to other materials
    if you need to read more information about those principles:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 其他常见原则如下；然而，每个原则的详细内容不在本章的范围内，如果您需要了解更多关于这些原则的信息，请参考其他材料：
- en: Encapsulate
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装
- en: Always encapsulate the code that you think may change sooner or later
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是封装你认为迟早会改变代码
- en: Composition over inheritance
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合优于继承
- en: In some cases, you may need the class behavior to change during runtime, and
    those cases favor composition over inheritance
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某些情况下，您可能需要在运行时更改类行为，并且这些情况更倾向于组合而不是继承
- en: Program for interface (not for the implementation)
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为接口编程（而不是实现）
- en: Bring flexibility to the code and can work with any new implementation
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为代码带来灵活性，并且可以与任何新的实现一起工作
- en: '**General responsibility assignment software patterns** (**GRASP**)'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一般责任分配软件模式**（**GRASP**）'
- en: Guides in assigning responsibilities to collaborate objects
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指导如何分配协作对象的责任
- en: '**Don''t repeat yourself** (**DRY**)'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要重复自己**（**DRY**）'
- en: Avoid duplicate codes by proper abstraction of the common codes into one place
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过适当抽象公共代码到一处来避免代码重复
- en: '**Single layer abstraction principle** (**SLAP**)'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单一层抽象原则**（**SLAP**）'
- en: Every line in a method should be on the same level of abstraction
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法中的每一行都应该处于相同的抽象级别
- en: OO design patterns
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象设计模式
- en: 'Object-oriented design patterns solve many common software design problems,
    as follows, that architects come across every day:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象设计模式解决了许多常见的软件设计问题，如下所述，建筑师每天都会遇到：
- en: Finding appropriate objects
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找合适的对象
- en: Determining object granularity
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定对象粒度
- en: Specifying object interfaces
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定对象接口
- en: Specifying object implementations
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定对象实现
- en: Programming to an interface, not an implementation
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向接口编程，而非面向实现
- en: Putting the reuse mechanism to work
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用重用机制
- en: We will touch upon some of the common problems and how design patterns solve
    the mentioned glitches in this section and cover OO design patterns in detail.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论一些常见问题以及设计模式如何解决这些问题，并详细介绍面向对象设计模式。
- en: 'We can categorize the patterns into three types: creational, structural, and
    behavioral. Refer to the table at the end of this chapter, which depicts the patterns
    and its categories as a simple reference before we move ahead with the details.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将模式分为三种类型：创建型、结构型和行为型。在我们继续详细讨论之前，请参考本章末尾的表格，该表格以简单参考的形式描述了模式和其类别。
- en: Creational design patterns
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建型设计模式
- en: 'The creational patterns intend to advocate a better way of creating objects
    or classes, and its primary focuses are as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 创建型模式旨在提倡一种更好的创建对象或类的方法，其重点如下：
- en: Abstracting the class instantiation process
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象类实例化过程
- en: Defining ways to create, compose, and represent objects and hide the implementation
    details from the involving system
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义创建、组合和表示对象的方式，并从涉及系统中隐藏实现细节
- en: Emphasizing avoiding hard code of a fixed set of behaviors and defining a smaller
    set of core behaviors instead, which can compose into any number of (complex)
    sets
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强调避免硬编码一组固定的行为，而是定义一组较小的核心行为，这些行为可以组合成任意数量的（复杂）集合
- en: 'Creational design patterns have two basic characteristics: one is that they
    encapsulate knowledge about which concrete class the system use, and the second
    is that they hide how the instances of these classes are created and put together.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 创建型设计模式有两个基本特征：一是它们封装了关于系统使用哪个具体类的知识，二是它们隐藏了这些类的实例是如何创建和组合的。
- en: The class creational pattern uses inheritance for instantiation, whereas object
    creations delegates it to another object.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 类创建型模式使用继承进行实例化，而对象创建则委托给另一个对象。
- en: The following section deals with each pattern, its general structure, and sample
    implementation diagram in most of the cases.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将处理每个模式，其一般结构和在大多数情况下的示例实现图。
- en: Factory method (virtual constructor)
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂方法（虚拟构造函数）
- en: 'This pattern suggests to let the subclasses instantiate the needed classes.
    The factory method defines an interface, but the instantiation is done by subclasses:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式建议让子类实例化所需的类。工厂方法定义了一个接口，但实例化是由子类完成的：
- en: '![](img/fd0f457d-4c77-4a7d-9ac6-91e5b13a0492.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fd0f457d-4c77-4a7d-9ac6-91e5b13a0492.png)'
- en: The preceding structure depicts a factory method, and an application uses a
    factory to create subtypes with an interface.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 上述结构描述了一个工厂方法，应用程序使用工厂来创建具有接口的子类型。
- en: 'The benefits of using this are as listed:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此方法的优点如下所示：
- en: '**Loose coupling**: Separates application from the classes and subclasses'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**松耦合**：将应用程序与类及其子类分离'
- en: '**Customization hooks**: The factory method gives subclasses a hook for providing
    an extended version of an object'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定制钩子**：工厂方法为子类提供了一个提供对象扩展版本的钩子'
- en: The impact of using this is that it creates parallel class hierarchies (mirroring
    each other's structures), so we need to structure in the best possible ways using
    intelligent children pattern or Defer identification of state variables pattern.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法的副作用是它创建了并行类层次结构（相互镜像结构），因此我们需要使用智能子模式或延迟识别状态变量模式以最佳方式来结构化。
- en: Abstract factory (kit)
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象工厂（套件）
- en: 'Abstract factory pattern is intended to provide an interface if we want to
    create families of related or dependent objects, but without explicitly specifying
    their concrete classes:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂模式旨在提供接口，如果我们想创建相关或依赖对象的家庭，但又不明确指定它们的具体类：
- en: '![](img/29f30562-ce33-4a4f-9fe7-b923af2335ee.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/29f30562-ce33-4a4f-9fe7-b923af2335ee.png)'
- en: The preceding class diagram depicts the **AbstractFactory** class structure
    and a real-time implementation of an abstract factory pattern for an application
    that combines a different set of (heterogeneous) products from two different groups
    (**<<Bank>>** and **<<Loan>>**).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 上述类图展示了**抽象工厂**类结构和为结合来自两个不同组（**<<Bank>>**和**<<Loan>>**）的不同集合（异构）产品而实现的应用程序的抽象工厂模式实时实现。
- en: 'The benefits of this are the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 其好处如下：
- en: Isolating concrete classes
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隔离具体类
- en: Making exchanging product families easy
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使交换产品族变得容易
- en: Promoting consistency among products
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 促进产品之间的一致性
- en: Impact is such as; supporting new kinds of the product is difficult.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 影响如下；支持新产品类型是困难的。
- en: Builder
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建造者
- en: 'The builder is intended to separate the construction of a complex object from
    its representation so that the same construction process can create different
    representations. In other words, use this pattern to simplify the construction
    of complex object with simple objects in a step-by-step manner:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 建造者旨在将复杂对象的构建与其表示分离，以便相同的构建过程可以创建不同的表示。换句话说，使用此模式以逐步方式通过简单对象简化复杂对象的构建：
- en: '![](img/43004272-349a-4b1f-9534-d32c97b09ab8.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/43004272-349a-4b1f-9534-d32c97b09ab8.png)'
- en: The class diagram depicts a typical builder pattern structure and a sample implementation
    classes for the **Builder** pattern. The **Builder** (**TextConverter**) is an
    abstract Interface that creates parts of a product page. The **Concrete Builder**
    (**AsciiConv**, **TexConv**) constructs and assembles parts by interface implementation,
    the **Director** (**Reader**) constructs an object with the builder interface,
    and the **Products** (**AsciiTxt**, **Text**) are under construction complex objects.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 类图展示了典型的建造者模式结构和**建造者**模式的示例实现类。**建造者**（**TextConverter**）是一个抽象接口，用于创建产品页面的部分。**具体建造者**（**AsciiConv**，**TexConv**）通过接口实现构建和组装部分，**导演**（**Reader**）通过建造者接口构建对象，而**产品**（**AsciiTxt**，**Text**）是正在构建的复杂对象。
- en: 'The benefits are as listed:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 好处如下：
- en: Allows changing the internal representation and defines new kind of builder
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许更改内部表示并定义新的建造者类型
- en: Isolates code for construction and representation
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隔离构建和表示的代码
- en: Provides finer control over the construction process
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供对构建过程的更精细控制
- en: 'Impacts are as listed:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 影响如下：
- en: Leads to creating a separate concrete builder for each type of product
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导致为每种产品类型创建一个单独的具体建造者
- en: Leads to mutable **Builder** classes
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导致可变的**建造者**类
- en: Prototype
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原型
- en: 'Prototype pattern suggests copying or cloning the existing object and customizing
    it if needed rather than creating a new object. Choose this pattern when a system
    should be independent of its products creation, compose, and representation:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 原型模式建议复制或克隆现有对象，并在需要时对其进行定制，而不是创建新对象。当系统应独立于其产品的创建、组合和表示时，选择此模式：
- en: '![](img/3a70ee05-e5c0-4624-8ff7-eacbc650719a.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3a70ee05-e5c0-4624-8ff7-eacbc650719a.png)'
- en: We can create a copy of **PublicProfile** (limited information) or **FullProfile**
    at runtime. Those two classes share a few combination of states, so it is good
    that we design as a prototype.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在运行时创建**PublicProfile**（有限信息）或**FullProfile**的副本。这两个类共享一些状态组合，因此将其设计为原型是很好的。
- en: 'Let''s take a look at its benefits:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它的好处：
- en: Adding and removing products at runtime
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时添加和删除产品
- en: Specifying new objects by varying values and structures
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过改变值和结构来指定新对象
- en: Reduced subclasses
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少子类数量
- en: Dynamic class configuration to an application
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态类配置到应用程序中
- en: The impact is, each subclass must implement clone operation, and it is not possible
    to clone circular reference classes.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 影响是，每个子类都必须实现克隆操作，并且无法克隆循环引用类。
- en: Singleton
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例
- en: 'This pattern suggests that you create one and only one instance and provide
    a global point of access to the created object:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式建议创建一个实例，并提供对创建对象的全球访问点：
- en: '![](img/c118a358-bda8-4199-8e9f-355eab6c9257.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c118a358-bda8-4199-8e9f-355eab6c9257.png)'
- en: The DB connection in the preceding diagram is intended to be a singleton and
    provides a getter for its only object.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图中数据库连接旨在作为单例，并为它的唯一对象提供一个获取器。
- en: 'Here are its benefits:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是其优点：
- en: Controlled access to a sole instance
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制对唯一实例的访问
- en: Reduced namespace
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少命名空间
- en: Flexibility to refinement of operations and representations
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作和表示的细化灵活性
- en: More flexible than class operations
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比类操作更灵活
- en: 'Impacts are as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 影响如下：
- en: Carry states for the whole lifetime of the application, creating additional
    overhead for unit tests
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在整个应用程序生命周期中携带状态，为单元测试创建额外的开销
- en: Some level of violation of single responsibility principle
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一定程度违反单一职责原则
- en: By using singleton as a global instance, it hides the dependencies of the application;
    rather, it should get exposed through interfaces
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用单例作为全局实例，它隐藏了应用程序的依赖关系；相反，它应该通过接口来暴露
- en: Structural design patterns
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构设计模式
- en: The structural patterns provide guidelines to compose classes and objects to
    form a larger structure in accordance with the OO design principles.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 结构模式提供了根据面向对象设计原则组合类和对象以形成更大结构的指导方针。
- en: The structural class pattern uses inheritance to compose interfaces or implementations,
    and structural object patterns advocate ways to compose objects and realize the
    new functionality.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 结构类模式使用继承来组合接口或实现，而结构对象模式提倡组合对象和实现新功能的方法。
- en: 'Some focus areas of Structural design pattern are as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 结构设计模式的一些关注领域如下：
- en: Providing a uniform abstraction of different interfaces (Adapter)
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供不同接口的统一抽象（适配器）
- en: Changing the composition at runtime and providing flexibility of object composition;
    otherwise, it is impossible with static class composition
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时更改组合并提供对象组合的灵活性；否则，使用静态类组合是不可能的
- en: Ensuring efficiency and consistency by sharing objects
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过共享对象确保效率和一致性
- en: Adding object responsibility dynamically
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态添加对象责任
- en: The following section describes each structural pattern with standard structure
    and sample implementation structure as a diagram as well.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分将描述每个结构模式，以及标准结构和示例实现结构图。
- en: Adapter class (wrapper)
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适配器类（包装器）
- en: 'Convert one interface of a class into another interface that the client wanted.
    In other words, the adapter makes heterogeneous classes work together:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个类的接口转换为客户端想要的另一个接口。换句话说，适配器使异构类能够协同工作：
- en: '![](img/2e5a4a22-ab05-4375-a8e4-82815b93cc4c.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2e5a4a22-ab05-4375-a8e4-82815b93cc4c.png)'
- en: The preceding class diagram depicts an adapter called **OnlineLinkedAccounts**
    that adopts a savings account's details and a target interface called **credit
    card details**, and combine the results to show both account numbers.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的类图描绘了一个名为**OnlineLinkedAccounts**的适配器，它采用储蓄账户的详细信息和一个目标接口**信用卡详情**，并将结果组合起来显示两个账户号码。
- en: Adapter (object)
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适配器（对象）
- en: 'An adapter object relies on object composition, and when we need to use several
    of the existing subclasses, we can use object adapter to adapt the interface of
    the parent class:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器对象依赖于对象组合，当我们需要使用几个现有的子类时，我们可以使用对象适配器来适配父类的接口：
- en: '![](img/8ab6bdc9-06c6-4546-bb31-8b76d6df9311.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8ab6bdc9-06c6-4546-bb31-8b76d6df9311.png)'
- en: The preceding diagram depicts the formal structure of an **Adapter**.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图描绘了**适配器**的正式结构。
- en: 'These are the benefits:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是优点：
- en: Saves time during development and testing by emulating a similar behavior of
    different parts of the application
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过模拟应用程序不同部分的行为，在开发和测试期间节省时间
- en: Provides easy extensions for new features with similar behaviors
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为具有相似行为的新功能提供易于扩展
- en: Allows a single adapter works with many adaptees (adapter object)
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许单个适配器与多个适配者一起工作（适配器对象）
- en: 'Impacts are as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 影响如下：
- en: Leads to needlessly duplicated codes between classes (less usage of inherited
    classes' functionalities)
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导致类之间不必要的代码重复（较少使用继承类功能）
- en: May lead to nested adaptions to reach for intended types that are in longer
    chains
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能会导致嵌套适配以到达更长的链中的目标类型
- en: Make it more difficult to override adaptee behavior (adapter object)
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使覆盖适配者行为更困难（适配器对象）
- en: Bridge (handle/body)
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 桥接（处理/主体）
- en: 'Bridge pattern intent is to decouple the abstraction from its implementation,
    so abstraction and implementation are independent (not bound at compile time,
    so no impact to the client):'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 桥接模式的目标是将抽象与其实现解耦，因此抽象和实现是独立的（不是在编译时绑定，因此不会影响客户端）：
- en: '![](img/aeca4612-f975-405e-8cb3-be0abefe969d.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/aeca4612-f975-405e-8cb3-be0abefe969d.png)'
- en: 'The benefits are as mentioned:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 好处如上所述：
- en: Decoupling interfaces from the implementation
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将接口与实现解耦
- en: Configuring the implementation of an abstraction at runtime
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时配置抽象的实现
- en: Elimination of compile-time dependency
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消除了编译时依赖
- en: Improved extensibility
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进了可扩展性
- en: Hiding implementation details from the client
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从客户端隐藏实现细节
- en: The impact is, introducing some level of complexity.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 影响是，引入了一定程度的复杂性。
- en: Composite
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合
- en: '**Composite** objects let clients treat individual objects and composition
    of objects uniformly. **Composite** represents the hierarchies of objects as tree
    structures.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**组合**对象让客户端可以统一地对待单个对象和对象的组合。**组合**将对象层次表示为树结构。'
- en: '![](img/5d9d53e9-be35-4e61-aa8d-f110afc41b83.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5d9d53e9-be35-4e61-aa8d-f110afc41b83.png)'
- en: The preceding diagram depicts the standard structure of the **Composite** pattern
    and an implementation of a part-whole hierarchy (employee part of agent, **Accountant**,
    and teller), and to the **Client,** all objects are **Composite** and structured
    uniformly.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图示描述了**组合**模式的标准结构和部分-整体层次结构的实现（代理的员工部分、**会计**和出纳员），以及对于**客户端**，所有对象都是**组合**的，并且结构统一。
- en: 'These are the benefits:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是好处：
- en: It simplifies the client code by hiding the complex communications (leaf or
    composite component)
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过隐藏复杂的通信（叶或组合组件）简化了客户端代码
- en: It is easier to add new components, and client does not need a change when new
    components get added
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加新组件更容易，并且当添加新组件时，客户端不需要更改
- en: The impact is such that it makes the design overly general and open as there
    are no restrictions to add any new components to composite classes.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 影响如此之大，以至于它使得设计过于通用和开放，因为没有限制向组合类添加任何新组件。
- en: Decorator
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器
- en: The decorator pattern attaches additional responsibilities to an object dynamically.
    It provides an alternative way (by composition) to subclass and to extend the
    functionality of an object at runtime.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器模式动态地为对象附加额外的责任。它提供了一种替代方法（通过组合）来子类化和在运行时扩展对象的功能。
- en: This pattern creates a decorator class by wrapping the original class to provide
    additional functionalities without impact to the signature of methods.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式通过包装原始类来创建一个装饰器类，以提供额外的功能，而不会影响方法签名。
- en: '![](img/59103344-aea2-49f7-96eb-2485e7f9787f.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/59103344-aea2-49f7-96eb-2485e7f9787f.png)'
- en: Observe the preceding diagram as it depicts invoice functionalities extended
    by composition dynamically (runtime).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 观察前面的图示，因为它动态（运行时）展示了通过组合扩展的发票功能
- en: 'Let''s list the benefits:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们列出好处：
- en: It reduces time for upgrades
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它减少了升级所需的时间
- en: It simplifies enhancing the functionalities from the targeted classes and incorporates
    behavior into objects (changes class responsibilities, not the interface)
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它简化了从目标类增强功能，并将行为纳入对象中（改变类责任，而不是接口）
- en: 'Impacts are as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 影响如下：
- en: It tends to introduce more look-alike objects
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它倾向于引入更多类似的对象
- en: It leads to debugging difficulties as it is adding functionality at runtime
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于它在运行时添加功能，因此会导致调试困难
- en: Façade
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外观
- en: Façade suggests providing a high-level interface that unifies set of interfaces
    of subsystems, so it simplifies the subsystem usage.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 外观模式建议提供一个高级接口，该接口统一了子系统接口集，因此简化了子系统的使用。
- en: '![](img/ba70359e-9d2d-48ba-aa1a-05d6d55280c4.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ba70359e-9d2d-48ba-aa1a-05d6d55280c4.png)'
- en: A sample implementation of a service façade as in the preceding diagram, the
    session subsystem are unified with session façade (local and remote).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，服务外观的示例实现，会话子系统与会话外观（本地和远程）统一。
- en: 'Let''s look at the benefits:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它的好处：
- en: It promotes loose coupling (between clients and subsystems)
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它促进了松散耦合（客户端和子系统之间）
- en: It hides complexities of the subsystem from the clients
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它隐藏了子系统对客户端的复杂性
- en: The impact is such that it may lead to façade to check whether the subsystem
    structure changes.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 影响如此之大，以至于它可能导致外观检查子系统结构是否发生变化。
- en: Flyweight
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 享元
- en: '**Flyweight** suggests using the shared support of a vast number of fine-grained
    objects. We can use the **Flyweight** pattern to reduce the number of objects
    created (by sharing) and thereby reduce the memory footprint and improve the performance.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**享元**建议使用大量细粒度对象的共享支持。我们可以使用**享元**模式来减少创建的对象数量（通过共享），从而减少内存占用并提高性能。'
- en: '![](img/c62ab08b-407c-4a43-8180-ec6d4cb7c37a.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c62ab08b-407c-4a43-8180-ec6d4cb7c37a.png)'
- en: The preceding diagram depicts the general structure of the **Flyweight** pattern
    and a sample implementation. Consider a massive object that is shared across printer
    and a screen; **Flyweight** is a good option and can be cached as well (say for
    printing multiple copies).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图展示了**享元**模式的一般结构和示例实现。考虑一个在打印机和屏幕之间共享的巨大对象；**享元**是一个很好的选择，也可以被缓存（例如，用于打印多份）。
- en: 'Here are the benefits:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是好处：
- en: It leads to good performance due to reduction in the total number of instances
    (by shared objects)
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于减少了实例总数（通过共享对象），它导致良好的性能。
- en: It makes implementation for objects cache easy
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使得对象缓存实现变得容易
- en: The impact is such that it may introduce runtime costs associated with transferring,
    finding, or computing foreign (extrinsic) state.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 影响如此之大，以至于它可能会引入与传输、查找或计算外部（外部的）状态相关的运行时成本。
- en: Proxy
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理
- en: The proxy pattern suggests providing a placeholder (surrogate) for another object
    to control and get access to it. It is the best fit for lazy loading of objects
    (defer the creation and initialization until we need to use it).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 代理模式建议提供一个占位符（代理）来控制另一个对象并获取对其的访问。这对于对象的延迟加载（直到需要使用时才创建和初始化）是最合适的。
- en: '![](img/5a8b6703-53df-43f2-9199-0702c4359698.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5a8b6703-53df-43f2-9199-0702c4359698.png)'
- en: The preceding diagram shows a sample implementation of a proxy pattern for a
    payment class, and the payment can be either by check or by pay order. However,
    the actual access would be to **DebitAccount** object, so **PayOrderProxy** and
    **CheckProxy** are both surrogates for Debit Account.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图展示了支付类代理模式的示例实现，支付可以是支票或汇票。然而，实际的访问将是到**DebitAccount**对象，因此**PayOrderProxy**和**CheckProxy**都是Debit
    Account的代理。
- en: 'The following are the benefits:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些好处：
- en: It introduces the right level of indirections when accessing an object (abstraction
    of an object that resides in a different space)
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在访问对象时引入了正确级别的间接性（位于不同空间的对象的抽象）
- en: Creating objects on demand
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按需创建对象
- en: Copy-on-write (may reduce the copying of heavy objects if not modified)
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写时复制（如果未修改，可能减少重对象的复制）
- en: The impact is such that it can make some implementations less efficient due
    to indirections.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 影响如此之大，以至于它可能会因为间接性而使某些实现效率降低。
- en: Behavioral patterns
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行为模式
- en: Behavioral patterns provide guidelines on assigning responsibilities between
    objects. It does help with ways to implement algorithms and with communication
    between classes and objects.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 行为模式为在对象之间分配责任提供了指导。这确实有助于实现算法以及类和对象之间的通信。
- en: 'Behavioral pattern focuses on the following characteristics:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 行为模式关注以下特性：
- en: Communication between objects and classes
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象和类之间的通信
- en: Characterizing the complex control flow; flow of control in software programming
    (otherwise, it is hard to follow at runtime)
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述复杂的控制流；软件编程中的控制流（否则，在运行时很难跟踪）
- en: Enforcing object composition rather than inheritance
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制使用对象组合而不是继承
- en: Loose coupling between the peer objects, and at the same time, they know each
    other (by indirections)
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同伴对象之间的松散耦合，同时，它们通过间接性相互了解
- en: Encapsulating the behavior in an object and delegating request to it
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在对象中封装行为并将请求委托给它
- en: There are various design patterns available to enforce the above said behavioral
    focusses and characteristics. We will see details of those behavioral patterns
    in this section . We also provided a sample implementation structure as a diagram
    for some of the patterns.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种设计模式可用于强制执行上述行为焦点和特性。在本节中，我们将看到这些行为模式的详细信息。我们还提供了一些模式的示例实现结构图。
- en: Chain of responsibility
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 责任链
- en: This pattern suggests avoiding coupling the client object (sender of requests)
    with the receiver object by enabling objects (more than one) to handle the request.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式建议通过使对象（多个）能够处理请求来避免将客户端对象（请求的发送者）与接收对象耦合。
- en: '![](img/23bb8393-93ad-48be-9fc8-cf469334f9b6.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/23bb8393-93ad-48be-9fc8-cf469334f9b6.png)'
- en: The preceding diagram depicts the typical structure of the chain of responsibility;
    the handler is the interface to define the requests and optionally express the
    successors along with concrete handlers that can handle the requests and forwards
    the same if needed.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图展示了责任链的典型结构；处理者是定义请求的接口，并可选择表达后继者，包括可以处理请求的具体处理者，如果需要，可以转发请求。
- en: 'Here''s a list of the benefits:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出了好处：
- en: Reduced coupling (objects do not know which other objects handle the requests)
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少了耦合（对象不知道哪些其他对象处理请求）
- en: Additional flexibilities in responsibilities assignments (of objects)
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在责任分配（对象）方面有更多的灵活性
- en: The impact is, no handshakes between the request handlers, so no guarantee of
    handling the request by other objects, and it may fall off from the chain unnoticed.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 影响是，请求处理器之间没有握手，因此无法保证其他对象处理请求，并且它可能在不被注意的情况下从链中脱落。
- en: Command (action/transaction)
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令（动作/事务）
- en: This pattern suggests encapsulation of requests as an object, parameterizing
    clients with different requests; it can placed over message queues, can be logged,
    and supports undo operations.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式建议将请求封装为对象，用不同的请求参数化客户端；它可以放在消息队列上，可以记录，并支持撤销操作。
- en: '![](img/61a4b414-aef0-480e-9e04-58fffeb712da.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/61a4b414-aef0-480e-9e04-58fffeb712da.png)'
- en: The preceding diagram depicts the structure of a command pattern and a sample
    implementation for a stockbroker application classes. **<<StockOrder>>** interface
    is a **Command**, and **Stock** concrete class creates requests. **Buy** and **Sell**
    are concrete classes implementing the **<<StockOrder>>**. The **StockBroker**
    is an invoker, and its objects execute specific commands depending on the type
    that it receives.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图示描述了命令模式的结构以及股票经纪人应用程序类的示例实现。**<<StockOrder>>** 接口是一个**命令**，**Stock** 具体类创建请求。**Buy**
    和 **Sell** 是实现 **<<StockOrder>>** 的具体类。**StockBroker** 是调用者，其对象根据接收到的类型执行特定的命令。
- en: 'Here are the benefits:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是它的好处：
- en: Encapsulation of object facilitates the changing of requests partially (by changing
    a single command) and no impacts to the rest of the flow
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象封装有助于部分更改请求（通过更改单个命令）而不会影响其余流程
- en: Separates the invoking object from the actual action performing object
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将调用对象与实际执行动作的对象分离
- en: Easy to add new commands without any impact to the existing classes
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容易添加新命令，而不会对现有类造成任何影响
- en: The impact is, the number of classes and objects increases over time or depends
    on the number of commands (concrete command implementations).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 影响是，随着时间的推移或取决于命令的数量（具体命令实现），类和对象的数量会增加。
- en: Interpreter
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释器
- en: This pattern suggests defining grammar along with an interpreter that uses representations
    so that the system can interpret any given sentences of a language.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式建议定义语法以及使用表示的解析器，以便系统可以解释任何给定语言的句子。
- en: '![](img/69393cc5-e685-4e6f-92fd-3063eb5493fe.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/69393cc5-e685-4e6f-92fd-3063eb5493fe.png)'
- en: Abstract expression or regular expression declares interpret operation, terminal
    expressions or literal expressions implements symbols in the grammar, and non-terminal
    expressions (alternate, sequence, repetition) has nonterminal symbols in the grammar.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象表达式或正则表达式声明解释操作，终端表达式或字面表达式实现语法中的符号，而非终端表达式（选择、序列、重复）在语法中有非终端符号。
- en: 'Let''s look at the benefits:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它的好处：
- en: It is easy to change and extend the grammar
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容易更改和扩展语法
- en: Implementing the grammar is easy as well
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现语法同样简单
- en: Helps introduce new ways to interpret expressions
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有助于引入解释表达式的新方法
- en: Impacts
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 影响
- en: Introduces maintenance overhead for complex grammars
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为复杂的语法引入了维护开销
- en: Iterator (cursor)
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代器（光标）
- en: This pattern suggests providing an approach to sequentially access the elements
    of an aggregate object and, at the same time, hide the underlying implementations.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式建议提供一个方法，以顺序访问聚合对象的元素，同时隐藏底层实现。
- en: '![](img/df228b63-eada-4f06-a3da-c48f78505152.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/df228b63-eada-4f06-a3da-c48f78505152.png)'
- en: The preceding diagram depicts the structure of the iteration pattern in which
    the iterator interface defines traversing methods, and the concrete iterator implements
    the interface. Aggregate defines an interface for creating an iterator object,
    while a Concrete aggregate implements the aggregate interface to create an object.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图示描述了迭代模式的结构，其中迭代器接口定义了遍历方法，具体的迭代器实现了接口。聚合定义了一个创建迭代器对象的接口，而具体的聚合实现了聚合接口以创建对象。
- en: 'Here are the benefits:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是它的好处：
- en: It supports variations in the aggregate traversals
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持聚合遍历中的变化
- en: Iterators simplify the aggregate interfaces
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器简化了聚合接口
- en: It may have null iterators and helps handle boundary conditions better
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能包含空迭代器，并有助于更好地处理边界条件
- en: Impacts
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 影响
- en: It may introduce additional maintenance cost (dynamic allocation of polymorphic
    iterators)
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能引入额外的维护成本（多态迭代器的动态分配）
- en: It may have privileged access and thus introduces complexities to define new
    traversal methods in iterators
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能具有特权访问权限，因此引入了定义新遍历方法在迭代器中的复杂性
- en: Mediator
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中介者
- en: The **Mediator** pattern advocates defining ways of interactions between encapsulated
    objects without depending on each other by explicit reference.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '**中介者**模式提倡定义封装对象之间交互的方式，而不依赖于彼此的显式引用。'
- en: '![](img/228791ae-4bd0-4d9d-83e8-96d04fffda93.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/228791ae-4bd0-4d9d-83e8-96d04fffda93.png)'
- en: The preceding diagram is a typical structure of the **Mediator** pattern, where
    **Mediator** or dialog director defines an interface to communicate with other
    colleague objects; concrete mediator implements cooperative behavior by coordinating
    colleague objects.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图示是**中介者**模式的典型结构，其中**中介者**或对话导演定义了一个与其他同事对象通信的接口；具体中介者通过协调同事对象来实现协作行为。
- en: 'Let''s look at the benefits:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它的好处：
- en: Limits subclassing (by localizing behavior and restricting the distribution
    of behaviors to several other objects)
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制子类化（通过本地化行为并限制行为分布到几个其他对象）
- en: Enforcing decoupling between colleagues objects
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制同事对象之间的解耦
- en: Simplifying object protocols (replaces many-to-many interactions to one-to-one)
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简化对象协议（将多对多交互替换为一对一）
- en: Providing clear clarification on how objects should interact
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供关于对象如何交互的明确说明
- en: Impacts is centralized control, leading to more complex and monolithic systems.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 影响是集中控制，导致系统更加复杂和单一。
- en: Memento
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 备忘录
- en: This pattern suggests capturing and externalizing an object's internal state
    without violating encapsulation principles; so, we can restore the captured object.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式建议捕获和外部化对象内部状态，而不违反封装原则；因此，我们可以恢复捕获的对象。
- en: '![](img/f3d3a1bf-46d4-4717-967a-741d7a23b699.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f3d3a1bf-46d4-4717-967a-741d7a23b699.png)'
- en: The preceding diagram depicts the structure of the memento pattern and a sample
    implementation for a calculator application. The **Caretaker** interface helps
    restore the previous operation that's handled in the **<<Calculator>>** concrete
    class.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图示展示了备忘录模式的结构以及一个计算器应用的示例实现。**保管者**接口帮助恢复在**<<计算器>>**具体类中处理的前一个操作。
- en: 'These are the benefits:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是它的好处：
- en: It preserves encapsulation boundaries by exposing information limited to the
    originator
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过暴露仅限于发起者的信息来保持封装边界
- en: It simplifies the originator
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它简化了发起者
- en: 'Impacts are as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 影响如下：
- en: Memento implementation might be expensive, as it needs to copy large amounts
    of data to store into the memento
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 备忘录实现可能成本高昂，因为它需要复制大量数据以存储到备忘录中
- en: It may be difficult to implement (through some programming languages) and ensure
    that only the originator is accessing the memento's state
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能难以实现（通过某些编程语言）并确保只有发起者可以访问备忘录的状态
- en: It might incur hidden storage and maintenance costs at the caretaker implementations
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能在保管者实现中产生隐藏的存储和维护成本
- en: Observer (dependents/publish/subscribe)
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察者（依赖者/发布/订阅）
- en: The **Observer** pattern suggests that when one object changes the state, it
    notifies its dependents and updates automatically. When implementation is in need
    of one-to-many dependencies, you would want to use this pattern.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '**观察者**模式建议当一个对象改变状态时，它通知其依赖者并自动更新。当实现需要一对多依赖关系时，您会想使用此模式。'
- en: '![](img/5c2b367d-7e5a-4e01-98fe-505d89ac8d33.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5c2b367d-7e5a-4e01-98fe-505d89ac8d33.png)'
- en: The preceding diagram depicts **Observer** pattern structure and a sample implementation
    of the same for a publications app; whenever an event occurs, subscribers need
    to be informed. The subscribers have a different mode of publishing (SMS, print,
    and emailing) and may need to support new modes as well in the future, so the
    best fit is **Observer**, as we just saw.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图示展示了**观察者**模式的结构以及一个出版物应用的示例实现；每当发生事件时，订阅者都需要被告知。订阅者有不同的发布模式（短信、印刷和电子邮件），并且未来可能还需要支持新的模式，因此最合适的选择是**观察者**，正如我们刚才看到的。
- en: 'Let''s go through its benefits:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看它的好处：
- en: Enables easy broadcast of communication
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现了通信的轻松广播
- en: Supports loose coupling between objects as it's capable of sending data to other
    objects without any change in the subject
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持对象之间的松散耦合，因为它能够将数据发送到其他对象，而无需对主题进行任何更改
- en: Abstract coupling between subject and observer (changes in the observer do not
    impact subject)
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主题和观察者之间的抽象耦合（观察者的变化不会影响主题）
- en: Can add or remove Observers any time
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以随时添加或删除观察者
- en: 'Impacts are as follows:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 影响如下：
- en: Accidental or unintended updates impact the system heavily as it cascades to
    the observer down the layers
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 意外的或非预期的更新对系统影响很大，因为它会级联到下层的观察者
- en: May lead to performance issues
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能导致性能问题
- en: Independent notifications may result in inconsistent state or behavior (no handshakes)
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立的通告可能导致不一致的状态或行为（没有握手）
- en: State (objects for states)
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态（状态的对象）
- en: These allow an object to alter its behavior when its internal state changes,
    and it appears as the class changes.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这些允许对象在其内部状态变化时改变其行为，并看起来像类变化一样。
- en: Use state pattern when an object's behavior depends on its state and change
    at runtime depends on that state.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个对象的行为依赖于其状态，并且运行时状态的变化依赖于该状态时，使用状态模式。
- en: '![](img/76cdf2c1-cc78-4e72-9c61-6f55be131808.png)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/76cdf2c1-cc78-4e72-9c61-6f55be131808.png)'
- en: The diagram depicts both structure of State pattern and a sample implementation;
    Context class carries states, and **Off** and **On** classes implement State interface
    so that context can use the action on each concrete class's off/on.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 该图展示了状态模式的结构和示例实现；上下文类携带状态，**Off**和**On**类实现状态接口，以便上下文可以使用每个具体类的开/关操作。
- en: 'Listed are the benefits:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 列出的好处如下：
- en: Suggest localizes state-specific behavior and partitions behavior for different
    states (new states and transitions can be added easily by subclass definitions)
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建议将特定于状态的行为本地化，并为不同状态划分行为（通过子类定义可以轻松添加新状态和转换）
- en: Makes state transitions explicit
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使得状态转换明确
- en: State objects are shareable
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态对象是可共享的
- en: The impact is, it may make adding a new concrete element difficult.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 影响是，它可能使添加新的具体元素变得困难。
- en: Strategy (policy)
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 策略（策略）
- en: Strategy pattern, also known as policy, defines a family or set of algorithms,
    encapsulates each one, and make them interchangeable. Strategy lets the algorithm
    vary independently of the clients that use it. When a group of classes differs
    only on their behavior, it is better to isolate the algorithms in separate classes
    and provide the ability to choose different algorithms at runtime.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式，也称为策略，定义了一个算法家族或一组算法，封装每个算法，并使它们可互换。策略允许算法独立于使用它的客户端变化。当一组类仅在行为上有所不同时，最好将算法隔离在单独的类中，并提供在运行时选择不同算法的能力。
- en: '![](img/a5fbbdbe-a91b-4aa1-afc5-c375524ae362.png)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a5fbbdbe-a91b-4aa1-afc5-c375524ae362.png)'
- en: The preceding diagram shows the strategy structure, and implementation of sorting
    algorithms (as a family) and depends on the input depends on the volume for sort,
    then the client can use the intended algorithm from the Concrete strategy sorting
    classes.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图显示了策略结构，以及排序算法（作为一个家族）的实现，它取决于输入的量，然后客户端可以使用预期的算法从具体的策略排序类中。
- en: 'The benefits are as listed:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 好处如上所述：
- en: Enables open and closed principle
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现了开闭原则
- en: Enables large-scale reusability
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现了大规模的可重用性
- en: Eliminates conditional statements (leads to clean code, well-defined responsibilities,
    easy to test, and so on)
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消除了条件语句（导致代码清晰、职责明确、易于测试等）
- en: 'Impacts are as follows:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 影响如下：
- en: Clients need to be aware of different strategies and how they differ
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户需要了解不同的策略以及它们之间的差异
- en: Communication overhead between strategy and context
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略和上下文之间的通信开销
- en: Increased number of objects
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象数量增加
- en: The template method
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板方法
- en: This suggests providing a skeleton of an algorithm in operation, and deferring
    a few steps to subclasses. The template method lets subclasses redefine a few
    specific actions of a defined algorithm without changing the algorithm structure.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明提供算法操作的框架，并将一些步骤推迟到子类中。模板方法允许子类在不改变算法结构的情况下重新定义定义算法的几个特定操作。
- en: '![](img/4809418f-9d85-4716-a069-c460fb93524e.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4809418f-9d85-4716-a069-c460fb93524e.png)'
- en: 'The following are the benefits:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些好处：
- en: Fundamental technique for code reuse
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码重用的基本技术
- en: Allows partial implementation of business process while delegating implementation-specific
    portion to implementation objects (flexible in creating prototypes)
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许在委托实现特定部分到实现对象的同时部分实现业务流程（在创建原型时灵活）
- en: Helps implement the Hollywood principle (inverted control structure, *Don't
    call us, we will call you*)
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帮助实现好莱坞原则（反转控制结构，*别叫我们，我们会叫你*）
- en: 'Impacts are as follows:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 影响如下：
- en: Sequence of flow might lead to confusion
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流程的顺序可能导致混淆
- en: High maintenance cost and impacts are high on any changes to the code
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护成本高，对代码的任何更改影响都很大
- en: Visitor
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问者
- en: The visitor pattern represents an operation performed on the objects. It lets
    us define a new operation without changing the class elements on which it operates.
    In simple words, we use the visitor class to alter the execution of an algorithm
    as and when the visitor varies.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 访问者模式表示对对象执行的操作。它允许我们定义一个新操作，而无需更改它所操作的类元素。简单来说，我们使用访问者类来根据访问者的变化来改变算法的执行。
- en: '>![](img/7b0e13b8-3355-4577-a5c3-58d815229791.png)'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '>![](img/7b0e13b8-3355-4577-a5c3-58d815229791.png)'
- en: 'Here are the benefits:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是它的好处：
- en: Adding new operations over an object structure is straightforward and easy (by
    adding a new visitor)
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在对象结构上添加新操作很简单且容易（通过添加一个新的访问者）。
- en: Visitor separates unrelated operations and gathers related operations
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问者将无关操作分离并聚集相关操作。
- en: 'Impacts are as follows:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 影响如下：
- en: The visitor class hierarchy can be difficult to maintain when a new concrete
    element class gets added
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当添加一个新的具体元素类时，访问者类层次结构可能难以维护。
- en: Implementation often forces to provide public operation that accesses an element's
    internal state (leads to compromising its encapsulation)
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现通常迫使提供公共操作以访问元素的内状态（导致其封装性受损）。
- en: Concurrency patterns
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发模式
- en: In software paradigm, the ability to perform multiple tasks at the same time
    (concurrency) by a software application is a critical factor; most software applications
    have some or other sort of concurrency. Keeping this in mind, let's briefly touch
    upon on a few concurrency patterns here, as other chapters in this book cover
    many (concurrency) related patterns in detail.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件范式中，软件应用能够同时执行多个任务（并发）是一个关键因素；大多数软件应用都有某种形式的并发。考虑到这一点，让我们简要地讨论一些并发模式，因为本书的其他章节详细介绍了许多（并发）相关模式。
- en: Concurrency design pattern
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发设计模式
- en: In many situations the automated system may have to handle many different events
    simultaneously called concurrency. OOP provides an adequate means (abstraction,
    reusability, sharing of distributed persistent data, parallel executions and so
    on) of dealing with concurrency. This section will cover few concurrency patterns
    in brief.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，自动化系统可能需要同时处理许多不同的事件，这被称为并发。面向对象编程提供了处理并发的充分手段（抽象、可重用性、分布式持久数据的共享、并行执行等）。本节将简要介绍一些并发模式。
- en: Producer-consumer
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生产者-消费者
- en: The producer-consumer pattern decouples the produce consume data processes.
    The process may handle data at different rates. Producer and consumer pattern's
    parallel loops are broken down into two categories as those that produce data
    and those that consume the produced data.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 生产者-消费者模式解耦了生产与消费数据的过程。该过程可能以不同的速率处理数据。生产者-消费者模式的并行循环可以分为两类：一类是生产数据，另一类是消费生产出的数据。
- en: Data queues are used to communicate data between loops in the producer/consumer
    design pattern. These queues are offered data buffering between the producer and
    consumer loops.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 数据队列用于在生产者/消费者设计模式中的循环之间传递数据。这些队列在生产者和消费者循环之间提供数据缓冲。
- en: Active object
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动对象
- en: The active object pattern enforces decoupling of method execution from the method
    invocation and so enhances the concurrency and simplifies synchronized access
    to the objects that reside in their (own) threads of control.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 活动对象模式强制将方法执行与方法调用解耦，从而增强了并发性并简化了对驻留在它们（自己的）控制线程中的对象的同步访问。
- en: We use this pattern where an application handles multiple client requests simultaneously
    to improve its quality of service.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用此模式（实现同步）来处理多个客户端请求，以提高其服务质量。
- en: Monitor object
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监视对象
- en: This pattern suggests synchronization on concurrent method execution to ensure
    that only one method runs within an object at a time. Monitors also allow an object's
    methods to execute scheduled sequences cooperatively.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式建议对并发方法执行进行同步，以确保一次只有一个方法在对象中运行。监视器还允许对象的方法以协作的方式执行预定的序列。
- en: We use this pattern (implement synchronization) when multiple threads are invoking
    methods of an object that modify its internal state. Contrary to active objects,
    monitor object belongs to the groups of passive objects; monitors are not having
    its (own) thread of control.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用此模式（实现同步）当多个线程调用修改对象内部状态的方法时。与活动对象相反，监视对象属于被动对象组；监视器没有自己的控制线程。
- en: Concurrency architectural pattern
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发架构模式
- en: '**Half-sync**/**Half-async**: In concurrent systems, decoupling of synchronous
    and asynchronous service processing brings programming simplicity without reducing
    the performance. Half-sync/Half-async introduces two intercommunicating layers,
    one for synchronous and another for asynchronous service processing, with a queuing
    layer in-between.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '**半同步**/**半异步**：在并发系统中，同步和异步服务处理的解耦带来了编程的简单性，而不会降低性能。半同步/半异步引入了两个相互通信的层，一个用于同步服务处理，另一个用于异步服务处理，中间有一个排队层。'
- en: This pattern enables the synchronous and asynchronous processing services to
    communicate with each other and helps those processes to decompose into layers.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式使得同步和异步处理服务能够相互通信，并帮助这些过程分解为层次。
- en: '**Leader**/**Followers**: If we need an efficient concurrency model where multiple
    threads need to take turns sharing a set of event sources that detect, de-multiplex,
    dispatch, and process event-sources'' service requests, then the best choice is
    to implement the Leaders/Followers pattern in our system.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '**领导者**/**跟随者**：如果我们需要一个高效的并发模型，其中多个线程需要轮流共享一组检测、解复用、调度和处理事件源服务请求的事件源，那么在我们的系统中实现领导者/跟随者模式是最好的选择。'
- en: The aim of this pattern is to provide an elegant solution to process multiple
    events concurrently, such as in multithreaded server applications.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式的目的是提供一个优雅的解决方案，以同时处理多个事件，例如在多线程服务器应用程序中。
- en: Summary
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The design patterns have evolved since 1992, and even today, it is inevitable
    in solving many software design problems in a proven technique and practices called
    design patterns. It is not difficult to see any specific pattern as a solution
    or technique that can be analyzed, implemented, and reused, but it is difficult
    to characterize the problem it solves and the context in which it is the best
    fit. It is critical to know the purpose of the patterns, as it helps understand
    the existing design of any given system.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式自1992年以来已经发展，即使在今天，在解决许多软件设计问题时，设计模式这种经过验证的技术和实践仍然是不可避免的。不难将任何特定的模式视为一种可以分析、实现和重用的解决方案或技术，但很难描述它解决的问题以及它最佳适用的情况。了解模式的目的至关重要，因为它有助于理解任何给定系统的现有设计。
- en: With this chapter, we touched upon the key elements of OOD, abstraction, encapsulation,
    modularization, and hierarchy along with a few additional items such as typing,
    concurrency, and persistence.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章，我们探讨了面向对象设计（OOD）的关键要素，包括抽象、封装、模块化和层次结构，以及一些额外的项目，如类型、并发性和持久性。
- en: Also, we discussed the design principles, hoping that the readers get a *SOLID*
    understanding of what OO principles offer to OO software designers. We believe
    that the SOLID principles are the fundamental training material for anyone who
    wants to step into software design and development even in today's world.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还讨论了设计原则，希望读者能够对面向对象原则为面向对象软件设计师提供的帮助有一个*SOLID*的理解。我们相信，SOLID原则是任何想要进入软件设计和开发领域的人的基本培训材料，即使在当今世界也是如此。
- en: 'We touched upon three broad categories of OO design patterns: creational, structural,
    and behavioral. We also discussed the benefits and impacts of each pattern so
    that the readers will be able to easily characterize the problems it solves and
    the context it best suits as a software solution.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要介绍了面向对象设计的三个广泛类别：创建型、结构型和行为型。我们还讨论了每种模式的益处和影响，以便读者能够轻松地描述它解决的问题以及它作为软件解决方案的最佳适用环境。
- en: We also added a section, hoping readers to get a fair amount of introduction
    about concurrency (design and architectural) patterns as well.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还增加了一个部分，希望读者能够对并发（设计和架构）模式有一个公平的介绍。
- en: References
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考资料
- en: 'The following table refers to cross-reference of OO software design patterns:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格是面向对象软件设计模式的交叉引用：
- en: '![](img/96ce5f1e-3d60-4dea-8db9-524ee9ace6a7.png)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
  zh: '![](img/96ce5f1e-3d60-4dea-8db9-524ee9ace6a7.png)'
- en: Reference books are as follows*:*
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些参考书籍*：*
- en: 'Design Patterns: Elements of Reusable Object-Oriented Software by Erich Gamma,
    Richard Helm, Ralph Johnson and John Vlissides'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《设计模式：可复用面向对象软件元素》by Erich Gamma, Richard Helm, Ralph Johnson 和 John Vlissides
- en: '*Object-Oriented Analysis and Design with Applications (2nd Edition)* by Grady
    Booch'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《面向对象分析与设计：应用篇》（第2版）* by Grady Booch'
- en: 'Other references for this chapter:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其他参考资料：
- en: '[http://www.oodesign.com/](http://www.oodesign.com/)'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.oodesign.com/](http://www.oodesign.com/)'
- en: '[https://www.tutorialspoint.com/design_pattern](https://www.tutorialspoint.com/design_pattern)'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.tutorialspoint.com/design_pattern](https://www.tutorialspoint.com/design_pattern)'
- en: '[https://sourcemaking.com/design_patterns/](https://sourcemaking.com/design_patterns/)'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://sourcemaking.com/design_patterns/](https://sourcemaking.com/design_patterns/)'
- en: '[http://www.blackwasp.co.uk/GofPatterns.aspx](http://www.blackwasp.co.uk/GofPatterns.aspx)'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.blackwasp.co.uk/GofPatterns.aspx](http://www.blackwasp.co.uk/GofPatterns.aspx)'
- en: '[http://www.mif.vu.lt/~plukas/resources/DPBook/](http://www.mif.vu.lt/~plukas/resources/DPBook/)'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.mif.vu.lt/~plukas/resources/DPBook/](http://www.mif.vu.lt/~plukas/resources/DPBook/)'
- en: '[www.dzone.com](http://www.dzone.com)'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[www.dzone.com](http://www.dzone.com)'
- en: '[http://www.javaworld.com](http://www.javaworld.com)'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.javaworld.com](http://www.javaworld.com)'
- en: '[https://sudo.ch/unizh/concurrencypatterns/ConcurrencyPatterns.pdf](https://sudo.ch/unizh/concurrencypatterns/ConcurrencyPatterns.pdf)'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://sudo.ch/unizh/concurrencypatterns/ConcurrencyPatterns.pdf](https://sudo.ch/unizh/concurrencypatterns/ConcurrencyPatterns.pdf)'
- en: '[http://www.cs.wustl.edu/~schmidt/POSA/POSA2/conc-patterns.html](http://www.cs.wustl.edu/~schmidt/POSA/POSA2/conc-patterns.html)'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.cs.wustl.edu/~schmidt/POSA/POSA2/conc-patterns.html](http://www.cs.wustl.edu/~schmidt/POSA/POSA2/conc-patterns.html)'
- en: '[https://en.wikipedia.org/wiki/Concurrency_pattern](https://en.wikipedia.org/wiki/Concurrency_pattern)'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Concurrency_pattern](https://en.wikipedia.org/wiki/Concurrency_pattern)'
