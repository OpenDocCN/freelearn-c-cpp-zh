- en: 'Integrating C++ and the Unreal Editor: Part I'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a class or struct as a  Blueprint variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating classes or structs that can be subclassed in Blueprint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating functions that can be called in Blueprint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating events that can be implemented in Blueprint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exposing multi-cast delegates to Blueprint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating C++ enums that can be used in Blueprint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Editing class properties in different places in the editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making properties accessible in the Blueprint editor graph
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Responding to property changed events from the editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a native code Construction Script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of Unreal's primary strengths is that it provides programmers with the ability
    to create Actors and other objects that can be customized or used by designers
    in the editor. This chapter shows you how to do this. Following that, we will
    try to customize the editor by creating custom Blueprint and Animation nodes from
    scratch. We will also implement custom editor windows and custom Details panels
    to inspect the Types that are created by users.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires the use of Unreal Engine 4 and uses Visual Studio 2017
    as the IDE. Instructions on how to install both pieces of software and their requirements
    can be found in [Chapter 1](4adb307e-d86f-4d70-b6de-a0893102d1cf.xhtml), *UE4
    Development Tools*.
  prefs: []
  type: TYPE_NORMAL
- en: Using a class or struct as a blueprint variable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Types that you declare in C++ do not automatically get incorporated into Blueprint
    for use as variables. This recipe shows you how to make them accessible so that
    you can use custom native code types as Blueprint function parameters.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new class using the editor. Unlike previous chapters, we are going
    to create an `Object`-based class. `Object` isn''t visible in the default list
    of common classes, so we need to tick the Show All Classes button in the editor
    UI, then select Object. Afterward, click on the Next button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/97bdcafe-9d31-4b14-a8e4-afda49cd46d7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Name your new Object subclass `TileType` and then click on the Create Class
    button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bb2c7553-314d-4c9a-af49-5814ac547b50.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Add the following properties to the `TileType` definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Compile your code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the editor, create a new Blueprint class based on `Actor`. Call it `Tile`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3a50d41d-8514-4f0f-af7e-6129a0374c88.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Within the blueprint editor for `Tile`, add a new variable to Blueprint by
    going to the My Blueprint section and moving down to the Variables section and
    then hitting the + button. The Details panel on the right-hand side of the screen
    will then fill up with information about this new variable, including what type
    it is. Check the list of types that you can create as variables under the Variable
    Type property, and verify that `TileType` is not there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/930a3f71-eaba-4f0c-9416-39c8cd3f517c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Return to Visual Studio and open up the `TileType.h` file. Add `BlueprintType`
    to the `UCLASS` macro, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Save your script, return to the editor and recompile the project, then return
    to the `Tile` blueprint editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, when you add a new variable to your actor, you can select `TileType` as
    the type for your new variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f84aea2a-98c2-4c81-8379-494983245449.png)'
  prefs: []
  type: TYPE_IMG
- en: You can now change the Variable Name to something better, such as `MyTileType`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We've now established a *has-a* relationship between `Tile` and `TileType`.
    Now, `TileType` is a Blueprint type that can be used as a function parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, go to the My Blueprint section and scroll down to the Functions
    section. From there, you can click on the + button to create a new function. Name
    this new function `SetTileType`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4f058424-18ef-43d7-8b36-2b7664febb9b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the function has been created, the Details tab will display information
    about the function itself. Under the Inputs section, click on the + button to
    add a new input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a885d752-02c3-406c-8f94-d267d00535c6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once selected, you''ll be able to give the variable a name and select the type
    from the dropdown that, by default, says `Boolean`. Set the input parameter''s
    type to `TileType`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/dca37210-53ef-4160-87e5-6439c6247fa8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you do this, you''ll see that the parameter has been added as an input
    to the Set Tile Type function in Blueprints:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6821f604-caf0-4c04-8074-0ae193b002ea.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Go back to the My Blueprint section and drag and drop the `MyTileType` variable
    onto the Set Tile Type graph, next to the first node. You can drag your `Type`
    variable into the viewport and select Set MyTileType:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3b1d3861-9389-4e2e-aea7-5d96da0a0e5b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have the two nodes we need, connect the Exec output pin to the
    input of the Set MyTileType node and then connect the parameter from `SetTileType`
    to the Set node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/44e78dd9-47fe-4cc1-bd19-960caa91ba82.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For performance reasons, Unreal assumes that classes do not require the extra
    reflection code that is needed to make the type available to Blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: We can override this default by specifying `BlueprintType` in our `UCLASS` macro.
  prefs: []
  type: TYPE_NORMAL
- en: With the specifier included, the type is now made available as a parameter or
    variable in Blueprint and can be used in all the same ways that default types
    can.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows that you can use a type as a function parameter in Blueprint
    if its native code declaration includes `BlueprintType`.
  prefs: []
  type: TYPE_NORMAL
- en: However, at the moment, none of the properties that we defined in C++ are accessible
    to Blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: Other recipes in this chapter deal with making those properties accessible so
    that we can actually do something meaningful with our custom objects.
  prefs: []
  type: TYPE_NORMAL
- en: Creating classes or structs that can be subclassed in Blueprint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While this book focuses on C++, when developing with Unreal a more standard
    workflow is to implement core gameplay functionality as well as performance-critical
    code in C++, and expose those features to Blueprint to allow designers to prototype
    gameplay, which can then be refactored by programmers with additional Blueprint
    features, or pushed back down to the C++ layer. One of the most common tasks,
    then, is to **mark up** our classes and structs in such a way that they are visible
    to the Blueprint system.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new C++ class derived from the `Actor` class using the editor wizard;
    name it `BaseEnemy`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ae20069a-adfb-4955-b837-b70770fa206b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Add the following `UPROPERTY` to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following class specifier to the `UCLASS` macro:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Save and then compile the script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the editor and create a new blueprint class. Expand the All Classes list
    to show all of the classes and select our `BaseEnemy` class as the parent. Afterward,
    click on the Select button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/21397387-9ab2-4a72-b976-7f2e71fc8f7b.png)'
  prefs: []
  type: TYPE_IMG
- en: Name the new Blueprint `EnemyGoblin` and open it in the Blueprint editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that the `UPROPERTY` macros we created earlier still aren't there because
    we haven't included the appropriate markup to make them visible to Blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous recipe demonstrated the use of `BlueprintType` as a class specifier.
    `BlueprintType` allows the type to be used as a type within the Blueprint editor
    (that is, it can be a variable or a function input/return value).
  prefs: []
  type: TYPE_NORMAL
- en: However, we may want to create blueprints based on our type (using inheritance)
    rather than composition (placing an instance of our type inside an `Actor`, for
    example).
  prefs: []
  type: TYPE_NORMAL
- en: This is why Epic provided `Blueprintable` as a class specifier. `Blueprintable`
    means a developer can mark a class as inheritable by Blueprint classes.
  prefs: []
  type: TYPE_NORMAL
- en: We have both `BlueprintType` and `Blueprintable` instead of a single combined
    specifier because sometimes you may only want to expose a partial functionality.
    For example, certain classes should be usable as variables, but performance reasons
    forbid creating them in Blueprint. In that instance, you would use `BlueprintType`
    rather than both specifiers.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, perhaps we want to use the Blueprint editor to create new
    subclasses, but we don't want to pass object instances around inside the `Actor`
    blueprints. It is recommended you use `Blueprintable`, but omit `BlueprintType`
    in this case.
  prefs: []
  type: TYPE_NORMAL
- en: Like before, neither `Blueprintable` nor `BlueprintType` specify anything about
    the member functions or member variables contained inside our class. We'll make
    those available in later recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating functions that can be called in Blueprint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While marking classes as `BlueprintType` or `Blueprintable` allows us to pass
    instances of the class around in Blueprint, or to subclass the type with a Blueprint
    class, those specifiers don't actually say anything about member functions or
    variables, and whether they should be exposed to Blueprint. This recipe shows
    you how to mark a function so that it can be called within Blueprint graphs.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new C++ class derived from the `StaticMeshActor` class using the editor
    wizard; call it `SlidingDoor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following text that''s in bold to the new class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the class implementation by adding the following text in bold to the
    `.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Compile your code and launch the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag a copy of your door out into the level:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7f1a01da-e630-4133-93f7-0a7381a4b1fd.png)'
  prefs: []
  type: TYPE_IMG
- en: An easy way to have objects *fall* to the ground is by using the End key with
    the object you want to drop selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure you have your `SlidingDoor` instance selected, then open the Level
    blueprint by going to Blueprints | Open Level Blueprint. Right-click on the empty
    canvas and expand Call function on Sliding  Door 1:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0b59687a-998c-4e30-99cb-1112f5ef746e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Expand the Door section and then select the `Open` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2e0152ed-e212-411e-a05f-a50e2c0c1a0c.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Link the execution pin (white arrow) from Event BeginPlay to the white arrow
    on the `Open` node, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8d197815-24a8-4c76-a565-e4c8c4a06e09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Play your level and verify that the door moves up as expected when `Open` is
    invoked on your door instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e844796d-e944-4409-9136-09e03f95fa99.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within the declaration of the door, we create a new function for opening the
    door, a Boolean to track whether the door has been told to open, and a vector
    allowing us to precompute the target location of the door.
  prefs: []
  type: TYPE_NORMAL
- en: We also override the `Tick` actor function so that we can perform some behavior
    on every frame.
  prefs: []
  type: TYPE_NORMAL
- en: Within the constructor, we load in the cube mesh and scale it to represent our
    door.
  prefs: []
  type: TYPE_NORMAL
- en: We also set `IsOpen` to a known good value of `false` and enable actor ticking
    by using `bCanEverTick` and `bStartWithTickEnabled`.
  prefs: []
  type: TYPE_NORMAL
- en: These two Booleans control whether ticking can be enabled for this actor and
    if ticking starts in an enabled state, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `Open` function, we calculate the target location that's relative
    to the door's starting position.
  prefs: []
  type: TYPE_NORMAL
- en: We also change the `IsOpen` Boolean from `false` to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the `IsOpen` Boolean is `true`, inside the `Tick` function, the door
    tries to move itself toward the target location using `SetActorLocation` and `Lerp` to
    interpolate between the current location and the destination.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 5](cf821ef4-8a19-440c-805d-573748b76d5f.xhtml), *Handling Events and
    Delegates*, has a number of recipes relating to the spawning of actors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating events that can be implemented in Blueprints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another way that C++ can be more tightly integrated with Blueprint is through
    the creation of functions that can have Blueprint implementations in native code.
    This allows a programmer to specify an event and invoke it, without needing to
    know anything about the implementation. The class can then be subclassed in Blueprint,
    and another member of the production team can implement a handler for the event
    without ever having to go near a line of C++.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new `StaticMeshActor` class called `Spotter`. Remember to use the Show
    All Classes button to select `StaticMeshActor` as the parent class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make sure that the following functions are defined and overridden in the class
    header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the implementation file (`Spotter.cpp`), update the code to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Compile and start the editor. Find your `Spotter` class in Content Browser,
    then left-click and drag a copy out into the game world.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you play the level, you''ll see the red line showing the trace that the
    `Actor` is performing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9914c7d6-45da-4f8f-b9f5-1a67276f9a50.png)'
  prefs: []
  type: TYPE_IMG
- en: However, nothing will happen if the player walks in front of it because we haven't
    implemented our `OnPlayerSpotted` event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To implement this event, we need to create a blueprint subclass of our `Spotter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Right-click on `Spotter` in the Content Browser and select Create Blueprint
    class based on Spotter. Name the class `BPSpotter`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/75939870-ef59-44a6-b9fa-38b3e8635a19.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating a Blueprint class based on Spotter
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the Blueprint editor, click on the Override button in the Functions
    section of the My Blueprint panel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8f457866-8e37-4655-9abc-650ec2e5e8af.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select On Player Spotted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1e41605e-623d-40fb-844c-b47593bb12fe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To see the event, click on the Event Graph tab. Left-click it and drag it away
    from the white execution pin on our event. In the context menu that appears, select
    and add a `Print String` node so that it is linked to the event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e38c3014-8e80-4e2a-9787-ceb994895a6e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Delete your previous Spotter object in the level and then drag and drop a `BPSpotter`
    in. Play the level again and verify that walking in front of the trace that the
    `BPSpotter` is using now prints a string to the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/96f3cfec-578d-40bb-9af1-1e813185972f.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the constructor for our `Spotter` object, we load one of the basic primitives,
    a cone, into our Static Mesh Component as a visual representation.
  prefs: []
  type: TYPE_NORMAL
- en: We then rotate the cone so that it resembles a spotlight pointing to the *X*
    axis of the actor.
  prefs: []
  type: TYPE_NORMAL
- en: During the `Tick` function, we get the actor's location and then find a point
    200 units away from the actor along its local *X* axis. We call the parent class
    implementation of `Tick` using `Super::` to ensure that any other tick functionality
    is preserved, despite our override.
  prefs: []
  type: TYPE_NORMAL
- en: We convert a local position into a world space position by first acquiring the
    Actor-to-World transform for the `Actor`, then using that to transform a vector
    specifying the position.
  prefs: []
  type: TYPE_NORMAL
- en: The transform is based on the orientation of the root component, which is the
    static mesh component that we rotated during the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: As a result of that existing rotation, we need to rotate the vector we want
    to transform. Given that we want the vector to point out of what was the bottom
    of the cone, we want a distance along the negative up axis; that is, we want a
    vector of the form (0,0,-d), where *d* is the actual distance away.
  prefs: []
  type: TYPE_NORMAL
- en: Having calculated our end location for our trace, we actually perform the trace
    with the `SweepSingleByChannel` function.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sweep is performed, we try to cast the resulting hit `Actor` into a
    pawn.
  prefs: []
  type: TYPE_NORMAL
- en: If the cast was successful, we invoke our Implementable Event of `OnPlayerSpotted`,
    and the user-defined Blueprint code executes.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing multi-cast delegates to Blueprint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multi-cast delegates are a great way to broadcast an event to multiple objects
    that **listen** or **subscribe** to the event in question. They are particularly
    invaluable if you have a C++ module that generates events that potentially arbitrary
    Actors might want to be notified about. This recipe shows you how to create a
    multi-cast delegate in C++ that can notify a group of other Actors during runtime.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new `StaticMeshActor` class called `King`. Add the following to the
    class header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We also want to display something on the screen, so add a definition for a
    constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a new `UFUNCTION` to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an instance of our multicast delegate to the class as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `King.cpp` file and then add in the implementation for the constructor
    to perform our mesh initialization (remembering to add an `#include` for the `ConstructionHelpers.h`
    file):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `Die` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Create a new class called `Peasant`, also based on `StaticMeshActor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Declare a default constructor in the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the following function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `Flee` function in the `.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Return to the Unreal Editor and compile your scripts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Afterward, create a Blueprint class based on `APeasant`. You can do this by
    right-clicking on the `Peasant` object in the Content Browser and then selecting
    Create Blueprint class based on Peasant. Call the new `BPPeasant` class. Afterward,
    click on the Create Blueprint Class button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d90c146a-d40e-4b97-ad38-1b4c93c2a64f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Within the Blueprint, click on the Event Graph tab and move upward to the `Event
    BeingPlay` node. Click and drag it away from the white (execution) pin of your
    `BeginPlay` node. Type `get all`, and you should see Get All Actors Of Class.
    Select the node to place it in your graph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/688d8fe5-46f8-4e55-9cbe-814a3c03422c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Set the value of the purple (class) node to `King`. You can type `king` in
    the search bar to make locating the class in the list easier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/024b2403-c44e-4992-81d0-bf62b0f94269.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Drag the blue grid (object array) node out into an empty space and, from the
    Actions menu that pops up, type in the word `get`. From the options that are available,
    select the Get (a copy) option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4775d89e-250e-4867-879a-5d17ae725240.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Drag away from the blue output pin of the get node and place a Not Equal (object)
    node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f7621e45-e678-460c-a3e5-ef35d2d5ec16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Connect the red (bool) pin of the Not Equal node to a `Branch` node, and wire
    the execution pin of `Branch` to our `Get All Actors Of Class` node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/57bbbe4c-7469-4ed1-bd16-419682944815.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Connect the True pin of the branch to the Bind Event to OnKing Death node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/165a3781-c973-477d-b8d5-9f92363d1c15.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that you will probably have to untick Context Sensitive in the context
    menu for the Bind Event node to be visible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, connect the output of the Get node into the Target property of the Bind
    Event to OnKingDeath node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2b0c31ca-100d-40ba-8f2f-bd1ffbe4b584.png)'
  prefs: []
  type: TYPE_IMG
- en: Connecting the  Get node into the Target property of the Bind Event to OnKingDeath node
  prefs: []
  type: TYPE_NORMAL
- en: If you double-click on a connection, you can create a reroute node that you
    can drag to make it easier to see the connections between nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Drag out the red pin of the Bind Event to OnKingDeath node and select Add Custom
    Event.... Give your event the desired name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You may need to uncheck the Context Sensitive option to see the Add Custom Event...
    option.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc779546-1339-4875-b6b8-2137e577236c.png)'
  prefs: []
  type: TYPE_IMG
- en: Connecting the Custom Event and the Event Binding.
  prefs: []
  type: TYPE_NORMAL
- en: 'Connect the white execution pin for the Custom Event to a new node named `Flee`,
    which we created back in Step 10:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f1f23155-2850-4057-8707-9a47724fd8bf.png)'
  prefs: []
  type: TYPE_IMG
- en: Lastly, drag the Dead King property from the Custom Event into the `Dead King`
    property of the Flee node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Verify that your Blueprint looks like what''s shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fb6eb322-517f-46c1-910c-d2f09ba30a3a.png)'
  prefs: []
  type: TYPE_IMG
- en: The completed Blueprint
  prefs: []
  type: TYPE_NORMAL
- en: 'Drag a copy of your `King` class into the level, and then add a few `BPPeasant`
    instances around it in a circle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/287e0110-9b2b-4353-8d05-18ad8101bde9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Open the level Blueprint. Inside it, drag away from `BeginPlay,` and add a
    `Delay` node. Set the delay to 5 seconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b444ee3f-2178-437e-b940-8a63dd56fa2e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With your `King` instance that's selected in the level, right-click in the graph
    editor for the Level Blueprint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select Call function on King 1 and look in the `King` category for a function
    called `Die`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/287aed93-e6e9-45a3-8ae2-517e3c05e79d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Select `Die`, then connect its execution pin to the output execution pin from
    the delay:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/23c556e5-53bb-4ff5-8dd7-97bb10398bda.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When you play your level, you should see that the king dies after 5 seconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b527406e-ae24-4ce9-87d5-1d06077f0ebe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Afterward, you should see the peasants all wail and flee directly away from
    the king:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9a1cc2a2-35c1-4201-8fb0-a09cb3f069fc.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We create a new actor (based on `StaticMeshActor` for convenience, as it saves
    us having to declare or create a Static Mesh component for the `Actor` visual
    representation).
  prefs: []
  type: TYPE_NORMAL
- en: We declare a dynamic multicast delegate using the `DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam`
    macro. Dynamic multicast delegates allow an arbitrary number of objects to subscribe
    (listen) and unsubscribe (stop listening) so that they will be notified when the
    delegate is broadcast.
  prefs: []
  type: TYPE_NORMAL
- en: The macro takes a number of arguments – the type name of the new delegate signature
    being created, the type of the signature's parameter, then the name of the signature's
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: We also add a function to `King` that will allow us to tell it to die. Because
    we want to expose the function to Blueprints for prototyping, we mark it as `BlueprintCallable`.
  prefs: []
  type: TYPE_NORMAL
- en: The `DECLARE_DYNAMIC_MULTICAST_DELEGATE` macro that we used earlier only declared
    a type; it didn't declare an instance of the delegate, so we do that now, referencing
    the type name that we provided earlier when invoking the macro.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic multicast delegates can be marked as `BlueprintAssignable` in their
    `UPROPERTY` declaration. This indicates to Unreal that the Blueprint system can
    dynamically assign events to the delegate that will be called when the delegate's
    `Broadcast` function is called.
  prefs: []
  type: TYPE_NORMAL
- en: As always, we assign a simple mesh to our `King` so that it has a visual representation
    in the game scene.
  prefs: []
  type: TYPE_NORMAL
- en: Within the `Die` function, we call `Broadcast` on our own delegate. We specified
    that the delegate would have a parameter that is a pointer to the king which died,
    so we pass this pointer as a parameter to the broadcast function.
  prefs: []
  type: TYPE_NORMAL
- en: If you want the king to be destroyed, rather than playing an animation or other
    effect when it dies, you need to change the delegate's declaration and pass in
    a different type. For example, you could use `FVector`, and simply pass in the
    location of the dead king directly so that the peasants could still flee appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Without this, you potentially could have a situation where the `King` pointer
    is valid when `Broadcast` is called, but the call to `Actor::Destroy()` invalidates
    it before your bound functions are executed.
  prefs: []
  type: TYPE_NORMAL
- en: Within our next `StaticMeshActor` subclass, called `Peasant`, we initialize
    the static mesh component as usual using a different shape from the one that we
    used for the `King`.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the implementation of the peasant's `Flee` function, we simulate the
    peasants playing sound by printing a message on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: We then calculate a vector to make the peasants flee by first finding a vector
    from the dead king to this peasant's location.
  prefs: []
  type: TYPE_NORMAL
- en: We normalize the vector to retrieve a unit vector (with a length of 1) pointing
    in the same direction.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling the normalized vector and adding it to our current location calculates
    a position at a fixed distance, in the exact direction for the peasant to be fleeing
    directly away from the dead king.
  prefs: []
  type: TYPE_NORMAL
- en: '`SetActorLocation` is then used to actually teleport the peasants to that location.'
  prefs: []
  type: TYPE_NORMAL
- en: If you used a Character with an AI controller, you could have the `Peasant` pathfind
    to the target location rather than teleporting. Alternatively, you could use a `Lerp` function
    that's invoked during the peasant's `Tick` to make them slide smoothly rather
    than jump directly to the location.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: See [Chapter 4](eade601c-4b55-484a-ba49-0a989d81d7f8.xhtml), *Actors and Components*,
    for more extended discussions about Actors and Components. [Chapter 5](cf821ef4-8a19-440c-805d-573748b76d5f.xhtml),
    *Handling Events and Delegates*, discusses events such as `Notify` and `ActorOverlap`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating C++ enums that can be used in Blueprint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enums are commonly used in C++ as flags or inputs to switch statements. However,
    what if you want to pass an `enum` value to or from C++ from a Blueprint? Alternatively,
    if you want to use a `switch` statement in Blueprint that uses an `enum` from
    C++, how do you let the Blueprint editor know that your `enum` should be accessible
    within the editor? This recipe shows you how to make enums visible in Blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new `StaticMeshActor` class called `Tree` using the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Insert the following code above the class declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following to the `Tree` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following to the `Tree` constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Return to the Unreal Editor and compile your code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Blueprint class called `MyTree`, based on `Tree`, by right-clicking
    on the Tree object and selecting Create Blueprint class based on Tree. Once the
    menu comes up, click on the Create Blueprint Class button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the blueprint editor for `MyTree`, click on the Construction Script tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Right-click in the empty window and type `treetype`. There is a Get number
    of entries in TreeType node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8a5f09a0-43b0-4d0e-852f-f28683ca8a5c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Where and then connect its Return value output pin to the Max property of a
    new Random Integer node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/aa62d8f0-eac4-4978-903c-33be135516cc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Connect the Return Value output of the random integer to a ToByte (Integer)
    node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e638984a-344d-4bcb-9d28-dc2bbdcfe361.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Variables section of the My Blueprint panel, click on the + button.
    From there, go to the Details tab and set the Variable Type to `Tree Type`. Afterward,
    set the Variable Name to `RandomTree`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/43c68378-cfe8-4485-8e5f-1a654392ffb4.png)'
  prefs: []
  type: TYPE_IMG
- en: Drag the RandomTree variable into the graph and select Set Random Tree when
    you see a small context menu appear.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the Return Value output of the `ToByte` node to the input of the SET
    Type node. You'll see an extra conversion node automatically appear.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Lastly, connect the execution pin of Construction Script to the SET Type node''s
    execution pin. Your Blueprint should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/17bd491f-612b-4926-9485-76609cd128da.png)'
  prefs: []
  type: TYPE_IMG
- en: To verify that the blueprint is correctly functioning and randomly assigning
    a type to our tree, we are going to add some nodes to the Event Graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Place a `Print String` node after the Event BeginPlay event node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/155d1518-6a95-478b-89db-c434fbb4a3ea.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Place a `Format Text` node and connect its output to the input of the `Print
    String` node. A conversion node will be added for you:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/825ac029-d5de-496c-87fe-2f17a6ebcd72.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Inside the `Format Text` node, add `My Type is {0}!` to the Format text box:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d1b858b3-6f18-4cba-a7c8-8d54f5137af8.png)'
  prefs: []
  type: TYPE_IMG
- en: You should see that it adds a new parameter, 0, which we can now set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Drag the RandomTree variable from the Variables section of the My Blueprint
    window into the graph and select Get from the menu:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/76fab5b0-2f7d-4c0e-a8d4-0ed39f776c22.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Add an Enum to Name node to the `Type` output pin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d92b7665-d8ed-4b79-b03a-ad3b56eb5f9f.png)'
  prefs: []
  type: TYPE_IMG
- en: The Format Text node will not use a Name, so we will need to convert it into
    Text. Add a ToText (name) node to the Enum to Name output pin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Connect the Return Value output of the ToText (name) node to the 0 input pin
    on the Format Text node. Your Event Graph should now look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f79e30f9-f9b9-46cf-8784-a4a7e93d8c40.png)'
  prefs: []
  type: TYPE_IMG
- en: The completed Blueprint graph
  prefs: []
  type: TYPE_NORMAL
- en: Compile your Blueprint and then return to the Unreal Editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag a few copies of your Blueprint into the level and hit Play. You should
    see a number of trees printing information regarding their type, verifying that
    types are being randomly assigned by the Blueprint code that we created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b1534f7b-f726-4577-92d5-380d72ddacf2.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As usual, we use `StaticMeshActor` as the base class for our `Actor` so that
    we can easily give it a visual representation in the level.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerated types are exposed to the reflection system using the `UENUM` macro.
  prefs: []
  type: TYPE_NORMAL
- en: We mark the `enum` as Blueprint-available using the `BlueprintType` specifier.
  prefs: []
  type: TYPE_NORMAL
- en: The `enum` declaration is just the same as we would use in any other context.
  prefs: []
  type: TYPE_NORMAL
- en: Our `Tree` requires a `TreeType`. Because *tree has tree-type* is the relationship
    we want to embody, we include an instance of `TreeType` in our `Tree` class.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, we need to use `UPROPERTY()` to make the member variable accessible
    to the reflection system.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `BlueprintReadWrite` specifier to mark the property as having both
    get and set support within Blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerated types require being wrapped in the `TEnumAsByte` template when used
    in `UPROPERTY`, so we declare an instance of `TEnumAsByte<TreeType>` as the Tree's
    `Type` variable.
  prefs: []
  type: TYPE_NORMAL
- en: The constructor changes for `Tree` are simply the standard load and initialize
    our static mesh component preamble that's used in other recipes.
  prefs: []
  type: TYPE_NORMAL
- en: We create a Blueprint that inherits from our `Tree` class so that we can demonstrate
    the Blueprint-accessibility of the `TreeType enum`.
  prefs: []
  type: TYPE_NORMAL
- en: To have the Blueprint assign a type to the tree at random when we create an
    instance, we need to use the Construction Script Blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: Within the Construction Script, we calculate the number of entries in the `TreeType
    enum`.
  prefs: []
  type: TYPE_NORMAL
- en: We generate a random number and use that as an index in the `TreeType enum`
    type to retrieve a value to store as our `Type`.
  prefs: []
  type: TYPE_NORMAL
- en: The Random number node, however, returns integers. Enumerated types are treated
    as bytes in Blueprint, so we need to use a `ToByte` node, which can then be implicitly
    converted by Blueprint into an `enum` value.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have Construction Script assigning a type to our tree instances
    as they are created, we need to display the tree's type at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: We do so with the graph attached to the `BeginPlay` event within the Event Graph
    tab.
  prefs: []
  type: TYPE_NORMAL
- en: To display text on screen, we use a `Print String` node.
  prefs: []
  type: TYPE_NORMAL
- en: To perform string substitution and print our type out as a human-readable string,
    we use the `Format Text` node.
  prefs: []
  type: TYPE_NORMAL
- en: The `Format Text` node takes terms enclosed in curly braces and allows you to
    substitute other values for those terms by returning the final string.
  prefs: []
  type: TYPE_NORMAL
- en: To substitute our `Type` into the `Format Text` node, we need to convert our
    variable stores from the `enum` value into the actual name of the value.
  prefs: []
  type: TYPE_NORMAL
- en: We can do so by accessing our `Type` variable and then using the `Enum to Name`
    node.
  prefs: []
  type: TYPE_NORMAL
- en: '`Names`, or `FNames` in native code, are a type of variable that can be converted
    into strings by Blueprint so that we can connect our `Name` to the input on the
    `Format Text` node.'
  prefs: []
  type: TYPE_NORMAL
- en: When we hit Play, the graph executes, retrieving the type of tree instances
    that have been placed in the level and printing the names to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Editing class properties in different places in the editor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When developing with Unreal, it is common for programmers to implement properties
    on Actors or other objects in C++, and make them visible in the editor for designer
    use. However, sometimes, it makes sense to view a property, or make it editable,
    but only on the object's default state. Sometimes, the property should only be
    modifiable at runtime with the default specified in C++. Fortunately, there are
    some specifiers that can help us restrict when a property is available.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new `Actor` class in the editor called `PropertySpecifierActor`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1181d0a4-74a1-4ab3-ac08-773bf590a75a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Add the following property definitions to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Perform a Save, Compile your code, and launch the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new blueprint based on the class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the blueprint and look at the Class Defaults section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/04d585d0-842c-4de5-b9da-731758e27c2b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Note which properties are editable and visible under the Property Specifier
    Actor section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1d639038-43e2-4ee8-abff-36f3ec2afa6b.png)'
  prefs: []
  type: TYPE_IMG
- en: Location of the Property Specifier Actor
  prefs: []
  type: TYPE_NORMAL
- en: 'Place instances in the level and view their Details panels:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/16d4fe8b-9f98-40b7-96de-36f7d1188c15.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that a different set of properties is editable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When specifying `UPROPERTY`, we can indicate where we want that value to be
    available inside the Unreal editor.
  prefs: []
  type: TYPE_NORMAL
- en: '`Visible*` prefixes indicate that the value is viewable in the Details panel
    for the indicated object. The value won''t be editable, however.'
  prefs: []
  type: TYPE_NORMAL
- en: This doesn't mean that the variable is a `const` qualifier; however, native
    code can change the value, for instance.
  prefs: []
  type: TYPE_NORMAL
- en: '`Edit*` prefixes indicate that the property can be altered within the Details
    panels inside the editor.'
  prefs: []
  type: TYPE_NORMAL
- en: '`InstanceOnly` as a suffix indicates that the property will only be displayed
    in the Details panels for instances of your class that have been placed into the
    game. They won''t be visible in the Class Defaults section of the Blueprint editor,
    for example.'
  prefs: []
  type: TYPE_NORMAL
- en: '`DefaultsOnly` is the inverse of `InstanceOnly` – `UPROPERTY` will only display
    in the Class Defaults section, and can''t be viewed on individual instances within
    the level.'
  prefs: []
  type: TYPE_NORMAL
- en: The suffix `Anywhere` is the combination of the two previous suffixes – the
    `UPROPERTY` will be visible in all the Details panels that inspect either the
    object's defaults or a particular instance in the level.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned previously, if you are interested in learning more about Property
    Specifiers, check out the following link: [https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/Reference/Properties/Specifiers](https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/Reference/Properties/Specifiers).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe makes the property in question visible in the inspector, but doesn't
    allow the property to be referenced in the actual Blueprint Event Graph. See the
    following recipe for a description of how to make that possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making properties accessible in the Blueprint editor graph
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The specifiers we mentioned in the previous recipe are all well and good, but
    they only control the visibility of `UPROPERTY` in the Details panel. By default,
    even with those specifiers used appropriately, `UPROPERTY` won't be viewable or
    accessible in the actual editor graph for use at `runtime.Other` specifiers, which
    can optionally be used in conjunction with the ones in the previous recipe so
    that you can interact with properties in the Event Graph.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new `Actor` class called `BlueprintPropertyActor` using the editor
    wizard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/40067092-2b56-401c-8825-8bfea89f5019.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Add the following `UPROPERTY` to the class using Visual Studio:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Perform a Save, Compile your project, and start the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Blueprint class based on your `BlueprintPropertyActor` and open its
    graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the My Blueprint panel, click on the eye icon to the right of the Search
    bar. From there, select Show Inherited Variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/04be7b53-3abc-4b96-91df-41feeef6a5b6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Verify that the properties are visible under the Cookbook category in the Variables
    section of the My Blueprint panel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bba20056-25a1-4ae7-90cf-639c18d06265.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Left-click and drag the `ReadWriteProperty` variable into the Event Graph.
    Then select Get ReadWriteProperty:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5ba2bbaf-baa3-48ca-ab9c-c7c14d66d450.png)'
  prefs: []
  type: TYPE_IMG
- en: Repeat the previous step, but instead select Set ReadWriteProperty.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag the ReadOnly property into the graph and note that the SET node is disabled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b43adb75-6bdf-41e5-b6ec-2d103fb65f05.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`BlueprintReadWrite` as a `UPROPERTY` specifier indicates to the Unreal Header
    Tool that the property should have both `Get` and `Set` operations exposed for
    use in Blueprints.'
  prefs: []
  type: TYPE_NORMAL
- en: '`BlueprintReadOnly` is, as the name implies, a specifier that only allows Blueprint
    to retrieve the value of the property; never set it.'
  prefs: []
  type: TYPE_NORMAL
- en: '`BlueprintReadOnly` can be useful when a property is set by native code, but
    should be accessible within Blueprint.'
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that `BlueprintReadWrite` and `BlueprintReadOnly` don't specify
    anything about the property being accessible in the Details panels or the My Blueprint
    section of the editor: these specifiers only control the generation of the getter/setter
    nodes for use in Blueprint graphs.
  prefs: []
  type: TYPE_NORMAL
- en: Responding to property changed events from the editor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a designer changes the properties of an `Actor` placed in the level, it
    is often important to show any visual results of that change immediately rather
    than just when the level is simulated or played. When changes are made using the
    Details panels, there's a special event that the editor emits called `PostEditChangeProperty`,
    which gives the class instance a chance to respond to the property being edited.
    This recipe shows you how to handle `PostEditChangeProperty` for immediate in-editor
    feedback.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new `Actor` called `PostEditChangePropertyActor` based on `StaticMeshActor`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/45976a36-1621-403c-973b-afa3c859cabe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Add the following `UPROPERTY` and function definition to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the class constructor by adding the following code to the `PostEditChangePropertyActor.cpp`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement `PostEditChangeProperty`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Compile your code and launch the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag an instance of your class into the game world and verify that toggling
    the Boolean value for `ShowStaticMesh` toggles the visibility of the mesh in the editor
    viewport:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/dba850f4-0119-4dac-85a7-e24f6a9e78f0.png)'
  prefs: []
  type: TYPE_IMG
- en: The location of the Show Static Mesh property
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, if you ever toggle it off, you''ll see the object disappear, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/340c8760-1eda-48ab-91fd-99f5034777b0.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We create a new `Actor` based on `StaticMeshActor` for easy access to a visual
    representation via the Static Mesh.
  prefs: []
  type: TYPE_NORMAL
- en: '`UPROPERTY` is added to give us a property to change, which causes `PostEditChangeProperty`
    events to be triggered.'
  prefs: []
  type: TYPE_NORMAL
- en: '`PostEditChangeProperty` is a virtual function that''s defined in `Actor`.'
  prefs: []
  type: TYPE_NORMAL
- en: As a result, we override the function in our class.
  prefs: []
  type: TYPE_NORMAL
- en: Within our class constructor, we initialize our mesh as usual, and set the default
    state of our `bool` property to match the visibility of the component it controls.
  prefs: []
  type: TYPE_NORMAL
- en: Inside `PostEditChangeProperty`, we first check that the property is valid.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming it is, we retrieve the name of the property using `GetFName()`.
  prefs: []
  type: TYPE_NORMAL
- en: '`FNames` are stored internally by the engine as a table of unique values.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to use the `GET_MEMBER_NAME_CHECKED` macro. The macro takes a
    number of parameters.
  prefs: []
  type: TYPE_NORMAL
- en: The first one is the name of the class to check, while the second parameter
    is the property to check the class for.
  prefs: []
  type: TYPE_NORMAL
- en: The macro will, at compile-time, verify that the class contains the member specified
    by name.
  prefs: []
  type: TYPE_NORMAL
- en: We compare the class member name that the macro returns against the name that
    our property contains.
  prefs: []
  type: TYPE_NORMAL
- en: If they are the same, then we verify that our `StaticMeshComponent` is initialized
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: If it is, we set its visibility to match the value of our `ShowStaticMesh` Boolean.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a native code Construction Script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within Blueprint, a Construction Script is an Event Graph that runs any time
    a property is changed on the object it is attached to – whether it's being dragged
    in the editor viewport or changed via a direct entry in a Details panel. Construction
    Scripts allow the object in question to *rebuild* itself based on its new location,
    for instance, or to change the components it contains based on user-selected options.
    When coding in C++ with Unreal Engine, the equivalent concept is the `OnConstruction`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new `Actor` called `OnConstructionActor` based on `StaticMeshActor`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e5a597b2-f38a-4fbf-9095-db45235e8c34.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Update the header file to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Go to the implementation file (`OnConstructionActor.cpp`) and implement the
    class constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement `OnConstruction`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Compile your code and launch the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag an instance of your class into the game world, and verify that toggling
    the Boolean value for `ShowStaticMesh` toggles the visibility of the mesh in the
    editor viewport:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0e5c8d54-687b-45bc-adb7-19163d4c24b0.png)'
  prefs: []
  type: TYPE_IMG
- en: '`OnConstruction` does not currently run for C++ actors that are placed in a
    level if they are moved.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To test this, place a breakpoint in your `OnConstruction` function, and then
    move your actor around the level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To place a breakpoint, place your cursor on the desired line and hit *F9* in
    Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: You'll notice that the function doesn't get called, but if you toggle the `ShowStaticMesh`
    Boolean, it does, causing your breakpoint to trigger.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To see why, take a look at the beginning of the `AActor::PostEditMove` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The top line here casts `UClass` for the current object to `UBlueprint`, and
    will only run the construction scripts and `OnConstruction` again if the class
    is a Blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We create a new Actor based on `StaticMeshActor` for easy access to a visual
    representation via the Static Mesh.
  prefs: []
  type: TYPE_NORMAL
- en: '`UPROPERTY` is added to give us a property to change, which causes `PostEditChangeProperty`
    events to be triggered.'
  prefs: []
  type: TYPE_NORMAL
- en: '`OnConstruction` is a virtual function that''s defined in Actor.'
  prefs: []
  type: TYPE_NORMAL
- en: As a result, we override the function in our class.
  prefs: []
  type: TYPE_NORMAL
- en: Within our class constructor, we initialize our mesh as usual, and set the default
    state of our `bool` property to match the visibility of the component that it
    controls.
  prefs: []
  type: TYPE_NORMAL
- en: Inside `OnConstruction`, the actor rebuilds itself using any properties that
    are required to do so.
  prefs: []
  type: TYPE_NORMAL
- en: For this simple example, we set the visibility of the mesh to match the value
    of our `ShowStaticMesh` property.
  prefs: []
  type: TYPE_NORMAL
- en: This could also be extended to changing other values based on the value of the
    `ShowStaticMesh` variable.
  prefs: []
  type: TYPE_NORMAL
- en: You'll note that we don't explicitly filter on a particular property being changed,
    like the previous recipe does with `PostEditChangeProperty`.
  prefs: []
  type: TYPE_NORMAL
- en: The `OnConstruction` script runs in its entirety for every property that gets
    changed on the object.
  prefs: []
  type: TYPE_NORMAL
- en: It has no way of testing which property was just edited, so you need to be judicious
    about placing computationally intensive code within it.
  prefs: []
  type: TYPE_NORMAL
