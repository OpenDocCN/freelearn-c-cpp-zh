- en: 'Integrating C++ and the Unreal Editor: Part I'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成 C++ 和 Unreal 编辑器：第一部分
- en: 'In this chapter, we will cover following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Using a class or struct as a  Blueprint variable
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类或结构体作为蓝图变量
- en: Creating classes or structs that can be subclassed in Blueprint
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可以在蓝图中继承的类或结构体
- en: Creating functions that can be called in Blueprint
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可以在蓝图中调用的函数
- en: Creating events that can be implemented in Blueprint
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可以在蓝图中实现的函数
- en: Exposing multi-cast delegates to Blueprint
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将多播委托公开给蓝图
- en: Creating C++ enums that can be used in Blueprint
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可以在蓝图中使用的 C++ 枚举
- en: Editing class properties in different places in the editor
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编辑器中的不同位置编辑类属性
- en: Making properties accessible in the Blueprint editor graph
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使属性在蓝图编辑器图中可访问
- en: Responding to property changed events from the editor
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应来自编辑器的属性更改事件
- en: Implementing a native code Construction Script
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现原生代码构建脚本
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: One of Unreal's primary strengths is that it provides programmers with the ability
    to create Actors and other objects that can be customized or used by designers
    in the editor. This chapter shows you how to do this. Following that, we will
    try to customize the editor by creating custom Blueprint and Animation nodes from
    scratch. We will also implement custom editor windows and custom Details panels
    to inspect the Types that are created by users.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal 的主要优势之一是它为程序员提供了创建可以由编辑器中的设计师自定义或使用的 Actor 和其他对象的能力。本章将向您展示如何做到这一点。之后，我们将尝试通过从头创建自定义蓝图和动画节点来自定义编辑器。我们还将实现自定义编辑器窗口和自定义详细信息面板来检查用户创建的类型。
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires the use of Unreal Engine 4 and uses Visual Studio 2017
    as the IDE. Instructions on how to install both pieces of software and their requirements
    can be found in [Chapter 1](4adb307e-d86f-4d70-b6de-a0893102d1cf.xhtml), *UE4
    Development Tools*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要使用 Unreal Engine 4，并使用 Visual Studio 2017 作为 IDE。有关如何安装这两款软件及其要求的说明，请参阅[第
    1 章](4adb307e-d86f-4d70-b6de-a0893102d1cf.xhtml)，*UE4 开发工具*。
- en: Using a class or struct as a blueprint variable
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类或结构体作为蓝图变量
- en: Types that you declare in C++ do not automatically get incorporated into Blueprint
    for use as variables. This recipe shows you how to make them accessible so that
    you can use custom native code types as Blueprint function parameters.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中声明的类型不会自动集成到蓝图中作为变量使用。本食谱向您展示如何使它们可访问，以便您可以使用自定义原生代码类型作为蓝图函数参数。
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a new class using the editor. Unlike previous chapters, we are going
    to create an `Object`-based class. `Object` isn''t visible in the default list
    of common classes, so we need to tick the Show All Classes button in the editor
    UI, then select Object. Afterward, click on the Next button:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用编辑器创建一个新类。与前面的章节不同，我们将创建一个基于 `Object` 的类。`Object` 在默认的常用类列表中不可见，因此我们需要在编辑器
    UI 中勾选显示所有类按钮，然后选择 Object。之后，点击下一步按钮：
- en: '![](img/97bdcafe-9d31-4b14-a8e4-afda49cd46d7.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/97bdcafe-9d31-4b14-a8e4-afda49cd46d7.png)'
- en: 'Name your new Object subclass `TileType` and then click on the Create Class
    button:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的新对象子类命名为 `TileType`，然后点击创建类按钮：
- en: '![](img/bb2c7553-314d-4c9a-af49-5814ac547b50.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bb2c7553-314d-4c9a-af49-5814ac547b50.png)'
- en: 'Add the following properties to the `TileType` definition:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下属性添加到 `TileType` 定义中：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Compile your code.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译您的代码。
- en: 'Inside the editor, create a new Blueprint class based on `Actor`. Call it `Tile`:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器内部，基于 `Actor` 创建一个新的蓝图类，命名为 `Tile`：
- en: '![](img/3a50d41d-8514-4f0f-af7e-6129a0374c88.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3a50d41d-8514-4f0f-af7e-6129a0374c88.png)'
- en: 'Within the blueprint editor for `Tile`, add a new variable to Blueprint by
    going to the My Blueprint section and moving down to the Variables section and
    then hitting the + button. The Details panel on the right-hand side of the screen
    will then fill up with information about this new variable, including what type
    it is. Check the list of types that you can create as variables under the Variable
    Type property, and verify that `TileType` is not there:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Tile` 的蓝图编辑器中，通过转到我的蓝图部分，然后移动到变量部分并点击 + 按钮，向蓝图添加一个新变量。屏幕右侧的详细信息面板将填充有关此新变量的信息，包括其类型。检查变量类型属性下可以创建为变量的类型列表，并验证
    `TileType` 是否不在其中：
- en: '![](img/930a3f71-eaba-4f0c-9416-39c8cd3f517c.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/930a3f71-eaba-4f0c-9416-39c8cd3f517c.png)'
- en: 'Return to Visual Studio and open up the `TileType.h` file. Add `BlueprintType`
    to the `UCLASS` macro, as follows:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回 Visual Studio 并打开 `TileType.h` 文件。将 `BlueprintType` 添加到 `UCLASS` 宏中，如下所示：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Save your script, return to the editor and recompile the project, then return
    to the `Tile` blueprint editor.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存您的脚本，返回到编辑器并重新编译项目，然后返回到 `Tile` 蓝图（Blueprint）编辑器。
- en: 'Now, when you add a new variable to your actor, you can select `TileType` as
    the type for your new variable:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当您向您的演员添加新变量时，您可以将 `TileType` 作为您新变量的类型选择：
- en: '![](img/f84aea2a-98c2-4c81-8379-494983245449.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f84aea2a-98c2-4c81-8379-494983245449.png)'
- en: You can now change the Variable Name to something better, such as `MyTileType`.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在可以将变量名更改为更好的名称，例如 `MyTileType`。
- en: We've now established a *has-a* relationship between `Tile` and `TileType`.
    Now, `TileType` is a Blueprint type that can be used as a function parameter.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在在 `Tile` 和 `TileType` 之间建立了一个 *has-a* 关系。现在，`TileType` 是一个可以作为函数参数使用的蓝图（Blueprint）类型。
- en: 'To do this, go to the My Blueprint section and scroll down to the Functions
    section. From there, you can click on the + button to create a new function. Name
    this new function `SetTileType`:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要这样做，请转到 My Blueprint 部分，并滚动到函数部分。从那里，您可以点击 + 按钮创建一个新函数。将这个新函数命名为 `SetTileType`：
- en: '![](img/4f058424-18ef-43d7-8b36-2b7664febb9b.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4f058424-18ef-43d7-8b36-2b7664febb9b.png)'
- en: 'Once the function has been created, the Details tab will display information
    about the function itself. Under the Inputs section, click on the + button to
    add a new input:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数创建后，详细信息选项卡将显示有关函数本身的信息。在输入部分下，点击 + 按钮添加一个新输入：
- en: '![](img/a885d752-02c3-406c-8f94-d267d00535c6.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a885d752-02c3-406c-8f94-d267d00535c6.png)'
- en: 'Once selected, you''ll be able to give the variable a name and select the type
    from the dropdown that, by default, says `Boolean`. Set the input parameter''s
    type to `TileType`:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦选择，您将能够给变量命名并从默认显示为 `Boolean` 的下拉菜单中选择类型。将输入参数的类型设置为 `TileType`：
- en: '![](img/dca37210-53ef-4160-87e5-6439c6247fa8.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dca37210-53ef-4160-87e5-6439c6247fa8.png)'
- en: 'Once you do this, you''ll see that the parameter has been added as an input
    to the Set Tile Type function in Blueprints:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这样做，您会看到参数已被添加到蓝图（Blueprint）中的设置瓷砖类型（Set Tile Type）函数的输入中：
- en: '![](img/6821f604-caf0-4c04-8074-0ae193b002ea.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6821f604-caf0-4c04-8074-0ae193b002ea.png)'
- en: 'Go back to the My Blueprint section and drag and drop the `MyTileType` variable
    onto the Set Tile Type graph, next to the first node. You can drag your `Type`
    variable into the viewport and select Set MyTileType:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到 My Blueprint 部分，将 `MyTileType` 变量拖放到设置瓷砖类型（Set Tile Type）图旁边，紧挨着第一个节点。您可以将您的
    `Type` 变量拖放到视图中，并选择设置 MyTileType：
- en: '![](img/3b1d3861-9389-4e2e-aea7-5d96da0a0e5b.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3b1d3861-9389-4e2e-aea7-5d96da0a0e5b.png)'
- en: 'Now that we have the two nodes we need, connect the Exec output pin to the
    input of the Set MyTileType node and then connect the parameter from `SetTileType`
    to the Set node:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了所需的两个节点，将 Exec 输出引脚连接到设置 MyTileType 节点的输入，然后将 `SetTileType` 的参数连接到设置节点：
- en: '![](img/44e78dd9-47fe-4cc1-bd19-960caa91ba82.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/44e78dd9-47fe-4cc1-bd19-960caa91ba82.png)'
- en: How it works...
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: For performance reasons, Unreal assumes that classes do not require the extra
    reflection code that is needed to make the type available to Blueprint.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于性能原因，Unreal 假设类不需要额外的反射代码，这些代码是使类型在蓝图（Blueprint）中可用的。
- en: We can override this default by specifying `BlueprintType` in our `UCLASS` macro.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在 `UCLASS` 宏中指定 `BlueprintType` 来覆盖此默认设置。
- en: With the specifier included, the type is now made available as a parameter or
    variable in Blueprint and can be used in all the same ways that default types
    can.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 包含指定符后，类型现在作为参数或变量在蓝图（Blueprint）中可用，并且可以像默认类型一样使用。
- en: There's more...
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This recipe shows that you can use a type as a function parameter in Blueprint
    if its native code declaration includes `BlueprintType`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方表明，如果其本地代码声明包含 `BlueprintType`，您可以在蓝图（Blueprint）中使用类型作为函数参数。
- en: However, at the moment, none of the properties that we defined in C++ are accessible
    to Blueprint.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，目前，我们在 C++ 中定义的属性都无法在蓝图（Blueprint）中访问。
- en: Other recipes in this chapter deal with making those properties accessible so
    that we can actually do something meaningful with our custom objects.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的其他配方涉及使这些属性可访问，以便我们实际上可以用我们的自定义对象做一些有意义的事情。
- en: Creating classes or structs that can be subclassed in Blueprint
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在蓝图（Blueprint）中可以继承的类或结构体
- en: While this book focuses on C++, when developing with Unreal a more standard
    workflow is to implement core gameplay functionality as well as performance-critical
    code in C++, and expose those features to Blueprint to allow designers to prototype
    gameplay, which can then be refactored by programmers with additional Blueprint
    features, or pushed back down to the C++ layer. One of the most common tasks,
    then, is to **mark up** our classes and structs in such a way that they are visible
    to the Blueprint system.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这本书主要关注C++，但在使用Unreal开发时，更标准的流程是在C++中实现核心游戏功能以及性能关键代码，并将这些功能暴露给蓝图，以便设计师可以原型化游戏玩法，然后程序员可以使用额外的蓝图功能对其进行重构，或者将其推回到C++层。因此，最常见的任务之一就是以某种方式标记我们的类和结构，使它们对蓝图系统可见。
- en: How to do it...
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a new C++ class derived from the `Actor` class using the editor wizard;
    name it `BaseEnemy`:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用编辑器向导创建一个从`Actor`类派生的新的C++类；命名为`BaseEnemy`：
- en: '![](img/ae20069a-adfb-4955-b837-b70770fa206b.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ae20069a-adfb-4955-b837-b70770fa206b.png)'
- en: 'Add the following `UPROPERTY` to the class:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下`UPROPERTY`添加到类中：
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add the following class specifier to the `UCLASS` macro:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下类指定符添加到`UCLASS`宏中：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Save and then compile the script.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并编译脚本。
- en: 'Open the editor and create a new blueprint class. Expand the All Classes list
    to show all of the classes and select our `BaseEnemy` class as the parent. Afterward,
    click on the Select button:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开编辑器并创建一个新的蓝图类。展开所有类列表以显示所有类，并将我们的`BaseEnemy`类作为父类选择。之后，点击选择按钮：
- en: '![](img/21397387-9ab2-4a72-b976-7f2e71fc8f7b.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/21397387-9ab2-4a72-b976-7f2e71fc8f7b.png)'
- en: Name the new Blueprint `EnemyGoblin` and open it in the Blueprint editor.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的蓝图命名为`EnemyGoblin`并在蓝图编辑器中打开它。
- en: Note that the `UPROPERTY` macros we created earlier still aren't there because
    we haven't included the appropriate markup to make them visible to Blueprint.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们之前创建的`UPROPERTY`宏仍然不存在，因为我们还没有包含适当的标记使它们对蓝图可见。
- en: How it works...
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The previous recipe demonstrated the use of `BlueprintType` as a class specifier.
    `BlueprintType` allows the type to be used as a type within the Blueprint editor
    (that is, it can be a variable or a function input/return value).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的配方演示了将`BlueprintType`用作类指定符的使用。`BlueprintType`允许类型在蓝图编辑器中使用（即，它可以是一个变量或函数输入/返回值）。
- en: However, we may want to create blueprints based on our type (using inheritance)
    rather than composition (placing an instance of our type inside an `Actor`, for
    example).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可能希望根据我们的类型（使用继承）而不是组合（例如，在`Actor`中放置我们的类型的实例）来创建蓝图。
- en: This is why Epic provided `Blueprintable` as a class specifier. `Blueprintable`
    means a developer can mark a class as inheritable by Blueprint classes.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么Epic提供了`Blueprintable`作为类指定符。`Blueprintable`意味着开发者可以将一个类标记为可以被蓝图类继承。
- en: We have both `BlueprintType` and `Blueprintable` instead of a single combined
    specifier because sometimes you may only want to expose a partial functionality.
    For example, certain classes should be usable as variables, but performance reasons
    forbid creating them in Blueprint. In that instance, you would use `BlueprintType`
    rather than both specifiers.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有`BlueprintType`和`Blueprintable`而不是单个组合指定符，因为有时你可能只想暴露部分功能。例如，某些类应该可以作为变量使用，但出于性能原因，不允许在蓝图中创建它们。在这种情况下，你会使用`BlueprintType`而不是两个指定符。
- en: On the other hand, perhaps we want to use the Blueprint editor to create new
    subclasses, but we don't want to pass object instances around inside the `Actor`
    blueprints. It is recommended you use `Blueprintable`, but omit `BlueprintType`
    in this case.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，也许我们想使用蓝图编辑器来创建新的子类，但又不希望在`Actor`蓝图内部传递对象实例。在这种情况下，建议使用`Blueprintable`，但省略`BlueprintType`。
- en: Like before, neither `Blueprintable` nor `BlueprintType` specify anything about
    the member functions or member variables contained inside our class. We'll make
    those available in later recipes.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，`Blueprintable`和`BlueprintType`都没有指定我们类中包含的成员函数或成员变量。我们将在后面的配方中使它们可用。
- en: Creating functions that can be called in Blueprint
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建可以在蓝图中调用的函数
- en: While marking classes as `BlueprintType` or `Blueprintable` allows us to pass
    instances of the class around in Blueprint, or to subclass the type with a Blueprint
    class, those specifiers don't actually say anything about member functions or
    variables, and whether they should be exposed to Blueprint. This recipe shows
    you how to mark a function so that it can be called within Blueprint graphs.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当将类标记为`BlueprintType`或`Blueprintable`时，允许我们在蓝图之间传递类的实例，或者使用蓝图类来子类化类型，但这些指定符实际上并没有说关于成员函数或变量的事情，以及它们是否应该暴露给蓝图。这个食谱展示了如何标记一个函数，以便它可以在蓝图图中被调用。
- en: How to do it...
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Create a new C++ class derived from the `StaticMeshActor` class using the editor
    wizard; call it `SlidingDoor`.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用编辑器向导创建一个从`StaticMeshActor`类派生的新的C++类；命名为`SlidingDoor`。
- en: 'Add the following text that''s in bold to the new class:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新类中添加以下粗体文本：
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create the class implementation by adding the following text in bold to the
    `.cpp` file:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在`.cpp`文件中添加以下粗体文本来创建类实现：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Compile your code and launch the editor.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译你的代码并启动编辑器。
- en: 'Drag a copy of your door out into the level:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的门拖到级别中：
- en: '![](img/7f1a01da-e630-4133-93f7-0a7381a4b1fd.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7f1a01da-e630-4133-93f7-0a7381a4b1fd.png)'
- en: An easy way to have objects *fall* to the ground is by using the End key with
    the object you want to drop selected.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要让对象*下落*到地面，可以通过使用对象选择器上的End键来实现。
- en: 'Make sure you have your `SlidingDoor` instance selected, then open the Level
    blueprint by going to Blueprints | Open Level Blueprint. Right-click on the empty
    canvas and expand Call function on Sliding  Door 1:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你已选择你的`SlidingDoor`实例，然后通过转到蓝图 | 打开级别蓝图来打开级别蓝图。在空画布上右键单击并展开“Sliding Door 1”上的调用函数：
- en: '![](img/0b59687a-998c-4e30-99cb-1112f5ef746e.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0b59687a-998c-4e30-99cb-1112f5ef746e.jpg)'
- en: 'Expand the Door section and then select the `Open` function:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开门部分，然后选择“打开”函数：
- en: '![](img/2e0152ed-e212-411e-a05f-a50e2c0c1a0c.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2e0152ed-e212-411e-a05f-a50e2c0c1a0c.jpg)'
- en: 'Link the execution pin (white arrow) from Event BeginPlay to the white arrow
    on the `Open` node, as shown in the following screenshot:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将执行引脚（白色箭头）从“事件开始播放”链接到“打开”节点上的白色箭头，如图下截图所示：
- en: '![](img/8d197815-24a8-4c76-a565-e4c8c4a06e09.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8d197815-24a8-4c76-a565-e4c8c4a06e09.png)'
- en: 'Play your level and verify that the door moves up as expected when `Open` is
    invoked on your door instance:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放你的级别并验证当在门实例上调用`Open`时，门是否按预期向上移动：
- en: '![](img/e844796d-e944-4409-9136-09e03f95fa99.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e844796d-e944-4409-9136-09e03f95fa99.jpg)'
- en: How it works...
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Within the declaration of the door, we create a new function for opening the
    door, a Boolean to track whether the door has been told to open, and a vector
    allowing us to precompute the target location of the door.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在门的声明中，我们创建了一个新的开门函数，一个布尔值用于跟踪门是否被指示打开，以及一个向量允许我们预先计算门的目标位置。
- en: We also override the `Tick` actor function so that we can perform some behavior
    on every frame.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还重写了`Tick`演员函数，以便我们可以在每一帧执行一些行为。
- en: Within the constructor, we load in the cube mesh and scale it to represent our
    door.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们加载立方体网格并将其缩放以表示我们的门。
- en: We also set `IsOpen` to a known good value of `false` and enable actor ticking
    by using `bCanEverTick` and `bStartWithTickEnabled`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将`IsOpen`设置为已知的良好值`false`，并使用`bCanEverTick`和`bStartWithTickEnabled`启用演员计时。
- en: These two Booleans control whether ticking can be enabled for this actor and
    if ticking starts in an enabled state, respectively.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个布尔值分别控制是否可以为此演员启用计时，以及如果计时以启用状态开始，计时是否启动。
- en: Inside the `Open` function, we calculate the target location that's relative
    to the door's starting position.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Open`函数内部，我们计算相对于门起始位置的目标位置。
- en: We also change the `IsOpen` Boolean from `false` to `true`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将`IsOpen`布尔值从`false`更改为`true`。
- en: Now that the `IsOpen` Boolean is `true`, inside the `Tick` function, the door
    tries to move itself toward the target location using `SetActorLocation` and `Lerp` to
    interpolate between the current location and the destination.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`IsOpen`布尔值为`true`，在`Tick`函数内部，门尝试使用`SetActorLocation`和`Lerp`来在当前位置和目的地之间进行插值，移动自己到目标位置。
- en: See also
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: '[Chapter 5](cf821ef4-8a19-440c-805d-573748b76d5f.xhtml), *Handling Events and
    Delegates*, has a number of recipes relating to the spawning of actors'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第五章](cf821ef4-8a19-440c-805d-573748b76d5f.xhtml)，*处理事件和委托*，包含与演员生成相关的一些食谱'
- en: Creating events that can be implemented in Blueprints
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建可以在蓝图实现的事件
- en: Another way that C++ can be more tightly integrated with Blueprint is through
    the creation of functions that can have Blueprint implementations in native code.
    This allows a programmer to specify an event and invoke it, without needing to
    know anything about the implementation. The class can then be subclassed in Blueprint,
    and another member of the production team can implement a handler for the event
    without ever having to go near a line of C++.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: C++可以更紧密地集成蓝图的另一种方式是通过创建具有蓝图实现的函数。这允许程序员指定一个事件并调用它，而无需了解任何有关实现的信息。然后该类可以在蓝图中被子类化，并且制作团队中的另一名成员可以不接触任何C++代码就实现事件的处理程序。
- en: How to do it...
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Create a new `StaticMeshActor` class called `Spotter`. Remember to use the Show
    All Classes button to select `StaticMeshActor` as the parent class.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Spotter`的新`StaticMeshActor`类。记住使用显示所有类按钮来选择`StaticMeshActor`作为父类。
- en: 'Make sure that the following functions are defined and overridden in the class
    header:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保以下函数在类头中定义并重写：
- en: '[PRE6]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the implementation file (`Spotter.cpp`), update the code to the following:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实现文件（`Spotter.cpp`）中，将代码更新如下：
- en: '[PRE7]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Compile and start the editor. Find your `Spotter` class in Content Browser,
    then left-click and drag a copy out into the game world.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并启动编辑器。在内容浏览器中找到你的`Spotter`类，然后左键单击并拖动一个副本到游戏世界中。
- en: 'When you play the level, you''ll see the red line showing the trace that the
    `Actor` is performing:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你播放级别时，你会看到表示`Actor`执行的红色线条：
- en: '![](img/9914c7d6-45da-4f8f-b9f5-1a67276f9a50.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9914c7d6-45da-4f8f-b9f5-1a67276f9a50.png)'
- en: However, nothing will happen if the player walks in front of it because we haven't
    implemented our `OnPlayerSpotted` event.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，如果玩家站在它前面，什么也不会发生，因为我们还没有实现我们的`OnPlayerSpotted`事件。
- en: To implement this event, we need to create a blueprint subclass of our `Spotter`.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要实现此事件，我们需要创建一个我们的`Spotter`的蓝图子类。
- en: 'Right-click on `Spotter` in the Content Browser and select Create Blueprint
    class based on Spotter. Name the class `BPSpotter`:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在内容浏览器中右键单击`Spotter`，并选择基于Spotter创建蓝图类。将类命名为`BPSpotter`：
- en: '![](img/75939870-ef59-44a6-b9fa-38b3e8635a19.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/75939870-ef59-44a6-b9fa-38b3e8635a19.png)'
- en: Creating a Blueprint class based on Spotter
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Spotter创建蓝图类
- en: 'Inside the Blueprint editor, click on the Override button in the Functions
    section of the My Blueprint panel:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在蓝图编辑器中，点击我的蓝图面板功能区域中的覆盖按钮：
- en: '![](img/8f457866-8e37-4655-9abc-650ec2e5e8af.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8f457866-8e37-4655-9abc-650ec2e5e8af.png)'
- en: 'Select On Player Spotted:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择玩家被看到：
- en: '![](img/1e41605e-623d-40fb-844c-b47593bb12fe.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1e41605e-623d-40fb-844c-b47593bb12fe.png)'
- en: 'To see the event, click on the Event Graph tab. Left-click it and drag it away
    from the white execution pin on our event. In the context menu that appears, select
    and add a `Print String` node so that it is linked to the event:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看事件，请点击事件图标签。左键单击它并将其从事件上的白色执行引脚拖离。在出现的上下文菜单中，选择并添加一个`Print String`节点，使其与事件链接：
- en: '![](img/e38c3014-8e80-4e2a-9787-ceb994895a6e.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e38c3014-8e80-4e2a-9787-ceb994895a6e.png)'
- en: 'Delete your previous Spotter object in the level and then drag and drop a `BPSpotter`
    in. Play the level again and verify that walking in front of the trace that the
    `BPSpotter` is using now prints a string to the screen:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在级别中删除你的上一个Spotter对象，然后拖放一个`BPSpotter`。再次播放级别并验证现在使用`BPSpotter`的跟踪行在玩家走过时会打印字符串到屏幕上：
- en: '![](img/96f3cfec-578d-40bb-9af1-1e813185972f.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/96f3cfec-578d-40bb-9af1-1e813185972f.png)'
- en: How it works...
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the constructor for our `Spotter` object, we load one of the basic primitives,
    a cone, into our Static Mesh Component as a visual representation.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Spotter`对象构造函数中，我们将一个基本原语，一个圆锥体，加载到我们的静态网格组件中作为视觉表示。
- en: We then rotate the cone so that it resembles a spotlight pointing to the *X*
    axis of the actor.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后将圆锥体旋转，使其类似于指向演员*x*轴的聚光灯。
- en: During the `Tick` function, we get the actor's location and then find a point
    200 units away from the actor along its local *X* axis. We call the parent class
    implementation of `Tick` using `Super::` to ensure that any other tick functionality
    is preserved, despite our override.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Tick`函数期间，我们获取演员的位置，然后在其局部*x*轴上找到距离演员200个单位的点。我们使用`Super::`调用父类`Tick`的实现，以确保保留任何其他`Tick`功能，尽管我们进行了覆盖。
- en: We convert a local position into a world space position by first acquiring the
    Actor-to-World transform for the `Actor`, then using that to transform a vector
    specifying the position.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过首先获取`Actor`的Actor-to-World转换，然后使用该转换来转换一个指定位置的向量，将局部位置转换为世界空间位置。
- en: The transform is based on the orientation of the root component, which is the
    static mesh component that we rotated during the constructor.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 变换基于根组件的朝向，这是我们在构造函数期间旋转的静态网格组件。
- en: As a result of that existing rotation, we need to rotate the vector we want
    to transform. Given that we want the vector to point out of what was the bottom
    of the cone, we want a distance along the negative up axis; that is, we want a
    vector of the form (0,0,-d), where *d* is the actual distance away.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存在旋转，我们需要旋转我们想要变换的向量。鉴于我们希望向量指向圆锥的底部，我们希望沿着负向上轴有一个距离；也就是说，我们希望有一个形式为（0，0，-d）的向量，其中*d*是实际的距离。
- en: Having calculated our end location for our trace, we actually perform the trace
    with the `SweepSingleByChannel` function.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算出我们的跟踪终点后，我们实际上使用`SweepSingleByChannel`函数执行跟踪。
- en: Once the sweep is performed, we try to cast the resulting hit `Actor` into a
    pawn.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦执行了扫描，我们尝试将结果击中的`Actor`转换为士兵。
- en: If the cast was successful, we invoke our Implementable Event of `OnPlayerSpotted`,
    and the user-defined Blueprint code executes.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果转换成功，我们调用我们的可实施事件`OnPlayerSpotted`，并执行用户定义的蓝图代码。
- en: Exposing multi-cast delegates to Blueprint
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将多播委托暴露给蓝图
- en: Multi-cast delegates are a great way to broadcast an event to multiple objects
    that **listen** or **subscribe** to the event in question. They are particularly
    invaluable if you have a C++ module that generates events that potentially arbitrary
    Actors might want to be notified about. This recipe shows you how to create a
    multi-cast delegate in C++ that can notify a group of other Actors during runtime.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 多播委托是一种向多个可能监听或订阅相关事件的物体广播事件的绝佳方式。如果你有一个生成事件的C++模块，这些事件可能会被任意演员通知，那么它们尤其有价值。这个配方展示了如何在C++中创建一个多播委托，以便在运行时通知一组其他演员。
- en: How to do it...
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a new `StaticMeshActor` class called `King`. Add the following to the
    class header:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`King`的新`StaticMeshActor`类。将以下内容添加到类头文件中：
- en: '[PRE8]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We also want to display something on the screen, so add a definition for a
    constructor:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还希望在屏幕上显示一些内容，因此添加一个构造函数的定义：
- en: '[PRE9]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add a new `UFUNCTION` to the class:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向类中添加一个新的`UFUNCTION`：
- en: '[PRE10]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add an instance of our multicast delegate to the class as well:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的多播委托实例添加到类中：
- en: '[PRE11]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Open the `King.cpp` file and then add in the implementation for the constructor
    to perform our mesh initialization (remembering to add an `#include` for the `ConstructionHelpers.h`
    file):'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`King.cpp`文件，然后添加构造函数的实现以执行我们的网格初始化（记得添加`ConstructionHelpers.h`文件的`#include`）：
- en: '[PRE12]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Implement the `Die` function:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`Die`函数：
- en: '[PRE13]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Create a new class called `Peasant`, also based on `StaticMeshActor`.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Peasant`的新类，也基于`StaticMeshActor`。
- en: 'Declare a default constructor in the class:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中声明默认构造函数：
- en: '[PRE14]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Declare the following function:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明以下函数：
- en: '[PRE15]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Implement the constructor:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现构造函数：
- en: '[PRE16]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Implement the `Flee` function in the `.cpp` file:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`.cpp`文件中实现`Flee`函数：
- en: '[PRE17]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Return to the Unreal Editor and compile your scripts.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回Unreal编辑器并编译你的脚本。
- en: 'Afterward, create a Blueprint class based on `APeasant`. You can do this by
    right-clicking on the `Peasant` object in the Content Browser and then selecting
    Create Blueprint class based on Peasant. Call the new `BPPeasant` class. Afterward,
    click on the Create Blueprint Class button:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，基于`APeasant`创建一个蓝图类。你可以通过在内容浏览器中右键单击`Peasant`对象，然后选择基于Peasant创建蓝图类来完成此操作。将新类命名为`BPPeasant`。之后，单击创建蓝图类按钮：
- en: '![](img/d90c146a-d40e-4b97-ad38-1b4c93c2a64f.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d90c146a-d40e-4b97-ad38-1b4c93c2a64f.png)'
- en: 'Within the Blueprint, click on the Event Graph tab and move upward to the `Event
    BeingPlay` node. Click and drag it away from the white (execution) pin of your
    `BeginPlay` node. Type `get all`, and you should see Get All Actors Of Class.
    Select the node to place it in your graph:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在蓝图内，单击事件图标签，向上移动到`Event BeingPlay`节点。单击并拖动它远离`BeginPlay`节点的白色（执行）引脚。输入`get
    all`，你应该看到获取所有类别的演员。选择节点将其放置在图中：
- en: '![](img/688d8fe5-46f8-4e55-9cbe-814a3c03422c.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/688d8fe5-46f8-4e55-9cbe-814a3c03422c.png)'
- en: 'Set the value of the purple (class) node to `King`. You can type `king` in
    the search bar to make locating the class in the list easier:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将紫色（类）节点的值设置为`King`。你可以在搜索栏中输入`king`，以便更容易地在列表中定位该类：
- en: '![](img/024b2403-c44e-4992-81d0-bf62b0f94269.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/024b2403-c44e-4992-81d0-bf62b0f94269.png)'
- en: 'Drag the blue grid (object array) node out into an empty space and, from the
    Actions menu that pops up, type in the word `get`. From the options that are available,
    select the Get (a copy) option:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将蓝色网格（对象数组）节点拖入一个空白区域，并从弹出的动作菜单中输入单词`get`。从可用的选项中选择获取（副本）选项：
- en: '![](img/4775d89e-250e-4867-879a-5d17ae725240.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4775d89e-250e-4867-879a-5d17ae725240.png)'
- en: 'Drag away from the blue output pin of the get node and place a Not Equal (object)
    node:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从获取节点的蓝色输出引脚拖动，放置一个不等式（对象）节点：
- en: '![](img/f7621e45-e678-460c-a3e5-ef35d2d5ec16.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f7621e45-e678-460c-a3e5-ef35d2d5ec16.png)'
- en: 'Connect the red (bool) pin of the Not Equal node to a `Branch` node, and wire
    the execution pin of `Branch` to our `Get All Actors Of Class` node:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将不等式节点的红色（布尔）引脚连接到`Branch`节点，并将`Branch`的执行引脚连接到我们的`Get All Actors Of Class`节点：
- en: '![](img/57bbbe4c-7469-4ed1-bd16-419682944815.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/57bbbe4c-7469-4ed1-bd16-419682944815.png)'
- en: 'Connect the True pin of the branch to the Bind Event to OnKing Death node:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将分支的True引脚连接到绑定事件到OnKing Death节点：
- en: '![](img/165a3781-c973-477d-b8d5-9f92363d1c15.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/165a3781-c973-477d-b8d5-9f92363d1c15.png)'
- en: Note that you will probably have to untick Context Sensitive in the context
    menu for the Bind Event node to be visible.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您可能需要在上下文菜单中取消选中上下文敏感选项，以便`Bind Event`节点可见。
- en: 'Then, connect the output of the Get node into the Target property of the Bind
    Event to OnKingDeath node:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将获取节点的输出连接到绑定事件到OnKingDeath节点的目标属性：
- en: '![](img/2b0c31ca-100d-40ba-8f2f-bd1ffbe4b584.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2b0c31ca-100d-40ba-8f2f-bd1ffbe4b584.png)'
- en: Connecting the  Get node into the Target property of the Bind Event to OnKingDeath node
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 将“Get”节点连接到绑定事件到OnKingDeath节点的目标属性
- en: If you double-click on a connection, you can create a reroute node that you
    can drag to make it easier to see the connections between nodes.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您双击一个连接，您可以创建一个重路由节点，您可以将其拖动以使其更容易看到节点之间的连接。
- en: 'Drag out the red pin of the Bind Event to OnKingDeath node and select Add Custom
    Event.... Give your event the desired name:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将绑定事件到OnKingDeath节点的红色引脚拖出，并选择“添加自定义事件....”给您的活动取一个期望的名字：
- en: You may need to uncheck the Context Sensitive option to see the Add Custom Event...
    option.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能需要取消选中上下文敏感选项才能看到“添加自定义事件...”选项。
- en: '![](img/bc779546-1339-4875-b6b8-2137e577236c.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bc779546-1339-4875-b6b8-2137e577236c.png)'
- en: Connecting the Custom Event and the Event Binding.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 连接自定义事件和事件绑定。
- en: 'Connect the white execution pin for the Custom Event to a new node named `Flee`,
    which we created back in Step 10:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将自定义事件的白色执行引脚连接到一个名为`Flee`的新节点，这是我们之前在第10步中创建的：
- en: '![](img/f1f23155-2850-4057-8707-9a47724fd8bf.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f1f23155-2850-4057-8707-9a47724fd8bf.png)'
- en: Lastly, drag the Dead King property from the Custom Event into the `Dead King`
    property of the Flee node.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将自定义事件中的Dead King属性拖入Flee节点的`Dead King`属性中。
- en: 'Verify that your Blueprint looks like what''s shown in the following screenshot:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认您的蓝图看起来像以下截图所示：
- en: '![](img/fb6eb322-517f-46c1-910c-d2f09ba30a3a.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fb6eb322-517f-46c1-910c-d2f09ba30a3a.png)'
- en: The completed Blueprint
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的蓝图
- en: 'Drag a copy of your `King` class into the level, and then add a few `BPPeasant`
    instances around it in a circle:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的`King`类的一个副本拖入级别中，然后在其周围添加几个`BPPeasant`实例形成一个圆圈：
- en: '![](img/287e0110-9b2b-4353-8d05-18ad8101bde9.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/287e0110-9b2b-4353-8d05-18ad8101bde9.png)'
- en: 'Open the level Blueprint. Inside it, drag away from `BeginPlay,` and add a
    `Delay` node. Set the delay to 5 seconds:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开级别蓝图。在其内部，从`BeginPlay`拖动，并添加一个`Delay`节点。将延迟设置为5秒：
- en: '![](img/b444ee3f-2178-437e-b940-8a63dd56fa2e.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b444ee3f-2178-437e-b940-8a63dd56fa2e.jpg)'
- en: With your `King` instance that's selected in the level, right-click in the graph
    editor for the Level Blueprint.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在级别中选中您的`King`实例后，在图编辑器中右键单击级别蓝图。
- en: 'Select Call function on King 1 and look in the `King` category for a function
    called `Die`:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在King 1上选择调用函数，然后在`King`类别中查找名为`Die`的函数：
- en: '![](img/287aed93-e6e9-45a3-8ae2-517e3c05e79d.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/287aed93-e6e9-45a3-8ae2-517e3c05e79d.jpg)'
- en: 'Select `Die`, then connect its execution pin to the output execution pin from
    the delay:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`Die`，然后将其执行引脚连接到延迟的输出执行引脚：
- en: '![](img/23c556e5-53bb-4ff5-8dd7-97bb10398bda.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/23c556e5-53bb-4ff5-8dd7-97bb10398bda.png)'
- en: 'When you play your level, you should see that the king dies after 5 seconds:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您玩您的级别时，您应该看到国王在5秒后死亡：
- en: '![](img/b527406e-ae24-4ce9-87d5-1d06077f0ebe.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b527406e-ae24-4ce9-87d5-1d06077f0ebe.png)'
- en: 'Afterward, you should see the peasants all wail and flee directly away from
    the king:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您应该看到农民们都在哭泣并直接逃离国王：
- en: '![](img/9a1cc2a2-35c1-4201-8fb0-a09cb3f069fc.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9a1cc2a2-35c1-4201-8fb0-a09cb3f069fc.png)'
- en: How it works...
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We create a new actor (based on `StaticMeshActor` for convenience, as it saves
    us having to declare or create a Static Mesh component for the `Actor` visual
    representation).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个新的演员（基于`StaticMeshActor`以方便起见，因为它可以节省我们为`Actor`视觉表示声明或创建静态网格组件的时间）。
- en: We declare a dynamic multicast delegate using the `DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam`
    macro. Dynamic multicast delegates allow an arbitrary number of objects to subscribe
    (listen) and unsubscribe (stop listening) so that they will be notified when the
    delegate is broadcast.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam`宏声明一个动态多播委托。动态多播委托允许任意数量的对象订阅（监听）和取消订阅（停止监听），以便在委托被广播时得到通知。
- en: The macro takes a number of arguments – the type name of the new delegate signature
    being created, the type of the signature's parameter, then the name of the signature's
    parameter.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 宏接受多个参数——正在创建的新委托签名类型的名称，签名参数的类型，然后是签名参数的名称。
- en: We also add a function to `King` that will allow us to tell it to die. Because
    we want to expose the function to Blueprints for prototyping, we mark it as `BlueprintCallable`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还向`King`添加了一个函数，允许我们告诉它死亡。因为我们想将此函数暴露给蓝图以进行原型设计，所以我们将其标记为`BlueprintCallable`。
- en: The `DECLARE_DYNAMIC_MULTICAST_DELEGATE` macro that we used earlier only declared
    a type; it didn't declare an instance of the delegate, so we do that now, referencing
    the type name that we provided earlier when invoking the macro.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前使用的`DECLARE_DYNAMIC_MULTICAST_DELEGATE`宏只声明了一个类型；它没有声明委托的实例，所以我们现在这样做，引用我们在调用宏时提供的类型名称。
- en: Dynamic multicast delegates can be marked as `BlueprintAssignable` in their
    `UPROPERTY` declaration. This indicates to Unreal that the Blueprint system can
    dynamically assign events to the delegate that will be called when the delegate's
    `Broadcast` function is called.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 动态多播委托可以在其`UPROPERTY`声明中标记为`BlueprintAssignable`。这表示向Unreal表明蓝图系统可以动态地将事件分配给委托，当委托的`Broadcast`函数被调用时，将调用这些委托。
- en: As always, we assign a simple mesh to our `King` so that it has a visual representation
    in the game scene.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们给我们的`King`分配一个简单的网格，以便它在游戏场景中有视觉表示。
- en: Within the `Die` function, we call `Broadcast` on our own delegate. We specified
    that the delegate would have a parameter that is a pointer to the king which died,
    so we pass this pointer as a parameter to the broadcast function.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Die`函数内部，我们在自己的委托上调用`Broadcast`。我们指定委托将有一个参数，该参数是指向已故国王的指针，因此我们将此指针作为参数传递给广播函数。
- en: If you want the king to be destroyed, rather than playing an animation or other
    effect when it dies, you need to change the delegate's declaration and pass in
    a different type. For example, you could use `FVector`, and simply pass in the
    location of the dead king directly so that the peasants could still flee appropriately.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想让国王被摧毁，而不是在它死亡时播放动画或其他效果，你需要更改委托的声明并传入不同的类型。例如，你可以使用`FVector`，并直接传入死去的国王的位置，这样农民仍然可以适当逃跑。
- en: Without this, you potentially could have a situation where the `King` pointer
    is valid when `Broadcast` is called, but the call to `Actor::Destroy()` invalidates
    it before your bound functions are executed.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 没有这个，你可能会遇到这样的情况：当调用`Broadcast`时，`King`指针是有效的，但在你的绑定函数执行之前，对`Actor::Destroy()`的调用使其无效。
- en: Within our next `StaticMeshActor` subclass, called `Peasant`, we initialize
    the static mesh component as usual using a different shape from the one that we
    used for the `King`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一个`StaticMeshActor`子类中，称为`Peasant`，我们像往常一样初始化静态网格组件，使用与`King`不同的形状。
- en: Inside the implementation of the peasant's `Flee` function, we simulate the
    peasants playing sound by printing a message on the screen.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在农民的`Flee`函数的实现中，我们通过在屏幕上打印消息来模拟农民播放声音。
- en: We then calculate a vector to make the peasants flee by first finding a vector
    from the dead king to this peasant's location.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们计算一个向量，使农民逃跑，首先找到从死去的国王到这个农民位置的一个向量。
- en: We normalize the vector to retrieve a unit vector (with a length of 1) pointing
    in the same direction.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向量归一化以检索一个单位向量（长度为1），指向相同的方向。
- en: Scaling the normalized vector and adding it to our current location calculates
    a position at a fixed distance, in the exact direction for the peasant to be fleeing
    directly away from the dead king.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 缩放归一化向量并将其添加到我们的当前位置，计算出在固定距离和确切方向上的一个位置，这样农民就可以直接逃离死去的国王。
- en: '`SetActorLocation` is then used to actually teleport the peasants to that location.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用`SetActorLocation`来实际将农民传送到那个位置。
- en: If you used a Character with an AI controller, you could have the `Peasant` pathfind
    to the target location rather than teleporting. Alternatively, you could use a `Lerp` function
    that's invoked during the peasant's `Tick` to make them slide smoothly rather
    than jump directly to the location.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用了一个具有AI控制器的角色，你可以让`Peasant`路径找到目标位置而不是传送。或者，你可以使用一个在农民的`Tick`期间调用的`Lerp`函数，使他们平滑滑动而不是直接跳到位置。
- en: See also
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: See [Chapter 4](eade601c-4b55-484a-ba49-0a989d81d7f8.xhtml), *Actors and Components*,
    for more extended discussions about Actors and Components. [Chapter 5](cf821ef4-8a19-440c-805d-573748b76d5f.xhtml),
    *Handling Events and Delegates*, discusses events such as `Notify` and `ActorOverlap`.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅[第4章](eade601c-4b55-484a-ba49-0a989d81d7f8.xhtml)，*演员和组件*，了解更多关于演员和组件的讨论。[第5章](cf821ef4-8a19-440c-805d-573748b76d5f.xhtml)，*处理事件和委托*，讨论了诸如`Notify`和`ActorOverlap`的事件。
- en: Creating C++ enums that can be used in Blueprint
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建在蓝图中使用C++枚举
- en: Enums are commonly used in C++ as flags or inputs to switch statements. However,
    what if you want to pass an `enum` value to or from C++ from a Blueprint? Alternatively,
    if you want to use a `switch` statement in Blueprint that uses an `enum` from
    C++, how do you let the Blueprint editor know that your `enum` should be accessible
    within the editor? This recipe shows you how to make enums visible in Blueprint.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举在C++中常用作标志或输入到switch语句中。然而，如果你想在蓝图中将枚举值传递到或从C++传递，或者如果你想在蓝图中使用一个使用C++枚举的`switch`语句，你该如何让蓝图编辑器知道你的枚举应该在编辑器中可访问？这个配方展示了如何在蓝图中使枚举可见。
- en: How to do it...
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Create a new `StaticMeshActor` class called `Tree` using the editor.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用编辑器创建一个新的名为`Tree`的`StaticMeshActor`类。
- en: 'Insert the following code above the class declaration:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类声明上方插入以下代码：
- en: '[PRE18]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add the following to the `Tree` class:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到`Tree`类中：
- en: '[PRE19]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add the following to the `Tree` constructor:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到`Tree`构造函数中：
- en: '[PRE20]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Return to the Unreal Editor and compile your code.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回Unreal编辑器并编译你的代码。
- en: Create a new Blueprint class called `MyTree`, based on `Tree`, by right-clicking
    on the Tree object and selecting Create Blueprint class based on Tree. Once the
    menu comes up, click on the Create Blueprint Class button.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过右键单击Tree对象并选择基于Tree创建蓝图类来创建一个新的名为`MyTree`的蓝图类。一旦菜单出现，点击创建蓝图类按钮。
- en: Inside the blueprint editor for `MyTree`, click on the Construction Script tab.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MyTree`的蓝图编辑器中，点击构造脚本选项卡。
- en: 'Right-click in the empty window and type `treetype`. There is a Get number
    of entries in TreeType node:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在空窗口中右键单击并输入`treetype`。在TreeType节点中获取条目数：
- en: '![](img/8a5f09a0-43b0-4d0e-852f-f28683ca8a5c.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8a5f09a0-43b0-4d0e-852f-f28683ca8a5c.png)'
- en: 'Where and then connect its Return value output pin to the Max property of a
    new Random Integer node:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后将它的返回值输出引脚连接到新随机整数节点的最大属性：
- en: '![](img/aa62d8f0-eac4-4978-903c-33be135516cc.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/aa62d8f0-eac4-4978-903c-33be135516cc.png)'
- en: 'Connect the Return Value output of the random integer to a ToByte (Integer)
    node:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将随机整数的返回值输出连接到一个ToByte (Integer)节点：
- en: '![](img/e638984a-344d-4bcb-9d28-dc2bbdcfe361.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e638984a-344d-4bcb-9d28-dc2bbdcfe361.png)'
- en: 'In the Variables section of the My Blueprint panel, click on the + button.
    From there, go to the Details tab and set the Variable Type to `Tree Type`. Afterward,
    set the Variable Name to `RandomTree`:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在My Blueprint面板的变量部分，点击+按钮。然后转到详细信息选项卡，将变量类型设置为`Tree Type`。之后，将变量名称设置为`RandomTree`：
- en: '![](img/43c68378-cfe8-4485-8e5f-1a654392ffb4.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/43c68378-cfe8-4485-8e5f-1a654392ffb4.png)'
- en: Drag the RandomTree variable into the graph and select Set Random Tree when
    you see a small context menu appear.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将RandomTree变量拖入图中，当出现一个小上下文菜单时，选择Set Random Tree。
- en: Connect the Return Value output of the `ToByte` node to the input of the SET
    Type node. You'll see an extra conversion node automatically appear.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ToByte`节点的返回值输出连接到SET Type节点的输入。你会看到一个额外的转换节点自动出现。
- en: 'Lastly, connect the execution pin of Construction Script to the SET Type node''s
    execution pin. Your Blueprint should look as follows:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将构造脚本的执行引脚连接到SET Type节点的执行引脚。你的蓝图应该看起来如下：
- en: '![](img/17bd491f-612b-4926-9485-76609cd128da.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/17bd491f-612b-4926-9485-76609cd128da.png)'
- en: To verify that the blueprint is correctly functioning and randomly assigning
    a type to our tree, we are going to add some nodes to the Event Graph.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了验证蓝图是否正确运行并且随机分配类型到我们的树中，我们将在事件图中添加一些节点。
- en: 'Place a `Print String` node after the Event BeginPlay event node:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Event BeginPlay 事件节点之后放置一个 `Print String` 节点：
- en: '![](img/155d1518-6a95-478b-89db-c434fbb4a3ea.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/155d1518-6a95-478b-89db-c434fbb4a3ea.png)'
- en: 'Place a `Format Text` node and connect its output to the input of the `Print
    String` node. A conversion node will be added for you:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 放置一个 `Format Text` 节点，并将其输出连接到 `Print String` 节点的输入。系统会为你添加一个转换节点：
- en: '![](img/825ac029-d5de-496c-87fe-2f17a6ebcd72.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/825ac029-d5de-496c-87fe-2f17a6ebcd72.png)'
- en: 'Inside the `Format Text` node, add `My Type is {0}!` to the Format text box:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Format Text` 节点内部，将 `My Type is {0}!` 添加到格式文本框中：
- en: '![](img/d1b858b3-6f18-4cba-a7c8-8d54f5137af8.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d1b858b3-6f18-4cba-a7c8-8d54f5137af8.png)'
- en: You should see that it adds a new parameter, 0, which we can now set.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到它添加了一个新的参数，0，我们现在可以设置它。
- en: 'Drag the RandomTree variable from the Variables section of the My Blueprint
    window into the graph and select Get from the menu:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 RandomTree 变量从 My Blueprint 窗口的变量部分拖放到图中，并从菜单中选择 Get：
- en: '![](img/76fab5b0-2f7d-4c0e-a8d4-0ed39f776c22.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/76fab5b0-2f7d-4c0e-a8d4-0ed39f776c22.png)'
- en: 'Add an Enum to Name node to the `Type` output pin:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Enum to Name 节点添加到 `Type` 输出引脚：
- en: '![](img/d92b7665-d8ed-4b79-b03a-ad3b56eb5f9f.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d92b7665-d8ed-4b79-b03a-ad3b56eb5f9f.png)'
- en: The Format Text node will not use a Name, so we will need to convert it into
    Text. Add a ToText (name) node to the Enum to Name output pin.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Format Text 节点将不会使用名称，因此我们需要将其转换为文本。向 Enum to Name 输出引脚添加一个 ToText (name) 节点。
- en: 'Connect the Return Value output of the ToText (name) node to the 0 input pin
    on the Format Text node. Your Event Graph should now look as follows:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 ToText (name) 节点的返回值输出连接到 Format Text 节点的 0 输入引脚。你的事件图现在应该如下所示：
- en: '![](img/f79e30f9-f9b9-46cf-8784-a4a7e93d8c40.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f79e30f9-f9b9-46cf-8784-a4a7e93d8c40.png)'
- en: The completed Blueprint graph
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的蓝图图
- en: Compile your Blueprint and then return to the Unreal Editor.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译你的蓝图，然后返回到虚幻编辑器。
- en: 'Drag a few copies of your Blueprint into the level and hit Play. You should
    see a number of trees printing information regarding their type, verifying that
    types are being randomly assigned by the Blueprint code that we created:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将几个蓝图副本拖放到级别中并播放。你应该会看到许多树打印有关它们类型的信息，验证蓝图代码正在随机分配类型：
- en: '![](img/b1534f7b-f726-4577-92d5-380d72ddacf2.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b1534f7b-f726-4577-92d5-380d72ddacf2.png)'
- en: How it works...
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As usual, we use `StaticMeshActor` as the base class for our `Actor` so that
    we can easily give it a visual representation in the level.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，我们使用 `StaticMeshActor` 作为我们的 `Actor` 的基类，这样我们就可以轻松地在级别中为其提供一个视觉表示。
- en: Enumerated types are exposed to the reflection system using the `UENUM` macro.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举类型通过 `UENUM` 宏暴露给反射系统。
- en: We mark the `enum` as Blueprint-available using the `BlueprintType` specifier.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `BlueprintType` 指定符将 `enum` 标记为蓝图可用的。
- en: The `enum` declaration is just the same as we would use in any other context.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum` 声明与我们在任何其他上下文中使用的完全相同。'
- en: Our `Tree` requires a `TreeType`. Because *tree has tree-type* is the relationship
    we want to embody, we include an instance of `TreeType` in our `Tree` class.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Tree` 需要一个 `TreeType`。因为 *tree has tree-type* 是我们想要体现的关系，我们在 `Tree` 类中包含了一个
    `TreeType` 实例。
- en: As usual, we need to use `UPROPERTY()` to make the member variable accessible
    to the reflection system.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，我们需要使用 `UPROPERTY()` 来使成员变量可被反射系统访问。
- en: We use the `BlueprintReadWrite` specifier to mark the property as having both
    get and set support within Blueprint.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `BlueprintReadWrite` 指定符标记属性在蓝图内既有获取又有设置支持。
- en: Enumerated types require being wrapped in the `TEnumAsByte` template when used
    in `UPROPERTY`, so we declare an instance of `TEnumAsByte<TreeType>` as the Tree's
    `Type` variable.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举类型在使用 `UPROPERTY` 时需要被 `TEnumAsByte` 模板包装，因此我们声明一个 `TEnumAsByte<TreeType>`
    的实例作为树的 `Type` 变量。
- en: The constructor changes for `Tree` are simply the standard load and initialize
    our static mesh component preamble that's used in other recipes.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`Tree` 构造函数的更改仅仅是标准的加载和初始化我们用于其他菜谱中的静态网格组件前缀。'
- en: We create a Blueprint that inherits from our `Tree` class so that we can demonstrate
    the Blueprint-accessibility of the `TreeType enum`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个继承自我们的 `Tree` 类的蓝图，以便我们可以演示 `TreeType enum` 的蓝图可访问性。
- en: To have the Blueprint assign a type to the tree at random when we create an
    instance, we need to use the Construction Script Blueprint.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在创建实例时让蓝图随机为树分配一个类型，我们需要使用构造脚本蓝图。
- en: Within the Construction Script, we calculate the number of entries in the `TreeType
    enum`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造脚本中，我们计算 `TreeType enum` 中的条目数。
- en: We generate a random number and use that as an index in the `TreeType enum`
    type to retrieve a value to store as our `Type`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生成一个随机数，并使用它作为 `TreeType` 枚举类型的索引来检索一个值作为我们的 `Type` 存储。
- en: The Random number node, however, returns integers. Enumerated types are treated
    as bytes in Blueprint, so we need to use a `ToByte` node, which can then be implicitly
    converted by Blueprint into an `enum` value.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随机数节点返回整数。在蓝图中，枚举类型被视为字节，因此我们需要使用 `ToByte` 节点，然后蓝图可以隐式地将它转换为 `enum` 值。
- en: Now that we have Construction Script assigning a type to our tree instances
    as they are created, we need to display the tree's type at runtime.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了构造脚本，在创建树实例时为它们分配类型，我们需要在运行时显示树的类型。
- en: We do so with the graph attached to the `BeginPlay` event within the Event Graph
    tab.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在事件图选项卡中的 `BeginPlay` 事件内附加的图来做到这一点。
- en: To display text on screen, we use a `Print String` node.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 要在屏幕上显示文本，我们使用 `Print String` 节点。
- en: To perform string substitution and print our type out as a human-readable string,
    we use the `Format Text` node.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行字符串替换并将我们的类型以人类可读的字符串打印出来，我们使用 `Format Text` 节点。
- en: The `Format Text` node takes terms enclosed in curly braces and allows you to
    substitute other values for those terms by returning the final string.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`Format Text` 节点用于提取花括号内的术语，并允许您通过返回最终字符串来替换这些术语的值。'
- en: To substitute our `Type` into the `Format Text` node, we need to convert our
    variable stores from the `enum` value into the actual name of the value.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 要将我们的 `Type` 替换到 `Format Text` 节点中，我们需要将我们的变量存储从 `enum` 值转换为实际值名称。
- en: We can do so by accessing our `Type` variable and then using the `Enum to Name`
    node.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过访问我们的 `Type` 变量并使用 `Enum to Name` 节点来实现这一点。
- en: '`Names`, or `FNames` in native code, are a type of variable that can be converted
    into strings by Blueprint so that we can connect our `Name` to the input on the
    `Format Text` node.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`Names`，或在本地代码中为 `FNames`，是一种可以被蓝图转换为字符串的变量类型，这样我们就可以将我们的 `Name` 连接到 `Format
    Text` 节点的输入上。'
- en: When we hit Play, the graph executes, retrieving the type of tree instances
    that have been placed in the level and printing the names to the screen.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们按下播放时，图执行，检索放置在级别中的树实例的类型，并将名称打印到屏幕上。
- en: Editing class properties in different places in the editor
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在编辑器中的不同位置编辑类属性
- en: When developing with Unreal, it is common for programmers to implement properties
    on Actors or other objects in C++, and make them visible in the editor for designer
    use. However, sometimes, it makes sense to view a property, or make it editable,
    but only on the object's default state. Sometimes, the property should only be
    modifiable at runtime with the default specified in C++. Fortunately, there are
    some specifiers that can help us restrict when a property is available.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Unreal 进行开发时，程序员通常会在 C++ 中实现 Actor 或其他对象的属性，并在编辑器中使它们对设计师可见。然而，有时查看属性或使其可编辑，但仅在对象的默认状态下是有意义的。有时，属性应该在运行时使用在
    C++ 中指定的默认值进行修改。幸运的是，有一些指定符可以帮助我们限制属性何时可用。
- en: How to do it...
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a new `Actor` class in the editor called `PropertySpecifierActor`:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中创建一个新的 `Actor` 类，命名为 `PropertySpecifierActor`：
- en: '![](img/1181d0a4-74a1-4ab3-ac08-773bf590a75a.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1181d0a4-74a1-4ab3-ac08-773bf590a75a.png)'
- en: 'Add the following property definitions to the class:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向类添加以下属性定义：
- en: '[PRE21]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Perform a Save, Compile your code, and launch the editor.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行保存，编译您的代码，并启动编辑器。
- en: Create a new blueprint based on the class.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于类创建一个新的蓝图。
- en: 'Open the blueprint and look at the Class Defaults section:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开蓝图并查看类默认值部分：
- en: '![](img/04d585d0-842c-4de5-b9da-731758e27c2b.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![](img/04d585d0-842c-4de5-b9da-731758e27c2b.jpg)'
- en: 'Note which properties are editable and visible under the Property Specifier
    Actor section:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意哪些属性在属性指定器演员部分下是可编辑和可见的：
- en: '![](img/1d639038-43e2-4ee8-abff-36f3ec2afa6b.png)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1d639038-43e2-4ee8-abff-36f3ec2afa6b.png)'
- en: Location of the Property Specifier Actor
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 属性指定器演员的位置
- en: 'Place instances in the level and view their Details panels:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将实例放置在级别中并查看它们的详细信息面板：
- en: '![](img/16d4fe8b-9f98-40b7-96de-36f7d1188c15.png)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![](img/16d4fe8b-9f98-40b7-96de-36f7d1188c15.png)'
- en: Note that a different set of properties is editable.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，一组不同的属性是可编辑的。
- en: How it works...
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When specifying `UPROPERTY`, we can indicate where we want that value to be
    available inside the Unreal editor.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 当指定 `UPROPERTY` 时，我们可以指示我们希望在 Unreal 编辑器内部何处使该值可用。
- en: '`Visible*` prefixes indicate that the value is viewable in the Details panel
    for the indicated object. The value won''t be editable, however.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`Visible*` 前缀表示可以在指示对象的详细面板中查看值。然而，该值不可编辑。'
- en: This doesn't mean that the variable is a `const` qualifier; however, native
    code can change the value, for instance.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着变量是 `const` 标识符；然而，原生代码可以更改其值，例如。
- en: '`Edit*` prefixes indicate that the property can be altered within the Details
    panels inside the editor.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`Edit*` 前缀表示可以在编辑器内的详细面板中更改属性。'
- en: '`InstanceOnly` as a suffix indicates that the property will only be displayed
    in the Details panels for instances of your class that have been placed into the
    game. They won''t be visible in the Class Defaults section of the Blueprint editor,
    for example.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 作为后缀的 `InstanceOnly` 表示该属性将仅在已放置到游戏中的类的实例的详细面板中显示。例如，它们在蓝图编辑器的“类默认值”部分中不可见。
- en: '`DefaultsOnly` is the inverse of `InstanceOnly` – `UPROPERTY` will only display
    in the Class Defaults section, and can''t be viewed on individual instances within
    the level.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`DefaultsOnly` 是 `InstanceOnly` 的逆，`UPROPERTY` 只会在类默认值部分显示，并且不能在级别中的单个实例中查看。'
- en: The suffix `Anywhere` is the combination of the two previous suffixes – the
    `UPROPERTY` will be visible in all the Details panels that inspect either the
    object's defaults or a particular instance in the level.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 前缀 `Anywhere` 是前两个前缀的组合——`UPROPERTY` 将在检查对象默认值或级别中的特定实例的所有详细面板中可见。
- en: As we mentioned previously, if you are interested in learning more about Property
    Specifiers, check out the following link: [https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/Reference/Properties/Specifiers](https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/Reference/Properties/Specifiers).
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，如果您想了解更多关于属性指定符的信息，请查看以下链接：[https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/Reference/Properties/Specifiers](https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/Reference/Properties/Specifiers)。
- en: See also
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: This recipe makes the property in question visible in the inspector, but doesn't
    allow the property to be referenced in the actual Blueprint Event Graph. See the
    following recipe for a description of how to make that possible.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此配方使所讨论的属性在检查器中可见，但不会允许在实际的蓝图事件图中引用该属性。有关如何实现此功能的描述，请参阅以下配方。
- en: Making properties accessible in the Blueprint editor graph
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在蓝图编辑器图中使属性可访问
- en: The specifiers we mentioned in the previous recipe are all well and good, but
    they only control the visibility of `UPROPERTY` in the Details panel. By default,
    even with those specifiers used appropriately, `UPROPERTY` won't be viewable or
    accessible in the actual editor graph for use at `runtime.Other` specifiers, which
    can optionally be used in conjunction with the ones in the previous recipe so
    that you can interact with properties in the Event Graph.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在先前的配方中提到的指定符都很好，但它们只控制 `UPROPERTY` 在详细面板中的可见性。默认情况下，即使使用了这些指定符，`UPROPERTY`
    也不会在真正的编辑器图中可见或可访问，以便在 `runtime.Other` 中使用。这些指定符可以与先前的配方中的指定符一起使用，以便您可以在事件图中与属性交互。
- en: How to do it...
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a new `Actor` class called `BlueprintPropertyActor` using the editor
    wizard:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用编辑器向导创建一个新的 `Actor` 类，命名为 `BlueprintPropertyActor`。
- en: '![](img/40067092-2b56-401c-8825-8bfea89f5019.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![](img/40067092-2b56-401c-8825-8bfea89f5019.png)'
- en: 'Add the following `UPROPERTY` to the class using Visual Studio:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Visual Studio 将以下 `UPROPERTY` 添加到类中：
- en: '[PRE22]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Perform a Save, Compile your project, and start the editor.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行保存，编译您的项目，并启动编辑器。
- en: Create a Blueprint class based on your `BlueprintPropertyActor` and open its
    graph.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于您的 `BlueprintPropertyActor` 创建一个蓝图类，并打开其图。
- en: 'From the My Blueprint panel, click on the eye icon to the right of the Search
    bar. From there, select Show Inherited Variables:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“我的蓝图”面板中，点击搜索栏右侧的图标。从那里，选择显示继承变量：
- en: '![](img/04be7b53-3abc-4b96-91df-41feeef6a5b6.png)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![](img/04be7b53-3abc-4b96-91df-41feeef6a5b6.png)'
- en: 'Verify that the properties are visible under the Cookbook category in the Variables
    section of the My Blueprint panel:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“我的蓝图”面板的变量部分中，验证属性是否在“食谱”类别下可见：
- en: '![](img/bba20056-25a1-4ae7-90cf-639c18d06265.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bba20056-25a1-4ae7-90cf-639c18d06265.jpg)'
- en: 'Left-click and drag the `ReadWriteProperty` variable into the Event Graph.
    Then select Get ReadWriteProperty:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 左键单击并拖动 `ReadWriteProperty` 变量到事件图中。然后选择获取读写属性：
- en: '![](img/5ba2bbaf-baa3-48ca-ab9c-c7c14d66d450.png)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5ba2bbaf-baa3-48ca-ab9c-c7c14d66d450.png)'
- en: Repeat the previous step, but instead select Set ReadWriteProperty.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复前面的步骤，但选择设置只读属性。
- en: 'Drag the ReadOnly property into the graph and note that the SET node is disabled:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将只读属性拖入图中，并注意SET节点被禁用：
- en: '![](img/b43adb75-6bdf-41e5-b6ec-2d103fb65f05.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b43adb75-6bdf-41e5-b6ec-2d103fb65f05.png)'
- en: How it works...
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何工作...
- en: '`BlueprintReadWrite` as a `UPROPERTY` specifier indicates to the Unreal Header
    Tool that the property should have both `Get` and `Set` operations exposed for
    use in Blueprints.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 作为`UPROPERTY`指定符的`BlueprintReadWrite`表示告诉Unreal头文件工具，该属性应该有`Get`和`Set`操作暴露以在蓝图中使用。
- en: '`BlueprintReadOnly` is, as the name implies, a specifier that only allows Blueprint
    to retrieve the value of the property; never set it.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，`BlueprintReadOnly`是一个指定符，它只允许蓝图检索属性的值；永远不能设置它。
- en: '`BlueprintReadOnly` can be useful when a property is set by native code, but
    should be accessible within Blueprint.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 当属性由原生代码设置时，`BlueprintReadOnly`可能很有用，但应在蓝图内可访问。
- en: It should be noted that `BlueprintReadWrite` and `BlueprintReadOnly` don't specify
    anything about the property being accessible in the Details panels or the My Blueprint
    section of the editor: these specifiers only control the generation of the getter/setter
    nodes for use in Blueprint graphs.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 应注意，`BlueprintReadWrite`和`BlueprintReadOnly`不指定属性在详细信息面板或编辑器的“我的蓝图”部分中的可访问性：这些指定符仅控制为蓝图图生成getter/setter节点。
- en: Responding to property changed events from the editor
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应来自编辑器的属性更改事件
- en: When a designer changes the properties of an `Actor` placed in the level, it
    is often important to show any visual results of that change immediately rather
    than just when the level is simulated or played. When changes are made using the
    Details panels, there's a special event that the editor emits called `PostEditChangeProperty`,
    which gives the class instance a chance to respond to the property being edited.
    This recipe shows you how to handle `PostEditChangeProperty` for immediate in-editor
    feedback.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 当设计师更改放置在关卡中的`Actor`的属性时，通常很重要立即显示该更改的任何视觉结果，而不仅仅是当关卡模拟或播放时。当使用详细信息面板进行更改时，编辑器会发出一个特殊事件，称为`PostEditChangeProperty`，它给类实例一个机会来响应正在编辑的属性。这个配方展示了如何处理`PostEditChangeProperty`以获得即时的编辑器反馈。
- en: How to do it...
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Create a new `Actor` called `PostEditChangePropertyActor` based on `StaticMeshActor`:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的基于`StaticMeshActor`的`Actor`，命名为`PostEditChangePropertyActor`：
- en: '![](img/45976a36-1621-403c-973b-afa3c859cabe.png)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![](img/45976a36-1621-403c-973b-afa3c859cabe.png)'
- en: 'Add the following `UPROPERTY` and function definition to the class:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下`UPROPERTY`和函数定义添加到类中：
- en: '[PRE23]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create the class constructor by adding the following code to the `PostEditChangePropertyActor.cpp`
    file:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将以下代码添加到`PostEditChangePropertyActor.cpp`文件中创建类构造函数：
- en: '[PRE24]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Implement `PostEditChangeProperty`:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`PostEditChangeProperty`：
- en: '[PRE25]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Compile your code and launch the editor.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译你的代码并启动编辑器。
- en: 'Drag an instance of your class into the game world and verify that toggling
    the Boolean value for `ShowStaticMesh` toggles the visibility of the mesh in the editor
    viewport:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的类的一个实例拖入游戏世界，并验证切换`ShowStaticMesh`的布尔值是否在编辑器视图中切换网格的可见性：
- en: '![](img/dba850f4-0119-4dac-85a7-e24f6a9e78f0.png)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dba850f4-0119-4dac-85a7-e24f6a9e78f0.png)'
- en: The location of the Show Static Mesh property
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 显示静态网格属性的定位
- en: 'Then, if you ever toggle it off, you''ll see the object disappear, as follows:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果你将其关闭，你会看到对象消失，如下所示：
- en: '![](img/340c8760-1eda-48ab-91fd-99f5034777b0.png)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![](img/340c8760-1eda-48ab-91fd-99f5034777b0.png)'
- en: How it works...
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何工作...
- en: We create a new `Actor` based on `StaticMeshActor` for easy access to a visual
    representation via the Static Mesh.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基于`StaticMeshActor`创建一个新的`Actor`，以便通过静态网格访问视觉表示。
- en: '`UPROPERTY` is added to give us a property to change, which causes `PostEditChangeProperty`
    events to be triggered.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 添加`UPROPERTY`以给我们一个可以更改的属性，这将触发`PostEditChangeProperty`事件。
- en: '`PostEditChangeProperty` is a virtual function that''s defined in `Actor`.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '`PostEditChangeProperty`是一个在`Actor`中定义的虚函数。'
- en: As a result, we override the function in our class.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们覆盖了我们类中的函数。
- en: Within our class constructor, we initialize our mesh as usual, and set the default
    state of our `bool` property to match the visibility of the component it controls.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的类构造函数中，我们像往常一样初始化我们的网格，并将我们的`bool`属性的默认状态设置为与它控制的组件的可见性相匹配。
- en: Inside `PostEditChangeProperty`, we first check that the property is valid.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PostEditChangeProperty`内部，我们首先检查属性是否有效。
- en: Assuming it is, we retrieve the name of the property using `GetFName()`.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 假设它是，我们使用`GetFName()`检索属性的名称。
- en: '`FNames` are stored internally by the engine as a table of unique values.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '`FNames`在引擎内部以唯一值表的形式存储。'
- en: Next, we need to use the `GET_MEMBER_NAME_CHECKED` macro. The macro takes a
    number of parameters.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要使用`GET_MEMBER_NAME_CHECKED`宏。该宏接受多个参数。
- en: The first one is the name of the class to check, while the second parameter
    is the property to check the class for.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是要检查的类的名称，而第二个参数是要检查该类的属性。
- en: The macro will, at compile-time, verify that the class contains the member specified
    by name.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 该宏将在编译时验证类是否包含由名称指定的成员。
- en: We compare the class member name that the macro returns against the name that
    our property contains.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将宏返回的类成员名称与我们的属性包含的名称进行比较。
- en: If they are the same, then we verify that our `StaticMeshComponent` is initialized
    correctly.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它们相同，那么我们验证我们的`StaticMeshComponent`是否正确初始化。
- en: If it is, we set its visibility to match the value of our `ShowStaticMesh` Boolean.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是，我们将它的可见性设置为与我们的`ShowStaticMesh`布尔值匹配。
- en: Implementing a native code Construction Script
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现原生代码构建脚本
- en: Within Blueprint, a Construction Script is an Event Graph that runs any time
    a property is changed on the object it is attached to – whether it's being dragged
    in the editor viewport or changed via a direct entry in a Details panel. Construction
    Scripts allow the object in question to *rebuild* itself based on its new location,
    for instance, or to change the components it contains based on user-selected options.
    When coding in C++ with Unreal Engine, the equivalent concept is the `OnConstruction`
    function.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在Blueprint中，一个构建脚本是一个事件图，它在任何时间对象上更改属性时都会运行——无论是被拖动到编辑器视图中，还是通过细节面板的直接输入进行更改。构建脚本允许相关对象根据其新位置*重建*自己，例如，或者根据用户选择的选项更改其包含的组件。在用Unreal
    Engine以C++进行编码时，等效的概念是`OnConstruction`函数。
- en: How to do it...
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a new `Actor` called `OnConstructionActor` based on `StaticMeshActor`:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于`StaticMeshActor`创建一个新的名为`OnConstructionActor`的`Actor`：
- en: '![](img/e5a597b2-f38a-4fbf-9095-db45235e8c34.png)'
  id: totrans-385
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e5a597b2-f38a-4fbf-9095-db45235e8c34.png)'
- en: 'Update the header file to the following:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将头文件更新为以下内容：
- en: '[PRE26]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Go to the implementation file (`OnConstructionActor.cpp`) and implement the
    class constructor:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往实现文件（`OnConstructionActor.cpp`）并实现类构造函数：
- en: '[PRE27]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Implement `OnConstruction`:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`OnConstruction`：
- en: '[PRE28]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Compile your code and launch the editor.
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译你的代码并启动编辑器。
- en: 'Drag an instance of your class into the game world, and verify that toggling
    the Boolean value for `ShowStaticMesh` toggles the visibility of the mesh in the
    editor viewport:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的类的一个实例拖入游戏世界，并验证切换`ShowStaticMesh`布尔值是否会在编辑器视图中切换网格的可见性：
- en: '![](img/0e5c8d54-687b-45bc-adb7-19163d4c24b0.png)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0e5c8d54-687b-45bc-adb7-19163d4c24b0.png)'
- en: '`OnConstruction` does not currently run for C++ actors that are placed in a
    level if they are moved.'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`OnConstruction`目前不会为放置在关卡中的C++ actor运行，如果它们被移动。'
- en: To test this, place a breakpoint in your `OnConstruction` function, and then
    move your actor around the level.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要测试这一点，在你的`OnConstruction`函数中放置一个断点，然后移动你的actor在关卡中的位置。
- en: To place a breakpoint, place your cursor on the desired line and hit *F9* in
    Visual Studio.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 要放置断点，将光标放在所需的行上，然后在Visual Studio中按*F9*。
- en: You'll notice that the function doesn't get called, but if you toggle the `ShowStaticMesh`
    Boolean, it does, causing your breakpoint to trigger.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会注意到函数没有被调用，但如果切换`ShowStaticMesh`布尔值，它就会被调用，导致你的断点被触发。
- en: 'To see why, take a look at the beginning of the `AActor::PostEditMove` function:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解原因，请查看`AActor::PostEditMove`函数的开始部分：
- en: '[PRE29]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The top line here casts `UClass` for the current object to `UBlueprint`, and
    will only run the construction scripts and `OnConstruction` again if the class
    is a Blueprint.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的第一行将当前对象的`UClass`转换为`UBlueprint`，并且只有当类是Blueprint时，才会再次运行构建脚本和`OnConstruction`。
- en: How it works...
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We create a new Actor based on `StaticMeshActor` for easy access to a visual
    representation via the Static Mesh.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基于`StaticMeshActor`创建一个新的Actor，以便通过静态网格访问视觉表示。
- en: '`UPROPERTY` is added to give us a property to change, which causes `PostEditChangeProperty`
    events to be triggered.'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 添加`UPROPERTY`以给我们一个可以更改的属性，这将触发`PostEditChangeProperty`事件。
- en: '`OnConstruction` is a virtual function that''s defined in Actor.'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnConstruction`是一个在Actor中定义的虚函数。'
- en: As a result, we override the function in our class.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在我们的类中重写了该函数。
- en: Within our class constructor, we initialize our mesh as usual, and set the default
    state of our `bool` property to match the visibility of the component that it
    controls.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的类构造函数中，我们像往常一样初始化我们的网格，并将我们的`bool`属性的默认状态设置为与它所控制的组件的可见性相匹配。
- en: Inside `OnConstruction`, the actor rebuilds itself using any properties that
    are required to do so.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在`OnConstruction`内部，演员使用任何所需的属性来重建自己。
- en: For this simple example, we set the visibility of the mesh to match the value
    of our `ShowStaticMesh` property.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个简单的例子，我们将网格的可见性设置为与我们的`ShowStaticMesh`属性的值相匹配。
- en: This could also be extended to changing other values based on the value of the
    `ShowStaticMesh` variable.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以扩展到根据`ShowStaticMesh`变量的值改变其他值。
- en: You'll note that we don't explicitly filter on a particular property being changed,
    like the previous recipe does with `PostEditChangeProperty`.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们并没有像之前的配方中用`PostEditChangeProperty`那样明确地对某个特定属性的改变进行过滤。
- en: The `OnConstruction` script runs in its entirety for every property that gets
    changed on the object.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnConstruction`脚本在对象上每个发生改变的属性上都会完整运行。'
- en: It has no way of testing which property was just edited, so you need to be judicious
    about placing computationally intensive code within it.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 它没有方法来测试刚刚编辑的是哪个属性，所以你需要谨慎地将计算密集型代码放置在其中。
