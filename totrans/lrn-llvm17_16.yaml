- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instruction Selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The heart of any backend is instruction selection. LLVM implements several approaches;
    in this chapter, we will implement instruction selection via the selection **directed
    acyclic graph** (**DAG**) and with global instruction selection.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Defining the rules of the calling convention*: This section shows you how
    to describe the rules of a calling convention in the target description'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Instruction selection via the selection DAG*: This section teaches you how
    to implement instruction selection with a graph data structure'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Adding register and instruction information*: This section explains how to
    access information in the target description, and what additional information
    you need to provide'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Putting an empty frame lowering in place*: This section introduces you to
    the stack layout and the prologue of a function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Emitting machine instructions*: This section tells you how machine instructions
    are finally written into an object file or as assembly text'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating the target machine and the sub-target*: This section shows you how
    a backend is configured'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Global instruction selection*: This section demonstrates a different approach
    to instruction selection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*How to further evolve the backend*: This section gives you some guidance about
    possible next steps'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will know how to create an LLVM backend that
    can translate simple instructions. You will also acquire the knowledge to develop
    instruction selection via the selection DAG and with global instruction selection,
    and you will become familiar with all the important support classes you have to
    implement to get instruction selection working.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the rules of the calling convention
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing the rules of the calling convention is an important part of lowering
    the LLVM **intermediate representation** (**IR**) to machine code. The basic rules
    can be defined in the target description. Let’s have a look.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most calling conventions follow a basic pattern: they define a subset of registers
    for parameter passing. If this subset is not exhausted, the next parameter is
    passed in the next free register. If there is no free register, then the value
    is passed on the stack. This can be realized by looping over the parameters and
    deciding how to pass each parameter to the called function while keeping track
    of the used registers. In LLVM, this loop is implemented inside the framework,
    and the state is held in a class called `CCState`. Furthermore, the rules are
    defined in the target description.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The rules are given as a sequence of conditions. If the condition holds, then
    an action is executed. Depending on the outcome of that action, either a place
    for the parameter is found, or the next condition is evaluated. For example, 32-bit
    integers are passed in a register. The condition is the type check, and the action
    is the assignment of a register to this parameter. In the target description,
    this is written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, if the called function has more than eight parameters, then the
    register list will be exhausted, and the action will fail. The remaining parameters
    are passed on the stack, and we can specify this as the next action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter is the size of a stack slot in bytes, while the second is
    the alignment. Since it is a catch-all rule, no condition is used.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the rules of the calling convention
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For a calling convention, there are also more predefined conditions and actions
    to note. For example, `CCIfInReg` checks if the argument is marked with the `inreg`
    attribute, and `CCIfVarArg` evaluates to `true` if the function has a variable
    argument list. The `CCPromoteToType` action promotes the type of the argument
    to a larger one, and the `CCPassIndirect` action indicates that the parameter
    value should be stored on the stack and that a pointer to that storage is passed
    as a normal argument. All of the predefined conditions and actions can be referenced
    within `llvm/include/llvm/Target/TargetCallingConv.td`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both the parameters and the return value are defined in this way. We will put
    the definition into the `M88kCallingConv.td` file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must define the rules for the parameters. To simplify the coding,
    we’ll only consider 32-bit values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, we must define the rules for return values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, the sequence of callee saved registers must be defined. Note that
    we use the `sequence` operator to generate a sequence of registers, instead of
    writing them down:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The benefit of defining the rules for the calling convention in the target description
    is that they can be reused for various instruction selection methods. We’ll look
    at instruction selection via the selection DAG next.
  prefs: []
  type: TYPE_NORMAL
- en: Instruction selection via the selection DAG
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating machine instructions from the IR is a very important task in the backend.
    One common way to implement it is to utilize a DAG:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we must create a DAG from the IR. A node of the DAG represents an operation
    and the edges model control and data flow dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we must loop over the DAG and legalize the types and operations. Legalization
    means that we only use types and operations that are supported by the hardware.
    This requires us to create a configuration that tells the framework how to deal
    with non-legal types and operations. For instance, a 64-bit value could be split
    into two 32-bit values, the multiplication of two 64-bit values could be changed
    to a library call, and a complex operation such as count population could be expanded
    into a sequence of simpler operations for calculating this value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After, pattern matching is utilized to match nodes in the DAG and replace them
    with machine instructions. We encountered such a pattern in the previous chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, an instruction scheduler reorders the machine instructions into a more
    performant order.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is just a high-level description of the instruction selection process via
    the selection DAG. If you are interested in more details, you can find it in the
    *The LLVM Target-Independent Code Generator* user guide at [https://llvm.org/docs/CodeGenerator.html#selectiondag-instruction-selection-process](https://llvm.org/docs/CodeGenerator.html#selectiondag-instruction-selection-process).
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, all backends in LLVM implement the selection DAG. The main advantage
    is that it generates performant code. However, this comes at a cost: creating
    the DAG is expensive, and it slows down compilation speed. Therefore, this has
    prompted LLVM developers to look for alternative and more desirable approaches.
    Some targets implement instruction selection via FastISel, which is only used
    for non-optimized code. It can quickly generate code, but the generated code is
    inferior to the one generated by the selection DAG method. In addition, it adds
    a whole new instruction selection method, which doubles the testing effort. Another
    method is also used for instruction selection called global instruction selection,
    which we’ll examine later in the *Global instruction* *selection* section.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we aim to implement enough of the backend to lower a simple
    IR function, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Moreover, for a real backend, much more code is needed, and we must point out
    what needs to be added for greater functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement instruction selection via the selection DAG, we need to create
    two new classes: `M88kISelLowering` and `M88kDAGToDAGISel`. The former class is
    used to customize the DAG, for example, by defining which types are legal. It
    also contains the code to support the lowering of functions and function calls.
    The latter class performs DAG transformations, and the implementation is mostly
    generated from the target description.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several classes within the backend that we will be adding implementation
    to, and *Figure 12**.1* depicts the high-level relationship between the primary
    classes that we will be developing further:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – Relationship between the main classes](img/B19561_12_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – Relationship between the main classes
  prefs: []
  type: TYPE_NORMAL
- en: Implementing DAG lowering – handling legal types and setting operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s implement the `M88kISelLowering` class, which is stored in `M88kISelLowering.cpp`
    file, first. The constructor configures the legal types and operations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The constructor takes references to the `TargetMachine` and `M88kSubtarget`
    classes as parameters. The `TargetMachine` class is responsible for the general
    configuration of the target, for example, which passes need to run. An LLVM backend
    usually targets a CPU family, and the `M88kSubtarget` class describes the characteristics
    of the chosen CPU. We’ll look at both classes later in this chapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The first action is to declare which machine value type uses which register
    class. Remember that the register classes are generated from the target description.
    Here, we only handle 32-bit values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After adding all register classes, we must compute the derived properties of
    those register classes. We need to query the sub-target for register information,
    which is mostly generated from the target description:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we must declare which register contains the stack pointer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Boolean values are represented differently on different platforms. For our
    target, we will declare that a Boolean value is stored in bit `0`; the other bits
    are cleared:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After, we set the alignment of functions. The minimal function alignment is
    the alignment that is required for correct execution. In addition, we give the
    preferred alignment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we declare which operations are legal. In the previous chapter, we
    only defined three logical instructions, and they are legal for 32-bit values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There are a couple of other actions we can use besides `Legal`. `Promote` widens
    the type, `Expand` replaces the operation with other operations, `LibCall` lowers
    the operation to a library call, and `Custom` calls the `LowerOperation()` hook
    method, which lets you implement your own custom handling. For example, in the
    M88k architecture, there is no count population instruction, so we request that
    this operation be expanded into other operations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s review some points to emphasize the connection between the definitions
    we made so far. In the target description mentioned in the `M88kInstrInfo.td`
    file, we defined a machine instruction with the `and` mnemonic, and we also attached
    a pattern to it. If we expand the `AND` multiclass record, and only look at the
    instruction using three registers, we get the TableGen definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `"and"` string is the mnemonic of the instruction. In C++ source code, we
    use `M88k::ANDrr` to refer to this instruction. Inside the pattern, the DAG `and`
    node type is used. In C++, it is named `ISD::AND`, and we used it in the call
    to the `setOperationAction()` method. During instruction selection, a DAG node
    of the `and` type is replaced by the `M88k::ANDrr` instruction if the pattern
    matches, which includes the input operands. Thus, when we develop instruction
    selection, the most important task is for us to define the correct legalization
    actions and attach the patterns to the instruction definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing DAG lowering – lowering formal arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s turn to another important task performed by the `M88kISelLowering` class.
    We defined the rules for the calling convention in the previous section, but we
    also need to map the physical registers and memory locations to virtual registers
    used in the DAG. For arguments, this is done in the `LowerFormalArguments()` method;
    return values are handled in the `LowerReturn()` method. First, we must handle
    the arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll begin by including the generated source:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `LowerFormalArguments()` method takes several parameters. The `SDValue`
    class denotes a value associated with a DAG node and is often used when dealing
    with the DAG. The first parameter, `Chain`, represents the control flow, and the
    possible updated `Chain` is also the return value of the method. The `CallConv`
    parameter identifies the used calling convention, and `IsVarArg` is set to `true`
    if a variable argument list is part of the parameters. The arguments that need
    to be handled are passed in the `Ins` parameter, together with their location
    in the `DL` parameter. The `DAG` parameter gives us access to the `SelectionDAG`
    class. Lastly, the result of the mapping will be stored in the `InVals` vector
    argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our first action is to retrieve references to the machine function and the
    machine register information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we must call the generated code. We need to instantiate an object of
    the `CCState` class. The `CC_M88k` parameter value that’s used in the call to
    the `AnalyzeFormalArguments()` method is the name of the calling convention we
    used in the target description. The result is stored in the `ArgLocs` vector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the locations of the arguments have been determined, we need to map them
    to the DAG. Therefore, we must loop over all locations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The mapping depends on the determined location. First, we handle arguments
    assigned to registers. The goal is to copy the physical register to a virtual
    register. To do so, we need to determine the correct register class. Since we’re
    only handling 32-bit values, it is easy to do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the register class stored in the `RC` variable, we can create the virtual
    register and copy the value. We also need to declare the physical register as
    a live-in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the definition of the calling convention, we added the rule that 8-bit and
    16-bit values should be promoted to 32-bit, and we need to ensure the promotion
    here. To do so, a DAG node must be inserted, which makes sure that the value is
    promoted. After, the value is truncated to the right size. Note that we pass the
    value of `ArgValue` as an operand to the DAG node and store the result in the
    same variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, we finish handling the register arguments by adding the DAG node to
    the result vector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The other possible location for a parameter is on the stack. However, we didn’t
    define any load and store instructions, so we cannot handle this case yet. This
    ends the loop over all argument locations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, we may need to add code to handle variable argument lists. Again,
    we have added some code to remind us that we have not implemented it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we must return the `Chain` argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Implementing DAG lowering – lowering return values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The return values are handled similarly. However, we must extend the target
    description for them. First, we need to define a new DAG node type called `RET_GLUE`.
    This DAG node type is used to glue the return values together, which prevents
    them from being rearranged, for example, by the instruction scheduler. The definition
    in `M88kInstrInfo.td` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same file, we also define a pseudo-instruction to represent a return
    from a function call, which will be selected for a `RET_GLUE` node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We will expand this pseudo-instruction when we generate the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'With these definitions in place, we can implement the `LowerReturn()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameters are the same as for `LowerFormalArguments()`, only the order
    is slightly different:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'First, we call the generated code, this time using the `RetCC_M88k` calling
    convention:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we loop over the locations again. With the simple definition of the calling
    convention we currently have, this loop will be executed once at most. However,
    this would change if we would add support for returning 64-bit values, which need
    to be returned in two registers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After, we copy the return values into the physical registers assigned to the
    return value. This is mostly similar to handling the arguments, with the exception
    that the values are glued together using the `Glue` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The return value is the chain and the glued register copy operations. The latter
    is only returned if there is a value to return:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we construct a DAG node of the `RET_GLUE` type, passing in the necessary
    values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Congratulations! With these definitions, the foundation has been laid for instruction
    selection.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing DAG-to-DAG transformations within instruction selection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One crucial part is still missing: we need to define the pass that performs
    the DAG transformations defined in the target descriptions. The class is called
    `M88kDAGToDAGISel` and is stored in the `M88kISelDAGToDAG.cpp` file. Most of the
    class is generated, but we still need to add some code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll begin by defining the debug type and providing a descriptive name for
    the pass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we must declare the class inside an anonymous namespace. We will only
    override the `Select()` method; the other code is generated and included in the
    body of the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After, we must add the code to initialize the pass. The LLVM backends still
    use the legacy pass manager, and the setup differs from the pass manager used
    for IR transformations. The static member `ID` value is used to identify the pass.
    Initializing the pass can be implemented using the `INITIALIZE_PASS` macro, which
    expands to C++ code. We must also add a factory method to create an instance of
    the pass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we must implement the `Select()` method. For now, we only call the
    generated code. However, if we encounter a complex transformation that we cannot
    express as a DAG pattern, then we can add our own code to perform the transformation
    before calling the generated code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With that, we have implemented the instruction selection. However, we still
    need to add some support classes before we can do the first test. We’ll look at
    those classes in the next few sections.
  prefs: []
  type: TYPE_NORMAL
- en: Adding register and instruction information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The target description captures most information about registers and instructions.
    To access that information, we must implement the `M88kRegisterInfo` and `M88kInstrInfo`
    classes. These classes also contain hooks that we can override to accomplish tasks
    that are too complex to express in the target description. Let’s begin with the
    `M88kRegisterInfo` class, which is declared in the `M88kRegisterInfo.h` file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The header file begins by including the code generated from the target description:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, we must declare the `M88kRegisterInfo` class in the `llvm` namespace.
    We only override a couple of methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The definition of the class is stored in the `M88kRegisterInfo.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, the film begins with including the code generated from the target description:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The constructor initializes the superclass, passing the register holding the
    return address as a parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we implement the method that returns the list of callee-saved registers.
    We defined the list in the target description, and we only return that list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After, we deal with the reserved registers. The reserved registers depend on
    the platform and the hardware. The `r0` register contains a constant value of
    `0`, so we treat it as a reserved register. The `r28` and `r29` registers are
    always reserved for use by a linker. Lastly, the `r31` register is used as a stack
    pointer. This list may depend on the function, and it cannot be generated due
    to this dynamic behavior:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If a frame register is required, then `r30` is used. Please note that our code
    does not support creating a frame yet. If the function requires a frame, then
    `r30` must also be marked as reserved in the `getReservedRegs()` method. However,
    we must implement this method because it is declared pure virtual in the superclass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similarly, we need to implement the `eliminateFrameIndex()` method because
    it is declared *pure virtual*. It is called to replace a frame index in an operand
    with the correct value to use to address the value on the stack:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `M88kInstrInfo` class has many hook methods we can override to accomplish
    special tasks, for example, for branch analysis and rematerialization. For now,
    we’re only overriding the `expandPostRAPseudo()` method, in which we expand the
    pseudo-instruction RET. Let’s begin with the header file, `M88kInstrInfo.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The header file begins with including the generated code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `M88kInstrInfo` class derives from the generated `M88kGenInstrInfo` class.
    Besides overriding the `expandPostRAPseudo()` method, the only other addition
    is that this class owns an instance of the previously defined class, `M88kRegisterInfo`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The implementation is stored in the `M88kInstrInfo.cpp` class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Like the header file, the implementation begins with including the generated
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we define the `anchor()` method, which is used to pin the vtable to this
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we expand `RET` in the `expandPostRAPseudo()` method. As its name
    suggests, this method is invoked after the register allocator runs and is intended
    to expand the pseudo-instruction, which may still be mixed with the machine code.
    If the opcode of the machine instruction, `MI`, is the pseudo-instruction, `RET`,
    we must insert the `jmp %r1` jump instruction, which is the instruction to exit
    a function. Then, we copy all implicit operands that represent the values to return
    and we delete the pseudo instruction. If we need other pseudo-instructions during
    code generation, then we can extend this function to expand them here too:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Both classes have minimal implementations. If you continue to develop the target,
    then many more methods need to be overridden. It is worth reading the comments
    in the `TargetInstrInfo` and `TargetRegisterInfo` base classes, which you can
    find in the `llvm/include/llvm/CodeGen` directory.
  prefs: []
  type: TYPE_NORMAL
- en: We still need more classes to get the instruction selection running. Next, we’ll
    look at frame lowering.
  prefs: []
  type: TYPE_NORMAL
- en: Putting an empty frame lowering in place
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The binary interface of a platform not only defines how parameters are passed.
    It also includes how a stack frame is laid out: in which places are local variables
    stored, where registers are spilled to, and so on. Often, a special instruction
    sequence is required at the beginning and end of a function, called the `TargetFrameLowering`
    is available. The easy solution is to provide the `M88kFrameLowering` class with
    an empty implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The declaration of the class is in the `M88kFrameLowering.h` file. All we must
    do here is override the pure virtual functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation, which is stored in the `M88kFrameLowering.cpp` file, provides
    some basic details about stack frames in the constructor. The stack grows downwards,
    to smaller addresses, and is aligned on 8-byte boundaries. When a function is
    called, the local variables are stored directly below the stack pointer of the
    calling function, so the offset of the local area is `0`. Even during a function
    call, the stack should remain aligned at an 8-byte boundary. The last parameter
    implies that the stack cannot be realigned. The other functions just have an empty
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Of course, as soon as our implementation grows, this class will be one of the
    first that needs to be fully implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can put all the pieces together, we need to implement the assembly
    printer, which is used to emit machine instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Emitting machine instructions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The instruction selection creates machine instructions, represented by the `MachineInstr`
    class, from LLVM IR. But this is not the end. An instance of the `MachineInstr`
    class still carries additional information, such as labels or flags. To emit an
    instruction via the machine code component, we need to lower the instances of
    `MachineInstr` to instances of `MCInst`. By doing this, the machine code component
    provides the functionality to write instructions into object files or print them
    as assembler text. The `M88kAsmPrinter` class is responsible for emitting a whole
    compilation unit. Lowering an instruction is delegated to the `M88kMCInstLower`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The assembly printer is the last pass to run in a backend. Its implementation
    is stored in the `M88kAsmPrinter.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The declaration of the `M88kAsmPrinter` class is in an anonymous namespace.
    Besides the constructor, we only override the `getPassName()` function, which
    returns the name of the pass as a human-readable string, and the `emitInstruction()`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Like many other classes, we have to register our assembly printer in the target
    registry:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `emitInstruction()` method is responsible for emitting the machine instruction,
    `MI`, to the output stream. In our implementation, we delegate the lowering of
    the instruction to the `M88kMCInstLower` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is already the full implementation. The base class, `AsmPrinter`, provides
    many useful hooks you can override. For example, the `emitStartOfAsmFile()` method
    is called before anything is emitted, and `emitEndOfAsmFile()` is called after
    everything is emitted. These methods can emit target-specific data or code at
    the beginning and the end of a file. Similarly, the `emitFunctionBodyStart()`
    and `emitFunctionBodyEnd()` methods are called before and after a function body
    is emitted. Read the comments in the `llvm/include/llvm/CodeGen/AsmPrinter.h`
    file to understand what can be customized.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `M88kMCInstLower` class lowers operands and instructions, and our implementation
    contains two methods for that purpose. The declaration is in the `M88kMCInstLower.h`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The definition goes into the `M88kMCInstLower.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To lower `MachineOperand` to `MCOperand`, we need to check the operand type.
    Here, we only handle registers and immediates by creating `MCOperand`-equivalent
    register and immediate values by supplying the original `MachineOperand` values.
    As soon as expressions are introduced as operands, this method needs to be enhanced:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The lowering of an instruction is similar. First, the opcode is copied, and
    then the operands are handled. An instance of `MachineInstr` can have implicit
    operands attached, which are not lowered, and we need to filter them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With that, we’ve implemented the assembly printer. Now, we need to bring all
    the pieces together. We’ll do this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the target machine and the sub-target
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we’ve implemented the instruction selection classes and a couple of
    other classes. Now, we need to set up how our backend will work. Like the optimization
    pipeline, a backend is divided into passes. Configuring those passes is the main
    task of the `M88kTargetMachine` class. In addition, we need to specify which features
    are available for instruction selection. Usually, a platform is a family of CPUs,
    which all have a common set of instructions but differ by specific extensions.
    For example, some CPUs have vector instructions, while others do not. In LLVM
    IR, a function can have attributes attached that specify for which CPU this function
    should be compiled, or what features are available. In other words, each function
    could have a different configuration, which is captured in the `M88kSubTarget`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing M88kSubtarget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s implement the `M88kSubtarget` class first. The declaration is stored
    in the `M88kSubtarget.h` class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parts of the sub-target are generated from the target description, and we include
    those codes first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we declare the class, deriving it from the generated `M88kGenSubtargetInfo`
    class. The class owns a couple of previously defined classes – the instruction
    information, the target lowering class, and the frame lowering class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The sub-target is initialized with the target triple, the name of the CPU,
    and a feature string, as well as with the target machine. All these parameters
    describe the hardware for which our backend will generate code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we include the generated file again, this time for automatically defining
    getter methods for features defined in the target description:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In addition, we need to declare the `ParseSubtargetFeatures()` method. The
    method itself is generated from the target description:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we must add getter methods for the member variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we must add a getter method for the register information, which is
    owned by the instruction information class. This finishes the declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we must implement the actual subtarget class. The implementation is stored
    in the `M88kSubtarget.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, we begin the file by including the generated source:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we define the anchor method, which pins the vtable to this file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we define the constructor. Note that the generated class expected
    two CPU parameters: the first one for the instruction set, and the second one
    for scheduling. The use case here is that you want to optimize the code for the
    latest CPU but still be able to run the code on an older CPU. We do not support
    this feature and use the same CPU name for both parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Implementing M88kTargetMachine – defining the definitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, we can implement the `M88kTargetMachine` class. This class holds all
    used sub-target instances. It also owns a subclass of `TargetLoweringObjectFile`,
    which provides details such as section names to the lowering process. Lastly,
    it creates the configuration of the passes that runs in this backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'The declaration in the `M88kTargetMachine.h` file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `M88kTargetMachine` class derives from the `LLVMTargetMachine` class. The
    only members are an instance of `TargetLoweringObjectFile` and the sub-target
    map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The parameters of the constructor completely describe the target configuration
    for which we will generate code. With the `TargetOptions` class, many details
    of the code generations can be controlled – for example, if floating-point multiply-and-add
    instructions can be used or not. Also, the relocation model, the code model, and
    the optimization level are passed to the constructor. Notably, the `JIT` parameter
    is set to true if the target machine is used for just-in-time compilation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also need to override some methods. The `getSubtargetImpl()` method returns
    the sub-target instance to use for the given function, and the `getObjFileLowering()`
    method just returns the member variable. In addition, we override the `createPassConfig()`
    method, which returns our configuration for the backend passes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Implementing M88kTargetMachine – adding the implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The implementation of the class is stored in the `M88kTargetMachine.cpp` file.
    Please note that we created this file in [*Chapter 11*](B19561_11.xhtml#_idTextAnchor177).
    Now, we will replace this file with a complete implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must register the target machine. In addition, we must initialize
    the DAG-to-DAG pass via the initialization function we defined earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we must define the support function, `computeDataLayout()`. We talked
    about the data layout string in [*Chapter 4*](B19561_04.xhtml#_idTextAnchor068),
    *Basics of IR Code Generation*. In this function, the data layout, as the backend,
    expects it to be defined. Since the data layout depends on hardware features,
    the triple, the name of the CPU, and the feature set string are passed to this
    function. We create the data layout string with the following components. The
    target is big-endian (`E`) and uses the `ELF` symbol mangling.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Pointers are 32-bit wide and 32-bit aligned. All scalar types are naturally
    aligned. The `MC88110` CPU has an extended register set and supports 80-bit wide
    floating points. If we were to support this special feature, then we’d need to
    add a check of the CPU name here and extend the string with the floating-point
    values accordingly. Next, we must state that all globals have a preferred alignment
    of 16-bit and that the hardware has only 32-bit registers:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can define the constructor and destructor. Many of the parameters are
    just passed to the superclass constructor. Note that our `computeDataLayout()`
    function is called here. In addition, the `TLOF` member is initialized with an
    instance of `TargetLoweringObjectFileELF`, since we are using the ELF file format.
    In the body of the constructor, we must call the `initAsmInfo()` method, which
    initializes many data members of the superclass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After, we define the `getSubtargetImpl()` method. The sub-target instance to
    use depends on the `target-cpu` and `target-features` function attributes. For
    example, the `target-cpu` attribute could be set to `MC88110`, thus targeting
    the second-generation CPU. However, the attribute target feature could describe
    that we should not use the graphics instructions of that CPU. We have not defined
    the CPUs and their features in the target description yet, so we are doing a bit
    more than what’s necessary here. However, the implementation is simple enough:
    we query the function attributes and use either the returned strings or the default
    values. With this information, we can query the `SubtargetMap` member, and if
    it’s not found, we create the sub-target:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we create the pass configuration. For this, we need our own class,
    `M88kPassConfig`, which derives from the `TargetPassConfig` class. We only override
    the `addInstSelector` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With this definition, we can implement the `createPassConfig` factory method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, we must add our instruction selection class to the pass pipeline in
    the `addInstSelector()` method. The return value, `false`, indicates that we have
    added a pass that converts LLVM IR into machine instructions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That was a long journey to finish the implementation! Now that we’ve built
    the `llc` tool, we can run an example. Save the following simple IR in the `and.ll`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can run `llc` and verify that the generated assembly looks reasonable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: To compile for the `m88k` target, we must specify the triple on the command
    line, as in this example, or in the IR file.
  prefs: []
  type: TYPE_NORMAL
- en: Enjoy your success for a bit before we look at global instruction selection.
  prefs: []
  type: TYPE_NORMAL
- en: Global instruction selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instruction selection via the selection DAG produces fast code, but it takes
    time to do so. The speed of the compiler is often critical for developers, who
    want to quickly try out the changes they’ve made. Usually, the compiler should
    be very fast at optimization level `0`, but it can take more time with increased
    optimization levels. However, constructing the selection DAG costs so much time
    that this approach does not scale as required. The first solution was to create
    another instruction selection algorithm called `FastISel`, which is fast but does
    not generate good code. It also does not share code with the selection DAG implementation,
    which is an obvious problem. Because of this, not all targets support `FastISel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The selection DAG approach does not scale because it is a large, monolithic
    algorithm. If we can avoid creating a new data structure such as the selection
    DAG, then we should be able to perform the instruction selection using small components.
    The backend already has a pass pipeline, so using passes is a natural choice.
    Based on these thoughts, GlobalISel performs the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, the LLVM IR is lowered into generic machine instructions. Generic machine
    instructions represent the most common operation found in real hardware. Note
    that this translation uses the machine functions and machine basic blocks, which
    means it directly translates into the data structures used by the other parts
    of the backend.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The generic machine instructions are then legalized.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After, the operands of generic machine instructions are mapped to register banks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the generic instructions are replaced with real machine instructions,
    using the patterns defined in the target description.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since these are all passes, we can insert as many passes as we want in between.
    For example, a combiner pass could be used to replace a sequence of generic machine
    instructions with another generic machine instruction, or with a real machine
    instruction. Turning these additional passes off increases the compilation speed
    while turning them on improves the quality of the generated code. Hence, we can
    scale as we need.
  prefs: []
  type: TYPE_NORMAL
- en: There is another advantage in this approach. The selection DAG translates basic
    block by basic block, but a machine pass works on a machine function, which enables
    us to consider all basic blocks of a function during instruction selections. Therefore,
    this instruction selection method is called global instruction selection (GlobalISel).
    Let’s have a look at how this approach works, starting with the transformation
    of calls.
  prefs: []
  type: TYPE_NORMAL
- en: Lowering arguments and return values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For translating the LLVM IR to generic machine instructions, we only need to
    implement how arguments and return values are handled. Again, the implementation
    can be simplified by using the generated code from the target description. The
    class we’ll create is called `M88kCallLowering`, and the declaration is in the
    `GISel/M88kCallLowering.h` header file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: The GlobalISel framework will call the `lowerReturn()` and `lowerFormalArguments()`
    methods when a function is translated. To translate a function call, you would
    need to override and implement the `lowerCall()` method as well. Please note that
    we also need to override `enableBigEndian()`. Without it, the wrong machine code
    would be generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the implementation in the `GISel/M88kCallLowering.cpp` file, we need to
    define to support classes. The generated code from the target description tells
    us how a parameter is passed – for example, in a register. We need to create a
    subclass of `ValueHandler` to generate the machine instructions for it. For incoming
    parameters, we need to derive our class from `IncomingValueHandler`, as well as
    for the return value from `OutgoingValueHandler`. Both are very similar, so we’ll
    only look at the handler for incoming arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, we can only handle parameters passed in registers, so we must provide
    a dummy implementation for the other methods. The `assignValueToReg()` method
    copies the value of the incoming physical register to a virtual register, performing
    a truncation if necessary. All we have to do here is mark the physical register
    as live-in to the function, and call the superclass implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can implement the `lowerFormalArgument()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the parameters of the `IR` function are translated into instances of
    the `ArgInfo` class. The `setArgFlags()` and `splitToValueTypes()` framework methods
    help with copying the parameter attributes and splitting the value type in case
    an incoming argument needs more than one virtual register:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the arguments prepared in the `SplitArgs` variable, we are ready to generate
    the machine code. This is all done by the framework code, with the help of the
    generated calling convention, `CC_M88k`, and our helper class, `FormalArghandler`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Return values are handled similarly, with the main difference being that one
    value is returned at most. The next task is to legalize the generic machine instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Legalizing the generic machine instructions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The translation from LLVM IR to generic machine code is mostly fixed. As a
    result, instructions can be generated that use unsupported data types, among other
    challenges. The task of the legalizer pass is to define which operations and instructions
    are legal. With this information, the GlobalISel framework tries to transform
    the instructions into a legal form. For example, the m88k architecture only has
    32-bit registers, so a bitwise `and` operation with 64-bit values is not legal.
    However, if we split the 64-bit value into two 32-bit values, and use two bitwise
    `and` operations instead, then we have legal code. This can be translated into
    a legalization rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Whenever the legalizer pass processes a `G_AND` instruction, then it is legal
    if all operands are 32-bit wide. Otherwise, the operands are clamped to 32-bit,
    effectively splitting larger values into multiple 32-bit values, and the rule
    is applied again. If an instruction cannot be legalized, then the backend terminates
    with an error message.
  prefs: []
  type: TYPE_NORMAL
- en: All legalization rules are defined in the constructor of the `M88kLegalizerInfo`
    class, which makes the class very simple.
  prefs: []
  type: TYPE_NORMAL
- en: What does legal mean?
  prefs: []
  type: TYPE_NORMAL
- en: In GlobalISel, a generic instruction is legal if it can be translated by the
    instruction selector. This gives us more freedom in the implementation. For example,
    we can state that an instruction works on a bit value, even if the hardware only
    operates on 32-bit values, so long as the instruction selector can handle the
    type correctly.
  prefs: []
  type: TYPE_NORMAL
- en: The next pass we need to look at is the register bank selector.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting a register bank for operands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many architectures define several register banks. A register bank is a set of
    registers. Typical register banks are general-purpose register banks and floating-point
    register banks. Why is this information important? Moving a value from one register
    to another is usually cheap inside a register bank, but copying the value to another
    register bank can be costly or impossible. Thus, we must select a good register
    bank for each operand.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of this class involves an addition to the target description.
    In the `GISel/M88lRegisterbanks.td` file, we define our single register bank,
    referencing the register classes we have defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'From this line, some support code is generated. However, we still need to add
    some code that could be potentially generated. First, we need to define partial
    mappings. This tells the framework at which bit index a value begins, how wide
    it is, and to which register bank it maps. We have two entries, one for each register
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'To index this array, we must define an enumeration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we have only three address instructions, we need three partial mappings,
    one for each operand. We must create an array with all those pointers, with the
    first entry denoting an invalid mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'To access that array, we must define a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: When creating these tables, it is easy to make errors. At first glance, all
    this information can be derived from the target description, and a comment in
    the source states that this code should be generated by TableGen! However, this
    hasn’t been implemented yet, so we have to create the code manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important function we have to implement in the `M88kRegisterBankInfo`
    class is `getInstrMapping()`, which returns the mapped register banks for each
    operand of the instruction. This now becomes easy because we can look up the array
    of partial mappings, which we can then pass to the `getInstructionMapping()` method,
    which constructs the full instruction mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: During development, it is common to forget the register bank mapping for a generic
    instruction. Unfortunately, the error message that’s generated at runtime does
    not mention for which instruction the mapping failed. The easy fix is to dump
    the instruction before returning the invalid mapping. However, we need to be careful
    here because the `dump()` method is not available in all build types.
  prefs: []
  type: TYPE_NORMAL
- en: After mapping the register banks, we must translate the generic machine instructions
    into real machine instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Translating generic machine instructions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For instruction selection via the selection DAG, we added patterns to the target
    description, which use DAG operations and operands. To reuse those patterns, a
    mapping from DAG node types to generic machine instructions was introduced. For
    example, the DAG `and` operation maps to the generic `G_AND` machine instruction.
    Not all DAG operations have an equivalent generic machine instruction; however,
    the most common cases are covered. Therefore, it is beneficial to define all code
    selection patterns in the target description.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the implementation of the `M88kInstructionSelector` class, which can
    be found in the `GISel/M88kInstructionSelector.cpp` file, is generated from the
    target description. However, we need to override the `select()` method, which
    allows us to translate generic machine instructions that are not covered by the
    patterns in the target description. Since we only support a very small subset
    of generic instructions, we can simply call the generated pattern matcher:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: With the instruction selection implemented, we can translate LLVM IR using GlobalISel!
  prefs: []
  type: TYPE_NORMAL
- en: Running an example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To translate LLVM IR using GlobalISel, we need to add the `-global-isel` option
    to the command line of `llc`. For example, you can use the previously defined
    IR file, `and.ll`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'The printed assembly text is the same. To convince ourselves that the translation
    uses GlobalISel, we must take advantage of the fact that we can stop the translation
    after a specified pass is run with the `-stop-after=` option. For example, to
    see the generic instructions after legalization, you would run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: The ability to stop after (or before) a pass is run is another advantage of
    GlobalISel because it makes it easy to debug and test the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have a working backend that can translate some LLVM IR into
    machine code for the m88k architecture. Let’s think about how to move from here
    to a more complete backend.
  prefs: []
  type: TYPE_NORMAL
- en: How to further evolve the backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the code from this and the previous chapter, we have created a backend
    that can translate some LLVM IR into machine code. It is very satisfying to see
    the backend working, but it is far from being usable for serious tasks. Much more
    coding is needed. Here is a recipe for how you can further evolve the backend:'
  prefs: []
  type: TYPE_NORMAL
- en: The first decision you should make is if you want to use GlobalISel or the selection
    DAG. In our experience, GlobalISel is easier to understand and develop, but all
    targets in the LLVM source tree implement the selection DAG, and you may already
    have experience in using it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, you should define the instructions for adding and subtracting integer
    values, which can be done similarly to the bitwise `and` instruction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After, you should implement the load and store instructions. This is more involved
    since you need to translate the different addressing modes. Most likely, you will
    deal with indexing, for example, to address an element of an array, which most
    likely requires the previously defined instruction for addition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, you can fully implement frame lowering and call lowering. At this point,
    you can translate a simple “Hello, world!” style application into a running program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next logical step is to implement branch instructions, which enable the
    translation of loops. To generate optimal code, you need to implement the branch
    analyzing methods in the instruction information class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you reach this point, your backend can already translate simple algorithms.
    You should also have gained enough experience to develop the missing parts based
    on your priorities.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you added two different instruction selections to your backend:
    instruction selection via the selection DAG, and global instruction selection.
    For this, you had to define the calling convention in the target description.
    In addition, you needed to implement register and instruction information classes,
    which give you access to information generated from the target description but
    which you also needed to enhance with additional information. You learned that
    the stack frame layout and prolog generation are needed later. To translate an
    example, you added a class to emit machine instructions, and you created the configuration
    of the backend. You also learned how global instruction selection works. Finally,
    you gained some guidance on how you can develop the backend on your own.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at some tasks that can be done after instruction
    selection – we will add a new pass in the pipeline of the backend, look at how
    to integrate the backend into the clang compiler, and how to cross-compile to
    a different architecture.
  prefs: []
  type: TYPE_NORMAL
