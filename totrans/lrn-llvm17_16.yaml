- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Instruction Selection
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指令选择
- en: The heart of any backend is instruction selection. LLVM implements several approaches;
    in this chapter, we will implement instruction selection via the selection **directed
    acyclic graph** (**DAG**) and with global instruction selection.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 任何后端的核心都是指令选择。LLVM实现了几种方法；在本章中，我们将通过选择**有向无环图**（**DAG**）和全局指令选择来实现指令选择。
- en: 'In this chapter, you will learn about the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下主题：
- en: '*Defining the rules of the calling convention*: This section shows you how
    to describe the rules of a calling convention in the target description'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*定义调用约定规则*：本节展示了如何在目标描述中描述调用约定的规则'
- en: '*Instruction selection via the selection DAG*: This section teaches you how
    to implement instruction selection with a graph data structure'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通过选择DAG进行指令选择*：本节教你如何使用图数据结构实现指令选择'
- en: '*Adding register and instruction information*: This section explains how to
    access information in the target description, and what additional information
    you need to provide'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*添加寄存器和指令信息*：本节解释了如何访问目标描述中的信息，以及你需要提供哪些附加信息'
- en: '*Putting an empty frame lowering in place*: This section introduces you to
    the stack layout and the prologue of a function'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实施空帧降低*：本节介绍了函数的栈布局和前导部分'
- en: '*Emitting machine instructions*: This section tells you how machine instructions
    are finally written into an object file or as assembly text'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*生成机器指令*：本节告诉你机器指令是如何最终写入目标文件或汇编文本的'
- en: '*Creating the target machine and the sub-target*: This section shows you how
    a backend is configured'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建目标机器和子目标*：本节展示了后端是如何配置的'
- en: '*Global instruction selection*: This section demonstrates a different approach
    to instruction selection'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*全局指令选择*：本节演示了指令选择的不同方法'
- en: '*How to further evolve the backend*: This section gives you some guidance about
    possible next steps'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*如何进一步发展后端*：本节为你提供了一些关于可能下一步的指导'
- en: By the end of this chapter, you will know how to create an LLVM backend that
    can translate simple instructions. You will also acquire the knowledge to develop
    instruction selection via the selection DAG and with global instruction selection,
    and you will become familiar with all the important support classes you have to
    implement to get instruction selection working.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解如何创建一个能够翻译简单指令的LLVM后端。你还将获得通过选择DAG和全局指令选择开发指令选择的知识，并且将熟悉你必须实现以使指令选择工作的重要支持类。
- en: Defining the rules of the calling convention
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义调用约定规则
- en: Implementing the rules of the calling convention is an important part of lowering
    the LLVM **intermediate representation** (**IR**) to machine code. The basic rules
    can be defined in the target description. Let’s have a look.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 实施调用约定规则是将LLVM**中间表示**（**IR**）降低到机器代码的重要部分。基本规则可以在目标描述中定义。让我们看看。
- en: 'Most calling conventions follow a basic pattern: they define a subset of registers
    for parameter passing. If this subset is not exhausted, the next parameter is
    passed in the next free register. If there is no free register, then the value
    is passed on the stack. This can be realized by looping over the parameters and
    deciding how to pass each parameter to the called function while keeping track
    of the used registers. In LLVM, this loop is implemented inside the framework,
    and the state is held in a class called `CCState`. Furthermore, the rules are
    defined in the target description.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数调用约定遵循一个基本模式：它们定义了一组寄存器用于参数传递。如果这个子集没有用完，下一个参数将传递到下一个空闲寄存器。如果没有空闲寄存器，则值将传递到栈上。这可以通过遍历参数并决定如何将每个参数传递给被调用函数，同时跟踪使用的寄存器来实现。在LLVM中，这个循环是在框架内部实现的，状态保存在一个名为`CCState`的类中。此外，规则也在目标描述中定义。
- en: 'The rules are given as a sequence of conditions. If the condition holds, then
    an action is executed. Depending on the outcome of that action, either a place
    for the parameter is found, or the next condition is evaluated. For example, 32-bit
    integers are passed in a register. The condition is the type check, and the action
    is the assignment of a register to this parameter. In the target description,
    this is written as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 规则是以条件序列的形式给出的。如果条件成立，则执行操作。根据该操作的结果，要么找到参数的位置，要么评估下一个条件。例如，32位整数在寄存器中传递。条件是类型检查，操作是将寄存器分配给该参数。在目标描述中，这被写成如下：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Of course, if the called function has more than eight parameters, then the
    register list will be exhausted, and the action will fail. The remaining parameters
    are passed on the stack, and we can specify this as the next action:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果被调用的函数有超过八个参数，那么寄存器列表将会耗尽，操作将失败。剩余的参数将通过栈传递，我们可以将此指定为下一个操作：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first parameter is the size of a stack slot in bytes, while the second is
    the alignment. Since it is a catch-all rule, no condition is used.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是栈槽的字节数大小，而第二个是对齐。由于这是一个通用的规则，没有使用条件。
- en: Implementing the rules of the calling convention
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现调用约定规则
- en: For a calling convention, there are also more predefined conditions and actions
    to note. For example, `CCIfInReg` checks if the argument is marked with the `inreg`
    attribute, and `CCIfVarArg` evaluates to `true` if the function has a variable
    argument list. The `CCPromoteToType` action promotes the type of the argument
    to a larger one, and the `CCPassIndirect` action indicates that the parameter
    value should be stored on the stack and that a pointer to that storage is passed
    as a normal argument. All of the predefined conditions and actions can be referenced
    within `llvm/include/llvm/Target/TargetCallingConv.td`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于调用约定，还有一些需要注意的更多预定义条件和操作。例如，`CCIfInReg`检查参数是否带有`inreg`属性，如果函数有一个可变参数列表，则`CCIfVarArg`评估为`true`。`CCPromoteToType`操作将参数的类型提升到更大的类型，而`CCPassIndirect`操作表示参数值应该存储在栈上，并且将对该存储的指针作为普通参数传递。所有预定义的条件和操作都可以在`llvm/include/llvm/Target/TargetCallingConv.td`中引用。
- en: 'Both the parameters and the return value are defined in this way. We will put
    the definition into the `M88kCallingConv.td` file:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 参数和返回值都是这样定义的。我们将定义放入`M88kCallingConv.td`文件中：
- en: 'First, we must define the rules for the parameters. To simplify the coding,
    we’ll only consider 32-bit values:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须定义参数的规则。为了简化编码，我们将只考虑32位值：
- en: '[PRE2]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After that, we must define the rules for return values:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们必须定义返回值的规则：
- en: '[PRE3]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, the sequence of callee saved registers must be defined. Note that
    we use the `sequence` operator to generate a sequence of registers, instead of
    writing them down:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，必须定义调用者保存寄存器的序列。请注意，我们使用`sequence`运算符生成寄存器序列，而不是逐个写出：
- en: '[PRE4]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The benefit of defining the rules for the calling convention in the target description
    is that they can be reused for various instruction selection methods. We’ll look
    at instruction selection via the selection DAG next.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在目标描述中定义调用约定规则的好处是它们可以用于各种指令选择方法。接下来，我们将查看通过选择DAG进行指令选择。
- en: Instruction selection via the selection DAG
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过选择DAG进行指令选择
- en: 'Creating machine instructions from the IR is a very important task in the backend.
    One common way to implement it is to utilize a DAG:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 从中间表示（IR）创建机器指令是后端中一个非常重要的任务。实现它的一个常见方法是通过使用DAG：
- en: First, we must create a DAG from the IR. A node of the DAG represents an operation
    and the edges model control and data flow dependencies.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须从中间表示（IR）创建一个DAG。DAG的一个节点代表一个操作，边表示控制和数据流依赖关系。
- en: Next, we must loop over the DAG and legalize the types and operations. Legalization
    means that we only use types and operations that are supported by the hardware.
    This requires us to create a configuration that tells the framework how to deal
    with non-legal types and operations. For instance, a 64-bit value could be split
    into two 32-bit values, the multiplication of two 64-bit values could be changed
    to a library call, and a complex operation such as count population could be expanded
    into a sequence of simpler operations for calculating this value.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须遍历DAG并合法化类型和操作。合法化意味着我们只使用硬件支持的类型和操作。这需要我们创建一个配置，告诉框架如何处理非法类型和操作。例如，一个64位值可以被拆分为两个32位值，两个64位值的乘法可以改为库调用，一个复杂的操作，如计数人口，可以扩展为一系列更简单的操作来计算这个值。
- en: After, pattern matching is utilized to match nodes in the DAG and replace them
    with machine instructions. We encountered such a pattern in the previous chapter.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，使用模式匹配来匹配DAG中的节点，并用机器指令替换它们。我们在上一章中遇到了这样的模式。
- en: Finally, an instruction scheduler reorders the machine instructions into a more
    performant order.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，指令调度器重新排列机器指令，以获得更高效的顺序。
- en: This is just a high-level description of the instruction selection process via
    the selection DAG. If you are interested in more details, you can find it in the
    *The LLVM Target-Independent Code Generator* user guide at [https://llvm.org/docs/CodeGenerator.html#selectiondag-instruction-selection-process](https://llvm.org/docs/CodeGenerator.html#selectiondag-instruction-selection-process).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是通过选择DAG进行指令选择过程的高级描述。如果您想了解更多细节，可以在[https://llvm.org/docs/CodeGenerator.html#selectiondag-instruction-selection-process](https://llvm.org/docs/CodeGenerator.html#selectiondag-instruction-selection-process)的*The
    LLVM Target-Independent Code Generator*用户指南中找到。
- en: 'Furthermore, all backends in LLVM implement the selection DAG. The main advantage
    is that it generates performant code. However, this comes at a cost: creating
    the DAG is expensive, and it slows down compilation speed. Therefore, this has
    prompted LLVM developers to look for alternative and more desirable approaches.
    Some targets implement instruction selection via FastISel, which is only used
    for non-optimized code. It can quickly generate code, but the generated code is
    inferior to the one generated by the selection DAG method. In addition, it adds
    a whole new instruction selection method, which doubles the testing effort. Another
    method is also used for instruction selection called global instruction selection,
    which we’ll examine later in the *Global instruction* *selection* section.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，LLVM中的所有后端都实现了选择DAG。主要优势是它生成高效的代码。然而，这也有代价：创建DAG代价高昂，并且会减慢编译速度。因此，这促使LLVM开发者寻找替代的、更理想的方法。一些目标通过FastISel实现指令选择，它仅用于非优化代码。它可以快速生成代码，但生成的代码不如选择DAG方法生成的代码。此外，它增加了一个全新的指令选择方法，这使测试工作翻倍。另一种用于指令选择的方法称为全局指令选择，我们将在后面的*全局指令选择*部分进行探讨。
- en: 'In this chapter, we aim to implement enough of the backend to lower a simple
    IR function, like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们的目标是实现足够的后端功能，以便降低一个简单的IR函数，如下所示：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Moreover, for a real backend, much more code is needed, and we must point out
    what needs to be added for greater functionality.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对于真正的后端，还需要更多的代码，我们必须指出需要添加什么以实现更多功能。
- en: 'To implement instruction selection via the selection DAG, we need to create
    two new classes: `M88kISelLowering` and `M88kDAGToDAGISel`. The former class is
    used to customize the DAG, for example, by defining which types are legal. It
    also contains the code to support the lowering of functions and function calls.
    The latter class performs DAG transformations, and the implementation is mostly
    generated from the target description.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过选择DAG实现指令选择，我们需要创建两个新的类：`M88kISelLowering`和`M88kDAGToDAGISel`。前者类用于定制DAG，例如，通过定义哪些类型是合法的。它还包含支持函数和函数调用的代码。后者类执行DAG转换，其实现主要来自目标描述。
- en: 'There are several classes within the backend that we will be adding implementation
    to, and *Figure 12**.1* depicts the high-level relationship between the primary
    classes that we will be developing further:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在后端中，我们将添加几个类的实现，*图12**.1*展示了我们将进一步开发的主要类之间的高级关系：
- en: '![Figure 12.1 – Relationship between the main classes](img/B19561_12_1.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1 – 主要类之间的关系](img/B19561_12_1.jpg)'
- en: Figure 12.1 – Relationship between the main classes
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – 主要类之间的关系
- en: Implementing DAG lowering – handling legal types and setting operations
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现DAG降低 – 处理合法类型和设置操作
- en: 'Let’s implement the `M88kISelLowering` class, which is stored in `M88kISelLowering.cpp`
    file, first. The constructor configures the legal types and operations:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先实现`M88kISelLowering`类，该类存储在`M88kISelLowering.cpp`文件中。构造函数配置合法类型和操作：
- en: 'The constructor takes references to the `TargetMachine` and `M88kSubtarget`
    classes as parameters. The `TargetMachine` class is responsible for the general
    configuration of the target, for example, which passes need to run. An LLVM backend
    usually targets a CPU family, and the `M88kSubtarget` class describes the characteristics
    of the chosen CPU. We’ll look at both classes later in this chapter:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数接受`TargetMachine`和`M88kSubtarget`类的引用作为参数。`TargetMachine`类负责目标的一般配置，例如，哪些传递需要运行。LLVM后端通常针对一个CPU系列，而`M88kSubtarget`类描述了所选CPU的特性。我们将在本章后面讨论这两个类：
- en: '[PRE6]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The first action is to declare which machine value type uses which register
    class. Remember that the register classes are generated from the target description.
    Here, we only handle 32-bit values:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是声明哪种机器值类型使用哪种寄存器类。记住，寄存器类是从目标描述生成的。在这里，我们只处理32位值：
- en: '[PRE7]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After adding all register classes, we must compute the derived properties of
    those register classes. We need to query the sub-target for register information,
    which is mostly generated from the target description:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在添加所有寄存器类之后，我们必须计算这些寄存器类的派生属性。我们需要查询子目标以获取寄存器信息，这些信息主要来自目标描述：
- en: '[PRE8]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we must declare which register contains the stack pointer:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须声明哪个寄存器包含栈指针：
- en: '[PRE9]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Boolean values are represented differently on different platforms. For our
    target, we will declare that a Boolean value is stored in bit `0`; the other bits
    are cleared:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 布尔值在不同的平台上表示方式不同。对于我们的目标，我们将声明布尔值存储在位`0`；其他位被清除：
- en: '[PRE10]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After, we set the alignment of functions. The minimal function alignment is
    the alignment that is required for correct execution. In addition, we give the
    preferred alignment:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们设置函数的对齐方式。最小函数对齐是正确执行所需的对齐方式。此外，我们给出首选对齐方式：
- en: '[PRE11]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, we declare which operations are legal. In the previous chapter, we
    only defined three logical instructions, and they are legal for 32-bit values:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们声明哪些操作是合法的。在前一章中，我们只定义了三个逻辑指令，并且它们对于32位值是合法的：
- en: '[PRE12]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'There are a couple of other actions we can use besides `Legal`. `Promote` widens
    the type, `Expand` replaces the operation with other operations, `LibCall` lowers
    the operation to a library call, and `Custom` calls the `LowerOperation()` hook
    method, which lets you implement your own custom handling. For example, in the
    M88k architecture, there is no count population instruction, so we request that
    this operation be expanded into other operations:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了`Legal`之外，我们还可以使用其他一些操作。`Promote`扩展类型，`Expand`用其他操作替换操作，`LibCall`将操作降低到库调用，而`Custom`调用`LowerOperation()`钩子方法，这允许你实现自己的自定义处理。例如，在M88k架构中，没有计数人口指令，因此我们请求将此操作扩展到其他操作：
- en: '[PRE13]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, let’s review some points to emphasize the connection between the definitions
    we made so far. In the target description mentioned in the `M88kInstrInfo.td`
    file, we defined a machine instruction with the `and` mnemonic, and we also attached
    a pattern to it. If we expand the `AND` multiclass record, and only look at the
    instruction using three registers, we get the TableGen definition:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回顾一些要点，以强调我们迄今为止所做定义之间的联系。在`M88kInstrInfo.td`文件中提到的目标描述中，我们使用`and`助记符定义了一个机器指令，并且我们还为其附加了一个模式。如果我们展开`AND`多类记录，并且只查看使用三个寄存器的指令，我们得到TableGen定义：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `"and"` string is the mnemonic of the instruction. In C++ source code, we
    use `M88k::ANDrr` to refer to this instruction. Inside the pattern, the DAG `and`
    node type is used. In C++, it is named `ISD::AND`, and we used it in the call
    to the `setOperationAction()` method. During instruction selection, a DAG node
    of the `and` type is replaced by the `M88k::ANDrr` instruction if the pattern
    matches, which includes the input operands. Thus, when we develop instruction
    selection, the most important task is for us to define the correct legalization
    actions and attach the patterns to the instruction definitions.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`"and"`字符串是指令的助记符。在C++源代码中，我们使用`M88k::ANDrr`来引用这个指令。在模式中，使用DAG `and`节点类型。在C++中，它命名为`ISD::AND`，我们在调用`setOperationAction()`方法时使用了它。在指令选择期间，如果模式匹配（包括输入操作数），则将`and`类型的DAG节点替换为`M88k::ANDrr`指令。因此，当我们开发指令选择时，最重要的任务是定义正确的合法化操作并将模式附加到指令定义上。'
- en: Implementing DAG lowering – lowering formal arguments
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现DAG降低 - 降低形式参数
- en: 'Let’s turn to another important task performed by the `M88kISelLowering` class.
    We defined the rules for the calling convention in the previous section, but we
    also need to map the physical registers and memory locations to virtual registers
    used in the DAG. For arguments, this is done in the `LowerFormalArguments()` method;
    return values are handled in the `LowerReturn()` method. First, we must handle
    the arguments:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转向`M88kISelLowering`类执行的另一个重要任务。我们在上一节中定义了调用约定的规则，但我们也需要将物理寄存器和内存位置映射到DAG中使用的虚拟寄存器。对于参数，这是在`LowerFormalArguments()`方法中完成的；返回值在`LowerReturn()`方法中处理。首先，我们必须处理参数：
- en: 'We’ll begin by including the generated source:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先包括生成的源代码：
- en: '[PRE15]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `LowerFormalArguments()` method takes several parameters. The `SDValue`
    class denotes a value associated with a DAG node and is often used when dealing
    with the DAG. The first parameter, `Chain`, represents the control flow, and the
    possible updated `Chain` is also the return value of the method. The `CallConv`
    parameter identifies the used calling convention, and `IsVarArg` is set to `true`
    if a variable argument list is part of the parameters. The arguments that need
    to be handled are passed in the `Ins` parameter, together with their location
    in the `DL` parameter. The `DAG` parameter gives us access to the `SelectionDAG`
    class. Lastly, the result of the mapping will be stored in the `InVals` vector
    argument:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`LowerFormalArguments()`方法接受多个参数。`SDValue`类表示与DAG节点关联的值，在处理DAG时经常使用。第一个参数`Chain`代表控制流，可能的更新`Chain`也是该方法的返回值。`CallConv`参数标识使用的调用约定，如果参数列表中包含可变参数，则`IsVarArg`设置为`true`。需要处理的参数通过`Ins`参数传递，同时带上它们在`DL`参数中的位置。`DAG`参数使我们能够访问`SelectionDAG`类。最后，映射的结果将存储在`InVals`向量参数中：'
- en: '[PRE16]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Our first action is to retrieve references to the machine function and the
    machine register information:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的第一步是检索机器函数和机器寄存器信息的引用：
- en: '[PRE17]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, we must call the generated code. We need to instantiate an object of
    the `CCState` class. The `CC_M88k` parameter value that’s used in the call to
    the `AnalyzeFormalArguments()` method is the name of the calling convention we
    used in the target description. The result is stored in the `ArgLocs` vector:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须调用生成的代码。我们需要实例化`CCState`类的一个对象。在调用`AnalyzeFormalArguments()`方法时使用的`CC_M88k`参数值是在目标描述中使用的调用约定名称。结果存储在`ArgLocs`向量中：
- en: '[PRE18]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once the locations of the arguments have been determined, we need to map them
    to the DAG. Therefore, we must loop over all locations:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦确定了参数的位置，我们需要将它们映射到DAG。因此，我们必须遍历所有位置：
- en: '[PRE19]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The mapping depends on the determined location. First, we handle arguments
    assigned to registers. The goal is to copy the physical register to a virtual
    register. To do so, we need to determine the correct register class. Since we’re
    only handling 32-bit values, it is easy to do this:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 映射取决于确定的地址。首先，我们处理分配给寄存器的参数。目标是把物理寄存器复制到虚拟寄存器。要做到这一点，我们需要确定正确的寄存器类别。由于我们只处理32位值，这很容易做到：
- en: '[PRE20]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'With the register class stored in the `RC` variable, we can create the virtual
    register and copy the value. We also need to declare the physical register as
    a live-in:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于寄存器类存储在`RC`变量中，我们可以创建虚拟寄存器并复制值。我们还需要将物理寄存器声明为输入活期：
- en: '[PRE21]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the definition of the calling convention, we added the rule that 8-bit and
    16-bit values should be promoted to 32-bit, and we need to ensure the promotion
    here. To do so, a DAG node must be inserted, which makes sure that the value is
    promoted. After, the value is truncated to the right size. Note that we pass the
    value of `ArgValue` as an operand to the DAG node and store the result in the
    same variable:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调用约定定义中，我们添加了规则，即8位和16位值应提升为32位，我们需要确保这里的提升。为此，必须插入一个DAG节点，以确保值被提升。之后，值被截断到正确的大小。注意，我们将`ArgValue`的值作为操作数传递给DAG节点，并将结果存储在同一个变量中：
- en: '[PRE22]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Lastly, we finish handling the register arguments by adding the DAG node to
    the result vector:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们通过将DAG节点添加到结果向量中完成对寄存器参数的处理：
- en: '[PRE23]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The other possible location for a parameter is on the stack. However, we didn’t
    define any load and store instructions, so we cannot handle this case yet. This
    ends the loop over all argument locations:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 参数的另一个可能位置是在栈上。然而，我们没有定义任何加载和存储指令，所以我们还不能处理这种情况。这标志着对所有参数位置的遍历结束：
- en: '[PRE24]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After that, we may need to add code to handle variable argument lists. Again,
    we have added some code to remind us that we have not implemented it:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们可能需要添加代码来处理可变参数列表。同样，我们已经添加了一些代码来提醒我们尚未实现它：
- en: '[PRE25]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, we must return the `Chain` argument:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们必须返回`Chain`参数：
- en: '[PRE26]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Implementing DAG lowering – lowering return values
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现DAG降低 – 降低返回值
- en: 'The return values are handled similarly. However, we must extend the target
    description for them. First, we need to define a new DAG node type called `RET_GLUE`.
    This DAG node type is used to glue the return values together, which prevents
    them from being rearranged, for example, by the instruction scheduler. The definition
    in `M88kInstrInfo.td` is as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值处理方式类似。然而，我们必须扩展它们的目标描述。首先，我们需要定义一个新的DAG节点类型，称为`RET_GLUE`。这种DAG节点类型用于将返回值粘合在一起，防止它们被重新排列，例如，由指令调度器。`M88kInstrInfo.td`中的定义如下：
- en: '[PRE27]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the same file, we also define a pseudo-instruction to represent a return
    from a function call, which will be selected for a `RET_GLUE` node:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一文件中，我们还定义了一个伪指令来表示函数调用的返回，它将被选择为`RET_GLUE`节点：
- en: '[PRE28]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We will expand this pseudo-instruction when we generate the output.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们生成输出时，我们将扩展这个伪指令。
- en: 'With these definitions in place, we can implement the `LowerReturn()` method:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些定义到位后，我们可以实现`LowerReturn()`方法：
- en: 'The parameters are the same as for `LowerFormalArguments()`, only the order
    is slightly different:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 参数与`LowerFormalArguments()`相同，只是顺序略有不同：
- en: '[PRE29]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'First, we call the generated code, this time using the `RetCC_M88k` calling
    convention:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们称生成的代码为`RetCC_M88k`调用约定：
- en: '[PRE30]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, we loop over the locations again. With the simple definition of the calling
    convention we currently have, this loop will be executed once at most. However,
    this would change if we would add support for returning 64-bit values, which need
    to be returned in two registers:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们再次遍历位置。根据我们目前拥有的简单调用约定定义，这个循环最多执行一次。然而，如果我们添加对返回64位值的支持，这需要用两个寄存器返回，这将会改变：
- en: '[PRE31]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After, we copy the return values into the physical registers assigned to the
    return value. This is mostly similar to handling the arguments, with the exception
    that the values are glued together using the `Glue` variable:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们将返回值复制到分配给返回值的物理寄存器中。这主要与处理参数类似，但有一个例外，即使用`Glue`变量将值粘合在一起：
- en: '[PRE32]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The return value is the chain and the glued register copy operations. The latter
    is only returned if there is a value to return:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回值是链和粘合的寄存器复制操作。后者仅在存在返回值时返回：
- en: '[PRE33]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, we construct a DAG node of the `RET_GLUE` type, passing in the necessary
    values:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们构建一个`RET_GLUE`类型的DAG节点，传递必要的值：
- en: '[PRE34]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Congratulations! With these definitions, the foundation has been laid for instruction
    selection.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！有了这些定义，指令选择的基石已经奠定。
- en: Implementing DAG-to-DAG transformations within instruction selection
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在指令选择中实现DAG到DAG转换
- en: 'One crucial part is still missing: we need to define the pass that performs
    the DAG transformations defined in the target descriptions. The class is called
    `M88kDAGToDAGISel` and is stored in the `M88kISelDAGToDAG.cpp` file. Most of the
    class is generated, but we still need to add some code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个关键部分缺失：我们需要定义执行目标描述中定义的DAG转换的pass。类名为`M88kDAGToDAGISel`，存储在`M88kISelDAGToDAG.cpp`文件中。类的大部分是自动生成的，但我们仍然需要添加一些代码：
- en: 'We’ll begin by defining the debug type and providing a descriptive name for
    the pass:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先定义调试类型并为传递提供描述性名称：
- en: '[PRE35]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, we must declare the class inside an anonymous namespace. We will only
    override the `Select()` method; the other code is generated and included in the
    body of the class:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们必须在匿名命名空间内声明类。我们只重写`Select()`方法；其他代码在类的主体中生成并包含：
- en: '[PRE36]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'After, we must add the code to initialize the pass. The LLVM backends still
    use the legacy pass manager, and the setup differs from the pass manager used
    for IR transformations. The static member `ID` value is used to identify the pass.
    Initializing the pass can be implemented using the `INITIALIZE_PASS` macro, which
    expands to C++ code. We must also add a factory method to create an instance of
    the pass:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们必须添加初始化传递的代码。LLVM后端仍然使用传统的传递管理器，其设置与用于IR转换的传递管理器不同。使用静态成员`ID`值来识别传递。可以通过使用`INITIALIZE_PASS`宏来实现传递的初始化，该宏展开为C++代码。我们还必须添加一个工厂方法来创建传递的实例：
- en: '[PRE37]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, we must implement the `Select()` method. For now, we only call the
    generated code. However, if we encounter a complex transformation that we cannot
    express as a DAG pattern, then we can add our own code to perform the transformation
    before calling the generated code:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们必须实现`Select()`方法。目前，我们只调用生成的代码。然而，如果我们遇到无法表示为DAG模式的复杂转换，那么我们可以在调用生成的代码之前添加我们自己的代码来执行转换：
- en: '[PRE38]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: With that, we have implemented the instruction selection. However, we still
    need to add some support classes before we can do the first test. We’ll look at
    those classes in the next few sections.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就实现了指令选择。然而，在我们进行第一次测试之前，我们还需要添加一些支持类。我们将在接下来的几节中查看这些类。
- en: Adding register and instruction information
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加寄存器和指令信息
- en: 'The target description captures most information about registers and instructions.
    To access that information, we must implement the `M88kRegisterInfo` and `M88kInstrInfo`
    classes. These classes also contain hooks that we can override to accomplish tasks
    that are too complex to express in the target description. Let’s begin with the
    `M88kRegisterInfo` class, which is declared in the `M88kRegisterInfo.h` file:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 目标描述捕获了关于寄存器和指令的大部分信息。要访问这些信息，我们必须实现`M88kRegisterInfo`和`M88kInstrInfo`类。这些类还包含我们可以重写的钩子，以完成在目标描述中难以表达的任务。让我们从在`M88kRegisterInfo.h`文件中声明的`M88kRegisterInfo`类开始：
- en: 'The header file begins by including the code generated from the target description:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 头文件首先包含来自目标描述生成的代码：
- en: '[PRE39]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'After that, we must declare the `M88kRegisterInfo` class in the `llvm` namespace.
    We only override a couple of methods:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们必须在`llvm`命名空间中声明`M88kRegisterInfo`类。我们只重写了几个方法：
- en: '[PRE40]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The definition of the class is stored in the `M88kRegisterInfo.cpp` file:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 类的定义存储在`M88kRegisterInfo.cpp`文件中：
- en: 'Again, the film begins with including the code generated from the target description:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，电影从包含来自目标描述生成的代码开始：
- en: '[PRE41]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The constructor initializes the superclass, passing the register holding the
    return address as a parameter:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数初始化超类，将包含返回地址的寄存器作为参数传递：
- en: '[PRE42]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then, we implement the method that returns the list of callee-saved registers.
    We defined the list in the target description, and we only return that list:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们实现返回调用者保留寄存器列表的方法。我们在目标描述中定义了该列表，并且只返回该列表：
- en: '[PRE43]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'After, we deal with the reserved registers. The reserved registers depend on
    the platform and the hardware. The `r0` register contains a constant value of
    `0`, so we treat it as a reserved register. The `r28` and `r29` registers are
    always reserved for use by a linker. Lastly, the `r31` register is used as a stack
    pointer. This list may depend on the function, and it cannot be generated due
    to this dynamic behavior:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们处理保留寄存器。保留寄存器取决于平台和硬件。`r0`寄存器包含常量值`0`，因此我们将其视为保留寄存器。`r28`和`r29`寄存器始终保留供链接器使用。最后，`r31`寄存器用作栈指针。此列表可能取决于函数，并且由于这种动态行为，它不能生成：
- en: '[PRE44]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If a frame register is required, then `r30` is used. Please note that our code
    does not support creating a frame yet. If the function requires a frame, then
    `r30` must also be marked as reserved in the `getReservedRegs()` method. However,
    we must implement this method because it is declared pure virtual in the superclass:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要帧寄存器，则使用`r30`。请注意，我们的代码目前还不支持创建帧。如果函数需要帧，那么`r30`也必须在`getReservedRegs()`方法中标记为保留。然而，我们必须实现此方法，因为它在超类中被声明为纯虚函数：
- en: '[PRE45]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Similarly, we need to implement the `eliminateFrameIndex()` method because
    it is declared *pure virtual*. It is called to replace a frame index in an operand
    with the correct value to use to address the value on the stack:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，我们需要实现`eliminateFrameIndex()`方法，因为它被声明为*纯虚*。它被调用以将操作数中的框架索引替换为用于在栈上寻址值的正确值：
- en: '[PRE46]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `M88kInstrInfo` class has many hook methods we can override to accomplish
    special tasks, for example, for branch analysis and rematerialization. For now,
    we’re only overriding the `expandPostRAPseudo()` method, in which we expand the
    pseudo-instruction RET. Let’s begin with the header file, `M88kInstrInfo.h`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`M88kInstrInfo`类有许多我们可以重写的钩子方法来完成特殊任务，例如，用于分支分析和重载。现在，我们只重写`expandPostRAPseudo()`方法，在这个方法中，我们扩展伪指令RET。让我们从头文件`M88kInstrInfo.h`开始：'
- en: 'The header file begins with including the generated code:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 头文件以包含生成的代码开始：
- en: '[PRE47]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `M88kInstrInfo` class derives from the generated `M88kGenInstrInfo` class.
    Besides overriding the `expandPostRAPseudo()` method, the only other addition
    is that this class owns an instance of the previously defined class, `M88kRegisterInfo`:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`M88kInstrInfo`类从生成的`M88kGenInstrInfo`类派生。除了重写`expandPostRAPseudo()`方法外，唯一的其他添加是，这个类拥有先前定义的类`M88kRegisterInfo`的一个实例：'
- en: '[PRE48]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The implementation is stored in the `M88kInstrInfo.cpp` class:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 实现存储在`M88kInstrInfo.cpp`类中：
- en: 'Like the header file, the implementation begins with including the generated
    code:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与头文件一样，实现以包含生成的代码开始：
- en: '[PRE49]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then, we define the `anchor()` method, which is used to pin the vtable to this
    file:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义`anchor()`方法，它用于将vtable固定到这个文件：
- en: '[PRE50]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Finally, we expand `RET` in the `expandPostRAPseudo()` method. As its name
    suggests, this method is invoked after the register allocator runs and is intended
    to expand the pseudo-instruction, which may still be mixed with the machine code.
    If the opcode of the machine instruction, `MI`, is the pseudo-instruction, `RET`,
    we must insert the `jmp %r1` jump instruction, which is the instruction to exit
    a function. Then, we copy all implicit operands that represent the values to return
    and we delete the pseudo instruction. If we need other pseudo-instructions during
    code generation, then we can extend this function to expand them here too:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们在`expandPostRAPseudo()`方法中扩展`RET`。正如其名称所暗示的，这个方法在寄存器分配器运行之后被调用，目的是扩展伪指令，该伪指令可能仍然与机器代码混合。如果机器指令的指令码`MI`是伪指令`RET`，我们必须插入`jmp
    %r1`跳转指令，这是退出函数的指令。然后，我们复制所有表示要返回值的隐式操作数，并删除伪指令。如果在代码生成过程中需要其他伪指令，我们也可以扩展这个函数来在这里扩展它们：
- en: '[PRE51]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Both classes have minimal implementations. If you continue to develop the target,
    then many more methods need to be overridden. It is worth reading the comments
    in the `TargetInstrInfo` and `TargetRegisterInfo` base classes, which you can
    find in the `llvm/include/llvm/CodeGen` directory.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 两个类都有最小实现。如果你继续开发目标，那么还需要重写更多方法。阅读`TargetInstrInfo`和`TargetRegisterInfo`基类的注释是值得的，这些基类可以在`llvm/include/llvm/CodeGen`目录中找到。
- en: We still need more classes to get the instruction selection running. Next, we’ll
    look at frame lowering.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要更多类来使指令选择运行。接下来，我们将查看框架降低。
- en: Putting an empty frame lowering in place
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将一个空的框架降低框架放置到位
- en: 'The binary interface of a platform not only defines how parameters are passed.
    It also includes how a stack frame is laid out: in which places are local variables
    stored, where registers are spilled to, and so on. Often, a special instruction
    sequence is required at the beginning and end of a function, called the `TargetFrameLowering`
    is available. The easy solution is to provide the `M88kFrameLowering` class with
    an empty implementation.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 平台的二进制接口不仅定义了参数的传递方式。它还包括如何布局栈帧：局部变量存储在哪些位置，寄存器溢出到哪里等等。通常，在函数的开始和结束需要一段特殊的指令序列，称为`TargetFrameLowering`可用。简单的解决方案是为`M88kFrameLowering`类提供一个空的实现。
- en: 'The declaration of the class is in the `M88kFrameLowering.h` file. All we must
    do here is override the pure virtual functions:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 类的声明在`M88kFrameLowering.h`文件中。我们在这里必须重写纯虚函数：
- en: '[PRE52]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The implementation, which is stored in the `M88kFrameLowering.cpp` file, provides
    some basic details about stack frames in the constructor. The stack grows downwards,
    to smaller addresses, and is aligned on 8-byte boundaries. When a function is
    called, the local variables are stored directly below the stack pointer of the
    calling function, so the offset of the local area is `0`. Even during a function
    call, the stack should remain aligned at an 8-byte boundary. The last parameter
    implies that the stack cannot be realigned. The other functions just have an empty
    implementation:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在`M88kFrameLowering.cpp`文件中的实现，在构造函数中提供了一些关于栈帧的基本细节。栈向下增长，到较小的地址，并且对齐在8字节边界上。当一个函数被调用时，局部变量直接存储在调用函数的栈指针下方，因此局部区域的偏移量是`0`。即使在函数调用期间，栈也应该保持在8字节边界上对齐。最后一个参数意味着栈不能重新对齐。其他函数只是有一个空的实现：
- en: '[PRE53]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Of course, as soon as our implementation grows, this class will be one of the
    first that needs to be fully implemented.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，一旦我们的实现增长，这个类将是首先需要完全实现的第一批之一。
- en: Before we can put all the pieces together, we need to implement the assembly
    printer, which is used to emit machine instructions.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以将所有这些部分组合在一起之前，我们需要实现汇编打印机，它用于发出机器指令。
- en: Emitting machine instructions
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发出机器指令
- en: The instruction selection creates machine instructions, represented by the `MachineInstr`
    class, from LLVM IR. But this is not the end. An instance of the `MachineInstr`
    class still carries additional information, such as labels or flags. To emit an
    instruction via the machine code component, we need to lower the instances of
    `MachineInstr` to instances of `MCInst`. By doing this, the machine code component
    provides the functionality to write instructions into object files or print them
    as assembler text. The `M88kAsmPrinter` class is responsible for emitting a whole
    compilation unit. Lowering an instruction is delegated to the `M88kMCInstLower`
    class.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 指令选择从LLVM IR创建机器指令，表示为`MachineInstr`类。但这并不是结束。`MachineInstr`类的一个实例仍然携带额外的信息，例如标签或标志。要通过机器代码组件发出指令，我们需要将`MachineInstr`实例降低到`MCInst`实例。通过这样做，机器代码组件提供了将指令写入对象文件或将它们作为汇编文本打印出来的功能。`M88kAsmPrinter`类负责发出整个编译单元。指令降低被委托给`M88kMCInstLower`类。
- en: 'The assembly printer is the last pass to run in a backend. Its implementation
    is stored in the `M88kAsmPrinter.cpp` file:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编打印机是在后端运行的最后一个阶段。它的实现存储在`M88kAsmPrinter.cpp`文件中：
- en: 'The declaration of the `M88kAsmPrinter` class is in an anonymous namespace.
    Besides the constructor, we only override the `getPassName()` function, which
    returns the name of the pass as a human-readable string, and the `emitInstruction()`
    function:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`M88kAsmPrinter`类的声明在一个匿名命名空间中。除了构造函数外，我们只重写了`getPassName()`函数，它返回一个人类可读的字符串作为阶段的名称，以及`emitInstruction()`函数：'
- en: '[PRE54]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Like many other classes, we have to register our assembly printer in the target
    registry:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像许多其他类一样，我们必须在我们的目标注册表中注册我们的汇编打印机：
- en: '[PRE55]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `emitInstruction()` method is responsible for emitting the machine instruction,
    `MI`, to the output stream. In our implementation, we delegate the lowering of
    the instruction to the `M88kMCInstLower` class:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`emitInstruction()`方法负责将机器指令`MI`发出到输出流。在我们的实现中，我们将指令降低委托给`M88kMCInstLower`类：'
- en: '[PRE56]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This is already the full implementation. The base class, `AsmPrinter`, provides
    many useful hooks you can override. For example, the `emitStartOfAsmFile()` method
    is called before anything is emitted, and `emitEndOfAsmFile()` is called after
    everything is emitted. These methods can emit target-specific data or code at
    the beginning and the end of a file. Similarly, the `emitFunctionBodyStart()`
    and `emitFunctionBodyEnd()` methods are called before and after a function body
    is emitted. Read the comments in the `llvm/include/llvm/CodeGen/AsmPrinter.h`
    file to understand what can be customized.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经是完整的实现。基类`AsmPrinter`提供了许多你可以重写的有用钩子。例如，`emitStartOfAsmFile()`方法在发出任何内容之前被调用，而`emitEndOfAsmFile()`方法在发出所有内容之后被调用。这些方法可以在文件的开始和结束时发出特定目标的数据或代码。同样，`emitFunctionBodyStart()`和`emitFunctionBodyEnd()`方法在函数体发出之前和之后被调用。阅读`llvm/include/llvm/CodeGen/AsmPrinter.h`文件中的注释，以了解可以自定义的内容。
- en: 'The `M88kMCInstLower` class lowers operands and instructions, and our implementation
    contains two methods for that purpose. The declaration is in the `M88kMCInstLower.h`
    file:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`M88kMCInstLower`类降低操作数和指令，我们的实现包含两个用于此目的的方法。声明在`M88kMCInstLower.h`文件中：'
- en: '[PRE57]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The definition goes into the `M88kMCInstLower.cpp` file:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 定义被放入到 `M88kMCInstLower.cpp` 文件中：
- en: 'To lower `MachineOperand` to `MCOperand`, we need to check the operand type.
    Here, we only handle registers and immediates by creating `MCOperand`-equivalent
    register and immediate values by supplying the original `MachineOperand` values.
    As soon as expressions are introduced as operands, this method needs to be enhanced:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了将 `MachineOperand` 降低到 `MCOperand`，我们需要检查操作数类型。在这里，我们只通过创建与 `MCOperand` 等效的寄存器和立即数值来处理寄存器和立即数，这些值由原始的
    `MachineOperand` 值提供。一旦表达式作为操作数引入，这种方法就需要增强：
- en: '[PRE58]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The lowering of an instruction is similar. First, the opcode is copied, and
    then the operands are handled. An instance of `MachineInstr` can have implicit
    operands attached, which are not lowered, and we need to filter them:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指令的降低过程类似。首先，将操作码复制，然后处理操作数。`MachineInstr` 实例可以附加隐式操作数，这些操作数不会被降低，我们需要过滤它们：
- en: '[PRE59]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: With that, we’ve implemented the assembly printer. Now, we need to bring all
    the pieces together. We’ll do this in the next section.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就实现了汇编打印机。现在，我们需要将所有这些部分组合在一起。我们将在下一节中这样做。
- en: Creating the target machine and the sub-target
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建目标机器和子目标
- en: So far, we’ve implemented the instruction selection classes and a couple of
    other classes. Now, we need to set up how our backend will work. Like the optimization
    pipeline, a backend is divided into passes. Configuring those passes is the main
    task of the `M88kTargetMachine` class. In addition, we need to specify which features
    are available for instruction selection. Usually, a platform is a family of CPUs,
    which all have a common set of instructions but differ by specific extensions.
    For example, some CPUs have vector instructions, while others do not. In LLVM
    IR, a function can have attributes attached that specify for which CPU this function
    should be compiled, or what features are available. In other words, each function
    could have a different configuration, which is captured in the `M88kSubTarget`
    class.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经实现了指令选择类和一些其他类。现在，我们需要设置我们的后端如何工作。就像优化管道一样，后端被分为多个阶段。配置这些阶段是 `M88kTargetMachine`
    类的主要任务。此外，我们还需要指定哪些功能可用于指令选择。通常，一个平台是一系列 CPU，它们都有一个共同的指令集，但具有特定的扩展不同。例如，一些 CPU
    有向量指令，而另一些则没有。在 LLVM IR 中，一个函数可以附加属性来指定该函数应该为哪个 CPU 编译，或者哪些功能可用。换句话说，每个函数可能有一个不同的配置，这被
    `M88kSubTarget` 类捕获。
- en: Implementing M88kSubtarget
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现 M88kSubtarget
- en: 'Let’s implement the `M88kSubtarget` class first. The declaration is stored
    in the `M88kSubtarget.h` class:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先实现 `M88kSubtarget` 类。声明存储在 `M88kSubtarget.h` 类中：
- en: 'Parts of the sub-target are generated from the target description, and we include
    those codes first:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 子目标的某些部分是从目标描述中生成的，我们首先包含这些代码：
- en: '[PRE60]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Then, we declare the class, deriving it from the generated `M88kGenSubtargetInfo`
    class. The class owns a couple of previously defined classes – the instruction
    information, the target lowering class, and the frame lowering class:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们声明该类，从生成的 `M88kGenSubtargetInfo` 类派生。该类拥有几个先前定义的类——指令信息、目标降低类和帧降低类：
- en: '[PRE61]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The sub-target is initialized with the target triple, the name of the CPU,
    and a feature string, as well as with the target machine. All these parameters
    describe the hardware for which our backend will generate code:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 子目标使用目标三元组、CPU 名称、特征字符串以及目标机器进行初始化，所有这些参数描述了我们的后端将为其生成代码的硬件：
- en: '[PRE62]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Next, we include the generated file again, this time for automatically defining
    getter methods for features defined in the target description:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们再次包含生成的文件，这次是为了自动定义在目标描述中定义的功能的获取方法：
- en: '[PRE63]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'In addition, we need to declare the `ParseSubtargetFeatures()` method. The
    method itself is generated from the target description:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们需要声明 `ParseSubtargetFeatures()` 方法。该方法本身是从目标描述中生成的：
- en: '[PRE64]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Next, we must add getter methods for the member variables:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须为成员变量添加获取方法：
- en: '[PRE65]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Finally, we must add a getter method for the register information, which is
    owned by the instruction information class. This finishes the declaration:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们必须为属于指令信息类的寄存器信息添加一个获取方法，这完成了声明：
- en: '[PRE66]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Next, we must implement the actual subtarget class. The implementation is stored
    in the `M88kSubtarget.cpp` file:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须实现实际的子目标类。实现存储在 `M88kSubtarget.cpp` 文件中：
- en: 'Again, we begin the file by including the generated source:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，我们首先通过包含生成的源文件来开始文件：
- en: '[PRE67]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Then, we define the anchor method, which pins the vtable to this file:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义锚定方法，它将vtable固定到这个文件：
- en: '[PRE68]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Finally, we define the constructor. Note that the generated class expected
    two CPU parameters: the first one for the instruction set, and the second one
    for scheduling. The use case here is that you want to optimize the code for the
    latest CPU but still be able to run the code on an older CPU. We do not support
    this feature and use the same CPU name for both parameters:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们定义构造函数。请注意，生成的类期望两个CPU参数：第一个用于指令集，第二个用于调度。这里的用例是，你想要优化最新CPU的代码，但仍然能够在旧CPU上运行代码。我们不支持此功能，并为两个参数使用相同的CPU名称：
- en: '[PRE69]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Implementing M88kTargetMachine – defining the definitions
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现M88kTargetMachine – 定义定义
- en: Finally, we can implement the `M88kTargetMachine` class. This class holds all
    used sub-target instances. It also owns a subclass of `TargetLoweringObjectFile`,
    which provides details such as section names to the lowering process. Lastly,
    it creates the configuration of the passes that runs in this backend.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以实现`M88kTargetMachine`类。这个类持有所有使用的子目标实例。它还拥有一个`TargetLoweringObjectFile`的子类，为降低过程提供如段名称等详细信息。最后，它创建在这个后端运行的传递配置。
- en: 'The declaration in the `M88kTargetMachine.h` file is as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`M88kTargetMachine.h`文件中的声明如下：'
- en: 'The `M88kTargetMachine` class derives from the `LLVMTargetMachine` class. The
    only members are an instance of `TargetLoweringObjectFile` and the sub-target
    map:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`M88kTargetMachine`类从`LLVMTargetMachine`类派生。唯一的成员是一个`TargetLoweringObjectFile`实例和子目标映射：'
- en: '[PRE70]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The parameters of the constructor completely describe the target configuration
    for which we will generate code. With the `TargetOptions` class, many details
    of the code generations can be controlled – for example, if floating-point multiply-and-add
    instructions can be used or not. Also, the relocation model, the code model, and
    the optimization level are passed to the constructor. Notably, the `JIT` parameter
    is set to true if the target machine is used for just-in-time compilation.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数的参数完全描述了我们将为其生成代码的目标配置。使用`TargetOptions`类，可以控制代码生成的许多细节 – 例如，是否可以使用浮点乘加指令。此外，重定位模型、代码模型和优化级别都传递给构造函数。值得注意的是，如果目标机器用于即时编译，则`JIT`参数设置为true。
- en: '[PRE71]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We also need to override some methods. The `getSubtargetImpl()` method returns
    the sub-target instance to use for the given function, and the `getObjFileLowering()`
    method just returns the member variable. In addition, we override the `createPassConfig()`
    method, which returns our configuration for the backend passes:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要重写一些方法。`getSubtargetImpl()`方法返回用于给定函数的子目标实例，而`getObjFileLowering()`方法仅返回成员变量。此外，我们重写`createPassConfig()`方法，它返回后端传递的配置：
- en: '[PRE72]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Implementing M88kTargetMachine – adding the implementation
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现M88kTargetMachine – 添加实现
- en: 'The implementation of the class is stored in the `M88kTargetMachine.cpp` file.
    Please note that we created this file in [*Chapter 11*](B19561_11.xhtml#_idTextAnchor177).
    Now, we will replace this file with a complete implementation:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 类的实现存储在`M88kTargetMachine.cpp`文件中。请注意，我们在[*第11章*](B19561_11.xhtml#_idTextAnchor177)中创建了此文件。现在，我们将用完整的实现替换此文件：
- en: 'First, we must register the target machine. In addition, we must initialize
    the DAG-to-DAG pass via the initialization function we defined earlier:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须注册目标机器。此外，我们必须通过我们之前定义的初始化函数初始化DAG-to-DAG传递：
- en: '[PRE73]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Next, we must define the support function, `computeDataLayout()`. We talked
    about the data layout string in [*Chapter 4*](B19561_04.xhtml#_idTextAnchor068),
    *Basics of IR Code Generation*. In this function, the data layout, as the backend,
    expects it to be defined. Since the data layout depends on hardware features,
    the triple, the name of the CPU, and the feature set string are passed to this
    function. We create the data layout string with the following components. The
    target is big-endian (`E`) and uses the `ELF` symbol mangling.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须定义支持函数，`computeDataLayout()`。我们曾在[*第4章*](B19561_04.xhtml#_idTextAnchor068)中讨论了数据布局字符串，*IR代码生成基础*。在这个函数中，数据布局作为后端，期望它被定义。由于数据布局依赖于硬件特性，因此将三元组、CPU名称和特性集字符串传递给此函数。我们使用以下组件创建数据布局字符串。目标是大端(`E`)并使用`ELF`符号混淆。
- en: 'Pointers are 32-bit wide and 32-bit aligned. All scalar types are naturally
    aligned. The `MC88110` CPU has an extended register set and supports 80-bit wide
    floating points. If we were to support this special feature, then we’d need to
    add a check of the CPU name here and extend the string with the floating-point
    values accordingly. Next, we must state that all globals have a preferred alignment
    of 16-bit and that the hardware has only 32-bit registers:'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 指针宽度为32位，且32位对齐。所有标量类型都是自然对齐的。`MC88110` CPU有一个扩展的寄存器集，并支持80位宽的浮点数。如果我们支持这个特殊特性，那么我们需要在这里添加对CPU名称的检查，并相应地扩展字符串以包含浮点值。接下来，我们必须声明所有全局变量都有一个首选的16位对齐，并且硬件只有32位寄存器：
- en: '[PRE74]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now, we can define the constructor and destructor. Many of the parameters are
    just passed to the superclass constructor. Note that our `computeDataLayout()`
    function is called here. In addition, the `TLOF` member is initialized with an
    instance of `TargetLoweringObjectFileELF`, since we are using the ELF file format.
    In the body of the constructor, we must call the `initAsmInfo()` method, which
    initializes many data members of the superclass:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以定义构造函数和析构函数。许多参数只是传递给超类构造函数。请注意，我们的`computeDataLayout()`函数在这里被调用。此外，`TLOF`成员使用`TargetLoweringObjectFileELF`的实例初始化，因为我们使用的是ELF文件格式。在构造函数的主体中，我们必须调用`initAsmInfo()`方法，该方法初始化超类中的许多数据成员：
- en: '[PRE75]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'After, we define the `getSubtargetImpl()` method. The sub-target instance to
    use depends on the `target-cpu` and `target-features` function attributes. For
    example, the `target-cpu` attribute could be set to `MC88110`, thus targeting
    the second-generation CPU. However, the attribute target feature could describe
    that we should not use the graphics instructions of that CPU. We have not defined
    the CPUs and their features in the target description yet, so we are doing a bit
    more than what’s necessary here. However, the implementation is simple enough:
    we query the function attributes and use either the returned strings or the default
    values. With this information, we can query the `SubtargetMap` member, and if
    it’s not found, we create the sub-target:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们定义了`getSubtargetImpl()`方法。要使用的子目标实例取决于`target-cpu`和`target-features`函数属性。例如，`target-cpu`属性可以设置为`MC88110`，从而针对第二代CPU。然而，目标特性属性可能描述我们不应该使用该CPU的图形指令。我们尚未在目标描述中定义CPU及其特性，因此我们在这里做了比必要的更多的工作。然而，实现足够简单：我们查询函数属性，并使用返回的字符串或默认值。有了这些信息，我们可以查询`SubtargetMap`成员，如果找不到，我们创建子目标：
- en: '[PRE76]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Finally, we create the pass configuration. For this, we need our own class,
    `M88kPassConfig`, which derives from the `TargetPassConfig` class. We only override
    the `addInstSelector` method:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们创建传递配置。为此，我们需要我们自己的类，`M88kPassConfig`，它从`TargetPassConfig`类派生。我们只重写了`addInstSelector`方法：
- en: '[PRE77]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'With this definition, we can implement the `createPassConfig` factory method:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过这个定义，我们可以实现`createPassConfig`工厂方法：
- en: '[PRE78]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Lastly, we must add our instruction selection class to the pass pipeline in
    the `addInstSelector()` method. The return value, `false`, indicates that we have
    added a pass that converts LLVM IR into machine instructions:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们必须在`addInstSelector()`方法中将我们的指令选择类添加到传递管道中。返回值`false`表示我们已经添加了一个将LLVM IR转换为机器指令的传递：
- en: '[PRE79]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'That was a long journey to finish the implementation! Now that we’ve built
    the `llc` tool, we can run an example. Save the following simple IR in the `and.ll`
    file:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 完成实现是一个漫长的旅程！现在我们已经构建了`llc`工具，我们可以运行一个示例。将以下简单的IR保存到`and.ll`文件中：
- en: '[PRE80]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Now, we can run `llc` and verify that the generated assembly looks reasonable:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行`llc`并验证生成的汇编代码是否合理：
- en: '[PRE81]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: To compile for the `m88k` target, we must specify the triple on the command
    line, as in this example, or in the IR file.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 要为`m88k`目标编译，我们必须在命令行上指定三元组，就像这个例子中一样，或者在IR文件中。
- en: Enjoy your success for a bit before we look at global instruction selection.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看全局指令选择之前，先享受一下成功的喜悦。
- en: Global instruction selection
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局指令选择
- en: Instruction selection via the selection DAG produces fast code, but it takes
    time to do so. The speed of the compiler is often critical for developers, who
    want to quickly try out the changes they’ve made. Usually, the compiler should
    be very fast at optimization level `0`, but it can take more time with increased
    optimization levels. However, constructing the selection DAG costs so much time
    that this approach does not scale as required. The first solution was to create
    another instruction selection algorithm called `FastISel`, which is fast but does
    not generate good code. It also does not share code with the selection DAG implementation,
    which is an obvious problem. Because of this, not all targets support `FastISel`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择DAG进行指令选择可以生成快速代码，但这需要时间。编译器的速度对于开发者来说往往至关重要，他们希望快速尝试他们所做的更改。通常，编译器在优化级别`0`时应该非常快，但随着优化级别的提高，它可能需要更多的时间。然而，构建选择DAG需要花费大量时间，因此这种方法无法按需扩展。第一个解决方案是创建另一个名为`FastISel`的指令选择算法，它速度快但生成的代码质量不佳。它也没有与选择DAG实现共享代码，这是一个明显的问题。正因为如此，并非所有目标都支持`FastISel`。
- en: 'The selection DAG approach does not scale because it is a large, monolithic
    algorithm. If we can avoid creating a new data structure such as the selection
    DAG, then we should be able to perform the instruction selection using small components.
    The backend already has a pass pipeline, so using passes is a natural choice.
    Based on these thoughts, GlobalISel performs the following steps:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 选择DAG方法无法扩展，因为它是一个庞大且单一化的算法。如果我们能避免创建像选择DAG这样的新数据结构，那么我们应该能够使用小型组件执行指令选择。后端已经有一个传递管道，因此使用传递是一个自然的选择。基于这些想法，GlobalISel执行以下步骤：
- en: First, the LLVM IR is lowered into generic machine instructions. Generic machine
    instructions represent the most common operation found in real hardware. Note
    that this translation uses the machine functions and machine basic blocks, which
    means it directly translates into the data structures used by the other parts
    of the backend.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将LLVM IR降低到通用机器指令。通用机器指令代表了在真实硬件中最常见的操作。请注意，这种转换使用机器函数和机器基本块，这意味着它直接转换为后端其他部分使用的数据结构。
- en: The generic machine instructions are then legalized.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将通用机器指令合法化。
- en: After, the operands of generic machine instructions are mapped to register banks.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，将通用机器指令的操作数映射到寄存器银行。
- en: Finally, the generic instructions are replaced with real machine instructions,
    using the patterns defined in the target description.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用目标描述中定义的模式将通用指令替换为真实机器指令。
- en: Since these are all passes, we can insert as many passes as we want in between.
    For example, a combiner pass could be used to replace a sequence of generic machine
    instructions with another generic machine instruction, or with a real machine
    instruction. Turning these additional passes off increases the compilation speed
    while turning them on improves the quality of the generated code. Hence, we can
    scale as we need.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些都是传递，我们可以在其中插入任意多的传递。例如，一个组合传递可以用来将一系列通用机器指令替换为另一个通用机器指令，或者是一个真实机器指令。关闭这些额外的传递可以提高编译速度，而开启它们则能提升生成代码的质量。因此，我们可以根据需要调整规模。
- en: There is another advantage in this approach. The selection DAG translates basic
    block by basic block, but a machine pass works on a machine function, which enables
    us to consider all basic blocks of a function during instruction selections. Therefore,
    this instruction selection method is called global instruction selection (GlobalISel).
    Let’s have a look at how this approach works, starting with the transformation
    of calls.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法还有另一个优点。选择DAG按基本块逐个翻译，但机器传递是在机器函数上工作的，这使得我们能够在指令选择时考虑函数的所有基本块。因此，这种指令选择方法被称为全局指令选择（GlobalISel）。让我们看看这种方法是如何工作的，从调用转换开始。
- en: Lowering arguments and return values
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 降低参数和返回值
- en: 'For translating the LLVM IR to generic machine instructions, we only need to
    implement how arguments and return values are handled. Again, the implementation
    can be simplified by using the generated code from the target description. The
    class we’ll create is called `M88kCallLowering`, and the declaration is in the
    `GISel/M88kCallLowering.h` header file:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 对于将LLVM IR转换为通用机器指令，我们只需要实现如何处理参数和返回值。同样，可以通过使用目标描述生成的代码来简化实现。我们将创建的类称为`M88kCallLowering`，其声明在`GISel/M88kCallLowering.h`头文件中：
- en: '[PRE82]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The GlobalISel framework will call the `lowerReturn()` and `lowerFormalArguments()`
    methods when a function is translated. To translate a function call, you would
    need to override and implement the `lowerCall()` method as well. Please note that
    we also need to override `enableBigEndian()`. Without it, the wrong machine code
    would be generated.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数被转换时，GlobalISel 框架将调用 `lowerReturn()` 和 `lowerFormalArguments()` 方法。为了转换函数调用，你还需要覆盖并实现
    `lowerCall()` 方法。请注意，我们还需要覆盖 `enableBigEndian()`。如果没有它，将会生成错误的机器代码。
- en: 'For the implementation in the `GISel/M88kCallLowering.cpp` file, we need to
    define to support classes. The generated code from the target description tells
    us how a parameter is passed – for example, in a register. We need to create a
    subclass of `ValueHandler` to generate the machine instructions for it. For incoming
    parameters, we need to derive our class from `IncomingValueHandler`, as well as
    for the return value from `OutgoingValueHandler`. Both are very similar, so we’ll
    only look at the handler for incoming arguments:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `GISel/M88kCallLowering.cpp` 文件中的实现，我们需要定义支持类。从目标描述生成的代码告诉我们参数是如何传递的——例如，在寄存器中。我们需要创建一个
    `ValueHandler` 的子类来生成它的机器指令。对于传入的参数，我们需要从 `IncomingValueHandler` 派生我们的类，以及对于返回值从
    `OutgoingValueHandler` 派生。这两个都非常相似，所以我们只看传入参数的处理器：
- en: '[PRE83]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'So far, we can only handle parameters passed in registers, so we must provide
    a dummy implementation for the other methods. The `assignValueToReg()` method
    copies the value of the incoming physical register to a virtual register, performing
    a truncation if necessary. All we have to do here is mark the physical register
    as live-in to the function, and call the superclass implementation:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只能处理通过寄存器传递的参数，因此我们必须为其他方法提供虚拟实现。`assignValueToReg()` 方法将传入的物理寄存器的值复制到虚拟寄存器，如果需要则进行截断。我们在这里要做的只是将物理寄存器标记为函数的
    live-in，并调用超类实现：
- en: '[PRE84]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Now, we can implement the `lowerFormalArgument()` method:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以实现 `lowerFormalArgument()` 方法：
- en: 'First, the parameters of the `IR` function are translated into instances of
    the `ArgInfo` class. The `setArgFlags()` and `splitToValueTypes()` framework methods
    help with copying the parameter attributes and splitting the value type in case
    an incoming argument needs more than one virtual register:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，`IR` 函数的参数被转换成 `ArgInfo` 类的实例。`setArgFlags()` 和 `splitToValueTypes()` 框架方法帮助复制参数属性，并在传入的参数需要多个虚拟寄存器时分割值类型：
- en: '[PRE85]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'With the arguments prepared in the `SplitArgs` variable, we are ready to generate
    the machine code. This is all done by the framework code, with the help of the
    generated calling convention, `CC_M88k`, and our helper class, `FormalArghandler`:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SplitArgs` 变量中准备好参数后，我们就准备好生成机器代码了。这一切都是通过框架代码完成的，在生成的调用约定 `CC_M88k` 和我们的辅助类
    `FormalArghandler` 的帮助下：
- en: '[PRE86]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Return values are handled similarly, with the main difference being that one
    value is returned at most. The next task is to legalize the generic machine instructions.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值以类似的方式处理，主要区别是最多返回一个值。下一个任务是合法化通用机器指令。
- en: Legalizing the generic machine instructions
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将通用机器指令合法化
- en: 'The translation from LLVM IR to generic machine code is mostly fixed. As a
    result, instructions can be generated that use unsupported data types, among other
    challenges. The task of the legalizer pass is to define which operations and instructions
    are legal. With this information, the GlobalISel framework tries to transform
    the instructions into a legal form. For example, the m88k architecture only has
    32-bit registers, so a bitwise `and` operation with 64-bit values is not legal.
    However, if we split the 64-bit value into two 32-bit values, and use two bitwise
    `and` operations instead, then we have legal code. This can be translated into
    a legalization rule:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 从 LLVM IR 到通用机器代码的转换主要是固定的。因此，可以生成使用不支持的数据类型的指令，以及其他挑战。合法化传递的任务是定义哪些操作和指令是合法的。有了这些信息，GlobalISel
    框架试图将指令转换成合法形式。例如，m88k 架构只有 32 位寄存器，所以对 64 位值的位运算 `and` 是不合法的。然而，如果我们把 64 位值分成两个
    32 位值，并使用两个位运算 `and` 代替，那么我们就有了合法的代码。这可以转换成一个合法化规则：
- en: '[PRE87]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Whenever the legalizer pass processes a `G_AND` instruction, then it is legal
    if all operands are 32-bit wide. Otherwise, the operands are clamped to 32-bit,
    effectively splitting larger values into multiple 32-bit values, and the rule
    is applied again. If an instruction cannot be legalized, then the backend terminates
    with an error message.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 当合法化传递处理`G_AND`指令时，如果所有操作数都是32位宽，则该指令是合法的。否则，操作数会被限制为32位宽，实际上是将更大的值分割成多个32位值，然后再次应用该规则。如果指令无法合法化，后端将终止并显示错误信息。
- en: All legalization rules are defined in the constructor of the `M88kLegalizerInfo`
    class, which makes the class very simple.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 所有合法化规则都在`M88kLegalizerInfo`类的构造函数中定义，这使得该类非常简单。
- en: What does legal mean?
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: “合法”是什么意思？
- en: In GlobalISel, a generic instruction is legal if it can be translated by the
    instruction selector. This gives us more freedom in the implementation. For example,
    we can state that an instruction works on a bit value, even if the hardware only
    operates on 32-bit values, so long as the instruction selector can handle the
    type correctly.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在GlobalISel中，如果一条通用指令可以被指令选择器翻译，则该指令是合法的。这给了我们在实现上更多的自由度。例如，我们可以声明一条指令作用于位值，即使硬件只操作32位值，只要指令选择器可以正确处理该类型即可。
- en: The next pass we need to look at is the register bank selector.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来需要查看的是寄存器组选择器。
- en: Selecting a register bank for operands
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为操作数选择寄存器组
- en: Many architectures define several register banks. A register bank is a set of
    registers. Typical register banks are general-purpose register banks and floating-point
    register banks. Why is this information important? Moving a value from one register
    to another is usually cheap inside a register bank, but copying the value to another
    register bank can be costly or impossible. Thus, we must select a good register
    bank for each operand.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 许多架构定义了多个寄存器组。寄存器组是一组寄存器。典型的寄存器组包括通用寄存器组和浮点寄存器组。为什么这个信息很重要？在寄存器组内部从一个寄存器移动到另一个寄存器的值通常成本很低，但将值复制到另一个寄存器组可能会很昂贵或不可能。因此，我们必须为每个操作数选择一个好的寄存器组。
- en: 'The implementation of this class involves an addition to the target description.
    In the `GISel/M88lRegisterbanks.td` file, we define our single register bank,
    referencing the register classes we have defined:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的实现涉及到对目标描述的补充。在`GISel/M88lRegisterbanks.td`文件中，我们定义了我们唯一的寄存器组，引用了我们定义的寄存器类：
- en: '[PRE88]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'From this line, some support code is generated. However, we still need to add
    some code that could be potentially generated. First, we need to define partial
    mappings. This tells the framework at which bit index a value begins, how wide
    it is, and to which register bank it maps. We have two entries, one for each register
    class:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一行开始，生成了一些支持代码。然而，我们仍然需要添加一些可能生成的代码。首先，我们需要定义部分映射。这告诉框架值从哪个位索引开始，它的宽度是多少，以及它映射到哪个寄存器组。我们有两条条目，每个寄存器类一个：
- en: '[PRE89]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'To index this array, we must define an enumeration:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 要索引这个数组，我们必须定义一个枚举：
- en: '[PRE90]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Since we have only three address instructions, we need three partial mappings,
    one for each operand. We must create an array with all those pointers, with the
    first entry denoting an invalid mapping:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只有三个地址指令，我们需要三个部分映射，每个操作数一个。我们必须创建一个包含所有这些指针的数组，第一个条目表示一个无效映射：
- en: '[PRE91]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'To access that array, we must define a function:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问该数组，我们必须定义一个函数：
- en: '[PRE92]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: When creating these tables, it is easy to make errors. At first glance, all
    this information can be derived from the target description, and a comment in
    the source states that this code should be generated by TableGen! However, this
    hasn’t been implemented yet, so we have to create the code manually.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建这些表格时，很容易出错。乍一看，所有这些信息都可以从目标描述中推导出来，源代码中的注释指出，这段代码应由TableGen生成！然而，这尚未实现，因此我们必须手动创建代码。
- en: 'The most important function we have to implement in the `M88kRegisterBankInfo`
    class is `getInstrMapping()`, which returns the mapped register banks for each
    operand of the instruction. This now becomes easy because we can look up the array
    of partial mappings, which we can then pass to the `getInstructionMapping()` method,
    which constructs the full instruction mapping:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`M88kRegisterBankInfo`类中必须实现的最重要函数是`getInstrMapping()`，它返回指令每个操作数的映射寄存器组。现在这变得简单，因为我们可以查找部分映射数组，然后将其传递给`getInstructionMapping()`方法，该方法构建完整的指令映射：
- en: '[PRE93]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: During development, it is common to forget the register bank mapping for a generic
    instruction. Unfortunately, the error message that’s generated at runtime does
    not mention for which instruction the mapping failed. The easy fix is to dump
    the instruction before returning the invalid mapping. However, we need to be careful
    here because the `dump()` method is not available in all build types.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，忘记通用指令的寄存器组映射是很常见的。不幸的是，在运行时生成的错误信息并没有提到映射失败的指令是哪一个。简单的修复方法是返回无效映射之前先转储指令。然而，我们需要在这里小心，因为`dump()`方法并不适用于所有构建类型。
- en: After mapping the register banks, we must translate the generic machine instructions
    into real machine instructions.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在映射寄存器组之后，我们必须将通用机器指令翻译成实际的机器指令。
- en: Translating generic machine instructions
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 翻译通用机器指令
- en: For instruction selection via the selection DAG, we added patterns to the target
    description, which use DAG operations and operands. To reuse those patterns, a
    mapping from DAG node types to generic machine instructions was introduced. For
    example, the DAG `and` operation maps to the generic `G_AND` machine instruction.
    Not all DAG operations have an equivalent generic machine instruction; however,
    the most common cases are covered. Therefore, it is beneficial to define all code
    selection patterns in the target description.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 对于通过选择DAG进行指令选择，我们在目标描述中添加了模式，这些模式使用DAG操作和操作数。为了重用这些模式，引入了从DAG节点类型到通用机器指令的映射。例如，DAG的`and`操作映射到通用的`G_AND`机器指令。并非所有DAG操作都有等效的通用机器指令；然而，最常见的情况都得到了覆盖。因此，在目标描述中定义所有代码选择模式是有益的。
- en: 'Most of the implementation of the `M88kInstructionSelector` class, which can
    be found in the `GISel/M88kInstructionSelector.cpp` file, is generated from the
    target description. However, we need to override the `select()` method, which
    allows us to translate generic machine instructions that are not covered by the
    patterns in the target description. Since we only support a very small subset
    of generic instructions, we can simply call the generated pattern matcher:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`M88kInstructionSelector`类的实现大部分，该类可以在`GISel/M88kInstructionSelector.cpp`文件中找到，是从目标描述生成的。然而，我们需要重写`select()`方法，这允许我们将目标描述中模式未覆盖的通用机器指令进行翻译。由于我们只支持非常小的通用指令子集，我们可以简单地调用生成的模式匹配器：'
- en: '[PRE94]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: With the instruction selection implemented, we can translate LLVM IR using GlobalISel!
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 指令选择实现后，我们可以使用GlobalISel来翻译LLVM IR！
- en: Running an example
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行示例
- en: 'To translate LLVM IR using GlobalISel, we need to add the `-global-isel` option
    to the command line of `llc`. For example, you can use the previously defined
    IR file, `and.ll`:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用GlobalISel翻译LLVM IR，我们需要在`llc`的命令行中添加`-global-isel`选项。例如，你可以使用之前定义的IR文件`and.ll`：
- en: '[PRE95]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The printed assembly text is the same. To convince ourselves that the translation
    uses GlobalISel, we must take advantage of the fact that we can stop the translation
    after a specified pass is run with the `-stop-after=` option. For example, to
    see the generic instructions after legalization, you would run the following command:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 打印的汇编文本是相同的。为了让我们确信翻译使用了GlobalISel，我们必须利用这样一个事实：我们可以使用`-stop-after=`选项在指定pass运行后停止翻译。例如，要查看合法化后的通用指令，你会运行以下命令：
- en: '[PRE96]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The ability to stop after (or before) a pass is run is another advantage of
    GlobalISel because it makes it easy to debug and test the implementation.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行一个pass之后（或之前）停止的能力是GlobalISel的另一个优点，因为它使得调试和测试实现变得容易。
- en: At this point, we have a working backend that can translate some LLVM IR into
    machine code for the m88k architecture. Let’s think about how to move from here
    to a more complete backend.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经有一个可以翻译一些LLVM IR到m88k架构机器代码的工作后端。让我们思考如何从这里过渡到一个更完整的后端。
- en: How to further evolve the backend
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何进一步发展后端
- en: 'With the code from this and the previous chapter, we have created a backend
    that can translate some LLVM IR into machine code. It is very satisfying to see
    the backend working, but it is far from being usable for serious tasks. Much more
    coding is needed. Here is a recipe for how you can further evolve the backend:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章和上一章的代码，我们已经创建了一个可以将一些LLVM IR翻译成机器代码的后端。看到后端工作是非常令人满意的，但它离用于严肃任务还远。还需要更多的编码。以下是如何进一步发展后端的步骤：
- en: The first decision you should make is if you want to use GlobalISel or the selection
    DAG. In our experience, GlobalISel is easier to understand and develop, but all
    targets in the LLVM source tree implement the selection DAG, and you may already
    have experience in using it.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该做的第一个决定是是否要使用GlobalISel或选择DAG。根据我们的经验，GlobalISel更容易理解和开发，但LLVM源树中的所有目标都实现了选择DAG，你可能已经对它有了一些使用经验。
- en: Next, you should define the instructions for adding and subtracting integer
    values, which can be done similarly to the bitwise `and` instruction.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，你应该定义添加和减去整数值的指令，这可以与位运算`and`指令类似地完成。
- en: After, you should implement the load and store instructions. This is more involved
    since you need to translate the different addressing modes. Most likely, you will
    deal with indexing, for example, to address an element of an array, which most
    likely requires the previously defined instruction for addition.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，你应该实现加载和存储指令。这更为复杂，因为你需要翻译不同的寻址模式。很可能会遇到索引，例如，为了访问数组的一个元素，这很可能需要之前定义的加法指令。
- en: Finally, you can fully implement frame lowering and call lowering. At this point,
    you can translate a simple “Hello, world!” style application into a running program.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，你可以完全实现帧降低和调用降低。在这个阶段，你可以将一个简单的“Hello, world!”风格的应用程序翻译成可运行的程序。
- en: The next logical step is to implement branch instructions, which enable the
    translation of loops. To generate optimal code, you need to implement the branch
    analyzing methods in the instruction information class.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个逻辑步骤是实现分支指令，这可以使循环的翻译成为可能。为了生成最优代码，你需要在指令信息类中实现分支分析方法。
- en: When you reach this point, your backend can already translate simple algorithms.
    You should also have gained enough experience to develop the missing parts based
    on your priorities.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 当你达到这个阶段时，你的后端已经可以翻译简单的算法。你也应该积累了足够多的经验，可以根据你的优先级开发缺失的部分。
- en: Summary
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you added two different instruction selections to your backend:
    instruction selection via the selection DAG, and global instruction selection.
    For this, you had to define the calling convention in the target description.
    In addition, you needed to implement register and instruction information classes,
    which give you access to information generated from the target description but
    which you also needed to enhance with additional information. You learned that
    the stack frame layout and prolog generation are needed later. To translate an
    example, you added a class to emit machine instructions, and you created the configuration
    of the backend. You also learned how global instruction selection works. Finally,
    you gained some guidance on how you can develop the backend on your own.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你向你的后端添加了两种不同的指令选择：通过选择DAG进行指令选择和全局指令选择。为此，你需要在目标描述中定义调用约定。此外，你需要实现寄存器和指令信息类，这些类让你能够访问从目标描述生成的信息，但你还需要用额外的信息来增强它们。你了解到栈帧布局和前导代码生成在之后是必需的。为了翻译一个示例，你添加了一个用于发出机器指令的类，并创建了后端的配置。你还学习了全局指令选择的工作原理。最后，你获得了一些关于如何独立开发后端的指导。
- en: In the next chapter, we will look at some tasks that can be done after instruction
    selection – we will add a new pass in the pipeline of the backend, look at how
    to integrate the backend into the clang compiler, and how to cross-compile to
    a different architecture.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨在指令选择之后可以执行的一些任务——我们将在后端管道中添加一个新的传递，查看如何将后端集成到clang编译器中，以及如何交叉编译到不同的架构。
