["```cpp\nrtc.i2c=ds1307,1,0x68\n```", "```cpp\n#include <linux/module.h>       // Needed by all modules \n#include <linux/kernel.h>       // Needed for KERN_INFO \n\nint init_module() { \n        printk(KERN_INFO \"Hello world.n\"); \n\n        return 0; \n} \n\nvoid cleanup_module() { \n        printk(KERN_INFO \"Goodbye world.n\"); \n} \n```", "```cpp\n#include \"listener.h\"\n\n #include <iostream>\n #include <string>\n\n using namespace std;\n\n #include <Poco/Util/IniFileConfiguration.h>\n #include <Poco/AutoPtr.h>\n #include <Poco/Net/HTTPServer.h>\n\n using namespace Poco::Util;\n using namespace Poco;\n using namespace Poco::Net;\n\n #include \"httprequestfactory.h\"\n #include \"club.h\"\n```", "```cpp\nint main(int argc, char* argv[]) {\n          Club::log(LOG_INFO, \"Starting ClubStatus server...\");\n          int rc;\n          mosqpp::lib_init();\n\n          Club::log(LOG_INFO, \"Initialised C++ Mosquitto library.\");\n\n          string configFile;\n          if (argc > 1) { configFile = argv[1]; }\n          else { configFile = \"config.ini\"; }\n\n          AutoPtr<IniFileConfiguration> config;\n          try {\n                config = new IniFileConfiguration(configFile);\n          }\n          catch (Poco::IOException &e) {\n                Club::log(LOG_FATAL, \"Main: I/O exception when opening configuration file: \" + configFile + \". Aborting...\");\n                return 1;\n          }\n\n          string mqtt_host = config->getString(\"MQTT.host\", \"localhost\");\n          int mqtt_port = config->getInt(\"MQTT.port\", 1883);\n          string mqtt_user = config->getString(\"MQTT.user\", \"\");\n          string mqtt_pass = config->getString(\"MQTT.pass\", \"\");\n          string mqtt_topic = config->getString(\"MQTT.clubStatusTopic\",    \"/public/clubstatus\");\n          bool relayactive = config->getBool(\"Relay.active\", true);\n          uint8_t relayaddress = config->getInt(\"Relay.address\", 0x20);\n```", "```cpp\nListener listener(\"ClubStatus\", mqtt_host, mqtt_port, mqtt_user, mqtt_pass);\n\n    Club::log(LOG_INFO, \"Created listener, entering loop...\");\n\n    UInt16 port = config->getInt(\"HTTP.port\", 80);\n    HTTPServerParams* params = new HTTPServerParams;\n    params->setMaxQueued(100);\n    params->setMaxThreads(10);\n    HTTPServer httpd(new RequestHandlerFactory, port, params);\n    try {\n          httpd.start();\n    }\n    catch (Poco::IOException &e) {\n          Club::log(LOG_FATAL, \"I/O Exception on HTTP server: port already in use?\");\n          return 1;\n    }\n    catch (...) {\n          Club::log(LOG_FATAL, \"Exception thrown for HTTP server start. Aborting.\");\n          return 1;\n    }\n```", "```cpp\n\n             Club::mqtt = &listener;\n             Club::start(relayactive, relayaddress, mqtt_topic);\n\n             while(1) {\n                   rc = listener.loop();\n                   if (rc){\n                         Club::log(LOG_ERROR, \"Disconnected. Trying to \n                         reconnect...\");\n                         listener.reconnect();\n                   }\n             }\n\n             mosqpp::lib_cleanup();\n             httpd.stop();\n             Club::stop();\n\n             return 0;\n }\n```", "```cpp\nclass Listener : public mosqpp::mosquittopp {\n          //\n\n public:\n          Listener(string clientId, string host, int port, string user, string pass);\n          ~Listener();\n\n          void on_connect(int rc);\n          void on_message(const struct mosquitto_message* message);\n          void on_subscribe(int mid, int qos_count, const int* granted_qos);\n\n          void sendMessage(string topic, string& message);\n          void sendMessage(string& topic, char* message, int msgLength);\n };\n```", "```cpp\n#include \"listener.h\"\n\n #include <iostream>\n\n using namespace std;\n Listener::Listener(string clientId, string host, int port, string user, string pass) : mosquittopp(clientId.c_str()) {\n          int keepalive = 60;\n          username_pw_set(user.c_str(), pass.c_str());\n          connect(host.c_str(), port, keepalive);\n }\n\n Listener::~Listener() {\n          //\n }\n```", "```cpp\nvoid Listener::on_connect(int rc) {\n    cout << \"Connected. Subscribing to topics...n\";\n\n          if (rc == 0) {\n                // Subscribe to desired topics.\n                string topic = \"/club/status\";\n                subscribe(0, topic.c_str(), 1);\n          }\n          else {\n                cerr << \"Connection failed. Aborting subscribing.n\";\n          }\n }\n```", "```cpp\n\n void Listener::on_message(const struct mosquitto_message* message) {\n          string topic = message->topic;\n          string payload = string((const char*) message->payload, message->payloadlen);\n\n          if (topic == \"/club/status\") {\n                string topic = \"/club/status/response\";\n                char payload[] = { 0x01 }; \n                publish(0, topic.c_str(), 1, payload, 1); // QoS 1\\.   \n          }     \n }\n```", "```cpp\n void Listener::on_subscribe(int mid, int qos_count, const int* granted_qos) {\n          // \n }\n\n void Listener::sendMessage(string topic, string &message) {\n          publish(0, topic.c_str(), message.length(), message.c_str(), true);\n }\n\n void Listener::sendMessage(string &topic, char* message, int msgLength) {\n          publish(0, topic.c_str(), msgLength, message, true);\n }\n```", "```cpp\n#include <wiringPi.h>\n #include <wiringPiI2C.h>\n```", "```cpp\nenum Log_level {\n    LOG_FATAL = 1,\n    LOG_ERROR = 2,\n    LOG_WARNING = 3,\n    LOG_INFO = 4,\n    LOG_DEBUG = 5\n };\n```", "```cpp\n class Listener;\n```", "```cpp\nclass ClubUpdater : public Runnable {\n          TimerCallback<ClubUpdater>* cb;\n          uint8_t regDir0;\n          uint8_t regOut0;\n          int i2cHandle;\n          Timer* timer;\n          Mutex mutex;\n          Mutex timerMutex;\n          Condition timerCnd;\n          bool powerTimerActive;\n          bool powerTimerStarted;\n\n public:\n          void run();\n          void updateStatus();\n          void writeRelayOutputs();\n          void setPowerState(Timer &t);\n };\n```", "```cpp\nclass Club {\n          static Thread updateThread;\n          static ClubUpdater updater;\n\n          static void lockISRCallback();\n          static void statusISRCallback();\n\n public:\n          static bool clubOff;\n          static bool clubLocked;\n          static bool powerOn;\n          static Listener* mqtt;\n          static bool relayActive;\n          static uint8_t relayAddress;\n          static string mqttTopic;      // Topic we publish status updates on.\n\n          static Condition clubCnd;\n          static Mutex clubCndMutex;\n          static Mutex logMutex;\n          static bool clubChanged ;\n          static bool running;\n          static bool clubIsClosed;\n          static bool firstRun;\n          static bool lockChanged;\n          static bool statusChanged;\n          static bool previousLockValue;\n          static bool previousStatusValue;\n\n          static bool start(bool relayactive, uint8_t relayaddress, string topic);\n          static void stop();\n          static void setRelay();\n          static void log(Log_level level, string msg);\n };\n```", "```cpp\n#include \"club.h\"\n\n #include <iostream>\n\n using namespace std;\n\n #include <Poco/NumberFormatter.h>\n\n using namespace Poco;\n\n #include \"listener.h\"\n```", "```cpp\n #define REG_INPUT_PORT0              0x00\n #define REG_INPUT_PORT1              0x01\n #define REG_OUTPUT_PORT0             0x02\n #define REG_OUTPUT_PORT1             0x03\n #define REG_POL_INV_PORT0            0x04\n #define REG_POL_INV_PORT1            0x05\n #define REG_CONF_PORT0               0x06\n #define REG_CONG_PORT1               0x07\n #define REG_OUT_DRV_STRENGTH_PORT0_L 0x40\n #define REG_OUT_DRV_STRENGTH_PORT0_H 0x41\n #define REG_OUT_DRV_STRENGTH_PORT1_L 0x42\n #define REG_OUT_DRV_STRENGTH_PORT1_H 0x43\n #define REG_INPUT_LATCH_PORT0        0x44\n #define REG_INPUT_LATCH_PORT1        0x45\n #define REG_PUD_EN_PORT0             0x46\n #define REG_PUD_EN_PORT1             0x47\n #define REG_PUD_SEL_PORT0            0x48\n #define REG_PUD_SEL_PORT1            0x49\n #define REG_INT_MASK_PORT0           0x4A\n #define REG_INT_MASK_PORT1           0x4B\n #define REG_INT_STATUS_PORT0         0x4C\n #define REG_INT_STATUS_PORT1         0x4D\n #define REG_OUTPUT_PORT_CONF         0x4F\n```", "```cpp\n #define RELAY_POWER 0\n #define RELAY_GREEN 1\n #define RELAY_YELLOW 2\n #define RELAY_RED 3\n```", "```cpp\nbool Club::clubOff;\n bool Club::clubLocked;\n bool Club::powerOn;\n Thread Club::updateThread;\n ClubUpdater Club::updater;\n bool Club::relayActive;\n uint8_t Club::relayAddress;\n string Club::mqttTopic;\n Listener* Club::mqtt = 0;\n\n Condition Club::clubCnd;\n Mutex Club::clubCndMutex;\n Mutex Club::logMutex;\n bool Club::clubChanged = false;\n bool Club::running = false;\n bool Club::clubIsClosed = true;\n bool Club::firstRun = true;\n bool Club::lockChanged = false;\n bool Club::statusChanged = false;\n bool Club::previousLockValue = false;\n bool Club::previousStatusValue = false;\n```", "```cpp\nvoid ClubUpdater::run() {\n    regDir0 = 0x00;\n    regOut0 = 0x00;\n    Club::powerOn = false;\n    powerTimerActive = false;\n    powerTimerStarted = false;\n    cb = new TimerCallback<ClubUpdater>(*this, &ClubUpdater::setPowerState);\n    timer = new Timer(10 * 1000, 0);\n```", "```cpp\nif (Club::relayActive) {\n    Club::log(LOG_INFO, \"ClubUpdater: Starting i2c relay device.\");\n    i2cHandle = wiringPiI2CSetup(Club::relayAddress);\n    if (i2cHandle == -1) {\n        Club::log(LOG_FATAL, string(\"ClubUpdater: error starting          \n        i2c relay device.\"));\n        return;\n    }\n\n    wiringPiI2CWriteReg8(i2cHandle, REG_CONF_PORT0, 0x00);\n    wiringPiI2CWriteReg8(i2cHandle, REG_OUTPUT_PORT0, 0x00);\n\n    Club::log(LOG_INFO, \"ClubUpdater: Finished configuring the i2c \n    relay device's registers.\");\n}\n```", "```cpp\n          updateStatus();\n\n          Club::log(LOG_INFO, \"ClubUpdater: Initial status update complete.\");\n          Club::log(LOG_INFO, \"ClubUpdater: Entering waiting condition.\");\n\n          while (Club::running) {\n                Club::clubCndMutex.lock();\n                if (!Club::clubCnd.tryWait(Club::clubCndMutex, 60 * 1000)) {.\n                      Club::clubCndMutex.unlock();\n                      if (!Club::clubChanged) { continue; }\n                }\n                else {\n                      Club::clubCndMutex.unlock();\n                }\n\n                updateStatus();\n          }\n }\n```", "```cpp\nvoid ClubUpdater::updateStatus() {\n    Club::clubChanged = false;\n\n    if (Club::lockChanged) {\n          string state = (Club::clubLocked) ? \"locked\" : \"unlocked\";\n          Club::log(LOG_INFO, string(\"ClubUpdater: lock status changed to \") + state);\n          Club::lockChanged = false;\n\n          if (Club::clubLocked == Club::previousLockValue) {\n                Club::log(LOG_WARNING, string(\"ClubUpdater: lock interrupt triggered, but value hasn't changed. Aborting.\"));\n                return;\n          }\n\n          Club::previousLockValue = Club::clubLocked;\n    }\n    else if (Club::statusChanged) {           \n          string state = (Club::clubOff) ? \"off\" : \"on\";\n          Club::log(LOG_INFO, string(\"ClubUpdater: status switch status changed to \") + state);\n          Club::statusChanged = false;\n\n          if (Club::clubOff == Club::previousStatusValue) {\n                Club::log(LOG_WARNING, string(\"ClubUpdater: status interrupt triggered, but value hasn't changed. Aborting.\"));\n                return;\n          }\n\n          Club::previousStatusValue = Club::clubOff;\n    }\n    else if (Club::firstRun) {\n          Club::log(LOG_INFO, string(\"ClubUpdater: starting initial update run.\"));\n          Club::firstRun = false;\n    }\n    else {\n          Club::log(LOG_ERROR, string(\"ClubUpdater: update triggered, but no change detected. Aborting.\"));\n          return;\n    }\n```", "```cpp\n    if (Club::clubIsClosed && !Club::clubOff) {\n          Club::clubIsClosed = false;\n\n          Club::log(LOG_INFO, string(\"ClubUpdater: Opening club.\"));\n\n          Club::powerOn = true;\n          try {\n                if (!powerTimerStarted) {\n                      timer->start(*cb);\n                      powerTimerStarted = true;\n                }\n                else { \n                      timer->stop();\n                      timer->start(*cb);\n                }\n          }\n          catch (Poco::IllegalStateException &e) {\n                Club::log(LOG_ERROR, \"ClubUpdater: IllegalStateException on timer start: \" + e.message());\n                return;\n          }\n          catch (...) {\n                Club::log(LOG_ERROR, \"ClubUpdater: Unknown exception on timer start.\");\n                return;\n          }\n\n          powerTimerActive = true;\n\n          Club::log(LOG_INFO, \"ClubUpdater: Started power timer...\");\n\n          char msg = { '1' };\n          Club::mqtt->sendMessage(Club::mqttTopic, &msg, 1);\n\n          Club::log(LOG_DEBUG, \"ClubUpdater: Sent MQTT message.\");\n    }\n    else if (!Club::clubIsClosed && Club::clubOff) {\n          Club::clubIsClosed = true;\n\n          Club::log(LOG_INFO, string(\"ClubUpdater: Closing club.\"));\n\n          Club::powerOn = false;\n\n          try {\n                if (!powerTimerStarted) {\n                      timer->start(*cb);\n                      powerTimerStarted = true;\n                }\n                else { \n                      timer->stop();\n                      timer->start(*cb);\n                }\n          }\n          catch (Poco::IllegalStateException &e) {\n                Club::log(LOG_ERROR, \"ClubUpdater: IllegalStateException on timer start: \" + e.message());\n                return;\n          }\n          catch (...) {\n                Club::log(LOG_ERROR, \"ClubUpdater: Unknown exception on timer start.\");\n                return;\n          }\n\n          powerTimerActive = true;\n\n          Club::log(LOG_INFO, \"ClubUpdater: Started power timer...\");\n\n          char msg = { '0' };\n          Club::mqtt->sendMessage(Club::mqttTopic, &msg, 1);\n\n          Club::log(LOG_DEBUG, \"ClubUpdater: Sent MQTT message.\");\n    }\n```", "```cpp\n\n    if (Club::clubOff) {\n          Club::log(LOG_INFO, string(\"ClubUpdater: New lights, clubstatus off.\"));\n\n          mutex.lock();\n          string state = (Club::powerOn) ? \"on\" : \"off\";\n          if (powerTimerActive) {\n                Club::log(LOG_DEBUG, string(\"ClubUpdater: Power timer active, inverting power state from: \") + state);\n                regOut0 = !Club::powerOn;\n          }\n          else {\n                Club::log(LOG_DEBUG, string(\"ClubUpdater: Power timer not active, using current power state: \") + state);\n                regOut0 = Club::powerOn; \n          }\n\n          if (Club::clubLocked) {\n                Club::log(LOG_INFO, string(\"ClubUpdater: Red on.\"));\n                regOut0 |= (1UL << RELAY_RED); \n          } \n          else {\n                Club::log(LOG_INFO, string(\"ClubUpdater: Yellow on.\"));\n                regOut0 |= (1UL << RELAY_YELLOW);\n          } \n\n          Club::log(LOG_DEBUG, \"ClubUpdater: Changing output register to: 0x\" + NumberFormatter::formatHex(regOut0));\n\n          writeRelayOutputs();\n          mutex.unlock();\n    }\n```", "```cpp\n    else { \n                Club::log(LOG_INFO, string(\"ClubUpdater: New lights, clubstatus on.\"));\n\n                mutex.lock();\n                string state = (Club::powerOn) ? \"on\" : \"off\";\n                if (powerTimerActive) {\n                      Club::log(LOG_DEBUG, string(\"ClubUpdater: Power timer active,    inverting power state from: \") + state);\n                      regOut0 = !Club::powerOn; // Take the inverse of what the timer    callback will set.\n                }\n                else {\n                      Club::log(LOG_DEBUG, string(\"ClubUpdater: Power timer not active,    using current power state: \") + state);\n                      regOut0 = Club::powerOn; // Use the current power state value.\n                }\n\n                if (Club::clubLocked) {\n                      Club::log(LOG_INFO, string(\"ClubUpdater: Yellow & Red on.\"));\n                      regOut0 |= (1UL << RELAY_YELLOW);\n                      regOut0 |= (1UL << RELAY_RED);\n                }\n                else {\n                      Club::log(LOG_INFO, string(\"ClubUpdater: Green on.\"));\n                      regOut0 |= (1UL << RELAY_GREEN);\n                }\n\n                Club::log(LOG_DEBUG, \"ClubUpdater: Changing output register to: 0x\" +    NumberFormatter::formatHex(regOut0));\n\n                writeRelayOutputs();\n                mutex.unlock();\n          }\n }\n```", "```cpp\nvoid ClubUpdater::writeRelayOutputs() {\n    wiringPiI2CWriteReg8(i2cHandle, REG_OUTPUT_PORT0, regOut0);\n\n    Club::log(LOG_DEBUG, \"ClubUpdater: Finished writing relay outputs with: 0x\" \n                + NumberFormatter::formatHex(regOut0));\n }\n```", "```cpp\n   void ClubUpdater::setPowerState(Timer &t) {\n          Club::log(LOG_INFO, string(\"ClubUpdater: setPowerState called.\"));\n\n          mutex.lock();\n          if (Club::powerOn) { regOut0 |= (1UL << RELAY_POWER); }\n          else { regOut0 &= ~(1UL << RELAY_POWER); }\n\n          Club::log(LOG_DEBUG, \"ClubUpdater: Writing relay with: 0x\" +    NumberFormatter::formatHex(regOut0));\n\n          writeRelayOutputs();\n\n          powerTimerActive = false;\n          mutex.unlock();\n }\n```", "```cpp\nbool Club::start(bool relayactive, uint8_t relayaddress, string topic) {\n          Club::log(LOG_INFO, \"Club: starting up...\");\n\n          relayActive = relayactive;\n          relayAddress = relayaddress;\n          mqttTopic = topic;\n\n          wiringPiSetup();\n\n          Club::log(LOG_INFO,  \"Club: Finished wiringPi setup.\");\n\n          pinMode(0, INPUT);\n          pinMode(7, INPUT);\n          pullUpDnControl(0, PUD_DOWN);\n          pullUpDnControl(7, PUD_DOWN);\n          clubLocked = digitalRead(0);\n          clubOff = !digitalRead(7);\n\n          previousLockValue = clubLocked;\n          previousStatusValue = clubOff;\n\n          Club::log(LOG_INFO, \"Club: Finished configuring pins.\");\n\n          wiringPiISR(0, INT_EDGE_BOTH, &lockISRCallback);\n          wiringPiISR(7, INT_EDGE_BOTH, &statusISRCallback);\n\n          Club::log(LOG_INFO, \"Club: Configured interrupts.\");\n\n          running = true;\n          updateThread.start(updater);\n\n          Club::log(LOG_INFO, \"Club: Started update thread.\");\n\n          return true;\n }\n```", "```cpp\nvoid Club::stop() {\n          running = false;\n }\n```", "```cpp\nvoid Club::lockISRCallback() {\n          clubLocked = digitalRead(0);\n          lockChanged = true;\n\n          clubChanged = true;\n          clubCnd.signal();\n }\n\n void Club::statusISRCallback() {\n          clubOff = !digitalRead(7);\n          statusChanged = true;\n\n          clubChanged = true;\n          clubCnd.signal();\n }\n```", "```cpp\nvoid Club::log(Log_level level, string msg) {\n    logMutex.lock();\n    switch (level) {\n          case LOG_FATAL: {\n                cerr << \"FATAL:t\" << msg << endl;\n                string message = string(\"ClubStatus FATAL: \") + msg;\n                if (mqtt) {\n                      mqtt->sendMessage(\"/log/fatal\", message);\n                }\n\n                break;\n          }\n          case LOG_ERROR: {\n                cerr << \"ERROR:t\" << msg << endl;\n                string message = string(\"ClubStatus ERROR: \") + msg;\n                if (mqtt) {\n                      mqtt->sendMessage(\"/log/error\", message);\n                }\n\n                break;\n          }\n          case LOG_WARNING: {\n                cerr << \"WARNING:t\" << msg << endl;\n                string message = string(\"ClubStatus WARNING: \") + msg;\n                if (mqtt) {\n                      mqtt->sendMessage(\"/log/warning\", message);\n                }\n\n                break;\n          }\n          case LOG_INFO: {\n                cout << \"INFO: t\" << msg << endl;\n                string message = string(\"ClubStatus INFO: \") + msg;\n                if (mqtt) {\n                      mqtt->sendMessage(\"/log/info\", message);\n                }\n\n                break;\n          }\n          case LOG_DEBUG: {\n                cout << \"DEBUG:t\" << msg << endl;\n                string message = string(\"ClubStatus DEBUG: \") + msg;\n                if (mqtt) {\n                      mqtt->sendMessage(\"/log/debug\", message);\n                }\n\n                break;\n          }\n          default:\n                break;\n    }\n\n    logMutex.unlock();\n }\n```", "```cpp\n#include <Poco/Net/HTTPRequestHandlerFactory.h>\n #include <Poco/Net/HTTPServerRequest.h>\n\n using namespace Poco::Net;\n\n #include \"statushandler.h\"\n #include \"datahandler.h\"\n\n class RequestHandlerFactory: public HTTPRequestHandlerFactory { \n public:\n          RequestHandlerFactory() {}\n          HTTPRequestHandler* createRequestHandler(const HTTPServerRequest& request) {\n                if (request.getURI().compare(0, 12, \"/clubstatus/\") == 0) { \n                     return new StatusHandler(); \n               }\n                else { return new DataHandler(); }\n          }\n };\n```", "```cpp\n#include <Poco/Net/HTTPRequestHandler.h>\n #include <Poco/Net/HTTPServerResponse.h>\n #include <Poco/Net/HTTPServerRequest.h>\n #include <Poco/URI.h>\n\n using namespace Poco;\n using namespace Poco::Net;\n\n #include \"club.h\"\n\n class StatusHandler: public HTTPRequestHandler { \n public: \n          void handleRequest(HTTPServerRequest& request, HTTPServerResponse& response)  {         \n                Club::log(LOG_INFO, \"StatusHandler: Request from \" +                                                     request.clientAddress().toString());\n\n                URI uri(request.getURI());\n                vector<string> parts;\n                uri.getPathSegments(parts);\n\n                response.setContentType(\"application/json\");\n                response.setChunkedTransferEncoding(true); \n\n                if (parts.size() == 1) {\n                      ostream& ostr = response.send();\n                      ostr << \"{ \"clubstatus\": \" << !Club::clubOff << \",\";\n                      ostr << \"\"lock\": \" << Club::clubLocked << \",\";\n                      ostr << \"\"power\": \" << Club::powerOn << \"\";\n                      ostr << \"}\";\n                }\n                else {\n                      response.setStatus(HTTPResponse::HTTP_BAD_REQUEST);\n                      ostream& ostr = response.send();\n                      ostr << \"{ \"error\": \"Invalid request.\" }\";\n                }\n          }\n };\n```", "```cpp\n#include <Poco/Net/HTTPRequestHandler.h>\n #include <Poco/Net/HTTPServerResponse.h>\n #include <Poco/Net/HTTPServerRequest.h>\n #include <Poco/URI.h>\n #include <Poco/File.h>\n\n using namespace Poco::Net;\n using namespace Poco;\n\n class DataHandler: public HTTPRequestHandler { \n public: \n    void handleRequest(HTTPServerRequest& request, HTTPServerResponse& response) {\n          Club::log(LOG_INFO, \"DataHandler: Request from \" + request.clientAddress().toString());\n\n          // Get the path and check for any endpoints to filter on.\n          URI uri(request.getURI());\n          string path = uri.getPath();\n\n          string fileroot = \"htdocs\";\n          if (path.empty() || path == \"/\") { path = \"/index.html\"; }\n\n          File file(fileroot + path);\n\n          Club::log(LOG_INFO, \"DataHandler: Request for \" + file.path());\n```", "```cpp\n          if (!file.exists() || file.isDirectory()) {\n                response.setStatus(HTTPResponse::HTTP_NOT_FOUND);\n                ostream& ostr = response.send();\n                ostr << \"File Not Found.\";\n                return;\n          }\n\n          string::size_type idx = path.rfind('.');\n          string ext = \"\";\n          if (idx != std::string::npos) {\n                ext = path.substr(idx + 1);\n          }\n\n          string mime = \"text/plain\";\n          if (ext == \"html\") { mime = \"text/html\"; }\n          if (ext == \"css\") { mime = \"text/css\"; }\n          else if (ext == \"js\") { mime = \"application/javascript\"; }\n          else if (ext == \"zip\") { mime = \"application/zip\"; }\n          else if (ext == \"json\") { mime = \"application/json\"; }\n          else if (ext == \"png\") { mime = \"image/png\"; }\n          else if (ext == \"jpeg\" || ext == \"jpg\") { mime = \"image/jpeg\"; }\n          else if (ext == \"gif\") { mime = \"image/gif\"; }\n          else if (ext == \"svg\") { mime = \"image/svg\"; }\n```", "```cpp\n                try {\n                      response.sendFile(file.path(), mime);\n                }\n                catch (FileNotFoundException &e) {\n                      Club::log(LOG_ERROR, \"DataHandler: File not found exception    triggered...\");\n                      cerr << e.displayText() << endl;\n\n                      response.setStatus(HTTPResponse::HTTP_NOT_FOUND);\n                      ostream& ostr = response.send();\n                      ostr << \"File Not Found.\";\n                      return;\n                }\n                catch (OpenFileException &e) {\n                      Club::log(LOG_ERROR, \"DataHandler: Open file exception triggered: \" +    e.displayText());\n\n                      response.setStatus(HTTPResponse::HTTP_INTERNAL_SERVER_ERROR);\n                      ostream& ostr = response.send();\n                      ostr << \"Internal Server Error. Couldn't open file.\";\n                      return;\n                }\n          }\n };\n```", "```cpp\n[Unit] \nDescription=ClubStatus monitoring & control \n\n[Service] \nExecStart=/home/user/clubstatus/clubstatus /home/user/clubstatus/config.ini \nUser=user \nWorkingDirectory=/home/user/clubstatus \nRestart=always \nRestartSec=5 \n\n[Install] \nWantedBy=multi-user.target \n```", "```cpp\n[MQTT]\n ; URL and port of the MQTT server.\n host = localhost\n port = 1883\n\n ; Authentication\n user = user\n pass = password\n\n ; The topic status on which changes will be published.\n clubStatusTopic = /my/topic\n\n [HTTP]\n port = 8080\n\n [Relay]\n ; Whether an i2c relay board is connected. 0 (false) or 1 (true).\n active = 0\n ; i2c address, in decimal or hexadecimal.\n address = 0x20\n```", "```cpp\n    sudo usermod -a -G gpio user\n    sudo usermod -a -G i2c user\n```"]