["```cpp\nclass ComplexAPI {\npublic:\n    void initialize();\n    void load_data_from_file(const std::string& filePath);\n    void load_data_from_database(const std::string& connection_string);\n    void process_data(int mode);\n    void save_data_to_file(const std::string& filePath);\n    void save_data_to_database(const std::string& connection_string);\n    void cleanup();\n};\n```", "```cpp\nclass FileDataLoader {\npublic:\n    explicit FileDataLoader(const std::string& filePath) : filePath(filePath) {}\n    void load() {\n        // Code to load data from a file\n    }\nprivate:\n    std::string filePath;\n};\nclass DatabaseDataLoader {\npublic:\n    explicit DatabaseDataLoader(const std::string& connection_string) : _connection_string(connection_string) {}\n    void load() {\n        // Code to load data from a database\n    }\nprivate:\n    std::string _connection_string;\n};\nclass DataProcessor {\npublic:\n    void process(int mode) {\n        // Code to process data based on the mode\n    }\n};\n```", "```cpp\nclass DataSaver {\npublic:\n    virtual void save() = 0;\n    virtual ~DataSaver() = default;\n};\nclass FileDataSaver : public DataSaver {\npublic:\n    explicit FileDataSaver(const std::string& filePath) : filePath(filePath) {}\n    void save() override {\n        // Code to save data to a file\n    }\nprivate:\n    std::string filePath;\n};\nclass DatabaseDataSaver : public DataSaver {\npublic:\n    explicit DatabaseDataSaver(const std::string& connection_string) : _connection_string(connection_string) {}\n    void save() override {\n        // Code to save data to a database\n    }\nprivate:\n    std::string _connection_string;\n};\n```", "```cpp\n        #include <nlohmann/json.hpp>\n        ```", "```cpp\n        nlohmann::json j = {\n        ```", "```cpp\n            {\"pi\", 3.141},\n        ```", "```cpp\n            {\"happy\", true},\n        ```", "```cpp\n            {\"name\", \"Niels\"},\n        ```", "```cpp\n            {\"nothing\", nullptr},\n        ```", "```cpp\n            {\"answer\", {\n        ```", "```cpp\n                {\"everything\", 42}\n        ```", "```cpp\n            }},\n        ```", "```cpp\n            {\"list\", {1, 0, 2}},\n        ```", "```cpp\n            {\"object\", {\n        ```", "```cpp\n                {\"currency\", \"USD\"},\n        ```", "```cpp\n                {\"value\", 42.99}\n        ```", "```cpp\n            }}\n        ```", "```cpp\n        };\n        ```", "```cpp\n        #include <SQLiteCpp/SQLiteCpp.h>\n        ```", "```cpp\n        SQLite::Database db(\"test.db\", SQLite::OPEN_READWRITE|SQLite::OPEN_CREATE);\n        ```", "```cpp\n        db.exec(\"CREATE TABLE test (id INTEGER PRIMARY KEY, value TEXT)\");\n        ```", "```cpp\n        SQLite::Statement query(db, \"INSERT INTO test (value) VALUES (?)\");\n        ```", "```cpp\n        query.bind(1, \"Sample value\");\n        ```", "```cpp\n        query.exec();\n        ```", "```cpp\n// MessageSender.hpp\n#pragma once\n#include <string>\n#include <vector>\nclass MessageSender {\npublic:\n    MessageSender(const std::string& receiver);\n    void send(const std::vector<uint8_t>& message) const;\n    void send(const uint8_t* message, size_t length) const;\n};\n// MessageSender.cpp\n#include \"MessageSender.h\"\n#include <iostream>\nMessageSender::MessageSender(const std::string& receiver) {\n    std::cout << \"MessageSender created for receiver: \" << receiver << std::endl;\n}\nvoid MessageSender::send(const std::vector<uint8_t>& message) const {\n    std::cout << \"Sending message of size: \" << message.size() << std::endl;\n}\nvoid MessageSender::send(const uint8_t* message, size_t length) const {\n    std::cout << \"Sending message of length: \" << length << std::endl;\n}\n```", "```cpp\n// MessageSender.h (C Wrapper Header)\n#ifdef __cplusplus\nextern \"C\" {\n#endif\ntypedef void* MessageSenderHandle;\nMessageSenderHandle create_message_sender(const char* receiver);\nvoid destroy_message_sender(MessageSenderHandle handle);\nvoid send_message(MessageSenderHandle handle, const uint8_t* message, size_t length);\n#ifdef __cplusplus\n}\n#endif\n// MessageSenderC.cpp (C Wrapper Implementation)\n#include \"MessageSenderC.h\"\n#include \"MessageSender.hpp\"\nMessageSenderHandle create_message_sender(const char* receiver) {\n    return new(std::nothrow) MessageSender(receiver);\n}\nvoid destroy_message_sender(MessageSenderHandle handle) {\n    MessageSender* instance = reinterpret_cast<MessageSender*>(handle);\n    assert(instance);\n    delete instance;\n}\nvoid send_message(MessageSenderHandle handle, const uint8_t* message, size_t length) {\n    MessageSender* instance = reinterpret_cast<MessageSender*>(handle);\n    assert(instance);\n    instance->send(message, length);\n}\n```", "```cpp\nclass ConnectionError : public std::runtime_error {\npublic:\n    ConnectionError(const std::string& message) : std::runtime_error(message) {}\n};\nclass SendError : public std::runtime_error {\npublic:\n    SendError(const std::string& message) : std::runtime_error(message) {}\n};\n```", "```cpp\n// MessageSender.h (C Wrapper Header)\ntypedef enum {\n    OK,\n    CONNECTION_ERROR,\n    SEND_ERROR,\n} MessageSenderStatus;\n// MessageSenderC.cpp (C Wrapper Implementation)\nMessageSenderStatus send_message(MessageSenderHandle handle, const uint8_t* message, size_t length) {\n    try {\n        MessageSender* instance = reinterpret_cast<MessageSender*>(handle);\n        instance->send(message, length);\n        return OK;\n    } catch (const ConnectionError&) {\n        return CONNECTION_ERROR;\n    } catch (const SendError&) {\n        return SEND_ERROR;\n    } catch (...) {\n       std::abort();\n    }\n}\n```"]