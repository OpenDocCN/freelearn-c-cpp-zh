["```cpp\nstruct OGLLineVertex {\n  glm::vec3 position = glm::vec3(0.0f);\n  glm::vec3 color = glm::vec3(0.0f);\n};\nstruct OGLLineMesh {\n  std::vector<OGLLineVertex> vertices{};\n}; \n```", "```cpp\n glVertexAttribPointer(0, 3, GL_FLOAT,\n    GL_FALSE, sizeof(OGLLineVertex),\n    (void*) offsetof(OGLLineVertex, position));\n  glVertexAttribPointer(1, 3, GL_FLOAT,\n    GL_FALSE, sizeof(OGLLineVertex),\n    (void*) offsetof(OGLLineVertex, color));\n  glEnableVertexAttribArray(0);\n  glEnableVertexAttribArray(1); \n```", "```cpp\n /*  X axis - red */\n  mVertexData.vertices[0].position =\n    glm::vec3(0.0f,0.0f, 0.0f);\n  mVertexData.vertices[1].position =\n    glm::vec3(1.0f, 0.0f,  0.0f);\n  mVertexData.vertices[2].position =\n    glm::vec3(1.0f, 0.0f,  0.0f);\n  ...\n  mVertexData.vertices[0].color =\n    glm::vec3(0.8f, 0.0f, 0.0f);\n  mVertexData.vertices[1].color =\n    glm::vec3(0.8f, 0.0f, 0.0f);\n  mVertexData.vertices[2].color =\n    glm::vec3(0.8f, 0.0f, 0.0f);\n  ... \n```", "```cpp\n mCoordArrowsLineIndexCount = 0;\n  mLineMesh->vertices.clear(); \n```", "```cpp\n InstanceSettings instSettings =\n    mModelInstData.miAssimpInstances.at(\n    mModelInstData.miSelectedInstance)\n    ->getInstanceSettings(); \n```", "```cpp\nmCoordArrowsLineIndexCount +=\n     mCoordArrowsMesh.vertices.size();\nstd::for_each(mCoordArrowsMesh.vertices.begin(),\n    mCoordArrowsMesh.vertices.end(),\n      [=](auto &n){\n      n.color /= 2.0f;\n      n.position =\n        glm::quat(glm::radians(\n        instSettings.isWorldRotation)) * n.position;\n        n.position += instSettings.isWorldPosition;\n    }); \n```", "```cpp\n mLineMesh->vertices.insert(mLineMesh->vertices.end(),\n      mCoordArrowsMesh.vertices.begin(),\n      mCoordArrowsMesh.vertices.end()); \n```", "```cpp\n mLineVertexBuffer.uploadData(*mLineMesh);\n  if (mCoordArrowsLineIndexCount > 0) {\n    mLineShader.use();\n    mLineVertexBuffer.bindAndDraw(GL_LINES, 0,\n      mCoordArrowsLineIndexCount);\n  } \n```", "```cpp\n if (ImGui::Button(\"Center This Instance\")) {\n      std::shared_ptr<AssimpInstance> currentInstance =\n        modInstData.miAssimpInstances.at(\n          modInstData.miSelectedInstance);\n       modInstData.miInstanceCenterCallbackFunction(\n         currentInstance);\n    } \n```", "```cpp\n mModelInstData.miInstanceCenterCallbackFunction =\n   [this](std::shared_ptr<AssimpInstance> instance)\n   { centerInstance(instance); }; \n```", "```cpp\nvoid OGLRenderer::centerInstance(\n    std::shared_ptr<AssimpInstance> instance) {\n  InstanceSettings instSettings =\n    instance->getInstanceSettings();\n  mCamera.moveCameraTo(mRenderData,\n    instSettings.isWorldPosition + glm::vec3(5.0f));\n} \n```", "```cpp\nvoid Camera::moveCameraTo(OGLRenderData& renderData,\n    glm::vec3 position) {\n  renderData.rdCameraWorldPosition = position;\n  renderData.rdViewAzimuth = 310.0f;\n  renderData.rdViewElevation = -15.0f;\n} \n```", "```cpp\n std::vector<float> mSelectedInstance{};\n    ShaderStorageBuffer mSelectedInstanceBuffer{}; \n```", "```cpp\n std::shared_ptr<AssimpInstance> currentSelectedInstance =\n    nullptr;\n  ...\n    currentSelectedInstance =\n      mModelInstData.miAssimpInstances.at(\n      mModelInstData.miSelectedInstance); \n```", "```cpp\n mRenderData.rdSelectedInstanceHighlightValue +=\n    deltaTime * 4.0f;\n  if (mRenderData.rdSelectedInstanceHighlightValue > 2.0f) {\n      mRenderData.rdSelectedInstanceHighlightValue = 0.1f\n  } \n```", "```cpp\n if (currentSelectedInstance ==\n        modelType.second.at(i)) {\n        mSelectedInstance.at(i) =\n          mRenderData.rdSelectedInstanceHighlightValue;\n      } else {\n        mSelectedInstance.at(i) = 1.0f;\n      } \n```", "```cpp\n mSelectedInstanceBuffer.uploadSsboData(\n      mSelectedInstance, 3); \n```", "```cpp\nlayout (std430, binding = 3) readonly restrict\n    buffer InstanceSelected {\n  float selected[];\n}; \n```", "```cpp\n mShaderBoneMatrixBuffer.bind(1);\n  mShaderModelRootMatrixBuffer.uploadSsboData(\n      mWorldPosMatrices, 2);\n  mSelectedInstanceBuffer.uploadSsboData(\n      mSelectedInstance, 3); \n```", "```cpp\n mShaderModelRootMatrixBuffer.uploadSsboData(\n    mWorldPosMatrices, 1);\n  mSelectedInstanceBuffer.uploadSsboData(\n    mSelectedInstance, 2); \n```", "```cpp\n color = aColor * selected[gl_InstanceID]; \n```", "```cpp\n if (selected[gl_InstanceID] != 1.0f) {\n    gl_Position.z -= 1.0f;\n  } \n```", "```cpp\n ImGui::Text(\"Hightlight Instance:\");\n    ImGui::SameLine();\n    ImGui::Checkbox(\"##HighlightInstance\",\n      &renderData.rdHighlightSelectedInstance); \n```", "```cpp\n glGenTextures(1, &mSelectionTex);\n  glBindTexture(GL_TEXTURE_2D, mSelectionTex);\n  glTexImage2D(GL_TEXTURE_2D, 0, GL_R32F, width, height,\n    0, GL_RED, GL_FLOAT, NULL);\n  glBindTexture(GL_TEXTURE_2D, 0);\n  glFramebufferTexture(GL_FRAMEBUFFER,\n    GL_COLOR_ATTACHMENT1, mSelectionTex, 0); \n```", "```cpp\n const GLenum buffers[] = { GL_COLOR_ATTACHMENT0,\n   GL_COLOR_ATTACHMENT1 };\n  glDrawBuffers(2, buffers); \n```", "```cpp\nvoid Framebuffer::clearTextures() {\n  static GLfloat colorClear[] =\n    { 0.25f, 0.25f, 0.25f, 1.0f };\n  glClearBufferfv(GL_COLOR, 0, colorClear);\n  static GLfloat selectionClearColor = -1.0f;\n  glClearBufferfv(GL_COLOR, 1, &selectionClearColor);\n  static GLfloat depthValue = 1.0f;\n  glClearBufferfv(GL_DEPTH, 0, &depthValue);\n} \n```", "```cpp\n std::vector<glm::vec2> mSelectedInstance{}; \n```", "```cpp\n Shader mAssimpSelectionShader{};\n    Shader mAssimpSkinningSelectionShader{}; \n```", "```cpp\n...\nlayout (location = 2) out vec2 texCoord;\n**layout** **(****location** **=** **3****)** **out****float** **selectInfo;** \n```", "```cpp\n selectInfo = selected[gl_InstanceID].y;\n} \n```", "```cpp\nlayout (location = 2) in vec2 texCoord;\n**layout** **(****location** **=** **3****)** **flat****in****float** **selectInfo;** \n```", "```cpp\n**layout** **(****location** **=** **0****)** **out****vec4** **FragColor;**\n**layout** **(****location** **=** **1****)** **out****float** **SelectedInstance;** \n```", "```cpp\n SelectedInstance = selectInfo; \n```", "```cpp\nfloat Framebuffer::readPixelFromPos(unsigned int xPos,\n    unsigned int yPos) {\n  float pixelColor = -444.0f; \n```", "```cpp\n glBindFramebuffer(GL_READ_FRAMEBUFFER, mBuffer);\n  glReadBuffer(GL_COLOR_ATTACHMENT1); \n```", "```cpp\n glPixelStorei(GL_UNPACK_ALIGNMENT, 1);\n  glReadPixels(xPos, yPos, 1, 1, GL_RED, GL_FLOAT,\n    &pixelColor); \n```", "```cpp\n glReadBuffer(GL_COLOR_ATTACHMENT0);\n  glBindFramebuffer(GL_READ_FRAMEBUFFER, 0);\n  return pixelColor;\n} \n```", "```cpp\n if (button == GLFW_MOUSE_BUTTON_LEFT &&\n      action == GLFW_RELEASE) {\n    mMousePick = true;\n  } \n```", "```cpp\n if (mMousePick) {\n      mAssimpSkinningSelectionShader.use();\n    } else {\n      mAssimpSkinningShader.use();\n    } \n```", "```cpp\nstruct InstanceSettings {\n ...\n  int isInstanceIndexPosition = -1;\n}; \n```", "```cpp\nvoid OGLRenderer::assignInstanceIndices() {\n  for (size_t i = 0;\n      i < mModelInstData.miAssimpInstances.size(); ++i) {\n  InstanceSettings instSettings =\n    mModelInstData.miAssimpInstances.at(i)\n    ->getInstanceSettings();\n  instSettings.isInstanceIndexPosition = i;\n  mModelInstData.miAssimpInstances.at(i)\n    ->setInstanceSettings(instSettings);\n  }\n} \n```", "```cpp\n if (mMousePick) {\n      InstanceSettings instSettings =\n         modelType.second.at(i)->getInstanceSettings();\n      mSelectedInstance.at(i).y =\n        static_cast<float>(\n        instSettings.isInstanceIndexPosition);\n    } \n```", "```cpp\n if (mMousePick) {\n    glFlush();\n    glFinish(); \n```", "```cpp\n float selectedInstanceId =\n      mFramebuffer.readPixelFromPos(mMouseXPos,\n      (mRenderData.rdHeight - mMouseYPos - 1)); \n```", "```cpp\n if (selectedInstanceId >= 0.0f) {\n      mModelInstData.miSelectedInstance =\n        static_cast<int>(selectedInstanceId);\n    }\n    mMousePick = false;\n  } \n```", "```cpp\n std::shared_ptr<AssimpModel> nullModel =\n    std::make_shared<AssimpModel>();\n  mModelInstData.miModelList.emplace_back(nullModel) \n```", "```cpp\n std::shared_ptr<AssimpInstance> nullInstance =\n    std::make_shared<AssimpInstance>(nullModel);\n  mModelInstData.miAssimpInstancesPerModel[nullModel\n    ->getModelFileName()].emplace_back(nullInstance);\n  mModelInstData.miAssimpInstances.emplace_back(\n    nullInstance); \n```", "```cpp\n assignInstanceIndices(); \n```", "```cpp\n if (numberOfInstances > 0 &&\n        modelType.second.at(0)->getModel()\n        ->getTriangleCount() > 0) {\n      ... \n```", "```cpp\n if (mModelInstData.miSelectedInstance > 0) {\n    .... \n```", "```cpp\n bool modelListEmtpy =\n       modInstData.miModelList.size() == 1;\n    bool nullInstanceSelected =\n      modInstData.miSelectedInstance == 0;\n    size_t numberOfInstances =\n      modInstData.miAssimpInstances.size() - 1; \n```"]