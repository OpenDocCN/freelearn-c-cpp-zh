- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing Variable Rate Shading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to implement a technique that has become quite
    popular recently: variable rate shading. This technique allows developers to specify
    at which rate to shade individual pixels while maintaining the same perceived
    visual quality. This approach allows us to reduce the time taken for some rendering
    passes, and the time savings can be used to implement more features or render
    at higher resolutions.'
  prefs: []
  type: TYPE_NORMAL
- en: Vulkan provides multiple options to integrate this technique into an application,
    and we are going to provide an overview of all of them. This feature is provided
    through an extension that is supported only on recent hardware, but it’s possible
    to implement it manually using compute shaders. We won’t cover this option here,
    but we are going to point you to the relevant resources in the *Further* *reading*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing variable rate shading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing variable rate shading using the Vulkan API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using specialization constants to configure compute shaders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code for this chapter can be found at the following URL: [https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan/tree/main/source/chapter9](https://github.com/PacktPublishing/Mastering-Graphics-Programming-with-Vulkan/tree/main/source/chapter9).'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing variable rate shading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Variable rate shading** (**VRS**) is a technique that allows developers to
    control the rate at which fragments are shaded. When this feature is disabled,
    all fragments are shaded using a 1x1 rate, meaning that the fragment shader will
    run for all fragments in the image.'
  prefs: []
  type: TYPE_NORMAL
- en: With the introduction of **virtual reality** (**VR**) headsets, developers have
    started to investigate ways to reduce the amount of time it takes to render a
    frame. This is crucial, not only because VR requires rendering two frames (one
    for the right eye and one for the left) but also because VR is quite sensitive
    to frame latency, and higher frame rates are required to avoid users experiencing
    motion sickness.
  prefs: []
  type: TYPE_NORMAL
- en: 'One technique that was developed is called **foveated rendering**: the idea
    is to render the center of the image at full rate while lowering the quality outside
    the center. Developers have noticed that users are focused primarily on the central
    region of the image and don’t notice the lower quality in the surrounding area.'
  prefs: []
  type: TYPE_NORMAL
- en: It turns out that this approach can be generalized outside of VR. For this reason,
    APIs such as DirectX® and Vulkan have added support for this feature natively.
  prefs: []
  type: TYPE_NORMAL
- en: With this more general approach, it’s possible to specify multiple shading rates
    for individual fragments. The rates that are usually recommended are 1x1, 1x2,
    2x1, and 2x2\. While it might be possible to adopt higher shading rates, it usually
    leads to a visible artifact in the final frame.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned, a 1x1 rate implies that the fragment shader will run for all
    fragments within an image, and there are no time savings. This is the default
    behavior when VRS is not enabled.
  prefs: []
  type: TYPE_NORMAL
- en: A rate of 1x2 or 2x1 means that two fragments will be shaded by a single fragment
    shader invocation, and the computed value is applied to both fragments. Likewise,
    with a 2x2 shading rate, a single fragment invocation will compute and apply a
    single value to four fragments.
  prefs: []
  type: TYPE_NORMAL
- en: Determining the shading rate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are multiple options to choose the shading rate for individual fragments,
    and the one we have implemented is to run an edge detection filter based on luminance
    after the lighting pass.
  prefs: []
  type: TYPE_NORMAL
- en: The idea is to reduce the shading rate in the areas of the image where luminance
    is uniform and use a full rate in transition areas. This approach works because
    the human eye is more susceptible to noticing changes in those areas compared
    to ones that have more uniform values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The filter we have used is the traditional Sobel filter in a 3x3 configuration.
    For each fragment, we compute two values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – The filters used to approximate the x and y derivative for a
    given fragment (source: Wikipedia –https://en.wikipedia.org/wiki/Sobel_operator)](img/B18395_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.1 – The filters used to approximate the x and y derivative for a given
    fragment (source: Wikipedia –https://en.wikipedia.org/wiki/Sobel_operator)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We then compute the final derivative value with the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – The formula to approximate the derivative value (source: Wikipedia
    –https://en.wikipedia.org/wiki/Sobel_operator)](img/B18395_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.2 – The formula to approximate the derivative value (source: Wikipedia
    –https://en.wikipedia.org/wiki/Sobel_operator)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s apply the Sobel filter to the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – The rendered frame after the lighting pass](img/B18395_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – The rendered frame after the lighting pass
  prefs: []
  type: TYPE_NORMAL
- en: 'It gives us the following shading rate mask:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – The computed shading rate mask](img/B18395_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – The computed shading rate mask
  prefs: []
  type: TYPE_NORMAL
- en: In our implementation, we are going to use a full 1x1 rate for fragments that
    have a `G` value (as computed by the formula in *Figure 9**.2*) greater than `0.1`.
    These are the black pixels in *Figure 9**.4*.
  prefs: []
  type: TYPE_NORMAL
- en: For fragments whose `G` value is below `0.1`, we are going to use a 2x2 rate,
    and these fragments are the red pixels in the screenshot in *Figure 9**.4*. We
    will explain how the values in the mask are computed in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have introduced the concepts behind variable rate shading
    and provided the details for our implementation. In the next section, we will
    demonstrate how to implement this feature using the Vulkan API.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating variable rate shading using Vulkan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned in the previous section, the fragment shading rate functionality
    is provided through the `VK_KHR_fragment_shading_rate` extension. As with other
    option extensions, make sure the device you are using supports it before calling
    the related APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Vulkan provides three methods to control the shading rate:'
  prefs: []
  type: TYPE_NORMAL
- en: Per draw
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Per primitive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using an image attachment for a render pass
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To use a custom shading rate per draw, there are two options. We can pass a
    `VkPipelineFragmentShadingRateStateCreateInfoKHR` structure when creating a pipeline,
    or we can call `vkCmdSetFragmentShadingRateKHR` at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: This approach is useful when we know in advance that some draws can be performed
    at a lower rate without affecting quality. This could include the sky or objects
    we know are far away from the camera.
  prefs: []
  type: TYPE_NORMAL
- en: It’s also possible to provide a shading rate per primitive. This is accomplished
    by populating the `PrimitiveShadingRateKHR` built-in shader variable from a vertex
    or mesh shader.
  prefs: []
  type: TYPE_NORMAL
- en: This can be useful if, for instance, we have determined we can use a lower level
    of details in the mesh shader and a lower rate to render that particular primitive.
  prefs: []
  type: TYPE_NORMAL
- en: For our implementation, we decided to use the third approach as it is more flexible
    for our use case. As we mentioned in the previous section, we first need to compute
    the variable rate shading mask. This is done using a compute shader that populates
    the shading rate image.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by populating a table that is shared within a shader invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Each entry in the table contains the luminance value for the fragment for this
    shader invocation.
  prefs: []
  type: TYPE_NORMAL
- en: We used this approach to reduce the number of texture reads we needed to perform.
    If each shader thread had to read the values it needs individually, we would need
    eight texture reads. With this solution, only one read per thread is needed.
  prefs: []
  type: TYPE_NORMAL
- en: There is a caveat for the threads of the fragments on the border of the region
    we are processing. With each shader invocation, we process 16x16 fragments, but
    because of how the Sobel filter works, we need to fill an 18x18 table. For the
    threads on the border, we need to do some extra processing to make sure the table
    is fully filled. We have omitted the code here for brevity.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we have to use the `barrier()` method to guarantee that all threads
    within this workgroup have completed their write. Without this call, threads will
    compute the wrong value, as the table will not be filled correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we compute the value of the derivative for a given fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This is simply applying the formula we introduced in the previous section.
    Now that we have computed the derivative, we need to store the shading rate for
    this fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The rate is computed following the formula from the Vulkan specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In our case, we are computing the `texel` value in the previous formula. We
    are setting the exponent (`0` or `1`) for the `x` and `y` shading rates and storing
    the value in the shading rate image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the shading rate image has been filled, we can use it to provide the shading
    rate for the render pass for the next frame. Before using this image, we need
    to transition it to the correct layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to use a new pipeline stage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: There are a few options to use the newly created shading rate image as part
    of a render pass. The `VkSubpassDescription2` structure can be extended by a `VkFragmentShadingRateAttachmentInfoKHR`
    structure, which specifies which attachment to use as the fragment shading rate.
    Since we aren’t using the `RenderPass2` extension just yet, we opted to extend
    our existing dynamic rendering implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to extend the `VkRenderingInfoKHR` structure using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: And that’s it! The shader used for rendering doesn’t require any modifications.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have detailed the changes required to our rendering code
    to make use of a shading rate image. We have also provided the implementation
    of the compute shader that implements an edge detection algorithm based on the
    Sobel filter.
  prefs: []
  type: TYPE_NORMAL
- en: The result of this algorithm is then used to determine the shading rate for
    each fragment.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to introduce specialization constants, a Vulkan
    feature that allows us to control the workgroup size of compute shaders for optimal
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: Taking advantage of specialization constants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Specialization constants** are a Vulkan feature that allows developers to
    define constant values when creating a pipeline. This is particularly useful when
    the same shader is needed for multiple use cases that differ only for some constant
    values, for example, materials. This is a more elegant solution compared to pre-processor
    definitions as they can be dynamically controlled at runtime without having to
    recompile the shaders.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we want to be able to control the workgroup size of compute shaders
    based on the hardware we are running to obtain the best performance:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step in the implementation is to determine whether a shader uses
    specialization constants. We now identify any variables that have been decorated
    with the following type when parsing the shader SPIR-V:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When parsing all the variables, we now save the specialization constants’ details
    so that they can be used when compiling a pipeline that uses this shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have the specialization constants’ information, we can change their
    values when creating a pipeline. We start by filling a `VkSpecializationInfo`
    structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then set the value for each specialization constant entry:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our case, we are looking for a variable named `SUBGROUP_SIZE`. The final
    step is to store the specialization constant details in the shader stage structure
    that will be used when creating the pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: During compilations, the driver and compiler will override the existing value
    in the shader with the one we specified.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have illustrated how to take advantage of specialization
    constants to modify shader behavior at runtime. We detailed the changes we made
    to identify specialization constants when parsing the SPIR-V binary. We then highlighted
    the new code required to override a specialization constant value when creating
    a pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced the variable rate shading technique. We gave
    a brief overview of this approach and how it can be used to improve the performance
    of some rendering passes without a loss in perceived quality. We also explained
    the edge detection algorithm used to determine the shading rate for each fragment.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we illustrated the changes necessary to enable and use
    this feature with the Vulkan API. We detailed the options available to change
    the shading rate at the draw, primitive, and render pass level. We then explained
    the implementation of the edge detection algorithm using a compute shader and
    how the result is used to generate the shading rate image.
  prefs: []
  type: TYPE_NORMAL
- en: In the last section, we introduced specialization constants, a mechanism provided
    by the Vulkan API to modify shader constant values at compile time. We illustrated
    how this feature can be used to control the group size of compute shaders for
    optimal performance based on the device our code is running on.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will introduce volumetric effects into our scene. This
    technique allows us to set the mood of the environment and can be used to direct
    the attention of the player to a particular area.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We only gave a brief overview of the Vulkan APIs for variable rate shading.
    We recommend reading the specification for further details: [https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.xhtml#primsrast-fragment-shading-rate](https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.xhtml#primsrast-fragment-shading-rate).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the resources available online seem to be focused on the DirectX API,
    but the same approach can be translated to Vulkan. This blog post provides some
    details on the benefits of VRS: [https://devblogs.microsoft.com/directx/variable-rate-shading-a-scalpel-in-a-world-of-sledgehammers/](https://devblogs.microsoft.com/directx/variable-rate-shading-a-scalpel-in-a-world-of-sledgehammers/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'These two videos provide in-depth details on integrating VRS into existing
    game engines. The section on how to implement VRS using compute shader is particularly
    interesting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.youtube.com/watch?v=pPyN9r5QNbs](https://www.youtube.com/watch?v=pPyN9r5QNbs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.youtube.com/watch?v=Sswuj7BFjGo](https://www.youtube.com/watch?v=Sswuj7BFjGo)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This article illustrates how VRS can also have other use cases, for instance,
    to accelerate raytracing: [https://interplayoflight.wordpress.com/2022/05/29/accelerating-raytracing-using-software-vrs/](https://interplayoflight.wordpress.com/2022/05/29/accelerating-raytracing-using-software-vrs/).'
  prefs: []
  type: TYPE_NORMAL
