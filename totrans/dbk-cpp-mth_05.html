<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-62">
    <a id="_idTextAnchor061">
    </a>
    
     5
    
   </h1>
   <h1 id="_idParaDest-63">
    <a id="_idTextAnchor062">
    </a>
    
     In a C++ Class, Order Must There Be
    
   </h1>
   <p class="italic-heading">
    <em class="italic">
     
      When law and order
     
    </em>
    
     <em class="italic">
      
       kill creativity
      
     </em>
    
   </p>
   <p>
    
     Ordering items is essential across various domains to ensure organization, efficiency, and clarity.
    
    
     Whether in libraries or contact lists through alphabetical ordering, customer service queues or data analysis with numerical sorting, timelines or appointments by chronology, task management or emergency response prioritization, inventory or digital file categorization, competition rankings, clothing size arrangement, geographical routing in travel or mail delivery, sequential steps in manufacturing or software development, or hierarchical structuring in organizations and biological taxonomies, ordering helps streamline processes, improve accessibility, and
    
    
     
      enhance decision-making.
     
    
   </p>
   <p>
    
     By applying different criteria, such as alphabetical, numerical, chronological, priority, categorical, ranking, size, geographical, sequential, or hierarchical, ordering facilitates better management and optimal functioning in
    
    
     
      diverse contexts.
     
    
   </p>
   <p>
    
     In this chapter, we will explore why it is important to have a specific order for members of a C++ class and what we can gain and lose when properly or improperly declaring the members of
    
    
     
      a class.
     
    
   </p>
   <p>
    
     Also, we will get a quick overview of what the order of operations is in C++, because that is a topic that to some extent can be quite confusing, even for more
    
    
     
      advanced programmers.
     
    
   </p>
   <p>
    
     With this chapter, you will learn about
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      The importance of properly declaring class members in a
     
     
      
       specific order
      
     
    </li>
    <li>
     
      The importance of initializing your class members in the
     
     
      
       required order
      
     
    </li>
    <li>
     
      The proper order of
     
     
      
       operation executions
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-64">
    <a id="_idTextAnchor063">
    </a>
    
     Size does matter
    
   </h1>
   <p>
    
     We have learned in school about the alphabet, that puts all letters in a specific order, like A, B, C if you are English, or A, Ä‚, Ã‚ if youâ€™re Romanian (yes, there are a surprisingly large number of variations to the letter A at the beginning of the Romanian alphabet).
    
    
     Not everyone alive today is sure about the reasoning of the order, but since todaysâ€™ alphabets are based on older ones, such as Î‘, Î’, Î“ for the Greeks or ğ“€€, ğ“, ğ“£ and even ğ“· for our Ancient Egyptian ancestors, we canâ€™t really be sure why this succession of characters
    
    
     
      has emerged.
     
    
   </p>
   <p>
    
     The alphabet is a very handy thing; it helps us organize and categorize everything that can be named.
    
    
     From insects, with ants being categorized before bees, through to the spices in your cupboard (except if you organize yours based on color or, even better, usage frequencyâ€¦ poor dear Zimbabwean mufushwa, youâ€™ll stay in the back for now), it helps us greatly in keeping our daily lives neat
    
    
     
      and organized.
     
    
   </p>
   <p>
    
     Before we venture too off topic, however, letâ€™s remember that this is a book about programming (more specifically, C++ programming), and thus we need to keep focused on our subject, and not get distracted talking about the bees and the birds (bees come before birds alphabetically,
    
    
     
      of course).
     
    
   </p>
   <p>
    
     Organizing C++ concepts can, however, be a very daunting topic.
    
    
     By
    
    <em class="italic">
     
      concepts
     
    </em>
    
     , I mean functions, classes, and variables, and not the very handy feature called concepts introduced in C++20, which sadly is not the topic of
    
    
     
      this book.
     
    
   </p>
   <p>
    
     You canâ€™t really do it the way you want, because some functions need to see other functions and some blocks of code need to access variables that you have to make sure were defined before them.
    
    
     So, carefully crafting a C++ program can be
    
    
     
      very difficult.
     
    
   </p>
   <p>
    
     Things change, however, when the discussion turns to C++ classes.
    
    
     You see, in a class, these visibility-related annoyances do not really matter.
    
    
     All the methods of a class see all the other methods of that class, and all member functions can be directly accessed in all the member functions, so life in a class
    
    
     
      is easyâ€¦
     
    
   </p>
   <p>
    
     Now, dear C++ disciple, I hear you cry, â€œBut you should never call the destructor or the constructor of a class from within the class!â€
    
    
     I mostly agree, but thereâ€™s nothing stopping me from writing a method such as
    
    
     
      the following:
     
    
   </p>
   <pre class="source-code">
struct a_class {
Â Â Â void reboot() {
Â Â Â Â Â Â this-&gt;~a_class();
Â Â Â Â Â Â new (reinterpret_cast&lt;void*&gt;(this)) a_class();
Â Â Â Â }
};</pre>
   <p>
    
     However, if you write code like this, dear reader, you will suffer the consequences.
    
    
     But back to our initial
    
    <a id="_idIndexMarker221">
    </a>
    
     
      topic: ordering.
     
    
   </p>
   <p>
    
     Inherently, the human mind craves order.
    
    
     We need to be able to have an overview of what we are working with, where that information is, and how to locate it as easily as possible.
    
    
     It is imperative to easily and quickly find the required information, even if it is as insignificant as the
    
    <a id="_idIndexMarker222">
    </a>
    
     whereabouts of a member of
    
    
     
      a class.
     
    
   </p>
   <p>
    
     So, after endless struggles with locating lost members of a class, it came as a revelation to one game programmer (letâ€™s call him Joe) who was happily working at the BigGameDev company that all the members of the class should be organized in alphabetical order.
    
    
     Brilliant, now everyone can easily locate where their required member is.
    
    
     And look how beautiful the
    
    
     
      code is:
     
    
   </p>
   <pre class="source-code">
struct point {
Â Â Â bool active;
Â Â Â double x;
Â Â Â double y;
Â Â Â double z;
};</pre>
   <p>
    
     This is not a particularly complicated use case; it is just a point in some game that tells us where a point is, by providing
    
    <em class="italic">
     
      x
     
    </em>
    
     ,
    
    <em class="italic">
     
      y
     
    </em>
    
     , and
    
    <em class="italic">
     
      z
     
    </em>
    
     coordinates, and it gives a small insight into the workings of the point, to tell us whether that specific point is active or not.
    
    
     Life is good.
    
    
     The game runs neatly, and the players
    
    
     
      are happy.
     
    
   </p>
   <p>
    
     However, at some point, the lead programmer of the game project thinks that some operations on that point take up too much time (Iâ€™ll spare you all the quirky details of what operations those are and why they need it) and those operations should be performed only if the point has recorded a change of values in all three coordinates.
    
    
     Joe, our programmer, is a good and very methodic programmer, and he knows that one solution would be to store three other
    
    <strong class="source-inline">
     
      double
     
    </strong>
    
     values, representing the previous
    
    <em class="italic">
     
      x
     
    </em>
    
     ,
    
    <em class="italic">
     
      y
     
    </em>
    
     , and
    
    <em class="italic">
     
      z
     
    </em>
    
     coordinates, update those on change, if any, and perform the requested operation only if the
    
    
     
      values differ.
     
    
   </p>
   <p>
    
     However, he discards that idea and quickly concocts a different one: he will keep a
    
    <strong class="source-inline">
     
      bool
     
    </strong>
    
     flag for recording the change of each required coordinate, since he knows that a
    
    <strong class="source-inline">
     
      bool
     
    </strong>
    
     usually takes up only 1 byte, while a double on their platform boasts up to 8 bytes.
    
    
     That is a saving ofâ€¦ well, 21 bytes.
    
    
     So, here is Joeâ€™s
    
    
     
      new class:
     
    
   </p>
   <pre class="source-code">
class point {
Â Â Â bool active;
Â Â Â double x;
Â Â Â bool x_changed;
Â Â Â double y;
Â Â Â bool y_changed;
Â Â Â double z;
Â Â Â bool z_changed;
};</pre>
   <p>
    
     Beautiful â€“ as with all the code he writes, itâ€™s almost like poetry.
    
    
     He submits the newly written piece of code to the repository, where it will be built overnight, and the freshly baked binary will be delivered for testing the next day.
    
    
     And then he does not go on vacation, because he is a diligent programmer; summer is still some time away, so he will wait for the testing team to approve the code before booking
    
    
     
      plane tickets.
     
    
   </p>
   <p>
    
     Overnight, the automated tests explode, every suite fails, and the entire dashboard is red like the flag of some communist country.
    
    
     The next day, the entire testing department faces fatal failures, the game crashes, and 99.9% of the errors at some point relate to
    
    
     
      out-of-memory issues.
     
    
   </p>
   <p>
    
     The application suddenly consumes almost double the memory it was expected to consume, the test machines struggle to keep the desired frame rate, and everything is slowed down, except the memory allocation checks, which steadily show that the application now uses a lot more
    
    
     
      than yesterday.
     
    
   </p>
   <p>
    
     There were not too many changes, besides Joeâ€™s own point class overhaul; some other developer had changed the background color in the main menu from dark gray to black (sadly, the developer who was supposed to implement the ground-breaking change that requested Joeâ€™s change had to stay at home with a sick child that day), so the development team gathers to discuss the newly
    
    
     
      found issue.
     
    
   </p>
   <p>
    
     The lead developer (letâ€™s call him Jimmy for his mastery in the programming languages) takes a look at the code and quickly proclaims, â€œJoe, mate, I really appreciate the neatness of your code, and that you organize the members alphabetically, but I will have to kindly ask you to change the order
    
    
     
      of them.â€
     
    
   </p>
   <p>
    
     Joe turns almost as red as the test failure indicators on the continuous integration monitoring screen, but since he is a reasonable person, he kindly asks why on Earth he should do that.
    
    
     Doesnâ€™t Jimmy see the beauty in
    
    
     
      the code?!
     
    
   </p>
   <p>
    
     The response from Jimmy stuns him.
    
    
     This is
    
    
     
      Jimmyâ€™s explanation.
     
    
   </p>
   <p>
    
     The memory layout
    
    <a id="_idIndexMarker223">
    </a>
    
     of a C++ class is determined by several factors, including the size and alignment requirements of its members, the inheritance hierarchy, and padding added by the compiler to satisfy alignment constraints.
    
    
     When talking about size, each data member occupies a certain number of bytes based on
    
    
     
      its type.
     
    
   </p>
   <p>
    
     Iâ€™m sure Joe was aware of this; however, what he might not have grasped entirely, looking at his solution, is the alignment of each member.
    
    
     Each data member must be stored at a memory address that is a multiple of its alignment requirement.
    
    
     The alignment requirement is typically the size of the type, but it can be adjusted with
    
    
     
      compiler-specific directives.
     
    
   </p>
   <p>
    
     Now, looking at padding, in order to
    
    <a id="_idIndexMarker224">
    </a>
    
     satisfy these alignment constraints, the compiler may insert padding bytes between members, and to ensure the size of the class is a multiple of the largest alignment requirement, padding may be added at the end of
    
    
     
      the class.
     
    
   </p>
   <p>
    
     Now, the class that the
    
    <a id="_idIndexMarker225">
    </a>
    
     team had initially might have looked like the following when it was set up in memory, knowing that on their architecture, the size of a double is 8
    
    
     
      bytes long:
     
    
   </p>
   <div><div><img alt="Figure 5.1 â€“ The initial class layout" src="img/B22235_05_1.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 5.1 â€“ The initial class layout
    
   </p>
   <p>
    
     Using this alignment, the size of the class added up being 32 bytes.
    
    
     But now that Joe has have added three more
    
    <strong class="source-inline">
     
      bool
     
    </strong>
    
     s, each 1 byte long, the compiler might have organized the memory according to the
    
    
     
      following layout:
     
    
   </p>
   <div><div><img alt="Figure 5.2 â€“ The class layout with the new members in the wrong order" src="img/B22235_05_2.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 5.2 â€“ The class layout with the new members in the wrong order
    
   </p>
   <p>
    
     So, each byte of
    
    <strong class="source-inline">
     
      bool
     
    </strong>
    
     must
    
    <a id="_idIndexMarker226">
    </a>
    
     have been padded up to 8 bytes, in order to allow the placement of the double that follows to the proper memory address.
    
    
     This made the size of the class grow to 56, because 4
    
    <strong class="source-inline">
     
      bool
     
    </strong>
    
     s padded up to 8 bytes plus 3
    
    <strong class="source-inline">
     
      double
     
    </strong>
    
     values, each of them 8 bytes, so the sum of these takes up a total of 56 bytes.
    
    
     Clang, the compiler, has a switch that allows us to inspect the memory layout of generated classes:
    
    <strong class="source-inline">
     
      -fdump-record-layouts
     
    </strong>
    
     .
    
    
     In order to put it into good use for this case, we have created a simple source file with the previous class definition and passed it down to the compiler in order to
    
    
     
      inspect it:
     
    
   </p>
   <pre class="source-code">
&gt; $ clang -cc1 -fdump-record-layouts main.cpp
*** Dumping AST Record Layout
Â Â Â Â Â Â Â Â Â 0 | struct Point
Â Â Â Â Â Â Â Â Â 0 |Â Â Â _Bool active
Â Â Â Â Â Â Â Â Â 8 |Â Â Â double x
Â Â Â Â Â Â Â Â 16 |Â Â Â _Bool x_changed
Â Â Â Â Â Â Â Â 24 |Â Â Â double y
Â Â Â Â Â Â Â Â 32 |Â Â Â _Bool y_changed
Â Â Â Â Â Â Â Â 40 |Â Â Â double z
Â Â Â Â Â Â Â Â 48 |Â Â Â _Bool z_changed
Â Â Â Â Â Â Â Â Â Â Â | [sizeof=56, dsize=56, align=8,
Â Â Â Â Â Â Â Â Â Â Â |Â Â nvsize=56, nvalign=8]</pre>
   <p>
    
     The preceding data clearly denotes what we suspected initially, that is, that the
    
    <strong class="source-inline">
     
      bool
     
    </strong>
    
     that was supposed to take 1 byte now officially occupies 8 (note that behind the scenes, we have created a file called
    
    <strong class="source-inline">
     
      main.cpp
     
    </strong>
    
     with the content of the
    
    
     <strong class="source-inline">
      
       point
      
     </strong>
    
    
     
      structure).
     
    
   </p>
   <p>
    
     Now, in order to straighten out this unfortunate situation, we clearly need to take some further actions, so letâ€™s consider the reorganization of the members
    
    <a id="_idIndexMarker227">
    </a>
    
     of the class in the
    
    
     
      following manner:
     
    
   </p>
   <pre class="source-code">
class point {
Â Â Â bool active;
Â Â Â bool x_changed;
Â Â Â bool y_changed;
Â Â Â bool z_changed;
Â Â Â double y;
Â Â Â double x;
Â Â Â double z;
};</pre>
   <p>
    
     It is not a huge change, besides hurting Joeâ€™s feelings that the members are not organized alphabetically.
    
    
     We have grouped together the
    
    <strong class="source-inline">
     
      bool
     
    </strong>
    
     values so the class is as compact
    
    
     
      as possible.
     
    
   </p>
   <p>
    
     We have used the preceding information, especially taking into consideration the size requirements of each of the types, and concluded that it is always better to have small types grouped together (by
    
    <em class="italic">
     
      small types
     
    </em>
    
     , we mean variables whose type will take up the smallest number of bytes; for example, we know that the size of a
    
    <strong class="source-inline">
     
      bool
     
    </strong>
    
     variable is 1, at least for the implementation we
    
    
     
      are using).
     
    
   </p>
   <p>
    
     By doing this, that is, by reorganizing the order in which the members are presented, we have created the following memory layout (or something similar but more optimal for
    
    
     
      our architecture):
     
    
   </p>
   <div><div><img alt="Figure 5.3 â€“ The class layout with the members in the proper order" src="img/B22235_05_3.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 5.3 â€“ The class layout with the members in the proper order
    
   </p>
   <p>
    
     Indeed, after checking with
    
    <a id="_idIndexMarker228">
    </a>
    
     Clang again, the memory of the class looks very different from the previous version (please again ignore the fact that behind the scenes, we have modified our
    
    <strong class="source-inline">
     
      main.cpp
     
    </strong>
    
     to contain the
    
    
     
      preceding structure):
     
    
   </p>
   <pre class="source-code">
&gt; $ clang -cc1 -fdump-record-layouts main.cpp
*** Dumping AST Record Layout
Â Â Â Â Â Â Â Â Â 0 | struct Point
Â Â Â Â Â Â Â Â Â 0 |Â Â Â _Bool active
Â Â Â Â Â Â Â Â Â 1 |Â Â Â _Bool x_changed
Â Â Â Â Â Â Â Â Â 2 |Â Â Â _Bool y_changed
Â Â Â Â Â Â Â Â Â 3 |Â Â Â _Bool z_changed
Â Â Â Â Â Â Â Â Â 8 |Â Â Â double x
Â Â Â Â Â Â Â Â 16 |Â Â Â double y
Â Â Â Â Â Â Â Â 24 |Â Â Â double z
Â Â Â Â Â Â Â Â Â Â Â | [sizeof=32, dsize=32, align=8,
Â Â Â Â Â Â Â Â Â Â Â |Â Â nvsize=32, nvalign=8]</pre>
   <p>
    
     So, as we can see now, the four
    
    <strong class="source-inline">
     
      bool
     
    </strong>
    
     values are placed in memory one after the other, and there is only one section of padding required to fill up the required space, for the
    
    <strong class="source-inline">
     
      double
     
    </strong>
    
     values to be aligned on the required memory addresses.
    
    
     Hypothetically, if we were to have a field with a size of
    
    <strong class="source-inline">
     
      4
     
    </strong>
    
     , we could nicely fit it after the last
    
    <strong class="source-inline">
     
      bool
     
    </strong>
    
     , before the first
    
    <strong class="source-inline">
     
      double
     
    </strong>
    
     , and we would not need any
    
    
     
      padding either.
     
    
   </p>
   <p>
    
     Upon hearing Jimmyâ€™s explanation, Joe now understood the issue.
    
    
     He had never encountered alignment issues before, but he decided to read up on the subject.
    
    
     What he read was
    
    
     
      very interesting.
     
    
   </p>
   <p>
    
     It explained that the alignment of variables in memory is necessary due to a combination of hardware requirements, performance optimization, and architectural constraints.
    
    
     Most modern processors are designed to access memory more efficiently when data is aligned to
    
    
     
      certain boundaries.
     
    
   </p>
   <p>
    
     For example, an 8-byte double is typically best accessed at an address that is a multiple of 8, and when data is misaligned, the processor may need to perform multiple memory accesses to read or write the data, which can be
    
    
     
      significantly slower.
     
    
   </p>
   <p>
    
     Some architectures, such as the older generation of ARM processors, PowerPC, and older MIPS processors, cannot properly handle misaligned access, and in these situations, they generate a
    
    <strong class="source-inline">
     
      SIGBUS
     
    </strong>
    
     fault, which
    
    <a id="_idIndexMarker229">
    </a>
    
     results in the early termination of the application causing the fault.
    
    
     So, for example, the following application, when compiled, and the resulting binary executed on a processor of this generation will generate a
    
    
     <strong class="source-inline">
      
       SIGBUS
      
     </strong>
    
    
     
      fault:
     
    
   </p>
   <pre class="source-code">
#include &lt;cstdlib&gt;
int main(int argc, char **argv) {
Â Â Â Â char *cptr = (char*)malloc(sizeof(int) + 1);
Â Â Â Â int* iptr = (int *) ++cptr;
Â Â Â Â *iptr = 42;
Â Â Â Â return 0;
}</pre>
   <p>
    
     The outcome of this highly unpleasant situation on an operating system not prepared to handle a misalignment error very often has quite drastic ramifications, such as an application crash.
    
    
     Older systems may even produce a
    
    
     
      system crash.
     
    
   </p>
   <div><div><img alt="Figure 5.4 â€“ Older system throwing a tantrum when seeing unaligned data" src="img/B22235_05_4.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 5.4 â€“ Older system throwing a tantrum when seeing unaligned data
    
   </p>
   <p>
    
     You might ask what
    
    <strong class="bold">
     
      error type 7
     
    </strong>
    
     means.
    
    
     The answer is simple: 7 is the magic number that was assigned to the
    
    <strong class="source-inline">
     
      SIGBUS
     
    </strong>
    
     error.
    
    
     On the authorâ€™s Linux machine, it can be found in
    
    <strong class="source-inline">
     
      /usr/include/x86_64-linux-gnu/bits/signum-arch.h
     
    </strong>
    
     , on
    
    
     
      line 34:
     
    
   </p>
   <pre class="source-code">
/* Historical signals specified by POSIX. */
#define SIGBUSÂ Â Â Â Â Â Â Â 7Â Â Â Â /* Bus error.Â Â */</pre>
   <p>
    
     Some other processors, such as the newer generation x86_64 processors, or even the older 80286 (and everything between, mostly adhering to the specifications of the x86 platform and beyond), handle these situations very gracefully, with a tiny time penalty concerning performance, but they can be easily convinced with the following assembly instructions to turn into a very moody persona
    
    
     
      of themselves:
     
    
   </p>
   <table class="No-Table-Style _idGenTablePara-1" id="table001-2">
    <colgroup>
     <col/>
     <col/>
    </colgroup>
    <thead>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <strong class="bold">
         
          AT&amp;T (
         
        </strong>
        
         <strong class="bold">
          
           64 bit)
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <strong class="bold">
         
          Intel (
         
        </strong>
        
         <strong class="bold">
          
           32 bit)
          
         </strong>
        
       </p>
      </td>
     </tr>
    </thead>
    <tbody>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           pushf
          
         </strong>
        
       </p>
       <p>
        
         <strong class="source-inline">
          
           orl $0x40000,(%rsp)
          
         </strong>
        
       </p>
       <p>
        
         <strong class="source-inline">
          
           popf
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           pushfd
          
         </strong>
        
       </p>
       <p>
        <strong class="source-inline">
         
          or dword ptr [
         
        </strong>
        
         <strong class="source-inline">
          
           esp], 40000h
          
         </strong>
        
       </p>
       <p>
        
         <strong class="source-inline">
          
           popfd
          
         </strong>
        
       </p>
      </td>
     </tr>
    </tbody>
   </table>
   <p>
    
     The code above modifies specific bits in the
    
    <strong class="source-inline">
     
      EFLAGS
     
    </strong>
    
     register using a bitwise OR operation.
    
    
     Specifically, the hexadecimal value
    
    <strong class="source-inline">
     
      40000h
     
    </strong>
    
     corresponds to setting the
    
    <strong class="source-inline">
     
      AC
     
    </strong>
    
     (which stands for alignment check) flag in the
    
    <strong class="source-inline">
     
      EFLAGS
     
    </strong>
    
     register, this flag is used to control alignment checking.
    
    
     When this flag is set and the
    
    <strong class="source-inline">
     
      AM
     
    </strong>
    
     (which stands for alignment mask) bit in the
    
    <strong class="source-inline">
     
      CR0
     
    </strong>
    
     register is also set, the processor checks whether data is aligned on natural boundaries.
    
    
     If data misalignment is detected, a fault
    
    
     
      is generated.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      EFLAGS
     
    </strong>
    
     register
    
    <a id="_idIndexMarker230">
    </a>
    
     is a special-purpose register used in x86 architecture CPUs that contains several flags reflecting the state of the processor.
    
    
     These flags can control or indicate various conditions, such as arithmetic conditions, control features, and system settings.
    
    
     The Intel developer center
    
    
     
      <a class="_idFootnoteLink _idGenColorInherit" href="B22235_05.xhtml#footnote-018">
       
        1
       
      </a>
     
    
    
     contains a plethora of information concerning these low-level programming features.
    
    
     We encourage anyone interested in this subject to go and browse that site for
    
    
     
      further information.
     
    
   </p>
   <div><p class="Footnote-text">
     <a class="_idFootnoteAnchor _idGenColorInherit" href="B22235_05.xhtml#footnote-018-backlink">
      
       1
      
     </a>
     <a href="https://www.intel.com/content/www/us/en/resources-documentation/developer.html">
      
       
        https://www.intel.com/content/www/us/en/resources-documentation/developer.html
       
      
     </a>
    </p>
   </div>
   <p>
    
     When the previous code is inserted into the source code of an application, we can see the
    
    <strong class="source-inline">
     
      SIGBUS
     
    </strong>
    
     signal in action.
    
    
     Weâ€™ll spare listing that code here, because no one should write code that intentionally crashes their application, but instead letâ€™s examine another one of our friend Joeâ€™s encounters with the curiously occurring ordering of
    
    
     
      class members.
     
    
   </p>
   <h1 id="_idParaDest-65">
    <a id="_idTextAnchor064">
    </a>
    
     The order that must be respected
    
   </h1>
   <p>
    
     While working at
    
    <a id="_idIndexMarker231">
    </a>
    
     BigGameDev, Joe was given another task that was vaguely related to character development â€“ in-game characters, that is, not his own character.
    
    
     The task was an easy one: it just required returning a formatted string that expressed the value of life points a character has.
    
   </p>
   <p>
    
     In order to implement this, Joe created the
    
    
     
      following class:
     
    
   </p>
   <pre class="source-code">
#include &lt;string&gt;
#include &lt;format&gt;
#include &lt;iostream&gt;
#include &lt;string_view&gt;
struct life_point_tracker {
Â Â life_point_tracker(std::string_view player, int points) {
Â Â Â Â Â Â Â m_player = player;
Â Â Â Â Â Â Â m_points = points;
Â Â Â Â Â Â Â m_result = std::format("{} has {} LPs",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â m_player, m_points);
Â Â Â }
Â Â Â std::string get_data() const {
Â Â Â Â Â Â Â return m_result;
Â Â Â }
private:
Â Â Â std::string m_result {""};
Â Â Â std::string m_player {""};
Â Â Â int m_pointsÂ Â Â Â Â Â Â Â Â {0};
 };
int main() {
Â Â Â life_point_tracker lpt("Joe", 120);
Â Â Â std::cout &lt;&lt; lpt.get_data();
}</pre>
   <p>
    
     This is as
    
    <a id="_idIndexMarker232">
    </a>
    
     straightforward as it can be.
    
    
     It just takes the input data and stores the result in case one needs to access it again.
    
    
     Joe is very happy; the class members are organized nicely by type, but he is not sticking to alphabetical order anymore (he learned his lesson from the alignment discussion).
    
    
     He even uses modern C++, such as the format library or in-class initialization of members, in case some are not initialized (we could argue, though, that the strings are initialized to an empty string upon creation with the default constructor, so for them, this is not as relevant.
    
    
     This isnâ€™t the case for the
    
    <strong class="source-inline">
     
      int
     
    </strong>
    
     s), and he is generally happy with the code he
    
    
     
      has written.
     
    
   </p>
   <p>
    
     He would happily commit these into their repository right away, but common sense prevails.
    
    
     He does some quick tests, and after ensuring that everything works as expected, he asks his supervisor (the same Jimmy to whom we were introduced in the previous section) to do a quick review of the code.
    
    
     The code looks OK; it compiles and performs the required operations, and there are just two tiny observations that are to be added.
    
    
     Joe is given the following feedback: instead of doing the assignment of the members in the body of the constructor, an initializer list should be used instead.
    
    
     In addition, since he is going to use initializer lists anyway, he should make the members const, for some minor optimizations that the compiler might decide to throw in at some stage.
    
   </p>
   <p>
    
     So, he should have
    
    
     
      the following:
     
    
   </p>
   <pre class="source-code">
const std::string m_result {""};
const std::string m_player {""};
const int m_pointsÂ Â Â Â Â Â Â Â Â {0};</pre>
   <p>
    
     In C++, using an initialization list in constructors is generally preferred over in-body initialization due to several key advantages: it is more efficient since it initializes member variables directly rather than initializing them by default and then assigning them.
    
    
     Also, it ensures proper initialization of
    
    <strong class="source-inline">
     
      const
     
    </strong>
    
     and reference members, which cannot be dealt with properly in the body of
    
    
     
      the constructor.
     
    
   </p>
   <p>
    
     Joe happily changes the code, and since not that much has changed, he â€œforgetsâ€ to test it.
    
    
     Instead, he quickly submits the following sequence
    
    
     
      to review:
     
    
   </p>
   <pre class="source-code">
life_point_tracker(std::string_view player, int points)
: m_player(player), m_points(points),
Â Â m_result(std::format("{} has {} LPs", m_player, m_points)) {}</pre>
   <p>
    
     A response does not take too long to arrive and is surprisingly not the pat on the back
    
    
     
      he expected.
     
    
   </p>
   <p>
    
     â€œJoe, did you test
    
    
     
      this code?â€
     
    
   </p>
   <p>
    
     He has to admit that he did not consider it necessary, since not that much had changed.
    
    
     He just moved a few lines a bit above their previous positions, changed an equal sign to a pair of parentheses, and he was done
    
    
     
      with it.
     
    
   </p>
   <p>
    
     â€œOh, I seeâ€¦â€ said Jimmy, and he pulled out a fresh hardcopy of the latest available C++ standard from his
    
    
     
      back pocket.
     
    
   </p>
   <p>
    
     The
    
    <a id="_idIndexMarker233">
    </a>
    
     standard says the following, in the
    
    <strong class="bold">
     
      [
     
    </strong>
    
     <strong class="bold">
      
       class.base.init]
      
     </strong>
    
    
     
      section:
     
    
   </p>
   <p class="author-quote">
    
     In a non-delegating constructor, initialization proceeds in the following order:
    
   </p>
   <p class="author-quote">
    
     First, and only for the constructor of the most derived class, virtual base classes are initialized in the order they appear on a depth-first left-to-right traversal of the directed acyclic graph of base classes, where â€œleft-to-rightâ€ is the order of appearance of the base classes in the derived class base-specifier-list.
    
   </p>
   <p class="author-quote">
    
     Then, direct base classes are initialized in declaration order as they appear in the base-specifier-list (regardless of the order of the mem-initializers).
    
   </p>
   <p class="author-quote">
    
     Then, non-static data members are initialized in the order they were declared in the class definition (again regardless of the order of the mem-initializers).
    
   </p>
   <p class="author-quote">
    
     Finally, the compound-statement of the constructor body is executed.
    
   </p>
   <p>
    
     This in practice means that regardless of the order in which you specified the members to be initialized in the initializer list, they still will be initialized in the order they were declared in the class, so
    
    <strong class="source-inline">
     
      m_result
     
    </strong>
    
     will be the first one to be initialized, and since it is using the other two data members, which have not been initialized yet, the result in the best case will be undefined behavior.
    
    
     In the worst case, during testing, you will get default values, and in production, the code will
    
    
     
      fail spectacularly.
     
    
   </p>
   <p>
    
     Now, armed
    
    <a id="_idIndexMarker234">
    </a>
    
     with this knowledge, Joe was finally able to deliver the code that was expected of him, on time and to the highest possible standard he
    
    
     
      could implement:
     
    
   </p>
   <pre class="source-code">
life_point_tracker(std::string_view player, int points)
try :
Â Â Â Â m_result(std::format("{} has {} LPs", player, points)),
Â Â Â Â m_player(player),
Â Â Â Â m_points(points)
{
}
catch(...) {throw;}</pre>
   <p>
    
     He learned that while using initializer lists can be a godsend in certain situations, it can also throw your code to the mythical depths of the seven circles of compiler hell when not taking into consideration some basic rules that are set by the
    
    
     
      C++ standard.
     
    
   </p>
   <p>
    
     The C++ standard makes it mandatory that member objects are initialized in the order they are declared within the class, regardless of the order specified in the constructor initializer list, because what happens if there is no initializer list, or if only some elements are initialized
    
    
     
      in it?
     
    
   </p>
   <p>
    
     This order ensures consistency and predictability in the setup process of an object.
    
    
     When an object is constructed, initializing members in declaration order helps avoid potential issues that could arise if members were initialized out of order, especially if some members depend on others being
    
    
     
      initialized first.
     
    
   </p>
   <p>
    
     This mandated order of initialization directly influences the destruction order, which is the reverse of initialization.
    
    
     Ensuring that members are destroyed in the reverse order of their initialization guarantees that dependent members are still valid when they are needed during the destruction phase.
    
    
     This consistent and predictable cleanup process prevents potential errors and maintains the integrity of the objectâ€™s
    
    
     
      life cycle.
     
    
   </p>
   <p>
    
     Building on this requirement of the language, we can easily provide an elegant and more concise solution to this
    
    <a id="_idIndexMarker235">
    </a>
    
     problem, by using an interesting feature
    
    <a id="_idIndexMarker236">
    </a>
    
     called
    
    <strong class="bold">
     
      designated initializers
     
    </strong>
    
     , which was introduced in C++20.
    
    
     Letâ€™s simplify our structure to look along the lines of
    
    
     
      the following:
     
    
   </p>
   <pre class="source-code">
struct life_point_tracker {
Â Â Â std::string get_data() const {
Â Â Â Â Â Â Â return m_result;
Â Â Â }
Â Â Â std::string m_player {"Nameless"};
Â Â Â int m_points {0};
Â Â Â const std::string m_result
Â Â Â Â Â Â Â {std::format("{} has {} LPs", m_player, m_points)};
};</pre>
   <p>
    
     These simple structures satisfy the requirements to be used as aggregates, which are required for the designated initializer feature to compile, and as you can see, the
    
    <strong class="source-inline">
     
      m_result
     
    </strong>
    
     member is using the already-initialized
    
    <strong class="source-inline">
     
      m_player
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      m_points
     
    </strong>
    
     members, during the construction of itself.
    
    
     Now, in the place where want to use the class, we just have to do
    
    
     
      the following:
     
    
   </p>
   <pre class="source-code">
int main(int argc, char **argv) {
Â Â Â life_point_tracker lpt {
Â Â Â Â Â Â Â .m_player = "Joe",
Â Â Â Â Â Â Â .m_points = 120
Â Â Â };
Â Â Â std::cout &lt;&lt; lpt.get_data();
}</pre>
   <p>
    
     By adhering to this handy feature, we have explicitly specified which member should be initialized to which value (this can be very helpful if, for example, there are more than two integers that need to be initialized).
    
    
     Also, the feature requires the members to be specified in the order of their declaration, thus increasing the readability and maintainability of the code.
    
    
     The only drawback is that we had to dumb down our class to an
    
    <strong class="bold">
     
      aggregate
     
    </strong>
    
     , so no virtual
    
    <a id="_idIndexMarker237">
    </a>
    
     functions, no constructors, no encapsulation â€“ none of the good stuff that raises a C++ class to mythical fame.
    
    
     But if itâ€™s good enough for Joe, we can live
    
    
     
      with it.
     
    
   </p>
   <h1 id="_idParaDest-66">
    <a id="_idTextAnchor065">
    </a>
    
     Deep thoughts about order
    
   </h1>
   <p>
    
     The adventures of our
    
    <a id="_idIndexMarker238">
    </a>
    
     friend Joe do not end here, because shortly after learning that the proper order of class members is not necessarily an alphabetical one, he was given a task that involved executing some code in a parallel manner.
    
    
     Since he learned everything about threads and associated features by watching a quick introductory tutorial to the subject by some guy on TikTok, he felt he was up to the task, and shortly, the following code was committed to the repository (please bear with the authors in this case; due to some pathological manifestations of copyright and intellectual property litigations, we cannot show the original code that took the entire development team two weeks to debug and fix.
    
    
     The example code is actually just trying to recreate the scenario that Joe so
    
    
     
      successfully implemented):
     
    
   </p>
   <pre class="source-code">
#include &lt;cstdio&gt;
#include &lt;thread&gt;
#include &lt;chrono&gt;
using namespace std::chrono_literals;
struct bar {
Â Â bar() : i(new long long) {
Â Â Â Â *i = 0;Â Â printf("bar::bar()\n");}
Â Â ~bar() {printf("bar::~bar()\n"); delete i;Â Â i = nullptr;}
Â Â void serve() {
Â Â Â while(true) {
Â Â Â Â Â (*i)++;
Â Â Â Â Â if(*i % 1024768 == 0) {
Â Â Â Â Â Â Â std::this_thread::sleep_for(200ms);
Â Â Â Â Â Â Â (*i) = 0;
Â Â Â Â Â Â Â printf("."); fflush(stdout);
Â Â Â Â Â }
Â Â Â Â Â if(stopRequest) break;
Â Â Â }
}
long long* i = nullptr;
bool stopRequest = false;
};
struct foo {
Â Â foo() : thread(&amp;foo::threadFunc, this) {
Â Â Â Â printf("foo::foo()\n");
Â Â }
Â Â ~foo() {
Â Â Â Â Â Â printf("foo::~foo()\n"); b.stopRequest = true;
Â Â }
Â Â void threadFunc() {
Â Â Â Â b.serve();
Â Â }
Â Â std::jthread thread;
Â Â bar b;
};
int main() {
Â Â foo f;
Â Â std::this_thread::sleep_for(2000ms);
Â Â printf("main returns\n");
Â Â return 0;
}</pre>
   <p>
    
     The given
    
    <a id="_idIndexMarker239">
    </a>
    
     C++ program tries to get as close as possible to the simple multithreaded mayhem Joe created, using two friendly structures, named
    
    <strong class="source-inline">
     
      bar
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      foo
     
    </strong>
    
     (we let
    
    <strong class="source-inline">
     
      baz
     
    </strong>
    
     take a rest for a short while, but if you miss him, you can name the function
    
    <strong class="source-inline">
     
      baz
     
    </strong>
    
     ), creating a meaningful interaction in order to perform a task on a separate thread.
    
    
     The
    
    <strong class="source-inline">
     
      bar
     
    </strong>
    
     structure manages a dynamically allocated
    
    <strong class="source-inline">
     
      long long
     
    </strong>
    
     variable,
    
    <strong class="source-inline">
     
      i
     
    </strong>
    
     (because what else would we call a variable that has the role of an index?), which is continuously incremented in its
    
    <strong class="source-inline">
     
      serve
     
    </strong>
    
     method.
    
    
     When the increment count reaches
    
    <strong class="source-inline">
     
      1024768
     
    </strong>
    
     (letâ€™s just ignore the fact that 1024x768 is also a screen resolution), then it pauses for 200 milliseconds, resets the counter
    
    <strong class="source-inline">
     
      i
     
    </strong>
    
     to
    
    <strong class="source-inline">
     
      0
     
    </strong>
    
     , and prints a dot to the console (in the real-life application, something else happened, but that is out of the scope of
    
    
     
      this book).
     
    
   </p>
   <p>
    
     This loop continues indefinitely until
    
    <strong class="source-inline">
     
      stopRequest
     
    </strong>
    
     is set to
    
    <strong class="source-inline">
     
      true
     
    </strong>
    
     , signaling the thread to exit.
    
    
     The constructor of
    
    <strong class="source-inline">
     
      bar
     
    </strong>
    
     initializes the counter
    
    <strong class="source-inline">
     
      i
     
    </strong>
    
     , and for our sole purpose of debugging, it prints a message, while the destructor handles memory cleanup and prints another message, ensuring that resources are properly managed.
    
    
     Why Joe does not use a smart pointer is another story, so letâ€™s not focus on that part
    
    
     
      for now.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      foo
     
    </strong>
    
     structure is responsible for starting and stopping the thread that runs the
    
    <strong class="source-inline">
     
      serve
     
    </strong>
    
     method of a
    
    <strong class="source-inline">
     
      bar
     
    </strong>
    
     instance.
    
    
     Upon creation,
    
    <strong class="source-inline">
     
      foo
     
    </strong>
    
     initializes a
    
    <strong class="source-inline">
     
      std::jthread
     
    </strong>
    
     to run its
    
    <strong class="source-inline">
     
      threadFunc
     
    </strong>
    
     , which in turn calls the
    
    <strong class="source-inline">
     
      serve
     
    </strong>
    
     method of its
    
    <strong class="source-inline">
     
      bar
     
    </strong>
    
     instance.
    
    
     This setup allows the
    
    <strong class="source-inline">
     
      serve
     
    </strong>
    
     method to run concurrently with the
    
    <strong class="source-inline">
     
      main
     
    </strong>
    
     program.
    
    
     The
    
    <strong class="source-inline">
     
      foo
     
    </strong>
    
     destructor sets
    
    <strong class="source-inline">
     
      stopRequest
     
    </strong>
    
     to
    
    <strong class="source-inline">
     
      true
     
    </strong>
    
     , ensuring the thread exits gracefully.
    
    
     Again, it remained a mystery why Joe decided to pick this way of gracefully ending the thread, but since it worked (after the already-mentioned two weeks of debugging and troubleshooting sessions), the engineering team decided not to ever mention this sequence
    
    
     
      of code.
     
    
   </p>
   <p>
    
     In the
    
    <strong class="source-inline">
     
      main
     
    </strong>
    
     function, an instance of
    
    <strong class="source-inline">
     
      foo
     
    </strong>
    
     is created, starting the thread upon its creation, and the program sleeps for two seconds to allow the thread to run.
    
    
     For brevity, letâ€™s just assume that in the original application, there was no mention of any kind of sleeping; the real beauty of the solution came from some lengthy operations performed in the
    
    <strong class="source-inline">
     
      main
     
    </strong>
    
     and
    
    
     <strong class="source-inline">
      
       bar
      
     </strong>
    
    
     
      threads.
     
    
   </p>
   <p>
    
     Dear seasoned C++
    
    <a id="_idIndexMarker240">
    </a>
    
     programmers: please do not focus on how this synthetic piece of code is handling the thread synchronization, or the fact that it allocates and releases memory, because that is not the purpose of it.
    
    
     The sole purpose of this code is to crash.
    
    
     For
    
    <strong class="source-inline">
     
      std::jthread
     
    </strong>
    
     , there are plenty of mechanisms to properly handle the execution, such as
    
    <strong class="source-inline">
     
      std::stop_source
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      std::stop_token
     
    </strong>
    
     , so please feel free to read up on them and let Joe suffer with his naive approach to threading
    
    
     
      for now.
     
    
   </p>
   <p>
    
     When the code is executed, the following is the result, at least on the authorâ€™s
    
    
     
      Linux system:
     
    
   </p>
   <pre class="source-code">
&gt; $ ./a.out
bar::bar()
foo::foo()
.........main returns
foo::~foo()
bar::~bar()</pre>
   <p>
    
     However, sometimes the output is
    
    
     
      as follows:
     
    
   </p>
   <pre class="source-code">
&gt; $ ./a.out
bar::bar()
foo::foo()
.........main returns
foo::~foo()
bar::~bar()
[1]Â Â Â Â 93622 segmentation fault (core dumped)Â Â ./a.out</pre>
   <p>
    
     The same happened to Joe too.
    
    
     Occasionally, the application would go haywire and crash upon exit.
    
    
     Initially, this was not too much of a hassle because, well, if the application crashes at the end, thatâ€™s not the end of it.
    
    
     However, after a while, the code Joe wrote was introduced in a larger module, and thatâ€™s where chaos, mayhem, and the aforementioned two weeks of debugging
    
    
     
      sessions materialized.
     
    
   </p>
   <p>
    
     The reason for the misdemeanor is quite simple.
    
    
     Jimmy, the master programmer discovered after consulting his pocket version of the C++ standard, specifically the
    
    <strong class="source-inline">
     
      [class.dtor]
     
    </strong>
    
     section
    
    
     
      of it:
     
    
   </p>
   <p class="author-quote">
    
     After executing the body of the destructor and destroying any objects with automatic storage duration allocated within the body, a destructor for class X calls the destructors for Xâ€™s direct non-variant non-static data members, the destructors for Xâ€™s non-virtual direct base classes and, if X is the most derived class, its destructor calls the destructors for Xâ€™s virtual base classes.
    
    
     All destructors are called as if they were referenced with a qualified name, that is, ignoring any possible virtual overriding destructors in more derived classes.
    
    
     Bases and members are destroyed in the reverse order of the completion of their constructor.
    
    
     A return statement in a destructor might not directly return to the caller; before transferring control to the caller, the destructors for the members and bases are called.
    
    
     Destructors for elements of an array are called in reverse order of their construction.
    
   </p>
   <p>
    
     The key is that the objects are destroyed in reverse order of their creation, just like they would have been pushed onto a stack upon creation and popped off with grace in the reverse order upon destruction.
    
    
     The culprits for the erroneous behavior were quickly identified as being
    
    
     
      the following:
     
    
   </p>
   <p>
    
     <strong class="source-inline">
      
       std::jthread thread;
      
     </strong>
    
   </p>
   <p>
    
     <strong class="source-inline">
      
       bar b;
      
     </strong>
    
   </p>
   <p>
    
     So, what happened
    
    <a id="_idIndexMarker241">
    </a>
    
     here upon construction was that the thread was created and started running its thread method:
    
    <strong class="source-inline">
     
      void threadFunc() { b.serve(); }
     
    </strong>
    
     .
    
    
     Only after this unpredictable operation was initiated was the
    
    <strong class="source-inline">
     
      bar b
     
    </strong>
    
     object created.
    
    
     Then, upon exit, as per the design of the C++ language, the
    
    <strong class="source-inline">
     
      bar b
     
    </strong>
    
     object was deleted and its resources freed.
    
    
     While the thread was still possibly being blocked in the long operation, suddenly it was running on an object that was
    
    
     
      already deleted.
     
    
   </p>
   <p>
    
     The delay between the creation of the thread object, the actual starting of the thread routine, and the creation of the
    
    <strong class="source-inline">
     
      bar b
     
    </strong>
    
     object is so insignificant that catching the error in the creation phase is almost implausible.
    
    
     But letâ€™s modify the constructor of
    
    <strong class="source-inline">
     
      bar
     
    </strong>
    
     to be along the lines of
    
    
     
      the following:
     
    
   </p>
   <pre class="source-code">
bar() { std::this_thread::sleep_for(200ms);
Â Â Â Â i = new long long; *i = 0;Â Â printf("bar::bar()\n ");}</pre>
   <p>
    
     In an instant, we can see how the thread is running on an object whose creation was not entirely finished by the time the thread started using it.
    
    
     Certainly, this specific issue can be resolved easily, by simply switching the order of
    
    
     
      the members:
     
    
   </p>
   <pre class="source-code">
bar b;
std::jthread thread;</pre>
   <p>
    
     Threading is an interesting aspect of C++.
    
    
     While it comes with many benefits, it also introduces extra complexity.
    
    
     Properly writing correct and efficient multithreaded code requires careful consideration of synchronization and coordination between
    
    
     
      various threads.
     
    
   </p>
   <p>
    
     Debugging
    
    <a id="_idIndexMarker242">
    </a>
    
     multithreaded applications can be challenging due to issues such as race conditions, deadlocks, and non-deterministic behavior, or the simple fact that the thread is stopped by the debugger, so upon inspecting it, no real work happens, and sometimes the success or failure of an application really hangs on the order in which the class members are declared.
    
    
     But for now, letâ€™s say goodbye to Joe and his friends.
    
    
     Letâ€™s hope they have got their AAAA title out on the door, and letâ€™s focus our attention on
    
    
     
      something else.
     
    
   </p>
   <h1 id="_idParaDest-67">
    <a id="_idTextAnchor066">
    </a>
    
     The dark orders of C++
    
   </h1>
   <p>
    
     There is one
    
    <a id="_idIndexMarker243">
    </a>
    
     dark corner of the C++ language that is rarely touched by sunlight, and if a piece of code from these depths surfaces by any chance, a gang of hardcore developers immediately jumps on it and refactors it into digestible bits and bytes.
    
    
     Letâ€™s consider, for example, the very simple case of why the
    
    <strong class="source-inline">
     
      a[2]
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      2[a]
     
    </strong>
    
     expressions are equivalent when in C++, and
    
    <strong class="source-inline">
     
      a
     
    </strong>
    
     is an array
    
    
     
      of objects:
     
    
   </p>
   <pre class="source-code">
int main() {
Â Â Â Â int a[16] = {0};
Â Â Â Â a[2] = 3;
Â Â Â Â 3[a] = 4;
}</pre>
   <p>
    
     The
    
    <a id="_idIndexMarker244">
    </a>
    
     preceding piece of code, despite the fact that it looks ugly, actually compiles.
    
    
     The reason is the following: in C++, the
    
    <strong class="source-inline">
     
      operator []
     
    </strong>
    
     array subscript is defined in terms of pointer arithmetic.
    
    
     The
    
    <strong class="source-inline">
     
      a[i]
     
    </strong>
    
     expression is translated by the compiler into
    
    <strong class="source-inline">
     
      *(a + i)
     
    </strong>
    
     , where
    
    <strong class="source-inline">
     
      a
     
    </strong>
    
     is a pointer to the first element of the array and
    
    <strong class="source-inline">
     
      i
     
    </strong>
    
     is the index.
    
    
     The
    
    <strong class="source-inline">
     
      i[a]
     
    </strong>
    
     expression at the end is also translated to the
    
    <strong class="source-inline">
     
      *(i + a)
     
    </strong>
    
     expression, where
    
    <strong class="source-inline">
     
      i
     
    </strong>
    
     is the index and
    
    <strong class="source-inline">
     
      a
     
    </strong>
    
     is the pointer to our arraysâ€™
    
    
     
      first elements.
     
    
   </p>
   <p>
    
     Since addition is commutative for the compiler, it does not really matter which
    
    
     
      comes first.
     
    
   </p>
   <p>
    
     So, we have found a specific case where order doesnâ€™t really matter in C++.
    
    
     But this works only for old-style C arrays;
    
    <strong class="source-inline">
     
      std::vector
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      std::array
     
    </strong>
    
     do not accept this kind of out-of-order syntax.
    
    
     There is a very specific reasoning for that; the subscript operator for
    
    <strong class="source-inline">
     
      std::vector
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      std::array
     
    </strong>
    
     does not support the commutative behavior seen in raw arrays, namely
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Operator overloading
      
     </strong>
     
      : The
     
     <strong class="source-inline">
      
       operator[]
      
     </strong>
     
      for
     
     <strong class="source-inline">
      
       std::vector
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       std::array
      
     </strong>
     
      is a member
     
     <a id="_idIndexMarker245">
     </a>
     
      function, meaning it needs to be called on an instance of the class.
     
     
      It cannot be invoked with the index first, as member functions require the object to be on the left side of
     
     
      
       the call.
      
     
    </li>
    <li>
     <strong class="bold">
      
       No pointer arithmetic
      
     </strong>
     
      : The internal implementation of
     
     <strong class="source-inline">
      
       std::vector
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       std::array
      
     </strong>
     
      does not rely on raw pointer arithmetic for indexing.
     
     
      They manage their memory and bounds checking differently, ensuring safer access
     
     
      
       to elements.
      
     
    </li>
   </ul>
   <p>
    
     At the current stage, the closest we can get to emulating the preceding unholy syntax for an object of type
    
    <strong class="source-inline">
     
      std::vector
     
    </strong>
    
     is the
    
    
     
      following code:
     
    
   </p>
   <pre class="source-code">
#include &lt;vector&gt;
#include &lt;iostream&gt;
struct wrapper {
Â Â Â wrapper(int p) : i(p) {}
Â Â Â int operator[](const std::vector&lt;int&gt; v) {return v[i];}
Â Â Â int i = 0;
};
struct helper {
Â Â Â helper() = default;
Â Â Â wrapper operator &lt;&lt; (int a) { return wrapper {a}; }
};
#define _ helper()&lt;&lt;
int main() {
Â Â Â std::vector&lt;int&gt; vec = {10, 20, 30, 40, 50};
Â Â Â int b= (_ 2) [vec];
Â Â Â std::cout &lt;&lt; b &lt;&lt; std::endl;Â Â // Outputs 30
Â Â Â return 0;
}</pre>
   <p>
    
     After a quick
    
    <a id="_idIndexMarker246">
    </a>
    
     examination of it, however, we, the authors (well, not actually both the authors, because Alex is innocent, at least concerning this code, so please consider this as the royal we), have decided that we are ashamed of it, and did not dare implement it for
    
    <strong class="source-inline">
     
      std::array
     
    </strong>
    
     or any
    
    
     
      other containers.
     
    
   </p>
   <p>
    
     But on a second look, we have some interesting code there.
    
    
     Our main goal was to recreate the orderless index access for vectors and arrays, but before we indulge ourselves in believing that it is possible, a harsh reality check: it is not.
    
    
     The reason for this is the following: if we try to compile the expression
    
    <strong class="source-inline">
     
      2[vec];
     
    </strong>
    
     , we get the
    
    
     
      following error:
     
    
   </p>
   <pre class="source-code">
error: no match for 'operator[]' (operand types are 'int' and 'std::vector&lt;int&gt;')</pre>
   <p>
    
     This, translated to plain English, means the compiler cannot find an index operator that is applied to integers and takes in as parameter a vector of ints.
    
    
     As long as C++ is C++, this will not happen for two major reasons.
    
    
     The first is that
    
    <strong class="source-inline">
     
      operator[]
     
    </strong>
    
     needs to be a member function in a class.
    
    
     It is not possible to have a freestanding
    
    <strong class="source-inline">
     
      []
     
    </strong>
    
     
      operator.
     
    
   </p>
   <p>
    
     The second is a peculiar thing, called operator precedence.
    
    
     That is not an operator called
    
    <em class="italic">
     
      precedence
     
    </em>
    
     , but the following: in C++, the order of operations, also known as operator precedence, determines
    
    <a id="_idIndexMarker247">
    </a>
    
     how operators are parsed concerning each other.
    
    
     Operators with higher precedence are evaluated before operators with lower precedence.
    
    
     When operators have the same precedence, their associativity determines the order
    
    
     
      of evaluation.
     
    
   </p>
   <p>
    
     While in the latest standard,
    
    <a href="B22235_07.xhtml#_idTextAnchor079">
     
      <em class="italic">
       
        Chapter 7
       
      </em>
     
    </a>
    <em class="italic">
     
      , Expressions
     
    </em>
    
     (specifically the
    
    <strong class="bold">
     
      [expr.pre]
     
    </strong>
    
     section), mentions that â€œThe precedence of operators is not directly specified, but it can be derived from the syntaxâ€ there are official sources of information2
    
    
     <a class="_idFootnoteLink _idGenColorInherit" href="B22235_05.xhtml#footnote-017">
      
       2
      
     </a>
    
    
     which contain the exact order of them so we really encourage you to go and dedicate proper time to study one of those sources.
    
   </p>
   <div><p class="Footnote-text">
     <strong class="source-inline">
      <a class="_idFootnoteAnchor _idGenColorInherit" href="B22235_05.xhtml#footnote-017-backlink">
       
        2
       
      </a>
     </strong>
     <strong class="source-inline">
     </strong>
     <a href="https://en.cppreference.com/w/cpp/language/operator_precedence">
      
       
        https://en.cppreference.com/w/cpp/language/operator_precedence
       
      
     </a>
    </p>
   </div>
   <h2 id="_idParaDest-68">
    <a id="_idTextAnchor067">
    </a>
    
     The most important question
    
   </h2>
   <p>
    
     And now that youâ€™re back, dear reader, we are pretty sure that you can easily answer the following question.
    
    
     What is the output of the
    
    
     
      following program?
     
    
   </p>
   <pre class="source-code">
#include &lt;iostream&gt;
int main() {
Â Â Â Â auto a = 4;
Â Â Â Â std::cout &lt;&lt; sizeof(a)["Hello World"] &lt;&lt; std::endl;
Â Â Â Â return 0;
}</pre>
   <p>
    
     Before you rush into feeding the code into your compiler, however, pause, sit back, and think thoroughly about what exactly is happening here.
    
    
     This section gave you all the hints, directions, and possible clues you needed in order to answer this correctly.
    
    
     We intentionally will not give the answer yet, nor a full explanation of the code, just a quick breakdown of whatâ€™s happening, which should be enough to figure
    
    
     
      it out:
     
    
   </p>
   <ul>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       auto a = 4;
      
     </strong>
     
      expression, the
     
     <strong class="source-inline">
      
       a
      
     </strong>
     
      variable is declared with the
     
     <strong class="source-inline">
      
       int
      
     </strong>
     
      type and initialized to
     
     <strong class="source-inline">
      
       4
      
     </strong>
     
      .
     
     
      This is just the way
     
     <strong class="source-inline">
      
       auto
      
     </strong>
     
      and numbers work in
     
     
      
       modern C++.
      
     
    </li>
    <li>
     
      Now comes the tricky part.
     
     
      Parsing the code in our brain, it is obvious that the
     
     <strong class="source-inline">
      
       sizeof(a)
      
     </strong>
     
      expression evaluates to a
     
     <strong class="source-inline">
      
       std::sizeof
      
     </strong>
     
      type, and typically,
     
     <strong class="source-inline">
      
       sizeof(int)
      
     </strong>
     
      is 4 bytes on most systems.
     
     
      Certainly, older 16-bit systems have
     
     <strong class="source-inline">
      
       sizeof(int)
      
     </strong>
     
      as
     
     <strong class="source-inline">
      
       2
      
     </strong>
     
      ; some exotic systems can have
     
     <strong class="source-inline">
      
       sizeof(int)
      
     </strong>
     
      as
     
     <strong class="source-inline">
      
       8
      
     </strong>
     
      , but the author of these lines has never seen a system
     
     
      
       like that.
      
     
    </li>
   </ul>
   <p>
    
     This is the crucial point where all our deduction has chicaned out.
    
    
     What kicks in is the operator precedence of C++.
    
    
     Hereâ€™s just a tiny extract from the preceding table, where we have kept just the parts relevant to
    
    
     
      our case:
     
    
   </p>
   <table class="No-Table-Style _idGenTablePara-1" id="table002">
    <colgroup>
     <col/>
     <col/>
     <col/>
    </colgroup>
    <thead>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Precedence
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Operator
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Description
          
         </strong>
        
       </p>
      </td>
     </tr>
    </thead>
    <tbody>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         1
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         
          ::
         
        </strong>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Scope
        
        
         
          resolution operator
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         2
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           a++ a--
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Postfix increment
        
        
         
          and decrement
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           a()
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         
          Function call
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           a[]
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         
          Subscript
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         3
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         
          ++
         
        </strong>
        
         <strong class="source-inline">
          
           a --a
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Prefix increment
        
        
         
          and decrement
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
      </td>
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         
          +
         
        </strong>
        
         <strong class="source-inline">
          
           a -a
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Unary plus
        
        
         
          and minus
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
      </td>
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         
          !
         
         
          ~
         
        </strong>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Logical NOT and
        
        
         
          bitwise NOT
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
      </td>
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         
          *a
         
        </strong>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         
          Dereference
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
      </td>
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         
          &amp;a
         
        </strong>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         
          Address-of
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           sizeof
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Size
        
        
         
          of operator
         
        
       </p>
      </td>
     </tr>
    </tbody>
   </table>
   <p>
    
     Now, we can finally see that in our code, the expression
    
    <strong class="source-inline">
     
      sizeof(a)
     
    </strong>
    
     will never be evaluated.
    
    
     Due to the way the C++ compiler works, the
    
    <strong class="source-inline">
     
      []
     
    </strong>
    
     operator has priority over
    
    <strong class="source-inline">
     
      sizeof
     
    </strong>
    
     , so what will be evaluated first is
    
    <strong class="source-inline">
     
      (
     
    </strong>
    
     <strong class="source-inline">
      
       a)["Hello World"];
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Since in C++
    
    <strong class="source-inline">
     
      (a)
     
    </strong>
    
     is almost always identical to
    
    <strong class="source-inline">
     
      a
     
    </strong>
    
     (except when you are dealing with the
    
    <em class="italic">
     
      most vexing parse
     
    </em>
    
     , but more on that at a later stage), the expression is identical to
    
    <strong class="source-inline">
     
      sizeof
     
    </strong>
    
     <strong class="source-inline">
      
       a["Hello World"];
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Now, as we have seen, this yields the same result as
    
    <strong class="source-inline">
     
      sizeof "Hello World"[a];
     
    </strong>
    
     , which, considering that today,
    
    <strong class="source-inline">
     
      a
     
    </strong>
    
     will most likely be
    
    <strong class="source-inline">
     
      4
     
    </strong>
    
     , gives us the character
    
    <strong class="source-inline">
     
      'o'
     
    </strong>
    
     .
    
    
     So, the entire expression is now reduced to
    
    <strong class="source-inline">
     
      sizeof 'o'
     
    </strong>
    
     , which, considering the way
    
    <strong class="source-inline">
     
      sizeof
     
    </strong>
    
     works, will always
    
    
     
      return
     
    
    
     <strong class="source-inline">
      
       1
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     We, the authors, think that at this stage, the answer to our question
    
    
     
      is obvious.
     
    
   </p>
   <h1 id="_idParaDest-69">
    <a id="_idTextAnchor068">
    </a>
    
     When order does not matter
    
   </h1>
   <p>
    
     There is one
    
    <a id="_idIndexMarker248">
    </a>
    
     tiny thing we ought not to forget to mention before closing this chapter.
    
    
     Well, actually two.
    
    
     The first one is that in C++, the order in which function arguments are evaluated is unspecified.
    
    
     This means that when you call a function with multiple arguments, the compiler is free to evaluate the arguments in any order it chooses.
    
    
     This can lead to unexpected results if the arguments have side effects, such as modifying
    
    
     
      a variable.
     
    
   </p>
   <p>
    
     Letâ€™s take, for example, the
    
    
     
      following program:
     
    
   </p>
   <pre class="source-code">
#include &lt;iostream&gt;
int f (int a, int b, int c) {
Â Â Â Â std::cout &lt;&lt; "a="&lt;&lt;a&lt;&lt;" b="&lt;&lt;b&lt;&lt;" c="&lt;&lt;c&lt;&lt;std::endl;
Â Â Â Â return a+b+c;
}
int main() {
Â Â Â Â int i = 1;
Â Â Â Â std::cout&lt;&lt;"f="&lt;&lt;f(i++, i++, i++)&lt;&lt;std::endl&lt;&lt;"i="&lt;&lt;i&lt;&lt;std::endl;
}</pre>
   <p>
    
     Regardless of what you think the output of this program is, it will
    
    
     
      be wrong.
     
    
   </p>
   <p>
    
     The reason for
    
    <a id="_idIndexMarker249">
    </a>
    
     this is, again, as mentioned previously: the order of evaluation of the parameters is not specified.
    
    
     With good reason, you may ask, why?
    
    
     The reasons for this are a bit more complex and historical.
    
    
     But before delving deeper into that, letâ€™s amuse ourselves with the output that various compilers provide us with, courtesy of gcc.godbolt.org and some
    
    
     
      other sources.
     
    
   </p>
   <table class="No-Table-Style _idGenTablePara-1" id="table003">
    <colgroup>
     <col/>
     <col/>
    </colgroup>
    <tbody>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Compiler
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Output
          
         </strong>
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         Microsoft Visual C++ (
        
        
         
          after 2005)
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         
          a=1
         
        </strong>
        
         <strong class="source-inline">
          
           b=1 c=1
          
         </strong>
        
       </p>
       <p>
        
         <strong class="source-inline">
          
           f=3
          
         </strong>
        
       </p>
       <p>
        
         <strong class="source-inline">
          
           i=4
          
         </strong>
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         Microsoft
        
        
         
          VS.NET 2003
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         
          a=3
         
        </strong>
        
         <strong class="source-inline">
          
           b=2 c=1
          
         </strong>
        
       </p>
       <p>
        
         <strong class="source-inline">
          
           f=6
          
         </strong>
        
       </p>
       <p>
        
         <strong class="source-inline">
          
           i=4
          
         </strong>
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         Microsoft Visual
        
        
         
          C++ 6
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         
          a=1
         
        </strong>
        
         <strong class="source-inline">
          
           b=1 c=1
          
         </strong>
        
       </p>
       <p>
        
         <strong class="source-inline">
          
           f=3
          
         </strong>
        
       </p>
       <p>
        
         <strong class="source-inline">
          
           i=4
          
         </strong>
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         ICC and Clang agree
        
        
         
          on thisâ€¦
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         
          f=a=1
         
        </strong>
        
         <strong class="source-inline">
          
           b=2 c=3
          
         </strong>
        
       </p>
       <p>
        <strong class="source-inline">
         
          6
         
        </strong>
       </p>
       <p>
        
         <strong class="source-inline">
          
           i=4
          
         </strong>
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         GCC,
        
        
         
          after 6.5
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         
          f=a=3
         
        </strong>
        
         <strong class="source-inline">
          
           b=2 c=1
          
         </strong>
        
       </p>
       <p>
        <strong class="source-inline">
         
          6
         
        </strong>
       </p>
       <p>
        
         <strong class="source-inline">
          
           i=4
          
         </strong>
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         GCC,
        
        
         
          before 6.5
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         
          a=3
         
        </strong>
        
         <strong class="source-inline">
          
           b=2 c=1
          
         </strong>
        
       </p>
       <p>
        
         <strong class="source-inline">
          
           f=6
          
         </strong>
        
       </p>
       <p>
        
         <strong class="source-inline">
          
           i=4
          
         </strong>
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         Turbo C Lite and
        
        
         
          Borland C++55
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         
          a=3
         
        </strong>
        
         <strong class="source-inline">
          
           b=2 c=1
          
         </strong>
        
       </p>
       <p>
        
         <strong class="source-inline">
          
           f=6
          
         </strong>
        
       </p>
       <p>
        
         <strong class="source-inline">
          
           i=1
          
         </strong>
        
       </p>
      </td>
     </tr>
    </tbody>
   </table>
   <p>
    
     So, we have a
    
    <a id="_idIndexMarker250">
    </a>
    
     plethora of options to choose from, some more straightforward and others more exotic.
    
    
     All these weird values claim they are the right one, the one to rule them all, regardless of the fact that even different versions of the same compiler from the same provider provide different results.
    
    
     And they are all right in
    
    
     
      their belief.
     
    
   </p>
   <p>
    
     Quite simply, the reasoning is that allowing the compiler the freedom to choose the order of evaluation enables it to make optimizations that can improve performance that we programmers may not notice.
    
    
     The compiler can reorder instructions to take advantage of CPU pipelines, minimize register usage, and enhance cache efficiency.
    
    
     Specifying a strict order would limit these
    
    
     
      optimization opportunities.
     
    
   </p>
   <p>
    
     Different hardware architectures may have different optimal evaluation strategies.
    
    
     By not specifying the order of evaluation, C++ code can be more easily optimized for a wide variety of architectures without requiring changes to the
    
    
     
      code itself.
     
    
   </p>
   <p>
    
     Also, by not specifying the order of evaluation, the C++ language specification remains simpler.
    
    
     Specifying a strict order for all expressions would add complexity to the language definition and increase the burden on compiler developers.
    
    
     Not to mention that the current standard is almost 2,000 pages long, so maybe it is a good idea not to add several hundred pages detailing the complexities of the order of
    
    
     
      parameter evaluations.
     
    
   </p>
   <p>
    
     The second thing we promised to mention at the beginning of this section, however, comes up: while operator precedence and associativity dictate how expressions are grouped and parsed, they do not dictate the order of evaluation.
    
    
     This means that even though you know how expressions will be grouped, the actual order in which parts of the expression are evaluated can
    
    
     
      still vary.
     
    
   </p>
   <p>
    
     Letâ€™s consider the following
    
    
     
      short application:
     
    
   </p>
   <pre class="source-code">
#include &lt;iostream&gt;
int main() {
Â Â Â Â int i = 4;
Â Â Â Â i = ++i + i++;
Â Â Â Â std::cout &lt;&lt; i &lt;&lt; std::endl;
Â Â Â Â return 0;
}</pre>
   <p>
    
     It is really short â€“ it couldnâ€™t be shorter â€“ and it contains some quite nasty code, especially looking at
    
    <strong class="source-inline">
     
      ++i + i++
     
    </strong>
    
     .
    
    
     That piece of code is so nasty that the compilers cannot really agree in which order to
    
    
     
      execute it.
     
    
   </p>
   <p>
    
     Some of them choose to execute
    
    <strong class="source-inline">
     
      ++i
     
    </strong>
    
     (making
    
    <strong class="source-inline">
     
      i
     
    </strong>
    
     be
    
    <strong class="source-inline">
     
      5
     
    </strong>
    
     and also using it as the left side of the addition) first, and then
    
    <strong class="source-inline">
     
      i++
     
    </strong>
    
     (which will be using the new value of
    
    <strong class="source-inline">
     
      i
     
    </strong>
    
     , which was incremented already, then incrementing it again to reach
    
    <strong class="source-inline">
     
      6
     
    </strong>
    
     , but due to the way post-increment works, the value of
    
    <strong class="source-inline">
     
      5
     
    </strong>
    
     will be used for the right-hand side of the addition), and then assigning this value back to
    
    <strong class="source-inline">
     
      i
     
    </strong>
    
     .
    
    
     So, thatâ€™s 5 + 5 =
    
    
     
      10.
     
    
   </p>
   <p>
    
     However, other compilers
    
    <a id="_idIndexMarker251">
    </a>
    
     decide to execute
    
    <strong class="source-inline">
     
      i++
     
    </strong>
    
     first, thus keeping the value
    
    <strong class="source-inline">
     
      4
     
    </strong>
    
     on the right-hand side of the operation, while also incrementing the value of
    
    <strong class="source-inline">
     
      i
     
    </strong>
    
     to
    
    <strong class="source-inline">
     
      6
     
    </strong>
    
     .
    
    
     Now,
    
    <strong class="source-inline">
     
      ++i
     
    </strong>
    
     is evaluated, which already sees the incremented value of
    
    <strong class="source-inline">
     
      6
     
    </strong>
    
     , decides to use it, and then increments it, thus obtaining
    
    <strong class="source-inline">
     
      7
     
    </strong>
    
     for the left-hand side of the addition.
    
    
     Thus, this will give 7 + 4 =
    
    
     
      11.
     
    
   </p>
   <p>
    
     Now, thinking a bit back, not having the evaluation order specified encourages developers aware of this uncanny feature to write code that does not expect specific evaluation orders.
    
    
     This can lead to more robust and portable code, as developers must avoid unintended dependencies on evaluation order.
    
    
     As such, the correct fix for the preceding situation would be some code along the lines of
    
    
     
      the following:
     
    
   </p>
   <pre class="source-code">
#include &lt;iostream&gt;
int main() {
Â Â int i = 4;
Â Â int preIncrement = ++i; // i is now 5
Â Â int postIncrement = i++; //postIncrement is 5, i is now 6
Â Â i = preIncrement + postIncrement;
Â Â std::cout &lt;&lt; i &lt;&lt; std::endl; // Output will be 10
Â Â return 0;
}</pre>
   <p>
    
     While this might be a rare situation, because the preceding code is a bit artificial, it is an issue, especially still if we are dealing with situations like
    
    
     
      the following:
     
    
   </p>
   <pre class="source-code">
int f() { std::cout &lt;&lt; "f"; return 1; }
int g() { std::cout &lt;&lt; "g"; return 2; }
int result = f() + g();</pre>
   <p>
    
     The value of
    
    <strong class="source-inline">
     
      result
     
    </strong>
    
     will
    
    <a id="_idIndexMarker252">
    </a>
    
     be
    
    <strong class="source-inline">
     
      3
     
    </strong>
    
     regardless, but the output, depending on how the compiler decides to execute the two function calls, can be either
    
    <strong class="source-inline">
     
      "fg"
     
    </strong>
    
     
      or
     
    
    
     <strong class="source-inline">
      
       "gf"
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     With all this in mind, we may think that we understand everything about ordering in C++.
    
    
     While in this chapter we have tried to cover all possible implications, we cannot promise that you will not find anything out of order.
    
    
     C++ is a language with a very wide scope and peculiar syntax, so if someone really wanted to, they could step on the toes of
    
    
     
      some compilers.
     
    
   </p>
   <h1 id="_idParaDest-70">
    <a id="_idTextAnchor069">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     With this chapter, we hope you have grasped the critical importance of following the specified order of everything C++-related to ensure predictable and error-free code execution.
    
    
     You should also understand the importance of not having a specified order
    
    
     
      of execution.
     
    
   </p>
   <p>
    
     With this in mind, we encourage you to go and experiment with the online playground offered by Compiler Explorer.
    
    
     It offers a large collection of compilers.
    
    
     Just bear in mind that if two compilers have generated different results for the code you wrote, then maybe you have ventured into unspecified/undefined
    
    
     
      behavior territory.
     
    
   </p>
   <p>
    
     The next chapter explores the challenges of memory management
    
    
     
      in C++.
     
    
   </p>
  </div>
 </body></html>