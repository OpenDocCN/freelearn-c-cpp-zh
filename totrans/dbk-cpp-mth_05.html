<html><head></head><body>
  <div id="_idContainer029">
   <h1 class="chapter-number" id="_idParaDest-62">
    <a id="_idTextAnchor061">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     5
    </span>
   </h1>
   <h1 id="_idParaDest-63">
    <a id="_idTextAnchor062">
    </a>
    <span class="koboSpan" id="kobo.2.1">
     In a C++ Class, Order Must There Be
    </span>
   </h1>
   <p class="italic-heading">
    <em class="italic">
     <span class="koboSpan" id="kobo.3.1">
      When law and order
     </span>
    </em>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.4.1">
       kill creativity
      </span>
     </em>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.5.1">
     Ordering items is essential across various domains to ensure organization, efficiency, and clarity.
    </span>
    <span class="koboSpan" id="kobo.5.2">
     Whether in libraries or contact lists through alphabetical ordering, customer service queues or data analysis with numerical sorting, timelines or appointments by chronology, task management or emergency response prioritization, inventory or digital file categorization, competition rankings, clothing size arrangement, geographical routing in travel or mail delivery, sequential steps in manufacturing or software development, or hierarchical structuring in organizations and biological taxonomies, ordering helps streamline processes, improve accessibility, and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.6.1">
      enhance decision-making.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.7.1">
     By applying different criteria, such as alphabetical, numerical, chronological, priority, categorical, ranking, size, geographical, sequential, or hierarchical, ordering facilitates better management and optimal functioning in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.8.1">
      diverse contexts.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.9.1">
     In this chapter, we will explore why it is important to have a specific order for members of a C++ class and what we can gain and lose when properly or improperly declaring the members of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.10.1">
      a class.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.11.1">
     Also, we will get a quick overview of what the order of operations is in C++, because that is a topic that to some extent can be quite confusing, even for more
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.12.1">
      advanced programmers.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.13.1">
     With this chapter, you will learn about
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.14.1">
      the following:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.15.1">
      The importance of properly declaring class members in a
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.16.1">
       specific order
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.17.1">
      The importance of initializing your class members in the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.18.1">
       required order
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.19.1">
      The proper order of
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.20.1">
       operation executions
      </span>
     </span>
    </li>
   </ul>
   <h1 id="_idParaDest-64">
    <a id="_idTextAnchor063">
    </a>
    <span class="koboSpan" id="kobo.21.1">
     Size does matter
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.22.1">
     We have learned in school about the alphabet, that puts all letters in a specific order, like A, B, C if you are English, or A, Ä‚, Ã‚ if youâ€™re Romanian (yes, there are a surprisingly large number of variations to the letter A at the beginning of the Romanian alphabet).
    </span>
    <span class="koboSpan" id="kobo.22.2">
     Not everyone alive today is sure about the reasoning of the order, but since todaysâ€™ alphabets are based on older ones, such as Î‘, Î’, Î“ for the Greeks or ğ“€€, ğ“, ğ“£ and even ğ“· for our Ancient Egyptian ancestors, we canâ€™t really be sure why this succession of characters
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.23.1">
      has emerged.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.24.1">
     The alphabet is a very handy thing; it helps us organize and categorize everything that can be named.
    </span>
    <span class="koboSpan" id="kobo.24.2">
     From insects, with ants being categorized before bees, through to the spices in your cupboard (except if you organize yours based on color or, even better, usage frequencyâ€¦ poor dear Zimbabwean mufushwa, youâ€™ll stay in the back for now), it helps us greatly in keeping our daily lives neat
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.25.1">
      and organized.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.26.1">
     Before we venture too off topic, however, letâ€™s remember that this is a book about programming (more specifically, C++ programming), and thus we need to keep focused on our subject, and not get distracted talking about the bees and the birds (bees come before birds alphabetically,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.27.1">
      of course).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.28.1">
     Organizing C++ concepts can, however, be a very daunting topic.
    </span>
    <span class="koboSpan" id="kobo.28.2">
     By
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.29.1">
      concepts
     </span>
    </em>
    <span class="koboSpan" id="kobo.30.1">
     , I mean functions, classes, and variables, and not the very handy feature called concepts introduced in C++20, which sadly is not the topic of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.31.1">
      this book.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.32.1">
     You canâ€™t really do it the way you want, because some functions need to see other functions and some blocks of code need to access variables that you have to make sure were defined before them.
    </span>
    <span class="koboSpan" id="kobo.32.2">
     So, carefully crafting a C++ program can be
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.33.1">
      very difficult.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.34.1">
     Things change, however, when the discussion turns to C++ classes.
    </span>
    <span class="koboSpan" id="kobo.34.2">
     You see, in a class, these visibility-related annoyances do not really matter.
    </span>
    <span class="koboSpan" id="kobo.34.3">
     All the methods of a class see all the other methods of that class, and all member functions can be directly accessed in all the member functions, so life in a class
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.35.1">
      is easyâ€¦
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.36.1">
     Now, dear C++ disciple, I hear you cry, â€œBut you should never call the destructor or the constructor of a class from within the class!â€
    </span>
    <span class="koboSpan" id="kobo.36.2">
     I mostly agree, but thereâ€™s nothing stopping me from writing a method such as
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.37.1">
      the following:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.38.1">
struct a_class {
Â Â Â void reboot() {
Â Â Â Â Â Â this-&gt;~a_class();
Â Â Â Â Â Â new (reinterpret_cast&lt;void*&gt;(this)) a_class();
Â Â Â Â }
};</span></pre>
   <p>
    <span class="koboSpan" id="kobo.39.1">
     However, if you write code like this, dear reader, you will suffer the consequences.
    </span>
    <span class="koboSpan" id="kobo.39.2">
     But back to our initial
    </span>
    <a id="_idIndexMarker221">
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.40.1">
      topic: ordering.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.41.1">
     Inherently, the human mind craves order.
    </span>
    <span class="koboSpan" id="kobo.41.2">
     We need to be able to have an overview of what we are working with, where that information is, and how to locate it as easily as possible.
    </span>
    <span class="koboSpan" id="kobo.41.3">
     It is imperative to easily and quickly find the required information, even if it is as insignificant as the
    </span>
    <a id="_idIndexMarker222">
    </a>
    <span class="koboSpan" id="kobo.42.1">
     whereabouts of a member of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.43.1">
      a class.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.44.1">
     So, after endless struggles with locating lost members of a class, it came as a revelation to one game programmer (letâ€™s call him Joe) who was happily working at the BigGameDev company that all the members of the class should be organized in alphabetical order.
    </span>
    <span class="koboSpan" id="kobo.44.2">
     Brilliant, now everyone can easily locate where their required member is.
    </span>
    <span class="koboSpan" id="kobo.44.3">
     And look how beautiful the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.45.1">
      code is:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.46.1">
struct point {
Â Â Â bool active;
Â Â Â double x;
Â Â Â double y;
Â Â Â double z;
};</span></pre>
   <p>
    <span class="koboSpan" id="kobo.47.1">
     This is not a particularly complicated use case; it is just a point in some game that tells us where a point is, by providing
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.48.1">
      x
     </span>
    </em>
    <span class="koboSpan" id="kobo.49.1">
     ,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.50.1">
      y
     </span>
    </em>
    <span class="koboSpan" id="kobo.51.1">
     , and
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.52.1">
      z
     </span>
    </em>
    <span class="koboSpan" id="kobo.53.1">
     coordinates, and it gives a small insight into the workings of the point, to tell us whether that specific point is active or not.
    </span>
    <span class="koboSpan" id="kobo.53.2">
     Life is good.
    </span>
    <span class="koboSpan" id="kobo.53.3">
     The game runs neatly, and the players
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.54.1">
      are happy.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.55.1">
     However, at some point, the lead programmer of the game project thinks that some operations on that point take up too much time (Iâ€™ll spare you all the quirky details of what operations those are and why they need it) and those operations should be performed only if the point has recorded a change of values in all three coordinates.
    </span>
    <span class="koboSpan" id="kobo.55.2">
     Joe, our programmer, is a good and very methodic programmer, and he knows that one solution would be to store three other
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.56.1">
      double
     </span>
    </strong>
    <span class="koboSpan" id="kobo.57.1">
     values, representing the previous
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.58.1">
      x
     </span>
    </em>
    <span class="koboSpan" id="kobo.59.1">
     ,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.60.1">
      y
     </span>
    </em>
    <span class="koboSpan" id="kobo.61.1">
     , and
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.62.1">
      z
     </span>
    </em>
    <span class="koboSpan" id="kobo.63.1">
     coordinates, update those on change, if any, and perform the requested operation only if the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.64.1">
      values differ.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.65.1">
     However, he discards that idea and quickly concocts a different one: he will keep a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.66.1">
      bool
     </span>
    </strong>
    <span class="koboSpan" id="kobo.67.1">
     flag for recording the change of each required coordinate, since he knows that a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.68.1">
      bool
     </span>
    </strong>
    <span class="koboSpan" id="kobo.69.1">
     usually takes up only 1 byte, while a double on their platform boasts up to 8 bytes.
    </span>
    <span class="koboSpan" id="kobo.69.2">
     That is a saving ofâ€¦ well, 21 bytes.
    </span>
    <span class="koboSpan" id="kobo.69.3">
     So, here is Joeâ€™s
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.70.1">
      new class:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.71.1">
class point {
Â Â Â bool active;
Â Â Â double x;
Â Â Â bool x_changed;
Â Â Â double y;
Â Â Â bool y_changed;
Â Â Â double z;
Â Â Â bool z_changed;
};</span></pre>
   <p>
    <span class="koboSpan" id="kobo.72.1">
     Beautiful â€“ as with all the code he writes, itâ€™s almost like poetry.
    </span>
    <span class="koboSpan" id="kobo.72.2">
     He submits the newly written piece of code to the repository, where it will be built overnight, and the freshly baked binary will be delivered for testing the next day.
    </span>
    <span class="koboSpan" id="kobo.72.3">
     And then he does not go on vacation, because he is a diligent programmer; summer is still some time away, so he will wait for the testing team to approve the code before booking
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.73.1">
      plane tickets.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.74.1">
     Overnight, the automated tests explode, every suite fails, and the entire dashboard is red like the flag of some communist country.
    </span>
    <span class="koboSpan" id="kobo.74.2">
     The next day, the entire testing department faces fatal failures, the game crashes, and 99.9% of the errors at some point relate to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.75.1">
      out-of-memory issues.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.76.1">
     The application suddenly consumes almost double the memory it was expected to consume, the test machines struggle to keep the desired frame rate, and everything is slowed down, except the memory allocation checks, which steadily show that the application now uses a lot more
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.77.1">
      than yesterday.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.78.1">
     There were not too many changes, besides Joeâ€™s own point class overhaul; some other developer had changed the background color in the main menu from dark gray to black (sadly, the developer who was supposed to implement the ground-breaking change that requested Joeâ€™s change had to stay at home with a sick child that day), so the development team gathers to discuss the newly
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.79.1">
      found issue.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.80.1">
     The lead developer (letâ€™s call him Jimmy for his mastery in the programming languages) takes a look at the code and quickly proclaims, â€œJoe, mate, I really appreciate the neatness of your code, and that you organize the members alphabetically, but I will have to kindly ask you to change the order
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.81.1">
      of them.â€
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.82.1">
     Joe turns almost as red as the test failure indicators on the continuous integration monitoring screen, but since he is a reasonable person, he kindly asks why on Earth he should do that.
    </span>
    <span class="koboSpan" id="kobo.82.2">
     Doesnâ€™t Jimmy see the beauty in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.83.1">
      the code?!
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.84.1">
     The response from Jimmy stuns him.
    </span>
    <span class="koboSpan" id="kobo.84.2">
     This is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.85.1">
      Jimmyâ€™s explanation.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.86.1">
     The memory layout
    </span>
    <a id="_idIndexMarker223">
    </a>
    <span class="koboSpan" id="kobo.87.1">
     of a C++ class is determined by several factors, including the size and alignment requirements of its members, the inheritance hierarchy, and padding added by the compiler to satisfy alignment constraints.
    </span>
    <span class="koboSpan" id="kobo.87.2">
     When talking about size, each data member occupies a certain number of bytes based on
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.88.1">
      its type.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.89.1">
     Iâ€™m sure Joe was aware of this; however, what he might not have grasped entirely, looking at his solution, is the alignment of each member.
    </span>
    <span class="koboSpan" id="kobo.89.2">
     Each data member must be stored at a memory address that is a multiple of its alignment requirement.
    </span>
    <span class="koboSpan" id="kobo.89.3">
     The alignment requirement is typically the size of the type, but it can be adjusted with
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.90.1">
      compiler-specific directives.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.91.1">
     Now, looking at padding, in order to
    </span>
    <a id="_idIndexMarker224">
    </a>
    <span class="koboSpan" id="kobo.92.1">
     satisfy these alignment constraints, the compiler may insert padding bytes between members, and to ensure the size of the class is a multiple of the largest alignment requirement, padding may be added at the end of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.93.1">
      the class.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.94.1">
     Now, the class that the
    </span>
    <a id="_idIndexMarker225">
    </a>
    <span class="koboSpan" id="kobo.95.1">
     team had initially might have looked like the following when it was set up in memory, knowing that on their architecture, the size of a double is 8
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.96.1">
      bytes long:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer025">
     <span class="koboSpan" id="kobo.97.1">
      <img alt="Figure 5.1 â€“ The initial class layout" src="image/B22235_05_1.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.98.1">
     Figure 5.1 â€“ The initial class layout
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.99.1">
     Using this alignment, the size of the class added up being 32 bytes.
    </span>
    <span class="koboSpan" id="kobo.99.2">
     But now that Joe has have added three more
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.100.1">
      bool
     </span>
    </strong>
    <span class="koboSpan" id="kobo.101.1">
     s, each 1 byte long, the compiler might have organized the memory according to the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.102.1">
      following layout:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer026">
     <span class="koboSpan" id="kobo.103.1">
      <img alt="Figure 5.2 â€“ The class layout with the new members in the wrong order" src="image/B22235_05_2.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.104.1">
     Figure 5.2 â€“ The class layout with the new members in the wrong order
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.105.1">
     So, each byte of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.106.1">
      bool
     </span>
    </strong>
    <span class="koboSpan" id="kobo.107.1">
     must
    </span>
    <a id="_idIndexMarker226">
    </a>
    <span class="koboSpan" id="kobo.108.1">
     have been padded up to 8 bytes, in order to allow the placement of the double that follows to the proper memory address.
    </span>
    <span class="koboSpan" id="kobo.108.2">
     This made the size of the class grow to 56, because 4
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.109.1">
      bool
     </span>
    </strong>
    <span class="koboSpan" id="kobo.110.1">
     s padded up to 8 bytes plus 3
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.111.1">
      double
     </span>
    </strong>
    <span class="koboSpan" id="kobo.112.1">
     values, each of them 8 bytes, so the sum of these takes up a total of 56 bytes.
    </span>
    <span class="koboSpan" id="kobo.112.2">
     Clang, the compiler, has a switch that allows us to inspect the memory layout of generated classes:
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.113.1">
      -fdump-record-layouts
     </span>
    </strong>
    <span class="koboSpan" id="kobo.114.1">
     .
    </span>
    <span class="koboSpan" id="kobo.114.2">
     In order to put it into good use for this case, we have created a simple source file with the previous class definition and passed it down to the compiler in order to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.115.1">
      inspect it:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.116.1">
&gt; $ clang -cc1 -fdump-record-layouts main.cpp
*** Dumping AST Record Layout
Â Â Â Â Â Â Â Â Â 0 | struct Point
Â Â Â Â Â Â Â Â Â 0 |Â Â Â _Bool active
Â Â Â Â Â Â Â Â Â 8 |Â Â Â double x
Â Â Â Â Â Â Â Â 16 |Â Â Â _Bool x_changed
Â Â Â Â Â Â Â Â 24 |Â Â Â double y
Â Â Â Â Â Â Â Â 32 |Â Â Â _Bool y_changed
Â Â Â Â Â Â Â Â 40 |Â Â Â double z
Â Â Â Â Â Â Â Â 48 |Â Â Â _Bool z_changed
Â Â Â Â Â Â Â Â Â Â Â | [sizeof=56, dsize=56, align=8,
Â Â Â Â Â Â Â Â Â Â Â |Â Â nvsize=56, nvalign=8]</span></pre>
   <p>
    <span class="koboSpan" id="kobo.117.1">
     The preceding data clearly denotes what we suspected initially, that is, that the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.118.1">
      bool
     </span>
    </strong>
    <span class="koboSpan" id="kobo.119.1">
     that was supposed to take 1 byte now officially occupies 8 (note that behind the scenes, we have created a file called
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.120.1">
      main.cpp
     </span>
    </strong>
    <span class="koboSpan" id="kobo.121.1">
     with the content of the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.122.1">
       point
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.123.1">
      structure).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.124.1">
     Now, in order to straighten out this unfortunate situation, we clearly need to take some further actions, so letâ€™s consider the reorganization of the members
    </span>
    <a id="_idIndexMarker227">
    </a>
    <span class="koboSpan" id="kobo.125.1">
     of the class in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.126.1">
      following manner:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.127.1">
class point {
Â Â Â bool active;
Â Â Â bool x_changed;
Â Â Â bool y_changed;
Â Â Â bool z_changed;
Â Â Â double y;
Â Â Â double x;
Â Â Â double z;
};</span></pre>
   <p>
    <span class="koboSpan" id="kobo.128.1">
     It is not a huge change, besides hurting Joeâ€™s feelings that the members are not organized alphabetically.
    </span>
    <span class="koboSpan" id="kobo.128.2">
     We have grouped together the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.129.1">
      bool
     </span>
    </strong>
    <span class="koboSpan" id="kobo.130.1">
     values so the class is as compact
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.131.1">
      as possible.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.132.1">
     We have used the preceding information, especially taking into consideration the size requirements of each of the types, and concluded that it is always better to have small types grouped together (by
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.133.1">
      small types
     </span>
    </em>
    <span class="koboSpan" id="kobo.134.1">
     , we mean variables whose type will take up the smallest number of bytes; for example, we know that the size of a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.135.1">
      bool
     </span>
    </strong>
    <span class="koboSpan" id="kobo.136.1">
     variable is 1, at least for the implementation we
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.137.1">
      are using).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.138.1">
     By doing this, that is, by reorganizing the order in which the members are presented, we have created the following memory layout (or something similar but more optimal for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.139.1">
      our architecture):
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer027">
     <span class="koboSpan" id="kobo.140.1">
      <img alt="Figure 5.3 â€“ The class layout with the members in the proper order" src="image/B22235_05_3.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.141.1">
     Figure 5.3 â€“ The class layout with the members in the proper order
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.142.1">
     Indeed, after checking with
    </span>
    <a id="_idIndexMarker228">
    </a>
    <span class="koboSpan" id="kobo.143.1">
     Clang again, the memory of the class looks very different from the previous version (please again ignore the fact that behind the scenes, we have modified our
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.144.1">
      main.cpp
     </span>
    </strong>
    <span class="koboSpan" id="kobo.145.1">
     to contain the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.146.1">
      preceding structure):
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.147.1">
&gt; $ clang -cc1 -fdump-record-layouts main.cpp
*** Dumping AST Record Layout
Â Â Â Â Â Â Â Â Â 0 | struct Point
Â Â Â Â Â Â Â Â Â 0 |Â Â Â _Bool active
Â Â Â Â Â Â Â Â Â 1 |Â Â Â _Bool x_changed
Â Â Â Â Â Â Â Â Â 2 |Â Â Â _Bool y_changed
Â Â Â Â Â Â Â Â Â 3 |Â Â Â _Bool z_changed
Â Â Â Â Â Â Â Â Â 8 |Â Â Â double x
Â Â Â Â Â Â Â Â 16 |Â Â Â double y
Â Â Â Â Â Â Â Â 24 |Â Â Â double z
Â Â Â Â Â Â Â Â Â Â Â | [sizeof=32, dsize=32, align=8,
Â Â Â Â Â Â Â Â Â Â Â |Â Â nvsize=32, nvalign=8]</span></pre>
   <p>
    <span class="koboSpan" id="kobo.148.1">
     So, as we can see now, the four
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.149.1">
      bool
     </span>
    </strong>
    <span class="koboSpan" id="kobo.150.1">
     values are placed in memory one after the other, and there is only one section of padding required to fill up the required space, for the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.151.1">
      double
     </span>
    </strong>
    <span class="koboSpan" id="kobo.152.1">
     values to be aligned on the required memory addresses.
    </span>
    <span class="koboSpan" id="kobo.152.2">
     Hypothetically, if we were to have a field with a size of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.153.1">
      4
     </span>
    </strong>
    <span class="koboSpan" id="kobo.154.1">
     , we could nicely fit it after the last
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.155.1">
      bool
     </span>
    </strong>
    <span class="koboSpan" id="kobo.156.1">
     , before the first
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.157.1">
      double
     </span>
    </strong>
    <span class="koboSpan" id="kobo.158.1">
     , and we would not need any
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.159.1">
      padding either.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.160.1">
     Upon hearing Jimmyâ€™s explanation, Joe now understood the issue.
    </span>
    <span class="koboSpan" id="kobo.160.2">
     He had never encountered alignment issues before, but he decided to read up on the subject.
    </span>
    <span class="koboSpan" id="kobo.160.3">
     What he read was
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.161.1">
      very interesting.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.162.1">
     It explained that the alignment of variables in memory is necessary due to a combination of hardware requirements, performance optimization, and architectural constraints.
    </span>
    <span class="koboSpan" id="kobo.162.2">
     Most modern processors are designed to access memory more efficiently when data is aligned to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.163.1">
      certain boundaries.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.164.1">
     For example, an 8-byte double is typically best accessed at an address that is a multiple of 8, and when data is misaligned, the processor may need to perform multiple memory accesses to read or write the data, which can be
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.165.1">
      significantly slower.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.166.1">
     Some architectures, such as the older generation of ARM processors, PowerPC, and older MIPS processors, cannot properly handle misaligned access, and in these situations, they generate a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.167.1">
      SIGBUS
     </span>
    </strong>
    <span class="koboSpan" id="kobo.168.1">
     fault, which
    </span>
    <a id="_idIndexMarker229">
    </a>
    <span class="koboSpan" id="kobo.169.1">
     results in the early termination of the application causing the fault.
    </span>
    <span class="koboSpan" id="kobo.169.2">
     So, for example, the following application, when compiled, and the resulting binary executed on a processor of this generation will generate a
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.170.1">
       SIGBUS
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.171.1">
      fault:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.172.1">
#include &lt;cstdlib&gt;
int main(int argc, char **argv) {
Â Â Â Â char *cptr = (char*)malloc(sizeof(int) + 1);
Â Â Â Â int* iptr = (int *) ++cptr;
Â Â Â Â *iptr = 42;
Â Â Â Â return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.173.1">
     The outcome of this highly unpleasant situation on an operating system not prepared to handle a misalignment error very often has quite drastic ramifications, such as an application crash.
    </span>
    <span class="koboSpan" id="kobo.173.2">
     Older systems may even produce a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.174.1">
      system crash.
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer028">
     <span class="koboSpan" id="kobo.175.1">
      <img alt="Figure 5.4 â€“ Older system throwing a tantrum when seeing unaligned data" src="image/B22235_05_4.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.176.1">
     Figure 5.4 â€“ Older system throwing a tantrum when seeing unaligned data
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.177.1">
     You might ask what
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.178.1">
      error type 7
     </span>
    </strong>
    <span class="koboSpan" id="kobo.179.1">
     means.
    </span>
    <span class="koboSpan" id="kobo.179.2">
     The answer is simple: 7 is the magic number that was assigned to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.180.1">
      SIGBUS
     </span>
    </strong>
    <span class="koboSpan" id="kobo.181.1">
     error.
    </span>
    <span class="koboSpan" id="kobo.181.2">
     On the authorâ€™s Linux machine, it can be found in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.182.1">
      /usr/include/x86_64-linux-gnu/bits/signum-arch.h
     </span>
    </strong>
    <span class="koboSpan" id="kobo.183.1">
     , on
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.184.1">
      line 34:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.185.1">
/* Historical signals specified by POSIX. </span><span class="koboSpan" id="kobo.185.2">*/
#define SIGBUSÂ Â Â Â Â Â Â Â 7Â Â Â Â /* Bus error.Â Â */</span></pre>
   <p>
    <span class="koboSpan" id="kobo.186.1">
     Some other processors, such as the newer generation x86_64 processors, or even the older 80286 (and everything between, mostly adhering to the specifications of the x86 platform and beyond), handle these situations very gracefully, with a tiny time penalty concerning performance, but they can be easily convinced with the following assembly instructions to turn into a very moody persona
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.187.1">
      of themselves:
     </span>
    </span>
   </p>
   <table class="No-Table-Style _idGenTablePara-1" id="table001-2">
    <colgroup>
     <col/>
     <col/>
    </colgroup>
    <thead>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <strong class="bold">
         <span class="koboSpan" id="kobo.188.1">
          AT&amp;T (
         </span>
        </strong>
        <span class="No-Break">
         <strong class="bold">
          <span class="koboSpan" id="kobo.189.1">
           64 bit)
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <strong class="bold">
         <span class="koboSpan" id="kobo.190.1">
          Intel (
         </span>
        </strong>
        <span class="No-Break">
         <strong class="bold">
          <span class="koboSpan" id="kobo.191.1">
           32 bit)
          </span>
         </strong>
        </span>
       </p>
      </td>
     </tr>
    </thead>
    <tbody>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.192.1">
           pushf
          </span>
         </strong>
        </span>
       </p>
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.193.1">
           orl $0x40000,(%rsp)
          </span>
         </strong>
        </span>
       </p>
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.194.1">
           popf
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.195.1">
           pushfd
          </span>
         </strong>
        </span>
       </p>
       <p>
        <strong class="source-inline">
         <span class="koboSpan" id="kobo.196.1">
          or dword ptr [
         </span>
        </strong>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.197.1">
           esp], 40000h
          </span>
         </strong>
        </span>
       </p>
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.198.1">
           popfd
          </span>
         </strong>
        </span>
       </p>
      </td>
     </tr>
    </tbody>
   </table>
   <p>
    <span class="koboSpan" id="kobo.199.1">
     The code above modifies specific bits in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.200.1">
      EFLAGS
     </span>
    </strong>
    <span class="koboSpan" id="kobo.201.1">
     register using a bitwise OR operation.
    </span>
    <span class="koboSpan" id="kobo.201.2">
     Specifically, the hexadecimal value
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.202.1">
      40000h
     </span>
    </strong>
    <span class="koboSpan" id="kobo.203.1">
     corresponds to setting the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.204.1">
      AC
     </span>
    </strong>
    <span class="koboSpan" id="kobo.205.1">
     (which stands for alignment check) flag in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.206.1">
      EFLAGS
     </span>
    </strong>
    <span class="koboSpan" id="kobo.207.1">
     register, this flag is used to control alignment checking.
    </span>
    <span class="koboSpan" id="kobo.207.2">
     When this flag is set and the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.208.1">
      AM
     </span>
    </strong>
    <span class="koboSpan" id="kobo.209.1">
     (which stands for alignment mask) bit in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.210.1">
      CR0
     </span>
    </strong>
    <span class="koboSpan" id="kobo.211.1">
     register is also set, the processor checks whether data is aligned on natural boundaries.
    </span>
    <span class="koboSpan" id="kobo.211.2">
     If data misalignment is detected, a fault
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.212.1">
      is generated.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.213.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.214.1">
      EFLAGS
     </span>
    </strong>
    <span class="koboSpan" id="kobo.215.1">
     register
    </span>
    <a id="_idIndexMarker230">
    </a>
    <span class="koboSpan" id="kobo.216.1">
     is a special-purpose register used in x86 architecture CPUs that contains several flags reflecting the state of the processor.
    </span>
    <span class="koboSpan" id="kobo.216.2">
     These flags can control or indicate various conditions, such as arithmetic conditions, control features, and system settings.
    </span>
    <span class="koboSpan" id="kobo.216.3">
     The Intel developer center
    </span>
    <span class="superscript">
     <span id="footnote-018-backlink">
      <a class="_idFootnoteLink _idGenColorInherit" href="B22235_05.xhtml#footnote-018">
       <span class="koboSpan" id="kobo.217.1">
        1
       </span>
      </a>
     </span>
    </span>
    <span class="koboSpan" id="kobo.218.1">
     contains a plethora of information concerning these low-level programming features.
    </span>
    <span class="koboSpan" id="kobo.218.2">
     We encourage anyone interested in this subject to go and browse that site for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.219.1">
      further information.
     </span>
    </span>
   </p>
   <div class="_idFootnote" epub:type="footnote" id="footnote-018">
    <p class="Footnote-text">
     <a class="_idFootnoteAnchor _idGenColorInherit" href="B22235_05.xhtml#footnote-018-backlink">
      <span class="koboSpan" id="kobo.220.1">
       1
      </span>
     </a>
     <a href="https://www.intel.com/content/www/us/en/resources-documentation/developer.html">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.221.1">
        https://www.intel.com/content/www/us/en/resources-documentation/developer.html
       </span>
      </span>
     </a>
    </p>
   </div>
   <p>
    <span class="koboSpan" id="kobo.222.1">
     When the previous code is inserted into the source code of an application, we can see the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.223.1">
      SIGBUS
     </span>
    </strong>
    <span class="koboSpan" id="kobo.224.1">
     signal in action.
    </span>
    <span class="koboSpan" id="kobo.224.2">
     Weâ€™ll spare listing that code here, because no one should write code that intentionally crashes their application, but instead letâ€™s examine another one of our friend Joeâ€™s encounters with the curiously occurring ordering of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.225.1">
      class members.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-65">
    <a id="_idTextAnchor064">
    </a>
    <span class="koboSpan" id="kobo.226.1">
     The order that must be respected
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.227.1">
     While working at
    </span>
    <a id="_idIndexMarker231">
    </a>
    <span class="koboSpan" id="kobo.228.1">
     BigGameDev, Joe was given another task that was vaguely related to character development â€“ in-game characters, that is, not his own character.
    </span>
    <span class="koboSpan" id="kobo.228.2">
     The task was an easy one: it just required returning a formatted string that expressed the value of life points a character has.
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.229.1">
     In order to implement this, Joe created the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.230.1">
      following class:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.231.1">
#include &lt;string&gt;
#include &lt;format&gt;
#include &lt;iostream&gt;
#include &lt;string_view&gt;
struct life_point_tracker {
Â Â life_point_tracker(std::string_view player, int points) {
Â Â Â Â Â Â Â m_player = player;
Â Â Â Â Â Â Â m_points = points;
Â Â Â Â Â Â Â m_result = std::format("{} has {} LPs",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â m_player, m_points);
Â Â Â }
Â Â Â std::string get_data() const {
Â Â Â Â Â Â Â return m_result;
Â Â Â }
private:
Â Â Â std::string m_result {""};
Â Â Â std::string m_player {""};
Â Â Â int m_pointsÂ Â Â Â Â Â Â Â Â {0};
 };
int main() {
Â Â Â life_point_tracker lpt("Joe", 120);
Â Â Â std::cout &lt;&lt; lpt.get_data();
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.232.1">
     This is as
    </span>
    <a id="_idIndexMarker232">
    </a>
    <span class="koboSpan" id="kobo.233.1">
     straightforward as it can be.
    </span>
    <span class="koboSpan" id="kobo.233.2">
     It just takes the input data and stores the result in case one needs to access it again.
    </span>
    <span class="koboSpan" id="kobo.233.3">
     Joe is very happy; the class members are organized nicely by type, but he is not sticking to alphabetical order anymore (he learned his lesson from the alignment discussion).
    </span>
    <span class="koboSpan" id="kobo.233.4">
     He even uses modern C++, such as the format library or in-class initialization of members, in case some are not initialized (we could argue, though, that the strings are initialized to an empty string upon creation with the default constructor, so for them, this is not as relevant.
    </span>
    <span class="koboSpan" id="kobo.233.5">
     This isnâ€™t the case for the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.234.1">
      int
     </span>
    </strong>
    <span class="koboSpan" id="kobo.235.1">
     s), and he is generally happy with the code he
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.236.1">
      has written.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.237.1">
     He would happily commit these into their repository right away, but common sense prevails.
    </span>
    <span class="koboSpan" id="kobo.237.2">
     He does some quick tests, and after ensuring that everything works as expected, he asks his supervisor (the same Jimmy to whom we were introduced in the previous section) to do a quick review of the code.
    </span>
    <span class="koboSpan" id="kobo.237.3">
     The code looks OK; it compiles and performs the required operations, and there are just two tiny observations that are to be added.
    </span>
    <span class="koboSpan" id="kobo.237.4">
     Joe is given the following feedback: instead of doing the assignment of the members in the body of the constructor, an initializer list should be used instead.
    </span>
    <span class="koboSpan" id="kobo.237.5">
     In addition, since he is going to use initializer lists anyway, he should make the members const, for some minor optimizations that the compiler might decide to throw in at some stage.
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.238.1">
     So, he should have
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.239.1">
      the following:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.240.1">
const std::string m_result {""};
const std::string m_player {""};
const int m_pointsÂ Â Â Â Â Â Â Â Â {0};</span></pre>
   <p>
    <span class="koboSpan" id="kobo.241.1">
     In C++, using an initialization list in constructors is generally preferred over in-body initialization due to several key advantages: it is more efficient since it initializes member variables directly rather than initializing them by default and then assigning them.
    </span>
    <span class="koboSpan" id="kobo.241.2">
     Also, it ensures proper initialization of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.242.1">
      const
     </span>
    </strong>
    <span class="koboSpan" id="kobo.243.1">
     and reference members, which cannot be dealt with properly in the body of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.244.1">
      the constructor.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.245.1">
     Joe happily changes the code, and since not that much has changed, he â€œforgetsâ€ to test it.
    </span>
    <span class="koboSpan" id="kobo.245.2">
     Instead, he quickly submits the following sequence
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.246.1">
      to review:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.247.1">
life_point_tracker(std::string_view player, int points)
: m_player(player), m_points(points),
Â Â m_result(std::format("{} has {} LPs", m_player, m_points)) {}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.248.1">
     A response does not take too long to arrive and is surprisingly not the pat on the back
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.249.1">
      he expected.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.250.1">
     â€œJoe, did you test
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.251.1">
      this code?â€
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.252.1">
     He has to admit that he did not consider it necessary, since not that much had changed.
    </span>
    <span class="koboSpan" id="kobo.252.2">
     He just moved a few lines a bit above their previous positions, changed an equal sign to a pair of parentheses, and he was done
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.253.1">
      with it.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.254.1">
     â€œOh, I seeâ€¦â€ said Jimmy, and he pulled out a fresh hardcopy of the latest available C++ standard from his
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.255.1">
      back pocket.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.256.1">
     The
    </span>
    <a id="_idIndexMarker233">
    </a>
    <span class="koboSpan" id="kobo.257.1">
     standard says the following, in the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.258.1">
      [
     </span>
    </strong>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.259.1">
       class.base.init]
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.260.1">
      section:
     </span>
    </span>
   </p>
   <p class="author-quote">
    <span class="koboSpan" id="kobo.261.1">
     In a non-delegating constructor, initialization proceeds in the following order:
    </span>
   </p>
   <p class="author-quote">
    <span class="koboSpan" id="kobo.262.1">
     First, and only for the constructor of the most derived class, virtual base classes are initialized in the order they appear on a depth-first left-to-right traversal of the directed acyclic graph of base classes, where â€œleft-to-rightâ€ is the order of appearance of the base classes in the derived class base-specifier-list.
    </span>
   </p>
   <p class="author-quote">
    <span class="koboSpan" id="kobo.263.1">
     Then, direct base classes are initialized in declaration order as they appear in the base-specifier-list (regardless of the order of the mem-initializers).
    </span>
   </p>
   <p class="author-quote">
    <span class="koboSpan" id="kobo.264.1">
     Then, non-static data members are initialized in the order they were declared in the class definition (again regardless of the order of the mem-initializers).
    </span>
   </p>
   <p class="author-quote">
    <span class="koboSpan" id="kobo.265.1">
     Finally, the compound-statement of the constructor body is executed.
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.266.1">
     This in practice means that regardless of the order in which you specified the members to be initialized in the initializer list, they still will be initialized in the order they were declared in the class, so
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.267.1">
      m_result
     </span>
    </strong>
    <span class="koboSpan" id="kobo.268.1">
     will be the first one to be initialized, and since it is using the other two data members, which have not been initialized yet, the result in the best case will be undefined behavior.
    </span>
    <span class="koboSpan" id="kobo.268.2">
     In the worst case, during testing, you will get default values, and in production, the code will
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.269.1">
      fail spectacularly.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.270.1">
     Now, armed
    </span>
    <a id="_idIndexMarker234">
    </a>
    <span class="koboSpan" id="kobo.271.1">
     with this knowledge, Joe was finally able to deliver the code that was expected of him, on time and to the highest possible standard he
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.272.1">
      could implement:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.273.1">
life_point_tracker(std::string_view player, int points)
try :
Â Â Â Â m_result(std::format("{} has {} LPs", player, points)),
Â Â Â Â m_player(player),
Â Â Â Â m_points(points)
{
}
catch(...) {throw;}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.274.1">
     He learned that while using initializer lists can be a godsend in certain situations, it can also throw your code to the mythical depths of the seven circles of compiler hell when not taking into consideration some basic rules that are set by the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.275.1">
      C++ standard.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.276.1">
     The C++ standard makes it mandatory that member objects are initialized in the order they are declared within the class, regardless of the order specified in the constructor initializer list, because what happens if there is no initializer list, or if only some elements are initialized
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.277.1">
      in it?
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.278.1">
     This order ensures consistency and predictability in the setup process of an object.
    </span>
    <span class="koboSpan" id="kobo.278.2">
     When an object is constructed, initializing members in declaration order helps avoid potential issues that could arise if members were initialized out of order, especially if some members depend on others being
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.279.1">
      initialized first.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.280.1">
     This mandated order of initialization directly influences the destruction order, which is the reverse of initialization.
    </span>
    <span class="koboSpan" id="kobo.280.2">
     Ensuring that members are destroyed in the reverse order of their initialization guarantees that dependent members are still valid when they are needed during the destruction phase.
    </span>
    <span class="koboSpan" id="kobo.280.3">
     This consistent and predictable cleanup process prevents potential errors and maintains the integrity of the objectâ€™s
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.281.1">
      life cycle.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.282.1">
     Building on this requirement of the language, we can easily provide an elegant and more concise solution to this
    </span>
    <a id="_idIndexMarker235">
    </a>
    <span class="koboSpan" id="kobo.283.1">
     problem, by using an interesting feature
    </span>
    <a id="_idIndexMarker236">
    </a>
    <span class="koboSpan" id="kobo.284.1">
     called
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.285.1">
      designated initializers
     </span>
    </strong>
    <span class="koboSpan" id="kobo.286.1">
     , which was introduced in C++20.
    </span>
    <span class="koboSpan" id="kobo.286.2">
     Letâ€™s simplify our structure to look along the lines of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.287.1">
      the following:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.288.1">
struct life_point_tracker {
Â Â Â std::string get_data() const {
Â Â Â Â Â Â Â return m_result;
Â Â Â }
Â Â Â std::string m_player {"Nameless"};
Â Â Â int m_points {0};
Â Â Â const std::string m_result
Â Â Â Â Â Â Â {std::format("{} has {} LPs", m_player, m_points)};
};</span></pre>
   <p>
    <span class="koboSpan" id="kobo.289.1">
     These simple structures satisfy the requirements to be used as aggregates, which are required for the designated initializer feature to compile, and as you can see, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.290.1">
      m_result
     </span>
    </strong>
    <span class="koboSpan" id="kobo.291.1">
     member is using the already-initialized
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.292.1">
      m_player
     </span>
    </strong>
    <span class="koboSpan" id="kobo.293.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.294.1">
      m_points
     </span>
    </strong>
    <span class="koboSpan" id="kobo.295.1">
     members, during the construction of itself.
    </span>
    <span class="koboSpan" id="kobo.295.2">
     Now, in the place where want to use the class, we just have to do
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.296.1">
      the following:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.297.1">
int main(int argc, char **argv) {
Â Â Â life_point_tracker lpt {
Â Â Â Â Â Â Â .m_player = "Joe",
Â Â Â Â Â Â Â .m_points = 120
Â Â Â };
Â Â Â std::cout &lt;&lt; lpt.get_data();
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.298.1">
     By adhering to this handy feature, we have explicitly specified which member should be initialized to which value (this can be very helpful if, for example, there are more than two integers that need to be initialized).
    </span>
    <span class="koboSpan" id="kobo.298.2">
     Also, the feature requires the members to be specified in the order of their declaration, thus increasing the readability and maintainability of the code.
    </span>
    <span class="koboSpan" id="kobo.298.3">
     The only drawback is that we had to dumb down our class to an
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.299.1">
      aggregate
     </span>
    </strong>
    <span class="koboSpan" id="kobo.300.1">
     , so no virtual
    </span>
    <a id="_idIndexMarker237">
    </a>
    <span class="koboSpan" id="kobo.301.1">
     functions, no constructors, no encapsulation â€“ none of the good stuff that raises a C++ class to mythical fame.
    </span>
    <span class="koboSpan" id="kobo.301.2">
     But if itâ€™s good enough for Joe, we can live
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.302.1">
      with it.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-66">
    <a id="_idTextAnchor065">
    </a>
    <span class="koboSpan" id="kobo.303.1">
     Deep thoughts about order
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.304.1">
     The adventures of our
    </span>
    <a id="_idIndexMarker238">
    </a>
    <span class="koboSpan" id="kobo.305.1">
     friend Joe do not end here, because shortly after learning that the proper order of class members is not necessarily an alphabetical one, he was given a task that involved executing some code in a parallel manner.
    </span>
    <span class="koboSpan" id="kobo.305.2">
     Since he learned everything about threads and associated features by watching a quick introductory tutorial to the subject by some guy on TikTok, he felt he was up to the task, and shortly, the following code was committed to the repository (please bear with the authors in this case; due to some pathological manifestations of copyright and intellectual property litigations, we cannot show the original code that took the entire development team two weeks to debug and fix.
    </span>
    <span class="koboSpan" id="kobo.305.3">
     The example code is actually just trying to recreate the scenario that Joe so
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.306.1">
      successfully implemented):
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.307.1">
#include &lt;cstdio&gt;
#include &lt;thread&gt;
#include &lt;chrono&gt;
using namespace std::chrono_literals;
struct bar {
Â Â bar() : i(new long long) {
Â Â Â Â *i = 0;Â Â printf("bar::bar()\n");}
Â Â ~bar() {printf("bar::~bar()\n"); delete i;Â Â i = nullptr;}
Â Â void serve() {
Â Â Â while(true) {
Â Â Â Â Â (*i)++;
Â Â Â Â Â if(*i % 1024768 == 0) {
Â Â Â Â Â Â Â std::this_thread::sleep_for(200ms);
Â Â Â Â Â Â Â (*i) = 0;
Â Â Â Â Â Â Â printf("."); fflush(stdout);
Â Â Â Â Â }
Â Â Â Â Â if(stopRequest) break;
Â Â Â }
}
long long* i = nullptr;
bool stopRequest = false;
};
struct foo {
Â Â foo() : thread(&amp;foo::threadFunc, this) {
Â Â Â Â printf("foo::foo()\n");
Â Â }
Â Â ~foo() {
Â Â Â Â Â Â printf("foo::~foo()\n"); b.stopRequest = true;
Â Â }
Â Â void threadFunc() {
Â Â Â Â b.serve();
Â Â }
Â Â std::jthread thread;
Â Â bar b;
};
int main() {
Â Â foo f;
Â Â std::this_thread::sleep_for(2000ms);
Â Â printf("main returns\n");
Â Â return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.308.1">
     The given
    </span>
    <a id="_idIndexMarker239">
    </a>
    <span class="koboSpan" id="kobo.309.1">
     C++ program tries to get as close as possible to the simple multithreaded mayhem Joe created, using two friendly structures, named
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.310.1">
      bar
     </span>
    </strong>
    <span class="koboSpan" id="kobo.311.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.312.1">
      foo
     </span>
    </strong>
    <span class="koboSpan" id="kobo.313.1">
     (we let
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.314.1">
      baz
     </span>
    </strong>
    <span class="koboSpan" id="kobo.315.1">
     take a rest for a short while, but if you miss him, you can name the function
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.316.1">
      baz
     </span>
    </strong>
    <span class="koboSpan" id="kobo.317.1">
     ), creating a meaningful interaction in order to perform a task on a separate thread.
    </span>
    <span class="koboSpan" id="kobo.317.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.318.1">
      bar
     </span>
    </strong>
    <span class="koboSpan" id="kobo.319.1">
     structure manages a dynamically allocated
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.320.1">
      long long
     </span>
    </strong>
    <span class="koboSpan" id="kobo.321.1">
     variable,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.322.1">
      i
     </span>
    </strong>
    <span class="koboSpan" id="kobo.323.1">
     (because what else would we call a variable that has the role of an index?), which is continuously incremented in its
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.324.1">
      serve
     </span>
    </strong>
    <span class="koboSpan" id="kobo.325.1">
     method.
    </span>
    <span class="koboSpan" id="kobo.325.2">
     When the increment count reaches
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.326.1">
      1024768
     </span>
    </strong>
    <span class="koboSpan" id="kobo.327.1">
     (letâ€™s just ignore the fact that 1024x768 is also a screen resolution), then it pauses for 200 milliseconds, resets the counter
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.328.1">
      i
     </span>
    </strong>
    <span class="koboSpan" id="kobo.329.1">
     to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.330.1">
      0
     </span>
    </strong>
    <span class="koboSpan" id="kobo.331.1">
     , and prints a dot to the console (in the real-life application, something else happened, but that is out of the scope of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.332.1">
      this book).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.333.1">
     This loop continues indefinitely until
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.334.1">
      stopRequest
     </span>
    </strong>
    <span class="koboSpan" id="kobo.335.1">
     is set to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.336.1">
      true
     </span>
    </strong>
    <span class="koboSpan" id="kobo.337.1">
     , signaling the thread to exit.
    </span>
    <span class="koboSpan" id="kobo.337.2">
     The constructor of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.338.1">
      bar
     </span>
    </strong>
    <span class="koboSpan" id="kobo.339.1">
     initializes the counter
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.340.1">
      i
     </span>
    </strong>
    <span class="koboSpan" id="kobo.341.1">
     , and for our sole purpose of debugging, it prints a message, while the destructor handles memory cleanup and prints another message, ensuring that resources are properly managed.
    </span>
    <span class="koboSpan" id="kobo.341.2">
     Why Joe does not use a smart pointer is another story, so letâ€™s not focus on that part
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.342.1">
      for now.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.343.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.344.1">
      foo
     </span>
    </strong>
    <span class="koboSpan" id="kobo.345.1">
     structure is responsible for starting and stopping the thread that runs the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.346.1">
      serve
     </span>
    </strong>
    <span class="koboSpan" id="kobo.347.1">
     method of a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.348.1">
      bar
     </span>
    </strong>
    <span class="koboSpan" id="kobo.349.1">
     instance.
    </span>
    <span class="koboSpan" id="kobo.349.2">
     Upon creation,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.350.1">
      foo
     </span>
    </strong>
    <span class="koboSpan" id="kobo.351.1">
     initializes a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.352.1">
      std::jthread
     </span>
    </strong>
    <span class="koboSpan" id="kobo.353.1">
     to run its
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.354.1">
      threadFunc
     </span>
    </strong>
    <span class="koboSpan" id="kobo.355.1">
     , which in turn calls the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.356.1">
      serve
     </span>
    </strong>
    <span class="koboSpan" id="kobo.357.1">
     method of its
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.358.1">
      bar
     </span>
    </strong>
    <span class="koboSpan" id="kobo.359.1">
     instance.
    </span>
    <span class="koboSpan" id="kobo.359.2">
     This setup allows the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.360.1">
      serve
     </span>
    </strong>
    <span class="koboSpan" id="kobo.361.1">
     method to run concurrently with the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.362.1">
      main
     </span>
    </strong>
    <span class="koboSpan" id="kobo.363.1">
     program.
    </span>
    <span class="koboSpan" id="kobo.363.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.364.1">
      foo
     </span>
    </strong>
    <span class="koboSpan" id="kobo.365.1">
     destructor sets
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.366.1">
      stopRequest
     </span>
    </strong>
    <span class="koboSpan" id="kobo.367.1">
     to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.368.1">
      true
     </span>
    </strong>
    <span class="koboSpan" id="kobo.369.1">
     , ensuring the thread exits gracefully.
    </span>
    <span class="koboSpan" id="kobo.369.2">
     Again, it remained a mystery why Joe decided to pick this way of gracefully ending the thread, but since it worked (after the already-mentioned two weeks of debugging and troubleshooting sessions), the engineering team decided not to ever mention this sequence
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.370.1">
      of code.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.371.1">
     In the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.372.1">
      main
     </span>
    </strong>
    <span class="koboSpan" id="kobo.373.1">
     function, an instance of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.374.1">
      foo
     </span>
    </strong>
    <span class="koboSpan" id="kobo.375.1">
     is created, starting the thread upon its creation, and the program sleeps for two seconds to allow the thread to run.
    </span>
    <span class="koboSpan" id="kobo.375.2">
     For brevity, letâ€™s just assume that in the original application, there was no mention of any kind of sleeping; the real beauty of the solution came from some lengthy operations performed in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.376.1">
      main
     </span>
    </strong>
    <span class="koboSpan" id="kobo.377.1">
     and
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.378.1">
       bar
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.379.1">
      threads.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.380.1">
     Dear seasoned C++
    </span>
    <a id="_idIndexMarker240">
    </a>
    <span class="koboSpan" id="kobo.381.1">
     programmers: please do not focus on how this synthetic piece of code is handling the thread synchronization, or the fact that it allocates and releases memory, because that is not the purpose of it.
    </span>
    <span class="koboSpan" id="kobo.381.2">
     The sole purpose of this code is to crash.
    </span>
    <span class="koboSpan" id="kobo.381.3">
     For
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.382.1">
      std::jthread
     </span>
    </strong>
    <span class="koboSpan" id="kobo.383.1">
     , there are plenty of mechanisms to properly handle the execution, such as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.384.1">
      std::stop_source
     </span>
    </strong>
    <span class="koboSpan" id="kobo.385.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.386.1">
      std::stop_token
     </span>
    </strong>
    <span class="koboSpan" id="kobo.387.1">
     , so please feel free to read up on them and let Joe suffer with his naive approach to threading
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.388.1">
      for now.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.389.1">
     When the code is executed, the following is the result, at least on the authorâ€™s
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.390.1">
      Linux system:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.391.1">
&gt; $ ./a.out
bar::bar()
foo::foo()
.........main returns
foo::~foo()
bar::~bar()</span></pre>
   <p>
    <span class="koboSpan" id="kobo.392.1">
     However, sometimes the output is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.393.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.394.1">
&gt; $ ./a.out
bar::bar()
foo::foo()
.........main returns
foo::~foo()
bar::~bar()
[1]Â Â Â Â 93622 segmentation fault (core dumped)Â Â ./a.out</span></pre>
   <p>
    <span class="koboSpan" id="kobo.395.1">
     The same happened to Joe too.
    </span>
    <span class="koboSpan" id="kobo.395.2">
     Occasionally, the application would go haywire and crash upon exit.
    </span>
    <span class="koboSpan" id="kobo.395.3">
     Initially, this was not too much of a hassle because, well, if the application crashes at the end, thatâ€™s not the end of it.
    </span>
    <span class="koboSpan" id="kobo.395.4">
     However, after a while, the code Joe wrote was introduced in a larger module, and thatâ€™s where chaos, mayhem, and the aforementioned two weeks of debugging
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.396.1">
      sessions materialized.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.397.1">
     The reason for the misdemeanor is quite simple.
    </span>
    <span class="koboSpan" id="kobo.397.2">
     Jimmy, the master programmer discovered after consulting his pocket version of the C++ standard, specifically the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.398.1">
      [class.dtor]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.399.1">
     section
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.400.1">
      of it:
     </span>
    </span>
   </p>
   <p class="author-quote">
    <span class="koboSpan" id="kobo.401.1">
     After executing the body of the destructor and destroying any objects with automatic storage duration allocated within the body, a destructor for class X calls the destructors for Xâ€™s direct non-variant non-static data members, the destructors for Xâ€™s non-virtual direct base classes and, if X is the most derived class, its destructor calls the destructors for Xâ€™s virtual base classes.
    </span>
    <span class="koboSpan" id="kobo.401.2">
     All destructors are called as if they were referenced with a qualified name, that is, ignoring any possible virtual overriding destructors in more derived classes.
    </span>
    <span class="koboSpan" id="kobo.401.3">
     Bases and members are destroyed in the reverse order of the completion of their constructor.
    </span>
    <span class="koboSpan" id="kobo.401.4">
     A return statement in a destructor might not directly return to the caller; before transferring control to the caller, the destructors for the members and bases are called.
    </span>
    <span class="koboSpan" id="kobo.401.5">
     Destructors for elements of an array are called in reverse order of their construction.
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.402.1">
     The key is that the objects are destroyed in reverse order of their creation, just like they would have been pushed onto a stack upon creation and popped off with grace in the reverse order upon destruction.
    </span>
    <span class="koboSpan" id="kobo.402.2">
     The culprits for the erroneous behavior were quickly identified as being
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.403.1">
      the following:
     </span>
    </span>
   </p>
   <p>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.404.1">
       std::jthread thread;
      </span>
     </strong>
    </span>
   </p>
   <p>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.405.1">
       bar b;
      </span>
     </strong>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.406.1">
     So, what happened
    </span>
    <a id="_idIndexMarker241">
    </a>
    <span class="koboSpan" id="kobo.407.1">
     here upon construction was that the thread was created and started running its thread method:
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.408.1">
      void threadFunc() { b.serve(); }
     </span>
    </strong>
    <span class="koboSpan" id="kobo.409.1">
     .
    </span>
    <span class="koboSpan" id="kobo.409.2">
     Only after this unpredictable operation was initiated was the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.410.1">
      bar b
     </span>
    </strong>
    <span class="koboSpan" id="kobo.411.1">
     object created.
    </span>
    <span class="koboSpan" id="kobo.411.2">
     Then, upon exit, as per the design of the C++ language, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.412.1">
      bar b
     </span>
    </strong>
    <span class="koboSpan" id="kobo.413.1">
     object was deleted and its resources freed.
    </span>
    <span class="koboSpan" id="kobo.413.2">
     While the thread was still possibly being blocked in the long operation, suddenly it was running on an object that was
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.414.1">
      already deleted.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.415.1">
     The delay between the creation of the thread object, the actual starting of the thread routine, and the creation of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.416.1">
      bar b
     </span>
    </strong>
    <span class="koboSpan" id="kobo.417.1">
     object is so insignificant that catching the error in the creation phase is almost implausible.
    </span>
    <span class="koboSpan" id="kobo.417.2">
     But letâ€™s modify the constructor of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.418.1">
      bar
     </span>
    </strong>
    <span class="koboSpan" id="kobo.419.1">
     to be along the lines of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.420.1">
      the following:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.421.1">
bar() { std::this_thread::sleep_for(200ms);
Â Â Â Â i = new long long; *i = 0;Â Â printf("bar::bar()\n ");}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.422.1">
     In an instant, we can see how the thread is running on an object whose creation was not entirely finished by the time the thread started using it.
    </span>
    <span class="koboSpan" id="kobo.422.2">
     Certainly, this specific issue can be resolved easily, by simply switching the order of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.423.1">
      the members:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.424.1">
bar b;
std::jthread thread;</span></pre>
   <p>
    <span class="koboSpan" id="kobo.425.1">
     Threading is an interesting aspect of C++.
    </span>
    <span class="koboSpan" id="kobo.425.2">
     While it comes with many benefits, it also introduces extra complexity.
    </span>
    <span class="koboSpan" id="kobo.425.3">
     Properly writing correct and efficient multithreaded code requires careful consideration of synchronization and coordination between
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.426.1">
      various threads.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.427.1">
     Debugging
    </span>
    <a id="_idIndexMarker242">
    </a>
    <span class="koboSpan" id="kobo.428.1">
     multithreaded applications can be challenging due to issues such as race conditions, deadlocks, and non-deterministic behavior, or the simple fact that the thread is stopped by the debugger, so upon inspecting it, no real work happens, and sometimes the success or failure of an application really hangs on the order in which the class members are declared.
    </span>
    <span class="koboSpan" id="kobo.428.2">
     But for now, letâ€™s say goodbye to Joe and his friends.
    </span>
    <span class="koboSpan" id="kobo.428.3">
     Letâ€™s hope they have got their AAAA title out on the door, and letâ€™s focus our attention on
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.429.1">
      something else.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-67">
    <a id="_idTextAnchor066">
    </a>
    <span class="koboSpan" id="kobo.430.1">
     The dark orders of C++
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.431.1">
     There is one
    </span>
    <a id="_idIndexMarker243">
    </a>
    <span class="koboSpan" id="kobo.432.1">
     dark corner of the C++ language that is rarely touched by sunlight, and if a piece of code from these depths surfaces by any chance, a gang of hardcore developers immediately jumps on it and refactors it into digestible bits and bytes.
    </span>
    <span class="koboSpan" id="kobo.432.2">
     Letâ€™s consider, for example, the very simple case of why the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.433.1">
      a[2]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.434.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.435.1">
      2[a]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.436.1">
     expressions are equivalent when in C++, and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.437.1">
      a
     </span>
    </strong>
    <span class="koboSpan" id="kobo.438.1">
     is an array
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.439.1">
      of objects:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.440.1">
int main() {
Â Â Â Â int a[16] = {0};
Â Â Â Â a[2] = 3;
Â Â Â Â 3[a] = 4;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.441.1">
     The
    </span>
    <a id="_idIndexMarker244">
    </a>
    <span class="koboSpan" id="kobo.442.1">
     preceding piece of code, despite the fact that it looks ugly, actually compiles.
    </span>
    <span class="koboSpan" id="kobo.442.2">
     The reason is the following: in C++, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.443.1">
      operator []
     </span>
    </strong>
    <span class="koboSpan" id="kobo.444.1">
     array subscript is defined in terms of pointer arithmetic.
    </span>
    <span class="koboSpan" id="kobo.444.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.445.1">
      a[i]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.446.1">
     expression is translated by the compiler into
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.447.1">
      *(a + i)
     </span>
    </strong>
    <span class="koboSpan" id="kobo.448.1">
     , where
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.449.1">
      a
     </span>
    </strong>
    <span class="koboSpan" id="kobo.450.1">
     is a pointer to the first element of the array and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.451.1">
      i
     </span>
    </strong>
    <span class="koboSpan" id="kobo.452.1">
     is the index.
    </span>
    <span class="koboSpan" id="kobo.452.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.453.1">
      i[a]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.454.1">
     expression at the end is also translated to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.455.1">
      *(i + a)
     </span>
    </strong>
    <span class="koboSpan" id="kobo.456.1">
     expression, where
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.457.1">
      i
     </span>
    </strong>
    <span class="koboSpan" id="kobo.458.1">
     is the index and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.459.1">
      a
     </span>
    </strong>
    <span class="koboSpan" id="kobo.460.1">
     is the pointer to our arraysâ€™
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.461.1">
      first elements.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.462.1">
     Since addition is commutative for the compiler, it does not really matter which
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.463.1">
      comes first.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.464.1">
     So, we have found a specific case where order doesnâ€™t really matter in C++.
    </span>
    <span class="koboSpan" id="kobo.464.2">
     But this works only for old-style C arrays;
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.465.1">
      std::vector
     </span>
    </strong>
    <span class="koboSpan" id="kobo.466.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.467.1">
      std::array
     </span>
    </strong>
    <span class="koboSpan" id="kobo.468.1">
     do not accept this kind of out-of-order syntax.
    </span>
    <span class="koboSpan" id="kobo.468.2">
     There is a very specific reasoning for that; the subscript operator for
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.469.1">
      std::vector
     </span>
    </strong>
    <span class="koboSpan" id="kobo.470.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.471.1">
      std::array
     </span>
    </strong>
    <span class="koboSpan" id="kobo.472.1">
     does not support the commutative behavior seen in raw arrays, namely
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.473.1">
      the following:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.474.1">
       Operator overloading
      </span>
     </strong>
     <span class="koboSpan" id="kobo.475.1">
      : The
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.476.1">
       operator[]
      </span>
     </strong>
     <span class="koboSpan" id="kobo.477.1">
      for
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.478.1">
       std::vector
      </span>
     </strong>
     <span class="koboSpan" id="kobo.479.1">
      and
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.480.1">
       std::array
      </span>
     </strong>
     <span class="koboSpan" id="kobo.481.1">
      is a member
     </span>
     <a id="_idIndexMarker245">
     </a>
     <span class="koboSpan" id="kobo.482.1">
      function, meaning it needs to be called on an instance of the class.
     </span>
     <span class="koboSpan" id="kobo.482.2">
      It cannot be invoked with the index first, as member functions require the object to be on the left side of
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.483.1">
       the call.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.484.1">
       No pointer arithmetic
      </span>
     </strong>
     <span class="koboSpan" id="kobo.485.1">
      : The internal implementation of
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.486.1">
       std::vector
      </span>
     </strong>
     <span class="koboSpan" id="kobo.487.1">
      and
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.488.1">
       std::array
      </span>
     </strong>
     <span class="koboSpan" id="kobo.489.1">
      does not rely on raw pointer arithmetic for indexing.
     </span>
     <span class="koboSpan" id="kobo.489.2">
      They manage their memory and bounds checking differently, ensuring safer access
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.490.1">
       to elements.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.491.1">
     At the current stage, the closest we can get to emulating the preceding unholy syntax for an object of type
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.492.1">
      std::vector
     </span>
    </strong>
    <span class="koboSpan" id="kobo.493.1">
     is the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.494.1">
      following code:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.495.1">
#include &lt;vector&gt;
#include &lt;iostream&gt;
struct wrapper {
Â Â Â wrapper(int p) : i(p) {}
Â Â Â int operator[](const std::vector&lt;int&gt; v) {return v[i];}
Â Â Â int i = 0;
};
struct helper {
Â Â Â helper() = default;
Â Â Â wrapper operator &lt;&lt; (int a) { return wrapper {a}; }
};
#define _ helper()&lt;&lt;
int main() {
Â Â Â std::vector&lt;int&gt; vec = {10, 20, 30, 40, 50};
Â Â Â int b= (_ 2) [vec];
Â Â Â std::cout &lt;&lt; b &lt;&lt; std::endl;Â Â // Outputs 30
Â Â Â return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.496.1">
     After a quick
    </span>
    <a id="_idIndexMarker246">
    </a>
    <span class="koboSpan" id="kobo.497.1">
     examination of it, however, we, the authors (well, not actually both the authors, because Alex is innocent, at least concerning this code, so please consider this as the royal we), have decided that we are ashamed of it, and did not dare implement it for
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.498.1">
      std::array
     </span>
    </strong>
    <span class="koboSpan" id="kobo.499.1">
     or any
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.500.1">
      other containers.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.501.1">
     But on a second look, we have some interesting code there.
    </span>
    <span class="koboSpan" id="kobo.501.2">
     Our main goal was to recreate the orderless index access for vectors and arrays, but before we indulge ourselves in believing that it is possible, a harsh reality check: it is not.
    </span>
    <span class="koboSpan" id="kobo.501.3">
     The reason for this is the following: if we try to compile the expression
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.502.1">
      2[vec];
     </span>
    </strong>
    <span class="koboSpan" id="kobo.503.1">
     , we get the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.504.1">
      following error:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.505.1">
error: no match for 'operator[]' (operand types are 'int' and 'std::vector&lt;int&gt;')</span></pre>
   <p>
    <span class="koboSpan" id="kobo.506.1">
     This, translated to plain English, means the compiler cannot find an index operator that is applied to integers and takes in as parameter a vector of ints.
    </span>
    <span class="koboSpan" id="kobo.506.2">
     As long as C++ is C++, this will not happen for two major reasons.
    </span>
    <span class="koboSpan" id="kobo.506.3">
     The first is that
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.507.1">
      operator[]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.508.1">
     needs to be a member function in a class.
    </span>
    <span class="koboSpan" id="kobo.508.2">
     It is not possible to have a freestanding
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.509.1">
      []
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.510.1">
      operator.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.511.1">
     The second is a peculiar thing, called operator precedence.
    </span>
    <span class="koboSpan" id="kobo.511.2">
     That is not an operator called
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.512.1">
      precedence
     </span>
    </em>
    <span class="koboSpan" id="kobo.513.1">
     , but the following: in C++, the order of operations, also known as operator precedence, determines
    </span>
    <a id="_idIndexMarker247">
    </a>
    <span class="koboSpan" id="kobo.514.1">
     how operators are parsed concerning each other.
    </span>
    <span class="koboSpan" id="kobo.514.2">
     Operators with higher precedence are evaluated before operators with lower precedence.
    </span>
    <span class="koboSpan" id="kobo.514.3">
     When operators have the same precedence, their associativity determines the order
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.515.1">
      of evaluation.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.516.1">
     While in the latest standard,
    </span>
    <a href="B22235_07.xhtml#_idTextAnchor079">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.517.1">
        Chapter 7
       </span>
      </em>
     </span>
    </a>
    <em class="italic">
     <span class="koboSpan" id="kobo.518.1">
      , Expressions
     </span>
    </em>
    <span class="koboSpan" id="kobo.519.1">
     (specifically the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.520.1">
      [expr.pre]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.521.1">
     section), mentions that â€œThe precedence of operators is not directly specified, but it can be derived from the syntaxâ€ there are official sources of information2
    </span>
    <span id="footnote-017-backlink">
     <a class="_idFootnoteLink _idGenColorInherit" href="B22235_05.xhtml#footnote-017">
      <span class="koboSpan" id="kobo.522.1">
       2
      </span>
     </a>
    </span>
    <span class="koboSpan" id="kobo.523.1">
     which contain the exact order of them so we really encourage you to go and dedicate proper time to study one of those sources.
    </span>
   </p>
   <div class="_idFootnote" epub:type="footnote" id="footnote-017">
    <p class="Footnote-text">
     <strong class="source-inline">
      <a class="_idFootnoteAnchor _idGenColorInherit" href="B22235_05.xhtml#footnote-017-backlink">
       <span class="koboSpan" id="kobo.524.1">
        2
       </span>
      </a>
     </strong>
     <strong class="source-inline">
     </strong>
     <a href="https://en.cppreference.com/w/cpp/language/operator_precedence">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.525.1">
        https://en.cppreference.com/w/cpp/language/operator_precedence
       </span>
      </span>
     </a>
    </p>
   </div>
   <h2 id="_idParaDest-68">
    <a id="_idTextAnchor067">
    </a>
    <span class="koboSpan" id="kobo.526.1">
     The most important question
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.527.1">
     And now that youâ€™re back, dear reader, we are pretty sure that you can easily answer the following question.
    </span>
    <span class="koboSpan" id="kobo.527.2">
     What is the output of the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.528.1">
      following program?
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.529.1">
#include &lt;iostream&gt;
int main() {
Â Â Â Â auto a = 4;
Â Â Â Â std::cout &lt;&lt; sizeof(a)["Hello World"] &lt;&lt; std::endl;
Â Â Â Â return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.530.1">
     Before you rush into feeding the code into your compiler, however, pause, sit back, and think thoroughly about what exactly is happening here.
    </span>
    <span class="koboSpan" id="kobo.530.2">
     This section gave you all the hints, directions, and possible clues you needed in order to answer this correctly.
    </span>
    <span class="koboSpan" id="kobo.530.3">
     We intentionally will not give the answer yet, nor a full explanation of the code, just a quick breakdown of whatâ€™s happening, which should be enough to figure
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.531.1">
      it out:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.532.1">
      In the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.533.1">
       auto a = 4;
      </span>
     </strong>
     <span class="koboSpan" id="kobo.534.1">
      expression, the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.535.1">
       a
      </span>
     </strong>
     <span class="koboSpan" id="kobo.536.1">
      variable is declared with the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.537.1">
       int
      </span>
     </strong>
     <span class="koboSpan" id="kobo.538.1">
      type and initialized to
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.539.1">
       4
      </span>
     </strong>
     <span class="koboSpan" id="kobo.540.1">
      .
     </span>
     <span class="koboSpan" id="kobo.540.2">
      This is just the way
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.541.1">
       auto
      </span>
     </strong>
     <span class="koboSpan" id="kobo.542.1">
      and numbers work in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.543.1">
       modern C++.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.544.1">
      Now comes the tricky part.
     </span>
     <span class="koboSpan" id="kobo.544.2">
      Parsing the code in our brain, it is obvious that the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.545.1">
       sizeof(a)
      </span>
     </strong>
     <span class="koboSpan" id="kobo.546.1">
      expression evaluates to a
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.547.1">
       std::sizeof
      </span>
     </strong>
     <span class="koboSpan" id="kobo.548.1">
      type, and typically,
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.549.1">
       sizeof(int)
      </span>
     </strong>
     <span class="koboSpan" id="kobo.550.1">
      is 4 bytes on most systems.
     </span>
     <span class="koboSpan" id="kobo.550.2">
      Certainly, older 16-bit systems have
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.551.1">
       sizeof(int)
      </span>
     </strong>
     <span class="koboSpan" id="kobo.552.1">
      as
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.553.1">
       2
      </span>
     </strong>
     <span class="koboSpan" id="kobo.554.1">
      ; some exotic systems can have
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.555.1">
       sizeof(int)
      </span>
     </strong>
     <span class="koboSpan" id="kobo.556.1">
      as
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.557.1">
       8
      </span>
     </strong>
     <span class="koboSpan" id="kobo.558.1">
      , but the author of these lines has never seen a system
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.559.1">
       like that.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.560.1">
     This is the crucial point where all our deduction has chicaned out.
    </span>
    <span class="koboSpan" id="kobo.560.2">
     What kicks in is the operator precedence of C++.
    </span>
    <span class="koboSpan" id="kobo.560.3">
     Hereâ€™s just a tiny extract from the preceding table, where we have kept just the parts relevant to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.561.1">
      our case:
     </span>
    </span>
   </p>
   <table class="No-Table-Style _idGenTablePara-1" id="table002">
    <colgroup>
     <col/>
     <col/>
     <col/>
    </colgroup>
    <thead>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="bold">
          <span class="koboSpan" id="kobo.562.1">
           Precedence
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="bold">
          <span class="koboSpan" id="kobo.563.1">
           Operator
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="bold">
          <span class="koboSpan" id="kobo.564.1">
           Description
          </span>
         </strong>
        </span>
       </p>
      </td>
     </tr>
    </thead>
    <tbody>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.565.1">
         1
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         <span class="koboSpan" id="kobo.566.1">
          ::
         </span>
        </strong>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.567.1">
         Scope
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.568.1">
          resolution operator
         </span>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.569.1">
         2
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.570.1">
           a++ a--
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.571.1">
         Postfix increment
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.572.1">
          and decrement
         </span>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.573.1">
           a()
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.574.1">
          Function call
         </span>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.575.1">
           a[]
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.576.1">
          Subscript
         </span>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.577.1">
         3
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         <span class="koboSpan" id="kobo.578.1">
          ++
         </span>
        </strong>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.579.1">
           a --a
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.580.1">
         Prefix increment
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.581.1">
          and decrement
         </span>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
      </td>
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         <span class="koboSpan" id="kobo.582.1">
          +
         </span>
        </strong>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.583.1">
           a -a
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.584.1">
         Unary plus
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.585.1">
          and minus
         </span>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
      </td>
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         <span class="koboSpan" id="kobo.586.1">
          !
         </span>
         <span class="koboSpan" id="kobo.586.2">
          ~
         </span>
        </strong>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.587.1">
         Logical NOT and
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.588.1">
          bitwise NOT
         </span>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
      </td>
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         <span class="koboSpan" id="kobo.589.1">
          *a
         </span>
        </strong>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.590.1">
          Dereference
         </span>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
      </td>
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         <span class="koboSpan" id="kobo.591.1">
          &amp;a
         </span>
        </strong>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.592.1">
          Address-of
         </span>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.593.1">
           sizeof
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.594.1">
         Size
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.595.1">
          of operator
         </span>
        </span>
       </p>
      </td>
     </tr>
    </tbody>
   </table>
   <p>
    <span class="koboSpan" id="kobo.596.1">
     Now, we can finally see that in our code, the expression
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.597.1">
      sizeof(a)
     </span>
    </strong>
    <span class="koboSpan" id="kobo.598.1">
     will never be evaluated.
    </span>
    <span class="koboSpan" id="kobo.598.2">
     Due to the way the C++ compiler works, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.599.1">
      []
     </span>
    </strong>
    <span class="koboSpan" id="kobo.600.1">
     operator has priority over
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.601.1">
      sizeof
     </span>
    </strong>
    <span class="koboSpan" id="kobo.602.1">
     , so what will be evaluated first is
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.603.1">
      (
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.604.1">
       a)["Hello World"];
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.605.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.606.1">
     Since in C++
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.607.1">
      (a)
     </span>
    </strong>
    <span class="koboSpan" id="kobo.608.1">
     is almost always identical to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.609.1">
      a
     </span>
    </strong>
    <span class="koboSpan" id="kobo.610.1">
     (except when you are dealing with the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.611.1">
      most vexing parse
     </span>
    </em>
    <span class="koboSpan" id="kobo.612.1">
     , but more on that at a later stage), the expression is identical to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.613.1">
      sizeof
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.614.1">
       a["Hello World"];
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.615.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.616.1">
     Now, as we have seen, this yields the same result as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.617.1">
      sizeof "Hello World"[a];
     </span>
    </strong>
    <span class="koboSpan" id="kobo.618.1">
     , which, considering that today,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.619.1">
      a
     </span>
    </strong>
    <span class="koboSpan" id="kobo.620.1">
     will most likely be
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.621.1">
      4
     </span>
    </strong>
    <span class="koboSpan" id="kobo.622.1">
     , gives us the character
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.623.1">
      'o'
     </span>
    </strong>
    <span class="koboSpan" id="kobo.624.1">
     .
    </span>
    <span class="koboSpan" id="kobo.624.2">
     So, the entire expression is now reduced to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.625.1">
      sizeof 'o'
     </span>
    </strong>
    <span class="koboSpan" id="kobo.626.1">
     , which, considering the way
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.627.1">
      sizeof
     </span>
    </strong>
    <span class="koboSpan" id="kobo.628.1">
     works, will always
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.629.1">
      return
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.630.1">
       1
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.631.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.632.1">
     We, the authors, think that at this stage, the answer to our question
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.633.1">
      is obvious.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-69">
    <a id="_idTextAnchor068">
    </a>
    <span class="koboSpan" id="kobo.634.1">
     When order does not matter
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.635.1">
     There is one
    </span>
    <a id="_idIndexMarker248">
    </a>
    <span class="koboSpan" id="kobo.636.1">
     tiny thing we ought not to forget to mention before closing this chapter.
    </span>
    <span class="koboSpan" id="kobo.636.2">
     Well, actually two.
    </span>
    <span class="koboSpan" id="kobo.636.3">
     The first one is that in C++, the order in which function arguments are evaluated is unspecified.
    </span>
    <span class="koboSpan" id="kobo.636.4">
     This means that when you call a function with multiple arguments, the compiler is free to evaluate the arguments in any order it chooses.
    </span>
    <span class="koboSpan" id="kobo.636.5">
     This can lead to unexpected results if the arguments have side effects, such as modifying
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.637.1">
      a variable.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.638.1">
     Letâ€™s take, for example, the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.639.1">
      following program:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.640.1">
#include &lt;iostream&gt;
int f (int a, int b, int c) {
Â Â Â Â std::cout &lt;&lt; "a="&lt;&lt;a&lt;&lt;" b="&lt;&lt;b&lt;&lt;" c="&lt;&lt;c&lt;&lt;std::endl;
Â Â Â Â return a+b+c;
}
int main() {
Â Â Â Â int i = 1;
Â Â Â Â std::cout&lt;&lt;"f="&lt;&lt;f(i++, i++, i++)&lt;&lt;std::endl&lt;&lt;"i="&lt;&lt;i&lt;&lt;std::endl;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.641.1">
     Regardless of what you think the output of this program is, it will
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.642.1">
      be wrong.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.643.1">
     The reason for
    </span>
    <a id="_idIndexMarker249">
    </a>
    <span class="koboSpan" id="kobo.644.1">
     this is, again, as mentioned previously: the order of evaluation of the parameters is not specified.
    </span>
    <span class="koboSpan" id="kobo.644.2">
     With good reason, you may ask, why?
    </span>
    <span class="koboSpan" id="kobo.644.3">
     The reasons for this are a bit more complex and historical.
    </span>
    <span class="koboSpan" id="kobo.644.4">
     But before delving deeper into that, letâ€™s amuse ourselves with the output that various compilers provide us with, courtesy of gcc.godbolt.org and some
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.645.1">
      other sources.
     </span>
    </span>
   </p>
   <table class="No-Table-Style _idGenTablePara-1" id="table003">
    <colgroup>
     <col/>
     <col/>
    </colgroup>
    <tbody>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="bold">
          <span class="koboSpan" id="kobo.646.1">
           Compiler
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="bold">
          <span class="koboSpan" id="kobo.647.1">
           Output
          </span>
         </strong>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.648.1">
         Microsoft Visual C++ (
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.649.1">
          after 2005)
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         <span class="koboSpan" id="kobo.650.1">
          a=1
         </span>
        </strong>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.651.1">
           b=1 c=1
          </span>
         </strong>
        </span>
       </p>
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.652.1">
           f=3
          </span>
         </strong>
        </span>
       </p>
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.653.1">
           i=4
          </span>
         </strong>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.654.1">
         Microsoft
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.655.1">
          VS.NET 2003
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         <span class="koboSpan" id="kobo.656.1">
          a=3
         </span>
        </strong>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.657.1">
           b=2 c=1
          </span>
         </strong>
        </span>
       </p>
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.658.1">
           f=6
          </span>
         </strong>
        </span>
       </p>
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.659.1">
           i=4
          </span>
         </strong>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.660.1">
         Microsoft Visual
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.661.1">
          C++ 6
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         <span class="koboSpan" id="kobo.662.1">
          a=1
         </span>
        </strong>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.663.1">
           b=1 c=1
          </span>
         </strong>
        </span>
       </p>
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.664.1">
           f=3
          </span>
         </strong>
        </span>
       </p>
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.665.1">
           i=4
          </span>
         </strong>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.666.1">
         ICC and Clang agree
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.667.1">
          on thisâ€¦
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         <span class="koboSpan" id="kobo.668.1">
          f=a=1
         </span>
        </strong>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.669.1">
           b=2 c=3
          </span>
         </strong>
        </span>
       </p>
       <p>
        <strong class="source-inline">
         <span class="koboSpan" id="kobo.670.1">
          6
         </span>
        </strong>
       </p>
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.671.1">
           i=4
          </span>
         </strong>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.672.1">
         GCC,
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.673.1">
          after 6.5
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         <span class="koboSpan" id="kobo.674.1">
          f=a=3
         </span>
        </strong>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.675.1">
           b=2 c=1
          </span>
         </strong>
        </span>
       </p>
       <p>
        <strong class="source-inline">
         <span class="koboSpan" id="kobo.676.1">
          6
         </span>
        </strong>
       </p>
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.677.1">
           i=4
          </span>
         </strong>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.678.1">
         GCC,
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.679.1">
          before 6.5
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         <span class="koboSpan" id="kobo.680.1">
          a=3
         </span>
        </strong>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.681.1">
           b=2 c=1
          </span>
         </strong>
        </span>
       </p>
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.682.1">
           f=6
          </span>
         </strong>
        </span>
       </p>
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.683.1">
           i=4
          </span>
         </strong>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="koboSpan" id="kobo.684.1">
         Turbo C Lite and
        </span>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.685.1">
          Borland C++55
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         <span class="koboSpan" id="kobo.686.1">
          a=3
         </span>
        </strong>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.687.1">
           b=2 c=1
          </span>
         </strong>
        </span>
       </p>
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.688.1">
           f=6
          </span>
         </strong>
        </span>
       </p>
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.689.1">
           i=1
          </span>
         </strong>
        </span>
       </p>
      </td>
     </tr>
    </tbody>
   </table>
   <p>
    <span class="koboSpan" id="kobo.690.1">
     So, we have a
    </span>
    <a id="_idIndexMarker250">
    </a>
    <span class="koboSpan" id="kobo.691.1">
     plethora of options to choose from, some more straightforward and others more exotic.
    </span>
    <span class="koboSpan" id="kobo.691.2">
     All these weird values claim they are the right one, the one to rule them all, regardless of the fact that even different versions of the same compiler from the same provider provide different results.
    </span>
    <span class="koboSpan" id="kobo.691.3">
     And they are all right in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.692.1">
      their belief.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.693.1">
     Quite simply, the reasoning is that allowing the compiler the freedom to choose the order of evaluation enables it to make optimizations that can improve performance that we programmers may not notice.
    </span>
    <span class="koboSpan" id="kobo.693.2">
     The compiler can reorder instructions to take advantage of CPU pipelines, minimize register usage, and enhance cache efficiency.
    </span>
    <span class="koboSpan" id="kobo.693.3">
     Specifying a strict order would limit these
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.694.1">
      optimization opportunities.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.695.1">
     Different hardware architectures may have different optimal evaluation strategies.
    </span>
    <span class="koboSpan" id="kobo.695.2">
     By not specifying the order of evaluation, C++ code can be more easily optimized for a wide variety of architectures without requiring changes to the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.696.1">
      code itself.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.697.1">
     Also, by not specifying the order of evaluation, the C++ language specification remains simpler.
    </span>
    <span class="koboSpan" id="kobo.697.2">
     Specifying a strict order for all expressions would add complexity to the language definition and increase the burden on compiler developers.
    </span>
    <span class="koboSpan" id="kobo.697.3">
     Not to mention that the current standard is almost 2,000 pages long, so maybe it is a good idea not to add several hundred pages detailing the complexities of the order of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.698.1">
      parameter evaluations.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.699.1">
     The second thing we promised to mention at the beginning of this section, however, comes up: while operator precedence and associativity dictate how expressions are grouped and parsed, they do not dictate the order of evaluation.
    </span>
    <span class="koboSpan" id="kobo.699.2">
     This means that even though you know how expressions will be grouped, the actual order in which parts of the expression are evaluated can
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.700.1">
      still vary.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.701.1">
     Letâ€™s consider the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.702.1">
      short application:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.703.1">
#include &lt;iostream&gt;
int main() {
Â Â Â Â int i = 4;
Â Â Â Â i = ++i + i++;
Â Â Â Â std::cout &lt;&lt; i &lt;&lt; std::endl;
Â Â Â Â return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.704.1">
     It is really short â€“ it couldnâ€™t be shorter â€“ and it contains some quite nasty code, especially looking at
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.705.1">
      ++i + i++
     </span>
    </strong>
    <span class="koboSpan" id="kobo.706.1">
     .
    </span>
    <span class="koboSpan" id="kobo.706.2">
     That piece of code is so nasty that the compilers cannot really agree in which order to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.707.1">
      execute it.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.708.1">
     Some of them choose to execute
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.709.1">
      ++i
     </span>
    </strong>
    <span class="koboSpan" id="kobo.710.1">
     (making
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.711.1">
      i
     </span>
    </strong>
    <span class="koboSpan" id="kobo.712.1">
     be
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.713.1">
      5
     </span>
    </strong>
    <span class="koboSpan" id="kobo.714.1">
     and also using it as the left side of the addition) first, and then
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.715.1">
      i++
     </span>
    </strong>
    <span class="koboSpan" id="kobo.716.1">
     (which will be using the new value of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.717.1">
      i
     </span>
    </strong>
    <span class="koboSpan" id="kobo.718.1">
     , which was incremented already, then incrementing it again to reach
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.719.1">
      6
     </span>
    </strong>
    <span class="koboSpan" id="kobo.720.1">
     , but due to the way post-increment works, the value of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.721.1">
      5
     </span>
    </strong>
    <span class="koboSpan" id="kobo.722.1">
     will be used for the right-hand side of the addition), and then assigning this value back to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.723.1">
      i
     </span>
    </strong>
    <span class="koboSpan" id="kobo.724.1">
     .
    </span>
    <span class="koboSpan" id="kobo.724.2">
     So, thatâ€™s 5 + 5 =
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.725.1">
      10.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.726.1">
     However, other compilers
    </span>
    <a id="_idIndexMarker251">
    </a>
    <span class="koboSpan" id="kobo.727.1">
     decide to execute
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.728.1">
      i++
     </span>
    </strong>
    <span class="koboSpan" id="kobo.729.1">
     first, thus keeping the value
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.730.1">
      4
     </span>
    </strong>
    <span class="koboSpan" id="kobo.731.1">
     on the right-hand side of the operation, while also incrementing the value of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.732.1">
      i
     </span>
    </strong>
    <span class="koboSpan" id="kobo.733.1">
     to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.734.1">
      6
     </span>
    </strong>
    <span class="koboSpan" id="kobo.735.1">
     .
    </span>
    <span class="koboSpan" id="kobo.735.2">
     Now,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.736.1">
      ++i
     </span>
    </strong>
    <span class="koboSpan" id="kobo.737.1">
     is evaluated, which already sees the incremented value of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.738.1">
      6
     </span>
    </strong>
    <span class="koboSpan" id="kobo.739.1">
     , decides to use it, and then increments it, thus obtaining
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.740.1">
      7
     </span>
    </strong>
    <span class="koboSpan" id="kobo.741.1">
     for the left-hand side of the addition.
    </span>
    <span class="koboSpan" id="kobo.741.2">
     Thus, this will give 7 + 4 =
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.742.1">
      11.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.743.1">
     Now, thinking a bit back, not having the evaluation order specified encourages developers aware of this uncanny feature to write code that does not expect specific evaluation orders.
    </span>
    <span class="koboSpan" id="kobo.743.2">
     This can lead to more robust and portable code, as developers must avoid unintended dependencies on evaluation order.
    </span>
    <span class="koboSpan" id="kobo.743.3">
     As such, the correct fix for the preceding situation would be some code along the lines of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.744.1">
      the following:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.745.1">
#include &lt;iostream&gt;
int main() {
Â Â int i = 4;
Â Â int preIncrement = ++i; // i is now 5
Â Â int postIncrement = i++; //postIncrement is 5, i is now 6
Â Â i = preIncrement + postIncrement;
Â Â std::cout &lt;&lt; i &lt;&lt; std::endl; // Output will be 10
Â Â return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.746.1">
     While this might be a rare situation, because the preceding code is a bit artificial, it is an issue, especially still if we are dealing with situations like
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.747.1">
      the following:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.748.1">
int f() { std::cout &lt;&lt; "f"; return 1; }
int g() { std::cout &lt;&lt; "g"; return 2; }
int result = f() + g();</span></pre>
   <p>
    <span class="koboSpan" id="kobo.749.1">
     The value of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.750.1">
      result
     </span>
    </strong>
    <span class="koboSpan" id="kobo.751.1">
     will
    </span>
    <a id="_idIndexMarker252">
    </a>
    <span class="koboSpan" id="kobo.752.1">
     be
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.753.1">
      3
     </span>
    </strong>
    <span class="koboSpan" id="kobo.754.1">
     regardless, but the output, depending on how the compiler decides to execute the two function calls, can be either
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.755.1">
      "fg"
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.756.1">
      or
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.757.1">
       "gf"
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.758.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.759.1">
     With all this in mind, we may think that we understand everything about ordering in C++.
    </span>
    <span class="koboSpan" id="kobo.759.2">
     While in this chapter we have tried to cover all possible implications, we cannot promise that you will not find anything out of order.
    </span>
    <span class="koboSpan" id="kobo.759.3">
     C++ is a language with a very wide scope and peculiar syntax, so if someone really wanted to, they could step on the toes of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.760.1">
      some compilers.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-70">
    <a id="_idTextAnchor069">
    </a>
    <span class="koboSpan" id="kobo.761.1">
     Summary
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.762.1">
     With this chapter, we hope you have grasped the critical importance of following the specified order of everything C++-related to ensure predictable and error-free code execution.
    </span>
    <span class="koboSpan" id="kobo.762.2">
     You should also understand the importance of not having a specified order
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.763.1">
      of execution.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.764.1">
     With this in mind, we encourage you to go and experiment with the online playground offered by Compiler Explorer.
    </span>
    <span class="koboSpan" id="kobo.764.2">
     It offers a large collection of compilers.
    </span>
    <span class="koboSpan" id="kobo.764.3">
     Just bear in mind that if two compilers have generated different results for the code you wrote, then maybe you have ventured into unspecified/undefined
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.765.1">
      behavior territory.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.766.1">
     The next chapter explores the challenges of memory management
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.767.1">
      in C++.
     </span>
    </span>
   </p>
  </div>
 </body></html>