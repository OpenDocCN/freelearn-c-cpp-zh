- en: '*Chapter 3*: Variadic Templates'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 3 章*：变长模板'
- en: A variadic template is a template with a variable number of arguments. This
    is a feature that was introduced in C++11\. It combines generic code with functions
    with variable numbers of arguments, a feature that was inherited from the C language.
    Although the syntax and some details could be seen as cumbersome, variadic templates
    help us write function templates with a variable number of arguments or class
    templates with a variable number of data members in a way that was not possible
    before with compile time evaluation and type safety.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 变长模板是一个具有可变数量参数的模板。这是 C++11 中引入的特性。它结合了泛型代码和具有可变数量参数的函数，这是从 C 语言继承来的特性。尽管语法和一些细节可能看起来有些繁琐，但变长模板帮助我们以前无法通过编译时评估和类型安全的方式编写具有可变数量参数的函数模板或具有可变数量数据成员的类模板。
- en: 'In this chapter, we will learn about the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下主题：
- en: Understanding the need for variadic templates
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解变长模板的需求
- en: Variadic function templates
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变长函数模板
- en: Parameter packs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数包
- en: Variadic class templates
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变长类模板
- en: Fold expressions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 折叠表达式
- en: Variadic alias templates
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变长别名模板
- en: Variadic variable templates
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变长变量模板
- en: By the end of the chapter, you will have a good understanding of how to write
    variadic templates and how they work.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将很好地理解如何编写变长模板以及它们是如何工作的。
- en: We will start, however, by trying to understand why templates with variable
    numbers of arguments are helpful.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们将首先尝试理解为什么具有可变数量参数的模板是有帮助的。
- en: Understanding the need for variadic templates
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解变长模板的需求
- en: 'One of the most famous C and C++ functions is `printf`, which writes formatted
    output to the `stdout` standard output stream. There is actually a family of functions
    in the I/O library for writing formatted output, which also includes `fprintf`
    (which writes to a file stream), `sprint`, and `snprintf` (which write to a character
    buffer). These functions are similar because they take a string defining the output
    format and a variable number of arguments. The language, however, provides us
    with the means to write our own functions with variable numbers of arguments.
    Here is an example of a function that takes one or more arguments and returns
    the minimum value:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最著名的 C 和 C++ 函数之一是 `printf`，它将格式化输出写入 `stdout` 标准输出流。实际上，I/O 库中有一系列用于写入格式化输出的函数，包括
    `fprintf`（写入文件流）、`sprintf` 和 `snprintf`（写入字符缓冲区）。这些函数之所以相似，是因为它们接受一个定义输出格式的字符串和可变数量的参数。然而，语言为我们提供了编写具有可变数量参数的函数的手段。以下是一个接受一个或多个参数并返回最小值的函数示例：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This implementation is specific for values of the `int` type. However, it is
    possible to write a similar function that is a function template. The transformation
    requires minimal changes and the result is as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现特定于 `int` 类型的值。然而，可以编写一个类似的函数模板。这种转换需要最小的更改，结果如下：
- en: '[PRE22]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Writing code like this, whether generic or not, has several important drawbacks:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 编写这样的代码，无论是泛型还是非泛型，都有几个重要的缺点：
- en: 'It requires the use of several macros: `va_list` (which provides access to
    the information needed by the others), `va_start` (starts the iterating of the
    arguments), `va_arg` (provides access to the next argument), and `va_end` (stops
    the iterating of the arguments).'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它需要使用几个宏：`va_list`（为其他宏提供所需的信息）、`va_start`（开始迭代参数）、`va_arg`（提供访问下一个参数的方法）和 `va_end`（停止迭代参数）。
- en: Evaluation happens at runtime, even though the number and the type of the arguments
    passed to the function are known at compile-time.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估发生在运行时，尽管传递给函数的参数数量和类型在编译时是已知的。
- en: Variadic functions implemented in this manner are not type-safe. The `va_` macros
    perform low-memory manipulation and type-casts are done in `va_arg` at runtime.
    These could lead to runtime exceptions.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以这种方式实现的变长函数不是类型安全的。`va_` 宏执行低内存操作，并且在运行时 `va_arg` 中进行类型转换。这可能导致运行时异常。
- en: These variadic functions require specifying in some way the number of variable
    arguments. In the implementation of the earlier `min` function, there is a first
    parameter that indicates the number of arguments. The `printf`-like functions
    take a formatting string from which the number of expected arguments is determined.
    The `printf` function, for example, evaluates and then ignores additional arguments
    (if more are supplied than the number specified in the formatting string) but
    has undefined behavior if fewer arguments are supplied.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些可变参数函数需要以某种方式指定可变参数的数量。在早期 `min` 函数的实现中，有一个参数表示参数的数量。类似于 `printf` 的函数从格式化字符串中获取一个格式化字符串，从而确定期望的参数数量。例如，`printf`
    函数会评估并忽略额外的参数（如果提供的参数多于格式化字符串中指定的数量），但如果提供的参数少于格式化字符串中指定的数量，则具有未定义的行为。
- en: In addition to all these things, only functions could be variadic, prior to
    C++11\. However, there are classes that could also benefit from being able to
    have a variable number of data members. Typical examples are the `tuple` class,
    which represents a fixed-size collection of heterogeneous values, and `variant`,
    which is a type-safe union.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 除了所有这些之外，在 C++11 之前，只有函数可以是可变的。然而，有一些类也可以从能够有可变数量的数据成员中受益。典型的例子是 `tuple` 类，它表示一组固定大小的异构值集合，以及
    `variant`，它是一个类型安全的联合体。
- en: Variadic templates help address all these issues. They are evaluated at compile-time,
    are type-safe, do not require macros, do not require explicitly specifying the
    number of arguments, and we can write both variadic function templates and variadic
    class templates. Moreover, we also have variadic variable templates and variadic
    alias templates.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 可变模板有助于解决所有这些问题。它们在编译时评估，是类型安全的，不需要宏，不需要显式指定参数数量，并且我们可以编写可变函数模板和可变类模板。此外，我们还有可变变量模板和可变别名模板。
- en: In the next section, we will start looking into variadic function templates.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将开始探讨可变参数模板函数。
- en: Variadic function templates
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变参数模板函数
- en: Variadic function templates are template functions with a variable number of
    arguments. They borrow the use of the ellipsis (`...`) for specifying a pack of
    arguments, which can have different syntax depending on its nature.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 可变参数模板函数是具有可变数量参数的模板函数。它们借用省略号（`...`）的使用来指定参数包，其语法可能因性质不同而不同。
- en: 'To understand the fundamentals for variadic function templates, let''s start
    with an example that rewrites the previous `min` function:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解可变参数模板函数的基本原理，让我们从一个重写之前 `min` 函数的例子开始：
- en: '[PRE44]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: What we have here are two overloads for the `min` function. The first is a function
    template with two parameters that returns the smallest of the two arguments. The
    second is a function template with a variable number of arguments that recursively
    calls itself with an expansion of the parameters pack. Although variadic function
    template implementations look like using some sort of compile-time recursion mechanism
    (in this case the overload with two parameters acting as the end case), in fact,
    they're only relying on overloaded functions, instantiated from the template and
    the set of provided arguments.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个 `min` 函数的重载。第一个是一个有两个参数的函数模板，返回两个参数中最小的一个。第二个是一个具有可变数量参数的函数模板，它递归地调用自身，并扩展参数包。尽管可变参数模板函数的实现看起来像使用了某种编译时递归机制（在这种情况下，两个参数的重载作为结束情况），但实际上，它们只是依赖于重载函数，这些函数是从模板和提供的参数集合实例化的。
- en: 'The ellipsis (`...`) is used in three different places, with different meanings,
    in the implementation of a variadic function template, as can be seen in our example:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在可变参数模板函数的实现中，省略号（`...`）被用于三个不同的地方，具有不同的含义，如我们的示例所示：
- en: To specify a pack of parameters in the template parameters list, as in `typename...
    Args`. This is called a **template parameter pack**. Template parameter packs
    can be defined for type templates, non-type templates, and template template parameters.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模板参数列表中指定一组参数，例如 `typename... Args`。这被称为**模板参数包**。模板参数包可以用于类型模板、非类型模板和模板模板参数。
- en: To specify a pack of parameters in the function parameters list, as in `Args...
    args`. This is called a **function parameter pack**.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数参数列表中指定一组参数，例如 `Args... args`。这被称为**函数参数包**。
- en: To expand a pack in the body of a function, as in `args…`, seen in the call
    `min(args…)`. This is called a **parameter pack expansion**. The result of such
    an expansion is a comma-separated list of zero or more values (or expressions).
    This topic will be covered in more detail in the next section.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数体中展开一个包，如`args…`在`min(args…)`调用中看到的那样。这被称为**参数包展开**。这种展开的结果是一个由逗号分隔的零个或多个值（或表达式）的列表。这个主题将在下一节中更详细地介绍。
- en: 'From the call `min(1, 5, 3, -4, 9)`, the compiler is instantiating a set of
    overloaded functions with 5, 4, 3, and 2 arguments. Conceptually, it is the same
    as having the following set of overloaded functions:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 从调用`min(1, 5, 3, -4, 9)`开始，编译器实例化了一组具有5、4、3和2个参数的重载函数。从概念上讲，它等同于以下一组重载函数：
- en: '[PRE61]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'As a result, `min(1, 5, 3, -4, 9)` expands to `min(1, min(5, min(3, min(-4,
    9))))`. This can raise questions about the performance of variadic templates.
    In practice, however, the compilers perform a lot of optimizations, such as inlining
    as much as possible. The result is that, in practice, when optimizations are enabled,
    there will be no actual function calls. You can use online resources, such as
    `min` is the variadic function template with the implementation shown earlier):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`min(1, 5, 3, -4, 9)`展开为`min(1, min(5, min(3, min(-4, 9))))`。这可能会引发关于变长模板性能的问题。然而，在实践中，编译器会执行大量的优化，例如尽可能地进行内联。结果是，当启用优化时，实际上将不会有函数调用。您可以使用在线资源，例如`min`是具有前面所示实现的变长函数模板）：
- en: '[PRE77]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Compiling this with GCC 11.2 with the `-O` flag for optimizations produces
    the following assembly code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GCC 11.2编译器，带有`-O`标志进行优化编译，会产生以下汇编代码：
- en: '[PRE81]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: You don't need to be an expert in assembly to understand what's happening here.
    The evaluation of the call to `min(1, 5, 3, -4, 9)` is done at compile-time and
    the result, `-4`, is loaded directly into the ESI register. There are no runtime
    calls, in this particular case, or computation, since everything is known at compile-time.
    Of course, that is not necessarily always the case.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您不需要是汇编语言专家就能理解这里发生的事情。对`min(1, 5, 3, -4, 9)`的调用是在编译时评估的，结果`-4`直接加载到ESI寄存器。在这个特定的情况下，没有运行时调用或计算，因为所有内容都是在编译时已知的。当然，这并不一定总是如此。
- en: 'The following snippet shows an invocation on the `min` function template that
    cannot be evaluated at compile-time because its arguments are only known at runtime:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了`min`函数模板的一个调用，由于它的参数仅在运行时才知道，因此无法在编译时评估：
- en: '[PRE89]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'This time, the assembly code generated is the following (only showing here
    the code for the call to the `min` function):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，生成的汇编代码如下（这里只展示了调用`min`函数的代码）：
- en: '[PRE95]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: We can see from this listing that the compiler has inlined all the calls to
    the `min` overloads. There is only a series of instructions for loading values
    into registers, comparisons of register values, and jumps based on the comparison
    result, but there are no function calls.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个列表中我们可以看到，编译器已经内联了所有对`min`重载的调用。这里只有一系列将值加载到寄存器中的指令、比较寄存器值以及基于比较结果的跳转，但没有函数调用。
- en: 'When optimizations are disabled, function calls do occur. We can trace these
    calls that occur during the invocation of the `min` function by using compiler-specific
    macros. GCC and Clang provide a macro called `__PRETTY_FUNCTION__` that contains
    the signature of a function and its name. Similarly, Visual C++ provides a macro,
    called `__FUNCSIG__`, that does the same. These could be used within the body
    of a function to print its name and signature. We can use them as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当禁用优化时，函数调用仍然会发生。我们可以通过使用编译器特定的宏来追踪在调用`min`函数期间发生的这些调用。GCC和Clang提供了一个名为`__PRETTY_FUNCTION__`的宏，其中包含函数的签名和名称。同样，Visual
    C++提供了一个名为`__FUNCSIG__`的宏，它执行相同的功能。这些可以在函数体内部使用来打印其名称和签名。我们可以如下使用它们：
- en: '[PRE111]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'The result of the execution of this program, when compiled with Clang, is the
    following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Clang编译此程序时，执行结果如下：
- en: '[PRE135]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'On the other hand, when compiled with Visual C++, the output is the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当使用Visual C++编译时，输出如下：
- en: '[PRE136]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Although the way the signature is formatted is significantly different between
    Clang/GCC on one hand and VC++ on the other hand, they all show the same: first,
    an overloaded function with five parameters is called, then one with four parameters,
    then one with three, and, in the end, there are four calls to the overload with
    two parameters (which marks the end of the expansion).'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管签名格式在Clang/GCC和VC++之间有显著差异，但它们都显示了相同的情况：首先调用具有五个参数的重载函数，然后是四个参数的函数，然后是三个参数的函数，最后有四个调用具有两个参数的重载函数（这标志着展开的结束）。
- en: Understanding the expansion of parameter packs is key to understanding variadic
    templates. Therefore, we'll explore this topic in detail in the next section.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 理解参数包的展开是理解变长模板的关键。因此，我们将在下一节详细探讨这个主题。
- en: Parameter packs
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数包
- en: 'A template or function parameter pack can accept zero, one, or more arguments.
    The standard does not specify any upper limit for the number of arguments, but
    in practice, compilers may have some. What the standard does is recommend minimum
    values for these limits but it does not require any compliance on them. These
    limits are as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 模板或函数参数包可以接受零个、一个或多个参数。标准没有指定参数数量的上限，但在实践中，编译器可能有一些限制。标准所做的是推荐这些限制的最小值，但不要求对这些限制有任何遵守。这些限制如下：
- en: For a function parameter pack, the maximum number of arguments depends on the
    limit of arguments for a function call, which is recommended to be at least 256.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于函数参数包，最大参数数量取决于函数调用参数的限制，建议至少为256。
- en: For a template parameter pack, the maximum number of arguments depends on the
    limit of template parameters, which is recommended to be at least 1,024.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于模板参数包，最大参数数量取决于模板参数的限制，建议至少为1,024。
- en: The number of arguments in a parameter pack can be retrieved at compile time
    with the `sizeof…` operator. This operator returns a `constexpr` value of the
    `std::size_t` type. Let's see this at work in a couple of examples.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 参数包中的参数数量可以在编译时使用`sizeof...`运算符检索。此运算符返回`std::size_t`类型的`constexpr`值。让我们通过几个示例来看看它是如何工作的。
- en: 'In the first example, the `sizeof…` operator is used to implement the end of
    the recursion pattern of the variadic function template `sum` with the help of
    a `constexpr if` statement. If the number of the arguments in the parameter pack
    is zero (meaning there is a single argument to the function) then we are processing
    the last argument, so we just return the value. Otherwise, we add the first argument
    to the sum of the remaining ones. The implementation looks as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例中，`sizeof...`运算符用于通过`constexpr if`语句帮助实现变长函数模板`sum`的递归模式结束。如果参数包中的参数数量为零（意味着函数只有一个参数），那么我们正在处理最后一个参数，所以我们只需返回值。否则，我们将第一个参数添加到剩余参数的总和中。实现如下：
- en: '[PRE137]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'This is semantically equivalent, but on the other hand more concise, than the
    following classical approach for the variadic function template implementation:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这与以下经典方法在语义上是等价的，但另一方面更简洁，用于变长函数模板的实现：
- en: '[PRE145]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Notice that `sizeof…(args)` (the function parameter pack) and `sizeof…(Args)`
    (the template parameter pack) return the same value. On the other hand, `sizeof…(args)`
    and `sizeof(args)...` are not the same thing. The former is the `sizeof` operator
    used on the parameter pack `args`. The latter is an expansion of the parameter
    pack `args` on the `sizeof` operator. These are both shown in the following example:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`sizeof…(args)`（函数参数包）和`sizeof…(Args)`（模板参数包）返回相同的值。另一方面，`sizeof…(args)`和`sizeof(args)...`不是同一回事。前者是应用于参数包`args`的`sizeof`运算符。后者是在`sizeof`运算符上展开的参数包`args`。这两个都在以下示例中展示：
- en: '[PRE155]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'In this snippet, `sizeof…(Ts)` evaluates to `4` at compile-time, while `sizeof(Ts)...`
    is expanded to the following comma-separated pack of arguments: `sizeof(short),
    sizeof(int), sizeof(long), sizeof(long long)`. Conceptually, the preceding function
    template, `get_type_sizes`, is equivalent to the following function template with
    four template parameters:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，`sizeof…(Ts)`在编译时评估为`4`，而`sizeof(Ts)...`展开为以下逗号分隔的参数包：`sizeof(short),
    sizeof(int), sizeof(long), sizeof(long long)`。从概念上讲，前面的函数模板`get_type_sizes`等同于以下具有四个模板参数的函数模板：
- en: '[PRE162]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'Typically, the parameter pack is the trailing parameter of a function or template.
    However, if the compiler can deduce the arguments, then a parameter pack can be
    followed by other parameters including more parameter packs. Let''s consider the
    following example:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，参数包是函数或模板的尾随参数。然而，如果编译器可以推断出参数，那么参数包后面可以跟有其他参数，包括更多的参数包。让我们考虑以下示例：
- en: '[PRE170]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'This function is supposed to take two sets of elements of possibly different
    types and do something with them. It can be invoked such as in the following examples:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数应该接受两组可能不同类型的元素，并对它们进行一些操作。它可以像以下示例那样调用：
- en: '[PRE176]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'For the first call, the `args1` pack is specified at the function call (as
    in `multipacks<int>`) and contains `1`, and `args2` is deduced to be `2, 3, 4,
    5, 6` from the function arguments. Similarly, for the second call, the two packs
    will have an equal number of arguments, more precisely `1, 2, 3` and `3, 4, 6`.
    For the last call, the first pack contains all the elements, and the second pack
    is empty. In all these examples, all the elements are of the `int` type. However,
    in the following examples, the two packs contain elements of different types:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一次调用，`args1`包在函数调用时指定（如`multipacks<int>`所示），包含`1`，而`args2`被推断出包含`2, 3, 4,
    5, 6`。同样，对于第二次调用，两个包将具有相同数量的参数，更确切地说，是`1, 2, 3`和`3, 4, 6`。对于最后一次调用，第一个包包含所有元素，而第二个包为空。在这些所有示例中，所有元素都是`int`类型。然而，在以下示例中，两个包包含不同类型的元素：
- en: '[PRE184]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: For the first call, the `args1` pack will contain the integers `1, 2` and the
    `args2` pack will be deduced to contain the double values `4.0, 5.0, 6.0`. Similarly,
    for the second call, the `args1` pack will be `1, 2, 3` and the `args2` pack will
    contain `4.0, 5.0, 6.0`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一次调用，`args1`包将包含整数`1, 2`，而`args2`将被推断出包含双精度值`4.0, 5.0, 6.0`。同样，对于第二次调用，`args1`包将是`1,
    2, 3`，而`args2`将包含`4.0, 5.0, 6.0`。
- en: 'However, if we change the function template `multipacks` a bit by requiring
    that the packs be of equal size, then only some of the calls shown earlier would
    still be possible. This is shown in the following example:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们稍微修改函数模板`multipacks`，要求包的大小相等，那么只有之前显示的一些调用仍然可能。这将在以下示例中显示：
- en: '[PRE186]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: In this snippet, only the second and the sixth calls are valid. In these two
    cases, the two deduced packs have three elements each. In all the other cases,
    as resulting from the prior example, the packs have different sizes and the `static_assert`
    statement will generate an error at compile-time.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，只有第二个和第六个调用是有效的。在这两种情况下，两个推断出的包各有三个元素。在其他所有情况下，如前一个示例所示，包的大小不同，`static_assert`语句将在编译时生成错误。
- en: 'Multiple parameter packs are not specific to variadic function templates. They
    can also be used for variadic class templates in partial specialization, provided
    that the compiler can deduce the template arguments. To exemplify this, we''ll
    consider the case of a class template that represents a pair of function pointers.
    The implementation should allow for storing pointers to any function. To implement
    this, we define a primary template, called here `func_pair`, and a partial specialization
    with four template parameters:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 多个参数包不仅限于变长函数模板。它们也可以用于部分特化的变长类模板，前提是编译器可以推断出模板参数。为了举例说明，我们将考虑一个表示函数指针对的类模板的情况。实现应该允许存储任何函数的指针。为此，我们定义了一个主模板，称为`func_pair`，以及一个具有四个模板参数的部分特化：
- en: A type template parameter for the return type of the first function
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个函数返回类型的类型模板参数
- en: A template parameter pack for the parameter types of the first function
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个函数的参数类型的模板参数包
- en: A second type template parameter for the return type of the second function
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个函数返回类型的第二个类型模板参数
- en: A second template parameter pack for the parameter types of the second function
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个函数的参数类型的第二个模板参数包
- en: 'The `func_pair` class template is shown in the next listing:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`func_pair`类模板在下一列表中显示：'
- en: '[PRE200]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: 'To demonstrate the use of this class template, let''s also consider the following
    two functions:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这个类模板的使用，让我们也考虑以下两个函数：
- en: '[PRE209]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: 'We can instantiate the `func_pair` class template and use it to call these
    two functions as shown in the following snippet:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以实例化`func_pair`类模板，并使用它来调用以下代码片段中所示的两个函数：
- en: '[PRE217]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: Parameter packs can be expanded in a variety of contexts and this will make
    the topic of the next section.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 参数包可以在各种上下文中展开，这将使下一节的主题。
- en: Understanding parameter packs expansion
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解参数包展开
- en: 'Parameter packs can appear in a multitude of contexts. The form of their expansion
    may depend on this context. These possible contexts are listed ahead along with
    examples:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 参数包可以出现在多种上下文中。它们的展开形式可能取决于此上下文。以下列出了可能的上下文及其示例：
- en: '**Template parameter list**: This is for when you specify parameters for a
    template:'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模板参数列表**：这是在指定模板参数时使用的：'
- en: '[PRE221]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '**Template argument list**: This is when you specify arguments for a template:'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模板参数列表**：这是在指定模板参数时使用的：'
- en: '[PRE222]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '**Function parameter list**: This is for when you specify parameters for a
    function template:'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数参数列表**：这是在指定函数模板的参数时使用的：'
- en: '[PRE223]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '**Function argument list**: When the expansion pack appears inside the parenthesis
    of a function call, the largest expression or brace initialization list to the
    left of the ellipsis is the pattern that is expanded:'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数参数列表**：当扩展包出现在函数调用括号内时，省略号左侧的最大表达式或花括号初始化列表是展开的模式：'
- en: '[PRE224]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '**Parenthesized initializers**: When the expansion pack appears inside the
    parenthesis of a direct initializer, function-style cast, member initializer,
    new expression, and other similar contexts, the rules are the same as for the
    context of function argument lists:'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**括号初始化器**：当扩展包出现在直接初始化器、函数样式转换、成员初始化器、new 表达式和其他类似上下文的括号内时，规则与函数参数列表的上下文相同：'
- en: '[PRE225]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '**Brace-enclosed initializers**: This is when you perform initialization using
    the brace notation:'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**花括号包围的初始化器**：这是使用花括号符号执行初始化的情况：'
- en: '[PRE226]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '**Base specifiers and member initializer lists**: A pack expansion may specify
    the list of base classes in a class declaration. In addition, it may also appear
    in the member initializer list, as this may be necessary to call the constructors
    of the base classes:'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基指定符和成员初始化器列表**：包展开可以指定类声明中的基类列表。此外，它还可以出现在成员初始化器列表中，因为这可能是调用基类构造函数所必需的：'
- en: '[PRE227]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '`using` declaration. This is demonstrated based on the previous example:'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`using` 声明。这基于前面的示例进行演示：'
- en: '[PRE228]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '**Lambda captures**: The capture clause of a lambda expression may contain
    a pack expansion, as shown in the following example:'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Lambda 捕获**：Lambda 表达式的捕获子句可以包含一个包展开，如下例所示：'
- en: '[PRE229]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '**Fold expressions**: These will be discussed in detail in the following section
    in this chapter:'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**折叠表达式**：这些将在本章接下来的部分中详细讨论：'
- en: '[PRE230]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE230]'
- en: 'The `sizeof…` operator: Examples have already been shown earlier in this section.
    Here is one again:'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sizeof…` 操作符：本节前面已经展示了示例。这里再次展示一个：'
- en: '[PRE231]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '`alignas` specifiers applied to the same declaration. The parameter pack can
    be either a type or non-type pack. Examples for both cases are listed here:'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用到相同声明的 `alignas` 指定符。参数包可以是类型包或非类型包。以下列出了两种情况下的示例：
- en: '[PRE232]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '**Attribute list**: This is not supported by any compiler yet.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性列表**：目前没有任何编译器支持。'
- en: Now that we have learned more about parameter packs and their expansion we can
    move forward and explore variadic class templates.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对参数包及其展开有了更多的了解，我们可以继续前进，探索可变参数类模板。
- en: Variadic class templates
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变参数类模板
- en: Class templates may also have a variable number of template arguments. This
    is key to building some categories of types, such as `tuple` and `variant`, that
    are available in the standard library. In this section, we will see how we could
    write a simple implementation for a `tuple` class. A tuple is a type that represents
    a fixed-size collection of heterogeneous values.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 类模板也可以有可变数量的模板参数。这是构建某些类型类别（如标准库中可用的 `tuple` 和 `variant`）的关键。在本节中，我们将看到如何编写一个简单的
    `tuple` 类实现。元组是一种表示固定大小异构值集合的类型。
- en: 'When implementing variadic function templates we used a recursion pattern with
    two overloads, one for the general case and one for ending the recursion. The
    same approach has to be taken with variadic class templates, except that we need
    to use specialization for this purpose. Next, you can see a minimal implementation
    for a tuple:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现可变函数模板时，我们使用了具有两个重载的递归模式，一个用于通用情况，另一个用于结束递归。对于可变参数类模板，也需要采取相同的方法，但我们需要为此目的使用特化。接下来，你可以看到对元组的最小实现：
- en: '[PRE233]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: 'The first class is the primary template. It has two template parameters: a
    type template and a parameter pack. This means, at the minimum, there must be
    one type specified for instantiating this template. The primary template tuple
    has two member variables: `value`, of the `T` type, and `rest`, of type `tuple<Ts…>`.
    This is an expansion of the rest of the template arguments. This means a tuple
    of `N` elements will contain the first element and another tuple; this second
    tuple, in turn, contains the second element and yet another tuple; this third
    nested tuple contains the rest. And this pattern continues until we end up with
    a tuple with a single element. This is defined by the partial specialization `tuple<T>`.
    Unlike the primary template, this specialization does not aggregate another tuple
    object.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个类是基本模板。它有两个模板参数：一个类型模板和一个参数包。这意味着，至少必须指定一个类型来实例化此模板。基本模板的元组有两个成员变量：`value`，类型为
    `T`，和 `rest`，类型为 `tuple<Ts…>`。这是模板参数剩余部分的展开。这意味着一个包含 `N` 个元素的元组将包含第一个元素和另一个元组；这个第二个元组反过来又包含第二个元素和另一个元组；这个第三个嵌套元组包含剩余部分。这种模式一直持续到我们最终得到一个只有一个元素的元组。这是由部分特化
    `tuple<T>` 定义的。与基本模板不同，这个特化不聚合另一个元组对象。
- en: 'We can use this simple implementation to write code like the following:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个简单的实现来编写如下代码：
- en: '[PRE254]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: 'Although this works, accessing elements through the `rest` member, such as
    in `three.rest.rest.value`, is very cumbersome. And the more elements a tuple
    has the more difficult it is to write code in this way. Therefore, we''d like
    to use some helper function to simplify accessing the elements of a tuple. The
    following is a snippet of how the previous could be transformed:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可行，但通过 `rest` 成员访问元素，例如在 `three.rest.rest.value` 中，非常繁琐。元组中的元素越多，以这种方式编写代码就越困难。因此，我们希望使用一些辅助函数来简化访问元组元素。以下是如何将之前的代码转换的片段：
- en: '[PRE263]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: 'Here, `get<N>` is a variadic function template that takes a tuple as an argument
    and returns a reference to the element at the `N` index in the tuple. Its prototype
    could look like the following:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`get<N>` 是一个变长函数模板，它接受一个元组作为参数，并返回元组中 `N` 索引处的元素引用。其原型可能如下所示：
- en: '[PRE269]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: 'The template arguments are the index and a parameter pack of the tuple types.
    Its implementation, however, requires some helper types. First, we need to know
    what the type of the element is at the `N` index in the tuple. This can be retrieved
    with the help of the following `nth_type` variadic class template:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 模板参数是元组类型的索引和参数包。然而，其实施需要一些辅助类型。首先，我们需要知道元组中 `N` 索引处的元素类型。这可以通过以下 `nth_type`
    变长类模板来检索：
- en: '[PRE271]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '[PRE274]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '[PRE275]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: '[PRE276]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[PRE281]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: 'Again, we have a primary template that uses recursive inheritance, and the
    specialization for the index 0\. The specialization defines an alias called `value_type`
    for the first type template (which is the head of the list of template arguments).
    This type is only used as a mechanism for determining the type of a tuple element.
    We need another variadic class template for retrieving the value. This is shown
    in the following listing:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们有一个使用递归继承的基本模板，以及针对索引 0 的特化。特化定义了一个名为 `value_type` 的别名，用于第一个类型模板（这是模板参数列表的头部）。这个类型仅用作确定元组元素类型的机制。我们需要另一个变长类模板来检索值。这将在下面的列表中展示：
- en: '[PRE282]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: '[PRE283]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: '[PRE288]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: '[PRE293]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: '[PRE294]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: '[PRE295]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '[PRE296]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '[PRE297]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '[PRE298]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: '[PRE299]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: '[PRE300]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: We can see here the same recursive pattern, with a primary template and an explicit
    specialization. The class template is called `getter` and has a single template
    parameter, which is a non-type template parameter. This represents the index of
    the tuple element we want to access. This class template has a static member function
    called `get`. This is a variadic function template. The implementation in the
    primary template calls the `get` function with the `rest` member of the tuple
    as an argument. On the other hand, the implementation of the explicit specialization
    returns the reference to the member value of the tuple.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这里相同的递归模式，有一个基本模板和一个显式特化。类模板被称为 `getter`，它有一个单一的模板参数，这是一个非类型模板参数。这代表我们想要访问的元组元素的索引。这个类模板有一个名为
    `get` 的静态成员函数。这是一个变长函数模板。基本模板中的实现使用元组的 `rest` 成员作为参数调用 `get` 函数。另一方面，显式特化的实现返回元组成员值的引用。
- en: 'With all these defined, we can now provide an actual implementation for the
    helper variadic function template `get`. This implementation relies on the `getter`
    class template and calls its `get` variadic function template:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了所有这些之后，我们现在可以提供一个实际的实现来为辅助的可变参数函数模板`get`。这个实现依赖于`getter`类模板，并调用其`get`可变参数函数模板：
- en: '[PRE301]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: '[PRE302]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: '[PRE303]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: '[PRE304]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: '[PRE305]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: '[PRE306]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: 'If this example seems a little bit complicated, perhaps analyzing it step by
    step will help you better understand how it all works. Therefore, let''s start
    with the following snippet:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个例子看起来有点复杂，也许逐步分析它将有助于你更好地理解它是如何工作的。因此，让我们从以下片段开始：
- en: '[PRE307]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: '[PRE308]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: 'We will use the `cppinsights.io` web tools to check the template instantiations
    that occur from this snippet. The first to look at is the class template `tuple`.
    We have a primary template and several specializations, as follows:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`cppinsights.io`网络工具来检查从这个片段中发生的模板实例化。首先查看的是类模板`tuple`。我们有一个主模板和几个特化，如下所示：
- en: '[PRE309]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: '[PRE310]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: '[PRE311]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: '[PRE312]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: '[PRE313]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: '[PRE314]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: '[PRE315]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: '[PRE316]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: '[PRE317]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: '[PRE318]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: '[PRE319]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: '[PRE320]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: '[PRE321]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: '[PRE322]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: '[PRE323]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: '[PRE324]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: '[PRE325]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: '[PRE326]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: '[PRE327]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: '[PRE328]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: '[PRE329]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: '[PRE330]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: '[PRE331]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: '[PRE332]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: '[PRE333]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: '[PRE334]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: '[PRE335]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: '[PRE336]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: '[PRE337]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: '[PRE338]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: '[PRE339]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: '[PRE340]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: '[PRE341]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: '[PRE342]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: '[PRE343]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: '[PRE344]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: '[PRE345]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: '[PRE346]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: '[PRE347]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: '[PRE348]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: '[PRE349]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: '[PRE350]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: '[PRE351]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: '[PRE352]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE352]'
- en: '[PRE353]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE353]'
- en: '[PRE354]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE354]'
- en: 'The `tuple<int, double, char>` structure contains an `int` and a `tuple<double,
    char>`, which contains a `double` and a `tuple<char>`, which, in turn, contains
    a `char` value. This last class represents the end of the recursive definition
    of the tuple. This can be conceptually represented graphically as follows:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '`tuple<int, double, char>`结构包含一个`int`和一个`tuple<double, char>`，它包含一个`double`和一个`tuple<char>`，后者又包含一个`char`值。这个最后的类代表了元组递归定义的末尾。这可以概念性地用以下图形表示：'
- en: '![Figure 3.1 – An example tuple'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.1 – 一个示例元组'
- en: '](img/Figure_3.1_B18367.jpg)'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.1 – 一个示例元组'
- en: Figure 3.1 – An example tuple
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – 一个示例元组
- en: 'Next, we have the `nth_type` class template, for which, again, we have a primary
    template and several specializations, as follows:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有`nth_type`类模板，对于它，我们再次有一个主模板和几个特化，如下所示：
- en: '[PRE355]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE355]'
- en: '[PRE356]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: '[PRE357]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE357]'
- en: '[PRE358]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE358]'
- en: '[PRE359]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE359]'
- en: '[PRE360]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: '[PRE361]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: '[PRE362]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: '[PRE363]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE363]'
- en: '[PRE364]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: '[PRE365]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE365]'
- en: '[PRE366]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE366]'
- en: '[PRE367]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: '[PRE368]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE368]'
- en: '[PRE369]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE369]'
- en: '[PRE370]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE370]'
- en: '[PRE371]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: '[PRE372]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE372]'
- en: '[PRE373]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: '[PRE374]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: '[PRE375]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: '[PRE376]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: '[PRE377]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE377]'
- en: The `nth_type<2, int, double, char>` specialization is derived from `nth_type<1,
    double, char>`, which in turn is derived from `nth_type<0, char>`, which is the
    last base class in the hierarchy (the end of the recursive hierarchy).
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '`nth_type<2, int, double, char>`特化是从`nth_type<1, double, char>`派生的，后者又从`nth_type<0,
    char>`派生，它是层次结构中的最后一个基类（递归层次结构的末尾）。'
- en: 'The `nth_type` structure is used as the return type in the `getter` helper
    class template, which is instantiated as follows:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '`nth_type`结构在`getter`辅助类模板中用作返回类型，其实例化如下：'
- en: '[PRE378]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: '[PRE379]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: '[PRE380]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: '[PRE381]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE381]'
- en: '[PRE382]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: '[PRE383]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: '[PRE384]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE384]'
- en: '[PRE385]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE385]'
- en: '[PRE386]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE386]'
- en: '[PRE387]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE387]'
- en: '[PRE388]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE388]'
- en: '[PRE389]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE389]'
- en: '[PRE390]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE390]'
- en: '[PRE391]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE391]'
- en: '[PRE392]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE392]'
- en: '[PRE393]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE393]'
- en: '[PRE394]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE394]'
- en: '[PRE395]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE395]'
- en: '[PRE396]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE396]'
- en: '[PRE397]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE397]'
- en: '[PRE398]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE398]'
- en: '[PRE399]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE399]'
- en: '[PRE400]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE400]'
- en: '[PRE401]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE401]'
- en: '[PRE402]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE402]'
- en: '[PRE403]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE403]'
- en: '[PRE404]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE404]'
- en: '[PRE405]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE405]'
- en: '[PRE406]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE406]'
- en: '[PRE407]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE407]'
- en: '[PRE408]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE408]'
- en: '[PRE409]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE409]'
- en: '[PRE410]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE410]'
- en: '[PRE411]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE411]'
- en: '[PRE412]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE412]'
- en: '[PRE413]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE413]'
- en: '[PRE414]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE414]'
- en: '[PRE415]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE415]'
- en: '[PRE416]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE416]'
- en: '[PRE417]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE417]'
- en: '[PRE418]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE418]'
- en: '[PRE419]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE419]'
- en: '[PRE420]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE420]'
- en: '[PRE421]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE421]'
- en: '[PRE422]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE422]'
- en: '[PRE423]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE423]'
- en: 'Lastly, the `get` function template that we use to retrieve the value of an
    element of a `tuple` is defined as follows:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用的`get`函数模板，用于检索`tuple`元素的值，定义如下：
- en: '[PRE424]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE424]'
- en: '[PRE425]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE425]'
- en: '[PRE426]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE426]'
- en: '[PRE427]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE427]'
- en: '[PRE428]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE428]'
- en: '[PRE429]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE429]'
- en: '[PRE430]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE430]'
- en: '[PRE431]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE431]'
- en: '[PRE432]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE432]'
- en: '[PRE433]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE433]'
- en: '[PRE434]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE434]'
- en: '[PRE435]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE435]'
- en: 'Should there be more calls to the `get` function more specializations of `get`
    would exist. For instance, for `get<1>(three)`, the following specialization would
    be added:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对`get`函数的调用更多，将存在更多的`get`特化。例如，对于`get<1>(three)`，将添加以下特化：
- en: '[PRE436]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE436]'
- en: '[PRE437]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE437]'
- en: '[PRE438]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE438]'
- en: '[PRE439]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE439]'
- en: '[PRE440]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE440]'
- en: '[PRE441]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE441]'
- en: This example helped us demonstrate how to implement variadic class templates
    with a primary template for the general case and a specialization for the end
    case of the variadic recursion.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子帮助我们展示了如何实现具有主模板和变体递归的末尾特化的可变参数类模板。
- en: You have probably noticed the use of the keyword `typename` to prefix the `nth_type<N,
    Ts...>::value_type` type, which is a **dependent type**. In C++20, this is no
    longer necessary. However, this topic will be addressed in detail in [*Chapter
    4*](B18367_04_ePub.xhtml#_idTextAnchor064), *Advanced Template Concepts*.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了使用关键字`typename`作为前缀来修饰`nth_type<N, Ts...>::value_type`类型，这是一个**依赖类型**。在C++20中，这不再是必要的。然而，这个主题将在[*第4章*](B18367_04_ePub.xhtml#_idTextAnchor064)中详细讨论，*高级模板概念*。
- en: Because implementing variadic templates is often verbose and can be cumbersome,
    the C++17 standard added **fold expressions** to ease this task. We will explore
    this topic in the next section.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 由于实现可变参数模板通常很冗长且可能很繁琐，C++17标准添加了**折叠表达式**来简化这项任务。我们将在下一节探讨这个主题。
- en: Fold expressions
  id: totrans-550
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 折叠表达式
- en: 'A `sum` that returned the sum of all its supplied arguments. For convenience,
    we will show it again here:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 一个返回所有传入参数总和的`sum`函数。为了方便，我们在这里再次展示它：
- en: '[PRE442]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE442]'
- en: '[PRE443]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE443]'
- en: '[PRE444]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE444]'
- en: '[PRE445]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE445]'
- en: '[PRE446]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE446]'
- en: '[PRE447]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE447]'
- en: '[PRE448]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE448]'
- en: '[PRE449]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE449]'
- en: '[PRE450]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE450]'
- en: '[PRE451]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE451]'
- en: 'With fold expressions, this implementation that requires two overloads can
    be reduced to the following form:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 使用折叠表达式，这个需要两个重载的实现可以简化为以下形式：
- en: '[PRE452]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE452]'
- en: '[PRE453]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE453]'
- en: '[PRE454]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE454]'
- en: '[PRE455]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE455]'
- en: '[PRE456]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE456]'
- en: 'There is no need for overloaded functions anymore. The expression `(... + args)`
    represents the fold expression, which upon evaluation becomes `((((arg0 + arg1)
    + arg2) + … ) + argN)`. The enclosing parentheses are part of the fold expression.
    We can use this new implementation, just as we would use the initial one, as follows:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 不再需要重载函数。表达式`(... + args)`代表折叠表达式，在评估时变为`((((arg0 + arg1) + arg2) + … ) + argN)`。括号是折叠表达式的一部分。我们可以像使用初始实现一样使用这个新实现，如下所示：
- en: '[PRE457]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE457]'
- en: '[PRE458]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE458]'
- en: '[PRE459]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE459]'
- en: '[PRE460]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE460]'
- en: '[PRE461]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE461]'
- en: '[PRE462]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE462]'
- en: 'There are four different types of folds, which are listed as follows:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种不同的折叠类型，如下列出：
- en: '![Table 3.1'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '![Table 3.1](img/B18367_Table_3.1.jpg)'
- en: '](img/B18367_Table_3.1.jpg)'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '![Table 3.1](img/B18367_Table_3.1.jpg)'
- en: Table 3.1
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: Table 3.1
- en: 'In this table, the following names are used:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个表格中，使用了以下名称：
- en: '`pack` is an expression that contains an unexpanded parameter pack, and `arg1`,
    `arg2`, `argN-1`, and `argN` are the arguments contained in this pack.'
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pack`是一个包含未展开参数包的表达式，而`arg1`、`arg2`、`argN-1`和`argN`是这个包中包含的参数。'
- en: '`op` is one of the following binary operators: `+ - * / % ^ & | = < > << >>
    += -= *= /= %= ^= &= |= <<= >>= == != <= >= && || , .* ->*.`'
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`op`是以下二元运算符之一：`+ - * / % ^ & | = < > << >> += -= *= /= %= ^= &= |= <<= >>=
    == != <= >= && || , .* ->*.`'
- en: '`init` is an expression that does not contain an unexpanded parameter pack.'
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init`是一个不包含未展开参数包的表达式。'
- en: 'In a unary fold, if the pack does not contain any elements, only some operators
    are allowed. These are listed in the following table, along with the value of
    the empty pack:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 在一元折叠中，如果包不包含任何元素，则只允许一些运算符。以下表格列出了这些运算符，以及空包的值：
- en: '![Table 3.2'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: '![Table 3.2](img/B18367_Table_3.2.jpg)'
- en: '](img/B18367_Table_3.2.jpg)'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '![Table 3.2](img/B18367_Table_3.2.jpg)'
- en: Table 3.2
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: Table 3.2
- en: 'Unary and binary folds differ in the use of an initialization value, that is
    present only for binary folds. Binary folds have the binary operator repeated
    twice (it must be the same operator). We can transform the variadic function template
    `sum` from using a unary right fold expression into one using a binary right fold
    by including an initialization value. Here is an example:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 一元折叠和二元折叠在初始化值的使用上有所不同，后者才需要初始化值。二元折叠中二元运算符重复两次（必须是相同的运算符）。我们可以通过包含一个初始化值将可变参数函数模板`sum`从使用一元右折叠表达式转换为使用二元右折叠。以下是一个示例：
- en: '[PRE463]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE463]'
- en: '[PRE464]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE464]'
- en: '[PRE465]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE465]'
- en: '[PRE466]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE466]'
- en: '[PRE467]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE467]'
- en: 'One could say there is no difference between the `sum` and `sum_from_zero`
    function templates. That is not actually true. Let''s consider the following invocations:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 有人说`sum`和`sum_from_zero`函数模板之间没有区别。这实际上并不正确。让我们考虑以下调用：
- en: '[PRE468]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE468]'
- en: '[PRE469]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE469]'
- en: Calling `sum` without arguments will produce a compiler error, because unary
    fold expressions (over the operator `+` in this case) must have non-empty expansions.
    However, binary fold expressions do not have this problem, so calling `sum_from_zero`
    without arguments works and the function will return `0`.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 不带参数调用`sum`将产生编译器错误，因为一元折叠表达式（在这种情况下是运算符`+`）必须有非空展开。然而，二元折叠表达式没有这个问题，所以不带参数调用`sum_from_zero`是有效的，并且函数将返回`0`。
- en: 'In these two examples with `sum` and `sum_from_zero`, the parameter pack `args`
    appears directly within the fold expression. However, it can be part of an expression,
    as long as it is not expanded. This is shown in the following example:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个使用`sum`和`sum_from_zero`的示例中，参数包`args`直接出现在折叠表达式中。然而，它可以是表达式的一部分，只要它没有被展开。以下是一个示例：
- en: '[PRE470]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE470]'
- en: '[PRE471]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE471]'
- en: '[PRE472]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE472]'
- en: '[PRE473]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE473]'
- en: '[PRE474]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE474]'
- en: '[PRE475]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE475]'
- en: '[PRE476]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE476]'
- en: '[PRE477]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE477]'
- en: '[PRE478]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE478]'
- en: '[PRE479]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE479]'
- en: 'Here, the parameter pack `args` is part of the `(std::cout << args)` expression.
    This is not a fold expression. A fold expression is `((std::cout << args), ...)`.
    This is a unary left fold over the comma operator. The `printl` and `printr` functions
    can be used as in the following snippet:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，参数包`args`是`(std::cout << args)`表达式的一部分。这不是一个折叠表达式。折叠表达式是`((std::cout << args),
    ...)`。这是一个以逗号运算符为操作符的一元左折叠。可以使用`printl`和`printr`函数，如下所示：
- en: '[PRE480]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE480]'
- en: '[PRE481]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE481]'
- en: In both these cases, the text printed to the console is `dog`. This is because
    the unary left fold expands to `(((std::cout << 'd'), std::cout << 'o'), << std::cout
    << 'g')` and the unary right fold expands to `(std::cout << 'd', (std::cout <<
    'o', (std::cout << 'g')))` and these two are evaluated in the same way. This is
    because a pair of expressions separated by a comma is evaluated left to right.
    This is true for the built-in comma operator. For types that overload the comma
    operator, the behavior depends on how the operator is overloaded. However, there
    are very few corner cases for overloading the comma operator (such as simplifying
    indexing multi-dimensional arrays). Libraries such as `Boost.Assign` and `SOCI`
    overload the comma operator, but, in general, this is an operator you should avoid
    overloading.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，打印到控制台的文字是 `dog`。这是因为一元左折叠展开为 `(((std::cout << 'd'), std::cout << 'o'),
    << std::cout << 'g')`，而一元右折叠展开为 `(std::cout << 'd', (std::cout << 'o', (std::cout
    << 'g')))`，并且这两个表达式以相同的方式评估。这是因为由逗号分隔的表达式是按从左到右的顺序评估的。这对于内置的逗号运算符来说是正确的。对于重载逗号运算符的类型，其行为取决于运算符是如何重载的。然而，重载逗号运算符的角落案例非常少（例如简化多维数组的索引）。例如，`Boost.Assign`
    和 `SOCI` 库重载了逗号运算符，但通常，这是一个你应该避免重载的运算符。
- en: 'Let''s consider another example for using the parameter pack in an expression
    inside a fold expression. The following variadic function template inserts multiple
    values to the end of a `std::vector`:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑另一个例子，在折叠表达式内部的表达式中使用参数包。以下可变参数函数模板将多个值插入到 `std::vector` 的末尾：
- en: '[PRE482]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE482]'
- en: '[PRE483]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE483]'
- en: '[PRE484]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE484]'
- en: '[PRE485]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE485]'
- en: '[PRE486]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE486]'
- en: '[PRE487]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE487]'
- en: The parameter pack `args` is used with the `v.push_back(args)` expression that
    is folded over the comma operator. The unary left fold expression is `(v.push_back(args),
    ...)`.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 参数包 `args` 与 `v.push_back(args)` 表达式一起使用，该表达式通过逗号运算符展开。一元左折叠表达式是 `(v.push_back(args),
    ...)`。
- en: 'Fold expressions have several benefits over the use of recursion to implement
    variadic templates. These benefits are as follows:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用递归实现可变参数模板相比，折叠表达式有几个优点。这些优点如下：
- en: Less and simpler code to write.
  id: totrans-621
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更少且更简单的代码要编写。
- en: Fewer template instantiations, which leads to faster compile times.
  id: totrans-622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更少的模板实例化，这导致编译时间更快。
- en: Potentially faster code since multiple function calls are replaced with a single
    expression. However, this point may not be true in practice, at least not when
    optimizations are enabled. We have already seen that the compilers optimize code
    by removing these function calls.
  id: totrans-623
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于将多个函数调用替换为单个表达式，代码可能更快。然而，在实际上，至少在启用优化时，这一点可能并不成立。我们已经看到编译器通过删除这些函数调用来优化代码。
- en: 'Now that we have seen how to create variadic function templates, variadic class
    templates, and how to use fold expressions, we are left to discuss the other kinds
    of templates that can be variadic: alias templates and variable templates. We
    will start with the former.'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何创建可变函数模板、可变类模板以及如何使用折叠表达式，我们接下来要讨论的是其他可以变元的模板类型：别名模板和变量模板。我们将从前者开始。
- en: Variadic alias templates
  id: totrans-625
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变参数别名模板
- en: 'Everything that can be templatized can also be made variadic. An alias template
    is an alias (another name) for a family of types. A variadic alias template is
    a name for a family of types with a variable number of template parameters. With
    the knowledge accumulated so far, it should be fairly trivial to write alias templates.
    Let''s see an example:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 可以模板化的任何内容也可以使其可变。别名模板是一系列类型的别名（另一个名称）。可变参数别名模板是一系列具有可变数量模板参数的类型名称。根据到目前为止积累的知识，编写别名模板应该是相当简单的。让我们看一个例子：
- en: '[PRE488]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE488]'
- en: '[PRE489]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE489]'
- en: '[PRE490]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE490]'
- en: '[PRE491]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE491]'
- en: '[PRE492]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE492]'
- en: '[PRE493]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE493]'
- en: 'The class template `foo` is variadic and takes at least one type template argument.
    `int_foo`, on the other hand, is only a different name for a family of types instantiated
    from the `foo` type with `int` as the first type template arguments. These could
    be used as follows:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 类模板 `foo` 是可变的，并且至少接受一个类型模板参数。另一方面，`int_foo` 只是 `foo` 类型的一个家族的实例的另一个名称，其中 `int`
    作为第一个类型模板参数。它们可以这样使用：
- en: '[PRE494]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE494]'
- en: '[PRE495]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE495]'
- en: '[PRE496]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE496]'
- en: '[PRE497]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE497]'
- en: In this snippet, `f1` on one hand and `f2` and `f3` on the other are instances
    of different `foo` types, as they are instantiated from different sets of template
    arguments for `foo`. However, `f2` and `f3` are instances of the same type, `foo<int,
    char, double>`, since `int_foo<char, double>` is just an alias for this type.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，`f1` 一方面和 `f2` 和 `f3` 另一方面是不同 `foo` 类型的实例，因为它们是从不同的 `foo` 模板参数集合中实例化的。然而，`f2`
    和 `f3` 是同一类型的实例，即 `foo<int, char, double>`，因为 `int_foo<char, double>` 只是这个类型的别名。
- en: 'A similar example, although a bit more complex, is presented ahead. The standard
    library contains a class template called `std::integer_sequence`, which represents
    a compile-time sequence of integers, along with a bunch of alias templates to
    help create various kinds of such integer sequences. Although the code shown here
    is a simplified snippet, their implementation can, at least conceptually, be as
    follows:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 前面将给出一个类似的例子，虽然稍微复杂一些。标准库中包含一个名为 `std::integer_sequence` 的类模板，它表示一个整数编译时序列，以及一些别名模板，以帮助创建各种这样的整数序列。尽管这里展示的代码是一个简化的片段，但它们的实现至少在概念上可以如下所示：
- en: '[PRE498]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE498]'
- en: '[PRE499]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE499]'
- en: '[PRE500]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE500]'
- en: '[PRE501]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE501]'
- en: '[PRE502]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE502]'
- en: '[PRE503]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE503]'
- en: '[PRE504]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE504]'
- en: '[PRE505]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE505]'
- en: '[PRE506]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE506]'
- en: '[PRE507]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE507]'
- en: '[PRE508]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE508]'
- en: '[PRE509]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE509]'
- en: '[PRE510]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE510]'
- en: '[PRE511]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE511]'
- en: '[PRE512]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE512]'
- en: '[PRE513]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE513]'
- en: '[PRE514]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE514]'
- en: '[PRE515]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE515]'
- en: '[PRE516]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE516]'
- en: '[PRE517]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE517]'
- en: 'There are three alias templates here:'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有三个别名模板：
- en: '`index_sequence`, which creates an `integer_sequence` for the `size_t` type;
    this is a variadic alias template.'
  id: totrans-661
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index_sequence`，它为 `size_t` 类型创建一个 `integer_sequence`；这是一个可变别名模板。'
- en: '`index_sequence_for`, which creates an `integer_sequence` from a parameter
    pack; this is also a variadic alias template.'
  id: totrans-662
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index_sequence_for`，它从一个参数包中创建一个 `integer_sequence`；这也是一个可变别名模板。'
- en: '`make_index_sequence`, which creates an `integer_sequence` for the `size_t`
    type with the values 0, 1, 2, …, *N-1*. Unlike the previous ones, this is not
    an alias for a variadic template.'
  id: totrans-663
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`make_index_sequence`，它为 `size_t` 类型创建一个包含值 0, 1, 2, …, *N-1* 的 `integer_sequence`。与之前的例子不同，这不是一个可变模板的别名。'
- en: The last subject to address in this chapter is variadic variable templates.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 本章最后要讨论的主题是可变参数变量模板。
- en: Variadic variable templates
  id: totrans-665
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变参数变量模板
- en: As mentioned before, variable templates may also be variadic. However, variables
    cannot be defined recursively, nor can they be specialized like class templates.
    Fold expressions, which simplify generating expressions from a variable number
    of arguments, are very handy for creating variadic variable templates.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，变量模板也可以是可变的。然而，变量不能递归定义，也不能像类模板那样进行特化。折叠表达式，它简化了从变量数量的参数生成表达式的过程，对于创建可变参数变量模板非常有用。
- en: 'In the following example, we define a variadic variable template called `Sum`
    that is initialized at compile-time with the sum of all integers supplied as non-type
    template arguments:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们定义了一个名为 `Sum` 的可变参数变量模板，它在编译时初始化为所有提供的非类型模板参数的整数之和：
- en: '[PRE518]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE518]'
- en: '[PRE519]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE519]'
- en: '[PRE520]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE520]'
- en: '[PRE521]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE521]'
- en: '[PRE522]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE522]'
- en: '[PRE523]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE523]'
- en: '[PRE524]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE524]'
- en: '[PRE525]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE525]'
- en: This is similar to the `sum` function written with the help of fold expressions.
    However, in that case, the numbers to add were provided as function arguments.
    Here, they are provided as template arguments to the variable template. The difference
    is mostly syntactic; with optimizations enabled, the end result is likely the
    same in terms of generated assembly code, and therefore performance.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 这与使用折叠表达式编写的 `sum` 函数类似。然而，在这种情况下，要加的数字是作为函数参数提供的。在这里，它们是作为变量模板的模板参数提供的。区别主要在于语法；在启用优化的情况下，生成的汇编代码的最终结果可能相同，因此性能也相似。
- en: Variadic variable templates follow the same patterns as all the other kinds
    of templates although they are not used as much as the others. However, by concluding
    this topic we have now completed the learning of variadic templates in C++.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 可变参数变量模板遵循与其他所有模板相同的模式，尽管它们不像其他模板那样常用。然而，通过结束这个主题，我们现在已经完成了C++中可变参数模板的学习。
- en: Summary
  id: totrans-678
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we have explored an important category of templates, variadic
    templates, which are templates with a variable number of template arguments. We
    can create variadic function templates, class templates, variable templates, and
    alias templates. The techniques to create variadic function templates and variadic
    class templates are different but incur a form of compile-time recursion. For
    the latter, this is done with template specialization, while for the former with
    function overloads. Fold expressions help to expand a variable number of arguments
    into a single expression, avoiding the need of using function overloads and enabling
    the creation of some categories of variadic variable templates such as the ones
    we have previously seen.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探索了一个重要的模板类别，即可变参数模板，它们是具有可变数量模板参数的模板。我们可以创建可变函数模板、类模板、变量模板和别名模板。创建可变函数模板和可变类模板的技术不同，但都涉及一种编译时递归。对于后者，这是通过模板特化来完成的，而对于前者，则是通过函数重载。折叠表达式有助于将变量数量的参数展开成一个单一的表达式，避免了使用函数重载的需要，并使得创建一些可变变量模板类别成为可能，如我们之前所见到的。
- en: In the next chapter, we will look into a series of more advanced features that
    will help you consolidate your knowledge of templates.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨一系列更高级的功能，这将有助于巩固你对模板知识的理解。
- en: Questions
  id: totrans-681
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are variadic templates and why are they useful?
  id: totrans-682
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可变参数模板是什么？为什么它们有用？
- en: What is a parameter pack?
  id: totrans-683
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是参数包？
- en: What are the contexts where parameter packs can be expanded?
  id: totrans-684
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在哪些上下文中可以展开参数包？
- en: What are fold expressions?
  id: totrans-685
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 折叠表达式是什么？
- en: What are the benefits of using fold expressions?
  id: totrans-686
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用折叠表达式有哪些好处？
- en: Further reading
  id: totrans-687
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*C++ Fold Expressions 101*, Jonathan Boccara, [https://www.fluentcpp.com/2021/03/12/cpp-fold-expressions/](https://www.fluentcpp.com/2021/03/12/cpp-fold-expressions/)'
  id: totrans-688
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C++折叠表达式101*，Jonathan Boccara，[https://www.fluentcpp.com/2021/03/12/cpp-fold-expressions/](https://www.fluentcpp.com/2021/03/12/cpp-fold-expressions/)'
- en: '*Fold Expressions in C++ 17*, Vaibhav, [https://mainfunda.com/fold-expressions-in-cpp17/](https://mainfunda.com/fold-expressions-in-cpp17/)'
  id: totrans-689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C++ 17中的折叠表达式*，Vaibhav，[https://mainfunda.com/fold-expressions-in-cpp17/](https://mainfunda.com/fold-expressions-in-cpp17/)'
- en: '*Nifty Fold Expression Tricks*, Jonathan Müller, [https://www.foonathan.net/2020/05/fold-tricks/](https://www.foonathan.net/2020/05/fold-tricks/)'
  id: totrans-690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*巧妙的折叠表达式技巧*，Jonathan Müller，[https://www.foonathan.net/2020/05/fold-tricks/](https://www.foonathan.net/2020/05/fold-tricks/)'
