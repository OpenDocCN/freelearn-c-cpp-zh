- en: '*Chapter 3*: Variadic Templates'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A variadic template is a template with a variable number of arguments. This
    is a feature that was introduced in C++11\. It combines generic code with functions
    with variable numbers of arguments, a feature that was inherited from the C language.
    Although the syntax and some details could be seen as cumbersome, variadic templates
    help us write function templates with a variable number of arguments or class
    templates with a variable number of data members in a way that was not possible
    before with compile time evaluation and type safety.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the need for variadic templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variadic function templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameter packs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variadic class templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fold expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variadic alias templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variadic variable templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you will have a good understanding of how to write
    variadic templates and how they work.
  prefs: []
  type: TYPE_NORMAL
- en: We will start, however, by trying to understand why templates with variable
    numbers of arguments are helpful.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the need for variadic templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most famous C and C++ functions is `printf`, which writes formatted
    output to the `stdout` standard output stream. There is actually a family of functions
    in the I/O library for writing formatted output, which also includes `fprintf`
    (which writes to a file stream), `sprint`, and `snprintf` (which write to a character
    buffer). These functions are similar because they take a string defining the output
    format and a variable number of arguments. The language, however, provides us
    with the means to write our own functions with variable numbers of arguments.
    Here is an example of a function that takes one or more arguments and returns
    the minimum value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This implementation is specific for values of the `int` type. However, it is
    possible to write a similar function that is a function template. The transformation
    requires minimal changes and the result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Writing code like this, whether generic or not, has several important drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: 'It requires the use of several macros: `va_list` (which provides access to
    the information needed by the others), `va_start` (starts the iterating of the
    arguments), `va_arg` (provides access to the next argument), and `va_end` (stops
    the iterating of the arguments).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evaluation happens at runtime, even though the number and the type of the arguments
    passed to the function are known at compile-time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variadic functions implemented in this manner are not type-safe. The `va_` macros
    perform low-memory manipulation and type-casts are done in `va_arg` at runtime.
    These could lead to runtime exceptions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These variadic functions require specifying in some way the number of variable
    arguments. In the implementation of the earlier `min` function, there is a first
    parameter that indicates the number of arguments. The `printf`-like functions
    take a formatting string from which the number of expected arguments is determined.
    The `printf` function, for example, evaluates and then ignores additional arguments
    (if more are supplied than the number specified in the formatting string) but
    has undefined behavior if fewer arguments are supplied.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to all these things, only functions could be variadic, prior to
    C++11\. However, there are classes that could also benefit from being able to
    have a variable number of data members. Typical examples are the `tuple` class,
    which represents a fixed-size collection of heterogeneous values, and `variant`,
    which is a type-safe union.
  prefs: []
  type: TYPE_NORMAL
- en: Variadic templates help address all these issues. They are evaluated at compile-time,
    are type-safe, do not require macros, do not require explicitly specifying the
    number of arguments, and we can write both variadic function templates and variadic
    class templates. Moreover, we also have variadic variable templates and variadic
    alias templates.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will start looking into variadic function templates.
  prefs: []
  type: TYPE_NORMAL
- en: Variadic function templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Variadic function templates are template functions with a variable number of
    arguments. They borrow the use of the ellipsis (`...`) for specifying a pack of
    arguments, which can have different syntax depending on its nature.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand the fundamentals for variadic function templates, let''s start
    with an example that rewrites the previous `min` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: What we have here are two overloads for the `min` function. The first is a function
    template with two parameters that returns the smallest of the two arguments. The
    second is a function template with a variable number of arguments that recursively
    calls itself with an expansion of the parameters pack. Although variadic function
    template implementations look like using some sort of compile-time recursion mechanism
    (in this case the overload with two parameters acting as the end case), in fact,
    they're only relying on overloaded functions, instantiated from the template and
    the set of provided arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ellipsis (`...`) is used in three different places, with different meanings,
    in the implementation of a variadic function template, as can be seen in our example:'
  prefs: []
  type: TYPE_NORMAL
- en: To specify a pack of parameters in the template parameters list, as in `typename...
    Args`. This is called a **template parameter pack**. Template parameter packs
    can be defined for type templates, non-type templates, and template template parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To specify a pack of parameters in the function parameters list, as in `Args...
    args`. This is called a **function parameter pack**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To expand a pack in the body of a function, as in `args…`, seen in the call
    `min(args…)`. This is called a **parameter pack expansion**. The result of such
    an expansion is a comma-separated list of zero or more values (or expressions).
    This topic will be covered in more detail in the next section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'From the call `min(1, 5, 3, -4, 9)`, the compiler is instantiating a set of
    overloaded functions with 5, 4, 3, and 2 arguments. Conceptually, it is the same
    as having the following set of overloaded functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result, `min(1, 5, 3, -4, 9)` expands to `min(1, min(5, min(3, min(-4,
    9))))`. This can raise questions about the performance of variadic templates.
    In practice, however, the compilers perform a lot of optimizations, such as inlining
    as much as possible. The result is that, in practice, when optimizations are enabled,
    there will be no actual function calls. You can use online resources, such as
    `min` is the variadic function template with the implementation shown earlier):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling this with GCC 11.2 with the `-O` flag for optimizations produces
    the following assembly code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: You don't need to be an expert in assembly to understand what's happening here.
    The evaluation of the call to `min(1, 5, 3, -4, 9)` is done at compile-time and
    the result, `-4`, is loaded directly into the ESI register. There are no runtime
    calls, in this particular case, or computation, since everything is known at compile-time.
    Of course, that is not necessarily always the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet shows an invocation on the `min` function template that
    cannot be evaluated at compile-time because its arguments are only known at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the assembly code generated is the following (only showing here
    the code for the call to the `min` function):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: We can see from this listing that the compiler has inlined all the calls to
    the `min` overloads. There is only a series of instructions for loading values
    into registers, comparisons of register values, and jumps based on the comparison
    result, but there are no function calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'When optimizations are disabled, function calls do occur. We can trace these
    calls that occur during the invocation of the `min` function by using compiler-specific
    macros. GCC and Clang provide a macro called `__PRETTY_FUNCTION__` that contains
    the signature of a function and its name. Similarly, Visual C++ provides a macro,
    called `__FUNCSIG__`, that does the same. These could be used within the body
    of a function to print its name and signature. We can use them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the execution of this program, when compiled with Clang, is the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, when compiled with Visual C++, the output is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'Although the way the signature is formatted is significantly different between
    Clang/GCC on one hand and VC++ on the other hand, they all show the same: first,
    an overloaded function with five parameters is called, then one with four parameters,
    then one with three, and, in the end, there are four calls to the overload with
    two parameters (which marks the end of the expansion).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the expansion of parameter packs is key to understanding variadic
    templates. Therefore, we'll explore this topic in detail in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter packs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A template or function parameter pack can accept zero, one, or more arguments.
    The standard does not specify any upper limit for the number of arguments, but
    in practice, compilers may have some. What the standard does is recommend minimum
    values for these limits but it does not require any compliance on them. These
    limits are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: For a function parameter pack, the maximum number of arguments depends on the
    limit of arguments for a function call, which is recommended to be at least 256.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a template parameter pack, the maximum number of arguments depends on the
    limit of template parameters, which is recommended to be at least 1,024.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of arguments in a parameter pack can be retrieved at compile time
    with the `sizeof…` operator. This operator returns a `constexpr` value of the
    `std::size_t` type. Let's see this at work in a couple of examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first example, the `sizeof…` operator is used to implement the end of
    the recursion pattern of the variadic function template `sum` with the help of
    a `constexpr if` statement. If the number of the arguments in the parameter pack
    is zero (meaning there is a single argument to the function) then we are processing
    the last argument, so we just return the value. Otherwise, we add the first argument
    to the sum of the remaining ones. The implementation looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'This is semantically equivalent, but on the other hand more concise, than the
    following classical approach for the variadic function template implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that `sizeof…(args)` (the function parameter pack) and `sizeof…(Args)`
    (the template parameter pack) return the same value. On the other hand, `sizeof…(args)`
    and `sizeof(args)...` are not the same thing. The former is the `sizeof` operator
    used on the parameter pack `args`. The latter is an expansion of the parameter
    pack `args` on the `sizeof` operator. These are both shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'In this snippet, `sizeof…(Ts)` evaluates to `4` at compile-time, while `sizeof(Ts)...`
    is expanded to the following comma-separated pack of arguments: `sizeof(short),
    sizeof(int), sizeof(long), sizeof(long long)`. Conceptually, the preceding function
    template, `get_type_sizes`, is equivalent to the following function template with
    four template parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: 'Typically, the parameter pack is the trailing parameter of a function or template.
    However, if the compiler can deduce the arguments, then a parameter pack can be
    followed by other parameters including more parameter packs. Let''s consider the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: 'This function is supposed to take two sets of elements of possibly different
    types and do something with them. It can be invoked such as in the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: 'For the first call, the `args1` pack is specified at the function call (as
    in `multipacks<int>`) and contains `1`, and `args2` is deduced to be `2, 3, 4,
    5, 6` from the function arguments. Similarly, for the second call, the two packs
    will have an equal number of arguments, more precisely `1, 2, 3` and `3, 4, 6`.
    For the last call, the first pack contains all the elements, and the second pack
    is empty. In all these examples, all the elements are of the `int` type. However,
    in the following examples, the two packs contain elements of different types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: For the first call, the `args1` pack will contain the integers `1, 2` and the
    `args2` pack will be deduced to contain the double values `4.0, 5.0, 6.0`. Similarly,
    for the second call, the `args1` pack will be `1, 2, 3` and the `args2` pack will
    contain `4.0, 5.0, 6.0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if we change the function template `multipacks` a bit by requiring
    that the packs be of equal size, then only some of the calls shown earlier would
    still be possible. This is shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: In this snippet, only the second and the sixth calls are valid. In these two
    cases, the two deduced packs have three elements each. In all the other cases,
    as resulting from the prior example, the packs have different sizes and the `static_assert`
    statement will generate an error at compile-time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiple parameter packs are not specific to variadic function templates. They
    can also be used for variadic class templates in partial specialization, provided
    that the compiler can deduce the template arguments. To exemplify this, we''ll
    consider the case of a class template that represents a pair of function pointers.
    The implementation should allow for storing pointers to any function. To implement
    this, we define a primary template, called here `func_pair`, and a partial specialization
    with four template parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: A type template parameter for the return type of the first function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A template parameter pack for the parameter types of the first function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A second type template parameter for the return type of the second function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A second template parameter pack for the parameter types of the second function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `func_pair` class template is shown in the next listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: 'To demonstrate the use of this class template, let''s also consider the following
    two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: 'We can instantiate the `func_pair` class template and use it to call these
    two functions as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: Parameter packs can be expanded in a variety of contexts and this will make
    the topic of the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding parameter packs expansion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Parameter packs can appear in a multitude of contexts. The form of their expansion
    may depend on this context. These possible contexts are listed ahead along with
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Template parameter list**: This is for when you specify parameters for a
    template:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Template argument list**: This is when you specify arguments for a template:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Function parameter list**: This is for when you specify parameters for a
    function template:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Function argument list**: When the expansion pack appears inside the parenthesis
    of a function call, the largest expression or brace initialization list to the
    left of the ellipsis is the pattern that is expanded:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Parenthesized initializers**: When the expansion pack appears inside the
    parenthesis of a direct initializer, function-style cast, member initializer,
    new expression, and other similar contexts, the rules are the same as for the
    context of function argument lists:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Brace-enclosed initializers**: This is when you perform initialization using
    the brace notation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Base specifiers and member initializer lists**: A pack expansion may specify
    the list of base classes in a class declaration. In addition, it may also appear
    in the member initializer list, as this may be necessary to call the constructors
    of the base classes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`using` declaration. This is demonstrated based on the previous example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Lambda captures**: The capture clause of a lambda expression may contain
    a pack expansion, as shown in the following example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Fold expressions**: These will be discussed in detail in the following section
    in this chapter:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `sizeof…` operator: Examples have already been shown earlier in this section.
    Here is one again:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`alignas` specifiers applied to the same declaration. The parameter pack can
    be either a type or non-type pack. Examples for both cases are listed here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Attribute list**: This is not supported by any compiler yet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have learned more about parameter packs and their expansion we can
    move forward and explore variadic class templates.
  prefs: []
  type: TYPE_NORMAL
- en: Variadic class templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Class templates may also have a variable number of template arguments. This
    is key to building some categories of types, such as `tuple` and `variant`, that
    are available in the standard library. In this section, we will see how we could
    write a simple implementation for a `tuple` class. A tuple is a type that represents
    a fixed-size collection of heterogeneous values.
  prefs: []
  type: TYPE_NORMAL
- en: 'When implementing variadic function templates we used a recursion pattern with
    two overloads, one for the general case and one for ending the recursion. The
    same approach has to be taken with variadic class templates, except that we need
    to use specialization for this purpose. Next, you can see a minimal implementation
    for a tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: 'The first class is the primary template. It has two template parameters: a
    type template and a parameter pack. This means, at the minimum, there must be
    one type specified for instantiating this template. The primary template tuple
    has two member variables: `value`, of the `T` type, and `rest`, of type `tuple<Ts…>`.
    This is an expansion of the rest of the template arguments. This means a tuple
    of `N` elements will contain the first element and another tuple; this second
    tuple, in turn, contains the second element and yet another tuple; this third
    nested tuple contains the rest. And this pattern continues until we end up with
    a tuple with a single element. This is defined by the partial specialization `tuple<T>`.
    Unlike the primary template, this specialization does not aggregate another tuple
    object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this simple implementation to write code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: 'Although this works, accessing elements through the `rest` member, such as
    in `three.rest.rest.value`, is very cumbersome. And the more elements a tuple
    has the more difficult it is to write code in this way. Therefore, we''d like
    to use some helper function to simplify accessing the elements of a tuple. The
    following is a snippet of how the previous could be transformed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `get<N>` is a variadic function template that takes a tuple as an argument
    and returns a reference to the element at the `N` index in the tuple. Its prototype
    could look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: 'The template arguments are the index and a parameter pack of the tuple types.
    Its implementation, however, requires some helper types. First, we need to know
    what the type of the element is at the `N` index in the tuple. This can be retrieved
    with the help of the following `nth_type` variadic class template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we have a primary template that uses recursive inheritance, and the
    specialization for the index 0\. The specialization defines an alias called `value_type`
    for the first type template (which is the head of the list of template arguments).
    This type is only used as a mechanism for determining the type of a tuple element.
    We need another variadic class template for retrieving the value. This is shown
    in the following listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: We can see here the same recursive pattern, with a primary template and an explicit
    specialization. The class template is called `getter` and has a single template
    parameter, which is a non-type template parameter. This represents the index of
    the tuple element we want to access. This class template has a static member function
    called `get`. This is a variadic function template. The implementation in the
    primary template calls the `get` function with the `rest` member of the tuple
    as an argument. On the other hand, the implementation of the explicit specialization
    returns the reference to the member value of the tuple.
  prefs: []
  type: TYPE_NORMAL
- en: 'With all these defined, we can now provide an actual implementation for the
    helper variadic function template `get`. This implementation relies on the `getter`
    class template and calls its `get` variadic function template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: 'If this example seems a little bit complicated, perhaps analyzing it step by
    step will help you better understand how it all works. Therefore, let''s start
    with the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the `cppinsights.io` web tools to check the template instantiations
    that occur from this snippet. The first to look at is the class template `tuple`.
    We have a primary template and several specializations, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: 'The `tuple<int, double, char>` structure contains an `int` and a `tuple<double,
    char>`, which contains a `double` and a `tuple<char>`, which, in turn, contains
    a `char` value. This last class represents the end of the recursive definition
    of the tuple. This can be conceptually represented graphically as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – An example tuple'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_3.1_B18367.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 – An example tuple
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have the `nth_type` class template, for which, again, we have a primary
    template and several specializations, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: The `nth_type<2, int, double, char>` specialization is derived from `nth_type<1,
    double, char>`, which in turn is derived from `nth_type<0, char>`, which is the
    last base class in the hierarchy (the end of the recursive hierarchy).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `nth_type` structure is used as the return type in the `getter` helper
    class template, which is instantiated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE390]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE398]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE399]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE400]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE401]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE402]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE403]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE404]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE405]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE406]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE407]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE408]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE409]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE410]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE411]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE412]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE413]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE414]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE415]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE416]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE417]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE418]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE419]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE420]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE421]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE422]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE423]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, the `get` function template that we use to retrieve the value of an
    element of a `tuple` is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE424]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE425]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE426]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE427]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE428]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE429]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE430]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE431]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE432]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE433]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE434]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE435]'
  prefs: []
  type: TYPE_PRE
- en: 'Should there be more calls to the `get` function more specializations of `get`
    would exist. For instance, for `get<1>(three)`, the following specialization would
    be added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE436]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE437]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE438]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE439]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE440]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE441]'
  prefs: []
  type: TYPE_PRE
- en: This example helped us demonstrate how to implement variadic class templates
    with a primary template for the general case and a specialization for the end
    case of the variadic recursion.
  prefs: []
  type: TYPE_NORMAL
- en: You have probably noticed the use of the keyword `typename` to prefix the `nth_type<N,
    Ts...>::value_type` type, which is a **dependent type**. In C++20, this is no
    longer necessary. However, this topic will be addressed in detail in [*Chapter
    4*](B18367_04_ePub.xhtml#_idTextAnchor064), *Advanced Template Concepts*.
  prefs: []
  type: TYPE_NORMAL
- en: Because implementing variadic templates is often verbose and can be cumbersome,
    the C++17 standard added **fold expressions** to ease this task. We will explore
    this topic in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Fold expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `sum` that returned the sum of all its supplied arguments. For convenience,
    we will show it again here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE442]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE443]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE444]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE445]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE446]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE447]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE448]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE449]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE450]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE451]'
  prefs: []
  type: TYPE_PRE
- en: 'With fold expressions, this implementation that requires two overloads can
    be reduced to the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE452]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE453]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE454]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE455]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE456]'
  prefs: []
  type: TYPE_PRE
- en: 'There is no need for overloaded functions anymore. The expression `(... + args)`
    represents the fold expression, which upon evaluation becomes `((((arg0 + arg1)
    + arg2) + … ) + argN)`. The enclosing parentheses are part of the fold expression.
    We can use this new implementation, just as we would use the initial one, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE457]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE458]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE459]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE460]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE461]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE462]'
  prefs: []
  type: TYPE_PRE
- en: 'There are four different types of folds, which are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 3.1'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18367_Table_3.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 3.1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this table, the following names are used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pack` is an expression that contains an unexpanded parameter pack, and `arg1`,
    `arg2`, `argN-1`, and `argN` are the arguments contained in this pack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`op` is one of the following binary operators: `+ - * / % ^ & | = < > << >>
    += -= *= /= %= ^= &= |= <<= >>= == != <= >= && || , .* ->*.`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`init` is an expression that does not contain an unexpanded parameter pack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In a unary fold, if the pack does not contain any elements, only some operators
    are allowed. These are listed in the following table, along with the value of
    the empty pack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 3.2'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18367_Table_3.2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 3.2
  prefs: []
  type: TYPE_NORMAL
- en: 'Unary and binary folds differ in the use of an initialization value, that is
    present only for binary folds. Binary folds have the binary operator repeated
    twice (it must be the same operator). We can transform the variadic function template
    `sum` from using a unary right fold expression into one using a binary right fold
    by including an initialization value. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE463]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE464]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE465]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE466]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE467]'
  prefs: []
  type: TYPE_PRE
- en: 'One could say there is no difference between the `sum` and `sum_from_zero`
    function templates. That is not actually true. Let''s consider the following invocations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE468]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE469]'
  prefs: []
  type: TYPE_PRE
- en: Calling `sum` without arguments will produce a compiler error, because unary
    fold expressions (over the operator `+` in this case) must have non-empty expansions.
    However, binary fold expressions do not have this problem, so calling `sum_from_zero`
    without arguments works and the function will return `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In these two examples with `sum` and `sum_from_zero`, the parameter pack `args`
    appears directly within the fold expression. However, it can be part of an expression,
    as long as it is not expanded. This is shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE470]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE471]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE472]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE473]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE474]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE475]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE476]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE477]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE478]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE479]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the parameter pack `args` is part of the `(std::cout << args)` expression.
    This is not a fold expression. A fold expression is `((std::cout << args), ...)`.
    This is a unary left fold over the comma operator. The `printl` and `printr` functions
    can be used as in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE480]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE481]'
  prefs: []
  type: TYPE_PRE
- en: In both these cases, the text printed to the console is `dog`. This is because
    the unary left fold expands to `(((std::cout << 'd'), std::cout << 'o'), << std::cout
    << 'g')` and the unary right fold expands to `(std::cout << 'd', (std::cout <<
    'o', (std::cout << 'g')))` and these two are evaluated in the same way. This is
    because a pair of expressions separated by a comma is evaluated left to right.
    This is true for the built-in comma operator. For types that overload the comma
    operator, the behavior depends on how the operator is overloaded. However, there
    are very few corner cases for overloading the comma operator (such as simplifying
    indexing multi-dimensional arrays). Libraries such as `Boost.Assign` and `SOCI`
    overload the comma operator, but, in general, this is an operator you should avoid
    overloading.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider another example for using the parameter pack in an expression
    inside a fold expression. The following variadic function template inserts multiple
    values to the end of a `std::vector`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE482]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE483]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE484]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE485]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE486]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE487]'
  prefs: []
  type: TYPE_PRE
- en: The parameter pack `args` is used with the `v.push_back(args)` expression that
    is folded over the comma operator. The unary left fold expression is `(v.push_back(args),
    ...)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fold expressions have several benefits over the use of recursion to implement
    variadic templates. These benefits are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Less and simpler code to write.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fewer template instantiations, which leads to faster compile times.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Potentially faster code since multiple function calls are replaced with a single
    expression. However, this point may not be true in practice, at least not when
    optimizations are enabled. We have already seen that the compilers optimize code
    by removing these function calls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we have seen how to create variadic function templates, variadic class
    templates, and how to use fold expressions, we are left to discuss the other kinds
    of templates that can be variadic: alias templates and variable templates. We
    will start with the former.'
  prefs: []
  type: TYPE_NORMAL
- en: Variadic alias templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Everything that can be templatized can also be made variadic. An alias template
    is an alias (another name) for a family of types. A variadic alias template is
    a name for a family of types with a variable number of template parameters. With
    the knowledge accumulated so far, it should be fairly trivial to write alias templates.
    Let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE488]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE489]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE490]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE491]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE492]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE493]'
  prefs: []
  type: TYPE_PRE
- en: 'The class template `foo` is variadic and takes at least one type template argument.
    `int_foo`, on the other hand, is only a different name for a family of types instantiated
    from the `foo` type with `int` as the first type template arguments. These could
    be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE494]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE495]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE496]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE497]'
  prefs: []
  type: TYPE_PRE
- en: In this snippet, `f1` on one hand and `f2` and `f3` on the other are instances
    of different `foo` types, as they are instantiated from different sets of template
    arguments for `foo`. However, `f2` and `f3` are instances of the same type, `foo<int,
    char, double>`, since `int_foo<char, double>` is just an alias for this type.
  prefs: []
  type: TYPE_NORMAL
- en: 'A similar example, although a bit more complex, is presented ahead. The standard
    library contains a class template called `std::integer_sequence`, which represents
    a compile-time sequence of integers, along with a bunch of alias templates to
    help create various kinds of such integer sequences. Although the code shown here
    is a simplified snippet, their implementation can, at least conceptually, be as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE498]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE499]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE500]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE501]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE502]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE503]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE504]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE505]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE506]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE507]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE508]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE509]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE510]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE511]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE512]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE513]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE514]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE515]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE516]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE517]'
  prefs: []
  type: TYPE_PRE
- en: 'There are three alias templates here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`index_sequence`, which creates an `integer_sequence` for the `size_t` type;
    this is a variadic alias template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index_sequence_for`, which creates an `integer_sequence` from a parameter
    pack; this is also a variadic alias template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`make_index_sequence`, which creates an `integer_sequence` for the `size_t`
    type with the values 0, 1, 2, …, *N-1*. Unlike the previous ones, this is not
    an alias for a variadic template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last subject to address in this chapter is variadic variable templates.
  prefs: []
  type: TYPE_NORMAL
- en: Variadic variable templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned before, variable templates may also be variadic. However, variables
    cannot be defined recursively, nor can they be specialized like class templates.
    Fold expressions, which simplify generating expressions from a variable number
    of arguments, are very handy for creating variadic variable templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we define a variadic variable template called `Sum`
    that is initialized at compile-time with the sum of all integers supplied as non-type
    template arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE518]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE519]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE520]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE521]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE522]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE523]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE524]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE525]'
  prefs: []
  type: TYPE_PRE
- en: This is similar to the `sum` function written with the help of fold expressions.
    However, in that case, the numbers to add were provided as function arguments.
    Here, they are provided as template arguments to the variable template. The difference
    is mostly syntactic; with optimizations enabled, the end result is likely the
    same in terms of generated assembly code, and therefore performance.
  prefs: []
  type: TYPE_NORMAL
- en: Variadic variable templates follow the same patterns as all the other kinds
    of templates although they are not used as much as the others. However, by concluding
    this topic we have now completed the learning of variadic templates in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have explored an important category of templates, variadic
    templates, which are templates with a variable number of template arguments. We
    can create variadic function templates, class templates, variable templates, and
    alias templates. The techniques to create variadic function templates and variadic
    class templates are different but incur a form of compile-time recursion. For
    the latter, this is done with template specialization, while for the former with
    function overloads. Fold expressions help to expand a variable number of arguments
    into a single expression, avoiding the need of using function overloads and enabling
    the creation of some categories of variadic variable templates such as the ones
    we have previously seen.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look into a series of more advanced features that
    will help you consolidate your knowledge of templates.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are variadic templates and why are they useful?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a parameter pack?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the contexts where parameter packs can be expanded?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are fold expressions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the benefits of using fold expressions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*C++ Fold Expressions 101*, Jonathan Boccara, [https://www.fluentcpp.com/2021/03/12/cpp-fold-expressions/](https://www.fluentcpp.com/2021/03/12/cpp-fold-expressions/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Fold Expressions in C++ 17*, Vaibhav, [https://mainfunda.com/fold-expressions-in-cpp17/](https://mainfunda.com/fold-expressions-in-cpp17/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Nifty Fold Expression Tricks*, Jonathan Müller, [https://www.foonathan.net/2020/05/fold-tricks/](https://www.foonathan.net/2020/05/fold-tricks/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
