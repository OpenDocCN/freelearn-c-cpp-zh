- en: Chapter 6. Building a Word Processor
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章：构建文本处理器
- en: 'In this chapter, we build a word processor that is capable of handling text
    on character level: that is, a single character that has its own font, color,
    size, and style. We also introduce caret handling, printing and print previewing,
    and file dropping, as well as clipboard handling with ASCII and Unicode text,
    which means that we can cut and paste between this application and, for instance,
    a text editor.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们构建了一个能够处理字符级别文本的文本处理器：也就是说，一个具有自己的字体、颜色、大小和样式的单个字符。我们还介绍了光标处理、打印和打印预览、文件拖放，以及与ASCII和Unicode文本的剪贴板处理，这意味着我们可以在该应用程序和，例如，文本编辑器之间进行剪切和粘贴。
- en: '![Building a Word Processor](img/image_06_001.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![构建文本处理器](img/image_06_001.jpg)'
- en: Auxiliary classes
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 辅助类
- en: 'A document in this application is made up of pages, paragraphs, lines, and
    characters. Let me try to explain how it all hangs together:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在此应用程序中，文档由页面、段落、行和字符组成。让我尝试解释它们是如何相互关联的：
- en: First of all, the document is made up of a list of characters. Each character
    has its own font and pointers to the paragraph and line it belongs to. The character
    information is stored in objects of the `CharInfo` class. The `charList` field
    in the `WordDocument` class is a list of `CharInfo` objects.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，文档由字符列表组成。每个字符都有自己的字体和指向其所属段落和行的指针。字符信息存储在`CharInfo`类的对象中。`WordDocument`类中的`charList`字段是一个`CharInfo`对象列表。
- en: The characters are divided into paragraphs. A paragraph does not hold its own
    character list. Instead, it holds the indexes in the character list of its first
    and last characters. The `paragraphList` field in `WordDocument` is a list of
    `Paragraph` objects. The last character of each paragraph is always a newline.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符被分为段落。一个段落不包含自己的字符列表。相反，它包含其第一个和最后一个字符在字符列表中的索引。`WordDocument`中的`paragraphList`字段是一个`Paragraph`对象列表。每个段落的最后一个字符始终是换行符。
- en: Each paragraph is divided into a list of lines. The `Paragraph` class below
    holds a list of `Line` objects. A line holds the indexes of its first and last
    characters relative to the beginning of the paragraph.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个段落被分为一行列表。下面的`Paragraph`类包含一个`Line`对象列表。一行包含其相对于段落开始的第一个和最后一个字符的索引。
- en: Finally, the document is also divided into pages. A page holds as many whole
    paragraphs as possible.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，文档也被分为页面。一个页面尽可能包含尽可能多的完整段落。
- en: Every time something is changed in the document, the current line and paragraph
    are recalculated. The page list is also recalculated.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 每次文档中发生更改时，当前行和段落都会重新计算。页面列表也会重新计算。
- en: Let's continue to look into the `CharInfo`, `LineInfo`, and `Paragraph` classes.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续深入了解`CharInfo`、`LineInfo`和`Paragraph`类。
- en: Character information
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符信息
- en: 'The `CharInfo` class is a structure that holds the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`CharInfo`类是一个结构，包含以下内容：'
- en: A character and its font
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符及其字体
- en: Its enclosing rectangle, which is used when drawing the character
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的包围矩形，用于绘制字符
- en: Pointers to the line and the paragraph it belongs to
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向所属行和段落的指针
- en: '**CharInfo.h**'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**CharInfo.h**'
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Each of the private fields in this class has its own method for getting and
    setting the value. The first set of methods is constant and returns the value
    itself, which means that the value of the field cannot be changed by these methods.
    The second set of methods is nonconstant and returns a reference to the field,
    which means that the value can be changed. However, they cannot be called from
    a constant object.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 该类中的每个私有字段都有自己的获取和设置值的方法。第一组方法是常量方法，返回值本身，这意味着字段的值不能通过这些方法更改。第二组方法是非常量方法，返回字段的引用，这意味着值可以更改。然而，它们不能从常量对象中调用。
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `tChar` and `charFont` fields hold the character itself and its font, and
    the `charRect` coordinates are relative to the top-left position of the paragraph
    the character belongs to. Each character belongs to a paragraph and one of the
    lines of that paragraph, which `paragraphPtr` and `lineInfoPtr` point at.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`tChar`和`charFont`字段包含字符本身及其字体，而`charRect`坐标相对于字符所属段落的左上角位置。每个字符属于一个段落以及该段落的一行，`paragraphPtr`和`lineInfoPtr`指向这些位置。'
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**CharInfo.cpp**'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**CharInfo.cpp**'
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The default value of the `font` parameter is the system font that gives the
    default font. It is often 10 point Arial.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`font`参数的默认值是提供默认字体的系统字体。它通常是10磅的Arial字体。'
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The copy constructor and assignment operator copies the fields. They are called
    on several occasions when the characters are written to and read from file streams,
    or when they are cut, copied, or pasted.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 复制构造函数和赋值运算符复制字段。它们在将字符写入和从文件流读取、剪切、复制或粘贴时被调用。
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `WriteCharInfoToStream` method writes and the `ReadCharInfoFromStream` method
    reads the values of the class to and from a file stream and the clipboard. Note
    that we omit the `paragraphPtr` and `lineInfoPtr` pointers since it would be meaningless
    to save pointer addresses to a stream. Instead, their values are set by the `ReadDocumentFromStream`
    method in the `WordDocument` class after calling the `ReadCharInfoFromStream`
    method.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`WriteCharInfoToStream` 方法写入，而 `ReadCharInfoFromStream` 方法读取类的值到和从文件流和剪贴板。请注意，我们省略了
    `paragraphPtr` 和 `lineInfoPtr` 指针，因为将指针地址保存到流中是没有意义的。相反，它们的值在 `WordDocument` 类中调用
    `ReadCharInfoFromStream` 方法之后由 `ReadDocumentFromStream` 方法设置。'
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `WriteCharInfoToClipboard` method writes and the `ReadCharInfoFromClipboard`
    method reads the values to and from the clipboard. Also, in this case, we omit
    the `paragraphPtr` and `lineInfoPtr` pointers. These pointers are set by the `PasteGeneric`
    method in the `WordDocument` class after the call to the `ReadCharInfoFromClipboard`
    method.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`WriteCharInfoToClipboard` 方法写入，而 `ReadCharInfoFromClipboard` 方法读取值到和从剪贴板。此外，在这种情况下，我们省略了
    `paragraphPtr` 和 `lineInfoPtr` 指针。这些指针在 `WordDocument` 类中调用 `ReadCharInfoFromClipboard`
    方法之后由 `PasteGeneric` 方法设置。'
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Line information
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行信息
- en: 'The `LineInfo` method is a small structure holding information about a line
    in a paragraph:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`LineInfo` 方法是一个小的结构，包含关于段落中行的信息：'
- en: The integer index of its first and last characters
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的第一个和最后一个字符的整数索引
- en: Its height and ascent, that is, the height and ascent of the largest character
    on the line.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的高度和上升，即行上最大字符的高度和上升。
- en: The top position of the line relative to its paragraph top position
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行相对于其段落顶部位置的顶部位置
- en: '**LineInfo.h**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**LineInfo.h**'
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Similar to the `CharInfo` method mentioned previously, the `LineInfo` method
    holds a set of constant methods for inspecting the class fields and a set of nonconstant
    methods for modifying them.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面提到的 `CharInfo` 方法类似，`LineInfo` 方法包含一组用于检查类字段的常量方法，以及一组用于修改它们的非常量方法。
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The fields of this class are four integer values; the `first` and `last` fields
    refer to the first and last characters on the line, respectively. The `top`, `height`,
    and `ascent` fields are the top position of the line relative to the top position
    of the paragraph, the maximum height, and ascent of the line.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 该类的字段是四个整数值；`first` 和 `last` 字段分别指代行上的第一个和最后一个字符。`top`、`height` 和 `ascent` 字段是行相对于段落顶部的顶部位置、最大高度和行上升。
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**LineInfo.cpp**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**LineInfo.cpp**'
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The default construct is called when the user reads a document from a stream,
    while the second constructor is called when new lines of a paragraph are being
    generated.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户从流中读取文档时调用默认构造函数，而当生成段落的新行时调用第二个构造函数。
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `WriteLineInfoToStream` and `ReadLineInfoFromStream` methods simply write
    and read, respectively, the field value. Note that there are no corresponding
    methods for cut, copy, and paste since the line list of a paragraph is regenerated
    each time the paragraph is pasted.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`WriteLineInfoToStream` 和 `ReadLineInfoFromStream` 方法简单地写入和读取字段值。请注意，没有相应的剪切、复制和粘贴方法，因为每次粘贴段落时，段落的行列表都会被重新生成。'
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The Paragraph class
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 段落类
- en: 'A document is made up of a sequence of paragraphs. The `Paragraph` structure
    holds the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 文档由一系列段落组成。`Paragraph` 结构包含以下内容：
- en: The index of its first and last characters
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的第一个和最后一个字符的索引
- en: Its top position relative to the beginning of the document, and its height
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它相对于文档开头的顶部位置及其高度
- en: Its index in the document paragraph pointer list
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在文档段落指针列表中的索引
- en: Its alignment–a paragraph can be left, center, justified, or right aligned
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的对齐方式——段落可以是左对齐、居中对齐、两端对齐或右对齐
- en: Whether it holds a page break, that is, whether this paragraph will be located
    at the beginning of the next page
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否包含分页符，即此段落是否将位于下一页的开头
- en: '**Paragraph.h**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**Paragraph.h**'
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, we name the `AlignmentField` method instead of just the `Alignment`
    method. The reason for this is that there already is a class named `Alignment`.
    We cannot give the same name to both the class and method. Therefore, we add the
    `Field` suffix to the method name.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们命名`AlignmentField`方法而不是仅仅命名`Alignment`方法。这样做的原因是已经有一个名为`Alignment`的类。我们不能同时给类和方法相同的名称。因此，我们在方法名称中添加了`Field`后缀。
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `first` and `last` fields are the index in the document character list of
    the first and last characters in the paragraph, respectively; the last character
    of the paragraph is always a newline. The `top` field is the top position of the
    paragraph relative to the beginning of the document, which is always zero for
    the first paragraph of the document and positive for the other paragraphs. The
    `height` is the height of the paragraph, and `index` refers to the index of the
    paragraph in the document paragraph pointer list. If `pageBreak` is `true`, the
    paragraph will always be located at the beginning of a page.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`first`和`last`字段分别是段落中第一个和最后一个字符在文档字符列表中的索引；段落的最后一个字符始终是换行符。`top`字段是段落相对于文档开始的顶部位置，对于文档的第一个段落始终为零，对于其他段落为正值。`height`是段落的高度，`index`指的是段落在文档段落指针列表中的索引。如果`pageBreak`为`true`，则段落将始终位于页面的开头。'
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: A paragraph can be left, right, centered, and justified aligned. In the justified
    case, the spaces are extended in order for the words to be distributed over the
    whole width of the page.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 段落可以左对齐、右对齐、居中对齐和两端对齐。在两端对齐的情况下，为了使单词分布在整个页面宽度上，会扩展空格。
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: A paragraph is made up of at least one line. The indexes of the `linePtrList`
    list are relative to the index of the first character in the paragraph (not the
    document), and the coordinates are relative to the top of the paragraph (again,
    not the document).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 段落至少由一行组成。`linePtrList`列表的索引相对于段落中第一个字符的索引（不是文档），坐标相对于段落的顶部（再次不是文档）。
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**Paragraph.cpp**'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**Paragraph.cpp**'
- en: '[PRE19]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The idea is that the `WriteParagraphToStream` and `ReadParagraphFromStream`
    methods write and read, respectively, all information about the paragraph. Remember
    that all coordinates are given in logical units (hundredths of millimeters), which
    means that works to save and open the file on screens with different resolutions.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是`WriteParagraphToStream`和`ReadParagraphFromStream`方法分别写入和读取段落的所有信息。记住，所有坐标都是以逻辑单位（毫米的百分之一）给出的，这意味着在不同的分辨率屏幕上保存和打开文件时会有所不同。
- en: '[PRE20]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When we have read indexes of the first and last character of the paragraph,
    we need to set the paragraph pointer of each character.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们读取到段落的第一个和最后一个字符的索引时，我们需要设置每个字符的段落指针。
- en: '[PRE21]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the same way as in the paragraph pointer case above, we need to set the line
    pointer of each character.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 与上面段落指针的情况相同，我们需要设置每个字符的行指针。
- en: '[PRE22]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: On the other hand, the `WriteParagraphToClipboard` and `ReadParagraphFromClipboard`
    methods only write and read, respectively, the essential information. After the
    paragraph has been read, the `CalaulateParagraph` method is then called, which
    calculates the character rectangles and the height of the paragraph and generates
    its line pointer list.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`WriteParagraphToClipboard`和`ReadParagraphFromClipboard`方法分别只写入和读取必要的信息。在读取段落之后，然后调用`CalaulateParagraph`方法，该方法计算字符矩形和段落的行高，并生成其行指针列表。
- en: '[PRE23]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The MainWindow class
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MainWindow类
- en: 'The `MainWindow` class is nearly identical to the versions of the previous
    chapters. It sets the application name to `Word` and returns the address of a
    `WordDocument` instance:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainWindow`类几乎与上一章的版本相同。它将应用程序名称设置为`Word`并返回`WordDocument`实例的地址：'
- en: '[PRE24]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The WordDocument class
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WordDocument类
- en: The `WordDocument` class is the main class of the application. It extends the
    `StandardDocument` class and takes advantage of its document-based functionality.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`WordDocument`类是应用程序的主要类。它扩展了`StandardDocument`类并利用了其基于文档的功能。'
- en: '**WordDocument.h**'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**WordDocument.h**'
- en: '[PRE25]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `InitDocument` class is called by the constructor, the `ClearDocument`,
    and `Delete` classes.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`InitDocument`类由构造函数、`ClearDocument`和`Delete`类调用。'
- en: '[PRE26]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `OnKeyboardMode` method is called every time the user presses the *Insert*
    key. The `UpdateCaret` method sets the caret to a vertical bar in `insert` mode
    and a block in `overwrite` mode. When the user marks one or several characters,
    the caret is cleared.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 每当用户按下 *Insert* 键时，都会调用 `OnKeyboardMode` 方法。`UpdateCaret` 方法将光标设置为 `insert`
    模式下的垂直条和 `overwrite` 模式下的块。当用户标记一个或多个字符时，光标会被清除。
- en: '[PRE27]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When the user presses, moves, and releases the mouse, we need to find the index
    of the character located at the mouse position. The `MousePointToIndex` method
    finds the paragraph, and the `MousePointToParagraphIndex` method finds the character
    in the paragraph. The `InvalidateBlock` method invalidates the characters from
    the smallest index, inclusive, to the largest index, exclusive.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下、移动和释放鼠标时，我们需要找到鼠标位置处的字符索引。`MousePointToIndex` 方法找到段落，而 `MousePointToParagraphIndex`
    方法找到段落中的字符。`InvalidateBlock` 方法使从最小索引（包含）到最大索引（不包含）的字符无效。
- en: '[PRE28]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When the user double-clicks on a word, it will be marked. The `GetFirstWordIndex`
    and `GetLastWordIndex` methods find the first and last index of the word, respectively,
    if in fact the user double-clicks on a word (rather than a space, period, comma,
    or question mark).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户双击一个单词时，它将被标记。如果用户确实双击了一个单词（而不是空格、句号、逗号或问号），则 `GetFirstWordIndex` 和 `GetLastWordIndex`
    方法分别找到单词的第一个和最后一个索引。
- en: '[PRE29]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this application, we introduce touchscreen handling. Unlike mouse clicks,
    it is possible to touch the screen in several locations at the same time. Therefore,
    the parameter is a list of points rather that one individual point.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用中，我们引入了触摸屏操作。与鼠标点击不同，可以同时触摸屏幕上的多个位置。因此，参数是一个点的列表，而不是一个单独的点。
- en: '[PRE30]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `OnPageSetup` method is called when the user has changed the page setting
    by selecting the **Page Setup** menu item in the **File** menu, which allows the
    user to modify the page and paragraphs settings. The `CalculateDocument` method
    distributes the paragraphs on the pages. If a paragraph is marked with a page
    break, or if it does not completely fit on the rest of the current page, it is
    placed at the beginning of the next page.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户通过在 **文件** 菜单中选择 **页面设置** 菜单项来更改页面设置时，会调用 `OnPageSetup` 方法。这允许用户修改页面和段落设置。`CalculateDocument`
    方法将段落分配到页面上。如果一个段落带有分页标记，或者它没有完全适合当前页的其余部分，它将被放置在下一页的开始处。
- en: '[PRE31]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Unlike the applications in the previous chapters, we override both the `OnPaint`
    and `OnDraw` methods. The `OnPaint` method is called when the client area needs
    to be redrawn. It performs paint-specific actions, that is, actions that will
    be performed only when the document is drawn in a window, but not when it is sent
    to the printer. More specifically, we add page break markers in the client area,
    but not in the printer text.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 与前几章中的应用不同，我们重写了 `OnPaint` 和 `OnDraw` 方法。当客户端区域需要重新绘制时调用 `OnPaint` 方法。它执行特定的绘制动作，即仅在文档在窗口中绘制时执行的动作，而不是在发送到打印机时执行。更具体地说，我们在客户端区域添加了分页标记，但不在打印机文本中。
- en: The `OnPaint` method then calls the `OnDraw` method that performs the actual
    drawing of the document. There is also a method `OnPrint` in the `StandardDocument`
    class (which we do not override) that calls the `OnDraw` method when printing
    the document.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`OnPaint` 方法调用执行文档实际绘制的 `OnDraw` 方法。在 `StandardDocument` 类（我们没有重写）中还有一个名为
    `OnPrint` 的方法，当打印文档时调用 `OnDraw` 方法。
- en: '[PRE32]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Similar to the applications in the previous chapters, the `ClearDocument`, `WriteDocumentToStream`,
    and `ReadDocumentFromStream` methods are called when the user selects the **New**,
    **Save**, **Save As**, or **Open** menu items in the **File** menu.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 与前几章中的应用类似，当用户在 **文件** 菜单中选择 **新建**、**保存**、**另存为** 或 **打开** 菜单项时，会调用 `ClearDocument`、`WriteDocumentToStream`
    和 `ReadDocumentFromStream` 方法。
- en: '[PRE33]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `CopyEnable` method returns `true` when text is ready to be copied, that
    is, when the user has marked a part of the text. The `CopyAscii` and `CopyUnicode`
    methods are called when the user selects the **Cut** or **Copy** menu item and
    copies the marked text into a string list. The `CopyGeneric` method is also called
    when the user selects the **Cut** or **Copy** menu item and copies the marked
    text in an application-specific format that also copies the font and style of
    the characters.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当文本准备好复制时，`CopyEnable`方法返回`true`，即当用户标记了文本的一部分时。当用户选择**剪切**或**复制**菜单项并复制标记的文本到字符串列表时，会调用`CopyAscii`和`CopyUnicode`方法。当用户选择**剪切**或**复制**菜单项并将标记的文本以应用程序特定的格式复制时，也会调用`CopyGeneric`方法，这种格式还会复制字符的字体和样式。
- en: '[PRE34]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `PasteAscii`, `PasteUnicode`, and `PasteGeneric` methods are called when
    the user selects the **Paste** menu item. One difference between copying and pasting
    is that all the three aforementioned methods are called when copying, but only
    one method when pasting, in the order the format is given in the `StandardDocument`
    constructor call.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择**粘贴**菜单项时，会调用`PasteAscii`、`PasteUnicode`和`PasteGeneric`方法。复制和粘贴之间的一个区别是，在复制时，上述三种方法都会被调用，但在粘贴时，只调用一个方法，其顺序与在`StandardDocument`构造函数调用中给出的格式顺序相同。
- en: '[PRE35]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We do not override the `CutEnable` or `OnCut` methods, since the `CutEnable`
    method in the `StandardDocument` class calls the `CopyEnable` method, and the
    `OnCut` method calls the `OnDelete` method followed by the `OnCopy` method.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有重写`CutEnable`或`OnCut`方法，因为`StandardDocument`类中的`CutEnable`方法会调用`CopyEnable`方法，而`OnCut`方法会调用`OnDelete`方法，然后是`OnCopy`方法。
- en: The **Delete** menu item is enabled unless the input position is at the end
    of the document, in which case there is nothing to delete. The `Delete` method
    is a general method for deleting text and is called when the user presses the
    *Delete* or *Backspace* keys or when a marked text block is being overwritten.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**删除**菜单项处于启用状态，除非输入位置在文档末尾，在这种情况下，没有可以删除的内容。`Delete`方法是一个通用方法，用于删除文本，当用户按下*Delete*或*Backspace*键或正在覆盖标记的文本块时会被调用。'
- en: '[PRE36]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `OnPageBreak` method sets the page break status of the edit paragraph. In
    case of a page break, the paragraph will be placed at the beginning of the next
    page. The `OnFont` method displays the standard font dialog that sets the font
    and color of the next character to be input or the font of the marked block.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnPageBreak`方法设置编辑段落的分页状态。如果发生分页，段落将被放置在下一页的开头。`OnFont`方法显示标准字体对话框，用于设置下一个要输入的字符或标记块的字体和颜色。'
- en: '[PRE37]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: A paragraph can be left, center, right, or justified aligned. The radio mark
    is present if the paragraph currently edited or all paragraphs currently marked
    have the alignment in question. All the listeners call the `IsAlignment` and `SetAlignment`
    methods, which returns the current alignment and sets the alignment, respectively,
    for the edited paragraph or all marked paragraphs.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 段落可以左对齐、居中对齐、右对齐或两端对齐。如果当前编辑的段落或所有当前标记的段落具有所询问的对齐方式，则会出现单选标记。所有听众都会调用`IsAlignment`和`SetAlignment`方法，分别用于获取编辑段落或所有标记段落的当前对齐方式以及设置对齐方式。
- en: '[PRE38]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `OnChar` method is called every time the user presses a graphical character;
    it calls the `InsertChar` or `OverwriteChar` method, depending on whether the
    keyboard holds `insert` or `overwrite` mode. When the text is marked and the user
    changes the font, the font is set on all marked characters. However, when editing
    text, the font of the next character to be input is set.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 每当用户按下图形字符时，都会调用`OnChar`方法；它根据键盘是否处于`insert`或`overwrite`模式来调用`InsertChar`或`OverwriteChar`方法。当文本被标记且用户更改字体时，字体会应用于所有标记字符。然而，在编辑文本时，下一个要输入的字符的字体会被设置。
- en: When the user does anything else than input the next character, such as clicking
    the mouse or pressing any of the arrow keys, the `ClearNextFont` method is called,
    which clears the next font by setting it to the `SystemFont` method.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户进行除输入下一个字符之外的其他操作时，例如点击鼠标或按下任何箭头键，会调用`ClearNextFont`方法，该方法通过将其设置为`SystemFont`方法来清除下一个字体。
- en: '[PRE39]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `OnKeyDown` method is called every time the user presses a key, such as
    the arrow keys, *Page Up* and *Page Down*, *Home* and *End*, *Delete*, or *Backspace*:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 每当用户按下键时，都会调用`OnKeyDown`方法，例如箭头键、*向上翻页*和*向下翻页*、*Home*和*End*、*Delete*或*Backspace*：
- en: '[PRE40]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: When the user presses the key without pressing the *Shift* key at the same time,
    the caret is moved. However, when they press the *Shift* key, the marking of the
    text is changed.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下键而没有同时按下 *Shift* 键时，光标会移动。然而，当他们按下 *Shift* 键时，文本的标记会改变。
- en: '[PRE41]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: When the user presses the *Home* or *End* key together with the *Ctrl* key,
    the caret is placed at the beginning or end of the document. If they also press
    the *Shift* key, the text is marked.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户同时按下 *Home* 或 *End* 键和 *Ctrl* 键时，光标将被放置在文档的开始或结束位置。如果他们还按下 *Shift* 键，文本将被标记。
- en: The reason we use listener instead of regular methods is that all actions involving
    the *Ctrl* key are interpreted as accelerators by Small Windows. The listeners
    are also added to a menu in the following constructor.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用监听器而不是常规方法的原因是，所有涉及 *Ctrl* 键的操作都被 Small Windows 解释为加速器。监听器也被添加到以下构造函数中的菜单中。
- en: '[PRE42]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: There are also the *Return*, *Backspace*, and *Delete* keys, in which case we
    do not care whether the *Shift* or *Ctrl* key is pressed. The *Delete* key is
    handled by the **Delete** menu item accelerator.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 同样存在 *返回*、*退格* 和 *删除* 键，在这种情况下，我们并不关心是否按下了 *Shift* 或 *Ctrl* 键。*删除* 键由 **删除**
    菜单项加速器处理。
- en: '[PRE43]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: When the user moves the caret with the keyboard, the edit character will be
    visible. The `MakeVisible` method makes sure it is visible, even if it means scrolling
    the document.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户使用键盘移动光标时，编辑字符将可见。`MakeVisible` 方法确保它是可见的，即使这意味着滚动文档。
- en: '[PRE44]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: When something happens to the paragraph (characters are added or deleted, the
    font or alignment is changed, or the page setup), the positions of the characters
    need to be calculated. The `GenerateParagraph` method calculates the surrounding
    rectangle for each of its character and generates its line list by calling the
    `GenerateSizeAndAscentList` method to calculate the size and ascent line for the
    characters, the `GenerateLineList` method to divide the paragraph into lines,
    the `GenerateRegularLineRectList` method to generate the character rectangles
    for left, center, or right aligned paragraphs or the `GenerateJustifiedLineRectList`
    method for justified paragraphs, and the `GenerateRepaintSet` method to invalidate
    the changed characters.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当段落发生某些变化（字符被添加或删除，字体或对齐方式改变，或页面设置）时，需要计算字符的位置。`GenerateParagraph` 方法为每个字符计算周围矩形，并通过调用
    `GenerateSizeAndAscentList` 方法计算字符的大小和上升线，调用 `GenerateLineList` 方法将段落分成行，调用 `GenerateRegularLineRectList`
    方法生成左对齐、居中对齐或右对齐段落的字符矩形，或调用 `GenerateJustifiedLineRectList` 方法为对齐段落生成字符矩形，以及调用
    `GenerateRepaintSet` 方法使更改的字符无效。
- en: '[PRE45]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'One central part of this application is the `wordMode` method. At a certain
    time, the application can be set to `edit` mode (the caret is visible), in which
    case `wordMode` is the `WordEdit` method, or `mark` mode (a part of the text is
    marked), in which case `wordMode` is the `WordMark` method. Later in the chapter,
    we will encounter expressions such as **in edit mode** and **in mark mode**, which
    refer to the value of `wordMode`: `WordEdit` or `WordMark`.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 本应用的一个核心部分是 `wordMode` 方法。在某个时刻，应用可以被设置为 `编辑` 模式（光标可见），在这种情况下 `wordMode` 是 `WordEdit`
    方法，或者 `标记` 模式（文本的一部分被标记），在这种情况下 `wordMode` 是 `WordMark` 方法。在章节的后面，我们将遇到 **编辑模式**
    和 **标记模式** 这样的表达式，它们指的是 `wordMode` 的值：`WordEdit` 或 `WordMark`。
- en: We will also encounter the expressions **in insert mode** and **in overwrite
    mode**, which refer to the `input` mode of the keyboard, the `InsertKeyboard`
    or `OverwriteKeyboard` method, which is returned by the `GetKeyboardMode` method
    in the Small Windows class `Document`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还会遇到 **插入模式** 和 **覆盖模式** 的表达式，它们指的是键盘的 `input` 模式，即 `InsertKeyboard` 或 `OverwriteKeyboard`
    方法，这是 Small Windows 类 `Document` 中的 `GetKeyboardMode` 方法返回的。
- en: The `totalPages` field holds the number of pages, which is used when printing
    and when setting the vertical scroll bar. The list of characters is stored in
    the `charList` list, and the list of paragraph pointers is stored in the `paragraphList`
    list. Note that the paragraphs are dynamically created and deleted `Paragraph`
    objects while the characters are static `CharInfo` objects. Also note that each
    paragraph does not hold a character list. There is only one `charList`, which
    is common to all paragraphs. However, each paragraph holds its own list of `Line`
    pointers that are local to the paragraph.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`totalPages` 字段包含页数，这在打印和设置垂直滚动条时使用。字符列表存储在 `charList` 列表中，段落指针列表存储在 `paragraphList`
    列表中。请注意，段落是动态创建和删除的 `Paragraph` 对象，而字符是静态的 `CharInfo` 对象。此外，请注意，每个段落不包含字符列表。只有一个
    `charList`，它是所有段落的公共部分。然而，每个段落都包含它自己的 `Line` 指针列表，这些指针是段落本地的。'
- en: In this chapter, we will also encounter expressions such as **the edit character**,
    which refers to the character with index `editIndex` in the `charList` list. As
    mentioned at the beginning of this chapter, each character has pointers to its
    paragraph and line. The expressions **the edit paragraph** and **the edit line**
    refer to the paragraph and line pointed at by the edit character.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们还将遇到诸如 **编辑字符** 这样的表达式，它指的是 `charList` 列表中索引为 `editIndex` 的字符。如本章开头所述，每个字符都有指向其段落和行的指针。**编辑段落**
    和 **编辑行** 这些表达式指的是由编辑字符指向的段落和行。
- en: The `firstMarkIndex` and `lastMarkIndex` fields hold the indexes of the first
    and last marked characters in `mark` mode. They are also referred to in expressions
    such as **the first marked character**, **the first marked paragraph**, and **the
    first marked line** as well as **the last marked character**, **the last marked
    paragraph**, and **the last marked line**. Note that the two fields refer to the
    chronological order, not necessarily their physical order. When needed, we will
    define the `minIndex` and `maxIndex` methods to refer to the first and last markings
    in the document in physical order.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`firstMarkIndex` 和 `lastMarkIndex` 字段包含在 `mark` 模式下第一个和最后一个标记字符的索引。它们也出现在诸如
    **第一个标记字符**、**第一个标记段落**、**第一个标记行** 以及 **最后一个标记字符**、**最后一个标记段落** 和 **最后一个标记行**
    等表达式中。请注意，这两个字段指的是时间顺序，而不一定是它们的物理顺序。当需要时，我们将定义 `minIndex` 和 `maxIndex` 方法来按物理顺序引用文档中的第一个和最后一个标记。'
- en: When the user sets the font in `edit` mode, it is stored in the `nextFont` font,
    which is then used when the user inputs the next character. The caret takes into
    consideration the status of the `nextFont` font, that is, if the  `nextFont` font
    is not equal to the `ZeroFont` font, it is used to set the caret. However, the
    `nextFont` font is cleared as soon as the user does anything else.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在 `edit` 模式下设置字体时，它被存储在 `nextFont` 字体中，然后当用户输入下一个字符时使用。光标会考虑 `nextFont` 字体的状态，即如果
    `nextFont` 字体不等于 `ZeroFont` 字体，它就会用来设置光标。然而，一旦用户做其他任何事情，`nextFont` 字体就会被清除。
- en: The user can zoom the document by menu items or by touching the screen. In that
    case, we need the `initZoom` and `initDistance` fields to keep track of the zooming.
    Finally, we need the `WordFormat` field to identify cut, copied, and pasted application-specific
    information. It is given the arbitrary value of 1002.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以通过菜单项或触摸屏幕来放大文档。在这种情况下，我们需要 `initZoom` 和 `initDistance` 字段来跟踪缩放。最后，我们需要
    `WordFormat` 字段来识别剪切、复制和粘贴的应用程序特定信息。它被赋予任意值 1002。
- en: '[PRE46]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '**WordDocument.cpp**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**WordDocument.cpp**'
- en: '[PRE47]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `WordDocument` constructor calls the `StandardDocument` constructor. The
    `UnicodeFormat` and `AsciiFormat` methods are general formats defined by Small
    Windows, while the `WordFormat` method is specific to this application.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`WordDocument` 构造函数调用 `StandardDocument` 构造函数。`UnicodeFormat` 和 `AsciiFormat`
    方法是由 Small Windows 定义的通用格式，而 `WordFormat` 方法是特定于这个应用程序的。'
- en: '[PRE48]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The **Format** menu holds the **Font** and **Page Break** menu items. Unlike
    the earlier applications in this book, we send `true` to `StandardFileMenu`. It
    indicates that we want to include the **Page Setup**, **Print Preview**, and **Print**
    menu items in the **File** menu.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**格式** 菜单包含 **字体** 和 **分页符** 菜单项。与本书中较早的应用程序不同，我们向 `StandardFileMenu` 发送 `true`。这表示我们希望在
    **文件** 菜单中包含 **页面设置**、**打印预览** 和 **打印** 菜单项。'
- en: '[PRE49]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The **Alignment** menu holds items for the left, center, right, and justified
    alignment:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**对齐** 菜单包含左对齐、居中对齐、右对齐和两端对齐的选项：'
- en: '[PRE50]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `extraMenu` menu is only added for the accelerators; note that we do not
    add it to the menu bar. The text of the menu, or its items, does not matter either.
    We only want to allow the user to jump to the beginning or end of the document
    by pressing the *Ctrl* key with *Home* or *End*, and possibly *Shift*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`extraMenu` 菜单仅用于加速器；请注意，我们不会将其添加到菜单栏中。菜单文本或其项目内容也不重要。我们只想允许用户通过按住 *Ctrl* 键并使用
    *Home* 或 *End* 键，以及可能使用 *Shift* 键来跳转到文档的开始或结束。'
- en: '[PRE51]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Finally, we call the `InitDocument` method that initializes the empty document.
    The `InitDocument` method is also called by the `ClearDocument` and `Delete` classes
    as follows, when the initialization code is placed in its own method.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用 `InitDocument` 方法来初始化空文档。`InitDocument` 方法也由 `ClearDocument` 和 `Delete`
    类在以下情况下调用，当初始化代码放置在其自己的方法中时。
- en: '[PRE52]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: A document always holds at least one paragraph, which, in turn, holds at least
    a newline. We create the first character and the first left-justified paragraph.
    The paragraph and character are added to the `paragraphList` and `charList` lists.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 文档始终至少包含一个段落，该段落又至少包含一个换行符。我们创建第一个字符和第一个左对齐的段落。段落和字符被添加到 `paragraphList` 和 `charList`
    列表中。
- en: Then, the paragraph is calculated by the `GenerateParagraph` method and distributed
    on the document by the `CalculateDocument` method. Finally, the caret is updated
    by the `UpdateCaret` method.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，段落通过 `GenerateParagraph` 方法计算，并通过 `CalculateDocument` 方法在文档中分布。最后，通过 `UpdateCaret`
    方法更新光标。
- en: '[PRE53]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The caret
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 光标
- en: 'Since in this chapter we introduce text handling, we need to keep track of
    the caret: the blinking vertical bar (in `insert` mode) or block (in `overwrite`
    mode) indicating where to input the character. The `UpdateCaret` method is called
    by the `OnKeyboardMode` method (which is called when the user presses the *Insert*
    key) as well as other methods when the input position is being modified.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在本章中我们介绍了文本处理，我们需要跟踪光标：在 `insert` 模式下的闪烁垂直线或块（在 `overwrite` 模式下）指示输入字符的位置。`UpdateCaret`
    方法由 `OnKeyboardMode` 方法（当用户按下 *Insert* 键时调用）以及其他方法调用，当输入位置正在修改时。
- en: '[PRE54]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In `edit` mode, the caret will be visible, and we obtain the area from the edit
    character. However, if the `nextFont` font is active (does not equal the `SystemFont`
    font), the user has changed the font, which we must take into consideration. In
    that case, we set the width and height of the caret in accordance with the size
    of an average character of the `nextFont` font.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `edit` 模式下，光标将可见，我们获取编辑字符所在区域。然而，如果 `nextFont` 字体处于活动状态（不等于 `SystemFont` 字体），用户已更改字体，我们必须考虑这一点。在这种情况下，我们将光标宽度和高度设置为
    `nextFont` 字体平均字符的大小。
- en: '[PRE55]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: If the `nextFont` font is not active, we check whether the keyboard holds `insert`
    mode and the caret is not located at the beginning of the paragraph. In that case,
    the caret's vertical coordinates will reflect the font size of the preceding character,
    since the next character to be input will be given its font.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `nextFont` 字体未处于活动状态，我们检查键盘是否处于 `insert` 模式，并且光标是否不在段落开头。在这种情况下，光标的垂直坐标将反映前一个字符的字体大小，因为下一个要输入的字符将使用该字体。
- en: '[PRE56]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: If the keyboard holds the `insert` mode, the caret will be a vertical bar, regardless
    of whether the `nextFont` font is active. It is given the width of one unit (which
    is later rounded to the width of one physical pixel).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果键盘处于 `insert` 模式，无论 `nextFont` 字体是否处于活动状态，光标都将是一条垂直线。它被赋予一个单位宽度（这后来会被四舍五入到物理像素的宽度）。
- en: '[PRE57]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The caret will not extend outside the page. If it does, its right border is
    set to the page's border.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 光标不会超出页面范围。如果它超出了，其右边界将被设置为页面的边界。
- en: '[PRE58]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Finally, we need the top position of the edit paragraph, since the caret so
    far is calculated relative to its top position.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要编辑段落的顶部位置，因为光标到目前为止是相对于其顶部位置计算的。
- en: '[PRE59]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In `mark` mode, the caret will be invisible. Therefore, we call `ClearCaret`
    as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `mark` 模式下，光标将不可见。因此，我们按照以下方式调用 `ClearCaret`：
- en: '[PRE60]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Mouse input
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 鼠标输入
- en: The `OnMouseDown`, `OnMouseMove`, `OnMouseUp`, and `OnDoubleClick` methods take
    the pressed buttons and the mouse coordinates. In all four cases, we check that
    the left mouse button is pressed. The `OnMouseDown` method first calls the `EnsureEditStatus`
    method in order to clear any potential marked area. Then it sets the application
    to `mark` mode (which may later be changed by the `OnMouseUp` method) and looks
    up the index of the character pointed at by calling the `MousePointToIndex` method.
    The `nextFont` field is cleared by a call to the `ClearNextFont` method. We also
    call the `UpdateCaret` method, since the caret will be cleared while the user
    drags the mouse.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnMouseDown`、`OnMouseMove`、`OnMouseUp` 和 `OnDoubleClick` 方法接收按下的按钮和鼠标坐标。在所有四种情况下，我们检查是否按下了左键鼠标。`OnMouseDown`
    方法首先调用 `EnsureEditStatus` 方法以清除任何潜在标记区域。然后它将应用程序设置为 `mark` 模式（这可能会稍后被 `OnMouseUp`
    方法更改）并通过调用 `MousePointToIndex` 方法查找指向的字符的索引。通过调用 `ClearNextFont` 方法清除 `nextFont`
    字段。我们还调用 `UpdateCaret` 方法，因为当用户拖动鼠标时，光标将被清除。'
- en: '[PRE61]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: In the `OnMouseMove` method, we retrieve the paragraph and character of the
    mouse by calling the `MousePointToIndex` method. If the mouse has been moved to
    a new character since the last call to the `OnMouseDown` or `OnMouseMove` method,
    we update the marked text by calling the `InvalidateBlock` method with the current
    and new mouse position, which invalidates the part of the text between the current
    and previous mouse event. Note that we do not invalidate the whole marked block.
    We only invalidate the block between the previous and current mouse positions
    in order to avoid dazzles.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `OnMouseMove` 方法中，我们通过调用 `MousePointToIndex` 方法检索鼠标的段落和字符。如果自上次调用 `OnMouseDown`
    或 `OnMouseMove` 方法以来鼠标已移动到新字符，我们通过调用 `InvalidateBlock` 方法并传递当前和新的鼠标位置来更新标记文本，这将使当前和上次鼠标事件之间的文本部分无效。请注意，我们不使整个标记块无效。我们只使前一个和当前鼠标位置之间的块无效，以避免闪烁。
- en: '[PRE62]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In the `OnMouseUp` method, we just have to check the last position. If it is
    the same as the first position (the user pressed and released the mouse at the
    same character), we change the application to `edit` mode and call the `UpdateCaret`
    method to make the caret visible.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `OnMouseUp` 方法中，我们只需检查最后一个位置。如果它与第一个位置相同（用户在同一个字符上按下并释放鼠标），我们将应用程序更改为 `edit`
    模式并调用 `UpdateCaret` 方法以使光标可见。
- en: '[PRE63]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The `MousePointToIndex` method finds the paragraph that the user has clicked
    on and calls the `MousePointToParagraphIndex` method to find the character in
    the paragraph. The reason we divide the functionality into two methods is that
    the `MousePointToIndexDown` method in [Chapter 7](ch07.html "Chapter 7. Keyboard
    Input and Character Calculation"), *Keyboard Input and Character Calculation*,
    also calls the `MousePointToParagraphIndex` method, which iterates through the
    paragraph list. If the vertical position is less than the top position of a paragraph,
    the correct paragraph is the previous one.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`MousePointToIndex` 方法用于找到用户点击的段落，并调用 `MousePointToParagraphIndex` 方法来找到段落中的字符。我们将功能分为两个方法的原因是，[第7章](ch07.html
    "第7章。键盘输入和字符计算")中的 `MousePointToIndexDown` 方法，*键盘输入和字符计算*，也调用了 `MousePointToParagraphIndex`
    方法，该方法遍历段落列表。如果垂直位置小于段落的顶部位置，则正确的段落是前一个段落。'
- en: This somewhat cumbersome way of finding the correct paragraph is due to the
    fact that paragraphs are distributed over the pages in such manner that when a
    paragraph does not fit on the rest of the page, or if it is marked with a page
    break, it is placed at the beginning of the next page. This may result in parts
    of the document where no paragraph is located. If the user clicks on such an area,
    we want the paragraph located before that area to be the correct one. In the same
    way, if the user clicks below the last paragraph of the document, it becomes the
    correct one.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这种寻找正确段落的略显繁琐的方法是由于段落以这种方式分布在页面上，即当段落无法适应页面的其余部分，或者如果它带有分页符时，它被放置在下一页的开头。这可能会导致文档中没有任何段落的位置。如果用户点击这样的区域，我们希望该区域之前的段落是正确的。同样，如果用户点击文档的最后一个段落下方，它将成为正确的段落。
- en: '[PRE64]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The `MousePointToParagraphIndex` method finds the clicked character in the paragraph.
    First, we subtract the paragraph's top position from the mouse position, since
    the paragraph's line coordinates are relative to the paragraph's top position.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`MousePointToParagraphIndex` 方法用于找到段落中点击的字符。首先，我们从鼠标位置中减去段落的顶部位置，因为段落的行坐标是相对于段落顶部位置的。'
- en: '[PRE65]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: As mentioned previously, the user may click on a position below the paragraph's
    area. In that case, we set the mouse position to its height, `-1`, which is equivalent
    to the user clicking on the last line of the paragraph.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，用户可能点击在段落区域下方的一个位置。在这种情况下，我们将鼠标位置设置为它的`-1`高度，这相当于用户点击了段落的最后一行。
- en: '[PRE66]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: First, we need to find the correct line in the paragraph. We check every line
    and test if the mouse position is located within the line by comparing it to the
    sum of the line's top position and its height. Compared to the paragraph search
    in the `MousePointToIndex` method, as mentioned previously, this search is a bit
    simpler, since there is no space between the lines in the paragraph as there may
    be between the paragraphs in the document.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在段落中找到正确的行。我们检查每一行，并通过将其与行的顶部位置和高度的加和进行比较来测试鼠标位置是否位于行内。与之前提到的`MousePointToIndex`方法中的段落搜索相比，这个搜索要简单一些，因为段落中的行之间没有空格，而文档中的段落之间可能有空格。
- en: '[PRE67]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'When we have found the correct line, we have three cases to consider: the user
    may have clicked on the left of the text (if the paragraph is center or right
    aligned), to its right (if it is left or center aligned), or on the text itself.
    If they have clicked on the left or right of the line, we return the index of
    the first or last character of the line. Note that we add the index of the first
    character of the paragraph, since the indexes of the lines are relative to the
    paragraph''s first index.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们找到正确的行时，我们需要考虑三种情况：用户可能点击了文本的左侧（如果段落是居中或右对齐的），右侧（如果它是左对齐或居中对齐的），或者文本本身。如果他们点击了行的左侧或右侧，我们返回行的第一个或最后一个字符的索引。请注意，我们添加了段落第一个字符的索引，因为行的索引是相对于段落第一个索引的。
- en: '[PRE68]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: If the user has clicked on the text, we need to find the correct character.
    We iterate through the characters of the line and compare the mouse position to
    the right-hand border of the character. When we have found the correct character,
    we need to decide whether the user has clicked near the character's left or right
    border. In case of the right border, we add one to the character index.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户点击了文本，我们需要找到正确的字符。我们遍历行的字符，并将鼠标位置与字符的右侧边界进行比较。当我们找到正确的字符时，我们需要决定用户是否点击了字符的左侧或右侧边界。在右侧边界的情况下，我们将字符索引加一。
- en: '[PRE69]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'As mentioned previously, there is no space between the lines in a paragraph.
    Therefore, we will always find the correct line and never reach this point. However,
    in order to avoid compiler errors, we still have to return a value. In this book,
    we will on a few occasions use the following notation:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，段落中的行与行之间没有空格。因此，我们总能找到正确的行，永远不会达到这个点。然而，为了避免编译器错误，我们仍然必须返回一个值。在这本书中，我们会在少数情况下使用以下符号：
- en: '[PRE70]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: When the user double-clicks the left mouse button, the word hit by the mouse
    will be marked. The application has been set to `edit` mode and the `editIndex`
    method has been properly set, because the call to the `OnDoubleClick` method is
    always preceded by calls to the `OnMouseDown` and `OnMouseUp` methods. If the
    mouse hits a word, we mark the word and set the application to `mark` mode.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户双击鼠标左键时，鼠标击中的单词将被标记。应用已被设置为`编辑`模式，并且`editIndex`方法已经被适当地设置，因为对`OnDoubleClick`方法的调用总是先于对`OnMouseDown`和`OnMouseUp`方法的调用。如果鼠标击中了一个单词，我们将标记该单词并将应用设置为`标记`模式。
- en: We find the indexes of the first and last characters in a word by calling the
    `GetFirstWordIndex` and `GetLastWordIndex` methods. If the first index is less
    than the last index, the user has double-clicked on an actual word, which we mark.
    If the first index is not less than the last index, the user has double-clicked
    on a space or a delimiter, in which case the double-click has no effect.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用`GetFirstWordIndex`和`GetLastWordIndex`方法来找到单词的第一个和最后一个字符的索引。如果第一个索引小于最后一个索引，用户实际上双击了一个单词，我们将它标记。如果第一个索引不小于最后一个索引，用户双击了空格或分隔符，在这种情况下，双击没有效果。
- en: '[PRE71]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: In the `GetFirstWordIndex` method, we find the index of the first character
    of the word by going backward in the character list until we reach the beginning
    of the document or a character that is not a letter.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GetFirstWordIndex`方法中，我们通过在字符列表中向后移动直到我们到达文档的开始或一个非字母字符来找到单词的第一个字符的索引。
- en: '[PRE72]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: In the `GetLastWordIndex` method, we do not need to check the end of the character
    list, since the last character always is a newline, which is not a letter. Note
    that in this case we return the index of the character after the last character
    of the word, since the marking of text is valid up to, but not inclusive of, the
    last character.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GetLastWordIndex`方法中，我们不需要检查字符列表的末尾，因为最后一个字符始终是换行符，它不是一个字母。请注意，在这种情况下，我们返回单词最后一个字符之后的字符索引，因为文本标记有效到，但不包括最后一个字符。
- en: '[PRE73]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Touchscreen
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 触摸屏
- en: On a touchscreen, the user can zoom the document by dragging two fingers on
    the screen. The `OnTouchDown` method is called when the user touches the screen,
    and the `OnTouchMove` method is called when they move their fingers. Unlike the
    mouse input methods mentioned previously, the user can touch several points on
    the screen at the same time. The points are stored in the `pointList` list.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在触摸屏上，用户可以通过在屏幕上拖动两个手指来缩放文档。当用户触摸屏幕时，会调用`OnTouchDown`方法，当用户移动手指时，会调用`OnTouchMove`方法。与之前提到的鼠标输入方法不同，用户可以同时触摸屏幕上的多个点。这些点存储在`pointList`列表中。
- en: If the list does not hold two points, we just let the `Window` class perform
    the default action, which is to convert each touch action to a mouse action.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列表不包含两个点，我们只需让`Window`类执行默认操作，即将每个触摸动作转换为鼠标动作。
- en: '[PRE74]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'When the user moves their fingers on the screen, the distance between the fingers
    is calculated and the zoom is set with regard to the initial distance. The zooming
    is allowed to range between 10% (factor 0.1) and 1,000% (factor 10.0):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在屏幕上移动手指时，会计算手指之间的距离，并根据初始距离设置缩放。缩放的范围允许在10%（因子0.1）和1,000%（因子10.0）之间：
- en: '[PRE75]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Page setup and calculation
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 页面设置和计算
- en: The `OnPageSetup` method is called when the user selects the standard **Page
    Setup** menu item in the **File** menu. Since the page settings have been altered,
    we need to recalculate each paragraph as well as the whole document.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在**文件**菜单中选择标准**页面设置**菜单项时，会调用`OnPageSetup`方法。由于页面设置已被更改，我们需要重新计算每个段落以及整个文档。
- en: '[PRE76]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: A small change may affect the whole document, and we need to calculate the paragraphs
    and distribute them on the pages in the document.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 一个小的变化可能会影响整个文档，我们需要计算段落并将它们分配到文档的页面上。
- en: '[PRE77]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: We iterate through the paragraph list, and in case the current document height
    differs from the paragraph's top position, we update its top position and invalidate
    it.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遍历段落列表，如果当前文档高度与段落的顶部位置不同，我们更新其顶部位置并使其无效。
- en: '[PRE78]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: We have a page break if the paragraph is marked with a page break and if it
    is not already located at the top of a page.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果段落被标记为分页，并且它尚未位于页面顶部，则会有一个分页符。
- en: '[PRE79]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The paragraph does not fit on the rest of the page if its top position plus
    its height is greater than the page height.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果段落的顶部位置加上其高度大于页面高度，则段落无法适应页面的剩余部分。
- en: '[PRE80]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: If we have a page break, or if the paragraph does not fit on the rest of the
    page, we invalidate the rest of the page and place the paragraph at the top of
    the next page.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有分页符，或者如果段落无法适应页面的其余部分，我们需要使页面的其余部分无效，并将段落放置在下一页的顶部。
- en: '[PRE81]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Since the paragraph has been moved to a new position, we need to invalidate
    its new area.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 由于段落已移动到新位置，我们需要使其新区域无效。
- en: '[PRE82]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: If the paragraph fits on the rest of the document, we just increase the document
    height.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果段落可以适应文档的其余部分，我们只需增加文档高度。
- en: '[PRE83]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: After the last paragraph, we need to invalidate the rest of the last page.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个段落之后，我们需要使最后一页的其余部分无效。
- en: '[PRE84]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: If the number of pages has changed, we invalidate the pages that differ.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果页数已更改，我们需要使不同的页面无效。
- en: '[PRE85]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Painting and drawing
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制和绘图
- en: The `OnPaint` method performs the action that is specific to drawing the client
    area, while the `OnPrint` method performs the action specific to printing. The
    default behavior for both the `OnPaint` and `OnPrint` methods in the `StandardDocument`
    class is to call the `OnDraw` method.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnPaint`方法执行特定于绘制客户端区域的动作，而`OnPrint`方法执行特定于打印的动作。在`StandardDocument`类中，`OnPaint`和`OnPrint`方法的默认行为是调用`OnDraw`方法。'
- en: In the application of the previous chapters, we have overridden only the `OnDraw`
    method, resulting in the same drawing regardless of whether the drawing occurs
    in the client area or is sent to a printer. However, in this application, we also
    override the `OnPaint` method, which fills the parts of the client area outside
    the document with a light gray color and places the text **Page Break** between
    every pair of pages, and finally calls the `OnDraw` method that performs the actual
    drawing of the document.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章的应用中，我们只重写了 `OnDraw` 方法，导致无论绘图是在客户端区域发生还是发送到打印机，绘图结果都相同。然而，在这个应用中，我们还重写了
    `OnPaint` 方法，该方法用浅灰色填充客户端区域之外的文档部分，并在每对页面之间放置文本 **分页符**，最后调用执行实际文档绘制的 `OnDraw`
    方法。
- en: '[PRE86]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The `OnDraw` method draws every character in the `charList` list. The `drawMode`
    parameter is `Paint` if the `OnDraw` method is called by the `OnPaint` method,
    and `Print` if it is called by the `OnPrint` method. In the previous applications,
    we have ignored the `drawMode` method. However, in this application, we draw a
    small square at every paragraph marked with a page break, if called by the `OnPaint`
    method.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnDraw` 方法绘制 `charList` 列表中的每个字符。当 `OnDraw` 方法由 `OnPaint` 方法调用时，`drawMode`
    参数为 `Paint`，而当它由 `OnPrint` 方法调用时，`drawMode` 参数为 `Print`。在先前的应用中，我们忽略了 `drawMode`
    方法。然而，在这个应用中，如果由 `OnPaint` 方法调用，我们会在每个带有分页符的段落处绘制一个小方块。'
- en: '[PRE87]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: If the character is marked, its text and background colors are inverted.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字符被标记，其文本和背景颜色将被反转。
- en: '[PRE88]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: If the character is newline, a space is drawn instead.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字符是换行符，则绘制一个空格代替。
- en: '[PRE89]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: If the character's rectangle is located outside the page, its right border is
    set to the page right border.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字符的矩形位于页面之外，其右边界被设置为页面右边界。
- en: '[PRE90]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Finally, the character is drawn:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，绘制字符：
- en: '[PRE91]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Actually, there is one more thing: if the `OnDraw` method has been called by
    the `OnPaint` method, we draw a small red square (2 × 2 millimeters) at its top-left
    position for every paragraph marked with a page break.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，还有一件事：如果 `OnDraw` 方法已经被 `OnPaint` 方法调用，我们会在每个带有分页符的段落的左上角绘制一个小红色方块（2 × 2
    毫米）。
- en: '[PRE92]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: File management
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件管理
- en: The `ClearDocument` method is called by the `StandardDocument` class when the
    user selects the **New** menu item in the **File** menu; the `WriteDocumentToStream`
    method is called when they select the **Save** or **Save As** menu items in the
    **File** menu, and the `ReadDocumentFromStream` method is called when they select
    the **Open** menu item.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在 **文件** 菜单中选择 **新建** 菜单项时，`StandardDocument` 类会调用 `ClearDocument` 方法；当用户在
    **文件** 菜单中选择 **保存** 或 **另存为** 菜单项时，会调用 `WriteDocumentToStream` 方法，而当用户选择 **打开**
    菜单项时，会调用 `ReadDocumentFromStream` 方法。
- en: The `ClearDocument` method deletes every paragraph in the `paragraphList` list
    by calling the `DeleteParagraph` method, which, in turn, deletes each line of
    the paragraph. This is actually the only memory we need to delete, since it is
    the only dynamically allocated memory of this application. Finally, the `InitDocument`
    method is called, which initializes an empty document.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClearDocument` 方法通过调用 `DeleteParagraph` 方法删除 `paragraphList` 列表中的每个段落，而 `DeleteParagraph`
    方法会删除段落的每一行。实际上，这是我们唯一需要删除的内存，因为它是本应用唯一动态分配的内存。最后，会调用 `InitDocument` 方法，该方法初始化一个空文档。'
- en: '[PRE93]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The `WriteDocumentToStream` method writes all the information about the document
    to the stream: the `application` mode (edit or mark), the index of the edit character,
    the indexes of the first and last marked characters, the number of pages in the
    document, and the next font. The idea is that the document will be opened in the
    exact same shape as it was written.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`WriteDocumentToStream` 方法将有关文档的所有信息写入流：`application` 模式（编辑或标记）、编辑字符的索引、第一个和最后一个标记字符的索引、文档中的页数以及下一个字体。想法是文档将以写入时的确切形状打开。'
- en: '[PRE94]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: However, if the file suffix is `.txt`, we save the word in text format and discard
    all formatting.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果文件扩展名是 `.txt`，我们将单词以文本格式保存并丢弃所有格式。
- en: '[PRE95]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The `ReadDocumentFromStream` method reads the information written by the `WriteDocumentToStream`
    method. Note that the `MakeVisible` method is called at the end in order to make
    the current position visible.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReadDocumentFromStream` 方法读取由 `WriteDocumentToStream` 方法写入的信息。请注意，为了使当前位置可见，在最后会调用
    `MakeVisible` 方法。'
- en: '[PRE96]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: However, if the file has the file suffix `.txt`, we just read the characters,
    and all characters are given the system font.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果文件具有文件扩展名 `.txt`，我们只读取字符，并且所有字符都赋予系统字体。
- en: '[PRE97]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Cut, copy, and paste
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 剪切、复制和粘贴
- en: 'The **Copy** item in the **Edit** menu is enabled in `mark` mode:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '**编辑**菜单中的**复制**项在`mark`模式下是启用的：'
- en: '[PRE98]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: As long as the `CopyEnable` method mentioned previously returns `true`, we are
    always ready to copy in every format. Therefore, we must let the `IsCopyAsciiReady`,
    `IsCopyUnicodeReady`, and `IsCopyGenericReady` methods return `true` (if they
    return `false` in the `StandardDocument` class).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 只要之前提到的`CopyEnable`方法返回`true`，我们就始终准备好以每种格式进行复制。因此，我们必须让`IsCopyAsciiReady`、`IsCopyUnicodeReady`和`IsCopyGenericReady`方法返回`true`（如果它们在`StandardDocument`类中返回`false`）。
- en: '[PRE99]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: The `CopyAscii` method simply calls the `CopyUnicode` method, since the text
    is stored in the generic text format and is transformed into ASCII and Unicode
    when saved to the global clipboard. The `CopyUnicode` method iterates through
    the marked paragraphs and, for each marked paragraph, extracts the marked text
    that is stored in the paragraph to the `textList` parameter. When it encounters
    a newline, it pushes the current text in the `textList` parameter.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`CopyAscii`方法简单地调用`CopyUnicode`方法，因为文本以通用文本格式存储，并在保存到全局剪贴板时转换为ASCII和Unicode。`CopyUnicode`方法遍历标记的段落，并且对于每个标记段落，将存储在段落中的标记文本提取到`textList`参数中。当它遇到换行符时，它将`textList`参数中的当前文本推入。'
- en: '[PRE100]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: The `CopyGeneric` method is simpler than the `CopyUnicode` method. It first
    saves the number of characters to be copied, then iterates through the marked
    characters (not the paragraphs), and then calls the `WriteCharInfoToClipboard`
    method for each character. This works, since each pair of paragraphs is already
    separated by a newline in the `charList` list. We really do not care about the
    format, since there is just one format (`WordFormat`) for generic cut, copy, and
    paste operations in this application.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`CopyGeneric`方法比`CopyUnicode`方法简单。它首先保存要复制的字符数，然后遍历标记的字符（不是段落），然后对每个字符调用`WriteCharInfoToClipboard`方法。这可行，因为`charList`列表中每对段落之间已经通过换行符分隔。我们实际上并不关心格式，因为在这个应用程序中，通用剪切、复制和粘贴操作只有一个格式（`WordFormat`）。'
- en: '[PRE101]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: One difference between copying and pasting is that when the user selects **Cut**
    or **Copy**, the marked text is copied in all three formats (ASCII, Unicode, and
    generic) given in the preceding `StandardDocument` constructor. Their order does
    not really matter. When pasting, on the other hand, the `StandardDocument` constructor
    tries to paste the text in the formats order given in the constructor call. If
    it finds pasted information in one format in the global clipboard, it does not
    continue to check the other format. In this application, it means that if there
    is text copied in the generic format (`WordFormat`), then that text is pasted
    regardless of whether there is text in the ASCII of Unicode format (`AsciiFormat`
    or `UnicodeFormat`).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 复制和粘贴之间的一个区别在于，当用户选择**剪切**或**复制**时，在先前的`StandardDocument`构造函数中给出的所有三种格式（ASCII、Unicode和通用）都会被复制。它们的顺序并不重要。另一方面，在粘贴时，`StandardDocument`构造函数会尝试按照构造函数调用中给出的格式顺序粘贴文本。如果它在全局剪贴板中找到一个格式的粘贴信息，它就不会继续检查其他格式。在这个应用程序中，这意味着如果以通用格式（`WordFormat`）复制了文本，那么无论ASCII或Unicode格式（`AsciiFormat`或`UnicodeFormat`）中是否有文本，都会粘贴该文本。
- en: The `PasteAscii` method calls the `PasteUnicode` method (again, both ASCII and
    Unicode text are transformed into the generic text type), which iterates through
    the `textList` parameter and inserts a new paragraph for each text. Note that
    we do not override the `PasteEnable` method, since the `StandardDocument` constructor
    handles it by checking if there is a clipboard buffer with any of the formats
    defined in the `StandardDocument` constructor call.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`PasteAscii`方法调用`PasteUnicode`方法（再次，ASCII和Unicode文本都被转换成通用文本类型），它遍历`textList`参数，并为每个文本插入一个新的段落。请注意，我们没有重写`PasteEnable`方法，因为`StandardDocument`构造函数通过检查是否存在包含在`StandardDocument`构造函数调用中定义的任何格式的剪贴板缓冲区来处理它。'
- en: The idea is that the first and last text in text list will be merged by the
    first and last part of the edit paragraph. The potential remaining text will be
    inserted as paragraphs in between. First we delete the marked text, if present,
    ensure `edit` mode, and clear the `nextFont` parameter (setting it to `SystemFont`).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是文本列表中的第一和最后一段文本将通过编辑段落的第一个和最后部分合并。潜在剩余的文本将作为段落插入其中。首先，如果存在标记文本，我们确保`edit`模式，并清除`nextFont`参数（将其设置为`SystemFont`）。
- en: '[PRE102]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: We remove the edit paragraph from the paragraph list, which makes it easier
    to insert the pasted paragraphs later on.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从段落列表中移除了编辑段落，这使得稍后插入粘贴的段落更加容易。
- en: '[PRE103]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: We use the font of the edit character and the alignment of the edit paragraph
    for the pasted characters and paragraphs.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为粘贴的字符和段落使用编辑字符的字体和编辑段落的对齐方式。
- en: '[PRE104]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: We save the number of the remaining characters of the edit paragraph. We also
    save the current edit index in order to calculate the total number of pasted characters
    at the end.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们保存编辑段落剩余字符的数量。我们还保存当前编辑索引，以便计算最终粘贴字符的总数。
- en: '[PRE105]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: We insert the characters of each text in the edit paragraph.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编辑段落中的每个文本的字符插入。
- en: '[PRE106]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Since each text will finish a paragraph, except the last one, we create and
    insert a new paragraph.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个文本都将完成一个段落（除了最后一个），我们创建并插入一个新的段落。
- en: '[PRE107]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: For the last text, we use the original edit paragraph and change its last character
    index.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最后一段文本，我们使用原始编辑段落并更改其最后一个字符索引。
- en: '[PRE108]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: We may also need to update the index of the succeeding paragraphs, since more
    than one paragraph may have been pasted. Since we know that at least one character
    has been pasted, we certainly need to at least modify the first and last index
    of the succeeding paragraphs.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能还需要更新后续段落的索引，因为可能粘贴了多个段落。由于我们知道至少粘贴了一个字符，我们肯定需要至少修改后续段落的第一和最后一个索引。
- en: '[PRE109]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: The `PasteGeneric` method reads and inserts the generic paragraph information
    stored in the clipboard in a way similar to the preceding `PasteUnicode` method.
    The difference is that the paragraphs are separated to be newlines and that each
    pasted character comes with its own font.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`PasteGeneric` 方法以类似于先前的 `PasteUnicode` 方法的方式读取并插入存储在剪贴板中的通用段落信息。不同之处在于段落被分隔成换行符，并且每个粘贴的字符都带有自己的字体。'
- en: '[PRE110]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: We erase the edit paragraph in order to make the insertion easier, just as in
    the preceding `PasteUnicode` method. We use the alignment of the edit paragraph,
    but not the font of the edit character since each pasted character has its own
    font.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们擦除编辑段落以使插入更容易，就像在先前的 `PasteUnicode` 方法中一样。我们使用编辑段落的对齐方式，但不使用编辑字符的字体，因为每个粘贴的字符都有自己的字体。
- en: '[PRE111]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: We read the paste size, which is the number of character to be pasted.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们读取粘贴的大小，即要粘贴的字符数。
- en: '[PRE112]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: We read each character from the paste buffer and insert the characters into
    the character list. When we encounter a newline, we insert a new paragraph.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从粘贴缓冲区中读取每个字符并将字符插入到字符列表中。当我们遇到换行符时，我们插入一个新段落。
- en: '[PRE113]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: We need to calculate the original paragraph before we insert it.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在插入之前，我们需要计算原始段落。
- en: '[PRE114]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Similar to the preceding `PasteUnicode` case, we may need to update the index
    of the succeeding paragraphs, since more than one paragraph may have been pasted.
    We also need to modify their first and last index, since at least one character
    has been pasted.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的 `PasteUnicode` 情况类似，我们可能需要更新后续段落的索引，因为可能粘贴了多个段落。我们还需要修改它们的第一和最后一个索引，因为至少粘贴了一个字符。
- en: '[PRE115]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Delete
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除
- en: 'In `edit` mode, it is possible to delete a character unless it is located at
    the very end of the document. In `mark` mode, the marked text can always always
    be deleted:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `edit` 模式下，除非字符位于文档的末尾，否则可以删除字符。在 `mark` 模式下，标记的文本始终可以被删除：
- en: '[PRE116]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: In `edit` mode, we delete the edit character, and in `mark` mode, we delete
    the marked text. In both cases, we call the `Delete` method to perform the actual
    deleting.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `edit` 模式下，我们删除编辑字符，在 `mark` 模式下，我们删除标记的文本。在这两种情况下，我们都调用 `Delete` 方法来执行实际的删除操作。
- en: '[PRE117]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: The `Delete` method is called by the `OnDelete`, `EnsureEditStatus`, `PasteUnicode`,
    and `PasteGeneric` methods. It removes the characters between the given indexes,
    which do not have to be in order. The removed paragraphs are deleted and the succeeding
    paragraphs are updated.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`Delete` 方法由 `OnDelete`、`EnsureEditStatus`、`PasteUnicode` 和 `PasteGeneric`
    方法调用。它删除给定索引之间的字符，这些字符不必按顺序排列。被删除的段落被删除，后续段落被更新。'
- en: '[PRE118]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: The deleted area covers at least two paragraphs, we set the characters of the
    maximal paragraph to point at the minimal paragraph, since they will be merged.
    We also set their rectangles to zero, to ensure that they will be redrawn.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 被删除的区域至少覆盖两个段落，我们将最大段落的字符设置为指向最小段落，因为它们将被合并。我们还将它们的矩形设置为零，以确保它们将被重新绘制。
- en: '[PRE119]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: The characters are removed from the `charList` list and the last index of the
    minimal paragraph is updated. It is set to the last character of the maximal paragraph
    (that may be the same paragraph as the minimal paragraph) minus the number of
    the characters to be deleted. The minimal paragraph is then regenerated.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 字符将从`charList`列表中删除，并且最小段落的最后一个索引被更新。它被设置为最大段落（可能和最小段落相同）的最后一个字符减去要删除的字符数。然后重新生成最小段落。
- en: '[PRE120]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: The paragraphs between the minimal and maximal paragraphs, if any, are deleted
    and the indexes of the succeeding paragraphs are set. We call `DeleteParagraph`
    for each paragraph to delete their dynamically allocated memory.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在，最小和最大段落之间的段落被删除，并且后续段落的索引被设置。我们为每个段落调用`DeleteParagraph`以删除它们的动态分配的内存。
- en: '[PRE121]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Finally, we need to set the indexes of the succeeding paragraphs. Note that
    we have to update the first and last index regardless of whether any paragraphs
    have been removed, since we have removed at least one character.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要设置后续段落的索引。请注意，无论是否已经删除了任何段落，我们都必须更新第一个和最后一个索引，因为我们至少删除了一个字符。
- en: '[PRE122]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: When the delete process is finished, the application is set to `edit` mode,
    and the edit index is set to the first marked character.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 当删除过程完成后，应用程序设置为`编辑`模式，并且编辑索引被设置为第一个标记的字符。
- en: '[PRE123]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Page break
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分页符
- en: 'The **PageBreak** menu item is enabled in `edit` mode, and the `OnPageBreak`
    method is also quite simple. It just inverses the page break status of the edit
    paragraph:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在`编辑`模式下，**分页符**菜单项被启用，并且`OnPageBreak`方法也非常简单。它只是反转编辑段落的分页符状态：
- en: '[PRE124]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Font
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字体
- en: 'The `OnFont` method is called when the user selects the **Font** menu item
    and it displays the font dialog. In `edit` mode, we first need to find the default
    font to use in the dialog. If the `nextFont` parameter is active (does not equal
    `SystemFont`), we use it. If it is not active, we check whether the edit character
    is the first character in the paragraph. If it is the first character, we use
    its font. If it is not the first character, we use the font of its preceding character.
    This is the same procedure as in the preceding `UpdateCaret` method:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择**字体**菜单项并显示字体对话框时，会调用`OnFont`方法。在`编辑`模式下，我们首先需要找到对话框中要使用的默认字体。如果`nextFont`参数是活动的（不等于`SystemFont`），我们使用它。如果不是活动的，我们检查编辑字符是否是段落的第一个字符。如果是第一个字符，我们使用它的字体。如果不是第一个字符，我们使用其前一个字符的字体。这与前面的`UpdateCaret`方法中的相同程序：
- en: '[PRE125]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: If the user closes the font dialog by choosing **Ok**, we set the `nextFont`
    parameter and recalculate the edit paragraph.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户通过选择**确定**来关闭字体对话框，我们将设置`nextFont`参数并重新计算编辑段落。
- en: '[PRE126]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: In `mark` mode, we choose the font of the marked character with the lowest index
    to be the default font in the font dialog.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在`标记`模式下，我们选择具有最低索引的标记字符作为字体对话框中的默认字体。
- en: '[PRE127]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: If the user chooses **Ok**, we set the font of every marked character and recalculate
    each of their paragraphs.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户选择**确定**，我们将设置每个标记字符的字体并重新计算它们的每个段落。
- en: '[PRE128]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Alignment
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对齐
- en: All the radio alignment listeners call the `IsAlignment` method, and all selection
    listeners call the `SetAlignment` method.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 所有单选对齐监听器调用`IsAlignment`方法，所有选择监听器调用`SetAlignment`方法。
- en: '[PRE129]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: In `edit` mode, the `IsAlignment` method checks whether the edit paragraph has
    the given alignment. In `mark` mode, it checks if all partly or completely marked
    paragraph have the given alignment. This implies that if several paragraphs are
    marked with different alignments, no alignment menu item will be marked with a
    radio button.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在`编辑`模式下，`IsAlignment`方法检查编辑段落是否具有给定的对齐方式。在`标记`模式下，它检查所有部分或完全标记的段落是否具有给定的对齐方式。这意味着如果几个段落被标记为不同的对齐方式，则没有对齐菜单项会被标记为单选按钮。
- en: '[PRE130]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: The `SetAlignment` method sets the alignment of the edited or marked paragraphs.
    In `edit` mode, we just set the alignment of the edit paragraph. Remember that
    this method can only be called when the paragraph has another alignment. In `mark`
    mode, we traverse the marked paragraphs and set the alignment on those paragraphs
    that do not have the alignment already in question. Also remember that this method
    can only be called if at least one paragraph does not hold the alignment in question.
    The paragraphs that have changed alignment need to be recalculated. However, the
    new alignment does not affect the height of the paragraph, which implies that
    we do not need to call the `CalculateDocument` method for the remaining paragraphs.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetAlignment` 方法设置编辑或标记段落的对齐方式。在 `edit` 模式下，我们只设置编辑段落的对齐方式。请记住，此方法只能在段落具有另一种对齐方式时调用。在
    `mark` 模式下，我们遍历标记段落，并设置那些尚未具有所讨论对齐方式的段落的对齐方式。也要记住，此方法只能在至少有一个段落不保持所讨论对齐方式的情况下调用。需要重新计算对齐方式的段落。然而，新的对齐方式不会影响段落的长度，这意味着我们不需要为剩余的段落调用
    `CalculateDocument` 方法。'
- en: '[PRE131]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Summary
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you started to develop a word processor capable of handling
    individual characters. The word processor supports the following:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你开始开发一个能够处理单个字符的字处理器。该字处理器支持以下功能：
- en: Individual font and style of each character
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个字符的独立字体和样式
- en: Left, center, right, and justified alignment of each paragraph
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个段落的左对齐、居中对齐、右对齐和对齐方式
- en: Paragraphs that are distributed over the pages
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布在页面上的段落
- en: Scrolling and zooming
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滚动和缩放
- en: Touchscreen
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触摸屏
- en: Cut, copy, and paste with ASCII or Unicode text, as well as application-specific
    generic information
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ASCII 或 Unicode 文本进行剪切、复制和粘贴，以及应用特定的通用信息
- en: In [Chapter 7](ch07.html "Chapter 7. Keyboard Input and Character Calculation"),
    *Keyboard Input and Character Calculation*, we will continue with the keyboard
    input and character calculation.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 7 章](ch07.html "第 7 章。键盘输入和字符计算")，*键盘输入和字符计算* 中，我们将继续讨论键盘输入和字符计算。
