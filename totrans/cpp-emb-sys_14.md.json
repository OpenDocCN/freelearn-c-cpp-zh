["```cpp\ntemplate <unsigned int N>\n`struct` factorial {\n    static const unsigned int value = N * factorial<N-1>::value;\n};\ntemplate <>\n`struct` factorial<0> {\n    static const unsigned int value = 1;\n};\nint main () {\n    const int fact = factorial<5>::value;\n    return fact;\n} \n```", "```cpp\nmain:\npush rbp\nmov rbp, rsp\nmov DWORD PTR [rbp-4], 120\nmov eax, 120\npop rbp\nret \n```", "```cpp\n#include <cmath>\nint main () {\n    `constexpr` int ret = round(sin(3.14));\n    return ret;\n} \n```", "```cpp\n<source>:4:19: error: constexpr variable 'ret' must be initialized by a constant expression\n    4 |     constexpr int ret = round(sin(3.14));\n      |                   ^     ~~~~~~~~~~~~~~~~\n<source>:4:31: note: non-constexpr function 'sin' cannot be used in a constant expression\n    4 |     constexpr int ret = round(sin(3.14)); \n```", "```cpp\nconstexpr unsigned int factorial(unsigned int n) {\n    unsigned int prod = 1;\n    while(n > 0) {\n        prod *= n;\n        n--;\n    }\n    return prod;\n}\nint main () {\n    constexpr int calc_val = 5;\n    constexpr unsigned int ret = factorial(calc_val);\n    return ret;\n} \n```", "```cpp\n#include <array>\n#include <cstdint>\n#include <string_view>\n#include <charconv>\n`struct` mac_address {\n    static constexpr std::size_t c_bytes_num = 6;\n    static constexpr std::size_t c_mac_addr_str_size = 17;\n\n    std::array<uint8_t, c_bytes_num> bytes{};\n    bool is_valid = false;\n    constexpr mac_address(std::string_view str) {\n        if (str.size() != c_mac_addr_str_size) {\n            return;\n        }\n        for (size_t i = 0; i < c_bytes_num; ++i) {\n            const std::string_view byte_str = str.substr(i * 3, 2);\n            uint8_t value = 0;\n            auto result = std::from_chars(byte_str.data(), byte_str.data() \n + byte_str.size(), value, 16);\n            if (result.ec != std::errc()) {\n                return;\n            }\n            bytes[i] = value;\n        }\n        is_valid = true;\n    }\n};\nint main () {\n    constexpr mac_address addr(\"00:11:22:33:44:55\");\n    static_assert(addr.is_valid);\n    return addr.bytes.at(5);\n} \n```", "```cpp\n$ cd Chapter11/compile_time\n$ cmake -B build -DCMAKE_BUILD_TYPE=MinSizeRel -DMAIN_CPP_FILE_NAME=main_constexpr_mac_address.cpp\n$ cmake --build build --target run_in_renode \n```", "```cpp\nconstexpr mac_address addr(\"00:11:22:33:44:55\");\nstatic_assert(addr.is_valid);\nconst std::array<uint8_t, 6> addr_arr{0x00, 0x11, 0x22, 0x33, 0x44, 0x55};\nconst auto & mac_ref = addr.bytes;\n//const auto & mac_ref = addr_arr;\nprintf(\"%02X:%02X:%02X:%02X:%02X:%02X\\r\\n\", mac_ref[0], mac_ref[1], mac_ref[2], mac_ref[3], mac_ref[4], mac_ref[5]); \n```", "```cpp\n    #include <array>\n    #include <cstdio>\n    template <typename T, std::size_t N>\n    `struct` signal : public std::array<T, N> {\n      constexpr signal() {}\n      constexpr signal(T begin, T end) {\n        static_assert(N > 1, \"N must be bigger than 1\"); \n        float step = (end - begin) / (N - 1);\n        for (std::size_t i = 0; i < N; i++) {\n          this->at(i) = begin + i * step;\n        }\n      }\n    };\n    int main() {\n        constexpr signal<float, 10> x_axis(0, 9);\n        for(auto elem: x_axis) {\n            printf(\"%.2f, \", elem);\n        }\n        printf(\"\\r\\n\");\n        return 0;\n    } \n    ```", "```cpp\n0.00, 1.00, 2.00, 3.00, 4.00, 5.00, 6.00, 7.00, 8.00, 9.00, \n```", "```cpp\n    template <typename T, std::size_t N>\n    `struct` signal : public std::array<T, N> {\n    // ...\n    constexpr signal(const signal &sig, auto fun) {\n        for (std::size_t i = 0; i < N; i++) {\n          this->at(i) = fun(sig.at(i));\n        }\n      }\n    }; \n    ```", "```cpp\n    int main() {\n        const auto print_signal = [](auto sig) {\n            for(auto elem: sig) {\n                printf(\"%.2f, \", elem);\n            }\n            printf(\"\\r\\n\");\n        };\n        constexpr signal<float, 10> x_axis(0, 9);\n        print_signal(x_axis);\n        auto sine = signal(x_axis, [](float x){ return std::sin(x);});\n        print_signal(sine);\n        return 0;\n    } \n    ```", "```cpp\n0.00, 1.00, 2.00, 3.00, 4.00, 5.00, 6.00, 7.00, 8.00, 9.00,\n0.00, 0.84, 0.91, 0.14, -0.76, -0.96, -0.28, 0.66, 0.99, 0.41, \n```", "```cpp\n    template <typename T, std::size_t N>\n    `struct` signal : public std::array<T, N> {\n    // ...\n    constexpr signal operator*(const T &t) const {\n        return signal(*this, [&](T elem)\n                      { return elem * t; });\n      };\n      constexpr signal operator/(const T &t) const {\n        return signal(*this, [&](T elem)\n                      { return elem / t; });\n      };\n     }; \n    ```", "```cpp\nauto result = sig * 2.0f; \n```", "```cpp\n    auto result = sig / 2.0f; \n    ```", "```cpp\n    template <typename T, std::size_t N>\n    struct signal : public std::array<T, N> {\n    // ...\n    friend constexpr signal operator*(const T &t, const signal &sig)\n      {\n        return sig * t;\n      }\n      friend constexpr signal operator/(const T &t, const signal &sig)\n      {\n        signal ret;\n        for (std::size_t i = 0; i < N; i++) {\n          ret.at(i) = t / sig.at(i);\n        }\n        return ret;\n      }\n    }; \n    ```", "```cpp\n    int main() {\n        // ...\n    constexpr signal<float, 10> x_axis(0, 9);\n        print_signal(x_axis);\n        auto linear_fun = 2.f * x_axis;\n        print_signal(linear_fun);\n        auto linear_fun2 = linear_fun / 2.f;\n        print_signal(linear_fun2);\n        return 0;\n    } \n    ```", "```cpp\n0.00, 1.00, 2.00, 3.00, 4.00, 5.00, 6.00, 7.00, 8.00, 9.00,\n0.00, 2.00, 4.00, 6.00, 8.00, 10.00, 12.00, 14.00, 16.00, 18.00,\n0.00, 1.00, 2.00, 3.00, 4.00, 5.00, 6.00, 7.00, 8.00, 9.00, \n```", "```cpp\n    template <typename T, std::size_t N>\n    struct signal : public std::array<T, N> {\n    // ...\n    constexpr signal operator+(const T &t) const {\n        return signal(*this, [&](T elem)\n                      { return elem + t; });\n      };\n      constexpr signal operator-(const T &t) const {\n        return signal(*this, [&](T elem)\n                      { return elem - t; });\n      };\n      constexpr signal operator+(const signal &sig) const {\n        signal ret;\n        for (std::size_t i = 0; i < N; i++)\n        {\n          ret.at(i) = this->at(i) + sig.at(i);\n        }\n        return ret;\n      };\n      friend constexpr signal operator+(const T &t, const signal &sig)\n      {\n        return sig + t;\n      }\n    }; \n    ```", "```cpp\nint main()\n{\n  constexpr float A = 1.18090254918130e-3;\n  constexpr float B = 2.16884014794388e-4;\n  constexpr float C = 1.90058756197216e-6;\n  constexpr float D = 1.83161892641824e-8;\n  constexpr int c_lut_points = 50;\n  constexpr signal<float, c_lut_points> resistance(1e3, 10e3);\n  constexpr auto temperature_k =\n  1 / (A +\n  B * signal(resistance, [](float x)\n                    { return std::log(x); }) +\n  C * signal(resistance, [](float x)\n                    { return std::pow(std::log(x), 2); }) +\n  D * signal(resistance, [](float x)\n                    { return std::pow(std::log(x), 3); }));\n  constexpr auto temperature_celsius = temperature_k - 273.15f;\n  std::ofstream file(\"out.csv\");\n  file << \"Resistance[Ohm], Temperature[Celsius]\\n\";\n  for (int i = 0; i < c_lut_points; i++) {\n    file << resistance[i] << \", \" << temperature_celsius[i] << \"\\n\";\n  }\n  return 0;\n} \n```", "```cpp\n$ cd Chapter11/signal_generator\n$ cmake -B build\n$ cmake --build build\n$ ./build/signal_gen \n```", "```cpp\n$ graph out.csv -o curve.png \n```", "```cpp\n$ docker cp dev_env:/workspace/Cpp-in-Embedded-Systems/Chapter11/signal_generator/curve.png \n```", "```cpp\nstruct voltage_divider {\n        units::resistance r2;\n        units::voltage vcc;\n        units::resistance get_r1(units::voltage vadc) {\n            return r2 * (vcc/vadc - 1);\n        }\n    };\nvoltage_divider divider{10e3_Ohm, 3.3_V}; \n```", "```cpp\nauto adc_val = adc.get_reading();\nif(adc_val) {\n  auto adc_val_voltage = *adc_val;\n  auto thermistor_r = divider.get_r1(adc_val_voltage);\n  auto it = std::lower_bound(resistance.begin(),    \n                resistance.end(), thermistor_r.get());\n  if(it != resistance.end()) {\n     std::size_t pos = std::distance(resistance.begin(), it);\n     float temperature = temperature_celsius.at(pos);\n     printf(\"%d mV, %d Ohm, %d.%d C\\r\\n\",\n           static_cast<int>(adc_val_voltage.get_mili()),\n           static_cast<int>(thermistor_r.get()),\n           static_cast<int>(temperature),\n           static_cast<int>(10*(temperature-std::floor(temperature))) );\n    }\n  }\nhal::time::delay_ms(200); \n```", "```cpp\n$ cd Chapter11/compile_time\n$ cmake -B build -DCMAKE_BUILD_TYPE=MinSizeRel -DMAIN_CPP_FILE_NAME=main_lookup_table.cpp\n$ cmake --build build --target run_in_renode \n```", "```cpp\n$ adc FeedVoltageSampleToChannel 0 1700 3 \n```", "```cpp\n1699 mV, 9412 Ohm, 26.2 C \n```", "```cpp\nconstexpr int square(int x) {\n    return x*x;\n}\nint main() {\n    constexpr int arg = 2;\n    int ret = square(arg);\n    return ret;\n} \n```", "```cpp\nconsteval int square(int x) {\n    return x*x;\n}\nint main() {\n    constexpr int arg = 2;\n    int ret = square(arg);\n    return ret;\n} \n```", "```cpp\n<source>: In function 'int main()':\n<source>:7:21: error: call to consteval function 'square(arg)' is not a constant expression\n    7 |     int ret = square(arg);\n      |               ~~~~~~^~~~~\n<source>:7:21: error: the value of 'arg' is not usable in a constant expression\n<source>:6:9: note: 'int arg' is not const\n    6 |     int arg = 2;\n      |         ^~~ \n```"]