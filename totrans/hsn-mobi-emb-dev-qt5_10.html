<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Where Am I? Location and Positioning</h1>
                </header>
            
            <article>
                
<p class="mce-root">Devices with GPS chips are everywhere. You can even track your cat or chicken! In this chapter, you will learn how to use Qt for location and positioning services.</p>
<p>Qt Positioning entails geographic coordinates from various sources, including satellites, Wi-Fi, and log files. <span>Qt Location is all about local places, for example services, such as restaurants or public parks, and also routing information.</span></p>
<p class="mce-root">In this chapter, we will cover the following topics:</p>
<ul>
<li>Positioning with satellites</li>
<li>Mapping the positions</li>
<li>Places of interest</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Positioning with satellites</h1>
                </header>
            
            <article>
                
<p class="mce-root"><span>A phone usually has a built-in GPS modem but also other sources of positioning information, so I will use Android for this example. The main Qt classes we will look at are as follows:</span></p>
<p class="mce-root">Here are the Qt Positioning APIs:</p>
<ul>
<li class="mce-root"><kbd>QGeoSatelliteInfo</kbd></li>
<li class="mce-root"><kbd>QGeoLocation</kbd></li>
<li>
<div>
<div><kbd><span>QGeoPositionInfoSource</span></kbd></div>
</div>
</li>
<li class="mce-root"><kbd>QGeoCoordinate</kbd></li>
</ul>
<p>And here are the Qt Location APIs:</p>
<ul>
<li class="mce-root"><kbd>QPlaceSearchResult</kbd></li>
<li class="mce-root"><kbd>QPlaceContent</kbd></li>
<li class="mce-root"><kbd>QGeoRoute</kbd></li>
</ul>
<p>First, we need to edit the <kbd>.pro</kbd> file and add <kbd>QT += positioning</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QGeoSatelliteInfoSource</h1>
                </header>
            
            <article>
                
<p><span>You can show the user satellite information by using </span><kbd>QGeoSatelliteInfoSource</kbd>, <span>which has a <kbd>static</kbd> method t</span><span>o get </span><kbd>QGeoSatelliteInfoSource.</kbd></p>
<div class="packt_infobox"><span>The source code can be found on the Git repository under the </span><kbd>Chapter08-1</kbd><span> directory, in the</span><span> <kbd>cp8</kbd> </span><span>branch.</span></div>
<p><span>We will start by calling </span><kbd>QGeoSatelliteInfoSource::createDefaultSource</kbd><span>.</span></p>
<pre><span>QGeoSatelliteInfoSource</span><span> </span><span>*source = </span><span>QGeoSatelliteInfoSource</span><span>::</span><span>createDefaultSource</span><span>(</span><span>this</span><span>);</span></pre>
<div class="packt_infobox"><span>On some systems, such as iOS, satellite information is not exposed to the public API, so </span><span><kbd>QGeoSatelliteInfoSource</kbd> will not work on that platform.</span></div>
<p><span><span>This</span></span> constructs a <kbd>QGeoSatelliteInfoSource</kbd> object for the highest-priority plugin on the system, which is about the same as doing the following:</p>
<pre><span>QStringList</span><span> </span>geoSources<span> </span><span>=</span><span> </span><span>QGeoSatelliteInfoSource</span><span>::</span><span>availableSources</span><span>();<br/></span><span>QGeoSatelliteInfoSource</span><span> </span><span>*</span><span>source</span><span> </span><span>=</span><span> </span><span>QGeoSatelliteInfoSource</span><span>::</span><span>createSource</span><span>(</span>geoSources<span>.</span><span>at</span><span>(</span><span>0</span><span>),</span><span>this</span><span>);</span></pre>
<p>There are two signals of particular interest: <kbd>satellitesInUseUpdated</kbd> and <kbd>satellitesInViewUpdated</kbd>. In addition, there is the overloaded <kbd>error</kbd> signal, so we need to use the special <kbd>QOverload</kbd> syntax:</p>
<pre><span>connect</span><span>(</span><span>source</span><span>,</span><span> </span><span>QOverload</span><span>&lt;</span><span>QGeoSatelliteInfoSource</span><span>::</span><span>Error</span><span>&gt;::<br/></span><span>    of</span><span>(</span><span>&amp;</span><span>QGeoSatelliteInfoSource</span><span>::</span><span>error</span><span>), <br/></span><span>    this</span><span>,</span><span> </span><span>&amp;</span><span>SomeClass</span><span>::</span><span>error</span><span>);</span></pre>
<p class="mce-root"/>
<p><span>The</span> <kbd>satellitesInUseUpdated</kbd> <span>signal is emitted when the number of satellites that the system is using changes. The</span> <kbd>satellitesInViewUpdated</kbd> <span>signal gets emitted when the number of satellites the system can see changes. We will receive a list of </span><kbd>QGeoSatelliteInfo</kbd> <span>objects.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QGeoSatelliteInfo</h1>
                </header>
            
            <article>
                
<p>Let's connect the <kbd>satellitesInViewUpdated</kbd> <span>signal so we can detect when satellites are found:</span></p>
<pre><span>connect</span><span>(source,</span><span> </span><span>SIGNAL</span><span>(</span><span>satellitesInViewUpdated</span><span>(</span><span>QList</span><span>&lt;</span><span>QGeoSatelliteInfo</span><span>&gt;)),<br/></span><span>    this</span><span>, </span><span>SLOT</span><span>(</span><span>satellitesInViewUpdated</span><span>(</span><span>QList</span><span>&lt;</span><span>QGeoSatelliteInfo</span><span>&gt;)));</span></pre>
<p>We can receive information for individual satellites this way. Information such as a satellite identifier, signal strength, elevation, and azimuth is included:</p>
<pre><span>void</span><span> </span><span>SomeClass</span><span>::</span><span>satellitesInViewUpdated</span><span>(</span><span>const</span><span> </span><span>QList</span><span>&lt;</span><span>QGeoSatelliteInfo</span><span>&gt;</span><span> </span><span>&amp;</span>infos<span>)<br/></span><span>{</span><span><br/></span>    <span>if</span><span> </span><span>(</span><span>infos</span><span>.</span><span>count</span><span>()</span><span> </span><span>&gt;</span><span> </span><span>0</span><span>)<br/></span><span>        </span><span>qWarning</span><span>()</span><span> </span><span>&lt;&lt;</span><span> </span><span>"Number</span><span> </span><span>of</span><span> </span><span>satellites</span><span> </span><span>in</span><span> </span><span>view:"</span><span> </span><span>&lt;&lt;</span><span> </span>infos<span>.</span><span>count</span><span>();<br/></span><span><br/>    </span><span>foreach</span><span> </span><span>(</span><span>const</span><span> </span>QGeoSatelliteInfo<span> </span><span>&amp;</span>info<span>,</span><span> </span>infos<span>)</span><span> </span><span>{<br/></span><span>        </span><span>qWarning</span><span>()</span><span> </span><span>&lt;&lt;</span><span> </span><span>"</span><span>    </span><span>"<br/></span><span>            &lt;&lt;</span><span> </span><span>"satelliteIdentifier"</span><span> </span><span>&lt;&lt; </span>info<span>.</span><span>satelliteIdentifier</span><span>()<br/></span><span>            </span><span>&lt;&lt;</span><span> </span><span>"signalStrength"</span><span> </span><span>&lt;&lt;</span><span> </span>info<span>.</span><span>signalStrength</span><span>()<br/></span><span>            </span><span>&lt;&lt;</span><span> </span><span>(</span>info<span>.</span><span>hasAttribute</span><span>(</span><span>QGeoSatelliteInfo</span><span>::</span><span>Elevation</span><span>)</span><span> </span><span>?</span><span>  </span><span>"Elevation</span><span> </span><span>"<br/></span><span>+</span><span> </span><span>QString</span><span>::</span><span>number</span><span>(</span>info<span>.</span><span>attribute</span><span>(</span><span>QGeoSatelliteInfo</span><span>::</span><span>Elevation</span><span>))</span><span> </span><span>:</span><span> </span><span>""</span><span>)<br/></span><span>            </span><span>&lt;&lt;</span><span> </span><span>(</span>info<span>.</span><span>hasAttribute</span><span>(</span><span>QGeoSatelliteInfo</span><span>::</span><span>Elevation</span><span>)</span><span> </span><span>?</span><span>  </span><span>"Azimuth</span><span> </span><span>"</span><span> </span><span>+<br/></span><span>QString</span><span>::</span><span>number</span><span>(</span>info<span>.</span><span>attribute</span><span>(</span><span>QGeoSatelliteInfo</span><span>::</span><span>Azimuth</span><span>))</span><span> </span><span>:</span><span> </span><span>""</span><span>);<br/></span><span>    </span><span>}<br/>}</span></pre>
<p>There's a lot to see here on a small screen. Every update is a new line, and you can see as it locates and adds different satellites when they come into view:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e67199f7-ab26-4d0e-84eb-0aa5d209cc9e.png" style="width:29.00em;height:51.58em;"/></p>
<p>The next step is to use those satellites to triangulate our position on the globe. We start by using <kbd>QGeoPositionInfoSource</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QGeoPositionInfoSource</h1>
                </header>
            
            <article>
                
<p>We can get the latitude and longitude position of the device by using <kbd>QGeoPositionInfoSource</kbd>, which encapsulates positional data. Like <kbd>QGeoSatelliteInfoSource</kbd><span>, it has two <kbd>static</kbd> methods to create the <kbd>source</kbd> object:</span></p>
<div class="packt_infobox"><span>The source code can be found on the Git repository under the </span><kbd>Chapter08-2</kbd><span> directory, in the</span><span> <kbd>cp8</kbd> </span><span>branch.</span></div>
<pre><span>QGeoPositionInfoSource *geoSource = </span><span>QGeoPositionInfoSource</span><span>::</span><span>createDefaultSource</span><span>(</span><span>this</span><span>);</span></pre>
<p><span>The</span> <kbd>QGeoPositionInfoSource</kbd> <span>signal we are interested in is </span><kbd>positionUpdated(const QGeoPositionInfo &amp;update)</kbd>:</p>
<pre><span>connect</span><span>(</span>geoSource<span>,</span><span> </span><span>&amp;</span><span>QGeoPositionInfoSource</span><span>::</span><span>positionUpdated</span><span>,<br/></span><span>    this</span><span>,</span><span> </span><span>&amp;</span><span>MainWindow</span><span>::</span><span>positionUpdated</span><span>);</span></pre>
<p>To start receiving updates, call <kbd>startUpdates();</kbd>:</p>
<pre><span> </span>geoSource<span>-&gt;</span><span>startUpdates</span><span>();</span></pre>
<p>The <kbd>positionUpdated</kbd> signal receives a <kbd>QGeoPositionInfo</kbd><span>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QGeoPositionInfo</h1>
                </header>
            
            <article>
                
<p><kbd>QGeoPositionInfo</kbd> contains a <kbd>QGeoCoordinate</kbd> that contains our latitude and longitude coordinates, as well as a timestamp for the location data.</p>
<p>It can also contain the following optional attributes:</p>
<ul>
<li><kbd><span>Direction</span></kbd></li>
<li><kbd>GroundSpeed</kbd></li>
<li><kbd>VerticalSpeed</kbd></li>
<li><kbd>MagneticVariation</kbd></li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<ul>
<li><kbd>HorizontalAccuracy</kbd></li>
<li><kbd>VerticalAccuracy</kbd></li>
</ul>
<p>The attributes can be checked with <kbd>hasAttribute(QGeoPositionInfo::Attribute)</kbd> and retrieved with the <kbd>attribute(QGeoPositionInfo::Attribute)</kbd> function:</p>
<pre><span>if</span><span> </span><span>(</span>positionInfo<span>.</span><span>hasAttribute</span><span>(</span><span>QGeoPositionInfo</span><span>::</span>MagneticVariation)<br/>    qreal magneticVariation = positionInfo<span>.</span><span>attribute</span><span>(</span><span>QGeoPositionInfo</span><span>::</span>MagneticVariation);</pre>
<p>To get latitude and longitude information, call the <kbd>coordinate()</kbd> function in the <kbd>QGeoPositionInfo</kbd> class, which returns a <kbd>QGeoCoordinate</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QGeoCoordinate</h1>
                </header>
            
            <article>
                
<p><span><kbd>QGeoCoordinate</kbd> contains the latitude and longitude coordinates, and can be found calling the respective</span> <kbd>latitude()</kbd> <span>and</span> <kbd>longitude()</kbd> <span>functions. It can be made up of different types of data, and can be discovered by calling the</span> <kbd>type()</kbd> <span>function, which returns an <kbd>enum</kbd> of </span><kbd>QGeoCoordinate::CoordinateType</kbd>, <span>which can be one of the following values:</span></p>
<ul>
<li><span><kbd>InvalidCoordinate</kbd>: Invalid coordinate</span></li>
<li>
<p><span><kbd>Coordinate2D</kbd>: Contains latitude and longitude coordinates</span></p>
</li>
<li>
<p><span><kbd>Coordinate3D</kbd>: Contains latitude, longitude, and altitude coordinates</span></p>
</li>
</ul>
<p>We can get the <kbd>QGeoCoordinate</kbd> from the <kbd>QGeoPositionInfo</kbd> object's <kbd>coordinate()</kbd> function which, in turn, has <kbd>latitude</kbd> and <kbd>longitude</kbd> values:</p>
<pre><span>QGeoCoordinate</span><span> </span>coords<span> </span><span>=</span><span> </span>positionInfo<span>.</span><span>coordinate</span><span>();<br/></span><span>QString</span><span>(</span><span>"</span><span>Latitude</span><span> </span><span>%1\n"</span><span>)</span><span>.</span><span>arg</span><span>(</span>coords<span>.</span><span>latitude</span><span>());<br/></span><span>QString</span><span>(</span><span>"</span><span>Longitude</span><span> </span><span>%1\n"</span><span>)</span><span>.</span><span>arg</span><span>(</span>coords<span>.</span><span>longitude</span><span>());</span><span> <br/><br/>​</span><span>if</span><span> </span><span>(</span>coords<span>.</span><span>type</span><span>()</span><span> </span><span>==</span><span> </span><span>QGeoCoordinate</span><span>::</span><span>Coordinate3D</span><span>)<br/></span><span>    QString</span><span>(</span><span>"</span><span>Altitude</span><span> </span><span>%1\n"</span><span>)</span><span>.</span><span>arg</span><span>(</span>coords<span>.</span><span>altitude</span><span>())</span></pre>
<p>Let's take a look at how we do this using Qt Quick and QML.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Qt Quick</h1>
                </header>
            
            <article>
                
<p>There are corresponding QML elements available for positioning.</p>
<p>The <kbd>import</kbd> statement would be <kbd>import QtPositioning 5.12</kbd>.</p>
<p>Let's do the same simple thing with QML and show our latitude and longitude values.</p>
<p>Here are the Qt Quick item <span>equivalents of the previously-mentioned classes:</span></p>
<ul>
<li>
<p><span><kbd>PositionSource</kbd>: </span><kbd>QGeoPositionInfoSource</kbd></p>
</li>
<li>
<p><span><kbd>Position</kbd>: <kbd>QGeoPositionInfo</kbd></span></p>
</li>
<li><span><span><kbd>Coordinate</kbd>: <kbd>QGeoCoordinate</kbd></span></span></li>
</ul>
<p>Qt Quick is often much simpler, and quick to implement these things.</p>
<div class="packt_infobox"><span>The source code can be found on the Git repository under the </span><kbd>Chapter08-3</kbd><span> directory, in the</span><span> <kbd>cp8</kbd> </span><span>branch.</span></div>
<p>We implement <kbd>PositionSource</kbd> with an <kbd>updateInterval</kbd> of 1,000, which means the devices position will update every 1,000 milliseconds. We set it to <kbd>active</kbd> to start the updates:</p>
<pre><span>    </span><span>PositionSource</span><span> </span>{<br/><span>        </span><span>id</span>:<span> </span><span>positionSource<br/></span><span>        </span><span>updateInterval</span>:<span> </span>1000<br/><span>        </span><span>active</span>:<span> </span>true</pre>
<p>This component has a signal named <kbd>onPositionChanged</kbd>, which gets called when the position changes. We receive the changed coordinates and can then use them:</p>
<pre>        <span>onPositionChanged</span><span>:</span><span> </span><span>{<br/></span><span>            </span><span>var</span><span> </span><span>coord</span><span> </span>=<span> </span><span>positionSource</span>.position.coordinate;<br/><span>            </span><span>console</span>.log(<span>"Coordinate:"</span>,<span> </span><span>coord</span>.longitude,<span> </span><span>coord</span>.latitude);<br/><span>            </span><span>latitudeLabel</span>.text<span> </span>=<span> </span><span>"Latitude:</span><span> </span><span>"</span><span> </span>+<span> </span><span>coord</span>.latitude;<br/><span>            </span><span>longitudeLabel</span>.text<span> </span>=<span> </span><span>"Longitude:</span><span> </span><span>"</span><span> </span>+<span> </span><span>coord</span>.longitude;<br/><span>            </span><span>if</span><span> </span>(<span>positionSource</span>.position.altitudeValid)<br/><span>                </span><span>altitudeLabel</span>.text<span> </span>=<span> </span><span>"Altitude:</span><span> </span><span>"</span><span> </span>+<span> </span><span>coord</span>.altitude;<br/><span>      </span>}<br/><span> </span>}</pre>
<p><span>Now that we know where we are, we can use those location details to get certain details around the coordinates, like the map and location's place details.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Mapping the positions</h1>
                </header>
            
            <article>
                
<p>We now need a map of some sort to show our location findings.</p>
<div class="packt_tip">The <kbd>Map</kbd> component for QML is the only way Qt provides for mapping, so you will have to use Qt Quick.</div>
<p>The <kbd>Map</kbd> component can be backed by various backend plugins. In fact, you need to specify which plugin you are using. <kbd>Map</kbd> has built-in support for the following plugins:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td style="width: 85px">
<p><strong>Provider</strong></p>
</td>
<td style="width: 117px">
<p><strong>Key</strong></p>
</td>
<td style="width: 141px">
<p><strong><span>Notes</span></strong></p>
</td>
<td style="width: 227px">
<p><strong><span>Url</span></strong></p>
</td>
</tr>
<tr>
<td style="width: 85px">
<p>Esri</p>
</td>
<td style="width: 117px">
<p>esri</p>
</td>
<td style="width: 141px">
<p><span>Subscription required</span></p>
</td>
<td style="width: 227px">
<p><kbd><span>www.esri.com</span></kbd></p>
</td>
</tr>
<tr>
<td style="width: 85px">
<p><span>HERE</span></p>
</td>
<td style="width: 117px">
<p>here</p>
</td>
<td style="width: 141px">
<p>Access token required</p>
</td>
<td style="width: 227px">
<p><kbd>developer.here.com/terms-and-conditions</kbd></p>
</td>
</tr>
<tr>
<td style="width: 85px">
<p>Mapbox</p>
</td>
<td style="width: 117px">
<p>mapbox</p>
</td>
<td style="width: 141px">
<p>Access token required</p>
</td>
<td style="width: 227px">
<p><kbd>www.mapbox.com/tos</kbd></p>
</td>
</tr>
<tr>
<td style="width: 85px">
<p>Mapbox GL</p>
</td>
<td style="width: 117px">
<p>mapboxgl</p>
</td>
<td style="width: 141px">
<p><span>Access token required</span></p>
</td>
<td style="width: 227px">
<p><kbd>www.mapbox.com/tos</kbd></p>
</td>
</tr>
<tr>
<td style="width: 85px">
<p><strong>Open Street Map</strong> (<strong>OSM</strong>)</p>
</td>
<td style="width: 117px">
<p>osm</p>
</td>
<td style="width: 141px">
<p>Free access</p>
</td>
<td style="width: 227px">
<p><kbd>openstreetmap.org/</kbd></p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>I will be using the OSM and HERE providers.</p>
<p>The HERE plugin requires an account at <kbd>developer.here.com</kbd>. It's easy to sign up and there is a free version. You need the app ID and app code to access their maps and API.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Map</h1>
                </header>
            
            <article>
                
<p>To start using the <kbd>Map</kbd> component, in your chosen <kbd>.qml</kbd> file, add both <kbd>QtLocation</kbd> and <kbd>QtPositioning</kbd> in the <kbd>import</kbd> lines:</p>
<pre>import QtLocation 5.12<br/>import QtPositioning 5.12</pre>
<div class="packt_infobox"><span>The source code can be found on the Git repository under the </span><kbd>Chapter08-4</kbd><span> directory, in the</span><span> <kbd>cp8</kbd> </span><span>branch.</span></div>
<p>The <kbd>Map</kbd> component needs a <kbd>plugin</kbd> object, whose <kbd>name</kbd> property is one of the keys from the preceding table. You can set where the map is centered by setting the <kbd>center</kbd> property to a coordinate.</p>
<p>I am using the OSM backend and it is centered on the Gold Coast, Australia:</p>
<pre><span>    </span><span>Map</span><span> </span>{<br/><span>        </span><span>anchors.fill</span>:<span> </span><span>parent<br/></span><span>        </span><span>plugin</span>:<span> </span><span>Plugin</span><span> </span>{<br/><span>            </span><span>name</span>:<span> </span><span>"osm"</span><span> <br/></span><span>        </span>}<br/><span>        </span><span>center</span>:<span> </span><span>QtPositioning</span>.coordinate(-28.0,<span> </span>153.4)<br/><span>        </span><span>zoomLevel</span>:<span> </span>10<br/><span>    </span>}</pre>
<p>The Map centers on the coordinates we indicate with the <kbd>center</kbd> property, which is used to position the map to the user's current location.</p>
<p>We defined the Map's <kbd>plugin</kbd> property to be the <kbd>"osm"</kbd> plugin, which is an identifier for the Open Street Map plugin.</p>
<p><span>It is that easy to show a map. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">MapCircle</h1>
                </header>
            
            <article>
                
<p>You can highlight an area by placing a <kbd>MapCircle</kbd> in the <kbd>Map</kbd>. Again, centered on the Gold Coast.</p>
<p>A <kbd>MapCircle</kbd> has a <kbd>center</kbd> property that we can define by using a <kbd>latitude</kbd> and <kbd>longitude</kbd> location in a signed decimal value.</p>
<p>The <kbd>radius</kbd> property here is in the unit of meters according to the map. So in our example, the <kbd>MapCircle</kbd> will have a radius of 5,000 meters.</p>
<pre><span>        </span><span>MapCircle</span><span> </span>{<br/><span>             </span><span>center</span><span> </span>{<br/><span>                 </span><span>latitude</span>:<span> </span>-28.0<br/><span>                 </span><span>longitude</span>:<span> </span>153.4<br/><span>             </span>}<br/><span>             </span><span>radius</span>:<span> </span>5000.0<br/><span>             </span><span>border.color</span>:<span> </span><span>'red'<br/></span><span>             </span><span>border.width</span>:<span> </span>3<br/><span>             </span><span>opacity</span>:<span> </span>0.5<br/><span>         </span>}</pre>
<p>Each map backend has its own parameters, which can be set using the <kbd>PluginParameter</kbd> component in the <kbd>Map</kbd> component. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">PluginParameter</h1>
                </header>
            
            <article>
                
<p><span>By default, the OSM backend downloads lower-resolution tiles. If you want high-resolution maps, you can specify the</span> <kbd>'osm.mapping.highdpi_tiles'</kbd> <span>parameter:</span></p>
<pre><span>PluginParameter</span><span> </span>{<br/><span>    </span><span>name</span>:<span> </span><span>'osm.mapping.highdpi_tiles'<br/></span><span>    </span><span>value</span>:<span> </span>true<br/>}</pre>
<p>Each <kbd>PluginParameter</kbd> element holds just one <kbd>name</kbd>/<kbd>value</kbd> parameter pair. If you need to set several parameters, you will need a <kbd>PluginParameter</kbd> element for each:</p>
<pre>PluginParameter { name: "osm.useragent"; value: "Mobile and Embedded Development with Qt5"; }</pre>
<p>Other <kbd>PluginParameters</kbd> you could consider are tokens and app IDs for various map providers, such as HERE maps.</p>
<p>Here's how our map looks, running on Android:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/49538139-169e-48a8-8e2c-0309ad29cccf.png" style="width:27.83em;height:49.50em;"/></p>
<p>There are other Qt Quick items that we can use with addresses on the map. Let's look at routing.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">RouteModel</h1>
                </header>
            
            <article>
                
<p>To show a route on a map, you will need to use <kbd>RouteModel</kbd>, which is a property of the <kbd>Map</kbd> item, <kbd>RouteQuery</kbd> to add waypoints, and a <kbd>MapItemView</kbd> to display it.</p>
<p><kbd>RouteModel</kbd> needs a plugin, so we just reuse the plugin for the <kbd>Map</kbd> item. It also needs a <kbd>RouteQuery</kbd> for its <kbd>query</kbd> property:</p>
<pre><span>        </span><span>RouteQuery</span><span> </span>{<br/><span>            </span><span>id</span>:<span> </span><span>routeQuery<br/></span><span>        </span>}<br/><span>        </span><span>RouteModel</span><span> </span>{<br/><span>            </span><span>id</span>:<span> </span><span>routeModel<br/></span><span>            </span><span>plugin</span><span> </span>:<span> </span><span>map</span>.plugin<br/><span>            </span><span>query</span>:<span> </span><span>routeQuery<br/></span><span>        </span>}</pre>
<p><kbd>MapItemView</kbd> is used to display model data on the map. It also needs a delegate of <kbd>MapRoute</kbd>. In our case, this is a line that describes the route:</p>
<pre><span>        </span><span>MapItemView</span><span> </span>{<br/><span>            </span><span>id</span>:<span> </span><span>mapView<br/></span><span>            </span><span>model</span>:<span> </span><span>routeModel<br/></span><span>            </span><span>delegate</span>:<span> </span><span>routeDelegate<br/></span><span>        </span>}<br/><span>        </span><span>Component</span><span> </span>{<br/><span>            </span><span>id</span>:<span> </span><span>routeDelegate<br/></span>            <span>MapRoute</span><span> </span><span>{<br/></span><span>                </span><span>id</span>:<span> </span><span>route<br/></span><span>                </span><span>route</span>:<span> </span>routeData<br/><span>                </span><span>line.color</span>:<span> </span><span>"#46a2da"<br/></span><span>                </span><span>line.width</span>:<span> </span>5<br/><span>                </span><span>smooth</span>:<span> </span>true<br/><span>                </span><span>opacity</span>:<span> </span>0.8<br/><span>            </span>}<br/><span>        </span>}</pre>
<p>Now what we need is a starting point, an ending point, and any point in between. In this example, I keep it simple and only specify start and end points. You can specify a GPS coordinate by using <kbd>QtPositioning.coordinate</kbd>, which takes a latitude and longitude value as arguments:</p>
<pre><span>​</span><span>property</span><span> </span><span>variant</span><span> </span><span>startCoordinate</span>:<span> </span><span>QtPositioning</span>.coordinate(-28.0,<span> </span>153.4)<br/><span>property</span><span> </span><span>variant</span><span> </span><span>endCoordinate</span>:<span> </span><span>QtPositioning</span>.coordinate(-27.579744,<span> </span>153.100175)</pre>
<p>The start-point coordinate is some random area on the Gold Coast, Australia; the endpoint is where the last south-of-the-equator Trolltech office was. The <kbd>RouteQuery travelModes</kbd> property determines how the route is figured, whether traveling by car, foot, or public transport. It can be one of the following values:</p>
<ul>
<li><kbd>CarTravel</kbd> </li>
<li><kbd>PedestrianTravel</kbd></li>
<li><kbd>BicycleTravel</kbd></li>
<li><kbd>PublicTransit</kbd></li>
<li><kbd>TruckTravel</kbd></li>
</ul>
<p>The <kbd>RouteQuery</kbd> property, <kbd>routeOptimzations</kbd>, limits the query to the following different values:</p>
<ul>
<li><kbd>ShortestRoute</kbd></li>
<li><kbd>FastestRoute</kbd></li>
<li><kbd>MostEconomicRoute</kbd></li>
<li><kbd>MostScenicRoute</kbd></li>
</ul>
<p>In this example, I made <kbd>routeQuery</kbd> fire off in the <kbd>Component.onCompleted</kbd> signal. Usually, something like this would be triggered after the user has configured the query:</p>
<pre><span>Component.onCompleted</span>:<span> </span>{<br/><span>    </span><span>routeQuery</span>.clearWaypoints();<br/><span>    </span><span>routeQuery</span>.addWaypoint(<span>startCoordinate</span>)<br/><span>    </span><span>routeQuery</span>.addWaypoint(<span>endCoordinate</span>)<br/><span>    </span><span>routeQuery</span>.travelModes<span> </span>=<span> </span><span>RouteQuery</span>.CarTravel<br/><span>    </span><span>routeQuery</span>.routeOptimizations<span> </span>=<span> </span><span>RouteQuery</span>.FastestRoute<br/>    <span>routeModel</span><span>.update();<br/></span><span> </span>}</pre>
<p>Here is how the route looks. This route indicated by the blue line starting in the big red circle:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/189324f1-d058-4353-a244-4acaed6350f0.png" style="width:28.83em;height:51.33em;"/></p>
<p>You can add more <kbd>Waypoints</kbd> to establish different routes or<span> get turn-by-turn directions by setting <kbd>routeModel</kbd> to a</span> <kbd>ListView</kbd> <span>or similar.</span></p>
<p>Not only can Qt Location show maps and routes, but there is also support for displaying places of interest, such as restaurants, gas stations, and national parks, in the <kbd>Places</kbd> API.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Places of interest</h1>
                </header>
            
            <article>
                
<p>At this point, I am going to switch to the HERE maps plugin. I tried to get the OpenStreetMaps places to work, but it could not find anything around.</p>
<p>In the next step of the construction of our map, we use <span><kbd>PlaceSearchModel</kbd> to search for places. As with the <kbd>RouteModel</kbd> before, <kbd>MapItemView</kbd> can display this model on our map.</span></p>
<p>Just like <kbd>RouteModel</kbd>, <kbd>PlaceSearchModel</kbd> needs some way of displaying the data; we could choose a <kbd>ListView</kbd>, which is useful for some purposes, but let's choose <kbd>MapItemView</kbd> for the visual effect.</p>
<p>We need to state which plugin we are using with <kbd>searchArea</kbd> and <kbd>searchTerm</kbd>:</p>
<pre><span>PlaceSearchModel</span><span> </span>{<br/><span>    </span><span>id</span>:<span> </span><span>searchModel<br/></span>    <span>plugin</span><span>:</span><span> </span><span>mapPlugin<br/></span>    <span>searchTerm</span><span>:</span><span> </span><span>"coffee"<br/></span><span>    </span><span>searchArea</span>:<span> </span><span>QtPositioning</span>.circle(<span>startCoordinate</span>)<br/>    <span>Component.onCompleted</span><span>:</span><span> </span><span>update</span><span>()<br/></span>}</pre>
<p>Our <kbd>MapItemView</kbd> and <kbd>delegate</kbd> code look like this. The <kbd>searchView</kbd> delegate will show up as an icon with its title text, from the resulting place :</p>
<pre><span>MapItemView</span><span> </span>{<br/><span>    </span><span>id</span>:<span> </span><span>searchView<br/></span><span>    </span><span>model</span>:<span> </span><span>searchModel<br/></span><span>    </span><span>delegate</span>:<span> </span><span>MapQuickItem</span><span> </span>{<br/><span>        </span><span>coordinate</span>:<span> </span>place.location.coordinate<br/>        <span>anchorPoint.x</span><span>:</span><span> </span><span>image</span><span>.width</span><span> </span><span>*</span><span> </span><span>0.5<br/></span><span>        </span><span>anchorPoint.y</span>:<span> </span><span>image</span>.height<br/>        <span>sourceItem</span><span>:</span><span> </span><span>Column</span><span> </span><span>{<br/></span><span>            </span><span>Image</span><span> </span>{<span> </span><span>id</span>:<span> </span><span>image</span>;<span> </span><span>source</span>:<span> </span><span>"map-pin.png"</span><span> </span>}<br/><span>            </span><span>Text</span><span> </span>{<span> </span><span>text</span>:<span> </span><span>title</span>;<span> </span><span>font.bold</span>:<span> </span>true;<span> </span><span>color</span>:<span> </span><span>"red"</span>}<br/><span>        </span>}<br/><span>    </span>}<br/>}</pre>
<p>As you can see here, the place points are a bit difficult to read and are superimposed on top of the other ones that are around. This indicates that there are places too near each other for the zoom level and the map is having difficulties in placing the names. You can work around this issue by using a different zoom level or by using some collision detection and layout <span>algorithms that</span> I won't go into there.</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/90adbe26-04ad-42a1-a2a8-680274dde9d2.png" style="width:26.42em;height:47.08em;"/></p>
<p>The <kbd>map-pin.png</kbd> icon is from <a href="https://feathericons.com/">https://feathericons.com/</a> and is released under the open source MIT license.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we covered many aspects of mapping using Qt Location and Qt Positioning. We can get satellite information with <kbd>QGeoSatelliteInfo</kbd><span>, and locate the exact current position coordinates with</span> <kbd>QGeoPositionInfo</kbd><span>. We learned how to use</span> <span>Qt Quick</span> <kbd>Map</kbd> <span>and different map providers to show the current location. We covered how to provide a route with</span> <kbd>RouteModel</kbd><span class="packt_screen">,</span> <span>search for places nearby using</span> <kbd>PlaceSearchModel</kbd>, <span>and show them using</span> <kbd>MapItemView</kbd><span>.</span></p>
<p>In the next chapter, we will discuss audio and video with Qt Multimedia.</p>


            </article>

            
        </section>
    </body></html>