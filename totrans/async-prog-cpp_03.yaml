- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How to Create and Manage Threads in C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we learned in the previous two chapters, threads are the smallest and most
    lightweight units of execution within a program. Each thread takes care of a unique
    task defined by a sequence of instructions running on allocated CPU resources
    by the OS scheduler. Threads play a critical role when managing concurrency within
    a program aiming to maximize the overall utilization of CPU resources.
  prefs: []
  type: TYPE_NORMAL
- en: During the program’s startup process, after the kernel passes the execution
    to the process, the C++ runtime creates the main thread and executes the **main()**
    function. After that, additional threads can be created to split the program into
    different tasks that can run concurrently and share resources. This way, the program
    can handle multiple tasks, improving efficiency and responsiveness.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn the basics of how to create and manage threads
    using modern C++ features. In the subsequent chapters, we will come across explanations
    of C++ lock synchronization primitives (mutexes, semaphores, barriers, and spinlocks),
    lock-free synchronization primitives (atomic variables), coordination synchronization
    primitives (condition variables), and approaches using C++ to solve or avoid potential
    problems when using concurrency or multithreading (race conditions or data races,
    deadlocks, livelocks, starvation, oversubscription, load balancing, and thread
    exhaustion).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to create, manage, and cancel threads in C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to pass arguments to threads and get results back from the thread
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to sleep a thread or yield execution to other threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What jthread objects are and why they are useful
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will develop different solutions using C++11 and C++20.
    Therefore, we will need to install the **GNU Compiler Collection** ( **GCC** ),
    specifically GCC 13, as well as Clang 8 (see [https://en.cppreference.com/w/cpp/compiler_support](https://en.cppreference.com/w/cpp/compiler_support)
    for further details on C++ compiler support).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find more information about GCC at [https://gcc.gnu.org](https://gcc.gnu.org)
    . You can find information on how to install GCC here: [https://gcc.gnu.org/install/index.html](https://gcc.gnu.org/install/index.html)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information about Clang, a compiler frontend supporting several languages
    including C++, visit [https://clang.llvm.org](https://clang.llvm.org) . Clang
    is part of the LLVM compiler infrastructure project ( [https://llvm.org](https://llvm.org)
    ). C++ support in Clang is documented here: [https://clang.llvm.org/cxx_status.html](https://clang.llvm.org/cxx_status.html)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this book, some code snippets do not show the libraries included. Additionally,
    some functions, even the main ones, might be simplified, showing only the relevant
    instructions. You can find all the complete code in the following GitHub repository:
    [https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP](https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Under the **scripts** folder in the root directory in the preceding GitHub repository,
    you can find a script called **install_compilers.sh** that might be of help with
    installing the required compilers in Debian-based Linux systems. The script has
    been tested in Ubuntu 22.04 and 24.04.
  prefs: []
  type: TYPE_NORMAL
- en: 'The examples for this chapter are located under the **Chapter_03** folder.
    All source code files can be compiled using C++20 with CMake as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Executables will be generated under the **bin** directory.
  prefs: []
  type: TYPE_NORMAL
- en: The thread library – an introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main library to create and manage threads in C++ is the thread library.
    First, let’s go through a recap about threads. Then we will dive into what the
    thread library offers.
  prefs: []
  type: TYPE_NORMAL
- en: What are threads? Let’s do a recap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The purpose of threads is to execute multiple simultaneous tasks in a process.
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen in the previous chapter, a thread has its own stack, local data,
    and CPU registers such as **Instruction Pointer** ( **IP** ) and **Stack Pointer**
    ( **SP** ), but shares the address space and virtual memory of its parent process.
  prefs: []
  type: TYPE_NORMAL
- en: In the user space, we can differentiate between **native threads** and **lightweight
    or virtual threads** . Native threads are the ones created by the OS when using
    some kernel APIs. The C++ thread objects create and manage these types of threads.
    On the other hand, lightweight threads are like native threads, except that they
    are emulated by a runtime or library. In C++, **coroutines** belong to this group.
    As described in the previous chapter, lightweight threads have faster context
    switching than native threads. Also, multiple lightweight threads can run in the
    same native thread and can be much smaller than native threads.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will start learning about native threads. In [*Chapter 8*](B22219_08.xhtml#_idTextAnchor164)
    , we will learn about lightweight threads in the form of coroutines.
  prefs: []
  type: TYPE_NORMAL
- en: The C++ thread library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In C++, threads allow multiple functions to run concurrently. The **thread**
    class defines a type-safe interface to a native thread. This class is defined
    in the **std::thread** library, in the **<thread>** header file in the **Standard
    Template Library** ( **STL** ). It is available from C++11 onward.
  prefs: []
  type: TYPE_NORMAL
- en: Before the inclusion of the thread library in the C++ STL, developers used platform-specific
    libraries such as the POSIX thread ( **pthread** ) library in Unix or Linux OSs,
    the **C Runtime** ( **CRT** ) and Win32 libraries for Windows NT and CE systems,
    or third-party libraries such as **Boost.Threads** . In this book, we will only
    use modern C++ features. As **<thread>** is available and provides a portable
    abstraction on top of platform-specific mechanisms, none of these libraries will
    be used or explained. In [*Chapter 9*](B22219_09.xhtml#_idTextAnchor184) , we
    will introduce **Boost.Asio** , and in [*Chapter 10*](B22219_10.xhtml#_idTextAnchor212)
    , **Boost.Cobalt** . Both libraries provide advanced frameworks to deal with asynchronous
    I/O operations and coroutines.
  prefs: []
  type: TYPE_NORMAL
- en: Now it’s time to learn about the different thread operations.
  prefs: []
  type: TYPE_NORMAL
- en: Thread operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how to create threads, pass arguments during
    their construction, return values from threads, cancel threads execution, catch
    exceptions, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: Thread creation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a thread is created, it executes immediately. It is only delayed by the
    OS scheduling process. If there are not enough resources to run both parent and
    child threads in parallel, the order in which they will run is not defined.
  prefs: []
  type: TYPE_NORMAL
- en: The constructor argument defines the function or **function** object to be executed
    by the thread. This callable object should not return anything, as its return
    value will be ignored. If for some reason the thread execution ends with an exception,
    **std::terminate** is called unless an exception is caught, as we will see later
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In the following examples, we create six threads using different callable objects.
  prefs: []
  type: TYPE_NORMAL
- en: '**t1** using a function pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**t2** using a lambda function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**t3** using an embedded lambda function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**t4** using a **function** object where **operator()** is overloaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**t5** using a non-static **member** function by passing the address of the
    **member** function and the address of an object to call the **member** function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**t6** using a static **member** function where only the address of the **member**
    function is needed as the method is static:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Thread creation incurs some overhead that can be reduced by using thread pools,
    as we will explore in [*Chapter 4*](B22219_04.xhtml#_idTextAnchor074) .
  prefs: []
  type: TYPE_NORMAL
- en: Checking hardware concurrency
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the strategies for effective thread management, which is related to scalability
    and performance and was commented on in the previous chapter, is to balance the
    number of threads with the available resources to avoid over-subscription.
  prefs: []
  type: TYPE_NORMAL
- en: 'To retrieve the number of concurrent threads supported by the OS, we can use
    the **std::thread::hardware_concurrency()** function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The value returned by this function must be considered to only provide a hint
    about the number of threads that will run concurrently. It is also sometimes not
    well defined, thus returning a value of **0** .
  prefs: []
  type: TYPE_NORMAL
- en: Synchronized stream writing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we print messages to the console by using **std::cout** from two or more
    threads, the output result can be messy. This is due to a **race condition** happening
    in the output stream.
  prefs: []
  type: TYPE_NORMAL
- en: As commented in the previous chapter, race conditions are bugs in software that
    happen in concurrent and multithreaded programs, whose behavior depends on the
    sequence of events happening on a shared resource where at least one of the actions
    is not atomic. We will learn more about how to avoid them in [*Chapter 4*](B22219_04.xhtml#_idTextAnchor074)
    . Additionally, we will learn how to debug race conditions using Clang’s sanitizers
    in [*Chapter 12*](B22219_12.xhtml#_idTextAnchor243) .
  prefs: []
  type: TYPE_NORMAL
- en: The following code snippet shows two threads printing a sequence of numbers.
    The **t1** thread should print lines containing the **1 2 3 4** sequence. The
    **t2** thread should print the **5 6 7 8** sequence. Each thread prints its sequence
    100 times. Before the main thread exits, it waits for **t1** and **t2** to finish
    by using **join()** .
  prefs: []
  type: TYPE_NORMAL
- en: More about joining threads later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'However, running the previous example shows some lines with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To avoid these issues, we can simply write from a specific thread or use a
    **std::ostringstream** object that makes atomic calls to the **std::cout** object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: From C++20 onward, we also can use the **std::osyncstream** objects. They behave
    similarly to **std::cout** but with writing synchronization between threads accessing
    the same stream. However, as only the transfer step from its internal buffer to
    the output stream is synchronized, every thread needs its own **std::osyncstream**
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: The internal buffer is transferred when the stream is destroyed, which is when
    **emit()** is explicitly called.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a simple solution to allow synchronization on each printed
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Both solutions will output the sequences without interleaving them
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As this approach is now the official C++20 way of avoiding race conditions when
    outputting content, we will use **std::osyncstream** as the default approach throughout
    the rest of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Sleeping the current thread
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**std::this_thread** is a namespace. It gives access to functions from the
    current thread to yield the execution to another thread or block the execution
    of the current task and wait for a period.'
  prefs: []
  type: TYPE_NORMAL
- en: The **std::this_thread::sleep_for** and **std::this_thread::sleep_until** functions
    block the execution of the thread for a given amount of time.
  prefs: []
  type: TYPE_NORMAL
- en: '**std::this_thread::sleep_for** sleeps for at least a given duration. The blockage
    can be longer depending on how the OS scheduler decides to run tasks, or due to
    some resource contention delays.'
  prefs: []
  type: TYPE_NORMAL
- en: Resource contention
  prefs: []
  type: TYPE_NORMAL
- en: Resource contention occurs when demand exceeds supply for a certain shared resource,
    leading to performance degradation.
  prefs: []
  type: TYPE_NORMAL
- en: '**std::this_thread::sleep_until** works like **std::this_thread::sleep_for**
    . However, instead of sleeping for a duration, it sleeps until a specific time
    point has been reached. The clock where the time point is computed must meet the
    **Clock** requirement (you can find more information on this here: [https://en.cppreference.com/w/cpp/named_req/Clock](https://en.cppreference.com/w/cpp/named_req/Clock)
    ). It is recommended by the standard to use a steady clock instead of the system
    clock to set up the duration.'
  prefs: []
  type: TYPE_NORMAL
- en: Identifying a thread
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When debugging multithreaded solutions, it is useful to know which thread is
    executing a given function. Each thread can be identified by an identifier, making
    it possible to log in its value for traceability and debugging.
  prefs: []
  type: TYPE_NORMAL
- en: '**std::thread::id** is a lightweight class that defines a unique identifier
    of thread objects ( **std::thread** and **std::jthread** , which we will introduce
    later in this chapter). This identifier is retrieved by using the **get_id()**
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: Thread identifier objects can be compared, serialized, and printed via an output
    stream. They can also be used as a key in mapping containers, as they are supported
    by the **std::hash** function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example prints the identifier of the **t** thread. Later in this
    chapter, we will learn how to create a thread and sleep for an interval of time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Remember that when a thread finishes, its identifier can be reused by a future
    thread.
  prefs: []
  type: TYPE_NORMAL
- en: Passing arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arguments can be passed to the thread by value, by reference, or as pointers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we can see how to pass arguments by value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Passing by value avoids data races. However, it is much more costly, as data
    is copied across.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next example shows how to pass values by reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Or as **const-reference** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Passing by reference is achieved by using **ref()** (non-const references) or
    **cref()** (const-references). Both are defined in the **<functional>** header
    file. This lets the variadic template define the thread constructor to treat the
    argument as a reference.
  prefs: []
  type: TYPE_NORMAL
- en: These helper functions are used to generate **std::reference_wrapper** objects,
    which wrap a reference in a copyable and assignable object. Missing these functions
    when passing arguments makes the arguments to be passed by value.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also move an object into a thread as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: However, note that trying to access the **v** vector in the main thread after
    it is moved into the **t** thread would result in undefined behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can also allow threads to access variables by lambda captures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the **str** variable is accessed by the **t** thread as a reference
    captured by the embedded lambda function.
  prefs: []
  type: TYPE_NORMAL
- en: Returning values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To return values that have been computed in a thread, we can use a shared variable
    with a synchronization mechanism such as a mutex, lock, or atomic variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code snippet, we can see how to return a value computed by
    a thread by using an argument passed by a non-const reference (using **ref()**
    ). The **result** variable is computed within the **t** thread in the **func**
    function. The resulting value can be seen from the main thread. As we will learn
    in the next section, the **join()** function simply waits for the **t** thread
    to finish before letting the main thread continue running and checking the **result**
    variable afterward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The **reference** argument can be a reference to the input object itself, or
    to another variable where we want the result to be stored, as done in this example
    with the **result** variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also return the value using a lambda capture, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also do this by writing into a shared variable protected by a mutex,
    locking the mutex (using **std::lock_guard** , for example) before executing the
    writing operation. However, we will dive deeper into these mechanisms in [*Chapter
    4*](B22219_04.xhtml#_idTextAnchor074) :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: There is a more elegant way of returning values from threads. This involves
    using futures and promises, which we will learn about in [*Chapter 6*](B22219_06.xhtml#_idTextAnchor125)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Moving threads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Threads can be moved but not copied. This is to avoid having two different thread
    objects to represent the same hardware thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, **t1** is moved to **t2** using **std::move** . Therefore,
    **t2** inherits the same identifier as **t1** had before being moved and **t1**
    is not joinable, as it no longer contains any valid thread anymore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: When a **std::thread** object is moved to another **std::thread** object, the
    move-from-thread object will reach a state where it does not represent a real
    thread anymore. This situation also happens to thread objects resulting from the
    default constructor after detaching or joining them. We will introduce these operations
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Waiting for a thread to finish
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are use cases where a thread needs to wait for another thread to finish
    so that it can use the result computed by the latter thread. Other use cases involve
    running a thread in the background, detaching it, and continuing to execute the
    main thread.
  prefs: []
  type: TYPE_NORMAL
- en: Joining a thread
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **join()** function blocks the current thread while waiting for the completion
    of the joining thread identified by the thread object where the **join()** function
    is being called. This ensures that the joining thread has terminated after **join()**
    returns (see the *Thread life cycle* section in [*Chapter 2*](B22219_02.xhtml#_idTextAnchor035)
    for more details).
  prefs: []
  type: TYPE_NORMAL
- en: It is easy to forget to use a **join()** function. **Joining Thread** ( **jthread**
    ) solves that problem. It is available from C++20 onward. We will introduce it
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Checking whether a thread is joinable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A thread is considered joinable and therefore active if the **join()** function
    has not been called in that thread. This is true even if the thread has finished
    executing code but still has not been joined. On the other hand, a default constructed
    thread or a thread that has already been joined is *not* joinable.
  prefs: []
  type: TYPE_NORMAL
- en: To check whether a thread is joinable, just use the **std::thread::joinable()**
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see the usage of **std::thread::join()** and **std::thread::joinable()**
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: After **t1** has been constructed using the default constructor (not specifying
    a callable object), the thread will not be joinable. As **t2** is constructed
    specifying a function, **t2** is joinable after construction. However, when **t1**
    and **t2** are swapped, **t1** becomes joinable again and **t2** is not joinable
    anymore. Then the main thread waits for **t1** to join, so it is no longer joinable.
    Trying to join **t2** , a non-joinable thread, results in undefined behavior.
    Finally, not joining a joinable thread will lead to resource leaks or potential
    program crashes due to the unexpected use of shared resources.
  prefs: []
  type: TYPE_NORMAL
- en: Daemon thread by detaching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we want a thread to continue running in the background as a **daemon thread**
    but finish the execution of the current thread, we can use the **std::thread::detach()**
    function. A daemon thread is a thread that performs some tasks in the background
    that do not need to run to completion. If the main program exits, all daemon threads
    are terminated. As commented earlier, a thread must join or detach before the
    main thread terminates, otherwise the program will abort its execution.
  prefs: []
  type: TYPE_NORMAL
- en: After calling **detach** , the detached thread cannot be controlled or joined
    (as it is waiting for its completion) using the **std::thread** object, as this
    object no longer represents the detached thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows a daemon thread called **t** that is detached just
    after construction, running the **daemonThread()** function in the background.
    This function executes for three seconds and then exits, finishing the thread
    execution. Meanwhile, the main thread sleeps for one more second than the thread
    execution time before exiting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Joining threads – the jthread class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From C++20 onward, there is a new class: **std::jthread** . This class is like
    **std:thread** but with the additional functionality that the thread rejoins on
    destruction, following the **Resource Acquisition is Initialization** ( **RAII**
    ) technique. It can be canceled or stopped in some scenarios.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the following example, a **jthread** thread has the same
    interface as **std::thread** . The only difference is that we do not need to call
    the **join()** function to ensure that the main thread waits for the **t** thread
    to join:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'When two **std::jthread** s are destroyed, their destructors are called in
    reverse order from their constructors. To demonstrate this behavior, let us implement
    a thread wrapper class that prints some messages when the wrapped thread is created
    and destroyed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this **JthreadWrapper** wrapper class, we start three threads that execute
    the **func** function. Each will wait for a second before exiting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This program will show the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, **t1** is created first, then **t2** , and finally **t3** . The
    destructors follow the reverse order, with **t3** being destroyed first, then
    **t2** , and **t1** last.
  prefs: []
  type: TYPE_NORMAL
- en: As jthreads avoid pitfalls when we forget to use **join** in a thread, we simply
    prefer to use **std::jthread** over **std::thread** . There might be cases where
    we need to use explicit calls to **join()** to be sure that threads have been
    joined and resources properly freed up before moving to another task.
  prefs: []
  type: TYPE_NORMAL
- en: Yielding thread execution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A thread can also decide to pause its execution, let the implementation reschedule
    the execution of threads, and give the chance to other threads to run.
  prefs: []
  type: TYPE_NORMAL
- en: The **std::this_thread::yield** method provides a hint to the OS to reschedule
    another thread. The behavior is implementation-dependent, depending on the OS
    scheduler and the current state of the system.
  prefs: []
  type: TYPE_NORMAL
- en: Some Linux implementations suspend the current thread and move it back to a
    queue of threads to schedule all threads with the same priority. If this queue
    is empty, the yield has no effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows two threads, **t1** and **t2** , executing the
    same work function. They randomly choose to either do some work (locking a mutex,
    as we will learn about in the next chapter, and waiting for three seconds) or
    yield the execution to the other thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: When running this example, when the execution reaches the yield command, we
    can see how the thread that is currently running stops and enables the other thread
    to restart its execution.
  prefs: []
  type: TYPE_NORMAL
- en: Threads cancellation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we are no longer interested in the result that a thread is computing, we
    will want to cancel that thread and avoid more computation costs.
  prefs: []
  type: TYPE_NORMAL
- en: Killing a thread could be a solution. However, that leaves resources that belong
    to the thread handling, such as other threads started from that thread, locks,
    connections, and so on. This could mean ending the program with undefined behavior,
    a critical section locked under a mutex, or any other unexpected issue.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid these problems, we need a data race-free mechanism to let the thread
    know about the intention to stop its execution (to request a stop) so that the
    thread can take all the specific steps needed to cancel its work and terminate
    gracefully.
  prefs: []
  type: TYPE_NORMAL
- en: One of the possible ways of achieving this is by using an atomic variable that
    is periodically checked by the thread. We will explore atomic variables at length
    in the next chapter. For now, let’s define an atomic variable as a variable that
    many threads can write or read from without any locking mechanism or data race
    due to its atomic transaction operations and memory model.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let us create a **Counter** class that calls a callback every
    second. This is done infinitely until the **running** atomic variable is set to
    **false** , when a caller uses the **stop()** function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In the caller function, we will instantiate **Counter** as follows. Then, when
    desired (here, that is after three seconds), we will call the **stop()** function,
    letting **Counter** exit the loop and terminate the thread execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Since C++20, there has been a new mechanism called **cooperative interruption**
    of a thread. This is available via **std::stop_token** .
  prefs: []
  type: TYPE_NORMAL
- en: The thread knows that a stop was requested by checking the result of calling
    the **std::stop_token::stop_requested()** function.
  prefs: []
  type: TYPE_NORMAL
- en: To produce **stop_token** , we will use a **stop_source** object via the **std::stop_source::get_token()**
    function.
  prefs: []
  type: TYPE_NORMAL
- en: This thread cancellation mechanism is implemented in **std::jthead** objects
    via an internal member of the **std::stop_source** type where the shared stop
    state is stored. The **jthread** constructor accepts **std::stop_token** as its
    first argument. This is used when a stop is requested during execution.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, **std::jthread** exposes some additional functions to manage stop
    tokens compared with **std::thread** objects. These functions are **get_stop_source()**
    , **get_stop_token()** , and **request_stop()** .
  prefs: []
  type: TYPE_NORMAL
- en: When **request_stop()** is called, it issues a stop request to the internal
    stop state, which is atomically updated to avoid race conditions (you will learn
    more about atomic variables in [*Chapter 4*](B22219_04.xhtml#_idTextAnchor074)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: Let us check how all these functions work in the following example.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will define a template function to show the properties of a stop
    item object ( **stop_token** or **stop_source** ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, within the **main()** function, we will start a worker thread, acquire
    its stop token object, and show its properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '**Worker1** is running the **func_with_stop_token()** function that is defined
    in the ensuing code block. In this function, the stop token is checked by using
    the **stop_requested()** function. If this function returns **true** , a stop
    was requested, so the function simply returns, terminating the thread execution.
    Otherwise, it runs the next loop iteration, sleeping the current thread for further
    300 ms until the next stop request check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We can request a stop from the main thread by using the stop token returned
    by the thread object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we can request a stop from a different thread. For this, we need to pass
    a **stop_source** object. In the following code snippet, we can see how a thread
    stopper is created with a **stop_source** object as an argument, acquired from
    the **worker2** worker thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The **stopper** thread waits for 0.5 seconds and requests a stop from the **stop_source**
    object. Then **worker2** becomes aware of that request and terminates its execution,
    as explained earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also register a callback function that will invoke a function when a
    stop is requested via a stop token or stop source. This can be done by using the
    **std::stop_callback** object, as shown in the ensuing code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'If a **std::stop_callback** object is destroyed, its execution is prevented.
    For example, this scoped stop callback will not execute, as the callback object
    is destroyed when going out of scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'After a stop has already been requested, a new stop callback object will execute
    immediately. In the following example, if a stop has been requested for **worker2**
    , **callback_after_stop** will execute the lambda function just after construction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Catching exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Any unhandled exception thrown within a thread needs to be caught within that
    thread. Otherwise, the C++ runtime calls **std::terminate** , causing the program
    to terminate abruptly. This causes unexpected behavior, data loss, or even program
    crashes.
  prefs: []
  type: TYPE_NORMAL
- en: One solution is to use try-catch blocks within the thread to catch exceptions.
    However, only exceptions thrown within that thread will be caught. Exceptions
    do not propagate to other threads.
  prefs: []
  type: TYPE_NORMAL
- en: To propagate an exception to another thread, one thread can capture it and store
    it into a **std::exception_ptr** object, then use shared memory techniques to
    pass it to another thread, where the **std::exception_ptr** object will be checked
    and the exception re-thrown if needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see how a **std::runtime_error** exception is thrown when executing
    the **func** function by the **t** thread. The exception is caught and stored
    in **captured_exception** , a **std::exception_ptr** shared object protected by
    a mutex. The type and value of the thrown exception are determined by calling
    the **std::current_exception()** function.
  prefs: []
  type: TYPE_NORMAL
- en: In the main thread, the **while** loop runs until an exception is captured.
    The exception is re-thrown in the main thread by calling **std::rethrow_exception(captured_exception)**
    . It is caught again by the main thread where the **catch** block is executed,
    printing a message to the console via the **std::cerr** error stream.
  prefs: []
  type: TYPE_NORMAL
- en: We will learn a better solution in [*Chapter 6*](B22219_06.xhtml#_idTextAnchor125)
    by using futures and promises.
  prefs: []
  type: TYPE_NORMAL
- en: Thread-local storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Thread-local Storage** ( **TLS** ) is a memory management technique that
    allows each thread to have its own instance of a variable. This technique allows
    threads to store thread-specific data that is not accessible by other threads,
    avoiding race conditions and improving performance. This is because the overhead
    of synchronization mechanisms to access these variables is removed.'
  prefs: []
  type: TYPE_NORMAL
- en: TLS is implemented by the OS and accessible by using the **thread_local** keyword,
    which has been available since C++11. **thread_local** provides a uniform way
    to use the TLS capabilities of many OSs and avoid compiler-specific language extensions
    for accessing the TLS feature (some examples of such extensions are the TLS Windows
    API, the **__declspec(thread)** MSVC compiler language extension, or the **__thread**
    GCC compiler language extension).
  prefs: []
  type: TYPE_NORMAL
- en: To use TLS with compilers that do not support C++11 or newer versions, use **Boost.Library**
    . This provides the **boost::thread_specific_ptr** container, which implements
    portable TLS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thread-local variables can be declared as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Globally
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In namespaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As class static member variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside functions; it has the same effect as variables allocated with the **static**
    keyword, meaning that the variables are allocated for the lifetime of the program
    and their value are carried through the next function call
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following examples show three threads calling the **multiplyByTwo** function
    with different arguments. This function sets the value of the **val** thread-local
    variable to the argument value, multiplies it by 2, and prints to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this code snippet will show the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that each thread operated on its input argument, resulting
    in **t1** printing **2** , **t2** printing **4** , and **t3** printing **6** .
    The main thread running the main function can also access its thread local variable,
    **val** , which has a value that is set to **1** when the program starts but only
    used when printed out to console at the end of the main function before exiting
    the program.
  prefs: []
  type: TYPE_NORMAL
- en: As with any technique, there are some drawbacks. TLS increases memory usage,
    as a variable is created per thread, so it could be problematic in resource-constrained
    environments. Also, accessing TLS variables might have some overhead compared
    with regular variables. This can be problematic in performance-critical software.
  prefs: []
  type: TYPE_NORMAL
- en: Using many of the techniques we have learned so far, let’s build a timer.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a timer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us implement a timer that accepts intervals and callback functions. The
    timer will execute the callback function at each interval. Also, the user will
    be able to stop the timer by calling its **stop()** function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet shows an implementation of the timer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The **Timer** constructor accepts a **Callback** function (a **std::function<void(void)>**
    object) and a **std::chrono::duration** object defining the period or interval
    when the callback will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: Then a **std::jthread** object is created with a lambda expression, whereby
    a loop calls the callback in intervals of time. This loop checks whether a stop
    has been requested via **stop_token** , which is enabled by using the **stop()**
    **Timer** API function. When this is the case, the loop exits and the thread terminates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we started the timer that will print the **Callback: Running**
    message every second. After three seconds, the main thread will call the **timer.stop()**
    function, terminating the timer thread. The main thread then waits for 500 milliseconds
    before exiting.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: As an exercise, you can slightly modify this example to implement a timeout
    class that calls a callback function if there is no input event within a given
    timeout interval. This is a common pattern when dealing with network communications
    where a packet replay request is sent if no packets have been received for some
    time.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to create and manage threads, how to pass arguments
    or retrieve results, how TLS works, and how to wait for a thread to finish. We
    also learned how to make a thread yield control to others or cancel its execution.
    If something goes wrong and an exception is thrown, we now know how to pass the
    exception between threads and avoid an unexpected program termination. Finally,
    we implemented a **timer** class that periodically runs a callback function.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about thread safety, mutual exclusion, and
    atomic operations. That will include mutexes, locking and lock-free algorithms,
    and memory synchronization ordering, among other topics. That knowledge will help
    us develop thread-safe data structures and algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Compiler support: [https://en.cppreference.com/w/cpp/compiler_support](https://en.cppreference.com/w/cpp/compiler_support)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GCC releases: [https://gcc.gnu.org/releases.html](https://gcc.gnu.org/releases.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Clang: [https://clang.llvm.org](https://clang.llvm.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Clang 8 documentation: [https://releases.llvm.org/8.0.0/tools/clang/docs/index.html](https://releases.llvm.org/8.0.0/tools/clang/docs/index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'LLVM project: [https://llvm.org](https://llvm.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Boost.Threads: [https://www.boost.org/doc/libs/1_78_0/doc/html/thread.html](https://www.boost.org/doc/libs/1_78_0/doc/html/thread.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'P0024 – Technical Specification for Parallelism: [https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0024r0.html](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0024r0.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'TLS proposal: [https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2659.htm](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2659.htm)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Thread Launching for* *C++0X* : [https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2184.html](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2184.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'TLS from IBM: [https://docs.oracle.com/cd/E19683-01/817-3677/chapter8-1/index.html](https://docs.oracle.com/cd/E19683-01/817-3677/chapter8-1/index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Data that is private to a* *thread* : [https://www.ibm.com/docs/en/i/7.5?topic=techniques-data-that-is-private-thread](https://www.ibm.com/docs/en/i/7.5?topic=techniques-data-that-is-private-thread)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource Acquisition Is Initialization** ( **RAII** ): [https://en.cppreference.com/w/cpp/language/raii](https://en.cppreference.com/w/cpp/language/raii)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bjarne Stroustrup, *A Tour of C++* , Third Edition, 18.2 and 18.7.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
