["```cpp\n#include <fstream>\n#include <cstdint>\n#include <array>\n#include <memory>\n#include <string_view>\nstruct Point3D {\n   float x{}, y{}, z{};\n   Point3D() = default;\n   constexpr Point3D(float x, float y, float z)\n      : x{ x }, y{ y }, z{ z } {\n   }\n};\n// ...\n// reads at most N bytes from file named file_name and\n// writes these bytes into buf. Returns the number of\n// bytes read (postcondition: return value <= N)\n//\ntemplate <int N>\n   int read_from_stream(std::array<unsigned char, N> &buf,\n                        std::string_view file_name) {\n   // ...\n}\n// ...\n```", "```cpp\n// ...\n#include <print>\n#include <cassert>\nusing namespace std::literals;\nint main() {\n   static constexpr int NB_PTS = 4;\n   static constexpr int NB_BYTES =\n      NB_PTS * sizeof(Point3D);\n   alignas(Point3D)\n      std::array<unsigned char, NB_BYTES> buf{};\n   if (int n = read_from_stream<NB_BYTES>(\n          buf, \"some_file.dat\"sv\n       ); n != 0) {\n      // print out the bytes: 0-filled left, 2\n      // characters-wide, hex format\n      for (int i = 0; i != n; ++i)\n         std::print(\"{:0<2x} \", buf[i]);\n      std::println();\n      // if we want to treat the bytes as Point3D objects,\n      // we need to start the lifetime of these Point3D\n      // objects. If we do not, we are in UB territory (it\n      // might work or it might not, and even if it works\n      // we cannot count on it)\n      const Point3D* pts =\n         std::start_lifetime_as_array(buf.data(), n);\n      assert(n % 3 == 0);\n      for (std::size_t i = 0;\n           i != n / sizeof(Point3D); ++i)\n         std::print(\"{} {} {}\\n\",\n                    pts[i].x, pts[i].y, pts[i].z);\n   }\n}\n```", "```cpp\n//\n// This is not a good function interface, but we want to\n// keep the example relatively simple\n//\ntemplate <class T>\n  void resize\n    (T *&arr, std::size_t old_cap, std::size_t new_cap) {\n    //\n    // we could deal with throwing a default constructor\n    // but it would complicate our code a bit and these\n    // added complexities, worthwhile as they are, are\n    // besides the point for what we are discussing here\n    //\n    static_assert(\n      std::is_nothrow_default_contructible_v<T>\n    );\n    //\n    // sometimes, there's just nothing to do\n    //\n    if(new_cap <= old_cap) return arr;\n    //\n    // allocate a chunk of raw memory (no object created)\n    //\n    auto p = static_cast<T*>(\n      std::malloc(new_cap * sizeof(T))\n    );\n    if(!p) throw std::bad_alloc{};\n    // ...\n```", "```cpp\n    // ...\n    //\n    // if move assignment does not throw, be aggressive\n    //\n    if constexpr(std::is_nothrow_move_assignable_v<T>) {\n      std::uninitialized_move(arr, arr + old_cap, p);\n      std::destroy(arr, arr + old_cap);\n    } else {\n      //\n      // since move assignment could throw, let's be\n      // conservative and copy instead\n      //\n      try {\n        std::uninitialized_copy(arr, arr + old_cap, p);\n        std::destroy(arr, arr + old_cap);\n      } catch (...) {\n        std::free(p);\n        throw;\n      }\n    }\n    //\n    // fill the remaining space with default objects\n    // (remember: we statically asserted that T::T() is\n    // non-throwing)\n    //\n    std::uninitialized_default_construct(\n      p + old_cap, p + new_cap\n    );\n    //\n    // replace the old memory block (now without objects)\n    // with the new one\n    //\n    std::free(arr);\n    arr = p;\n  }\n```", "```cpp\ntemplate <class T>\n   void resize\n     (T * &arr, std::size_t old_cap, std::size_t new_cap) {\n      static_assert(\n         std::is_nothrow_default_contructible_v<T>\n      );\n      if(new_cap <= old_cap) return arr;\n      auto p = static_cast<T*>(\n         std::malloc(new_cap * sizeof(T))\n      );\n      if(!p) throw std::bad_alloc{};\n      //\n      // this is our ideal case\n      //\n      if constexpr (std::is_trivially_relocatable_v<T>) {\n         // equivalent to memcpy() plus consider the\n         // lifetime of objects in [arr, arr + old_cap)\n         // finished and the lifetime of objects in\n         // [p, p + old_cap) started\n         //\n         // note: this supposes that the trait\n         // std::is_trivially_relocatable<T>\n         // implies std::is_trivially_destructible<T>\n         std::relocate(arr, arr + old_cap, p);\n      //\n      // if move assignment does not throw, be aggressive\n      //\n      } else if constexpr(\n           std::is_nothrow_move_assignable_v<T>\n      ){\n         std::uninitialized_move(arr, arr + old_cap, p);\n         std::destroy(arr, arr + old_cap);\n      } else {\n         // ... see previous code example for the rest\n      }\n   }\n```", "```cpp\n#include <new>\n#include <type_traits>\nvoid* operator new(std::type_identity<X>, std::size_t n);\nvoid operator delete(new X, for example, the specialized form will be preferred to the usual form of operator new() and operator delete(), being assumed to be more appropriate unless the programmer takes steps to prevent it.\nIt also means that, given a specialized allocation algorithm that applies to type `T` only if `special_alloc_alg<T>` is satisfied, you could provide allocation functions that use this specialized algorithm for type `T` through the following function signatures:\n\n```", "```cpp\n#include <concepts>\n#include <type_traits>\nclass X { /* ... */ };\nclass Y { /* ... */ };\nclass Z { /* ... */ };\ntemplate <class C>\n   concept cool_alloc_algorithm =\n      std::is_same_v<C, X> || std::is_same_v<C, Y>;\ntemplate <class T> requires cool_alloc_algorithm<T>\n  void* operator new(std::type_identity<T>, std::size_t n){\n     // apply the cool allocation algorithm\n  }\ntemplate <class T> requires cool_alloc_algorithm<T>\n  void operator delete(std::type_identity<T>, void* p) {\n     // apply the cool deallocation algorithm\n  }\n#include <memory>\nint main() {\n   // uses the \"cool\" allocation algorithm\n   auto p = std::make_unique<X>();\n   // uses the standard allocation algorithm\n   auto q = std::make_unique<Z>();\n} // uses the standard deallocation algorithm for q\n  // uses the \"cool\" deallocation algorithm for p\n```", "```cpp\nclass D0; // forward class declaration\nstruct B {\n  // i)\n  template <class T>\n  void* operator new(std::type_identity<T>, std::size_t);\n  // ii)\n  void* operator new(std::type_identity<D0>, std::size_t);\n};\n// ...\n```", "```cpp\n// ...\nstruct D0 : B { };\nstruct D1 : B { };\nstruct D2 : B {\n  // iii)\n  void *operator new(std::size_t);\n};\n// ...\n```", "```cpp\n// ...\nvoid f() {\n  new B;       // i) where T is B\n  new D0;      // ii)\n  new D1;      // i) where T is D1\n  new D2;      // iii)\n  ::new B;     // uses appropriate global operator new\n}\n```", "```cpp\n\n```", "```cpp\nstruct Drawable {\n   virtual void draw() = 0;\n   virtual ~Drawable() = default;\n};\nclass Painting : public Drawable {\n   void draw() override;\n};\n```", "```cpp\n    //\n    // the following supposes that Painting is a public\n    // derived class of Drawable as suggested earlier in\n    // this section\n    //\n    Drawable *p = new Painting;\n    // ...\n    delete p; // <-- here\n    ```", "```cpp\nauto s0 = sizeof(int); // s0 is the number of bytes in an\n                       // int (parentheses required)\nint n;\nauto s1 = sizeof n; // s1 is the number of bytes occupied\n                    // by s1, which is identical to s0.\n                    // Note: for objects, parentheses are\n                    // allowed but not mandated\n```", "```cpp\nvoid f(int *p) {\n   assert(p); // we hold p != nullptr to be true\n   // use *p\n}\n```", "```cpp\nint *obtain_buf(int);\nvoid danger(int n) {\n   int *p; // uninitialized\n   assert(p = obtain_buf(n)); // dangerous!!!\n   // use *p, but p might be uninitialized if assert()\n   // has been disabled. This is very bad\n}\n```", "```cpp\nstatic_assert(sizeof(int)==4); // only compiles if the\n                               // condition holds\n```", "```cpp\n// hand-made is_const<T> and remove_const<T> traits\n// (please use the standard versions from <type_traits>\n// instead of writing your own!)\ntemplate <class> struct is_const {\n   static constexpr bool value = false; // general case\n};\n// specialization for const types\ntemplate <class T> struct is_const<const T> {\n   static constexpr bool value = true;\n};\n// general case\ntemplate <class T> struct remove_const {\n   using type = T;\n};\n// specialization for const T\ntemplate <class T> struct remove_const<const T> {\n   using type = T;\n};\n```", "```cpp\n#include <type_traits>\n// hand-made is_const<T> (prefer the std:: versions...)\ntemplate <class> struct is_const : std::false_type {\n};\ntemplate <class T>\n   struct is_const<const T> : std::true_type {\n   };\n```", "```cpp\n#include <cmath>\n// we will allow comparisons between exact representations\n// or floating point representations based on so-called tag\n// types (empty classes used to distinguish function\n// signatures)\nstruct floating {};\nstruct exact {};\n// the three-argument versions are not meant to be called\n// directly from user code\ntemplate <class T>\n   bool close_enough(T a, T b, exact) {\n      return a == b; // fine for int, short, bool, etc.\n   }\ntemplate <class T>\n   bool close_enough(T a, T b, floating) {\n      // note: this could benefit from more rigor, but\n      // that's orthogonal to our discussion\n      return std::abs(a - b) < static_cast<T>(0.000001);\n   }\n// this two-argument version is the one user code is\n// meant to call\ntemplate <class T>\n   bool close_enough(T a, T b) {\n      // OUR GOAL: call the \"floating\" version for types\n      // float, double and long double; call the \"exact\"\n      // version otherwise\n   }\n```", "```cpp\n// we could write is_floating_point<T> as follows\n// (but please use std::is_floating_point<T> instead!\ntemplate <class> struct is_floating_point\n   : std::false_type {}; // general case\n// specializations\ntemplate <> struct is_floating_point<float>\n   : std::true_type {};\ntemplate <> struct is_floating_point<double>\n   : std::true_type {};\ntemplate <> struct is_floating_point<long double>\n   : std::true_type {};\n// convenience to simplify user code\ntemplate <class T>\n   constexpr bool is_floating_point_v =\n      is_floating_point<T>::value;\n```", "```cpp\n// example, home-made conditional<B,T,F> type trait\n// (prefer the std:: version in <type_traits>)\n// general case (incomplete type)\ntemplate <bool, class T, class F> struct conditional;\n// specializations\ntemplate < class T, class F>\n   struct conditional<true, T, F> {\n      using type = T; // constant true, picks type T\n   };\ntemplate < class T, class F>\n   struct conditional<false, T, F> {\n   using type = F; // constant true, picks type F\n};\n// convenience to simplify user code\ntemplate <bool B, class T, class F>\n   using conditional_t = typename conditional<B,T,F>::type;\n```", "```cpp\n// ...\n// this version will be called from user code\ntemplate <class T>\n   bool close_enough(T a, T b) {\n      return close_enough(\n         a, b, conditional_t<\n            is_floating_point_v<T>,\n            floating,\n            exact\n         > {}\n      );\n   }\n```", "```cpp\nint vals[]{ 2,3,5,7,11 };\nint dest[5];\nfor(int i = 0; i != 5; ++i)\n   dest[i] = vals[i];\n```", "```cpp\nint vals[]{ 2,3,5,7,11 };\nint dest[5];\n[begin,end), meaning that for all algorithms, the beginning iterator (here, begin(vals)) is included and the ending iterator (here, end(vals)) is excluded, making [begin,end) a half-open range. All algorithms in <algorithm> and in its cousin header, <numeric>, follow that simple convention.\nWhat about ranges?\nThe `<ranges>` library is a major addition to the C++ standard library since C++20 and can sometimes be used to lead to even better code than the already tremendous `<algorithm>` library. This book does not use ranges much, but that does not mean this library is not wonderful, so please feel free to use it and investigate ways through which it can be used to make your code better.\nFunctors (function objects) and lambdas\nIt is customary in C++ to use **functors**, otherwise called **function objects**, to represent stateful computations. Think, for example, of a program that would print integers to the standard output using an algorithm:\n\n```", "```cpp\n\n This small program works fine, but should we want to print elsewhere than on the standard output, we would find ourselves in an unpleasant situation: the `for_each()` algorithm expects a unary function in the sense of “function accepting a single argument” (here, the value to print), so there’s no syntactic space to add an argument such as the output stream to use. We could “solve” this issue through a global variable, or using a different function for every output stream, but that would fall short of a reasonable design.\nIf we replace the `display` function with a class, which we’ll name `Display` to make them visually distinct, we end up with the following:\n\n```", "```cpp\n\n This leads to nice, readable code with added flexibility. Note that, conceptually, lambda expressions are functors (you can even use lambdas as base classes!), so the previous example can be rewritten equivalently as follows:\n\n```", "```cpp\n\n Lambdas are thus essentially functors that limit themselves to a constructor and an `operator()` member function, and this combination represents the most common case by far for such objects. You can, of course, still use full-blown, explicit functors if you want more than this.\nFriends\nC++ offers an access qualifier that’s not commonly found in other languages and is often misunderstood: the `friend` qualifier. A class can specify another class or a function as one of its friends, giving said `friend` qualifier full access to all of that class’s members, including those qualified as `protected` or `private`.\nSome consider `friend` to break encapsulation, and indeed it can do this if used recklessly, but the intent here is to provide privileged access to specific entities rather than exposing them as `public` or `protected` members that were not designed to that end, leading to an even wider encapsulation breakage.\nConsider, for example, the following classes, where `thing` is something that is meant to be built from the contents of a file named `name` by a `thing_factory` that’s able to validate the file’s content before constructing the `thing`:\n\n```", "```cpp\n\n We do not want the whole world to be able to call the `private`-qualified `thing` constructor that takes an arbitrary `string_view` as an argument since that constructor is not meant to handle character strings that have not been validated in the first place. For this reason, we only let `thing_factory` use it, thus strengthening encapsulation rather than weakening it.\nIt is customary to put a class and its friends together when shipping code as they go together: a friend of a class, in essence, is an external addition to that class’s interface. Finally, note that restrictions apply to friendship. Friendship is not reflexive; if `A` declares `B` to be its friend, it does not follow that `B` declares `A` to be its friend:\n\n```", "```cpp\n\n Friendship is not transitive; if `A` declares `B` to be its friend and `B` declares `C` to be its friend, it does not follow that `A` declares `C` to be its friend:\n\n```", "```cpp\n\n Last but not least, friendship is not inherited; if `A` declares `B` to be its friend, it does not follow that if `C` is a child class of `B`, `A` has declared `C` to be its friend:\n\n```", "```cpp\n\n Used judiciously, `friend` solves encapsulation problems that would be difficult to deal with otherwise.\nThe decltype operator\nThe type system of C++ is powerful and nuanced, offering (among other things) a set of type deduction facilities. The best-known type deduction tool is probably `auto`, used to infer the type of an expression from the type of its initializer:\n\n```", "```cpp\n\n As you might notice from the preceding example, by default, `auto` makes copies (see the declaration of variable `m` ), but you can qualify `auto` with `&`, `&&`, `const`, and so on if needed.\nSometimes, you want to deduce the type of an expression with more precision, keeping the various qualifiers that accompany it. That might be useful when inferring the type of an arithmetic expression, the type of a lambda, the return type of a complicated generic function, and so on. For this, you have the `decltype` operator:\n\n```", "```cpp\n\n The use of `auto` has become commonplace in C++ code since C++11, at least in some circles. The `decltype` operator, also part of C++ since C++11, is a sharper tool, still widely used but for more specialized use cases.\nWhen the types get painful to spell\nIn the preceding `decltype` example, we spelled `pass_thru(n)` twice: once in the `decltype` operator and once in the actual function call. That’s not practical in general since it duplicates the maintenance effort and… well, it’s just noise, really. Since C++14, one can use `decltype(auto)` to express “the fully qualified type of the initializing expression.”\nThus, we would customarily write `decltype(auto) r = pass_thru(n);` to express that `r` is to have the fully qualified type of the expression `pass_thru(n)` .\nPerfect forwarding\nThe advent of variadic templates in C++11 has made it necessary to ensure there is a way for the semantics at the call site of a function to be conveyed throughout the call chain. This might seem abstract but it’s quite real and has implications on the effect of function calls.\nConsider the following class:\n\n```", "```cpp\n\n This class exposes at least two constructors, one that takes an `int` and `const string&` as argument and another that takes an `int` and a `string&&` instead. To make the example more general, we’ll also suppose the existence of other `X` constructors that we might want to call while still focusing on these two. If we called these two constructors explicitly, we could do so with the following:\n\n```", "```cpp\n\n The constructor of `x0` calls `A`, as `\"hello\"` is a `const char(&)[6]` (including the trailing `'\\0'`), not a `string` type, but the compiler’s allowed to synthesize a temporary `string` to pass as a `const string&` in this case (it could not if the `string&` was non-`const` as it would require referring to a modifiable object).\nThe constructor of `x1` also calls `A`, as `s` is a named `string` type, which means it cannot be implicitly passed by movement.\nThe constructors of `x2` and `x3` both call `B`, which takes a `string&&` as an argument, as they are both passed temporary, anonymous `string` objects that can be implicitly passed by movement.\nNow, suppose we want to write a factory of `X` objects that relays arguments to the appropriate `X` constructor (one of the two we’re looking at or any other `X` constructor) after having done some preliminary work; for the sake of this example, we’ll simply log the fact that we are constructing an `X` object. Let’s say we wrote it this way:\n\n```", "```cpp\n\n In this case, arguments would all have names and be passed by value, so the constructor that takes a `string&&` would never be chosen.\nNow, let’s say we wrote it this way:\n\n```", "```cpp\n\n In this case, arguments would all be passed by reference, and a call that passed a `char` array such as `\"hello\"` as an argument would not compile. What we need to do is write our factory function in such a way that each argument keeps the semantics it had at the function’s call site, and is forwarded by the function with the exact same semantics.\nThe way to express this in C++ involves `std::forward<T>()` (from `<utility>`), which behaves as a cast. A forwarding reference superficially and syntactically looks like the `rvalue` references used for move semantics, but their impact on argument semantics is quite different. Consider the following example:\n\n```", "```cpp\n// T is vector<int>&& (pass by movement)\nf2(vector<int>{ 2,3,5,7,11 });\nvector<int> v0{ 2,3,5,7,11 };\nf2(v0); // T is vector<int>& (pass by reference)\nconst vector<int> v1{ 2,3,5,7,11 };\nX objects, in this case, the appropriate signature for makeX() would be as follows:\n\n```", "```cpp\n\n This version of our function almost works. The signature of `makeX()` is correct as each argument will be accepted with the type used at the call site, be it a reference, a reference to `const`, or an `rvalue` reference. What’s missing is that the arguments we are receiving as `rvalue` references now have a name within `makeX()` (they’re part of the pack named `args`!), so when calling the constructor of `X`, there’s no implicit move involved anymore.\nWhat we need to do to complete our effort is to *cast back each argument to the type it had at the call site*. That type is inscribed in `Args`, the type of our pack, and the way to perform that cast is to apply `std::forward<T>()` to each argument in the pack. A correct `makeX()` function, at long last, would be as follows:\n\n```", "```cpp\n\n Whew! There are simpler syntaxes indeed, but we made it.\nThe singleton design pattern\nThere are many design patterns out there. Design patterns are a topic of their own, representing well-known ways of solving problems that one can represent in the abstract, give a name to, explain to others, and then reify within the constraints and idioms of one’s chosen programming language.\nThe **singleton** design pattern describes ways in which we can write a class that ensures it is instantiated only once in a program.\nSingleton is not a well-liked pattern: it makes testing difficult, introduces dependencies on global state, represents a single point of failure in a program as well as a potential program-wide bottleneck, complicates multithreading (if the singleton is mutable, then its state requires synchronization), and so on, but it has its uses, is used in practice, and we use it on occasion in this book.\nThere are many ways to write a class that is instantiated only once in a program with the C++ language. All of them share some key characteristics:\n\n*   The type’s `copy` operations have to be deleted. If one can copy a singleton, then there will be more than one instance of that type, which leads to a contradiction.\n*   There should be no `public` constructor. If there were, the client code could call it and create more than one instance.\n*   There should be no `protected` members. Objects of derived classes are also, conceptually, objects of the base class, again leading to a contradiction (there would, in practice, be more than one instance of the singleton!).\n*   Since there is no `public` constructor, there should be a `private` constructor (probably a default constructor), and that one will only be accessible to the class itself or to its friends (if any). For simplicity, we’ll suppose that the way to access a singleton is to go through a `static` (obviously) member function of the singleton.\n\nWe’ll look at ways to implement an overly simplistic singleton in C++. For the sake of this example, the singleton will provide sequential integers on demand. The general idea for that class will be the following:\n\n```", "```cpp\n\n The following subsections show two different techniques to create and provide access to the singleton.\nInstantiation at program startup\nOne way to instantiate a singleton is to create it before `main()` starts by actually making it a `static` data member of its class. This requires *declaring* the singleton in the class and *defining* it in a separate source file in order to avoid ODR problems.\nODR, you say?\nThe **One Definition Rule** (**ODR**) and associated issues are described in [*Chapter 2*](B21071_02.xhtml#_idTextAnchor027) of this book, but the gist of it is that in C++, every object can have many declarations but only one definition.\nA possible implementation would be as follows:\n\n```", "```cpp\nauto & provider = SequentialIdProvider::get();\nfor(int i = 0; i != 5; ++i)\n   cout << provider.next() << ' ';\n```", "```cpp\n#include <atomic>\nclass SequentialIdProvider {\n   std::atomic<long long> cur; // state (synchronized)\n   // default constructor (private)\n   SequentialIdProvider() : cur{ 0LL } {\n   }\npublic:\n   // static member function providing access to the object\n   static auto & get() {\n      static SequentialIdProvider singleton; // definition\n      return singleton;\n   }\n   // service offered by the singleton (synchronized)\n   auto next() { return cur++; }\n   // deleted copy operations\n   SequentialIdProvider(const SequentialIdProvider&)\n      = delete;\n   SequentialIdProvider&\n      operator=(const SequentialIdProvider&) = delete;\n   // ...\n};\n```", "```cpp\nauto & provider = SequentialIdProvider::get();\nfor(int i = 0; i != 5; ++i)\n   cout << provider.next() << ' ';\n```", "```cpp\ntemplate <class T>\n   class fixed_size_array {\n      T *elems{};\n      std::size_t nelems{};\n   public:\n      // ...\n      fixed_size_array(fixed_size_array &&other)\n         : elems{ other.elems }, nelems{ other.nelems } {\n         other.elems = nullptr;\n         other.nelems = 0;\n      }\n      // ...\n   };\n```", "```cpp\ntemplate <class T>\n   class fixed_size_array {\n      T *elems{};\n      std::size_t nelems{};\n   public:\n      // ...\n      fixed_size_array(fixed_size_array &&other)\n         : elems{ std::exchange(other.elems, nullptr) },\n           nelems{ std::exchange(other.nelems, 0) } {\n      }\n      // ...\n   };\n```", "```cpp\n\n```", "```cpp\n\n```"]