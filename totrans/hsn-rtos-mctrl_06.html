<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Selecting the Right MCU</h1>
                </header>
            
            <article>
                
<p><span>This chapter is a crash course on <strong>microcontroller unit</strong> (<strong>MCU</strong>) selection, targeted at engineers who don't have a deep hardware background. It doesn't try to be an exhaustive list of absolutely everything you need to know and consider when selecting hardware for your new project. It does provide an introduction to many of the contributing factors for differentiating between and selecting MCU devices. By the end, you'll be aware of enough key considerations to efficiently research MCUs and discuss potential candidates with the hardware engineers on the team. By increasing hardware/firmware collaboration and selecting the right MCU for the project the first time around, you'll avoid both hardware redesigns and schedule delays.</span></p>
<p><span>We'll start by introducing a wide range of considerations that go into selecting a suitable MCU for your project. After that, trade-offs between different development hardware will be discussed. A short introduction to the STM32 line is provided to show how vendors tend to group their product families. At the end of this chapter, we'll compare a few different <strong>development boards</strong> (<strong>dev boards</strong>) with STM32 MCUs at their heart to show why we're using the dev board we are!</span></p>
<p>This chapter will cover the following topics:</p>
<ul>
<li>The importance of MCU selection</li>
<li>MCU considerations</li>
<li>Dev board considerations</li>
<li>Introducing the STM32 MCU product line</li>
<li>How our dev board was selected</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>All you need for this chapter is access to the internet in order to browse a few websites.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The importance of MCU selection</h1>
                </header>
            
            <article>
                
<p>After reading the title of this section, you might be asking yourself:</p>
<div class="packt_quote">"Hey! I thought this was a book about how to program a microcontroller using an RTOS—what's all this about MCU selection? I'm a software developer!"</div>
<p>FreeRTOS is almost exclusively targeted at MCUs. It is primarily a scheduling kernel with a stable API, which makes it very well-suited to extremely low-level design. Unlike a full-blown CPU system with practically<span> </span><span>unlimited</span><span> virtual addressing space and more clock cycles than you know what to do with, you're going to be working with a resource-constrained system. If you're developing firmware on this type of system, it means you're going to be much closer to the hardware than if you were writing software—which, in turn, means you're very likely going to be getting your hands very dirty, compared to your software counterparts. By dirty, we're talking</span> <em>logic analyzer probing pins</em> <span>dirty. . .</span> <em>DMM permanently sitting on your desk</em> <span>dirty. . . </span><em>learn how to solder so you can tack a lead onto the MCU in the quad flat pack</em> <span>dirty. . . you get the idea! If you're from an exclusively software background, you've got some learning to do because we're about to dive into the gray area that resides between software and hardware—firmware—and it should be a lot of fun!</span></p>
<p class="mce-root">Firmware and hardware are very closely linked, which is why it is so important that firmware engineers are brought into the fray early on in the development process. In some organizations, there is still only one person performing the electrical design work and writing the firmware. However, there is a growing trend that drives disciplines to be more and more specialized in their domains of expertise. Even in this case, it is important that multiple team members are brought in to make important design decisions up front, so everyone is aware of the trade-offs being made.</p>
<p>If you're not the person immediately responsible for selecting an MCU, then there's a chance a design might be <em>thrown over the wall</em> to you. This is almost always a bad thing because it encourages sub-optimal system designs to avoid schedule delays caused by hardware being significantly redesigned after some core piece of functionality of the system is discovered. Instead of committing to a significant board revision to address a major design shortcoming, many teams are pressured to <em>just fix it with some code</em>.</p>
<p>So, assuming you have some input in selecting an MCU—even if your involvement is just a case of "<em>Hey, Ted, what do you think of this micro for that new project?", </em>it's on you to arm yourself with enough background knowledge to form an intelligent opinion (or at least ask intelligent questions). This chapter isn't meant to be an exhaustive list with absolutely everything you need to know and consider when selecting hardware for your new project, but it does aim to provide an introduction to many of the contributing factors for differentiating and selecting between MCU devices. The other thing to keep in mind when reading this chapter is that it only applies to deciding between MCUs. As we saw from <em><a href="39404421-bf7a-4283-bf78-c396818be4b4.xhtml">Chapter 1</a>, Introducing Real-Time Systems</em>, there's more than one way to skin a real-time system cat—MCUs aren't <em>always</em> the best choice.</p>
<p>In order to limit the scope of this chapter to what is immediately relevant, for the examples presented in the remainder of the book, we'll be limiting our discussion to features found in ARM Cortex-M-based devices. We're focusing on ARM Cortex-M MCUs because the devices based on the Cortex-M core bring a really useful blend of features that enable engineers to create medium to highly complex real-time embedded systems using a <strong>real-time operating system</strong> (<strong>RTOS</strong>), while still being able to architect the solution in such a way that modules are reusable for other projects. <span>STM32 MCUs have been selected because of their popularity, the wide range of MCUs available, their approachable <strong>integrated circuit</strong> (<strong>IC</strong>) packaging, and the included hardware peripherals. </span>While we're focusing on STM32 parts in this chapter, keep in mind that there are plenty of other manufacturers out there with tons of great products and the vast majority of what's covered will apply to non-STM32 (and non-ARM) parts as well.  </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">MCU considerations </h1>
                </header>
            
            <article>
                
<p>There are a few considerations that need to be made into selecting a microcontroller itself, rather than the dev board. Assuming the project contains fully custom electronics, there is no limitation on the exact MCU chosen as there would be if you were only selecting between dev boards. Students and hobbyists sometimes artificially limit themselves even further, sometimes staying loyal to certain ecosystems and only selecting from dev boards within those ecosystems (such as Arduino or mBed). While there is certainly nothing inherently <em>wrong</em> with any of the ecosystems, you'll fail to grow as a professional engineer if you're incapable of considering other solutions or appreciating the unique strengths each piece of hardware brings to a particular project.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Core considerations</h1>
                </header>
            
            <article>
                
<p>First, we'll discuss how to address some key questions that will immediately narrow down the field of potential MCU candidates for a project:</p>
<ul>
<li>Will it fit?</li>
<li>Can it run all of my code?</li>
<li>How much does it cost?</li>
<li>Is it readily available?</li>
</ul>
<p>Let's answer these questions one by one.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Physical size</h1>
                </header>
            
            <article>
                
<p>Depending on the design, the MCU's size can be an important factor. If you're developing a wearable or portable device, size is likely to be at the top of your list. Sometimes, pre-packaged MCUs are too large and the designers are required to resort to <em>chip on board</em> (where the MCU silicon die is directly bonded to the <strong>printed circuit board</strong><span> (</span><strong>PCB</strong><span>)</span>, instead of being placed in a separate plastic package). On the other hand, large pieces of rack-mounted equipment tend to have more than enough space for any size MCU that is suitable to do the job. </p>
<p>A note to those of you who are interested in designing your own hardware—the packaging type will play a role in the PCB complexity as well as the ease of assembly (especially at the prototyping stage). If your prototypes will be hand-assembled, any of the gull-wing packages, such as <strong>quad flat pack</strong> (<strong>QFP</strong>), are the most approachable. After QFPs, <strong>quad flat pack no-lead</strong> (<strong>QFN</strong>) packages are still easily hand soldered. <strong>Ball grid arrays</strong> (<strong>BGAs</strong>) are generally best avoided for hand assembly, unless you're a soldering wizard!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">ROM</h1>
                </header>
            
            <article>
                
<p><strong>Read-only memory</strong> (<strong>ROM</strong>) is a fairly large differentiating factor for MCUs in the same family, with ROM size being strongly correlated to price. Depending on the number of different models available in a product family, there could be multiple MCUs with very similar peripheral sets. These MCUs will likely share the same physical footprint but have significantly different amounts of memory. If your application is cost-sensitive but the required ROM is unknown, consider the following approach:</p>
<ol>
<li>Select an MCU family that provides multiple flash sizes in a compatible footprint.</li>
<li>Start development with the MCU that has the most ROM in the family. This provides the most flexibility for adding features.</li>
<li>After the final image size is known, the exact MCU (with a smaller flash size) can be selected before beginning mass production. </li>
</ol>
<div class="packt_tip">When taking this approach, you'll need to be sure to leave enough room for future features, assuming your product will be capable of receiving field-updates to its firmware. Also, be sure to double-check peripheral assignments between models—<em>pin compatible</em> doesn't always mean <em>firmware compatible</em>!</div>
<p>The amount of ROM required varies greatly and is dependent on how much code needs to be loaded onto the device. If you've been working with 8-bit MCUs, then you might be in for a nasty surprise when moving to a 32-bit architecture such as ARM. A similar program will require more flash space to implement on a 32-bit architecture versus an 8-bit architecture. The good news here is that flash sizes have kept up, so it's nearly always possible to find an MCU with enough onboard flash to accommodate your application. Pulling third-party libraries into your code base is generally fairly costly in terms of flash, so be mindful if you choose to go down this route.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">RAM</h1>
                </header>
            
            <article>
                
<p>The amount of on-chip <strong>random access memory</strong> (<strong>RAM</strong>) is another factor to consider—it will generally follow the amount of flash a given device has. Parts with larger ROM will usually have more RAM. A few examples where large amounts of RAM will be required are data processing that requires large buffers for data, complex network stacks, deep buffers for communication, GUIs (especially those that require frame buffers), and any interpreted languages that run a virtual machine (that is, MicroPython and Lua). </p>
<p>For example, let's say your application calls for a high-resolution display. If the display doesn't have an on-board controller with its own frame buffer, you're likely already in external RAM territory. The size buffer required to drive that type of display will likely exceed the RAM available on board the MCU. On the other hand, if you're building a simple control system with limited connectivity and UI capability, then a small amount of RAM may be all that is required. </p>
<p>Also, note that each task in FreeRTOS requires its own stack (generally with a bare minimum of 512 bytes on the Cortex-M port), so if a large number of tasks is required, it will be easy to quickly utilize several KB of RAM.</p>
<p>From a firmware engineer's perspective, external RAM seems like a get-out-of-jail-free card (who wouldn't want to increase the available RAM by nearly an order of magnitude)—but all of that functionality does come at a cost. Unless your system absolutely requires it, external RAM on the MCU's address/data bus is best avoided. It will require additional PCB real estate, consume more power, and ultimately, drive up PCB and bill of materials (<strong>BOM</strong>) costs. The PCB layout can be considerably more complicated when adding an external high-speed parallel bus used for accessing an external RAM because of length-tuning requirements and the number of signals involved. The design will also be more likely to emit EMI because of all the high-speed signals. Although it offers plenty of space, external RAM is often marginally slower than on-board RAM, which can lead to a more complex linker file (if certain functions have very tight timing constraints). <span>Other factors worthy of consideration include </span>properly setting up RAM timing parameters and caching coherency issues if you attempt to speed up access to external RAM by using data caching (refer to <em>Further reading</em> section for details).</p>
<p>With all of its downsides, having external RAM enables a lot of functionality, such as the ability to cache entire firmware images in RAM for upgrades, feature-rich GUI frameworks, complex networking stacks, and sophisticated signal processing techniques. As with any other requirement, there are trade-offs to be made.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The CPU clock rate</h1>
                </header>
            
            <article>
                
<p>Since we're limiting our discussion to MCUs with the same underlying architecture, an MCU with a faster core clock rate will execute the same set of pure software functions faster than one with a slower clock rate. Notice the keyword <em>pure</em> in the previous statement—sometimes, there are on-board hardware peripherals that can make a huge difference to execution speed that have nothing to do with the CPU clock rate (such as the hardware floating point and DSP functionality available on the Cortex-M4 core). </p>
<p>Another thing to be mindful of is the absolute maximum clock rate of the device versus the practical clock rate for an application. For example, some MCUs' maximum clock frequency is incompatible with generating an internal 48 MHz clock required for a USB peripheral, so it can't be used at maximum speed if the USB peripheral is also used. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Interrupt processing</h1>
                </header>
            
            <article>
                
<p>Within the ARM Cortex-M family, interrupt processing is all very similar. All of the devices include a <strong>nested vector interrupt controller</strong> (<strong>NVIC</strong>) with a relocatable vector table and an <strong>external interrupt controller</strong> (<strong>EXTI</strong>). Device-specific considerations include the exact peripheral interrupts that are available and how they are mapped to the NVIC, as well as how external interrupts are multiplexed into the EXTI.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Price</h1>
                </header>
            
            <article>
                
<p>Depending on the application, the BOM's cost may be a significant driver or hardly a consideration. Generally, BOM costs come under increasing scrutiny in high-volume applications. However, with lower volume products, it is often wise to focus more on minimizing the development time and effort of a product, rather than achieving the lowest BOM cost possible. By focusing on minimizing the amount of engineering effort and development time for a low-volume product, the product will get to market sooner. Not only does the product start generating revenue faster, but it also accrues less <strong>non-recurring engineering</strong> (<strong>NRE</strong>) costs. Less NRE leads to a faster <strong>return on investment</strong> (<strong>ROI</strong>) for the product being developed. Faster ROI ultimately makes managers and CEOs really happy! In these situations, worrying about spending a few dollars on a BOM for a product selling dozens per year—at the expense of weeks or months of development effort—is rarely a wise trade-off.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Availability</h1>
                </header>
            
            <article>
                
<p>An often-overlooked aspect of an MCU by junior engineers is its expected and guaranteed availability. Just because a part is available for purchase at the beginning of the project does not mean it will be available for the entire time that the end product will be sold. In the case of consumer devices, this probably isn't a huge issue. This is because these devices can have extremely high volumes, but any single revision is only in production for a limited amount of time (from months to a year or two). </p>
<p>Contrast the consumer electronics mindset of planned obsolescence with something on the industrial, telecom, or aerospace side. In these industries, development timelines can be measured in years and required support periods are often a decade or more. This is why part availability is a very real consideration. Be sure to investigate the manufacture guarantees on availability and weigh these against their history, reputation, and the risk to the project—it's not a pleasant experience to get 80% of a design complete only to find out that the MCU can't be sourced during a pre-production run!</p>
<p>Now that we've covered some of the initial considerations to be aware of, we'll move on to some of the more unique considerations for embedded processors—hardware peripherals.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Hardware peripherals</h1>
                </header>
            
            <article>
                
<p>Compared to the desktop world of CPUs, where the processor itself is generally the center of attention, selecting the <em>right</em> MCU is more complex due to the increase in scope. Many different pieces of hardware are included on the same chip, which enables us to optimize the solution for speed, power, CPU utilization, or BOM cost. In a highly constrained design, all of these factors can come into play and trade-offs will need to be made.</p>
<p>This section will cover some of the hardware peripherals commonly available on Cortex-M- based MCUs and aims to provide an extremely brief introduction to them, with the goal of informing you why each type of peripheral may be helpful to have in a design.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Connectivity</h1>
                </header>
            
            <article>
                
<p>In today's ever-increasingly connected ecosystem of the <span><strong>Internet of Things</strong> (</span><strong>IoT</strong>), having on-board networking capability on the MCU can be a boon to a project. . . as long as the right firmware exists to drive it. It is important to realize that having a peripheral is not the same as having full functionality. For example, just because an MCU supports a <strong>reduced media independent interface</strong> (<strong>RMII</strong>) and a <strong>physical layer in networking</strong> (<strong><span>PHY</span></strong>) does not mean you can immediately get a full TCP/IP stack—all of that firmware functionality needs to come from somewhere. Potential connectivity baked into devices can include Ethernet, RMII, 802.11 (WiFi), 802.15.1 (<span>Bluetooth)</span>, and 802.15.4 (Zigbee, HART, and so on).</p>
<p>When it comes to wireless communications, things get a bit more complex, since the product will need to be pushed through an approval process from the appropriate agency, depending on geographic location. Pre-certified <strong>radio frequency</strong> (<strong>RF</strong>) modules can be used to minimize the amount of effort and cost to develop a properly certified end product. </p>
<p>Due to a specialized PCB layout, regulatory requirements, and complex network stacks, on-board MCU peripherals that facilitate wireless communications aren't quite as useful as they first appear for a low-volume product. Again, don't be lulled into a false sense of accomplishment by simply specifying a part that has hardware available, since wireless communication stacks can be extremely complex and wireless certification testing is expensive.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Memory protection units</h1>
                </header>
            
            <article>
                
<p><strong>Memory protection units</strong> (<strong>MPUs</strong>) are used to ensure that code only accesses the range of RAM it is permitted to. When used correctly, MPUs ensure greater system stability and increased security, since the application is less likely to cause unintended consequences by accessing memory it shouldn't.</p>
<div class="mce-root packt_infobox">FreeRTOS includes support for MPU-protected tasks, which we'll cover in <em><a href="0f98e454-9804-4589-9854-5c38c9d8d416.xhtml">Chapter 15</a>, FreeRTOS Memory Management</em>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Hardware floating-point units</h1>
                </header>
            
            <article>
                
<p>If your application is going to be crunching lots of floating point numbers, a <strong>hardware</strong> <strong>floating-point unit</strong> (<strong>FPU</strong>) can be extremely helpful. Until the past decade or so, floating point numbers were generally best avoided in most MCU-based embedded systems. The availability of faster processors started to change this. Now, FPUs are often implemented in hardware. Thanks to FPUs, many different applications can benefit from using floating point math, without incurring the CPU performance penalty commonly associated with software-based library implementations.</p>
<p>Single-precision (32-bit) FPUs are optional on Cortex-M4 processors, while Cortex-M7-based processors add optional hardware support for double-precision (64-bit) floating point arithmetic. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Digital signal processing functions</h1>
                </header>
            
            <article>
                
<p>Along with increased performance from hardware-based, floating point support, the Cortex-M4- and Cortex-M7-based MCUs also have optional <strong>digital signal processing</strong> (<strong>DSP</strong>) functionality baked into the hardware, which can greatly accelerate some complex algorithms and potentially help reduce the coding burden for firmware engineers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Direct memory access channels</h1>
                </header>
            
            <article>
                
<p><strong>Direct memory access</strong> (<strong>DMA</strong>) can be extremely useful in a variety of situations where high bandwidth or highly event-driven code is desired. DMA controllers are typically able to interact with MCU peripherals, as well as different parts of RAM. They take care of populating peripheral registers and RAM without involving the CPU at all. These autonomous transfers can free up significant CPU time by greatly reducing the interrupt load and context switching.</p>
<p>One thing to keep in mind regarding DMA peripherals is that all channels aren't always mapped to all peripherals. Certain channels can be of a higher bandwidth than others. This is most significant in systems that require multiple high-bandwidth devices. For challenging systems such as these, it is important for firmware and hardware engineers to work together to ensure that a hardware design doesn't cause a handicap for firmware down the road.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Communication interfaces</h1>
                </header>
            
            <article>
                
<p>We've already introduced external network connectivity relative to Ethernet and wireless technologies. There are many different communication interfaces that are more traditionally associated with embedded devices and are commonly available as hardware peripherals on an MCU. The interfaces that <span>are used for communicating with on- and off-board sensors and actuators are as follows:</span></p>
<ul>
<li><strong>Inter-IC Communication</strong> (<strong>I2C</strong>)</li>
<li><strong>Serial peripheral interface</strong> (<strong>SPI</strong>)</li>
<li><strong>Universal Synchronous/Asynchronous Receiver Transmitter</strong> (<strong>USART</strong>)</li>
</ul>
<p><span>The following peripherals are regularly used in automotive and industrial environments for inter-module communication:</span></p>
<ul>
<li><strong>USARTs</strong></li>
<li><strong>Controller area network</strong> (<strong>CAN</strong>)</li>
<li><strong>Local interconnect network</strong> (<strong>LIN</strong>)</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Hardware crypto engines</h1>
                </header>
            
            <article>
                
<p>If your application calls for external connectivity, then your mind should also be focused on security. In the same way that FPUs make floating point operations more CPU efficient, hardware-based cryptography engines are available on some MCUs, which will greatly reduce the CPU burden required to securely transfer data over public networks.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Timing hardware</h1>
                </header>
            
            <article>
                
<p>There are often several different timing peripherals included on an MCU. The peripherals themselves will often include input capture, output compare, and <strong>pulse width modulation</strong> (<strong>PWM</strong>) functionality as a minimum. Some devices will also include timing hardware for interfacing with quadrature encoders.</p>
<p>Input capture deals with <em>capturing</em> the time a digital input to the MCU changes state. MCU peripherals do this with a much higher resolution than firmware because they use high-frequency counters and hardware gates to capture the signal transition (rather than relying on multiple CPU instructions). There are often several channels of input capture available, which can be used in parallel. Output compare is effectively the reverse of input capture (a signal is output with precise timing characteristics)—<em>compare</em> refers to the hardware comparator used to determine when to perform the transition.</p>
<p>PWM and input capture are both very commonly used in control systems to interact with sensors and actuators. Some actuators will take PWM as inputs. PWM can also be used to provide proportional control of a binary driver (such as a transistor), which can be used to precisely change the amount of power delivered to a load. Many different encoders will often supply information in PWM format as well, which can be read by the MCU using a timer peripheral's input capture mode.</p>
<p><strong>Quadrature encoder inputs</strong> (<strong>QEIs</strong>) are extremely useful in motion feedback systems. Although similar functionality can be achieved using multiple channels of input capture (or slowly, without any dedicated hardware), having dedicated QEI hardware allows for very minimal CPU intervention, even at high input rates.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Integrated analog</h1>
                </header>
            
            <article>
                
<p class="mce-root"><strong>Digital to Analog Converters</strong> (<strong>DACs</strong>) and <strong>Analog to Digital Converters</strong> (<strong>ADCs</strong>) are used when converting between continuously varying analog values and associated digital representations of that value. Most often, these types of on-board peripherals will be lower resolution and lower frequency than what you'll find with external chips. However, depending on the requirements of your system, they can be extremely useful. Another useful peripheral is on-board comparators, which will signal the processor when an analog value is above or below a given threshold.</p>
<p>Some more specialized devices (for example, Cypress PSoC) include fully reconfigurable analog peripherals (including op-amps, DACs, and ADCs) as well as flexible digital peripherals, flexibly integrating a very large feature set into a signal chip. Analog Devices and Maxim offer some of the more exotic mixed-signal MCUs, which tend to integrate application-specific components onto the same chip as the MCU, making development for a specific end product easier. You can find a very wide range of application-specific MCUs aimed at everything from industrial process control, automotive distance sensing, and IoT sensors to TV remote control applications. </p>
<p>If there is a popular use case for a mixed-signal problem, chances are, there is also a fully integrated piece of silicone that integrates an MCU with most of the required analog frontend available to solve most of the problem. The question then becomes one of balancing the BOM cost, detailed specifications, the size, development time, and long-term sourcing risk mitigation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dedicated touch interfaces</h1>
                </header>
            
            <article>
                
<p>Thanks to the increased prevalence of touch interfaces, full implementations of touch controllers are now included on some MCUs. This can greatly reduce the amount of expertise and effort required to have a fully functional and robust touch interface implementation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Display interfaces</h1>
                </header>
            
            <article>
                
<p>Generally found in higher performance devices with larger pin counts, sophisticated display interfaces and even graphics acceleration are becoming fairly common. Expect to find parallel LCD/TFT interfaces (for example, 6800 and 8080) on a large number of parts, with interfaces such as MIPI DSI capable of driving inexpensive, high-resolution displays to displays with only a few lines. Hardware protocol conversion ICs can be used to adapt to a number of different display standards, such as LVDS and HDMI. MCUs are now capable of delivering a rich user experience, with added hardware acceleration and efficiently written middleware and drivers. The CPU load is perfectly tolerable as well.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">External memory support</h1>
                </header>
            
            <article>
                
<p>In higher pin count packages, expect to find support for <strong>static random access memory</strong> (<strong>SRAM</strong>). <strong>Synchronous dynamic random access memory</strong> (<strong>SDRAM</strong>) support, with an on-board controller taking care of the tight timing requirements and refresh cycles, can be found in higher performance devices. Devices aimed at performance will generally bring in support for quad-SPI. Often, external RAM—and even quad-SPI devices—can be memory-mapped and used similar to internal storage, albeit with a performance hit. Many devices have <strong>MultiMediaCard</strong> (<strong>MMC</strong>) and <strong>secure digital card</strong> (<strong>SD card</strong>) controllers as well, so commodity consumer-grade removable storage is easily added.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Real-time clock</h1>
                </header>
            
            <article>
                
<p>Hardware calendars are available on some devices as well; all that is needed is a 32 kHz crystal and a back-up power source, such as a CR2032 primary lithium battery. Something that is also generally offered with this capability is a limited amount of battery backed-up RAM.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Audio support</h1>
                </header>
            
            <article>
                
<p>High-fidelity audio support through <strong>Inter-IC Sound</strong> (<strong>I<sup>2</sup>S</strong>) is commonly available. Expect to find DMA channels attached to the I<sup>2</sup>S peripheral to minimize the amount of CPU intervention required for feeding data-hungry DACs and collecting data from ADCs on these buses. </p>
<p class="mce-root">This concludes our long list of hardware peripherals to look out for when evaluating MCUs. Next up is a topic that will be of specific interest to anyone interested in designing battery-or energy-harvesting devices: power consumption.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Power consumption</h1>
                </header>
            
            <article>
                
<p>Lower-power MCUs have been the trend for well over a decade. However, what was historically a specialized use case with limited options (such as the 16-bit MSP430) has now become mainstream, thanks to the plethora of battery-powered, IoT-based devices coming onto the market. Now, full 32-bit MCUs are available, which can quickly cycle between low deep sleep and high-clockrate, data-crunching run modes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Power efficiency  </h1>
                </header>
            
            <article>
                
<p>It may sound simple, but a fairly good way of making sure something draws less power is to turn it off (don't laugh—this can be surprisingly complicated depending on the parts involved, thanks to various leakage currents!). If complex MCUs with dozens of peripherals have any hope of being power efficient, there needs to be a way to turn off whatever functionality isn't required to minimize wasted power. This is typically accomplished by shutting off clocks to peripherals that aren't in use and ensuring that CMOS-based I/O pins are not floating (remember, it's the transitions in CMOS devices that draw the most power).</p>
<p>Another spec that is commonly found in datasheets is how much power is consumed per MHz of CPU clock—generally specified in µA/MHz. If the amount of processing per wake-up period is fairly constant, this provides another metric to compare different MCU models.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Low-power modes</h1>
                </header>
            
            <article>
                
<p>Devices that are aimed at lower-power applications will typically have a few different levels of shutdown states to choose from. These states will allow the programmer to trade off between current consumption, available features (such as keeping RAM content intact and some peripherals on), the number of interrupts available to trigger a wake-up event, and the wake-up time. Thankfully, many lower-power IoT applications are fairly limited in their scope of operations, so sometimes a combination of novel features in a particular MCU will prove to be a very good fit for a specific application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Wake-up time</h1>
                </header>
            
            <article>
                
<p>If a device has an amazingly low shutdown current, but takes an abnormally long time to <em>wakeup</em> and get itself into a usable running state, it might not be the best choice for an application that requires fairly frequent wake-ups, since significant time will be spent getting the system up and running instead of getting it to perform the necessary processing and then going back to sleep.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Power supply voltage</h1>
                </header>
            
            <article>
                
<p>Lower power supply voltages will typically lead to lower current consumption. Depending on the design, trade-offs can be made between eliminating power conditioning circuitry (which consumes current due to less than 100% efficiency) and extending the usable operating voltage range of a given battery cell. The MCU's voltage requirement (as well as any ancillary circuitry) will be a driving factor for how much flexibility there is on the regulation side. Also, be aware that the maximum clock typically scales with supply voltage as well, so don't expect to be able to drive the CPU at the maximum specified frequency and lowest possible supply voltage. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Migrating MCUs mid-project</h1>
                </header>
            
            <article>
                
<p>Occasionally, 100% of the project requirements won't be known up front, or everyone might not be 100% confident about how exactly to solve every detailed problem on day 1. If you happen to be fortunate enough to know that there is a high level of uncertainty, then it is always better to plan for it, rather than be caught by surprise. Here are a few areas where selecting an MCU that's part of a larger family or ecosystem can help to mitigate some of the risks associated with project uncertainty. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Importance of pin compatibility</h1>
                </header>
            
            <article>
                
<p class="mce-root">When planning for a potential MCU shift, if possible, identify alternative MCUs that are pin-compatible ahead of time. For example, the NXP <span>LPC1850's parts are pin-compatible with LPC 4350 MCUs. STM32 devices are all pin-compatible within a family (and package) but will occasionally be <em>almost</em> pin-compatible with other families as well (STM32M4 and STM32M7, for example). ST regularly publishes migration guides for engineers that have <em>outgrown</em> one MCU family and need something a bit more capable. If a few likely candidates and alternatives are selected up front, some simple jumper populations on the PCB may facilitate migration between different MCUs with significantly different performance (and cost), helping to eliminate the time required for PCB reworking mid-project.  </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Peripheral similarity</h1>
                </header>
            
            <article>
                
<p class="mce-root">Most MCUs, within a given family, will inherit the same peripheral IP. Silicon vendors don't necessarily redesign peripherals from scratch every time they create a new MCU family, so there is often a significant amount of overlap in the register maps and behavior for peripherals belonging to a given vendor. Often, if your applications only use a subset of the most basic peripheral functions, to begin with, you might be lucky enough to use largely the same driver, even if the vendor decides to drastically change their API between MCU families. Ironically, sometimes, the raw hardware proves to be more consistent over time than the abstraction layers above it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The concept of an MCU family</h1>
                </header>
            
            <article>
                
<p>Many silicon vendors have concepts of device families, and <strong>STMicroelectronics</strong> (<strong>STM</strong>) is no exception—datasheets are typically written for entire families of devices. The most notable differences between devices in an STM family are typically RAM/ROM and the package size. However, additional peripherals are added to more capable devices as well—for example, larger packages will start to include parallel RAM controllers. Devices with more RAM/ROM will include more capable timer peripherals, more comm peripherals, or domain-specific peripherals, such as cryptographic modules.</p>
<p>Moving between devices in a given device family should be easy to do, so it is advisable to start on one end of the family (high is usually advisable) and see where the project goes. If scope creep was kept to a minimum, it may be possible to painlessly downgrade the MCU after all of the major features have been developed, saving some BOM cost.</p>
<p>That wraps up our list of considerations for the raw MCU. However, going out and buying a single chip and letting it sit on a desk won't do us much good for writing firmware. We need a way of powering the device, and communicating with it—we need a dev board!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Development board considerations</h1>
                </header>
            
            <article>
                
<p>A dev board is any piece of hardware that engineers use during the early development phase of a project. Dev boards aren't just for MCUs; they are useful for many different types of hardware—anything from op-amps to <strong>field-programmable gat arrays</strong> (<strong>FPGAs</strong>).</p>
<p>MCU dev boards should provide a few key functions:</p>
<ul>
<li>Ancillary circuitry, required to power and run the MCU</li>
<li>A way to program and communicate with the MCU</li>
<li>Connectors for easy connection to external circuitry</li>
<li>Possibly, some useful on-board ICs to exercise some of the peripherals</li>
</ul>
<p>There are many different routes that can be taken when it comes to evaluating MCUs. We're currently enjoying a period of time where hardware is inexpensive and commonly available. Because of this, there are a plethora of options to choose from for evaluating hardware. There are three major groupings that a piece of prototyping hardware tends to fall into, each of which has strengths and weaknesses. Of course, you can also roll your own dev board or prototype, if you have specific requirements.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What a development platform is and why it matters</h1>
                </header>
            
            <article>
                
<p>For our purposes, a development platform is an ecosystem of products that allows for a high degree of abstraction across multiple vendors. The primary focus of a platform is delivering large amounts of functionality with the smallest amount of effort possible, which is excellent when the main purpose is to create a prototype as quickly as possible. </p>
<p>In order to deliver large amounts of functionality across multiple vendors, standardized interfaces, ease of use, and flexibility tends to be emphasized. With these values, the platform itself is what the focal point is (as it should be) and individual differentiating features of particular devices tend to go largely unnoticed, that is, unless you're interested in coding them specifically, which takes additional time and ends up requiring you to put more focus into developing <em>for</em> the platform instead of <em>with</em> the platform.</p>
<p>Ecosystems develop around platforms, gently guiding platform users into tooling, workflows, least-common denominator feature sets, and available hardware. This is all well and good if the goal is to produce a proof-of-concept in the least amount of time possible. However, if a long-term development and production-worthy solution is to be found using the platform approach, the platform will likely need to be high quality, extremely well established, and stable. This generally means using platforms based on industrial standards available from multiple vendors (such as SMARC, QSeven, and COM Express), rather than the current "flavor of the year" in the maker space:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1119 image-border" src="assets/e8665d67-e955-4b25-971f-f2dd3d5542c3.png" style="width:32.17em;height:25.92em;"/></p>
<p>The bottom line is that a platform's interest is generally making the platform easy to use so that it gains further adoption. This accessibility can lead to common interfaces (as seen in the preceding diagram), which can be a boon to productivity during fast prototyping efforts but abstract away considerable differences in the underlying hardware. Often, platform-specific functionality is so important that the platform code will simply virtualize interfaces to make them more accessible, often at very significant costs (that is, bit-banging PWM or SPI so they can be assigned to specific predetermined pins). So, if you choose to use a platform to evaluate hardware (or specifically, an MCU), you should realize that you're likely evaluating the platform and its implementation on a given piece of hardware, rather than the hardware itself. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Evaluation kits</h1>
                </header>
            
            <article>
                
<p>An <strong>evaluation kit</strong> (<strong>eval kit</strong>) is at the other end of the spectrum when it comes to standardized footprints versus focus on the hardware itself. Eval kits are generally outfitted with the biggest, most feature-filled model of MCU available and are made with the sole intent of <em>showing off</em> that piece of hardware. This means they will generally not share a common footprint or connectors between different target MCUs (refer to the following diagram) because each MCU has different primary features and is targeted at a different market. Eval boards will have as many peripherals broken out to actual connectors as possible (such as serial, Ethernet, SD cards, a CAN bus, and multiple USBs). They also typically include a slew of peripheral hardware, such as RAM, eMMC, buttons, sliders, potentiometers, displays, and audio codecs to drive speakers. They will almost always break out all the interesting MCU pins to easily accessible headers, so developers are able to quickly try out any specific hardware configuration they can dream up. Manufacturers typically showcase their other non-MCU silicons on eval kit boards as well, in an effort to drive more sales in relation to their own products:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1637 image-border" src="assets/3bdbf332-8153-40e1-a3fc-8123197b4fbf.png" style="width:42.83em;height:27.25em;"/></p>
<p>To best demonstrate a device's capabilities, eval kits will also ship with a plethora of working example code that allows an engineer to interact with all of the peripherals included. Unlike the generalized implementations you'd generally find with a platform-based implementation, these examples are tailored to demonstrate the unique differentiating features of the target device to be evaluated. In the first part of this chapter, we discussed choosing hardware based on specific use cases. If you're seeking a specific solution to a challenging aspect of a design, the importance of having a guided example to working code that exemplifies the key differentiating aspects of an MCU can be a serious timesaver (and eye opener) compared to having to implement all of those features from scratch yourself.</p>
<p>All of this functionality comes at a cost—full-blown eval kits typically cost a few hundred dollars. However, if your goal is to quickly evaluate a potential MCU with a specific purpose in mind, they can quickly pay for themselves by saving engineering time and mitigating risk.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Low-cost demonstration boards</h1>
                </header>
            
            <article>
                
<p>Low-cost demonstration boards have really come into their own in recent years. Prices have come down significantly; manufacturers will occasionally sell demonstration boards for the same cost as the bare IC that sits on them (occasionally, they were actually <em>less</em> expensive than buying individual ICs!). Unlike hardware platforms, these boards will often have <em>similar </em>footprints, but not necessarily the same connectors or pinouts.</p>
<p>Recently, more low-cost demonstration boards <span>that blur the line between platforms and demonstration boards (also called demo boards) </span><span>have come to the market</span><span>. Thanks to the ubiquity of Arduino®, most low-cost boards will have </span><span>at least</span><span> </span><span>a set of Arduino headers that are pin-compatible. However, the availability of compatible headers and having a development board that fully embraces an ecosystem are very different things. The demo board may not have any software to accompany those headers; just because hardware exists and can be plugged into the board does not automatically mean you'll get compatible libraries for the target MCU to drive the hardware. This doesn't make them incompatible, but the amount of effort to get something up and running will be much greater than simply plugging a board in and following along with a "hello world" demo.</span></p>
<p>Some manufacturers are also creating their own standardized headers that are common between demo boards, which is at least helpful when migrating between different product families (but is obviously limited to that manufacturer). The ST Nucleo and NXP Freedom standardized headers are some examples. In an attempt to become more user-friendly, these boards will also typically feature mBed compatibility.</p>
<p>Now that you've been introduced to the different types of development boards, we'll take a more detailed look at a single manufacturer's microcontroller line—the STM32 line.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing the STM32 product line</h1>
                </header>
            
            <article>
                
<p>Over the past several years, STM has developed a fairly wide range of MCUs. Here, we'll discuss how a few of the major swaths of that portfolio fall into place relative to the considerations discussed in the <em>MCU considerations</em> section of this chapter . Most other vendors also arrange their products into major segments as well, which tends to make the selection process a bit easier.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Mainstream</h1>
                </header>
            
            <article>
                
<p>The STM32 line started with the STM32F1, a Cortex-M3-based MCU, back in 2007. This portion of the product line is meant to serve the majority of high volume applications, where cost and performance must be balanced, with minimally complex applications. The STM32F0 and the STM32G0 portions of the line are Cortex-M0- and Cortex-M0+-based devices that are aimed at low-cost applications. The original STM32F1 is Cortex-M3-based and has a very wide range of feature sets, but is starting to show its age when its performance is compared to other devices.</p>
<p>The STM32F3 was STM's first attempt at providing integrated, higher precision analog peripherals (other vendors offer higher precision analog components than STM); however, the line falls short of offering truly high-performance analog. It includes a 16-bit sigma delta ADC, but the <strong>effective number of bits</strong> (<strong>ENOB</strong>) is only stated to be 14 bits, which is slightly better than STM's 12-bit <strong>successive approximation</strong> (<strong>SAR</strong>) ADC peripherals, which are included most often. The newer Cortex-M4+-based STM32G4 family has the most analog peripherals available, including many instances of <strong>programmable gain op-amps</strong> (<strong>PGA</strong>), DACs, ADCs, and several comparators, but there are no integrated high-precision ADCs available at the time of writing.</p>
<p>Look out for the STM32G0 and STM32G4 families increasing the breadth of their offerings through 2020—they are both newer lines and STM will likely start filling these out with many more devices.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">High performance </h1>
                </header>
            
            <article>
                
<p>High-performance MCUs from STM started with the <span>Cortex-M4-based </span>STM32F4. The Cortex-M4 is very similar to the Cortex-M3, but it includes (optional) hardware 32-bit FPU and DSP instructions, which are both present on all STM3F4 devices. All of the devices in the high-performance line are capable of comfortably driving very attractive GUIs on controllerless displays, as long as the required RAM is available (usually external to the MCU). Acceleration provided by various hardware peripherals (such as MIPI <strong>Display Serial Interface</strong> (<strong>DSI</strong>), memory transfers via FMC and DMA, and some basic graphics acceleration using the <strong>Chrom-Adaptive Real-Time</strong> (<strong>Chrom-ART</strong>) accelerator) make it possible to off-load a fair amount of the effort involved with communicating with the display to various peripherals so that the CPU can spend time performing other tasks.</p>
<p>Here's a quick breakdown of the two major members of the family and some notable features:</p>
<table style="border-collapse: collapse" border="1">
<tbody>
<tr>
<td style="width: 12%">
<p><strong>MCU line</strong></p>
</td>
<td style="width: 26.599%">
<p><strong>CPU</strong></p>
</td>
<td style="width: 55.401%">
<p><strong>Features</strong></p>
</td>
</tr>
<tr>
<td style="width: 12%">
<p>STM32H7</p>
</td>
<td style="width: 26.599%">
<p class="mce-root">Cortex-M7 (480 MHz)</p>
<p>Cortex-M4 (240 MHz) (opt)</p>
</td>
<td style="width: 55.401%">
<p>Highest performance MCU from STM</p>
<p>64-bit FPU and extended DSP instructions</p>
</td>
</tr>
<tr>
<td style="width: 12%">
<p>STM32F7</p>
</td>
<td style="width: 26.599%">
<p>Cortex-M7 (216 MHz)</p>
</td>
<td style="width: 55.401%">
<p><span>64-bit FPU and extended DSP instructions</span></p>
</td>
</tr>
<tr>
<td style="width: 12%">
<p>STM32F2</p>
</td>
<td style="width: 26.599%">
<p>Cortex-M3</p>
</td>
<td style="width: 55.401%">
<p>Offers trade-off for performance versus cost</p>
<p>High level of integration (camera interface and USB OTG)</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>This class of MCU can be thought of as <em>crossover</em> MCUs. They are powerful enough that they can be used for some application tasks that were traditionally reserved for full-blown CPUs, but they still have the ease of use of an MCU.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The heterogeneous multi-core approach</h1>
                </header>
            
            <article>
                
<p>In 2019, STM launched the STM32MP line, which was the company's first entry into the application processor space. This family offers a single or dual-core Cortex-A7 at 650 MHz, along with a single Cortex-M4 running at 209 MHz. STM appears to be targeting the high-volume, low-cost portion of the market with these solutions by focusing on a lower core count and packages that require fewer PCB layers using less expensive fabrication techniques.</p>
<p>From a software perspective, the main difference between STM's MCU offerings and the new <strong><span>micro-processor unit</span></strong><span> (</span><strong><span>MPU</span></strong><span>) is that since the MPUs have</span> <strong>memory management units</strong> <span>(</span><strong>MMUs</strong><span>), they are capable of running a</span> <em>full OS</em> <span>via mainline Linux kernels, which opens up an entirely different ecosystem of open source software (that you don't personally need to write).</span></p>
<p>The heterogeneous multi-core approach allows designers to split up portions of a design and solve them in the domain that they are best suited to. For example, a dedicated process controller with a GUI and networking capability could use the Cortex-A7 to leverage Linux and gain access to the Qt framework and complex networking stacks, while using the Cortex-M4 for all of the real-time control aspects.</p>
<div class="packt_infobox">Implementations of <span>μ</span>Clinux have been available for the STM32F4 and STM32F7 MCUs for years, but because of the lack of MMU on these devices, there is typically a pretty hefty performance penalty.</div>
<p>Of course, with additional capability comes additional complexity. Unlike MCUs, there's no way to get around integrating external RAM with the STM32MP line, so be prepared for some fairly involved PCB layout (compared to a stand-alone MCU solution).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Low power</h1>
                </header>
            
            <article>
                
<p>STM's low power line is squarely aimed at battery-powered devices. Here's a quick comparison between all of the different family members:</p>
<table style="border-collapse: collapse" border="1">
<tbody>
<tr>
<td style="width: 30.0496%">
<p><strong>MCU version</strong></p>
</td>
<td style="width: 15.9504%">
<p><strong>CPU</strong></p>
</td>
<td style="width: 132%">
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td style="width: 30.0496%">
<p><span>STM32L</span></p>
</td>
<td style="width: 15.9504%">
<p><span>Cortex-M0</span></p>
</td>
<td style="width: 132%">
<p><span>Lowest performance and RAM and ROM space of the family, but offers fairly good efficiency.</span></p>
</td>
</tr>
<tr>
<td style="width: 30.0496%">
<p><span>STM32L1</span></p>
</td>
<td style="width: 15.9504%">
<p>Cortex-M3</p>
</td>
<td style="width: 132%">
<p><span>Higher ROM capacity and offers faster performance with the trade-off of increased power consumption.</span></p>
</td>
</tr>
<tr>
<td style="width: 30.0496%">
<p><span>STM32L4 and STM32L4+</span></p>
</td>
<td style="width: 15.9504%">
<p>Cortex-M4</p>
</td>
<td style="width: 132%">
<p><span>Have increased number-crunching capability (the STM32L4+ also offers faster clock speeds and larger internal flash storage).</span></p>
</td>
</tr>
<tr>
<td style="width: 30.0496%">
<p><span>STM32L5</span></p>
</td>
<td style="width: 15.9504%">
<p>Cortex-M33</p>
</td>
<td style="width: 132%">
<p><span>Blends performance and power and incorporates the latest ARM v8 architecture. Cortex-M33 offers additional security features, such as Trust.Zone, and executes instructions more efficiently than Cortex-M4, which allows for some additional performance while still keeping power consumption in check.</span></p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Depending on the exact workload of a given IoT application, it may make sense to use a low-power 32-bit MCU, such as the ones in the preceding table. However, for very simple applications, low-power 8- and 16-bit MCUs should also be considered.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Wireless</h1>
                </header>
            
            <article>
                
<p><span>The STM32WB implements a</span> Cortex-M4 with a dedicated Cortex-M0+ to run a Bluetooth BLE stack. This line provides a lot of integration, from large flash memory and RAM to mixed-signal analog peripherals, including touch sensors and small segment LCDs. Various security features, such as crypto algorithms and a random number generator, are also present. Since FCC certification is required for products using this family of devices, they will make the most sense for high volume applications.</p>
<p>With a wide range of MCUs to choose from, STM <em>probably</em> has something we can use to experiment with an RTOS! It's time to move on to selecting a development board to use.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How our development board was selected</h1>
                </header>
            
            <article>
                
<p>Now that we've covered the important considerations for MCU selection and the general types of development hardware, let's see how the development board that will be used in this book was selected. STM is the only manufacturer that we are evaluating in order to limit the examples to something easily digestible. In an actual product engineering effort, it behooves the designer to take a fresh look at all possible vendors. While everybody has their own preferred way of accomplishing cross-vendor searches, an easy way is to use distributor websites.</p>
<p>Thanks to well-curated prototyping-oriented distributor websites (such as Digikey and Mouser), an engineer is able to perform parametric searches and comparisons across many different vendors. One downside to this approach is the searches are limited to whatever product lines that specific distributor carries. Another potential downside is that the parametric search results are at the mercy of the distributor's data entry accuracy and categorization. The upsides to using a distributor website directly are that many different vendors are all in one spot, product availability can be checked immediately, and semi-real-world pricing is easily seen and filtered.</p>
<div class="packt_infobox">Pricing from prototyping-oriented distributors is considered <em>semi-real-world</em> because oftentimes, after a product goes into full production it is generally more economical to use a quantity-oriented distributor or go directly to the vendor for high volumes.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Requirements</h1>
                </header>
            
            <article>
                
<p>Up to this point, we've covered all of the considerations that go into selecting an MCU for a project at a theoretical level. Now, it's time to put all of that into action and select the MCU that will be used for all of the actual <em>hands-on</em> exercises. A few things to keep in mind are as follows:</p>
<ul>
<li>We'll be selecting a dev board<span> </span><em>and</em><span> </span>MCU—therefore, some of the requirements will be aimed at the dev board, which generally isn't a good idea if you're making a product that needs to go into long-term production.</li>
<li>Requirements are going to be specific to this book—the requirements that make something a good choice for a book probably don't translate to the project you're working on. Obviously, your selection criteria will be tailored to your project.</li>
</ul>
<p>The must-haves—that is, the <em>requirements—</em> are as follows:</p>
<ul>
<li>The target MCU on your dev board will be an STM32 Cortex-M-based CPU.</li>
<li>The target MCU must have a <strong>memory protection unit</strong> (<strong>MPU</strong>).</li>
<li>The dev board must have a visible means of displaying status.</li>
<li>A relatively low cost (such as &lt; USD 50). </li>
</ul>
<p>The nice-to-haves—that is, the <em>desirements</em> needed—are as follows:</p>
<ul>
<li>Versatility: It would be nice if the dev board could be used with other hardware.</li>
<li>Virtual communication over USB available as a debug port.</li>
<li>Multiple cores.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Requirements justification</h1>
                </header>
            
            <article>
                
<p>We're going to be limiting our search to STM32 parts since that's the example family we're using throughout this book. In <a href="0f98e454-9804-4589-9854-5c38c9d8d416.xhtml">Chapter 15</a>, <em>FreeRTOS Memory Management</em> we'll be covering how to prevent tasks from accessing memory they shouldn't, which will require us to make use of a part with a memory protection unit. One of the goals of this book is to keep hardware interaction as accessible as possible, which leads to the next two requirements: status display and cost. </p>
<p>Some means of displaying <em>status</em> will likely translate into a simple LED (ideally multiple). There should be some form of feedback for the programmer to be able to see what's going on at a glance in order to ensure the code is actually doing something. In a real embedded environment, this would likely take the form of additional instrumentation, such as oscilloscopes, logic analyzers, and DMMs. In the spirit of keeping this accessible for as many people as possible, we'll be explicitly avoiding those tools. So, rather than relying on external tools and the debugger alone, we're going to be on the lookout for on-board indicators.</p>
<p>The nice-to-haves aren't hard requirements, but they are desirable qualities the system would possess in a perfect world. Ideally, the target dev board would also be part of a larger hardware ecosystem, which would enable people to use existing hardware they might already have to further explore the concepts in this book. A USB port attached to the target MCU would also be great to have—that way, we would be able to use a virtual comm port to output debug instead of using only the debugger. Finally, in <a href="19872ca7-d0fe-44e7-a4fc-1bdbfda87e59.xhtml">Chapter 16</a>,<em> Multi-Processor and Multi-Core Systems</em>, we will look at a brief introduction and a few tips on developing our board with multiple CPUs. Although this topic is deserving of its own book (many have already been written from an architectural perspective), it would be nice to have some code that we could put into action on actual hardware.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Choosing the dev board</h1>
                </header>
            
            <article>
                
<p>Alright—we now know what we're looking for, so let's get started! As mentioned before, distributor websites can be a great place to start because they offer excellent parametric search capabilities. If you're a hardware person, using the same search engine will reduce the amount of time spent hunting for parts. Of course, this approach isn't perfect, so if there's a really specific part you're looking for, you might be better off going directly to your favourite manufacturer's site and searching there instead:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1121 image-border" src="assets/8fe693bd-e9ad-4345-93f0-a825f36f5bf7.png" style="width:38.75em;height:31.17em;"/></p>
<p>Here's an example of the steps we've used to narrow down our search using a popular distributor in the United States, DigiKey:</p>
<ol>
<li>From DigiKey's home page, <a href="https://www.digikey.com/">https://www.digikey.com/</a>, we've started with a search for STM32 and selected eval boards for the MCUs and DSPs from the selections.</li>
<li>We're only interested in parts that are currently available (not obsolete).</li>
<li>The dev kit must also be in stock.</li>
</ol>
<p>Here are the results:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1122 image-border" src="assets/fb4cf50a-5fca-4f68-8721-dd1c90cdc286.png" style="width:28.00em;height:20.08em;"/></p>
<p>From our knowledge of the STM32 product line, the MCUs with memory protection units have been selected. Currently, this criteria provides 73 available dev platforms, ranging from <span>USD </span><span>9-550—quite a range. We have most of the hard requirements covered already—with the exception of the on-board indicator, which isn't likely to show up in a search. Let's see if we can't narrow the field a bit more by including some of the</span> <em>desirements</em> <span>as well.</span></p>
<div class="packt_infobox">STM refers to their micro-processors as <span>micro-processor units</span><span> (</span><span>MPU</span><span>)</span><span>, which has created an overloaded term and some ambiguity when also talking about memory protection units (MPU). You'll likely run into both uses of this acronym when browsing websites and documentation.</span></div>
<p>If we're looking for multiple cores, then the STM32H7 and STM32MP1 lines are valid options. It turns out there are discovery boards with these parts available at a relatively reasonable cost<span> </span><span>(for what they include)</span><span> of </span><span>USD </span><span>80, but we're ideally looking for hardware closer to the </span><span>USD </span><span>20 range—let's not let the desirements interfere with the hard requirements!</span></p>
<p>Narrowing the focus to only the processors that don't violate the pricing requirement of &lt; <span>USD </span><span>50 leads us to the STM </span><span>Nucleo line of dev boards. All of the Nucleo line is mBed- compatible, which will allow the use of that entire ecosystem, should we choose to use it. The other realization that STM had with Nucleo was it was a good idea to support existing popular platforms—so, in addition to breaking out nearly all of the more relevant MCU pins on a proprietary header, Nucleo boards also provide various Arduino-style headers. All Nucleo boards also include an ST-Link on-board programmer, some of which can be re-flashed to appear identical to a SEGGER J-Link </span><span>, which is a <em>huge</em> plus and will eliminate the need to purchase an additional piece of hardware:</span></p>
<table style="border-collapse: collapse" border="1">
<tbody>
<tr>
<td style="width: 17%">
<p><strong><span>Manufacturer </span></strong><strong>part number</strong></p>
</td>
<td style="width: 25.4089%">
<p><strong>Description</strong></p>
</td>
<td style="width: 52.5911%">
<p><strong>Relevant features</strong></p>
</td>
</tr>
<tr>
<td style="width: 17%">
<p>NUCLEO-L432KC</p>
</td>
<td style="width: 25.4089%">
<p>Nucl32 platform</p>
</td>
<td style="width: 52.5911%">
<p>Cortex-M4, one user LED, user USB, Arduino Nano v3 compatible, NOT listed as SEGGER J-Link on-board compatible</p>
</td>
</tr>
<tr>
<td style="width: 17%">
<p>NUCLEO-F401RE</p>
</td>
<td style="width: 25.4089%">
<p>Nucleo64 platform </p>
</td>
<td style="width: 52.5911%">
<p>Cortex-M4, one user LED, user USB via re-enumeration, Arduino Uno v3 headers, <span>SEGGER J-Link on-board compatible</span></p>
</td>
</tr>
<tr>
<td style="width: 17%">
<p>NUCLEO-L4R5ZI</p>
</td>
<td style="width: 25.4089%">
<p>Nucleo144 platform</p>
</td>
<td style="width: 52.5911%">
<p>Cortex-M4, three user LEDs, a dedicated user USB OTB, ST Morpho, <span>Arduino Uno v3 headers, SEGGER J-Link on-board compatible</span></p>
</td>
</tr>
<tr>
<td style="width: 17%">
<p><strong>NUCLEO-F767ZI</strong></p>
</td>
<td style="width: 25.4089%">
<p><strong><span>Nucleo144 platform</span></strong></p>
</td>
<td style="width: 52.5911%">
<p><strong><span>Cortex-M7, three user LEDs, a dedicated user USB, Ethernet, </span><span>Arduino Uno v3 headers, SEGGER J-Link on-board compatible</span></strong></p>
</td>
</tr>
</tbody>
</table>
<p>Our target platform will be the Nucleo-F767ZI, which incorporates the widest range of connectivity and includes the most flexibility for debugging. We'll cover re-flashing the on-board ST-Link to use SEGGER J-Link firmware in <a href="699daa80-06ae-4acc-8b93-a81af2eb774b.xhtml">Chapter 6</a>, <em>Debugging Tools for Real-Time Systems</em>. The three user LEDs will make communicating firmware status feedback very simple since no additional interfaces will need to be configured. Built-in Ethernet allows the development of networked applications. It would have been convenient to have a multi-core MCU for our target platform, but none were available that met our cost requirement:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1500 image-border" src="assets/dd45871d-0ac9-4599-afcd-f8e59b5e855b.png" style="width:21.33em;height:40.08em;"/></p>
<p>Although there are many options when selecting an MCU or development board, it doesn't need to be a daunting process, especially when you know your requirements and the trade-offs to be made.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>This chapter has touched on many considerations for selecting an appropriate MCU and we've explained the selection process by going through the trade-offs made when selecting the dev board used in this book. You should now understand the importance of MCU selection and have enough background to begin researching and selecting MCUs for your projects. If you're part of a multi-disciplinary team, you'll be better positioned to converse with your peers on the trade-offs of using various MCUs for a given application.</p>
<p>In the next chapter, we'll go through a similar exercise, comparing various classes of <strong>Integrated Development Environments</strong> (<strong>IDEs</strong>) and choose a suitable IDE to code the exercises you'll find in this book, starting with <a href="2fa909fe-91a6-48c1-8802-8aa767100b8f.xhtml">Chapter 7</a>, <em>The FreeRTOS Scheduler</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<p>As we conclude, here is a list of questions for you to test your knowledge regarding this chapter's material. You will find the answers in the <em>Assessments</em> section of the Appendix:</p>
<ol>
<li>Why is it important for firmware engineers to be knowledgeable about the MCU they are programming on?</li>
<li>When selecting an MCU for performance, clock speed is the only factor at play:
<ul>
<li>True </li>
<li>False</li>
</ul>
</li>
<li>Today's MCUs contain many different pieces of hardware in addition to the CPU. What is the general name given to these pieces of hardware?
<ul>
<li>Batteries</li>
<li>Hardware peripherals</li>
<li>Bugs</li>
</ul>
</li>
<li>Name one advantage of using a <em>platform</em> approach for development.</li>
<li>Name one advantage of using a fully featured evaluation board for development.</li>
<li><span>Name two significant device characteristics when designing low-power applications</span>.</li>
<li>Why was an inexpensive development board chosen for this book?</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li>AN4839: An STM application note regarding the level 1 cache system on STM32F7 devices: <span><a href="https://www.st.com/content/ccc/resource/technical/document/application_note/group0/08/dd/25/9c/4d/83/43/12/DM00272913/files/DM00272913.pdf/jcr:content/translations/en.DM00272913.pdf"><span>https://www.st.com/content/ccc/resource/technical/document/application_note/group0/08/dd/25/9c/4d/83/43/12/DM00272913/files/DM00272913.pdf/jcr:content/translations/en.DM00272913.pdf</span></a></span></li>
<li>More information regarding SEGGER ST-Link on-board: <a href="https://www.segger.com/products/debug-probes/j-link/models/other-j-links/st-link-on-board/">https://www.segger.com/products/debug-probes/j-link/models/other-j-links/st-link-on-board/</a></li>
</ul>


            </article>

            
        </section>
    </body></html>