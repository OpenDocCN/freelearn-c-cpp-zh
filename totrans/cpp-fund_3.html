<html><head></head><body>
		<div class="Content" id="_idContainer028">
			<h1 id="_idParaDest-78"><em class="italics"><a id="_idTextAnchor085"/>Chapter 3</em></h1>
		</div>
		<div class="Content" id="_idContainer029">
			<h1 id="_idParaDest-79"><a id="_idTextAnchor086"/>Classes</h1>
		</div>
		<div class="Content" id="_idContainer030">
			<h2>Lesson Objectives</h2>
			<p>By the end of this chapter, you will be able to:</p>
			<ul>
				<li class="bullets">Declare and define a class</li>
				<li class="bullets">Access the members of a class using objects</li>
				<li class="bullets">Apply access modifiers to encapsulate data</li>
				<li class="bullets">Use the static modifier on data members and member functions</li>
				<li class="bullets">Implement a nested class</li>
				<li class="bullets">Utilize the friend specifier to access private and protected members</li>
				<li class="bullets">Use constructors, copy constructors, assignment operators, and destructors</li>
				<li class="bullets">Overload operators </li>
				<li class="bullets">Implement functors</li>
			</ul>
			<p>In this chapter, we will be learning about classes and objects in C++.</p>
		</div>
		<div class="Content" id="_idContainer036">
			<h2 id="_idParaDest-80">Introduction<a id="_idTextAnchor087"/></h2>
			<p>In the previous chapter, we saw how we can use functions to combine basic operations into units with a clear meaning. Additionally, in the first chapter, we saw how, in C++, we can store data in basic types, such as integers, chars, and floats.</p>
			<p>In this chapter, we will be covering how to define and declare classes and how to access member functions of a class. We will explore what <strong class="inline">member</strong> and <strong class="inline">friend</strong> functions are and how to use each in a program. Later in the chapter, we will look at how constructors and destructors work. At the end of the chapter, we will explore functors and how you can use them in your programs.</p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor088"/>Declaring and Defining a Class</h2>
			<p>A <strong class="keyword">class</strong> is a way to combine data and operations together to create new types that can be used to represent complex concepts.</p>
			<p>Basic types can be composed to create more meaningful abstractions. For example, <em class="italics">location data</em> is composed of latitude and longitude coordinates, which are represented as <strong class="inline">float</strong> values. With such a representation, when our code needs to operate on a location, we would have to provide both the latitude and longitude as separate variables. This is error-prone, as we might forget to pass one of the two variables, or we could provide them in the wrong order.</p>
			<p>Additionally, computing the distance between two coordinates is a complex task and we don't want to write the same code again and again. It becomes even more difficult when we use more complex objects.</p>
			<p>Continuing our example on Coordinates, instead of using operations on two <strong class="inline">float</strong> types, we can define a type, which stores the location and provides the necessary operations to interact with it.</p>
			<h3 id="_idParaDest-82"><a id="_idTextAnchor089"/>The Advantages of Using Classes</h3>
			<p>Classes provide several benefits, such as abstraction, information hiding, and encapsulation. Let's explore each of these in depth:</p>
			<ul>
				<li><strong class="keyword">Abstraction</strong>: This allows us to represent a high-level concept. In our previous example with GPS coordinates, we can see that, without classes we need to use two <strong class="inline">float</strong> variables, but this does not represent the concept that we want to use. The programmer needs to remember that the two variables have a different meaning and should be used together. Classes allow us to explicitly define a concept, composed by data and operations on that data, and assign a <em class="italics">name</em> to it.<p>In our example, we can create a class to represent GPS coordinates. The data will be the two <strong class="inline">float</strong> variables to describe <strong class="bold">latitude</strong> and <strong class="bold">longitude</strong>. </p><p>Examples of operations could be ways to compute distances between coordinates, or to check whether a coordinate is inside a specific state. The programmer will directly operate on the class and will not have to interact with the two <strong class="inline">float</strong> variables that are used to represent it.</p></li>
				<li><strong class="keyword">Information hiding</strong>: The process of exposing a set of functionalities to the user of the class while hiding the details of how they are implemented in the class.<p>This approach reduces the complexity of interacting with the class and makes it easier to update the class implementation in the future:</p></li>
			</ul>
			<div>
				<div class="IMG---Figure" id="_idContainer031">
					<img alt="Figure 2.1: The class exposes functionality that the user code uses directly, hiding the fact that it is implemented with two floats" src="image/Image70122.jpg"/>
				</div>
			</div>
			<h6>Figure 2.1: The class exposes functionality that the user code uses directly, hiding the fact that it is implemented with two floats</h6>
			<p>We discussed the fact that we can represent GPS coordinates as latitude and longitude. Later, we might decide to represent a coordinate as the distance from the <strong class="bold">North Pole</strong>. Thanks to information hiding, we can change how a class is implemented and the users of the class will not be impacted, since we do not change the functionality offered by the class:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer032">
					<img alt="Figure 2.2: The implementation of the class changes, but since it is hidden from the user and the functionality was not changed, the user does not have to change how their code interacts with the class" src="image/Image70130.jpg"/>
				</div>
			</div>
			<h6>Figure 2.2: The implementation of the class changes, but since it is hidden from the user and the functionality was not changed, the user does not have to change how their code interacts with it</h6>
			<p>The set of functionalities the class exposes to the users is normally referred to as the <strong class="keyword">public interface</strong>.</p>
			<h4>Note</h4>
			<p class="callout">Changing the implementation of a class is generally more convenient than to changing the interface of a class, which requires you to change all the users of the class to adapt to the new interface. Getting the design of the public interface of a class right is the first step to creating a class that is easy to use and requires low maintenance.</p>
			<ul>
				<li><strong class="keyword">Encapsulation</strong>: This is the principle of grouping the data and the operations we can perform on it together. Since the data is hidden in the class, the user cannot access or operate on it. The class must provide functionality to interact with it. C++ enables encapsulation by letting the user put the operations to interact with a class and the data that is used to implement such operations in the same unit: <strong class="keyword">class</strong>.</li>
			</ul>
			<p>Let's explore the structure of a class in C++ and the information associated with it. The following is the basic structure of a class:</p>
			<p class="snippet">class ClassName { </p>
			<p class="snippet">  // class body</p>
			<p class="snippet">};</p>
			<h4>Note</h4>
			<p class="callout">It is common to forget the last <strong class="inline">semicolon</strong> after closing curly brackets. Always make sure that you add it.</p>
			<h3 id="_idParaDest-83"><a id="_idTextAnchor090"/>C++ Data Members and Access Specifiers</h3>
			<p>Inside the body of a class, we can define the following class members:</p>
			<ul>
				<li><strong class="keyword">Data members</strong>: These are variables that live inside a class, which look like a <strong class="bold">variable declaration</strong>, but are inside the class body. They are also called <strong class="bold">fields</strong>.</li>
				<li><strong class="keyword">Member functions</strong>: These are functions that can access the variables inside a class. They look like a <strong class="bold">function declaration</strong> but are inside the class body. They are also called <strong class="bold">methods</strong>.</li>
			</ul>
			<p>As we mentioned before, classes support information hiding by denying users of the class to access information. The programmer uses <strong class="keyword">access specifiers</strong> to specify which parts of the class are available for the user to be accessed.</p>
			<p>There are the following three access specifiers in C++:</p>
			<ul>
				<li><strong class="keyword">Private</strong>: Members declared as <strong class="inline">private</strong> can only be accessed by the functions inside the class and are not allowed to be accessed directly outside the class</li>
				<li><strong class="keyword">Protected</strong>: Members declared as <strong class="inline">protected</strong> can only be accessed by the functions inside the class and the derived classes. We will learn more about in the last chapter of this book</li>
				<li><strong class="keyword">Public</strong>: Members declared as <strong class="inline">public</strong> can be accessed from anywhere in the program</li>
			</ul>
			<p>Access specifiers followed by a colon delimit an area in the class, and any member defined in that area has the access specifier that precedes it. Here's the syntax:</p>
			<p class="snippet">class ClassName {</p>
			<p class="snippet">  private:</p>
			<p class="snippet">    int privateDataMember;</p>
			<p class="snippet">    int privateMemberFunction();</p>
			<p class="snippet">  protected:</p>
			<p class="snippet">    float protectedDataMember;</p>
			<p class="snippet">    float protectedMemberFunction();</p>
			<p class="snippet">  public:</p>
			<p class="snippet">    double publicDataMember;</p>
			<p class="snippet">    double publicMemberFunction();</p>
			<p class="snippet">};</p>
			<h4>Note</h4>
			<p class="callout">By default, class members have the <strong class="inline">private</strong> access modifier.</p>
			<p>In C++, we can also use the <strong class="inline">struct</strong> keyword to define a class. A <strong class="inline">struct</strong> is identical to a class, with the only exception that, by default, the access modifier is <strong class="inline">public</strong>, while for the class it is <strong class="inline">private</strong>.</p>
			<p>The following side-by-side code snippets are equivalent:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer033">
					<img alt="" src="image/C11557_03_03.jpg"/>
				</div>
			</div>
			<h6>Figure 3.2: The difference between the code snippets of class and struct</h6>
			<p>Whether to use <strong class="inline">struct</strong> or <strong class="inline">class</strong> depends on convention used: usually, we use <strong class="inline">structs</strong> when we want a collection of data members that should be accessible from anywhere in the code; on the other hand, we use classes when we are modelling a more complex concept.</p>
			<p>We have learned how to define a class. Now, let's understand how to use one in a program.</p>
			<p>A class defines a blueprint or the design of an object. Like a blueprint, we can create multiple objects from the same class. These objects are called <strong class="keyword">instances</strong>.</p>
			<p>We can create an instance in the same way that we create any basic type: define the type of the variable followed by the name of the variable. Let's explore the following example.</p>
			<p class="snippet">class Coordinates {</p>
			<p class="snippet">  public:</p>
			<p class="snippet">    float latitude;</p>
			<p class="snippet">    float longitude;</p>
			<p class="snippet">    float distance(const Coordinates&amp; other_coordinate);</p>
			<p class="snippet">};</p>
			<p>Here's an example that shows a class that has multiple instances:</p>
			<p class="snippet">Coordinates newYorkPosition;</p>
			<p class="snippet">Coordinates tokyoPosition;</p>
			<p>Here, we have two instances of the <strong class="inline">Coordinates</strong> class, each with their <strong class="inline">latitude</strong> and <strong class="inline">longitude</strong>, which can change independently. Once we have an instance, we can access its members.</p>
			<p>When we declare a class, we create a new scope called the <strong class="keyword">class scope</strong>. The names defined inside the class scope are accessible only inside the same class scope. The operator for accessing members of a <strong class="inline">class</strong> or a <strong class="inline">struct</strong> from a scope outside the class is the dot (<strong class="inline">.</strong>) operator.</p>
			<p>For the previously defined variables, we can access their <strong class="inline">latitude</strong> using the following code:</p>
			<p class="snippet">float newYorkLatitude = newYorkPosition.latitude;</p>
			<p>If we want to call a member function instead, we can invoke it like this:</p>
			<p class="snippet">float distance = newYorkPosition.distance(tokyoPosition);</p>
			<p>On the other hand, when we are writing the body of a <strong class="inline">class</strong> method, we are inside the class's scope. This means that we can access the other members of the class by using their names directly, without having to use the <em class="italics">dot</em> operator. The members of the current instance are going to be used.</p>
			<p>Let's assume that the <strong class="inline">distance</strong> method is implemented as follows:</p>
			<p class="snippet">float Coordinates::distance(const Coordinates&amp; other_coordinate) {</p>
			<p class="snippet">  return pythagorean_distance(latitude, longitude, other_coodinate.latitude, other_coordinate.longitude);</p>
			<p class="snippet">}</p>
			<p><a id="_idTextAnchor091"/>When we call <strong class="inline">newYorkPosition.distance(tokyoPosition);</strong>, the <strong class="inline">distance</strong> method is called on the <strong class="inline">newYorkPosition</strong> instance. This means that <strong class="inline">latitude</strong> and <strong class="inline">longitude</strong> in the <strong class="inline">distance</strong> method refer to <strong class="inline">newYorkPosition.latitude</strong> and <strong class="inline">newYorkPosition.longitude</strong>, while <strong class="inline">other_coordinate.latitude</strong> refers to <strong class="inline">tokyoPosition.latitude</strong>.</p>
			<p>If we had called <strong class="inline">tokyoPosition.distance(newYorkPosition);</strong> instead, the current instance would have been <strong class="inline">tokyoPosition</strong>, and <strong class="inline">latitude</strong> and <strong class="inline">longitude</strong> would have referred to the <strong class="inline">tokyoPosition</strong>, and <strong class="inline">other_coordinate</strong> to <strong class="inline">newYorkPosition</strong>.</p>
			<h3 id="_idParaDest-84"><a id="_idTextAnchor092"/>Static Members</h3>
			<p>In the previous section, we learned that a class defines the fields and methods that compose an object. It is like a blueprint, specifying what the object looks like, but it does not actually build it. <em class="italics">An instance is the object that's built from the blueprint that's defined by the class</em>. Instances contain data and we can operate on instances.</p>
			<p>Imagine the blueprint of a car. It specifies the engine of the car and that the car will have four wheels. The blueprint is the class of the car, but we cannot turn on and drive a blueprint. A car that's built by following the blueprint is an instance of the class. The built car has four wheels and an engine, and we can drive it. In the same way, an instance of a class contains the fields that are specified by the class.</p>
			<p>This means that the value of each field is connected to a specific instance of a class and evolves independently from the fields of all the other instances. At the same time, it also means that a field cannot exist without the associated instance: there would be no object that would be able to provide the storage (the space in memory) to store the value of the field!</p>
			<p>However, sometimes, we want to share the same value across all instances. In those cases, we can associate the field with the class instead of the instance by creating a <strong class="inline">static</strong> field. Let's examine the following syntax:</p>
			<p class="snippet">class ClassName {</p>
			<p class="snippet">  static Type memberName;</p>
			<p class="snippet">};</p>
			<p>There will be only one <strong class="inline">memberName</strong> field, which is shared across all instances. Like any variable in C++, <strong class="inline">memberName</strong> needs to be stored in memory. We cannot use the storage of the instance object, since <strong class="inline">memberName</strong> is not associated with any specific instance. <strong class="inline">memberName</strong> is stored in a similar way to a <em class="italics">global variable</em>.</p>
			<p>Outside of the class in which the static variable is declared, in a <strong class="inline">.cpp</strong> file, we can define the value of the <strong class="inline">static</strong> variable. The syntax to initialize the value is as follows:</p>
			<p class="snippet">Type ClassName::memberName = value;</p>
			<h4>Note</h4>
			<p class="callout">Note that we do not repeat the <strong class="inline">static</strong> keyword.</p>
			<p class="callout">It is important to define the values of the <strong class="inline">static</strong> variables in the <strong class="inline">.cpp</strong> file. If we define them inside the <strong class="bold">header</strong> file, the definition will be included anywhere inside the header, which will create multiple definitions, and the <strong class="bold">linker</strong> will complain.</p>
			<p>A class static variable's lifetime lasts for the complete duration of the program, like global variables.</p>
			<p>Let's see an example of how a static field in a class can be defined in the header and how to assign a value to it in the <strong class="inline">.cpp</strong> file:</p>
			<p class="snippet">// In the .h file</p>
			<p class="snippet">class Coordinates {</p>
			<p class="snippet">  // Data member</p>
			<p class="snippet">  float latitude_ = 0;</p>
			<p class="snippet">  // Data member</p>
			<p class="snippet">  float longitude_ = 0; </p>
			<p class="snippet">public:</p>
			<p class="snippet">  // Static data member declaration</p>
			<p class="snippet">  static const Coordinates hearthCenter;</p>
			<p class="snippet">  // Member function declaration</p>
			<p class="snippet">  float distanceFrom(Coordinates other);</p>
			<p class="snippet">  // Member function definition</p>
			<p class="snippet">  float distanceFromCenter() {</p>
			<p class="snippet">    return distanceFrom(hearthCenter);</p>
			<p class="snippet">  }</p>
			<p class="snippet">};</p>
			<p class="snippet">// In the .cpp file </p>
			<p class="snippet">// Static data member definition</p>
			<p class="snippet">const Coordinates Coordinates::hearthCenter = Coordinates(0, 0);</p>
			<p>When accessing the members of an instance, we learned to use the dot operator.</p>
			<p>When accessing a static member, we might not have an instance to use the dot operator on. C++ gives us the ability to access the static members of a class by using the <strong class="bold">scope resolution operator</strong>, which is, a double colon (<strong class="inline">::</strong>), after the class name.</p>
			<h4>Note</h4>
			<p class="callout">Always use <strong class="inline">const</strong> when declaring a static field. Any instance can access the static fields of its class; if they are <strong class="bold">mutable</strong>, it becomes extremely hard to track down which instances is modifying the value. In programs that use multiple threads, it is common to create bugs by modifying the static fields from different threads at the same time.</p>
			<p>Let's examine the following exercise to understand how static variables work.</p>
			<h3 id="_idParaDest-85"><a id="_idTextAnchor093"/>Exercise 7: Working with Static Variables</h3>
			<p>Let's write a program to print and find the square of numbers from 1 to 10:</p>
			<ol>
				<li>Include the required header files.</li>
				<li>Write the <strong class="inline">squares()</strong> function and the following logic:<p class="snippet">void squares() </p><p class="snippet">{  </p><p class="snippet">    static int count = 1; </p><p class="snippet">    int x = count * count;</p><p class="snippet">    x = count * count;</p><p class="snippet">    std::cout &lt;&lt; count &lt;&lt; "*" &lt;&lt; count;</p><p class="snippet">    std::cout &lt;&lt; ": " &lt;&lt; x &lt;&lt;std::endl;</p><p class="snippet">    count++;</p><p class="snippet">}</p></li>
				<li>Now, in the <strong class="inline">main</strong> function, add the following code:<p class="snippet">int main() </p><p class="snippet">{ </p><p class="snippet">    for (int i=1; i&lt;11; i++)     </p><p class="snippet">        squares(); </p><p class="snippet">    return 0; </p><p class="snippet">}</p><p>The output is as follows:</p><p class="snippet">1*1: 1</p><p class="snippet">2*2: 4</p><p class="snippet">3*3: 9</p><p class="snippet">4*4: 16</p><p class="snippet">5*5: 25</p><p class="snippet">6*6: 36</p><p class="snippet">7*7: 49</p><p class="snippet">8*8: 64</p><p class="snippet">9*9: 81</p><p class="snippet">10*10: 100</p></li>
			</ol>
			<p>In addition to static fields, classes can also have static methods.</p>
			<p>A static method is associated with a class; it can be invoked without an instance. Since the fields and members of a class are associated with an instance, while static methods are not, static methods cannot invoke them. Static methods can be invoked using the scope resolution operator: <strong class="inline">ClassName::staticMethodName();</strong>.</p>
			<h4>Note</h4>
			<p class="callout">Static methods can only call other static methods and static fields inside a class.</p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor094"/>Member Functions</h2>
			<p><strong class="keyword">Member functions</strong> are functions that are used to manipulate the data members of a class, and they define the properties and behavior of the objects of the class.</p>
			<p>Declaring a member function is just a matter of declaring a function inside the body of a class. Let's examine the following syntax:</p>
			<p class="snippet">class Car</p>
			<p class="snippet">{</p>
			<p class="snippet">  public:</p>
			<p class="snippet">  void turnOn() {}</p>
			<p class="snippet">};</p>
			<p>Member functions, like the data members of a class, can be accessed using the dot (<strong class="inline">.</strong>) operator that's applied on the object:</p>
			<p class="snippet">Car car;</p>
			<p class="snippet">car.turnOn();</p>
			<p>Let's understand how to declare a member function outside the class scope.</p>
			<h3 id="_idParaDest-87"><a id="_idTextAnchor095"/>Declaring a Member Function</h3>
			<p>Member functions, like data members, must be declared inside the class. However, a member function's implementation can be placed either inside or outside the class, body.</p>
			<p>The following is a definition of a member function outside of the class, scope. This is done by using the scope resolution operator (<strong class="inline">::</strong>) to declare that the function that's being referred to is a member of the class. In the class, body, the function is declared with its prototype:</p>
			<p class="snippet">class Car</p>
			<p class="snippet">{</p>
			<p class="snippet">  public:</p>
			<p class="snippet">  void turnOn();</p>
			<p class="snippet">};</p>
			<p class="snippet">void Car::turnOn() {}</p>
			<h3 id="_idParaDest-88"><a id="_idTextAnchor096"/>Using const Member Functions</h3>
			<p>The member functions of a class can be qualified as <strong class="inline">const</strong>, which means that the function limits its access to be read-only. Moreover, a member function is required to be <strong class="inline">const</strong> when it accesses <strong class="inline">const</strong> member data. So, <strong class="inline">const</strong> member functions are not allowed to modify the state of an object or call another function that does so.</p>
			<p>To declare a member function as <strong class="inline">const</strong>, we use the <strong class="inline">const</strong> keyword in the function declaration after the function name and before its body:</p>
			<p class="snippet">const std::string&amp; getColor() const</p>
			<p class="snippet">{</p>
			<p class="snippet">  // Function body</p>
			<p class="snippet">}</p>
			<p>In addition to the overloading rules that we learned in the previous chapter that member functions can be overloaded in their const-ness, which means that two functions can have identical signatures except for one being <strong class="inline">const</strong> and the other not. The <strong class="inline">const</strong> member function will be called when an object is declared <strong class="inline">const</strong>; otherwise, the non-const function is called. Let's examine the following code:</p>
			<p class="snippet">class Car</p>
			<p class="snippet">{</p>
			<p class="snippet">  std::string&amp; getColor() {}</p>
			<p class="snippet">  const std::string&amp; getColor() const {}</p>
			<p class="snippet">};</p>
			<p class="snippet">Car car;</p>
			<p class="snippet">// Call std::string&amp; getColor()</p>
			<p class="snippet">car.getColor();</p>
			<p class="snippet">const Car constCar; </p>
			<p class="snippet">// Call const Color&amp; getColor() const</p>
			<p class="snippet">constCar.getColor();</p>
			<h4>Note</h4>
			<p class="callout">It is important to distinguish between a <strong class="inline">const</strong> function and a function returning a <strong class="inline">const</strong> type. Both make use of the same <strong class="inline">const</strong> keyword, but in different places in the function prototype. They express a different concept and are independent.</p>
			<p>The following examples show three versions of the <strong class="inline">const</strong> function:</p>
			<ul>
				<li>The first one is a <strong class="inline">const</strong> member function</li>
				<li>The second returns a <strong class="inline">const</strong> reference</li>
				<li>The third one is a <strong class="inline">const</strong> function that returns a <strong class="inline">const</strong> reference:<p class="snippet">type&amp; function() const {}</p><p class="snippet">const type&amp; function() {}</p><p class="snippet">const type&amp; function() const {}</p></li>
			</ul>
			<h3 id="_idParaDest-89"><a id="_idTextAnchor097"/>The this Keyword</h3>
			<p>When the <strong class="inline">this</strong> keyword is used in the <strong class="inline">class</strong> context, it represents a pointer whose value is the address of the object on which the member function is called. It can appear within the body of any non-static member function.</p>
			<p>In the following example, <strong class="inline">setColorToRed()</strong> and <strong class="inline">setColorToBlue()</strong> perform the same action. Both set a data member, but the former uses the <strong class="inline">this</strong> keyword to refer to the current object:</p>
			<p class="snippet">class Car</p>
			<p class="snippet">{</p>
			<p class="snippet">  std::string color;</p>
			<p class="snippet">  void setColorToRed()</p>
			<p class="snippet">  {</p>
			<p class="snippet">    this-&gt;color = "Red";</p>
			<p class="snippet">    // explicit use of this</p>
			<p class="snippet">  }</p>
			<p class="snippet">  void setColorToBlue()</p>
			<p class="snippet">  {</p>
			<p class="snippet">    color = "Blue";</p>
			<p class="snippet">    // same as this-&gt;color = "Blue";</p>
			<p class="snippet">  }</p>
			<p class="snippet">};</p>
			<h4>Note</h4>
			<p class="callout"><strong class="inline">pointer-&gt;member</strong> is a convenient way to access the member of the <strong class="inline">struct</strong> pointed by <strong class="inline">pointer</strong>. It is equivalent to <strong class="inline">(*pointer).member</strong>.</p>
			<h3 id="_idParaDest-90"><a id="_idTextAnchor098"/>Exercise 8: Creating a Program Using the this Keyword to Greet New Users</h3>
			<p>Let's write a program that asks users for their names and greets them with a welcoming message:</p>
			<ol>
				<li value="1">First, include the required header files.</li>
				<li>Then, add the following functions to print the required output:<p class="snippet">class PrintName {</p><p class="snippet">    std::string name;</p><p class="snippet">    </p><p class="snippet">};</p></li>
				<li>Now, let's complete the program with a closing message using the <strong class="inline">this</strong> keyword. Define the following methods inside the previous class:<p class="snippet">public:</p><p class="snippet">   void set_name(const std::string &amp;name){</p><p class="snippet">       this-&gt;name = name;</p><p class="snippet">   }    </p><p class="snippet">   void print_name() {</p><p class="snippet">       std::cout &lt;&lt; this-&gt;name &lt;&lt; "! Welcome to the C++ community :)" &lt;&lt; std::endl;</p><p class="snippet">   }</p></li>
				<li>Write the <strong class="inline">main</strong> function, as follows:<p class="snippet">int main()</p><p class="snippet">{</p><p class="snippet">PrintName object;</p><p class="snippet">object.set_name("Marco");</p><p class="snippet">object.print_name();</p><p class="snippet">}</p><p>The output is as follows:</p><p class="snippet">Marco! Welcome to the C++ community :)</p><h4>Note</h4><p class="callout">A function argument that has the same name as a data member of a class can shadow its visibility. In this case, the <strong class="inline">this</strong> keyword is required for disambiguation.</p></li>
			</ol>
			<h3 id="_idParaDest-91"><a id="_idTextAnchor099"/>Non-Member Class-Related Functions</h3>
			<p>Defined as functions or operations that conceptually belong to the interface of a class, non-member class-related functions are not part of a class itself. Let's examine the following example:</p>
			<p class="snippet">class Circle{</p>
			<p class="snippet">  public:</p>
			<p class="snippet">    int radius;</p>
			<p class="snippet">};</p>
			<p class="snippet">ostream&amp; print(ostream&amp; os, const Circle&amp; circle) {</p>
			<p class="snippet">  os &lt;&lt; "Circle's radius: " &lt;&lt; circle.radius;</p>
			<p class="snippet">  return os;</p>
			<p class="snippet">}</p>
			<p>The print function writes the radius of the circle on the given stream, which is most commonly the standard output.</p>
			<h3 id="_idParaDest-92"><a id="_idTextAnchor100"/>Activity 7: Information Hiding Through Getters and Setters</h3>
			<p>In this activity, you are being asked to define a class named <strong class="inline">Coordinates</strong>, which contains two data members, and <strong class="inline">latitude</strong> and <strong class="inline">longitude</strong>, both of type <strong class="inline">float</strong> and not publicly accessible.</p>
			<p>There are four operations that are associated with the <strong class="inline">Coordinates</strong> class: <strong class="inline">set_latitude</strong>, <strong class="inline">set_longitude</strong>, <strong class="inline">get_latitude</strong>, and <strong class="inline">get_longitude</strong>.</p>
			<h4>Note</h4>
			<p class="callout">The <strong class="inline">set_latitude</strong> and <strong class="inline">set_longitude</strong> operations are used to <strong class="bold">set</strong> the <strong class="inline">x</strong> and <strong class="inline">y</strong> coordinates (also referred to as <strong class="keyword">setters</strong>), while <strong class="inline">get_latitude</strong> and <strong class="inline">get_longitude</strong> are used to <strong class="bold">retrieve</strong> them (sometimes called <strong class="keyword">getters</strong>).</p>
			<p>Performing encapsulation using the member functions through getter and setters.</p>
			<p>To perform this activity, follow these steps:</p>
			<ol>
				<li value="1">Define a class with the name <strong class="inline">Coordinates</strong>, with its members under a <strong class="inline">private</strong> access specifier.</li>
				<li>Add the four operations previously specified and make them publicly accessible by preceding their declaration by the <strong class="inline">public</strong> access specifier.</li>
				<li>The setters (<strong class="inline">set_latitude</strong> and <strong class="inline">set_longitude</strong>) should take a float as a parameter and return <strong class="inline">void</strong>, while the getters do not take any parameters and return a <strong class="inline">float</strong>.</li>
				<li>The four methods should now be implemented. The setters assign the given value to the corresponding member they are supposed to set; the getters return the values that are stored.<h4>Note</h4><p class="callout">The solution for this activity can be found on page 288.</p></li>
			</ol>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor101"/>Constructors and Destructors</h2>
			<p>Up until now, we have learned how to declare data members, how to use them in functions with a <strong class="inline">public</strong> specifier, and how to access them. Now, let's explore how to set a value to them.</p>
			<p>In the following example, we'll declare a <strong class="inline">struct</strong> by the name of <strong class="inline">Rectangle</strong>, and set a value to it as follows:</p>
			<p class="snippet">struct Rectangle {</p>
			<p class="snippet">  int height;</p>
			<p class="snippet">  int width;</p>
			<p class="snippet">};</p>
			<p class="snippet">Rectangle rectangle;</p>
			<p class="snippet">// What will the following print function print?</p>
			<p class="snippet">std::cout &lt;&lt; "Height: " &lt;&lt; rectangle.height &lt;&lt; std::endl;</p>
			<p>This line will print a random value because we never set the value of <strong class="inline">int</strong>. The C++ rule for the initialization of basic types is that they get non-specified values.</p>
			<h4>Note</h4>
			<p class="callout">In some situations, the values of variables are set to <strong class="inline">0</strong> when they are not initialized. This might happen because of some details in the implementation of the operating system, the standard library, or the compiler, and the C++ standard does not guarantee it. A program will have strange bugs when it relies on this behavior, since it is unpredictable when variables are initialized to <strong class="inline">0</strong>. Always explicitly initialize variables with basic types.</p>
			<h3 id="_idParaDest-94"><a id="_idTextAnchor102"/>Constructors</h3>
			<p>The way to initialize data members is by using a <strong class="keyword">constructor</strong>. A constructor is a special member function that has the <em class="italics">same name</em> as the class and <em class="italics">no return type</em>, and it is called automatically by the compiler when a new object of the class is created.</p>
			<p>Like any other function, a constructor can accept parameters and has a function body. We can invoke a constructor by adding a parameter list after the name of the variable:</p>
			<p class="snippet">Rectangle rectangle(parameter1, paramter2, ..., parameterN);</p>
			<p>When there are no parameters, we can avoid using parentheses, which is what we did in the previous example.</p>
			<p>An example of a constructor with no parameters for the <strong class="inline">Rectangle</strong> struct would look as follows:</p>
			<p class="snippet">struct Rectangle {</p>
			<p class="snippet">  int height, width;</p>
			<p class="snippet">  Rectangle() {</p>
			<p class="snippet">    height = 0;</p>
			<p class="snippet">    width = 0;</p>
			<p class="snippet">  }</p>
			<p class="snippet">};</p>
			<h4>Note</h4>
			<p class="callout">When the only operation the constructor does is initialize the data members, opt for using the initialization list, which we will show you later in this chapter.</p>
			<p>In addition to assigning values to data members, a constructor can also execute code, similar to a normal function body. This is important for the concept of the <em class="italics">class invariant</em>.</p>
			<p>A key advantage of hiding the implementation of a class in <em class="italics">private</em> members and only exposing <em class="italics">public</em> methods to interact with the concept represented by the class is the ability to enforce a class invariant.</p>
			<p>A class invariant is a property or a set of properties of a class that should be <strong class="inline">true</strong> for any given instance of the class, at any point. It is called <strong class="bold">invariant</strong> because the set of properties do not vary; they are always <strong class="inline">true</strong>.</p>
			<p>Let's look at an example of a class that requires a class invariant. Imagine that we want to create a class that represents a date. The date would contain a year, month, and day, all represented as integers.</p>
			<p>Implement it as a <strong class="inline">struct</strong> with all the fields as <strong class="inline">public</strong>. Refer to the following code:</p>
			<p class="snippet">struct Date {</p>
			<p class="snippet">  int day;</p>
			<p class="snippet">  int month;</p>
			<p class="snippet">  int year;</p>
			<p class="snippet">};</p>
			<p>Now, the user could easily do the following:</p>
			<p class="snippet">Date date;</p>
			<p class="snippet">date.month = 153;</p>
			<p>The previous code does not make any sense, as there are only 12 months in the Gregorian calendar.</p>
			<p>A class invariant for the date would be that the month is always between 1 and 12, and that the day is always between 1 and 31, and depending on the month, even less.</p>
			<p>Independently of any change the user performs on the <strong class="inline">Date</strong> object, the invariant must always hold.</p>
			<p>A class can hide the detail that the date is stored as three integers and expose the functions to interact with the <strong class="inline">Date</strong> object. Functions can expect to find the dates to always be in a valid state (the invariant is satisfied at the start of the function), and they need to make sure to leave the class in a valid state (the invariant is satisfied at the end of the function).</p>
			<p>The constructor does not only initialize the data members but also ensure that the class respects the invariant. After the constructor is executed, the invariant must be <strong class="inline">true</strong>.</p>
			<h4>Note</h4>
			<p class="callout">The concept of an invariant is not specific to the C++ language, and there is no dedicated facility to specify the invariant of a class. A best practice is to document the expected invariant of the class together with the class code so that the developers working with the class can easily check what the expected invariant is and make sure they respect it.</p>
			<p>Using assertions in code also helps in identifying when the invariant is not respected. This probably means there is a bug in the code.</p>
			<h3 id="_idParaDest-95"><a id="_idTextAnchor103"/>Overloading Constructor</h3>
			<p>Similar to other functions, we can overload the constructor by accepting different parameters. This is useful when an object can be created in several ways, since the user can create the object by providing the expected parameter, and the correct constructor is going to be called.</p>
			<p>We showed an example of a default constructor for the <strong class="inline">Rectangle</strong> class earlier in this chapter. If we want to add a constructor that creates a rectangle from a square, we could add the following constructor to the <strong class="inline">Rectangle</strong> class:</p>
			<p class="snippet">class Rectangle {</p>
			<p class="snippet">  public: </p>
			<p class="snippet">    Rectangle(); // as before</p>
			<p class="snippet">    Rectangle (Square square);</p>
			<p class="snippet">}; </p>
			<p>The second constructor is an overloaded constructor and will be invoked according to the way the class object is initialized.</p>
			<p>In the following example, the first line will call the constructor with empty parameters, while the second line will call the overloaded constructor:</p>
			<p class="snippet">Rectangle obj; // Calls the first constructor</p>
			<p class="snippet">Rectangle obj(square); // Calls the second overloaded constructor</p>
			<h4>Note</h4>
			<p class="callout">A constructor with a single non-default parameter is also called a <strong class="keyword">converting constructor</strong>. This kind of constructor specifies an implicit conversion, from the type of the argument to the class type.</p>
			<p>The following conversion is possible according to the previous definitions:</p>
			<p class="snippet">Square square;</p>
			<p class="snippet">Rectangle rectangle(square);</p>
			<p>The constructor is initialized, and it converts from type <strong class="inline">Square</strong> to <strong class="inline">Rectangle</strong>.</p>
			<p>Similarly, the compiler can create implicit conversions when calling functions, as shown in the following example:</p>
			<p class="snippet">void use_rectangle(Rectangle rectangle);</p>
			<p class="snippet">int main() {</p>
			<p class="snippet">  Square square;</p>
			<p class="snippet">  use_rectangle(square);</p>
			<p class="snippet">}</p>
			<p>When calling <strong class="inline">use_rectangle</strong>, the compiler creates a new object of type <strong class="inline">Rectangle</strong> by calling the conversion constructor, which accepts a <strong class="inline">Square</strong>.</p>
			<p>One way to avoid this is to use the <strong class="inline">explicit</strong> specifier before the constructor definition:</p>
			<p class="snippet">explicit class_name(type arg) {}</p>
			<p>Let's look at a different implementation of <strong class="inline">Rectangle</strong>, which has an explicit constructor:</p>
			<p class="snippet">class ExplicitRectangle {</p>
			<p class="snippet">  public: </p>
			<p class="snippet">    explicit ExplicitRectangle(Square square);</p>
			<p class="snippet">}; </p>
			<p>When we use try to use <strong class="inline">Square</strong> to call a function that takes <strong class="inline">ExplicitRectangle</strong>, we get an error:</p>
			<p class="snippet">void use_explicit_rectangle(ExplicitRectangle rectangle);</p>
			<p class="snippet">int main() {</p>
			<p class="snippet">    Square square;</p>
			<p class="snippet">    use_explicit_rectangle(square); // Error!</p>
			<p class="snippet">}</p>
			<h3 id="_idParaDest-96"><a id="_idTextAnchor104"/>Constructor Member Initialization</h3>
			<p>Constructors, as we've seen already, are used to initialize members. Up until now, we have initialized the members inside the body of the function by assigning values to members directly. C++ provides a feature to initialize the values of fields of the class in a more ergonomic way: initialization lists. Initialization lists allow you to call the constructor of the data members of class before the constructor body is executed. To write an initializer list, insert a colon (<strong class="inline">:</strong>) and a comma-separated list of initializations for class members before the constructor's body.</p>
			<p>Let's look at the following example:</p>
			<p class="snippet">class Rectangle {</p>
			<p class="snippet">  public:</p>
			<p class="snippet">    Rectangle(): width(0), height(0) { } //Empty function body, as the variables have already been initialized</p>
			<p class="snippet">  private:</p>
			<p class="snippet">    int width;</p>
			<p class="snippet">    int height;</p>
			<p class="snippet">};</p>
			<p>Note how, in this last case, the constructor does nothing other than initialize its members. Hence, it has an empty function body. </p>
			<p>Now, if we try to print the width and the height of the <strong class="inline">Rectangle</strong> object, we will notice that they are correctly initialized to <strong class="inline">0</strong>:</p>
			<p class="snippet">Rectangle rectangle; </p>
			<p class="snippet">std::cout &lt;&lt; "Width: " &lt;&lt; rectangle.width &lt;&lt; std::endl;  // 0</p>
			<p class="snippet">std::cout &lt;&lt; "Height: " &lt;&lt; rectangle.height &lt;&lt; std::endl; // 0</p>
			<p>Initializer lists are the recommended way to initialize member variables in C++, and they are necessary when a data member is <strong class="inline">const</strong>.</p>
			<p>When using an initializer list, the order in which the members are constructed is the one in which they are declared inside the class; not the one in which they appear in the initializer list. Let's look at the following example:</p>
			<p class="snippet">class Example {</p>
			<p class="snippet">    Example() : second(0), first(0) {}</p>
			<p class="snippet">    int first;</p>
			<p class="snippet">    int second;</p>
			<p class="snippet">};</p>
			<p>When calling the default constructor of the <strong class="inline">Example</strong> class, the <strong class="inline">first</strong> method will be initialized first, and the <strong class="inline">second</strong> method after it, even if they appear in a different order in the initializer list.</p>
			<h4>Note</h4>
			<p class="callout">You should always write the members in the initializer list in the same order as they are declared; compilers will help you by warning you when the order differs from the expected one.</p>
			<h3 id="_idParaDest-97"><a id="_idTextAnchor105"/>Aggregate Classes Initialization</h3>
			<p>Classes or structs with no user-declared constructors, no private or protected specifiers non-static data members, no base classes, and no virtual functions are considered aggregate.</p>
			<h4>Note</h4>
			<p class="callout">We will talk about base classes and virtual functions in chapter 6.</p>
			<p>These types of classes can be initialized, even though they do not have a constructor, by using a brace-enclosed comma-separated list of initializer-clauses, as shown here:</p>
			<p class="snippet">struct Rectangle {</p>
			<p class="snippet">  int length;</p>
			<p class="snippet">  int width;</p>
			<p class="snippet">};</p>
			<p class="snippet">Rectangle rectangle = {10, 15};</p>
			<p class="snippet">std::cout &lt;&lt; rectangle.length &lt;&lt; "," &lt;&lt; rectangle.width;</p>
			<p class="snippet">// Prints: 10, 15</p>
			<h3 id="_idParaDest-98"><a id="_idTextAnchor106"/>Destructors</h3>
			<p>A <em class="italics">destructor</em> function is called automatically when the object goes out of scope and is used to destroy objects of its class type.</p>
			<p>Destructors have the same name as the class preceded by a tilde (<strong class="inline">~</strong>) and do not take any argument nor return any value (not even void). Let's examine the following example:</p>
			<p class="snippet">class class_name {</p>
			<p class="snippet">  public:</p>
			<p class="snippet">    class_name() {} // constructor</p>
			<p class="snippet">    ~class_name() {} // destructor</p>
			<p class="snippet">};</p>
			<p>After executing the body of the destructor and destroying any automatic objects allocated within the body, a destructor for a class calls the destructors for all the direct members of the class. Data members are destroyed in reverse order of their construction.</p>
			<h3 id="_idParaDest-99"><a id="_idTextAnchor107"/>Exercise 9: Creating a Simple Coordinate Program to Demonstrate the Use of Constructors and Destructors</h3>
			<p>Let's write a simple program to demonstrate the use of constructors and destructors:</p>
			<ol>
				<li value="1">First, include the required header files.</li>
				<li>Now, add the following code to the <strong class="inline">Coordinates</strong> class:<p class="snippet">class Coordinates {</p><p class="snippet">    public:</p><p class="snippet">    Coordinates(){</p><p class="snippet">        std::cout &lt;&lt; "Constructor called!" &lt;&lt; std::endl;</p><p class="snippet">    }</p><p class="snippet">    </p><p class="snippet">    ~Coordinates(){</p><p class="snippet">        std::cout &lt;&lt; "Destructor called!" &lt;&lt; std::endl;</p><p class="snippet">    }</p><p class="snippet">};</p></li>
				<li>In the <strong class="inline">main</strong> function, add the following code:<p class="snippet">int main() </p><p class="snippet">{ </p><p class="snippet">  </p><p class="snippet">  Coordinates c;  </p><p class="snippet">  // Constructor called!</p><p class="snippet">  // Destructor called!</p><p class="snippet">  </p><p class="snippet">}</p><p>The output is as follows:</p><p class="snippet">Constructor called!</p><p class="snippet">Destructor called!</p></li>
			</ol>
			<h3 id="_idParaDest-100"><a id="_idTextAnchor108"/>Default Constructor and Destructor</h3>
			<p>All the classes needs constructor and destructor functions. When the programmer does not define these, the compiler automatically creates an implicitly defined constructor and destructor.</p>
			<h4>Note</h4>
			<p class="callout">The default constructor might not initialize data members. Classes that have members of a built-in or compound type should ordinarily either initialize those members inside the class or define their version of the default constructor.</p>
			<h3 id="_idParaDest-101"><a id="_idTextAnchor109"/>Activity 8: Representing Positions in a 2D Map</h3>
			<p>Alice is building a program to show 2D maps of the world. Users need to be able to save locations, such as their house, a restaurant, or their workplace. To enable this functionality, Alice needs to be able to represent a position in the world.</p>
			<p>Create a class named <strong class="inline">Coordinates</strong> whose data members are the 2D coordinates of a point. To ensure that the object is always properly initialized, implement a constructor to initialize the data members of the class.</p>
			<p>Let's perform the following steps:</p>
			<ol>
				<li value="1">The first step is to create a class named <strong class="inline">Coordinates</strong> containing the coordinates as data members.</li>
				<li>Now, there are two floating-point values, <strong class="inline">_latitude</strong> and <strong class="inline">_longitude</strong>, which identify the coordinates on a geographic coordinate system. Additionally, these data members are defined with the <strong class="inline">private</strong> access specifier.</li>
				<li>Extend the class with a <strong class="inline">public</strong> constructor that takes two arguments, <strong class="inline">latitude</strong> and <strong class="inline">longitude</strong>, which are used to initialize the data members of the class.</li>
				<li>Alice can now use this <strong class="inline">Coordinates</strong> class to represent 2D positions on the map.<h4>Note</h4><p class="callout">The solution for this activity can be found on page 289.</p></li>
			</ol>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor110"/>Resource Acquisition Is Initialization</h2>
			<p><strong class="keyword">Resource Acquisition Is Initialization</strong>, or just <strong class="keyword">RAII</strong>, is a programming idiom that is used to manage the life cycle of a resource automatically by binding it to the lifetime of an object.</p>
			<p>Through the smart use of the constructor and destructor of an object, you can achieve RAII. The former acquires the resource, while the latter takes care of realizing it. The constructor is allowed to throw an exception, when a resource cannot be acquired, while the destructor must never throw exceptions.</p>
			<p>Typically, it is a good practice to operate on a resource via an instance of a RAII class when its usage involves <strong class="inline">open()</strong>/<strong class="inline">close()</strong>, <strong class="inline">lock()</strong>/<strong class="inline">unlock()</strong>, <strong class="inline">start()</strong>/<strong class="inline">stop()</strong>, <strong class="inline">init()</strong>/<strong class="inline">destroy()</strong>, or similar function calls.</p>
			<p>The following is a way to open and close a file using an RAII-style mechanism.</p>
			<h4>Note</h4>
			<p class="callout">C++, like many languages, represents input/output operations as streams, where data can be written to or read from.</p>
			<p>The constructor of the class opens the file into a provided stream, while the destructor closes it:</p>
			<p class="snippet">class file_handle {</p>
			<p class="snippet">  public:</p>
			<p class="snippet">    file_handle(ofstream&amp; stream, const char* filepath) : _stream(stream) {</p>
			<p class="snippet">      _stream.open(filepath);</p>
			<p class="snippet">    }</p>
			<p class="snippet">    ~file_handle {</p>
			<p class="snippet">      _stream.close();</p>
			<p class="snippet">    }</p>
			<p class="snippet">  private:</p>
			<p class="snippet">    ofstream&amp; _stream;</p>
			<p class="snippet">};</p>
			<p>To open the file, it is sufficient to provide the file path to the <strong class="inline">file_handle </strong>class. Then, for the entire lifetime of the <strong class="inline">file_handle</strong> object, the file will not be closed. Once the object reaches the end of the scope, the file is closed:</p>
			<p class="snippet">ofstream stream;</p>
			<p class="snippet">{</p>
			<p class="snippet">  file_handle myfile(stream, "Some path"); // file is opened</p>
			<p class="snippet">  do_something_with_file(stream);</p>
			<p class="snippet">}                                          // file is closed here </p>
			<p>This is used instead of the following code:</p>
			<p class="snippet">ofstream stream;</p>
			<p class="snippet">{</p>
			<p class="snippet">  stream.open("Some path");    // file is opened</p>
			<p class="snippet">  do_something_with_file(stream);</p>
			<p class="snippet">  stream.close();              // file is closed here</p>
			<p class="snippet">}</p>
			<p>Even though the benefit provided by applying the RAII idiom seems to be just to reduce code, the real improvement is having safer code. It is common for a programmer to write a function that correctly opens a file but never closes it or allocates memory that never gets destroyed.</p>
			<p>RAII makes sure that these operations cannot be forgotten, as it automatically handles them.</p>
			<h3 id="_idParaDest-103"><a id="_idTextAnchor111"/>Activity 9: Storing Multiple Coordinates of Different Positions on a Map</h3>
			<p>In the 2D map program, the user can save multiple positions on the map. We need to be able to store multiple coordinates to keep track of the positions saved by the user. To do so, we need a way to create an array that can store them:</p>
			<ol>
				<li value="1">Using the RAII programming idiom, write a class that manages memory allocation and the deletion of an array of values . The class has an array of integers as member data, which will be used to store the values .</li>
				<li>The constructor takes the size of the array as a parameter.</li>
				<li>The constructor also takes care of allocating memory, which is used to store the coordinates.</li>
				<li>To allocate the memory use the function <strong class="inline">allocate_memory</strong> (number of elements) which returns a pointer to an array of Coordinates of the requested size. To release the memory, call <strong class="inline">release_memory</strong> (array) which takes an array of Coordinates and releases the memory.</li>
				<li>Finally, define a destructor and make sure to free the previously allocated array in its implementation:<h4>Note</h4><p class="callout">The solution for this activity can be found on page 290.</p></li>
			</ol>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor112"/>Nested Class Declarations</h2>
			<p>Inside the scope of a class, we can declare more than just data members and member functions; we can declare a class inside another class. These classes are called <strong class="keyword">nested classes</strong>.</p>
			<p>Since a nested class declaration happens inside the <em class="italics">outer class</em>, it has access to all the declared names as if it were part of the outer class: it can access even <strong class="bold">private declarations</strong>.</p>
			<p>On the other hand, a nested class is not associated with any instance, so it can only access <em class="italics">static members</em>.</p>
			<p>To access a nested class, we can use the double colon (<strong class="inline">::</strong>), similar to accessing static members of the outer class. Let's examine the following example:</p>
			<p class="snippet">// Declaration</p>
			<p class="snippet">class Coordinate {</p>
			<p class="snippet">...</p>
			<p class="snippet">  struct CoordinateDistance {</p>
			<p class="snippet">    float x = 0;</p>
			<p class="snippet">    float y = 0;</p>
			<p class="snippet">    static float walkingDistance(CoordinateDistance distance);</p>
			<p class="snippet">  }</p>
			<p class="snippet">};</p>
			<p class="snippet">// Create an instance of the nested class CoordinateDistance</p>
			<p class="snippet">Coordinate::CoordinateDistance distance;</p>
			<p class="snippet">/* Invoke the static method walkingDistance declared inside the nested class CoordinateDistance */</p>
			<p class="snippet">Coordinate::CoordinateDistance::walkingDistance(distance);</p>
			<p>Nested classes are useful for two main reasons:</p>
			<ul>
				<li>When implementing a class, we need an object that manages some of the logic of the class. In such cases, the nested class is usually <strong class="bold">private</strong>, and is not exposed through the <strong class="bold">public interface</strong> of the class. It is mostly used to ease the implementation of the class.</li>
				<li>When designing the functionality of a class, we want to provide a different class, closely related to the original one, which provides part of that functionality. In that case, the class is accessible by the users of the class and is usually an important part of the interaction with the class.</li>
			</ul>
			<p>Imagine a list  a sequence of objects. We would like the user to be able to iterate over the items contained in the list. To do so, we need to keep track of which items the user has already iterated over and which are remaining. This is typically done with an <strong class="bold">iterator</strong>, which is a <em class="italics">nested class</em>. The iterator is an integral part of interacting with the <strong class="inline">List</strong> class.</p>
			<p>We will look at iterators more in detail in <em class="italics">Lesson 5</em>, <em class="italics">Standard Library Containers and Algorithms</em>.</p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor113"/>Friend Specifier</h2>
			<p>As we have already seen, private and protected members of a class are not accessible from within other functions and classes. A class can declare another function or class as a friend: this function or class will have access to the private and protected members of the class which declares the <strong class="bold">friend relationship</strong>.</p>
			<p>The user has to specify the <strong class="inline">friend</strong> declaration within the body of the class.</p>
			<h3 id="_idParaDest-106"><a id="_idTextAnchor114"/>Friend Functions</h3>
			<p>Friend functions are non-member functions that are entitled to access the private and protected members of a class. The way to declare a function as a <strong class="inline">friend</strong> function is by adding its declaration within the class and preceding it by the <strong class="inline">friend</strong> keyword. Let's examine the following code:</p>
			<p class="snippet">class class_name {</p>
			<p class="snippet">  type_1 member_1;</p>
			<p class="snippet">  type_2 member_2;</p>
			<p class="snippet">  public:</p>
			<p class="snippet">    friend void print(const class_name &amp;obj);</p>
			<p class="snippet">};</p>
			<p class="snippet">friend void print(const class_name &amp;obj){</p>
			<p class="snippet">  std::cout &lt;&lt; obj.member_1 &lt;&lt; " " &lt;&lt; member_2 &lt;&lt; std::endl;</p>
			<p class="snippet">}</p>
			<p>In the previous example, the function declared outside of the class scope has the right to access the class data members because it is declared as a <strong class="inline">friend</strong> function.</p>
			<h3 id="_idParaDest-107"><a id="_idTextAnchor115"/>Friend Classes</h3>
			<p>Similarly, like a <strong class="inline">friend</strong> function, a class can also be made a friend of another class by using the <strong class="inline">friend</strong> keyword.</p>
			<p>Declaring a class as a <strong class="inline">friend</strong> is like declaring all of its methods as friend functions.</p>
			<h4>Note</h4>
			<p class="callout">Friendship is not mutual. If a class is a friend of another, then the opposite is not automatically true.</p>
			<p>The following code demonstrates the concept of how friendship is not mutual:</p>
			<p class="snippet">class A {</p>
			<p class="snippet">  friend class B;</p>
			<p class="snippet">  int a = 0;</p>
			<p class="snippet">};</p>
			<p class="snippet">class B {</p>
			<p class="snippet">  friend class C;</p>
			<p class="snippet">  int b = 0;</p>
			<p class="snippet">};</p>
			<p class="snippet">class C {</p>
			<p class="snippet">  int c = 0;</p>
			<p class="snippet">  void access_a(const A&amp; object) {</p>
			<p class="snippet">    object.a;</p>
			<p class="snippet">    // Error! A.a is private, and C is not a friend of A.</p>
			<p class="snippet">  }</p>
			<p class="snippet">};</p>
			<p>Friendship is not transitive; so, in the previous example, class <strong class="inline">C</strong> is not a friend of class <strong class="inline">A,</strong> and the methods of class <strong class="inline">C</strong> cannot access the protected or private members of class <strong class="inline">A</strong>. Additionally, <strong class="inline">A</strong> cannot access B's private members, since <strong class="inline">B</strong> is a friend of <strong class="inline">A</strong>, but friendship is not mutual.</p>
			<h3 id="_idParaDest-108"><a id="_idTextAnchor116"/>Exercise 10: Creating a Program to Print the User's Height</h3>
			<p>Let's write a program that collects height input from the user in inches and, after performing a calculation, prints the height of the user in feet:</p>
			<ol>
				<li value="1">First, let's add all the required header files to the program.</li>
				<li>Now, create the <strong class="inline">Height</strong> class with one <strong class="inline">public</strong> method, as illustrated:<p class="snippet">class Height {</p><p class="snippet">    double inches;</p><p class="snippet">    public:</p><p class="snippet">        Height(double value): inches(value) { }</p><p class="snippet">        friend void print_feet(Height);</p><p class="snippet">};</p></li>
				<li>As you can see, in the previous code, we used a friend function named <strong class="inline">print_feet</strong>. Now, let's declare it:<p class="snippet">void print_feet(Height h){</p><p class="snippet">    std::cout &lt;&lt; "Your height in inches is: " &lt;&lt; h.inches&lt;&lt; std::endl;</p><p class="snippet">    std::cout &lt;&lt; "Your height in feet is: " &lt;&lt; h.inches * 0.083 &lt;&lt; std::endl;</p><p class="snippet">}</p></li>
				<li>Invoke the class in the <strong class="inline">main</strong> function, as shown here:<p class="snippet">int main(){</p><p class="snippet">    IHeight h(83);</p><p class="snippet">    print_feet(h);</p><p class="snippet">}</p><p>The output is as follows:</p><p class="snippet">Your height in inches is: 83</p><p class="snippet">Your height in feet is: 6.889</p></li>
			</ol>
			<h3 id="_idParaDest-109"><a id="_idTextAnchor117"/>Activity 10: The AppleTree Class, which Creates an Apple Instance</h3>
			<p>Sometimes, we would like to prevent the creation of an object of a specific type except for a limited number of classes. This usually happens when the classes are strictly related.</p>
			<p>Create an <strong class="inline">Apple</strong> class that does not provide a <strong class="inline">public</strong> constructor and an <strong class="inline">AppleTree</strong> class that is in charge of creating the former object.</p>
			<p>Let's execute the following steps:</p>
			<ol>
				<li value="1">First, we need to create a class with a <strong class="inline">private</strong> constructor. In this way, the object cannot be constructed, because the constructor is not publicly accessible:<p class="snippet">class Apple </p><p class="snippet">{</p><p class="snippet">  private:</p><p class="snippet">    Apple() {}</p><p class="snippet">    // do nothing</p><p class="snippet">};</p></li>
				<li>The <strong class="inline">AppleTree</strong> class is defined and contains a method called <strong class="inline">createFruit</strong>, which is in charge of creating an <strong class="inline">Apple</strong> and returning it:<p class="snippet">class AppleTree</p><p class="snippet">{</p><p class="snippet">  public:</p><p class="snippet">    Apple createApple(){</p><p class="snippet">      Apple apple;</p><p class="snippet">      return apple;</p><p class="snippet">    }</p><p class="snippet">};</p></li>
				<li>If we compile this code, we will get an error. At this point, the <strong class="inline">Apple</strong> constructor is <strong class="inline">private</strong>, so the <strong class="inline">AppleTree</strong> class cannot access it. We need to declare the <strong class="inline">AppleTree</strong> class as a <strong class="inline">friend</strong> of <strong class="inline">Apple</strong> to allow <strong class="inline">AppleTree</strong> to access the private methods of <strong class="inline">Apple</strong>:<p class="snippet">class Apple</p><p class="snippet">{</p><p class="snippet">  friend class AppleTree;</p><p class="snippet">  private:</p><p class="snippet">    Apple() {}</p><p class="snippet">    // do nothing</p><p class="snippet">}</p></li>
				<li>The <strong class="inline">Apple</strong> object can now be constructed using the following code:<p class="snippet">AppleTree tree;</p><p class="snippet">Apple apple = tree.createFruit();</p><h4>Note</h4><p class="callout">The solution for this activity can be found on page 291.</p></li>
			</ol>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor118"/>Copy Constructors and Assignment Operators</h2>
			<p>One special type of constructor is the <strong class="keyword">copy constructor</strong>. It initializes the data members of one object to another object. The object that's used to copy the member's value is passed as an argument to the copy constructor, typically of <em class="italics">type reference</em> to the class itself, and possibly <strong class="inline">const</strong> qualified.</p>
			<p>The following code refers to a class with a user-defined copy constructor, which copies the data member of the other object into the current one:</p>
			<p class="snippet">class class_name {</p>
			<p class="snippet">  public:</p>
			<p class="snippet">    class_name(const class_name&amp; other) : member(other.member){}</p>
			<p class="snippet">  private:</p>
			<p class="snippet">    type member;</p>
			<p class="snippet">};</p>
			<p>A copy constructor is declared <em class="italics">implicitly</em> by the compiler when the class definition does not explicitly declare a copy constructor and all the data members have a copy constructor. This implicit copy constructor performs a copy of the class members in the <em class="italics">same order</em> of initialization.</p>
			<p>Let's look at an example:</p>
			<p class="snippet">struct A {</p>
			<p class="snippet">  A() {}</p>
			<p class="snippet">  A(const A&amp; a) {</p>
			<p class="snippet">    std::cout &lt;&lt; "Copy construct A" &lt;&lt; std::endl;</p>
			<p class="snippet">  }</p>
			<p class="snippet">};</p>
			<p class="snippet">struct B {</p>
			<p class="snippet">  B() {}</p>
			<p class="snippet">  B(const B&amp; a) {</p>
			<p class="snippet">    std::cout &lt;&lt; "Copy construct B" &lt;&lt; std::endl;</p>
			<p class="snippet">  }</p>
			<p class="snippet">};</p>
			<p class="snippet">class C {</p>
			<p class="snippet">  A a;</p>
			<p class="snippet">  B b;</p>
			<p class="snippet">  // The copy constructor is implicitly generated</p>
			<p class="snippet">};</p>
			<p class="snippet">int main() {</p>
			<p class="snippet">  C first;</p>
			<p class="snippet">  C second(first);</p>
			<p class="snippet">  // Prints: "Copy construct A", "Copy construct B"</p>
			<p class="snippet">}</p>
			<p>When <strong class="inline">C</strong> is copy constructed, the members are copied in order: first, <strong class="inline">a</strong> is copied and then <strong class="inline">b</strong> is copied. To copy <strong class="inline">A</strong> and <strong class="inline">B</strong>, the compiler calls the copy constructor defined in those classes.</p>
			<h4>Note</h4>
			<p class="callout">When a pointer is copied, we are not copying the object pointed to, but simply the address at which the object is located.</p>
			<p class="callout">This means that when a class contains a <strong class="inline">pointer</strong> as a data member, the implicit copy constructor only copies the pointer and not the pointed object, so the copied object and the original one will share the object that's pointed to by the pointer. This is sometimes called a <strong class="bold">shallow copy</strong>.</p>
			<h3 id="_idParaDest-111"><a id="_idTextAnchor119"/>The copy Assignment Operator</h3>
			<p>An alternative way to copy an object is by using the <strong class="bold">copy assignment operator</strong>, which, contrary to the construct operator, is called when the object has been already initialized.</p>
			<p>The assignment operator signature and implementation look quite similar to the copy constructor, with the only difference being that the former is an overload of the <strong class="inline">=</strong> operator and it generally returns a reference to <strong class="inline">*this</strong>, although it's not required.</p>
			<p>Here's an example of the use of the copy assignment operator:</p>
			<p class="snippet">class class_name {</p>
			<p class="snippet">  public:</p>
			<p class="snippet">    class_name&amp; operator= (const class_name &amp; other) {</p>
			<p class="snippet">      member = other.member;</p>
			<p class="snippet">    }</p>
			<p class="snippet">  private:</p>
			<p class="snippet">    type member;</p>
			<p class="snippet">};</p>
			<p>Also, for the copy assignment operator, the compiler generates an <em class="italics">implicit</em> one when it is not explicitly declared. As for the copy constructor, the members are copied in the same order of initialization.</p>
			<p>In the following example, the copy constructor and the copy assignment operator will output a sentence when they are called:</p>
			<p class="snippet">class class_name {</p>
			<p class="snippet">  public:</p>
			<p class="snippet">    class_name(const class_name&amp; other) : member(other.member){</p>
			<p class="snippet">      std::cout &lt;&lt; "Copy constructor called!" &lt;&lt; std::endl;</p>
			<p class="snippet">    }</p>
			<p class="snippet">    class_name&amp; operator= (const class_name &amp; other) {</p>
			<p class="snippet">      member = other.member;</p>
			<p class="snippet">      std::cout &lt;&lt; "Copy assignment operator called!" &lt;&lt; std::endl;</p>
			<p class="snippet">    }</p>
			<p class="snippet">  private:</p>
			<p class="snippet">    type member;</p>
			<p class="snippet">};</p>
			<p>The following code shows two ways of copying an object. The former uses the copy constructor, while the latter uses the copy assignment operator. The two implementations will print a sentence when they are called:</p>
			<p class="snippet">class_name obj;</p>
			<p class="snippet">class_name other_obj1(obj);</p>
			<p class="snippet">\\ prints "Copy constructor called!"</p>
			<p class="snippet">class_name other_obj2 = obj;</p>
			<p class="snippet">\\ prints "Copy assignment operator called!"</p>
			<h3 id="_idParaDest-112"><a id="_idTextAnchor120"/>The move-constructor and move-assignment Operator</h3>
			<p>Like copying, moving also allows you to set the data members of an object to be equal to those of another data member. The only difference with copying lies in the fact that the content is transferred from one object to another, removing it from the source.</p>
			<p>The move-constructor and move-assignment are members that take a parameter of type <strong class="inline">rvalue</strong> reference to the <strong class="inline">class</strong> itself:</p>
			<p class="snippet">class_name (class_name &amp;&amp; other);</p>
			<p class="snippet">// move-constructor</p>
			<p class="snippet">class_name&amp; operator= (class_name &amp;&amp; other);</p>
			<p class="snippet">// move-assignment</p>
			<h4>Note</h4>
			<p class="callout">For clarity, we can briefly describe an <strong class="inline">rvalue</strong> reference (formed by placing an <strong class="inline">&amp;&amp;</strong> operator after the type of the function argument) as a value that does not have a memory address and does not persist beyond a single expression, for example, a <strong class="bold">temporary object</strong>.</p>
			<p>A move constructor and a move assignment operator enable the resources owned by an <strong class="inline">rvalue</strong> object to be moved into an <strong class="inline">lvalue</strong> without copying.</p>
			<p>When we move a construct or assign a source object to a destination object, we transfer the content of the source object into the destination object, but the source object needs to remain valid. To do so, when implementing such methods, it is fundamental to reset the data members of the source object to a valid value. This is necessary to prevent the destructor from freeing the resources (such as memory) of the class multiple times.</p>
			<p>Let's assume that there is a <strong class="inline">Resource</strong> that can be acquired, released, reset, and checked if it's reset.</p>
			<p>Here is an example of a <strong class="inline">WrongMove</strong> constructor:</p>
			<p class="snippet">class WrongMove {</p>
			<p class="snippet">  public:</p>
			<p class="snippet">    WrongMove() : _resource(acquire_resource()) {}</p>
			<p class="snippet">    WrongMove(WrongMove&amp;&amp; other) {</p>
			<p class="snippet">      _resource = other._resource;</p>
			<p class="snippet">      // Wrong: we never reset other._resource</p>
			<p class="snippet">    }</p>
			<p class="snippet">    ~WrongMove() {</p>
			<p class="snippet">      if (not is_reset_resource(_resource)) {</p>
			<p class="snippet">        release_resource(_resource);</p>
			<p class="snippet">      }</p>
			<p class="snippet">    }</p>
			<p class="snippet">  private:</p>
			<p class="snippet">    Resource _resource;</p>
			<p class="snippet">}</p>
			<p>The move-constructor of the <strong class="inline">WrongMove</strong> class will release the resource twice:</p>
			<p class="snippet">{</p>
			<p class="snippet">  WrongMove first;</p>
			<p class="snippet">  // Acquires the resource</p>
			<p class="snippet">  {</p>
			<p class="snippet">  /* Call the move constructor: we copy the resource to second, but we are not resetting it in first */</p>
			<p class="snippet">    WrongMove second(std::move(first)); </p>
			<p class="snippet">  }</p>
			<p class="snippet">  /* Second is destroyed: second._resource is released here. Since we copied the resource, now first._resource has been released as well. */</p>
			<p class="snippet">}</p>
			<p class="snippet">// First is destroyed: the same resource is released again! Error!</p>
			<p>Instead, the move constructor should have reset the <strong class="inline">_resource</strong> member of other, so that the destructor would not call <strong class="inline">release_resource</strong> again:</p>
			<p class="snippet">WrongMove(WrongMove&amp;&amp; other) {</p>
			<p class="snippet">  _resource = other._resource;</p>
			<p class="snippet">  other._resource = resetted_resource();</p>
			<p class="snippet">}</p>
			<p>The move constructor and move assignment operator can be implicitly generated by the compiler if no user-defined ones are provided and there are no user-declared destructors, copy constructors, or copy or move assignment operators:</p>
			<p class="snippet">struct MovableClass {</p>
			<p class="snippet">  MovableClass(MovableClass&amp;&amp; other) {</p>
			<p class="snippet">    std::cout &lt;&lt; "Move construct" &lt;&lt; std::endl;</p>
			<p class="snippet">  }</p>
			<p class="snippet">  MovableClass&amp; operator=(MovableClass&amp;&amp; other) {</p>
			<p class="snippet">    std::cout &lt;&lt; "Move assign" &lt;&lt; std::endl;</p>
			<p class="snippet">  }</p>
			<p class="snippet">};</p>
			<p class="snippet">MovableClass first;</p>
			<p class="snippet">// Move construct</p>
			<p class="snippet">MovableClass second = std::move(first);</p>
			<p class="snippet">// Or: MovableClass second(std::move(first));</p>
			<p class="snippet">MovableClass third;</p>
			<p class="snippet">// Move assignment</p>
			<p class="snippet">second = std::move(third);</p>
			<h3 id="_idParaDest-113"><a id="_idTextAnchor121"/>Preventing Implicit Constructors and Assignment Operators</h3>
			<p>The compiler will implicitly generate the copy constructor, copy assignment, move constructor, and move assignment if our class respects all the required conditions.</p>
			<p>For cases in which our class should not be copied or moved, we can prevent that.</p>
			<p>To prevent the generation of implicit constructors and operators, we can write the declaration of the constructor or operator and add <strong class="inline">= delete</strong>; at the end of the declaration.</p>
			<p>Let's examine the following example:</p>
			<p class="snippet">class Rectangle {</p>
			<p class="snippet">  int length;</p>
			<p class="snippet">  int width;</p>
			<p class="snippet">  // Prevent generating the implicit move constructor</p>
			<p class="snippet">  Rectangle(Rectangle&amp;&amp; other) = delete;</p>
			<p class="snippet">  // Prevent generating the implicit move assignment</p>
			<p class="snippet">  Rectangle&amp; operator=(Rectangle&amp;&amp; other) = delete;</p>
			<p class="snippet">};</p>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor122"/>Operator Overloading</h2>
			<p>C++ classes represent user-defined types. So, the need arises to be able to operate with these types in a different way. Some operator functions may have a different meaning when operating on different types. <strong class="keyword">Operator overloading</strong> lets you define the meaning of an operator when applied to a class type object.</p>
			<p>For example, the <strong class="inline">+</strong> operator applied to numerical types is different than when it is applied to the following <strong class="inline">Point</strong> class, which is constituted of coordinates. The language cannot specify what the <strong class="inline">+</strong> operator should do for user-defined types such as <strong class="inline">Point</strong>, as it is not in control of such types and does not know what the expected behavior is. Because of that, the language does not define the operators for user-defined types.</p>
			<p>However, C++ allows the user to specify the behavior of most operators for user-defined types, including classes.</p>
			<p>Here is an example of the <strong class="inline">+</strong> operator, defined for the <strong class="inline">Point</strong> class:</p>
			<p class="snippet">class Point</p>
			<p class="snippet">{</p>
			<p class="snippet">  Point operator+(const Point &amp;other) </p>
			<p class="snippet">  {</p>
			<p class="snippet">    Point new_point;</p>
			<p class="snippet">    new_point.x = x + other.x; </p>
			<p class="snippet">    new_point.y = y + other.y;</p>
			<p class="snippet">    return new_point;</p>
			<p class="snippet">  }</p>
			<p class="snippet">  private:</p>
			<p class="snippet">    int x;</p>
			<p class="snippet">    int y;</p>
			<p class="snippet">}</p>
			<p>Here is a list of all the operators that can and cannot be overloaded:</p>
			<ul>
				<li>The following are the operators that can be overloaded:</li>
			</ul>
			<div>
				<div class="IMG---Figure" id="_idContainer034">
					<img alt="Figure 3.4: Operators that can be overloaded" src="image/C11557_03_04.jpg"/>
				</div>
			</div>
			<h6>Figure 3.4: Operators that can be overloaded</h6>
			<ul>
				<li>The following are the operators that cannot be overloaded:</li>
			</ul>
			<div>
				<div class="IMG---Figure" id="_idContainer035">
					<img alt="Figure 3.5: Operators that cannot be overloaded" src="image/C11557_03_05.jpg"/>
				</div>
			</div>
			<h6>Figure 3.5: Operators that cannot be overloaded</h6>
			<p>Operators that expect two operands are called <strong class="keyword">binary operators</strong>. Examples are <strong class="inline">+</strong>, <strong class="inline">-</strong>, <strong class="inline">*</strong>, and <strong class="inline">/</strong>.</p>
			<p>A method overloading a binary operator needs to accept a single parameter. When the compiler encounters the use of the operator, it will call the method on the variable on the left-hand side of the operator, while the variable on the right-hand side will be passed as parameter to the method.</p>
			<p>We saw in the previous example that <strong class="inline">Point</strong> defines the <strong class="inline">+</strong> operator, which takes a parameter. When using the addition operation on a <strong class="inline">Point</strong>, the code would look like this:</p>
			<p class="snippet">Point first;</p>
			<p class="snippet">Point second;</p>
			<p class="snippet">Point sum = first + second;</p>
			<p>The last line from the code example is equivalent to writing the following:</p>
			<p class="snippet">Point sum = first.operator+(second);</p>
			<p>The compiler automatically rewrites the first expression to the second one.</p>
			<p>Operators that expect only one operand are called <strong class="keyword">unary operators</strong>. Examples are <strong class="inline">--</strong>, <strong class="inline">++</strong>, and <strong class="inline">!</strong>.</p>
			<p>A method overloading a unary operator must not accept any parameters. When the compiler encounters the use of the operator, it will call the method on the variable to which the operator is assigned.</p>
			<p>As an example, let's say we are given an object that's defined as follows:</p>
			<p class="snippet">class ClassOverloadingNotOperator {</p>
			<p class="snippet">  public:</p>
			<p class="snippet">    bool condition = false;</p>
			<p class="snippet">    </p>
			<p class="snippet">    ClassOverloadingNotOperator&amp; operator!() {</p>
			<p class="snippet">      condition = !condition;</p>
			<p class="snippet">    }</p>
			<p class="snippet">};</p>
			<p>We would write the following:</p>
			<p class="snippet">ClassOverloadingNotOperator object;</p>
			<p class="snippet">!object;</p>
			<p>The code is therefore rewritten as follows:</p>
			<p class="snippet">ClassOverloadingNotOperator object;</p>
			<p class="snippet">object.operator!();</p>
			<h4>Note</h4>
			<p class="callout">Operator overloading is possible in two ways: either as a member function or as a non-member function. The two end up producing the same effect.</p>
			<h3 id="_idParaDest-115"><a id="_idTextAnchor123"/>Activity 11: Ordering Point Objects</h3>
			<p>In the 2D map application, we want to be able to display the locations that have been saved by the user in order: from South-West to North-East. To be able to show the locations in order, we need to be able to sort the location points representing the locations in such an order.</p>
			<p>Remember that the <strong class="inline">x</strong> coordinate represents the location along the West-East axis and the <strong class="inline">y</strong> coordinate represents the location along the North-South axis.</p>
			<p>In a real-life scenario, to compare two points, we need to compare their <strong class="inline">x</strong> and <strong class="inline">y</strong> coordinates. To do so in code, we need to overload the <strong class="inline">&lt;</strong> operator for the <strong class="inline">Point</strong> class. This new function we're defining returns a <strong class="inline">bool</strong>, either <strong class="inline">true</strong> or <strong class="inline">false</strong>, according to the order of <strong class="inline">p_1</strong> and <strong class="inline">p_2</strong>.</p>
			<p>The <strong class="inline">p_1</strong> point comes before than <strong class="inline">p_2</strong> in the order if the <strong class="inline">x</strong> coordinate of <strong class="inline">p_1</strong> is less than the <strong class="inline">x</strong> coordinate of <strong class="inline">p_2</strong>. If they are equal, then we need to compare their <strong class="inline">y</strong> coordinates.</p>
			<p>Let's perform the following steps:</p>
			<ol>
				<li value="1">We need to add an overload for the <strong class="inline">&lt;</strong> operator to the <strong class="inline">Point</strong> class that we previously defined, which takes another object of type <strong class="inline">Point</strong> as an argument and returns a <strong class="inline">bool</strong> indicating whether the object is less than the one provided as a parameter, using the previous definition for how to compare two points:</li>
				<li>At this point, we are able to compare two <strong class="inline">Point</strong> objects:</li>
				<li>Since, in our example, <strong class="inline">p_1.x</strong> is initialized to <strong class="inline">1</strong> and <strong class="inline">p_2.x</strong> to <strong class="inline">2</strong>, the result of the comparison will be <strong class="inline">true</strong>, which indicates that <strong class="inline">p_1</strong> comes earlier than <strong class="inline">p_2</strong> in the order.<h4>Note</h4><p class="callout">The solution for this activity can be found on page 293.</p></li>
			</ol>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor124"/>Introducing Functors</h2>
			<p>A <strong class="keyword">Functor</strong> (function object) is similar to a class. The class that overloads the <strong class="inline">operator()</strong> function is also known as the <strong class="bold">function call operator</strong>.</p>
			<p>The syntax that's used to define a <strong class="inline">functor</strong> is as follows:</p>
			<p class="snippet">class class_name {</p>
			<p class="snippet">  public:</p>
			<p class="snippet">    type operator()(type arg) {} </p>
			<p class="snippet">};</p>
			<p>The function call operator has a return type and takes any number of arguments of any type. To invoke the call operator of an object, we can write the name of the object, followed by parentheses containing the arguments to pass to the operator. You can imagine that an object that provides a call operator can be used in the same way as you would use a function. Here's an example of a <strong class="inline">functor</strong>:</p>
			<p class="snippet">class_name obj;</p>
			<p class="snippet">type t;</p>
			<p class="snippet">/* obj is an instance of a class with the call operator: it can be used as if it was a function */</p>
			<p class="snippet">obj(t);</p>
			<p>They are particularly useful in places where you can pass a function object to an algorithmic template that accepts an object with <strong class="inline">operator()</strong> defined. This exploits code reusability and testability. We will see more on this in chapter 5 when we talk about <strong class="bold">lambda</strong>.</p>
			<p>The following is a simple example of a <strong class="inline">functor</strong> that prints a string before appending a new line at the end of it:</p>
			<p class="snippet">class logger{</p>
			<p class="snippet">  public:</p>
			<p class="snippet">    void operator()(const std::string &amp;s) {</p>
			<p class="snippet">       std::cout &lt;&lt; s &lt;&lt; std::endl;</p>
			<p class="snippet">    }</p>
			<p class="snippet">};</p>
			<p class="snippet">logger log;</p>
			<p class="snippet">log ("Hello world!");</p>
			<p class="snippet">log("Keep learning C++");</p>
			<h3 id="_idParaDest-117"><a id="_idTextAnchor125"/>Activity 12: Implementing Functors</h3>
			<p>Write a function object that takes a number when constructed and defines an operator call that takes another number and returns the sum of the two. </p>
			<p>Let's perform the following steps to achieve the desired output:</p>
			<ol>
				<li value="1">Define a class by the name of <strong class="inline">AddX</strong>, constituted by a <strong class="inline">private</strong> data member of type <strong class="inline">int</strong>, and a constructor that is used to initialize it.</li>
				<li>Extend it with the call operator, <strong class="inline">operator()</strong>, which takes an <strong class="inline">int</strong> as a parameter and returns an <strong class="inline">int</strong>. The implementation in the function body should return the addition of the previously defined <strong class="inline">x</strong> value and the parameter of the function named <strong class="inline">y</strong>.</li>
				<li>Instantiate an object of the class we just defined and invoke the calling operator:<p class="snippet">class AddX {</p><p class="snippet">   public:</p><p class="snippet">      explicit AddX(int v) : value(v) {}</p><p class="snippet">      int operator()(int other_value) {</p><p class="snippet">   Indent it to the right, same as above</p><p class="snippet">}</p><p class="snippet">   private:</p><p class="snippet">     int value;</p><p class="snippet">};</p><p class="snippet">AddX add_five(5);</p><p class="snippet">std::cout &lt;&lt; add_five(4) &lt;&lt; std::endl; // prints 9</p><h4>Note</h4><p class="callout">The solution for this activity can be found on page 294.</p></li>
			</ol>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor126"/>Summary</h2>
			<p>In this chapter, we saw how the concept of classes can be used in C++. We started by delineating the advantages of using classes, describing how they can help us to create powerful abstractions.</p>
			<p>We outlined the access modifiers a class can use to control who has access to class fields and methods.</p>
			<p>We continued by exploring the conceptual differences between a class and its instances, along with the implications this has when implementing static fields and static methods.</p>
			<p>We saw how constructors are used to initialize classes and their members, while destructors are used to clean up the resources that are managed by a class.</p>
			<p>We then explored how constructors and destructors can be combined to implement the fundamental paradigm C++ is famous for: RAII. We showed how RAII makes it easy to create classes that handle resources and make programs safer and easier to work with.</p>
			<p>Finally, we introduced the concept of operator overloading and how it can be used to create classes that are as easy to use as built-in types.</p>
			<p>In the next chapter, we'll focus on templates. We'll primarily look at how to implement template functions and classes, and write code that works for multiple types.</p>
		</div>
</body></html>