<html><head></head><body>
        

                            
                    <h1 class="header-title">Interacting with JavaScript and Debugging</h1>
                
            
            
                
<p class="mce-root">There's a great deal of exciting features and proposals in the works for WebAssembly. However, at the time of writing this book, the feature set is rather limited. As it stands, you can benefit greatly from using some of the features Emscripten provides. The process for interacting with C/C++ from JavaScript (and vice versa) will differ depending on whether you decide to use Emscripten.</p>
<p class="mce-root">In this chapter, we will cover how to utilize JavaScript functions with C/C++ code as well as how to interact with the compiled output of your C/C++ code from JavaScript. We'll also describe how Emscripten's <em>glue</em> code affects the ways a Wasm instance is utilized and how to debug compiled code in the browser.</p>
<p class="mce-root">Our goal for this chapter is to understand the following:</p>
<ul>
<li>The differences between Emscripten's <kbd>Module</kbd> and the browser's <kbd>WebAssembly</kbd> object</li>
<li>How to call compiled C/C++ functions from your JavaScript code</li>
<li>How to call JavaScript functions from your C/C++ code</li>
<li>Special considerations to be aware of when working with C++</li>
<li>Techniques for debugging compiled output in the browser</li>
</ul>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">The Emscripten module versus the WebAssembly object</h1>
                
            
            
                
<p>In the previous chapter, we briefly covered Emscripten's <kbd>Module</kbd> object and how to load it in the browser. The <kbd>Module</kbd> object provides several convenient methods and differs significantly from the browser's <kbd>WebAssembly</kbd> object. In this section, we're going to review Emscripten's <kbd>Module</kbd> object in greater detail. We'll also discuss the difference between Emscripten's <kbd>Module</kbd> and the objects described in WebAssembly's <em>JavaScript API</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">What is the Emscripten module?</h1>
                
            
            
                
<p>Emscripten's official site provides the following definition for the <kbd>Module</kbd> object:</p>
<p>"Module is a global JavaScript object with attributes that Emscripten-generated code calls at various points in its execution."</p>
<p>Not only is the loading procedure different from WebAssembly's <kbd>compile</kbd> and <kbd>instantiate</kbd> functions, but the <kbd>Module</kbd> provides some helpful functionality out of the box that would otherwise require a custom implementation in WebAssembly. The <kbd>Module</kbd> is available in a global scope (<kbd>window.Module</kbd>) after fetching and loading Emscripten's JavaScript <em>glue</em> code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Default methods in the glue code</h1>
                
            
            
                
<p>Emscripten's <kbd>Module</kbd> object provides some default methods and properties to aid in debugging and ensuring the successful execution of your compiled code. You can utilize the <kbd>preRun</kbd> and <kbd>postRun</kbd> properties to execute JavaScript code before or after the Module's <kbd>run()</kbd> function is called, or pipe the output of the <kbd>print()</kbd> and <kbd>printErr()</kbd> functions to an HTML element on the page. We'll utilize some of these methods later in this book. You can read more about them at <a href="https://kripken.github.io/emscripten-site/docs/api_reference/module.html">https://kripken.github.io/emscripten-site/docs/api_reference/module.html</a>.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Differences with the WebAssembly object</h1>
                
            
            
                
<p>We covered the browser's WebAssembly object and the corresponding loading procedures in <a href="51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml">Chapter 5</a>, <em>Creating and Loading a WebAssembly Module</em>. WebAssembly's JavaScript and Web APIs define the objects and methods available in the browser's <kbd>window.WebAssembly</kbd> object. Emscripten's <kbd>Module</kbd> can be seen as a combination of WebAssembly's <kbd>Module</kbd> and <kbd>Instance</kbd> objects, which are present in the <kbd>result</kbd> object that WebAssembly's instantiation function returns. By passing the <kbd>-s MODULARIZE=1</kbd> flag to the <kbd>emcc</kbd> command, we're able to replicate WebAssembly's instantiation method (to a degree). We will examine the differences between Emscripten's <kbd>Module</kbd> and the browser's <kbd>WebAssembly</kbd> object in greater detail as we evaluate the methods of integrating JavaScript and C/C++ in the upcoming sections.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Calling compiled C/C++ functions from JavaScript</h1>
                
            
            
                
<p>Calling functions from a Wasm instance is a relatively straightforward process with or without Emscripten's glue code. Utilizing Emscripten's API affords a wider range of functionality and integration at the expense of including the glue code alongside the <kbd>.wasm</kbd> file. In this section, we will review the means of interacting with the compiled Wasm instance through JavaScript and the added tooling Emscripten provides.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Calling functions from a Module </h1>
                
            
            
                
<p>Emscripten provides two functions for calling compiled C/C++ functions from JavaScript: <kbd>ccall()</kbd> and <kbd>cwrap()</kbd>. Both of these functions are present in the <kbd>Module</kbd> object. Deciding which one to use is contingent on whether the function will be called more than once. The content in the following sections was taken from Emscripten's API reference documentation for <kbd>preamble.js</kbd>, which can be viewed at <a href="http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html">http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html</a>.</p>
<p>You don't need to prefix function calls with <kbd>_</kbd> when using <kbd>ccall()</kbd> or <kbd>cwrap()</kbd> – just use the name specified in the C/C++ file.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Module.ccall()</h1>
                
            
            
                
<p><kbd>Module.ccall()</kbd> calls a compiled C function from JavaScript and returns the result of that function. The function signature for <kbd>Module.ccall()</kbd> is as follows:</p>
<pre>ccall(ident, returnType, argTypes, args, opts)</pre>
<p>You must specify a type name for the <kbd>returnType</kbd> and <kbd>argTypes</kbd> parameters. The possible types are <kbd>"number"</kbd>, <kbd>"string"</kbd>, <kbd>"array"</kbd>, and <kbd>"boolean"</kbd>, which correspond to the appropriate JavaScript types. You cannot specify <kbd>"array"</kbd> for the <kbd>returnType</kbd> parameter because there is no way to know the length of the array. If the function doesn't return anything, you can specify <kbd>null</kbd> for the <kbd>returnType</kbd> (note the absence of quotation marks).</p>
<p>The <kbd>opts</kbd> parameter is an optional options object that can contain a Boolean property named <kbd>async</kbd>. Specifying a value of <kbd>true</kbd> for this property implies that the call will perform an async operation. We won't use this parameter for any of our examples, but if you wish to learn more about it, the documentation is available at <a href="http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html#calling-compiled-c-functions-from-javascript">http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html#calling-compiled-c-functions-from-javascript</a>.</p>
<p>Let's look at an example of <kbd>ccall()</kbd>. The following code, taken from the Emscripten site, demonstrates how to call a function named <kbd>c_add()</kbd> from the compiled output of a C file:</p>
<pre>// Call C from JavaScript<br/>var result = Module.ccall(<br/>  'c_add', // name of C function<br/>  'number', // return type<br/>  ['number', 'number'], // argument types<br/>  [10, 20] // arguments<br/>);<br/><br/>// result is 30</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Module.cwrap()</h1>
                
            
            
                
<p><kbd>Module.cwrap()</kbd> is similar to <kbd>ccall()</kbd> in that it calls a compiled C function. However, rather than returning a value, it returns a JavaScript function that can be reused as many times as needed. The function signature for <kbd>Module.cwrap()</kbd> is as follows:</p>
<pre>cwrap(ident, returnType, argTypes)</pre>
<p class="mce-root"/>
<p>Just as with <kbd>ccall()</kbd>, you can specify string values that represent types for the <kbd>returnType</kbd> and <kbd>argTypes</kbd> parameters. You cannot use the <kbd>"array"</kbd> type in <kbd>argTypes</kbd> because there is no way to know the length of the array when the function is called. For a function that doesn't return a value, use <kbd>null</kbd> (with no quotation marks) for the <kbd>returnType</kbd> parameter.</p>
<p>The following code, taken from the Emscripten site, demonstrates the use of <kbd>cwrap()</kbd> to create a reusable function:</p>
<pre>// Call C from JavaScript<br/>var c_javascript_add = Module.cwrap(<br/>  'c_add', // name of C function<br/>  'number', // return type<br/>  ['number', 'number'] // argument types<br/>);<br/><br/>// Call c_javascript_add normally<br/>console.log(c_javascript_add(10, 20)); // 30<br/>console.log(c_javascript_add(20, 30)); // 50</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">C++ and name mangling</h1>
                
            
            
                
<p>You may have noticed that the descriptions of <kbd>ccall()</kbd> and <kbd>cwrap()</kbd> specified that both are used to call a compiled C function. The omission of C++ was intentional because an additional step is needed to call functions from a C++ file. C++ supports function overloading, which means that you can use the same function name multiple times, but pass different arguments to each one to get a different result. Here's an example of some code that uses function overloading:</p>
<pre>int addNumbers(int num1, int num2) {<br/>    return num1 + num2;<br/>}<br/><br/>int addNumbers(int num1, int num2, int num3) {<br/>    return num1 + num2 + num3;<br/>}<br/><br/>int addNumbers(int num1, int num2, int num3, int num4) {<br/>    return num1 + num2 + num3 + num4;<br/>}<br/><br/>// The function will return a value based on how many<br/>// arguments you pass it:<br/>int getSumOfTwoNumbers = addNumbers(1, 2);<br/>// returns 3<br/><br/>int getSumOfThreeNumbers = addNumbers(1, 2, 3);<br/>// returns 6<br/><br/>int getSumOfFourNumbers = addNumbers(1, 2, 3, 4);<br/>// returns 10</pre>
<p>The compiler needs to differentiate between these functions. If it used the name <kbd>addNumbers</kbd> and you tried calling the function in one place with two arguments and another with three, it would fail. To call the function by name in your compiled Wasm, you need to wrap the function in an <kbd>extern</kbd> block. One implication of wrapping the function is that you would have to explicitly define functions for each condition. The following code snippet demonstrates how to implement the previous functions without name mangling:</p>
<pre>extern "C" {<br/>int addTwoNumbers(int num1, int num2) {<br/>    return num1 + num2;<br/>}<br/><br/>int addThreeNumbers(int num1, int num2, int num3) {<br/>    return num1 + num2 + num3;<br/>}<br/><br/>int addFourNumbers(int num1, int num2, int num3, int num4) {<br/>    return num1 + num2 + num3 + num4;<br/>}<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Calling functions from a WebAssembly instance</h1>
                
            
            
                
<p>We demonstrated how to call a function in a Wasm instance from JavaScript in the previous chapter, but that was assuming you instantiated a module in the browser with no glue code. Emscripten provides the ability to call functions from the Wasm instance as well. After a module is instantiated, you call functions by invoking them from the <kbd>instance.exports</kbd> object, which is accessible from the result of the resolved <kbd>Promise</kbd>. MDN's documentation provides the following function signature for <kbd>WebAssembly.instantiateStreaming</kbd>:</p>
<pre>Promise&lt;ResultObject&gt; WebAssembly.instantiateStreaming(source, importObject);</pre>
<p>You may need to use the <kbd>WebAssembly.instantiate()</kbd> method, depending on your browser. Chrome currently supports <kbd>WebAssembly.instantiateStreaming()</kbd>, but if you encounter an error when attempting to load your module, use the <kbd>WebAssembly.instantiate()</kbd> method instead.</p>
<p>The <kbd>ResultObject</kbd> contains the <kbd>instance</kbd> object that we need to reference to call exported functions from the module. Here's some code that calls a function named <kbd>_addTwoNumbers</kbd> from the compiled Wasm instance:</p>
<pre>// Assume the importObj is already defined.<br/>WebAssembly.instantiateStreaming(<br/>  fetch('simple.wasm'),<br/>  importObj<br/>)<br/>  .then(result =&gt; {<br/>    const addedNumbers = result.instance.exports._addTwoNumbers(1, 2);<br/>    // result is 3<br/>  });</pre>
<p>Emscripten provides a way to perform function calls in much the same way, albeit in a slightly different implementation. If you use the Promise-like API, you can access the function from an <kbd>asm</kbd> object that the promise of the <kbd>Module()</kbd> resolves with. The following example demonstrates how to utilize this functionality:</p>
<pre>// Using Emscripten's Module<br/>Module()<br/>  .then(result =&gt; {<br/>    // "asm" is essentially "instance"<br/>    const exports = result.asm;<br/>    const addedNumbers = exports._addTwoNumbers(1, 2);<br/>    // result is 3<br/>  });</pre>
<p>Replicating the WebAssembly's Web API syntax with Emscripten simplifies any future refactoring. You can easily replace <kbd>Module()</kbd> with WebAssembly's <kbd>instantiateStreaming()</kbd> method and <kbd>result.asm</kbd> with <kbd>result.instance</kbd> in the future if you decide to use WebAssembly's Web API.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Calling JavaScript functions from C/C++</h1>
                
            
            
                
<p>Accessing JavaScript's functionality from C/C++ code allows for added flexibility when working with WebAssembly. The methodologies and means of utilizing JavaScript differ considerably between Emscripten's glue code and Wasm-only implementations. In this section, we will cover the various ways you can integrate JavaScript into your C/C++ code with and without Emscripten.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Interacting with JavaScript using glue code</h1>
                
            
            
                
<p>Emscripten provides several techniques for integrating JavaScript with your C/C++ code. The techniques available differ in implementation and complexity, and some only apply to specific execution environments (for example, the browser). Deciding which one to use is contingent on your specific use case. We'll focus on the <kbd>emscripten_run_script()</kbd> function and inlining JavaScript with <kbd>EM_*</kbd> wrappers. The content in the following sections was taken from the <em>Interacting with Code</em> section of Emscripten's site, which can be viewed at <a href="https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/Interacting-with-code.html#interacting-with-code">https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/Interacting-with-code.html#interacting-with-code</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Executing strings with emscripten_run_script()</h1>
                
            
            
                
<p>The Emscripten site describes the <kbd>emscripten_run_script()</kbd> function as the most direct, but slightly slower approach for calling JavaScript for C/C++. It's a technique that is well suited for a single line of JavaScript code and can be useful for debugging. The documentation states that it effectively runs the code using <kbd>eval()</kbd>, which is a JavaScript function that executes a string as code. The following code taken from the Emscripten site demonstrates the use of <kbd>emscripten_run_script()</kbd> to call the browser's <kbd>alert()</kbd> function with the text <kbd>'hi'</kbd>:</p>
<pre>emscripten_run_script("alert('hi')");</pre>
<p>For more complex use cases where performance is a factor, using <em>inline JavaScript</em> provides a better solution.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Executing inline JavaScript with EM_ASM()</h1>
                
            
            
                
<p>You can wrap JavaScript code inside your C/C++ file with <kbd>EM_ASM()</kbd> and it will execute when the compiled code is run in the browser. The following code demonstrates basic usage:</p>
<pre>#include &lt;emscripten.h&gt;<br/><br/>int main() {<br/>    EM_ASM(<br/>        console.log('This is some JS code.');<br/>    );<br/>    return 0;<br/>}</pre>
<p>The JavaScript code is executed immediately and cannot be reused within the C/C++ file in which it is contained. Arguments can be passed into the JavaScript code block where they arrive as variables <kbd>$0</kbd>, <kbd>$1</kbd>, and so on. These arguments can either be of type <kbd>int32_t</kbd> or <kbd>double</kbd>. The following code snippet, taken from the Emscripten site, demonstrates how to utilize arguments in an <kbd>EM_ASM()</kbd> block:</p>
<pre>EM_ASM({<br/>    console.log('I received: ' + [ $0, $1 ]);<br/>}, 100, 35.5);</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Reusing inline JavaScript with EM_JS()</h1>
                
            
            
                
<p>If you need a reusable function within your C/C++ file, you can wrap JavaScript code within an <kbd>EM_JS()</kbd> block and execute it like a normal C/C++ function. The definition for <kbd>EM_JS()</kbd> is described in the following code snippet:</p>
<pre>EM_JS(return_type, function_name, arguments, code)</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The <kbd>return_type</kbd> parameter represents the C type that corresponds with the JavaScript code's output (for example, <kbd>int</kbd> or <kbd>float</kbd>). If nothing is returned from the JavaScript code, specify <kbd>void</kbd> for the <kbd>return_type</kbd>. The next parameter, <kbd>function_name</kbd>, represents the name to use when calling the JavaScript code from other locations in the C/C++ file. The <kbd>arguments</kbd> parameter is used to define arguments that can be passed into the JavaScript code from the C calling function. The <kbd>code</kbd> parameter is the JavaScript code that's wrapped in curly braces. The following code snippet, taken from the Emscripten site, demonstrates the use of <kbd>EM_JS()</kbd> in a C file:</p>
<pre>#include &lt;emscripten.h&gt;<br/><br/>EM_JS(void, take_args, (int x, float y), {<br/>    console.log(`I received ${x} and ${y}`);<br/>});<br/><br/>int main() {<br/>    take_args(100, 35.5);<br/>    return 0;<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Examples of using glue code</h1>
                
            
            
                
<p>Let's write some code that utilizes all of these features. In this section, we will modify the code we used in the <em>Compiling C without the glue code</em> and <em>Fetching and instantiating a Wasm file</em> sections of <a href="51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml">Chapter 5</a>, <em>Creating and Loading a WebAssembly Module</em>. This was the code that displayed a moving blue rectangle on a red canvas and could be paused and restarted with the click of a button. The code for this section is located in the <kbd>/chapter-06-interact-with-js</kbd> folder in the <kbd>learn-webassembly</kbd> repository. Let's start by updating the C code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The C code</h1>
                
            
            
                
<p>Create a new folder in your <kbd>/book-examples</kbd> folder named <kbd>/chapter-06-interact-with-js</kbd>. Create a new file in the <kbd>/chapter-06-interact-with-js</kbd> folder named <kbd>js-with-glue.c</kbd> and populate it with the following contents:</p>
<pre>/*<br/> * This file interacts with the canvas through imported functions.<br/> * It moves a blue rectangle diagonally across the canvas<br/> * (mimics the SDL example).<br/> */<br/>#include &lt;emscripten.h&gt;<br/>#include &lt;stdbool.h&gt;<br/><br/>#define BOUNDS 255<br/>#define RECT_SIDE 50<br/>#define BOUNCE_POINT (BOUNDS - RECT_SIDE)<br/><br/>bool isRunning = true;<br/><br/>typedef struct Rect {<br/>  int x;<br/>  int y;<br/>  char direction;<br/>} Rect;<br/><br/>struct Rect rect;<br/><br/>/*<br/> * Updates the rectangle location by 1px in the x and y in a<br/> * direction based on its current position.<br/> */<br/>void updateRectLocation() {<br/>    // Since we want the rectangle to "bump" into the edge of the<br/>    // canvas, we need to determine when the right edge of the<br/>    // rectangle encounters the bounds of the canvas, which is why<br/>    // we're using the canvas width - rectangle width:<br/>    if (rect.x == BOUNCE_POINT) rect.direction = 'L';<br/><br/>    // As soon as the rectangle "bumps" into the left side of the<br/>    // canvas, it should change direction again.<br/>    if (rect.x == 0) rect.direction = 'R';<br/><br/>    // If the direction has changed based on the x and y<br/>    // coordinates, ensure the x and y points update<br/>    // accordingly:<br/>    int incrementer = 1;<br/>    if (rect.direction == 'L') incrementer = -1;<br/>    rect.x = rect.x + incrementer;<br/>    rect.y = rect.y + incrementer;<br/>}<br/><br/>EM_JS(void, js_clear_rect, (), {<br/>    // Clear the rectangle to ensure there's no color where it<br/>    // was before:<br/>    var canvas = document.querySelector('#myCanvas');<br/>    var ctx = canvas.getContext('2d');<br/>    ctx.fillStyle = '#ff0000';<br/>    ctx.fillRect(0, 0, 255, 255);<br/>});<br/><br/>EM_JS(void, js_fill_rect, (int x, int y, int width, int height), {<br/>    // Fill the rectangle with blue in the specified coordinates:<br/>    var canvas = document.querySelector('#myCanvas');<br/>    var ctx = canvas.getContext('2d');<br/>    ctx.fillStyle = '#0000ff';<br/>    ctx.fillRect(x, y, width, height);<br/>});<br/><br/>/*<br/> * Clear the existing rectangle element from the canvas and draw a<br/> * new one in the updated location.<br/> */<br/>EMSCRIPTEN_KEEPALIVE<br/>void moveRect() {<br/>    // Event though the js_clear_rect doesn't have any<br/>    // parameters, we pass 0 in to prevent a compiler warning:<br/>    js_clear_rect(0);<br/>    updateRectLocation();<br/>    js_fill_rect(rect.x, rect.y, RECT_SIDE, RECT_SIDE);<br/>}<br/><br/>EMSCRIPTEN_KEEPALIVE<br/>bool getIsRunning() {<br/>    return isRunning;<br/>}<br/><br/>EMSCRIPTEN_KEEPALIVE<br/>void setIsRunning(bool newIsRunning) {<br/>    isRunning = newIsRunning;<br/>    EM_ASM({<br/>        // isRunning is either 0 or 1, but in JavaScript, 0<br/>        // is "falsy", so we can set the status text based<br/>        // without explicitly checking if the value is 0 or 1:<br/>        var newStatus = $0 ? 'Running' : 'Paused';<br/>        document.querySelector('#runStatus').innerHTML = newStatus;<br/>    }, isRunning);<br/>}<br/><br/>EMSCRIPTEN_KEEPALIVE<br/>void init() {<br/>    emscripten_run_script("console.log('Initializing rectangle...')");<br/>    rect.x = 0;<br/>    rect.y = 0;<br/>    rect.direction = 'R';<br/>    setIsRunning(true);<br/>    emscripten_run_script("console.log('Rectangle should be moving!')");<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root">You can see that we used all three of the JavaScript integrations that Emscripten provides. There are two functions, <kbd>js_clear_rect()</kbd> and <kbd>js_fill_rect()</kbd>, that are defined in <kbd>EM_JS()</kbd> blocks that take the place of the imported functions from the original example. The <kbd>EM_ASM()</kbd> block within the <kbd>setIsRunning()</kbd> function updates the text of a new status element we'll add to the HTML code. The <kbd>emscripten_run_script()</kbd> functions simply log out some status messages. We need to specify <kbd>EMSCRIPTEN_KEEPALIVE</kbd> above the functions we're planning to utilize outside of the module. If you don't specify this, the compiler will treat the functions as dead code and remove them.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The HTML code</h1>
                
            
            
                
<p class="mce-root">Let's create a file named <kbd>js-with-glue.html</kbd> in the <kbd>/chapter-06-interact-with-js</kbd> folder and populate it with the following contents:</p>
<pre>&lt;!doctype html&gt;<br/>&lt;html lang="en-us"&gt;<br/>&lt;head&gt;<br/>  &lt;title&gt;Interact with JS using Glue Code&lt;/title&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>  &lt;h1&gt;Interact with JS using Glue Code&lt;/h1&gt;<br/>  &lt;canvas id="myCanvas" width="255" height="255"&gt;&lt;/canvas&gt;<br/>  &lt;div style="margin-top: 16px;"&gt;<br/>    &lt;button id="actionButton" style="width: 100px; height: 24px;"&gt;Pause&lt;/button&gt;<br/>    &lt;span style="width: 100px; margin-left: 8px;"&gt;Status:&lt;/span&gt;<br/>    &lt;span id="runStatus" style="width: 100px;"&gt;&lt;/span&gt;<br/>  &lt;/div&gt;<br/>  &lt;script type="application/javascript" src="img/js-with-glue.js"&gt;&lt;/script&gt;<br/>  &lt;script type="application/javascript"&gt;<br/>    Module()<br/>      .then(result =&gt; {<br/>        const m = result.asm;<br/>        m._init();<br/><br/>        // Move the rectangle by 1px in the x and y every 20 milliseconds:<br/>        const loopRectMotion = () =&gt; {<br/>          setTimeout(() =&gt; {<br/>            m._moveRect();<br/>            if (m._getIsRunning()) loopRectMotion();<br/>          }, 20)<br/>        };<br/><br/>        // Enable you to pause and resume the rectangle movement:<br/>        document.querySelector('#actionButton')<br/>          .addEventListener('click', event =&gt; {<br/>            const newIsRunning = !m._getIsRunning();<br/>            m._setIsRunning(newIsRunning);<br/>            event.target.innerHTML = newIsRunning ? 'Pause' : 'Start';<br/>            if (newIsRunning) loopRectMotion();<br/>          });<br/><br/>        loopRectMotion();<br/>      });<br/>  &lt;/script&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</pre>
<p class="mce-root">We added two <kbd>&lt;span&gt;</kbd> elements to display the status of the rectangle's movement, along with a corresponding label. We're using Emscripten's Promise-like API to load the module and reference the functions from the compiled code. We're no longer passing in the <kbd>_jsFillRect</kbd> and <kbd>_jsClearRect</kbd> functions to the module because we're handling that within the <kbd>js-with-glue.c</kbd> file.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Compiling and serving the result</h1>
                
            
            
                
<p class="mce-root">To compile the code, ensure that you're in the <kbd>/chapter-06-interact-with-js</kbd> folder and run the following command:</p>
<pre class="mce-root"><strong>emcc js-with-glue.c -O3 -s WASM=1 -s MODULARIZE=1 -o js-with-glue.js</strong></pre>
<p class="mce-root">Once complete, run the following command to start your local server:</p>
<pre class="mce-root"><strong>serve -l 8080</strong></pre>
<p class="mce-root">Open up a browser and navigate to <kbd>http://127.0.0.1:8080/js-with-glue.html</kbd>. You should see something like this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/72e12623-7f8d-4d6a-8661-1f13822c1ef5.png"/></p>
<p>Glue code running in the browser</p>
<p>If you press the Pause button, the caption on the button should change to Start, the text next to Status should change to Paused, and the rectangle should stop moving.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Interacting with JavaScript without glue code</h1>
                
            
            
                
<p>Utilizing JavaScript code in C/C++ files follows a different paradigm than the techniques used for Emscripten. Rather than writing JavaScript within the C/C++ files, you pass the functions into your WebAssembly instantiation code. In this section, we will describe this process in greater detail.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Passing JavaScript to C/C++ using the import object</h1>
                
            
            
                
<p>In order to utilize JavaScript's functionality in your C/C++ code, you need to add a function definition to the <kbd>importObj.env</kbd> argument that gets passed into WebAssembly's instantiation function. You can either define the function outside of the <kbd>importObj.env</kbd> or inline. The following code snippet demonstrates each option:</p>
<pre>// You can define the function inside of the env object:<br/>const env = {<br/>  // Make sure you prefix the function name with "_"!<br/>  _logValueToConsole: value =&gt; {<br/>    console.log(`'The value is ${value}'`);<br/>  }<br/>};<br/><br/>// Or define it outside of env and reference it within env:<br/>const logValueToConsole = value =&gt; {<br/>  console.log(`'The value is ${value}'`);<br/>};<br/><br/>const env = {<br/>  _logValueToConsole: logValueToConsole<br/>};</pre>
<p>Given the manual memory management and strict typing requirements of C, C++, and Rust, you're limited in what can be passed in and utilized in a Wasm module. JavaScript allows you to easily add, remove, and change the values of properties on an object over the course of code execution. You can even extend the language by adding functions to the <kbd>prototype</kbd> of a built-in language feature. C, C++, and Rust are much more restrictive, and it can be difficult to take full advantage of WebAssembly if you're not familiar with these languages.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Calling imported functions in C/C++</h1>
                
            
            
                
<p>You need to define the JavaScript function you passed into <kbd>importObj.env</kbd> within the C/C++ code that utilizes it. The function signature must match what you passed in. The following example demonstrates this in greater detail. Here's the JavaScript code that interacts with the compiled C file (<kbd>index.html</kbd>):</p>
<pre>// index.html &lt;script&gt; contents<br/>const env = {<br/>  _logAndMultiplyTwoNums: (num1, num2) =&gt; {<br/>    const result = num1 * num2;<br/>    console.log(result);<br/>    return result;<br/>  },<br/>};<br/><br/>loadWasm('main.wasm', { env })<br/>  .then(({ instance }) =&gt; {<br/>    const result = instance.exports._callMultiply(5.5, 10);<br/>    console.log(result);<br/>    // 55 is logged to the console twice<br/>  });</pre>
<p>This is the contents of <kbd>main.c</kbd>, which is compiled to <kbd>main.wasm</kbd> and used within <kbd>index.html</kbd>:</p>
<pre class="mce-root">// main.c (compiled to main.wasm)<br/>extern float logAndMultiplyTwoNums(float num1, float num2);<br/><br/>float callMultiply(float num1, float num2) {<br/>    return logAndMultiplyTwoNums(num1, num2);<br/>}</pre>
<p>You call the JavaScript function in your C/C++ the same way you'd call a normal C/C++ function. Although you prefix your function with a <kbd>_</kbd> when you pass it into the <kbd>importObj.env</kbd>, you don't need to include the prefix when defining it in the C/C++ file.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">An example without glue code</h1>
                
            
            
                
<p>The example code from the <em>Compiling C without the glue code</em> and <em>Fetching and instantiating a Wasm file</em> sections of <a href="51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml"/><a href="51201d69-0a8e-45f3-bb4f-03ded5bbeb6c.xhtml">Chapter 5</a>, <em>Creating and Loading a WebAssembly Module</em>, demonstrated how to integrate JavaScript in our C file without using Emscripten's glue code. In this section, we will modify the example code slightly and change the file type to C++.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The C++ code</h1>
                
            
            
                
<p>Create a file named <kbd>js-without-glue.cpp</kbd> in your <kbd>/chapter-06-interact-with-js</kbd> folder and populate it with the following contents:</p>
<pre>/*<br/> * This file interacts with the canvas through imported functions.<br/> * It moves a circle diagonally across the canvas.<br/> */<br/>#define BOUNDS 255<br/>#define CIRCLE_RADIUS 50<br/>#define BOUNCE_POINT (BOUNDS - CIRCLE_RADIUS)<br/><br/>bool isRunning = true;<br/><br/>typedef struct Circle {<br/>  int x;<br/>  int y;<br/>  char direction;<br/>} Circle;<br/><br/>struct Circle circle;<br/><br/>/*<br/> * Updates the circle location by 1px in the x and y in a<br/> * direction based on its current position.<br/> */<br/>void updateCircleLocation() {<br/>    // Since we want the circle to "bump" into the edge of the canvas,<br/>    // we need to determine when the right edge of the circle<br/>    // encounters the bounds of the canvas, which is why we're using<br/>    // the canvas width - circle width:<br/>    if (circle.x == BOUNCE_POINT) circle.direction = 'L';<br/><br/>    // As soon as the circle "bumps" into the left side of the<br/>    // canvas, it should change direction again.<br/>    if (circle.x == CIRCLE_RADIUS) circle.direction = 'R';<br/><br/>    // If the direction has changed based on the x and y<br/>    // coordinates, ensure the x and y points update accordingly:<br/>    int incrementer = 1;<br/>    if (circle.direction == 'L') incrementer = -1;<br/>    circle.x = circle.x + incrementer;<br/>    circle.y = circle.y - incrementer;<br/>}<br/><br/>// We need to wrap any imported or exported functions in an<br/>// extern block, otherwise the function names will be mangled.<br/>extern "C" {<br/>// These functions are passed in through the importObj.env object<br/>// and update the circle on the &lt;canvas&gt;:<br/>extern int jsClearCircle();<br/>extern int jsFillCircle(int x, int y, int radius);<br/><br/>/*<br/> * Clear the existing circle element from the canvas and draw a<br/> * new one in the updated location.<br/> */<br/>void moveCircle() {<br/>    jsClearCircle();<br/>    updateCircleLocation();<br/>    jsFillCircle(circle.x, circle.y, CIRCLE_RADIUS);<br/>}<br/><br/>bool getIsRunning() {<br/>    return isRunning;<br/>}<br/><br/>void setIsRunning(bool newIsRunning) {<br/>    isRunning = newIsRunning;<br/>}<br/><br/>void init() {<br/>    circle.x = 0;<br/>    circle.y = 255;<br/>    circle.direction = 'R';<br/>    setIsRunning(true);<br/>}<br/>}</pre>
<p class="mce-root">This code is similar to the previous example, but the shape and direction of the element on the canvas has changed. Now, the element is a circle that starts in the lower-left corner of the canvas and moves diagonally toward the upper-right.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The HTML code</h1>
                
            
            
                
<p class="mce-root">Next, create a file named <kbd>js-without-glue.html</kbd> in your <kbd>/chapter-06-interact-with-js</kbd> folder and populate it with the following contents:</p>
<pre>&lt;!doctype html&gt;<br/>&lt;html lang="en-us"&gt;<br/>&lt;head&gt;<br/>  &lt;title&gt;Interact with JS without Glue Code&lt;/title&gt;<br/>  &lt;script<br/>    type="application/javascript"<br/>    src="img/load-wasm.js"&gt;<br/>  &lt;/script&gt;<br/>  &lt;style&gt;<br/>    #myCanvas {<br/>      border: 2px solid black;<br/>    }<br/>    #actionButtonWrapper {<br/>      margin-top: 16px;<br/>    }<br/>    #actionButton {<br/>      width: 100px;<br/>      height: 24px;<br/>    }<br/>  &lt;/style&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>  &lt;h1&gt;Interact with JS without Glue Code&lt;/h1&gt;<br/>  &lt;canvas id="myCanvas" width="255" height="255"&gt;&lt;/canvas&gt;<br/>  &lt;div id="actionButtonWrapper"&gt;<br/>    &lt;button id="actionButton"&gt;Pause&lt;/button&gt;<br/>  &lt;/div&gt;<br/>  &lt;script type="application/javascript"&gt;<br/>    const canvas = document.querySelector('#myCanvas');<br/>    const ctx = canvas.getContext('2d');<br/><br/>    const fillCircle = (x, y, radius) =&gt; {<br/>      ctx.fillStyle = '#fed530';<br/>      // Face outline:<br/>      ctx.beginPath();<br/>      ctx.arc(x, y, radius, 0, 2 * Math.PI);<br/>      ctx.fill();<br/>      ctx.stroke();<br/>      ctx.closePath();<br/><br/>      // Eyes:<br/>      ctx.fillStyle = '#000000';<br/>      ctx.beginPath();<br/>      ctx.arc(x - 15, y - 15, 6, 0, 2 * Math.PI);<br/>      ctx.arc(x + 15, y - 15, 6, 0, 2 * Math.PI);<br/>      ctx.fill();<br/>      ctx.closePath();<br/><br/>      // Mouth:<br/>      ctx.beginPath();<br/>      ctx.moveTo(x - 20, y + 10);<br/>      ctx.quadraticCurveTo(x, y + 30, x + 20, y + 10);<br/>      ctx.lineWidth = 4;<br/>      ctx.stroke();<br/>      ctx.closePath();<br/>    };<br/><br/>    const env = {<br/>      table: new WebAssembly.Table({ initial: 8, element: 'anyfunc' }),<br/>      _jsFillCircle: fillCircle,<br/>      _jsClearCircle: function() {<br/>        ctx.fillStyle = '#fff';<br/>        ctx.fillRect(0, 0, 255, 255);<br/>      },<br/>    };<br/><br/>    loadWasm('js-without-glue.wasm', { env }).then(({ instance }) =&gt; {<br/>      const m = instance.exports;<br/>      m._init();<br/><br/>      // Move the circle by 1px in the x and y every 20 milliseconds:<br/>      const loopCircleMotion = () =&gt; {<br/>        setTimeout(() =&gt; {<br/>          m._moveCircle();<br/>          if (m._getIsRunning()) loopCircleMotion();<br/>        }, 20)<br/>      };<br/><br/>      // Enable you to pause and resume the circle movement:<br/>      document.querySelector('#actionButton')<br/>        .addEventListener('click', event =&gt; {<br/>          const newIsRunning = !m._getIsRunning();<br/>          m._setIsRunning(newIsRunning);<br/>          event.target.innerHTML = newIsRunning ? 'Pause' : 'Start';<br/>          if (newIsRunning) loopCircleMotion();<br/>        });<br/><br/>      loopCircleMotion();<br/>    });<br/>  &lt;/script&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</pre>
<p class="mce-root">Instead of using the <kbd>rect()</kbd> element, we can manually draw paths using the functions available on the canvas element's 2D context.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Compiling and serving the result</h1>
                
            
            
                
<p class="mce-root">We're only generating a Wasm module, so we can use the build task we set up in the previous chapter to compile our code. Select Tasks | Run Build Task… or use the keyboard shortcut <em>Ctrl</em>/<em>Cmd</em> + <em>Shift</em> + <em>B</em> to compile the code. If you're not using VS Code, open a CLI instance in the <kbd>/chapter-06-interact-with-js</kbd> folder and run the following command:</p>
<pre class="mce-root"><strong>emcc js-without-glue.cpp -Os -s WASM=1 -s SIDE_MODULE=1 -s BINARYEN_ASYNC_COMPILATION=0 -o js-without-glue.wasm</strong></pre>
<p class="mce-root">Once complete, open a terminal in the <kbd>/book-examples</kbd> folder, and run the following command to start your local server:</p>
<pre class="mce-root"><strong>serve -l 8080</strong></pre>
<p class="mce-root">Open up a browser and navigate to <kbd>http://127.0.0.1:8080/chapter-06-interact-with-js/js-without-glue.html</kbd>. You should see something like this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/c981ffdb-10a6-4d61-b87c-fdfa19ce9d83.png" style="width:35.67em;height:30.08em;"/></p>
<p>The Wasm module running in the browser without glue code</p>
<p>Just as with the previous examples, if you press the Pause button, the caption on the button should change to Start and the circle should stop moving.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Advanced Emscripten features</h1>
                
            
            
                
<p>We covered the Emscripten features we'll be using most frequently for communicating between JavaScript and C/C++ in the previous sections, but those aren't the only capabilities Emscripten provides. There are advanced features and additional APIs that you need to be aware of, especially if you plan on adding more complex functionality to your application. In this section, we'll briefly review some of these advanced features and provide details about where you can learn more.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Embind</h1>
                
            
            
                
<p>Embind is an additional feature that Emscripten offers for connecting JavaScript and C++. Emscripten's site provides the following description:</p>
<p>"Embind is used to bind C++ functions and classes to JavaScript, so that the compiled code can be used in a natural way by 'normal' JavaScript. Embind also supports calling JavaScript classes from C++."</p>
<p>Embind is a powerful feature that allows for tight integration between JavaScript and C++. You can wrap some C++ code in an <kbd>EMSCRIPTEN_BINDINGS()</kbd> block and reference it through the <kbd>Module</kbd> object in your browser. Let's look at an example from Emscripten's site. The following file, <kbd>example.cpp</kbd>, is compiled with the <kbd>--bind</kbd> flag of <kbd>emcc</kbd>:</p>
<pre class="mce-root">// example.cpp<br/>#include &lt;emscripten/bind.h&gt;<br/><br/>using namespace emscripten;<br/><br/>float lerp(float a, float b, float t) {<br/>    return (1 - t) * a + t * b;<br/>}<br/><br/>EMSCRIPTEN_BINDINGS(my_module) {<br/>    function("lerp", &amp;lerp);<br/>}</pre>
<p class="mce-root">The resultant module is loaded in <kbd>example.html</kbd> and the <kbd>lerp()</kbd> function is called:</p>
<pre class="mce-root">&lt;!-- example.html --&gt;<br/>&lt;!doctype html&gt;<br/>&lt;html&gt;<br/>&lt;script src="img/example.js"&gt;&lt;/script&gt;<br/>&lt;script&gt;<br/>  // example.js was generated by running this command:<br/>  // emcc --bind -o example.js example.cpp<br/>  console.log('lerp result: ' + Module.lerp(1, 2, 0.5));<br/>&lt;/script&gt;<br/>&lt;/html&gt;</pre>
<p>The preceding example represents a small portion of Embind's capabilities. You can learn more about Embind at <a href="https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html">https://kripken.github.io/emscripten-site/docs/porting/connecting_cpp_and_javascript/embind.html</a>.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">File System API</h1>
                
            
            
                
<p>Emscripten provides support for file operations by using the FS library and exposes an API for working with the filesystem. However, it's not included by default when you compile your project because it could increase the file's size significantly. If your C/C++ code uses files, the library will be added automatically. The filesystem types vary based on the execution environment. For example, if you're running code inside a worker, the <kbd>WORKERFS</kbd> filesystem can be used. By default, <kbd>MEMFS</kbd> is used, which stores the data in memory, and any data written to memory is lost when the page is reloaded. You can read more about the File System API at <a href="https://kripken.github.io/emscripten-site/docs/api_reference/Filesystem-API.html#filesystem-api">https://kripken.github.io/emscripten-site/docs/api_reference/Filesystem-API.html#filesystem-api</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Fetch API</h1>
                
            
            
                
<p>Emscripten provides a Fetch API as well. The following is taken from the documentation:</p>
<p>"The Emscripten Fetch API allows native code to transfer files via XHR (HTTP GET, PUT, POST) from remote servers, and to persist the downloaded files locally in browser's IndexedDB storage, so that they can be re-accessed locally on subsequent page visits. The Fetch API is callable from multiple threads, and the network requests can be run either synchronously or asynchronously as desired."</p>
<p>The Fetch API can be used to integrate with Emscripten's other features. If you need to fetch data that isn't utilized by Emscripten, you should use the browser's Fetch API (<a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API</a>). You can read more about the Fetch API at <a href="https://kripken.github.io/emscripten-site/docs/api_reference/fetch.html">https://kripken.github.io/emscripten-site/docs/api_reference/fetch.html</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Debugging in the browser</h1>
                
            
            
                
<p>Effectively debugging JavaScript code in the browser has not always been easy. However, development tooling has markedly improved in the browser and in editors/IDEs with built-in debugging capabilities. Unfortunately, adding WebAssembly to a web application adds an additional level of complexity to the debugging process. In this section, we will review some techniques for debugging JavaScript that utilizes Wasm as well as some of the additional capabilities Emscripten offers.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">High-level overview</h1>
                
            
            
                
<p>Debugging Emscripten's <kbd>Module</kbd> is relatively straightforward. Emscripten's error messages are well formed and descriptive, so you'll usually discover what's causing the issue right away. You can view these messages in your browser's development tools console.</p>
<p>If you specified a <kbd>.html</kbd> output when running the <kbd>emcc</kbd> command, some debugging code will already be built in (<kbd>Module.print</kbd> and <kbd>Module.printErr</kbd>). Within the HTML file, the loading code sets the <kbd>window.onerror</kbd> event to call the <kbd>Module.printErr</kbd> event, so you can see details about the error that occurred when loading.</p>
<p>One common error you may encounter is calling the wrong function name. If you're using Emscripten's Promise-like API, you can print out the available functions by running the following code in your browser's console:</p>
<pre><strong>console.log(Module().asm);</strong></pre>
<p>The following screenshot shows the output for the <kbd>js-with-glue.js</kbd> example we used in the <em>Calling JavaScript functions from C/C++</em> section of this chapter:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/7a85c9a2-9f60-48eb-b1d1-196d77f5e9f8.png" style="width:44.25em;height:28.17em;"/></p>
<p>Logging the contents of <kbd>Module().asm</kbd> in the browser console</p>
<p class="mce-root"/>
<p>Your functions, as well as some functions that Emscripten generates, will be prefixed with a <kbd>_</kbd>. The advantage of writing code that gets compiled is that the compiler will catch most errors up front. Given the extensive tooling available for languages such as C and C++, you should be able to understand and address these errors quickly.</p>
<p>If you're not using any glue code and instantiating a Wasm file using WebAssembly's JavaScript and Web APIs, debugging can get a little more complex. As previously stated, you have the advantage of catching most errors at compile time in your C or C++ code. Just as with Emscripten, the error messages printed out in your browser's development tools console provide a stack trace and a relatively clear description of the issue. However, logging to the console may become cumbersome and difficult to manage if you're troubleshooting a particularly difficult bug. Fortunately, you can use source maps to improve your debugging capabilities.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using source maps</h1>
                
            
            
                
<p>Emscripten has the ability to generate source maps by passing some additional flags to the compiler. Source maps allow your browser to map the source of a file to the file being utilized in an application. For example, you can use a JavaScript build tool such Webpack to minify the code as part of your build process. However, it's incredibly difficult to navigate and troubleshoot the minified code if you're trying to find a bug. By generating a source map, you can view the code in its original form within the browser's development tools and set breakpoints for debugging. Let's generate a source map for our <kbd>/chapter-06-interact-with-js/js-without-glue.cpp</kbd> file. Within the <kbd>/book-examples</kbd> folder, run the following command in a terminal:</p>
<pre><strong>emcc chapter-06-interact-with-js/js-without-glue.cpp -O1 -g4 -s WASM=1 -s SIDE_MODULE=1 -s BINARYEN_ASYNC_COMPILATION=0 -o chapter-06-interact-with-js/js-without-glue.wasm --source-map-base http://localhost:8080/chapter-06-interact-with-js/</strong></pre>
<p>The <kbd>-g4</kbd> argument enables source maps, while the <kbd>--source-map-base</kbd> argument tells the browser where to find the source map file. Once compiled, start your local server up from the <kbd>/book-examples</kbd> folder by running the following command:</p>
<pre><strong>serve -l 8080</strong></pre>
<p>Navigate to <kbd>http://127.0.0.1:8080/chapter-06-interact-with-js/js-without-glue.html</kbd>, open the Developer Tools, and select the Sources tab (in Chrome) or Debugger tab (in Firefox). If you're using Chrome, you should see the following:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/ccc8b38d-f748-40fb-8d25-667dc176c0ff.png"/></p>
<p>Wasm source maps in Chrome Developer Tools</p>
<p class="mce-root"/>
<p>As you can see, the filenames aren't very helpful. Each file should include the function name at the top, although some of the names may have been mangled. You can set breakpoints if you encounter errors, and Chrome's debugging functionality allows you to navigate the call stack. Firefox handles their source maps differently. The following screenshot shows the Debugger view in Firefox's Developer Tools:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/d40de2b0-f550-4e74-bbac-4249f1693ec4.png"/></p>
<p>Wasm source map in Firefox Developer Tools</p>
<p>The source map is a single file that contains the Wat representation of the Wasm file. You can set breakpoints and debug code here as well. As WebAssembly evolves, more (and better) tooling will become available. In the meantime, logging to the console and utilizing source maps are the current debugging methods you can use.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we focused on the intercommunication of JavaScript and C/C++, some of the features Emscripten offers, and how to effectively debug web applications that utilize Wasm in the browser. We reviewed the various means of calling compiled C/C++ functions from JavaScript, and how to integrate JavaScript with your C/C++ code. Emscripten's APIs were presented as a way to understand how you can overcome some of WebAssembly's current limitations by including glue code with your compiled Wasm files. Even though the capabilities Emscripten provides are not present in the official WebAssembly <em>Core Specification</em> (and may never be), that shouldn't deter you from taking advantage of them. Finally, we briefly covered how to debug Wasm files in the browser in the context of an Emscripten module or a WebAssembly instance.</p>
<p>In the next chapter, we'll build a real-world WebAssembly application from scratch.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Questions</h1>
                
            
            
                
<ol>
<li>What are the names of the two functions available on the <kbd>Module</kbd> object that you use to interact with the compiled code from the browser?</li>
<li>What do you need to wrap your C++ code in to ensure the function names don't get mangled?</li>
<li>What's the difference between <kbd>EM_ASM()</kbd> and <kbd>EM_JS()</kbd>?</li>
<li>Which is more performant, <kbd>emscripten_run_script()</kbd> or <kbd>EM_ASM()</kbd>/<kbd>EM_JS()</kbd>?</li>
<li>What do you need to include in the line above your function if you want to use it outside of your C/C++ code (hint: it starts with <kbd>EMSCRIPTEN</kbd>)?</li>
<li>Where can you define a function that needs to be passed into the <kbd>importObj.env</kbd> object when instantiating a module?</li>
<li>What additional APIs does Emscripten provide?</li>
<li>What is the purpose of source maps?</li>
</ol>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Further reading</h1>
                
            
            
                
<ul>
<li>Emscripten API Reference: <a href="http://kripken.github.io/emscripten-site/docs/api_reference/index.html">http://kripken.github.io/emscripten-site/docs/api_reference/index.html</a></li>
<li>An Introduction to Source Maps: <a href="http://blog.teamtreehouse.com/introduction-source-maps">http://blog.teamtreehouse.com/introduction-source-maps</a></li>
<li>Using Browsers to Debug WebAssembly: <a href="http://webassemblycode.com/using-browsers-debug-webassembly">http://webassemblycode.com/using-browsers-debug-webassembly</a></li>
</ul>


            

            
        
    </body></html>