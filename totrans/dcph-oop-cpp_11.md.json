["```cpp\n// Assume Student class is as seen before, but with one\n// additional virtual mbr function. Assume usual headers.\nvoid Student::Validate() // defined as virtual in class def\n{                        // so derived classes may override\n    // check constructed Student; see if standards are met\n    // if not, throw an exception\n    throw string(\"Does not meet prerequisites\");\n}\nint main()\n{\n    Student s1(\"Sara\", \"Lin\", 'B', \"Dr.\", 3.9,\n               \"C++\", \"23PSU\");\n    try      // Let's 'try' this block of code -- \n    {        // Validate() may raise an exception\n        s1.Validate(); // does s1 meet admission standards?\n    }\n    catch (const string &err) \n    {\n        cout << err << endl;\n        // try to fix problem here…\n        exit(1); // only if you can't fix error, \n    }            // exit as gracefully as possible\n    cout << \"Moving onward with remainder of code.\";\n    cout << endl;\n    return 0;\n}\n```", "```cpp\nStudent does not meet prerequisites \n```", "```cpp\nvoid AppSpecificTerminate()\n{   // first, do what's necessary to end program gracefully\n    cout << \"Uncaught exception. Program terminating\";\n    cout << endl;\n    exit(1);\n}\nint main()\n{   \n    set_terminate(AppSpecificTerminate);  // register fn.\n    return 0;\n}\n```", "```cpp\nUncaught exception. Program terminating\n```", "```cpp\n// Assume Student class is as seen before, but with\n// two additional member fns. Assume usual header files.\nvoid Student::Validate() // defined as virtual in class def\n{                        // so derived classes may override\n    // check constructed student; see if standards are met\n    // if not, throw an exception\n    throw string(\"Does not meet prerequisites\");\n}\nbool Student::TakePrerequisites()  \n{\n    // Assume this function can correct the issue at hand\n    // if not, it returns false\n    return false;\n}\nint main()\n{\n    Student s1(\"Alex\", \"Ren\", 'Z', \"Dr.\", 3.9, \n               \"C++\", \"89CU\");\n    try    // illustrates a nested try block \n    {   \n        // Assume another important task occurred in this\n        // scope, which may have also raised an exception\n        try\n        {   \n            s1.Validate();  // may raise an exception\n        }\n        catch (const string &err)\n        {\n            cout << err << endl;\n            // try to correct (or partially handle) error.\n            // If you cannot, pass exception to outer scope\n            if (!s1.TakePrerequisites())\n                throw;    // re-throw the exception\n        }\n    }\n    catch (const string &err) // outer scope catcher \n    {                         // (e.g. handler)\n        cout << err << endl;\n        // try to fix problem here…\n        exit(1); // only if you can't fix, exit gracefully\n    } \n    cout << \"Moving onward with remainder of code. \";\n    cout << endl;\n    return 0;\n}\n```", "```cpp\nStudent does not meet prerequisites\nStudent does not meet prerequisites\n```", "```cpp\n// Assume Student class is as seen before, but with one\n// additional virtual member function, Graduate(). Assume \n// a simple Course class exists. All headers are as usual.\nvoid Student::Graduate()\n{   // Assume the below if statements are fully implemented \n    if (gpa < 2.0) // if gpa doesn't meet requirements\n        throw gpa;\n    // if Student is short credits, throw number missing\n        throw numCreditsMissing;  // assume this is an int\n    // or if Student is missing a Course, construct, then\n    // throw the missing Course as a referenceable object\n    // Assume appropriate Course constructor exists\n        throw Course(\"Intro. To Programming\", 1234); \n    // or if another issue, throw a diagnostic message\n        throw string(\"Does not meet requirements\"); \n}\nint main()\n{\n    Student s1(\"Ling\", \"Mau\", 'I', \"Ms.\", 3.1, \n               \"C++\", \"55UD\");\n    try  \n    {  \n        s1.Graduate();\n    }\n    catch (float err)\n    {\n        cout << \"Too low gpa: \" << err << endl;\n        exit(1); // only if you can't fix, exit gracefully\n    } \n    catch (int err)\n    {\n        cout << \"Missing \" << err << \" credits\" << endl;\n        exit(2);\n    }\n    catch (const Course &err)\n    {\n        cout << \"Need to take: \" << err.GetTitle() << endl;\n        cout << \"Course #: \" << err.GetCourseNum() << endl; \n        // Ideally, correct the error, and continue program \n        exit(3); // Otherwise, exit, gracefully if possible\n    }             \n    catch (const string &err)\n    {\n        cout << err << endl;\n        exit(4); \n    }\n    catch (...)\n    {\n        cout << \"Exiting\" << endl;\n        exit(5);\n    }\n    cout << \"Moving onward with remainder of code.\";\n    cout << endl;\n    return 0;\n}\n```", "```cpp\nNeed to take: Intro. to Programming\nCourse #: 1234\n```", "```cpp\nvoid Student::Graduate() throw(float, int, \n                               Course &, string)\n{\n   // this method might throw any type included in \n   // its extended signature\n}\nvoid Student::Enroll() throw()\n{\n   // this method might throw any type of exception\n}\n```", "```cpp\nvoid Student::Graduate() noexcept   // will not throw() \n{          // same as  noexcept(true) in extended signature\n}          // same as deprecated throw() in ext. signature\nvoid Student::Enroll() noexcept(false)  // may throw()\n{                                       // an exception\n}                                     \n```", "```cpp\nvoid AppSpecificUnexpected()\n{\n    cout << \"An unexpected type was thrown\" << endl;\n    // optionally re-throw the correct type, or\n    // terminate() will be called.\n}\nint main()\n{\n   set_unexpected(AppSpecificUnexpected)\n}\n```", "```cpp\n#include <iostream>\n#include <exception>\n// See online code for many using std:: inclusions\nclass StudentException: public exception\n{\nprivate:\n    int errCode = 0;  // in-class init, will be over-\n    // written with bonified value after successful \n    // alternate constructor completion\n    string details;\npublic:\n    StudentException(const string &det, int num):\n                     errCode(num), details(det) { } \n    // Base class destructor (exception class) is virtual. \n    // Override at this level if there's work to do. \n    // We can omit the default destructor prototype.\n    // ~StudentException() override = default;\n    const char *what() const noexcept override\n    {   // overridden function from exception class\n        return \"Student Exception\";\n    } \n    int GetCode() const { return errCode; }\n    const string &GetDetails() const { return details; }\n};\n// Assume Student class is as we've seen before, but with\n// one additional virtual member function, Graduate() \nvoid Student::Graduate() // fn. may throw StudentException\n{\n   // if something goes wrong, construct a \n   // StudentException, packing it with relevant data, \n   // and then throw it as a referenceable object\n   throw StudentException(\"Missing Credits\", 4);\n}\nint main()\n{\n    Student s1(\"Alexandra\", \"Doone\", 'G', \"Miss\", 3.95, \n               \"C++\", \"231GWU\");\n    try\n    {\n        s1.Graduate();\n    }\n    catch (const StudentException &e)  // catch exc. by ref\n    { \n        cout << e.what() << endl;\n        cout << e.GetCode() << \" \" << e.GetDetails();\n        cout << endl;\n        // Grab useful info from e and try to fix problem\n        // so that the program can continue.\n        exit(1);  // only exit if we can't fix the problem!\n    }\n    return 0;\n}\n```", "```cpp\nStudent Exception\n4 Missing Credits\n```", "```cpp\n// Assume Student class is as before, but with the addition \n// of a nested exception class. All headers are as usual.\nclass Student: public Person\n{\nprivate:  // assume usual data members\npublic:   // usual constructors, destructor, and methods\n    virtual void Graduate();\n    class StudentException   // nested exception class\n    {\n    private:\n        int number = 0;  // will be over-written after \n        // successful alternate constructor \n        // note: there is no default constructor\n    public:\n        StudentException(int num): number(num) { }\n        // Remember, it is unnecessary to proto. default ~\n        // ~StudentException() = default;\n        int GetNum() const { return number; }\n    };\n};\nvoid Student::Graduate()\n{   // assume we determine an error and wish to throw\n    // the nested exception type\n    throw StudentException(5);\n}\nint main()\n{\n    Student s1(\"Ling\", \"Mau\", 'I', \"Ms.\", 3.1, \n               \"C++\", \"55UD\");\n    try\n    {\n        s1.Graduate();\n    }\n    // following is one of many catch blocks in online code\n    catch (const Student::StudentException &err)\n    {\n        cout << \"Error: \" << err.GetNum() << endl;\n        // If you correct error, continue the program\n        exit(5);  // Otherwise, exit application \n    }\n    cout << \"Moving onward with remainder of code.\";\n    cout << endl;\n    return 0;\n}\n```", "```cpp\nError: 5\n```"]