<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Programming the Arduino - Beyond the Basics</h1>
                </header>
            
            <article>
                
<p>One of the things that I learned early on in my development career is that I can write some pretty amazing applications even if I only know the basics of the programming language that I am using; however, it usually makes the code hard to maintain and read while also adding significant development time to the project. I always tell people that are learning a language to take the time to understand some of the more advanced features of the language they are learning prior to using it for serious projects.</p>
<p>In this chapter, we will learn:</p>
<ul>
<li>How to set the pin mode on an Arduino digital pin</li>
<li>How to get and set the values of an Arduino digital pin</li>
<li>How to get and set the values of an Arduino analog pin</li>
<li>How to use structures and unions</li>
<li>How to use additional tabs</li>
<li>How to use classes and objects</li>
</ul>
<p>In the previous chapter, we looked at the basics of the Arduino programming language. In this chapter, we are going to go beyond the basics of the language itself. We will start off by looking at how we can interact with the digital pins on the Arduino.</p>
<div class="packt_infobox">For the samples in this chapter, we will be using the prototype that we created at the end of <a href="f0039485-e47c-40c8-9130-fba1e1afd421.xhtml" target="_blank"><span class="ChapterrefPACKT">Chapter 4</span></a>, <em>Basic Prototyping</em>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting digital pin mode</h1>
                </header>
            
            <article>
                
<p>In <a href="a46a0d68-6899-45e9-8f90-3ba0f15ad9e6.xhtml" target="_blank"><span class="ChapterrefPACKT">Chapter 1</span></a>, <em>The Arduino</em>, we saw that the Arduino has several digital pins that we can connect external sensors and other devices to. Before we use these pins, we should configure them for either input or output depending on what we are using them for. To do this, we use the <kbd>pinMode()</kbd> function that is built into the Arduino programming language. Usually for smaller sketches we call the <kbd>pinMode()</kbd> function within the <kbd>setup()</kbd> function; however, this is not required. The following code shows the syntax for the <kbd>pinMode()</kbd> function:</p>
<pre>pinMode(pin, mode);</pre>
<p>This function is called with two parameters. The first is the number of the pin that we are setting and the second is the mode for the pin. The mode for the pin can be either <kbd>INPUT</kbd>, to read the value from the pin (external sensor writes a value to the pin), or <kbd>OUTPUT</kbd>, to set the value for the pin. The following code shows how to use this command to set the pin mode for two pins:</p>
<pre>pinMode( 11 , INPUT);
pinMode( 12 , OUTPUT);</pre>
<p>In the preceding code, we set pin <kbd>11</kbd> to input and pin <kbd>12</kbd> for output. Therefore, we would write values to pin 11 and read values from pin 12.</p>
<p>It is good practice never to use the pin numbers themselves, as shown in the last example, to access the pin on the Arduino. Instead of using the pin numbers like this, we should set a variable or constant with the number of the pin and then use that variable or constant when accessing the pin. This will prevent us from typing in the wrong number within the code.</p>
<div class="packt_infobox">My personal preference is to use <kbd>#define</kbd> to define the pin numbers that I am using when the pin number will not change. This allows me to separate my pin definitions from the other constants within my sketch.<br/>
If you wish to use constants instead of <kbd>#define</kbd>, that is perfectly acceptable, and some people would say that it is preferable.</div>
<p>The following code shows how we should use the <kbd>pinMode()</kbd> function within a sketch:</p>
<pre>#define BUTTON_ONE 12
#define LED_ONE 11

void setup() {
  pinMode(BUTTON_ONE, INPUT);
  pinMode(LED_ONE, OUTPUT);
}</pre>
<p>In the preceding code, we defined constants that represented two pins. The first line defines <kbd>BUTTON_ONE</kbd> to the number (pin) <kbd>12</kbd> and the second line defines <kbd>LED_ONE</kbd> to the number (pin) <kbd>11</kbd>. We then set the <kbd>BUTTON_ONE</kbd> pin to input mode and <kbd>LED_ONE</kbd> pin to output mode within the <kbd>setup()</kbd> function.</p>
<p>The <kbd>pinMode()</kbd> function can also be used to configure the internal pull-up resistor by setting the mode of the pin to <kbd>INPUT_PULLUP</kbd>. This will invert the behavior of the pin when it is in input mode.</p>
<p>These digital pins may have one of two values: <kbd>HIGH</kbd> or <kbd>LOW</kbd>. Let's see how we can set the value of a digital pin.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Digital write</h1>
                </header>
            
            <article>
                
<p>To set the value of a digital pin in the Arduino programming language, we use the <kbd>digitalWrite()</kbd> function. This function takes the following syntax:</p>
<pre>digitalWrite(pin, value);</pre>
<p>The <kbd>digitalWrite()</kbd> function accepts two parameters, where the first one is the pin number and the second is the value to set. We should use either <kbd>HIGH</kbd> or <kbd>LOW</kbd> when setting the value of a digital pin. The following code shows how to do this:</p>
<pre>digitalWrite(LED_ONE, HIGH);
delay(500);
digitalWrite(LED_ONE, LOW);  
delay(500);</pre>
<p>In the preceding code, we set the pin defined by the <kbd>LED_ONE</kbd> constant too <kbd>HIGH</kbd> and then pause for half a second. The <kbd>delay()</kbd> function in the Arduino programming language pauses the execution of the sketch for a certain amount of time. The time for this function is in milliseconds. After the <kbd>delay()</kbd> function we then set the pin defined by the <kbd>LED_ONE</kbd> constant too <kbd>LOW</kbd> and wait another half a second before looping back to the beginning.</p>
<p>The previous code can be used in the <kbd>loop()</kbd> function to blink an LED; however, before we do that we need to define the <kbd>LED_ONE</kbd> constant and also set the pin mode. Let's look at the full sketch required to blink an LED.</p>
<pre>#define LED_ONE 11

void setup() {
  pinMode(LED_ONE, OUTPUT);
}

void loop() {
  digitalWrite(LED_ONE, HIGH);
  delay(500);
  digitalWrite(LED_ONE, LOW);
  delay(500);
}</pre>
<p>This code starts off by defining the <kbd>LED_ONE</kbd> constant and setting to <kbd>11</kbd>. The pin mode for the <kbd>LED_ONE</kbd> pin is then set in the <kbd>setup()</kbd> function. Finally, the code that will cause the LED to blink is added to the <kbd>loop()</kbd> function. If you connect the prototype that we developed in <a href="f0039485-e47c-40c8-9130-fba1e1afd421.xhtml" target="_blank">C<span class="ChapterrefPACKT">hapter 4</span></a>, <em>Basic Prototyping</em> and ran this code, you should see one of the LEDs blinking.</p>
<p>Now that we know how to write to a digital pin, let's see how we can read the value of one.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Digital read</h1>
                </header>
            
            <article>
                
<p>To read the value of a digital pin in the Arduino programming language, we use the <kbd>digitalRead()</kbd> function. This function takes the following syntax:</p>
<pre>digitalRead(pin);</pre>
<p>The <kbd>digitalRead()</kbd> function takes one parameter, which is the number of the digital pin to read, and will return an integer value. The following code shows how we can use the <kbd>digitalRead()</kbd> function to read one of the digital pins on the Arduino:</p>
<pre>int val = digitalRead(BUTTON_ONE);</pre>
<p>With this code, the <kbd>digitalRead()</kbd> function will return the value of the pin defined by the <kbd>BUTTON_ONE</kbd> constant and put that value into the variable named <kbd>val</kbd>. The <kbd>val</kbd> variable is defined to be an integer. However, the <kbd>digitalRead()</kbd> function will only return a 0 or a 1. We can use the same <kbd>HIGH</kbd> and <kbd>LOW</kbd> constants that we saw in the <em>Digital write</em> section to see if the pin is either high or low. Using these constants are preferred and makes your code more readable.</p>
<p>Now let's see how we can use the <kbd>digitalRead()</kbd> function to read the status of a button. The following code will read the status of the button from the prototype that we built in <span class="ChapterrefPACKT"><a href="f0039485-e47c-40c8-9130-fba1e1afd421.xhtml" target="_blank">Chapter 4</a>,</span> <em>Basic Prototyping</em>:</p>
<pre>#define BUTTON_ONE 12

void setup() {
  Serial.begin(9600);
  pinMode(BUTTON_ONE, INPUT);
} 

void loop() {
  int val = digitalRead(BUTTON_ONE);
  if (val == HIGH) {
    Serial.println("Button HIGH");
  } else {
    Serial.println("Button LOW");
  }
}</pre>
<p>This code starts off by defining the <kbd>BUTTON_ONE</kbd> constant and setting it to <kbd>12</kbd>. The serial monitor and the pin mode for the pin that the button is connected to are both configured in the <kbd>setup()</kbd> function. Within the loop button, the <kbd>digitalRead()</kbd> function is used to read the pin and the <kbd>if</kbd> statement is used to compare the value that was returned with the <kbd>HIGH</kbd> constant. If they are equal, then the message <kbd>Button HIGH</kbd> is sent to the serial monitor otherwise the message <kbd>Button LOW</kbd> is sent.</p>
<p>If this code is run on the prototype that was created in <a href="f0039485-e47c-40c8-9130-fba1e1afd421.xhtml" target="_blank"><span class="ChapterrefPACKT">Chapter 4</span></a>, <em>Basic Prototyping</em>, then you should see one of the two messages being printed to the serial monitor depending if the button is pressed or not.</p>
<p>Now let's see how we can write to an analog pin on the Arduino.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Analog write</h1>
                </header>
            
            <article>
                
<p>Analog values are written to the Arduino with the <strong>Pulse-Width Modulation</strong> (<strong>PWM</strong>) pins. In <a href="a46a0d68-6899-45e9-8f90-3ba0f15ad9e6.xhtml" target="_blank"/><a href="a46a0d68-6899-45e9-8f90-3ba0f15ad9e6.xhtml">C<span class="ChapterrefPACKT">hapter 1</span></a><span class="ChapterrefPACKT">, </span><em>The Arduino</em>, we looked at what PWM is and how they work. On most Arduino boards the PWM pins are configured for pins 3, 5, 6, 9, 10, and 11; however, the Arduino Mega has significantly more pins available for PWM functionality.</p>
<p>To perform an analog write, we use the <kbd>analogWrite()</kbd> function, which takes the following syntax:</p>
<pre>analogWrite(pin, value); </pre>
<p>The <kbd>analogWrite()</kbd> function accepts two parameters, where the first one is the pin number and the second is the value to set. The value for the <kbd>analogWrite()</kbd> function can range from 0 to 255.</p>
<p>Let's look at a sample sketch to see how we can use the <kbd>analogWrite()</kbd> function to fade a led in and out:</p>
<pre>#define LED_ONE 11

int val = 0;
int change = 5;

void setup()
{
  pinMode(LED_ONE, OUTPUT);
}

void loop()
{
  val += change;
  if (val &gt; 250 || val &lt; 5) {
    change *= -1;
  }
  analogWrite(LED_ONE, val);
  delay(100);
}</pre>
<p>This code starts off by defining a <kbd>LED_ONE</kbd> constant with a value of <kbd>11</kbd>. This will be the pin that the LED is connected to. There are also two global variables defined, both of the integer type, named <kbd>val</kbd> and <kbd>change</kbd>. The <kbd>val</kbd> integer will store the current value of the analog pin, and the <kbd>change</kbd> integer will store how much the <kbd>val</kbd> integer should change each loop.</p>
<p>The pin defined by the <kbd>LED_ONE</kbd> constant is set to output mode within the <kbd>setup()</kbd> function. This will enable us to write to the pin and change the brightness of the LED connected to the pin.</p>
<p>The <kbd>loop()</kbd> function starts off by adding the <kbd>change</kbd> variable to the <kbd>val</kbd> variable, and the result is stored in the <kbd>val</kbd> variable. If the value of the <kbd>val</kbd> variable is greater than 250 or less than 5 we multiple the <kbd>change</kbd> variable by -1. This causes the <kbd>change</kbd> variable to rotate between 5 and -5, which causes the <kbd>val</kbd> variable to increase or decrease each loop. Finally, the value of the <kbd>val</kbd> variable is written to the pin defined by the <kbd>LED_ONE</kbd> constant, and then there is a short delay before looping back.</p>
<p>If this code is run on the prototype that was created in <a href="f0039485-e47c-40c8-9130-fba1e1afd421.xhtml" target="_blank"><span class="ChapterrefPACKT">Chapter 4</span></a>, <em>Basic Prototyping</em>, then you should see LED fade in and out. Now let's look at how we can read an analog pin.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Analog read</h1>
                </header>
            
            <article>
                
<p>We read the value from an analog pin using the <kbd>analogRead()</kbd> function. This function will return a value between 0 and 1023. This means that if the sensor is returning the full voltage of 5V, then the <kbd>analogRead()</kbd> function will return a value 1023, which results in a value of 0.0049V per unit (we will use this number in the sample code). The following code shows the syntax for the <kbd>analogRead()</kbd> function:</p>
<pre>analogRead(pin);</pre>
<p>The <kbd>analogRead()</kbd> function takes one parameter which is the pin to read from. The following code uses the <kbd>analogRead()</kbd> function with a tmp36 temperature sensor to determine the current temperature:</p>
<pre>#define TEMP_PIN 5

void setup() {
  Serial.begin(9600);
}

void loop() {
  int pinValue = analogRead(TEMP_PIN);
  double voltage = pinValue * 0.0049;
  double tempC = (voltage - .5) * 100.0;
  double tempF = (tempC * 1.8) + 32;
  Serial.print(tempC);
  Serial.print(" -  ");
  Serial.println(tempF);
  delay(2000);
}</pre>
<p>The preceding code starts off by defining the pin that the temperature sensor is attached to which is the analog pin 5. The <kbd>setup()</kbd> function configures the serial monitor so the application can print the temperature to it.</p>
<p>The <kbd>loop()</kbd> function begins by reading the analog pin and storing the value in the <kbd>pinValue</kbd> variable. To convert this value to the actual voltage, we multiply it by the 0.0049V value that we saw earlier in this section. If we look at the datasheet for the tmp36 temperature sensor, we will determine that the <kbd>(voltage - .5) *100.0</kbd> is the correct formula to calculate the temperature in Celsius. We can then use the standard formula <kbd>(celsiusTemp *1.8) + 32</kbd> to determine the temperature in Fahrenheit. Finally, we print these values to the serial monitor and delay for two seconds before beginning the loop again.</p>
<p>We will be using the <kbd>digitalRead()</kbd>, <kbd>digitalWrite()</kbd>, <kbd>analogRead()</kbd> and <kbd>analogWrite()</kbd> functions a lot in this book so you will be getting familiar with them.</p>
<p>Now let's look at structures.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Structures</h1>
                </header>
            
            <article>
                
<p>A structure is a user-defined a composite data type that is used to group multiple variables together. The variables in a structure may be of different types enabling us to store related data, of different types, together. The following code shows the syntax of how we would define a structure:</p>
<pre>struct name {
  variable list
  .
  .
};</pre>
<p>When a structure is defined, the <kbd>struct</kbd> keyword is used followed by the name of the structure. The variable list is then defined between the curly brackets.</p>
<p>Let's take a look at how we can create and use a structure by changing the previous sketch, which used the <kbd>analogRead()</kbd> function to read the TMP36 temperature, to use a structure. The first thing we need to do is to define a structure that will store the temperature information from the sensor. We will name this structure <kbd>tmp36_reading,</kbd> and it will contain three variables all of the double type. The following code shows how to define this structure:</p>
<pre>struct tmp36_reading {
  double voltage;
  double tempC;
  double tempF;
};</pre>
<p>The preceding code defines a structure named <kbd>tmp36_reading</kbd> that contains three variables all of the double type. Keep in mind that the variables in a structure do not have to be of the same type, it just worked out that all of the individual variables in this structure were of the double type.</p>
<p>The following code shows how we would create a variable of the <kbd>tmp36_reading</kbd> type:</p>
<pre>struct tmp36_reading temp;</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The preceding code creates a variable named <kbd>temp</kbd> that is of the <kbd>tmp36_reading</kbd> type. We can then assign or retrieve values by using the dot syntax as shown in the following code:</p>
<pre>temp.voltage = pinValue * 0.0049;
temp.tempC = (temp.voltage - .5) * 100.0;
temp.tempF = (temp.tempC * 1.8) + 32;</pre>
<p>In the preceding code we assign values to the <kbd>voltage</kbd>, <kbd>tempC</kbd> and <kbd>tempF</kbd> variables of the <kbd>tmp36_reading</kbd> structure. Now let's see how we can integrate this code into a sketch that reads the TMP36 temperature sensor. The following is the complete code for the new sketch:</p>
<pre>#define TEMP_PIN 5

struct tmp36_reading {
  double voltage;
  double tempC;
  double tempF;
};

void setup() {
  Serial.begin(9600);
}
 
void loop() {
  struct tmp36_reading temp;
  int pinValue = analogRead(TEMP_PIN);
  temp.voltage = pinValue * 0.0049;
  temp.tempC = (temp.voltage - .5) * 100.0;
  temp.tempF = (temp.tempC * 1.8) + 32;

  showTemp(temp);
  delay(2000);
}

void showTemp(struct tmp36_reading temp) {
  Serial.print(temp.tempC);
  Serial.print("  -  ");
  Serial.println(temp.tempF);
}</pre>
<p>This sketch functions exactly like the previous sketch that read the TMP36 temperature sensor, except now we use a structure to store the values from the sensor rather than variables.</p>
<p>If you have multiple values that you can group together like this, it is recommended that we use a structure rather than variables because all of the values are grouped together in one structure.</p>
<p>Now let's look at another special data type that may look similar to a structure; however, the functionality is significantly different.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Unions</h1>
                </header>
            
            <article>
                
<p>A union is a special data type that enables us to store different data types in a single definition, similar to the structure; however, only one of the members may contain data at any one time. The following shows the syntax for defining a union:</p>
<pre>union name {
  variable list
  .
  .
};</pre>
<p>If the syntax looks a lot like the syntax for a structure. In fact, it is the same syntax except for the <kbd>struct</kbd>/<kbd>union</kbd> keywords.</p>
<p>Let's see how we would use a union. The following code defines a new union:</p>
<pre>union some_data {
  int i;
  double d;
  char s[20];
};</pre>
<p>The preceding code defines a union named <kbd>some_data</kbd> that can contain an integer, double or a character string. The keyword in that last sentence is the <em>o</em><em>r</em>. Unlike the structure, which can store several different values, a union can only store one value at a time. The following code will illustrate this:</p>
<pre>union some_data {
  int i;
  double d;
  char s[20];
};

void setup() {
  Serial.begin(9600);
  union some_data myData;
  myData.i = 42;
  myData.d = 3.14;
  strcpy( myData.s, "Arduino");
  Serial.println(myData.s);
  Serial.println(myData.d);
  Serial.println(myData.i);
}</pre>
<p>In the preceding code, we define a union named <kbd>some_data</kbd>. Then in the <kbd>setup()</kbd> function we create an instance of the <kbd>some_data</kbd> union type named <kbd>myData</kbd>. We then assign values to each member of the union type. The integer member is set to <kbd>42</kbd>, the double member is set to <kbd>3.14</kbd> and the character string is set to <kbd>Arduino</kbd>. When this code is run, we will see that the <kbd>Arduino</kbd> character string is correctly printed to the serial monitor; however, when the integer and double members are printed to the serial monitor the information is not correct.</p>
<p>In the previous example, when the <kbd>some_data.i</kbd> member is set to <kbd>42</kbd>, the <kbd>some_data</kbd> union will contain the integer 42. Then when we set the <kbd>some_data.d</kbd> member to <kbd>3.14</kbd>, the integer value of 42 is overwritten, and the <kbd>some_data</kbd> union would now contain 3.14. Finally when we set the <kbd>some_data.s</kbd> member to <kbd>Arduino</kbd> it overwrites the <kbd>some_data.d</kbd> member, so the <kbd>some_data</kbd> union now contains the string <kbd>Arduino</kbd>.</p>
<p>Before we look at more features of the Arduino programming language, let's look at another feature of the Arduino IDE and the Web Editor.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding tabs</h1>
                </header>
            
            <article>
                
<p>As you begin to work with larger and more complex projects, it quickly becomes important to divide your code up into separate workspaces because it makes your code easier to manage. To do this, in both the Arduino IDE and the Web Editor, we can add new tabs to a sketch.</p>
<p>To add a new tab to the Arduino IDE, click on the button with an upside-down triangle in it that is located at the upper right side of the IDE window, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/17df9d15-3f78-4982-80fc-48a433b0694e.png" style="width:42.33em;height:40.00em;"/></p>
<p>In the window that pops up, click on the <span class="packt_screen">New Tab</span> option, and you will see an orange bar below the code section of the Arduino IDE windows. In this orange bar, you can name the new tab and then press the <span class="packt_screen">OK</span> button to create the tab. The following screenshot shows how to name the new tab:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/af64ca57-2280-48f2-ba1a-0718dabd3aaf.png" style="width:32.75em;height:39.67em;"/></p>
<p>Once you click <span class="packt_screen">OK</span> a new tab is created, with the name you gave it, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/0c582b88-8706-47a0-a7ed-8536061683e7.png" style="width:34.42em;height:41.25em;"/></p>
<p>We can create a new tab in the Web Editor exactly as we did in the Arduino IDE. In the Web Editor, there is a similar button with an upside-down triangle. When that button is clicked a menu will appear, and you can select the <span class="packt_screen">New Tab</span> option. Once you name the new tab, it will appear in the Web Editor.</p>
<p>Before we start adding tabs to our projects, we need to have a plan on how we want to separate the code. I find that for large projects it is good practice to only have the <kbd>setup()</kbd> and <kbd>loop()</kbd> functions in the main tab. I then create a tab for each functional area of the project. For example, if I made a weather station that had both temperature rain sensors, then I would have my main tab with the <kbd>setup()</kbd> and <kbd>loop()</kbd> functions and then have two additional tabs; one for the temperature sensor functionality and one for the rain sensor functionality.</p>
<p>In addition to using additional tabs for code, it is also good practice, for larger projects and libraries, to have tabs that define constants that need to be used in multiple tabs. These constants are usually put into header files. A header file should be named with a <kbd>.h</kbd> extension. Now let's see how to work with tabs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with tabs</h1>
                </header>
            
            <article>
                
<p>When creating a new tab, the first thing we need to decide is what is going to the tab. For example in this section, we will create two new tabs. One will be named <kbd>led.h</kbd> and the other <kbd>led</kbd>. The <kbd>led.h</kbd> file will contain the constant definition, and the <kbd>led</kbd> file will contain code.</p>
<p>When we create a tab with the <kbd>.h</kbd> extension we are creating, what is known in the C language, a header file. A header file is a file that contains declarations and macro definitions. These tabs can then be included in the normal code tabs. In the next section, we will see another type of tab which is the cpp tab.</p>
<p>Once the new tabs are created, add the following code to the <kbd>led.h</kbd> tab:</p>
<pre>#ifndef LED_H
#define LED_H<br/> 
#define LED_ONE 3
#define LED_TWO 11
#endif</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>This code will define two constants, which are the pin header numbers for the two LEDs on the prototype that we built in <a href="f0039485-e47c-40c8-9130-fba1e1afd421.xhtml" target="_blank">C<span class="ChapterrefPACKT">hapter 4</span></a>, <em>Basic Prototyping</em>. The <kbd>#ifndef</kbd> and <kbd>#endif</kbd> ensure that the header file is imported only once within any tab. The <kbd>#ifndef</kbd> looks to see if the <kbd>LED_H</kbd> constant is defined, and if not then it includes the code between the <kbd>#ifndef</kbd> and <kbd>#endif</kbd>.</p>
<p>Now in the <kbd>led</kbd> tab add the following code:</p>
<pre>void blink_led(int led) {
  digitalWrite(led, HIGH);
  delay(500);
  digitalWrite(led, LOW);
  delay(500);
}</pre>
<p>The <kbd>blink_led()</kbd> function contains a single parameter, which will be the pin for the LED that we wish to blink. The function itself will turn the LED on for 1/2 a second and then turn it off.</p>
<p>Now in the main tab, we will need to include an <kbd>#include</kbd> statement at the top of the tab to include the <kbd>led.h</kbd> header file. The following code shows how to do this:</p>
<pre>#include "led.h"</pre>
<p>The <kbd>#include</kbd> statement will take a header file and includes it in the tab, allowing us to use the definitions within our code. If we attempted to use one of the constants within our code but forgot to include the header file, we would receive an error that the constant was not declared in this scope meaning the compiler was unable to find the declarations for the constant.</p>
<p>If we are adding a header file from the sketch, we are working in, the name of the header file is surrounded by double quotes. If we include a header file from a separate library the name will be surrounded by the less than and greater than signs. We will see this later in this book as we use third-party libraries.</p>
<p>In the <kbd>loop()</kbd> function, we will want to call the <kbd>blink_led()</kbd> function from the <kbd>led</kbd> tab. One thing to note here is we only need to include the <kbd>#include</kbd> statement for the header file and not for the tab that contains the code. The following shows the code for the main tab:</p>
<pre>#include "led.h"
void setup() {
  // put your setup code here, to run once:
  pinMode(LED_ONE, OUTPUT);
  pinMode(LED_TWO, OUTPUT);
}

void loop() {
  // put your main code here, to run repeatedly:
  blink_led(LED_ONE);
  delay(1000);
  blink_led(LED_TWO);
}</pre>
<p>Now if you connect the prototype that we created in <a href="f0039485-e47c-40c8-9130-fba1e1afd421.xhtml" target="_blank"><span class="ChapterrefPACKT">Chapter 4</span></a>, <em>Basic Prototyping</em>, you should see the LEDs blink one after the other.</p>
<p>Dividing your code between separate tabs is a great way to organize it when working with larger projects. This makes it a lot easier to maintain and organize your code.</p>
<p>Classes are usually used when creating libraries for the Arduino. While creating libraries is beyond the scope of this book, it is good to know what classes are and how to use them because we will be using libraries in certain sections of this book.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Object-oriented programming</h1>
                </header>
            
            <article>
                
<p><strong>Object-oriented programming</strong> (<strong>OOP</strong>) is a programming paradigm that helps us divide our code into reusable components using classes and objects. An object is designed to model something. For example, we could create an LED object that will contain the properties and functionality we want for a LED; however, before we can create an object we need to have a blueprint for it. This blueprint is called a <strong>class</strong>. Let's see how this works by creating a class that will help us control a LED.</p>
<p>We will start off by creating two new tabs named <kbd>led.cpp</kbd> and <kbd>led.h</kbd>. The <kbd>led.h</kbd> file will contain the definition for the class, and the <kbd>led.cpp</kbd> file will contain the code. Let's start off by adding the following code to the <kbd>led.h</kbd> file:</p>
<pre>#ifndef LED_H
#define LED_H

#define LED_ONE 3
#define LED_TWO 11

class Led{
  int ledPin;
  long onTime;
  long offTime;
  public:
    Led(int pin, long on, long off);
    void blinkLed();
    void turnOn();
    void turnOff();
};

#endif</pre>
<p>The code is similar to the <kbd>led.h</kbd> file in the working with tabs section except the <kbd>Led</kbd> class definition is added. The <kbd>Led</kbd> class definition defines three properties (variables) for the class: <kbd>ledPin</kbd>, <kbd>onTime</kbd>, and <kbd>offTime</kbd>. Previous to this example, all of the variables we used have been either global variables or defined within a function. Class properties are variables that are defined within a class and usually define something about the object. In this example, the <kbd>ledPin</kbd> property defines what pin the LED is connected to; the <kbd>onTime</kbd> property defines the amount of time to keep the LED on and the <kbd>offTime</kbd> property defines how long to keep the LED off.</p>
<p>After the properties, a constructor for the class is defined. A constructor is used to create an instance of a class, and we will see how to use this later in this section. After the constructor, three methods (functions) for the class. A class method is simply a function that is part of a class and usually defines the functionality of an object.</p>
<p>Where the <kbd>led.h</kbd> tab contains the definition for the <kbd>Led</kbd> class, the <kbd>led.cpp</kbd> tab contains the code for the class. Let's add the following code to the <kbd>led.cpp</kbd> tab:</p>
<pre>#include "led.h"
#include "Arduino.h"

Led::Led(int pin, long on, long off) {
  ledPin = pin;
  pinMode(ledPin, OUTPUT);
     
  onTime = on;
  offTime = off;
}
 
void Led::turnOn() {
  digitalWrite(ledPin, HIGH); 
}
 
void Led::turnOff(){
  digitalWrite(ledPin, LOW);
}
 
void Led::blinkLed() {
  this-&gt;turnOn();
  delay(onTime);              
  this-&gt;turnOff();
  delay(offTime);
}</pre>
<p>This code starts off by importing two header files. The first header file is the <kbd>led.h</kbd> file that we just created and the second is the <kbd>Arduino.h</kbd> header file. The <kbd>Arduino.h</kbd> header file contains the definitions for all of the custom Arduino functions. It is automatically added to the main tab; however, if you wish to use the Arduino custom functions in other tabs, as is needed here, we need to import this file.</p>
<p>Following the imports is the implementation of the constructor for the <kbd>Led</kbd> class that was defined in the <kbd>led.h</kbd> tab. When we implement a constructor or a method for a class we prefix the name of it with the name of the class followed by two colons (::). The name of a constructor for a class is required to be the same as the class name. Therefore, the implementation for the constructor is <kbd>Led::Led</kbd>. Within the constructor, we set the class properties and the pin mode for the pin that the LED is connected too.</p>
<p>The next two class methods, <kbd>Led::turnOn</kbd> and <kbd>Led::turnOff</kbd>, use the <kbd>digitalWrite()</kbd> method to turn the LED on or off. Notice how these two methods us the <kbd>ledPin</kbd> property within the <kbd>digitalWrite()</kbd> method. This property is set within the constructor when the class is created.</p>
<p>Finally the implementation for the <kbd>Led::blinkLed()</kbd> method is defined. This method uses the <kbd>Led::turnOn</kbd> and <kbd>Led::turnOff</kbd> methods defined previously to blink the LED on and OFF. When we call a method of a class we use the dash/greater than signs together (<kbd>-&gt;</kbd>) as shown in the <kbd>blinkLed()</kbd> method. The <kbd>this</kbd> keyword is used to refer to the current instance.</p>
<p>Now let's see how we would use the <kbd>Led</kbd> class. Within the main tab, the first thing we need to do is to include the <kbd>led.h</kbd> file. Add the following line to the top of the tab:</p>
<pre>#include "led.h"</pre>
<p>Next, we need to create a global instance of the <kbd>Led</kbd> class and give it a name of <kbd>led</kbd>. To do this, we use the constructor that we created for the class. The following code will create an instance of the <kbd>Led</kbd> class:</p>
<pre>Led led(LED_ONE, 1000, 500);</pre>
<p>Within the <kbd>Led</kbd> class the constructor is defined like this:</p>
<pre>Led::Led(int pin, long on, long off)</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Notice that the definition for the <kbd>Led</kbd> class has three parameters (<kbd>pin</kbd>, <kbd>on</kbd> and <kbd>off</kbd>). These three parameters match the three values that we are passing into the constructor when we create an instance of the <kbd>Led</kbd> class.</p>
<p>We can now use the class to make the LED blink by calling the <kbd>blinkLed()</kbd> method of the class. The following code shows how to do this:</p>
<pre>led.blinkLed();</pre>
<p>The following code shows the code within the main tab that will use the <kbd>Led</kbd> class to blink an LED:</p>
<pre>#include "led.h"
Led led(LED_ONE, 1000, 500);
void setup() {
}<br/>void loop() {
  led.blinkLed();
}</pre>
<p>If you run this code on the prototype that we created in <a href="f0039485-e47c-40c8-9130-fba1e1afd421.xhtml" target="_blank"><span class="ChapterrefPACKT">Chapter 4</span></a>, <em>Basic Prototyping</em>, you will see one of the LEDs blink.</p>
<p>In this section, we only gave a very brief introduction to OOP enabling you to understand how most professional Arduino libraries are created and how to use them. There are whole books written about OOP, and if you wish to create libraries for the Arduino, I would recommend reading more object-oriented design in general and OOP for the Arduino.</p>
<p>Now let's look at how we can use the built-in String library for the Arduino.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">String library</h1>
                </header>
            
            <article>
                
<p>The String library, which is part of the Arduino core libraries, enables us to use and manipulate text easier and in a more complex way then character arrays do. It does take more memory to use the String library than it does to use character arrays but it is easier to use the String library</p>
<p>There are numerous ways to create an instance of the String type. Let's look at a few examples here:</p>
<pre>String str1 = "Arduino";
String str2 = String("Arduino");
String str3 = String('B');
String str4 = String(str2 + " is Cool");</pre>
<p>Both of the first two lines create a simple string with the word <kbd>Arduino</kbd> in it. In the third line, a new String instance is created from a single constant character. In this line, notice that the single quote is used. The last example concatenates two Strings. There are several more constructors that enable us to create instances of the String class from a number. Here are a few examples:</p>
<pre>String strNum1 = String(42);
String strNum2 = String(42, HEX);
String strNum3 = String(42, BIN);</pre>
<p>In the preceding code, the <kbd>strNum1</kbd> String instance would contain the text <kbd>42</kbd>, which is the decimal version of the number 42. The <kbd>strNum2</kbd> String instance would contain the text <kbd>2a</kbd> which is the hex version of the number 42. The <kbd>strNum3</kbd> String instance would contain the text <kbd>101010</kbd>, which is the binary version of the number 42.</p>
<p>There are also numerous methods that can be used in instances of the <kbd>String</kbd> class. Some of these methods are:</p>
<ul>
<li><kbd>concat(string)</kbd>: Concatenates one string to the end of the original string.</li>
<li><kbd>endsWith(string)</kbd>: Returns true if the original string ends with the characters of the other string.</li>
<li><kbd>equals()</kbd>: Will compare two strings and return true if the strings contain the same text. When comparing the strings, this method is case sensitive.</li>
<li><kbd>equalsIgnoreCase()</kbd>: Will compare two strings and returns true if the strings contain the same text. When comparing strings, this method is case insensitive.</li>
<li><kbd>length()</kbd>: Returns the length of the strings. The length will not include the trailing null character.</li>
<li><kbd>replace(substring1, substring2)</kbd>: This method will replace all instances of one substring with another substring.</li>
<li><kbd>startsWith(string)</kbd>: Returns true if the original string starts with the characters of the other string.</li>
<li><kbd>toLowerCase()</kbd>: Returns the lower case version of the original string.</li>
<li><kbd>toUpperCase()</kbd>: Returns the upper case version of the original string.</li>
</ul>
<p>The String library can be used as a replacement for the character array; however, you will find that most sample code on the internet uses character arrays mainly because they take up less memory and they execute faster than the String library.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>This ends the introduction to the Arduino programming language. You can refer to the Arduino quick reference pages for additional information about the Arduino programming language.</p>
<p>You can find the reference pages here: <a href="https://www.arduino.cc/reference/en/">https://www.arduino.cc/reference/en/</a>. On this page, you will find links to information about the built-in Arduino functions and variables. That are also links to information about the operators and other Arduino language elements.</p>
<p>Don't worry if you do not feel comfortable writing your own Arduino programs right now because we will be writing a lot of code in the remaining chapters of this book, and by the end you should feel comfortable writing your own Arduino applications.</p>


            </article>

            
        </section>
    </body></html>