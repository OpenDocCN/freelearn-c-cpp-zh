["```cpp\nnamespace SmallWindows { \n\n```", "```cpp\n  extern map<HWND,Dialog*> dialogMap; \n  extern Font DialogFont; \n\n```", "```cpp\n  class Dialog : public Window { \n    public: \n      Dialog(String name, Point topLeft, \n             Window* parentPtr = nullptr, \n             WindowStyle style = OverlappedWindow, \n             WindowStyle extendedStyle = NoStyle, \n             Font font = DialogFont); \n\n```", "```cpp\n      bool DoModal(); \n\n```", "```cpp\n      ~Dialog(); \n\n```", "```cpp\n      int AddControl(Control* controlPtr); \n\n```", "```cpp\n      void OnSize(Size windowSize); \n\n```", "```cpp\n      void OnReturn(); \n      void OnEscape(); \n\n```", "```cpp\n      virtual void OnDialogInit() {/* Empty. */} \n\n```", "```cpp\n      virtual bool TryClose() const {return true;} \n      virtual void OnClose(); \n      virtual void OnDestroy() {/* Empty. */} \n\n```", "```cpp\n      map<WORD,Control*> IdMap() const {return idMap;} \n      map<WORD,Control*>& IdMap() {return idMap;} \n\n    private: \n      map<WORD,Control*> idMap; \n\n```", "```cpp\n      String header; \n      Point topLeft; \n      Font font; \n      WindowStyle style; \n      WindowStyle extendedStyle; \n\n```", "```cpp\n      int leftMargin, maxWidth, topMargin, maxHeight; \n\n```", "```cpp\n      int currentId = 1000; \n\n```", "```cpp\n      Size originalClientSize; \n\n```", "```cpp\n      friend INT_PTR CALLBACK \n        DialogProc(HWND windowHandle, UINT message, \n                   WPARAM wordParam, LPARAM longParam); \n  }; \n}; \n\n```", "```cpp\n#include \"SmallWindows.h\" \n\nnamespace SmallWindows { \n  map<HWND,Dialog*> dialogMap; \n\n```", "```cpp\n  Font DialogFont(TEXT(\"Times New Roman\"), 12); \n\n```", "```cpp\n  Dialog::Dialog(String header, Point topLeft, \n                 Window* parentPtr /*=nullptr*/, \n                 WindowStyle style /* = OverlappedWindow */, \n                 WindowStyle extendedStyle /* = NoStyle */, \n                 Font font /* = DialogFont */) \n   :Window(parentPtr), \n    header(header), \n    topLeft(topLeft), \n    style(style), \n    extendedStyle(extendedStyle), \n\n    font(font) { \n    // Empty. \n  } \n\n```", "```cpp\n  bool Dialog::DoModal() { \n    InfoList infoList; \n\n```", "```cpp\n    infoList.AddValue<WORD>(1); \n\n```", "```cpp\n    infoList.AddValue<WORD>(0xFFFF); \n\n```", "```cpp\n    infoList.AddValue<DWORD>(0); \n\n```", "```cpp\n    infoList.AddValue<DWORD>(extendedStyle); \n    infoList.AddValue<DWORD>(style | WS_CAPTION | WS_SYSMENU | \n                             DS_MODALFRAME | DS_SETFONT); \n\n```", "```cpp\n    infoList.AddValue<WORD>(idMap.size()); \n\n```", "```cpp\n    infoList.AddValue<WORD>(topLeft.X()); \n    infoList.AddValue<WORD>(topLeft.Y()); \n\n```", "```cpp\n    infoList.AddValue<WORD>(maxWidth + leftMargin); \n    infoList.AddValue<WORD>(maxHeight + topMargin); \n\n```", "```cpp\n    infoList.AddValue<WORD>(0); \n    infoList.AddValue<WORD>(0); \n\n```", "```cpp\n    infoList.AddString<TCHAR>(header); \n\n```", "```cpp\n    LOGFONT logFont = font.LogFont(); \n    infoList.AddValue<WORD>((WORD) logFont.lfHeight); \n    infoList.AddValue<WORD>((WORD) logFont.lfWeight); \n    infoList.AddValue<BYTE>(logFont.lfItalic); \n    infoList.AddValue<BYTE>(logFont.lfCharSet); \n    infoList.AddString<TCHAR>(logFont.lfFaceName); \n\n```", "```cpp\n    for (pair<WORD,Control*> entry : idMap) { \n      Control* controlPtr = entry.second; \n      controlPtr->AddControlInfo(infoList); \n    } \n\n```", "```cpp\n    HGLOBAL globalHandle = ::GlobalAlloc(0, infoList.Size()); \n    if (globalHandle != nullptr) { \n      char* buffer = (char*) ::GlobalLock(globalHandle); \n\n      if (buffer != nullptr) { \n        infoList.ToBuffer(buffer); \n\n```", "```cpp\n        HWND parentHandle = (parentPtr != nullptr) ? \n                            parentPtr->WindowHandle() : nullptr; \n        INT_PTR result = \n          ::DialogBoxIndirectParam(Application::InstanceHandle(), \n                     (DLGTEMPLATE*) buffer, parentHandle, \n                     DialogProc, (LPARAM) this); \n        ::GlobalUnlock(globalHandle); \n\n```", "```cpp\n        return (result != 0); \n      } \n    } \n\n```", "```cpp\n    return false;    \n  } \n\n```", "```cpp\n  Dialog::~Dialog() { \n    for (pair<WORD,Control*> entry : idMap) { \n      Control* controlPtr = entry.second; \n      delete controlPtr; \n    } \n  } \n\n```", "```cpp\n  int Dialog::AddControl(Control* controlPtr) { \n    Point topLeft = controlPtr->TopLeft(); \n    Size controlSize = controlPtr->GetSize(); \n\n    if (idMap.empty()) { \n      leftMargin = topLeft.X(); \n      topMargin = topLeft.X(); \n      maxWidth = topLeft.X() + controlSize.Width(); \n      maxHeight = topLeft.Y() + controlSize.Height(); \n    } \n    else { \n      leftMargin = min(leftMargin, topLeft.X()); \n      topMargin = min(topMargin, topLeft.Y()); \n      maxWidth = max(maxWidth, topLeft.X() + controlSize.Width()); \n      maxHeight = max(maxHeight,topLeft.Y()+controlSize.Height()); \n    } \n\n```", "```cpp\n    idMap[currentId] = controlPtr; \n    return currentId--; \n  } \n\n```", "```cpp\n  void Dialog::OnSize(Size newClientSize) { \n    pair<double, double> factorPair \n      (((double) newClientSize.Width() / \n       originalClientSize.Width()), \n       ((double) newClientSize.Height() / \n       originalClientSize.Height())); \n\n```", "```cpp\n    for (pair<WORD,Control*> entry : idMap) { \n      Control* controlPtr = entry.second; \n      Rect originalRect = controlPtr->OriginalRect(); \n      controlPtr->SetWindowDeviceRect(factorPair * originalRect); \n    } \n  } \n\n```", "```cpp\n  void Dialog::OnReturn() { \n    if (TryClose()) { \n      ::EndDialog(windowHandle, 1); \n    } \n  } \n\n  void Dialog::OnEscape() { \n    if (TryClose()) { \n      ::EndDialog(windowHandle, 0); \n    } \n  } \n\n  void Dialog::OnClose() { \n    if (TryClose()) { \n      ::EndDialog(windowHandle, 0); \n    } \n  } \n\n```", "```cpp\n  INT_PTR CALLBACK DialogProc(HWND dialogHandle, UINT message, \n                              WPARAM wordParam, LPARAM longParam){ \n    switch (message) { \n\n```", "```cpp\n      case WM_INITDIALOG: { \n          Dialog* dialogPtr = (Dialog*) longParam; \n          dialogMap[dialogHandle] = dialogPtr; \n\n```", "```cpp\n          dialogPtr->WindowHandle() = dialogHandle; \n          dialogPtr->originalClientSize = \n            dialogPtr->GetClientDeviceSize(); \n          dialogPtr->OnDialogInit(); \n\n```", "```cpp\n          for (pair<WORD,Control*> entry : dialogPtr->IdMap()) { \n            WORD controlId = entry.first; \n            Control* controlPtr = entry.second; \n            controlPtr->WindowHandle() = \n              ::GetDlgItem(dialogHandle,controlId); \n            controlPtr->OriginalRect() = \n              controlPtr->GetWindowDeviceRect(); \n            controlPtr->OnControlInit(dialogPtr); \n          } \n        }  \n\n```", "```cpp\n        return TRUE; \n\n```", "```cpp\n      case WM_SIZE: { \n          Dialog* dialogPtr = dialogMap[dialogHandle]; \n          assert(dialogPtr != nullptr); \n          Size clientSize = \n            {LOWORD(longParam), HIWORD(longParam)}; \n          dialogPtr->OnSize(clientSize); \n        } \n        return TRUE; \n\n```", "```cpp\n      case WM_CLOSE: { \n          Dialog* dialogPtr = dialogMap[dialogHandle]; \n          assert(dialogPtr != nullptr); \n          dialogPtr->OnClose(); \n        } \n        return TRUE; \n\n```", "```cpp\n      case WM_DESTROY: { \n          Dialog* dialogPtr = dialogMap[dialogHandle]; \n          dialogPtr->OnDestroy(); \n          dialogMap.erase(dialogHandle); \n        } \n        return TRUE; \n\n```", "```cpp\n      case WM_COMMAND: { \n          Dialog* dialogPtr = dialogMap[dialogHandle]; \n          WORD controlId = LOWORD(wordParam); \n\n```", "```cpp\n          switch (controlId) { \n            case IDOK: \n              dialogPtr->OnReturn(); \n              break; \n\n            case IDCANCEL: \n              dialogPtr->OnEscape(); \n              break; \n\n```", "```cpp\n            default: { \n                Control* controlPtr = \n                  dialogPtr->IdMap()[controlId]; \n                WORD notificationCode = HIWORD(wordParam); \n\n```", "```cpp\n                switch (notificationCode) { \n                  case EN_SETFOCUS: \n                    controlPtr->OnGainFocus(dialogPtr); \n                    break;  \n\n                  case EN_KILLFOCUS: \n                    controlPtr->OnLoseFocus(dialogPtr); \n                    break;  \n\n                  case EN_CHANGE: \n                    controlPtr->OnChange(dialogPtr); \n                    break;  \n\n                  case CBN_SELCHANGE: \n                    controlPtr->OnSelect(dialogPtr); \n                    break;  \n\n                  case BN_CLICKED: \n                    controlPtr->OnClick(dialogPtr); \n                    break;  \n                } \n              } \n          } \n        } \n\n```", "```cpp\n        return TRUE; \n    } \n\n```", "```cpp\n    return FALSE; \n  } \n}; \n\n```", "```cpp\nnamespace SmallWindows { \n  class Dialog; \n\n```", "```cpp\n  class Control : public Window { \n    public: \n      Control(Dialog* parentPtr, Point topLeft, Size controlSize, \n              String className, String text, int style); \n      void AddControlInfo(InfoList& infoList) const; \n\n      Point TopLeft() const {return topLeft;} \n      Size GetSize() const {return controlSize;} \n\n```", "```cpp\n      virtual void OnControlInit(Dialog* dialogPtr) {/* Empty. */} \n      virtual void OnGainFocus(Dialog* dialogPtr) {/* Empty. */} \n      virtual void OnLoseFocus(Dialog* dialogPtr) {/* Empty. */} \n      virtual void OnChange(Dialog* dialogPtr) {/* Empty. */} \n      virtual void OnSelect(Dialog* dialogPtr)  {/* Empty. */} \n      virtual void OnClick(Dialog* dialogPtr) {/* Empty. */} \n\n```", "```cpp\n      Rect OriginalRect() const {return originalRect;} \n      Rect& OriginalRect() {return originalRect;} \n\n    private: \n      Rect originalRect; \n\n```", "```cpp\n      int controlId, style; \n      Point topLeft; \n      Size controlSize; \n      String className; \n      String text; \n  }; \n}; \n\n```", "```cpp\n#include \"..\\\\SmallWindows.h\" \n\n```", "```cpp\nnamespace SmallWindows { \n  Control::Control(Dialog* parentPtr, Point topLeft, \n                   Size controlSize, String className, \n                   String text, int style) \n   :Window(parentPtr), \n    topLeft(topLeft), \n    controlSize(controlSize), \n    className(className), \n    text(text), \n    style(style) { \n    controlId = parentPtr->AddControl(this); \n  } \n\n```", "```cpp\n  void Control::AddControlInfo(InfoList& infoList) const { \n    infoList.Align<DWORD>(); \n\n```", "```cpp\n    infoList.AddValue<DWORD>(0); \n    infoList.AddValue<DWORD>(0); \n\n```", "```cpp\n    infoList.AddValue<DWORD>(WS_CHILD | WS_VISIBLE | style); \n\n```", "```cpp\n    infoList.AddValue<WORD>(topLeft.X()); \n    infoList.AddValue<WORD>(topLeft.Y()); \n    infoList.AddValue<WORD>(controlSize.Width()); \n    infoList.AddValue<WORD>(controlSize.Height()); \n\n```", "```cpp\n    infoList.AddValue<DWORD>(controlId); \n\n```", "```cpp\n    infoList.AddString<TCHAR>(className); \n    infoList.AddString<TCHAR>(text); \n\n```", "```cpp\n    infoList.AddValue<WORD>(0); \n  } \n}; \n\n```", "```cpp\nnamespace SmallWindows { \n\n  class ButtonControl : public Control { \n    public: \n      ButtonControl(Dialog* parentPtr, Point topLeft, \n                    Size controlSize, String text, int style); \n\n    protected: \n      void Check(bool check) const; \n      bool IsChecked() const; \n  }; \n}; \n\n```", "```cpp\n#include \"..\\\\SmallWindows.h\" \n\nnamespace SmallWindows { \n  ButtonControl::ButtonControl(Dialog* parentPtr, Point topLeft, \n                       Size controlSize, String text, int style) \n   :Control(parentPtr, topLeft, controlSize, \n            TEXT(\"button\"), text, style) { \n    // Empty. \n  } \n\n```", "```cpp\n  void ButtonControl::Check(bool check) const { \n    ::SendMessage(windowHandle, BM_SETCHECK, check ? 1 : 0, 0); \n  } \n\n  bool ButtonControl::IsChecked() const { \n    return (::SendMessage(windowHandle, BM_GETCHECK, 0, 0) != 0); \n  } \n}; \n\n```", "```cpp\nnamespace SmallWindows { \n  class GroupBox : public ButtonControl { \n    public: \n      GroupBox(Dialog* parentPtr, Point topLeft, \n               Size controlSize, String text); \n  }; \n}; \n\n```", "```cpp\n#include \"..\\\\SmallWindows.h\" \n\nnamespace SmallWindows { \n  GroupBox::GroupBox(Dialog* parentPtr, Point topLeft, \n                     Size controlSize, String text) \n   :ButtonControl(parentPtr, topLeft, controlSize, \n                  text, BS_GROUPBOX) { \n    // Empty. \n  } \n}; \n\n```", "```cpp\nnamespace SmallWindows { \n  class PushButton : public ButtonControl { \n    public: \n      PushButton(Dialog* parentPtr, Point topLeft, \n                 Size controlSize, String text, \n                 VoidListener clickListener, \n                 bool default = false); \n      void OnClick(Dialog* dialogPtr); \n\n    private: \n      VoidListener clickListener; \n  }; \n}; \n\n```", "```cpp\n#include \"..\\\\SmallWindows.h\" \n\nnamespace SmallWindows { \n  PushButton::PushButton(Dialog* parentPtr, Point topLeft, \n                         Size controlSize, String text, \n                         VoidListener clickListener, \n                         bool default /* = false */) \n   :ButtonControl(parentPtr, topLeft, controlSize, text, \n                  WS_BORDER | WS_GROUP| WS_TABSTOP | \n                  (default ? BS_DEFPUSHBUTTON : BS_PUSHBUTTON)), \n    clickListener(clickListener) { \n    // Empty. \n  } \n\n  void PushButton::OnClick(Dialog* dialogPtr) { \n    clickListener(dialogPtr); \n  } \n}; \n\n```", "```cpp\nnamespace SmallWindows { \n  class CheckBox : public ButtonControl { \n    public: \n      CheckBox(Dialog* parentPtr, Point topLeft, \n               Size controlSize, String text, bool* checkPtr); \n\n    private: \n      void OnControlInit(Dialog* dialogPtr); \n      void OnClick(Dialog* dialogPtr); \n      bool* checkPtr; \n  }; \n}; \n\n```", "```cpp\n#include \"..\\\\SmallWindows.h\" \n\nnamespace SmallWindows { \n  CheckBox::CheckBox(Dialog* parentPtr, Point topLeft, \n                 Size controlSize, String text, bool* checkPtr) \n\n   :ButtonControl(parentPtr, topLeft, controlSize, text, \n                  BS_AUTOCHECKBOX | WS_GROUP | WS_TABSTOP), \n    checkPtr(checkPtr) { \n  } \n\n```", "```cpp\n  void CheckBox::OnControlInit(Dialog* dialogPtr) { \n    Check(*checkPtr); \n  } \n\n  void CheckBox::OnClick(Dialog* dialogPtr) { \n    *checkPtr = IsChecked(); \n  } \n}; \n\n```", "```cpp\nnamespace SmallWindows { \n  class RadioButton : public ButtonControl { \n    public: \n      RadioButton(Dialog* parentPtr, Point topLeft, Size size, \n                  String text, int* indexPtr, int index); \n      void OnControlInit(Dialog* dialogPtr); \n      void OnClick(Dialog* dialogPtr); \n\n    private: \n      int *indexPtr, index; \n  }; \n}; \n\n```", "```cpp\n#include \"..\\\\SmallWindows.h\" \n\n```", "```cpp\nnamespace SmallWindows { \n  RadioButton::RadioButton(Dialog* parentPtr, Point topLeft, \n                           Size size, String text, int* indexPtr, \n                           int index) \n   :ButtonControl(parentPtr, topLeft, size, text, \n                  BS_AUTORADIOBUTTON | \n                  ((index == 0) ? (WS_GROUP | WS_TABSTOP) : 0)), \n    indexPtr(indexPtr), \n    index(index) { \n    // Empty. \n  } \n\n```", "```cpp\n  void RadioButton::OnControlInit(Dialog* dialogPtr) { \n    Check((*indexPtr) == index); \n  } \n\n  void RadioButton::OnClick(Dialog* dialogPtr) { \n    *indexPtr = index; \n  } \n}; \n\n```", "```cpp\nnamespace SmallWindows { \n  class ListControl : public Control { \n    public: \n      ListControl(Dialog* parentPtr, Point topLeft, \n                  Size controlSize, int style, \n                  list<String> textList); \n\n    protected: \n      void LoadList() const; \n\n    private: \n      list<String> textList; \n  }; \n}; \n\n```", "```cpp\n#include \"..\\\\SmallWindows.h\" \n\nnamespace SmallWindows { \n  ListControl::ListControl(Dialog* parentPtr, Point topLeft, \n                           Size controlSize, int style, \n                           list<String> textList) \n   :Control(parentPtr, topLeft, controlSize, \n            TEXT(\"listbox\"), TEXT(\"\"), style), \n    textList(textList) { \n    // Empty. \n  } \n\n```", "```cpp\n  void ListControl::LoadList() const { \n    for (String text : textList) { \n      ::SendMessage(windowHandle, LB_ADDSTRING, \n                    0, (LPARAM) text.c_str()); \n    } \n  } \n}; \n\n```", "```cpp\nnamespace SmallWindows { \n  class ListBox : public ListControl { \n    public: \n      ListBox(Dialog* parentPtr, Point topLeft, Size controlSize, \n              initializer_list<String> textList, int* indexPtr); \n      void OnControlInit(Dialog* dialogPtr); \n      void OnSelect(Dialog* dialogPtr); \n\n    private: \n      void SelectList(int index) const; \n      int GetListSelection() const; \n      int* indexPtr; \n  }; \n}; \n\n```", "```cpp\n#include \"..\\\\SmallWindows.h\" \n\nnamespace SmallWindows { \n  ListBox::ListBox(Dialog* parentPtr, Point topLeft, \n             Size controlSize, initializer_list<String>  textList, \n             int* indexPtr) \n   :ListControl(parentPtr, topLeft, controlSize, WS_VSCROLL | \n                WS_BORDER | LBS_NOTIFY | WS_GROUP | WS_TABSTOP, \n                textList), \n    indexPtr(indexPtr) { \n    // Empty. \n  } \n\n  void ListBox::OnControlInit(Dialog* dialogPtr) { \n    LoadList(); \n    SelectList(*indexPtr); \n  } \n\n  void ListBox::OnSelect(Dialog* dialogPtr) { \n    *indexPtr = GetListSelection(); \n  } \n\n```", "```cpp\n  void ListBox::SelectList(int index) const { \n    ::SendMessage(windowHandle, LB_SETCURSEL, index, 0); \n  } \n\n  int ListBox::GetListSelection() const { \n    return ::SendMessage(windowHandle, LB_GETCURSEL, 0, 0); \n  } \n}; \n\n```", "```cpp\nnamespace SmallWindows { \n  class MultipleListBox : public ListControl { \n    public: \n      MultipleListBox(Dialog* parentPtr, Point topLeft, \n              Size controlSize, initializer_list<String> textList, \n              set<int>* indexSetPtr); \n      void OnControlInit(Dialog* dialogPtr); \n      void OnSelect(Dialog* dialogPtr); \n\n    private: \n      void SelectMultiple(set<int>& indexSet) const; \n      set<int> GetSelectionMultiple() const; \n      set<int>* indexSetPtr; \n  }; \n}; \n\n```", "```cpp\n#include \"..\\\\SmallWindows.h\" \n\nnamespace SmallWindows { \n  MultipleListBox::MultipleListBox(Dialog* parentPtr, \n              Point topLeft, Size controlSize, \n              initializer_list<String> textList, \n              set<int>* indexSetPtr) \n   :ListControl(parentPtr, topLeft, controlSize, LBS_MULTIPLESEL | \n                WS_VSCROLL | WS_BORDER | LBS_NOTIFY | WS_GROUP | \n                WS_TABSTOP, textList), \n    indexSetPtr(indexSetPtr) { \n    // Empty. \n  } \n\n  void MultipleListBox::OnControlInit(Dialog* dialogPtr) { \n    LoadList(); \n    SelectMultiple(*indexSetPtr); \n  } \n\n  void MultipleListBox::OnSelect(Dialog* dialogPtr) { \n    *indexSetPtr = GetSelectionMultiple(); \n  } \n\n```", "```cpp\n  void MultipleListBox::SelectMultiple(set<int>& indexSet) const { \n    int size = ::SendMessage(windowHandle, LB_GETCOUNT, 0, 0); \n    for (int index = 0; index < size; ++index) { \n      BOOL selected = (indexSet.count(index) > 0) ? TRUE : FALSE; \n      ::SendMessage(windowHandle, LB_SETSEL, selected, index); \n    } \n  } \n\n```", "```cpp\n  set<int> MultipleListBox::GetSelectionMultiple() const { \n    int size = ::SendMessage(windowHandle, LB_GETCOUNT, 0, 0); \n\n    set<int> indexSet; \n    for (int index = 0; index < size; ++index) { \n      if (::SendMessage(windowHandle, LB_GETSEL, index, 0) != 0) { \n        indexSet.insert(index); \n      } \n    } \n\n    return indexSet; \n  } \n}; \n\n```", "```cpp\nnamespace SmallWindows { \n  class ComboBox : public Control { \n    public: \n      ComboBox(Dialog* parentPtr, Point topLeft, Size controlSize, \n               initializer_list<String> textList, int* indexPtr); \n      void OnControlInit(Dialog* dialogPtr); \n      void OnSelect(Dialog* dialogPtr); \n\n    private: \n      void LoadCombo() const; \n      void SelectCombo(int index) const; \n      int GetComboSelection() const; \n      list<String> textList; \n      int* indexPtr; \n  }; \n}; \n\n```", "```cpp\n#include \"..\\\\SmallWindows.h\" \n\nnamespace SmallWindows { \n  ComboBox::ComboBox(Dialog* parentPtr, Point topLeft, \n            Size controlSize, initializer_list<String> textList, \n            int* indexPtr) \n   :Control(parentPtr, topLeft, controlSize, TEXT(\"combobox\"), \n            TEXT(\"\"), CBS_DROPDOWN | CBS_HASSTRINGS | LBS_NOTIFY | \n            LBS_COMBOBOX | WS_GROUP | WS_TABSTOP), \n    textList(textList), \n    indexPtr(indexPtr) { \n    // Empty. \n  } \n\n  void ComboBox::OnControlInit(Dialog* dialogPtr) { \n    LoadCombo(); \n    SelectCombo(*indexPtr); \n  } \n\n  void ComboBox::OnSelect(Dialog* dialogPtr) { \n    *indexPtr = GetComboSelection(); \n  } \n\n```", "```cpp\n  void ComboBox::LoadCombo() const { \n    for (String text : textList) { \n      ::SendMessage(windowHandle, CB_ADDSTRING, \n                    0, (LPARAM) text.c_str()); \n    } \n  } \n\n  void ComboBox::SelectCombo(int index) const { \n    ::SendMessage(windowHandle, CB_SETCURSEL, index, 0); \n  } \n\n  int ComboBox::GetComboSelection() const { \n    return ::SendMessage(windowHandle, CB_GETCURSEL, 0, 0); \n  } \n}; \n\n```", "```cpp\nnamespace SmallWindows { \n  class Label : public Control { \n    public: \n      Label(Dialog* parentPtr, Point topLeft, \n            Size controlSize, String text); \n  }; \n}; \n\n```", "```cpp\n#include \"..\\\\SmallWindows.h\" \n\nnamespace SmallWindows { \n  Label::Label(Dialog* parentPtr, Point topLeft, \n               Size controlSize, String text) \n   :Control(parentPtr, topLeft, controlSize, \n            TEXT(\"static\"), text, 0) { \n  } \n}; \n\n```", "```cpp\nnamespace SmallWindows { \n  enum EditStyle {LeftEdit = ES_LEFT, CenterEdit = ES_CENTER, \n                  RightEdit = ES_RIGHT, DigitsOnly = ES_NUMBER, \n                  ReadOnly = ES_READONLY, Password = ES_PASSWORD, \n                  Uppercase = ES_UPPERCASE,Lowercase=ES_LOWERCASE, \n                  AutoScroll = ES_AUTOHSCROLL}; \n\n  enum {oct = 8, dec = 10, hex = 16}; \n\n  template <class Type = String, int Base = dec, \n            class TheConverter = Converter<Type>> \n  class TextField : public Control { \n    public: \n      TextField(Dialog* parentPtr, Point topLeft, \n                Size controlSize, Type* valuePtr, \n                int size = 100, EditStyle style = AutoScroll); \n\n```", "```cpp\n      void OnControlInit(Dialog* dialogPtr); \n      void OnLoseFocus(Dialog* dialogPtr); \n\n    protected: \n      String GetText() const; \n      void SetText(String text); \n\n    private: \n      Type* valuePtr; \n  }; \n\n  template <class Type = String, int Base = dec, \n            class TheConverter = Converter<Type>> \n  TextField<Type,Base,TheConverter>::TextField \n    (Dialog* parentPtr, Point topLeft, Size controlSize, \n     Type* valuePtr, int size /* = 100 */, \n     EditStyle style /* = AutoScroll */) \n   :Control(parentPtr, topLeft, controlSize, TEXT(\"edit\"), \n            TEXT(\"\"), style | WS_BORDER | WS_GROUP | WS_TABSTOP), \n    valuePtr(valuePtr) { \n    // Empty. \n  } \n\n```", "```cpp\n  template <class Type = String, int Base = dec, \n            class TheConverter = Converter<Type>> \n  String TextField<Type,Base,TheConverter>::GetText() const { \n    TCHAR buffer[MAX_PATH]; \n    ::GetWindowText(windowHandle, buffer, MAX_PATH); \n    return String(buffer); \n  } \n\n  template <class Type = String, int Base = dec, \n            class TheConverter = Converter<Type>> \n  void TextField<Type,Base,TheConverter>::SetText(String text) { \n    ::SetWindowText(windowHandle, text.c_str()); \n  } \n\n```", "```cpp\n  template <class Type = String, int Base = dec, \n            class TheConverter = Converter<Type>> \n  void TextField<Type,Base,TheConverter>::OnControlInit \n                                          (Dialog* dialogPtr) { \n    SetText(TheConverter::ValueToText(*valuePtr, Base)); \n  } \n\n```", "```cpp\n  template <class Type = String, int Base = dec, \n            class TheConverter = Converter<Type>> \n  void TextField<Type,Base,TheConverter>::OnLoseFocus \n                                          (Dialog* dialogPtr) { \n    String text = GetText(); \n\n    if (TheConverter::Check(text, Base)) { \n      *valuePtr = TheConverter::TextToValue(text, Base); \n    } \n\n    SetText(TheConverter::ValueToText(*valuePtr, Base)); \n  } \n}; \n\n```", "```cpp\nnamespace SmallWindows { \n  template <class Type> \n  class Converter { \n    public: \n      static bool Check(String& text, int base); \n      static Type TextToValue(String& text, int base); \n      static String ValueToText(Type& value, int base); \n  }; \n\n```", "```cpp\n  template <> \n  class Converter<int> { \n    public: \n      static bool Check(String& text, int base); \n      static int TextToValue(String& text, int base); \n      static String ValueToText(int& value, int base); \n  }; \n\n```", "```cpp\n#include \"SmallWindows.h\" \n\n```", "```cpp\nnamespace SmallWindows { \n  bool Converter<int>::Check(String& text, int base) { \n    IStringStream stringStream(Trim(text)); \n    int value; \n    stringStream >> setbase(base) >> value; \n    return stringStream.eof(); \n  } \n\n```", "```cpp\n  int Converter<int>::TextToValue(String& text, int base) { \n    IStringStream stringStream(Trim(text)); \n    int value; \n    stringStream >> setbase(base) >> value; \n    return value; \n  } \n\n```", "```cpp\n  String Converter<int>::ValueToText(int& value, int base) { \n    OStringStream outputStream; \n    outputStream << setbase(base) << value; \n    return outputStream.str(); \n  } \n\n```", "```cpp\n  template <> \n  class Converter<unsigned int> { \n    public: \n      static bool Check(String& text, int base); \n      static unsigned int TextToValue(String& text, int base); \n      static String ValueToText(unsigned int& value, int base); \n  }; \n\n```", "```cpp\n  bool Converter<unsigned int>::Check(String& text, int base) { \n    IStringStream stringStream(Trim(text)); \n    unsigned int value; \n    stringStream >> setbase(base) >> value; \n    return stringStream.eof() && (text.find(TEXT(\"-\")) == -1); \n  } \n  unsigned int Converter<unsigned int>::TextToValue(String& text, \n                                                     int base){ \n    IStringStream stringStream(Trim(text)); \n    unsigned int value; \n    stringStream >> setbase(base) >> value; \n    return value; \n  } \n  String Converter<unsigned int>::ValueToText(unsigned int&value, \n                                               int base){ \n    OStringStream outputStream; \n    outputStream << setbase(base) << value; \n    return outputStream.str(); \n  } \n\n```", "```cpp\n  template <> \n  class Converter<double> { \n    public: \n      static bool Check(String& text, int /* base */); \n      static double TextToValue(String& text, int /* base */); \n      static String ValueToText(double& value, int /* base */); \n  }; \n\n```", "```cpp\n  bool Converter<double>::Check(String& text, int /* base */) { \n    IStringStream stringStream(Trim(text)); \n    double value; \n    stringStream >> value; \n    return stringStream.eof(); \n  } \n\n  double Converter<double>::TextToValue(String& text, \n                                         int /* base */) { \n    IStringStream stringStream(Trim(text)); \n    double value; \n    stringStream >> value; \n    return value; \n  } \n  String Converter<double>::ValueToText(double& value, \n                                         int /* base */) { \n    OStringStream outputStream; \n    outputStream << value; \n    return outputStream.str(); \n  } \n\n```", "```cpp\n  template <> \n  class Converter<String> { \n    public: \n      static bool Check(String& text, int /* base */) \n                       {return true;} \n      static String TextToValue(String& text, int /* base */) \n                               {return String(text);} \n      static String ValueToText(String& value, int /* base */) \n                               {return String(value);} \n  }; \n\n```", "```cpp\n  template <> \n  class Converter<Rational> { \n\n    public: \n      static bool Check(String& text, int /* base */); \n      static Rational TextToValue(String& text, int /* base */); \n      static String ValueToText(Rational& value, int /* base */); \n  }; \n\n```", "```cpp\n  bool Converter<Rational>::Check(String& text, int /* base */) { \n    try { \n      Rational value(text); \n      return true; \n    } \n    catch (NotaRationalNumber) { \n      return false; \n    } \n  } \n\n```", "```cpp\n  Rational Converter<Rational>::TextToValue(String& text, \n                                             int /* base */) { \n    return Rational(text); \n  } \n\n```", "```cpp\n  String Converter<Rational>::ValueToText(Rational& value, \n                                           int /* base */) { \n    return ((String) value); \n  } \n\n```", "```cpp\n  template <> \n  class Converter<Complex> { \n    public: \n      static bool Check(String& text, int /* base */); \n      static Complex TextToValue(String& text, int /* base */); \n      static String ValueToText(Complex& value, int /* base */); \n  }; \n}; \n\n```", "```cpp\n  bool Converter<Complex>::Check(String& text, int /* base */) { \n    try { \n      Complex value(text); \n      return true; \n    } \n    catch (NotaComplexNumber) { \n      return false; \n    } \n  } \n\n  Complex Converter<Complex>::TextToValue(String& text, \n                                           int /* base */) { \n    return Complex(text); \n  } \n\n  String Converter<Complex>::ValueToText(Complex& value, \n                                          int /* base */) { \n    return ((String) value); \n  } \n}; \n\n```", "```cpp\nnamespace SmallWindows { \n  enum Orientation {Portrait, Landscape}; \n\n  class PageSetupInfo { \n    public: \n      PageSetupInfo(); \n      PageSetupInfo(const PageSetupInfo& pageSetupInfo); \n      bool operator==(const PageSetupInfo& pageSetupInfo); \n      bool operator!=(const PageSetupInfo& pageSetupInfo); \n\n      void ClearPageSetupInfo(); \n      bool WritePageSetupInfoToStream(ostream& outStream) const; \n      bool ReadPageSetupInfoFromStream(istream& inStream); \n\n      Orientation& GetOrientation() {return orientation;} \n      int& LeftMargin() {return leftMargin;} \n      int& TopMargin() {return topMargin;} \n      int& RightMargin() {return rightMargin;} \n      int& BottomMargin() {return bottomMargin;} \n      String& HeaderText() {return headerText;} \n      String& FooterText() {return footerText;} \n      bool& HeaderFirst() {return headerFirst;} \n      bool& FooterFirst() {return footerFirst;} \n      bool& Frame() {return frame;} \n      Font& HeaderFont() {return headerFont;} \n      Font& FooterFont() {return footerFont;} \n\n      Orientation GetOrientation() const {return orientation;} \n      int LeftMargin() const {return leftMargin;} \n      int TopMargin() const {return topMargin;} \n      int RightMargin() const {return rightMargin;} \n      int BottomMargin() const {return bottomMargin;} \n      String HeaderText() const {return headerText;} \n      String FooterText() const {return footerText;} \n      bool HeaderFirst() const {return headerFirst;} \n      bool FooterFirst() const {return footerFirst;} \n      bool Frame() const {return frame;} \n      Font HeaderFont() const {return headerFont;} \n      Font FooterFont() const {return footerFont;} \n\n    private: \n      Orientation orientation; \n      int leftMargin, topMargin, rightMargin, bottomMargin; \n      String headerText, footerText; \n      bool headerFirst, footerFirst, frame; \n      Font headerFont, footerFont; \n }; \n}; \n\n```", "```cpp\n#include \"..\\\\SmallWindows\\\\SmallWindows.h\" \n\n```", "```cpp\nnamespace SmallWindows { \n  PageSetupInfo::PageSetupInfo() { \n    ClearPageSetupInfo(); \n  } \n\n```", "```cpp\n  PageSetupInfo::PageSetupInfo(const PageSetupInfo& pageSetupInfo) \n   :orientation(pageSetupInfo.orientation), \n    leftMargin(pageSetupInfo.leftMargin), \n    topMargin(pageSetupInfo.topMargin), \n    rightMargin(pageSetupInfo.rightMargin), \n    bottomMargin(pageSetupInfo.bottomMargin), \n    headerText(pageSetupInfo.headerText), \n    footerText(pageSetupInfo.footerText), \n    headerFirst(pageSetupInfo.headerFirst), \n    footerFirst(pageSetupInfo.footerFirst), \n    frame(pageSetupInfo.frame), \n    headerFont(pageSetupInfo.headerFont), \n    footerFont(pageSetupInfo.footerFont) { \n     // Empty. \n  } \n\n```", "```cpp\n  bool PageSetupInfo::operator== \n         (const PageSetupInfo& pageSetupInfo) { \n    return (orientation == pageSetupInfo.orientation) && \n           (leftMargin == pageSetupInfo.leftMargin) && \n           (topMargin == pageSetupInfo.topMargin) && \n           (rightMargin == pageSetupInfo.rightMargin) && \n           (bottomMargin == pageSetupInfo.bottomMargin) && \n           (headerText == pageSetupInfo.headerText) && \n           (footerText == pageSetupInfo.footerText) && \n           (headerFirst == pageSetupInfo.headerFirst) && \n           (footerFirst == pageSetupInfo.footerFirst) && \n           (frame == pageSetupInfo.frame) && \n           (headerFont == pageSetupInfo.headerFont) && \n           (footerFont == pageSetupInfo.footerFont); \n  } \n\n  bool PageSetupInfo::operator!= \n         (const PageSetupInfo& pageSetupInfo) { \n    return !(*this == pageSetupInfo); \n  } \n  void PageSetupInfo::ClearPageSetupInfo() { \n    orientation = Portrait; \n    leftMargin = 25; \n    topMargin = 25; \n    rightMargin = 25; \n    bottomMargin = 25; \n    headerText = TEXT(\"\"); \n    footerText = TEXT(\"\"); \n    headerFirst = true; \n    footerFirst = true; \n    frame = true; \n    headerFont = Font(TEXT(\"Times New Roman\"), 12, false, true); \n    footerFont = Font(TEXT(\"Times New Roman\"), 12, false); \n  } \n\n```", "```cpp\n  bool PageSetupInfo::WritePageSetupInfoToStream \n                      (ostream& outStream) const { \n    outStream.write((char*) &orientation, sizeof orientation); \n    outStream.write((char*) &leftMargin, sizeof leftMargin); \n    outStream.write((char*) &topMargin, sizeof topMargin); \n    outStream.write((char*) &rightMargin, sizeof rightMargin); \n    outStream.write((char*) &bottomMargin, sizeof bottomMargin); \n    WriteStringToStream(headerText, outStream); \n    WriteStringToStream(footerText, outStream); \n    outStream.write((char*) &headerFirst, sizeof headerFirst); \n    outStream.write((char*) &footerFirst, sizeof footerFirst); \n    outStream.write((char*) &frame, sizeof frame); \n    headerFont.WriteFontToStream(outStream); \n    footerFont.WriteFontToStream(outStream); \n    return ((bool) outStream); \n  } \n\n  bool PageSetupInfo::ReadPageSetupInfoFromStream \n                      (istream& inStream) { \n    inStream.read((char*) &orientation, sizeof orientation); \n    inStream.read((char*) &leftMargin, sizeof leftMargin); \n    inStream.read((char*) &topMargin, sizeof topMargin); \n    inStream.read((char*) &rightMargin, sizeof rightMargin); \n    inStream.read((char*) &bottomMargin, sizeof bottomMargin); \n    ReadStringFromStream(headerText, inStream); \n    ReadStringFromStream(footerText, inStream); \n    inStream.read((char*) &headerFirst, sizeof headerFirst); \n    inStream.read((char*) &footerFirst, sizeof footerFirst); \n    inStream.read((char*) &frame, sizeof frame); \n    headerFont.ReadFontFromStream(inStream); \n    footerFont.ReadFontFromStream(inStream); \n    return ((bool) inStream); \n  } \n}; \n\n```", "```cpp\nnamespace SmallWindows { \n  class PageSetupDialog : public Dialog { \n    public: \n      PageSetupDialog(Window* parentPtr, PageSetupInfo* infoPtr); \n\n```", "```cpp\n      DEFINE_VOID_LISTENER(PageSetupDialog, OnHeaderFont); \n      DEFINE_VOID_LISTENER(PageSetupDialog, OnFooterFont);       \n      DEFINE_VOID_LISTENER(PageSetupDialog, OnOk); \n      DEFINE_VOID_LISTENER(PageSetupDialog, OnCancel); \n\n```", "```cpp\n    private: \n      PageSetupInfo *infoPtr, backupInfo; \n  }; \n}; \n\n```", "```cpp\n#include \"SmallWindows.h\" \n\n```", "```cpp\nnamespace SmallWindows { \n  PageSetupDialog::PageSetupDialog(Window* parentPtr, \n                                   PageSetupInfo* infoPtr) \n   :Dialog(TEXT(\"Page Setup\"), Point(0, 0), parentPtr), \n    infoPtr(infoPtr), \n    backupInfo(*infoPtr) { \n\n```", "```cpp\n    new GroupBox(this, Point(10, 10), \n                 Size(330, 50), TEXT(\"Margins\")); \n    new Label(this, Point(20, 20), Size(50, 10), \n              TEXT(\"&Top Margin:\")); \n\n```", "```cpp\n    new TextField<int>(this, Point(70, 20), Size(100, 12), \n                       &infoPtr->TopMargin()); \n    new Label(this, Point(180, 20), Size(50, 10), \n              TEXT(\"&Bottom Margin:\")); \n    new TextField<int>(this, Point(230, 20), Size(100, 12), \n                       &infoPtr->BottomMargin()); \n    new Label(this, Point(20, 40), Size(50, 10), \n              TEXT(\"&Left Margin:\")); \n    new TextField<int>(this, Point(70, 40), Size(100, 12), \n                       &infoPtr->LeftMargin()); \n    new Label(this, Point(180, 40), Size(50, 10), \n              TEXT(\"&Right Margin:\")); \n    new TextField<int>(this, Point(230, 40), Size(100, 12), \n                       &infoPtr->RightMargin()); \n\n    new GroupBox(this, Point(10, 70), \n                 Size(330, 50), TEXT(\"Header\")); \n    new Label(this, Point(20, 80), Size(50, 10), \n              TEXT(\"&Header Text:\")); \n    new TextField<>(this, Point(70, 80), Size(260, 12), \n                    &infoPtr->HeaderText()); \n\n```", "```cpp\n    new CheckBox(this, Point(70, 100), Size(100, 10), \n                 TEXT(\"H&eader at First Page\"), \n                 &infoPtr->HeaderFirst()); \n\n```", "```cpp\n    new PushButton(this, Point(270, 98), Size(60, 15), \n                   TEXT(\"He&ader Font\"), OnHeaderFont); \n\n    new GroupBox(this, Point(10, 130), \n                 Size(330, 50), TEXT(\"Footer\")); \n    new Label(this, Point(20, 140), Size(50, 10), \n              TEXT(\"&Footer Text:\")); \n    new TextField<>(this, Point(70, 140), Size(260, 12), \n                    &infoPtr->FooterText()); \n    new CheckBox(this, Point(70, 160), Size(100, 10), \n                 TEXT(\"F&ooter at First Page\"), \n                 &infoPtr->FooterFirst()); \n    new PushButton(this, Point(270, 158), Size(60, 15), \n                   TEXT(\"Footer Fo&nt\"), OnFooterFont); \n\n    new Label(this, Point(20, 190), Size(40, 10), \n              TEXT(\"&Orientation:\")); \n    new ComboBox(this, Point(65, 190), Size(70, 30), \n                 {TEXT(\"Portrait\"), TEXT(\"Landscape\")}, \n                 (int*) &infoPtr->GetOrientation()); \n    new CheckBox(this, Point(20, 205), Size(100, 10), \n                 TEXT(\"Page &Surrounded by Frame\"), \n                 &infoPtr->Frame()); \n    new PushButton(this, Point(200, 200), \n                   Size(60, 15), TEXT(\"Ok\"), OnOk); \n    new PushButton(this, Point(270, 200), Size(60, 15), \n                   TEXT(\"Cancel\"), OnCancel); \n  } \n\n```", "```cpp\n  void PageSetupDialog::OnHeaderFont() { \n    StandardDialog::FontDialog(this, infoPtr->HeaderFont()); \n  } \n\n  void PageSetupDialog::OnFooterFont() { \n    StandardDialog::FontDialog(this, infoPtr->FooterFont()); \n  } \n\n```", "```cpp\n  void PageSetupDialog::OnOk() { \n    Dialog::OnReturn(); \n  } \n\n  void PageSetupDialog::OnCancel() { \n    *infoPtr = backupInfo; \n    Dialog::OnEscape(); \n  } \n}; \n\n```", "```cpp\nnamespace SmallWindows { \n  String Template(const Document* documentPtr, String templateText, \n                  int copy = 0, int page = 0, int totalPages = 0); \n}; \n\n```", "```cpp\n#include \"SmallWindows.h\" \n\nnamespace SmallWindows { \n  String Template(const Document* documentPtr, String templateText, \n                  int copy /* = 0 */, int page /* = 0 */, \n                  int totalPages /* = 0 */) { \n\n```", "```cpp\n    ReplaceAll(templateText, TEXT(\"%c\"), to_String(copy)); \n    ReplaceAll(templateText, TEXT(\"%n\"), to_String(page)); \n    ReplaceAll(templateText, TEXT(\"%N\"), to_String(totalPages)); \n\n```", "```cpp\n    String pathWithSuffix = documentPtr->GetName(); \n    ReplaceAll(templateText, TEXT(\"%P\"), pathWithSuffix); \n\n    int lastPathDot = pathWithSuffix.find_last_of(TEXT('.')); \n    String pathWithoutSuffix = \n      pathWithSuffix.substr(0, lastPathDot); \n    ReplaceAll(templateText, TEXT(\"%p\"), pathWithoutSuffix); \n\n    int lastBackslash = pathWithSuffix.find_last_of(TEXT('')); \n    String fileWithSuffix = \n      pathWithSuffix.substr(lastBackslash + 1); \n    ReplaceAll(templateText, TEXT(\"%F\"), fileWithSuffix); \n\n    int lastFileDot = fileWithSuffix.find_last_of(TEXT('.')); \n    String fileWithoutSuffix = \n      fileWithSuffix.substr(0, lastFileDot); \n    ReplaceAll(templateText, TEXT(\"%f\"), fileWithoutSuffix); \n\n```", "```cpp\n    time_t t = ::time(nullptr); \n    struct tm time; \n    ::localtime_s(&time, &t); \n\n```", "```cpp\n    { OStringStream timeWithoutSeconds; \n      timeWithoutSeconds << std::setw(2) << setw(2) \n                         << setiosflags(ios::right)  \n                         << setfill(TEXT('0')) << time.tm_hour \n                         << TEXT(\":\") << setiosflags(ios::right) \n                         << setw(2) << setfill(TEXT('0')) \n                         << time.tm_min; \n\n      ReplaceAll(templateText, TEXT(\"%t\"), \n                 timeWithoutSeconds.str()); \n\n      OStringStream timeWithSeconds; \n      timeWithSeconds << timeWithoutSeconds.str() << TEXT(\":\") \n                      << setiosflags(ios::right) << setw(2) \n                      << setfill(TEXT('0')) << time.tm_sec; \n      ReplaceAll(templateText, TEXT(\"%T\"), timeWithSeconds.str()); \n    } \n\n    { static const String longMonths[] = \n        {TEXT(\"January\"), TEXT(\"February\"), TEXT(\"March\"), \n         TEXT(\"April\"), TEXT(\"May\"), TEXT(\"June\"), TEXT(\"July\"), \n         TEXT(\"August\"), TEXT(\"September\"), TEXT(\"October\"), \n         TEXT(\"November\"), TEXT(\"December\")}; \n      OStringStream dateFullMonth; \n      dateFullMonth << longMonths[time.tm_mon] << TEXT(\" \") \n                    << time.tm_mday << TEXT(\", \") \n                    << (1900 + time.tm_year); \n      ReplaceAll(templateText, TEXT(\"%D\"), dateFullMonth.str()); \n    } \n\n    { static const String shortMonths[] = \n        {TEXT(\"Jan\"), TEXT(\"Feb\"), TEXT(\"Mar\"), TEXT(\"Apr\"), \n         TEXT(\"May\"), TEXT(\"Jun\"), TEXT(\"Jul\"), TEXT(\"Aug\"), \n         TEXT(\"Sep\"), TEXT(\"Oct\"), TEXT(\"Nov\"), TEXT(\"Dec\")}; \n      OStringStream dateShortMonth; \n      dateShortMonth << shortMonths[time.tm_mon] << TEXT(\" \") \n                     << time.tm_mday << TEXT(\", \") \n                     << (1900 + time.tm_year); \n      ReplaceAll(templateText, TEXT(\"%d\"), dateShortMonth.str()); \n    } \n\n```", "```cpp\n    ReplaceAll(templateText, TEXT(\"%%\"), TEXT(\"%\")); \n    return templateText; \n  } \n}; \n\n```"]