<html><head></head><body>
		<div><h1 class="chapter-number" id="_idParaDest-44"><a id="_idTextAnchor065"/>3</h1>
			<h1 id="_idParaDest-45"><a id="_idTextAnchor066"/>Making a Lobby to Gather Players Together</h1>
			<p>In the previous chapter, we discussed how to use UDP packets to exchange data between multiple players in a game. While this approach is highly efficient, it requires a lot of manual work to ensure that data is sent and received correctly. In this chapter, we will explore the high-level network API of the Godot Engine, which simplifies the networking process by providing a set of built-in tools and functions that can handle common network tasks.</p>
			<p>Specifically, we will focus on<a id="_idIndexMarker088"/> the <strong class="bold">ENetMultiplayerPeer API</strong>, which is the Godot Engine’s wrapper class for its ENet library implementation, and <strong class="bold">Remote Procedure Call</strong> (<strong class="bold">RPC</strong>), a <a id="_idIndexMarker089"/>communication protocol that allows us to make calls to functions and methods on remote computers as if we were making them locally. We will use these tools to create a lobby, authenticate players, retrieve player avatar data from a fake JSON database, and synchronize all players when a player enters the lobby. We will explore the benefits of using RPCs instead of exchanging UDP packets, and how this approach can simplify the process of synchronizing game states between multiple players.</p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>Calling functions remotely with RPCs</li>
				<li>Understanding the multiplayer authority</li>
				<li>Comparing UDP and ENet approaches</li>
				<li>Remaking the login screen with RPCs</li>
				<li>Adding the player’s avatar</li>
				<li>Retrieving players’ avatars</li>
				<li>Testing the lobby</li>
			</ul>
			<p>By the end of this chapter, you will have a solid understanding of how to use the Godot Engine’s high-level network API and RPCs to create a robust multiplayer lobby for your game.</p>
			<h1 id="_idParaDest-46"><a id="_idTextAnchor067"/>Technical requirements</h1>
			<p>In this chapter, we will build yet another project using the Godot Engine. Remember, throughout this book, we are using Godot Engine version 4.0, so this is also a requirement.</p>
			<p>This time around, we are going to use the files provided in the <code>res://03.making-lobby-to-gather-players</code> folder. So, if you don’t have the project repository yet, download it through this link:</p>
			<p><a href="https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0">https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0</a></p>
			<p>Then, with the project added to your Godot Engine’s project manager, open the project and proceed to the <code>res://03.making-lobby-to-gather-players</code> folder<a id="_idTextAnchor068"/>.</p>
			<h1 id="_idParaDest-47"><a id="_idTextAnchor069"/>Calling functions remotely with RPCs</h1>
			<p>In a <a id="_idIndexMarker090"/>network context, <strong class="bold">RPC</strong> stands for <strong class="bold">remote procedure call</strong>, which is a protocol that allows one program to call a function or procedure on another program running on a different machine or over a network. In the context of the Godot Engine, RPCs allow objects to exchange data between each other over the network, which is a key feature in creating multiplayer games.</p>
			<p>To use RPCs in the<a id="_idIndexMarker091"/> Godot Engine, we need to <a id="_idIndexMarker092"/>use the <code>ENetMultiplayerPeer</code> API, which provides a high-level network interface for handling network connections and sending and receiving data, as well as managing RPCs. By using <code>ENetMultiplayerPeer</code>, we can easily send and receive RPCs and handle network communication more straightforwardly.</p>
			<p>When exchanging data with RPCs, objects can exchange data through functions, which makes the process more straightforward compared to exchanging data using UDP packets. With UDP packets, we need to send packets requesting procedures and wait for a response, and only then can we get the data. This process can be complex and difficult to manage, as we saw in the previous chapter, especially in large games with many objects exchanging data.</p>
			<p>One limitation<a id="_idIndexMarker093"/> of RPCs is that they don’t allow the transmission of objects, such as nodes or resources, through the network. This can be a challenge in games that require the exchange of complex objects between different machines. However, there are workarounds to this limitation, such as sending serialized data or using custom serialization methods. We learned how to do that in <a href="B18527_02.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Sending and Receiving Data</em>, so this won’t be a problem to us.</p>
			<p>RPCs are a powerful tool for <a id="_idIndexMarker094"/>creating multiplayer<a id="_idIndexMarker095"/> games, and using the <code>ENetMultiplayerPeer</code> API in the Godot Engine makes it easy to use them. Although there are limitations to RPCs, such as the inability to transmit objects over the network, they are still a crucial part of creating a robust and seamless multiplayer expe<a id="_idTextAnchor070"/>rience.</p>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor071"/>Introducing the @rpc annotation</h2>
			<p>Godot Engine 4.0 introduces a<a id="_idIndexMarker096"/> new feature called <code>@rpc</code> function annotation. An <code>@rpc</code>, this annotation is used to mark functions that can be called remotely over the network in a multiplayer game.</p>
			<p>There are several options that we can add to the <code>@rpc</code> annotation, which control how the function is called and executed over the network.</p>
			<p>Let’s take a closer look at each option:</p>
			<ul>
				<li>We have the calling options, meaning what should happen when we make an RPC to this function:<ul><li><code>call_remote</code>: This option indicates that the function should only be called remotely on instances of the node in other peers’ machines but not on the node’s local instance.</li><li><code>call_local</code>: This option indicates that the function should also be called locally on the current peer’s instance of the node as well. This is useful when we need to sync all peers in the network, including the caller.</li></ul></li>
				<li>Then, we have the <a id="_idIndexMarker098"/>caller option, meaning who can call this function remotely:<ul><li><code>authority</code>: This option indicates that the function should only be called by the multiplayer authority. We’ll see more about that soon.</li><li><code>any_peer</code>: This option indicates that the function can be called by any peer in the network. This is useful for functions that can be executed by multiple peers in a multiplayer game and not only the multiplayer authority.</li></ul></li>
				<li>We also have options regarding the reliability of the remote data exchange when we make an RPC to this function:<ul><li><code>reliable</code>: This option indicates that the function should be executed reliably over the network, which means that the function call will be guaranteed to arrive at its destination. This is useful for functions that need to be executed without the risk of losing data.</li><li><code>unreliable</code>: This option indicates that the function should be executed with low reliability, which means that there is a chance that some data may be lost or delayed over the network. This is useful for functions that can tolerate some loss of data.</li><li><code>unreliable_ordered</code>: This option is similar to <code>unreliable</code> but ensures that function calls are executed in order over the network. This is useful for functions that need to be executed in a specific order but can tolerate some data loss.</li></ul></li>
			</ul>
			<p>We can also specify which connection channel the RPC should use to transmit its data. This is useful to prevent bottlenecking or to dedicate some channels for specific functions. For instance, we can pick a channel that uses <code>reliable</code> data, such as the transmission of a message between players. Then, we can have another channel that uses <code>unreliable_ordered</code> data, such as updating peers about their avatars’ current position.</p>
			<p>In that sense, we just need the most recent position to arrive; every other call with previous positions is irrelevant. So, while one channel waits for messages to arrive, the other is constantly receiving new updates about avatars’ positions and neither of them blocks the other.</p>
			<p>The order in which we pass these options doesn’t matter for the Godot Engine itself. The only exception is the channel, which<a id="_idIndexMarker099"/> should always be the <em class="italic">last option</em> passed. Take the following example:</p>
			<pre class="source-code">
@rpc("any_peer", "unreliable_ordered")
func update_pos():
    pass
@rpc("unreliable_order", "any_peer")
func update_pos():
    pass</pre>			<p>These two ways of establishing the RPC options are the same and both will work. Now, the following annotation has an issue:</p>
			<pre class="source-code">
# This wouldn't work
@rpc(2, "any_peer", "unreliable_ordered")
func update_pos():
    pass
# This would work
@rpc("any_peer", "unreliable_ordered", 2)
func update_pos():
    pass</pre>			<p>Only the second RPC annotation will work, because we are passing the channel as the last argument of the annotation. In the first RPC annotation example, we are passing the channel as the first argument, so it won’t work.</p>
			<p>Now that we understand how we can mark a function as an <code>rpc</code> function and what options we can use to fine-tune it and achieve what we need in our game, let’s see what we need to be able to call such functions and propagate them across t<a id="_idTextAnchor072"/>he network.</p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor073"/>What’s necessary for an RPC?</h2>
			<p>To make RPCs in the<a id="_idIndexMarker100"/> Godot Engine, first, we must set up an <code>ENetMultiplayerPeer</code> connection, which manages the network connection and handles the transmission of data between nodes. We did that in the first chapter, but we will also go through the process here as well.</p>
			<p>Once the <code>ENetMultiplayerPeer</code> connection is set up, we must ensure that the <code>NodePath</code> to the nodes receiving the RPC is exact. This means that the <code>NodePath</code> to the target node must be identical on all peers in the network. If the <code>NodePath</code> is not exact, the RPC may not be sent to the correct node or may not be sent at all.</p>
			<p>We can establish a default name for our root nodes to avoid issues. We chose the root node to facilitate the logic afterward as it is the first node in the hierarchy.</p>
			<p>For instance, in our upcoming <code>Main</code>:</p>
			<div><div><img alt="Figure 3.1 – The ServerLobby, LoginScreen, and ClientLobby scenes with their root node named Main" src="img/Figure_03.01_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – The ServerLobby, LoginScreen, and ClientLobby scenes with their root node named Main</p>
			<p>It’s also important to note that every node in the network should share all the methods marked with <code>@rpc</code>, even if they are not called or used by anyone. This is because the Godot Engine requires all nodes to have access to the same set of methods to function properly. This can be a minor inconvenience for developers as it may bloat some classes with unnecessary methods, but it is necessary for Godot’s networking system to work effectively.</p>
			<p>For instance, these are the<a id="_idIndexMarker101"/> methods found in each of the scenes that compose our upcoming <strong class="bold">Lobby</strong> project. Note that they all share the highlighted methods on top of their non-RPC methods:</p>
			<div><div><img alt="Figure 3.2 – The Server.gd, LoginScreen.gd, and Client.gd scripts share functions marked with the @rpc annotation" src="img/Figure_03.02_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – The Server.gd, LoginScreen.gd, and Client.gd scripts share functions marked with the @rpc annotation</p>
			<p>Making RPCs in the Godot Engine requires setting up <code>ENetMultiplayerPeer</code> connections, ensuring that the <code>NodePath</code> to the target node is exact, and ensuring that all nodes in the network share all the methods marked as RPC. While this may require some additional setup and minor inconvenience, it enables developers to create multiplayer games easily and efficiently.</p>
			<p>With that, we understand the core of RPCs in the Godot Engine. We saw what we need to set our game to support RPCs, how the <code>@rpc</code> annotation works, and how we can tweak it to match our design. In one of those tweaking options, we saw that it’s possible to only allow the multiplayer authority to call a given RPC function. Let’s see what the multiplayer authority is and what we can <a id="_idTextAnchor074"/>do with it.</p>
			<h1 id="_idParaDest-50"><a id="_idTextAnchor075"/>Understanding the multiplayer authority</h1>
			<p>In Godot Engine’s high-level<a id="_idIndexMarker102"/> network API, the <strong class="bold">multiplayer authority</strong> is a concept that refers to the node that has the authority to make decisions about a node state in a multiplayer game. When two or more peers are connected in a multiplayer game, it is important to have a centralized peer that decides what changes are valid and should be synchronized across all connected clients.</p>
			<p>The multiplayer authority is assigned to a specific peer in the game, usually the server or host, and this peer has the power to decide which changes from a given node should be accepted and synchronized across all connected clients. This is important because in a multiplayer game, multiple players may try to make changes to the game state at the same time, and it is the responsibility of the multiplayer authority to manage, verify, and synchronize these changes correctly.</p>
			<p>Each connected client in a multiplayer game is assigned a unique peer ID, which is a number that identifies the client within the game’s network. Peer IDs are managed by the <code>Node.multiplayer.multiplayer_peer</code> object, which is a reference to the <code>ENetMultiplayerPeer</code> object, which handles the game’s network connection. The <code>multiplayer_peer</code> object can be used to send and receive data between connected clients, as well as to manage the state of the game’s network connection.</p>
			<p>We can use the <code>Node.get_multiplayer_authority()</code> method to retrieve the node’s current multiplayer authority, as well as set a different one using <code>Node.set_multiplayer_authority(),</code> passing the peer ID as an argument. Changing a node’s multiplayer authority will allow the new peer to make and sync changes to this node across the network, and this can be quite dangerous.</p>
			<p>For instance, if a player is responsible for a node that contains its health, the player may somehow hack it and be able to self-manage their health, ultimately becomi<a id="_idTextAnchor076"/>ng immortal.</p>
			<h1 id="_idParaDest-51"><a id="_idTextAnchor077"/>Comparing UDP and ENet approaches</h1>
			<p>The <code>UDPServer</code> and <code>PacketPeerUDP</code> classes are lower-level networking tools that allow for the exchange of <a id="_idIndexMarker103"/>data through UDP packets. This approach requires more work from us, as we must manage the sending and receiving of packets ourselves. For example, to create a login system using <code>UDPServer</code> and <code>PacketPeerUDP</code>, we would need to create a packet that contains the user’s login information, send it to the server, and then wait for a response.</p>
			<p>In <a href="B18527_02.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Sending and Receiving Data</em> project, we saw how to use <code>UDPServer</code> and <code>PacketPeerUDP</code> to pass data around. We saw that using these classes, we can serialize data and deserialize it on each end of the system, both client and server. Using this approach, we need to poll packets and wait for requests and responses to arrive. It does the trick, but you saw it can get a bit complicated.</p>
			<p>One advantage of using the <code>UDPServer</code> and <code>PacketPeerUDP</code> classes is that they provide more control over the networking process, which can be useful for more complex games that require fine-tuned networking. However, this approach is also more error-prone, as we must handle the sending and receiving of packets ourselves, which can lead to issues such as packet loss or out-of-order packets.</p>
			<p>On the other hand, using <code>ENetMultiplayerPeer</code> and RPCs provides a higher-level networking solution that simplifies the process of creating a login system. With this approach, developers can use the <code>@rpc</code> function annotation to mark a method as an RPC, which allows it to be called from any node in the network.</p>
			<p>For example, to create a<a id="_idIndexMarker104"/> login system using <code>ENetMultiplayerPeer</code> and RPCs, we can mark the method that handles the login process as an RPC, and then call it from the client nodes. We are going to see that in a moment, and you will understand how powerful and simple the Godot Engine’s high-level network API is.</p>
			<p>Using <code>ENetMultiplayerPeer</code> and RPCs simplifies the networking process and makes it easier to create multiplayer games. The built-in features of <code>ENetMultiplayerPeer</code>, such as automatic packet ordering and error correction, make it easier to create a stable network connection. On top of that, the <code>@rpc</code> annotation makes it easy to call methods from any node in the network, simplifying the development process.</p>
			<p>While the <code>UDPServer</code> and <code>PacketPeerUDP</code> classes provide more control over the networking process, using <code>ENetMultiplayerPeer</code> and RPCs offers a simpler and more streamlined approach to creating multiplayer games. The choice ultimately depends on the specific needs of the game you are making, but in most cases, using the higher-level tools provided by the Godot Engine will lead to a faster and more efficient development process.</p>
			<p>Now that we understand how the Godot Engine’s high-level network API solves a lot of issues through the <code>ENetMultiplayerPeer</code> class and how it compares to the UDP approach, with major<a id="_idIndexMarker105"/> advantages, such as its ability to easily allow the RPC features we need to make our game easier, let’s remake the login screen we made in <a href="B18527_02.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Sending and Receiving Data</em>, using these new tools. This will allow us to use the high-level API while understanding the low-level approach and the advantages of using the high-level ap<a id="_idTextAnchor078"/>proach instead.</p>
			<h1 id="_idParaDest-52"><a id="_idTextAnchor079"/>Remaking the login screen with RPCs</h1>
			<p>Welcome back to our <a id="_idIndexMarker106"/>studio, fellow network<a id="_idIndexMarker107"/> engineer! In <a href="B18527_02.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Sending and Receiving Data</em>, we learned how to create a basic login system using the Godot Engine’s <code>UDPServer</code> and <code>PacketPeerUDP</code> classes. While this approach was perfect for our small-scale project, we need to level our game as we move forward and create a lobby!</p>
			<p>Fear not, for we have the perfect solution for you – the Godot Engine’s <code>ENetMultiplayerPeer</code> and RPCs! These two powerful tools will help us build a robust and efficient system that can easily scale up to support multiple connected clients – as far as we researched, up to 4,095 simultaneously connected players!</p>
			<p>With the Godot Engine’s <code>ENetMultiplayerPeer</code>, we can easily manage multiple connections and synchronize game data across all connected clients. This means that our login system will be able to handle more connections, and our game will run smoother than ever before!</p>
			<p>With that, we will also be able to make RPCs! RPCs are an essential part of networking in the Godot Engine. They allow us to call functions on other nodes in the network as if they were local functions. With RPCs, we can easily share data and perform actions across all connected clients, making our login system even more robust and efficient.</p>
			<p>So, get ready to level up our game, network engineer! In the upcoming sections, we’ll dive into implementing the new login system using <code>ENetMultiplayerPeer</code> and RPCs and synchronizing players’ avatars into a lobby.</p>
			<p>We’ll also cover some best practices and tips for working with <code>ENetMultiplayerPeer</code> and RPCs to ensure our multiplayer game runs smoothly and efficiently. With these powerful tools at our disposal, we’ll be able to create a multiplayer game that will wow players and leave them wanting more.</p>
			<p>Let’s start by establishing connections between our players and the server using the <code>ENetMul<a id="_idTextAnchor080"/>tiplayerPeer</code> API.</p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor081"/>Establishing an ENetMultiplayerPeer connection</h2>
			<p>Let’s recap from <a id="_idIndexMarker108"/>the first chapter how to establish a connection using the high-level <code>ENetMultiplayerPeer</code> class. We’ll start with the server.</p>
			<p>This time, we will also add elements such as the fake database and the logged users from our project from <a href="B18527_02.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Sending and Receiving Data</em>. This will allow us to authenticate players and keep track of who’s connected and their session tokens. Well, without further ado, let’s dive into it!</p>
			<p>We’ll start by setting up an ENet multiplayer server on port <code>9999</code>, loading our fake JSON database file, and assigning the <code>peer</code> instance to the <code>multiplayer_peer</code> property of the node’s <code>multiplayer</code> object so we can make RPCs. Remember, we can only carry out RPCs within an established ENet connection:</p>
			<ol>
				<li>Open the <code>res://03.making-lobby-to-gather-players/LobbyServer.tscn</code> scene, and then open the <strong class="bold">Main</strong> node’s script.</li>
				<li>Declare a constant variable, <code>PORT</code>, and assign our default value of <code>9999</code>. This variable will be used later to specify the port number on which the server will listen for incoming connections:<pre class="source-code">
const PORT = 9999</pre></li>				<li>Use the <code>@export</code> decorator to create a new variable, <code>database_file_path</code>, which can be edited from the <strong class="bold">Inspector</strong> panel. This variable will store the path to the JSON file that contains our fake user database. We are using the same file from the previous chapter:<pre class="source-code">
@export var database_file_path = "res://02.sending-and-receiving-data/FakeDatabase.json"</pre></li>				<li>Create a new <code>ENetMultiplayerPeer</code> instance and assign it to the <code>peer</code> variable. This will be our high-level network interface for sending and receiving data between clients and the server and making RPCs:<pre class="source-code">
var peer = ENetMultiplayerPeer.new()</pre></li>				<li>Create an empty dictionary called <code>database</code> and an empty dictionary called <code>logged_users</code>. These variables will be used to store our fake user data and keep track of which users are currently logged in, respectively:<pre class="source-code">
var database = {}
var logged_users = {}</pre></li>				<li>In the <code>_ready()</code> callback, call <code>peer.create_server(PORT)</code> to create a new multiplayer server that listens for incoming connections on the port number specified by the <code>PORT</code> variable:<pre class="source-code">
func _ready():
    peer.create_server(PORT)</pre></li>				<li>Still in the <code>_ready()</code> callback, assign the <code>peer</code> to <code>multiplayer.multiplayer_peer</code>. This variable makes our <code>peer</code> object the default network interface for all nodes in the game:<pre class="source-code">
func _ready():
    peer.create_server(PORT)
    multiplayer.multiplayer_peer = peer</pre></li>				<li>Finally, still in the <code>_ready()</code> callback, make a call to the <code>load_database()</code> method. We are going to create this in a moment. We do that to have the database in memory<a id="_idIndexMarker109"/> from the start, as soon as the server is ready:<pre class="source-code">
func _ready():
    peer.create_server(PORT)
    multiplayer.multiplayer_peer = peer
    load_database()</pre></li>				<li>Now, define a new function, <code>load_database()</code>, that takes an optional argument, <code>path_to_database_file</code>. This function will be used to load the user data from the JSON file into our <code>database</code> dictionary:<pre class="source-code">
func load_database(path_to_database_file =
    database_file_path):</pre></li>				<li>Inside <code>load_database()</code>, open the file specified by <code>path_to_database_file</code> using <code>FileAccess.open()</code> and assign it to the <code>file</code> variable:<pre class="source-code">
func load_database(path_to_database_file =
    database_file_path):
    var file = FileAccess.open(path_to_database_file,
        FileAccess.READ)</pre></li>				<li>Get the <a id="_idIndexMarker110"/>contents of the file as text using <code>file.get_as_text()</code> and assign it to the <code>file_content</code> variable:<pre class="source-code">
func load_database(path_to_database_file =
    database_file_path):
    var file = FileAccess.open(path_to_database_file,
        FileAccess.READ)
    var file_content = file.get_as_text()</pre></li>				<li>Parse the contents of <code>file_content</code> as JSON using <code>JSON.parse_string()</code> and assign the resulting dictionary to <code>database</code>:<pre class="source-code">
func load_database(path_to_database_file =
    database_file_path):
    var file = FileAccess.open(path_to_database_file,
        FileAccess.READ)
    var file_content = file.get_as_text()
    database = JSON.parse_string(file_content)</pre><p class="list-inset">At this point, this <a id="_idIndexMarker111"/>is how our <code>LobbyServer.gd</code> should look like this:</p><pre class="source-code">extends Control
const PORT = 9999
@export var database_file_path = "res://
    02.sending-and-receiving-data/FakeDatabase.json"
var peer = ENetMultiplayerPeer.new()
var database = {}
var logged_users = {}
func _ready():
    peer.create_server(PORT)
    multiplayer.multiplayer_peer = peer
    load_database()
func load_database(path_to_database_file =
    database_file_path):
    var file = FileAccess.open(path_to_database_file,
        FileAccess.READ)
    var file_content = file.get_as_text()
    database = JSON.parse_string(file_content)</pre></li>			</ol>
			<p>With that, it’s time to get our hands dirty with the fun part and the core of this chapter. Up next, we are going to finally create the <code>@rpc</code> methods that we’ll use across <a id="_idTextAnchor082"/>our upcoming classes.</p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor083"/>Creating the RPC functions template</h2>
			<p>With that, we <a id="_idIndexMarker112"/>can start to define our <code>@rpc</code> methods so when we move on to <code>LobbyLogin</code>, we already know what we’ll call and how it works. So, still in <code>LobbyServer</code>, let’s create some RPC methods.</p>
			<p>These methods are going to be used on <code>LobbyLogin</code> and <code>LobbyClient</code> as well. Remember, all classes that make RPCs should share the same RPC methods even if they don’t use them.</p>
			<p>So, let’s create this interface:</p>
			<ol>
				<li>The <code>@rpc</code> annotation on this line is an RPC annotation that tells Godot that this function is called remotely only by the multiplayer authority, which is the server itself. A remote call means that when <code>LobbyServer</code> makes an RPC to this function, it won’t execute it on itself locally. We will use the <code>add_avatar()</code> method to add a new avatar to the game’s lobby, and we will implement it on <code>LobbyClient</code>:<pre class="source-code">
@rpc
func add_avatar(avatar_name, texture_path):
    pass</pre></li>				<li>The <code>clear_avatars()</code> function will remove all avatars from the lobby. We use this function to clear all avatars from the game so we can sync with newer players. This is also a method that we’ll implement on <code>LobbyClient</code>:<pre class="source-code">
@rpc
func clear_avatars():
    pass</pre></li>				<li>This <code>@rpc("any_peer", "call_remote")</code> annotation tells Godot any peer can remotely call this function. We’ll use the <code>retrieve_avatar()</code> method to retrieve the texture path for a specific player’s avatar. We’ll implement this method in <code>LobbyServer</code> soon, and the <code>LobbyClient</code> is the one that’s going to remotely call it:<pre class="source-code">
@rpc("any_peer", "call_remote")
func retrieve_avatar(user, session_token):
    pass</pre></li>				<li>The <code>authenticate_player()</code> method will authenticate a player using a username and password. We use this function to authenticate players’ credentials and pair them with a session token on the <code>logged_users</code> dictionary. This is also a method from <code>LobbyServer</code>, but now it’s <code>LobbyLogin</code> that’s going to remotely call it:<pre class="source-code">
@rpc("any_peer", "call_remote")
func authenticate_player(user, password):
    pass</pre></li>				<li>Then, we <a id="_idIndexMarker113"/>use the <code>authentication_failed()</code> method to notify a player that their authentication failed. We will call this from <code>LobbyServer</code> on <code>LobbyClient</code> when the server can’t authenticate the credentials the player sent.<p class="list-inset">Note that while every function marked with an <code>@rpc</code> annotation should be on all other classes it interacts with, those classes don’t need to have the same options for their <code>@rpc</code>. You will understand this better when we jump into <code>LobbyLogin</code> and <code>LobbyClient</code>:</p><pre class="source-code">
@rpc
func authentication_failed(error_message):
    pass</pre></li>				<li>We also have <code>authentication_succeed()</code>. We call this function from <code>LobbsyServer</code> on the player’s <code>LobbyClient</code> to tell them that their authentication succeeded, providing them with their session token:<pre class="source-code">
@rpc
func authentication_succeed(user, session_token):
    pass</pre><p class="list-inset">With that, we have all the RPC functions we are going to use in our lobby system. <code>LobbyServer</code>’s RPCs <a id="_idIndexMarker114"/>section should look like this:</p><pre class="source-code">@rpc
func add_avatar(avatar_name, texture_path):
    pass
@rpc
func clear_avatars():
    pass
@rpc("any_peer", "call_remote")
func retrieve_avatar(user, session_token):
    pass
@rpc("any_peer", "call_remote")
func authenticate_player(user, password):
    pass
@rpc
func authentication_failed(error_message):
    pass
@rpc
func authentication_succeed(user, session_token):
    pass</pre></li>			</ol>
			<p>Our template is<a id="_idIndexMarker115"/> ready. It has the <code>@rpc</code> methods that the classes that comprise our lobby need to share to communicate in our network. Remember, this is a necessary step; even if some of the classes don’t implement the method, they should at least share this interface. For instance, coming next, we are going to implement the authentication logic in the lobby server, but other classes only need the method signature for that to work.<a id="_idTextAnchor084"/> Let’s see how this goes.</p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor085"/>Authenticating the player</h2>
			<p>In this<a id="_idIndexMarker116"/> section, we will focus on authenticating the player in the lobby server. We will use the <code>authenticate_player()</code> RPC method that we previously defined in our server script to verify the player’s identity and grant access to the lobby.</p>
			<p>The <code>authenticate_player()</code> method will take a username and a password as arguments and will return either an error message or a session token. If the credentials are invalid, the method will make a remote call to the <code>authentication_failed()</code> method with an error message explaining the reason for the failure.</p>
			<p>If the credentials are valid, the method will make a remote call to the <code>authentication_succeed()</code> method, passing a session token and returning it to the player’s <code>LobbyClient</code>. The session token is a unique integer number that identifies the player and is used to authenticate the player in subsequent RPCs.</p>
			<p>Let’s see how we can implement this logic using the tools we have at our disposal in the Godot Engine:</p>
			<ol>
				<li>Inside <code>LobbyServer</code>’s <code>authenticate_player()</code> method, get the <code>peer_id</code> of the player who sent the authentication request using the <code>multiplayer.get_remote_sender_id()</code> method. This is how we identify who sent the request so we can properly respond to the request:<pre class="source-code">
func authenticate_player(user, password):
    var peer_id = multiplayer.get_remote_sender_id()</pre></li>				<li>Check<a id="_idIndexMarker117"/> whether the user exists in the <code>database</code> dictionary. If they don’t exist, call the <code>authentication_failed</code> RPC method on the <code>peer_id</code> with the message <code>"User doesn't exist"</code>. For that, we can use the <code>rpc_id()</code> method, which makes an RPC directly to the peer with the given ID:<pre class="source-code">
    if not user in database:
        rpc_id(peer_id, "authentication_failed",
            "User doesn't exist")</pre></li>				<li>If the user exists in the database, check whether the password matches the password associated with the user. If it does, generate a random token using the <code>randi()</code> built-in method:<pre class="source-code">
        elif database[user]['password'] == password:
            var token = randi()</pre></li>				<li>Then, add the authenticated user to the <code>logged_users</code> dictionary and call the <code>authentication_succeed</code> RPC method on the <code>peer_id</code> passing the token as an argument:<pre class="source-code">
        logged_users[user] = token
        rpc_id(peer_id, "authentication_succeed",
            token)</pre><p class="list-inset">This is what this method should look like:</p><pre class="source-code">func authenticate_player(user, password):
    var peer_id = multiplayer.get_remote_sender_id()
    if not user in database:
        rpc_id(peer_id, "authentication_failed",
            "User doesn't exist")
    elif database[user]['password'] == password:
        var token = randi()
        logged_users[user] = token
        rpc_id(peer_id, "authentication_succeed", token)</pre></li>			</ol>
			<p>Note how useful making <a id="_idIndexMarker118"/>RPCs is. We don’t need to poll or wait for packets to arrive at the destination or be concerned with serializing function arguments. We don’t even have to create a <em class="italic">request</em> API to detect what the requester is trying to achieve as we did previously. It’s very straightforward, almost like making a local application where you have direct access to the objects.</p>
			<p>Now, let’s see how we call this function on <code>LobbyLogin</code>. I’ll assume that you already understand how it connects to the server using the <code>ENetMultiplayerPeer.create_client()</code> method. If you have any doubts about that, refer to the first chapter; the procedure is the same.</p>
			<p><code>LobbyLogin</code> resembles the login from the previous chapter, so let’s skip directly to the <code>send_credentials()</code> method, where it communicates with <code>LobbyServer</code>. You’ll notice it also has the RPC methods we saw in <code>LobbyServer</code>. In this case, they all have the default options since the server is the only one that should call these methods on it:</p>
			<ol>
				<li>In the <code>send_credentials()</code> method, retrieve the <code>text</code> String property from the <code>user_line_edit</code> node and store it in the <code>user</code> variable:<pre class="source-code">
func send_credentials():
    var user = user_line_edit.text</pre></li>				<li>Then, do the same but with <code>password_line_edit</code> and store it in the <code>password</code> variable:<pre class="source-code">
    var password = password_line_edit.text</pre></li>				<li>Finally, make an RPC to the multiplayer authority calling the <code>authenticate_player()</code> method with the <code>user</code> and <code>password</code> arguments. This will make this call only on <code>LobbyServer</code>:<pre class="source-code">
    rpc_id(get_multiplayer_authority(),
        "authenticate_player", user, password)</pre><p class="list-inset">This is what the <code>LobbyLogin.send_credentials()</code> method will look like in the end:</p><pre class="source-code">func send_credentials():
    var user = user_line_edit.text
    var password = password_line_edit.text
    rpc_id(get_multiplayer_authority(),
        "authenticate_player", user, password)</pre></li>			</ol>
			<p>Let’s take a look at the <code>authentication_failed()</code> and <code>authentication_succeed()</code> methods just so we understand how they work and how we keep the players’ authenticated credentials across the scenes.</p>
			<p><code>authentication_succeed()</code> takes one argument called <code>session_token</code>, which is passed by the <a id="_idIndexMarker119"/>server when it authenticates the player’s credentials, as we saw previously.</p>
			<p>Then, we update the <code>AuthenticationCredentials.user</code> and <code>AuthenticationCredentials.session_token</code> values using <code>user_line_edit.text</code> and the <code>session_token</code> argument. Just like in the previous chapter, <code>AuthenticationCredentials</code> is a singleton autoload that stores the player’s username and session token so we can use it in further scenes.</p>
			<p>Talking about further scenes, after updating the <code>AuthenticationCredentials</code> singleton, we change the scene to <code>lobby_screen_scene</code> using <code>get_tree().change_scene_to_file(lobby_screen_scene)</code>. That means the player has successfully logged in and we can take them to the game lobby:</p>
			<pre class="source-code">
@rpc
func authentication_succeed(session_token):
    AuthenticationCredentials.user = user_line_edit.text
    AuthenticationCredentials.session_token = session_token
    get_tree().change_scene_to_file(lobby_screen_scene)</pre>			<p>As for <code>authentication_failed()</code>, we set <code>error_label.text</code> to the error message <a id="_idIndexMarker120"/>received from <code>LobbyServer</code>. This will display the error to the player:</p>
			<pre class="source-code">
@rpc
func authentication_failed(error_message):
    error_label.text = error_message</pre>			<p>Now that we understand how both sides of this relationship communicate and what they do with the data they pass around and get from each other, it’s time to move on and see how the game resolves this data and displays the players’ avatars to each other, synchronizing new players across the network every time they join the session.</p>
			<p>In the upcoming section, we will see what the lobby screen looks like on the player’s end and how we load, display, and sync player<a id="_idTextAnchor086"/>s’ avatars across the network.</p>
			<h1 id="_idParaDest-56"><a id="_idTextAnchor087"/>Adding the player’s avatar</h1>
			<p>In any online game, the <a id="_idIndexMarker121"/>player’s avatar is a crucial element that represents them in the virtual world. In the previous section, we successfully authenticated the player and saved their session token and username in our <code>AuthenticationCredentials</code> autoload. Now, it’s time to use that information to display the player’s avatar in the lobby.</p>
			<p>To achieve this, we will retrieve the player’s avatar information from our fake database and create a new <code>AvatarCard</code>, a custom scene with a <code>TextureRect</code> node to display the avatar’s image and a label to show its name. This way, players will be able to easily identify each other and feel more connected to the game world.</p>
			<p>For that, let’s open the <code>LobbyClient.gd</code> script. Here, we are going to do three major things:</p>
			<ol>
				<li>Retrieve the avatar information from the server by making an RPC to the <code>retrieve_avatar()</code> method.</li>
				<li>Implement the <code>add_avatar()</code> method that <code>LobbyServer</code> calls after retrieving the avatar data.</li>
				<li>Implement the <code>clear_avatars()</code> method that <code>LobbyServer</code> calls before adding a new avatar to the lobby.</li>
			</ol>
			<p>We are going to start with the<a id="_idIndexMarker122"/> latter two, then we can move on to the <code>LobbyServer.gd</code> file again to implement the <code>retrieve_avatar()</code> method:</p>
			<ol>
				<li>In the <code>add_avatar()</code> method, create a new instance of <code>avatar_card_scene</code>:<pre class="source-code">
@rpc
func add_avatar(avatar_name, texture_path):
    var avatar_card = avatar_card_scene.instantiate()</pre></li>				<li>Add the newly created instance of <code>avatar_card</code> to <code>avatar_card_container</code>. This is an <code>HBoxContainer</code> node inside a <code>ScrollContainer</code> node:<pre class="source-code">
    avatar_card_container.add_child(avatar_card)</pre></li>				<li>Wait for the next frame to process before continuing the execution of the code. We do that because <code>AvatarCard</code> needs to be ready before we update its data:<pre class="source-code">
    await(get_tree().process_frame)</pre></li>				<li>Call the <code>update_data()</code> method on the <code>avatar_card</code> instance to update its data using the arguments passed to the <code>add_avatar()</code> method. With that, the lobby will use <code>avatar_name</code> to display the player’s avatar name and will load the image stored in the <code>texture_path</code> to display their avatar’s image:<pre class="source-code">
    avatar_card.update_data(avatar_name, texture_path)</pre><p class="list-inset">The whole <code>add_avatar()</code> method should look like this:</p><pre class="source-code">@rpc
func add_avatar(avatar_name, texture_path):
    var avatar_card = avatar_card_scene.instantiate()
    avatar_card_container.add_child(avatar_card)
    await(get_tree().process_frame)
    avatar_card.update_data(avatar_name, texture_path)</pre></li>			</ol>
			<p>Using the <code>@rpc</code> annotation, we created <a id="_idIndexMarker123"/>a method that the game’s server can call on clients to add a new player avatar to all players’ lobby screens, but this causes a small issue. As it is, this method may add the avatars that were already in the lobby before the newer player joined it.</p>
			<p>So, we need to first clear all previous avatars and then add all currently logged players’ avatars again. This ensures the lobby has only the correct avatars.</p>
			<p>In the coming section, we are going to create a method that will run through all current avatars and remove them to have an empty <code>HBoxContainer</code>th<a id="_idTextAnchor088"/>at we can use to add new avatars.</p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor089"/>Cleaning AvatarCards</h2>
			<p>As mentioned before, whenever <a id="_idIndexMarker124"/>the server adds a new avatar to the lobby, it first cleans the lobby and recreates all avatars from scratch. We are going to see that in detail when we implement the <code>retrieve_avatar()</code> method.</p>
			<p>The <code>clear_avatars()</code> method frees all existing avatars from the <code>avatar_card_container</code> node. It iterates over all children of <code>avatar_card_container</code> and calls <code>queue_free()</code> on each of them. After this function is executed, all avatars previously displayed in the lobby are removed from the container.</p>
			<p>In the <code>clear_avatars()</code> method, iterate over each child node in <code>avatar_card_container</code> using a <code>for</code> loop and call the <code>queue_free()</code> method on each child node to remove it from <code>SceneTree</code> and free its resources:</p>
			<pre class="source-code">
@rpc
func clear_avatars():
    for child in avatar_card_container.get_children():
        child.queue_free()</pre>			<p>That’s it; pretty simple, right?</p>
			<p>Now, before we move back to <code>LobbyServer.gd</code>, let’s make an RPC to the multiplayer authority so it retrieves the current player’s avatar. We do that in the <code>_ready()</code> method:</p>
			<pre class="source-code">
func _ready():
    rpc_id(get_multiplayer_authority(), "retrieve_avatar",
        AuthenticationCredentials.user,
            AuthenticationCredentials.session_token)</pre>			<p>We use the <code>rpc_id()</code> method<a id="_idIndexMarker125"/> to call the <code>retrieve_avatar()</code> RPC method on the multiplayer authority, which is <code>LobbyServer</code> in this case. We pass the player’s <code>username</code> and <code>session_token</code>, which are stored in the <code>AuthenticationCredentials</code> singleton autoload, as arguments to the <code>retrieve_avatar()</code> method. Now, it’s t<a id="_idTextAnchor090"/>ime to move back to <code>LobbyServer.gd</code>.</p>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor091"/>Retrieving players’ avatars</h1>
			<p>In this <a id="_idIndexMarker126"/>section, we will implement the <code>retrieve_avatar()</code> method on the <code>LobbyServer.gd</code> script, which will allow players to request their avatar data from the server. The avatar data is stored in the fake database. The server will respond with some RPCs to update all players with the appropriate data, displaying their avatars in the shared lobby.</p>
			<p>With this method in place, we will complete the functionality of our <strong class="bold">Lobby</strong> project. Players will be able to authenticate themselves and display their avatars in the lobby. This will provide a solid foundation for building more complex multiplayer games in the upcoming chapter, as the basics of networking have been covered.</p>
			<p>Let’s do it!</p>
			<ol>
				<li>In the <code>retrieve_avatar()</code> method, check whether the user is logged in by verifying that the user exists in the <code>logged_users</code> dictionary. If the user is not logged in, exit the function:<pre class="source-code">
func retrieve_avatar(user, session_token):
    if not user in logged_users:
        return</pre></li>				<li>Then, check whether the session token provided by the remote peer matches the session token stored in the <code>logged_users</code> dictionary for the user:<pre class="source-code">
    if session_token == logged_users[user]:</pre></li>				<li>If the tokens match, call the <code>clear_avatars()</code> function on all connected peers to clear any existing avatars from their lobby screen:<pre class="source-code">
        rpc("clear_avatars")</pre></li>				<li>Loop through all the logged-in users stored in the <code>logged_users</code> dictionary:<pre class="source-code">
        for logged_user in logged_users:</pre></li>				<li>Retrieve the <a id="_idIndexMarker127"/>avatar name and texture path for the current <code>logged_user</code> from the <code>database</code> dictionary:<pre class="source-code">
            Var avatar_name = database[logged_user]
                ['name']
            var avatar_texture_path = database
                [logged_user]['avatar']</pre></li>				<li>Call the <code>add_avatar()</code> method on all connected peers and pass in <code>avatar_name</code> and <code>avatar_texture_path</code> as arguments to display the avatar in the lobby:<pre class="source-code">
           rpc("add_avatar", avatar_name,
               avatar_texture_path)</pre><p class="list-inset">This is how the <code>retrieve_avatar()</code> method should look after all these steps:</p><pre class="source-code">@rpc("any_peer", "call_remote")
func retrieve_avatar(user, session_token):
    if not user in logged_users:
        return
    if session_token == logged_users[user]:
        rpc("clear_avatars")
        for logged_user in logged_users:
            var avatar_name = database
                [logged_user]['name']
            Var avatar_texture_path = database
                [logged_user]['avatar']
            rpc("add_avatar", avatar_name,
                avatar_texture_path)</pre></li>			</ol>
			<p>Pay attention<a id="_idIndexMarker128"/> to its <code>@rpc</code> annotation options. Notice that any peer can call it remotely. This is how we make an RPC API for our online multiplayer games in the Godot Engine.</p>
			<p>Some methods should be called remotely only by the multiplayer authority, some should be called locally as well, and some can be called by any peer on the network. It is up to us to decide and manage how peers interact with each other.</p>
			<p>With all that in place, it’s time to test out our game using multiple instances to simulate a server and multiple players connected to our netwo<a id="_idTextAnchor092"/>rk. Let’s do this in the next section!</p>
			<h1 id="_idParaDest-59"><a id="_idTextAnchor093"/>Testing the lobby</h1>
			<p>To test this out, we are going to run <a id="_idIndexMarker129"/>three instances of the game:</p>
			<ol>
				<li>Go to <strong class="bold">Debug</strong> | <strong class="bold">Run Multiple Instances</strong> and select <strong class="bold">Run </strong><strong class="bold">3 Instances</strong>.</li>
			</ol>
			<div><div><img alt="Figure 3.3 – Choosing to run three instances in the Run Multiple Instance﻿s menu" src="img/Figure_3.03_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – Choosing to run three instances in the Run Multiple Instances menu</p>
			<ol>
				<li value="2">Then, open the <code>res://03.making-lobby-to-gather-players/MainMenu.tscn</code> scene and hit the <strong class="bold">Play</strong> button.</li>
				<li>Pick one of the<a id="_idIndexMarker130"/> instances to be the game’s server. To do that, just click on the <strong class="bold">Server</strong> button.</li>
			</ol>
			<div><div><img alt="Figure 3.4 – Pressing the Server button on the MainMenu screen" src="img/Figure_03.04_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – Pressing the Server button on the MainMenu screen</p>
			<ol>
				<li value="4">Now, pick another instance and click on the <code>LobbyLogin</code> screen, where you can enter the first fake player’s credentials.</li>
				<li>Insert <code>user1</code> in the username field and <code>test</code> in the password field. These are the credentials we added to <code>FakeDatabase.json</code> for our first user. Then, press the <code>LobbyClient</code> screen with a single avatar.</li>
			</ol>
			<div><div><img alt="Figure 3.5 – The LobbyLogin screen with the player’s credentials" src="img/Figure_3.05_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5 – The LobbyLogin screen with the player’s credentials</p>
			<p class="list-inset">With that, the server will authenticate the player’s credentials and will allow the player to move on to the next screen, displaying the player’s character’s avatar and name based on the data it matched in the database file. In the following screenshot, we can see the next screen after a successful login.</p>
			<div><div><img alt="Figure 3.6 – LobbyClient displaying the player’s avatar after login" src="img/Figure_03.06_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6 – LobbyClient displaying the player’s avatar after login</p>
			<ol>
				<li value="6">Then, select the last <a id="_idIndexMarker132"/>instance and click on the <code>LobbyLogin</code> screen, use the second player’s credentials. In the first field, insert <code>user2</code>, and then, in the second field, <code>test</code>. It will take you to the <code>LobbyClient</code> screen, where there should be two avatars now. You can check the other client instance and they will both have the same avatars in order.</li>
			</ol>
			<div><div><img alt="Figure 3.7 – The game displaying both players’ avatars after the second player is logged in" src="img/Figure_3.07_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.7 – The game displaying both players’ avatars after the second player is logged in</p>
			<p>We can see that everything is working as we want! The players can insert their credentials and the server authenticates them and provides a session token to keep them logged in after their validation. When logged in, they can see their avatar. Not only that, but our game also syncs players’ avatars when a new player joins the session.</p>
			<p>We did all that using the powerful <code>@rpc</code> annotation, which is possible to use when peers connect using the <code>ENetMultiplayerPeer</code> API.</p>
			<h1 id="_idParaDest-60"><a id="_idTextAnchor094"/>Summary</h1>
			<p>In this chapter, we learned about RPCs and their importance in multiplayer game architectures. We saw how RPCs can be used to exchange data between nodes in the Godot Engine. We also saw what a multiplayer authority node is and how to set one up that manages all the game states between network peers. On top of that, we saw that by using the multiplayer API and <code>ENetMultiplayerPeer</code>, we can easily handle the communication between nodes.</p>
			<p>Throughout the chapter, we created a lobby, which is a multiplayer game that features a lobby where players can join together. We saw how to create a client-server architecture, authenticate users, and exchange data between the server and the clients using RPCs. We also learned how to use the multiplayer API and <code>ENetMultiplayerPeer</code> to create a connection between the client and the server.</p>
			<p>One of the essential concepts we learned is how <code>ENetMultiplayerPeer</code> simplifies the whole process of creating a multiplayer game compared to the low-level UDP approach. It abstracts away the complexity of low-level network programming, such as sending and receiving data packets, managing connections, and handling errors. This makes it easier for us to focus on implementing the gameplay mechanics of the game rather than worrying about the low-level details of the network communication.</p>
			<p>Overall, this chapter has provided a solid foundation for developing multiplayer games in the Godot Engine. By following the steps outlined in this chapter, developers can create a simple lobby-based multiplayer game that utilizes RPCs, authentication, and the multiplayer API.</p>
			<p>In the upcoming chapter, we are going to test the <code>ENetMultiplayerPeer</code> capabilities to exchange, update, and sync players. For that, we will create a chat room where players can communicate with each other and finally create a shared experience and a sense of community.</p>
		</div>
	</body></html>