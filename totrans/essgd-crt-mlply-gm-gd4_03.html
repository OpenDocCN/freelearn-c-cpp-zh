<html><head></head><body>
		<div id="_idContainer036">
			<h1 class="chapter-number" id="_idParaDest-44"><a id="_idTextAnchor065"/>3</h1>
			<h1 id="_idParaDest-45"><a id="_idTextAnchor066"/>Making a Lobby to Gather Players Together</h1>
			<p>In the previous chapter, we discussed how to use UDP packets to exchange data between multiple players in a game. While this approach is highly efficient, it requires a lot of manual work to ensure that data is sent and received correctly. In this chapter, we will explore the high-level network API of the Godot Engine, which simplifies the networking process by providing a set of built-in tools and functions that can handle common <span class="No-Break">network tasks.</span></p>
			<p>Specifically, we will focus on<a id="_idIndexMarker088"/> the <strong class="bold">ENetMultiplayerPeer API</strong>, which is the Godot Engine’s wrapper class for its ENet library implementation, and <strong class="bold">Remote Procedure Call</strong> (<strong class="bold">RPC</strong>), a <a id="_idIndexMarker089"/>communication protocol that allows us to make calls to functions and methods on remote computers as if we were making them locally. We will use these tools to create a lobby, authenticate players, retrieve player avatar data from a fake JSON database, and synchronize all players when a player enters the lobby. We will explore the benefits of using RPCs instead of exchanging UDP packets, and how this approach can simplify the process of synchronizing game states between <span class="No-Break">multiple players.</span></p>
			<p>We will cover the following topics in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>Calling functions remotely <span class="No-Break">with RPCs</span></li>
				<li>Understanding the <span class="No-Break">multiplayer authority</span></li>
				<li>Comparing UDP and <span class="No-Break">ENet approaches</span></li>
				<li>Remaking the login screen <span class="No-Break">with RPCs</span></li>
				<li>Adding the <span class="No-Break">player’s avatar</span></li>
				<li>Retrieving <span class="No-Break">players’ avatars</span></li>
				<li>Testing <span class="No-Break">the lobby</span></li>
			</ul>
			<p>By the end of this chapter, you will have a solid understanding of how to use the Godot Engine’s high-level network API and RPCs to create a robust multiplayer lobby for <span class="No-Break">your game.</span></p>
			<h1 id="_idParaDest-46"><a id="_idTextAnchor067"/>Technical requirements</h1>
			<p>In this chapter, we will build yet another project using the Godot Engine. Remember, throughout this book, we are using Godot Engine version 4.0, so this is also <span class="No-Break">a requirement.</span></p>
			<p>This time around, we are going to use the files provided in the <strong class="source-inline">res://03.making-lobby-to-gather-players</strong> folder. So, if you don’t have the project repository yet, download it through <span class="No-Break">this link:</span></p>
			<p><a href="https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0"><span class="No-Break">https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0</span></a></p>
			<p>Then, with the project added to your Godot Engine’s project manager, open the project and proceed to the <span class="No-Break"><strong class="source-inline">res://03.making-lobby-to-gather-players</strong></span><span class="No-Break"> folder<a id="_idTextAnchor068"/>.</span></p>
			<h1 id="_idParaDest-47"><a id="_idTextAnchor069"/>Calling functions remotely with RPCs</h1>
			<p>In a <a id="_idIndexMarker090"/>network context, <strong class="bold">RPC</strong> stands for <strong class="bold">remote procedure call</strong>, which is a protocol that allows one program to call a function or procedure on another program running on a different machine or over a network. In the context of the Godot Engine, RPCs allow objects to exchange data between each other over the network, which is a key feature in creating <span class="No-Break">multiplayer games.</span></p>
			<p>To use RPCs in the<a id="_idIndexMarker091"/> Godot Engine, we need to <a id="_idIndexMarker092"/>use the <strong class="source-inline">ENetMultiplayerPeer</strong> API, which provides a high-level network interface for handling network connections and sending and receiving data, as well as managing RPCs. By using <strong class="source-inline">ENetMultiplayerPeer</strong>, we can easily send and receive RPCs and handle network communication <span class="No-Break">more straightforwardly.</span></p>
			<p>When exchanging data with RPCs, objects can exchange data through functions, which makes the process more straightforward compared to exchanging data using UDP packets. With UDP packets, we need to send packets requesting procedures and wait for a response, and only then can we get the data. This process can be complex and difficult to manage, as we saw in the previous chapter, especially in large games with many objects <span class="No-Break">exchanging data.</span></p>
			<p>One limitation<a id="_idIndexMarker093"/> of RPCs is that they don’t allow the transmission of objects, such as nodes or resources, through the network. This can be a challenge in games that require the exchange of complex objects between different machines. However, there are workarounds to this limitation, such as sending serialized data or using custom serialization methods. We learned how to do that in <a href="B18527_02.xhtml#_idTextAnchor037"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Sending and Receiving Data</em>, so this won’t be a problem <span class="No-Break">to us.</span></p>
			<p>RPCs are a powerful tool for <a id="_idIndexMarker094"/>creating multiplayer<a id="_idIndexMarker095"/> games, and using the <strong class="source-inline">ENetMultiplayerPeer</strong> API in the Godot Engine makes it easy to use them. Although there are limitations to RPCs, such as the inability to transmit objects over the network, they are still a crucial part of creating a robust and seamless <span class="No-Break">multiplayer expe<a id="_idTextAnchor070"/>rience.</span></p>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor071"/>Introducing the @rpc annotation</h2>
			<p>Godot Engine 4.0 introduces a<a id="_idIndexMarker096"/> new feature called <strong class="source-inline">@rpc</strong> function annotation. An <strong class="bold">annotation</strong> is a <a id="_idIndexMarker097"/>special marker that we can add to a function in our code that provides additional information to the compiler or the Godot Engine. In the case of <strong class="source-inline">@rpc</strong>, this annotation is used to mark functions that can be called remotely over the network in a <span class="No-Break">multiplayer game.</span></p>
			<p>There are several options that we can add to the <strong class="source-inline">@rpc</strong> annotation, which control how the function is called and executed over <span class="No-Break">the network.</span></p>
			<p>Let’s take a closer look at <span class="No-Break">each option:</span></p>
			<ul>
				<li>We have the calling options, meaning what should happen when we make an RPC to <span class="No-Break">this function:</span><ul><li><strong class="source-inline">call_remote</strong>: This option indicates that the function should only be called remotely on instances of the node in other peers’ machines but not on the node’s <span class="No-Break">local instance.</span></li><li><strong class="source-inline">call_local</strong>: This option indicates that the function should also be called locally on the current peer’s instance of the node as well. This is useful when we need to sync all peers in the network, including <span class="No-Break">the caller.</span></li></ul></li>
				<li>Then, we have the <a id="_idIndexMarker098"/>caller option, meaning who can call this <span class="No-Break">function remotely:</span><ul><li><strong class="source-inline">authority</strong>: This option indicates that the function should only be called by the multiplayer authority. We’ll see more about <span class="No-Break">that soon.</span></li><li><strong class="source-inline">any_peer</strong>: This option indicates that the function can be called by any peer in the network. This is useful for functions that can be executed by multiple peers in a multiplayer game and not only the <span class="No-Break">multiplayer authority.</span></li></ul></li>
				<li>We also have options regarding the reliability of the remote data exchange when we make an RPC to <span class="No-Break">this function:</span><ul><li><strong class="source-inline">reliable</strong>: This option indicates that the function should be executed reliably over the network, which means that the function call will be guaranteed to arrive at its destination. This is useful for functions that need to be executed without the risk of <span class="No-Break">losing data.</span></li><li><strong class="source-inline">unreliable</strong>: This option indicates that the function should be executed with low reliability, which means that there is a chance that some data may be lost or delayed over the network. This is useful for functions that can tolerate some loss <span class="No-Break">of data.</span></li><li><strong class="source-inline">unreliable_ordered</strong>: This option is similar to <strong class="source-inline">unreliable</strong> but ensures that function calls are executed in order over the network. This is useful for functions that need to be executed in a specific order but can tolerate some <span class="No-Break">data loss.</span></li></ul></li>
			</ul>
			<p>We can also specify which connection channel the RPC should use to transmit its data. This is useful to prevent bottlenecking or to dedicate some channels for specific functions. For instance, we can pick a channel that uses <strong class="source-inline">reliable</strong> data, such as the transmission of a message between players. Then, we can have another channel that uses <strong class="source-inline">unreliable_ordered</strong> data, such as updating peers about their avatars’ <span class="No-Break">current position.</span></p>
			<p>In that sense, we just need the most recent position to arrive; every other call with previous positions is irrelevant. So, while one channel waits for messages to arrive, the other is constantly receiving new updates about avatars’ positions and neither of them blocks <span class="No-Break">the other.</span></p>
			<p>The order in which we pass these options doesn’t matter for the Godot Engine itself. The only exception is the channel, which<a id="_idIndexMarker099"/> should always be the <em class="italic">last option</em> passed. Take the <span class="No-Break">following example:</span></p>
			<pre class="source-code">
@rpc("any_peer", "unreliable_ordered")
func update_pos():
    pass
@rpc("unreliable_order", "any_peer")
func update_pos():
    pass</pre>			<p>These two ways of establishing the RPC options are the same and both will work. Now, the following annotation has <span class="No-Break">an issue:</span></p>
			<pre class="source-code">
# This wouldn't work
@rpc(2, "any_peer", "unreliable_ordered")
func update_pos():
    pass
# This would work
@rpc("any_peer", "unreliable_ordered", 2)
func update_pos():
    pass</pre>			<p>Only the second RPC annotation will work, because we are passing the channel as the last argument of the annotation. In the first RPC annotation example, we are passing the channel as the first argument, so it <span class="No-Break">won’t work.</span></p>
			<p>Now that we understand how we can mark a function as an <strong class="source-inline">rpc</strong> function and what options we can use to fine-tune it and achieve what we need in our game, let’s see what we need to be able to call such functions and propagate them across <span class="No-Break">t<a id="_idTextAnchor072"/>he network.</span></p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor073"/>What’s necessary for an RPC?</h2>
			<p>To make RPCs in the<a id="_idIndexMarker100"/> Godot Engine, first, we must set up an <strong class="source-inline">ENetMultiplayerPeer</strong> connection, which manages the network connection and handles the transmission of data between nodes. We did that in the first chapter, but we will also go through the process here <span class="No-Break">as well.</span></p>
			<p>Once the <strong class="source-inline">ENetMultiplayerPeer</strong> connection is set up, we must ensure that the <strong class="source-inline">NodePath</strong> to the nodes receiving the RPC is exact. This means that the <strong class="source-inline">NodePath</strong> to the target node must be identical on all peers in the network. If the <strong class="source-inline">NodePath</strong> is not exact, the RPC may not be sent to the correct node or may not be sent <span class="No-Break">at all.</span></p>
			<p>We can establish a default name for our root nodes to avoid issues. We chose the root node to facilitate the logic afterward as it is the first node in <span class="No-Break">the hierarchy.</span></p>
			<p>For instance, in our upcoming <strong class="bold">Lobby</strong> project, all three scenes share a common root <span class="No-Break">name, </span><span class="No-Break"><strong class="source-inline">Main</strong></span><span class="No-Break">:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer029">
					<img alt="Figure 3.1 – The ServerLobby, LoginScreen, and ClientLobby scenes with their root node named Main" src="image/Figure_03.01_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – The ServerLobby, LoginScreen, and ClientLobby scenes with their root node named Main</p>
			<p>It’s also important to note that every node in the network should share all the methods marked with <strong class="source-inline">@rpc</strong>, even if they are not called or used by anyone. This is because the Godot Engine requires all nodes to have access to the same set of methods to function properly. This can be a minor inconvenience for developers as it may bloat some classes with unnecessary methods, but it is necessary for Godot’s networking system to <span class="No-Break">work effectively.</span></p>
			<p>For instance, these are the<a id="_idIndexMarker101"/> methods found in each of the scenes that compose our upcoming <strong class="bold">Lobby</strong> project. Note that they all share the highlighted methods on top of their <span class="No-Break">non-RPC methods:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer030">
					<img alt="Figure 3.2 – The Server.gd, LoginScreen.gd, and Client.gd scripts share functions marked with the @rpc annotation" src="image/Figure_03.02_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – The Server.gd, LoginScreen.gd, and Client.gd scripts share functions marked with the @rpc annotation</p>
			<p>Making RPCs in the Godot Engine requires setting up <strong class="source-inline">ENetMultiplayerPeer</strong> connections, ensuring that the <strong class="source-inline">NodePath</strong> to the target node is exact, and ensuring that all nodes in the network share all the methods marked as RPC. While this may require some additional setup and minor inconvenience, it enables developers to create multiplayer games easily <span class="No-Break">and efficiently.</span></p>
			<p>With that, we understand the core of RPCs in the Godot Engine. We saw what we need to set our game to support RPCs, how the <strong class="source-inline">@rpc</strong> annotation works, and how we can tweak it to match our design. In one of those tweaking options, we saw that it’s possible to only allow the multiplayer authority to call a given RPC function. Let’s see what the multiplayer authority is and what we can <a id="_idTextAnchor074"/>do <span class="No-Break">with it.</span></p>
			<h1 id="_idParaDest-50"><a id="_idTextAnchor075"/>Understanding the multiplayer authority</h1>
			<p>In Godot Engine’s high-level<a id="_idIndexMarker102"/> network API, the <strong class="bold">multiplayer authority</strong> is a concept that refers to the node that has the authority to make decisions about a node state in a multiplayer game. When two or more peers are connected in a multiplayer game, it is important to have a centralized peer that decides what changes are valid and should be synchronized across all <span class="No-Break">connected clients.</span></p>
			<p>The multiplayer authority is assigned to a specific peer in the game, usually the server or host, and this peer has the power to decide which changes from a given node should be accepted and synchronized across all connected clients. This is important because in a multiplayer game, multiple players may try to make changes to the game state at the same time, and it is the responsibility of the multiplayer authority to manage, verify, and synchronize these <span class="No-Break">changes correctly.</span></p>
			<p>Each connected client in a multiplayer game is assigned a unique peer ID, which is a number that identifies the client within the game’s network. Peer IDs are managed by the <strong class="source-inline">Node.multiplayer.multiplayer_peer</strong> object, which is a reference to the <strong class="source-inline">ENetMultiplayerPeer</strong> object, which handles the game’s network connection. The <strong class="source-inline">multiplayer_peer</strong> object can be used to send and receive data between connected clients, as well as to manage the state of the game’s <span class="No-Break">network connection.</span></p>
			<p>We can use the <strong class="source-inline">Node.get_multiplayer_authority()</strong> method to retrieve the node’s current multiplayer authority, as well as set a different one using <strong class="source-inline">Node.set_multiplayer_authority(),</strong> passing the peer ID as an argument. Changing a node’s multiplayer authority will allow the new peer to make and sync changes to this node across the network, and this can be <span class="No-Break">quite dangerous.</span></p>
			<p>For instance, if a player is responsible for a node that contains its health, the player may somehow hack it and be able to self-manage their health, ultimately <span class="No-Break">becomi<a id="_idTextAnchor076"/>ng immortal.</span></p>
			<h1 id="_idParaDest-51"><a id="_idTextAnchor077"/>Comparing UDP and ENet approaches</h1>
			<p>The <strong class="source-inline">UDPServer</strong> and <strong class="source-inline">PacketPeerUDP</strong> classes are lower-level networking tools that allow for the exchange of <a id="_idIndexMarker103"/>data through UDP packets. This approach requires more work from us, as we must manage the sending and receiving of packets ourselves. For example, to create a login system using <strong class="source-inline">UDPServer</strong> and <strong class="source-inline">PacketPeerUDP</strong>, we would need to create a packet that contains the user’s login information, send it to the server, and then wait for <span class="No-Break">a response.</span></p>
			<p>In <a href="B18527_02.xhtml#_idTextAnchor037"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Sending and Receiving Data</em> project, we saw how to use <strong class="source-inline">UDPServer</strong> and <strong class="source-inline">PacketPeerUDP</strong> to pass data around. We saw that using these classes, we can serialize data and deserialize it on each end of the system, both client and server. Using this approach, we need to poll packets and wait for requests and responses to arrive. It does the trick, but you saw it can get a <span class="No-Break">bit complicated.</span></p>
			<p>One advantage of using the <strong class="source-inline">UDPServer</strong> and <strong class="source-inline">PacketPeerUDP</strong> classes is that they provide more control over the networking process, which can be useful for more complex games that require fine-tuned networking. However, this approach is also more error-prone, as we must handle the sending and receiving of packets ourselves, which can lead to issues such as packet loss or <span class="No-Break">out-of-order packets.</span></p>
			<p>On the other hand, using <strong class="source-inline">ENetMultiplayerPeer</strong> and RPCs provides a higher-level networking solution that simplifies the process of creating a login system. With this approach, developers can use the <strong class="source-inline">@rpc</strong> function annotation to mark a method as an RPC, which allows it to be called from any node in <span class="No-Break">the network.</span></p>
			<p>For example, to create a<a id="_idIndexMarker104"/> login system using <strong class="source-inline">ENetMultiplayerPeer</strong> and RPCs, we can mark the method that handles the login process as an RPC, and then call it from the client nodes. We are going to see that in a moment, and you will understand how powerful and simple the Godot Engine’s high-level network <span class="No-Break">API is.</span></p>
			<p>Using <strong class="source-inline">ENetMultiplayerPeer</strong> and RPCs simplifies the networking process and makes it easier to create multiplayer games. The built-in features of <strong class="source-inline">ENetMultiplayerPeer</strong>, such as automatic packet ordering and error correction, make it easier to create a stable network connection. On top of that, the <strong class="source-inline">@rpc</strong> annotation makes it easy to call methods from any node in the network, simplifying the <span class="No-Break">development process.</span></p>
			<p>While the <strong class="source-inline">UDPServer</strong> and <strong class="source-inline">PacketPeerUDP</strong> classes provide more control over the networking process, using <strong class="source-inline">ENetMultiplayerPeer</strong> and RPCs offers a simpler and more streamlined approach to creating multiplayer games. The choice ultimately depends on the specific needs of the game you are making, but in most cases, using the higher-level tools provided by the Godot Engine will lead to a faster and more efficient <span class="No-Break">development process.</span></p>
			<p>Now that we understand how the Godot Engine’s high-level network API solves a lot of issues through the <strong class="source-inline">ENetMultiplayerPeer</strong> class and how it compares to the UDP approach, with major<a id="_idIndexMarker105"/> advantages, such as its ability to easily allow the RPC features we need to make our game easier, let’s remake the login screen we made in <a href="B18527_02.xhtml#_idTextAnchor037"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Sending and Receiving Data</em>, using these new tools. This will allow us to use the high-level API while understanding the low-level approach and the advantages of using the high-level <span class="No-Break">ap<a id="_idTextAnchor078"/>proach instead.</span></p>
			<h1 id="_idParaDest-52"><a id="_idTextAnchor079"/>Remaking the login screen with RPCs</h1>
			<p>Welcome back to our <a id="_idIndexMarker106"/>studio, fellow network<a id="_idIndexMarker107"/> engineer! In <a href="B18527_02.xhtml#_idTextAnchor037"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Sending and Receiving Data</em>, we learned how to create a basic login system using the Godot Engine’s <strong class="source-inline">UDPServer</strong> and <strong class="source-inline">PacketPeerUDP</strong> classes. While this approach was perfect for our small-scale project, we need to level our game as we move forward and create <span class="No-Break">a lobby!</span></p>
			<p>Fear not, for we have the perfect solution for you – the Godot Engine’s <strong class="source-inline">ENetMultiplayerPeer</strong> and RPCs! These two powerful tools will help us build a robust and efficient system that can easily scale up to support multiple connected clients – as far as we researched, up to 4,095 simultaneously <span class="No-Break">connected players!</span></p>
			<p>With the Godot Engine’s <strong class="source-inline">ENetMultiplayerPeer</strong>, we can easily manage multiple connections and synchronize game data across all connected clients. This means that our login system will be able to handle more connections, and our game will run smoother than <span class="No-Break">ever before!</span></p>
			<p>With that, we will also be able to make RPCs! RPCs are an essential part of networking in the Godot Engine. They allow us to call functions on other nodes in the network as if they were local functions. With RPCs, we can easily share data and perform actions across all connected clients, making our login system even more robust <span class="No-Break">and efficient.</span></p>
			<p>So, get ready to level up our game, network engineer! In the upcoming sections, we’ll dive into implementing the new login system using <strong class="source-inline">ENetMultiplayerPeer</strong> and RPCs and synchronizing players’ avatars into <span class="No-Break">a lobby.</span></p>
			<p>We’ll also cover some best practices and tips for working with <strong class="source-inline">ENetMultiplayerPeer</strong> and RPCs to ensure our multiplayer game runs smoothly and efficiently. With these powerful tools at our disposal, we’ll be able to create a multiplayer game that will wow players and leave them <span class="No-Break">wanting more.</span></p>
			<p>Let’s start by establishing connections between our players and the server using the <span class="No-Break"><strong class="source-inline">ENetMul<a id="_idTextAnchor080"/>tiplayerPeer</strong></span><span class="No-Break"> API.</span></p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor081"/>Establishing an ENetMultiplayerPeer connection</h2>
			<p>Let’s recap from <a id="_idIndexMarker108"/>the first chapter how to establish a connection using the high-level <strong class="source-inline">ENetMultiplayerPeer</strong> class. We’ll start with <span class="No-Break">the server.</span></p>
			<p>This time, we will also add elements such as the fake database and the logged users from our project from <a href="B18527_02.xhtml#_idTextAnchor037"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Sending and Receiving Data</em>. This will allow us to authenticate players and keep track of who’s connected and their session tokens. Well, without further ado, let’s dive <span class="No-Break">into it!</span></p>
			<p>We’ll start by setting up an ENet multiplayer server on port <strong class="source-inline">9999</strong>, loading our fake JSON database file, and assigning the <strong class="source-inline">peer</strong> instance to the <strong class="source-inline">multiplayer_peer</strong> property of the node’s <strong class="source-inline">multiplayer</strong> object so we can make RPCs. Remember, we can only carry out RPCs within an established <span class="No-Break">ENet connection:</span></p>
			<ol>
				<li>Open the <strong class="source-inline">res://03.making-lobby-to-gather-players/LobbyServer.tscn</strong> scene, and then open the <strong class="bold">Main</strong> <span class="No-Break">node’s script.</span></li>
				<li>Declare a constant variable, <strong class="source-inline">PORT</strong>, and assign our default value of <strong class="source-inline">9999</strong>. This variable will be used later to specify the port number on which the server will listen for <span class="No-Break">incoming connections:</span><pre class="source-code">
const PORT = 9999</pre></li>				<li>Use the <strong class="source-inline">@export</strong> decorator to create a new variable, <strong class="source-inline">database_file_path</strong>, which can be edited from the <strong class="bold">Inspector</strong> panel. This variable will store the path to the JSON file that contains our fake user database. We are using the same file from the <span class="No-Break">previous chapter:</span><pre class="source-code">
@export var database_file_path = "res://02.sending-and-receiving-data/FakeDatabase.json"</pre></li>				<li>Create a new <strong class="source-inline">ENetMultiplayerPeer</strong> instance and assign it to the <strong class="source-inline">peer</strong> variable. This will be our high-level network interface for sending and receiving data between clients and the server and <span class="No-Break">making RPCs:</span><pre class="source-code">
var peer = ENetMultiplayerPeer.new()</pre></li>				<li>Create an empty dictionary called <strong class="source-inline">database</strong> and an empty dictionary called <strong class="source-inline">logged_users</strong>. These variables will be used to store our fake user data and keep track of which users are currently logged <span class="No-Break">in, respectively:</span><pre class="source-code">
var database = {}
var logged_users = {}</pre></li>				<li>In the <strong class="source-inline">_ready()</strong> callback, call <strong class="source-inline">peer.create_server(PORT)</strong> to create a new multiplayer server that listens for incoming connections on the port number specified by the <span class="No-Break"><strong class="source-inline">PORT</strong></span><span class="No-Break"> variable:</span><pre class="source-code">
func _ready():
    peer.create_server(PORT)</pre></li>				<li>Still in the <strong class="source-inline">_ready()</strong> callback, assign the <strong class="source-inline">peer</strong> to <strong class="source-inline">multiplayer.multiplayer_peer</strong>. This variable makes our <strong class="source-inline">peer</strong> object the default network interface for all nodes in <span class="No-Break">the game:</span><pre class="source-code">
func _ready():
    peer.create_server(PORT)
    multiplayer.multiplayer_peer = peer</pre></li>				<li>Finally, still in the <strong class="source-inline">_ready()</strong> callback, make a call to the <strong class="source-inline">load_database()</strong> method. We are going to create this in a moment. We do that to have the database in memory<a id="_idIndexMarker109"/> from the start, as soon as the server <span class="No-Break">is ready:</span><pre class="source-code">
func _ready():
    peer.create_server(PORT)
    multiplayer.multiplayer_peer = peer
    load_database()</pre></li>				<li>Now, define a new function, <strong class="source-inline">load_database()</strong>, that takes an optional argument, <strong class="source-inline">path_to_database_file</strong>. This function will be used to load the user data from the JSON file into our <span class="No-Break"><strong class="source-inline">database</strong></span><span class="No-Break"> dictionary:</span><pre class="source-code">
func load_database(path_to_database_file =
    database_file_path):</pre></li>				<li>Inside <strong class="source-inline">load_database()</strong>, open the file specified by <strong class="source-inline">path_to_database_file</strong> using <strong class="source-inline">FileAccess.open()</strong> and assign it to the <span class="No-Break"><strong class="source-inline">file</strong></span><span class="No-Break"> variable:</span><pre class="source-code">
func load_database(path_to_database_file =
    database_file_path):
    var file = FileAccess.open(path_to_database_file,
        FileAccess.READ)</pre></li>				<li>Get the <a id="_idIndexMarker110"/>contents of the file as text using <strong class="source-inline">file.get_as_text()</strong> and assign it to the <span class="No-Break"><strong class="source-inline">file_content</strong></span><span class="No-Break"> variable:</span><pre class="source-code">
func load_database(path_to_database_file =
    database_file_path):
    var file = FileAccess.open(path_to_database_file,
        FileAccess.READ)
    var file_content = file.get_as_text()</pre></li>				<li>Parse the contents of <strong class="source-inline">file_content</strong> as JSON using <strong class="source-inline">JSON.parse_string()</strong> and assign the resulting dictionary <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">database</strong></span><span class="No-Break">:</span><pre class="source-code">
func load_database(path_to_database_file =
    database_file_path):
    var file = FileAccess.open(path_to_database_file,
        FileAccess.READ)
    var file_content = file.get_as_text()
    database = JSON.parse_string(file_content)</pre><p class="list-inset">At this point, this <a id="_idIndexMarker111"/>is how our <strong class="source-inline">LobbyServer.gd</strong> should look <span class="No-Break">like this:</span></p><pre class="source-code">extends Control
const PORT = 9999
@export var database_file_path = "res://
    02.sending-and-receiving-data/FakeDatabase.json"
var peer = ENetMultiplayerPeer.new()
var database = {}
var logged_users = {}
func _ready():
    peer.create_server(PORT)
    multiplayer.multiplayer_peer = peer
    load_database()
func load_database(path_to_database_file =
    database_file_path):
    var file = FileAccess.open(path_to_database_file,
        FileAccess.READ)
    var file_content = file.get_as_text()
    database = JSON.parse_string(file_content)</pre></li>			</ol>
			<p>With that, it’s time to get our hands dirty with the fun part and the core of this chapter. Up next, we are going to finally create the <strong class="source-inline">@rpc</strong> methods that we’ll use across <a id="_idTextAnchor082"/>our <span class="No-Break">upcoming classes.</span></p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor083"/>Creating the RPC functions template</h2>
			<p>With that, we <a id="_idIndexMarker112"/>can start to define our <strong class="source-inline">@rpc</strong> methods so when we move on to <strong class="source-inline">LobbyLogin</strong>, we already know what we’ll call and how it works. So, still in <strong class="source-inline">LobbyServer</strong>, let’s create some <span class="No-Break">RPC methods.</span></p>
			<p>These methods are going to be used on <strong class="source-inline">LobbyLogin</strong> and <strong class="source-inline">LobbyClient</strong> as well. Remember, all classes that make RPCs should share the same RPC methods even if they don’t <span class="No-Break">use them.</span></p>
			<p>So, let’s create <span class="No-Break">this interface:</span></p>
			<ol>
				<li>The <strong class="source-inline">@rpc</strong> annotation on this line is an RPC annotation that tells Godot that this function is called remotely only by the multiplayer authority, which is the server itself. A remote call means that when <strong class="source-inline">LobbyServer</strong> makes an RPC to this function, it won’t execute it on itself locally. We will use the <strong class="source-inline">add_avatar()</strong> method to add a new avatar to the game’s lobby, and we will implement it <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">LobbyClient</strong></span><span class="No-Break">:</span><pre class="source-code">
@rpc
func add_avatar(avatar_name, texture_path):
    pass</pre></li>				<li>The <strong class="source-inline">clear_avatars()</strong> function will remove all avatars from the lobby. We use this function to clear all avatars from the game so we can sync with newer players. This is also a method that we’ll implement <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">LobbyClient</strong></span><span class="No-Break">:</span><pre class="source-code">
@rpc
func clear_avatars():
    pass</pre></li>				<li>This <strong class="source-inline">@rpc("any_peer", "call_remote")</strong> annotation tells Godot any peer can remotely call this function. We’ll use the <strong class="source-inline">retrieve_avatar()</strong> method to retrieve the texture path for a specific player’s avatar. We’ll implement this method in <strong class="source-inline">LobbyServer</strong> soon, and the <strong class="source-inline">LobbyClient</strong> is the one that’s going to remotely <span class="No-Break">call it:</span><pre class="source-code">
@rpc("any_peer", "call_remote")
func retrieve_avatar(user, session_token):
    pass</pre></li>				<li>The <strong class="source-inline">authenticate_player()</strong> method will authenticate a player using a username and password. We use this function to authenticate players’ credentials and pair them with a session token on the <strong class="source-inline">logged_users</strong> dictionary. This is also a method from <strong class="source-inline">LobbyServer</strong>, but now it’s <strong class="source-inline">LobbyLogin</strong> that’s going to remotely <span class="No-Break">call it:</span><pre class="source-code">
@rpc("any_peer", "call_remote")
func authenticate_player(user, password):
    pass</pre></li>				<li>Then, we <a id="_idIndexMarker113"/>use the <strong class="source-inline">authentication_failed()</strong> method to notify a player that their authentication failed. We will call this from <strong class="source-inline">LobbyServer</strong> on <strong class="source-inline">LobbyClient</strong> when the server can’t authenticate the credentials the <span class="No-Break">player sent.</span><p class="list-inset">Note that while every function marked with an <strong class="source-inline">@rpc</strong> annotation should be on all other classes it interacts with, those classes don’t need to have the same options for their <strong class="source-inline">@rpc</strong>. You will understand this better when we jump into <strong class="source-inline">LobbyLogin</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">LobbyClient</strong></span><span class="No-Break">:</span></p><pre class="source-code">
@rpc
func authentication_failed(error_message):
    pass</pre></li>				<li>We also have <strong class="source-inline">authentication_succeed()</strong>. We call this function from <strong class="source-inline">LobbsyServer</strong> on the player’s <strong class="source-inline">LobbyClient</strong> to tell them that their authentication succeeded, providing them with their <span class="No-Break">session token:</span><pre class="source-code">
@rpc
func authentication_succeed(user, session_token):
    pass</pre><p class="list-inset">With that, we have all the RPC functions we are going to use in our lobby system. <strong class="source-inline">LobbyServer</strong>’s RPCs <a id="_idIndexMarker114"/>section should look <span class="No-Break">like this:</span></p><pre class="source-code">@rpc
func add_avatar(avatar_name, texture_path):
    pass
@rpc
func clear_avatars():
    pass
@rpc("any_peer", "call_remote")
func retrieve_avatar(user, session_token):
    pass
@rpc("any_peer", "call_remote")
func authenticate_player(user, password):
    pass
@rpc
func authentication_failed(error_message):
    pass
@rpc
func authentication_succeed(user, session_token):
    pass</pre></li>			</ol>
			<p>Our template is<a id="_idIndexMarker115"/> ready. It has the <strong class="source-inline">@rpc</strong> methods that the classes that comprise our lobby need to share to communicate in our network. Remember, this is a necessary step; even if some of the classes don’t implement the method, they should at least share this interface. For instance, coming next, we are going to implement the authentication logic in the lobby server, but other classes only need the method signature for that to work.<a id="_idTextAnchor084"/> Let’s see how <span class="No-Break">this goes.</span></p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor085"/>Authenticating the player</h2>
			<p>In this<a id="_idIndexMarker116"/> section, we will focus on authenticating the player in the lobby server. We will use the <strong class="source-inline">authenticate_player()</strong> RPC method that we previously defined in our server script to verify the player’s identity and grant access to <span class="No-Break">the lobby.</span></p>
			<p>The <strong class="source-inline">authenticate_player()</strong> method will take a username and a password as arguments and will return either an error message or a session token. If the credentials are invalid, the method will make a remote call to the <strong class="source-inline">authentication_failed()</strong> method with an error message explaining the reason for <span class="No-Break">the failure.</span></p>
			<p>If the credentials are valid, the method will make a remote call to the <strong class="source-inline">authentication_succeed()</strong> method, passing a session token and returning it to the player’s <strong class="source-inline">LobbyClient</strong>. The session token is a unique integer number that identifies the player and is used to authenticate the player in <span class="No-Break">subsequent RPCs.</span></p>
			<p>Let’s see how we can implement this logic using the tools we have at our disposal in the <span class="No-Break">Godot Engine:</span></p>
			<ol>
				<li>Inside <strong class="source-inline">LobbyServer</strong>’s <strong class="source-inline">authenticate_player()</strong> method, get the <strong class="source-inline">peer_id</strong> of the player who sent the authentication request using the <strong class="source-inline">multiplayer.get_remote_sender_id()</strong> method. This is how we identify who sent the request so we can properly respond to <span class="No-Break">the request:</span><pre class="source-code">
func authenticate_player(user, password):
    var peer_id = multiplayer.get_remote_sender_id()</pre></li>				<li>Check<a id="_idIndexMarker117"/> whether the user exists in the <strong class="source-inline">database</strong> dictionary. If they don’t exist, call the <strong class="source-inline">authentication_failed</strong> RPC method on the <strong class="source-inline">peer_id</strong> with the message <strong class="source-inline">"User doesn't exist"</strong>. For that, we can use the <strong class="source-inline">rpc_id()</strong> method, which makes an RPC directly to the peer with the <span class="No-Break">given ID:</span><pre class="source-code">
    if not user in database:
        rpc_id(peer_id, "authentication_failed",
            "User doesn't exist")</pre></li>				<li>If the user exists in the database, check whether the password matches the password associated with the user. If it does, generate a random token using the <strong class="source-inline">randi()</strong> <span class="No-Break">built-in method:</span><pre class="source-code">
        elif database[user]['password'] == password:
            var token = randi()</pre></li>				<li>Then, add the authenticated user to the <strong class="source-inline">logged_users</strong> dictionary and call the <strong class="source-inline">authentication_succeed</strong> RPC method on the <strong class="source-inline">peer_id</strong> passing the token as <span class="No-Break">an argument:</span><pre class="source-code">
        logged_users[user] = token
        rpc_id(peer_id, "authentication_succeed",
            token)</pre><p class="list-inset">This is what this method should <span class="No-Break">look like:</span></p><pre class="source-code">func authenticate_player(user, password):
    var peer_id = multiplayer.get_remote_sender_id()
    if not user in database:
        rpc_id(peer_id, "authentication_failed",
            "User doesn't exist")
    elif database[user]['password'] == password:
        var token = randi()
        logged_users[user] = token
        rpc_id(peer_id, "authentication_succeed", token)</pre></li>			</ol>
			<p>Note how useful making <a id="_idIndexMarker118"/>RPCs is. We don’t need to poll or wait for packets to arrive at the destination or be concerned with serializing function arguments. We don’t even have to create a <em class="italic">request</em> API to detect what the requester is trying to achieve as we did previously. It’s very straightforward, almost like making a local application where you have direct access to <span class="No-Break">the objects.</span></p>
			<p>Now, let’s see how we call this function on <strong class="source-inline">LobbyLogin</strong>. I’ll assume that you already understand how it connects to the server using the <strong class="source-inline">ENetMultiplayerPeer.create_client()</strong> method. If you have any doubts about that, refer to the first chapter; the procedure is <span class="No-Break">the same.</span></p>
			<p><strong class="source-inline">LobbyLogin</strong> resembles the login from the previous chapter, so let’s skip directly to the <strong class="source-inline">send_credentials()</strong> method, where it communicates with <strong class="source-inline">LobbyServer</strong>. You’ll notice it also has the RPC methods we saw in <strong class="source-inline">LobbyServer</strong>. In this case, they all have the default options since the server is the only one that should call these methods <span class="No-Break">on it:</span></p>
			<ol>
				<li>In the <strong class="source-inline">send_credentials()</strong> method, retrieve the <strong class="source-inline">text</strong> String property from the <strong class="source-inline">user_line_edit</strong> node and store it in the <span class="No-Break"><strong class="source-inline">user</strong></span><span class="No-Break"> variable:</span><pre class="source-code">
func send_credentials():
    var user = user_line_edit.text</pre></li>				<li>Then, do the same but with <strong class="source-inline">password_line_edit</strong> and store it in the <span class="No-Break"><strong class="source-inline">password</strong></span><span class="No-Break"> variable:</span><pre class="source-code">
    var password = password_line_edit.text</pre></li>				<li>Finally, make an RPC to the multiplayer authority calling the <strong class="source-inline">authenticate_player()</strong> method with the <strong class="source-inline">user</strong> and <strong class="source-inline">password</strong> arguments. This will make this call only <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">LobbyServer</strong></span><span class="No-Break">:</span><pre class="source-code">
    rpc_id(get_multiplayer_authority(),
        "authenticate_player", user, password)</pre><p class="list-inset">This is what the <strong class="source-inline">LobbyLogin.send_credentials()</strong> method will look like in <span class="No-Break">the end:</span></p><pre class="source-code">func send_credentials():
    var user = user_line_edit.text
    var password = password_line_edit.text
    rpc_id(get_multiplayer_authority(),
        "authenticate_player", user, password)</pre></li>			</ol>
			<p>Let’s take a look at the <strong class="source-inline">authentication_failed()</strong> and <strong class="source-inline">authentication_succeed()</strong> methods just so we understand how they work and how we keep the players’ authenticated credentials across <span class="No-Break">the scenes.</span></p>
			<p><strong class="source-inline">authentication_succeed()</strong> takes one argument called <strong class="source-inline">session_token</strong>, which is passed by the <a id="_idIndexMarker119"/>server when it authenticates the player’s credentials, as we <span class="No-Break">saw previously.</span></p>
			<p>Then, we update the <strong class="source-inline">AuthenticationCredentials.user</strong> and <strong class="source-inline">AuthenticationCredentials.session_token</strong> values using <strong class="source-inline">user_line_edit.text</strong> and the <strong class="source-inline">session_token</strong> argument. Just like in the previous chapter, <strong class="source-inline">AuthenticationCredentials</strong> is a singleton autoload that stores the player’s username and session token so we can use it in <span class="No-Break">further scenes.</span></p>
			<p>Talking about further scenes, after updating the <strong class="source-inline">AuthenticationCredentials</strong> singleton, we change the scene to <strong class="source-inline">lobby_screen_scene</strong> using <strong class="source-inline">get_tree().change_scene_to_file(lobby_screen_scene)</strong>. That means the player has successfully logged in and we can take them to the <span class="No-Break">game lobby:</span></p>
			<pre class="source-code">
@rpc
func authentication_succeed(session_token):
    AuthenticationCredentials.user = user_line_edit.text
    AuthenticationCredentials.session_token = session_token
    get_tree().change_scene_to_file(lobby_screen_scene)</pre>			<p>As for <strong class="source-inline">authentication_failed()</strong>, we set <strong class="source-inline">error_label.text</strong> to the error message <a id="_idIndexMarker120"/>received from <strong class="source-inline">LobbyServer</strong>. This will display the error to <span class="No-Break">the player:</span></p>
			<pre class="source-code">
@rpc
func authentication_failed(error_message):
    error_label.text = error_message</pre>			<p>Now that we understand how both sides of this relationship communicate and what they do with the data they pass around and get from each other, it’s time to move on and see how the game resolves this data and displays the players’ avatars to each other, synchronizing new players across the network every time they join <span class="No-Break">the session.</span></p>
			<p>In the upcoming section, we will see what the lobby screen looks like on the player’s end and how we load, display, and sync player<a id="_idTextAnchor086"/>s’ avatars across <span class="No-Break">the network.</span></p>
			<h1 id="_idParaDest-56"><a id="_idTextAnchor087"/>Adding the player’s avatar</h1>
			<p>In any online game, the <a id="_idIndexMarker121"/>player’s avatar is a crucial element that represents them in the virtual world. In the previous section, we successfully authenticated the player and saved their session token and username in our <strong class="source-inline">AuthenticationCredentials</strong> autoload. Now, it’s time to use that information to display the player’s avatar in <span class="No-Break">the lobby.</span></p>
			<p>To achieve this, we will retrieve the player’s avatar information from our fake database and create a new <strong class="source-inline">AvatarCard</strong>, a custom scene with a <strong class="source-inline">TextureRect</strong> node to display the avatar’s image and a label to show its name. This way, players will be able to easily identify each other and feel more connected to the <span class="No-Break">game world.</span></p>
			<p>For that, let’s open the <strong class="source-inline">LobbyClient.gd</strong> script. Here, we are going to do three <span class="No-Break">major things:</span></p>
			<ol>
				<li>Retrieve the avatar information from the server by making an RPC to the <span class="No-Break"><strong class="source-inline">retrieve_avatar()</strong></span><span class="No-Break"> method.</span></li>
				<li>Implement the <strong class="source-inline">add_avatar()</strong> method that <strong class="source-inline">LobbyServer</strong> calls after retrieving the <span class="No-Break">avatar data.</span></li>
				<li>Implement the <strong class="source-inline">clear_avatars()</strong> method that <strong class="source-inline">LobbyServer</strong> calls before adding a new avatar to <span class="No-Break">the lobby.</span></li>
			</ol>
			<p>We are going to start with the<a id="_idIndexMarker122"/> latter two, then we can move on to the <strong class="source-inline">LobbyServer.gd</strong> file again to implement the <span class="No-Break"><strong class="source-inline">retrieve_avatar()</strong></span><span class="No-Break"> method:</span></p>
			<ol>
				<li>In the <strong class="source-inline">add_avatar()</strong> method, create a new instance <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">avatar_card_scene</strong></span><span class="No-Break">:</span><pre class="source-code">
@rpc
func add_avatar(avatar_name, texture_path):
    var avatar_card = avatar_card_scene.instantiate()</pre></li>				<li>Add the newly created instance of <strong class="source-inline">avatar_card</strong> to <strong class="source-inline">avatar_card_container</strong>. This is an <strong class="source-inline">HBoxContainer</strong> node inside a <span class="No-Break"><strong class="source-inline">ScrollContainer</strong></span><span class="No-Break"> node:</span><pre class="source-code">
    avatar_card_container.add_child(avatar_card)</pre></li>				<li>Wait for the next frame to process before continuing the execution of the code. We do that because <strong class="source-inline">AvatarCard</strong> needs to be ready before we update <span class="No-Break">its data:</span><pre class="source-code">
    await(get_tree().process_frame)</pre></li>				<li>Call the <strong class="source-inline">update_data()</strong> method on the <strong class="source-inline">avatar_card</strong> instance to update its data using the arguments passed to the <strong class="source-inline">add_avatar()</strong> method. With that, the lobby will use <strong class="source-inline">avatar_name</strong> to display the player’s avatar name and will load the image stored in the <strong class="source-inline">texture_path</strong> to display their <span class="No-Break">avatar’s image:</span><pre class="source-code">
    avatar_card.update_data(avatar_name, texture_path)</pre><p class="list-inset">The whole <strong class="source-inline">add_avatar()</strong> method should look <span class="No-Break">like this:</span></p><pre class="source-code">@rpc
func add_avatar(avatar_name, texture_path):
    var avatar_card = avatar_card_scene.instantiate()
    avatar_card_container.add_child(avatar_card)
    await(get_tree().process_frame)
    avatar_card.update_data(avatar_name, texture_path)</pre></li>			</ol>
			<p>Using the <strong class="source-inline">@rpc</strong> annotation, we created <a id="_idIndexMarker123"/>a method that the game’s server can call on clients to add a new player avatar to all players’ lobby screens, but this causes a small issue. As it is, this method may add the avatars that were already in the lobby before the newer player <span class="No-Break">joined it.</span></p>
			<p>So, we need to first clear all previous avatars and then add all currently logged players’ avatars again. This ensures the lobby has only the <span class="No-Break">correct avatars.</span></p>
			<p>In the coming section, we are going to create a method that will run through all current avatars and remove them to have an empty <strong class="source-inline">HBoxContainer</strong>th<a id="_idTextAnchor088"/>at we can use to add <span class="No-Break">new avatars.</span></p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor089"/>Cleaning AvatarCards</h2>
			<p>As mentioned before, whenever <a id="_idIndexMarker124"/>the server adds a new avatar to the lobby, it first cleans the lobby and recreates all avatars from scratch. We are going to see that in detail when we implement the <span class="No-Break"><strong class="source-inline">retrieve_avatar()</strong></span><span class="No-Break"> method.</span></p>
			<p>The <strong class="source-inline">clear_avatars()</strong> method frees all existing avatars from the <strong class="source-inline">avatar_card_container</strong> node. It iterates over all children of <strong class="source-inline">avatar_card_container</strong> and calls <strong class="source-inline">queue_free()</strong> on each of them. After this function is executed, all avatars previously displayed in the lobby are removed from <span class="No-Break">the container.</span></p>
			<p>In the <strong class="source-inline">clear_avatars()</strong> method, iterate over each child node in <strong class="source-inline">avatar_card_container</strong> using a <strong class="source-inline">for</strong> loop and call the <strong class="source-inline">queue_free()</strong> method on each child node to remove it from <strong class="source-inline">SceneTree</strong> and free <span class="No-Break">its resources:</span></p>
			<pre class="source-code">
@rpc
func clear_avatars():
    for child in avatar_card_container.get_children():
        child.queue_free()</pre>			<p>That’s it; pretty <span class="No-Break">simple, right?</span></p>
			<p>Now, before we move back to <strong class="source-inline">LobbyServer.gd</strong>, let’s make an RPC to the multiplayer authority so it retrieves the current player’s avatar. We do that in the <span class="No-Break"><strong class="source-inline">_ready()</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
func _ready():
    rpc_id(get_multiplayer_authority(), "retrieve_avatar",
        AuthenticationCredentials.user,
            AuthenticationCredentials.session_token)</pre>			<p>We use the <strong class="source-inline">rpc_id()</strong> method<a id="_idIndexMarker125"/> to call the <strong class="source-inline">retrieve_avatar()</strong> RPC method on the multiplayer authority, which is <strong class="source-inline">LobbyServer</strong> in this case. We pass the player’s <strong class="source-inline">username</strong> and <strong class="source-inline">session_token</strong>, which are stored in the <strong class="source-inline">AuthenticationCredentials</strong> singleton autoload, as arguments to the <strong class="source-inline">retrieve_avatar()</strong> method. Now, it’s t<a id="_idTextAnchor090"/>ime to move back <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">LobbyServer.gd</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor091"/>Retrieving players’ avatars</h1>
			<p>In this <a id="_idIndexMarker126"/>section, we will implement the <strong class="source-inline">retrieve_avatar()</strong> method on the <strong class="source-inline">LobbyServer.gd</strong> script, which will allow players to request their avatar data from the server. The avatar data is stored in the fake database. The server will respond with some RPCs to update all players with the appropriate data, displaying their avatars in the <span class="No-Break">shared lobby.</span></p>
			<p>With this method in place, we will complete the functionality of our <strong class="bold">Lobby</strong> project. Players will be able to authenticate themselves and display their avatars in the lobby. This will provide a solid foundation for building more complex multiplayer games in the upcoming chapter, as the basics of networking have <span class="No-Break">been covered.</span></p>
			<p>Let’s <span class="No-Break">do it!</span></p>
			<ol>
				<li>In the <strong class="source-inline">retrieve_avatar()</strong> method, check whether the user is logged in by verifying that the user exists in the <strong class="source-inline">logged_users</strong> dictionary. If the user is not logged in, exit <span class="No-Break">the function:</span><pre class="source-code">
func retrieve_avatar(user, session_token):
    if not user in logged_users:
        return</pre></li>				<li>Then, check whether the session token provided by the remote peer matches the session token stored in the <strong class="source-inline">logged_users</strong> dictionary for <span class="No-Break">the user:</span><pre class="source-code">
    if session_token == logged_users[user]:</pre></li>				<li>If the tokens match, call the <strong class="source-inline">clear_avatars()</strong> function on all connected peers to clear any existing avatars from their <span class="No-Break">lobby screen:</span><pre class="source-code">
        rpc("clear_avatars")</pre></li>				<li>Loop through all the logged-in users stored in the <span class="No-Break"><strong class="source-inline">logged_users</strong></span><span class="No-Break"> dictionary:</span><pre class="source-code">
        for logged_user in logged_users:</pre></li>				<li>Retrieve the <a id="_idIndexMarker127"/>avatar name and texture path for the current <strong class="source-inline">logged_user</strong> from the <span class="No-Break"><strong class="source-inline">database</strong></span><span class="No-Break"> dictionary:</span><pre class="source-code">
            Var avatar_name = database[logged_user]
                ['name']
            var avatar_texture_path = database
                [logged_user]['avatar']</pre></li>				<li>Call the <strong class="source-inline">add_avatar()</strong> method on all connected peers and pass in <strong class="source-inline">avatar_name</strong> and <strong class="source-inline">avatar_texture_path</strong> as arguments to display the avatar in <span class="No-Break">the lobby:</span><pre class="source-code">
           rpc("add_avatar", avatar_name,
               avatar_texture_path)</pre><p class="list-inset">This is how the <strong class="source-inline">retrieve_avatar()</strong> method should look after all <span class="No-Break">these steps:</span></p><pre class="source-code">@rpc("any_peer", "call_remote")
func retrieve_avatar(user, session_token):
    if not user in logged_users:
        return
    if session_token == logged_users[user]:
        rpc("clear_avatars")
        for logged_user in logged_users:
            var avatar_name = database
                [logged_user]['name']
            Var avatar_texture_path = database
                [logged_user]['avatar']
            rpc("add_avatar", avatar_name,
                avatar_texture_path)</pre></li>			</ol>
			<p>Pay attention<a id="_idIndexMarker128"/> to its <strong class="source-inline">@rpc</strong> annotation options. Notice that any peer can call it remotely. This is how we make an RPC API for our online multiplayer games in the <span class="No-Break">Godot Engine.</span></p>
			<p>Some methods should be called remotely only by the multiplayer authority, some should be called locally as well, and some can be called by any peer on the network. It is up to us to decide and manage how peers interact with <span class="No-Break">each other.</span></p>
			<p>With all that in place, it’s time to test out our game using multiple instances to simulate a server and multiple players connected to our netwo<a id="_idTextAnchor092"/>rk. Let’s do this in the <span class="No-Break">next section!</span></p>
			<h1 id="_idParaDest-59"><a id="_idTextAnchor093"/>Testing the lobby</h1>
			<p>To test this out, we are going to run <a id="_idIndexMarker129"/>three instances of <span class="No-Break">the game:</span></p>
			<ol>
				<li>Go to <strong class="bold">Debug</strong> | <strong class="bold">Run Multiple Instances</strong> and select <strong class="bold">Run </strong><span class="No-Break"><strong class="bold">3 Instances</strong></span><span class="No-Break">.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer031">
					<img alt="Figure 3.3 – Choosing to run three instances in the Run Multiple Instance﻿s menu" src="image/Figure_3.03_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – Choosing to run three instances in the Run Multiple Instances menu</p>
			<ol>
				<li value="2">Then, open the <strong class="source-inline">res://03.making-lobby-to-gather-players/MainMenu.tscn</strong> scene and hit the <span class="No-Break"><strong class="bold">Play</strong></span><span class="No-Break"> button.</span></li>
				<li>Pick one of the<a id="_idIndexMarker130"/> instances to be the game’s server. To do that, just click on the <span class="No-Break"><strong class="bold">Server</strong></span><span class="No-Break"> button.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer032">
					<img alt="Figure 3.4 – Pressing the Server button on the MainMenu screen" src="image/Figure_03.04_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – Pressing the Server button on the MainMenu screen</p>
			<ol>
				<li value="4">Now, pick another instance and click on the <strong class="bold">Client</strong> button. It will take you to the <strong class="source-inline">LobbyLogin</strong> screen, where you can enter the first fake <span class="No-Break">player’s credentials.</span></li>
				<li>Insert <strong class="source-inline">user1</strong> in the username field and <strong class="source-inline">test</strong> in the password field. These are the credentials we added to <strong class="source-inline">FakeDatabase.json</strong> for our first user. Then, press the <strong class="bold">Login</strong> button. It <a id="_idIndexMarker131"/>will take you to the <strong class="source-inline">LobbyClient</strong> screen with a <span class="No-Break">single avatar.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer033">
					<img alt="Figure 3.5 – The LobbyLogin screen with the player’s credentials" src="image/Figure_3.05_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5 – The LobbyLogin screen with the player’s credentials</p>
			<p class="list-inset">With that, the server will authenticate the player’s credentials and will allow the player to move on to the next screen, displaying the player’s character’s avatar and name based on the data it matched in the database file. In the following screenshot, we can see the next screen after a <span class="No-Break">successful login.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer034">
					<img alt="Figure 3.6 – LobbyClient displaying the player’s avatar after login" src="image/Figure_03.06_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6 – LobbyClient displaying the player’s avatar after login</p>
			<ol>
				<li value="6">Then, select the last <a id="_idIndexMarker132"/>instance and click on the <strong class="bold">Client</strong> button as well. On the <strong class="source-inline">LobbyLogin</strong> screen, use the second player’s credentials. In the first field, insert <strong class="source-inline">user2</strong>, and then, in the second field, <strong class="source-inline">test</strong>. It will take you to the <strong class="source-inline">LobbyClient</strong> screen, where there should be two avatars now. You can check the other client instance and they will both have the same avatars <span class="No-Break">in order.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer035">
					<img alt="Figure 3.7 – The game displaying both players’ avatars after the second player is logged in" src="image/Figure_3.07_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.7 – The game displaying both players’ avatars after the second player is logged in</p>
			<p>We can see that everything is working as we want! The players can insert their credentials and the server authenticates them and provides a session token to keep them logged in after their validation. When logged in, they can see their avatar. Not only that, but our game also syncs players’ avatars when a new player joins <span class="No-Break">the session.</span></p>
			<p>We did all that using the powerful <strong class="source-inline">@rpc</strong> annotation, which is possible to use when peers connect using the <span class="No-Break"><strong class="source-inline">ENetMultiplayerPeer</strong></span><span class="No-Break"> API.</span></p>
			<h1 id="_idParaDest-60"><a id="_idTextAnchor094"/>Summary</h1>
			<p>In this chapter, we learned about RPCs and their importance in multiplayer game architectures. We saw how RPCs can be used to exchange data between nodes in the Godot Engine. We also saw what a multiplayer authority node is and how to set one up that manages all the game states between network peers. On top of that, we saw that by using the multiplayer API and <strong class="source-inline">ENetMultiplayerPeer</strong>, we can easily handle the communication <span class="No-Break">between nodes.</span></p>
			<p>Throughout the chapter, we created a lobby, which is a multiplayer game that features a lobby where players can join together. We saw how to create a client-server architecture, authenticate users, and exchange data between the server and the clients using RPCs. We also learned how to use the multiplayer API and <strong class="source-inline">ENetMultiplayerPeer</strong> to create a connection between the client and <span class="No-Break">the server.</span></p>
			<p>One of the essential concepts we learned is how <strong class="source-inline">ENetMultiplayerPeer</strong> simplifies the whole process of creating a multiplayer game compared to the low-level UDP approach. It abstracts away the complexity of low-level network programming, such as sending and receiving data packets, managing connections, and handling errors. This makes it easier for us to focus on implementing the gameplay mechanics of the game rather than worrying about the low-level details of the <span class="No-Break">network communication.</span></p>
			<p>Overall, this chapter has provided a solid foundation for developing multiplayer games in the Godot Engine. By following the steps outlined in this chapter, developers can create a simple lobby-based multiplayer game that utilizes RPCs, authentication, and the <span class="No-Break">multiplayer API.</span></p>
			<p>In the upcoming chapter, we are going to test the <strong class="source-inline">ENetMultiplayerPeer</strong> capabilities to exchange, update, and sync players. For that, we will create a chat room where players can communicate with each other and finally create a shared experience and a sense <span class="No-Break">of community.</span></p>
		</div>
	</body></html>