<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-16"><a id="_idTextAnchor015"/>1</h1>
<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>Embedded Systems – A Pragmatic Approach</h1>
<p>Designing and writing software for embedded systems poses a different set of challenges than traditional high-level software development.</p>
<p>This chapter provides an overview of these challenges and introduces the basic components and the platform that will be used as a reference in this book.</p>
<p>In this chapter, we will discuss the following topics:</p>
<ul>
<li>Domain definition</li>
<li><strong class="bold">General-purpose </strong><strong class="bold">input/output</strong> (<strong class="bold">GPIO</strong>)</li>
<li>Interfaces and peripherals</li>
<li>Connected systems</li>
<li>Introduction to isolation mechanisms</li>
<li>The reference platform</li>
</ul>
<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/>Domain definition</h1>
<p><strong class="bold">Embedded systems</strong> are computing devices that perform specific, dedicated tasks with no direct or <a id="_idIndexMarker000"/>continued user interaction. Due to the variety of markets and technologies, these objects have different shapes and sizes, but often, all have a small size and a limited amount of resources.</p>
<p>In this book, the concepts and the building blocks of embedded systems will be analyzed through the development of the software components that interact with their resources and peripherals. The first step is to define the scope for the validity of the techniques and the architectural patterns explained in this book, within the broader definition of embedded systems.<a id="_idTextAnchor018"/></p>
<h2 id="_idParaDest-19"><a id="_idTextAnchor019"/>Embedded Linux systems</h2>
<p>One part of the <a id="_idIndexMarker001"/>embedded market relies on devices with enough power and resources to run a variant of the GNU/Linux OS. These systems, often referred to as <strong class="bold">embedded Linux</strong>, are outside the scope of this book, as their development includes different strategies of design and integration of the components. A typical hardware platform that is capable of running a system based on the Linux kernel is equipped with a reasonably large amount of RAM, up to a few gigabytes, and sufficient storage space on board to store all the software components provided in the GNU/Linux distribution.</p>
<p>Additionally, for the Linux memory management to provide separate virtual address spaces to each process on <a id="_idIndexMarker002"/>the system, the hardware must be equipped with a <strong class="bold">memory management unit</strong> (<strong class="bold">MMU</strong>), a hardware component that assists the OS in translating physical addresses into virtual addresses, and vice versa, at runtime.</p>
<p>This class of devices presents different characteristics that are often overkill for building tailored solutions, which can use a much simpler design and reduce the production costs of single units.</p>
<p>Hardware manufacturers and chip designers have researched new techniques to improve the performance of microcontroller-based systems. In the past few decades, they have introduced new generations of platforms that would cut hardware costs, firmware complexity, size, and power consumption to provide a set of features that are most interesting for the embedded market.</p>
<p>Due to their specifications, in some real-life scenarios, embedded systems must be able to execute a <a id="_idIndexMarker003"/>series of tasks within a short, measurable, and predictable amount of time. These kinds of systems are called <strong class="bold">real-time systems</strong> and differ from the approach of multi-task computing, which is used in desktops, servers, and mobile phones.</p>
<p><strong class="bold">Real-time processing</strong> is a goal that is <a id="_idIndexMarker004"/>extremely hard, if not impossible, to reach on embedded Linux platforms. The Linux kernel is not designed for hard real-time processing, and <a id="_idIndexMarker005"/>even if patches are available to modify the kernel scheduler to help meet these requirements, the results are not comparable to bare-metal, constrained systems that are designed with this purpose in mind.</p>
<p>Some other application domains, such as battery-powered and energy-harvesting devices, can benefit from the low power consumption capabilities of smaller embedded devices and the energy efficiency of the wireless communication technologies often integrated into embedded connected devices. The higher amount of resources and the increased hardware complexity of Linux-based systems often do not scale down enough on energy levels or require effort to meet similar figures in power consumption.</p>
<p>The type of microcontroller-based systems that we will analyze in this book is 32-bit systems, which are capable of running software in a single-threaded, bare-metal application, as well as <a id="_idIndexMarker006"/>integrating minimalist real-time OSs, which are very popular in the industrial manufacturing of embedded systems, which we use daily to accomplish specific tasks. They are becoming more and more adopted to help define more generic, multiple-purpose development plat<a id="_idTextAnchor020"/>forms.</p>
<h2 id="_idParaDest-20"><a id="_idTextAnchor021"/>Low-end 8-bit microcontrollers</h2>
<p>In the past, <strong class="bold">8-bit microcontrollers</strong> dominated the embedded market. The simplicity of their design allows <a id="_idIndexMarker007"/>us to write small applications that can <a id="_idIndexMarker008"/>accomplish a set of predefined tasks but are too simple and usually equipped with too few resources to implement an embedded system, especially since 32-bit microcontrollers have evolved to cover all the use cases for these devices within the same range of price, size, and power consumption.</p>
<p>Nowadays, 8-bit microcontrollers are mostly relegated to the market of educational platform kits, aimed at introducing hobbyists and newcomers to the basics of software development on electronic devices. 8-bit platforms are not covered in this book because they lack the characteristics that allow advanced system programming, multithreading, and advanced features to be developed to build professional embedded systems.</p>
<p>In the context of this book, the term <strong class="bold">embedded systems</strong> is used to indicate a class of systems running on <a id="_idIndexMarker009"/>microcontroller-based hardware architecture, offering constrained resources but allowing real-time systems to be built through features provided by the hardware architecture to implement system pro<a id="_idTextAnchor022"/>gramming.</p>
<h2 id="_idParaDest-21"><a id="_idTextAnchor023"/>Hardware architecture</h2>
<p>The architecture of an embedded system is centered around its microcontroller, also sometimes referred to as the <strong class="bold">microcontroller unit</strong> (<strong class="bold">MCU</strong>). This is typically a single integrated circuit <a id="_idIndexMarker010"/>containing the processor, RAM, flash <a id="_idIndexMarker011"/>memory, serial receivers and transmitters, and other core components. The market offers many different choices among architectures, vendors, price ranges, features, and integrated resources. These are typically designed to <a id="_idIndexMarker012"/>be inexpensive, low-resource, low-energy consuming, self-contained systems on a single integrated circuit, which is the reason why they are often referred to as <strong class="bold">System-on-Chip</strong> (<strong class="bold">SoC</strong>).</p>
<p>Due to the variety of processors, memories, and interfaces that can be integrated, there is no actual reference architecture for microcontrollers. Nevertheless, some architectural elements are common across a wide range of models and brands, and even across different processor architectures.</p>
<p>Some microcontrollers are dedicated to specific applications and expose a particular set of interfaces to communicate to peripherals and the outside world. Others are focused on providing solutions with reduced hardware costs, or with very limited energy consumption.</p>
<p>Nevertheless, the <a id="_idIndexMarker013"/>following set of components is hardcoded into almost every microcontroller:</p>
<ul>
<li><strong class="bold">Microprocessor</strong></li>
<li><strong class="bold">RAM</strong></li>
<li><strong class="bold">Flash memory</strong></li>
<li><strong class="bold">Serial transceivers</strong></li>
</ul>
<p>Additionally, more and more devices are capable of accessing a network, to communicate with other devices and gateways. Some microcontrollers may provide either well-established standards, such as <em class="italic">Ethernet or Wi-Fi interfaces</em>, or specific protocols specifically <a id="_idIndexMarker014"/>designed to meet the constraints of embedded systems, such as sub-GHz radio interfaces or a <strong class="bold">Controller Area Network</strong> (<strong class="bold">CAN</strong>) bus, being partially or fully implemented within the IC.</p>
<p>All the components must share a bus line with the processor, which is responsible for coordinating the logic. The RAM, flash memory, and control registers of the transceivers are all mapped in the same physical address space:</p>
<div><div><img alt="Figure 1.1 – A simplified block diagram of the components inside a generic microcontroller" src="img/B18730_01_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – A simplified block diagram of the components inside a generic microcontroller</p>
<p>The addresses <a id="_idIndexMarker015"/>where <strong class="bold">RAM</strong> and <strong class="bold">Flash Memory</strong> are mapped depend on the specific model and are usually provided in the datasheet. A microcontroller can run code in its native machine language; that is, a <a id="_idIndexMarker016"/>sequence of instructions conveyed into a binary file that is specific to the architecture it is running on. By default, compilers provide a generic executable file as the output of the compilation and assembly operations, which needs to be converted into a format that can be executed by the target.</p>
<p>The <strong class="bold">Processor</strong> part is designed to execute the instructions that have been stored in its own specific binary format directly from RAM as well as from its internal flash memory. This is usually mapped starting from position zero in memory or another well-known address specified in the microcontroller manual. The CPU can fetch and execute code from RAM faster, but the final firmware is stored in the flash memory, which is usually bigger than the RAM on almost all microcontrollers and permits it to retain the data across power cycles and reboots.</p>
<p>Compiling a software operating environment for an embedded microcontroller and loading it onto the flash memory requires a host machine, which is a specific set of hardware and software tools. Some knowledge about the target device’s characteristics is also needed to instruct <a id="_idIndexMarker017"/>the compiler to organize the symbols within the executable image. For many valid reasons, C is the most popular language in embedded software, although not the only available option. Higher-level languages, such as Rust and C++, can produce embedded code when combined with a specific embedded runtime, or even in some cases by entirely removing the runtime support from the language.</p>
<p class="callout-heading">Note</p>
<p class="callout">This book will focus entirely on C code because it abstracts less than any other high-level language, thus making it easier to describe the behavior of the underlying hardware while looking at the code.</p>
<p>All modern embedded systems platforms also have at least one mechanism (such as <strong class="bold">JTAG</strong>) for debugging purposes and uploading the software to the flash. When the debugging interface is accessed from the host machine, a debugger can interact with the breakpoint unit in the processor, interrupting and resuming the execution, and can also read and write from any address in memory.</p>
<p>A significant part of embedded programming is communicating the peripherals while using the interfaces that the MCU exposes. Embedded software development requires basic knowledge of electronics, the ability to understand schematics and datasheets, and confidence with the measurement tools, such as logic analyzers o<a id="_idTextAnchor024"/>r oscilloscopes.</p>
<h2 id="_idParaDest-22"><a id="_idTextAnchor025"/>Understanding the challenges</h2>
<p>Approaching embedded <a id="_idIndexMarker018"/>development means keeping the focus on the specifications as well as the hardware restrictions at all times. Embedded software development is a constant challenge that requires focusing on the most efficient way to perform a set of specific tasks but keeping the limited resources available in strong consideration. There are several compromises to deal with, which are uncommon in other environments. Here are some examples:</p>
<ul>
<li>There might be not enough space in the flash to implement a new feature</li>
<li>There might not be enough RAM to store complex structures or make copies of large data buffers</li>
<li>The processor might be not fast enough to accomplish all the required calculations and data processing in due time</li>
<li>Battery-powered and resource-harvesting devices might require lower energy consumption to meet lifetime expectations</li>
</ul>
<p>Moreover, PC and mobile OSs make large use of the MMU, a component of the processor that allows runtime translations between physical and virtual addresses.</p>
<p>The MMU is a necessary abstraction to implement address space separation among the tasks, as well as between <a id="_idIndexMarker019"/>the tasks and the kernel itself. Embedded microcontrollers do not have an MMU, and usually lack the amount of non-volatile memory required to store kernels, applications, and libraries. For this reason, embedded systems are often running in a single task, with the main loop performing all the data processing and communication in a specific order. Some devices can run embedded OSs, which are far less complex than their PC counterparts.</p>
<p>Application developers often see the underlying system as a commodity, while embedded development often means that the entire system has to be implemented from scratch, from the boot procedure up to the application logic. In an embedded environment, the various software components are more closely related to each other because of the lack of more complex abstractions, such as memory separations between the processes and the OS kernel.</p>
<p>A developer approaching embedded systems for the first time might find testing and debugging on some of the systems a bit more intricate than just running the software and reading out the results. This becomes especially true in those systems that have been designed with little or no human interaction interfaces.</p>
<p>A successful approach requires a healthy workflow, which includes well-defined test cases, a list of key performance indicators coming from the analysis of the specifications to identify possibilities of trade-offs, several tools and procedures at hand to perform all the needed measurements, and a well-established and efficient prototyping phase.</p>
<p>In this context, security deserves some special consideration. As usual, when writing code at the system level, it is <a id="_idIndexMarker020"/>wise to keep in mind the system-wide consequences of possible faults. Most embedded application code runs with extended privileges on the hardware, and a single task misbehaving can affect the stability and integrity of the entire firmware. As we will see, some platforms offer specific memory protection mechanisms and built-in privilege separation, which are useful for building fail-safe systems, even in the absence of a full OS based on separating proc<a id="_idTextAnchor026"/>ess address spaces.</p>
<h2 id="_idParaDest-23"><a id="_idTextAnchor027"/>Multithreading</h2>
<p>One of the advantages of using microcontrollers designed to build embedded systems is the possibility to run <a id="_idIndexMarker021"/>logically separated tasks within separate execution units by time-sharing the resources.</p>
<p>The most popular type of design for embedded software is based on a single loop-based sequential execution model, where modules and components are connected to expose callback interfaces. However, modern microcontrollers offer features and core logic characteristics that can be used by system developers to build a multitasking environment to run logically separated applications.</p>
<p>These features are particularly handy in the approach to more complex real-time systems, and they help us understand the possibilities of the implementation of safety models based on process isolation and <a id="_idTextAnchor028"/>memory segmentation.</p>
<h1 id="_idParaDest-24"><a id="_idTextAnchor029"/>RAM</h1>
<p><em class="italic">“640 KB of memory ought to be enough </em><em class="italic">for everyone”</em></p>
<p><em class="italic">– Bill Gates (founder and former director </em><em class="italic">of Microsoft)</em></p>
<p>This famous statement has <a id="_idIndexMarker022"/>been cited many times in the past three decades to underline the progress in technology and the outstanding achievements of the PC industry. While it may sound like a joke for many software engineers out there, it is still in these figures that embedded programming has to be thought about, more than 30 years after MS-DOS was initially released.</p>
<p>Although most embedded systems are capable of breaking that limit today, especially due to the availability of external DRAM interfaces, the simplest devices that can be programmed in C may have as little as 4 KB of RAM available to implement the entire system logic. This has to be taken into account when designing an embedded system, by estimating the amount of memory potentially needed for all the operations that the system has to perform, and the buffers that may be used at any time to communicate with peripherals and nearby devices.</p>
<p>The memory model at the system level is simpler than that of PCs and mobile devices. Memory access is typically done at the physical level, so all the pointers in your code are telling you the physical location of the data they are pointing to. In modern computers, the OS is responsible for translating physical addresses into a virtual representation of the running tasks.</p>
<p>The advantage of the physical-only memory access on those systems that do not have an MMU is the reduced complexity of having to deal with address translations while coding and debugging. On the other hand, some of the features that are implemented by any modern OS, such as process swapping and dynamically resizing address spaces through memory relocation, become cumbersome and sometimes impossible.</p>
<p>Handling memory is particularly important in embedded systems. Programmers who are used to writing application code expect a certain level of protection to be provided by the underlying OS. A virtual address space does not allow memory areas to overlap, and the OS can easily detect <a id="_idIndexMarker023"/>unauthorized memory accesses and segmentation violations, so it promptly terminates the process and avoids having the whole system compromised.</p>
<p>On embedded systems, especially when writing bare-metal code, the boundaries of each address pool must be checked manually. Accidentally modifying a few bits in the wrong memory, or even accessing a different area of memory, may result in a fatal, irrevocable error. The entire system may hang, or, in the worst case, become unpredictable. A safe approach is required when handling memory in embedded systems, in particular when dealing with life-critical devices. Identifying memory errors too late in the development process is complex and often requires more resources than forcing yourself to write safe code and protecting the system from a programmer’s mistakes.</p>
<p>Proper memory-handling <a id="_idIndexMarker024"/>techniques will be explained in <a href="B18730_05.xhtml#_idTextAnchor149"><em class="italic">Chapter 5</em></a>, <em class="italic">Memory Management</em>.</p>
<h1 id="_idParaDest-25"><a id="_idTextAnchor030"/>Flash memory</h1>
<p>In a server or a personal computer, the executable applications and libraries reside in storage devices. At <a id="_idIndexMarker025"/>the beginning of the execution, they are accessed, transformed, possibly uncompressed, and stored in RAM before the execution starts.</p>
<p>The firmware of an embedded device is, in general, one single binary file containing all the software components, which can be transferred to the internal flash memory of the MCU. Since the flash memory is directly mapped to a fixed address in the memory space, the processor is <a id="_idIndexMarker026"/>capable of sequentially fetching and executing single instructions from it with no intermediate steps. This mechanism is called <strong class="bold">execute in </strong><strong class="bold">place</strong> (<strong class="bold">XIP</strong>).</p>
<p>All non-modifiable sections on the firmware do not need to be loaded in memory and are accessible through direct addressing in the memory space. This includes not only the executable instructions but also all the variables that are marked as constant by the compiler. On the other hand, supporting XIP requires a few extra steps when preparing the firmware image to be stored in flash, and the linker needs to be instructed about the different memory-mapped areas on the target.</p>
<p>The internal flash memory that is mapped in the address space of the microcontroller is not accessible for writing. Altering the content of the internal flash can be done only by using block-based access, due to the hardware characteristics of flash memory devices. Before changing the value of a single byte in flash memory, the whole block containing it must be erased <a id="_idIndexMarker027"/>and rewritten. The mechanism offered by most manufacturers to access block-based flash memory for writing is known as <strong class="bold">In-Application Programming</strong> (<strong class="bold">IAP</strong>). Some filesystem implementations take care of abstracting write operations on a block-based flash device, by creating a temporary copy of the block where the write operation is performed.</p>
<p>While selecting the components for a microcontroller-based solution, it is vital to match the size of the flash memory to the space required by the firmware. The flash is often one of the most expensive components in the MCU, so for deployment on a large scale, choosing an MCU with a smaller flash could be more cost-effective. Developing software with code size in mind is not very usual nowadays within other domains, but it may be required when trying to fit multiple features in such little storage. Finally, compiler optimizations may exist on specific architectures to reduce code size when building the firmware and linking its components.</p>
<p>Additional non-volatile memories that reside outside of the MCU silicon can typically be accessed using specific interfaces, such as the <strong class="bold">Serial Peripheral Interface</strong>. External flash memories use different <a id="_idIndexMarker028"/>technologies than internal flash, which is designed to be fast and execute code in place. While being generally more dense and less expensive, external flash memories do not allow direct memory mapping in the physical address space, which makes them <a id="_idIndexMarker029"/>unsuitable for storing firmware images. This is because it would be impossible to execute the code fetching the instructions sequentially unless a mechanism is used to load the executable symbols in RAM – read access on these kinds of devices is performed one block at a time. On the other hand, write access may be faster compared to IAP, making these kinds of non-volatile memory devices ideal for storing data that is retrieved at runtime in some designs.</p>
<h1 id="_idParaDest-26"><a id="_idTextAnchor031"/>General-purpose input/output (GPIO)</h1>
<p>The most basic functionality that can be achieved with any microcontroller is the possibility to <a id="_idIndexMarker030"/>control signals on specific pins of the integrated circuit. The microcontroller can turn a digital output on or off, which corresponds to a reference voltage to be applied to the pin when the value assigned to it is 1, and zero volts when the value is 0. In the same way, a pin can be used to detect a 1 or a 0 when the pin is configured as input. The software will read the digital value “1” when the voltage applied to it is higher than a certain threshold.</p>
<h2 id="_idParaDest-27"><a id="_idTextAnchor032"/>ADC and DAC</h2>
<p>Some chips have onboard ADC controllers, which are capable of sensing the voltage that is applied to the <a id="_idIndexMarker031"/>pin and sampling it. This is often <a id="_idIndexMarker032"/>used to acquire measurements from input peripherals providing a variable voltage as output. The embedded software will be able to read the voltage, with an accuracy that depends on the predefined range.</p>
<p>A DAC controller is the inverse <a id="_idIndexMarker033"/>of an ADC controller, transforming <a id="_idIndexMarker034"/>a value on a microcontroller register into the corresponding voltage.</p>
<h2 id="_idParaDest-28"><a id="_idTextAnchor033"/>Timers and PWM</h2>
<p>Microcontrollers may <a id="_idIndexMarker035"/>offer diverse ways to measure time. Often, there is at least one interface based on a countdown timer that can trigger an interrupt and automatically reset upon expiry.</p>
<p>GPIO pins configured as <a id="_idIndexMarker036"/>output can be programmed to output <a id="_idIndexMarker037"/>a square wave with a preconfigured frequency and duty cycle. This is called <strong class="bold">pulse-wave modulation</strong> (<strong class="bold">PWM</strong>) and has several uses, from controlling output peripherals to dimming an LED or even playing an audible sound through a speaker.</p>
<p>More details about GPIO, interrupt timers, and watchdogs will be explored in <a href="B18730_06.xhtml#_idTextAnchor194"><em class="italic">Chapter 6</em></a>, <em class="italic">General-Purpose Peripherals</em>.</p>
<h1 id="_idParaDest-29"><a id="_idTextAnchor034"/>Interfaces and peripherals</h1>
<p>To communicate with <a id="_idIndexMarker038"/>peripherals and other microcontrollers, several <em class="italic">de facto</em> standards are well <a id="_idIndexMarker039"/>established in the embedded world. Some of the external pins of the microcontroller can be programmed to carry out communication with external peripherals using specific protocols. A few of the common interfaces available on most architectures are as follows:</p>
<ul>
<li>Asynchronous UART-based serial communication</li>
<li><strong class="bold">Serial Peripheral Interface</strong> (<strong class="bold">SPI</strong>) bus</li>
<li><strong class="bold">Inter-integrated circuit</strong> (<strong class="bold">I</strong>2<strong class="bold">C</strong>) bus</li>
<li><strong class="bold">Universal Serial <a id="_idTextAnchor035"/></strong><strong class="bold">Bus</strong> (<strong class="bold">USB</strong>)</li>
</ul>
<p>Let’s review each in detail.</p>
<h2 id="_idParaDest-30"><a id="_idTextAnchor036"/>Asynchronous UART-based serial communication</h2>
<p>Asynchronous <a id="_idIndexMarker040"/>communication is <a id="_idIndexMarker041"/>provided by the <strong class="bold">Universal Asynchronous Receiver-Transmitter</strong> (<strong class="bold">UART</strong>). These kinds of interfaces, commonly known as <strong class="bold">serial ports</strong>, are called asynchronous because they do not need to share a clock signal to synchronize the sender and the receiver, but rather work on predefined clock rates that can be aligned while the communication is ongoing. Microcontrollers may contain multiple UARTs that can be attached to a specific set of pins upon request. Asynchronous communication is provided by UART as a full-duplex channel, through two independent wires, connecting the RX pin of each endpoint to the TX pin on the opposite side.</p>
<p>To understand each other, the systems at the two endpoints must set up the UART using the same <a id="_idIndexMarker042"/>parameters. This includes the framing of the bytes on the wire and the frame rate. All of these parameters have to be known in advance by both endpoints to correctly establish a communication channel. Despite being simpler than the other types of serial communication, UART-based serial communication is still widely used in electronic devices, particularly as an interface for modems and GPS receivers. Furthermore, using TTL-to-USB serial converters, it is easy to connect a UART to a console on the host machine, which i<a id="_idTextAnchor037"/>s often handy for providing log messages.</p>
<h2 id="_idParaDest-31"><a id="_idTextAnchor038"/>SPI</h2>
<p>A different approach to classic UAR—based communication is <strong class="bold">SPI</strong>. Introduced in the late 1980s, this <a id="_idIndexMarker043"/>technology aimed to replace asynchronous serial communication toward peripherals by introducing several improvements:</p>
<ul>
<li>Serial clock line to synchronize the endpoints</li>
<li>Master-slave protocol</li>
<li>One-to-many communication over the same three-wire bus</li>
</ul>
<p>The master device, usually the microcontroller, shares the bus with one or more slaves. To trigger the communication, a separate <strong class="bold">slave select</strong> (<strong class="bold">SS</strong>) signal is used to address each slave connected <a id="_idIndexMarker044"/>to the bus. The bus uses two independent signals for data transfer, one per direction, and a shared clock line that synchronizes the two ends of the communication. Due to the clock line being generated by the master, the data transfer is more reliable, making it possible to achieve higher bitrates than ordinary UART. One of the keys to the continued success of SPI over multiple generations of microcontrollers is the low complexity required for the design of slaves, which can be as simple as a single shift register. SPI is commonly used in sensor devices, LCDs, flash <a id="_idTextAnchor039"/><a id="_idIndexMarker045"/>memory controllers, and network interfaces.</p>
<h2 id="_idParaDest-32"><a id="_idTextAnchor040"/>I2C</h2>
<p>I2C is slightly more complex, and <a id="_idIndexMarker046"/>that is because it is designed with a different purpose in mind: <em class="italic">interconnecting multiple microcontrollers</em>, as well as multiple slave devices, on the <a id="_idIndexMarker047"/>same two-wire bus. The two signals are <strong class="bold">serial clock</strong> (<strong class="bold">SCL</strong>) and <strong class="bold">serial data</strong> (<strong class="bold">SDA</strong>). Unlike SPI or UART, the bus is half-duplex, as the two directions of the flow share the <a id="_idIndexMarker048"/>same signal. Thanks to a 7-bit slave-addressing mechanism incorporated in the protocol, it does not require additional signals dedicated to selecting the slaves. Multiple masters are allowed on the same line, given that all the masters in the system follow the a<a id="_idTextAnchor041"/>rbitration logic in the case of bus contention.</p>
<h2 id="_idParaDest-33"><a id="_idTextAnchor042"/>USB</h2>
<p>The USB protocol, originally <a id="_idIndexMarker049"/>designed to replace UART and include many protocols in the same hardware connector, is very popular in personal computers, portable devices, and a huge number of peripherals.</p>
<p>This protocol works in host-device mode, with one side of communication, the device, exposing services that can be used by the controller, on the host side. USB transceivers present in many microcontrollers can work in both modes. By implementing the upper layer of the USB standards, different types of devices can be emulated by the microcontroller, such as serial ports, storage devices, and point-to-point Ethernet interfaces, creating microcontroller-based USB devices that can be connected to a host system.</p>
<p>If the transceiver supports host mode, the embedded system can act as a USB host, and devices can be connected to it. In this case, the system should implement device drivers and applications to access the functionality provided by the device.</p>
<p>When both modes are <a id="_idIndexMarker050"/>implemented on the same USB controller, the transceiver works in <strong class="bold">on-the-go</strong> (<strong class="bold">OTG</strong>) mode, and selecting and configuring the desired mode can be done at runtime.</p>
<p>A more extended introduction to some of the most common protocols used for communicating <a id="_idIndexMarker051"/>with peripherals and neighboring systems will be provided<a id="_idTextAnchor043"/> in <a href="B18730_07.xhtml#_idTextAnchor230"><em class="italic">Chapter 7</em></a>, <em class="italic">Local </em><em class="italic">Bus Interfaces</em>.</p>
<h1 id="_idParaDest-34"><a id="_idTextAnchor044"/>Connected systems</h1>
<p>An increasing number of embedded devices designed for different markets are now capable of network communication with their peers in the surrounding area or with gateways routing their <a id="_idIndexMarker052"/>traffic to a broader network or the internet. The term <strong class="bold">Internet of Things</strong> (<strong class="bold">IoT</strong>) has been used to describe the networks where those embedded devices can communicate using internet protocols.</p>
<p>This means that IoT devices can be addressed within the network in the same way as more complex systems, such as PCs or mobile devices, and most importantly, they use the transport layer protocols <a id="_idIndexMarker053"/>typical of internet communications to exchange data. TCP/IP is a suite of protocols standardized by the IETF, and it is the fabric of the infrastructure for the internet and other self-contained, local area networks.</p>
<p>The <strong class="bold">Internet Protocol</strong> (<strong class="bold">IP</strong>) provides network connectivity, but on the condition that the underlying link <a id="_idIndexMarker054"/>provides packet-based communication and mechanisms to control and regulate access to the physical media. Fortunately, many network interfaces meet these requirements. Alternative protocol families, which are not compatible with TCP/IP, are still in use in several distributed embedded systems, but a clear advantage of using the TCP/IP standard on the target is that, in the case of communication with non-embedded systems, there is no need for a translation mechanism to route the frames outside the scope of the LAN.</p>
<p>Besides the types of links that are widely used in non-embedded systems, such as Ethernet or wireless LAN, embedded systems can benefit from a wide choice of technologies that are specifically designed for the requirements introduced by IoT. New standards have been researched and put into effect to provide efficient communication for constrained devices, defining communication models to cope with specific resource usage limits and energy efficiency requirements.</p>
<p>Recently, new link technologies have been developed in the direction of lower bitrates and power consumption for wide-area network communication. These protocols are designed to provide narrow-band, long-range communication. The frame is too small to fit IP packets, so these technologies are mostly employed to transmit small payloads, such as periodic sensor data, or device configuration parameters if a bidirectional channel is available, and they require some form of gateway to translate the communication so that it can travel across the internet.</p>
<p>The interaction with the cloud services, however, requires, in most cases, connecting all the nodes in the network, and implementing the same technologies used by the servers and the IT infrastructure directly in the host. Enabling TCP/IP communication on an embedded device is not always straightforward. Even though there are several open source implementations available, system TCP/IP code is complex, big in size, and often has memory requirements that may be difficult to meet.</p>
<p>The same observation <a id="_idIndexMarker055"/>applies to the <strong class="bold">Secure Socket Layer</strong> (<strong class="bold">SSL</strong>)/<strong class="bold">Transport Layer Security</strong> (<strong class="bold">TLS</strong>) library, which adds confidentiality and authentication between <a id="_idIndexMarker056"/>the two communication endpoints. Choosing the right microcontroller for the task is, again, crucial, and if the system has to be connected to the internet and support secure socket communication, then the flash and RAM requirements have to be updated in the design phase to ensure integration with third-party libraries.</p>
<h2 id="_idParaDest-35"><a id="_idTextAnchor045"/>Challenges of distributed systems</h2>
<p>Designing distributed embedded systems, especially those that are based on wireless link technologies, adds a set of interesting challenges.</p>
<p>Some of these <a id="_idIndexMarker057"/>challenges are related to the following aspects:</p>
<ul>
<li>Selecting the correct technologies and protocols</li>
<li>Limitations on bitrate, packet size, and media access</li>
<li>Availability of the nodes</li>
<li>Single points of failure in the topology</li>
<li>Configuring the routes</li>
<li>Authenticating the hosts involved</li>
<li>The confidentiality of the communication over the media</li>
<li>The impact of buffering on network speed, latency, and RAM usage</li>
<li>The complexity <a id="_idIndexMarker058"/>of implementing the protocol stacks</li>
</ul>
<p><a href="B18730_09.xhtml#_idTextAnchor311"><em class="italic">Chapter 9</em></a>, <em class="italic">Distributed Systems and IoT Architecture</em>, analyzes some of the link-layer technologies implemented in embedded systems to provide remote communication, where TCP/IP communication is integrated into the design of distributed systems that are integrated with IoT services.</p>
<h1 id="_idParaDest-36"><a id="_idTextAnchor046"/>Introduction to isolation mechanisms</h1>
<p>Some newer microcontrollers include support for isolation between trusted and non-trusted software running <a id="_idIndexMarker059"/>onboard. This mechanism is based on a CPU extension, available only on some specific architectures, which usually relies on a sort of physical separation inside the CPU itself between the two modes of execution. All the code running from a non-trusted zone in the system will have a restricted view of the RAM, devices, and peripherals, which must be dynamically configured by the trusted counterpart in advance.</p>
<p>Software running from the trusted area can also provide features that are not directly accessible from the non-trusted world, through special function calls that cross the secure/non-secure boundary.</p>
<p><a href="B18730_11.xhtml#_idTextAnchor403"><em class="italic">Chapter 11</em></a>, <em class="italic">Trusted Execution Environment</em>, explores the technology behind <strong class="bold">Trust Execution Environments</strong> (<strong class="bold">TEEs</strong>), as well as the software components involved in real embedded <a id="_idIndexMarker060"/>systems to provide a <a id="_idTextAnchor047"/>safe environment to run non-trusted modules and components.</p>
<h1 id="_idParaDest-37"><a id="_idTextAnchor048"/>The reference platform</h1>
<p>The preferred design <a id="_idIndexMarker061"/>strategy for embedded CPU cores is <strong class="bold">reduced instruction set computer</strong> (<strong class="bold">RISC</strong>). Among all the RISC CPU architectures, several reference <a id="_idIndexMarker062"/>designs are used as guidelines by silicon manufacturers to produce the core logic to integrate into the microcontroller. Each reference design differs from the others in several characteristics of the CPU implementation. Each reference design includes one or more families of microprocessors integrated into embedded systems, which share the following characteristics:</p>
<ul>
<li>Word size used <a id="_idIndexMarker063"/>for registers and addresses (8-bit, 16-bit, 32-bit, or 64-bit)</li>
<li>Instruction set</li>
<li>Register configurations</li>
<li>Endianness</li>
<li>Extended CPU features (interrupt controller, FPU, MMU)</li>
<li>Caching strategies</li>
<li>Pipeline design</li>
</ul>
<p>Choosing a reference platform for your embedded system depends on your project needs. Smaller, less feature-rich processors are generally more suited to low energy consumption, have a smaller MCU packaging, and are less expensive. Higher-end systems, on the other <a id="_idIndexMarker064"/>hand, come with a bigger set of resources and some of them have dedicated hardware to cope with challenging calculations (such as a floating-point unit, or an <strong class="bold">Advanced Encryption Standard</strong> (<strong class="bold">AES</strong>) hardware module to offload symmetric encryption operations). 8-bit and 16-bit core designs are slowly giving way to 32-bit architectures, but some successful designs remai<a id="_idTextAnchor049"/>n relatively popular in some niche markets and among hobbyists.</p>
<h2 id="_idParaDest-38"><a id="_idTextAnchor050"/>ARM reference design</h2>
<p>ARM is the most <a id="_idIndexMarker065"/>ubiquitous reference design supplier in the <a id="_idIndexMarker066"/>embedded market, with more than 10 billion ARM-based microcontrollers produced for embedded applications. One of the most interesting core designs in the embedded industry is the ARM Cortex-M family, which includes a range of models scaling from cost-effective and energy-efficient, to high-performance cores specifically designed for multimedia microcontrollers. Despite ranging among three different instruction sets (ARMv6, ARMv7, and ARMv8), all Cortex-M CPUs share the same programming interface, which improves portability across microcontrollers in the same families.</p>
<p>Most of the examples in this book will be based on this family of CPUs. Though most of the concepts expressed will apply to other core designs as well, picking a reference platform now opens the door to a more complete analysis of the interactions with the underlying hardware. In <a id="_idIndexMarker067"/>particular, some of the examples in this <a id="_idIndexMarker068"/>book use specific assembly instructions from the ARMv<a id="_idTextAnchor051"/>7 instruction set, which is implemented in some Cortex-M CPU cores.</p>
<h2 id="_idParaDest-39"><a id="_idTextAnchor052"/>The Cortex-M microprocessor</h2>
<p>The main characteristic of the 32-bit cores in the Cortex-M family are as follows:</p>
<ul>
<li>16 generic-purpose <a id="_idIndexMarker069"/>CPU registers</li>
<li>Thumb 16-bit <a id="_idIndexMarker070"/>only instructions for code density optimizations</li>
<li>A built-in <strong class="bold">Nested Vector Interrupt Controller</strong> (<strong class="bold">NVIC</strong>) with 8 to 16 priority levels</li>
<li>ARMv6-M (M0, M0+), ARMv7-M (M3, M4, M7), or ARMv8-M (M23, M33) architecture</li>
<li>Optional <a id="_idIndexMarker071"/>8-region <strong class="bold">memory protection </strong><strong class="bold">unit</strong> (<strong class="bold">MPU</strong>)</li>
<li>Optional TEE isolation mechanism (ARM TrustZone-M)</li>
</ul>
<p>The total memory <a id="_idIndexMarker072"/>address space is 4 GB. The beginning of the internal RAM is <a id="_idIndexMarker073"/>typically mapped at the fixed address of <code>0x20000000</code>. The mapping of the internal flash, as well as the other peripherals, depends on the silicon manufacturer. However, the highest 512 MB (<code>0xE0000000</code> to <code>0xFFFFFFFF</code>) addresses are reserved for the <strong class="bold">System Control Block</strong> (<strong class="bold">SCB</strong>), which groups together several configuration parameters and <a id="_idIndexMarker074"/>diagnostics that can be accessed by the software at any time to directly interact with the core.</p>
<p>Synchronous communication with peripherals and other hardware components can be triggered through interrupt lines. The processor can receive and recognize several different digital input signals and react to them promptly, interrupting the execution of the software and temporarily jumping to a specific location in the memory. Cortex-M supports up to 240 interrupt lines on the high-end cores of the family.</p>
<p>The interrupt vector, located at the beginning of the software image in flash, contains the addresses of the interrupt routines that will automatically execute on specific events. Thanks to the NVIC, interrupt lines can be assigned priorities so that when a higher-priority interrupt occurs while the routine for a lower interrupt is executed, the current interrupt routine is temporarily suspended to allow the higher-priority interrupt line to be serviced. This ensures minimal interrupt latency for these signal lines, which are somewhat critical for the system to execute as fast as possible.</p>
<p>At any time, the software on the target can run in two privilege modes: unprivileged or privileged. The CPU has built-in support for privilege separation between system and application software, even providing two different registers for the two separate stack pointers. In <a href="B18730_10.xhtml#_idTextAnchor357"><em class="italic">Chapter 10</em></a>, <em class="italic">Parallel Tasks and Scheduling</em>, we will examine how to properly implement privilege separation, as well as how to enforce memory separation when running untrusted code on the target, in more detail. This is, for example, used to hide secrets such as private keys from direct access from the non-secure world. In <a href="B18730_11.xhtml#_idTextAnchor403"><em class="italic">Chapter 11</em></a>, <em class="italic">Trusted Execution Environment</em>, we will learn how to properly implement privilege separation, as well as how to enforce memory separation within an OS when running application code on the target with a different level of trust.</p>
<p>A Cortex-M core is present in many microcontrollers, from different silicon vendors. Software tools are similar for all the platforms, but each MCU has a different configuration to take <a id="_idIndexMarker075"/>into account. Convergence libraries are available <a id="_idIndexMarker076"/>to hide manufacturer-specific details and improve portability across different models and brands. Manufacturers provide reference kits and all the documentation required to get started, which are intended to be used for evaluation during the design phase, and may also be useful for developing prototypes at a later stage. Some of these evaluation boards are equipped with sensors, multimedia electronics, or other peripherals that extend the functionality of the microcontroller. Some even include preconfigured, third-party “middleware” libraries such as TCP/IP communication stacks, TLS and cryptography <a id="_idIndexMarker077"/>libraries, simple filesystems and other accessory <a id="_idIndexMarker078"/>compon<a id="_idTextAnchor053"/>ents, and modules that can be quickly and easily added to a software project.</p>
<h1 id="_idParaDest-40"><a id="_idTextAnchor054"/>Summary</h1>
<p>When approaching embedded software requirements, before anything else, you must have a good understanding of the hardware platform and its components. By describing the architecture of modern microcontrollers, this chapter pointed out some of the peculiarities of embedded devices and how developers should efficiently rethink their approach to meeting requirements and solving problems, while at the same time taking into account the features and the limits of the target platform.</p>
<p>In the next chapter, we will analyze the tools and procedures typically used in embedded development, including command-line toolchains and <strong class="bold">integrated development environments</strong> (<strong class="bold">IDEs</strong>). We will understand how to organize the workflow and how to effectively prevent, locate, and fix bugs.</p>
</div>
</body></html>