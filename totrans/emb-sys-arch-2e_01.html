<html><head></head><body>
<div id="_idContainer009">
<h1 class="chapter-number" id="_idParaDest-16"><a id="_idTextAnchor015"/><span class="koboSpan" id="kobo.1.1">1</span></h1>
<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/><span class="koboSpan" id="kobo.2.1">Embedded Systems – A Pragmatic Approach</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Designing and writing software for embedded systems poses a different set of challenges than traditional high-level </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">software development.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">This chapter provides an overview of these challenges and introduces the basic components and the platform that will be used as a reference in </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">this book.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">In this chapter, we will discuss the </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">following topics:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.9.1">Domain definition</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.10.1">General-purpose </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.11.1">input/output</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.12.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.13.1">GPIO</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Interfaces </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">and peripherals</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.17.1">Connected systems</span></span></li>
<li><span class="koboSpan" id="kobo.18.1">Introduction to </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">isolation mechanisms</span></span></li>
<li><span class="koboSpan" id="kobo.20.1">The </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">reference platform</span></span></li>
</ul>
<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/><span class="koboSpan" id="kobo.22.1">Domain definition</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.23.1">Embedded systems</span></strong><span class="koboSpan" id="kobo.24.1"> are computing devices that perform specific, dedicated tasks with no direct or </span><a id="_idIndexMarker000"/><span class="koboSpan" id="kobo.25.1">continued user interaction. </span><span class="koboSpan" id="kobo.25.2">Due to the variety of markets and technologies, these objects have different shapes and sizes, but often, all have a small size and a limited amount </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">of resources.</span></span></p>
<p><span class="koboSpan" id="kobo.27.1">In this book, the concepts and the building blocks of embedded systems will be analyzed through the development of the software components that interact with their resources and peripherals. </span><span class="koboSpan" id="kobo.27.2">The first step is to define the scope for the validity of the techniques and the architectural patterns explained in this book, within the broader definition of </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">embedded systems.</span></span><a id="_idTextAnchor018"/></p>
<h2 id="_idParaDest-19"><a id="_idTextAnchor019"/><span class="koboSpan" id="kobo.29.1">Embedded Linux systems</span></h2>
<p><span class="koboSpan" id="kobo.30.1">One part of the </span><a id="_idIndexMarker001"/><span class="koboSpan" id="kobo.31.1">embedded market relies on devices with enough power and resources to run a variant of the GNU/Linux OS. </span><span class="koboSpan" id="kobo.31.2">These systems, often referred to as </span><strong class="bold"><span class="koboSpan" id="kobo.32.1">embedded Linux</span></strong><span class="koboSpan" id="kobo.33.1">, are outside the scope of this book, as their development includes different strategies of design and integration of the components. </span><span class="koboSpan" id="kobo.33.2">A typical hardware platform that is capable of running a system based on the Linux kernel is equipped with a reasonably large amount of RAM, up to a few gigabytes, and sufficient storage space on board to store all the software components provided in the </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">GNU/Linux distribution.</span></span></p>
<p><span class="koboSpan" id="kobo.35.1">Additionally, for the Linux memory management to provide separate virtual address spaces to each process on </span><a id="_idIndexMarker002"/><span class="koboSpan" id="kobo.36.1">the system, the hardware must be equipped with a </span><strong class="bold"><span class="koboSpan" id="kobo.37.1">memory management unit</span></strong><span class="koboSpan" id="kobo.38.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.39.1">MMU</span></strong><span class="koboSpan" id="kobo.40.1">), a hardware component that assists the OS in translating physical addresses into virtual addresses, and vice versa, </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">at runtime.</span></span></p>
<p><span class="koboSpan" id="kobo.42.1">This class of devices presents different characteristics that are often overkill for building tailored solutions, which can use a much simpler design and reduce the production costs of </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">single units.</span></span></p>
<p><span class="koboSpan" id="kobo.44.1">Hardware manufacturers and chip designers have researched new techniques to improve the performance of microcontroller-based systems. </span><span class="koboSpan" id="kobo.44.2">In the past few decades, they have introduced new generations of platforms that would cut hardware costs, firmware complexity, size, and power consumption to provide a set of features that are most interesting for the </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">embedded market.</span></span></p>
<p><span class="koboSpan" id="kobo.46.1">Due to their specifications, in some real-life scenarios, embedded systems must be able to execute a </span><a id="_idIndexMarker003"/><span class="koboSpan" id="kobo.47.1">series of tasks within a short, measurable, and predictable amount of time. </span><span class="koboSpan" id="kobo.47.2">These kinds of systems are called </span><strong class="bold"><span class="koboSpan" id="kobo.48.1">real-time systems</span></strong><span class="koboSpan" id="kobo.49.1"> and differ from the approach of multi-task computing, which is used in desktops, servers, and </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">mobile phones.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.51.1">Real-time processing</span></strong><span class="koboSpan" id="kobo.52.1"> is a goal that is </span><a id="_idIndexMarker004"/><span class="koboSpan" id="kobo.53.1">extremely hard, if not impossible, to reach on embedded Linux platforms. </span><span class="koboSpan" id="kobo.53.2">The Linux kernel is not designed for hard real-time processing, and </span><a id="_idIndexMarker005"/><span class="koboSpan" id="kobo.54.1">even if patches are available to modify the kernel scheduler to help meet these requirements, the results are not comparable to bare-metal, constrained systems that are designed with this purpose </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">in mind.</span></span></p>
<p><span class="koboSpan" id="kobo.56.1">Some other application domains, such as battery-powered and energy-harvesting devices, can benefit from the low power consumption capabilities of smaller embedded devices and the energy efficiency of the wireless communication technologies often integrated into embedded connected devices. </span><span class="koboSpan" id="kobo.56.2">The higher amount of resources and the increased hardware complexity of Linux-based systems often do not scale down enough on energy levels or require effort to meet similar figures in </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">power consumption.</span></span></p>
<p><span class="koboSpan" id="kobo.58.1">The type of microcontroller-based systems that we will analyze in this book is 32-bit systems, which are capable of running software in a single-threaded, bare-metal application, as well as </span><a id="_idIndexMarker006"/><span class="koboSpan" id="kobo.59.1">integrating minimalist real-time OSs, which are very popular in the industrial manufacturing of embedded systems, which we use daily to accomplish specific tasks. </span><span class="koboSpan" id="kobo.59.2">They are becoming more and more adopted to help define more generic, multiple-purpose </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">development plat</span><a id="_idTextAnchor020"/><span class="koboSpan" id="kobo.61.1">forms.</span></span></p>
<h2 id="_idParaDest-20"><a id="_idTextAnchor021"/><span class="koboSpan" id="kobo.62.1">Low-end 8-bit microcontrollers</span></h2>
<p><span class="koboSpan" id="kobo.63.1">In the past, </span><strong class="bold"><span class="koboSpan" id="kobo.64.1">8-bit microcontrollers</span></strong><span class="koboSpan" id="kobo.65.1"> dominated the embedded market. </span><span class="koboSpan" id="kobo.65.2">The simplicity of their design allows </span><a id="_idIndexMarker007"/><span class="koboSpan" id="kobo.66.1">us to write small applications that can </span><a id="_idIndexMarker008"/><span class="koboSpan" id="kobo.67.1">accomplish a set of predefined tasks but are too simple and usually equipped with too few resources to implement an embedded system, especially since 32-bit microcontrollers have evolved to cover all the use cases for these devices within the same range of price, size, and </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">power consumption.</span></span></p>
<p><span class="koboSpan" id="kobo.69.1">Nowadays, 8-bit microcontrollers are mostly relegated to the market of educational platform kits, aimed at introducing hobbyists and newcomers to the basics of software development on electronic devices. </span><span class="koboSpan" id="kobo.69.2">8-bit platforms are not covered in this book because they lack the characteristics that allow advanced system programming, multithreading, and advanced features to be developed to build professional </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">embedded systems.</span></span></p>
<p><span class="koboSpan" id="kobo.71.1">In the context of this book, the term </span><strong class="bold"><span class="koboSpan" id="kobo.72.1">embedded systems</span></strong><span class="koboSpan" id="kobo.73.1"> is used to indicate a class of systems running on </span><a id="_idIndexMarker009"/><span class="koboSpan" id="kobo.74.1">microcontroller-based hardware architecture, offering constrained resources but allowing real-time systems to be built through features provided by the hardware architecture to implement </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">system pro</span><a id="_idTextAnchor022"/><span class="koboSpan" id="kobo.76.1">gramming.</span></span></p>
<h2 id="_idParaDest-21"><a id="_idTextAnchor023"/><span class="koboSpan" id="kobo.77.1">Hardware architecture</span></h2>
<p><span class="koboSpan" id="kobo.78.1">The architecture of an embedded system is centered around its microcontroller, also sometimes referred to as the </span><strong class="bold"><span class="koboSpan" id="kobo.79.1">microcontroller unit</span></strong><span class="koboSpan" id="kobo.80.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.81.1">MCU</span></strong><span class="koboSpan" id="kobo.82.1">). </span><span class="koboSpan" id="kobo.82.2">This is typically a single integrated circuit </span><a id="_idIndexMarker010"/><span class="koboSpan" id="kobo.83.1">containing the processor, RAM, flash </span><a id="_idIndexMarker011"/><span class="koboSpan" id="kobo.84.1">memory, serial receivers and transmitters, and other core components. </span><span class="koboSpan" id="kobo.84.2">The market offers many different choices among architectures, vendors, price ranges, features, and integrated resources. </span><span class="koboSpan" id="kobo.84.3">These are typically designed to </span><a id="_idIndexMarker012"/><span class="koboSpan" id="kobo.85.1">be inexpensive, low-resource, low-energy consuming, self-contained systems on a single integrated circuit, which is the reason why they are often referred to as </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.86.1">System-on-Chip</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.87.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.88.1">SoC</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.90.1">Due to the variety of processors, memories, and interfaces that can be integrated, there is no actual reference architecture for microcontrollers. </span><span class="koboSpan" id="kobo.90.2">Nevertheless, some architectural elements are common across a wide range of models and brands, and even across different </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">processor architectures.</span></span></p>
<p><span class="koboSpan" id="kobo.92.1">Some microcontrollers are dedicated to specific applications and expose a particular set of interfaces to communicate to peripherals and the outside world. </span><span class="koboSpan" id="kobo.92.2">Others are focused on providing solutions with reduced hardware costs, or with very limited </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">energy consumption.</span></span></p>
<p><span class="koboSpan" id="kobo.94.1">Nevertheless, the </span><a id="_idIndexMarker013"/><span class="koboSpan" id="kobo.95.1">following set of components is hardcoded into almost </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">every microcontroller:</span></span></p>
<ul>
<li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.97.1">Microprocessor</span></strong></span></li>
<li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.98.1">RAM</span></strong></span></li>
<li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.99.1">Flash memory</span></strong></span></li>
<li><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.100.1">Serial transceivers</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.101.1">Additionally, more and more devices are capable of accessing a network, to communicate with other devices and gateways. </span><span class="koboSpan" id="kobo.101.2">Some microcontrollers may provide either well-established standards, such as </span><em class="italic"><span class="koboSpan" id="kobo.102.1">Ethernet or Wi-Fi interfaces</span></em><span class="koboSpan" id="kobo.103.1">, or specific protocols specifically </span><a id="_idIndexMarker014"/><span class="koboSpan" id="kobo.104.1">designed to meet the constraints of embedded systems, such as sub-GHz radio interfaces or a </span><strong class="bold"><span class="koboSpan" id="kobo.105.1">Controller Area Network</span></strong><span class="koboSpan" id="kobo.106.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.107.1">CAN</span></strong><span class="koboSpan" id="kobo.108.1">) bus, being partially or fully implemented within </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">the IC.</span></span></p>
<p><span class="koboSpan" id="kobo.110.1">All the components must share a bus line with the processor, which is responsible for coordinating the logic. </span><span class="koboSpan" id="kobo.110.2">The RAM, flash memory, and control registers of the transceivers are all mapped in the same physical </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">address space:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer008">
<span class="koboSpan" id="kobo.112.1"><img alt="Figure 1.1 – A simplified block diagram of the components inside a generic microcontroller" src="image/B18730_01_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.113.1">Figure 1.1 – A simplified block diagram of the components inside a generic microcontroller</span></p>
<p><span class="koboSpan" id="kobo.114.1">The addresses </span><a id="_idIndexMarker015"/><span class="koboSpan" id="kobo.115.1">where </span><strong class="bold"><span class="koboSpan" id="kobo.116.1">RAM</span></strong><span class="koboSpan" id="kobo.117.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.118.1">Flash Memory</span></strong><span class="koboSpan" id="kobo.119.1"> are mapped depend on the specific model and are usually provided in the datasheet. </span><span class="koboSpan" id="kobo.119.2">A microcontroller can run code in its native machine language; that is, a </span><a id="_idIndexMarker016"/><span class="koboSpan" id="kobo.120.1">sequence of instructions conveyed into a binary file that is specific to the architecture it is running on. </span><span class="koboSpan" id="kobo.120.2">By default, compilers provide a generic executable file as the output of the compilation and assembly operations, which needs to be converted into a format that can be executed by </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">the target.</span></span></p>
<p><span class="koboSpan" id="kobo.122.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.123.1">Processor</span></strong><span class="koboSpan" id="kobo.124.1"> part is designed to execute the instructions that have been stored in its own specific binary format directly from RAM as well as from its internal flash memory. </span><span class="koboSpan" id="kobo.124.2">This is usually mapped starting from position zero in memory or another well-known address specified in the microcontroller manual. </span><span class="koboSpan" id="kobo.124.3">The CPU can fetch and execute code from RAM faster, but the final firmware is stored in the flash memory, which is usually bigger than the RAM on almost all microcontrollers and permits it to retain the data across power cycles </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">and reboots.</span></span></p>
<p><span class="koboSpan" id="kobo.126.1">Compiling a software operating environment for an embedded microcontroller and loading it onto the flash memory requires a host machine, which is a specific set of hardware and software tools. </span><span class="koboSpan" id="kobo.126.2">Some knowledge about the target device’s characteristics is also needed to instruct </span><a id="_idIndexMarker017"/><span class="koboSpan" id="kobo.127.1">the compiler to organize the symbols within the executable image. </span><span class="koboSpan" id="kobo.127.2">For many valid reasons, C is the most popular language in embedded software, although not the only available option. </span><span class="koboSpan" id="kobo.127.3">Higher-level languages, such as Rust and C++, can produce embedded code when combined with a specific embedded runtime, or even in some cases by entirely removing the runtime support from </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">the language.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.129.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.130.1">This book will focus entirely on C code because it abstracts less than any other high-level language, thus making it easier to describe the behavior of the underlying hardware while looking at </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">the code.</span></span></p>
<p><span class="koboSpan" id="kobo.132.1">All modern embedded systems platforms also have at least one mechanism (such as </span><strong class="bold"><span class="koboSpan" id="kobo.133.1">JTAG</span></strong><span class="koboSpan" id="kobo.134.1">) for debugging purposes and uploading the software to the flash. </span><span class="koboSpan" id="kobo.134.2">When the debugging interface is accessed from the host machine, a debugger can interact with the breakpoint unit in the processor, interrupting and resuming the execution, and can also read and write from any address </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">in memory.</span></span></p>
<p><span class="koboSpan" id="kobo.136.1">A significant part of embedded programming is communicating the peripherals while using the interfaces that the MCU exposes. </span><span class="koboSpan" id="kobo.136.2">Embedded software development requires basic knowledge of electronics, the ability to understand schematics and datasheets, and confidence with the measurement tools, such as logic analyzers </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">o</span><a id="_idTextAnchor024"/><span class="koboSpan" id="kobo.138.1">r oscilloscopes.</span></span></p>
<h2 id="_idParaDest-22"><a id="_idTextAnchor025"/><span class="koboSpan" id="kobo.139.1">Understanding the challenges</span></h2>
<p><span class="koboSpan" id="kobo.140.1">Approaching embedded </span><a id="_idIndexMarker018"/><span class="koboSpan" id="kobo.141.1">development means keeping the focus on the specifications as well as the hardware restrictions at all times. </span><span class="koboSpan" id="kobo.141.2">Embedded software development is a constant challenge that requires focusing on the most efficient way to perform a set of specific tasks but keeping the limited resources available in strong consideration. </span><span class="koboSpan" id="kobo.141.3">There are several compromises to deal with, which are uncommon in other environments. </span><span class="koboSpan" id="kobo.141.4">Here are </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">some examples:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.143.1">There might be not enough space in the flash to implement a </span><span class="No-Break"><span class="koboSpan" id="kobo.144.1">new feature</span></span></li>
<li><span class="koboSpan" id="kobo.145.1">There might not be enough RAM to store complex structures or make copies of large </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">data buffers</span></span></li>
<li><span class="koboSpan" id="kobo.147.1">The processor might be not fast enough to accomplish all the required calculations and data processing in </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">due time</span></span></li>
<li><span class="koboSpan" id="kobo.149.1">Battery-powered and resource-harvesting devices might require lower energy consumption to meet </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">lifetime expectations</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.151.1">Moreover, PC and mobile OSs make large use of the MMU, a component of the processor that allows runtime translations between physical and </span><span class="No-Break"><span class="koboSpan" id="kobo.152.1">virtual addresses.</span></span></p>
<p><span class="koboSpan" id="kobo.153.1">The MMU is a necessary abstraction to implement address space separation among the tasks, as well as between </span><a id="_idIndexMarker019"/><span class="koboSpan" id="kobo.154.1">the tasks and the kernel itself. </span><span class="koboSpan" id="kobo.154.2">Embedded microcontrollers do not have an MMU, and usually lack the amount of non-volatile memory required to store kernels, applications, and libraries. </span><span class="koboSpan" id="kobo.154.3">For this reason, embedded systems are often running in a single task, with the main loop performing all the data processing and communication in a specific order. </span><span class="koboSpan" id="kobo.154.4">Some devices can run embedded OSs, which are far less complex than their </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">PC counterparts.</span></span></p>
<p><span class="koboSpan" id="kobo.156.1">Application developers often see the underlying system as a commodity, while embedded development often means that the entire system has to be implemented from scratch, from the boot procedure up to the application logic. </span><span class="koboSpan" id="kobo.156.2">In an embedded environment, the various software components are more closely related to each other because of the lack of more complex abstractions, such as memory separations between the processes and the </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">OS kernel.</span></span></p>
<p><span class="koboSpan" id="kobo.158.1">A developer approaching embedded systems for the first time might find testing and debugging on some of the systems a bit more intricate than just running the software and reading out the results. </span><span class="koboSpan" id="kobo.158.2">This becomes especially true in those systems that have been designed with little or no human </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">interaction interfaces.</span></span></p>
<p><span class="koboSpan" id="kobo.160.1">A successful approach requires a healthy workflow, which includes well-defined test cases, a list of key performance indicators coming from the analysis of the specifications to identify possibilities of trade-offs, several tools and procedures at hand to perform all the needed measurements, and a well-established and efficient </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">prototyping phase.</span></span></p>
<p><span class="koboSpan" id="kobo.162.1">In this context, security deserves some special consideration. </span><span class="koboSpan" id="kobo.162.2">As usual, when writing code at the system level, it is </span><a id="_idIndexMarker020"/><span class="koboSpan" id="kobo.163.1">wise to keep in mind the system-wide consequences of possible faults. </span><span class="koboSpan" id="kobo.163.2">Most embedded application code runs with extended privileges on the hardware, and a single task misbehaving can affect the stability and integrity of the entire firmware. </span><span class="koboSpan" id="kobo.163.3">As we will see, some platforms offer specific memory protection mechanisms and built-in privilege separation, which are useful for building fail-safe systems, even in the absence of a full OS based on separating proc</span><a id="_idTextAnchor026"/><span class="koboSpan" id="kobo.164.1">ess </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">address spaces.</span></span></p>
<h2 id="_idParaDest-23"><a id="_idTextAnchor027"/><span class="koboSpan" id="kobo.166.1">Multithreading</span></h2>
<p><span class="koboSpan" id="kobo.167.1">One of the advantages of using microcontrollers designed to build embedded systems is the possibility to run </span><a id="_idIndexMarker021"/><span class="koboSpan" id="kobo.168.1">logically separated tasks within separate execution units by time-sharing </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">the resources.</span></span></p>
<p><span class="koboSpan" id="kobo.170.1">The most popular type of design for embedded software is based on a single loop-based sequential execution model, where modules and components are connected to expose callback interfaces. </span><span class="koboSpan" id="kobo.170.2">However, modern microcontrollers offer features and core logic characteristics that can be used by system developers to build a multitasking environment to run logically </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">separated applications.</span></span></p>
<p><span class="koboSpan" id="kobo.172.1">These features are particularly handy in the approach to more complex real-time systems, and they help us understand the possibilities of the implementation of safety models based on process isolation and </span><a id="_idTextAnchor028"/><span class="No-Break"><span class="koboSpan" id="kobo.173.1">memory segmentation.</span></span></p>
<h1 id="_idParaDest-24"><a id="_idTextAnchor029"/><span class="koboSpan" id="kobo.174.1">RAM</span></h1>
<p><em class="italic"><span class="koboSpan" id="kobo.175.1">“640 KB of memory ought to be enough </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.176.1">for everyone”</span></em></span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.177.1">– Bill Gates (founder and former director </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.178.1">of Microsoft)</span></em></span></p>
<p><span class="koboSpan" id="kobo.179.1">This famous statement has </span><a id="_idIndexMarker022"/><span class="koboSpan" id="kobo.180.1">been cited many times in the past three decades to underline the progress in technology and the outstanding achievements of the PC industry. </span><span class="koboSpan" id="kobo.180.2">While it may sound like a joke for many software engineers out there, it is still in these figures that embedded programming has to be thought about, more than 30 years after MS-DOS was </span><span class="No-Break"><span class="koboSpan" id="kobo.181.1">initially released.</span></span></p>
<p><span class="koboSpan" id="kobo.182.1">Although most embedded systems are capable of breaking that limit today, especially due to the availability of external DRAM interfaces, the simplest devices that can be programmed in C may have as little as 4 KB of RAM available to implement the entire system logic. </span><span class="koboSpan" id="kobo.182.2">This has to be taken into account when designing an embedded system, by estimating the amount of memory potentially needed for all the operations that the system has to perform, and the buffers that may be used at any time to communicate with peripherals and </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">nearby devices.</span></span></p>
<p><span class="koboSpan" id="kobo.184.1">The memory model at the system level is simpler than that of PCs and mobile devices. </span><span class="koboSpan" id="kobo.184.2">Memory access is typically done at the physical level, so all the pointers in your code are telling you the physical location of the data they are pointing to. </span><span class="koboSpan" id="kobo.184.3">In modern computers, the OS is responsible for translating physical addresses into a virtual representation of the </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">running tasks.</span></span></p>
<p><span class="koboSpan" id="kobo.186.1">The advantage of the physical-only memory access on those systems that do not have an MMU is the reduced complexity of having to deal with address translations while coding and debugging. </span><span class="koboSpan" id="kobo.186.2">On the other hand, some of the features that are implemented by any modern OS, such as process swapping and dynamically resizing address spaces through memory relocation, become cumbersome and </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">sometimes impossible.</span></span></p>
<p><span class="koboSpan" id="kobo.188.1">Handling memory is particularly important in embedded systems. </span><span class="koboSpan" id="kobo.188.2">Programmers who are used to writing application code expect a certain level of protection to be provided by the underlying OS. </span><span class="koboSpan" id="kobo.188.3">A virtual address space does not allow memory areas to overlap, and the OS can easily detect </span><a id="_idIndexMarker023"/><span class="koboSpan" id="kobo.189.1">unauthorized memory accesses and segmentation violations, so it promptly terminates the process and avoids having the whole </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">system compromised.</span></span></p>
<p><span class="koboSpan" id="kobo.191.1">On embedded systems, especially when writing bare-metal code, the boundaries of each address pool must be checked manually. </span><span class="koboSpan" id="kobo.191.2">Accidentally modifying a few bits in the wrong memory, or even accessing a different area of memory, may result in a fatal, irrevocable error. </span><span class="koboSpan" id="kobo.191.3">The entire system may hang, or, in the worst case, become unpredictable. </span><span class="koboSpan" id="kobo.191.4">A safe approach is required when handling memory in embedded systems, in particular when dealing with life-critical devices. </span><span class="koboSpan" id="kobo.191.5">Identifying memory errors too late in the development process is complex and often requires more resources than forcing yourself to write safe code and protecting the system from a </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">programmer’s mistakes.</span></span></p>
<p><span class="koboSpan" id="kobo.193.1">Proper memory-handling </span><a id="_idIndexMarker024"/><span class="koboSpan" id="kobo.194.1">techniques will be explained in </span><a href="B18730_05.xhtml#_idTextAnchor149"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.195.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.196.1">, </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.197.1">Memory Management</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">.</span></span></p>
<h1 id="_idParaDest-25"><a id="_idTextAnchor030"/><span class="koboSpan" id="kobo.199.1">Flash memory</span></h1>
<p><span class="koboSpan" id="kobo.200.1">In a server or a personal computer, the executable applications and libraries reside in storage devices. </span><span class="koboSpan" id="kobo.200.2">At </span><a id="_idIndexMarker025"/><span class="koboSpan" id="kobo.201.1">the beginning of the execution, they are accessed, transformed, possibly uncompressed, and stored in RAM before the </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">execution starts.</span></span></p>
<p><span class="koboSpan" id="kobo.203.1">The firmware of an embedded device is, in general, one single binary file containing all the software components, which can be transferred to the internal flash memory of the MCU. </span><span class="koboSpan" id="kobo.203.2">Since the flash memory is directly mapped to a fixed address in the memory space, the processor is </span><a id="_idIndexMarker026"/><span class="koboSpan" id="kobo.204.1">capable of sequentially fetching and executing single instructions from it with no intermediate steps. </span><span class="koboSpan" id="kobo.204.2">This mechanism is called </span><strong class="bold"><span class="koboSpan" id="kobo.205.1">execute in </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.206.1">place</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.207.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.208.1">XIP</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.210.1">All non-modifiable sections on the firmware do not need to be loaded in memory and are accessible through direct addressing in the memory space. </span><span class="koboSpan" id="kobo.210.2">This includes not only the executable instructions but also all the variables that are marked as constant by the compiler. </span><span class="koboSpan" id="kobo.210.3">On the other hand, supporting XIP requires a few extra steps when preparing the firmware image to be stored in flash, and the linker needs to be instructed about the different memory-mapped areas on </span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">the target.</span></span></p>
<p><span class="koboSpan" id="kobo.212.1">The internal flash memory that is mapped in the address space of the microcontroller is not accessible for writing. </span><span class="koboSpan" id="kobo.212.2">Altering the content of the internal flash can be done only by using block-based access, due to the hardware characteristics of flash memory devices. </span><span class="koboSpan" id="kobo.212.3">Before changing the value of a single byte in flash memory, the whole block containing it must be erased </span><a id="_idIndexMarker027"/><span class="koboSpan" id="kobo.213.1">and rewritten. </span><span class="koboSpan" id="kobo.213.2">The mechanism offered by most manufacturers to access block-based flash memory for writing is known as </span><strong class="bold"><span class="koboSpan" id="kobo.214.1">In-Application Programming</span></strong><span class="koboSpan" id="kobo.215.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.216.1">IAP</span></strong><span class="koboSpan" id="kobo.217.1">). </span><span class="koboSpan" id="kobo.217.2">Some filesystem implementations take care of abstracting write operations on a block-based flash device, by creating a temporary copy of the block where the write operation </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">is performed.</span></span></p>
<p><span class="koboSpan" id="kobo.219.1">While selecting the components for a microcontroller-based solution, it is vital to match the size of the flash memory to the space required by the firmware. </span><span class="koboSpan" id="kobo.219.2">The flash is often one of the most expensive components in the MCU, so for deployment on a large scale, choosing an MCU with a smaller flash could be more cost-effective. </span><span class="koboSpan" id="kobo.219.3">Developing software with code size in mind is not very usual nowadays within other domains, but it may be required when trying to fit multiple features in such little storage. </span><span class="koboSpan" id="kobo.219.4">Finally, compiler optimizations may exist on specific architectures to reduce code size when building the firmware and linking </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">its components.</span></span></p>
<p><span class="koboSpan" id="kobo.221.1">Additional non-volatile memories that reside outside of the MCU silicon can typically be accessed using specific interfaces, such as the </span><strong class="bold"><span class="koboSpan" id="kobo.222.1">Serial Peripheral Interface</span></strong><span class="koboSpan" id="kobo.223.1">. </span><span class="koboSpan" id="kobo.223.2">External flash memories use different </span><a id="_idIndexMarker028"/><span class="koboSpan" id="kobo.224.1">technologies than internal flash, which is designed to be fast and execute code in place. </span><span class="koboSpan" id="kobo.224.2">While being generally more dense and less expensive, external flash memories do not allow direct memory mapping in the physical address space, which makes them </span><a id="_idIndexMarker029"/><span class="koboSpan" id="kobo.225.1">unsuitable for storing firmware images. </span><span class="koboSpan" id="kobo.225.2">This is because it would be impossible to execute the code fetching the instructions sequentially unless a mechanism is used to load the executable symbols in RAM – read access on these kinds of devices is performed one block at a time. </span><span class="koboSpan" id="kobo.225.3">On the other hand, write access may be faster compared to IAP, making these kinds of non-volatile memory devices ideal for storing data that is retrieved at runtime in </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">some designs.</span></span></p>
<h1 id="_idParaDest-26"><a id="_idTextAnchor031"/><span class="koboSpan" id="kobo.227.1">General-purpose input/output (GPIO)</span></h1>
<p><span class="koboSpan" id="kobo.228.1">The most basic functionality that can be achieved with any microcontroller is the possibility to </span><a id="_idIndexMarker030"/><span class="koboSpan" id="kobo.229.1">control signals on specific pins of the integrated circuit. </span><span class="koboSpan" id="kobo.229.2">The microcontroller can turn a digital output on or off, which corresponds to a reference voltage to be applied to the pin when the value assigned to it is 1, and zero volts when the value is 0. </span><span class="koboSpan" id="kobo.229.3">In the same way, a pin can be used to detect a 1 or a 0 when the pin is configured as input. </span><span class="koboSpan" id="kobo.229.4">The software will read the digital value “1” when the voltage applied to it is higher than a </span><span class="No-Break"><span class="koboSpan" id="kobo.230.1">certain threshold.</span></span></p>
<h2 id="_idParaDest-27"><a id="_idTextAnchor032"/><span class="koboSpan" id="kobo.231.1">ADC and DAC</span></h2>
<p><span class="koboSpan" id="kobo.232.1">Some chips have onboard ADC controllers, which are capable of sensing the voltage that is applied to the </span><a id="_idIndexMarker031"/><span class="koboSpan" id="kobo.233.1">pin and sampling it. </span><span class="koboSpan" id="kobo.233.2">This is often </span><a id="_idIndexMarker032"/><span class="koboSpan" id="kobo.234.1">used to acquire measurements from input peripherals providing a variable voltage as output. </span><span class="koboSpan" id="kobo.234.2">The embedded software will be able to read the voltage, with an accuracy that depends on the </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">predefined range.</span></span></p>
<p><span class="koboSpan" id="kobo.236.1">A DAC controller is the inverse </span><a id="_idIndexMarker033"/><span class="koboSpan" id="kobo.237.1">of an ADC controller, transforming </span><a id="_idIndexMarker034"/><span class="koboSpan" id="kobo.238.1">a value on a microcontroller register into the </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">corresponding voltage.</span></span></p>
<h2 id="_idParaDest-28"><a id="_idTextAnchor033"/><span class="koboSpan" id="kobo.240.1">Timers and PWM</span></h2>
<p><span class="koboSpan" id="kobo.241.1">Microcontrollers may </span><a id="_idIndexMarker035"/><span class="koboSpan" id="kobo.242.1">offer diverse ways to measure time. </span><span class="koboSpan" id="kobo.242.2">Often, there is at least one interface based on a countdown timer that can trigger an interrupt and automatically reset </span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">upon expiry.</span></span></p>
<p><span class="koboSpan" id="kobo.244.1">GPIO pins configured as </span><a id="_idIndexMarker036"/><span class="koboSpan" id="kobo.245.1">output can be programmed to output </span><a id="_idIndexMarker037"/><span class="koboSpan" id="kobo.246.1">a square wave with a preconfigured frequency and duty cycle. </span><span class="koboSpan" id="kobo.246.2">This is called </span><strong class="bold"><span class="koboSpan" id="kobo.247.1">pulse-wave modulation</span></strong><span class="koboSpan" id="kobo.248.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.249.1">PWM</span></strong><span class="koboSpan" id="kobo.250.1">) and has several uses, from controlling output peripherals to dimming an LED or even playing an audible sound through </span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">a speaker.</span></span></p>
<p><span class="koboSpan" id="kobo.252.1">More details about GPIO, interrupt timers, and watchdogs will be explored in </span><a href="B18730_06.xhtml#_idTextAnchor194"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.253.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.254.1">, </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.255.1">General-Purpose Peripherals</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">.</span></span></p>
<h1 id="_idParaDest-29"><a id="_idTextAnchor034"/><span class="koboSpan" id="kobo.257.1">Interfaces and peripherals</span></h1>
<p><span class="koboSpan" id="kobo.258.1">To communicate with </span><a id="_idIndexMarker038"/><span class="koboSpan" id="kobo.259.1">peripherals and other microcontrollers, several </span><em class="italic"><span class="koboSpan" id="kobo.260.1">de facto</span></em><span class="koboSpan" id="kobo.261.1"> standards are well </span><a id="_idIndexMarker039"/><span class="koboSpan" id="kobo.262.1">established in the embedded world. </span><span class="koboSpan" id="kobo.262.2">Some of the external pins of the microcontroller can be programmed to carry out communication with external peripherals using specific protocols. </span><span class="koboSpan" id="kobo.262.3">A few of the common interfaces available on most architectures are </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.264.1">Asynchronous UART-based </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">serial communication</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.266.1">Serial Peripheral Interface</span></strong><span class="koboSpan" id="kobo.267.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.268.1">SPI</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">) bus</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.270.1">Inter-integrated circuit</span></strong><span class="koboSpan" id="kobo.271.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.272.1">I</span></strong></span><span class="No-Break"><span class="superscript"><span class="koboSpan" id="kobo.273.1">2</span></span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.274.1">C</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">) bus</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.276.1">Universal Serial </span><a id="_idTextAnchor035"/></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.277.1">Bus</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.278.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.279.1">USB</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.281.1">Let’s review each </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">in detail.</span></span></p>
<h2 id="_idParaDest-30"><a id="_idTextAnchor036"/><span class="koboSpan" id="kobo.283.1">Asynchronous UART-based serial communication</span></h2>
<p><span class="koboSpan" id="kobo.284.1">Asynchronous </span><a id="_idIndexMarker040"/><span class="koboSpan" id="kobo.285.1">communication is </span><a id="_idIndexMarker041"/><span class="koboSpan" id="kobo.286.1">provided by the </span><strong class="bold"><span class="koboSpan" id="kobo.287.1">Universal Asynchronous Receiver-Transmitter</span></strong><span class="koboSpan" id="kobo.288.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.289.1">UART</span></strong><span class="koboSpan" id="kobo.290.1">). </span><span class="koboSpan" id="kobo.290.2">These kinds of interfaces, commonly known as </span><strong class="bold"><span class="koboSpan" id="kobo.291.1">serial ports</span></strong><span class="koboSpan" id="kobo.292.1">, are called asynchronous because they do not need to share a clock signal to synchronize the sender and the receiver, but rather work on predefined clock rates that can be aligned while the communication is ongoing. </span><span class="koboSpan" id="kobo.292.2">Microcontrollers may contain multiple UARTs that can be attached to a specific set of pins upon request. </span><span class="koboSpan" id="kobo.292.3">Asynchronous communication is provided by UART as a full-duplex channel, through two independent wires, connecting the RX pin of each endpoint to the TX pin on the </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">opposite side.</span></span></p>
<p><span class="koboSpan" id="kobo.294.1">To understand each other, the systems at the two endpoints must set up the UART using the same </span><a id="_idIndexMarker042"/><span class="koboSpan" id="kobo.295.1">parameters. </span><span class="koboSpan" id="kobo.295.2">This includes the framing of the bytes on the wire and the frame rate. </span><span class="koboSpan" id="kobo.295.3">All of these parameters have to be known in advance by both endpoints to correctly establish a communication channel. </span><span class="koboSpan" id="kobo.295.4">Despite being simpler than the other types of serial communication, UART-based serial communication is still widely used in electronic devices, particularly as an interface for modems and GPS receivers. </span><span class="koboSpan" id="kobo.295.5">Furthermore, using TTL-to-USB serial converters, it is easy to connect a UART to a console on the host machine, which i</span><a id="_idTextAnchor037"/><span class="koboSpan" id="kobo.296.1">s often handy for providing </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">log messages.</span></span></p>
<h2 id="_idParaDest-31"><a id="_idTextAnchor038"/><span class="koboSpan" id="kobo.298.1">SPI</span></h2>
<p><span class="koboSpan" id="kobo.299.1">A different approach to classic UAR—based communication is </span><strong class="bold"><span class="koboSpan" id="kobo.300.1">SPI</span></strong><span class="koboSpan" id="kobo.301.1">. </span><span class="koboSpan" id="kobo.301.2">Introduced in the late 1980s, this </span><a id="_idIndexMarker043"/><span class="koboSpan" id="kobo.302.1">technology aimed to replace asynchronous serial communication toward peripherals by introducing </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">several improvements:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.304.1">Serial clock line to synchronize </span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">the endpoints</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.306.1">Master-slave protocol</span></span></li>
<li><span class="koboSpan" id="kobo.307.1">One-to-many communication over the same </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">three-wire bus</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.309.1">The master device, usually the microcontroller, shares the bus with one or more slaves. </span><span class="koboSpan" id="kobo.309.2">To trigger the communication, a separate </span><strong class="bold"><span class="koboSpan" id="kobo.310.1">slave select</span></strong><span class="koboSpan" id="kobo.311.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.312.1">SS</span></strong><span class="koboSpan" id="kobo.313.1">) signal is used to address each slave connected </span><a id="_idIndexMarker044"/><span class="koboSpan" id="kobo.314.1">to the bus. </span><span class="koboSpan" id="kobo.314.2">The bus uses two independent signals for data transfer, one per direction, and a shared clock line that synchronizes the two ends of the communication. </span><span class="koboSpan" id="kobo.314.3">Due to the clock line being generated by the master, the data transfer is more reliable, making it possible to achieve higher bitrates than ordinary UART. </span><span class="koboSpan" id="kobo.314.4">One of the keys to the continued success of SPI over multiple generations of microcontrollers is the low complexity required for the design of slaves, which can be as simple as a single shift register. </span><span class="koboSpan" id="kobo.314.5">SPI is commonly used in sensor devices, LCDs, flash </span><a id="_idTextAnchor039"/><a id="_idIndexMarker045"/><span class="koboSpan" id="kobo.315.1">memory controllers, and </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">network interfaces.</span></span></p>
<h2 id="_idParaDest-32"><a id="_idTextAnchor040"/><span class="koboSpan" id="kobo.317.1">I</span><span class="superscript"><span class="koboSpan" id="kobo.318.1">2</span></span><span class="koboSpan" id="kobo.319.1">C</span></h2>
<p><span class="koboSpan" id="kobo.320.1">I</span><span class="superscript"><span class="koboSpan" id="kobo.321.1">2</span></span><span class="koboSpan" id="kobo.322.1">C is slightly more complex, and </span><a id="_idIndexMarker046"/><span class="koboSpan" id="kobo.323.1">that is because it is designed with a different purpose in mind: </span><em class="italic"><span class="koboSpan" id="kobo.324.1">interconnecting multiple microcontrollers</span></em><span class="koboSpan" id="kobo.325.1">, as well as multiple slave devices, on the </span><a id="_idIndexMarker047"/><span class="koboSpan" id="kobo.326.1">same two-wire bus. </span><span class="koboSpan" id="kobo.326.2">The two signals are </span><strong class="bold"><span class="koboSpan" id="kobo.327.1">serial clock</span></strong><span class="koboSpan" id="kobo.328.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.329.1">SCL</span></strong><span class="koboSpan" id="kobo.330.1">) and </span><strong class="bold"><span class="koboSpan" id="kobo.331.1">serial data</span></strong><span class="koboSpan" id="kobo.332.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.333.1">SDA</span></strong><span class="koboSpan" id="kobo.334.1">). </span><span class="koboSpan" id="kobo.334.2">Unlike SPI or UART, the bus is half-duplex, as the two directions of the flow share the </span><a id="_idIndexMarker048"/><span class="koboSpan" id="kobo.335.1">same signal. </span><span class="koboSpan" id="kobo.335.2">Thanks to a 7-bit slave-addressing mechanism incorporated in the protocol, it does not require additional signals dedicated to selecting the slaves. </span><span class="koboSpan" id="kobo.335.3">Multiple masters are allowed on the same line, given that all the masters in the system follow the a</span><a id="_idTextAnchor041"/><span class="koboSpan" id="kobo.336.1">rbitration logic in the case of </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">bus contention.</span></span></p>
<h2 id="_idParaDest-33"><a id="_idTextAnchor042"/><span class="koboSpan" id="kobo.338.1">USB</span></h2>
<p><span class="koboSpan" id="kobo.339.1">The USB protocol, originally </span><a id="_idIndexMarker049"/><span class="koboSpan" id="kobo.340.1">designed to replace UART and include many protocols in the same hardware connector, is very popular in personal computers, portable devices, and a huge number </span><span class="No-Break"><span class="koboSpan" id="kobo.341.1">of peripherals.</span></span></p>
<p><span class="koboSpan" id="kobo.342.1">This protocol works in host-device mode, with one side of communication, the device, exposing services that can be used by the controller, on the host side. </span><span class="koboSpan" id="kobo.342.2">USB transceivers present in many microcontrollers can work in both modes. </span><span class="koboSpan" id="kobo.342.3">By implementing the upper layer of the USB standards, different types of devices can be emulated by the microcontroller, such as serial ports, storage devices, and point-to-point Ethernet interfaces, creating microcontroller-based USB devices that can be connected to a </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">host system.</span></span></p>
<p><span class="koboSpan" id="kobo.344.1">If the transceiver supports host mode, the embedded system can act as a USB host, and devices can be connected to it. </span><span class="koboSpan" id="kobo.344.2">In this case, the system should implement device drivers and applications to access the functionality provided by </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">the device.</span></span></p>
<p><span class="koboSpan" id="kobo.346.1">When both modes are </span><a id="_idIndexMarker050"/><span class="koboSpan" id="kobo.347.1">implemented on the same USB controller, the transceiver works in </span><strong class="bold"><span class="koboSpan" id="kobo.348.1">on-the-go</span></strong><span class="koboSpan" id="kobo.349.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.350.1">OTG</span></strong><span class="koboSpan" id="kobo.351.1">) mode, and selecting and configuring the desired mode can be done </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">at runtime.</span></span></p>
<p><span class="koboSpan" id="kobo.353.1">A more extended introduction to some of the most common protocols used for communicating </span><a id="_idIndexMarker051"/><span class="koboSpan" id="kobo.354.1">with peripherals and neighboring systems will be provided</span><a id="_idTextAnchor043"/><span class="koboSpan" id="kobo.355.1"> in </span><a href="B18730_07.xhtml#_idTextAnchor230"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.356.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.357.1">, </span><em class="italic"><span class="koboSpan" id="kobo.358.1">Local </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.359.1">Bus Interfaces</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">.</span></span></p>
<h1 id="_idParaDest-34"><a id="_idTextAnchor044"/><span class="koboSpan" id="kobo.361.1">Connected systems</span></h1>
<p><span class="koboSpan" id="kobo.362.1">An increasing number of embedded devices designed for different markets are now capable of network communication with their peers in the surrounding area or with gateways routing their </span><a id="_idIndexMarker052"/><span class="koboSpan" id="kobo.363.1">traffic to a broader network or the internet. </span><span class="koboSpan" id="kobo.363.2">The term </span><strong class="bold"><span class="koboSpan" id="kobo.364.1">Internet of Things</span></strong><span class="koboSpan" id="kobo.365.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.366.1">IoT</span></strong><span class="koboSpan" id="kobo.367.1">) has been used to describe the networks where those embedded devices can communicate using </span><span class="No-Break"><span class="koboSpan" id="kobo.368.1">internet protocols.</span></span></p>
<p><span class="koboSpan" id="kobo.369.1">This means that IoT devices can be addressed within the network in the same way as more complex systems, such as PCs or mobile devices, and most importantly, they use the transport layer protocols </span><a id="_idIndexMarker053"/><span class="koboSpan" id="kobo.370.1">typical of internet communications to exchange data. </span><span class="koboSpan" id="kobo.370.2">TCP/IP is a suite of protocols standardized by the IETF, and it is the fabric of the infrastructure for the internet and other self-contained, local </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">area networks.</span></span></p>
<p><span class="koboSpan" id="kobo.372.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.373.1">Internet Protocol</span></strong><span class="koboSpan" id="kobo.374.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.375.1">IP</span></strong><span class="koboSpan" id="kobo.376.1">) provides network connectivity, but on the condition that the underlying link </span><a id="_idIndexMarker054"/><span class="koboSpan" id="kobo.377.1">provides packet-based communication and mechanisms to control and regulate access to the physical media. </span><span class="koboSpan" id="kobo.377.2">Fortunately, many network interfaces meet these requirements. </span><span class="koboSpan" id="kobo.377.3">Alternative protocol families, which are not compatible with TCP/IP, are still in use in several distributed embedded systems, but a clear advantage of using the TCP/IP standard on the target is that, in the case of communication with non-embedded systems, there is no need for a translation mechanism to route the frames outside the scope of </span><span class="No-Break"><span class="koboSpan" id="kobo.378.1">the LAN.</span></span></p>
<p><span class="koboSpan" id="kobo.379.1">Besides the types of links that are widely used in non-embedded systems, such as Ethernet or wireless LAN, embedded systems can benefit from a wide choice of technologies that are specifically designed for the requirements introduced by IoT. </span><span class="koboSpan" id="kobo.379.2">New standards have been researched and put into effect to provide efficient communication for constrained devices, defining communication models to cope with specific resource usage limits and energy </span><span class="No-Break"><span class="koboSpan" id="kobo.380.1">efficiency requirements.</span></span></p>
<p><span class="koboSpan" id="kobo.381.1">Recently, new link technologies have been developed in the direction of lower bitrates and power consumption for wide-area network communication. </span><span class="koboSpan" id="kobo.381.2">These protocols are designed to provide narrow-band, long-range communication. </span><span class="koboSpan" id="kobo.381.3">The frame is too small to fit IP packets, so these technologies are mostly employed to transmit small payloads, such as periodic sensor data, or device configuration parameters if a bidirectional channel is available, and they require some form of gateway to translate the communication so that it can travel across </span><span class="No-Break"><span class="koboSpan" id="kobo.382.1">the internet.</span></span></p>
<p><span class="koboSpan" id="kobo.383.1">The interaction with the cloud services, however, requires, in most cases, connecting all the nodes in the network, and implementing the same technologies used by the servers and the IT infrastructure directly in the host. </span><span class="koboSpan" id="kobo.383.2">Enabling TCP/IP communication on an embedded device is not always straightforward. </span><span class="koboSpan" id="kobo.383.3">Even though there are several open source implementations available, system TCP/IP code is complex, big in size, and often has memory requirements that may be difficult </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">to meet.</span></span></p>
<p><span class="koboSpan" id="kobo.385.1">The same observation </span><a id="_idIndexMarker055"/><span class="koboSpan" id="kobo.386.1">applies to the </span><strong class="bold"><span class="koboSpan" id="kobo.387.1">Secure Socket Layer</span></strong><span class="koboSpan" id="kobo.388.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.389.1">SSL</span></strong><span class="koboSpan" id="kobo.390.1">)/</span><strong class="bold"><span class="koboSpan" id="kobo.391.1">Transport Layer Security</span></strong><span class="koboSpan" id="kobo.392.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.393.1">TLS</span></strong><span class="koboSpan" id="kobo.394.1">) library, which adds confidentiality and authentication between </span><a id="_idIndexMarker056"/><span class="koboSpan" id="kobo.395.1">the two communication endpoints. </span><span class="koboSpan" id="kobo.395.2">Choosing the right microcontroller for the task is, again, crucial, and if the system has to be connected to the internet and support secure socket communication, then the flash and RAM requirements have to be updated in the design phase to ensure integration with </span><span class="No-Break"><span class="koboSpan" id="kobo.396.1">third-party libraries.</span></span></p>
<h2 id="_idParaDest-35"><a id="_idTextAnchor045"/><span class="koboSpan" id="kobo.397.1">Challenges of distributed systems</span></h2>
<p><span class="koboSpan" id="kobo.398.1">Designing distributed embedded systems, especially those that are based on wireless link technologies, adds a set of </span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">interesting challenges.</span></span></p>
<p><span class="koboSpan" id="kobo.400.1">Some of these </span><a id="_idIndexMarker057"/><span class="koboSpan" id="kobo.401.1">challenges are related to the </span><span class="No-Break"><span class="koboSpan" id="kobo.402.1">following aspects:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.403.1">Selecting the correct technologies </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">and protocols</span></span></li>
<li><span class="koboSpan" id="kobo.405.1">Limitations on bitrate, packet size, and </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">media access</span></span></li>
<li><span class="koboSpan" id="kobo.407.1">Availability of </span><span class="No-Break"><span class="koboSpan" id="kobo.408.1">the nodes</span></span></li>
<li><span class="koboSpan" id="kobo.409.1">Single points of failure in </span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">the topology</span></span></li>
<li><span class="koboSpan" id="kobo.411.1">Configuring </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">the routes</span></span></li>
<li><span class="koboSpan" id="kobo.413.1">Authenticating the </span><span class="No-Break"><span class="koboSpan" id="kobo.414.1">hosts involved</span></span></li>
<li><span class="koboSpan" id="kobo.415.1">The confidentiality of the communication over </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">the media</span></span></li>
<li><span class="koboSpan" id="kobo.417.1">The impact of buffering on network speed, latency, and </span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">RAM usage</span></span></li>
<li><span class="koboSpan" id="kobo.419.1">The complexity </span><a id="_idIndexMarker058"/><span class="koboSpan" id="kobo.420.1">of implementing the </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">protocol stacks</span></span></li>
</ul>
<p><a href="B18730_09.xhtml#_idTextAnchor311"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.422.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.423.1">, </span><em class="italic"><span class="koboSpan" id="kobo.424.1">Distributed Systems and IoT Architecture</span></em><span class="koboSpan" id="kobo.425.1">, analyzes some of the link-layer technologies implemented in embedded systems to provide remote communication, where TCP/IP communication is integrated into the design of distributed systems that are integrated with </span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">IoT services.</span></span></p>
<h1 id="_idParaDest-36"><a id="_idTextAnchor046"/><span class="koboSpan" id="kobo.427.1">Introduction to isolation mechanisms</span></h1>
<p><span class="koboSpan" id="kobo.428.1">Some newer microcontrollers include support for isolation between trusted and non-trusted software running </span><a id="_idIndexMarker059"/><span class="koboSpan" id="kobo.429.1">onboard. </span><span class="koboSpan" id="kobo.429.2">This mechanism is based on a CPU extension, available only on some specific architectures, which usually relies on a sort of physical separation inside the CPU itself between the two modes of execution. </span><span class="koboSpan" id="kobo.429.3">All the code running from a non-trusted zone in the system will have a restricted view of the RAM, devices, and peripherals, which must be dynamically configured by the trusted counterpart </span><span class="No-Break"><span class="koboSpan" id="kobo.430.1">in advance.</span></span></p>
<p><span class="koboSpan" id="kobo.431.1">Software running from the trusted area can also provide features that are not directly accessible from the non-trusted world, through special function calls that cross the </span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">secure/non-secure boundary.</span></span></p>
<p><a href="B18730_11.xhtml#_idTextAnchor403"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.433.1">Chapter 11</span></em></span></a><span class="koboSpan" id="kobo.434.1">, </span><em class="italic"><span class="koboSpan" id="kobo.435.1">Trusted Execution Environment</span></em><span class="koboSpan" id="kobo.436.1">, explores the technology behind </span><strong class="bold"><span class="koboSpan" id="kobo.437.1">Trust Execution Environments</span></strong><span class="koboSpan" id="kobo.438.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.439.1">TEEs</span></strong><span class="koboSpan" id="kobo.440.1">), as well as the software components involved in real embedded </span><a id="_idIndexMarker060"/><span class="koboSpan" id="kobo.441.1">systems to provide a </span><a id="_idTextAnchor047"/><span class="koboSpan" id="kobo.442.1">safe environment to run non-trusted modules </span><span class="No-Break"><span class="koboSpan" id="kobo.443.1">and components.</span></span></p>
<h1 id="_idParaDest-37"><a id="_idTextAnchor048"/><span class="koboSpan" id="kobo.444.1">The reference platform</span></h1>
<p><span class="koboSpan" id="kobo.445.1">The preferred design </span><a id="_idIndexMarker061"/><span class="koboSpan" id="kobo.446.1">strategy for embedded CPU cores is </span><strong class="bold"><span class="koboSpan" id="kobo.447.1">reduced instruction set computer</span></strong><span class="koboSpan" id="kobo.448.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.449.1">RISC</span></strong><span class="koboSpan" id="kobo.450.1">). </span><span class="koboSpan" id="kobo.450.2">Among all the RISC CPU architectures, several reference </span><a id="_idIndexMarker062"/><span class="koboSpan" id="kobo.451.1">designs are used as guidelines by silicon manufacturers to produce the core logic to integrate into the microcontroller. </span><span class="koboSpan" id="kobo.451.2">Each reference design differs from the others in several characteristics of the CPU implementation. </span><span class="koboSpan" id="kobo.451.3">Each reference design includes one or more families of microprocessors integrated into embedded systems, which share the </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">following characteristics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.453.1">Word size used </span><a id="_idIndexMarker063"/><span class="koboSpan" id="kobo.454.1">for registers and addresses (8-bit, 16-bit, 32-bit, </span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">or 64-bit)</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.456.1">Instruction set</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.457.1">Register configurations</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.458.1">Endianness</span></span></li>
<li><span class="koboSpan" id="kobo.459.1">Extended CPU features (interrupt controller, </span><span class="No-Break"><span class="koboSpan" id="kobo.460.1">FPU, MMU)</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.461.1">Caching strategies</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.462.1">Pipeline design</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.463.1">Choosing a reference platform for your embedded system depends on your project needs. </span><span class="koboSpan" id="kobo.463.2">Smaller, less feature-rich processors are generally more suited to low energy consumption, have a smaller MCU packaging, and are less expensive. </span><span class="koboSpan" id="kobo.463.3">Higher-end systems, on the other </span><a id="_idIndexMarker064"/><span class="koboSpan" id="kobo.464.1">hand, come with a bigger set of resources and some of them have dedicated hardware to cope with challenging calculations (such as a floating-point unit, or an </span><strong class="bold"><span class="koboSpan" id="kobo.465.1">Advanced Encryption Standard</span></strong><span class="koboSpan" id="kobo.466.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.467.1">AES</span></strong><span class="koboSpan" id="kobo.468.1">) hardware module to offload symmetric encryption operations). </span><span class="koboSpan" id="kobo.468.2">8-bit and 16-bit core designs are slowly giving way to 32-bit architectures, but some successful designs remai</span><a id="_idTextAnchor049"/><span class="koboSpan" id="kobo.469.1">n relatively popular in some niche markets and </span><span class="No-Break"><span class="koboSpan" id="kobo.470.1">among hobbyists.</span></span></p>
<h2 id="_idParaDest-38"><a id="_idTextAnchor050"/><span class="koboSpan" id="kobo.471.1">ARM reference design</span></h2>
<p><span class="koboSpan" id="kobo.472.1">ARM is the most </span><a id="_idIndexMarker065"/><span class="koboSpan" id="kobo.473.1">ubiquitous reference design supplier in the </span><a id="_idIndexMarker066"/><span class="koboSpan" id="kobo.474.1">embedded market, with more than 10 billion ARM-based microcontrollers produced for embedded applications. </span><span class="koboSpan" id="kobo.474.2">One of the most interesting core designs in the embedded industry is the ARM Cortex-M family, which includes a range of models scaling from cost-effective and energy-efficient, to high-performance cores specifically designed for multimedia microcontrollers. </span><span class="koboSpan" id="kobo.474.3">Despite ranging among three different instruction sets (ARMv6, ARMv7, and ARMv8), all Cortex-M CPUs share the same programming interface, which improves portability across microcontrollers in the </span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">same families.</span></span></p>
<p><span class="koboSpan" id="kobo.476.1">Most of the examples in this book will be based on this family of CPUs. </span><span class="koboSpan" id="kobo.476.2">Though most of the concepts expressed will apply to other core designs as well, picking a reference platform now opens the door to a more complete analysis of the interactions with the underlying hardware. </span><span class="koboSpan" id="kobo.476.3">In </span><a id="_idIndexMarker067"/><span class="koboSpan" id="kobo.477.1">particular, some of the examples in this </span><a id="_idIndexMarker068"/><span class="koboSpan" id="kobo.478.1">book use specific assembly instructions from the ARMv</span><a id="_idTextAnchor051"/><span class="koboSpan" id="kobo.479.1">7 instruction set, which is implemented in some Cortex-M </span><span class="No-Break"><span class="koboSpan" id="kobo.480.1">CPU cores.</span></span></p>
<h2 id="_idParaDest-39"><a id="_idTextAnchor052"/><span class="koboSpan" id="kobo.481.1">The Cortex-M microprocessor</span></h2>
<p><span class="koboSpan" id="kobo.482.1">The main characteristic of the 32-bit cores in the Cortex-M family are </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.484.1">16 generic-purpose </span><a id="_idIndexMarker069"/><span class="No-Break"><span class="koboSpan" id="kobo.485.1">CPU registers</span></span></li>
<li><span class="koboSpan" id="kobo.486.1">Thumb 16-bit </span><a id="_idIndexMarker070"/><span class="koboSpan" id="kobo.487.1">only instructions for code </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">density optimizations</span></span></li>
<li><span class="koboSpan" id="kobo.489.1">A built-in </span><strong class="bold"><span class="koboSpan" id="kobo.490.1">Nested Vector Interrupt Controller</span></strong><span class="koboSpan" id="kobo.491.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.492.1">NVIC</span></strong><span class="koboSpan" id="kobo.493.1">) with 8 to 16 </span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">priority levels</span></span></li>
<li><span class="koboSpan" id="kobo.495.1">ARMv6-M (M0, M0+), ARMv7-M (M3, M4, M7), or ARMv8-M (M23, </span><span class="No-Break"><span class="koboSpan" id="kobo.496.1">M33) architecture</span></span></li>
<li><span class="koboSpan" id="kobo.497.1">Optional </span><a id="_idIndexMarker071"/><span class="koboSpan" id="kobo.498.1">8-region </span><strong class="bold"><span class="koboSpan" id="kobo.499.1">memory protection </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.500.1">unit</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.501.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.502.1">MPU</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.503.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.504.1">Optional TEE isolation mechanism (</span><span class="No-Break"><span class="koboSpan" id="kobo.505.1">ARM TrustZone-M)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.506.1">The total memory </span><a id="_idIndexMarker072"/><span class="koboSpan" id="kobo.507.1">address space is 4 GB. </span><span class="koboSpan" id="kobo.507.2">The beginning of the internal RAM is </span><a id="_idIndexMarker073"/><span class="koboSpan" id="kobo.508.1">typically mapped at the fixed address of </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">0x20000000</span></strong><span class="koboSpan" id="kobo.510.1">. </span><span class="koboSpan" id="kobo.510.2">The mapping of the internal flash, as well as the other peripherals, depends on the silicon manufacturer. </span><span class="koboSpan" id="kobo.510.3">However, the highest 512 MB (</span><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">0xE0000000</span></strong><span class="koboSpan" id="kobo.512.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">0xFFFFFFFF</span></strong><span class="koboSpan" id="kobo.514.1">) addresses are reserved for the </span><strong class="bold"><span class="koboSpan" id="kobo.515.1">System Control Block</span></strong><span class="koboSpan" id="kobo.516.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.517.1">SCB</span></strong><span class="koboSpan" id="kobo.518.1">), which groups together several configuration parameters and </span><a id="_idIndexMarker074"/><span class="koboSpan" id="kobo.519.1">diagnostics that can be accessed by the software at any time to directly interact with </span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">the core.</span></span></p>
<p><span class="koboSpan" id="kobo.521.1">Synchronous communication with peripherals and other hardware components can be triggered through interrupt lines. </span><span class="koboSpan" id="kobo.521.2">The processor can receive and recognize several different digital input signals and react to them promptly, interrupting the execution of the software and temporarily jumping to a specific location in the memory. </span><span class="koboSpan" id="kobo.521.3">Cortex-M supports up to 240 interrupt lines on the high-end cores of </span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">the family.</span></span></p>
<p><span class="koboSpan" id="kobo.523.1">The interrupt vector, located at the beginning of the software image in flash, contains the addresses of the interrupt routines that will automatically execute on specific events. </span><span class="koboSpan" id="kobo.523.2">Thanks to the NVIC, interrupt lines can be assigned priorities so that when a higher-priority interrupt occurs while the routine for a lower interrupt is executed, the current interrupt routine is temporarily suspended to allow the higher-priority interrupt line to be serviced. </span><span class="koboSpan" id="kobo.523.3">This ensures minimal interrupt latency for these signal lines, which are somewhat critical for the system to execute as fast </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">as possible.</span></span></p>
<p><span class="koboSpan" id="kobo.525.1">At any time, the software on the target can run in two privilege modes: unprivileged or privileged. </span><span class="koboSpan" id="kobo.525.2">The CPU has built-in support for privilege separation between system and application software, even providing two different registers for the two separate stack pointers. </span><span class="koboSpan" id="kobo.525.3">In </span><a href="B18730_10.xhtml#_idTextAnchor357"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.526.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.527.1">, </span><em class="italic"><span class="koboSpan" id="kobo.528.1">Parallel Tasks and Scheduling</span></em><span class="koboSpan" id="kobo.529.1">, we will examine how to properly implement privilege separation, as well as how to enforce memory separation when running untrusted code on the target, in more detail. </span><span class="koboSpan" id="kobo.529.2">This is, for example, used to hide secrets such as private keys from direct access from the non-secure world. </span><span class="koboSpan" id="kobo.529.3">In </span><a href="B18730_11.xhtml#_idTextAnchor403"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.530.1">Chapter 11</span></em></span></a><span class="koboSpan" id="kobo.531.1">, </span><em class="italic"><span class="koboSpan" id="kobo.532.1">Trusted Execution Environment</span></em><span class="koboSpan" id="kobo.533.1">, we will learn how to properly implement privilege separation, as well as how to enforce memory separation within an OS when running application code on the target with a different level </span><span class="No-Break"><span class="koboSpan" id="kobo.534.1">of trust.</span></span></p>
<p><span class="koboSpan" id="kobo.535.1">A Cortex-M core is present in many microcontrollers, from different silicon vendors. </span><span class="koboSpan" id="kobo.535.2">Software tools are similar for all the platforms, but each MCU has a different configuration to take </span><a id="_idIndexMarker075"/><span class="koboSpan" id="kobo.536.1">into account. </span><span class="koboSpan" id="kobo.536.2">Convergence libraries are available </span><a id="_idIndexMarker076"/><span class="koboSpan" id="kobo.537.1">to hide manufacturer-specific details and improve portability across different models and brands. </span><span class="koboSpan" id="kobo.537.2">Manufacturers provide reference kits and all the documentation required to get started, which are intended to be used for evaluation during the design phase, and may also be useful for developing prototypes at a later stage. </span><span class="koboSpan" id="kobo.537.3">Some of these evaluation boards are equipped with sensors, multimedia electronics, or other peripherals that extend the functionality of the microcontroller. </span><span class="koboSpan" id="kobo.537.4">Some even include preconfigured, third-party “middleware” libraries such as TCP/IP communication stacks, TLS and cryptography </span><a id="_idIndexMarker077"/><span class="koboSpan" id="kobo.538.1">libraries, simple filesystems and other accessory </span><a id="_idIndexMarker078"/><span class="koboSpan" id="kobo.539.1">compon</span><a id="_idTextAnchor053"/><span class="koboSpan" id="kobo.540.1">ents, and modules that can be quickly and easily added to a </span><span class="No-Break"><span class="koboSpan" id="kobo.541.1">software project.</span></span></p>
<h1 id="_idParaDest-40"><a id="_idTextAnchor054"/><span class="koboSpan" id="kobo.542.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.543.1">When approaching embedded software requirements, before anything else, you must have a good understanding of the hardware platform and its components. </span><span class="koboSpan" id="kobo.543.2">By describing the architecture of modern microcontrollers, this chapter pointed out some of the peculiarities of embedded devices and how developers should efficiently rethink their approach to meeting requirements and solving problems, while at the same time taking into account the features and the limits of the </span><span class="No-Break"><span class="koboSpan" id="kobo.544.1">target platform.</span></span></p>
<p><span class="koboSpan" id="kobo.545.1">In the next chapter, we will analyze the tools and procedures typically used in embedded development, including command-line toolchains and </span><strong class="bold"><span class="koboSpan" id="kobo.546.1">integrated development environments</span></strong><span class="koboSpan" id="kobo.547.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.548.1">IDEs</span></strong><span class="koboSpan" id="kobo.549.1">). </span><span class="koboSpan" id="kobo.549.2">We will understand how to organize the workflow and how to effectively prevent, locate, and </span><span class="No-Break"><span class="koboSpan" id="kobo.550.1">fix bugs.</span></span></p>
</div>
</body></html>