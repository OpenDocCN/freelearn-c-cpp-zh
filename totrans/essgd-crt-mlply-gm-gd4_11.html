<html><head></head><body>
		<div id="_idContainer135">
			<h1 class="chapter-number" id="_idParaDest-164"><a id="_idTextAnchor276"/>11</h1>
			<h1 id="_idParaDest-165"><a id="_idTextAnchor277"/>Optimizing Data Requests</h1>
			<p>Welcome to <a href="B18527_11.xhtml#_idTextAnchor276"><span class="No-Break"><em class="italic">Chapter 11</em></span></a>, <em class="italic">Optimizing Data Requests</em>, where we will use the tools that we saw in <a href="B18527_10.xhtml#_idTextAnchor260"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, <em class="italic">Debugging and Profiling the Network</em>, and finally implement improvements to the network code that we wrote in <a href="B18527_09.xhtml#_idTextAnchor188"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, <em class="italic">Creating an Online </em><span class="No-Break"><em class="italic">Adventure Prototype</em></span><span class="No-Break">.</span></p>
			<p>In this chapter, we will understand a bit more about bandwidth and throughput by analyzing the current state of our game. We saw, in the <em class="italic">Using the network profiler</em> section of <a href="B18527_10.xhtml#_idTextAnchor260"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, <em class="italic">Debugging and Profiling the Network</em>, that we have some improvements to make, especially regarding the MultiplayerSynchronizers and the <strong class="source-inline">QuestDatabase</strong> data transmission. So, here, we will see how we can decrease the number of requests and how we can compress and decompress data to reduce the bandwidth and throughput and make our game available to more people in a more reliable and <span class="No-Break">optimal way.</span></p>
			<p>By the end of this chapter, you will understand that there are many ways to optimize a game and most of the optimizations will depend on the specific demands of the game itself. As you progress, you will develop a keen sense and understanding of how to assess potential areas of improvement and the kind of data you are looking for, as well as some general techniques to address bottlenecks in your <span class="No-Break">network code.</span></p>
			<p>So, this chapter will cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Understanding <span class="No-Break">network resources</span></li>
				<li>Decreasing the <span class="No-Break">requests count</span></li>
				<li>Data compression <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">ENetConnection</strong></span></li>
			</ul>
			<h1 id="_idParaDest-166"><a id="_idTextAnchor278"/>Technical requirements</h1>
			<p>As mentioned in <a href="B18527_10.xhtml#_idTextAnchor260"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, <em class="italic">Debugging and Profiling the Network</em>, <em class="italic">Part 3</em>, <em class="italic">Optimizing the Online Experience</em>, is based on the final version of the project made in <a href="B18527_09.xhtml#_idTextAnchor188"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, <em class="italic">Creating an Online Adventure Prototype</em>, so it’s fundamental to have read, practiced, and implemented the concepts <span class="No-Break">presented there.</span></p>
			<p>You can get the files necessary to get started with this chapter through the following link. These files have the implementations we’ve made in <a href="B18527_10.xhtml#_idTextAnchor260"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, <em class="italic">Debugging and Profiling </em><span class="No-Break"><em class="italic">the Network</em></span><span class="No-Break">:</span></p>
			<p><a href="https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0/tree/11.optimizing-data-requests"><span class="No-Break">https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0/tree/11.optimizing-data-requests</span></a></p>
			<p>It’s also necessary that you have read and understood the concepts and tools presented in <a href="B18527_10.xhtml#_idTextAnchor260"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, <em class="italic">Debugging and Profiling the Network</em>, so that we can move forward under the assumption that you already know what they are and how to use them properly. In particular, you will need to understand how the Debugger’s Network Profiler and Monitors tools work. So, if you aren’t sure how to use these tools, please take some time to go back and read <a href="B18527_10.xhtml#_idTextAnchor260"><span class="No-Break"><em class="italic">Chapter 10</em></span></a><em class="italic">, Debugging and Profiling the Network,</em> so you can master these and other <span class="No-Break">debugging tools.</span></p>
			<h1 id="_idParaDest-167"><a id="_idTextAnchor279"/>Understanding network resources</h1>
			<p>We’ve <a id="_idIndexMarker395"/>already mentioned the importance of bandwidth<a id="_idIndexMarker396"/> and throughput; in <a href="B18527_01.xhtml#_idTextAnchor018"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Setting up a Server</em>, we even had a<a id="_idIndexMarker397"/> brief introduction to and a visual representation of the topic in <span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.3</em> and <span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.4</em>. Now it’s time to wrap our heads around these concepts, which are fundamental to network usage optimization and will be our major resources to measure the improvements we made toward our <span class="No-Break">optimization goals.</span></p>
			<p>As a general rule, the less <a id="_idIndexMarker398"/>bandwidth and the lower the throughput<a id="_idIndexMarker399"/> of our network code, the better. Of course, we need to keep in mind that all optimizations should maintain the game experience, so we are in a very delicate position. Different from other processing, memory, and graphics optimizations, our work can’t create “beautiful accidents,” such as a processing optimization that can lead to a cool mechanic. No, our job as network engineers is to replicate the already established mechanics and effects to all peers in a network. Let’s understand how we <span class="No-Break">do that.</span></p>
			<p>When talking about bandwidth, it might be surprising to hear that most games don’t actually need to have huge infrastructures available. For instance, a video conference takes way more bandwidth than a complex first-person shooter or a war simulator with tons of physics simulation because it works with processed data in the form of rendered images that must be passed around and re-created in each of the participants’ instances of the conference. In the case of games, most of the necessary resources to create the simulations are already available on the user’s machine, so most of our job is to communicate through messages what the computer should load to sync the client’s and server’s game instances. It’s well established that players need a bandwidth of about 5 Mbps to play most modern online multiplayer games, including huge franchises such as Call of Duty, League of Legends, <span class="No-Break">and Fortnite.</span></p>
			<p>In <em class="italic">Part 1</em>, <em class="italic">Handshaking and Networking</em>, of this book, we saw that games work mostly with<a id="_idIndexMarker400"/> unreliable data, meaning that most of the time, we only need to know the latest data regarding an object in the game in order to sync it. This decreases the network usage a lot and allows us to focus on the specific types of data necessary to replicate the server’s game world in clients’ <span class="No-Break">game worlds.</span></p>
			<p>The major concern in online multiplayer games is the consistency with which we can keep on the data transmission stream – ultimately, whether we can maintain the throughput of our network consistently. This can be affected by latency and other external aspects, so all we can do is design a communication architecture that takes into account how latency<a id="_idIndexMarker401"/> can affect our throughput. Of course, we will also try to keep the bandwidth to a minimum so that if a household has many devices connected to the same network, our game has room to keep the <span class="No-Break">data flowing.</span></p>
			<p>So, keep in mind that bandwidth<a id="_idIndexMarker402"/> and throughput<a id="_idIndexMarker403"/> are our major resources and we will be looking at them to find areas that we can improve in <span class="No-Break">our game.</span></p>
			<p>You might still be trying to work out the difference between bandwidth and throughput. So, let’s briefly assess them both. We were introduced to these concepts in <a href="B18527_01.xhtml#_idTextAnchor018"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Setting up a Server</em>, so if you don’t quite remember what they are, take a brief moment to read the <em class="italic">What is the UDP protocol?</em> section of <span class="No-Break">the chapter.</span></p>
			<p>We are going to use bandwidth to understand how much of the network our game needs to perform correctly, meaning how much data we expect to transmit through the network taking into account all the measurements we observed using the network profiler. This means that if we have 1,000 MultiplayerSynchronizers syncing 5 KB of data per second at any given point of our game, we will need a network with a 5 Mbps velocity. Note that this might not be consistent transmission of 5 Mbps throughout the whole game session, but it’s a recommendation based on our measurements that the game might require a network that can manage up to 5 Mbps to play smoothly. In summary, bandwidth is the amount of space available in a connection for data transmission, not the <span class="No-Break">transmission itself.</span></p>
			<p>Now, the actual thing we are looking to optimize is<a id="_idIndexMarker404"/> the <strong class="bold">throughput</strong>, which points to how many packets and the size of these packets we are actually transmitting through the network. The throughput is our actual data flow. You can think about it using an analogy where bandwidth is a pipe and throughput is the water. We can’t stream more water than a pipe can support; instead, we can stream water up to the available pipe size. In the same way, the amount of throughput we can have is based on the available <span class="No-Break">bandwidth capacity.</span></p>
			<p>You can see an illustration of a good and bad throughput-bandwidth relationship in the <span class="No-Break">following figure:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer129">
					<img alt="Figure 11.1 – An illustration of a good and bad throughput-bandwidth relationship" src="image/Figure_11.01_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1 – An illustration of a good and bad throughput-bandwidth relationship</p>
			<p>Note that with <a id="_idIndexMarker405"/>good throughput, the data sent and received is consistent and doesn’t exceed the bandwidth, whereas with bad throughput, the data packets are inconsistent in size and frequency, and some are even lost in the middle of the transmission. When packets don’t reach their destination, we call<a id="_idIndexMarker406"/> it <strong class="bold">packet loss</strong>, and this can cause lots of headaches and complaints <span class="No-Break">from players.</span></p>
			<p>With packet loss, the client doesn’t know how to handle their game instance properly. Where should the second player’s spaceship be? Did it stop shooting? Is it shooting at an <strong class="source-inline">Asteroid</strong> node or are there no more <strong class="source-inline">Asteroid</strong> nodes to shoot? Is the <strong class="source-inline">Asteroid</strong> node they were shooting at there yet? We are going to see, in <a href="B18527_12.xhtml#_idTextAnchor285"><span class="No-Break"><em class="italic">Chapter 12</em></span></a>, <em class="italic">Implementing Lag Compensation</em>, how to handle these situations, but ideally, we should avoid them by paying attention to <span class="No-Break">the throughput.</span></p>
			<p>With all that said, network engineers are left in a very delicate position when the resources available for optimization don’t leave space for new mechanics to emerge. We take the already implemented mechanics and try to fit them all into the available resources, usually squeezing them to keep up with any potential changes that may require more of these <a id="_idIndexMarker407"/>resources, for instance, a new mechanic that requires more bandwidth. So, we can’t experiment a lot when optimizing <span class="No-Break">the network.</span></p>
			<p>In the next section, let’s talk about how we can initiate our optimizations by decreasing the number of requests that our game makes. We are going to assess the problems presented in <a href="B18527_10.xhtml#_idTextAnchor260"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, <em class="italic">Debugging and Profiling the Network</em>, such as in <strong class="source-inline">Weapon2D</strong> massive RPC count and unnecessary syncs of the <strong class="source-inline">Asteroid</strong> node’s <span class="No-Break"><strong class="source-inline">MultiplayerSynchronizer</strong></span><span class="No-Break"> node.</span></p>
			<h1 id="_idParaDest-168"><a id="_idTextAnchor280"/>Decreasing the requests count</h1>
			<p>Previously, in <a href="B18527_10.xhtml#_idTextAnchor260"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, <em class="italic">Debugging and Profiling the Network</em>, we saw that there was a <a id="_idIndexMarker408"/>disproportional and unnecessary number of requests being made to the <strong class="source-inline">Weapon2D</strong> node’s <strong class="source-inline">fire()</strong> RPC method, and we even came up with what could be a solution for this issue. We also saw that we can decrease the <strong class="source-inline">Asteroid</strong> node’s sync problem by only updating it once a given player requests a synchronization using the <strong class="source-inline">World</strong> node’s <strong class="source-inline">sync_world()</strong> <span class="No-Break">RPC method.</span></p>
			<p>In this section, we are going to implement these optimization methods and improve the overall performance of our network. Let’s start with the <strong class="source-inline">Weapon2D</strong> <span class="No-Break">node issue.</span></p>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor281"/>Reducing the weapon fire count</h2>
			<p>Sometimes we may need to <a id="_idIndexMarker409"/>make changes in the core code of a feature in order to improve its network performance, even when its local performance stays the same, or may even drop. When talking about optimization, we are always trying to balance things out and figure out how to use the available resources in a way that allows more players to enjoy a better experience. Network resources are particularly a priority in most online multiplayer games since it’s through a good network that players will be able to get the most out of their shared experiences. So, let’s make some changes to how <strong class="source-inline">Player2D</strong> node fires <strong class="source-inline">Weapon2D</strong> node. Let’s open the <strong class="source-inline">res://09.prototyping-space-adventure/Objects/Weapon/Weapon2D.tscn</strong> scene first and carry out the <span class="No-Break">following steps:</span></p>
			<ol>
				<li>Connect <a id="_idIndexMarker410"/>the <strong class="source-inline">timeout</strong> signal of <strong class="source-inline">Timer</strong> node to <strong class="source-inline">Weapon2D</strong> node and create a callback method <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">_on_timer_timeout()</strong></span><span class="No-Break">:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer130">
					<img alt="Figure 11.2 – Timer node’s timeout signal connecting to theWeapon2D node’s _on_timer_timeout() callback" src="image/Figure_11.02_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2 – Timer node’s timeout signal connecting to theWeapon2D node’s _on_timer_timeout() callback</p>
			<ol>
				<li value="2">Open the <strong class="source-inline">res://09.prototyping-space-adventure/Objects/Weapon/Weapon2D.gd</strong> script and, in the <strong class="source-inline">_on_timer_timeout()</strong> callback, call the <strong class="source-inline">fire()</strong> method so <strong class="source-inline">Weapon2D</strong> node fires on every <strong class="source-inline">Timer</strong> <span class="No-Break">node’s tic.</span></li>
				<li>Then, let’s create an RPC method that can be called by any peer and should also be called locally. We will use this method to change <strong class="source-inline">Weapon2D</strong>’s firing state, so it should receive a Boolean variable as <span class="No-Break">an argument:</span><pre class="source-code">
@rpc("any_peer", "call_local")
func set_firing(firing):</pre></li>				<li>Inside this method, we will check the <strong class="source-inline">firing</strong> state, and if it’s <strong class="source-inline">true</strong>, we will call the <strong class="source-inline">fire()</strong> method <a id="_idIndexMarker411"/>as well; otherwise, we will tell <strong class="source-inline">Timer</strong> <span class="No-Break">to stop:</span><pre class="source-code">
@rpc("any_peer", "call_local")
func set_firing(firing):
  if firing:
    fire()
  else:
    timer.stop()</pre></li>				<li>With that, we can remove the RPC annotation on the <strong class="source-inline">fire()</strong> method and the <strong class="source-inline">if timer.is_stopped()</strong> statement, since now <strong class="source-inline">Timer</strong> itself tells when <strong class="source-inline">Weapon2D</strong> fires. The <strong class="source-inline">fire()</strong> method should look like this <span class="No-Break">after that:</span><pre class="source-code">
func fire():
  animation_player.play("fire")
  spawner.spawn(bullet_scene)
  timer.start(1.0 / fire_rate)</pre></li>			</ol>
			<p>With that, <strong class="source-inline">Weapon2D</strong> will fire based on the timeout signal from <strong class="source-inline">Timer</strong>. With the new RPC method, we can change the firing state, starting or stopping the creation of new <em class="italic">bullets</em>. The <strong class="source-inline">Weapon2D</strong> script should look like this at <span class="No-Break">this point:</span></p>
			<pre class="source-code">
class_name Weapon2D
extends Marker2D
@export var bullet_scene: PackedScene
@export_range(0, 1, 1, "or_greater") var fire_rate = 3
@onready var spawner = $BulletSpawner2D
@onready var timer = $Timer
@onready var animation_player = $AnimationPlayer
func fire():
  animation_player.play("fire")
  spawner.spawn(bullet_scene)
  timer.start(1.0 / fire_rate)
@rpc("any_peer", "call_local")
func set_firing(firing):
  if firing:
    fire()
  else:
    timer.stop()
func _on_timer_timeout():
  fire()</pre>			<p>Now, we need to know when <a id="_idIndexMarker412"/><strong class="source-inline">Weapon2D</strong>’s firing state changes, and to do that, we will need to make some changes to <strong class="source-inline">Player2D</strong>. So, open <strong class="source-inline">res://09.prototyping-space-adventure/Actors/Player/Player2D.gd</strong> and implement the <span class="No-Break">following steps:</span></p>
			<ol>
				<li>Remove the whole <strong class="source-inline">_process()</strong> callback code. Then, override the <span class="No-Break"><strong class="source-inline">_unhandled_input()</strong></span><span class="No-Break"> callback:</span><pre class="source-code">
func _unhandled_input(event):</pre></li>				<li>Inside the <strong class="source-inline">_unhandled_input()</strong> callback, we are going to check whether the <strong class="source-inline">"shoot"</strong> action was pressed or released. If pressed, we set the <strong class="source-inline">weapon</strong> firing state to <strong class="source-inline">true</strong>, and if released, it’s set to <strong class="source-inline">false</strong> (remember, we should do that using the <strong class="source-inline">rpc()</strong> method so the player shoots on all network <span class="No-Break">peer instances):</span><pre class="source-code">
func _unhandled_input(event):
  if event.is_action_pressed("shoot"):
    weapon.rpc("set_firing", true)
  elif event.is_action_released("shoot"):
    weapon.rpc("set_firing", false)</pre></li>				<li>Next, we need to add a line to the <strong class="source-inline">setup_multiplayer()</strong> method to also toggle the <strong class="source-inline">_unhandled_input()</strong> process based on whether the instance of the spaceship is the current player or a <span class="No-Break">remote player:</span><pre class="source-code">
func setup_multiplayer(player_id):
  var self_id = multiplayer.get_unique_id()
  var is_player = self_id == player_id
  set_process(is_player)
  set_physics_process(is_player)
  set_process_unhandled_input(is_player)</pre></li>			</ol>
			<p>With that, <strong class="source-inline">Player2D</strong> will toggle <strong class="source-inline">Weapon2D</strong>’s firing state based on whether the <strong class="source-inline">"shoot"</strong> action was pressed or released, instead of calling it every frame while <strong class="source-inline">"shoot"</strong> <span class="No-Break">was pressed.</span></p>
			<p>Let’s make an assessment of this<a id="_idIndexMarker413"/> improvement. Turn on the network profiler and let’s see how this goes. Remember that depending on the duration of the profiling section, we may get different results, so this isn’t as accurate as a unit test; but still, it will give us a good sense of any potential improvements we’ve made. In the following figure, we have <strong class="bold">Session 1</strong> as the server, receiving RPCs from the client’s <span class="No-Break"><strong class="source-inline">Player2D</strong></span><span class="No-Break"> instance:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer131">
					<img alt="Figure 11.3 – The Session 1 Debugger’s Network Profiler tab highlighting thePlayer2D node instance’s incoming RPCs" src="image/Figure_11.03_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.3 – The Session 1 Debugger’s Network Profiler tab highlighting thePlayer2D node instance’s incoming RPCs</p>
			<p>As you can see in the figure, I<a id="_idIndexMarker414"/> destroyed all 30 asteroids in a play session of around 20.0 seconds, with a total of six RPC calls from <strong class="source-inline">Player2D</strong> instance. If you compare this to <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.13</em>, where we had 693 calls for a session with about the same duration, this is more than 115x fewer calls. I think we did a good <span class="No-Break">job here.</span></p>
			<p>So, in this section, we learned how to optimize data requests in our game to improve network performance. We focused on how to decrease the number of requests being made in the game by optimizing the firing of <strong class="source-inline">Weapon2D</strong> node. We also saw how to create an RPC method that can change <strong class="source-inline">Weapon2D</strong>’s firing state, and how to toggle the firing state based on the <strong class="source-inline">"shoot"</strong> action being pressed or released instead of triggering the firing on every frame in the <strong class="source-inline">_process()</strong> callback. Finally, we saw how to use the network profiler to assess the impact of these optimizations on the game’s performance. In the next section, we will work on decreasing the requests of <span class="No-Break">Asteroid’s </span><span class="No-Break"><strong class="source-inline">MultiplayerSynchronizer</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-170"><a id="_idTextAnchor282"/>Decreasing Asteroid’s syncing count</h2>
			<p>Another<a id="_idIndexMarker415"/> issue we saw in <a href="B18527_10.xhtml#_idTextAnchor260"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, <em class="italic">Debugging and Profiling the Network</em>, was <a id="_idIndexMarker416"/>regarding the way <strong class="source-inline">Asteroid</strong> node’s <strong class="source-inline">MultiplayerSynchronizers</strong> sync their position to players. Since they don’t move throughout the play session, there’s no need to keep updating their position and other properties on a regular basis. Instead, we only need to sync them once when the player asks <strong class="source-inline">World</strong> node <span class="No-Break">to sync.</span></p>
			<p>So, open the <strong class="source-inline">res://09.prototyping-space-adventure/Objects/Asteroid/Asteroid.tscn</strong> scene and make the necessary changes to improve this aspect of our <span class="No-Break">network engineering.</span></p>
			<p>Here, we just need to set the <strong class="source-inline">MultiplayerSynchronizer</strong> node’s <strong class="bold">Visibility Update Mode</strong> property <span class="No-Break">to </span><span class="No-Break"><strong class="bold">None</strong></span><span class="No-Break">:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer132">
					<img alt="Figure 11.4 – Asteroid node’s MultiplayerSynchronizer node Visibility Update Mode property set to None" src="image/Figure_11.04_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.4 – Asteroid node’s MultiplayerSynchronizer node Visibility Update Mode property set to None</p>
			<p>With <a id="_idIndexMarker417"/>that, we just<a id="_idIndexMarker418"/> have to do the syncing manually now. The <strong class="source-inline">MultiplayerSynchronizer</strong> node has a method called <strong class="source-inline">update_visibility()</strong>, which receives an argument where we can pass the ID of the peer we want to sync with; if we pass <strong class="source-inline">0</strong>, it updates all <span class="No-Break">peers instead.</span></p>
			<p>Note that this method takes into account the filters we set in the <em class="italic">Syncing the asteroids</em> section of <a href="B18527_09.xhtml#_idTextAnchor188"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, <em class="italic">Creating an Online Adventure Prototype</em>, using the <strong class="source-inline">set_visibility_for()</strong> method, meaning only the peers added using this method will be synced. So, in our case, if we don’t add the peer to the filtering using the <strong class="source-inline">set_visibility_for()</strong> method, this peer won’t be synced, even if we use the <strong class="source-inline">update_visibility()</strong> method, passing the correct <span class="No-Break">peer ID.</span></p>
			<p>The best <a id="_idIndexMarker419"/>place to manually sync the <strong class="source-inline">Asteroid</strong> node’s properties<a id="_idIndexMarker420"/> will be in the <strong class="source-inline">World</strong> class, so open the <strong class="source-inline">res://09.prototyping-space-adventure/Levels/World.gd</strong> script . Then, inside the <strong class="source-inline">sync_world()</strong> method, let’s add another group call to the <strong class="source-inline">"Sync"</strong> group, but this time to the <strong class="source-inline">update_visibility</strong> method, and pass <strong class="source-inline">player_id</strong> as an argument. The whole <strong class="source-inline">sync_world()</strong> method should look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
@rpc("any_peer", "call_local")
func sync_world():
  var player_id = multiplayer.get_remote_sender_id()
  get_tree().call_group("Sync", "set_visibility_for",
      player_id, true)
  get_tree().call_group("Sync", "update_visibility",
      player_id)</pre>			<p>With that, all <strong class="source-inline">Asteroid</strong> nodes should only sync once to every player, decreasing the total network <span class="No-Break">resource usage.</span></p>
			<p>Let’s profile this change as well to see its impact on the overall network consumption. The following figure showcases the sync count of some <span class="No-Break">asteroids’ MultiplayerSynchronizers:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer133">
					<img alt="Figure 11.5 – The Session 2 Debugger’s Network Profiler highlighting the Asteroid ﻿nodes’ MultiplayerSynchronizer ﻿nodes’ sync counts" src="image/Figure_11.05_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.5 – The Session 2 Debugger’s Network Profiler highlighting the Asteroid nodes’ MultiplayerSynchronizer nodes’ sync counts</p>
			<p>Compare this to <span class="No-Break"><em class="italic">Figure 10</em></span><em class="italic">.13</em>, where we had hundreds and hundreds of updates, and for every frame, the update count would increase. After what we’ve done, they only increase once a player enters a session and only to that specific player. Pretty good <span class="No-Break">job, right?</span></p>
			<p>In this section, we saw how to optimize data requests by decreasing the <strong class="source-inline">asteroid</strong> nodes’ <strong class="source-inline">MultiplayerSynchronizer</strong> nodes’ syncs. To do that, we disabled the automatic <a id="_idIndexMarker421"/>synchronization <a id="_idIndexMarker422"/>by setting <strong class="source-inline">MultiplayerSynchronizer</strong> node’s <strong class="bold">Visibility Update Mode</strong> property to <strong class="bold">None</strong> and manually syncing by using the <strong class="source-inline">MultiplayerSynchronizer.update_visibility()</strong> method once the player joins <span class="No-Break">the game.</span></p>
			<p>In the upcoming section, we will see how we can compress data to optimize the packet’s size. Until now, we’ve only dealt with how many packets we send or receive, but the size of these packets is very important to handle as well. Let’s understand what we have available to <span class="No-Break">do that.</span></p>
			<h1 id="_idParaDest-171"><a id="_idTextAnchor283"/>Compressing data with the ENetConnection class</h1>
			<p>The <a id="_idIndexMarker423"/>Godot Engine’s high-level network API includes <a id="_idIndexMarker424"/>the <strong class="source-inline">ENetConnection</strong> class. This class is available after a connection between peers, such as the server and client, is established. Using <strong class="source-inline">ENetConnection</strong>, we can tweak the peer’s connections, allowing us to tell, for instance, the compression method. We can access the <strong class="source-inline">ENetConnection</strong> instance after the peers have successfully connected. For that, we can use the <span class="No-Break"><strong class="source-inline">ENetMultiplayerPeer.host</strong></span><span class="No-Break"> property.</span></p>
			<p>There are five available compression methods to use in the <span class="No-Break"><strong class="source-inline">ENetConnection</strong></span><span class="No-Break"> class:</span></p>
			<ul>
				<li><strong class="bold">None</strong>, which can be used through the <strong class="source-inline">CompressionMode</strong> enumerator’s <strong class="source-inline">COMPRESS_NONE</strong> option. This is what the <span class="No-Break">documentation says:</span><p class="list-inset"><em class="italic">This uses the most bandwidth but has the upside of requiring the fewest CPU resources. This option may also be used to make network debugging using tools like </em><span class="No-Break"><em class="italic">Wireshark easier.</em></span></p></li>
				<li>ENet’s built-in <strong class="bold">Range Coder</strong>, which can be used through the <strong class="source-inline">CompressionMode</strong> enumerator’s <strong class="source-inline">COMPRESS_RANGE_CODER</strong> option. This is what the <span class="No-Break">documentation says:</span><p class="list-inset"><em class="italic">[This is] ENet’s built-in range encoding. Works well on small packets, but is not the most efficient algorithm on packets larger than </em><span class="No-Break"><em class="italic">4 KB.</em></span></p></li>
				<li><strong class="bold">FastLZ</strong>, which can be used through the <strong class="source-inline">CompressionMode</strong> enumerator’s <strong class="source-inline">COMPRESS_FASTLZ</strong> option. This is what the <span class="No-Break">documentation says:</span><p class="list-inset"><em class="italic">This option uses less CPU resources compared to COMPRESS_ZLIB, at the expense of using </em><span class="No-Break"><em class="italic">more bandwidth.</em></span></p></li>
				<li><strong class="bold">ZLib</strong>, which can be used through the <strong class="source-inline">CompressionMode</strong> enumerator’s <strong class="source-inline">COMPRESS_ZLIB</strong> option. This is what the <span class="No-Break">documentation says:</span><p class="list-inset"><em class="italic">This option uses less bandwidth compared to COMPRESS_FASTLZ , at the expense of using more </em><span class="No-Break"><em class="italic">CPU resources.</em></span></p></li>
				<li><strong class="bold">Zstandard</strong>, which can be used through the <strong class="source-inline">CompressionMode</strong> enumerator’s <strong class="source-inline">COMPRESS_ZSTD</strong> option. This is what the <span class="No-Break">documentation says:</span><p class="list-inset"><em class="italic">Note that this algorithm is not very efficient on packets smaller than 4 KB. Therefore, it’s recommended to use other compression algorithms in </em><span class="No-Break"><em class="italic">most cases.</em></span></p></li>
			</ul>
			<p>You can find more about <strong class="source-inline">ENetConnection</strong> and <strong class="source-inline">CompressionMode</strong> in the Godot docs through the <span class="No-Break">following link:</span></p>
			<p><a href="https://docs.godotengine.org/en/stable/classes/class_enetconnection.html#enum-enetconnection-compressionmode"><span class="No-Break">https://docs.godotengine.org/en/stable/classes/class_enetconnection.html#enum-enetconnection-compressionmode</span></a></p>
			<p>It’s time to <a id="_idIndexMarker425"/>work on the size of the data we are <a id="_idIndexMarker426"/>transmitting through the network. In the following steps, we will implement compression to decrease our game’s packet size and optimize the transmission of data through the network. Note that, as always, there’s a trade-off between the bandwidth and CPU resources. Our game currently doesn’t have any issues regarding CPU usage. So, at this point, we can focus on optimizing the network resources. For that, we can use the <strong class="source-inline">COMPRESS_ZLIB</strong> compression mode. To do that, let’s open the <strong class="source-inline">res://09.prototyping-space-adventure/Authentication.gd</strong> script and complete the <span class="No-Break">following steps:</span></p>
			<ol>
				<li>Right before we set <strong class="source-inline">multiplayer_peer</strong> to the peer in the <strong class="source-inline">_ready()</strong> callback, we are going to change the <strong class="source-inline">ENetConnection</strong> compression mode. For that, we access the <strong class="source-inline">host</strong> property and use the <strong class="source-inline">compress()</strong> method, passing <strong class="source-inline">EnetConnection.COMPRESS_ZLIB</strong> as <span class="No-Break">an argument:</span><pre class="source-code">
func _ready():
  if multiplayer.is_server():
    peer.create_server(PORT)
    load_database()
  else:
    peer.create_client(ADDRESS, PORT)
    peer.host.compress(EnetConnection.COMPRESS_ZLIB)
  multiplayer.multiplayer_peer = peer</pre><p class="list-inset">We need to do this here because the compression mode needs to be set before the connection is established, which happens after we set the <span class="No-Break"><strong class="source-inline">multiplayer.multiplayer_peer</strong></span><span class="No-Break"> property.</span></p></li>				<li>We also <a id="_idIndexMarker427"/>need to do the same thing in<a id="_idIndexMarker428"/> the <strong class="source-inline">res://09.prototyping-spaceadventure/LoggingScreen.gd</strong> script so that this connection also matches the server’s connection compression. Again, before setting <strong class="source-inline">multiplayer.multiplayer_peer</strong>, we set ENetConnection’s compression <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">COMPRESS_ZLIB</strong></span><span class="No-Break">:</span><pre class="source-code">
func _ready():
  peer.create_client(ADDRESS, PORT)
  peer.host.compress(ENetConnection.COMPRESS_ZLIB)
  multiplayer.multiplayer_peer = peer</pre></li>			</ol>
			<p>With that, we are able to change the compression mode used in our game’s network connection as soon as the players join the game’s world. For now, this won’t make a huge impact. As we saw in the previous quotes from the documentation, most of the compression algorithms aim at having data packets be either below 4 KB or above 4 KB. Our game’s packets currently haven’t even reached the Kilobytes yet, so…this may not have a big, if any, impact at this point, to <span class="No-Break">be honest.</span></p>
			<p>If we want to<a id="_idIndexMarker429"/> measure how much bandwidth we are<a id="_idIndexMarker430"/> using and get at least a glance at any possible improvements, we can use the Debugger’s <strong class="bold">Monitors</strong> to track <strong class="source-inline">EnetConnection</strong> instances’ sent and received data. For that, we can use the <strong class="source-inline">ENetConnection.pop_statistic()</strong> method to create two relevant monitors using the <strong class="source-inline">Performance</strong> singleton to add our custom monitors. Let’s <span class="No-Break">do it:</span></p>
			<ol>
				<li>Still in the <strong class="source-inline">World</strong> class script, create a method called <strong class="source-inline">get_received_data()</strong>. This method needs to return an integer or floating point so we can use it to create a monitor. In this case, it will return the received data statistic from the current <strong class="source-inline">ENetConnection</strong>. For that, we can use the <strong class="source-inline">pop_statistic()</strong> method, passing <strong class="source-inline">ENetConnection.HOST_TOTAL_RECEIVED_DATA</strong> as <span class="No-Break">an argument:</span><pre class="source-code">
func get_received_data():
     var enet_connection = multiplayer.multiplayer_
         peer.host
     var data_received = enet_connection.pop_statistic
         (ENetConnection.HOST_TOTAL_RECEIVED_DATA)
     return data_received</pre></li>				<li>Then, we are going to create another method called <strong class="source-inline">get_sent_data()</strong> and do the same thing, but passing <strong class="source-inline">ENetConnection.HOST_TOTAL_SENT_DATA</strong> as an argument this <span class="No-Break">time around:</span><pre class="source-code">
func get_sent_data():
  var enet_connection = multiplayer.multiplayer_
      peer.host
  var data_sent = enet_connection.pop_statistic
      (ENetConnection.HOST_TOTAL_SENT_DATA)
  return data_sent</pre></li>				<li>Now, in the <strong class="source-inline">_ready()</strong> callback, where we check to see whether this instance is the server or not, right above where we create the <strong class="source-inline">Asteroid</strong> instances, we are going to add the respective <strong class="source-inline">callable</strong> to the <strong class="source-inline">Performance</strong> singleton using the <strong class="source-inline">Performance.add_custom_monitor()</strong> method, <span class="No-Break">like so:</span><pre class="source-code">
  var callable = Callable(self, "get_received_data")
  Performance.add_custom_monitor("Network/Received
      Data", callable)
  callable = Callable(self, "get_sent_data")
  Performance.add_custom_monitor("Network/Sent
      Data", callable)
  for i in 30:
    asteroid_spawner.spawn()</pre></li>			</ol>
			<p>Now, we are able to monitor<a id="_idIndexMarker431"/> the differences between each<a id="_idIndexMarker432"/> compression mode and see the one that better fits our game. In the following figure, we compare the usage of the <strong class="source-inline">COMPRESS_ZLIB</strong> and <strong class="source-inline">COMPRESS_NONE</strong> <span class="No-Break">compression modes:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer134">
					<img alt="Figure 11.6 – A comparison between the monitors of the data sent and received using the COMPRESS_ZLIB and COMPRESS_NONE compression modes" src="image/Figure_11.06_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.6 – A comparison between the monitors of the data sent and received using the COMPRESS_ZLIB and COMPRESS_NONE compression modes</p>
			<p>Note that <a id="_idIndexMarker433"/>with the <strong class="source-inline">COMPRESS_ZLIB</strong> compression, we <a id="_idIndexMarker434"/>had a peak of 12,509 bytes on the received data, while we had a peak of 48,802 bytes in the data sent. Meanwhile, using <strong class="source-inline">COMPRESS_NONE</strong>, we peaked at 14,470 bytes in the received data and 80,234 bytes on the sent data – even with very small data packets, we have massive gains, especially on the server’s data sent metrics, so we also did a good <span class="No-Break">job there!</span></p>
			<h1 id="_idParaDest-172"><a id="_idTextAnchor284"/>Summary</h1>
			<p>In this chapter, we learned how to optimize data requests in our game to improve network performance. We focused on decreasing the number of requests being made in the game by optimizing the firing of the weapon. We saw how to create an RPC method that can change the weapon’s firing state and how to toggle the firing state based on the “shoot” action being pressed or released instead of triggering the firing on every frame in the <strong class="source-inline">_process()</strong> callback. Finally, we saw how to use the network profiler to assess the impact of these optimizations on the <span class="No-Break">game’s performance.</span></p>
			<p>After that, we tackled the issue of <strong class="source-inline">Asteroid</strong> node’s MultiplayerSynchronizers’ syncs. We disabled the automatic synchronization by setting the <strong class="bold">Visibility Update Node</strong> of <strong class="source-inline">MultiplayerSynchronizer</strong> to <strong class="bold">None</strong> and manually synced by using the <strong class="source-inline">MultiplayerSynchronizer.update_visibility()</strong> method once the player joins the game. This decreased the <strong class="source-inline">Asteroid</strong><em class="italic"> </em>node’s sync count and decreased the total network resource usage. We also saw how to measure the effectiveness of these optimizations using the debugger’s <span class="No-Break">network profiler.</span></p>
			<p>Finally, we learned about the Godot Engine’s high-level network API’s <strong class="source-inline">ENetConnection</strong> class, which offers compression methods to optimize the packet size. We saw how to use the <strong class="source-inline">ENetConnection.pop_statistic()</strong> method to create custom monitors using the <strong class="source-inline">Performance</strong> singleton to track ENetConnection’s sent and received data. We compared the usage of the <strong class="source-inline">COMPRESS_ZLIB</strong> and <strong class="source-inline">COMPRESS_NONE</strong> compression modes and found that even with very small data packets, we have massive gains, especially on the server’s data <span class="No-Break">sent metrics.</span></p>
			<p>In the next chapter, we are going to get even deeper into optimization. We are going to use interpolation and prediction to decrease the <strong class="source-inline">MultiplayerSynchronizer</strong> syncing count of the player’s spaceship while trying to keep the movement consistent throughout the game network instances. See <span class="No-Break">you there!</span></p>
		</div>
	</body></html>