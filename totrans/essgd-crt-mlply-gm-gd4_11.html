<html><head></head><body>
		<div><h1 class="chapter-number" id="_idParaDest-164"><a id="_idTextAnchor276"/>11</h1>
			<h1 id="_idParaDest-165"><a id="_idTextAnchor277"/>Optimizing Data Requests</h1>
			<p>Welcome to <a href="B18527_11.xhtml#_idTextAnchor276"><em class="italic">Chapter 11</em></a>, <em class="italic">Optimizing Data Requests</em>, where we will use the tools that we saw in <a href="B18527_10.xhtml#_idTextAnchor260"><em class="italic">Chapter 10</em></a>, <em class="italic">Debugging and Profiling the Network</em>, and finally implement improvements to the network code that we wrote in <a href="B18527_09.xhtml#_idTextAnchor188"><em class="italic">Chapter 9</em></a>, <em class="italic">Creating an Online </em><em class="italic">Adventure Prototype</em>.</p>
			<p>In this chapter, we will understand a bit more about bandwidth and throughput by analyzing the current state of our game. We saw, in the <em class="italic">Using the network profiler</em> section of <a href="B18527_10.xhtml#_idTextAnchor260"><em class="italic">Chapter 10</em></a>, <em class="italic">Debugging and Profiling the Network</em>, that we have some improvements to make, especially regarding the MultiplayerSynchronizers and the <code>QuestDatabase</code> data transmission. So, here, we will see how we can decrease the number of requests and how we can compress and decompress data to reduce the bandwidth and throughput and make our game available to more people in a more reliable and optimal way.</p>
			<p>By the end of this chapter, you will understand that there are many ways to optimize a game and most of the optimizations will depend on the specific demands of the game itself. As you progress, you will develop a keen sense and understanding of how to assess potential areas of improvement and the kind of data you are looking for, as well as some general techniques to address bottlenecks in your network code.</p>
			<p>So, this chapter will cover the following topics:</p>
			<ul>
				<li>Understanding network resources</li>
				<li>Decreasing the requests count</li>
				<li>Data compression with <code>ENetConnection</code></li>
			</ul>
			<h1 id="_idParaDest-166"><a id="_idTextAnchor278"/>Technical requirements</h1>
			<p>As mentioned in <a href="B18527_10.xhtml#_idTextAnchor260"><em class="italic">Chapter 10</em></a>, <em class="italic">Debugging and Profiling the Network</em>, <em class="italic">Part 3</em>, <em class="italic">Optimizing the Online Experience</em>, is based on the final version of the project made in <a href="B18527_09.xhtml#_idTextAnchor188"><em class="italic">Chapter 9</em></a>, <em class="italic">Creating an Online Adventure Prototype</em>, so it’s fundamental to have read, practiced, and implemented the concepts presented there.</p>
			<p>You can get the files necessary to get started with this chapter through the following link. These files have the implementations we’ve made in <a href="B18527_10.xhtml#_idTextAnchor260"><em class="italic">Chapter 10</em></a>, <em class="italic">Debugging and Profiling </em><em class="italic">the Network</em>:</p>
			<p><a href="https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0/tree/11.optimizing-data-requests">https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0/tree/11.optimizing-data-requests</a></p>
			<p>It’s also necessary that you have read and understood the concepts and tools presented in <a href="B18527_10.xhtml#_idTextAnchor260"><em class="italic">Chapter 10</em></a>, <em class="italic">Debugging and Profiling the Network</em>, so that we can move forward under the assumption that you already know what they are and how to use them properly. In particular, you will need to understand how the Debugger’s Network Profiler and Monitors tools work. So, if you aren’t sure how to use these tools, please take some time to go back and read <a href="B18527_10.xhtml#_idTextAnchor260"><em class="italic">Chapter 10</em></a><em class="italic">, Debugging and Profiling the Network,</em> so you can master these and other debugging tools.</p>
			<h1 id="_idParaDest-167"><a id="_idTextAnchor279"/>Understanding network resources</h1>
			<p>We’ve <a id="_idIndexMarker395"/>already mentioned the importance of bandwidth<a id="_idIndexMarker396"/> and throughput; in <a href="B18527_01.xhtml#_idTextAnchor018"><em class="italic">Chapter 1</em></a>, <em class="italic">Setting up a Server</em>, we even had a<a id="_idIndexMarker397"/> brief introduction to and a visual representation of the topic in <em class="italic">Figure 1</em><em class="italic">.3</em> and <em class="italic">Figure 1</em><em class="italic">.4</em>. Now it’s time to wrap our heads around these concepts, which are fundamental to network usage optimization and will be our major resources to measure the improvements we made toward our optimization goals.</p>
			<p>As a general rule, the less <a id="_idIndexMarker398"/>bandwidth and the lower the throughput<a id="_idIndexMarker399"/> of our network code, the better. Of course, we need to keep in mind that all optimizations should maintain the game experience, so we are in a very delicate position. Different from other processing, memory, and graphics optimizations, our work can’t create “beautiful accidents,” such as a processing optimization that can lead to a cool mechanic. No, our job as network engineers is to replicate the already established mechanics and effects to all peers in a network. Let’s understand how we do that.</p>
			<p>When talking about bandwidth, it might be surprising to hear that most games don’t actually need to have huge infrastructures available. For instance, a video conference takes way more bandwidth than a complex first-person shooter or a war simulator with tons of physics simulation because it works with processed data in the form of rendered images that must be passed around and re-created in each of the participants’ instances of the conference. In the case of games, most of the necessary resources to create the simulations are already available on the user’s machine, so most of our job is to communicate through messages what the computer should load to sync the client’s and server’s game instances. It’s well established that players need a bandwidth of about 5 Mbps to play most modern online multiplayer games, including huge franchises such as Call of Duty, League of Legends, and Fortnite.</p>
			<p>In <em class="italic">Part 1</em>, <em class="italic">Handshaking and Networking</em>, of this book, we saw that games work mostly with<a id="_idIndexMarker400"/> unreliable data, meaning that most of the time, we only need to know the latest data regarding an object in the game in order to sync it. This decreases the network usage a lot and allows us to focus on the specific types of data necessary to replicate the server’s game world in clients’ game worlds.</p>
			<p>The major concern in online multiplayer games is the consistency with which we can keep on the data transmission stream – ultimately, whether we can maintain the throughput of our network consistently. This can be affected by latency and other external aspects, so all we can do is design a communication architecture that takes into account how latency<a id="_idIndexMarker401"/> can affect our throughput. Of course, we will also try to keep the bandwidth to a minimum so that if a household has many devices connected to the same network, our game has room to keep the data flowing.</p>
			<p>So, keep in mind that bandwidth<a id="_idIndexMarker402"/> and throughput<a id="_idIndexMarker403"/> are our major resources and we will be looking at them to find areas that we can improve in our game.</p>
			<p>You might still be trying to work out the difference between bandwidth and throughput. So, let’s briefly assess them both. We were introduced to these concepts in <a href="B18527_01.xhtml#_idTextAnchor018"><em class="italic">Chapter 1</em></a>, <em class="italic">Setting up a Server</em>, so if you don’t quite remember what they are, take a brief moment to read the <em class="italic">What is the UDP protocol?</em> section of the chapter.</p>
			<p>We are going to use bandwidth to understand how much of the network our game needs to perform correctly, meaning how much data we expect to transmit through the network taking into account all the measurements we observed using the network profiler. This means that if we have 1,000 MultiplayerSynchronizers syncing 5 KB of data per second at any given point of our game, we will need a network with a 5 Mbps velocity. Note that this might not be consistent transmission of 5 Mbps throughout the whole game session, but it’s a recommendation based on our measurements that the game might require a network that can manage up to 5 Mbps to play smoothly. In summary, bandwidth is the amount of space available in a connection for data transmission, not the transmission itself.</p>
			<p>Now, the actual thing we are looking to optimize is<a id="_idIndexMarker404"/> the <strong class="bold">throughput</strong>, which points to how many packets and the size of these packets we are actually transmitting through the network. The throughput is our actual data flow. You can think about it using an analogy where bandwidth is a pipe and throughput is the water. We can’t stream more water than a pipe can support; instead, we can stream water up to the available pipe size. In the same way, the amount of throughput we can have is based on the available bandwidth capacity.</p>
			<p>You can see an illustration of a good and bad throughput-bandwidth relationship in the following figure:</p>
			<div><div><img alt="Figure 11.1 – An illustration of a good and bad throughput-bandwidth relationship" src="img/Figure_11.01_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1 – An illustration of a good and bad throughput-bandwidth relationship</p>
			<p>Note that with <a id="_idIndexMarker405"/>good throughput, the data sent and received is consistent and doesn’t exceed the bandwidth, whereas with bad throughput, the data packets are inconsistent in size and frequency, and some are even lost in the middle of the transmission. When packets don’t reach their destination, we call<a id="_idIndexMarker406"/> it <strong class="bold">packet loss</strong>, and this can cause lots of headaches and complaints from players.</p>
			<p>With packet loss, the client doesn’t know how to handle their game instance properly. Where should the second player’s spaceship be? Did it stop shooting? Is it shooting at an <code>Asteroid</code> node or are there no more <code>Asteroid</code> nodes to shoot? Is the <code>Asteroid</code> node they were shooting at there yet? We are going to see, in <a href="B18527_12.xhtml#_idTextAnchor285"><em class="italic">Chapter 12</em></a>, <em class="italic">Implementing Lag Compensation</em>, how to handle these situations, but ideally, we should avoid them by paying attention to the throughput.</p>
			<p>With all that said, network engineers are left in a very delicate position when the resources available for optimization don’t leave space for new mechanics to emerge. We take the already implemented mechanics and try to fit them all into the available resources, usually squeezing them to keep up with any potential changes that may require more of these <a id="_idIndexMarker407"/>resources, for instance, a new mechanic that requires more bandwidth. So, we can’t experiment a lot when optimizing the network.</p>
			<p>In the next section, let’s talk about how we can initiate our optimizations by decreasing the number of requests that our game makes. We are going to assess the problems presented in <a href="B18527_10.xhtml#_idTextAnchor260"><em class="italic">Chapter 10</em></a>, <em class="italic">Debugging and Profiling the Network</em>, such as in <code>Weapon2D</code> massive RPC count and unnecessary syncs of the <code>Asteroid</code> node’s <code>MultiplayerSynchronizer</code> node.</p>
			<h1 id="_idParaDest-168"><a id="_idTextAnchor280"/>Decreasing the requests count</h1>
			<p>Previously, in <a href="B18527_10.xhtml#_idTextAnchor260"><em class="italic">Chapter 10</em></a>, <em class="italic">Debugging and Profiling the Network</em>, we saw that there was a <a id="_idIndexMarker408"/>disproportional and unnecessary number of requests being made to the <code>Weapon2D</code> node’s <code>fire()</code> RPC method, and we even came up with what could be a solution for this issue. We also saw that we can decrease the <code>Asteroid</code> node’s sync problem by only updating it once a given player requests a synchronization using the <code>World</code> node’s <code>sync_world()</code> RPC method.</p>
			<p>In this section, we are going to implement these optimization methods and improve the overall performance of our network. Let’s start with the <code>Weapon2D</code> node issue.</p>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor281"/>Reducing the weapon fire count</h2>
			<p>Sometimes we may need to <a id="_idIndexMarker409"/>make changes in the core code of a feature in order to improve its network performance, even when its local performance stays the same, or may even drop. When talking about optimization, we are always trying to balance things out and figure out how to use the available resources in a way that allows more players to enjoy a better experience. Network resources are particularly a priority in most online multiplayer games since it’s through a good network that players will be able to get the most out of their shared experiences. So, let’s make some changes to how <code>Player2D</code> node fires <code>Weapon2D</code> node. Let’s open the <code>res://09.prototyping-space-adventure/Objects/Weapon/Weapon2D.tscn</code> scene first and carry out the following steps:</p>
			<ol>
				<li>Connect <a id="_idIndexMarker410"/>the <code>timeout</code> signal of <code>Timer</code> node to <code>Weapon2D</code> node and create a callback method named <code>_on_timer_timeout()</code>:</li>
			</ol>
			<div><div><img alt="Figure 11.2 – Timer node’s timeout signal connecting to theWeapon2D node’s _on_timer_timeout() callback" src="img/Figure_11.02_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2 – Timer node’s timeout signal connecting to theWeapon2D node’s _on_timer_timeout() callback</p>
			<ol>
				<li value="2">Open the <code>res://09.prototyping-space-adventure/Objects/Weapon/Weapon2D.gd</code> script and, in the <code>_on_timer_timeout()</code> callback, call the <code>fire()</code> method so <code>Weapon2D</code> node fires on every <code>Timer</code> node’s tic.</li>
				<li>Then, let’s create an RPC method that can be called by any peer and should also be called locally. We will use this method to change <code>Weapon2D</code>’s firing state, so it should receive a Boolean variable as an argument:<pre class="source-code">
@rpc("any_peer", "call_local")
func set_firing(firing):</pre></li>				<li>Inside this method, we will check the <code>firing</code> state, and if it’s <code>true</code>, we will call the <code>fire()</code> method <a id="_idIndexMarker411"/>as well; otherwise, we will tell <code>Timer</code> to stop:<pre class="source-code">
@rpc("any_peer", "call_local")
func set_firing(firing):
  if firing:
    fire()
  else:
    timer.stop()</pre></li>				<li>With that, we can remove the RPC annotation on the <code>fire()</code> method and the <code>if timer.is_stopped()</code> statement, since now <code>Timer</code> itself tells when <code>Weapon2D</code> fires. The <code>fire()</code> method should look like this after that:<pre class="source-code">
func fire():
  animation_player.play("fire")
  spawner.spawn(bullet_scene)
  timer.start(1.0 / fire_rate)</pre></li>			</ol>
			<p>With that, <code>Weapon2D</code> will fire based on the timeout signal from <code>Timer</code>. With the new RPC method, we can change the firing state, starting or stopping the creation of new <em class="italic">bullets</em>. The <code>Weapon2D</code> script should look like this at this point:</p>
			<pre class="source-code">
class_name Weapon2D
extends Marker2D
@export var bullet_scene: PackedScene
@export_range(0, 1, 1, "or_greater") var fire_rate = 3
@onready var spawner = $BulletSpawner2D
@onready var timer = $Timer
@onready var animation_player = $AnimationPlayer
func fire():
  animation_player.play("fire")
  spawner.spawn(bullet_scene)
  timer.start(1.0 / fire_rate)
@rpc("any_peer", "call_local")
func set_firing(firing):
  if firing:
    fire()
  else:
    timer.stop()
func _on_timer_timeout():
  fire()</pre>			<p>Now, we need to know when <a id="_idIndexMarker412"/><code>Weapon2D</code>’s firing state changes, and to do that, we will need to make some changes to <code>Player2D</code>. So, open <code>res://09.prototyping-space-adventure/Actors/Player/Player2D.gd</code> and implement the following steps:</p>
			<ol>
				<li>Remove the whole <code>_process()</code> callback code. Then, override the <code>_unhandled_input()</code> callback:<pre class="source-code">
func _unhandled_input(event):</pre></li>				<li>Inside the <code>_unhandled_input()</code> callback, we are going to check whether the <code>"shoot"</code> action was pressed or released. If pressed, we set the <code>weapon</code> firing state to <code>true</code>, and if released, it’s set to <code>false</code> (remember, we should do that using the <code>rpc()</code> method so the player shoots on all network peer instances):<pre class="source-code">
func _unhandled_input(event):
  if event.is_action_pressed("shoot"):
    weapon.rpc("set_firing", true)
  elif event.is_action_released("shoot"):
    weapon.rpc("set_firing", false)</pre></li>				<li>Next, we need to add a line to the <code>setup_multiplayer()</code> method to also toggle the <code>_unhandled_input()</code> process based on whether the instance of the spaceship is the current player or a remote player:<pre class="source-code">
func setup_multiplayer(player_id):
  var self_id = multiplayer.get_unique_id()
  var is_player = self_id == player_id
  set_process(is_player)
  set_physics_process(is_player)
  set_process_unhandled_input(is_player)</pre></li>			</ol>
			<p>With that, <code>Player2D</code> will toggle <code>Weapon2D</code>’s firing state based on whether the <code>"shoot"</code> action was pressed or released, instead of calling it every frame while <code>"shoot"</code> was pressed.</p>
			<p>Let’s make an assessment of this<a id="_idIndexMarker413"/> improvement. Turn on the network profiler and let’s see how this goes. Remember that depending on the duration of the profiling section, we may get different results, so this isn’t as accurate as a unit test; but still, it will give us a good sense of any potential improvements we’ve made. In the following figure, we have <code>Player2D</code> instance:</p>
			<div><div><img alt="Figure 11.3 – The Session 1 Debugger’s Network Profiler tab highlighting thePlayer2D node instance’s incoming RPCs" src="img/Figure_11.03_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.3 – The Session 1 Debugger’s Network Profiler tab highlighting thePlayer2D node instance’s incoming RPCs</p>
			<p>As you can see in the figure, I<a id="_idIndexMarker414"/> destroyed all 30 asteroids in a play session of around 20.0 seconds, with a total of six RPC calls from <code>Player2D</code> instance. If you compare this to <em class="italic">Figure 10</em><em class="italic">.13</em>, where we had 693 calls for a session with about the same duration, this is more than 115x fewer calls. I think we did a good job here.</p>
			<p>So, in this section, we learned how to optimize data requests in our game to improve network performance. We focused on how to decrease the number of requests being made in the game by optimizing the firing of <code>Weapon2D</code> node. We also saw how to create an RPC method that can change <code>Weapon2D</code>’s firing state, and how to toggle the firing state based on the <code>"shoot"</code> action being pressed or released instead of triggering the firing on every frame in the <code>_process()</code> callback. Finally, we saw how to use the network profiler to assess the impact of these optimizations on the game’s performance. In the next section, we will work on decreasing the requests of Asteroid’s <code>MultiplayerSynchronizer</code>.</p>
			<h2 id="_idParaDest-170"><a id="_idTextAnchor282"/>Decreasing Asteroid’s syncing count</h2>
			<p>Another<a id="_idIndexMarker415"/> issue we saw in <a href="B18527_10.xhtml#_idTextAnchor260"><em class="italic">Chapter 10</em></a>, <em class="italic">Debugging and Profiling the Network</em>, was <a id="_idIndexMarker416"/>regarding the way <code>Asteroid</code> node’s <code>MultiplayerSynchronizers</code> sync their position to players. Since they don’t move throughout the play session, there’s no need to keep updating their position and other properties on a regular basis. Instead, we only need to sync them once when the player asks <code>World</code> node to sync.</p>
			<p>So, open the <code>res://09.prototyping-space-adventure/Objects/Asteroid/Asteroid.tscn</code> scene and make the necessary changes to improve this aspect of our network engineering.</p>
			<p>Here, we just need to set the <code>MultiplayerSynchronizer</code> node’s <strong class="bold">Visibility Update Mode</strong> property to <strong class="bold">None</strong>:</p>
			<div><div><img alt="Figure 11.4 – Asteroid node’s MultiplayerSynchronizer node Visibility Update Mode property set to None" src="img/Figure_11.04_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.4 – Asteroid node’s MultiplayerSynchronizer node Visibility Update Mode property set to None</p>
			<p>With <a id="_idIndexMarker417"/>that, we just<a id="_idIndexMarker418"/> have to do the syncing manually now. The <code>MultiplayerSynchronizer</code> node has a method called <code>update_visibility()</code>, which receives an argument where we can pass the ID of the peer we want to sync with; if we pass <code>0</code>, it updates all peers instead.</p>
			<p>Note that this method takes into account the filters we set in the <em class="italic">Syncing the asteroids</em> section of <a href="B18527_09.xhtml#_idTextAnchor188"><em class="italic">Chapter 9</em></a>, <em class="italic">Creating an Online Adventure Prototype</em>, using the <code>set_visibility_for()</code> method, meaning only the peers added using this method will be synced. So, in our case, if we don’t add the peer to the filtering using the <code>set_visibility_for()</code> method, this peer won’t be synced, even if we use the <code>update_visibility()</code> method, passing the correct peer ID.</p>
			<p>The best <a id="_idIndexMarker419"/>place to manually sync the <code>Asteroid</code> node’s properties<a id="_idIndexMarker420"/> will be in the <code>World</code> class, so open the <code>res://09.prototyping-space-adventure/Levels/World.gd</code> script . Then, inside the <code>sync_world()</code> method, let’s add another group call to the <code>"Sync"</code> group, but this time to the <code>update_visibility</code> method, and pass <code>player_id</code> as an argument. The whole <code>sync_world()</code> method should look like this:</p>
			<pre class="source-code">
@rpc("any_peer", "call_local")
func sync_world():
  var player_id = multiplayer.get_remote_sender_id()
  get_tree().call_group("Sync", "set_visibility_for",
      player_id, true)
  get_tree().call_group("Sync", "update_visibility",
      player_id)</pre>			<p>With that, all <code>Asteroid</code> nodes should only sync once to every player, decreasing the total network resource usage.</p>
			<p>Let’s profile this change as well to see its impact on the overall network consumption. The following figure showcases the sync count of some asteroids’ MultiplayerSynchronizers:</p>
			<div><div><img alt="Figure 11.5 – The Session 2 Debugger’s Network Profiler highlighting the Asteroid ﻿nodes’ MultiplayerSynchronizer ﻿nodes’ sync counts" src="img/Figure_11.05_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.5 – The Session 2 Debugger’s Network Profiler highlighting the Asteroid nodes’ MultiplayerSynchronizer nodes’ sync counts</p>
			<p>Compare this to <em class="italic">Figure 10</em><em class="italic">.13</em>, where we had hundreds and hundreds of updates, and for every frame, the update count would increase. After what we’ve done, they only increase once a player enters a session and only to that specific player. Pretty good job, right?</p>
			<p>In this section, we saw how to optimize data requests by decreasing the <code>asteroid</code> nodes’ <code>MultiplayerSynchronizer</code> nodes’ syncs. To do that, we disabled the automatic <a id="_idIndexMarker421"/>synchronization <a id="_idIndexMarker422"/>by setting <code>MultiplayerSynchronizer</code> node’s <code>MultiplayerSynchronizer.update_visibility()</code> method once the player joins the game.</p>
			<p>In the upcoming section, we will see how we can compress data to optimize the packet’s size. Until now, we’ve only dealt with how many packets we send or receive, but the size of these packets is very important to handle as well. Let’s understand what we have available to do that.</p>
			<h1 id="_idParaDest-171"><a id="_idTextAnchor283"/>Compressing data with the ENetConnection class</h1>
			<p>The <a id="_idIndexMarker423"/>Godot Engine’s high-level network API includes <a id="_idIndexMarker424"/>the <code>ENetConnection</code> class. This class is available after a connection between peers, such as the server and client, is established. Using <code>ENetConnection</code>, we can tweak the peer’s connections, allowing us to tell, for instance, the compression method. We can access the <code>ENetConnection</code> instance after the peers have successfully connected. For that, we can use the <code>ENetMultiplayerPeer.host</code> property.</p>
			<p>There are five available compression methods to use in the <code>ENetConnection</code> class:</p>
			<ul>
				<li><code>CompressionMode</code> enumerator’s <code>COMPRESS_NONE</code> option. This is what the documentation says:<p class="list-inset"><em class="italic">This uses the most bandwidth but has the upside of requiring the fewest CPU resources. This option may also be used to make network debugging using tools like </em><em class="italic">Wireshark easier.</em></p></li>
				<li>ENet’s built-in <code>CompressionMode</code> enumerator’s <code>COMPRESS_RANGE_CODER</code> option. This is what the documentation says:<p class="list-inset"><em class="italic">[This is] ENet’s built-in range encoding. Works well on small packets, but is not the most efficient algorithm on packets larger than </em><em class="italic">4 KB.</em></p></li>
				<li><code>CompressionMode</code> enumerator’s <code>COMPRESS_FASTLZ</code> option. This is what the documentation says:<p class="list-inset"><em class="italic">This option uses less CPU resources compared to COMPRESS_ZLIB, at the expense of using </em><em class="italic">more bandwidth.</em></p></li>
				<li><code>CompressionMode</code> enumerator’s <code>COMPRESS_ZLIB</code> option. This is what the documentation says:<p class="list-inset"><em class="italic">This option uses less bandwidth compared to COMPRESS_FASTLZ , at the expense of using more </em><em class="italic">CPU resources.</em></p></li>
				<li><code>CompressionMode</code> enumerator’s <code>COMPRESS_ZSTD</code> option. This is what the documentation says:<p class="list-inset"><em class="italic">Note that this algorithm is not very efficient on packets smaller than 4 KB. Therefore, it’s recommended to use other compression algorithms in </em><em class="italic">most cases.</em></p></li>
			</ul>
			<p>You can find more about <code>ENetConnection</code> and <code>CompressionMode</code> in the Godot docs through the following link:</p>
			<p><a href="https://docs.godotengine.org/en/stable/classes/class_enetconnection.html#enum-enetconnection-compressionmode">https://docs.godotengine.org/en/stable/classes/class_enetconnection.html#enum-enetconnection-compressionmode</a></p>
			<p>It’s time to <a id="_idIndexMarker425"/>work on the size of the data we are <a id="_idIndexMarker426"/>transmitting through the network. In the following steps, we will implement compression to decrease our game’s packet size and optimize the transmission of data through the network. Note that, as always, there’s a trade-off between the bandwidth and CPU resources. Our game currently doesn’t have any issues regarding CPU usage. So, at this point, we can focus on optimizing the network resources. For that, we can use the <code>COMPRESS_ZLIB</code> compression mode. To do that, let’s open the <code>res://09.prototyping-space-adventure/Authentication.gd</code> script and complete the following steps:</p>
			<ol>
				<li>Right before we set <code>multiplayer_peer</code> to the peer in the <code>_ready()</code> callback, we are going to change the <code>ENetConnection</code> compression mode. For that, we access the <code>host</code> property and use the <code>compress()</code> method, passing <code>EnetConnection.COMPRESS_ZLIB</code> as an argument:<pre class="source-code">
func _ready():
  if multiplayer.is_server():
    peer.create_server(PORT)
    load_database()
  else:
    peer.create_client(ADDRESS, PORT)
    peer.host.compress(EnetConnection.COMPRESS_ZLIB)
  multiplayer.multiplayer_peer = peer</pre><p class="list-inset">We need to do this here because the compression mode needs to be set before the connection is established, which happens after we set the <code>multiplayer.multiplayer_peer</code> property.</p></li>				<li>We also <a id="_idIndexMarker427"/>need to do the same thing in<a id="_idIndexMarker428"/> the <code>res://09.prototyping-spaceadventure/LoggingScreen.gd</code> script so that this connection also matches the server’s connection compression. Again, before setting <code>multiplayer.multiplayer_peer</code>, we set ENetConnection’s compression to <code>COMPRESS_ZLIB</code>:<pre class="source-code">
func _ready():
  peer.create_client(ADDRESS, PORT)
  peer.host.compress(ENetConnection.COMPRESS_ZLIB)
  multiplayer.multiplayer_peer = peer</pre></li>			</ol>
			<p>With that, we are able to change the compression mode used in our game’s network connection as soon as the players join the game’s world. For now, this won’t make a huge impact. As we saw in the previous quotes from the documentation, most of the compression algorithms aim at having data packets be either below 4 KB or above 4 KB. Our game’s packets currently haven’t even reached the Kilobytes yet, so…this may not have a big, if any, impact at this point, to be honest.</p>
			<p>If we want to<a id="_idIndexMarker429"/> measure how much bandwidth we are<a id="_idIndexMarker430"/> using and get at least a glance at any possible improvements, we can use the Debugger’s <code>EnetConnection</code> instances’ sent and received data. For that, we can use the <code>ENetConnection.pop_statistic()</code> method to create two relevant monitors using the <code>Performance</code> singleton to add our custom monitors. Let’s do it:</p>
			<ol>
				<li>Still in the <code>World</code> class script, create a method called <code>get_received_data()</code>. This method needs to return an integer or floating point so we can use it to create a monitor. In this case, it will return the received data statistic from the current <code>ENetConnection</code>. For that, we can use the <code>pop_statistic()</code> method, passing <code>ENetConnection.HOST_TOTAL_RECEIVED_DATA</code> as an argument:<pre class="source-code">
func get_received_data():
     var enet_connection = multiplayer.multiplayer_
         peer.host
     var data_received = enet_connection.pop_statistic
         (ENetConnection.HOST_TOTAL_RECEIVED_DATA)
     return data_received</pre></li>				<li>Then, we are going to create another method called <code>get_sent_data()</code> and do the same thing, but passing <code>ENetConnection.HOST_TOTAL_SENT_DATA</code> as an argument this time around:<pre class="source-code">
func get_sent_data():
  var enet_connection = multiplayer.multiplayer_
      peer.host
  var data_sent = enet_connection.pop_statistic
      (ENetConnection.HOST_TOTAL_SENT_DATA)
  return data_sent</pre></li>				<li>Now, in the <code>_ready()</code> callback, where we check to see whether this instance is the server or not, right above where we create the <code>Asteroid</code> instances, we are going to add the respective <code>callable</code> to the <code>Performance</code> singleton using the <code>Performance.add_custom_monitor()</code> method, like so:<pre class="source-code">
  var callable = Callable(self, "get_received_data")
  Performance.add_custom_monitor("Network/Received
      Data", callable)
  callable = Callable(self, "get_sent_data")
  Performance.add_custom_monitor("Network/Sent
      Data", callable)
  for i in 30:
    asteroid_spawner.spawn()</pre></li>			</ol>
			<p>Now, we are able to monitor<a id="_idIndexMarker431"/> the differences between each<a id="_idIndexMarker432"/> compression mode and see the one that better fits our game. In the following figure, we compare the usage of the <code>COMPRESS_ZLIB</code> and <code>COMPRESS_NONE</code> compression modes:</p>
			<div><div><img alt="Figure 11.6 – A comparison between the monitors of the data sent and received using the COMPRESS_ZLIB and COMPRESS_NONE compression modes" src="img/Figure_11.06_B18527.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.6 – A comparison between the monitors of the data sent and received using the COMPRESS_ZLIB and COMPRESS_NONE compression modes</p>
			<p>Note that <a id="_idIndexMarker433"/>with the <code>COMPRESS_ZLIB</code> compression, we <a id="_idIndexMarker434"/>had a peak of 12,509 bytes on the received data, while we had a peak of 48,802 bytes in the data sent. Meanwhile, using <code>COMPRESS_NONE</code>, we peaked at 14,470 bytes in the received data and 80,234 bytes on the sent data – even with very small data packets, we have massive gains, especially on the server’s data sent metrics, so we also did a good job there!</p>
			<h1 id="_idParaDest-172"><a id="_idTextAnchor284"/>Summary</h1>
			<p>In this chapter, we learned how to optimize data requests in our game to improve network performance. We focused on decreasing the number of requests being made in the game by optimizing the firing of the weapon. We saw how to create an RPC method that can change the weapon’s firing state and how to toggle the firing state based on the “shoot” action being pressed or released instead of triggering the firing on every frame in the <code>_process()</code> callback. Finally, we saw how to use the network profiler to assess the impact of these optimizations on the game’s performance.</p>
			<p>After that, we tackled the issue of <code>Asteroid</code> node’s MultiplayerSynchronizers’ syncs. We disabled the automatic synchronization by setting the <code>MultiplayerSynchronizer</code> to <code>MultiplayerSynchronizer.update_visibility()</code> method once the player joins the game. This decreased the <code>Asteroid</code><em class="italic"> </em>node’s sync count and decreased the total network resource usage. We also saw how to measure the effectiveness of these optimizations using the debugger’s network profiler.</p>
			<p>Finally, we learned about the Godot Engine’s high-level network API’s <code>ENetConnection</code> class, which offers compression methods to optimize the packet size. We saw how to use the <code>ENetConnection.pop_statistic()</code> method to create custom monitors using the <code>Performance</code> singleton to track ENetConnection’s sent and received data. We compared the usage of the <code>COMPRESS_ZLIB</code> and <code>COMPRESS_NONE</code> compression modes and found that even with very small data packets, we have massive gains, especially on the server’s data sent metrics.</p>
			<p>In the next chapter, we are going to get even deeper into optimization. We are going to use interpolation and prediction to decrease the <code>MultiplayerSynchronizer</code> syncing count of the player’s spaceship while trying to keep the movement consistent throughout the game network instances. See you there!</p>
		</div>
	</body></html>