<html><head></head><body>
<div><div><div><h1 id="_idParaDest-138" class="chapter-number"><a id="_idTextAnchor241"/>8</h1>
			<h1 id="_idParaDest-139"><a id="_idTextAnchor242"/>System Tick (SysTick) Timer</h1>
			<p>In this chapter, we will<a id="_idIndexMarker567"/> learn about the <strong class="bold">System Tick</strong> (<strong class="bold">SysTick</strong>) timer, an important core peripheral in all Arm Cortex microcontrollers. We will begin by introducing the SysTick timer and discussing its most common use cases. Following this, we will explore the SysTick timer registers in detail. Finally, we will develop a driver for the SysTick timer.</p>
			<p>In this chapter, we’re going to cover the following main topics:<a id="_idTextAnchor243"/></p>
			<ul>
				<li>Introduction to the SysTick timer<a id="_idTextAnchor244"/></li>
				<li>Developing a driver for the SysTick timer</li>
			</ul>
			<p>By the end of this chapter, you will have a good understanding of the SysTick timer and be able to effectively implement and utilize it in your Arm Cortex-M projects.</p>
			<h1 id="_idParaDest-140"><a id="_idTextAnchor245"/>Technical requirements</h1>
			<p>All the code examples for this chapter can be found on GitHub at</p>
			<p><a href="https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming">https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming</a>.</p>
			<h1 id="_idParaDest-141"><a id="_idTextAnchor246"/>Introduction to the SysTick timer</h1>
			<p>The <strong class="bold">System Tick</strong> timer, commonly <a id="_idIndexMarker568"/>known as <strong class="bold">SysTick</strong>, is a fundamental component of all Arm Cortex microcontrollers. Regardless of the processor core—whether it’s Cortex-M0, Cortex-M1, or Cortex-M7—and the silicon manufacturer—be it STMicroelectronics, Texas Instruments, or any other—every Arm Cortex microcontroller includes a SysTick timer. In this section, we will learn about this essential peripheral and explore its registers in detail.</p>
			<h2 id="_idParaDest-142"><a id="_idTextAnchor247"/>Overview of the SysTick timer</h2>
			<p>The SysTick timer<a id="_idIndexMarker569"/> is a <strong class="bold">24-bit down counter</strong> integral to all Arm Cortex-M processors. It is designed to offer a configurable time base that can be used for<a id="_idIndexMarker570"/> various<a id="_idIndexMarker571"/> purposes, such as <strong class="bold">task scheduling</strong>, <strong class="bold">system monitoring</strong>, and <strong class="bold">time tracking</strong>. This timer<a id="_idIndexMarker572"/> provides us with a simple and efficient means of <strong class="bold">generating periodic interrupts</strong> and serves as a cornerstone for implementing system timing functions, including <strong class="bold">operating system</strong> (<strong class="bold">OS</strong>) tick generation<a id="_idIndexMarker573"/> for <strong class="bold">real-time operating systems</strong> (<strong class="bold">RTOSs</strong>). Using SysTick makes our code more portable since it is part of the core and not a vendor-specific peripheral.</p>
			<p>The key features of the <a id="_idIndexMarker574"/>SysTick timer include the following:</p>
			<ul>
				<li><strong class="bold">24-bit Reloadable Counter</strong>: The counter decrements from a specified value to zero, then reloads automatically to provide a continuous timing operation</li>
				<li><strong class="bold">Core Integration</strong>: Being part of the core, it requires minimal configuration and offers low-latency interrupt handling</li>
				<li><strong class="bold">Configurable Clock Source</strong>: SysTick can operate either from the core clock or an external reference clock, providing flexibility in timing accuracy and power consumption</li>
				<li><strong class="bold">Interrupt Generation</strong>: When<a id="_idIndexMarker575"/> the counter reaches zero, it can trigger an interrupt</li>
			</ul>
			<p>The SysTick timer <a id="_idIndexMarker576"/>typically serves three primary use cases:</p>
			<ul>
				<li><strong class="bold">OS Tick Generation</strong>: In an RTOS environment, SysTick is commonly used to generate the system tick interrupt, which drives the OS scheduler</li>
				<li><strong class="bold">Periodic Task Execution</strong>: It can be used to trigger regular tasks, such as sensor sampling or communication checks</li>
				<li><strong class="bold">Time Delay Functions</strong>: SysTick can provide precise delays for various timing functions within the<a id="_idIndexMarker577"/> firmware</li>
			</ul>
			<p>Now let’s explore the registers in the SysTick timer.</p>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor248"/>SysTick timer registers</h2>
			<p>The SysTick <a id="_idIndexMarker578"/>timer consists of four primary<a id="_idTextAnchor249"/> registers:</p>
			<ul>
				<li>SysTick Control and Status Register<a id="_idTextAnchor250"/> (<code>SYST_CSR</code>)</li>
				<li>SysTick Reload Value Register (<code>SYST_RVR</code>)</li>
				<li>SysTick Current Value Register (<code>SYST_CVR</code>)</li>
				<li>SysTick Calibration Value Register (<code>SYST_CALIB</code>)</li>
			</ul>
			<p>Let’s analyze them one by one, starting with the Control and Status Re<a id="_idTextAnchor251"/>gister.</p>
			<h3>The SysTick Control and Statu<a id="_idTextAnchor252"/><a id="_idTextAnchor253"/>s Register (SYST_CSR)</h3>
			<p>The <code>SYST_CSR</code> register controls the <a id="_idIndexMarker579"/>SysTick timer’s operation and provides status information. It has the following bits:</p>
			<ul>
				<li><strong class="bold">ENABLE (Bit 0)</strong>: Enables or disables the SysTick counter</li>
				<li><strong class="bold">TICKINT (Bit 1)</strong>: Enables or disables the SysTick interrupt</li>
				<li><strong class="bold">CLKSOURCE (Bit 2)</strong>: Selects the clock source (0 = external reference clock, 1 = processor clock)</li>
				<li><strong class="bold">COUNTFLAG (Bit 16)</strong>: Indicates whether the counter has reached zero since the last read (1 = yes, 0 = no)</li>
			</ul>
			<p>This is the structure of the SysTick Control and Status Register:</p>
			<div><div><img src="img/B21914_08_1.jpg" alt="Figure 8.1: The SysTick Control and Status Register" width="960" height="220"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1: The SysTick Control and Status Register</p>
			<p>The next regi<a id="_idTextAnchor254"/>ster is the SysTick Reload Value Register <a id="_idTextAnchor255"/>(<code>SYST_RVR</code>).</p>
			<h3>The SysTick Reload Value Register (SYST_RVR)</h3>
			<p>This register specifies the start value to<a id="_idIndexMarker580"/> load into the SysTick Current Value Register. It is crucial for setting the timer’s period and understanding its bit assignments and calculations is essential for effective SysTick co<a id="_idTextAnchor256"/>nfiguration.</p>
			<p>It has the following fields:</p>
			<ul>
				<li><strong class="bold">Bits [31:24] Reserved</strong>: These bits are reserved</li>
				<li><code>SYST_CVR</code> register when the counter is enabled and when it reaches zero</li>
			</ul>
			<p>This is the structure of the SysTick Reload Value Register:</p>
			<div><div><img src="img/B21914_08_2.jpg" alt="Figure 8.2: The SysTick Reload Value Register" width="902" height="114"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2: The SysTick Reload Value Register</p>
			<p>Since SysTick is a 24-bit timer, the <code>RELOAD</code> value can be any value in the range <strong class="bold">0x00000001</strong> to <strong class="bold">0x00FFFFFF</strong>.</p>
			<p>To calculate the <code>RELOAD</code> value based on the desired timer period, we determine the number of clock cycles for the desired period, and then subtract 1 from this number to get the <code>RELOAD</code> value.</p>
			<p>For example, if the <code>RELOAD</code> value would be calculated as follows:</p>
			<ol>
				<li>Calculate the number of clock cycles in 1 ms:<p class="list-inset"><strong class="bold">Clock cycles = 16,000,000 cycles/second * 0.001 second = </strong><strong class="bold">16,000 cycles</strong></p><p class="list-inset">Note: 1ms = 0.001 second</p></li>
				<li>Subtract 1 from the calculated number of clock cycles:<p class="list-inset"><strong class="bold"> RELOAD = 16,000 - 1 = 15,999</strong> since<a id="_idIndexMarker581"/> counting from 0 to 15,999 will give us 16000 ticks.</p></li>
			</ol>
			<p>Meaning, to configure the SysTick timer for a 1 ms period with a 16 MHz clock, we would set the <code>RELOAD</code> value to <code>SYST_CVR</code>).</p>
			<h3>The SysTick Current Value Register</h3>
			<p>The <a id="_idIndexMarker582"/>SysTick Current V<a id="_idTextAnchor258"/>alue Register (<code>SYST_CVR</code>) holds the current value of the SysTick counter. We can use this register to monitor the countdown process and to reset the counter when necessary.</p>
			<p>It has the following fields:</p>
			<ul>
				<li><strong class="bold">Bits [31:24] Reserved</strong>: These bits are reserved and should not be modified. They must be written as zero.</li>
				<li><code>COUNTFLAG</code> bit in the SysTick Control and Status Register (<code>SYST_CSR</code>). This is the SysTick Current Value Register:</li>
			</ul>
			<div><div><img src="img/B21914_08_3.jpg" alt="Figure 8.3: The SysTick Current Value Register" width="902" height="114"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3: The SysTick Current Value Register</p>
			<h3>The SysTick Calibration Value Register</h3>
			<p>The final register of<a id="_idIndexMarker583"/> the SysTick timer is the SysTick Calibration Value Register (<code>SYST_CALIB</code>). This register provides us with the calibration properties of the SysTick timer.</p>
			<p>The names of these registers are slightly different in the STM32 header files. <em class="italic">Table 8.1</em> provides a clear correspondence between the register names used in the <em class="italic">Arm Generic User Guide</em> documentation and those in the STM32-specific header files. This correspondence will help us understand and reference them correctly in our code.</p>
			<table id="table001-5" class="T---Table _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Header">
							<p><strong class="bold">Function</strong></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><strong class="bold">Arm Generic </strong><strong class="bold">User Guide</strong></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><strong class="bold">STM32 </strong><strong class="bold">Header File</strong></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p>Control and Status</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>SYST_CSR</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>SysTick-&gt;CTRL</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p>Reload Value</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>SYST_RVR</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>SysTick-&gt;LOAD</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p>Current Value</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>SYST_CVR</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>SysTick-&gt;VAL</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p>Calibration Value</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>SYST_CALIB</p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>SysTick-&gt;CALIB</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 8.1: Correspondence of SysTick register names</p>
			<p>In the next section, we will use the information we have learned to develop a driver for the SysTick timer.</p>
			<h1 id="_idParaDest-144"><a id="_idTextAnchor259"/>Developing a driver for the SysTick timer</h1>
			<p>In this section, we will <a id="_idIndexMarker584"/>develop a driver for the SysTick timer to generate precise delays.</p>
			<p>Let’s start by making a copy of our last project in our IDE, following the steps we learned in <a href="B21914_07.xhtml#_idTextAnchor217"><em class="italic">Chapter 7</em></a>. Rename the copied project to <code>SysTick</code>. Next, create a new file named <code>systick.c</code> in the <code>Src</code> folder and another file named <code>systick.h</code> in the <code>Inc</code> folder, just like we did for the GPIO drivers in the previous lesson.</p>
			<p>Populate your <code>systick.c</code> file with the following code:</p>
			<pre class="source-code">
<strong class="bold">#include</strong> "systick.h"
<strong class="bold">#define</strong> CTRL_ENABLE        (1U&lt;&lt;0)
<strong class="bold">#define</strong> CTRL_CLCKSRC    (1U&lt;&lt;2)
<strong class="bold">#define</strong> CTRL_COUNTFLAG    (1U&lt;&lt;16)
/*By default, the frequency of the MCU is 16Mhz*/
<strong class="bold">#define</strong> ONE_MSEC_LOAD     16000
<strong class="bold">void systick_msec_delay</strong>(uint32_t delay)
{
    /*Load number of clock cycles per millisecond*/
    SysTick-&gt;LOAD =  ONE_MSEC_LOAD - 1;
    /*Clear <strong class="bold">systick</strong> current value register*/
    SysTick-&gt;VAL = 0;
    /*Select internal clock source*/
    SysTick-&gt;CTRL = CTRL_CLCKSRC;
    /*Enable <strong class="bold">systick</strong>*/
    SysTick-&gt;CTRL |=CTRL_ENABLE;
    <strong class="bold">for</strong>(<strong class="bold">int</strong> i = 0; i &lt; delay; i++)
    {
        <strong class="bold">while</strong>((SysTick-&gt;CTRL &amp; CTRL_COUNTFLAG) == 0){}
    }
    /*Disable <strong class="bold">systick</strong>*/
    SysTick-&gt;CTRL = 0;
}</pre>			<p>Let’s break it down.</p>
			<p>We start with <a id="_idIndexMarker585"/>the header file inclusion:</p>
			<pre class="source-code">
#include "systick.h"</pre>			<p>This line includes the header file, <code>systick.h</code>, which in turn includes <code>stm32fxx.h</code> to provide access to the register definitions.</p>
			<p>Next, we define all the macros we need:</p>
			<ul>
				<li><code>#define CTRL_ENABLE (1U &lt;&lt; 0)</code>: Macro to enable the SysTick timer.</li>
				<li><code>#define CTRL_CLKSRC (1U &lt;&lt; 2)</code>: Macro to select the internal clock source for the SysTick timer.</li>
				<li><code>#define CTRL_COUNTFLAG (1U &lt;&lt; 16)</code>: Macro to check the <code>COUNTFLAG</code> bit, which indicates when the timer has counted to zero.</li>
				<li><code>#define ONE_MSEC_LOAD 16000</code>: Macro to define the number of clock cycles in 1 millisecond. This assumes the microcontroller’s clock frequency is 16 MHz. This is the default configuration of the NUCLEO-F411 development board.</li>
			</ul>
			<p>Next, we move on to the function implementation.</p>
			<p>First, we have the following:</p>
			<pre class="source-code">
SysTick-&gt;LOAD = ONE_MSEC_LOAD - 1;</pre>			<p>This line loads the SysTick timer with the number of clock cycles for 1 millisecond.</p>
			<p>Then, we clear the Current Value register with the following to reset the timer:</p>
			<pre class="source-code">
SysTick-&gt;VAL = 0;</pre>			<p>Next, we select the internal clock source:</p>
			<pre class="source-code">
SysTick-&gt;CTRL = CTRL_CLKSRC;</pre>			<p>To enable the SysTick timer, we use the following:</p>
			<pre class="source-code">
SysTick-&gt;CTRL |= CTRL_ENABLE;</pre>			<p>Now, we enter the loop that handles the delay:</p>
			<pre class="source-code">
for (int i = 0; i &lt; delay; i++)
{
    while ((SysTick-&gt;CTRL &amp; CTRL_COUNTFLAG) == 0) {}
}</pre>			<p>This loop runs for the <a id="_idIndexMarker586"/>specified delay duration. Inside each iteration, it waits for the <code>COUNTFLAG</code> bit to be set, which indicates the timer has counted down to zero.</p>
			<p>Finally, we disable the SysTick timer:</p>
			<pre class="source-code">
SysTick-&gt;CTRL = 0;</pre>			<p>And that’s it! With these steps, we’ve successfully implemented a delay function using the SysTick timer.</p>
			<p>Our next task is to populate the <code>systick.h</code> file.</p>
			<p>Here is the code:</p>
			<pre class="source-code">
#ifndef SYSTICK_H_
#define SYSTICK_H_
#include &lt;stdint.h&gt;
#include "stm32f4xx.h"
void systick_msec_delay(uint32_t delay);
#endif</pre>			<p>Over here, the <code>#include &lt;stdint.h&gt;</code> directive is needed to ensure that we have access to standard integer type definitions provided by the C standard library. These definitions include fixed-width integer types such as <code>uint32_t</code>, <code>int32_t</code>, <code>uint16_t</code>, and so on, which are essential for writing portable and clear code, especially in embedded systems programming.</p>
			<p>With the driver files complete, we are now ready to test inside <code>main.c</code>.</p>
			<p>First, let’s enhance<a id="_idIndexMarker587"/> our <code>gpio.c</code> file by adding a new function that toggles the LED. This will simplify our code by allowing us to toggle the LED with a single function call instead of calling <code>led_on()</code> and <code>led_off()</code> separately.</p>
			<p>Add the following function to your <code>gpio.c</code> file:</p>
			<pre class="source-code">
<strong class="bold">#define LED_PIN            (1U&lt;<a id="_idTextAnchor260"/>&lt;5)</strong>
void led_toggle(void)
{
    /*Toggle PA5*/
    GPIOA-&gt;ODR ^=LED_PIN;
}</pre>			<p>This function toggles the state of the LED connected to pin PA5 by using the bitwise <code>XOR</code> operation on<a id="_idIndexMarker588"/> the <strong class="bold">Output Data </strong><strong class="bold">Register</strong> (<strong class="bold">ODR</strong>).</p>
			<p>Next, declare this function in the <code>gpio.h</code> file by adding the following line:</p>
			<pre class="source-code">
void led_toggle(void)</pre>			<p>Finally, update your <code>main.c</code> file as shown here to call the SysTick delay and LED toggle functions:</p>
			<pre class="source-code">
#include "gpio.h"
#include "systick.h"
int main(void)
{
    /*Initialize LED*/
    led_init();
    while(1){
        /*Delay for 500ms*/
        systick_msec_delay(500);
           /* Toggle the LED */
        led_toggle();
    }
}</pre>			<p>In this example, we <a id="_idIndexMarker589"/>are <strong class="bold">toggling the LED at a 500ms interval</strong>. Build the project and run it on your development board. You should see the green LED blinking. To experiment further, you can modify the delay value and observe how the blinking rate of the LED changes.</p>
			<h1 id="_idParaDest-145"><a id="_idTextAnchor261"/>Summary</h1>
			<p>In this chapter, we explored the SysTick timer, a core peripheral of all Arm Cortex microcontrollers. We began with an introduction to the SysTick timer, discussing its significance and common applications, such as generating OS ticks in real-time operating systems, executing periodic tasks, and providing precise time delays.</p>
			<p>We then examined the SysTick timer’s registers in detail. These included the Control and Status Register (<code>SYST_CSR</code>), which manages the timer’s operation and status; the Reload Value Register (<code>SYST_RVR</code>), which sets the timer’s countdown period; the Current Value Register (<code>SYST_CVR</code>), which holds the current value of the countdown; and the Calibration Value Register (<code>SYST_CALIB</code>), which provides essential calibration properties for accurate timing. We also provided a comparison between the register names used in the Arm Generic User Guide and those in the STM32 header files to ensure clear correspondence for accurate coding.</p>
			<p>The chapter concluded with the development of a SysTick timer driver. We walked through the creation and implementation of the <code>systick_msec_delay</code> function, which introduces millisecond delays using the SysTick timer. To test the driver, we integrated it with GPIO functions to toggle our green LED, demonstrating how to achieve precise timing and control in embedded systems.</p>
			<p>In the next chapter, we shall learn about another timer peripheral. Unlike the SysTick timer, the configuration of this timer peripheral is specific to STM32 microcontrollers.</p>
		</div>
	</div>
</div>
</body></html>