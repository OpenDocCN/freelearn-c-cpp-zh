<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer085">
			<h1 id="_idParaDest-138" class="chapter-number"><a id="_idTextAnchor241"/>8</h1>
			<h1 id="_idParaDest-139"><a id="_idTextAnchor242"/>System Tick (SysTick) Timer</h1>
			<p>In this chapter, we will<a id="_idIndexMarker567"/> learn about the <strong class="bold">System Tick</strong> (<strong class="bold">SysTick</strong>) timer, an important core peripheral in all Arm Cortex microcontrollers. We will begin by introducing the SysTick timer and discussing its most common use cases. Following this, we will explore the SysTick timer registers in detail. Finally, we will develop a driver for the <span class="No-Break">SysTick timer.</span></p>
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span><a id="_idTextAnchor243"/></p>
			<ul>
				<li>Introduction to the <span class="No-Break">SysTick timer</span><a id="_idTextAnchor244"/></li>
				<li>Developing a driver for the <span class="No-Break">SysTick timer</span></li>
			</ul>
			<p>By the end of this chapter, you will have a good understanding of the SysTick timer and be able to effectively implement and utilize it in your Arm <span class="No-Break">Cortex-M projects.</span></p>
			<h1 id="_idParaDest-140"><a id="_idTextAnchor245"/>Technical requirements</h1>
			<p>All the code examples for this chapter can be found on <span class="No-Break">GitHub at</span></p>
			<p><a href="https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming"><span class="No-Break">https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-141"><a id="_idTextAnchor246"/>Introduction to the SysTick timer</h1>
			<p>The <strong class="bold">System Tick</strong> timer, commonly <a id="_idIndexMarker568"/>known as <strong class="bold">SysTick</strong>, is a fundamental component of all Arm Cortex microcontrollers. Regardless of the processor core—whether it’s Cortex-M0, Cortex-M1, or Cortex-M7—and the silicon manufacturer—be it STMicroelectronics, Texas Instruments, or any other—every Arm Cortex microcontroller includes a SysTick timer. In this section, we will learn about this essential peripheral and explore its registers <span class="No-Break">in detail.</span></p>
			<h2 id="_idParaDest-142"><a id="_idTextAnchor247"/>Overview of the SysTick timer</h2>
			<p>The SysTick timer<a id="_idIndexMarker569"/> is a <strong class="bold">24-bit down counter</strong> integral to all Arm Cortex-M processors. It is designed to offer a configurable time base that can be used for<a id="_idIndexMarker570"/> various<a id="_idIndexMarker571"/> purposes, such as <strong class="bold">task scheduling</strong>, <strong class="bold">system monitoring</strong>, and <strong class="bold">time tracking</strong>. This timer<a id="_idIndexMarker572"/> provides us with a simple and efficient means of <strong class="bold">generating periodic interrupts</strong> and serves as a cornerstone for implementing system timing functions, including <strong class="bold">operating system</strong> (<strong class="bold">OS</strong>) tick generation<a id="_idIndexMarker573"/> for <strong class="bold">real-time operating systems</strong> (<strong class="bold">RTOSs</strong>). Using SysTick makes our code more portable since it is part of the core and not a <span class="No-Break">vendor-specific peripheral.</span></p>
			<p>The key features of the <a id="_idIndexMarker574"/>SysTick timer include <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">24-bit Reloadable Counter</strong>: The counter decrements from a specified value to zero, then reloads automatically to provide a continuous <span class="No-Break">timing operation</span></li>
				<li><strong class="bold">Core Integration</strong>: Being part of the core, it requires minimal configuration and offers low-latency <span class="No-Break">interrupt handling</span></li>
				<li><strong class="bold">Configurable Clock Source</strong>: SysTick can operate either from the core clock or an external reference clock, providing flexibility in timing accuracy and <span class="No-Break">power consumption</span></li>
				<li><strong class="bold">Interrupt Generation</strong>: When<a id="_idIndexMarker575"/> the counter reaches zero, it can trigger <span class="No-Break">an interrupt</span></li>
			</ul>
			<p>The SysTick timer <a id="_idIndexMarker576"/>typically serves three primary <span class="No-Break">use cases:</span></p>
			<ul>
				<li><strong class="bold">OS Tick Generation</strong>: In an RTOS environment, SysTick is commonly used to generate the system tick interrupt, which drives the <span class="No-Break">OS scheduler</span></li>
				<li><strong class="bold">Periodic Task Execution</strong>: It can be used to trigger regular tasks, such as sensor sampling or <span class="No-Break">communication checks</span></li>
				<li><strong class="bold">Time Delay Functions</strong>: SysTick can provide precise delays for various timing functions within <span class="No-Break">the</span><span class="No-Break"><a id="_idIndexMarker577"/></span><span class="No-Break"> firmware</span></li>
			</ul>
			<p>Now let’s explore the registers in the <span class="No-Break">SysTick timer.</span></p>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor248"/>SysTick timer registers</h2>
			<p>The SysTick <a id="_idIndexMarker578"/>timer consists of four <span class="No-Break">primary<a id="_idTextAnchor249"/> registers:</span></p>
			<ul>
				<li>SysTick Control and Status <span class="No-Break">Register<a id="_idTextAnchor250"/> (</span><span class="No-Break"><strong class="source-inline">SYST_CSR</strong></span><span class="No-Break">)</span></li>
				<li>SysTick Reload Value <span class="No-Break">Register (</span><span class="No-Break"><strong class="source-inline">SYST_RVR</strong></span><span class="No-Break">)</span></li>
				<li>SysTick Current Value <span class="No-Break">Register (</span><span class="No-Break"><strong class="source-inline">SYST_CVR</strong></span><span class="No-Break">)</span></li>
				<li>SysTick Calibration Value <span class="No-Break">Register (</span><span class="No-Break"><strong class="source-inline">SYST_CALIB</strong></span><span class="No-Break">)</span></li>
			</ul>
			<p>Let’s analyze them one by one, starting with the Control and <span class="No-Break">Status Re<a id="_idTextAnchor251"/>gister.</span></p>
			<h3>The SysTick Control and Statu<a id="_idTextAnchor252"/><a id="_idTextAnchor253"/>s Register (SYST_CSR)</h3>
			<p>The <strong class="source-inline">SYST_CSR</strong> register controls the <a id="_idIndexMarker579"/>SysTick timer’s operation and provides status information. It has the <span class="No-Break">following bits:</span></p>
			<ul>
				<li><strong class="bold">ENABLE (Bit 0)</strong>: Enables or disables the <span class="No-Break">SysTick counter</span></li>
				<li><strong class="bold">TICKINT (Bit 1)</strong>: Enables or disables the <span class="No-Break">SysTick interrupt</span></li>
				<li><strong class="bold">CLKSOURCE (Bit 2)</strong>: Selects the clock source (0 = external reference clock, 1 = <span class="No-Break">processor clock)</span></li>
				<li><strong class="bold">COUNTFLAG (Bit 16)</strong>: Indicates whether the counter has reached zero since the last read (1 = yes, 0 = <span class="No-Break">no)</span></li>
			</ul>
			<p>This is the structure of the SysTick Control and <span class="No-Break">Status Register:</span></p>
			<div>
				<div id="_idContainer082" class="IMG---Figure">
					<img src="image/B21914_08_1.jpg" alt="Figure 8.1: The SysTick Control and Status Register" width="960" height="220"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1: The SysTick Control and Status Register</p>
			<p>The next regi<a id="_idTextAnchor254"/>ster is the SysTick Reload Value <span class="No-Break">Register <a id="_idTextAnchor255"/>(</span><span class="No-Break"><strong class="source-inline">SYST_RVR</strong></span><span class="No-Break">).</span></p>
			<h3>The SysTick Reload Value Register (SYST_RVR)</h3>
			<p>This register specifies the start value to<a id="_idIndexMarker580"/> load into the SysTick Current Value Register. It is crucial for setting the timer’s period and understanding its bit assignments and calculations is essential for effective <span class="No-Break">SysTick co<a id="_idTextAnchor256"/>nfiguration.</span></p>
			<p>It has the <span class="No-Break">following fields:</span></p>
			<ul>
				<li><strong class="bold">Bits [31:24] Reserved</strong>: These bits <span class="No-Break">are reserved</span></li>
				<li><strong class="bold">Bits [23:0] RELOAD</strong>: This field specifies the value that the SysTick timer will load into the <strong class="source-inline">SYST_CVR</strong> register when the counter is enabled and when it <span class="No-Break">reaches zero</span></li>
			</ul>
			<p>This is the structure of the SysTick Reload <span class="No-Break">Value Register:</span></p>
			<div>
				<div id="_idContainer083" class="IMG---Figure">
					<img src="image/B21914_08_2.jpg" alt="Figure 8.2: The SysTick Reload Value Register" width="902" height="114"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2: The SysTick Reload Value Register</p>
			<p>Since SysTick is a 24-bit timer, the <strong class="source-inline">RELOAD</strong> value can be any value in the range <strong class="bold">0x00000001</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="bold">0x00FFFFFF</strong></span><span class="No-Break">.</span></p>
			<p>To calculate the <strong class="source-inline">RELOAD</strong> value based on the desired timer period, we determine the number of clock cycles for the desired period, and then subtract 1 from this number to get the <span class="No-Break"><strong class="source-inline">RELOAD</strong></span><span class="No-Break"> value.</span></p>
			<p>For example, if the <strong class="bold">core clock frequency</strong> is <strong class="bold">16 MHz</strong> and we want the SysTick timer <strong class="bold">to trigger every 1 ms</strong>, the <strong class="source-inline">RELOAD</strong> value would be calculated <span class="No-Break">as follows:</span></p>
			<ol>
				<li>Calculate the number of clock cycles in <span class="No-Break">1 ms:</span><p class="list-inset"><strong class="bold">Clock cycles = 16,000,000 cycles/second * 0.001 second = </strong><span class="No-Break"><strong class="bold">16,000 cycles</strong></span></p><p class="list-inset">Note: 1ms = <span class="No-Break">0.001 second</span></p></li>
				<li>Subtract 1 from the calculated number of <span class="No-Break">clock cycles:</span><p class="list-inset"><strong class="bold"> RELOAD = 16,000 - 1 = 15,999</strong> since<a id="_idIndexMarker581"/> counting from 0 to 15,999 will give us <span class="No-Break">16000 ticks.</span></p></li>
			</ol>
			<p>Meaning, to configure the SysTick timer for a 1 ms period with a 16 MHz clock, we would set the <strong class="source-inline">RELOAD</strong> value to <strong class="bold">15,999</strong>. The next<a id="_idTextAnchor257"/> register is the SysTick Current Value <span class="No-Break">Register (</span><span class="No-Break"><strong class="source-inline">SYST_CVR</strong></span><span class="No-Break">).</span></p>
			<h3>The SysTick Current Value Register</h3>
			<p>The <a id="_idIndexMarker582"/>SysTick Current V<a id="_idTextAnchor258"/>alue Register (<strong class="source-inline">SYST_CVR</strong>) holds the current value of the SysTick counter. We can use this register to monitor the countdown process and to reset the counter <span class="No-Break">when necessary.</span></p>
			<p>It has the <span class="No-Break">following fields:</span></p>
			<ul>
				<li><strong class="bold">Bits [31:24] Reserved</strong>: These bits are reserved and should not be modified. They must be written <span class="No-Break">as zero.</span></li>
				<li><strong class="bold">Bits [23:0] CURRENT</strong>: This field contains the current value of the SysTick counter. Reading this field returns the current counter value. Writing any value to this field clears it to zero and also clears the <strong class="source-inline">COUNTFLAG</strong> bit in the SysTick Control and Status Register (<strong class="source-inline">SYST_CSR</strong>). This is the SysTick Current <span class="No-Break">Value Register:</span></li>
			</ul>
			<div>
				<div id="_idContainer084" class="IMG---Figure">
					<img src="image/B21914_08_3.jpg" alt="Figure 8.3: The SysTick Current Value Register" width="902" height="114"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3: The SysTick Current Value Register</p>
			<h3>The SysTick Calibration Value Register</h3>
			<p>The final register of<a id="_idIndexMarker583"/> the SysTick timer is the SysTick Calibration Value Register (<strong class="source-inline">SYST_CALIB</strong>). This register provides us with the calibration properties of the <span class="No-Break">SysTick timer.</span></p>
			<p>The names of these registers are slightly different in the STM32 header files. <em class="italic">Table 8.1</em> provides a clear correspondence between the register names used in the <em class="italic">Arm Generic User Guide</em> documentation and those in the STM32-specific header files. This correspondence will help us understand and reference them correctly in <span class="No-Break">our code.</span></p>
			<table id="table001-5" class="T---Table _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Header">
							<p><span class="No-Break"><strong class="bold">Function</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><strong class="bold">Arm Generic </strong><span class="No-Break"><strong class="bold">User Guide</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><strong class="bold">STM32 </strong><span class="No-Break"><strong class="bold">Header File</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p>Control <span class="No-Break">and Status</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">SYST_CSR</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">SysTick-&gt;CTRL</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">Reload Value</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">SYST_RVR</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">SysTick-&gt;LOAD</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">Current Value</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">SYST_CVR</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">SysTick-&gt;VAL</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">Calibration Value</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">SYST_CALIB</span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">SysTick-&gt;CALIB</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 8.1: Correspondence of SysTick register names</p>
			<p>In the next section, we will use the information we have learned to develop a driver for the <span class="No-Break">SysTick timer.</span></p>
			<h1 id="_idParaDest-144"><a id="_idTextAnchor259"/>Developing a driver for the SysTick timer</h1>
			<p>In this section, we will <a id="_idIndexMarker584"/>develop a driver for the SysTick timer to generate <span class="No-Break">precise delays.</span></p>
			<p>Let’s start by making a copy of our last project in our IDE, following the steps we learned in <a href="B21914_07.xhtml#_idTextAnchor217"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>. Rename the copied project to <strong class="source-inline">SysTick</strong>. Next, create a new file named <strong class="source-inline">systick.c</strong> in the <strong class="source-inline">Src</strong> folder and another file named <strong class="source-inline">systick.h</strong> in the <strong class="source-inline">Inc</strong> folder, just like we did for the GPIO drivers in the <span class="No-Break">previous lesson.</span></p>
			<p>Populate your <strong class="source-inline">systick.c</strong> file with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
<strong class="bold">#include</strong> "systick.h"
<strong class="bold">#define</strong> CTRL_ENABLE        (1U&lt;&lt;0)
<strong class="bold">#define</strong> CTRL_CLCKSRC    (1U&lt;&lt;2)
<strong class="bold">#define</strong> CTRL_COUNTFLAG    (1U&lt;&lt;16)
/*By default, the frequency of the MCU is 16Mhz*/
<strong class="bold">#define</strong> ONE_MSEC_LOAD     16000
<strong class="bold">void systick_msec_delay</strong>(uint32_t delay)
{
    /*Load number of clock cycles per millisecond*/
    SysTick-&gt;LOAD =  ONE_MSEC_LOAD - 1;
    /*Clear <strong class="bold">systick</strong> current value register*/
    SysTick-&gt;VAL = 0;
    /*Select internal clock source*/
    SysTick-&gt;CTRL = CTRL_CLCKSRC;
    /*Enable <strong class="bold">systick</strong>*/
    SysTick-&gt;CTRL |=CTRL_ENABLE;
    <strong class="bold">for</strong>(<strong class="bold">int</strong> i = 0; i &lt; delay; i++)
    {
        <strong class="bold">while</strong>((SysTick-&gt;CTRL &amp; CTRL_COUNTFLAG) == 0){}
    }
    /*Disable <strong class="bold">systick</strong>*/
    SysTick-&gt;CTRL = 0;
}</pre>			<p>Let’s break <span class="No-Break">it down.</span></p>
			<p>We start with <a id="_idIndexMarker585"/>the header <span class="No-Break">file inclusion:</span></p>
			<pre class="source-code">
#include "systick.h"</pre>			<p>This line includes the header file, <strong class="source-inline">systick.h</strong>, which in turn includes <strong class="source-inline">stm32fxx.h</strong> to provide access to the <span class="No-Break">register definitions.</span></p>
			<p>Next, we define all the macros <span class="No-Break">we need:</span></p>
			<ul>
				<li><strong class="source-inline">#define CTRL_ENABLE (1U &lt;&lt; 0)</strong>: Macro to enable the <span class="No-Break">SysTick timer.</span></li>
				<li><strong class="source-inline">#define CTRL_CLKSRC (1U &lt;&lt; 2)</strong>: Macro to select the internal clock source for the <span class="No-Break">SysTick timer.</span></li>
				<li><strong class="source-inline">#define CTRL_COUNTFLAG (1U &lt;&lt; 16)</strong>: Macro to check the <strong class="source-inline">COUNTFLAG</strong> bit, which indicates when the timer has counted <span class="No-Break">to zero.</span></li>
				<li><strong class="source-inline">#define ONE_MSEC_LOAD 16000</strong>: Macro to define the number of clock cycles in 1 millisecond. This assumes the microcontroller’s clock frequency is 16 MHz. This is the default configuration of the NUCLEO-F411 <span class="No-Break">development board.</span></li>
			</ul>
			<p>Next, we move on to the <span class="No-Break">function implementation.</span></p>
			<p>First, we have <span class="No-Break">the following:</span></p>
			<pre class="source-code">
SysTick-&gt;LOAD = ONE_MSEC_LOAD - 1;</pre>			<p>This line loads the SysTick timer with the number of clock cycles for <span class="No-Break">1 millisecond.</span></p>
			<p>Then, we clear the Current Value register with the following to reset <span class="No-Break">the timer:</span></p>
			<pre class="source-code">
SysTick-&gt;VAL = 0;</pre>			<p>Next, we select the internal <span class="No-Break">clock source:</span></p>
			<pre class="source-code">
SysTick-&gt;CTRL = CTRL_CLKSRC;</pre>			<p>To enable the SysTick timer, we use <span class="No-Break">the following:</span></p>
			<pre class="source-code">
SysTick-&gt;CTRL |= CTRL_ENABLE;</pre>			<p>Now, we enter the loop that handles <span class="No-Break">the delay:</span></p>
			<pre class="source-code">
for (int i = 0; i &lt; delay; i++)
{
    while ((SysTick-&gt;CTRL &amp; CTRL_COUNTFLAG) == 0) {}
}</pre>			<p>This loop runs for the <a id="_idIndexMarker586"/>specified delay duration. Inside each iteration, it waits for the <strong class="source-inline">COUNTFLAG</strong> bit to be set, which indicates the timer has counted down <span class="No-Break">to zero.</span></p>
			<p>Finally, we disable the <span class="No-Break">SysTick timer:</span></p>
			<pre class="source-code">
SysTick-&gt;CTRL = 0;</pre>			<p>And that’s it! With these steps, we’ve successfully implemented a delay function using the <span class="No-Break">SysTick timer.</span></p>
			<p>Our next task is to populate the <span class="No-Break"><strong class="source-inline">systick.h</strong></span><span class="No-Break"> file.</span></p>
			<p>Here is <span class="No-Break">the code:</span></p>
			<pre class="source-code">
#ifndef SYSTICK_H_
#define SYSTICK_H_
#include &lt;stdint.h&gt;
#include "stm32f4xx.h"
void systick_msec_delay(uint32_t delay);
#endif</pre>			<p>Over here, the <strong class="source-inline">#include &lt;stdint.h&gt;</strong> directive is needed to ensure that we have access to standard integer type definitions provided by the C standard library. These definitions include fixed-width integer types such as <strong class="source-inline">uint32_t</strong>, <strong class="source-inline">int32_t</strong>, <strong class="source-inline">uint16_t</strong>, and so on, which are essential for writing portable and clear code, especially in embedded <span class="No-Break">systems programming.</span></p>
			<p>With the driver files complete, we are now ready to test <span class="No-Break">inside </span><span class="No-Break"><strong class="source-inline">main.c</strong></span><span class="No-Break">.</span></p>
			<p>First, let’s enhance<a id="_idIndexMarker587"/> our <strong class="source-inline">gpio.c</strong> file by adding a new function that toggles the LED. This will simplify our code by allowing us to toggle the LED with a single function call instead of calling <strong class="source-inline">led_on()</strong> and <span class="No-Break"><strong class="source-inline">led_off()</strong></span><span class="No-Break"> separately.</span></p>
			<p>Add the following function to your <span class="No-Break"><strong class="source-inline">gpio.c</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
<strong class="bold">#define LED_PIN            (1U&lt;<a id="_idTextAnchor260"/>&lt;5)</strong>
void led_toggle(void)
{
    /*Toggle PA5*/
    GPIOA-&gt;ODR ^=LED_PIN;
}</pre>			<p>This function toggles the state of the LED connected to pin PA5 by using the bitwise <strong class="source-inline">XOR</strong> operation on<a id="_idIndexMarker588"/> the <strong class="bold">Output Data </strong><span class="No-Break"><strong class="bold">Register</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">ODR</strong></span><span class="No-Break">).</span></p>
			<p>Next, declare this function in the <strong class="source-inline">gpio.h</strong> file by adding the <span class="No-Break">following line:</span></p>
			<pre class="source-code">
void led_toggle(void)</pre>			<p>Finally, update your <strong class="source-inline">main.c</strong> file as shown here to call the SysTick delay and LED <span class="No-Break">toggle functions:</span></p>
			<pre class="source-code">
#include "gpio.h"
#include "systick.h"
int main(void)
{
    /*Initialize LED*/
    led_init();
    while(1){
        /*Delay for 500ms*/
        systick_msec_delay(500);
           /* Toggle the LED */
        led_toggle();
    }
}</pre>			<p>In this example, we <a id="_idIndexMarker589"/>are <strong class="bold">toggling the LED at a 500ms interval</strong>. Build the project and run it on your development board. You should see the green LED blinking. To experiment further, you can modify the delay value and observe how the blinking rate of the <span class="No-Break">LED changes.</span></p>
			<h1 id="_idParaDest-145"><a id="_idTextAnchor261"/>Summary</h1>
			<p>In this chapter, we explored the SysTick timer, a core peripheral of all Arm Cortex microcontrollers. We began with an introduction to the SysTick timer, discussing its significance and common applications, such as generating OS ticks in real-time operating systems, executing periodic tasks, and providing precise <span class="No-Break">time delays.</span></p>
			<p>We then examined the SysTick timer’s registers in detail. These included the Control and Status Register (<strong class="source-inline">SYST_CSR</strong>), which manages the timer’s operation and status; the Reload Value Register (<strong class="source-inline">SYST_RVR</strong>), which sets the timer’s countdown period; the Current Value Register (<strong class="source-inline">SYST_CVR</strong>), which holds the current value of the countdown; and the Calibration Value Register (<strong class="source-inline">SYST_CALIB</strong>), which provides essential calibration properties for accurate timing. We also provided a comparison between the register names used in the Arm Generic User Guide and those in the STM32 header files to ensure clear correspondence for <span class="No-Break">accurate coding.</span></p>
			<p>The chapter concluded with the development of a SysTick timer driver. We walked through the creation and implementation of the <strong class="source-inline">systick_msec_delay</strong> function, which introduces millisecond delays using the SysTick timer. To test the driver, we integrated it with GPIO functions to toggle our green LED, demonstrating how to achieve precise timing and control in <span class="No-Break">embedded systems.</span></p>
			<p>In the next chapter, we shall learn about another timer peripheral. Unlike the SysTick timer, the configuration of this timer peripheral is specific to <span class="No-Break">STM32 microcontrollers.</span></p>
		</div>
	</div>
</div>
</body></html>