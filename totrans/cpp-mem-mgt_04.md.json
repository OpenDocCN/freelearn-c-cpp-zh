["```cpp\n#include <iostream>\nstruct Base {\n    ~Base() { std::cout << \"~Base()\\n\"; }\n};\nstruct DerivedA : Base {\n    ~DerivedA() { std::cout << \"~DerivedA()\\n\"; }\n};\nstruct VirtBase {\n    virtual ~VirtBase() {\n       std::cout << \"~VirtBase()\\n\";\n    }\n};\nstruct DerivedB : VirtBase {\n    ~DerivedB() {\n       std::cout << \"~DerivedB()\\n\";\n    }\n};\nint main() {\n   {\n      Base base;\n   }\n   {\n      DerivedA derivedA;\n   }\n   std::cout << \"----\\n\";\n   Base *pBase = new DerivedA;\n   delete pBase; // bad\n   VirtBase *pVirtBase = new DerivedB;\n   delete pVirtBase; // Ok\n}\n```", "```cpp\n// opens the file called \"name\", returns a pointer\n// to a file descriptor for that file (nullptr on failure)\nFILE *open_file(const char *name);\n// returns the number of bytes read from the file into\n// buf. Preconditions: file is non-null and valid, buf\n// points to a buffer of at least capacity bytes, and\n// capacity >= 0\nint read_from(FILE *file, char *buf, int capacity);\n// closes file. Precondition: file is non-null and valid,\nvoid close_file(FILE *file);\n```", "```cpp\nvoid f(const char *name) {\n   FILE *file = open_file(name);\n   if(!file) return false; // failure\n   vector<char> v;\n   char buf[N]; // N is a positive integral constant\n   for(int n = read_from(file, buf, N); n != 0;\n       n = read_from(file, buf, N))\n      v.insert(end(v), buf + 0, buf + n);\n   process(v); // our processing function\n   close_file(file);\n}\n```", "```cpp\nvoid f(const char *name) {\n   FILE *file = open_file(name);\n   if(!file) return; // failure\n   vector<char> v;\n   char buf[N]; // N is a positive integral constant\n   try {\n      for(int n = read_from(file, buf, N); n != 0;\n          n = read_from(file, buf, N))\n         v.insert(end(v), buf + 0, buf + n);\n      process(v); // our processing function\n      close_file(file);\n   } catch(...) { // catch anything\n      close_file(file);\n      throw; // re-throw what we caught\n   }\n}\n```", "```cpp\nclass FileCloser { // perfectible, as we will see\n   FILE * file;\npublic:\n   FileCloser(FILE *file) : file{ file } {\n   }\n   ~FileCloser() {\n      close_file(file);\n}\n};\nvoid f(const char *name) {\n   FILE *file = open_file(name);\n   if(!file) return; // failure\n   FileCloser fc{ file }; // <-- fc manages file now\n   vector<char> v;\n   char buf[N]; // N is a positive integral constant\n   for(int n = read_from(file, buf, N); n != 0;\n       n = read_from(file, buf, N))\n      v.insert(end(v), buf + 0, buf + n);\n   process(v); // our processing function\n} FileCloser does will vary with our perception of its role: does this class just manage the closing of the file or does it actually represent the file with all of its services? I went for the former in this case but both options are reasonable: it all depends on the semantics you are seeking to implement. The key point is that by using a FileCloser object, we are relieving client code of a responsibility, instead delegating the responsibility of closing a file to an object that automates this task, simplifying our own code and reducing the risks of inadvertently leaving it open.\nThis `FileCloser` object is very specific to our task. We could generalize it in many ways, for example through a generic object that performs a user-supplied set of actions when destroyed:\n\n```", "```cpp\ntemplate <class F> class scoped_finalizer {\n   F f;\npublic:\n   scoped_finalizer(const scoped_finalizer&) = delete;\n   scoped_finalizer& operator=\n      (const scoped_finalizer&) = delete;\n   scoped_finalizer(F f) : f{ f } {\n   }\n   ~scoped_finalizer() {\n      f();\n   }\n};\n```", "```cpp\n#include <iostream>\nclass Darn {};\nvoid f() { throw 3; }\nstruct Evil {\n   Evil() { std::cout << \"Evil::Evil()\\n\"; }\n   ~Evil() noexcept(false) {\n      std::cout << \"Evil::~Evil()\\n\";\n      throw Darn {};\n   }\n};\nvoid g() {\n    std::cout << \"A\\n\";\n    Evil e;\n    std::cout << \"B\\n\";\n    f();\n    std::cout << \"C\\n\";\n}\nint main() {\n   try {\n      g();\n   } catch(int) {\n      std::cerr << \"catch(int)\\n\";\n   } catch(Darn) {\n      std::cerr << \"darn...\\n\";\n   }\n}\n```", "```cpp\nvoid f() {\n   A a; // a's ctor\n   B b; // b's ctor\n   {\n      C c; // c's ctor\n   } // c's dtor\n   D d; // d's ctor\n} // d's dtor, b's dtor, a's dtor (in that order)\n```", "```cpp\n#include <iostream>\n#include <format>\nstruct Verbose {\n   int n;\n   Verbose(int n) : n{ n } {\n      std::cout << std::format(«Verbose({})\\n», n);\n   }\n   ~Verbose(){\n      std::cout << std::format(«~Verbose({})\\n», n);\n   }\n};\nclass X {\n   static inline Verbose v0 { 0 };\n   Verbose v1{ 1 };\n};\nVerbose v2{ 2 };\nstatic void f() {\n    static Verbose v3 { 3 };\n    Verbose v4{ 4 };\n}\nstatic void g() { // note : never called\n    static Verbose v5 { 5 };\n}\nint main() {\n   Verbose v6{ 6 };\n   {\n      Verbose v7{ 7 };\n      f();\n      X x;\n   }\n   f();\n   X x;\n}\n```", "```cpp\nVerbose(0)\nVerbose(2)\nVerbose(6)\nVerbose(7)\nVerbose(3)\nVerbose(4)\n~Verbose(4)\nVerbose(1)\n~Verbose(1)\n~Verbose(7)\nVerbose(4)\n~Verbose(4)\nVerbose(1)\n~Verbose(1)\n~Verbose(6)\n~Verbose(3)\n~Verbose(2)\n~Verbose(0)\n```", "```cpp\n#include \"Lib.h\"\n#include <Windows.h> // LoadLibrary, GetProcAddress\nint main() {\n   using namespace std;\n   HMODULE hMod = LoadLibrary(L\"Lib.dll\");\n   // suppose the signature of factory is in Lib.h\n   auto factory_ptr = reinterpret_cast<\n      decltype(&factory)\n   >(GetProcAddress(hMod, \"factory\"));\n   X *p = factory_ptr();\n   p->f();\n   delete p;\n   FreeLibrary(hMod);\n}\n```", "```cpp\n#include \"Lib.h\"\n#include <memory> // std::unique_ptr\n#include <Windows.h> // LoadLibrary, GetProcAddress\nint main() {\n   using namespace std;\n   HMODULE hMod = LoadLibrary(L\"Lib.dll\");\n   // suppose the signature of factory is in Lib.h\n   auto factory_ptr = reinterpret_cast<\n      decltype(&factory)\n   >(GetProcAddress(hMod, \"factory\"));\n   std::unique_ptr<X> p { factory_ptr() };\n   p->f();\n   // delete p; // not needed anymore\n   FreeLibrary(hMod);\n} p is now an RAII object responsible for the destruction of the *pointee*. Being destroyed at the closing brace of our main() function, we know that the destructor of the *pointee* will be called even if p->f() throws, so we consider ourselves more exception-safe than before…\n… except that this code crashes on that closing brace! If you investigate the source of the crash, you will probably end up realizing that the crash happens at the point where the destructor of `p` calls operator `delete` on the `X*` it has stored internally. Reading further, you will notice that the reason why this crash happens is that the library the object came from has been freed (call to `FreeLibrary()`) before the destructor ran.\nDoes that mean we cannot use an automated memory management tool here? Of course not, but we need to be more careful with the way in which we put object lifetime to contribution. In this example, we want to make sure that `p` is destroyed before the call to `FreeLibrary()` happens; this can be achieved through the simple introduction of a scope in our function:\n\n```", "```cpp\n\n In this specific example, we could find a simple solution; in other cases we might have to move some declarations around to make sure the scopes in which our objects find themselves don’t alter the intended semantics of our function. Understanding the order in which objects are destroyed is essential to properly using this precious resource management facility that is the destructor.\nStandard resource management automation tools\nThe standard library offers a significant number of classes that manage memory efficiently. One needs only consider the standard containers to see shining examples of the sort. In this section, we will take a quick look at a few examples of types useful for resource management. Far from providing an exhaustive list, we’ll try to show different ways to benefit from the RAII idiom.\nAs mentioned before, when expressing a type that provides automated resource management, the key aspects of that type’s behavior are expressed through its six special member functions. For that reason, with each of the following types, we will take a brief look at what the semantics of these functions are.\nunique_ptr<T> and shared_ptr<T>\nThis short section aims to provide a brief overview of the two main standard smart pointers types in the C++ standard library: `std::unique_ptr<T>` and `std::shared_ptr<T>`. It is meant to provide a broad overview of each type’s role; a more detailed examination of how these types can be used appears in [*Chapter 5*](B21071_05.xhtml#_idTextAnchor079), and we will implement simplified versions of both types (as well as of a few other smart pointer types) in [*Chapter 6*](B21071_06.xhtml#_idTextAnchor096).\nWe have seen an example using `std::unique_ptr<T>` earlier in this chapter. An object of this type implements “single ownership of the resource” semantics: an object of type `std::unique_ptr<T>` is uncopiable, and when provided with a `T*` to manage, it destroys the *pointee* at the end of its lifetime. By default, this type will call `delete` on the pointer it manages, but it can be made to use some other means of disposal if needed.\nA default `std::unique_ptr<T>` represents an empty object and mostly behaves like a null pointer. Since this type expresses exclusive ownership of a resource, it is uncopiable. Moving from a `std::unique_ptr<T>` transfers ownership of the resource, leaving the moved-from object into an empty state conceptually analogous to a null pointer. The destructor of this type destroys the resource managed by the object, if any.\nType `std::shared_ptr<T>` implements “shared ownership of the resource” semantics. With this type, each `std::shared_ptr<T>` object that co-owns a given pointer shares responsibilities with respect to the pointee’s lifetime and the last co-owner of the resource is responsible for freeing it; as is the case with most smart pointers, this responsibility falls on the object’s destructor. This type is surprisingly complicated to write, even in a somewhat naïve implementation like the one we will write in [*Chapter 6*](B21071_06.xhtml#_idTextAnchor096), and is less frequently useful than some people think, as the main use case (expressing ownership in the type system for cases where the last owner of the pointee is a priori unknown, something most frequently seen in multithreaded code) is more specialized than many would believe, but when one needs to fill this niche, it’s the kind of type that’s immensely useful.\nA default `std::shared_ptr<T>` also represents an empty object and mostly behaves like a null pointer. Since this type expresses shared ownership of a resource, it is copyable but copying an object means sharing the *pointee*; copy assignment releases the resource held by the object on the left hand of the assignment and then shares the resource held by the object on the right side of the assignment between both objects. Moving from a `std::unique_ptr<T>` transfers ownership of the resource, leaving the moved-from object into an empty state. The destructor of this type releases ownership of the shared resource, destroying the resource managed by the object if that object was the last owner thereof.\nWhat does the “shared” in shared_ptr mean?\nThere can be confusion with respect to what the word “shared” in the name of the `std::shared_ptr` type actually means. For example, should we use that type whenever we want to share a pointer between caller and callee? Should we use it when whenever client code makes a copy of a pointer with the intent of sharing the pointee, such as when passing a pointer by value to a function or sharing resources stored in a global manager object?\nThe short answer is that this is the wrong way to approach smart pointers. Sharing a dynamically allocated resource does not mean co-owning that resource: only the latter is what `std::shared_ptr` models, whereas the former can be done with much more lightweight types. We will examine this idea in detail in [*Chapter 5*](B21071_05.xhtml#_idTextAnchor079) from a usage perspective, then reexamine it in [*Chapter 6*](B21071_06.xhtml#_idTextAnchor096) with our implementer eyes, hopefully building a more comprehensive understanding of these deep and subtle issues.\nlock_guard and scoped_lock\nOwning a resource is not limited to owning memory. Indeed, consider the following code excerpt and suppose that `string_mutator` is a class used to perform arbitrary transformations to characters in a `string`, but is expected to be used in a multithreaded context in the sense that one needs to synchronize accesses to that `string` object:\n\n```", "```cpp\n\n In this example, a `string_mutator` object’s function call operator accepts an arbitrary function `f` applicable to a `char` and that returns something that can be converted to a `char`, then applies `f` to each `char` in the sequence. For example, the following call would display `\"I LOVE` `MY INSTRUCTOR\"`:\n\n```", "```cpp\n\n Now, since `string_mutator::operator()(F)` accepts any function of the appropriate signature as argument, it could among other things accept a function that could throw an exception. Looking at the implementation of that operator, you will notice that with the current (naïve) implementation, this would lock `m` but never unlock it, a bad situation indeed.\nThere are languages that offer specialized language constructs to solve this problem. In C++, there’s no need for such specialized support as robust code just flows from the fact that one could write an object that locks a mutex at construction time and unlocks it when destroyed… and that’s pretty much all we need. In C++, the simplest such type is `std::lock_guard<M>`, where a simple implementation could look like:\n\n```", "```cpp\n\n The simplest types are often the best. Indeed, applying this type to our `string_mutator` example, we end up with a simpler, yet much more robust implementation:\n\n```", "```cpp\n\n Clearly, using destructors to automate unlocking our mutex is advantageous for cases such as this: it simplifies code and helps make it exception-safe.\nstream objects\nIn C++, stream objects are also resource owners. Consider the following code example where we copy each byte from file `in.txt` to the standard output stream:\n\n```", "```cpp\n\n You might notice a few interesting details in this code: we never call `close()`, there’s no `try` block where we would be preparing ourselves for exception management, there’s no call to `open()` in order to open the file, there’s no explicit check for some end-of-file state… yet, this code works correctly, does what it’s supposed to do, and does not leak resources.\nHow can such a simple program do all that? Through “the magic of destructors”, or (more precisely) the magic of a good API. Think about it:\n\n*   The constructor’s role is to put the object in a correct initial state. Thus, we use it to open the file as it would be both pointless and inefficient to default-construct the stream, then open it later.\n*   Errors when reading from a stream are not exceptional at all… Think about it, how often do we face errors when reading from a stream? In C++, reading from a stream (here: calling `in.get(c)`) returns a reference to the stream after reading from it, and that stream behaves like a `false` Boolean value if the stream is in an error state.\n*   Finally, the destructor of a stream object closes whatever representation of a stream it is responsible for. Calling `close()` on a stream in C++ is unnecessary most of the time; just using the stream object in a limited scope generally suffices.\n\nDestructors (and constructors!), when used appropriately, lead to more robust and simpler code.\nvector<T> and other containers\nWe will not write a full-blown comparison of containers with raw arrays or other low-level constructs such as linked lists with manually managed nodes or dynamic arrays maintained explicitly through client code. We will however examine how one can write containers such as `std::vector` or `std::list` in later chapters of this book (*Chapters 12*, *13*, and *14*) when we know a bit more on memory management techniques.\nPlease note, still, that using `std::vector<T>` (for example) is not only significantly simpler and safer than managing a dynamically allocated array of `T`: in practice, it’s most probably significantly *faster*, at least if used knowledgeably. As we will come to see, there’s no way users can invest the care and attention that goes into memory management and object creation, destruction and copying or movement that goes in a standard container when writing day-to-day code. The destructor of these types, coupled with the way their other special member functions are implemented, make them almost as easy to use as `int` objects, a worthy goal if there ever was one!\nSummary\nIn this chapter, we have discussed some safety-related issues, with a focus on those involving exceptions. We have seen that some standard library types offer specialized semantics with respect to resource management, where “resource” includes but is not limited to memory. In [*Chapter 5*](B21071_05.xhtml#_idTextAnchor079), we will spend some time examining how to use and benefit from standard smart pointer; then, in [*Chapter 6*](B21071_06.xhtml#_idTextAnchor096), we will go further and look at some of the challenges behind writing your own versions of these smart pointers, as well as some other smart pointer-inspired types with other semantics. Then, we will delve into deeper memory management-related concerns.\n\n```", "```cpp\n\n```"]