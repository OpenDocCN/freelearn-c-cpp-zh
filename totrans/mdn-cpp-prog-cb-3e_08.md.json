["```cpp\ninline void print_time()\n{\n  auto now = std::chrono::system_clock::now();\n  auto stime = std::chrono::system_clock::to_time_t(now);\n  auto ltime = std::localtime(&stime);\n  std::cout << std::put_time(ltime, \"%c\") << '\\n';\n} \n```", "```cpp\n    std::thread t; \n    ```", "```cpp\n    void func1()\n    {\n      std::cout << \"thread func without params\" << '\\n';\n    }\n    std::thread t1(func1);\n    std::thread t2([]() {\n      std::cout << \"thread func without params\" << '\\n'; }); \n    ```", "```cpp\n    void func2(int const i, double const d, std::string const s)\n    {\n      std::cout << i << \", \" << d << \", \" << s << '\\n';\n    }\n    std::thread t(func2, 42, 42.0, \"42\"); \n    ```", "```cpp\n    t.join(); \n    ```", "```cpp\n    t.detach(); \n    ```", "```cpp\n    void func3(int & i)\n    {\n      i *= 2;\n    }\n    int n = 42;\n    std::thread t(func3, std::ref(n));\n    t.join();\n    std::cout << n << '\\n'; // 84 \n    ```", "```cpp\n    void func4()\n    {\n      using namespace std::chrono;\n      print_time();\n      std::this_thread::sleep_for(2s);\n      print_time();\n    }\n    std::thread t(func4);\n    t.join(); \n    ```", "```cpp\n    void func5()\n    {\n      using namespace std::chrono;\n      print_time();\n      std::this_thread::sleep_until(\n        std::chrono::system_clock::now() + 2s);\n      print_time();\n    }\n    std::thread t(func5);\n    t.join(); \n    ```", "```cpp\n    void func6(std::chrono::seconds timeout)\n    {\n      auto now = std::chrono::system_clock::now();\n      auto then = now + timeout;\n      do\n      {\n        std::this_thread::yield();\n      } while (std::chrono::system_clock::now() < then);\n    }\n    std::thread t(func6, std::chrono::seconds(2));\n    t.join();\n    print_time(); \n    ```", "```cpp\n    std::mutex g_mutex; \n    ```", "```cpp\n    void thread_func()\n    {\n      using namespace std::chrono_literals;\n      {\n        std::lock_guard<std::mutex> lock(g_mutex);\n        std::cout << \"running thread \" \n                  << std::this_thread::get_id() << '\\n';\n      }\n      std::this_thread::yield();\n      std::this_thread::sleep_for(2s);\n      {\n        std::lock_guard<std::mutex> lock(g_mutex);\n        std::cout << \"done in thread \" \n                  << std::this_thread::get_id() << '\\n';\n      }\n    } \n    ```", "```cpp\n    template <typename T>\n    struct container\n    {\n      std::mutex     mutex;\n      std::vector<T> data;\n    }; \n    ```", "```cpp\n    template <typename T>\n    void move_between(container<T> & c1, container<T> & c2, \n                      T const value)\n    {\n      std::lock(c1.mutex, c2.mutex);\n      // continued at 3.\n    } \n    ```", "```cpp\n    // continued from 2.\n    std::lock_guard<std::mutex> l1(c1.mutex, std::adopt_lock);\n    std::lock_guard<std::mutex> l2(c2.mutex, std::adopt_lock);\n    c1.data.erase(\n      std::remove(c1.data.begin(), c1.data.end(), value), \n      c1.data.end());\n    c2.data.push_back(value); \n    ```", "```cpp\ng_mutex.lock();\n// use the shared resource such as std::cout\nstd::cout << \"accessing shared resource\" << '\\n';\ng_mutex.unlock(); \n```", "```cpp\n    template <class M>\n    class lock_guard\n    {\n    public:\n      typedef M mutex_type;\n      explicit lock_guard(M& Mtx) : mtx(Mtx)\n      {\n        mtx.lock();\n      }\n      lock_guard(M& Mtx, std::adopt_lock_t) : mtx(Mtx)\n      { }\n      ~lock_guard() noexcept\n      {\n        mtx.unlock();\n      }\n      lock_guard(const lock_guard&) = delete;\n      lock_guard& operator=(const lock_guard&) = delete;\n    private:\n      M& mtx;\n    }; \n    ```", "```cpp\nstd::vector<std::thread> threads;\nfor (int i = 0; i < 5; ++i)\n  threads.emplace_back(thread_func);\nfor (auto & t : threads)\n  t.join(); \n```", "```cpp\nrunning thread 140296854550272\nrunning thread 140296846157568\nrunning thread 140296837764864\nrunning thread 140296829372160\nrunning thread 140296820979456\ndone in thread 140296854550272\ndone in thread 140296846157568\ndone in thread 140296837764864\ndone in thread 140296820979456\ndone in thread 140296829372160 \n```", "```cpp\ntemplate <typename T>\nvoid move_between(container<T> & c1, container<T> & c2, T const value)\n{\n  std::lock_guard<std::mutex> l1(c1.mutex);\n  std::lock_guard<std::mutex> l2(c2.mutex);\n  c1.data.erase(\n    std::remove(c1.data.begin(), c1.data.end(), value), \n    c1.data.end());\n  c2.data.push_back(value);\n}\ncontainer<int> c1;\nc1.data.push_back(1);\nc1.data.push_back(2);\nc1.data.push_back(3);\ncontainer<int> c2;\nc2.data.push_back(4);\nc2.data.push_back(5);\nc2.data.push_back(6);\nstd::thread t1(move_between<int>, std::ref(c1), std::ref(c2), 3);\nstd::thread t2(move_between<int>, std::ref(c2), std::ref(c1), 6);\nt1.join();\nt2.join(); \n```", "```cpp\nstd::lock(c1.mutex, c2.mutex);\nstd::lock_guard<std::mutex> l1(c1.mutex, std::adopt_lock);\nstd::lock_guard<std::mutex> l2(c2.mutex, std::adopt_lock); \n```", "```cpp\nstd::scoped_lock lock(c1.mutex, c2.mutex); \n```", "```cpp\nclass foo_rec\n{\n  std::recursive_mutex m;\n  int data;\npublic:\n  foo_rec(int const d = 0) : data(d) {}\n  void update(int const d)\n {\n    std::lock_guard<std::recursive_mutex> lock(m);\n    data = d;\n  }\n  int update_with_return(int const d)\n {\n    std::lock_guard<std::recursive_mutex> lock(m);\n    auto temp = data;\n    update(d);\n    return temp;\n  }\n}; \n```", "```cpp\n    class foo\n    {\n      std::mutex m;\n      int        data;\n      // continued at 2.\n    }; \n    ```", "```cpp\n    void internal_update(int const d) { data = d; }\n    // continued at 3. \n    ```", "```cpp\n    public:\n      foo(int const d = 0) : data(d) {}\n      void update(int const d)\n     {\n        std::lock_guard<std::mutex> lock(m);\n        internal_update(d);\n      }\n      int update_with_return(int const d)\n     {\n        std::lock_guard<std::mutex> lock(m);\n        auto temp = data;\n        internal_update(d);\n        return temp;\n      } \n    ```", "```cpp\n    std::vector<std::exception_ptr> g_exceptions; \n    ```", "```cpp\n    std::mutex g_mutex; \n    ```", "```cpp\n    void func1()\n    {\n      throw std::runtime_error(\"exception 1\");\n    }\n    void func2()\n    {\n      throw std::runtime_error(\"exception 2\");\n    }\n    void thread_func1()\n    {\n      try\n      {\n        func1();\n      }\n      catch (...)\n      {\n        std::lock_guard<std::mutex> lock(g_mutex);\n        g_exceptions.push_back(std::current_exception());\n      }\n    }\n    void thread_func2()\n    {\n      try\n      {\n        func2();\n      }\n      catch (...)\n      {\n        std::lock_guard<std::mutex> lock(g_mutex);\n        g_exceptions.push_back(std::current_exception());\n      }\n    } \n    ```", "```cpp\n    g_exceptions.clear(); \n    ```", "```cpp\n    std::thread t1(thread_func1);\n    std::thread t2(thread_func2);\n    t1.join();\n    t2.join();\n    for (auto const & e : g_exceptions)\n    {\n      try\n      {\n        if(e)\n          std::rethrow_exception(e);\n      }\n      catch(std::exception const & ex)\n      {\n        std::cout << ex.what() << '\\n';\n      }\n    } \n    ```", "```cpp\n    std::condition_variable cv; \n    ```", "```cpp\n    std::mutex data_mutex; // data mutex\n    std::mutex io_mutex;   // I/O mutex \n    ```", "```cpp\n    int data = 0; \n    ```", "```cpp\n    std::thread producer([&](){\n     // simulate long running operation\n      {\n     using namespace std::chrono_literals;\n        std::this_thread::sleep_for(2s);\n      }\n     // produce\n      {\n        std::unique_lock lock(data_mutex);\n        data = 42;\n      }\n     // print message\n      {\n        std::lock_guard l(io_mutex);\n        std::cout << \"produced \" << data << '\\n';\n      }\n     // continued at 5.\n    }); \n    ```", "```cpp\n    // continued from 4.\n    cv.notify_one(); \n    ```", "```cpp\n    std::thread consumer([&](){\n     // wait for notification\n      {\n        std::unique_lock lock(data_mutex);\n        cv.wait(lock);\n      }\n     // continued at 7.\n    }); \n    ```", "```cpp\n    // continued from 6.\n    {\n      std::lock_guard lock(io_mutex);\n      std::cout << \"consumed \" << data << '\\n';\n    } \n    ```", "```cpp\n    while(!pred())\n      wait(lock); \n    ```", "```cpp\nproducer thread:\n```", "```cpp\nstd::mutex g_lockprint;\nstd::mutex g_lockqueue;\nstd::condition_variable g_queuecheck;\nstd::queue<int> g_buffer;\nbool g_done;\nvoid producer(\n int const id, \n  std::mt19937& generator,\n  std::uniform_int_distribution<int>& dsleep,\n  std::uniform_int_distribution<int>& dcode)\n{\n  for (int i = 0; i < 5; ++i)\n  {\n    // simulate work\n    std::this_thread::sleep_for(\n      std::chrono::seconds(dsleep(generator)));\n    // generate data\n    {\n      std::unique_lock<std::mutex> locker(g_lockqueue);\n      int value = id * 100 + dcode(generator);\n      g_buffer.push(value);\n      {\n        std::unique_lock<std::mutex> locker(g_lockprint);\n        std::cout << \"[produced(\" << id << \")]: \" << value << '\\n';\n      }\n    }\n    // notify consumers \n    g_queuecheck.notify_one();\n  }\n} \n```", "```cpp\nvoid consumer()\n{\n  // loop until end is signaled\nwhile (!g_done)\n  {\n    std::unique_lock<std::mutex> locker(g_lockqueue);\n    g_queuecheck.wait_for(\n      locker, \n      std::chrono::seconds(1),\n      [&]() {return !g_buffer.empty(); });\n    // if there are values in the queue process them\nwhile (!g_done && !g_buffer.empty())\n    {\n      std::unique_lock<std::mutex> locker(g_lockprint);\n      std::cout << \"[consumed]: \" << g_buffer.front() << '\\n';\n      g_buffer.pop();\n    }\n  }\n} \n```", "```cpp\nauto seed_data = std::array<int, std::mt19937::state_size> {};\nstd::random_device rd {};\nstd::generate(std::begin(seed_data), std::end(seed_data),\n              std::ref(rd));\nstd::seed_seq seq(std::begin(seed_data), std::end(seed_data));\nauto generator = std::mt19937{ seq };\nauto dsleep = std::uniform_int_distribution<>{ 1, 5 };\nauto dcode = std::uniform_int_distribution<>{ 1, 99 };\nstd::cout << \"start producing and consuming...\" << '\\n';\nstd::thread consumerthread(consumer);\nstd::vector<std::thread> threads;\nfor (int i = 0; i < 5; ++i)\n{\n  threads.emplace_back(producer, \n                       i + 1, \n                       std::ref(generator),\n                       std::ref(dsleep),\n                       std::ref(dcode));\n}\n// work for the workers to finish\nfor (auto& t : threads)\n  t.join();\n// notify the logger to finish and wait for it\ng_done = true;\nconsumerthread.join();\nstd::cout << \"done producing and consuming\" << '\\n'; \n```", "```cpp\nstart producing and consuming...\n[produced(5)]: 550\n[consumed]: 550\n[produced(5)]: 529\n[consumed]: 529\n[produced(5)]: 537\n[consumed]: 537\n[produced(1)]: 122\n[produced(2)]: 224\n[produced(3)]: 326\n[produced(4)]: 458\n[consumed]: 122\n[consumed]: 224\n[consumed]: 326\n[consumed]: 458\n...\ndone producing and consuming \n```", "```cpp\n    void produce_value(std::promise<int>& p)\n    {\n      // simulate long running operation\n      {\n        using namespace std::chrono_literals;\n        std::this_thread::sleep_for(2s);\n      }\n      // continued at 2.\n    } \n    ```", "```cpp\n    // continued from 1.\n    p.set_value(42); \n    ```", "```cpp\n    void consume_value(std::future<int>& f)\n    {\n      // continued at 4.\n    } \n    ```", "```cpp\n    // continued from 3.\n    auto value = f.get(); \n    ```", "```cpp\n    std::promise<int> p;\n    std::thread t1(produce_value, std::ref(p));\n    std::future<int> f = p.get_future();\n    std::thread t2(consume_value, std::ref(f));\n    t1.join();\n    t2.join(); \n    ```", "```cpp\nvoid produce_value(std::promise<int>& p)\n{\n  // simulate long running operation\n  {\n    using namespace std::chrono_literals;\n    std::this_thread::sleep_for(2s);\n  }\n  try\n  {\n    throw std::runtime_error(\"an error has occurred!\");\n  }\n  catch(...)\n  {\n    p.set_exception(std::current_exception());\n  }\n}\nvoid consume_value(std::future<int>& f)\n{\n  std::lock_guard<std::mutex> lock(g_mutex);\n  try\n  {\n    std::cout << f.get() << '\\n';\n  }\n  catch(std::exception const & e)\n  {\n    std::cout << e.what() << '\\n';\n  } \n} \n```", "```cpp\nvoid do_something()\n{\n  // simulate long running operation\n  {\n    using namespace std::chrono_literals;\n    std::this_thread::sleep_for(2s);\n  } \n  std::lock_guard<std::mutex> lock(g_mutex);\n  std::cout << \"operation 1 done\" << '\\n'; \n}\nvoid do_something_else()\n{\n  // simulate long running operation\n  {\n    using namespace std::chrono_literals;\n    std::this_thread::sleep_for(1s);\n  } \n  std::lock_guard<std::mutex> lock(g_mutex);\n  std::cout << \"operation 2 done\" << '\\n'; \n}\nint compute_something()\n{\n  // simulate long running operation\n  {\n    using namespace std::chrono_literals;\n    std::this_thread::sleep_for(2s);\n  } \n  return 42;\n}\nint compute_something_else()\n{\n  // simulate long running operation\n  {\n    using namespace std::chrono_literals;\n    std::this_thread::sleep_for(1s);\n  }\n  return 24;\n} \n```", "```cpp\n    auto f = std::async(std::launch::async, do_something); \n    ```", "```cpp\n    do_something_else(); \n    ```", "```cpp\n    f.wait(); \n    ```", "```cpp\n    auto f = std::async(std::launch::async, compute_something); \n    ```", "```cpp\n    auto value = compute_something_else(); \n    ```", "```cpp\n    value += f.get(); \n    ```", "```cpp\nenum class launch : /* unspecified */ \n{\n  async = /* unspecified */,\n  deferred = /* unspecified */,\n  /* implementation-defined */\n}; \n```", "```cpp\nauto f = std::async(std::launch::async, do_something);\nwhile(true)\n{\n  std::cout << \"waiting...\\n\";\n  using namespace std::chrono_literals;\n  auto status = f.wait_for(500ms);\n  if(status == std::future_status::ready) \n    break;\n}\nstd::cout << \"done!\\n\"; \n```", "```cpp\nwaiting...\nwaiting...\nwaiting...\noperation 1 done\ndone! \n```", "```cpp\n    std::atomic<int> counter {0};\n    std::vector<std::thread> threads;\n    for(int i = 0; i < 10; ++i)\n    {\n      threads.emplace_back([&counter](){\n        for(int j = 0; j < 10; ++j)\n          ++counter;\n        });\n    }\n    for(auto & t : threads) t.join();\n    std::cout << counter << '\\n'; // prints 100 \n    ```", "```cpp\n    void do_count(int& c)\n    {\n      std::atomic_ref<int> counter{ c };\n      std::vector<std::thread> threads;\n      for (int i = 0; i < 10; ++i)\n      {\n        threads.emplace_back([&counter]() {\n          for (int j = 0; j < 10; ++j)\n            ++counter;\n          });\n      }\n      for (auto& t : threads) t.join();\n    }\n    int main()\n    {\n      int c = 0;\n      do_count(c);\n      std::cout << c << '\\n'; // prints 100\n    } \n    ```", "```cpp\n    std::atomic_flag lock = ATOMIC_FLAG_INIT;\n    int counter = 0;\n    std::vector<std::thread> threads;\n    for(int i = 0; i < 10; ++i)\n    {\n      threads.emplace_back([&](){\n        while(lock.test_and_set(std::memory_order_acquire));\n          ++counter;\n          lock.clear(std::memory_order_release);\n      });\n    }\n    for(auto & t : threads) t.join();\n    std::cout << counter << '\\n'; // prints 10 \n    ```", "```cpp\n    std::atomic<int> sum {0};\n    std::vector<int> numbers = generate_random();\n    size_t size = numbers.size();\n    std::vector<std::thread> threads;\n    for(int i = 0; i < 10; ++i)\n    {\n      threads.emplace_back([&sum, &numbers](size_t const start,\n                                            size_t const end) {\n      for(size_t j = start; j < end; ++j)\n      {\n        std::atomic_fetch_add_explicit(\n          &sum, numbers[j], \n          std::memory_order_acquire);\n        // same as \n    // sum.fetch_add(numbers[i], std::memory_order_acquire);\n      }},\n      i*(size/10),\n      (i+1)*(size/10));\n    }\n    for(auto & t : threads) t.join(); \n    ```", "```cpp\na = a + 42; \n```", "```cpp\na += 42; \n```", "```cpp\na.fetch_add(42);               // using member function\nstd::atomic_fetch_add(&a, 42); // using non-member function \n```", "```cpp\nstd::atomic_flag lock = ATOMIC_FLAG_INIT; \n```", "```cpp\ntemplate <typename T, \n          typename I = \n            typename std::enable_if<std::is_integral_v<T>>::type>\nclass atomic_counter\n{\n  std::atomic<T> counter {0};\npublic:\n  T increment()\n {\n    return counter.fetch_add(1);\n  }\n  T decrement()\n {\n    return counter.fetch_sub(1);\n  }\n  T get()\n {\n    return counter.load();\n  }\n}; \n```", "```cpp\natomic_counter<int> counter;\nstd::vector<std::thread> threads;\nfor(int i = 0; i < 10; ++i)\n{\n  threads.emplace_back([&counter](){\n    for(int j = 0; j < 10; ++j)\n      counter.increment();\n  });\n}\nfor(auto & t : threads) t.join();\nstd::cout << counter.get() << '\\n'; // prints 100 \n```", "```cpp\nunsigned get_no_of_threads()\n{\n  return std::thread::hardware_concurrency();\n} \n```", "```cpp\n    template <typename Iter, typename F>\n    void parallel_map(Iter begin, Iter end, F&& f)\n    {\n    } \n    ```", "```cpp\n    auto size = std::distance(begin, end);\n    if(size <= 10000)\n      std::transform(begin, end, begin, std::forward<F>(f)); \n    ```", "```cpp\n    else\n    {\n      auto no_of_threads = get_no_of_threads();\n      auto part = size / no_of_threads;\n      auto last = begin;\n      // continued at 4\\. and 5.\n    } \n    ```", "```cpp\n    std::vector<std::thread> threads;\n    for(unsigned i = 0; i < no_of_threads; ++i)\n    {\n      if(i == no_of_threads - 1) last = end;\n      else std::advance(last, part);\n      threads.emplace_back(\n        [=,&f]{std::transform(begin, last, \n                              begin, std::forward<F>(f));});\n      begin = last;\n    } \n    ```", "```cpp\n    for(auto & t : threads) t.join(); \n    ```", "```cpp\ntemplate <typename Iter, typename F>\nvoid parallel_map(Iter begin, Iter end, F&& f)\n{\n  auto size = std::distance(begin, end);\n  if(size <= 10000)\n    std::transform(begin, end, begin, std::forward<F>(f)); \n  else\n  {\n    auto no_of_threads = get_no_of_threads();\n    auto part = size / no_of_threads;\n    auto last = begin;\n    std::vector<std::thread> threads;\n    for(unsigned i = 0; i < no_of_threads; ++i)\n    {\n      if(i == no_of_threads - 1) last = end;\n      else std::advance(last, part);\n      threads.emplace_back(\n        [=,&f]{std::transform(begin, last, \n                              begin, std::forward<F>(f));});\n      begin = last;\n    }\n    for(auto & t : threads) t.join();\n  }\n} \n```", "```cpp\n    template <typename Iter, typename R, typename F>\n    auto parallel_fold(Iter begin, Iter end, R init, F&& op)\n    {\n    } \n    ```", "```cpp\n    auto size = std::distance(begin, end);\n    if(size <= 10000)\n      return std::accumulate(begin, end, \n                             init, std::forward<F>(op)); \n    ```", "```cpp\n    else\n    {\n      auto no_of_threads = get_no_of_threads();\n      auto part = size / no_of_threads;\n      auto last = begin;\n      // continued with 4\\. and 5.\n    } \n    ```", "```cpp\n    std::vector<std::thread> threads;\n    std::vector<R> values(no_of_threads);\n    for(unsigned i = 0; i < no_of_threads; ++i)\n    {\n      if(i == no_of_threads - 1) last = end;\n      else std::advance(last, part);\n      threads.emplace_back(\n        [=,&op](R& result){\n          result = std::accumulate(begin, last, R{}, \n                                   std::forward<F>(op));},\n        std::ref(values[i]));\n      begin = last;\n    } \n    ```", "```cpp\n    for(auto & t : threads) t.join();\n    return std::accumulate(std::begin(values), std::end(values),\n                           init, std::forward<F>(op)); \n    ```", "```cpp\ntemplate <typename Iter, typename R, typename F>\nauto parallel_fold(Iter begin, Iter end, R init, F&& op)\n{\n  auto size = std::distance(begin, end);\n  if(size <= 10000)\n    return std::accumulate(begin, end, init, std::forward<F>(op));\n  else\n  {\n    auto no_of_threads = get_no_of_threads();\n    auto part = size / no_of_threads;\n    auto last = begin;\n    std::vector<std::thread> threads;\n    std::vector<R> values(no_of_threads);\n    for(unsigned i = 0; i < no_of_threads; ++i)\n    {\n      if(i == no_of_threads - 1) last = end;\n      else std::advance(last, part);\n      threads.emplace_back(\n        [=,&op](R& result){\n          result = std::accumulate(begin, last, R{}, \n                                   std::forward<F>(op));},\n        std::ref(values[i]));\n      begin = last;\n    }\n    for(auto & t : threads) t.join();\n    return std::accumulate(std::begin(values), std::end(values), \n                           init, std::forward<F>(op));\n  }\n} \n```", "```cpp\nstd::vector<int> sizes\n{\n  10000, 100000, 500000, \n  1000000, 2000000, 5000000, \n  10000000, 25000000, 50000000\n};\nstd::cout\n  << std::right << std::setw(8) << std::setfill(' ') << \"size\"\n  << std::right << std::setw(8) << \"s map\"\n  << std::right << std::setw(8) << \"p map\"\n  << std::right << std::setw(8) << \"s fold\"\n  << std::right << std::setw(8) << \"p fold\"\n  << '\\n';\nfor (auto const size : sizes)\n{\n  std::vector<int> v(size);\n  std::iota(std::begin(v), std::end(v), 1);\n  auto v1 = v;\n  auto s1 = 0LL;\n  auto tsm = perf_timer<>::duration([&] {\n    std::transform(std::begin(v1), std::end(v1), std::begin(v1), \n                   [](int const i) {return i + i; }); });\n  auto tsf = perf_timer<>::duration([&] {\n    s1 = std::accumulate(std::begin(v1), std::end(v1), 0LL,\n                         std::plus<>()); });\n  auto v2 = v;\n  auto s2 = 0LL;\n  auto tpm = perf_timer<>::duration([&] {\n    parallel_map(std::begin(v2), std::end(v2), \n                 [](int const i) {return i + i; }); });\n  auto tpf = perf_timer<>::duration([&] {\n    s2 = parallel_fold(std::begin(v2), std::end(v2), 0LL,\n                       std::plus<>()); });\n  assert(v1 == v2);\n  assert(s1 == s2);\n  std::cout\n    << std::right << std::setw(8) << std::setfill(' ') << size\n    << std::right << std::setw(8) \n    << std::chrono::duration<double, std::micro>(tsm).count()\n    << std::right << std::setw(8) \n    << std::chrono::duration<double, std::micro>(tpm).count()\n    << std::right << std::setw(8) \n    << std::chrono::duration<double, std::micro>(tsf).count()\n    << std::right << std::setw(8) \n    << std::chrono::duration<double, std::micro>(tpf).count()\n    << '\\n';\n} \n```", "```cpp\n size   s map   p map  s fold  p fold\n   10000      11      10       7      10\n  100000     108    1573      72     710\n  500000     547    2006     361     862\n 1000000    1146    1163     749     862\n 2000000    2503    1527    1677    1289\n 5000000    5937    3000    4203    2314\n10000000   11959    6269    8269    3868\n25000000   29872   13823   20961    9156\n50000000   60049   27457   41374   19075 \n```", "```cpp\n    template <typename Iter, typename F>\n    void parallel_map(Iter begin, Iter end, F&& f)\n    {\n    } \n    ```", "```cpp\n    auto size = std::distance(begin, end);\n    if(size <= 10000)\n      std::transform(begin, end, begin, std::forward<F>(f)); \n    ```", "```cpp\n    else\n    {\n      auto no_of_tasks = get_no_of_threads();\n      auto part = size / no_of_tasks;\n      auto last = begin;\n      // continued at 4\\. and 5.\n    } \n    ```", "```cpp\n    std::vector<std::future<void>> tasks;\n    for(unsigned i = 0; i < no_of_tasks; ++i)\n    {\n      if(i == no_of_tasks - 1) last = end;\n      else std::advance(last, part);\n      tasks.emplace_back(std::async(\n        std::launch::async, \n          [=,&f]{std::transform(begin, last, begin, \n                                std::forward<F>(f));}));\n        begin = last;\n    } \n    ```", "```cpp\n    for(auto & t : tasks) t.wait(); \n    ```", "```cpp\ntemplate <typename Iter, typename F>\nvoid parallel_map(Iter begin, Iter end, F&& f)\n{\n  auto size = std::distance(begin, end);\n  if(size <= 10000)\n    std::transform(begin, end, begin, std::forward<F>(f)); \n  else\n  {\n    auto no_of_tasks = get_no_of_threads();\n    auto part = size / no_of_tasks;\n    auto last = begin;\n    std::vector<std::future<void>> tasks;\n    for(unsigned i = 0; i < no_of_tasks; ++i)\n    {\n      if(i == no_of_tasks - 1) last = end;\n      else std::advance(last, part);\n      tasks.emplace_back(std::async(\n        std::launch::async, \n          [=,&f]{std::transform(begin, last, begin, \n                                std::forward<F>(f));}));\n      begin = last;\n    }\n    for(auto & t : tasks) t.wait();\n  }\n} \n```", "```cpp\n    template <typename Iter, typename R, typename F>\n    auto parallel_fold(Iter begin, Iter end, R init, F&& op)\n    {\n    } \n    ```", "```cpp\n    auto size = std::distance(begin, end);\n    if(size <= 10000)\n      return std::accumulate(begin, end, init, std::forward<F>(op)); \n    ```", "```cpp\n    else\n    {\n      auto no_of_tasks = get_no_of_threads();\n      auto part = size / no_of_tasks;\n      auto last = begin;\n      // continued at 4\\. and 5.\n    } \n    ```", "```cpp\n    std::vector<std::future<R>> tasks;\n    for(unsigned i = 0; i < no_of_tasks; ++i)\n    {\n      if(i == no_of_tasks - 1) last = end;\n      else std::advance(last, part);\n      tasks.emplace_back(\n        std::async(\n          std::launch::async,\n          [=,&op]{return std::accumulate(\n                              begin, last, R{}, \n                              std::forward<F>(op));}));\n      begin = last;\n    } \n    ```", "```cpp\n    std::vector<R> values;\n    for(auto & t : tasks)\n      values.push_back(t.get());\n    return std::accumulate(std::begin(values), std::end(values), \n                           init, std::forward<F>(op)); \n    ```", "```cpp\ntemplate <typename Iter, typename R, typename F>\nauto parallel_fold(Iter begin, Iter end, R init, F&& op)\n{\n  auto size = std::distance(begin, end);\n  if(size <= 10000)\n    return std::accumulate(begin, end, init, std::forward<F>(op));\n  else\n  {\n    auto no_of_tasks = get_no_of_threads();\n    auto part = size / no_of_tasks;\n    auto last = begin;\n    std::vector<std::future<R>> tasks;\n    for(unsigned i = 0; i < no_of_tasks; ++i)\n    {\n      if(i == no_of_tasks - 1) last = end;\n      else std::advance(last, part);\n      tasks.emplace_back(\n        std::async(\n          std::launch::async,\n          [=,&op]{return std::accumulate(\n                            begin, last, R{}, \n                            std::forward<F>(op));}));\n      begin = last;\n    }\n    std::vector<R> values;\n    for(auto & t : tasks)\n      values.push_back(t.get());\n    return std::accumulate(std::begin(values), std::end(values), \n                           init, std::forward<F>(op));\n  }\n} \n```", "```cpp\nstd::vector<int> sizes\n{\n  10000, 100000, 500000,\n  1000000, 2000000, 5000000,\n  10000000, 25000000, 50000000\n};\nstd::cout\n  << std::right << std::setw(8) << std::setfill(' ') << \"size\"\n  << std::right << std::setw(8) << \"s map\"\n  << std::right << std::setw(8) << \"p map\"\n  << std::right << std::setw(8) << \"s fold\"\n  << std::right << std::setw(8) << \"p fold\"\n  << '\\n';\nfor(auto const size : sizes)\n{\n  std::vector<int> v(size);\n  std::iota(std::begin(v), std::end(v), 1);\n  auto v1 = v;\n  auto s1 = 0LL;\n  auto tsm = perf_timer<>::duration([&] {\n    std::transform(std::begin(v1), std::end(v1), std::begin(v1), \n                   [](int const i) {return i + i; }); });\n  auto tsf = perf_timer<>::duration([&] {\n    s1 = std::accumulate(std::begin(v1), std::end(v1), 0LL,\n                         std::plus<>()); });\nauto v2 = v;\nauto s2 = 0LL;\nauto tpm = perf_timer<>::duration([&] {\n  parallel_map(std::begin(v2), std::end(v2), \n               [](int const i) {return i + i; }); });\nauto tpf = perf_timer<>::duration([&] {\n  s2 = parallel_fold(std::begin(v2), std::end(v2), 0LL, \n                       std::plus<>()); });\nassert(v1 == v2);\nassert(s1 == s2);\nstd::cout\n  << std::right << std::setw(8) << std::setfill(' ') << size\n  << std::right << std::setw(8) \n  << std::chrono::duration<double, std::micro>(tsm).count()\n  << std::right << std::setw(8) \n  << std::chrono::duration<double, std::micro>(tpm).count()\n  << std::right << std::setw(8) \n  << std::chrono::duration<double, std::micro>(tsf).count()\n  << std::right << std::setw(8) \n  << std::chrono::duration<double, std::micro>(tpf).count()\n  << '\\n';\n} \n```", "```cpp\n size   s map   p map  s fold  p fold\n   10000      11      11      11      11\n  100000     117     260     113      94\n  500000     576     303     571     201\n 1000000    1180     573    1165     283\n 2000000    2371     911    2330     519\n 5000000    5942    2144    5841    1886\n10000000   11954    4999   11643    2871\n25000000   30525   11737   29053    9048\n50000000   59665   22216   58689   12942 \n```", "```cpp\ntemplate <typename Iter, typename F>\nvoid parallel_map(Iter begin, Iter end, F f)\n{ \n  auto size = std::distance(begin, end);\n  if(size <= 10000)\n  {\n    std::transform(begin, end, begin, std::forward<F>(f)); \n  }\n  else\n  {\n    auto middle = begin;\n    std::advance(middle, size / 2);\n    auto result = std::async(\n      std::launch::deferred, \n      parallel_map<Iter, F>, \n      begin, middle, std::forward<F>(f));\n    parallel_map(middle, end, std::forward<F>(f));\n    result.wait();\n  }\n}\ntemplate <typename Iter, typename R, typename F>\nauto parallel_fold(Iter begin, Iter end, R init, F op)\n{\n  auto size = std::distance(begin, end);\n  if(size <= 10000)\n    return std::accumulate(begin, end, init, std::forward<F>(op));\n  else\n  {\n    auto middle = begin;\n    std::advance(middle, size / 2);\n    auto result1 = std::async(\n      std::launch::async, \n      parallel_reduce<Iter, R, F>, \n      begin, middle, R{}, std::forward<F>(op));\n    auto result2 = parallel_fold(middle, end, init, \n                                 std::forward<F>(op));\n    return result1.get() + result2;\n  }\n} \n```", "```cpp\n size   s map p1 map  p2 map  s fold p1 fold p2 fold\n   10000      11     11      10       7      10      10\n  100000     111    275     120      72      96     426\n  500000     551    230     596     365     210    1802\n 1000000    1142    381    1209     753     303    2378\n 2000000    2411    981    2488    1679     503    4190\n 5000000    5962   2191    6237    4177    1969    7974\n10000000   11961   4517   12581    8384    2966   15174 \n```", "```cpp\ntemplate <typename Iter, typename F>\nvoid parallel_map(Iter begin, Iter end, F&& f)\n{\n   std::transform(std::execution::par,\n                  begin, end,\n                  begin,\n                  std::forward<F>(f));\n} \n```", "```cpp\ntemplate <typename Iter, typename R, typename F>\nauto parallel_fold(Iter begin, Iter end, R init, F&& op)\n{\n   return std::reduce(std::execution::par,\n                      begin, end,\n                      init,\n                      std::forward<F>(op));\n} \n```", "```cpp\nstd::vector<int> v(size);\nstd::iota(std::begin(v), std::end(v), 1);\n// sequential\nauto sums = std::transform_reduce(\n    std::begin(v), std::end(v), \n    0LL,\n    std::plus<>(),\n    [](int const i) {return i + i; } );\n// parallel\nauto sump = std::transform_reduce(\n    std::execution::par,\n    std::begin(v), std::end(v),\n    0LL,\n    std::plus<>(),\n    [](int const i) {return i + i; }); \n```", "```cpp\n    void thread_func(int i)\n    {\n        while(i-- > 0)\n        {\n            std::cout << i << '\\n';\n        }\n    }\n    int main()\n    {\n        std::jthread t(thread_func, 10);\n    } \n    ```", "```cpp\n        void thread_func(std::stop_token st, int& i)\n        {\n            while(!st.stop_requested() && i < 100)\n            {\n                using namespace std::chrono_literals;\n                std::this_thread::sleep_for(200ms);\n                i++;\n            }\n        }\n        int main()\n        {\n            int a = 0;\n\n            std::jthread t(thread_func, std::ref(a));\n\n            using namespace std::chrono_literals;\n            std::this_thread::sleep_for(1s);\n\n            t.request_stop();\n\n            std::cout << a << '\\n';       // prints 4\n        } \n        ```", "```cpp\n        void thread_func(std::stop_token st, int& i)\n        {\n            while(!st.stop_requested() && i < 100)\n            {\n                using namespace std::chrono_literals;\n                std::this_thread::sleep_for(200ms);\n                i++;\n            }\n        }\n        int main()\n        {\n            int a = 0;\n            int b = 10;\n\n            std::stop_source st;\n\n            std::jthread t1(thread_func, st.get_token(),\n                            std::ref(a));\n            std::jthread t2(thread_func, st.get_token(),\n                            std::ref(b));\n\n            using namespace std::chrono_literals;\n            std::this_thread::sleep_for(1s);\n\n            st.request_stop();\n\n            std::cout << a << ' ' << b << '\\n';       // prints 4\n        // and 14\n        } \n        ```", "```cpp\n    void thread_func(std::stop_token st, int& i)\n    {\n        while(!st.stop_requested() && i < 100)\n        {\n            using namespace std::chrono_literals;\n            std::this_thread::sleep_for(200ms);\n            i++;\n        }\n    }\n    int main()\n    {\n        int a = 0;\n\n        std::stop_source src;\n        std::stop_token token = src.get_token();\n        std::stop_callback cb(token, []{std::cout << \"the end\\n\";});\n\n        std::jthread t(thread_func, token, std::ref(a));\n\n        using namespace std::chrono_literals;\n        std::this_thread::sleep_for(1s);\n\n        src.request_stop();\n\n        std::cout << a << '\\n';       // prints \"the end\" and 4\n    } \n    ```", "```cpp\nvoid process(std::vector<int> const& data) noexcept\n{\n   for (auto const e : data)\n      std::cout << e << ' ';  \n   std::cout << '\\n';\n}\nint create(int const i, int const factor) noexcept\n{\n   return i * factor;\n} \n```", "```cpp\n    int const jobs = 4;\n    std::latch work_done(jobs);\n    std::vector<int> data(jobs);\n    std::vector<std::jthread> threads;\n    for(int i = 1; i <= jobs; ++i)\n    {   \n       threads.push_back(std::jthread([&data, i, &work_done]{\n          using namespace std::chrono_literals;\n          std::this_thread::sleep_for(1s); // simulate work\n          data[i-1] = create(i, 1);        // create data\n\n          work_done.count_down();          // decrement counter\n       }));   \n    }\n    work_done.wait();             // wait for all jobs to finish\n    process(data);                // process data from all jobs \n    ```", "```cpp\n    int const jobs = 4;\n    std::vector<int> data(jobs);\n    int cycle = 1;\n    std::stop_source st;\n    // completion function\n    auto on_completion = [&data, &cycle, &st]() noexcept {\n       process(data);          // process data from all jobs\n       cycle++;\n       if (cycle == 10)        // stop after ten cycles\n          st.request_stop();\n       };\n    std::barrier work_done(jobs, on_completion);\n    std::vector<std::jthread> threads;\n    for (int i = 1; i <= jobs; ++i)\n    {\n       threads.push_back(std::jthread(\n          [&data, &cycle, &work_done](std::stop_token st, \n                                      int const i)\n          {\n             while (!st.stop_requested())\n             {\n                using namespace std::chrono_literals;\n                // simulate work\n                std::this_thread::sleep_for(200ms); \n                data[i-1] = create(i, cycle); // create data \n                work_done.arrive_and_wait();  // decrement counter\n             }\n          },\n          st.get_token(),\n          i));\n    }\n    for (auto& t : threads) t.join(); \n    ```", "```cpp\n    int const jobs = 4;\n    std::vector<int> data;\n    std::binary_semaphore sem(1);\n    std::vector<std::jthread> threads;\n    for (int i = 1; i <= jobs; ++i)\n    {\n       threads.push_back(std::jthread([&data, i, &sem] {\n          for (int k = 1; k < 5; ++k)\n          {\n             // simulate work\n    using namespace std::chrono_literals;\n             std::this_thread::sleep_for(200ms);\n             // create data\n    int value = create(i, k);\n             // acquire the semaphore\n             sem.acquire();\n             // write to the shared resource\n             data.push_back(value);\n             // release the semaphore\n             sem.release();\n          }\n       }));\n    }\n    for (auto& t : threads) t.join();\n    process(data); // process data from all jobs \n    ```", "```cpp\nHow to do it... section. In this example, a std::barrier is created and initialized with a counter, which represents the number of threads, and a completion function. This function processes the data produced by all the threads, then increments a loop counter, and requests threads to stop after 10 loops. This basically means that the barrier will perform 10 cycles before the threads will finish their work. Each thread loops until a stop is requested, and, in each iteration, they produce some data, written to the shared vector of integers. At the end of the loop, each thread arrives at the barrier synchronization point, decrements the counter, and waits for it to reach zero and the completion function to execute. This is done with a call to the arrive_and_wait() method of the std::barrier class.\n```", "```cpp\nstd::vector<std::jthread> threads;\nfor (int i = 1; i <= 10; ++i)\n{\n   threads.push_back(\n      std::jthread([](const int id)\n         {\n            std::osyncstream scout{ std::cout };\n            scout << \"thread \" << id << \" running\\n\";\n         }, i));\n} \n```", "```cpp\nstd::vector<std::jthread> threads;\nfor (int i = 1; i <= 10; ++i)\n{\n   threads.push_back(\n      std::jthread([](const int id)\n         {\n            std::cout << \"thread \" << id << \" running\\n\";\n         }, i));\n} \n```", "```cpp\nthread thread thread 6 running\nthread 2 running\n1 running\nthread 3 running\n5 running\nthread 4thread 7 running\nthread 10 running\nthread 9 running\n running\nthread 8 running \n```", "```cpp\nstd::vector<std::jthread> threads;\nfor (int i = 1; i <= 10; ++i)\n{\n   threads.push_back(\n      std::jthread([](const int id)\n         {\n            std::stringstream ss;\n            ss << \"thread \" << id << \" running\\n\";\n            std::cout << ss.str();\n         }, i));\n} \n```", "```cpp\nthread 1 running\nthread 2 running\nthread 3 running\nthread 4 running\nthread 5 running\nthread 6 running\nthread 7 running\nthread 8 running\nthread 9 running\nthread 10 running \n```", "```cpp\nint main()\n{\n   std::ostringstream str{ };\n   {\n      std::osyncstream syncstr{ str };\n      syncstr << \"sync stream demo\";\n      std::cout << \"A:\" << str.str() << '\\n'; // [1]\n   }\n   std::cout << \"B:\" << str.str() << '\\n';    // [2]\n} \n```", "```cpp\nA:\nB:sync stream demo \n```", "```cpp\nint main()\n{\n   std::ostringstream str{ };\n   {\n      std::osyncstream syncstr{ str };\n      syncstr << \"sync stream demo\";\n      std::cout << \"A:\" << str.str() << '\\n'; // [1]\n      syncstr.emit();\n      std::cout << \"B:\" << str.str() << '\\n'; // [2]\n      syncstr << \"demo part 2\";\n      std::cout << \"C:\" << str.str() << '\\n'; // [3]\n   }\n   std::cout << \"D:\" << str.str() << '\\n';    // [4]\n} \n```", "```cpp\nA:\nB:sync stream demo\nC:sync stream demo\nD:sync stream demodemo part 2 \n```", "```cpp\nint main()\n{\n   std::ostringstream str{ };\n   {\n      std::osyncstream syncstr{ str };\n      syncstr << \"sync stream demo\";\n      std::cout << \"A:\" << str.str() << '\\n';    // [1]\n      {\n         std::osyncstream syncstr2{ syncstr.get_wrapped() };\n         syncstr2 << \"demo part 3\";\n         std::cout << \"B:\" << str.str() << '\\n'; // [2]\n      }\n      std::cout << \"C:\" << str.str() << '\\n';    // [3]\n   }\n   std::cout << \"D:\" << str.str() << '\\n';       // [4]\n} \n```", "```cpp\nA:\nB:\nC:demo part 3\nD:demo part 3sync stream demo \n```", "```cpp\nthreads.push_back(\n   std::jthread([](const int id)\n      {\n         std::osyncstream{ std::cout } << \"thread \" << id \n                                       << \" running\\n\";\n      }, i)); \n```"]