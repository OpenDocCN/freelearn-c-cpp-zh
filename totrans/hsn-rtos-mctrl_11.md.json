["```cpp\n//create storage for a pointer to a semaphore\nSemaphoreHandle_t semPtr = NULL;\n\nint main(void)\n{\n    //.... init code removed.... //\n\n    //create a semaphore using the FreeRTOS Heap\n semPtr = xSemaphoreCreateBinary(); //ensure pointer is valid (semaphore created successfully)\n assert_param(semPtr != NULL);\n```", "```cpp\nvoid GreenTaskA( void* argument )\n{\n  uint_fast8_t count = 0;\n  while(1)\n  {\n    //every 5 times through the loop, give the semaphore\n    if(++count >= 5)\n    {\n      count = 0;\n      SEGGER_SYSVIEW_PrintfHost(\"Task A (green LED) gives semPtr\");\n xSemaphoreGive(semPtr);\n    }\n    GreenLed.On();\n    vTaskDelay(100/portTICK_PERIOD_MS);\n    GreenLed.Off();\n    vTaskDelay(100/portTICK_PERIOD_MS);\n  }\n}\n```", "```cpp\n/**\n * wait to receive semPtr and triple blink the Blue LED\n */\nvoid BlueTaskB( void* argument )\n{\n  while(1)\n  {\n if(xSemaphoreTake(semPtr, portMAX_DELAY) == pdPASS)\n    {   \n        //triple blink the Blue LED\n        for(uint_fast8_t i = 0; i < 3; i++)\n        {\n            BlueLed.On();\n            vTaskDelay(50/portTICK_PERIOD_MS);\n            BlueLed.Off();\n            vTaskDelay(50/portTICK_PERIOD_MS);\n        }\n    }\n    else\n    {\n        // This is the code that will be executed if we time out\n        // waiting for the semaphore to be given\n    }\n  }\n}\n```", "```cpp\nvoid GreenTaskA( void* argument )\n{\n  uint_fast8_t count = 0;\n  while(1)\n  {\n    //every 5 times through the loop, set the flag\n    if(++count >= 5)\n    {\n      count = 0;\n      SEGGER_SYSVIEW_PrintfHost(\"Task A (green LED) sets flag\");\n flag = 1; //set 'flag' to 1 to \"signal\" BlueTaskB to run\n```", "```cpp\nvoid BlueTaskB( void* argument )\n{\n  while(1)\n  {\n      SEGGER_SYSVIEW_PrintfHost(\"Task B (Blue LED) starts \"\\\n                                \"polling on flag\");\n\n    //repeateadly poll on flag. As soon as it is non-zero,\n    //blink the blue LED 3 times\n while(!flag);    SEGGER_SYSVIEW_PrintfHost(\"Task B (Blue LED) received flag\");\n```", "```cpp\nwhile(!flag)\n{\n    vTaskDelay(1);\n}\n```", "```cpp\nBaseType_t xSemaphoreTake( SemaphoreHandle_t xSemaphore,\n                            TickType_t xTicksToWait );\n\n```", "```cpp\nvoid GreenTaskA( void* argument )\n{\n    uint_fast8_t count = 0;\n    while(1)\n    {\n        uint8_t numLoops = StmRand(3,7);\n        if(++count >= numLoops)\n        {\n            count = 0;\n xSemaphoreGive(semPtr);\n        }\n greenBlink();\n    }\n}\n```", "```cpp\nvoid TaskB( void* argument )\n{\n    while(1)\n    {\n //'take' the semaphore with a 500mS timeout                    \n        if(xSemaphoreTake(semPtr, 500/portTICK_PERIOD_MS) == pdPASS)\n        {\n //received semPtr in time\n            RedLed.Off();\n            blueTripleBlink();\n        }\n        else\n {\n //this code is called when the \n //semaphore wasn't taken in time \n            RedLed.On();\n        }\n    }\n}\n```", "```cpp\nSemaphoreHandle_t semPtr = NULL;\nsemPtr = xSemaphoreCreateCounting( /*max count*/3, /*init count*/ 3);\nif(semPtr != NULL)\n```", "```cpp\nif(xSemaphoreTake( semPtr, /*timeoutTicks*/100) == pdPASS)\n{\n    //resources for TCP session are available\n}\nelse\n{\n    //timed out waiting for session to become available\n}\n```", "```cpp\nxSemaphoreGive( semPtr );\n```", "```cpp\nwhile(1)\n{\n    //'take' the semaphore with a 200mS timeout\n    SEGGER_SYSVIEW_PrintfHost(\"attempt to take semPtr\");\n if(xSemaphoreTake(semPtr, 200/portTICK_PERIOD_MS) == pdPASS)\n    {\n        RedLed.Off();\n        SEGGER_SYSVIEW_PrintfHost(\"received semPtr\");\n blinkTwice(&GreenLed);\n xSemaphoreGive(semPtr);\n    }\n    else\n    {\n        //this code is called when the \n //semaphore wasn't taken in time\n        SEGGER_SYSVIEW_PrintfHost(\"FAILED to receive \"\n                                    \"semphr in time\");\n        RedLed.On();\n    }\n    //sleep for a bit to let other tasks run\n    vTaskDelay(StmRand(10,30));\n}\n```", "```cpp\nuint32_t counter = 0;\nwhile(1)\n{\n    SEGGER_SYSVIEW_PrintfHost(\"starting iteration %ui\", counter);\n    vTaskDelay(StmRand(75,150));\n    lookBusy(StmRand(250000, 750000));\n}\n```", "```cpp\nwhile(1)\n  {\n    //'take' the semaphore with a 200mS timeout\n    SEGGER_SYSVIEW_PrintfHost(\"attempt to take semPtr\");\n if(xSemaphoreTake(semPtr, 200/portTICK_PERIOD_MS) == pdPASS)\n    {\n      RedLed.Off();\n      SEGGER_SYSVIEW_PrintfHost(\"received semPtr\");\n      blinkTwice(&BlueLed);\n xSemaphoreGive(semPtr);\n    }\n    else\n    {\n //this code is called when the semaphore wasn't taken in time\n      SEGGER_SYSVIEW_PrintfHost(\"FAILED to receive \"\n                                    \"semphr in time\");\n      RedLed.On();\n    }\n  }\n```", "```cpp\nSEGGER_SYSVIEW_PrintfHost(\"FAILED to receive \"\n\"semphr in time\");\n```", "```cpp\nmutexPtr = xSemaphoreCreateMutex();\nassert_param(mutexPtr != NULL);\n```", "```cpp\nif(xSemaphoreTake(mutexPtr, 200/portTICK_PERIOD_MS) == pdPASS)\n{\n    //critical section is here\n //KEEP THIS AS SHORT AS POSSIBLE\n    xSemaphoreGive(mutexPtr);\n}\n```", "```cpp\nif(xSemaphoreTake(mutexPtr, 200/portTICK_PERIOD_MS) == pdPASS)\n{\n    //critical section starts here\n    uint32_t aVariable, returnValue;\n    aVariable = PerformSomeOperation(someOtherVarNotProtectedbyMutexPtr);\n    returnValue = callAnotherFunction(aVariable);\n\n    protectedData = returnValue; //critical section ends here\n    xSemaphoreGive(mutexPtr);\n}\n```", "```cpp\nuint32_t aVariable, returnValue;\naVariable = PerformSomeOperation(someOtherVarNotProtectedbyMutexPtr);\nreturnValue = callAnotherFunction(aVariable);\n\nif(xSemaphoreTake(mutexPtr, 200/portTICK_PERIOD_MS) == pdPASS)\n{\n    //critical section starts here\n    protectedData = returnValue; //critical section ends here\n    xSemaphoreGive(mutexPtr);\n}\n```", "```cpp\nstruct AccelReadings\n{\n    uint16_t X;\n    uint16_t Y;\n    uint16_t Z;\n};\nstruct AccelReadings sharedData;\n```", "```cpp\nvoid Task1( void* args)\n{\n    while(1)\n    {\n        updateValues();\n        sharedData.X = newXValue;\n        sharedData.Y = newYValue;\n        sharedData.Z = newZValue;\n    }\n}\n\n```", "```cpp\nvoid Task2( void* args)\n{\n    uint16_t myX, myY, myZ;\n    while(1)\n    {\n        myX = sharedData.X;\n        myY = sharedData.Y;\n        myZ = sharedData.Z;\n        calculation(myX, myY, myZ);\n    }\n}\n```", "```cpp\nvoid Task1( void* args)\n{\n    while(1)\n    {\n        updateValues();\n        if(xSemaphoreTake(mutexPtr, timeout) == pdPASS)\n        {\n            sharedData.X = newXValue;    //critical section start\n            sharedData.Y = newYValue;\n            sharedData.Z = newZValue;    //critical section end\n            xSemaphoreGive(mutexPtr);\n        }\n        else { /* report failure */}\n    }\n}\n```", "```cpp\n\nvoid Task2( void* args)\n{\n    uint16_t myX, myY, myZ;\n    while(1)\n    {\n        if(xSemaphoreTake(mutexPtr, timeout) == pdPASS)\n        {\n            myX = sharedData.X; //critical section start\n            myY = sharedData.Y;\n            myZ = sharedData.Z; //critical section end\n xSemaphoreGive(mutexPtr);\n\n            //keep the critical section short\n            calculation(myX, myY, myZ);\n        }\n        else{ /* report failure */ }\n    }\n}\n```", "```cpp\n/* Software timer definitions. */\n#define configUSE_TIMERS 1\n#define configTIMER_TASK_PRIORITY ( 2 )\n#define configTIMER_QUEUE_LENGTH 10\n#define configTIMER_TASK_STACK_DEPTH 256\n```", "```cpp\nvoid oneShotCallBack( TimerHandle_t xTimer );\n```", "```cpp\nTimerHandle_t xTimerCreate (    const char * const pcTimerName, \n                                const TickType_t xTimerPeriod, \n                                const UBaseType_t uxAutoReload,\n                                void * const pvTimerID, \n                                TimerCallbackFunction_t pxCallbackFunction );\n```", "```cpp\nTimerHandle_t oneShotHandle = \nxTimerCreate(   \"myOneShotTimer\",        //name for timer\n                2200/portTICK_PERIOD_MS, //period of timer in ticks\n                pdFALSE,                 //auto-reload flag\n                NULL,                    //unique ID for timer\n                oneShotCallBack);        //callback function\nassert_param(oneShotHandle != NULL);     //ensure creation\nxTimerStart(oneShotHandle, 0);           //start with scheduler\n```", "```cpp\n\nvoid oneShotCallBack( TimerHandle_t xTimer )\n{\n    BlueLed.Off();\n}\n```", "```cpp\nTimerHandle_t repeatHandle = \nxTimerCreate(   \"myRepeatTimer\",         //name for timer\n                500 /portTICK_PERIOD_MS, //period of timer in ticks\n                pdTRUE,                  //auto-reload flag\n                NULL,                    //unique ID for timer\n                repeatCallBack);          //callback function\nassert_param(repeatHandle != NULL);\nxTimerStart(repeatHandle , 0);\n```", "```cpp\nvoid repeatCallBack( TimerHandle_t xTimer )\n{\n    static uint32_t counter = 0;\n    if(counter++ % 2)\n    {\n        GreenLed.On();\n    }\n    else\n    {\n        GreenLed.Off();\n    }\n}\n```"]