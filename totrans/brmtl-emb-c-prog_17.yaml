- en: '17'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '17'
- en: Direct Memory Access (DMA)
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 直接内存访问（DMA）
- en: In this chapter, we will explore **Direct Memory Access** (**DMA**), a powerful
    feature in microcontrollers that allows peripherals to transfer data to and from
    memory without involving the CPU. This functionality is critical for improving
    data throughput and freeing up the CPU to handle other tasks, making it fundamental
    to high-performance embedded system development.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨 **直接内存访问**（**DMA**），这是微控制器中的一个强大功能，允许外设在不涉及 CPU 的情况下在内存之间传输数据。这种功能对于提高数据吞吐量和释放
    CPU 以处理其他任务至关重要，对于高性能嵌入式系统开发是基础。
- en: We will begin by understanding the basic principles of DMA and its significance
    in embedded systems. We will then delve into the specifics of the DMA controller
    in STM32F4 microcontrollers, examining its structure and features and how it manages
    data transfers. Following this, we will apply this theoretical knowledge to develop
    practical DMA drivers for various use cases, including memory-to-memory transfers,
    **Analog-to-Digital Converter** (**ADC**) data transfers, and **Universal Asynchronous
    Receiver-Transmitter** (**UART**) communications.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先了解 DMA 的基本原理及其在嵌入式系统中的重要性。然后，我们将深入研究 STM32F4 微控制器中 DMA 控制器的具体细节，检查其结构和功能以及它如何管理数据传输。随后，我们将应用这些理论知识来开发针对各种用例的实用
    DMA 驱动程序，包括内存到内存传输、**模拟数字转换器**（**ADC**）数据传输和**通用异步收发传输器**（**UART**）通信。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: An overview of DMA
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DMA 概述
- en: The STM32F4 DMA
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: STM32F4 DMA
- en: Developing the DMA ADC driver
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发 DMA ADC 驱动程序
- en: Developing the DMA UART driver
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发 DMA UART 驱动程序
- en: Developing the DMA memory-to-memory driver
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发 DMA 内存到内存驱动程序
- en: By the end of this chapter, you will have a comprehensive understanding of how
    DMA works and how to implement it in your projects. You will be able to develop
    efficient DMA drivers to handle data transfers in various scenarios, significantly
    enhancing the performance and responsiveness of your embedded systems.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将全面了解 DMA 的工作原理以及如何在项目中实现它。您将能够开发高效的 DMA 驱动程序来处理各种场景下的数据传输，显著提升嵌入式系统的性能和响应速度。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming](https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码示例都可以在 GitHub 上找到：[https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming](https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming)。
- en: Understanding Direct Memory Access (DMA)
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解直接内存访问（DMA）
- en: DMA is a feature that can significantly elevate the performance of your embedded
    systems. If you’ve been dealing with data transfers in your microcontroller projects,
    you know how taxing it can be on the CPU to handle all that data movement. This
    is where DMA steps in as a game-changer, offloading the data transfer tasks from
    the CPU and allowing it to focus on more critical functions. Let’s see how it
    works.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: DMA 是一个可以显著提升您嵌入式系统性能的功能。如果您在微控制器项目中处理过数据传输，您就知道这对 CPU 来说是一项多么繁重的任务，需要处理所有这些数据移动。这就是
    DMA 走进来成为游戏改变者的地方，它将数据传输任务从 CPU 中卸载，使其能够专注于更关键的功能。让我们看看它是如何工作的。
- en: How DMA works
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DMA 的工作原理
- en: So, what exactly is DMA, and how does it work? In simple terms, DMA is a method
    that allows peripherals within a microcontroller to transfer data directly to
    and from memory, without requiring continuous CPU intervention. Imagine it as
    a dedicated assistant that takes over the tedious task of moving boxes (data)
    so that you (the CPU) can focus on more important work, such as solving complex
    problems or managing other peripherals.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，DMA 究竟是什么，它是如何工作的呢？简单来说，DMA 是一种允许微控制器内的外设直接在内存之间传输数据的方法，无需持续 CPU 干预。想象一下，它就像一个专门的助手，接管了移动盒子（数据）的繁琐任务，让您（CPU）可以专注于更重要的工作，比如解决复杂问题或管理其他外设。
- en: A typical DMA controller in a microcontroller has multiple channels, each capable
    of handling a specific data transfer operation. Each channel can be configured
    independently to manage transfers between various peripherals and memory.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 微控制器中的典型 DMA 控制器具有多个通道，每个通道都能够处理特定的数据传输操作。每个通道都可以独立配置，以管理各种外设和内存之间的传输。
- en: 'Here’s a step-by-step look at how DMA generally operates:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 下面我们将一步一步地看看 DMA 通常是如何操作的：
- en: '**Initialization**: The DMA controller and channels are configured. This setup
    includes specifying the source and destination addresses, the direction of data
    transfer, and the number of data units to transfer.'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**初始化**: 配置 DMA 控制器和通道。此设置包括指定源地址和目标地址、数据传输方向以及要传输的数据单元数量。'
- en: '**Trigger**: The data transfer is initiated by a trigger, which can be an event
    such as a peripheral signaling that it’s ready to send or receive data, or a software
    command.'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**触发器**: 数据传输由触发器启动，这可以是一个事件，例如外围设备表示它已准备好发送或接收数据，或者是一个软件命令。'
- en: '**Data transfer**: Once triggered, the DMA controller takes over, reading data
    from the source address and writing it to the destination address. This process
    continues until the specified number of data units is transferred.'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**数据传输**: 一旦触发，DMA 控制器接管，从源地址读取数据并将其写入目标地址。这个过程一直持续到指定的数据单元数量传输完毕。'
- en: '**Completion**: Upon completing the transfer, the DMA controller can generate
    an interrupt to notify the CPU that the transfer is done, allowing the system
    to perform any necessary post-transfer processing.'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**完成**: 在传输完成后，DMA 控制器可以生成一个中断来通知 CPU 传输已完成，从而使系统能够执行任何必要的传输后处理。'
- en: Next, let’s take a look at some key features of DMA controllers.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 DMA 控制器的关键特性。
- en: Key features
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关键特性
- en: 'DMA controllers are packed with features that make them versatile and powerful.
    Let’s break down some of the key specifications you’ll often encounter:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: DMA 控制器集成了许多特性，使它们变得多功能且强大。让我们分解一些你经常遇到的 key specifications：
- en: '**Channels and streams**: DMA controllers typically have multiple channels
    and streams, each capable of handling a different transfer. For instance, the
    STM32F4 microcontroller has up to 16 streams in its DMA controllers.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通道和流**: DMA 控制器通常具有多个通道和流，每个都能处理不同的传输。例如，STM32F4 微控制器在其 DMA 控制器中最多有 16 个流。'
- en: '**Priorities**: Channels can be assigned different priority levels, ensuring
    that more critical transfers get precedence over less critical ones.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优先级**: 通道可以分配不同的优先级，确保更关键传输的优先级高于不那么关键的传输。'
- en: '**Transfer Types**: DMA can handle various types of transfers, including memory-to-memory,
    peripheral-to-memory, and memory-to-peripheral.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传输类型**: DMA 可以处理各种类型的传输，包括内存到内存、外设到内存和内存到外设。'
- en: '**FIFO**: Some DMA controllers come with a **First-In-First-Out** (**FIFO**)
    buffer, which helps manage data flow and improve efficiency, especially in burst
    transfers.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FIFO**: 一些 DMA 控制器配备了 **先进先出**（**FIFO**）缓冲区，这有助于管理数据流并提高效率，尤其是在突发传输中。'
- en: '**Circular mode**: This mode allows the DMA to continuously transfer data in
    a loop, which is particularly useful for peripherals that need constant data streaming,
    such as audio or video feeds.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**循环模式**: 此模式允许 DMA 在循环中连续传输数据，这对于需要持续数据流的设备特别有用，例如音频或视频流。'
- en: '**Interrupts**: DMA controllers can generate interrupts on transfer completion,
    half-transfer completion, and transfer errors, allowing the CPU to react appropriately
    to different stages of the transfer.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中断**: DMA 控制器可以在传输完成、半传输完成和传输错误时生成中断，使 CPU 能够对传输的不同阶段做出适当的反应。'
- en: To understand the real power of DMA, let’s look at some common use cases where
    DMA shines.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解 DMA 的真正威力，让我们看看一些 DMA 发挥作用的常见用例。
- en: Common use cases
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见用例
- en: 'Here are some common use cases of DMA:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些 DMA 的常见用例：
- en: '**Audio streaming**: DMA is heavily used in audio applications where continuous
    data streaming is essential. For instance, in a digital audio player, the audio
    samples must be continuously sent to a **Digital-to-Analog Converter** (**DAC**).
    Using DMA, the audio data can be streamed from memory to the DAC without CPU intervention,
    ensuring smooth playback and freeing up the CPU to manage the user interface and
    other tasks.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**音频流传输**: DMA 在需要连续数据流的应用程序中被大量使用，这对于音频应用至关重要。例如，在数字音频播放器中，音频样本必须连续发送到 **数字到模拟转换器**（**DAC**）。使用
    DMA，音频数据可以从内存流到 DAC，而无需 CPU 干预，确保流畅播放并释放 CPU 来管理用户界面和其他任务。'
- en: '**Sensor data acquisition**: In applications such as environmental monitoring
    or industrial automation, sensors often need to sample data at precise intervals.
    For example, an ADC can be configured to continuously sample temperature data,
    with DMA transferring the sampled data directly to memory. This setup ensures
    that the CPU isn’t bogged down with handling each individual sample, thus maintaining
    efficient and timely data collection.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传感器数据采集**：在环境监测或工业自动化等应用中，传感器通常需要以精确的间隔采样数据。例如，ADC 可以配置为连续采样温度数据，DMA 将采样数据直接传输到内存。这种设置确保
    CPU 不会被处理每个单独样本所拖累，从而保持高效及时的数据收集。'
- en: '**Communication interfaces**: DMA is a lifesaver when dealing with high-speed
    communication protocols such as UART, SPI, or I2C. Consider a scenario where an
    embedded system needs to log data received over UART to an SD card. Without DMA,
    the CPU would need to handle each byte of data, process it, and then write it
    to the SD card, which can be highly inefficient. With DMA, the data received over
    UART can be directly written to memory, and another DMA channel can transfer it
    to the SD card, all with minimal CPU intervention.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通信接口**：在处理高速通信协议（如 UART、SPI 或 I2C）时，DMA 是救命稻草。考虑这样一个场景，嵌入式系统需要将通过 UART 接收到的数据记录到
    SD 卡。如果没有 DMA，CPU 需要处理每个数据字节，对其进行处理，然后将其写入 SD 卡，这可以非常低效。使用 DMA，通过 UART 接收到的数据可以直接写入内存，另一个
    DMA 通道可以将其传输到 SD 卡，所有这些操作都只需要最小的 CPU 干预。'
- en: '**Graphics processing**: DMA is also crucial in applications involving graphics,
    such as updating a display buffer. In a system where the display needs to be refreshed
    continuously, the DMA can handle the transfer of image data from memory to the
    display controller. This ensures smooth and flicker-free graphics rendering, while
    the CPU can focus on generating the next frame or managing user inputs.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图形处理**：DMA 在涉及图形的应用程序中也至关重要，例如更新显示缓冲区。在一个需要不断刷新显示的系统中，DMA 可以处理从内存到显示控制器的图像数据传输。这确保了平滑且无闪烁的图形渲染，同时
    CPU 可以专注于生成下一帧或管理用户输入。'
- en: With this in mind, let’s compare some DMA solutions to non-DMA solutions.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，让我们比较一些 DMA 解决方案和非 DMA 解决方案。
- en: Case study 1 – audio streaming
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 案例研究 1 – 音频流
- en: '**Scenario**: You are developing an audio playback system that streams digital
    audio data from a microcontroller to a DAC.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景**：你正在开发一个音频播放系统，该系统从微控制器流式传输数字音频数据到 DAC。'
- en: '**Without DMA**: The CPU is responsible for fetching each audio sample from
    memory and sending it to the DAC. Given the high sampling rate required for audio
    applications (e.g., 44.1 kHz for CD-quality audio), the CPU must handle tens of
    thousands of interrupts per second just to maintain the audio stream. This constant
    load significantly limits the CPU’s ability to perform other tasks, potentially
    leading to audio glitches and reduced system responsiveness.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**不使用 DMA**：CPU 负责从内存中检索每个音频样本并发送到 DAC。鉴于音频应用所需的高采样率（例如，CD 音质音频的 44.1 kHz），CPU
    必须每秒处理数万个中断，仅为了保持音频流。这种持续的负载显著限制了 CPU 执行其他任务的能力，可能导致音频故障和系统响应速度降低。'
- en: '**With DMA**: The DMA controller is configured to transfer audio data directly
    from memory to the DAC. The CPU sets up the DMA transfer and then handles higher-level
    tasks, only occasionally checking the status of the transfer. This setup ensures
    smooth and uninterrupted audio playback while freeing up the CPU to manage other
    aspects of the system, such as user interface and control logic.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 DMA**：DMA 控制器被配置为直接从内存传输音频数据到 DAC。CPU 设置 DMA 传输并处理更高级别的任务，仅偶尔检查传输状态。这种设置确保了平滑且不间断的音频播放，同时释放
    CPU 来管理系统的其他方面，例如用户界面和控制逻辑。'
- en: Case study 2 – high-speed data acquisition
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 案例研究 2 – 高速数据采集
- en: '**Scenario**: You are developing a data acquisition system that continuously
    samples data from multiple sensors via ADCs and stores the data for later analysis.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景**：你正在开发一个数据采集系统，该系统通过 ADC 连续从多个传感器采样数据，并将数据存储以供后续分析。'
- en: '**Without DMA**: The CPU must handle each ADC conversion, read the data, and
    store it in memory. If the sampling rate is high, the CPU can become overwhelmed,
    leading to missed samples and unreliable data collection. This approach can also
    complicate real-time data processing and analysis, as the CPU is bogged down with
    managing the data flow.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**不使用DMA**：CPU必须处理每个ADC转换，读取数据并将其存储在内存中。如果采样率很高，CPU可能会过载，导致样本丢失和数据收集不可靠。这种方法也可能使实时数据处理和分析复杂化，因为CPU被数据流管理所困扰。'
- en: '**With DMA**: The ADC is configured to generate DMA requests. Each time a conversion
    is complete, the DMA controller transfers the data from the ADC to memory without
    CPU intervention. The CPU can then process the collected data in batches, ensuring
    that no samples are missed and enabling real-time data analysis and decision-making.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用DMA**：ADC被配置为生成DMA请求。每次转换完成后，DMA控制器将数据从ADC传输到内存，无需CPU干预。CPU可以随后批量处理收集到的数据，确保没有样本丢失，并实现实时数据分析和决策。'
- en: Case study 3 – an LCD display refresh
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 案例研究3 – LCD显示刷新
- en: '**Scenario**: You are developing a graphical application that continuously
    updates an LCD display with new data.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景**：您正在开发一个图形应用程序，该程序持续更新LCD显示屏上的新数据。'
- en: '**Without DMA**: The CPU must update the display by sending each pixel or line
    of data directly to the LCD controller. This process can be very CPU-intensive,
    especially for high-resolution displays, leading to sluggish performance and reduced
    responsiveness in the user interface.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**不使用DMA**：CPU必须通过直接将每个像素或数据行发送到LCD控制器来更新显示。这个过程可能非常占用CPU资源，特别是对于高分辨率显示器，会导致性能下降和用户界面响应性降低。'
- en: '**With DMA**: The DMA controller is configured to transfer display data from
    memory to the LCD controller. The CPU sets up the DMA transfer and then focuses
    on generating new graphical data or handling user inputs. The DMA controller ensures
    that the display is updated smoothly and efficiently.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用DMA**：DMA控制器被配置为从内存传输显示数据到LCD控制器。CPU设置DMA传输然后专注于生成新的图形数据或处理用户输入。DMA控制器确保显示平滑高效地更新。'
- en: In each of the case studies, we’ve seen how using DMA can transform a system’s
    capabilities, freeing up the CPU to handle more critical tasks and ensuring that
    data transfers are handled efficiently and reliably. Understanding and implementing
    DMA in your projects can lead to more robust, responsive, and high-performance
    embedded systems.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个案例研究中，我们都看到了使用DMA如何改变系统的能力，释放CPU来处理更关键的任务，并确保数据传输高效可靠。在您的项目中理解和实现DMA可以导致更健壮、响应更快、性能更高的嵌入式系统。
- en: In the following section, we will delve deeper into the specifics of the STM32F4
    DMA controller, exploring its architecture, key registers, and practical implementation
    techniques.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将深入了解STM32F4 DMA控制器的具体细节，探讨其架构、关键寄存器和实际实现技术。
- en: The DMA modules of the STM32F4 microcontroller
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: STM32F4微控制器的DMA模块
- en: Each STM32F4 microcontroller is equipped with **two DMA** controllers, each
    supporting up to **8 streams**. Each stream can manage multiple requests, providing
    up to **16 streams** in total to handle various data transfer tasks. A **stream**
    is a unidirectional pathway that facilitates data transfer between a source and
    a destination. The architecture includes an **arbiter** to prioritize these DMA
    requests, ensuring that high-priority transfers are handled promptly.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 每个STM32F4微控制器配备**两个DMA控制器**，每个控制器支持多达**8个流**。每个流可以管理多个请求，总共提供**16个流**来处理各种数据传输任务。**流**是一个单向路径，它促进了源和目的地之间的数据传输。该架构包括一个**仲裁器**来优先处理这些DMA请求，确保高优先级传输得到及时处理。
- en: Let’s see some key features of the STM32F4 DMA controller.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看STM32F4 DMA控制器的一些关键特性。
- en: The key features of the STM32F4 DMA controller
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: STM32F4 DMA控制器的关键特性
- en: 'The following are the key features of the STM32F4 DMA controller:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下STM32F4 DMA控制器的关键特性：
- en: '**Independent FIFO**: Each stream includes a **four-word FIFO buffer**, which
    can operate in either direct mode or FIFO mode. In direct mode, data transfers
    occur immediately upon request, while FIFO mode allows for **threshold-level buffering**,
    enhancing efficiency for burst data transfers.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**独立FIFO**：每个流包含一个**四字FIFO缓冲区**，可以以直接模式或FIFO模式运行。在直接模式下，数据传输在请求后立即发生，而FIFO模式允许**阈值级缓冲**，提高突发数据传输的效率。'
- en: '**Flexible configuration**: Each stream can be configured to handle the following:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活配置**：每个流可以配置为处理以下内容：'
- en: Peripheral-to-memory
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外设到内存
- en: Memory-to-peripheral
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存到外设
- en: Memory-to-memory transfers
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存到内存传输
- en: 'Additionally, streams can be set up for regular or double-buffer transfers,
    the latter enabling seamless data handling by swapping memory buffers automatically:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，可以设置流进行常规或双缓冲传输，后者通过自动交换内存缓冲区实现无缝的数据处理：
- en: '**Prioritization and arbitration**: DMA stream requests are prioritized via
    software with four levels – **very high**, **high**, **medium**, and **low**.
    If two streams have the same priority, hardware prioritization based on the stream
    number ensures orderly data transfer.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优先级和仲裁**：DMA流请求通过软件以四个级别进行优先级排序——**非常高**、**高**、**中**和**低**。如果两个流的优先级相同，基于流号的硬件优先级确保有序的数据传输。'
- en: '**Incremental and burst transfers**: The DMA controller supports both incremental
    and non-incremental addressing for source and destination. It can manage burst
    transfers of **4, 8, or 16 beats**, optimizing bandwidth usage. The term **beat**
    refers to the individual units of data that are transferred in a single DMA transaction.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增量和非增量传输**：DMA控制器支持源和目标地址的增量和非增量寻址。它可以管理**4、8或16次打击**的突发传输，优化带宽使用。术语**打击**指的是在单个DMA事务中传输的数据的单独单元。'
- en: '**Interrupts and error handling**: Each stream supports multiple event flags
    such as transfer complete, half-transfer, transfer error, FIFO error, and direct
    mode error. These flags can trigger interrupts, providing robust error handling
    and status monitoring.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中断和错误处理**：每个流支持多个事件标志，如传输完成、半传输、传输错误、FIFO错误和直接模式错误。这些标志可以触发中断，提供强大的错误处理和状态监控。'
- en: To fully utilize the STM32F DMA controller, it’s important to understand DMA
    transactions and channel selection. Let’s break these concepts down.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要充分利用STM32F DMA控制器，了解DMA事务和通道选择非常重要。让我们分解这些概念。
- en: '`DMA_SxNDTR` register to track the number of remaining data items'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`DMA_SxNDTR`寄存器跟踪剩余数据项的数量
- en: '`CHSEL` bits in the `DMA_SxCR` register. This flexibility allows various peripherals
    to initiate DMA requests efficiently.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DMA_SxCR`寄存器中的`CHSEL`位。这种灵活性允许各种外设有效地启动DMA请求。'
- en: Previously, we discussed that the STM32F4 DMA controller supports three distinct
    transfer modes. Now, let’s explore the characteristics of each mode.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们讨论了STM32F4 DMA控制器支持三种不同的传输模式。现在，让我们探索每种模式的特性。
- en: Transfer modes
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传输模式
- en: 'There are three transfer modes:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种传输模式：
- en: '`EN` bit in the `DMA_SxCR` register. The stream transfers data from the peripheral
    to memory, using the FIFO buffer if enabled.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DMA_SxCR`寄存器中的`EN`位。如果启用，该位使用FIFO缓冲区将数据从外设传输到内存。'
- en: '**Memory-to-peripheral mode**: This is similar to peripheral-to-memory, but
    the transfer direction is reversed. Data is loaded from memory and sent to the
    peripheral.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存到外设模式**：这与外设到内存类似，但传输方向相反。数据从内存加载并发送到外设。'
- en: '**Memory-to-memory mode**: This mode is unique, as it does not require peripheral
    requests. The DMA stream transfers data between two memory locations, using the
    FIFO buffer if enabled. This is particularly useful for large data transfers within
    memory.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存到内存模式**：这种模式是独特的，因为它不需要外设请求。DMA流在两个内存位置之间传输数据，如果启用，则使用FIFO缓冲区。这对于内存内部的大数据传输特别有用。'
- en: The DMA controller can automatically increment source and destination pointers,
    facilitating efficient data transfers across different memory regions. This is
    configurable via the `PINC` and `MINC` bits in the `DMA_SxCR` register.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: DMA控制器可以自动增加源和目标指针，从而在不同内存区域之间实现高效的数据传输。这可以通过`DMA_SxCR`寄存器中的`PINC`和`MINC`位进行配置。
- en: The STM32F4 DMA controller also provides data mode options.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: STM32F4 DMA控制器还提供了数据模式选项。
- en: DMA data modes
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DMA数据模式
- en: 'This data mode options include the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此数据模式选项包括以下内容：
- en: '`DMA_SxNDTR` register. This is especially useful for applications such as ADC
    sampling, where data needs to be continuously recorded.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DMA_SxNDTR`寄存器。这对于需要连续记录数据的应用程序（如ADC采样）特别有用。'
- en: '**Double buffer mode**: Double buffer mode enhances efficiency by allowing
    the DMA controller to swap between two memory buffers automatically. This ensures
    continuous data processing. While the CPU works on one buffer, the DMA can load
    the next set of data into the other buffer.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**双缓冲模式**：双缓冲模式通过允许DMA控制器自动在两个内存缓冲区之间交换，从而提高效率。这确保了连续的数据处理。当CPU处理一个缓冲区时，DMA可以将下一组数据加载到另一个缓冲区中。'
- en: In the next section, we will examine the STM32F4 DMA block diagram from the
    reference manual. This will help us better understand the key characteristics
    and functionalities of the DMA controller.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: The STM32F4 DMA block diagram
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The DMA has **two ports** for data transfer – one peripheral port and one memory
    port, as shown in *Figure 17**.1*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.1: The DMA module, indicating the data transfer ports](img/B21914_17_1.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.1: The DMA module, indicating the data transfer ports'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Each of the two DMA modules features **eight distinct streams**, with each stream
    dedicated to handling memory access requests from various peripherals.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.2: The DMA module, indicating the streams](img/B21914_17_2.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.2: The DMA module, indicating the streams'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Each stream can accommodate up to **eight selectable channels**, which are software-configurable
    to enable multiple peripherals to initiate DMA requests. However, within any given
    stream, only one channel can be active at a time.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.3: The DMA module, with channels zoomed in](img/B21914_17_3.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.3: The DMA module, with channels zoomed in'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: To find the mappings of DMA channels and streams to the various peripherals
    of the microcontroller, refer to *page 170* of the reference manual (**RM0383**).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Before we start developing our DMA drivers, the final piece of the puzzle involves
    familiarizing ourselves with the key DMA registers.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: The key STM32 DMA registers
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will explore the characteristics and functions of some of
    the crucial registers within the DMA peripheral, starting with the DMA Stream
    Configuration Register.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: The DMA Stream Configuration Register (DMA_SxCR)
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The DMA Stream Configuration Register (`DMA_SxCR`) is one of the primary registers
    used to configure a DMA stream’s operational settings. This register allows us
    to set up various parameters, such as the **data direction**, the **size** of
    the data items, and the **priority** level of the stream. The key bits in this
    register include the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '**EN**: Stream enable. Setting this bit activates the stream.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CHSEL[2:0]**: Channel selection. These bits select the DMA channel for the
    stream.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DIR[1:0]**: Data transfer direction. These bits specify the direction of
    the data transfer (peripheral-to-memory, memory-to-peripheral, or memory-to-memory).'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CIRC**: Circular mode. Setting this bit enables circular mode, which allows
    continuous data transfers.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PINC**: Peripheral increment mode. When set, this bit increments the peripheral
    address after each data transfer.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MINC**: Memory increment mode. When set, this bit increments the memory address
    after each data transfer.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PSIZE[1:0]**: Peripheral data size. These bits specify the size of the data
    items read from or written to the peripheral (8-bit, 16-bit, or 32-bit).'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MSIZE[1:0]**: Memory data size. These bits specify the size of the data items
    read from or written to memory.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PL[1:0]**: Priority level. These bits set the priority level of the stream
    (low, medium, high, or very high).'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find detailed information about this register on *page 190* of the STM32F411
    reference manual (RM0383). Next, we have the DMA Stream Number of Data Register
    (`DMA_SxNDTR`).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: DMA Stream Number of Data Register (DMA_SxNDTR)
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The DMA Stream Number of Data Register (`DMA_SxNDTR`) specifies the number of
    data items to be transferred by the DMA stream. This register is crucial for controlling
    the length of the data transfer.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: The only field in this register is **NDT[15:0]**. This stands for the number
    of data items. This field specifies the total number of data items to be transferred.
    The value in this register is decremented after each transfer until it reaches
    zero.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Further information about this register can be found on *page 193* of the reference
    manual. Let’s move on to the DMA Stream Peripheral Address Register (`DMA_SxPAR`).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: DMA Stream Peripheral Address Register (DMA_SxPAR)
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The DMA Stream Peripheral Address Register (`DMA_SxPAR`) holds the address of
    the peripheral data register that the data will be read to or written from.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: The only field in this register is **PA[31:0]**. This stands for **peripheral
    address**. This field contains the address of the peripheral data register involved
    in the data transfer.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: More details about this register can be found on *page 194* of the reference
    manual. Finally, we have the DMA Stream Memory Address Registers (`DMA_SxM0AR`
    and `DMA_SxM1AR`).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: DMA Stream Memory Address Registers (DMA_SxM0AR and DMA_SxM1AR)
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These registers store the addresses of the memory locations used for data transfers.
    The `DMA_SxM0AR` register is used for single buffer mode, while both `DMA_SxM0AR`
    and `DMA_SxM1AR` are used in double buffer mode.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: The only field in these registers is **MA[31:0]**. This stands for **memory
    address**. This field contains the address of the memory location involved in
    the data transfer. For detailed information, refer to *pages 194* of the reference
    manual.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Developing the ADC DMA driver
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will develop three distinct DMA drivers – one for transferring
    ADC data, another for UART data, and a third for transferring data between memory
    locations. Let’s begin with the ADC DMA driver.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: The ADC DMA driver
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a copy of your previous project in your IDE, following the steps outlined
    in earlier chapters. Rename this copied project `ADC_DMA`. Next, create a new
    file named `adc_dma.c` in the `Src` folder and another file named `adc_dma.h`
    in the `Inc` folder.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'Populate your `adc_dma.c` file with the following code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let’s go through each part of the code step by step to understand its purpose
    and functionality.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '`adc_dma.h` header file, which calls the `stm32f4xx.h` file and contains a
    macro for the number of channels of our DMA driver. We then define several constants
    using `#define` statements. These constants represent bit masks for various registers
    and control flags, making the code more readable and maintainable.'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`adc_raw_data`, that stores the raw ADC data. The size of this array is determined
    by a predefined constant, `NUM_OF_CHANNELS`.'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`adc_dma_init` function, we begin by enabling the clock for GPIOA, which is
    necessary for configuring the GPIO pins used by the ADC. We then set the mode
    of the `PA0` and `PA1` pins to analog, as they are connected to the ADC channels.'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we enable the clock for ADC1 and configure the ADC sequence length and
    channel sequence. We set the ADC to scan mode, allowing it to convert multiple
    channels sequentially. Additionally, we enable DMA and continuous conversion mode
    for the ADC.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`DMA2` and ensure that the DMA stream is disabled before making any configurations.
    We configure the DMA stream for circular mode, which allows continuous data transfer.
    We set the memory and peripheral data sizes to half-word (16 bits). We enable
    memory address increment to correctly move through the `adc_raw_data` array and
    set the peripheral address to the ADC data register. We specify the number of
    data items to transfer and, finally, enable the DMA stream.'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Enable and start ADC**: In the final steps, we simply enable the ADC and
    start the conversion process by setting the appropriate control bits.'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our next task is to populate the `adc_dma.h` file. Here is the code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '#include <stdio.h>'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '#include "uart.h"'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '#include "adc_dma.h"'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: extern uint16_t adc_raw_data[NUM_OF_CHANNELS];
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: int main(void)
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: /*Initialize debug UART*/
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: uart_init();
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: /*Initialize ADC DMA*/
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: adc_dma_init();
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: while(1)
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'printf("Value from sensor one : %d \n\r ",adc_raw_data[0]);'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'printf("Value from sensor two : %d \n\r ",adc_raw_data[1]);'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: for( int i = 0; i < 90000; i++){}
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '#include "uart_dma.h"'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '#define UART2EN            (1U<<17)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '#define GPIOAEN            (1U<<0)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '#define CR1_TE            (1U<<3)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '#define CR1_RE            (1U<<2)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '#define CR1_UE            (1U<<13)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '#define SR_TXE            (1U<<7)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '#define CR3_DMAT        (1U<<7)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '#define CR3_DMAR        (1U<<6)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '#define SR_TC            (1U<<6)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '#define CR1_TCIE        (1U<<6)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '#define UART_BAUDRATE    115200'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '#define CLK                16000000'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '#define DMA1EN                (1U<<21)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '#define DMA_SCR_EN          (1U<<0)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '#define DMA_SCR_MINC        (1U<<10)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '#define DMA_SCR_PINC        (1U<<9)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '#define DMA_SCR_CIRC        (1U<<8)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '#define DMA_SCR_TCIE        (1U<<4)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '#define DMA_SCR_TEIE        (1U<<2)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '#define DMA_SFCR_DMDIS        (1U<<2)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '#define HIFCR_CDMEIF5        (1U<<8)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '#define HIFCR_CTEIF5        (1U<<9)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '#define HIFCR_CTCIF5        (1U<<11)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '#define HIFCR_CDMEIF6        (1U<<18)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '#define HIFCR_CTEIF6        (1U<<19)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '#define HIFCR_CTCIF6        (1U<<21)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '#define HIFSR_TCIF5        (1U<<11)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '#define HIFSR_TCIF6        (1U<<21)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: static uint16_t compute_uart_bd(uint32_t periph_clk, uint32_t baudrate);
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: static void uart_set_baudrate(uint32_t periph_clk, uint32_t baudrate);
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: char uart_data_buffer[UART_DATA_BUFF_SIZE];
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: uint8_t g_rx_cmplt;
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: uint8_t g_tx_cmplt;
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: uint8_t g_uart_cmplt;
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: void uart2_rx_tx_init(void)
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: /*************Configure UART GPIO pin********************/
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: /*1.Enable clock access to GPIOA*/
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: RCC->AHB1ENR |= GPIOAEN;
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: /*2.Set PA2 mode to alternate function mode*/
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: GPIOA->MODER &= ~(1U<<4);
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: GPIOA->MODER |=     (1U<<5);
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: /*3.Set PA3 mode to alternate function mode*/
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: GPIOA->MODER &= ~(1U<<6);
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: GPIOA->MODER |=     (1U<<7);
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: /*4.Set PA2 alternate function function type to AF7(UART2_TX)*/
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: GPIOA->AFR[0] |= (1U<<8);
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: GPIOA->AFR[0] |= (1U<<9);
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: GPIOA->AFR[0] |= (1U<<10);
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: GPIOA->AFR[0] &= ~(1U<<11);
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: /*5.Set PA3 alternate function function type to AF7(UART2_TX)*/
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: GPIOA->AFR[0] |= (1U<<12);
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: GPIOA->AFR[0] |= (1U<<13);
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: GPIOA->AFR[0] |= (1U<<14);
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: GPIOA->AFR[0] &= ~(1U<<15);
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: /*************Configure UART Module********************/
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: /*6\. Enable clock access to UART2*/
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: RCC->APB1ENR |= UART2EN;
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: /*7\. Set baudrate*/
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: uart_set_baudrate(CLK,UART_BAUDRATE);
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: /*8\. Select to use DMA for TX and RX*/
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: USART2->CR3 = CR3_DMAT |CR3_DMAR;
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: /*9\. Set transfer direction*/
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: USART2->CR1 = CR1_TE |CR1_RE;
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: /*10.Clear TC flag*/
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: USART2->SR &=~SR_TC;
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: /*11.Enable TCIE*/
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: USART2->CR1 |=CR1_TCIE;
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: /*12\. Enable uart module*/
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: USART2->CR1 |= CR1_UE;
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: /*13.Enable USART2 interrupt in the NVIC*/
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: NVIC_EnableIRQ(USART2_IRQn);
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: void dma1_init(void)
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: /*Enable clock access to DMA*/
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: RCC->AHB1ENR |=DMA1EN;
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: /*Enable DMA Stream6 Interrupt in NVIC*/
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: NVIC_EnableIRQ(DMA1_Stream6_IRQn);
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: void dma1_stream5_uart_rx_config(void)
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: /*Disable DMA stream*/
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: DMA1_Stream5->CR &=~DMA_SCR_EN;
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: /*Wait till DMA Stream is disabled*/
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: while((DMA1_Stream5->CR & DMA_SCR_EN)){}
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: /*Clear interrupt flags for stream 5*/
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: DMA1->HIFCR = HIFCR_CDMEIF5 |HIFCR_CTEIF5|HIFCR_CTCIF5;
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: /*Set periph address*/
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: DMA1_Stream5->PAR = (uint32_t)(&(USART2->DR));
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: /*Set mem address*/
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: DMA1_Stream5->M0AR = (uint32_t)(&uart_data_buffer);
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: /*Set number of transfer*/
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: DMA1_Stream5->NDTR = (uint16_t)UART_DATA_BUFF_SIZE;
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: /*Select Channel 4*/
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: DMA1_Stream5->CR &= ~(1u<<25);
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: DMA1_Stream5->CR &= ~(1u<<26);
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: DMA1_Stream5->CR |= (1u<<27);
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: /*Enable memory addr increment*/
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: DMA1_Stream5->CR |=DMA_SCR_MINC;
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: /*Enable transfer complete interrupt*/
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: DMA1_Stream5->CR |= DMA_SCR_TCIE;
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: /*Enable Circular mode*/
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: DMA1_Stream5->CR |=DMA_SCR_CIRC;
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '/*Set transfer direction : Periph to Mem*/'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: DMA1_Stream5->CR &=~(1U<<6);
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: DMA1_Stream5->CR &=~(1U<<7);
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: /*Enable DMA stream*/
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: DMA1_Stream5->CR |= DMA_SCR_EN;
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: /*Enable DMA Stream5 Interrupt in NVIC*/
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: NVIC_EnableIRQ(DMA1_Stream5_IRQn);
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: void dma1_stream6_uart_tx_config(uint32_t msg_to_snd, uint32_t msg_len)
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: /*Disable DMA stream*/
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: DMA1_Stream6->CR &=~DMA_SCR_EN;
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: /*Wait till  DMA Stream is disabled*/
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: while((DMA1_Stream6->CR & DMA_SCR_EN)){}
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: /*Clear interrupt flags for stream 6*/
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: DMA1->HIFCR = HIFCR_CDMEIF6 |HIFCR_CTEIF6|HIFCR_CTCIF6;
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: /*Set periph address*/
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: DMA1_Stream6->PAR = (uint32_t)(&(USART2->DR));
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: /*Set mem address*/
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: DMA1_Stream6->M0AR = msg_to_snd;
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: /*Set number of transfer*/
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: DMA1_Stream6->NDTR = msg_len;
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: /*Select Channel 4*/
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: DMA1_Stream6->CR &= ~(1u<<25);
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: DMA1_Stream6->CR &= ~(1u<<26);
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: DMA1_Stream6->CR |= (1u<<27);
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: /*Enable memory addr increment*/
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: DMA1_Stream6->CR |=DMA_SCR_MINC;
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: /*Set transfer direction :Mem to Periph*/
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: DMA1_Stream6->CR |=(1U<<6);
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: DMA1_Stream6->CR &=~(1U<<7);
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: /*Set transfer complete interrupt*/
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: DMA1_Stream6->CR |= DMA_SCR_TCIE;
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: /*Enable DMA stream*/
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: DMA1_Stream6->CR |= DMA_SCR_EN;
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: static uint16_t compute_uart_bd(uint32_t periph_clk, uint32_t baudrate)
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: return ((periph_clk +( baudrate/2U ))/baudrate);
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: static void uart_set_baudrate(uint32_t periph_clk, uint32_t baudrate)
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: USART2->BRR  = compute_uart_bd(periph_clk,baudrate);
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: void DMA1_Stream6_IRQHandler(void)
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: if((DMA1->HISR) & HIFSR_TCIF6)
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: //do_ssomething
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: g_tx_cmplt = 1;
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: /*Clear the flag*/
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: DMA1->HIFCR |= HIFCR_CTCIF6;
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: void DMA1_Stream5_IRQHandler(void)
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: if((DMA1->HISR) & HIFSR_TCIF5)
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: g_rx_cmplt = 1;
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: /*Clear the flag*/
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: DMA1->HIFCR |= HIFCR_CTCIF5;
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: void USART2_IRQHandler(void)
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: g_uart_cmplt  = 1;
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: /*Clear TC interrupt flag*/
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: USART2->SR &=~SR_TC;
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '#ifndef UART_DMA_H__'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '#define UART_DMA_H__'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '#include <stdint.h>'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '#include "stm32f4xx.h"'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '#define UART_DATA_BUFF_SIZE        5'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: void uart2_rx_tx_init(void);
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: void dma1_init(void);
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: void dma1_stream5_uart_rx_config(void);
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: void dma1_stream6_uart_tx_config(uint32_t msg_to_snd, uint32_t msg_len);
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: 'main.c file:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the `main` function, we start by initializing the UART and DMA, and then
    we configure DMA1 Stream5 for UART reception and DMA1 Stream6 for UART transmission.
    We prepare a message that indicates initialization completion and initiate its
    transmission via DMA. The main loop continuously checks whether a UART message
    has been received. When a message is received, it formats the received data into
    a response message, resets the completion flags, and transmits the response using
    DMA.
  id: totrans-347
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Testing the project
  id: totrans-348
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: To test the project, compile the code and upload it to your microcontroller.
    Open RealTerm or any other serial terminal application, and then configure it
    with the appropriate port and baud rate to view the debug messages. Press the
    black push button on the development board to reset the microcontroller. Ensure
    the output area of RealTerm is active by clicking on it. Then, type any five keys
    on your keyboard. You should see these keys appear in the output area of RealTerm.
    The microcontroller receives the typed keys through the `dma1_stream5_uart_rx_config`
    function, stores them in the `msg_buff`, and transmits them to your host computer’s
    serial port via the `dma1_stream6_uart_tx_config` function. The last received
    data remains in `msg_buff` for further processing if needed. We type five characters
    because the `UART_DATA_BUFF_SIZE` is set to `5` in the `uart_dma.h` file.
  id: totrans-349
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: In the next section, we will develop our final DMA driver – the DMA memory-to-memory
    driver.
  id: totrans-350
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Developing the DMA memory-to-memory driver
  id: totrans-351
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a copy of your previous project in your IDE and rename it `DMA_MemToMem`.
    Next, create a new file named `dma.c` in the `Src` folder and another file named
    `dma.h` in the `Inc` folder. Update your `dma.c` file, as shown here:'
  id: totrans-352
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This function sets up the `DMA2` controller for memory-to-memory data transfers.
    It begins by enabling the clock for the DMA2 module and ensures that the DMA stream
    is disabled before making any configuration changes. The function configures the
    data size for both memory and peripheral to `half-word` (16-bit) and enables automatic
    incrementing of the memory and peripheral addresses. It sets the transfer direction
    to `memory-to-memory` and enables interrupts for transfer completion and transfer
    errors, ensuring robust error handling and efficient operation. Direct mode is
    disabled to use `FIFO mode`, and the FIFO threshold is set to `full`. Finally,
    the function enables the DMA stream and configures the NVIC to handle DMA interrupts,
    ensuring that the system can respond to DMA events appropriately. We also have
    the `dma_transfer_start` function:'
  id: totrans-354
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This function initiates the DMA transfer by configuring the source and destination
    addresses and the length of the data transfer. It begins by setting the peripheral
    address of the value passed in `src_buff` and the memory address of the value
    passed in `dest_buff`. The transfer length is then specified by setting the `NDTR`
    register to `len`, indicating the number of data items to transfer. Finally, the
    function enables the DMA stream by setting the `EN` bit in the `CR` register,
    thereby starting the data transfer from the source to the destination. This is
    the `dma.h` file:'
  id: totrans-356
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '#include <stdio.h>'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '#include <string.h>'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '#include "uart.h"'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '#include "dma.h"'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '#include "uart.h"'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '#define BUFFER_SIZE        5'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: uint16_t sensor_data_arr[BUFFER_SIZE] = {892,731,1234,90,23};
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: uint16_t temp_data_arr[BUFFER_SIZE];
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: volatile uint8_t g_transfer_cmplt;
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: int main(void)
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: g_transfer_cmplt = 0;
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: uart_init();
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: dma2_mem2mem_config();
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: dma_transfer_start((uint32_t)sensor_data_arr,(uint32_t) temp_data_
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: arr, BUFFER_SIZE);
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: /*Wait until transfer complete*/
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: while(!g_transfer_cmplt){}
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: for( int i = 0; i < BUFFER_SIZE; i++)
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: 'printf("Temp buffer[%d]: %d\r\n",i,temp_data_arr[i]);'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: g_transfer_cmplt = 0;
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: while(1)
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: void DMA2_Stream0_IRQHandler(void)
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: /*Check if transfer complete interrupt occurred*/
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: if((DMA2->LISR) & LISR_TCIF0)
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: g_transfer_cmplt = 1;
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: /*Clear flag*/
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: DMA2->LIFCR |=LIFCR_CTCIF0;
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: /*Check if transfer error occurred*/
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: if((DMA2->LISR) & LISR_TEIF0)
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: /*Do something...*/
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: /*Clear flag*/
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: DMA2->LIFCR |= LIFCR_CTEIF0;
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
