- en: '17'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Direct Memory Access (DMA)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will explore **Direct Memory Access** (**DMA**), a powerful
    feature in microcontrollers that allows peripherals to transfer data to and from
    memory without involving the CPU. This functionality is critical for improving
    data throughput and freeing up the CPU to handle other tasks, making it fundamental
    to high-performance embedded system development.
  prefs: []
  type: TYPE_NORMAL
- en: We will begin by understanding the basic principles of DMA and its significance
    in embedded systems. We will then delve into the specifics of the DMA controller
    in STM32F4 microcontrollers, examining its structure and features and how it manages
    data transfers. Following this, we will apply this theoretical knowledge to develop
    practical DMA drivers for various use cases, including memory-to-memory transfers,
    **Analog-to-Digital Converter** (**ADC**) data transfers, and **Universal Asynchronous
    Receiver-Transmitter** (**UART**) communications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of DMA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The STM32F4 DMA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing the DMA ADC driver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing the DMA UART driver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing the DMA memory-to-memory driver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a comprehensive understanding of how
    DMA works and how to implement it in your projects. You will be able to develop
    efficient DMA drivers to handle data transfers in various scenarios, significantly
    enhancing the performance and responsiveness of your embedded systems.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming](https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Direct Memory Access (DMA)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DMA is a feature that can significantly elevate the performance of your embedded
    systems. If you’ve been dealing with data transfers in your microcontroller projects,
    you know how taxing it can be on the CPU to handle all that data movement. This
    is where DMA steps in as a game-changer, offloading the data transfer tasks from
    the CPU and allowing it to focus on more critical functions. Let’s see how it
    works.
  prefs: []
  type: TYPE_NORMAL
- en: How DMA works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, what exactly is DMA, and how does it work? In simple terms, DMA is a method
    that allows peripherals within a microcontroller to transfer data directly to
    and from memory, without requiring continuous CPU intervention. Imagine it as
    a dedicated assistant that takes over the tedious task of moving boxes (data)
    so that you (the CPU) can focus on more important work, such as solving complex
    problems or managing other peripherals.
  prefs: []
  type: TYPE_NORMAL
- en: A typical DMA controller in a microcontroller has multiple channels, each capable
    of handling a specific data transfer operation. Each channel can be configured
    independently to manage transfers between various peripherals and memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a step-by-step look at how DMA generally operates:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Initialization**: The DMA controller and channels are configured. This setup
    includes specifying the source and destination addresses, the direction of data
    transfer, and the number of data units to transfer.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Trigger**: The data transfer is initiated by a trigger, which can be an event
    such as a peripheral signaling that it’s ready to send or receive data, or a software
    command.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Data transfer**: Once triggered, the DMA controller takes over, reading data
    from the source address and writing it to the destination address. This process
    continues until the specified number of data units is transferred.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Completion**: Upon completing the transfer, the DMA controller can generate
    an interrupt to notify the CPU that the transfer is done, allowing the system
    to perform any necessary post-transfer processing.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, let’s take a look at some key features of DMA controllers.
  prefs: []
  type: TYPE_NORMAL
- en: Key features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'DMA controllers are packed with features that make them versatile and powerful.
    Let’s break down some of the key specifications you’ll often encounter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Channels and streams**: DMA controllers typically have multiple channels
    and streams, each capable of handling a different transfer. For instance, the
    STM32F4 microcontroller has up to 16 streams in its DMA controllers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Priorities**: Channels can be assigned different priority levels, ensuring
    that more critical transfers get precedence over less critical ones.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transfer Types**: DMA can handle various types of transfers, including memory-to-memory,
    peripheral-to-memory, and memory-to-peripheral.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FIFO**: Some DMA controllers come with a **First-In-First-Out** (**FIFO**)
    buffer, which helps manage data flow and improve efficiency, especially in burst
    transfers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Circular mode**: This mode allows the DMA to continuously transfer data in
    a loop, which is particularly useful for peripherals that need constant data streaming,
    such as audio or video feeds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interrupts**: DMA controllers can generate interrupts on transfer completion,
    half-transfer completion, and transfer errors, allowing the CPU to react appropriately
    to different stages of the transfer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To understand the real power of DMA, let’s look at some common use cases where
    DMA shines.
  prefs: []
  type: TYPE_NORMAL
- en: Common use cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some common use cases of DMA:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Audio streaming**: DMA is heavily used in audio applications where continuous
    data streaming is essential. For instance, in a digital audio player, the audio
    samples must be continuously sent to a **Digital-to-Analog Converter** (**DAC**).
    Using DMA, the audio data can be streamed from memory to the DAC without CPU intervention,
    ensuring smooth playback and freeing up the CPU to manage the user interface and
    other tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sensor data acquisition**: In applications such as environmental monitoring
    or industrial automation, sensors often need to sample data at precise intervals.
    For example, an ADC can be configured to continuously sample temperature data,
    with DMA transferring the sampled data directly to memory. This setup ensures
    that the CPU isn’t bogged down with handling each individual sample, thus maintaining
    efficient and timely data collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Communication interfaces**: DMA is a lifesaver when dealing with high-speed
    communication protocols such as UART, SPI, or I2C. Consider a scenario where an
    embedded system needs to log data received over UART to an SD card. Without DMA,
    the CPU would need to handle each byte of data, process it, and then write it
    to the SD card, which can be highly inefficient. With DMA, the data received over
    UART can be directly written to memory, and another DMA channel can transfer it
    to the SD card, all with minimal CPU intervention.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Graphics processing**: DMA is also crucial in applications involving graphics,
    such as updating a display buffer. In a system where the display needs to be refreshed
    continuously, the DMA can handle the transfer of image data from memory to the
    display controller. This ensures smooth and flicker-free graphics rendering, while
    the CPU can focus on generating the next frame or managing user inputs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this in mind, let’s compare some DMA solutions to non-DMA solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Case study 1 – audio streaming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Scenario**: You are developing an audio playback system that streams digital
    audio data from a microcontroller to a DAC.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Without DMA**: The CPU is responsible for fetching each audio sample from
    memory and sending it to the DAC. Given the high sampling rate required for audio
    applications (e.g., 44.1 kHz for CD-quality audio), the CPU must handle tens of
    thousands of interrupts per second just to maintain the audio stream. This constant
    load significantly limits the CPU’s ability to perform other tasks, potentially
    leading to audio glitches and reduced system responsiveness.'
  prefs: []
  type: TYPE_NORMAL
- en: '**With DMA**: The DMA controller is configured to transfer audio data directly
    from memory to the DAC. The CPU sets up the DMA transfer and then handles higher-level
    tasks, only occasionally checking the status of the transfer. This setup ensures
    smooth and uninterrupted audio playback while freeing up the CPU to manage other
    aspects of the system, such as user interface and control logic.'
  prefs: []
  type: TYPE_NORMAL
- en: Case study 2 – high-speed data acquisition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Scenario**: You are developing a data acquisition system that continuously
    samples data from multiple sensors via ADCs and stores the data for later analysis.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Without DMA**: The CPU must handle each ADC conversion, read the data, and
    store it in memory. If the sampling rate is high, the CPU can become overwhelmed,
    leading to missed samples and unreliable data collection. This approach can also
    complicate real-time data processing and analysis, as the CPU is bogged down with
    managing the data flow.'
  prefs: []
  type: TYPE_NORMAL
- en: '**With DMA**: The ADC is configured to generate DMA requests. Each time a conversion
    is complete, the DMA controller transfers the data from the ADC to memory without
    CPU intervention. The CPU can then process the collected data in batches, ensuring
    that no samples are missed and enabling real-time data analysis and decision-making.'
  prefs: []
  type: TYPE_NORMAL
- en: Case study 3 – an LCD display refresh
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Scenario**: You are developing a graphical application that continuously
    updates an LCD display with new data.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Without DMA**: The CPU must update the display by sending each pixel or line
    of data directly to the LCD controller. This process can be very CPU-intensive,
    especially for high-resolution displays, leading to sluggish performance and reduced
    responsiveness in the user interface.'
  prefs: []
  type: TYPE_NORMAL
- en: '**With DMA**: The DMA controller is configured to transfer display data from
    memory to the LCD controller. The CPU sets up the DMA transfer and then focuses
    on generating new graphical data or handling user inputs. The DMA controller ensures
    that the display is updated smoothly and efficiently.'
  prefs: []
  type: TYPE_NORMAL
- en: In each of the case studies, we’ve seen how using DMA can transform a system’s
    capabilities, freeing up the CPU to handle more critical tasks and ensuring that
    data transfers are handled efficiently and reliably. Understanding and implementing
    DMA in your projects can lead to more robust, responsive, and high-performance
    embedded systems.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will delve deeper into the specifics of the STM32F4
    DMA controller, exploring its architecture, key registers, and practical implementation
    techniques.
  prefs: []
  type: TYPE_NORMAL
- en: The DMA modules of the STM32F4 microcontroller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each STM32F4 microcontroller is equipped with **two DMA** controllers, each
    supporting up to **8 streams**. Each stream can manage multiple requests, providing
    up to **16 streams** in total to handle various data transfer tasks. A **stream**
    is a unidirectional pathway that facilitates data transfer between a source and
    a destination. The architecture includes an **arbiter** to prioritize these DMA
    requests, ensuring that high-priority transfers are handled promptly.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see some key features of the STM32F4 DMA controller.
  prefs: []
  type: TYPE_NORMAL
- en: The key features of the STM32F4 DMA controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are the key features of the STM32F4 DMA controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Independent FIFO**: Each stream includes a **four-word FIFO buffer**, which
    can operate in either direct mode or FIFO mode. In direct mode, data transfers
    occur immediately upon request, while FIFO mode allows for **threshold-level buffering**,
    enhancing efficiency for burst data transfers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexible configuration**: Each stream can be configured to handle the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Peripheral-to-memory
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory-to-peripheral
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory-to-memory transfers
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additionally, streams can be set up for regular or double-buffer transfers,
    the latter enabling seamless data handling by swapping memory buffers automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Prioritization and arbitration**: DMA stream requests are prioritized via
    software with four levels – **very high**, **high**, **medium**, and **low**.
    If two streams have the same priority, hardware prioritization based on the stream
    number ensures orderly data transfer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Incremental and burst transfers**: The DMA controller supports both incremental
    and non-incremental addressing for source and destination. It can manage burst
    transfers of **4, 8, or 16 beats**, optimizing bandwidth usage. The term **beat**
    refers to the individual units of data that are transferred in a single DMA transaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interrupts and error handling**: Each stream supports multiple event flags
    such as transfer complete, half-transfer, transfer error, FIFO error, and direct
    mode error. These flags can trigger interrupts, providing robust error handling
    and status monitoring.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To fully utilize the STM32F DMA controller, it’s important to understand DMA
    transactions and channel selection. Let’s break these concepts down.
  prefs: []
  type: TYPE_NORMAL
- en: '`DMA_SxNDTR` register to track the number of remaining data items'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CHSEL` bits in the `DMA_SxCR` register. This flexibility allows various peripherals
    to initiate DMA requests efficiently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Previously, we discussed that the STM32F4 DMA controller supports three distinct
    transfer modes. Now, let’s explore the characteristics of each mode.
  prefs: []
  type: TYPE_NORMAL
- en: Transfer modes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three transfer modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`EN` bit in the `DMA_SxCR` register. The stream transfers data from the peripheral
    to memory, using the FIFO buffer if enabled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory-to-peripheral mode**: This is similar to peripheral-to-memory, but
    the transfer direction is reversed. Data is loaded from memory and sent to the
    peripheral.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory-to-memory mode**: This mode is unique, as it does not require peripheral
    requests. The DMA stream transfers data between two memory locations, using the
    FIFO buffer if enabled. This is particularly useful for large data transfers within
    memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The DMA controller can automatically increment source and destination pointers,
    facilitating efficient data transfers across different memory regions. This is
    configurable via the `PINC` and `MINC` bits in the `DMA_SxCR` register.
  prefs: []
  type: TYPE_NORMAL
- en: The STM32F4 DMA controller also provides data mode options.
  prefs: []
  type: TYPE_NORMAL
- en: DMA data modes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This data mode options include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DMA_SxNDTR` register. This is especially useful for applications such as ADC
    sampling, where data needs to be continuously recorded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Double buffer mode**: Double buffer mode enhances efficiency by allowing
    the DMA controller to swap between two memory buffers automatically. This ensures
    continuous data processing. While the CPU works on one buffer, the DMA can load
    the next set of data into the other buffer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will examine the STM32F4 DMA block diagram from the
    reference manual. This will help us better understand the key characteristics
    and functionalities of the DMA controller.
  prefs: []
  type: TYPE_NORMAL
- en: The STM32F4 DMA block diagram
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The DMA has **two ports** for data transfer – one peripheral port and one memory
    port, as shown in *Figure 17**.1*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.1: The DMA module, indicating the data transfer ports](img/B21914_17_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.1: The DMA module, indicating the data transfer ports'
  prefs: []
  type: TYPE_NORMAL
- en: Each of the two DMA modules features **eight distinct streams**, with each stream
    dedicated to handling memory access requests from various peripherals.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.2: The DMA module, indicating the streams](img/B21914_17_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.2: The DMA module, indicating the streams'
  prefs: []
  type: TYPE_NORMAL
- en: Each stream can accommodate up to **eight selectable channels**, which are software-configurable
    to enable multiple peripherals to initiate DMA requests. However, within any given
    stream, only one channel can be active at a time.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.3: The DMA module, with channels zoomed in](img/B21914_17_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17.3: The DMA module, with channels zoomed in'
  prefs: []
  type: TYPE_NORMAL
- en: To find the mappings of DMA channels and streams to the various peripherals
    of the microcontroller, refer to *page 170* of the reference manual (**RM0383**).
  prefs: []
  type: TYPE_NORMAL
- en: Before we start developing our DMA drivers, the final piece of the puzzle involves
    familiarizing ourselves with the key DMA registers.
  prefs: []
  type: TYPE_NORMAL
- en: The key STM32 DMA registers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will explore the characteristics and functions of some of
    the crucial registers within the DMA peripheral, starting with the DMA Stream
    Configuration Register.
  prefs: []
  type: TYPE_NORMAL
- en: The DMA Stream Configuration Register (DMA_SxCR)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The DMA Stream Configuration Register (`DMA_SxCR`) is one of the primary registers
    used to configure a DMA stream’s operational settings. This register allows us
    to set up various parameters, such as the **data direction**, the **size** of
    the data items, and the **priority** level of the stream. The key bits in this
    register include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**EN**: Stream enable. Setting this bit activates the stream.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CHSEL[2:0]**: Channel selection. These bits select the DMA channel for the
    stream.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DIR[1:0]**: Data transfer direction. These bits specify the direction of
    the data transfer (peripheral-to-memory, memory-to-peripheral, or memory-to-memory).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CIRC**: Circular mode. Setting this bit enables circular mode, which allows
    continuous data transfers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PINC**: Peripheral increment mode. When set, this bit increments the peripheral
    address after each data transfer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MINC**: Memory increment mode. When set, this bit increments the memory address
    after each data transfer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PSIZE[1:0]**: Peripheral data size. These bits specify the size of the data
    items read from or written to the peripheral (8-bit, 16-bit, or 32-bit).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MSIZE[1:0]**: Memory data size. These bits specify the size of the data items
    read from or written to memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PL[1:0]**: Priority level. These bits set the priority level of the stream
    (low, medium, high, or very high).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find detailed information about this register on *page 190* of the STM32F411
    reference manual (RM0383). Next, we have the DMA Stream Number of Data Register
    (`DMA_SxNDTR`).
  prefs: []
  type: TYPE_NORMAL
- en: DMA Stream Number of Data Register (DMA_SxNDTR)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The DMA Stream Number of Data Register (`DMA_SxNDTR`) specifies the number of
    data items to be transferred by the DMA stream. This register is crucial for controlling
    the length of the data transfer.
  prefs: []
  type: TYPE_NORMAL
- en: The only field in this register is **NDT[15:0]**. This stands for the number
    of data items. This field specifies the total number of data items to be transferred.
    The value in this register is decremented after each transfer until it reaches
    zero.
  prefs: []
  type: TYPE_NORMAL
- en: Further information about this register can be found on *page 193* of the reference
    manual. Let’s move on to the DMA Stream Peripheral Address Register (`DMA_SxPAR`).
  prefs: []
  type: TYPE_NORMAL
- en: DMA Stream Peripheral Address Register (DMA_SxPAR)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The DMA Stream Peripheral Address Register (`DMA_SxPAR`) holds the address of
    the peripheral data register that the data will be read to or written from.
  prefs: []
  type: TYPE_NORMAL
- en: The only field in this register is **PA[31:0]**. This stands for **peripheral
    address**. This field contains the address of the peripheral data register involved
    in the data transfer.
  prefs: []
  type: TYPE_NORMAL
- en: More details about this register can be found on *page 194* of the reference
    manual. Finally, we have the DMA Stream Memory Address Registers (`DMA_SxM0AR`
    and `DMA_SxM1AR`).
  prefs: []
  type: TYPE_NORMAL
- en: DMA Stream Memory Address Registers (DMA_SxM0AR and DMA_SxM1AR)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These registers store the addresses of the memory locations used for data transfers.
    The `DMA_SxM0AR` register is used for single buffer mode, while both `DMA_SxM0AR`
    and `DMA_SxM1AR` are used in double buffer mode.
  prefs: []
  type: TYPE_NORMAL
- en: The only field in these registers is **MA[31:0]**. This stands for **memory
    address**. This field contains the address of the memory location involved in
    the data transfer. For detailed information, refer to *pages 194* of the reference
    manual.
  prefs: []
  type: TYPE_NORMAL
- en: Developing the ADC DMA driver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will develop three distinct DMA drivers – one for transferring
    ADC data, another for UART data, and a third for transferring data between memory
    locations. Let’s begin with the ADC DMA driver.
  prefs: []
  type: TYPE_NORMAL
- en: The ADC DMA driver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a copy of your previous project in your IDE, following the steps outlined
    in earlier chapters. Rename this copied project `ADC_DMA`. Next, create a new
    file named `adc_dma.c` in the `Src` folder and another file named `adc_dma.h`
    in the `Inc` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Populate your `adc_dma.c` file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let’s go through each part of the code step by step to understand its purpose
    and functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '`adc_dma.h` header file, which calls the `stm32f4xx.h` file and contains a
    macro for the number of channels of our DMA driver. We then define several constants
    using `#define` statements. These constants represent bit masks for various registers
    and control flags, making the code more readable and maintainable.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`adc_raw_data`, that stores the raw ADC data. The size of this array is determined
    by a predefined constant, `NUM_OF_CHANNELS`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`adc_dma_init` function, we begin by enabling the clock for GPIOA, which is
    necessary for configuring the GPIO pins used by the ADC. We then set the mode
    of the `PA0` and `PA1` pins to analog, as they are connected to the ADC channels.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we enable the clock for ADC1 and configure the ADC sequence length and
    channel sequence. We set the ADC to scan mode, allowing it to convert multiple
    channels sequentially. Additionally, we enable DMA and continuous conversion mode
    for the ADC.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`DMA2` and ensure that the DMA stream is disabled before making any configurations.
    We configure the DMA stream for circular mode, which allows continuous data transfer.
    We set the memory and peripheral data sizes to half-word (16 bits). We enable
    memory address increment to correctly move through the `adc_raw_data` array and
    set the peripheral address to the ADC data register. We specify the number of
    data items to transfer and, finally, enable the DMA stream.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Enable and start ADC**: In the final steps, we simply enable the ADC and
    start the conversion process by setting the appropriate control bits.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our next task is to populate the `adc_dma.h` file. Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '#include <stdio.h>'
  prefs: []
  type: TYPE_NORMAL
- en: '#include "uart.h"'
  prefs: []
  type: TYPE_NORMAL
- en: '#include "adc_dma.h"'
  prefs: []
  type: TYPE_NORMAL
- en: extern uint16_t adc_raw_data[NUM_OF_CHANNELS];
  prefs: []
  type: TYPE_NORMAL
- en: int main(void)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: /*Initialize debug UART*/
  prefs: []
  type: TYPE_NORMAL
- en: uart_init();
  prefs: []
  type: TYPE_NORMAL
- en: /*Initialize ADC DMA*/
  prefs: []
  type: TYPE_NORMAL
- en: adc_dma_init();
  prefs: []
  type: TYPE_NORMAL
- en: while(1)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: 'printf("Value from sensor one : %d \n\r ",adc_raw_data[0]);'
  prefs: []
  type: TYPE_NORMAL
- en: 'printf("Value from sensor two : %d \n\r ",adc_raw_data[1]);'
  prefs: []
  type: TYPE_NORMAL
- en: for( int i = 0; i < 90000; i++){}
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '#include "uart_dma.h"'
  prefs: []
  type: TYPE_NORMAL
- en: '#define UART2EN            (1U<<17)'
  prefs: []
  type: TYPE_NORMAL
- en: '#define GPIOAEN            (1U<<0)'
  prefs: []
  type: TYPE_NORMAL
- en: '#define CR1_TE            (1U<<3)'
  prefs: []
  type: TYPE_NORMAL
- en: '#define CR1_RE            (1U<<2)'
  prefs: []
  type: TYPE_NORMAL
- en: '#define CR1_UE            (1U<<13)'
  prefs: []
  type: TYPE_NORMAL
- en: '#define SR_TXE            (1U<<7)'
  prefs: []
  type: TYPE_NORMAL
- en: '#define CR3_DMAT        (1U<<7)'
  prefs: []
  type: TYPE_NORMAL
- en: '#define CR3_DMAR        (1U<<6)'
  prefs: []
  type: TYPE_NORMAL
- en: '#define SR_TC            (1U<<6)'
  prefs: []
  type: TYPE_NORMAL
- en: '#define CR1_TCIE        (1U<<6)'
  prefs: []
  type: TYPE_NORMAL
- en: '#define UART_BAUDRATE    115200'
  prefs: []
  type: TYPE_NORMAL
- en: '#define CLK                16000000'
  prefs: []
  type: TYPE_NORMAL
- en: '#define DMA1EN                (1U<<21)'
  prefs: []
  type: TYPE_NORMAL
- en: '#define DMA_SCR_EN          (1U<<0)'
  prefs: []
  type: TYPE_NORMAL
- en: '#define DMA_SCR_MINC        (1U<<10)'
  prefs: []
  type: TYPE_NORMAL
- en: '#define DMA_SCR_PINC        (1U<<9)'
  prefs: []
  type: TYPE_NORMAL
- en: '#define DMA_SCR_CIRC        (1U<<8)'
  prefs: []
  type: TYPE_NORMAL
- en: '#define DMA_SCR_TCIE        (1U<<4)'
  prefs: []
  type: TYPE_NORMAL
- en: '#define DMA_SCR_TEIE        (1U<<2)'
  prefs: []
  type: TYPE_NORMAL
- en: '#define DMA_SFCR_DMDIS        (1U<<2)'
  prefs: []
  type: TYPE_NORMAL
- en: '#define HIFCR_CDMEIF5        (1U<<8)'
  prefs: []
  type: TYPE_NORMAL
- en: '#define HIFCR_CTEIF5        (1U<<9)'
  prefs: []
  type: TYPE_NORMAL
- en: '#define HIFCR_CTCIF5        (1U<<11)'
  prefs: []
  type: TYPE_NORMAL
- en: '#define HIFCR_CDMEIF6        (1U<<18)'
  prefs: []
  type: TYPE_NORMAL
- en: '#define HIFCR_CTEIF6        (1U<<19)'
  prefs: []
  type: TYPE_NORMAL
- en: '#define HIFCR_CTCIF6        (1U<<21)'
  prefs: []
  type: TYPE_NORMAL
- en: '#define HIFSR_TCIF5        (1U<<11)'
  prefs: []
  type: TYPE_NORMAL
- en: '#define HIFSR_TCIF6        (1U<<21)'
  prefs: []
  type: TYPE_NORMAL
- en: static uint16_t compute_uart_bd(uint32_t periph_clk, uint32_t baudrate);
  prefs: []
  type: TYPE_NORMAL
- en: static void uart_set_baudrate(uint32_t periph_clk, uint32_t baudrate);
  prefs: []
  type: TYPE_NORMAL
- en: char uart_data_buffer[UART_DATA_BUFF_SIZE];
  prefs: []
  type: TYPE_NORMAL
- en: uint8_t g_rx_cmplt;
  prefs: []
  type: TYPE_NORMAL
- en: uint8_t g_tx_cmplt;
  prefs: []
  type: TYPE_NORMAL
- en: uint8_t g_uart_cmplt;
  prefs: []
  type: TYPE_NORMAL
- en: void uart2_rx_tx_init(void)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: /*************Configure UART GPIO pin********************/
  prefs: []
  type: TYPE_NORMAL
- en: /*1.Enable clock access to GPIOA*/
  prefs: []
  type: TYPE_NORMAL
- en: RCC->AHB1ENR |= GPIOAEN;
  prefs: []
  type: TYPE_NORMAL
- en: /*2.Set PA2 mode to alternate function mode*/
  prefs: []
  type: TYPE_NORMAL
- en: GPIOA->MODER &= ~(1U<<4);
  prefs: []
  type: TYPE_NORMAL
- en: GPIOA->MODER |=     (1U<<5);
  prefs: []
  type: TYPE_NORMAL
- en: /*3.Set PA3 mode to alternate function mode*/
  prefs: []
  type: TYPE_NORMAL
- en: GPIOA->MODER &= ~(1U<<6);
  prefs: []
  type: TYPE_NORMAL
- en: GPIOA->MODER |=     (1U<<7);
  prefs: []
  type: TYPE_NORMAL
- en: /*4.Set PA2 alternate function function type to AF7(UART2_TX)*/
  prefs: []
  type: TYPE_NORMAL
- en: GPIOA->AFR[0] |= (1U<<8);
  prefs: []
  type: TYPE_NORMAL
- en: GPIOA->AFR[0] |= (1U<<9);
  prefs: []
  type: TYPE_NORMAL
- en: GPIOA->AFR[0] |= (1U<<10);
  prefs: []
  type: TYPE_NORMAL
- en: GPIOA->AFR[0] &= ~(1U<<11);
  prefs: []
  type: TYPE_NORMAL
- en: /*5.Set PA3 alternate function function type to AF7(UART2_TX)*/
  prefs: []
  type: TYPE_NORMAL
- en: GPIOA->AFR[0] |= (1U<<12);
  prefs: []
  type: TYPE_NORMAL
- en: GPIOA->AFR[0] |= (1U<<13);
  prefs: []
  type: TYPE_NORMAL
- en: GPIOA->AFR[0] |= (1U<<14);
  prefs: []
  type: TYPE_NORMAL
- en: GPIOA->AFR[0] &= ~(1U<<15);
  prefs: []
  type: TYPE_NORMAL
- en: /*************Configure UART Module********************/
  prefs: []
  type: TYPE_NORMAL
- en: /*6\. Enable clock access to UART2*/
  prefs: []
  type: TYPE_NORMAL
- en: RCC->APB1ENR |= UART2EN;
  prefs: []
  type: TYPE_NORMAL
- en: /*7\. Set baudrate*/
  prefs: []
  type: TYPE_NORMAL
- en: uart_set_baudrate(CLK,UART_BAUDRATE);
  prefs: []
  type: TYPE_NORMAL
- en: /*8\. Select to use DMA for TX and RX*/
  prefs: []
  type: TYPE_NORMAL
- en: USART2->CR3 = CR3_DMAT |CR3_DMAR;
  prefs: []
  type: TYPE_NORMAL
- en: /*9\. Set transfer direction*/
  prefs: []
  type: TYPE_NORMAL
- en: USART2->CR1 = CR1_TE |CR1_RE;
  prefs: []
  type: TYPE_NORMAL
- en: /*10.Clear TC flag*/
  prefs: []
  type: TYPE_NORMAL
- en: USART2->SR &=~SR_TC;
  prefs: []
  type: TYPE_NORMAL
- en: /*11.Enable TCIE*/
  prefs: []
  type: TYPE_NORMAL
- en: USART2->CR1 |=CR1_TCIE;
  prefs: []
  type: TYPE_NORMAL
- en: /*12\. Enable uart module*/
  prefs: []
  type: TYPE_NORMAL
- en: USART2->CR1 |= CR1_UE;
  prefs: []
  type: TYPE_NORMAL
- en: /*13.Enable USART2 interrupt in the NVIC*/
  prefs: []
  type: TYPE_NORMAL
- en: NVIC_EnableIRQ(USART2_IRQn);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: void dma1_init(void)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: /*Enable clock access to DMA*/
  prefs: []
  type: TYPE_NORMAL
- en: RCC->AHB1ENR |=DMA1EN;
  prefs: []
  type: TYPE_NORMAL
- en: /*Enable DMA Stream6 Interrupt in NVIC*/
  prefs: []
  type: TYPE_NORMAL
- en: NVIC_EnableIRQ(DMA1_Stream6_IRQn);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: void dma1_stream5_uart_rx_config(void)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: /*Disable DMA stream*/
  prefs: []
  type: TYPE_NORMAL
- en: DMA1_Stream5->CR &=~DMA_SCR_EN;
  prefs: []
  type: TYPE_NORMAL
- en: /*Wait till DMA Stream is disabled*/
  prefs: []
  type: TYPE_NORMAL
- en: while((DMA1_Stream5->CR & DMA_SCR_EN)){}
  prefs: []
  type: TYPE_NORMAL
- en: /*Clear interrupt flags for stream 5*/
  prefs: []
  type: TYPE_NORMAL
- en: DMA1->HIFCR = HIFCR_CDMEIF5 |HIFCR_CTEIF5|HIFCR_CTCIF5;
  prefs: []
  type: TYPE_NORMAL
- en: /*Set periph address*/
  prefs: []
  type: TYPE_NORMAL
- en: DMA1_Stream5->PAR = (uint32_t)(&(USART2->DR));
  prefs: []
  type: TYPE_NORMAL
- en: /*Set mem address*/
  prefs: []
  type: TYPE_NORMAL
- en: DMA1_Stream5->M0AR = (uint32_t)(&uart_data_buffer);
  prefs: []
  type: TYPE_NORMAL
- en: /*Set number of transfer*/
  prefs: []
  type: TYPE_NORMAL
- en: DMA1_Stream5->NDTR = (uint16_t)UART_DATA_BUFF_SIZE;
  prefs: []
  type: TYPE_NORMAL
- en: /*Select Channel 4*/
  prefs: []
  type: TYPE_NORMAL
- en: DMA1_Stream5->CR &= ~(1u<<25);
  prefs: []
  type: TYPE_NORMAL
- en: DMA1_Stream5->CR &= ~(1u<<26);
  prefs: []
  type: TYPE_NORMAL
- en: DMA1_Stream5->CR |= (1u<<27);
  prefs: []
  type: TYPE_NORMAL
- en: /*Enable memory addr increment*/
  prefs: []
  type: TYPE_NORMAL
- en: DMA1_Stream5->CR |=DMA_SCR_MINC;
  prefs: []
  type: TYPE_NORMAL
- en: /*Enable transfer complete interrupt*/
  prefs: []
  type: TYPE_NORMAL
- en: DMA1_Stream5->CR |= DMA_SCR_TCIE;
  prefs: []
  type: TYPE_NORMAL
- en: /*Enable Circular mode*/
  prefs: []
  type: TYPE_NORMAL
- en: DMA1_Stream5->CR |=DMA_SCR_CIRC;
  prefs: []
  type: TYPE_NORMAL
- en: '/*Set transfer direction : Periph to Mem*/'
  prefs: []
  type: TYPE_NORMAL
- en: DMA1_Stream5->CR &=~(1U<<6);
  prefs: []
  type: TYPE_NORMAL
- en: DMA1_Stream5->CR &=~(1U<<7);
  prefs: []
  type: TYPE_NORMAL
- en: /*Enable DMA stream*/
  prefs: []
  type: TYPE_NORMAL
- en: DMA1_Stream5->CR |= DMA_SCR_EN;
  prefs: []
  type: TYPE_NORMAL
- en: /*Enable DMA Stream5 Interrupt in NVIC*/
  prefs: []
  type: TYPE_NORMAL
- en: NVIC_EnableIRQ(DMA1_Stream5_IRQn);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: void dma1_stream6_uart_tx_config(uint32_t msg_to_snd, uint32_t msg_len)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: /*Disable DMA stream*/
  prefs: []
  type: TYPE_NORMAL
- en: DMA1_Stream6->CR &=~DMA_SCR_EN;
  prefs: []
  type: TYPE_NORMAL
- en: /*Wait till  DMA Stream is disabled*/
  prefs: []
  type: TYPE_NORMAL
- en: while((DMA1_Stream6->CR & DMA_SCR_EN)){}
  prefs: []
  type: TYPE_NORMAL
- en: /*Clear interrupt flags for stream 6*/
  prefs: []
  type: TYPE_NORMAL
- en: DMA1->HIFCR = HIFCR_CDMEIF6 |HIFCR_CTEIF6|HIFCR_CTCIF6;
  prefs: []
  type: TYPE_NORMAL
- en: /*Set periph address*/
  prefs: []
  type: TYPE_NORMAL
- en: DMA1_Stream6->PAR = (uint32_t)(&(USART2->DR));
  prefs: []
  type: TYPE_NORMAL
- en: /*Set mem address*/
  prefs: []
  type: TYPE_NORMAL
- en: DMA1_Stream6->M0AR = msg_to_snd;
  prefs: []
  type: TYPE_NORMAL
- en: /*Set number of transfer*/
  prefs: []
  type: TYPE_NORMAL
- en: DMA1_Stream6->NDTR = msg_len;
  prefs: []
  type: TYPE_NORMAL
- en: /*Select Channel 4*/
  prefs: []
  type: TYPE_NORMAL
- en: DMA1_Stream6->CR &= ~(1u<<25);
  prefs: []
  type: TYPE_NORMAL
- en: DMA1_Stream6->CR &= ~(1u<<26);
  prefs: []
  type: TYPE_NORMAL
- en: DMA1_Stream6->CR |= (1u<<27);
  prefs: []
  type: TYPE_NORMAL
- en: /*Enable memory addr increment*/
  prefs: []
  type: TYPE_NORMAL
- en: DMA1_Stream6->CR |=DMA_SCR_MINC;
  prefs: []
  type: TYPE_NORMAL
- en: /*Set transfer direction :Mem to Periph*/
  prefs: []
  type: TYPE_NORMAL
- en: DMA1_Stream6->CR |=(1U<<6);
  prefs: []
  type: TYPE_NORMAL
- en: DMA1_Stream6->CR &=~(1U<<7);
  prefs: []
  type: TYPE_NORMAL
- en: /*Set transfer complete interrupt*/
  prefs: []
  type: TYPE_NORMAL
- en: DMA1_Stream6->CR |= DMA_SCR_TCIE;
  prefs: []
  type: TYPE_NORMAL
- en: /*Enable DMA stream*/
  prefs: []
  type: TYPE_NORMAL
- en: DMA1_Stream6->CR |= DMA_SCR_EN;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: static uint16_t compute_uart_bd(uint32_t periph_clk, uint32_t baudrate)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: return ((periph_clk +( baudrate/2U ))/baudrate);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: static void uart_set_baudrate(uint32_t periph_clk, uint32_t baudrate)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: USART2->BRR  = compute_uart_bd(periph_clk,baudrate);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: void DMA1_Stream6_IRQHandler(void)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: if((DMA1->HISR) & HIFSR_TCIF6)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: //do_ssomething
  prefs: []
  type: TYPE_NORMAL
- en: g_tx_cmplt = 1;
  prefs: []
  type: TYPE_NORMAL
- en: /*Clear the flag*/
  prefs: []
  type: TYPE_NORMAL
- en: DMA1->HIFCR |= HIFCR_CTCIF6;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: void DMA1_Stream5_IRQHandler(void)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: if((DMA1->HISR) & HIFSR_TCIF5)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: g_rx_cmplt = 1;
  prefs: []
  type: TYPE_NORMAL
- en: /*Clear the flag*/
  prefs: []
  type: TYPE_NORMAL
- en: DMA1->HIFCR |= HIFCR_CTCIF5;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: void USART2_IRQHandler(void)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: g_uart_cmplt  = 1;
  prefs: []
  type: TYPE_NORMAL
- en: /*Clear TC interrupt flag*/
  prefs: []
  type: TYPE_NORMAL
- en: USART2->SR &=~SR_TC;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '#ifndef UART_DMA_H__'
  prefs: []
  type: TYPE_NORMAL
- en: '#define UART_DMA_H__'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <stdint.h>'
  prefs: []
  type: TYPE_NORMAL
- en: '#include "stm32f4xx.h"'
  prefs: []
  type: TYPE_NORMAL
- en: '#define UART_DATA_BUFF_SIZE        5'
  prefs: []
  type: TYPE_NORMAL
- en: void uart2_rx_tx_init(void);
  prefs: []
  type: TYPE_NORMAL
- en: void dma1_init(void);
  prefs: []
  type: TYPE_NORMAL
- en: void dma1_stream5_uart_rx_config(void);
  prefs: []
  type: TYPE_NORMAL
- en: void dma1_stream6_uart_tx_config(uint32_t msg_to_snd, uint32_t msg_len);
  prefs: []
  type: TYPE_NORMAL
- en: 'main.c file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the `main` function, we start by initializing the UART and DMA, and then
    we configure DMA1 Stream5 for UART reception and DMA1 Stream6 for UART transmission.
    We prepare a message that indicates initialization completion and initiate its
    transmission via DMA. The main loop continuously checks whether a UART message
    has been received. When a message is received, it formats the received data into
    a response message, resets the completion flags, and transmits the response using
    DMA.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Testing the project
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: To test the project, compile the code and upload it to your microcontroller.
    Open RealTerm or any other serial terminal application, and then configure it
    with the appropriate port and baud rate to view the debug messages. Press the
    black push button on the development board to reset the microcontroller. Ensure
    the output area of RealTerm is active by clicking on it. Then, type any five keys
    on your keyboard. You should see these keys appear in the output area of RealTerm.
    The microcontroller receives the typed keys through the `dma1_stream5_uart_rx_config`
    function, stores them in the `msg_buff`, and transmits them to your host computer’s
    serial port via the `dma1_stream6_uart_tx_config` function. The last received
    data remains in `msg_buff` for further processing if needed. We type five characters
    because the `UART_DATA_BUFF_SIZE` is set to `5` in the `uart_dma.h` file.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: In the next section, we will develop our final DMA driver – the DMA memory-to-memory
    driver.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Developing the DMA memory-to-memory driver
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a copy of your previous project in your IDE and rename it `DMA_MemToMem`.
    Next, create a new file named `dma.c` in the `Src` folder and another file named
    `dma.h` in the `Inc` folder. Update your `dma.c` file, as shown here:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This function sets up the `DMA2` controller for memory-to-memory data transfers.
    It begins by enabling the clock for the DMA2 module and ensures that the DMA stream
    is disabled before making any configuration changes. The function configures the
    data size for both memory and peripheral to `half-word` (16-bit) and enables automatic
    incrementing of the memory and peripheral addresses. It sets the transfer direction
    to `memory-to-memory` and enables interrupts for transfer completion and transfer
    errors, ensuring robust error handling and efficient operation. Direct mode is
    disabled to use `FIFO mode`, and the FIFO threshold is set to `full`. Finally,
    the function enables the DMA stream and configures the NVIC to handle DMA interrupts,
    ensuring that the system can respond to DMA events appropriately. We also have
    the `dma_transfer_start` function:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This function initiates the DMA transfer by configuring the source and destination
    addresses and the length of the data transfer. It begins by setting the peripheral
    address of the value passed in `src_buff` and the memory address of the value
    passed in `dest_buff`. The transfer length is then specified by setting the `NDTR`
    register to `len`, indicating the number of data items to transfer. Finally, the
    function enables the DMA stream by setting the `EN` bit in the `CR` register,
    thereby starting the data transfer from the source to the destination. This is
    the `dma.h` file:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '#include <stdio.h>'
  prefs: []
  type: TYPE_NORMAL
- en: '#include <string.h>'
  prefs: []
  type: TYPE_NORMAL
- en: '#include "uart.h"'
  prefs: []
  type: TYPE_NORMAL
- en: '#include "dma.h"'
  prefs: []
  type: TYPE_NORMAL
- en: '#include "uart.h"'
  prefs: []
  type: TYPE_NORMAL
- en: '#define BUFFER_SIZE        5'
  prefs: []
  type: TYPE_NORMAL
- en: uint16_t sensor_data_arr[BUFFER_SIZE] = {892,731,1234,90,23};
  prefs: []
  type: TYPE_NORMAL
- en: uint16_t temp_data_arr[BUFFER_SIZE];
  prefs: []
  type: TYPE_NORMAL
- en: volatile uint8_t g_transfer_cmplt;
  prefs: []
  type: TYPE_NORMAL
- en: int main(void)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: g_transfer_cmplt = 0;
  prefs: []
  type: TYPE_NORMAL
- en: uart_init();
  prefs: []
  type: TYPE_NORMAL
- en: dma2_mem2mem_config();
  prefs: []
  type: TYPE_NORMAL
- en: dma_transfer_start((uint32_t)sensor_data_arr,(uint32_t) temp_data_
  prefs: []
  type: TYPE_NORMAL
- en: arr, BUFFER_SIZE);
  prefs: []
  type: TYPE_NORMAL
- en: /*Wait until transfer complete*/
  prefs: []
  type: TYPE_NORMAL
- en: while(!g_transfer_cmplt){}
  prefs: []
  type: TYPE_NORMAL
- en: for( int i = 0; i < BUFFER_SIZE; i++)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: 'printf("Temp buffer[%d]: %d\r\n",i,temp_data_arr[i]);'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: g_transfer_cmplt = 0;
  prefs: []
  type: TYPE_NORMAL
- en: while(1)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: void DMA2_Stream0_IRQHandler(void)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: /*Check if transfer complete interrupt occurred*/
  prefs: []
  type: TYPE_NORMAL
- en: if((DMA2->LISR) & LISR_TCIF0)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: g_transfer_cmplt = 1;
  prefs: []
  type: TYPE_NORMAL
- en: /*Clear flag*/
  prefs: []
  type: TYPE_NORMAL
- en: DMA2->LIFCR |=LIFCR_CTCIF0;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: /*Check if transfer error occurred*/
  prefs: []
  type: TYPE_NORMAL
- en: if((DMA2->LISR) & LISR_TEIF0)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: /*Do something...*/
  prefs: []
  type: TYPE_NORMAL
- en: /*Clear flag*/
  prefs: []
  type: TYPE_NORMAL
- en: DMA2->LIFCR |= LIFCR_CTEIF0;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
