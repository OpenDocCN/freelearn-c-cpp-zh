- en: Creating Classes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建类
- en: 'This chapter will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下食谱：
- en: Making a UCLASS – deriving from UObject
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 UCLASS – 从 UObject 派生
- en: Creating a blueprint from your custom UCLASS
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从您的自定义 UCLASS 创建蓝图
- en: Creating a user-editable UPROPERTY
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个可由用户编辑的 UPROPERTY
- en: Accessing a UPROPERTY from blueprints
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从蓝图访问 UPROPERTY
- en: Specifying a UCLASS as the type of a UPROPERTY
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 UCLASS 指定为 UPROPERTY 的类型
- en: Instantiating UObject-derived classes (ConstructObject<> and NewObject <>)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例化从 UObject 派生的类（ConstructObject<> 和 NewObject <>）
- en: Destroying UObject-derived classes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 销毁从 UObject 派生的类
- en: Creating a USTRUCT
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 USTRUCT
- en: Creating a UENUM()
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 UENUM()
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This chapter focuses on how to create C++ classes and structs that integrate
    well with the UE4 blueprints editor.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍如何创建与 UE4 蓝图编辑器良好集成的 C++ 类和结构体。
- en: The classes we will be creating in this chapter are graduated versions of the
    regular C++ classes, and are called `UCLASS`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中创建的类是常规 C++ 类的毕业版本，并称为 `UCLASS`。
- en: A `UCLASS` is just a C++ class with a whole lot of UE4 macro decoration on top.
    The macros generate additional C++ header code that enables integration with the
    UE4 editor itself.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`UCLASS` 只是一个带有大量 UE4 宏装饰的 C++ 类。这些宏生成额外的 C++ 头文件代码，使它与 UE4 编辑器本身集成。'
- en: Using `UCLASS` is a great practice to get into. The `UCLASS` macro, if configured
    correctly, can possibly make your `UCLASS` blueprintable, which can enable your
    custom C++ objects to be used within Unreal's visual-scripting language blueprints.
    This can be really useful if you have designers on your team, as they can access
    and tweak aspects of your project without having to dive into code.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `UCLASS` 是一个很好的实践。如果配置正确，`UCLASS` 宏可以使您的 `UCLASS` 可蓝图化，这可以使您的自定义 C++ 对象能够在
    Unreal 的视觉脚本语言蓝图中使用。如果您团队中有设计师，这会非常有用，因为他们可以访问和调整项目的一些方面，而无需深入代码。
- en: 'We can have blueprint''s visually editable properties (`UPROPERTY`) with handy
    UI widgets such as text fields, sliders, and model selection boxes. You can also
    have functions (such as `UFUNCTION`) that are callable from within a blueprints
    diagram. Both of these are shown in the following screenshots:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以有蓝图的可视化可编辑属性（`UPROPERTY`），例如文本字段、滑块和模型选择框等便捷的 UI 小部件。您还可以有函数（如 `UFUNCTION`），这些函数可以从蓝图图中调用。这两个都在以下屏幕截图中显示：
- en: '![](img/48b7d5fd-8b17-41f9-b7fd-2d363741cd9e.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/48b7d5fd-8b17-41f9-b7fd-2d363741cd9e.jpg)'
- en: On the left, two `UPROPERTY` decorated class members (a `UTexture` reference
    and an `FColor`) show up for editing in a C++ class's blueprint. On the right,
    a C++ `GetName` function marked as `BlueprintCallable UFUNCTION` shows up as callable
    from a blueprints diagram.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧，两个带有 `UPROPERTY` 装饰的类成员（一个 `UTexture` 引用和一个 `FColor`）在 C++ 类的蓝图中显示出来以供编辑。在右侧，一个标记为
    `BlueprintCallable UFUNCTION` 的 C++ `GetName` 函数在蓝图图中显示为可调用的。
- en: Code generated by the `UCLASS` macro will be located in a `ClassName.generated.h` file,
    which will be the last `#include` required in your `UCLASS` header file, `ClassName.h`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由 `UCLASS` 宏生成的代码将位于一个 `ClassName.generated.h` 文件中，该文件将是您的 `UCLASS` 头文件 `ClassName.h`
    中所需的最后一个 `#include`。
- en: You will notice that the sample objects we create in this class, even when blueprintable,
    will not be placed in levels. That is because in order to be placed in levels,
    your C++ class must derive from the `Actor` base class, or a subclass below it.
    See [Chapter 4](eade601c-4b55-484a-ba49-0a989d81d7f8.xhtml), *Actors and Components*,
    for further details.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您将注意到，我们在这个类中创建的示例对象，即使当它们是可蓝图化的，也不会放置在级别中。这是因为，为了放置在级别中，您的 C++ 类必须从 `Actor`
    基类派生，或者从其派生的子类。有关更多详细信息，请参阅[第 4 章](eade601c-4b55-484a-ba49-0a989d81d7f8.xhtml)，*演员和组件*。
- en: UE4 code is, typically, very easy to write and manage once you know the patterns.
    The code we write to derive from another `UCLASS`, or to create a `UPROPERTY`
    or `UFUNCTION` instance, is very consistent. This chapter provides recipes for
    common UE4 coding tasks revolving around basic `UCLASS` derivation, property and
    reference declaration, construction, destruction, and general functionality.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您了解了模式，UE4 代码通常很容易编写和管理。我们编写的代码，无论是从另一个 `UCLASS` 派生，还是创建一个 `UPROPERTY` 或 `UFUNCTION`
    实例，都是非常一致的。本章提供了围绕基本 `UCLASS` 派生、属性和引用声明、构造、销毁和一般功能等常见 UE4 编码任务的食谱。
- en: Technical requirements
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires the use of Unreal Engine 4 and uses Visual Studio 2017
    as the IDE. Instructions on how to install both pieces of software and the requirements
    for them can be found in [Chapter 1](4adb307e-d86f-4d70-b6de-a0893102d1cf.xhtml), *UE4
    Development Tools*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要使用 Unreal Engine 4，并使用 Visual Studio 2017 作为 IDE。有关如何安装这两款软件及其要求的说明，请参阅[第
    1 章](4adb307e-d86f-4d70-b6de-a0893102d1cf.xhtml)，*UE4 开发工具*。
- en: Making a UCLASS – deriving from UObject
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 UCLASS – 从 UObject 派生
- en: When coding with C++, you can have your own code that compiles and runs as native
    C++ code, with appropriate calls to the `new` and `delete` operators to create
    and destroy your custom objects. Native C++ code is perfectly acceptable in your
    UE4 project as long as your `new` and `delete` calls are appropriately paired
    so that no memory leaks are present in your code.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当用 C++ 编码时，你可以有自己的代码，这些代码可以作为本地 C++ 代码编译和运行，并适当地调用 `new` 和 `delete` 操作符来创建和销毁你的自定义对象。只要你的
    `new` 和 `delete` 调用适当配对，确保代码中没有内存泄漏，本地 C++ 代码在 UE4 项目中是完全可接受的。
- en: You can, however, also declare custom C++ classes, which behave like UE4 classes,
    by declaring your custom C++ objects using the `UCLASS` macro. The `UCLASS` macro
    tells the class to make use of UE4's smart pointers and memory management routines
    for allocation and de-allocation according to their smart pointer rules, which
    can be loaded and read by the UE4 editor automatically, and can optionally be
    accessed from blueprints.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你也可以通过使用 `UCLASS` 宏来声明自定义 C++ 类，这些类的行为类似于 UE4 类，通过使用 `UCLASS` 宏声明你的自定义 C++
    对象。`UCLASS` 宏告诉类使用 UE4 的智能指针和内存管理例程进行分配和释放，根据它们的智能指针规则，可以由 UE4 编辑器自动加载和读取，并且可以选择从蓝图访问。
- en: 'Note that when you use the `UCLASS` macro, your `UCLASS` object''s creation
    and destruction must be completely managed by UE4: you must use the `ConstructObject` function
    to create an instance of your object (not the C++ native keyword `new`), and call
    the `UObject::ConditionalBeginDestroy()` function to destroy the object (not the
    C++ native keyword `delete`).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当你使用 `UCLASS` 宏时，你的 `UCLASS` 对象的创建和销毁必须完全由 UE4 管理：你必须使用 `ConstructObject`
    函数来创建你的对象实例（而不是 C++ 本地关键字 `new`），并调用 `UObject::ConditionalBeginDestroy()` 函数来销毁对象（而不是
    C++ 本地关键字 `delete`）。
- en: Getting ready
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will outline how to write a C++ class that uses the `UCLASS`
    macro to enable managed memory allocation and de-allocation, as well as to permit
    access from the UE4 editor and blueprints. To complete this recipe, you will need
    a UE4 project that you can add new code to.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将概述如何编写一个使用 `UCLASS` 宏来启用托管内存分配和释放的 C++ 类，以及允许从 UE4 编辑器和蓝图进行访问。要完成此食谱，你需要一个可以添加新代码的
    UE4 项目。
- en: How to do it...
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To create your own `UObject` derivative class, follow these steps:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建自己的 `UObject` 派生类，请按照以下步骤操作：
- en: From your running project, select File | New C++ Class inside the UE4 editor.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 UE4 编辑器中，从你的运行项目中选择文件 | 新 C++ 类。
- en: 'In the Add C++ Class dialog that appears, go to the upper-right-hand side of
    the window and tick the Show All Classes checkbox:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在出现的添加 C++ 类对话框中，转到窗口的右上角并勾选显示所有类复选框：
- en: '![](img/4dc61190-34b3-4777-a3b1-dbd680a1c64b.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4dc61190-34b3-4777-a3b1-dbd680a1c64b.png)'
- en: Select `Object` (top of the hierarchy) as the parent class to inherit from,
    and then click on Next.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `Object`（层次结构的顶部）作为要继承的父类，然后点击下一步。
- en: Note that although `Object` will be written in the dialog box, in your C++ code,
    the C++ class you will be deriving from is actually `UObject` with a leading uppercase `U`.
    This is the naming convention of UE4.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管在对话框中将写入 `Object`，但在你的 C++ 代码中，你将派生的 C++ 类实际上是带有首字母大写的 `U` 的 `UObject`。这是
    UE4 的命名约定。
- en: '`UCLASS` deriving from `UObject` (on a branch other than `Actor`) must be named
    with a leading `U`.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `Actor` 以外的分支派生的 `UCLASS` 必须以首字母 `U` 命名。
- en: '`UCLASS` deriving from `Actor` must be named with a leading `A` ([Chapter 4](eade601c-4b55-484a-ba49-0a989d81d7f8.xhtml), *Actors
    and Components*).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `Actor` 派生的 `UCLASS` 必须以首字母 `A` 命名（[第 4 章](eade601c-4b55-484a-ba49-0a989d81d7f8.xhtml)，*演员和组件*）。
- en: C++ classes (that are not `UCLASS`) deriving from nothing do not have a naming
    convention, but can be named with a leading `F` (for example, `FAssetData`), if
    preferred.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 不是 `UCLASS` 的 C++ 类（从无派生）没有命名约定，但如果愿意，可以用首字母 `F` 命名（例如，`FAssetData`）。
- en: Direct derivatives of `UObject` will not be level-placeable, even if they contain
    visual representation elements such as `UStaticMeshes`. If you want to place your
    object inside a UE4 level, you must at least derive from the `Actor` class or
    beneath it in the inheritance hierarchy. See [Chapter 4](eade601c-4b55-484a-ba49-0a989d81d7f8.xhtml), *Actors
    and Components,* for more information how to derive from the `Actor` class for
    a level-placeable object.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`UObject` 的直接派生类将不会是层级可放置的，即使它们包含视觉表示元素，如 `UStaticMeshes`。如果你想在 UE4 级别内放置你的对象，你必须至少从
    `Actor` 类派生，或者在继承层次结构中位于其下方。有关如何从 `Actor` 类派生以创建层级可放置对象的更多信息，请参阅第 4 章，*演员和组件*。'
- en: This chapter's example code will not be placeable in the level, but you can
    create and use blueprints based on the C++ classes that we write in this chapter
    in the UE4 editor.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码在级别中不可放置，但你可以在 UE4 编辑器中创建和使用基于我们本章中编写的 C++ 类的蓝图。
- en: 'Name your new `Object` derivative something appropriate for the object type
    that you are creating. I''ll call mine `UserProfile`:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为你创建的新 `Object` 派生类命名时，应选择适合你创建的对象类型的名称。我将我的命名为 `UserProfile`：
- en: '![](img/17828513-6e03-4510-8764-731dddf869c3.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/17828513-6e03-4510-8764-731dddf869c3.png)'
- en: This comes off as `UUserObject` in the naming of the class in the C++ file that
    UE4 generates to ensure that the UE4 conventions are followed (In C++, class names
    with a `UCLASS` are preceded with a leading `U`).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 文件中类的命名中，它表现为 `UUserObject`，以确保遵循 UE4 的约定（在 C++ 中，带有 `UCLASS` 的类名以首字母
    `U` 开头）。
- en: 'Click on Create Class and the files should be created after file compilation
    is completed. Afterwards, Visual Studio should open (otherwise, open the solution
    by going to File | Open Visual Studio), and will open up the `.cpp` file of the
    class we just created (`UserProfile.cpp`). Open the header rule (`UserProfile.h`)
    for your class and ensure your class file has the following form:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击创建类，文件应该在文件编译完成后创建。之后，Visual Studio 应该打开（否则，通过转到文件 | 打开 Visual Studio 来打开解决方案），并将打开我们刚刚创建的类的
    `.cpp` 文件（`UserProfile.cpp`）。打开你的类的头文件规则（`UserProfile.h`），确保你的类文件具有以下形式：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Compile and run your project. You can now use your custom `UCLASS` object inside
    Visual Studio, as well as inside the UE4 editor. See the following recipes for
    more details on what you can do with it.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并运行你的项目。现在你可以在 Visual Studio 以及 UE4 编辑器中使用你自定义的 `UCLASS` 对象。有关更多详细信息，请参阅以下菜谱，了解你可以用它做什么。
- en: How to create and destroy your `UObject`-derived classes is outlined in the *Instantiating
    UObject-derived classes (ConstructObject <> and NewObject <>)* and *Destroying
    UObject-derived classes* recipes later in this chapter.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如何创建和销毁你的 `UObject` 派生类将在本章后面的 *实例化 UObject 派生类（ConstructObject <> 和 NewObject
    <>）* 和 *销毁 UObject 派生类* 菜谱中概述。
- en: How it works...
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: UE4 generates and manages a significant amount of code for your custom `UCLASS`.
    This code is generated as a result of the use of the UE4 macros such as `UPROPERTY`,
    `UFUNCTION`, and the `UCLASS` macro itself. The generated code is put into `UserProfile.generated.h`.
    You must `#include` the `UCLASSNAME.generated.h` file with the `UCLASSNAME.h`
    file for compilation to succeed, which is why, by default, the editor includes
    this automatically. Without including the `UCLASSNAME.generated.h` file, compilation
    would fail.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: UE4 为你的自定义 `UCLASS` 生成并管理大量的代码。这些代码是使用 UE4 宏（如 `UPROPERTY`、`UFUNCTION` 和 `UCLASS`
    宏本身）的结果。生成的代码放入 `UserProfile.generated.h`。你必须使用 `UCLASSNAME.h` 文件包含 `UCLASSNAME.generated.h`
    文件以成功编译，这就是为什么默认情况下编辑器会自动包含它。如果不包含 `UCLASSNAME.generated.h` 文件，编译将失败。
- en: It is also important to note that the `UCLASSNAME.generated.h` file must be
    included as the last `#include` in the list of `#include` in `UCLASSNAME.h`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要注意的是，`UCLASSNAME.generated.h` 文件必须作为 `UCLASSNAME.h` 文件中 `#include` 列表中的最后一个
    `#include` 包含。
- en: 'Here''s a correct example:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个正确的示例：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And here is an incorrect one:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个错误的示例：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If the `UCLASSNAME.generated.h` file is not the last item within the list of
    `#include` statements shown in the previous code sample, you will get the following
    error:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `UCLASSNAME.generated.h` 文件不是在前面代码示例中显示的 `#include` 语句列表中的最后一个项目，你将得到以下错误：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: There's more...
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There are a bunch of keywords that we want to discuss here, which modify the
    way a `UCLASS` behaves. A `UCLASS` can be marked as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们想要讨论一些关键字，它们会修改 `UCLASS` 的行为方式。`UCLASS` 可以按以下方式标记：
- en: '`Blueprintable`: This means that you want to be able to construct a blueprint
    from the Class Viewer inside the UE4 editor (when you right-click it, Create Blueprint
    Class... becomes available). Without the `Blueprintable` keyword, the Create Blueprint
    Class... option will not be available for your `UCLASS`, even if you can find
    it from within the Class Viewer and right-click on it:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Blueprintable`：这意味着您希望能够在UE4编辑器中的类查看器内构建蓝图（当您右键单击它时，创建蓝图类...变为可用）。如果没有`Blueprintable`关键字，即使您可以在类查看器中找到它并右键单击它，创建蓝图类...选项也不会对您的`UCLASS`可用：'
- en: '![](img/2c569908-51ef-4c1f-b399-4f45af55f714.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2c569908-51ef-4c1f-b399-4f45af55f714.jpg)'
- en: The Create Blueprint Class... option is only available if you specify `Blueprintable`
    in your `UCLASS` macro definition.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅当您在`UCLASS`宏定义中指定`Blueprintable`时，创建蓝图类...选项才可用。
- en: '`BlueprintType`: Using this keyword implies that the `UCLASS` is usable as
    a variable from another blueprint. You can create blueprint variables from the
    Variables group in the left-hand panel of any blueprint''s EventGraph.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BlueprintType`：使用此关键字意味着`UCLASS`可以用作来自另一个蓝图中的变量。您可以从任何蓝图的事件图左侧面板的变量组中创建蓝图变量。'
- en: '`NotBlueprintType`: Using this keyword specifies that you cannot use this blueprint
    variable type as a variable in a blueprints diagram. Right-clicking the `UCLASS`
    name in the Class Viewer will not show Create Blueprint Class... in its context
    menu:'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NotBlueprintType`：使用此关键字指定您不能将此蓝图变量类型用作蓝图图中的变量。在类查看器中右键单击`UCLASS`名称时，其上下文菜单中不会显示创建蓝图类...：'
- en: '![](img/816ad77a-791c-42fc-b5dd-f517e92db546.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/816ad77a-791c-42fc-b5dd-f517e92db546.jpg)'
- en: You may be unsure whether to declare your C++ class as a `UCLASS` or not. The
    general rule of thumb is to use `UCLASS` unless you have a good reason not to.
    Unreal Engine 4's code is very well-written and has been tested thoroughly by
    this point. If you like smart pointers, you may find that `UCLASS` not only makes
    for safer code, but also makes the entire code base more coherent and more consistent.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能不确定是否应该将您的C++类声明为`UCLASS`。一般规则是除非您有充分的理由不这样做，否则请使用`UCLASS`。到这一点为止，Unreal
    Engine 4的代码已经写得非常好，并且已经经过彻底的测试。如果您喜欢智能指针，您可能会发现`UCLASS`不仅使代码更安全，而且使整个代码库更加连贯和一致。
- en: See also
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: To add additional programmable `UPROPERTY` to the blueprints diagrams, see the
    *Creating a user-editable UPROPERTY* recipe
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要向蓝图图中添加额外的可编程`UPROPERTY`，请参阅*创建用户可编辑的UPROPERTY*配方
- en: For details on referring to instances of your `UCLASS` using appropriate smart
    pointers, refer to [Chapter 3](03463b9f-098a-445f-97b4-291a2b6182e8.xhtml), *Memory
    Management, Smart Pointers, and Debugging*
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关使用适当的智能指针引用您的`UCLASS`实例的详细信息，请参阅[第3章](03463b9f-098a-445f-97b4-291a2b6182e8.xhtml)，*内存管理、智能指针和调试*
- en: For more information on `UCLASS`, `UPROPERTY`, and all of the other similar
    macros and how they are used by UE4, check out [https://www.unrealengine.com/en-US/blog/unreal-property-system-reflection](https://www.unrealengine.com/en-US/blog/unreal-property-system-reflection)
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`UCLASS`、`UPROPERTY`以及所有其他类似宏的更多信息以及它们如何在UE4中使用的详细信息，请查看[https://www.unrealengine.com/en-US/blog/unreal-property-system-reflection](https://www.unrealengine.com/en-US/blog/unreal-property-system-reflection)
- en: Creating a blueprint from your custom UCLASS
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从您的自定义UCLASS创建蓝图
- en: Blueprinting is just the process of deriving a blueprint class for your C++
    object. Creating blueprint-derived classes from your UE4 objects allows you to
    edit the custom `UPROPERTY` visually inside the editor. This avoids hardcoding
    any resources into your C++ code. In addition, your C++ class to be placeable
    within the level, it must be blueprinted first. But this is only possible if the
    C++ class underlying the blueprint is an `Actor` class-derivative.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝图化只是为您的C++对象推导出蓝图类的过程。从UE4对象创建派生自蓝图类允许您在编辑器中直观地编辑自定义`UPROPERTY`。这避免了将任何资源硬编码到您的C++代码中。此外，要使您的C++类能够在级别中放置，它必须首先进行蓝图化。但这仅当蓝图背后的C++类是`Actor`类派生时才可能。
- en: There is a way to load resources (such as textures) using `FStringAssetReferences` and `StaticLoadObject`.
    These pathways to loading resources (by hardcoding path strings into your C++
    code) are generally discouraged, however. Providing an editable value in a `UPROPERTY()` and
    loading from a proper concretely typed asset reference is a much better practice.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种方法可以使用`FStringAssetReferences`和`StaticLoadObject`加载资源（如纹理）。然而，这些加载资源的方法（通过将路径字符串硬编码到您的C++代码中）通常是不推荐的。在`UPROPERTY()`中提供一个可编辑的值，并从适当的具体类型资产引用中加载是一种更好的做法。
- en: Getting ready
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to have a constructed `UCLASS` that you'd like to derive a `Blueprint`
    class from (see the *Making a UCLASS – deriving from UObject* recipe earlier in
    this chapter) to follow this recipe. You must have also marked your `UCLASS` as `Blueprintable` in
    the `UCLASS` macro for blueprinting to be possible inside the engine.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要有一个构造的`UCLASS`，你想要从中派生一个`Blueprint`类（参见本章前面的*制作UCLASS – 从UObject派生*配方），才能遵循此配方。你还必须在`UCLASS`宏中将你的`UCLASS`标记为`Blueprintable`，以便在引擎内部进行蓝图化。
- en: How to do it...
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To blueprint your `UserProfile` class, first ensure that `UCLASS` has the `Blueprintable` tag
    in the `UCLASS` macro. This should look as follows:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要蓝图化你的`UserProfile`类，首先确保`UCLASS`在`UCLASS`宏中有`Blueprintable`标签。它应该看起来像这样：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Compile your code.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译你的代码。
- en: 'Find the `UserProfile` C++ class in the Class Viewer (Window | Developer Tools | Class
    Viewer). Since the previously created `UCLASS` does not derive from `Actor`, to
    find your custom `UCLASS`, you must turn off Filters | Actors Only in the Class
    Viewer (which is checked by default):'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类查看器中找到`UserProfile`C++类（窗口 | 开发者工具 | 类查看器）。由于之前创建的`UCLASS`没有从`Actor`派生，为了找到你的自定义`UCLASS`，你必须关闭类查看器中的过滤器
    | 仅演员（默认情况下是勾选的）：
- en: '![](img/1afbf2e4-e1af-4d41-8e0b-a0947e5e6ba6.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1afbf2e4-e1af-4d41-8e0b-a0947e5e6ba6.jpg)'
- en: If you don't do this, then your custom C++ class may not show!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有这样做，那么你的自定义C++类可能不会显示！
- en: 'Keep in mind that you can use the small search box inside the Class Viewer to
    easily find the `UserProfile` class by starting to type it in:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，你可以使用类查看器内部的小搜索框，通过开始输入来轻松找到`UserProfile`类：
- en: '![](img/eb3b6c95-62c1-4582-b2fe-2d367fc21356.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/eb3b6c95-62c1-4582-b2fe-2d367fc21356.jpg)'
- en: Find your `UserProfile` class in the Class Viewer, right-click on it, and create
    a blueprint from it by selecting Create Blueprint....
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类查看器中找到你的`UserProfile`类，右键单击它，通过选择创建蓝图...来从它创建蓝图。
- en: Name your blueprint. Some prefer to prefix the blueprint class name with `BP_`.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名你的蓝图。有些人喜欢在蓝图类名前加上`BP_`前缀。
- en: You may choose to follow this convention; just be sure to be consistent.
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以选择遵循此约定；只需确保保持一致。
- en: You will be able to edit any fields that are created for each `UserProfile` blueprint
    instance you create.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将能够编辑为每个创建的`UserProfile`蓝图实例创建的任何字段。
- en: If the blueprint editor does not open automatically, you can open it by double-clicking
    on the file in the Content Browser.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果蓝图编辑器没有自动打开，你可以通过在内容浏览器中双击文件来打开它。
- en: How it works...
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Any C++ class you create that has the `Blueprintable` tag in its `UCLASS` macro
    can be blueprinted within the UE4 editor. A blueprint allows you to customize
    properties on the C++ class in the visual GUI interface of UE4.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建的任何具有`UCLASS`宏中`Blueprintable`标签的C++类都可以在UE4编辑器中进行蓝图化。蓝图允许你在UE4的可视GUI界面中自定义C++类的属性。
- en: Creating a user-editable UPROPERTY
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个用户可编辑的UPROPERTY
- en: Each `UCLASS` that you declare can have any number of `UPROPERTY` declared for
    it within it. Each `UPROPERTY` can be a visually editable field, or a blueprints-accessible
    data member of the `UCLASS`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你声明的每个`UCLASS`都可以有任意数量的`UPROPERTY`声明，每个`UPROPERTY`都可以是一个可视编辑字段，或者是一个`UCLASS`的可访问数据成员。
- en: There are a number of qualifiers that we can add to each `UPROPERTY`, which
    change the way it behaves from within the UE4 Editor, such as `EditAnywhere` (specifying
    that the `UPROPERTY` can be changed through code or in the editor), and `BlueprintReadWrite`
    (specifying that blueprints can both read and write the variable at any time,
    in addition to the C++ code being allowed to do so).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为每个`UPROPERTY`添加许多限定符，这些限定符会改变它在UE4编辑器中的行为，例如`EditAnywhere`（指定`UPROPERTY`可以通过代码或编辑器进行更改），以及`BlueprintReadWrite`（指定蓝图可以在任何时间读取和写入变量，除了允许C++代码这样做之外）。
- en: Getting ready
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To use this recipe, you should have a C++ project that you can add C++ code
    to. In addition, you should have completed the preceding recipe, *Making a UCLASS
    – deriving from UObject*.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此配方，你应该有一个可以添加C++代码的C++项目。此外，你应该已经完成了前面的配方，*制作UCLASS – 从UObject派生*。
- en: How to do it...
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First, we will need to mark the class as `Blueprintable` and then add the following
    members to your `UCLASS` declaration, which are shown in bold:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要将类标记为`Blueprintable`，然后向你的`UCLASS`声明中添加以下成员，这些成员以粗体显示：
- en: '[PRE5]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Return to Unreal Editor and then hit the Compile button to update our code.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回Unreal编辑器，然后点击编译按钮以更新我们的代码。
- en: Once updated, create a blueprint of your `UObject` class derivative, if it hasn't
    been created already.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦更新，如果尚未创建，请创建您的`UObject`类派生版的蓝图。
- en: This can be done in the same way that we saw in the previous recipe, but it
    is also possible to do by hand, which we will do now.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过我们之前看到的方式完成，但也可以手动完成，我们现在就是这样做的。
- en: 'To do this, go to the Content Browser tab and click on the folder icon to select
    what section of the project you want to work in. From the window that pops up,
    select the Content section:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要这样做，请转到内容浏览器选项卡并单击文件夹图标以选择您想要工作的项目部分。从弹出的窗口中，选择内容部分：
- en: '![](img/cd4114e3-97a9-42b7-abb8-562944beaa03.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cd4114e3-97a9-42b7-abb8-562944beaa03.png)'
- en: Selecting the Content folder in the Content Browser
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在内容浏览器中选择内容文件夹
- en: 'From there, select the Add New button and then select Blueprint Class:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从那里，选择添加新按钮，然后选择蓝图类：
- en: '![](img/c79a081c-e525-4674-84b1-070f83273e06.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c79a081c-e525-4674-84b1-070f83273e06.png)'
- en: Creating a Blueprint Class from the Content Browser
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 从内容浏览器创建蓝图类
- en: 'From the Pick Parent Class menu, you''ll see some buttons for Common Classes.
    Below that, you''ll see the All Classes option with an arrow to click on to expand
    it. From there, type in the name of your class (in our case, `UserProfile`) and
    then select it from the list. Afterwards, click on the Select button:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从选择父类菜单中，您将看到一些用于常见类的按钮。下面，您将看到所有类选项，有一个箭头可以点击以展开它。从那里，输入您类的名称（在我们的例子中，是`UserProfile`），然后从列表中选择它。之后，单击选择按钮：
- en: '![](img/818ac6d6-2da2-4908-bea0-7f890a911271.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/818ac6d6-2da2-4908-bea0-7f890a911271.png)'
- en: From there, you'll see the item appear in the `Content Browser`, where you can
    rename the instance to whatever you'd like; I named mine `MyProfile`.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从那里，您将在“内容浏览器”中看到项目出现，您可以将实例重命名为您想要的任何名称；我将其命名为`MyProfile`。
- en: Once created, we can open the blueprint in the UE4 Editor by double-clicking
    it.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建后，我们可以通过双击它来在UE4编辑器中打开蓝图。
- en: 'You can now specify values in blueprints for the default values of these new
    `UPROPERTY` fields:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在可以为这些新的`UPROPERTY`字段的默认值指定值：
- en: '![](img/519b9463-1cdd-469b-b1d5-2e8039763b7d.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/519b9463-1cdd-469b-b1d5-2e8039763b7d.png)'
- en: Since the blueprint is empty, it may open as a data-only blueprint that does
    not include the middle and left-hand side sections. To see the full blueprint
    menu, you may need to click Open Full Blueprint Editor at the top of the menu
    to make the screen look like the one in the previous screenshot. However, the
    variables should still be visible and modifiable, either way.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 由于蓝图是空的，它可能以仅包含数据而不包含中间和左侧部分的蓝图打开。要查看完整的蓝图菜单，您可能需要点击菜单顶部的“打开完整蓝图编辑器”以使屏幕看起来像之前的截图。然而，变量仍然应该是可见和可修改的。
- en: Specify the per-instance values by creating new instances of the blueprint and
    editing the values on the object that's placed (by double-clicking on them).
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建蓝图的新实例并编辑放置的对象上的值（通过双击它们）来指定每个实例的值。
- en: How it works...
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The parameters that are passed to the `UPROPERTY()` macro specify a couple
    of important pieces of information regarding the variable. In the preceding example,
    we specified the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`UPROPERTY()`宏的参数指定了有关变量的几个重要信息。在先前的示例中，我们指定了以下内容：
- en: '`EditAnywhere`: This means that the property can be edited either directly
    from the Blueprint, or on each instance of the `UClass` object as placed'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EditAnywhere`：这意味着可以从蓝图直接编辑属性，或者在每个放置的`UClass`对象实例上编辑。'
- en: 'in the game level. Contrast this with the following:'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在游戏级别中。与以下内容进行对比：
- en: '`EditDefaultsOnly`: The blueprint''s value is editable, but it is not editable
    on a per-instance basis.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EditDefaultsOnly`：蓝图值是可编辑的，但不能按实例编辑。'
- en: '`EditInstanceOnly`: This would allow editing of the property in the game-level
    instances of the `UClass` object, and not on the base blueprint itself.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EditInstanceOnly`：这将允许编辑`UClass`对象在游戏级别实例中的属性，而不是在基础蓝图本身上。'
- en: '`BlueprintReadWrite`: This indicates that the property is both readable and
    writable from the blueprints diagrams. `UPROPERTY()` with `BlueprintReadWrite`
    must be public members; otherwise, compilation will fail. Contrast this with the
    following:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BlueprintReadWrite`：这表示属性既可以从蓝图图中读取也可以写入。带有`BlueprintReadWrite`的`UPROPERTY()`必须是公共成员；否则，编译将失败。与以下内容进行对比：'
- en: '`BlueprintReadOnly`: The property must be set from C++ and cannot be changed
    from the blueprints.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BlueprintReadOnly`：属性必须从C++设置，并且不能从蓝图更改。'
- en: '`Category`: You should always specify a `Category` for your `UPROPERTY()` as
    it''s a good practice to stay organized. The `Category` determines which submenu
    the `UPROPERTY()` will appear under in the property editor. All `UPROPERTY()` specified
    under `Category=Stats` will appear in the same `Stats` area in the blueprints
    editor. If no category is specified, the `UPROPERTY` will appear under the default
    category, `UserProfile` (or whatever one called their class).'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`类别`: 你应该始终为你的 `UPROPERTY()` 指定一个 `类别`，因为保持组织有序是一个好习惯。`类别` 决定了 `UPROPERTY()`
    将在属性编辑器下的哪个子菜单中显示。所有在 `Category=Stats` 下指定的 `UPROPERTY()` 都将在蓝图编辑器中的相同 `Stats`
    区域中显示。如果没有指定类别，`UPROPERTY` 将显示在默认类别 `UserProfile`（或 whatever one called their
    class）下。'
- en: There's more...
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'It is important to understand the entire process, which is why we went through
    everything here, but you can also create a Blueprint class from a script by right-clicking
    on the class from the C++ Classes section of the Content Browser and then selecting Create
    Blueprint class based on UserProfile. Refer to the following screenshot:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 理解整个过程很重要，这就是为什么我们在这里详细说明了所有内容，但你也可以通过在内容浏览器的 C++ 类部分右键单击类并选择基于 UserProfile
    创建蓝图类来从脚本创建蓝图类。参见图表：
- en: '![](img/244a29c5-a663-4594-999e-33369eb41c2c.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/244a29c5-a663-4594-999e-33369eb41c2c.png)'
- en: See also
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: A complete `UPROPERTY` listing is located at [https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Reference/Properties/Specifiers/index.html](https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Reference/Properties/Specifiers/index.html).
    Give it a browse.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完整的 `UPROPERTY` 列表位于 [https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Reference/Properties/Specifiers/index.html](https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Reference/Properties/Specifiers/index.html)。浏览一下。
- en: Accessing a UPROPERTY from blueprints
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从蓝图访问 UPROPERTY
- en: Accessing a `UPROPERTY` from blueprints is fairly simple. The member must be
    exposed as a `UPROPERTY` on the member variable that you want to access from your
    blueprints diagram. You must qualify the `UPROPERTY` in your macro declaration
    as being either `BlueprintReadOnly` or `BlueprintReadWrite` to specify whether
    you want the variable to be either readable (only) from Blueprints, or even writable
    from Blueprints.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 从蓝图访问 `UPROPERTY` 相对简单。成员必须作为 `UPROPERTY` 在你想要从蓝图图示中访问的成员变量上暴露。你必须在你宏声明中指定 `UPROPERTY`
    为 `BlueprintReadOnly` 或 `BlueprintReadWrite` 以指定你想要变量是否只从蓝图可读（或甚至可写）。
- en: You can also use the special value `BlueprintDefaultsOnly` to indicate that
    you only want the default value (before the game starts) to be editable from the
    blueprints editor. `BlueprintDefaultsOnly` indicates that the data member cannot
    be edited from Blueprints at runtime.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用特殊值 `BlueprintDefaultsOnly` 来表示你只想从蓝图编辑器编辑默认值（在游戏开始之前）。`BlueprintDefaultsOnly`
    表示数据成员在运行时不能从蓝图编辑。
- en: How to do it...
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create some `UObject`-derivative class, specifying both `Blueprintable` and
    `BlueprintType`, such as in the following code, using the same class we created
    previously:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `UObject` 派生类，指定 `Blueprintable` 和 `BlueprintType`，如下面的代码所示，使用我们之前创建的相同类：
- en: '[PRE6]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `BlueprintType` declaration in the `UCLASS` macro is required to use the
    `UCLASS` as a type within a blueprints diagram.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `UCLASS` 宏中的 `BlueprintType` 声明是必需的，以便在蓝图图中使用 `UCLASS` 作为类型。
- en: Save and compile your code.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并编译你的代码。
- en: Within the UE4 editor, derive a blueprint class from the C++ class if needed,
    as shown in the previous recipe or in the *Creating a Blueprint from your custom
    UCLASS* recipe.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 UE4 编辑器中，如果需要，从 C++ 类派生蓝图类，如前一个食谱或 *从自定义 UCLASS 创建蓝图* 食谱中所示。
- en: 'Double-click on your instance and change the Name variable to have a new value,
    for instance, `Billy`. Afterwards, hit the Compile button to save all of your
    changes:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击你的实例并更改名称变量以获得新值，例如，`Billy`。之后，点击编译按钮以保存所有更改：
- en: '![](img/1472fe26-f9e5-48df-8842-a2e18cc4e7a9.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1472fe26-f9e5-48df-8842-a2e18cc4e7a9.png)'
- en: In a blueprints diagram that allows function calls (such as the Level Blueprint,
    which is accessible via Blueprints | Open Level Blueprint), we can now try to
    make use of the variable we added. Perhaps we can try printing the Name property
    whenever the game starts.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在允许函数调用（如可通过蓝图 | 打开级别蓝图访问的 Level Blueprint）的蓝图图中，我们现在可以尝试使用我们添加的变量。也许我们可以尝试在游戏开始时打印名称属性。
- en: 'To have something happen at the start of the game, we will need to create a
    BeginPlay event. You can do this by right-clicking in the blueprint graph and
    selecting Add Event | Event BeginPlay:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在游戏开始时发生某些事情，我们需要创建一个 BeginPlay 事件。您可以通过在蓝图图中右键单击并选择“添加事件 | 事件 BeginPlay”来完成此操作：
- en: '![](img/48f3b87f-6a3d-4555-8329-bf4efb26de61.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/48f3b87f-6a3d-4555-8329-bf4efb26de61.png)'
- en: Now, need to create an instance of the class. Since it's derived from `UObject`,
    we cannot instantiate it from drag and drop, but we can create something through
    the Construct Object from Class Blueprint node.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，需要创建类的实例。由于它继承自 `UObject`，我们不能通过拖放来实例化它，但我们可以通过从类蓝图节点创建“构造对象”来创建一个实例。
- en: 'Right-click to the right of the node that was just created and from the search
    bar, type in `construct` and select the Construct Object from Class node from
    the list:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击刚刚创建的节点右侧，并在搜索栏中输入“construct”，然后从列表中选择“从类创建对象”节点：
- en: '![](img/8923bed8-7698-4ffa-a1cd-64ab300272ae.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8923bed8-7698-4ffa-a1cd-64ab300272ae.png)'
- en: Next, connect the line from the right of the Event BeginPlay node to the left
    of the Construct Node by dragging the arrow on the bottom-right of the Event BeginPlay node
    to the arrow on the left-hand side of the Construct Node and releasing it.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过将 Event BeginPlay 节点右下角的箭头拖放到 Construct 节点的左侧箭头，并将箭头释放到 Construct 节点的左侧来连接从
    Event BeginPlay 节点右侧的线。
- en: Navigating blueprints diagrams is easy. Right-click and drag to pan a blueprints
    diagram, *Alt* + right-click + drag, or use the mouse wheel to zoom. You can left-click
    and drag any node to position it wherever you want. You can also select multiple
    nodes at the same time and move them all together. You can find more information
    on blueprints here: [https://docs.unrealengine.com/en-US/Engine/Blueprints/BestPractices](https://docs.unrealengine.com/en-US/Engine/Blueprints/BestPractices).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在蓝图图中导航图示非常简单。右键单击并拖动以平移蓝图图示，*Alt* + 右键单击 + 拖动，或使用鼠标滚轮进行缩放。您可以左键单击并拖动任何节点以将其定位到您想要的位置。您还可以同时选择多个节点并将它们全部移动。您可以在以下位置找到有关蓝图的信息：[https://docs.unrealengine.com/en-US/Engine/Blueprints/BestPractices](https://docs.unrealengine.com/en-US/Engine/Blueprints/BestPractices)。
- en: Under the Class section, click on the dropdown and type in the name of the blueprint
    you created (MyProfile) and select it from the list.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“类”部分，单击下拉菜单并输入您创建的蓝图名称（MyProfile），然后从列表中选择它。
- en: 'You also need to select something for the Outer property that will be the owner
    of the object. Click and drag the blue circle and move the mouse to the left of
    the node, and then let go of the mouse to create a new node. When the menu pops
    up, type in the word `self` and then select the Get a reference to self option.
    If all went well, your blueprint should look something like this:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还需要为将作为对象所有者的“外部”属性选择某个内容。单击并拖动蓝色圆圈，将鼠标移至节点的左侧，然后释放鼠标以创建一个新节点。当菜单弹出时，输入单词“self”，然后选择“获取对自身的引用”选项。如果一切顺利，您的蓝图应该看起来像这样：
- en: '![](img/bf976ee7-696b-4cbb-8a58-2eda3acc5830.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bf976ee7-696b-4cbb-8a58-2eda3acc5830.png)'
- en: This will create a variable using the information from the MyProfile instance
    we created earlier. However, we have no way to use it yet unless we make it a
    variable. Drag and drop this to the right of the Return Value property and select
    Promote to a variable. This will automatically create a variable called `NewVar_0`
    and create a Set node, but you can rename it to whatever you want using the menu
    on the left-hand side of the menu.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用我们之前创建的 MyProfile 实例的信息创建一个变量。然而，除非我们将其转换为变量，否则我们无法使用它。将其拖放到 Return Value
    属性的右侧并选择“提升为变量”。这将自动创建一个名为 `NewVar_0` 的变量并创建一个 SET 节点，但您可以使用菜单左侧的菜单将其重命名为您想要的任何名称。
- en: To the right of the SET node, drag and drop the white arrow on the top right
    of the node and create a Print Text node.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 SET 节点右侧，将节点右上角的白色箭头拖放到节点上并创建一个打印文本节点。
- en: We now need something to print, and the Name property will work perfectly for
    this. To the right of the SET node, drag and drop the blue node and select the
    Variables | Stats | Get Name node.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在需要打印一些内容，名称属性将非常适合这个用途。在 SET 节点右侧，将蓝色节点拖放到并选择 Variables | Stats | Get Name
    节点。
- en: Finally, connect the Name value to the In Text property of the Print Text node.
    It will automatically create a conversion node to change the name string into
    a Text object that it can understand.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将名称值连接到打印文本节点的 In Text 属性。它将自动创建一个转换节点，将名称字符串转换为它可以理解的文本对象。
- en: '![](img/223a2a1c-2c4f-4e5c-a49a-bfc510832fc8.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/223a2a1c-2c4f-4e5c-a49a-bfc510832fc8.png)'
- en: 'In the end, the entire blueprint should look something like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，整个蓝图应该看起来像这样：
- en: '![](img/f4713373-7763-48e8-b6d5-da8ae46aea27.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![蓝图示例](img/f4713373-7763-48e8-b6d5-da8ae46aea27.png)'
- en: The completed blueprint
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的蓝图
- en: 'If all went well, you should be able to hit the Compile button and then play
    the game by hitting the Play button on the top of the menu:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，您应该能够点击编译按钮，然后通过点击菜单顶部的播放按钮来玩游戏：
- en: '![](img/eec7e943-df92-4160-8faa-f5435887ca15.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![蓝图示例](img/eec7e943-df92-4160-8faa-f5435887ca15.png)'
- en: Upon playing, you should see Billy show up on the screen, just as we set previously!
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当您开始游戏时，应该会看到比利出现在屏幕上，就像我们之前设置的那样！
- en: How it works...
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: '`UPROPERTY`s are automatically written `Get`/`Set` methods for UE4 classes
    and can be used to access and assign values for properties, as we just saw.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`UPROPERTY`s 会自动为 UE4 类编写 `Get`/`Set` 方法，并可用于访问和分配属性值，正如我们刚才看到的。'
- en: Specifying a UCLASS as the type of a UPROPERTY
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 UCLASS 指定为 UPROPERTY 的类型
- en: So, you've constructed some custom `UCLASS`, intended for use inside UE4\. We
    created one in the editor using blueprints in the previous recipe, but how do
    you instantiate them in C++? Objects in UE4 are reference-counted and memory-managed
    objects, so you should not allocate them directly using the C++ keyword `new`. Instead,
    you'll have to use a function called `ConstructObject` so that we can instantiate
    your `UObject` derivative.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您已经构建了一些自定义的 `UCLASS`，打算在 UE4 内使用。我们在之前的配方中使用蓝图在编辑器中创建了一个，但如何在 C++ 中实例化它们呢？UE4
    中的对象是引用计数和内存管理的对象，因此您不应直接使用 C++ 关键字 `new` 来分配它们。相反，您将不得不使用一个名为 `ConstructObject`
    的函数，这样我们就可以实例化您的 `UObject` 派生类。
- en: '`ConstructObject` doesn''t just take the C++ class name of the object you are
    creating; it also requires a blueprint class derivative of the C++ class (a `UClass*`
    reference). A `UClass*` reference is just a pointer to a blueprint.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConstructObject` 不仅需要您正在创建的对象的 C++ 类名；它还需要 C++ 类的蓝图类派生（一个 `UClass*` 引用）。`UClass*`
    引用只是一个指向蓝图的指针。'
- en: How do we instantiate an instance of a particular blueprint from the C++ code?
    C++ code does not, and should not, know concrete `UCLASS` names, since these names
    are created and edited in the UE4 editor, which you can only access after compilation.
    We need a way to somehow hand back the blueprint class name to instantiate with
    the C++ code.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在 C++ 代码中实例化特定蓝图的实例？C++ 代码既不知道也不应该知道具体的 `UCLASS` 名称，因为这些名称是在 UE4 编辑器中创建和编辑的，您只能在编译后才能访问。我们需要一种方法，以某种方式将蓝图类名称返回以供
    C++ 代码实例化。
- en: The way we do this is by having the UE4 programmer select the `UClass` that
    the C++ code is to use from a simple drop-down menu listing all the blueprints
    available (derived from a particular C++ class) inside the UE4 editor. To do this,
    we simply have to provide a user-editable `UPROPERTY` with a `TSubclassOf<C++ClassName>` typed
    variable. Alternatively, you can use `FStringClassReference` to achieve the same
    objective.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做是通过让 UE4 程序员从 UE4 编辑器内列出的所有可用的蓝图（从特定的 C++ 类派生而来）的简单下拉菜单中选择要使用的 `UClass`，在
    C++ 代码中使用。为此，我们只需提供一个用户可编辑的 `UPROPERTY`，其中包含 `TSubclassOf<C++ClassName>` 类型的变量。或者，您也可以使用
    `FStringClassReference` 来实现相同的目标。
- en: '`UCLASS` should be considered as resources to the C++ code, and their names
    should never be hardcoded into the code base.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 应将 `UCLASS` 视为 C++ 代码的资源，其名称永远不应硬编码到代码库中。
- en: Getting ready
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In your UE4 code, you're often going to need to refer to different `UCLASS`
    in the project. For example, say you need to know the `UCLASS` of the player object
    so that you can use `SpawnObject` in your code on it. Specifying a `UCLASS` from
    C++ code is extremely awkward, because the C++ code is not supposed to know about
    the concrete instances of the derived `UCLASS` that were created in the blueprints
    editor at all. Just as we don't want to bake specific asset names into the C++
    code, we don't want to hardcode derived blueprints class names into the C++ code.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的 UE4 代码中，您经常会需要引用项目中的不同 `UCLASS`。例如，假设您需要知道玩家对象的 `UCLASS`，以便您可以在代码中使用 `SpawnObject`。从
    C++ 代码中指定 `UCLASS` 非常尴尬，因为 C++ 代码根本不应该知道在蓝图编辑器中创建的派生 `UCLASS` 的具体实例。就像我们不想将特定的资产名称烘焙到
    C++ 代码中一样，我们也不希望将派生蓝图类名称硬编码到 C++ 代码中。
- en: So, we use a C++ variable (for example, `UClassOfPlayer`), and select that from
    a blueprints dialog in the UE4 editor. You can do so using a `TSubclassOf` member
    or an `FStringClassReference` member.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们使用一个 C++ 变量（例如，`UClassOfPlayer`），并在 UE4 编辑器的蓝图对话框中选择它。您可以使用 `TSubclassOf`
    成员或 `FStringClassReference` 成员来这样做。
- en: How to do it...
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Navigate to the C++ class that you'd like to add the `UCLASS` reference member
    to.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到你想添加 `UCLASS` 引用成员的 C++ 类。
- en: 'From inside a `UCLASS`, use code of the following form to declare a `UPROPERTY` that
    allows for the selection of a `UClass` (blueprint class) that derives from `UObject` in
    the hierarchy:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `UCLASS` 内部，使用以下形式的代码来声明一个 `UPROPERTY`，允许选择从 `UObject` 在层次结构中派生的 `UClass`（蓝图类）：
- en: '[PRE7]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Visual Studio may underline the `UClassOfPlayer` variable and say that an incomplete
    class is not allowed. This is one of those cases when Visual Studio errors aren't
    right and can be ignored as it will compile fine inside UE4.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 可能会下划线显示 `UClassOfPlayer` 变量，并指出不允许不完整的类。这是 Visual Studio 错误不正确的情况之一，可以忽略，因为它在
    UE4 内部编译时不会有问题。
- en: 'Blueprint the C++ class, and then open that blueprint:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 蓝图 C++ 类，然后打开该蓝图：
- en: '![](img/dbb893f3-d100-42be-afc7-4fc7a2076da2.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dbb893f3-d100-42be-afc7-4fc7a2076da2.png)'
- en: Notice that we now have a second category, Unit, and it has the two properties
    we specified in our script.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们现在有了第二个类别，单位，并且它具有我们在脚本中指定的两个属性。
- en: Click on the drop-down menu beside your `UClassOfPlayer` menu.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `UClassOfPlayer` 菜单旁边的下拉菜单。
- en: 'Select the appropriate `UClassOfPlayer` member from the drop-down menu of the
    listed `UClass`:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从列出的 `UClass` 的下拉菜单中选择合适的 `UClassOfPlayer` 成员：
- en: '![](img/21af16e5-ea46-4084-bd60-4b3f4fa8dac6.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/21af16e5-ea46-4084-bd60-4b3f4fa8dac6.png)'
- en: How it works...
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Unreal Engine 4 give us a number of ways to specify a `UClass` or expected class
    type.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Unreal Engine 4 提供了多种方式来指定 `UClass` 或期望的类类型。
- en: TSubclassOf
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TSubclassOf
- en: The `TSubclassOf< >` member will allow you to specify a `UClass` name using
    a drop-down menu inside the UE4 editor when editing any blueprints that have `TSubclassOf<
    >` members.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`TSubclassOf< >` 成员将允许你在 UE4 编辑器内编辑任何具有 `TSubclassOf< >` 成员的蓝图时，使用下拉菜单指定 `UClass`
    名称。'
- en: FStringClassReference
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FStringClassReference
- en: The `MetaClass` tag refers to the base C++ class from which you expect the `UClassName` to
    derive. This limits the drop-down menu's contents to only the blueprints derived
    from that C++ class. You can leave the `MetaClass` tag out if you wish to display
    all the blueprints in the project.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`MetaClass` 标签指的是你期望 `UClassName` 从其派生的基 C++ 类。这限制了下拉菜单的内容仅限于从该 C++ 类派生的蓝图。如果你希望显示项目中的所有蓝图，可以省略
    `MetaClass` 标签。'
- en: Instantiating UObject-derived classes (ConstructObject< > and NewObject< >)
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实例化从 UObject 派生的类（ConstructObject< > 和 NewObject< >）
- en: Creating class instances in C++ is traditionally done using the keyword `new`.
    However, UE4 actually creates instances of its classes internally and requires
    you to call special factory functions to produce copies of any `UCLASS` that you
    want to instantiate. You produce instances of the UE4 blueprints classes, not
    the C++ class alone. When you create `UObject`-derived classes, you will need
    to instantiate them using special UE4 Engine functions.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C++ 中创建类实例的传统方法是使用关键字 `new`。然而，UE4 实际上在其内部创建其类的实例，并要求你调用特殊的工厂函数来生成任何你想要实例化的
    `UCLASS` 的副本。你生成的是 UE4 蓝图类的实例，而不仅仅是 C++ 类。当你创建 `UObject` 派生的类时，你需要使用特殊的 UE4 引擎函数来实例化它们。
- en: The factory method allows UE4 to exercise some memory management on the object,
    controlling what happens to the object when it is deleted. This method allows
    UE4 to track all references to an object so that on object destruction, all references
    to the object can be easily unlinked. This ensures that no dangling pointers with
    references to invalidated memory exist in the program. This process is usually
    called **garbage collection**.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂方法允许 UE4 对对象进行一些内存管理，控制对象被删除时发生的情况。此方法允许 UE4 跟踪对象的所有引用，以便在对象销毁时，可以轻松地解除所有对对象的引用。这确保程序中不存在指向已失效内存的悬空指针。这个过程通常被称为
    **垃圾回收**。
- en: Getting ready
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Instantiating `UObject`-derived classes that are not `AActor` class derivatives
    does not use `UWorld::SpawnActor< >`. Instead, we have to a special global function: `ConstructObject<
    >` or `NewObject< >`. Note that you should not use the bare C++ keyword `new`
    to allocate new instances of your UE4 `UObject` class derivatives.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化不是 `AActor` 类派生的 `UObject` 派生类不使用 `UWorld::SpawnActor< >`。相反，我们必须使用一个特殊的全局函数：`ConstructObject<
    >` 或 `NewObject< >`。请注意，你不应该使用裸 C++ 关键字 `new` 来分配 UE4 `UObject` 类派生的新实例。
- en: 'You will need at least two pieces of information to properly instantiate your
    `UCLASS` instance:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你至少需要两份信息来正确实例化你的 `UCLASS` 实例：
- en: A C++ typed `UClass` reference to the class type that you would like to instantiate
    (blueprint class)
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指向你想要实例化的类类型的 C++ 类型化 `UClass` 引用（蓝图类）
- en: The original C++ base class from which the blueprint class derives
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蓝图类所继承的原始 C++ 基类
- en: How to do it...
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In a globally accessible object (such as your `GameMode` object), add a `TSubclassOf<
    YourC++ClassName > UPROPERTY()` to specify and supply the `UCLASS` name to your
    C++ code. To do this with the GameMode, do the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个全局可访问的对象（如你的 `GameMode` 对象）中，添加一个 `TSubclassOf< YourC++ClassName > UPROPERTY()`
    来指定并为你 C++ 代码提供 `UCLASS` 名称。要对 GameMode 执行此操作，请按照以下步骤操作：
- en: 'From Visual Studio, open up the `Chapter02_GameModeBase.h` file from the Solution
    Explorer. From there, update the script to the following:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Visual Studio 中，在 Solution Explorer 中打开 `Chapter02_GameModeBase.h` 文件。从那里，将脚本更新为以下内容：
- en: '[PRE8]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Save and compile your code.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并编译你的代码。
- en: 'From the UE4 editor, create a blueprint from this class. Double-click on it
    to enter the blueprints editor and then select your `UClass` name from the drop-down
    menu so that you can see what it does. Save and exit the editor:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 UE4 编辑器中，从这个类创建一个蓝图。双击它进入蓝图编辑器，然后从下拉菜单中选择你的 `UClass` 名称，以便你可以看到它做了什么。保存并退出编辑器：
- en: '![](img/1fd16d87-b45d-4366-b178-bc8863d838b8.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1fd16d87-b45d-4366-b178-bc8863d838b8.png)'
- en: In your C++ code, find the section where you want to instantiate the `UCLASS`
    instance.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 C++ 代码中，找到你想要实例化 `UCLASS` 实例的部分。
- en: 'Instantiate the object using `ConstructObject< >` with the following formula:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下公式使用 `ConstructObject< >` 实例化对象：
- en: '[PRE9]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For example, using the `UserProfile` object that we specified in the last recipe,
    we would get code such as this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用我们在上一个菜谱中指定的 `UserProfile` 对象，我们会得到如下代码：
- en: '[PRE10]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can see an example of this being used in the `Chapter_02GameModeBase.cpp`
    file in this book's example code.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书示例代码中的 `Chapter_02GameModeBase.cpp` 文件中看到一个使用此功能的例子。
- en: How it works...
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Instantiating a `UObject` class using `NewObject` is simple. `ConstructObject`
    will instantiate an object of the blueprint-class type, and return a C++ pointer
    of the correct type.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `NewObject` 实例化 `UObject` 类很简单。`ConstructObject` 将实例化蓝图类类型的对象，并返回正确类型的 C++
    指针。
- en: Unfortunately, `NewObject` has a nasty first parameter that requires you to
    pass `GetTransientPackage()` with each call.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 很不幸，`NewObject` 有一个讨厌的第一个参数，它要求你在每次调用时传递 `GetTransientPackage()`。
- en: Do not use the keyword `new` when constructing your UE4 `UObject` derivative!
    It will not be properly memory-managed.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 构建你的 UE4 `UObject` 派生类时，不要使用关键字 `new`！它将无法得到适当的内存管理。
- en: For more information on `NewObject` and other object creation functions, check
    out [https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/Objects/Creation](https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/Objects/Creation).[ ](https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/Objects/Creation)
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于 `NewObject` 和其他对象创建函数的信息，请查看[https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/Objects/Creation](https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/Objects/Creation)。
- en: There's more...
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `NewObject` function is what the OOP world refers to as a factory, and is
    a common design pattern. You ask the factory to make you the object; you don't
    go about constructing it by yourself. Using a factory pattern enables the engine
    to easily track objects as they are created.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewObject` 函数是面向对象世界所说的工厂，它是一种常见的设计模式。你要求工厂为你创建对象；你不需要自己构建它。使用工厂模式可以使引擎在对象创建时轻松跟踪对象。'
- en: 'For more information on design patterns, including the factory pattern, check
    out *Design Patterns: Elements of Reusable Object-Oriented Software *by Erich
    Gamma.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于设计模式的信息，包括工厂模式，请查看 Erich Gamma 所著的 *《设计模式：可复用面向对象软件元素》*。
- en: If you are interested in learning more about design patterns for game development,
    you may wish to check out *Game Development Patterns and Best Practices*, also
    available from Packt Publishing.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对游戏开发中的设计模式感兴趣，你可能希望查看 *《游戏开发模式和最佳实践》*，该书也由 Packt Publishing 出版。
- en: Destroying UObject-derived classes
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 销毁从 UObject 派生的类
- en: Removing any `UObject` derivative is simple in UE4\. When you are ready to delete
    your `UObject`-derived class, we will simply call a single function (`ConditionalBeginDestroy()`)
    on it to begin teardown. We do not use the native C++ `delete` command on `UObject`
    derivatives. We will show this in the following recipe.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在UE4中移除任何`UObject`派生类都很简单。当你准备好删除你的`UObject`派生类时，我们只需在它上面调用一个函数（`ConditionalBeginDestroy()`）来开始拆卸。我们不会在`UObject`派生类上使用原生的C++
    `delete`命令。我们将在下面的配方中展示这一点。
- en: Getting ready
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To complete this recipe, you will need to have an object (`objectInstance`,
    in this case) that you wish to destroy in your project.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个配方，你需要在你的项目中有一个对象（在这个例子中是`objectInstance`）是你希望销毁的。
- en: How to do it...
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Call `objectInstance->ConditionalBeginDestroy()` on your object instance.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的对象实例上调用`objectInstance->ConditionalBeginDestroy()`。
- en: 'Null all your references to `objectInstance` in your client code, and do not
    use `objectInstance` again after `ConditionalBeginDestroy()` has been called on
    it:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的客户端代码中，将所有对`objectInstance`的引用置为空，并且在调用`ConditionalBeginDestroy()`之后不要再使用`objectInstance`：
- en: '[PRE11]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `ConditionalBeginDestroy()` function begins the destruction process by removing
    all internal engine linkages to it. This marks the object for destruction as far
    as the engine is concerned. The object is then destroyed some time later by destroying
    its internal properties, followed by actual destruction of the object.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConditionalBeginDestroy()`函数通过移除所有内部引擎链接来开始销毁过程。这从引擎的角度标记对象为销毁。然后，通过销毁其内部属性，稍后实际销毁对象。'
- en: After `ConditionalBeginDestroy()` has been called on an object, your (client)
    code must consider the object to be destroyed, and must no longer use it.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在对对象调用`ConditionalBeginDestroy()`之后，你的（客户端）代码必须认为该对象将被销毁，并且必须不再使用它。
- en: 'Actual memory recovery happens some time later than when `ConditionalBeginDestroy()`
    has been called on an object. There is a garbage collection routine that finishes
    clearing the memory of objects that are no longer referenced by the game program
    at fixed time intervals. The time interval between garbage collector calls is
    listed in `C:\Program Files (x86)\Epic Games\Launcher\Engine\Config\BaseEngine.ini`,
    and defaults to one collection every 61.1 seconds:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的内存恢复发生在对对象调用`ConditionalBeginDestroy()`之后的一段时间。有一个垃圾回收例程会在固定的时间间隔内清除游戏程序不再引用的对象的内存。垃圾收集器调用之间的时间间隔列在`C:\Program
    Files (x86)\Epic Games\Launcher\Engine\Config\BaseEngine.ini`中，默认为每61.1秒收集一次：
- en: '[PRE12]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If the memory seems low after several `ConditionalBeginDestroy()` calls, you
    can trigger memory cleanup by calling `GetWorld()->ForceGarbageCollection(true)` to
    force an internal memory cleanup.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在多次调用`ConditionalBeginDestroy()`之后内存似乎很低，你可以通过调用`GetWorld()->ForceGarbageCollection(true)`来触发内存清理，以强制进行内部内存清理。
- en: Usually, you do not need to worry about garbage collection or the interval unless
    you urgently need memory cleared. Do not call garbage collection routines too
    often, as this may cause unnecessary lag in the game.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，除非你急需清理内存，否则你不需要担心垃圾回收或间隔。不要频繁调用垃圾回收例程，因为这可能会在游戏中引起不必要的延迟。
- en: Creating a USTRUCT
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个USTRUCT
- en: 'You may want to construct a blueprints editable property in UE4 that contains
    multiple members. The `FColoredTexture` struct that we will create in this recipe
    will allow you to group together a texture and its color inside the same structure
    for inclusion and specification in any other `UObject`-derivative, `Blueprintable`
    class:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想在UE4中构建一个包含多个成员的蓝图可编辑属性。我们将在这个配方中创建的`FColoredTexture`结构将允许你将纹理及其颜色组合在同一结构中，以便在任何其他`UObject`派生类、`Blueprintable`类中包含和指定：
- en: '![](img/beee3b48-2091-4242-a170-46e6704965ce.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/beee3b48-2091-4242-a170-46e6704965ce.png)'
- en: The `FColoredTexture` structure does have the visual within the blueprints appearance,
    as shown in the preceding screenshot.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`FColoredTexture`结构确实在蓝图外观中具有视觉元素，如前一张截图所示。'
- en: This is for good organization and convenience of your other `UCLASS UPROPERTIES()`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了良好的组织和其他`UCLASS UPROPERTIES()`的便利性。
- en: You may want to construct a C++ structure in your game using the `struct` keyword.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想在游戏中使用`struct`关键字构建一个C++结构。
- en: Getting ready
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: A `UObject` is the base class of all UE4 class objects, while an `FStruct` is
    just any plain old C++ style struct. All objects that use the automatic memory
    management features within the engine must derive from this class.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`UObject` 是所有 UE4 类对象的基类，而 `FStruct` 只是任何普通的 C++ 风格的结构体。所有使用引擎内自动内存管理功能的对象都必须从这个类派生。'
- en: If you may recall from the C++ language, the only difference between a C++ `class`
    and a C++ `struct` is that C++ classes have default `private` members, while structs
    default to `public` members.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得 C++ 语言，C++ `class` 和 C++ `struct` 之间的唯一区别是 C++ 类默认拥有 `private` 成员，而结构体默认为
    `public` 成员。
- en: In languages such as C#, this isn't the case. In C#, a struct is value-typed,
    while a class is reference-typed.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在像 C# 这样的语言中，情况并非如此。在 C# 中，结构体是值类型，而类是引用类型。
- en: How to do it...
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We''ll create a structure called `FColoredTexture` in C++ code to contain a
    texture and a modulating color:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 C++ 代码中创建一个名为 `FColoredTexture` 的结构，以包含一个纹理和一个调节颜色：
- en: From Visual Studio, right-click on the Games/Chapter_02/Source/Chapter_02 folder
    and select Add | New item.... From the menu, select a Header file (.h) and then
    name the file `ColoredTexture.h` (not `FColoredTexture`).
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Visual Studio 中，右键单击 Games/Chapter_02/Source/Chapter_02 文件夹，然后选择 Add | New
    item.... 从菜单中选择一个头文件 (.h)，然后命名文件为 `ColoredTexture.h`（而不是 `FColoredTexture`）。
- en: 'Under Location, make sure that you select the same folder as the other script
    files in the project (in my case, `C:\Users\admin\Documents\Unreal Projects\Chapter_02\Source\Chapter_02`)
    that is not the default:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“位置”下，确保您选择与项目中的其他脚本文件相同的文件夹（在我的情况下，`C:\Users\admin\Documents\Unreal Projects\Chapter_02\Source\Chapter_02`），而不是默认设置：
- en: '![](img/894cbb06-baf9-4618-bcde-1bd140907c72.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](img/894cbb06-baf9-4618-bcde-1bd140907c72.png)'
- en: 'Once created, use the following code in `ColoredTexture.h`:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建后，在 `ColoredTexture.h` 中使用以下代码：
- en: '[PRE13]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Use `ColoredTexture.h` as a `UPROPERTY()` in a blueprintable `UCLASS()`, using
    a `UPROPERTY()` declaration such as this:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在蓝图可用的 `UCLASS()` 中使用 `ColoredTexture.h` 作为 `UPROPERTY()`，使用如下 `UPROPERTY()`
    声明：
- en: '[PRE14]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Save your script and compile your changes. Upon entering your object blueprint,
    you should notice the new properties:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存您的脚本并编译更改。进入您的对象蓝图后，您应该会注意到新的属性：
- en: '![](img/5699f592-65aa-48d5-9511-2035977e0c6f.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5699f592-65aa-48d5-9511-2035977e0c6f.png)'
- en: How it works...
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `UPROPERTY()` specified for the `FColoredTexture` will show up in the editor
    as editable fields when included as `UPROPERTY()` fields inside another class,
    as shown in step 3.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 为 `FColoredTexture` 指定的 `UPROPERTY()` 当作为另一个类中的 `UPROPERTY()` 字段包含时，将在编辑器中显示为可编辑字段，如第
    3 步所示。
- en: There's more...
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The main reason for making a struct, that is, a `USTRUCT()` instead of just
    a plain old C++ struct, is to interface with the UE4 Engine functionality. You
    can use plain C++ code (without creating `USTRUCT()` objects) for quick small
    structures that don't ask the engine to use them directly.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 创建结构体（即 `USTRUCT()` 而不是普通的 C++ 结构体）的主要原因是为了与 UE4 引擎功能接口。对于快速的小结构，您可以使用普通的 C++
    代码（无需创建 `USTRUCT()` 对象），这些结构不需要引擎直接使用它们。
- en: Creating a UENUM( )
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个 UENUM()
- en: C++ `enum` instances are very useful in typical C++ code. UE4 has a custom type
    of enumeration called `UENUM()`, which allows you to create an `enum` that will
    show up in a drop-down menu inside a blueprint that you are editing.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: C++ `enum` 实例在典型的 C++ 代码中非常有用。UE4 有一种自定义的枚举类型称为 `UENUM()`，它允许您创建一个在您正在编辑的蓝图中的下拉菜单中显示的
    `enum`。
- en: How to do it...
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Go to the header file that will use the `UENUM()` you are specifying, or create
    a
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往将使用您指定的 `UENUM()` 的头文件，或者创建一个
- en: file called `EnumName.h`.
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 文件名为 `EnumName.h`。
- en: 'Use the following code:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码：
- en: '[PRE15]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Use your `UENUM()` in a `UCLASS()`, as follows:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `UCLASS()` 中使用您的 `UENUM()`，如下所示：
- en: '[PRE16]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: '`UENUM()` shows up nicely in the code editor as a drop-down menu in the blueprints
    editor, from which you can only select one of a few values:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`UENUM()` 在代码编辑器中作为蓝图编辑器中的下拉菜单出现，您只能从中选择几个值之一：'
- en: '![](img/ff0d78df-992a-47b1-bd70-9231db4839c7.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ff0d78df-992a-47b1-bd70-9231db4839c7.png)'
- en: As you can see, the values that were specified are there!
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，指定的值都在那里！
