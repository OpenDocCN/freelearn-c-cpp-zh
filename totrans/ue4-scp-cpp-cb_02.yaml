- en: Creating Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Making a UCLASS – deriving from UObject
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a blueprint from your custom UCLASS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a user-editable UPROPERTY
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing a UPROPERTY from blueprints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifying a UCLASS as the type of a UPROPERTY
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instantiating UObject-derived classes (ConstructObject<> and NewObject <>)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Destroying UObject-derived classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a USTRUCT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a UENUM()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter focuses on how to create C++ classes and structs that integrate
    well with the UE4 blueprints editor.
  prefs: []
  type: TYPE_NORMAL
- en: The classes we will be creating in this chapter are graduated versions of the
    regular C++ classes, and are called `UCLASS`.
  prefs: []
  type: TYPE_NORMAL
- en: A `UCLASS` is just a C++ class with a whole lot of UE4 macro decoration on top.
    The macros generate additional C++ header code that enables integration with the
    UE4 editor itself.
  prefs: []
  type: TYPE_NORMAL
- en: Using `UCLASS` is a great practice to get into. The `UCLASS` macro, if configured
    correctly, can possibly make your `UCLASS` blueprintable, which can enable your
    custom C++ objects to be used within Unreal's visual-scripting language blueprints.
    This can be really useful if you have designers on your team, as they can access
    and tweak aspects of your project without having to dive into code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can have blueprint''s visually editable properties (`UPROPERTY`) with handy
    UI widgets such as text fields, sliders, and model selection boxes. You can also
    have functions (such as `UFUNCTION`) that are callable from within a blueprints
    diagram. Both of these are shown in the following screenshots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/48b7d5fd-8b17-41f9-b7fd-2d363741cd9e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: On the left, two `UPROPERTY` decorated class members (a `UTexture` reference
    and an `FColor`) show up for editing in a C++ class's blueprint. On the right,
    a C++ `GetName` function marked as `BlueprintCallable UFUNCTION` shows up as callable
    from a blueprints diagram.
  prefs: []
  type: TYPE_NORMAL
- en: Code generated by the `UCLASS` macro will be located in a `ClassName.generated.h` file,
    which will be the last `#include` required in your `UCLASS` header file, `ClassName.h`.
  prefs: []
  type: TYPE_NORMAL
- en: You will notice that the sample objects we create in this class, even when blueprintable,
    will not be placed in levels. That is because in order to be placed in levels,
    your C++ class must derive from the `Actor` base class, or a subclass below it.
    See [Chapter 4](eade601c-4b55-484a-ba49-0a989d81d7f8.xhtml), *Actors and Components*,
    for further details.
  prefs: []
  type: TYPE_NORMAL
- en: UE4 code is, typically, very easy to write and manage once you know the patterns.
    The code we write to derive from another `UCLASS`, or to create a `UPROPERTY`
    or `UFUNCTION` instance, is very consistent. This chapter provides recipes for
    common UE4 coding tasks revolving around basic `UCLASS` derivation, property and
    reference declaration, construction, destruction, and general functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires the use of Unreal Engine 4 and uses Visual Studio 2017
    as the IDE. Instructions on how to install both pieces of software and the requirements
    for them can be found in [Chapter 1](4adb307e-d86f-4d70-b6de-a0893102d1cf.xhtml), *UE4
    Development Tools*.
  prefs: []
  type: TYPE_NORMAL
- en: Making a UCLASS – deriving from UObject
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When coding with C++, you can have your own code that compiles and runs as native
    C++ code, with appropriate calls to the `new` and `delete` operators to create
    and destroy your custom objects. Native C++ code is perfectly acceptable in your
    UE4 project as long as your `new` and `delete` calls are appropriately paired
    so that no memory leaks are present in your code.
  prefs: []
  type: TYPE_NORMAL
- en: You can, however, also declare custom C++ classes, which behave like UE4 classes,
    by declaring your custom C++ objects using the `UCLASS` macro. The `UCLASS` macro
    tells the class to make use of UE4's smart pointers and memory management routines
    for allocation and de-allocation according to their smart pointer rules, which
    can be loaded and read by the UE4 editor automatically, and can optionally be
    accessed from blueprints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that when you use the `UCLASS` macro, your `UCLASS` object''s creation
    and destruction must be completely managed by UE4: you must use the `ConstructObject` function
    to create an instance of your object (not the C++ native keyword `new`), and call
    the `UObject::ConditionalBeginDestroy()` function to destroy the object (not the
    C++ native keyword `delete`).'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to write a C++ class that uses the `UCLASS`
    macro to enable managed memory allocation and de-allocation, as well as to permit
    access from the UE4 editor and blueprints. To complete this recipe, you will need
    a UE4 project that you can add new code to.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create your own `UObject` derivative class, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: From your running project, select File | New C++ Class inside the UE4 editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Add C++ Class dialog that appears, go to the upper-right-hand side of
    the window and tick the Show All Classes checkbox:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4dc61190-34b3-4777-a3b1-dbd680a1c64b.png)'
  prefs: []
  type: TYPE_IMG
- en: Select `Object` (top of the hierarchy) as the parent class to inherit from,
    and then click on Next.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that although `Object` will be written in the dialog box, in your C++ code,
    the C++ class you will be deriving from is actually `UObject` with a leading uppercase `U`.
    This is the naming convention of UE4.
  prefs: []
  type: TYPE_NORMAL
- en: '`UCLASS` deriving from `UObject` (on a branch other than `Actor`) must be named
    with a leading `U`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`UCLASS` deriving from `Actor` must be named with a leading `A` ([Chapter 4](eade601c-4b55-484a-ba49-0a989d81d7f8.xhtml), *Actors
    and Components*).'
  prefs: []
  type: TYPE_NORMAL
- en: C++ classes (that are not `UCLASS`) deriving from nothing do not have a naming
    convention, but can be named with a leading `F` (for example, `FAssetData`), if
    preferred.
  prefs: []
  type: TYPE_NORMAL
- en: Direct derivatives of `UObject` will not be level-placeable, even if they contain
    visual representation elements such as `UStaticMeshes`. If you want to place your
    object inside a UE4 level, you must at least derive from the `Actor` class or
    beneath it in the inheritance hierarchy. See [Chapter 4](eade601c-4b55-484a-ba49-0a989d81d7f8.xhtml), *Actors
    and Components,* for more information how to derive from the `Actor` class for
    a level-placeable object.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter's example code will not be placeable in the level, but you can
    create and use blueprints based on the C++ classes that we write in this chapter
    in the UE4 editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Name your new `Object` derivative something appropriate for the object type
    that you are creating. I''ll call mine `UserProfile`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/17828513-6e03-4510-8764-731dddf869c3.png)'
  prefs: []
  type: TYPE_IMG
- en: This comes off as `UUserObject` in the naming of the class in the C++ file that
    UE4 generates to ensure that the UE4 conventions are followed (In C++, class names
    with a `UCLASS` are preceded with a leading `U`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on Create Class and the files should be created after file compilation
    is completed. Afterwards, Visual Studio should open (otherwise, open the solution
    by going to File | Open Visual Studio), and will open up the `.cpp` file of the
    class we just created (`UserProfile.cpp`). Open the header rule (`UserProfile.h`)
    for your class and ensure your class file has the following form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Compile and run your project. You can now use your custom `UCLASS` object inside
    Visual Studio, as well as inside the UE4 editor. See the following recipes for
    more details on what you can do with it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to create and destroy your `UObject`-derived classes is outlined in the *Instantiating
    UObject-derived classes (ConstructObject <> and NewObject <>)* and *Destroying
    UObject-derived classes* recipes later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: UE4 generates and manages a significant amount of code for your custom `UCLASS`.
    This code is generated as a result of the use of the UE4 macros such as `UPROPERTY`,
    `UFUNCTION`, and the `UCLASS` macro itself. The generated code is put into `UserProfile.generated.h`.
    You must `#include` the `UCLASSNAME.generated.h` file with the `UCLASSNAME.h`
    file for compilation to succeed, which is why, by default, the editor includes
    this automatically. Without including the `UCLASSNAME.generated.h` file, compilation
    would fail.
  prefs: []
  type: TYPE_NORMAL
- en: It is also important to note that the `UCLASSNAME.generated.h` file must be
    included as the last `#include` in the list of `#include` in `UCLASSNAME.h`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a correct example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is an incorrect one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `UCLASSNAME.generated.h` file is not the last item within the list of
    `#include` statements shown in the previous code sample, you will get the following
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a bunch of keywords that we want to discuss here, which modify the
    way a `UCLASS` behaves. A `UCLASS` can be marked as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Blueprintable`: This means that you want to be able to construct a blueprint
    from the Class Viewer inside the UE4 editor (when you right-click it, Create Blueprint
    Class... becomes available). Without the `Blueprintable` keyword, the Create Blueprint
    Class... option will not be available for your `UCLASS`, even if you can find
    it from within the Class Viewer and right-click on it:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/2c569908-51ef-4c1f-b399-4f45af55f714.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Create Blueprint Class... option is only available if you specify `Blueprintable`
    in your `UCLASS` macro definition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BlueprintType`: Using this keyword implies that the `UCLASS` is usable as
    a variable from another blueprint. You can create blueprint variables from the
    Variables group in the left-hand panel of any blueprint''s EventGraph.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NotBlueprintType`: Using this keyword specifies that you cannot use this blueprint
    variable type as a variable in a blueprints diagram. Right-clicking the `UCLASS`
    name in the Class Viewer will not show Create Blueprint Class... in its context
    menu:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/816ad77a-791c-42fc-b5dd-f517e92db546.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You may be unsure whether to declare your C++ class as a `UCLASS` or not. The
    general rule of thumb is to use `UCLASS` unless you have a good reason not to.
    Unreal Engine 4's code is very well-written and has been tested thoroughly by
    this point. If you like smart pointers, you may find that `UCLASS` not only makes
    for safer code, but also makes the entire code base more coherent and more consistent.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To add additional programmable `UPROPERTY` to the blueprints diagrams, see the
    *Creating a user-editable UPROPERTY* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For details on referring to instances of your `UCLASS` using appropriate smart
    pointers, refer to [Chapter 3](03463b9f-098a-445f-97b4-291a2b6182e8.xhtml), *Memory
    Management, Smart Pointers, and Debugging*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on `UCLASS`, `UPROPERTY`, and all of the other similar
    macros and how they are used by UE4, check out [https://www.unrealengine.com/en-US/blog/unreal-property-system-reflection](https://www.unrealengine.com/en-US/blog/unreal-property-system-reflection)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a blueprint from your custom UCLASS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Blueprinting is just the process of deriving a blueprint class for your C++
    object. Creating blueprint-derived classes from your UE4 objects allows you to
    edit the custom `UPROPERTY` visually inside the editor. This avoids hardcoding
    any resources into your C++ code. In addition, your C++ class to be placeable
    within the level, it must be blueprinted first. But this is only possible if the
    C++ class underlying the blueprint is an `Actor` class-derivative.
  prefs: []
  type: TYPE_NORMAL
- en: There is a way to load resources (such as textures) using `FStringAssetReferences` and `StaticLoadObject`.
    These pathways to loading resources (by hardcoding path strings into your C++
    code) are generally discouraged, however. Providing an editable value in a `UPROPERTY()` and
    loading from a proper concretely typed asset reference is a much better practice.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You need to have a constructed `UCLASS` that you'd like to derive a `Blueprint`
    class from (see the *Making a UCLASS – deriving from UObject* recipe earlier in
    this chapter) to follow this recipe. You must have also marked your `UCLASS` as `Blueprintable` in
    the `UCLASS` macro for blueprinting to be possible inside the engine.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To blueprint your `UserProfile` class, first ensure that `UCLASS` has the `Blueprintable` tag
    in the `UCLASS` macro. This should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Compile your code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Find the `UserProfile` C++ class in the Class Viewer (Window | Developer Tools | Class
    Viewer). Since the previously created `UCLASS` does not derive from `Actor`, to
    find your custom `UCLASS`, you must turn off Filters | Actors Only in the Class
    Viewer (which is checked by default):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1afbf2e4-e1af-4d41-8e0b-a0947e5e6ba6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you don't do this, then your custom C++ class may not show!
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep in mind that you can use the small search box inside the Class Viewer to
    easily find the `UserProfile` class by starting to type it in:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb3b6c95-62c1-4582-b2fe-2d367fc21356.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Find your `UserProfile` class in the Class Viewer, right-click on it, and create
    a blueprint from it by selecting Create Blueprint....
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name your blueprint. Some prefer to prefix the blueprint class name with `BP_`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You may choose to follow this convention; just be sure to be consistent.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You will be able to edit any fields that are created for each `UserProfile` blueprint
    instance you create.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the blueprint editor does not open automatically, you can open it by double-clicking
    on the file in the Content Browser.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any C++ class you create that has the `Blueprintable` tag in its `UCLASS` macro
    can be blueprinted within the UE4 editor. A blueprint allows you to customize
    properties on the C++ class in the visual GUI interface of UE4.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a user-editable UPROPERTY
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each `UCLASS` that you declare can have any number of `UPROPERTY` declared for
    it within it. Each `UPROPERTY` can be a visually editable field, or a blueprints-accessible
    data member of the `UCLASS`.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of qualifiers that we can add to each `UPROPERTY`, which
    change the way it behaves from within the UE4 Editor, such as `EditAnywhere` (specifying
    that the `UPROPERTY` can be changed through code or in the editor), and `BlueprintReadWrite`
    (specifying that blueprints can both read and write the variable at any time,
    in addition to the C++ code being allowed to do so).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To use this recipe, you should have a C++ project that you can add C++ code
    to. In addition, you should have completed the preceding recipe, *Making a UCLASS
    – deriving from UObject*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we will need to mark the class as `Blueprintable` and then add the following
    members to your `UCLASS` declaration, which are shown in bold:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Return to Unreal Editor and then hit the Compile button to update our code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once updated, create a blueprint of your `UObject` class derivative, if it hasn't
    been created already.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This can be done in the same way that we saw in the previous recipe, but it
    is also possible to do by hand, which we will do now.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, go to the Content Browser tab and click on the folder icon to select
    what section of the project you want to work in. From the window that pops up,
    select the Content section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cd4114e3-97a9-42b7-abb8-562944beaa03.png)'
  prefs: []
  type: TYPE_IMG
- en: Selecting the Content folder in the Content Browser
  prefs: []
  type: TYPE_NORMAL
- en: 'From there, select the Add New button and then select Blueprint Class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c79a081c-e525-4674-84b1-070f83273e06.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating a Blueprint Class from the Content Browser
  prefs: []
  type: TYPE_NORMAL
- en: 'From the Pick Parent Class menu, you''ll see some buttons for Common Classes.
    Below that, you''ll see the All Classes option with an arrow to click on to expand
    it. From there, type in the name of your class (in our case, `UserProfile`) and
    then select it from the list. Afterwards, click on the Select button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/818ac6d6-2da2-4908-bea0-7f890a911271.png)'
  prefs: []
  type: TYPE_IMG
- en: From there, you'll see the item appear in the `Content Browser`, where you can
    rename the instance to whatever you'd like; I named mine `MyProfile`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once created, we can open the blueprint in the UE4 Editor by double-clicking
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can now specify values in blueprints for the default values of these new
    `UPROPERTY` fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/519b9463-1cdd-469b-b1d5-2e8039763b7d.png)'
  prefs: []
  type: TYPE_IMG
- en: Since the blueprint is empty, it may open as a data-only blueprint that does
    not include the middle and left-hand side sections. To see the full blueprint
    menu, you may need to click Open Full Blueprint Editor at the top of the menu
    to make the screen look like the one in the previous screenshot. However, the
    variables should still be visible and modifiable, either way.
  prefs: []
  type: TYPE_NORMAL
- en: Specify the per-instance values by creating new instances of the blueprint and
    editing the values on the object that's placed (by double-clicking on them).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The parameters that are passed to the `UPROPERTY()` macro specify a couple
    of important pieces of information regarding the variable. In the preceding example,
    we specified the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`EditAnywhere`: This means that the property can be edited either directly
    from the Blueprint, or on each instance of the `UClass` object as placed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'in the game level. Contrast this with the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`EditDefaultsOnly`: The blueprint''s value is editable, but it is not editable
    on a per-instance basis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EditInstanceOnly`: This would allow editing of the property in the game-level
    instances of the `UClass` object, and not on the base blueprint itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BlueprintReadWrite`: This indicates that the property is both readable and
    writable from the blueprints diagrams. `UPROPERTY()` with `BlueprintReadWrite`
    must be public members; otherwise, compilation will fail. Contrast this with the
    following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BlueprintReadOnly`: The property must be set from C++ and cannot be changed
    from the blueprints.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Category`: You should always specify a `Category` for your `UPROPERTY()` as
    it''s a good practice to stay organized. The `Category` determines which submenu
    the `UPROPERTY()` will appear under in the property editor. All `UPROPERTY()` specified
    under `Category=Stats` will appear in the same `Stats` area in the blueprints
    editor. If no category is specified, the `UPROPERTY` will appear under the default
    category, `UserProfile` (or whatever one called their class).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is important to understand the entire process, which is why we went through
    everything here, but you can also create a Blueprint class from a script by right-clicking
    on the class from the C++ Classes section of the Content Browser and then selecting Create
    Blueprint class based on UserProfile. Refer to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/244a29c5-a663-4594-999e-33369eb41c2c.png)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A complete `UPROPERTY` listing is located at [https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Reference/Properties/Specifiers/index.html](https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/Reference/Properties/Specifiers/index.html).
    Give it a browse.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing a UPROPERTY from blueprints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Accessing a `UPROPERTY` from blueprints is fairly simple. The member must be
    exposed as a `UPROPERTY` on the member variable that you want to access from your
    blueprints diagram. You must qualify the `UPROPERTY` in your macro declaration
    as being either `BlueprintReadOnly` or `BlueprintReadWrite` to specify whether
    you want the variable to be either readable (only) from Blueprints, or even writable
    from Blueprints.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the special value `BlueprintDefaultsOnly` to indicate that
    you only want the default value (before the game starts) to be editable from the
    blueprints editor. `BlueprintDefaultsOnly` indicates that the data member cannot
    be edited from Blueprints at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create some `UObject`-derivative class, specifying both `Blueprintable` and
    `BlueprintType`, such as in the following code, using the same class we created
    previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `BlueprintType` declaration in the `UCLASS` macro is required to use the
    `UCLASS` as a type within a blueprints diagram.
  prefs: []
  type: TYPE_NORMAL
- en: Save and compile your code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the UE4 editor, derive a blueprint class from the C++ class if needed,
    as shown in the previous recipe or in the *Creating a Blueprint from your custom
    UCLASS* recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Double-click on your instance and change the Name variable to have a new value,
    for instance, `Billy`. Afterwards, hit the Compile button to save all of your
    changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1472fe26-f9e5-48df-8842-a2e18cc4e7a9.png)'
  prefs: []
  type: TYPE_IMG
- en: In a blueprints diagram that allows function calls (such as the Level Blueprint,
    which is accessible via Blueprints | Open Level Blueprint), we can now try to
    make use of the variable we added. Perhaps we can try printing the Name property
    whenever the game starts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To have something happen at the start of the game, we will need to create a
    BeginPlay event. You can do this by right-clicking in the blueprint graph and
    selecting Add Event | Event BeginPlay:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/48f3b87f-6a3d-4555-8329-bf4efb26de61.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, need to create an instance of the class. Since it's derived from `UObject`,
    we cannot instantiate it from drag and drop, but we can create something through
    the Construct Object from Class Blueprint node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click to the right of the node that was just created and from the search
    bar, type in `construct` and select the Construct Object from Class node from
    the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8923bed8-7698-4ffa-a1cd-64ab300272ae.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, connect the line from the right of the Event BeginPlay node to the left
    of the Construct Node by dragging the arrow on the bottom-right of the Event BeginPlay node
    to the arrow on the left-hand side of the Construct Node and releasing it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigating blueprints diagrams is easy. Right-click and drag to pan a blueprints
    diagram, *Alt* + right-click + drag, or use the mouse wheel to zoom. You can left-click
    and drag any node to position it wherever you want. You can also select multiple
    nodes at the same time and move them all together. You can find more information
    on blueprints here: [https://docs.unrealengine.com/en-US/Engine/Blueprints/BestPractices](https://docs.unrealengine.com/en-US/Engine/Blueprints/BestPractices).
  prefs: []
  type: TYPE_NORMAL
- en: Under the Class section, click on the dropdown and type in the name of the blueprint
    you created (MyProfile) and select it from the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You also need to select something for the Outer property that will be the owner
    of the object. Click and drag the blue circle and move the mouse to the left of
    the node, and then let go of the mouse to create a new node. When the menu pops
    up, type in the word `self` and then select the Get a reference to self option.
    If all went well, your blueprint should look something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bf976ee7-696b-4cbb-8a58-2eda3acc5830.png)'
  prefs: []
  type: TYPE_IMG
- en: This will create a variable using the information from the MyProfile instance
    we created earlier. However, we have no way to use it yet unless we make it a
    variable. Drag and drop this to the right of the Return Value property and select
    Promote to a variable. This will automatically create a variable called `NewVar_0`
    and create a Set node, but you can rename it to whatever you want using the menu
    on the left-hand side of the menu.
  prefs: []
  type: TYPE_NORMAL
- en: To the right of the SET node, drag and drop the white arrow on the top right
    of the node and create a Print Text node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now need something to print, and the Name property will work perfectly for
    this. To the right of the SET node, drag and drop the blue node and select the
    Variables | Stats | Get Name node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, connect the Name value to the In Text property of the Print Text node.
    It will automatically create a conversion node to change the name string into
    a Text object that it can understand.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/223a2a1c-2c4f-4e5c-a49a-bfc510832fc8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the end, the entire blueprint should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f4713373-7763-48e8-b6d5-da8ae46aea27.png)'
  prefs: []
  type: TYPE_IMG
- en: The completed blueprint
  prefs: []
  type: TYPE_NORMAL
- en: 'If all went well, you should be able to hit the Compile button and then play
    the game by hitting the Play button on the top of the menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eec7e943-df92-4160-8faa-f5435887ca15.png)'
  prefs: []
  type: TYPE_IMG
- en: Upon playing, you should see Billy show up on the screen, just as we set previously!
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`UPROPERTY`s are automatically written `Get`/`Set` methods for UE4 classes
    and can be used to access and assign values for properties, as we just saw.'
  prefs: []
  type: TYPE_NORMAL
- en: Specifying a UCLASS as the type of a UPROPERTY
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, you've constructed some custom `UCLASS`, intended for use inside UE4\. We
    created one in the editor using blueprints in the previous recipe, but how do
    you instantiate them in C++? Objects in UE4 are reference-counted and memory-managed
    objects, so you should not allocate them directly using the C++ keyword `new`. Instead,
    you'll have to use a function called `ConstructObject` so that we can instantiate
    your `UObject` derivative.
  prefs: []
  type: TYPE_NORMAL
- en: '`ConstructObject` doesn''t just take the C++ class name of the object you are
    creating; it also requires a blueprint class derivative of the C++ class (a `UClass*`
    reference). A `UClass*` reference is just a pointer to a blueprint.'
  prefs: []
  type: TYPE_NORMAL
- en: How do we instantiate an instance of a particular blueprint from the C++ code?
    C++ code does not, and should not, know concrete `UCLASS` names, since these names
    are created and edited in the UE4 editor, which you can only access after compilation.
    We need a way to somehow hand back the blueprint class name to instantiate with
    the C++ code.
  prefs: []
  type: TYPE_NORMAL
- en: The way we do this is by having the UE4 programmer select the `UClass` that
    the C++ code is to use from a simple drop-down menu listing all the blueprints
    available (derived from a particular C++ class) inside the UE4 editor. To do this,
    we simply have to provide a user-editable `UPROPERTY` with a `TSubclassOf<C++ClassName>` typed
    variable. Alternatively, you can use `FStringClassReference` to achieve the same
    objective.
  prefs: []
  type: TYPE_NORMAL
- en: '`UCLASS` should be considered as resources to the C++ code, and their names
    should never be hardcoded into the code base.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In your UE4 code, you're often going to need to refer to different `UCLASS`
    in the project. For example, say you need to know the `UCLASS` of the player object
    so that you can use `SpawnObject` in your code on it. Specifying a `UCLASS` from
    C++ code is extremely awkward, because the C++ code is not supposed to know about
    the concrete instances of the derived `UCLASS` that were created in the blueprints
    editor at all. Just as we don't want to bake specific asset names into the C++
    code, we don't want to hardcode derived blueprints class names into the C++ code.
  prefs: []
  type: TYPE_NORMAL
- en: So, we use a C++ variable (for example, `UClassOfPlayer`), and select that from
    a blueprints dialog in the UE4 editor. You can do so using a `TSubclassOf` member
    or an `FStringClassReference` member.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Navigate to the C++ class that you'd like to add the `UCLASS` reference member
    to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From inside a `UCLASS`, use code of the following form to declare a `UPROPERTY` that
    allows for the selection of a `UClass` (blueprint class) that derives from `UObject` in
    the hierarchy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Visual Studio may underline the `UClassOfPlayer` variable and say that an incomplete
    class is not allowed. This is one of those cases when Visual Studio errors aren't
    right and can be ignored as it will compile fine inside UE4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Blueprint the C++ class, and then open that blueprint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/dbb893f3-d100-42be-afc7-4fc7a2076da2.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that we now have a second category, Unit, and it has the two properties
    we specified in our script.
  prefs: []
  type: TYPE_NORMAL
- en: Click on the drop-down menu beside your `UClassOfPlayer` menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the appropriate `UClassOfPlayer` member from the drop-down menu of the
    listed `UClass`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/21af16e5-ea46-4084-bd60-4b3f4fa8dac6.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unreal Engine 4 give us a number of ways to specify a `UClass` or expected class
    type.
  prefs: []
  type: TYPE_NORMAL
- en: TSubclassOf
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `TSubclassOf< >` member will allow you to specify a `UClass` name using
    a drop-down menu inside the UE4 editor when editing any blueprints that have `TSubclassOf<
    >` members.
  prefs: []
  type: TYPE_NORMAL
- en: FStringClassReference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `MetaClass` tag refers to the base C++ class from which you expect the `UClassName` to
    derive. This limits the drop-down menu's contents to only the blueprints derived
    from that C++ class. You can leave the `MetaClass` tag out if you wish to display
    all the blueprints in the project.
  prefs: []
  type: TYPE_NORMAL
- en: Instantiating UObject-derived classes (ConstructObject< > and NewObject< >)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating class instances in C++ is traditionally done using the keyword `new`.
    However, UE4 actually creates instances of its classes internally and requires
    you to call special factory functions to produce copies of any `UCLASS` that you
    want to instantiate. You produce instances of the UE4 blueprints classes, not
    the C++ class alone. When you create `UObject`-derived classes, you will need
    to instantiate them using special UE4 Engine functions.
  prefs: []
  type: TYPE_NORMAL
- en: The factory method allows UE4 to exercise some memory management on the object,
    controlling what happens to the object when it is deleted. This method allows
    UE4 to track all references to an object so that on object destruction, all references
    to the object can be easily unlinked. This ensures that no dangling pointers with
    references to invalidated memory exist in the program. This process is usually
    called **garbage collection**.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instantiating `UObject`-derived classes that are not `AActor` class derivatives
    does not use `UWorld::SpawnActor< >`. Instead, we have to a special global function: `ConstructObject<
    >` or `NewObject< >`. Note that you should not use the bare C++ keyword `new`
    to allocate new instances of your UE4 `UObject` class derivatives.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need at least two pieces of information to properly instantiate your
    `UCLASS` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: A C++ typed `UClass` reference to the class type that you would like to instantiate
    (blueprint class)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The original C++ base class from which the blueprint class derives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a globally accessible object (such as your `GameMode` object), add a `TSubclassOf<
    YourC++ClassName > UPROPERTY()` to specify and supply the `UCLASS` name to your
    C++ code. To do this with the GameMode, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From Visual Studio, open up the `Chapter02_GameModeBase.h` file from the Solution
    Explorer. From there, update the script to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Save and compile your code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the UE4 editor, create a blueprint from this class. Double-click on it
    to enter the blueprints editor and then select your `UClass` name from the drop-down
    menu so that you can see what it does. Save and exit the editor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1fd16d87-b45d-4366-b178-bc8863d838b8.png)'
  prefs: []
  type: TYPE_IMG
- en: In your C++ code, find the section where you want to instantiate the `UCLASS`
    instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Instantiate the object using `ConstructObject< >` with the following formula:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, using the `UserProfile` object that we specified in the last recipe,
    we would get code such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You can see an example of this being used in the `Chapter_02GameModeBase.cpp`
    file in this book's example code.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instantiating a `UObject` class using `NewObject` is simple. `ConstructObject`
    will instantiate an object of the blueprint-class type, and return a C++ pointer
    of the correct type.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, `NewObject` has a nasty first parameter that requires you to
    pass `GetTransientPackage()` with each call.
  prefs: []
  type: TYPE_NORMAL
- en: Do not use the keyword `new` when constructing your UE4 `UObject` derivative!
    It will not be properly memory-managed.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on `NewObject` and other object creation functions, check
    out [https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/Objects/Creation](https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/Objects/Creation).[ ](https://docs.unrealengine.com/en-us/Programming/UnrealArchitecture/Objects/Creation)
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `NewObject` function is what the OOP world refers to as a factory, and is
    a common design pattern. You ask the factory to make you the object; you don't
    go about constructing it by yourself. Using a factory pattern enables the engine
    to easily track objects as they are created.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on design patterns, including the factory pattern, check
    out *Design Patterns: Elements of Reusable Object-Oriented Software *by Erich
    Gamma.'
  prefs: []
  type: TYPE_NORMAL
- en: If you are interested in learning more about design patterns for game development,
    you may wish to check out *Game Development Patterns and Best Practices*, also
    available from Packt Publishing.
  prefs: []
  type: TYPE_NORMAL
- en: Destroying UObject-derived classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Removing any `UObject` derivative is simple in UE4\. When you are ready to delete
    your `UObject`-derived class, we will simply call a single function (`ConditionalBeginDestroy()`)
    on it to begin teardown. We do not use the native C++ `delete` command on `UObject`
    derivatives. We will show this in the following recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To complete this recipe, you will need to have an object (`objectInstance`,
    in this case) that you wish to destroy in your project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Call `objectInstance->ConditionalBeginDestroy()` on your object instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Null all your references to `objectInstance` in your client code, and do not
    use `objectInstance` again after `ConditionalBeginDestroy()` has been called on
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ConditionalBeginDestroy()` function begins the destruction process by removing
    all internal engine linkages to it. This marks the object for destruction as far
    as the engine is concerned. The object is then destroyed some time later by destroying
    its internal properties, followed by actual destruction of the object.
  prefs: []
  type: TYPE_NORMAL
- en: After `ConditionalBeginDestroy()` has been called on an object, your (client)
    code must consider the object to be destroyed, and must no longer use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Actual memory recovery happens some time later than when `ConditionalBeginDestroy()`
    has been called on an object. There is a garbage collection routine that finishes
    clearing the memory of objects that are no longer referenced by the game program
    at fixed time intervals. The time interval between garbage collector calls is
    listed in `C:\Program Files (x86)\Epic Games\Launcher\Engine\Config\BaseEngine.ini`,
    and defaults to one collection every 61.1 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If the memory seems low after several `ConditionalBeginDestroy()` calls, you
    can trigger memory cleanup by calling `GetWorld()->ForceGarbageCollection(true)` to
    force an internal memory cleanup.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, you do not need to worry about garbage collection or the interval unless
    you urgently need memory cleared. Do not call garbage collection routines too
    often, as this may cause unnecessary lag in the game.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a USTRUCT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You may want to construct a blueprints editable property in UE4 that contains
    multiple members. The `FColoredTexture` struct that we will create in this recipe
    will allow you to group together a texture and its color inside the same structure
    for inclusion and specification in any other `UObject`-derivative, `Blueprintable`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/beee3b48-2091-4242-a170-46e6704965ce.png)'
  prefs: []
  type: TYPE_IMG
- en: The `FColoredTexture` structure does have the visual within the blueprints appearance,
    as shown in the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: This is for good organization and convenience of your other `UCLASS UPROPERTIES()`.
  prefs: []
  type: TYPE_NORMAL
- en: You may want to construct a C++ structure in your game using the `struct` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `UObject` is the base class of all UE4 class objects, while an `FStruct` is
    just any plain old C++ style struct. All objects that use the automatic memory
    management features within the engine must derive from this class.
  prefs: []
  type: TYPE_NORMAL
- en: If you may recall from the C++ language, the only difference between a C++ `class`
    and a C++ `struct` is that C++ classes have default `private` members, while structs
    default to `public` members.
  prefs: []
  type: TYPE_NORMAL
- en: In languages such as C#, this isn't the case. In C#, a struct is value-typed,
    while a class is reference-typed.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll create a structure called `FColoredTexture` in C++ code to contain a
    texture and a modulating color:'
  prefs: []
  type: TYPE_NORMAL
- en: From Visual Studio, right-click on the Games/Chapter_02/Source/Chapter_02 folder
    and select Add | New item.... From the menu, select a Header file (.h) and then
    name the file `ColoredTexture.h` (not `FColoredTexture`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under Location, make sure that you select the same folder as the other script
    files in the project (in my case, `C:\Users\admin\Documents\Unreal Projects\Chapter_02\Source\Chapter_02`)
    that is not the default:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/894cbb06-baf9-4618-bcde-1bd140907c72.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once created, use the following code in `ColoredTexture.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `ColoredTexture.h` as a `UPROPERTY()` in a blueprintable `UCLASS()`, using
    a `UPROPERTY()` declaration such as this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Save your script and compile your changes. Upon entering your object blueprint,
    you should notice the new properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5699f592-65aa-48d5-9511-2035977e0c6f.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `UPROPERTY()` specified for the `FColoredTexture` will show up in the editor
    as editable fields when included as `UPROPERTY()` fields inside another class,
    as shown in step 3.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main reason for making a struct, that is, a `USTRUCT()` instead of just
    a plain old C++ struct, is to interface with the UE4 Engine functionality. You
    can use plain C++ code (without creating `USTRUCT()` objects) for quick small
    structures that don't ask the engine to use them directly.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a UENUM( )
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ `enum` instances are very useful in typical C++ code. UE4 has a custom type
    of enumeration called `UENUM()`, which allows you to create an `enum` that will
    show up in a drop-down menu inside a blueprint that you are editing.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go to the header file that will use the `UENUM()` you are specifying, or create
    a
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: file called `EnumName.h`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Use your `UENUM()` in a `UCLASS()`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`UENUM()` shows up nicely in the code editor as a drop-down menu in the blueprints
    editor, from which you can only select one of a few values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ff0d78df-992a-47b1-bd70-9231db4839c7.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the values that were specified are there!
  prefs: []
  type: TYPE_NORMAL
