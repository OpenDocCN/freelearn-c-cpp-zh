- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inter-Integrated Circuit (I2C)
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn about the **Inter-Integrated Circuit** (**I2C**)
    communication protocol. We will begin by exploring the fundamental principles
    of the I2C protocol, covering its modes of operation, addressing methods, and
    the communication process. Then, we will examine the key registers of the I2C
    peripheral in STM32 microcontrollers and apply this knowledge to develop a bare-metal
    I2C driver.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: An overview of the I2C protocol
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The STM32 I2C peripheral
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing the I2C Driver
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a solid grasp of the I2C protocol
    and be equipped with the skills to develop bare-metal drivers for I2C.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming](https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: An overview of the I2C protocol
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I2C is another commonly used protocol. Let’s explore what it is, its key features,
    how it works, and its data format.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: What is I2C?
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I2C is a *multi-master*, multi-slave, packet-switched, single-ended, serial
    communication bus invented by Philips Semiconductor (now NXP Semiconductors).
    It’s designed for short-distance communication within a single device or between
    multiple devices on the same board. I2C is known for its simplicity and ease of
    use, making it a popular choice for communication between microcontrollers and
    other ICs. Let’s see its key features.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: The key features of I2C
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I2C has a number of unique features, which makes it ideal for various applications
    in embedded systems:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '**A two-wire interface**: I2C uses only two wires, **Serial Data** (**SDA**)
    and **Serial Clock** (**SCL**), which simplifies the wiring and reduces the number
    of pins required on the microcontroller.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multi-master and multi-slave**: Multiple master devices can initiate communication
    on the bus, and multiple slave devices can respond. This flexibility allows for
    complex communication setups. The I2C protocol supports up to 128 devices with
    7-bit addressing, although the practical limit is 119 due to reserved addresses.
    With 10-bit addressing, the protocol theoretically allows for 1,024 devices, but
    again, reserved addresses reduce the practical maximum slightly. The 10-bit mode,
    while less common, enables a higher number of devices on the same bus.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Addressable devices**: Each device on the I2C bus has a unique address, enabling
    the master to communicate with specific slaves.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Synchronous communication**: The SCL line provides the clock signal, ensuring
    that data is transferred synchronously between devices.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Speed variants**: I2C supports various speed modes, including standard mode
    (100 kHz), fast mode (400 kHz), fast mode plus (1 MHz), and high-speed mode (3.4
    MHz), catering to different speed requirements.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simple and low-cost**: The protocol’s simplicity and minimal hardware requirements
    make it cost-effective and easy to implement.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s look at the I2C interface.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: The I2C interface
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The I2C interface consists of two main lines:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '**Serial Data (SDA)**: This line carries the data being transferred between
    devices. It’s a bidirectional line, meaning that both the master and slave can
    send and receive data.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Serial Clock (SCL)**: This line carries the clock signal generated by the
    master device. It synchronizes the data transfer between the master and the slave.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 13.1: The I2C interface – multiple slaves](img/B21914_13_1.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.1: The I2C interface – multiple slaves'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: These two lines are connected to all devices on the bus, with pull-up resistors
    to ensure that the lines are pulled to a high state when idle. Let’s see how it
    works.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: How I2C works
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Understanding how I2C works involves looking at the **roles** of master and
    slave devices, the **addressing scheme**, and the **communication process**.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the roles and addressing scheme:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '**Master device**: The master device initiates communication and generates
    a clock signal. It controls the flow of data and can address multiple slaves.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Slave device**: The slave device responds to the master’s commands and performs
    the requested operations. Each slave has a unique **7-bit** or **10-bit address**
    that the master uses to identify it.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The communication process is as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '**A start condition**: Communication begins with the master generating a start
    condition. This involves pulling the SDA line low while the SCL line is high.'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Address frame**: The master sends the address of the target slave device,
    followed by a read/write bit indicating the operation type (0 for write and 1
    for read).'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Acknowledge (ACK) bit**: The addressed slave responds with an ACK bit by
    pulling the SDA line low during the next clock pulse.'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Data Frames**: Data is transferred in 8-bit frames. Each byte is followed
    by an ACK bit from the receiver.'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**A stop condition**: The master ends the communication by generating a stop
    condition, which involves pulling the SDA line high while the SCL line is high.'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.2: The I2C packet](img/B21914_13_2.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.2: The I2C packet'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Before we proceed to the next section, let’s take a moment to touch on the I2C
    data transfer, using an example.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin by revisiting the role of the data frame and the start condition:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '**Data frames**: Data is transferred in **8-bit bytes**. After each byte, the
    receiver sends an ACK bit to confirm successful reception.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Repeated start condition**: If the master needs to communicate with another
    slave or continue communication without releasing the bus, it can generate a **repeated
    start condition** instead of a stop condition.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s see the data transfer:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '**Write operation**: The master sends a **start condition**, the **address
    frame** with the **write bit**, and the **data frames**. Each data byte is followed
    by an ACK bit from the slave.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Read operation**: The master sends a start condition, the address frame with
    the **read bit**, and then reads the data frames from the slave. Each data byte
    is acknowledged by the master with an ACK bit, except for the last byte, which
    is followed by a **NACK** to indicate the end of the read operation.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a better understanding, let’s analyze *Figures 13.3* to *13.6*, starting
    with the start and stop conditions.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3: The start condition](img/B21914_13_3.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.3: The start condition'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the stop condition:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.4: The stop condition](img/B21914_13_4.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.4: The stop condition'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: The start condition occurs when the master device pulls the SDA line low while
    the SCL line remains high. This sequence signals all devices on the I2C bus that
    a communication session is about to begin, allowing the master to claim the bus
    for its intended operations. Without a valid start condition, the I²C communication
    cannot commence.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, the stop condition signals the end of communication. The master
    device releases the SDA line to a high state while the SCL line is high, indicating
    that the communication session is complete and the bus is now free for other devices.
    The proper use of stop conditions is essential for ensuring that no devices remain
    active on the bus, which could lead to conflicts or communication errors.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s see how the I2C protocol distinguishes between zeros and ones.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.5: The data transmission process](img/B21914_13_5.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.5: The data transmission process'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 13**.5* illustrates the data transmission process. Data is sent bit
    by bit, synchronized with the clock pulses on the SCL line. As shown, each bit
    of data is placed on the SDA line while the SCL line is low. When the SCL line
    transitions to high, the state of the SDA line is read by the receiving device.
    This particular figure shows the transmission of **1**, followed by a **0**.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let’s examine the complete packet and how it interacts with the SDA
    and SCL lines.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.6: The complete packet](img/B21914_13_6.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.6: The complete packet'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 13**.6* provides a comprehensive view of a complete I²C communication
    packet, showcasing the relationship between the SDA and SCL lines throughout the
    transaction. The communication begins with a start condition, where the SDA line
    is pulled low while the SCL line remains high, signaling the initiation of a new
    communication sequence.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Following the start condition, the address frame is transmitted. This frame
    contains the 7-bit address of the target device, followed by the **read/write**
    (**R/W**) bit that indicates whether the master intends to read from or write
    to the slave device. The address frame is then acknowledged by the slave device
    with an ACK bit, confirming that it is ready to proceed with the communication.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: After the address frame, the data frame is transmitted. The data is sent in
    8-bit bytes, with each bit being placed on the SDA line while the SCL line clocks
    each bit in sync. After each byte of data, the receiving device responds with
    another ACK bit, ensuring that the data was received correctly.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: The communication concludes with a stop condition, where the SDA line is released
    to go high while the SCL line is also high. This signals the end of the communication
    session, freeing the bus for other potential communications. This complete cycle,
    from start to stop, forms the backbone of data exchange in the I²C protocol, ensuring
    structured and reliable communication between devices.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our overview of the I2C protocol. In the next section, we shall
    analyze the I2C peripheral in the STM32F4 microcontroller.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: The STM32F4 I2C peripherals
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Depending on the specific model of STM32F4 you are working with, you can typically
    find up to three I2C peripherals labeled I2C1, I2C2, and I2C3\. These peripherals
    enable the microcontroller to communicate with I2C-compatible devices using the
    standard two-wire interface.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'The I2C peripherals in STM32F4 microcontrollers come packed with features that
    enhance their versatility and performance:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '**Multi-master and multi-slave capabilities**: Each I2C peripheral can operate
    as both master and slave, supporting multiple master configurations where more
    than one master device can control the bus'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Standard, fast, and fast mode plus**: The peripherals support multiple speed
    modes, including **standard mode** (100 kHz), **fast mode** (400 kHz), and **fast
    mode plus** (1 MHz), allowing for flexibility in communication speed'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**10-bit addressing**: In addition to standard **7-bit addressing**, the I2C
    peripherals also support **10-bit addressing**, enabling communication with a
    broader range of devices'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dual addressing mode**: Each I2C peripheral can be configured to respond
    to two different addresses, useful for complex multi-device setups'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DMA support**: **Direct Memory Access** (**DMA**) support is available, enabling
    efficient data transfer without CPU intervention'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s examine the key registers of this peripheral.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: The key I2C registers
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Configuring the I2C peripheral on an STM32 microcontroller involves several
    key registers that control various aspects of its operation.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Each register has specific bits that need to be set correctly to ensure proper
    functionality. Let’s break down the main registers we’ll be working with, starting
    with **Control** **Register 1**.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: I2C Control Register 1 (I2C_CR1)
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`I2C_CR1` is one of the primary control registers used to configure the I2C
    peripheral’s basic operational settings. It provides options to **enable the peripheral**,
    manage the start and stop conditions, and control the acknowledge feature.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'The key bits in this register include the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '**Peripheral enable (PE)**: This bit enables or disables the I2C peripheral.
    Setting this bit to 1 turns on the I2C peripheral, while clearing it turns it
    off.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`START` condition, initiating communication.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`STOP` condition, terminating communication.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Acknowledge enable (ACK)**: When set, this bit enables the ACK after each
    byte received.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Acknowledge/PEC position (POS)**: This bit controls the position of the ACK
    bit.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Software reset (SWRST)**: Setting this bit resets the I2C peripheral.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find detailed information about this register on *page 492* of the STM32F4
    reference manual (RM0383). Next, let’s look at I2C **Control** **Register 2**.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: I2C Control Register 2 (I2C_CR2)
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`I2C_CR2` is another crucial control register that handles different aspects
    of I2C operation, including **clock frequency**, **interrupt** enable, and **DMA**
    control. Key bits in this register include the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '**FREQ[5:0] (peripheral clock frequency)**: These bits set the I2C peripheral
    clock frequency in MHz'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DMAEN (DMA requests enable)**: When set, this bit enables the DMA requests
    for the I2C peripheral'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find detailed information about this register on *page 494* of the STM32F4
    reference manual (RM0383). Next, let’s look at the I2C **Clock** **Control Register**.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: I2C Clock Control Register (I2C_CCR)
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`I2C_CCR` configures the clock control settings for standard, fast, and fast
    mode plus operations. Key bits in this register include the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '**CCR[11:0] (clock control)**: These bits set the clock control value, determining
    the I2C clock speed'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DUTY (fast mode duty cycle)**: This bit selects the duty cycle for fast mode'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**F/S (I2C master mode selection)**: This bit selects between standard mode
    (0) and fast mode (1)'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find detailed information about this register on *page 502* of the STM32F4
    reference manual (RM0383). The next register is the I2C Rise Time Register.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: I2C TRISE register (I2C_TRISE)
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`I2C_TRISE` configures the maximum rise time for the I2C signals, ensuring
    compliance with I2C specifications. This register has only one field – **TRISE[5:0]
    (maximum rise time)**. These bits set the maximum rise time for the SDA and SCL
    signals in nanoseconds.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: The final register is the I2C **Data Register**.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: I2C Data Register (I2C_DR)
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`I2C_DR` is the data register used for both **transmitting** and **receiving**
    data. Data written to this register is transmitted, and data received from the
    bus is stored in this register. This register has only one field – **DR[7:0] (8-bit
    data register)**: This register holds the 8-bit data to be transmitted or the
    data received from the bus.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: With these registers in mind, we’re now ready to develop the I2C driver. Let’s
    do that in the next section.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Developing the I2C driver
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s develop the I2C driver. Create a copy of your previous project in your
    IDE and rename this copied project `I2C`. Next, create a new file named `i2c.c`
    in the `Src` folder and another file named `i2c.h` in the `Inc` folder.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: The initialization function
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s populate the `i2c.c` file, starting with the macros and initialization
    function:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s break down what we have so far:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This line enables the clock for GPIOB by setting the corresponding bit.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These lines configure `PB8` and `PB9` pins to an alternate function mode for
    I2C.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: These lines configure the pins as **open-drain**, which is required for I2C
    communication.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: These lines enable **pull-up resistors** for the I2C pins.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: These lines configure the `I2C1`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This line enables the clock for the I2C1 peripheral.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: These lines **reset** the I2C1 peripheral.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This configures the I2C1 clock.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This line sets the clock control register for 100 kHz standard mode, using the
    macro we defined.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This line sets the rise time for the I2C signals using the macro we defined.
    The TRISE register specifies the maximum time the signal is allowed to take to
    transition from a low to a high state on the I2C bus. Setting this value correctly
    is important to ensure that the I2C communication adheres to the timing requirements
    of the I2C standard, which helps maintain reliable and stable communication.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This line enables the I2C1 peripheral by setting the PE bit. Next, we will add
    and analyze the function to read a byte from an I2C slave device.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: The read function
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s analyze the `read` function:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let’s break down what we have so far:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '`while (I2C1->SR2 & (SR2_BUSY)){}`: This line waits for the I2C bus to be free
    by checking the state of the `BUSY` bit in I2C Status Register 2.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`I2C1->CR1 |= CR1_START;`: This line initiates a start condition on the I2C
    bus.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`while (!(I2C1->SR1 & (SR1_SB))){}`: This line waits until the start condition
    is acknowledged by checking the `SB` bit in I2C Status Register 1.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`I2C1->DR = saddr << 1;`: This line sends the slave address with the write
    bit. The 7-bit address of the device is left-shifted by 1 bit to make room for
    the R/W bit in the `saddr` left by 1, we prepare the address for a subsequent
    write operation to the slave device.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`while (!(I2C1->SR1 & (SR1_ADDR))){}`: This line waits until the address is
    acknowledged by checking the `ADDR` bit in I2C Status Register 1.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tmp = I2C1->SR2;`: This line clears the address flag by simply reading I2C
    Status Register 2.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2C1->DR = maddr;`: Here, we send the memory address to read from the slave
    device.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`while (!(I2C1->SR1 & SR1_TXE)){}`: This line waits until the data register
    is empty by reading the transmit buffer empty (`TXE`) bit in I2C Status Register
    1.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`I2C1->CR1 |= CR1_START;`: This line initiates a **restart condition** on the
    I2C bus.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`while (!(I2C1->SR1 & SR1_SB)){}`: Here, we wait until the restart condition
    is acknowledged by checking the `SB` bit in I2C Status Register 1.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`I2C1->DR = saddr << 1 | 1;`: This line prepares the I2C data register for
    a read operation by setting up the 7-bit I2C address of the slave device and appending
    the R/W bit. Specifically, `saddr << 1` shifts the 7-bit address left by one bit
    to make room for the LSB, which is then set to 1 using the bitwise `OR` operator
    (| 1). This final value, with the LSB set to 1, indicates a read operation when
    loaded into the I2C1 **data register** (**DR**). Hence, this line configures the
    I2C peripheral to initiate communication with the slave device, requesting to
    read data from it.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`while (!(I2C1->SR1 & (SR1_ADDR))){}`: This line waits until the address is
    acknowledged.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`I2C1->CR1 &= ~CR1_ACK;`: This line disables the acknowledge bit to prepare
    for a stop condition.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tmp = I2C1->SR2;`: This line clears the address flag by reading I2C Status
    Register 2.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`I2C1->CR1 |= CR1_STOP;`: This initiates a stop condition on the I2C bus.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`while (!(I2C1->SR1 & SR1_RXNE)){}`: This line waits until the receive buffer
    is not empty by reading the `RXNE`) flag in I2C Status Register 1\. This flag
    indicates that new data has been received and is available in the data register.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*data++ = I2C1->DR;`: This line is responsible for storing the received byte
    of data from the I2C DR in the memory location pointed to by the `data` pointer.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we have a function to read multiple bytes from the slave device:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This function reads multiple bytes of data from a specified memory address
    in the I2C slave device. Here’s a breakdown of what it does:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '**Waits for bus availability**: The function starts by ensuring that the I2C
    bus is not busy, waiting until it is free to initiate communication.'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Generates a start condition**: It generates a start condition to begin communication
    with the slave device.'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Transmits a slave address for write**: The function sends the slave device
    address with a write bit, indicating that it will initially write data to specify
    the memory address.'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Waits for the address flag and clears it**: It waits for the address flag
    to be set and then clears it by reading the SR2 register.'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Transmits the memory address**: The memory address from which to start reading
    is sent to the slave device.'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Generates a restart condition**: A repeated start condition is generated
    to switch the communication mode from write to read.'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Transmits a slave address for read**: The function sends the slave address
    with a read bit, indicating that it will read data from the slave device.'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Waits for the address flag and clears it**: Again, it waits for the address
    flag to be set and clears it by reading the SR2 register.'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Enables acknowledge**: The acknowledge bit is set.'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`RXNE` flag to indicate that data is ready, reads the data into the buffer,
    and decrements the byte counter'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we add the function to write data to the slave device.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: The write function
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s break down the function to write multiple bytes to the slave device:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This function writes **multiple bytes** of data to a specific memory address
    in the I2C slave device. The function begins by waiting for the I2C bus to be
    free, ensuring that there is no ongoing communication. It then generates a start
    condition to initiate communication with the slave device. The slave address is
    transmitted with a write bit, and then the function waits for the address flag
    to be set and cleared by reading the SR2 register. After ensuring the data register
    is empty, it sends the memory address where the data writing should begin. The
    function enters a loop to transmit each byte of data, waiting for the data register
    to empty before each byte is sent. Once all bytes have been transmitted, it waits
    for the byte transfer to finish and then generates a stop condition to end the
    communication.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Our next task is to populate the `i2c.h` file.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: The header file
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here is the code for the header file:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Let’s update our driver for the adxl345 device to use the I2C driver we developed.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: The ADXL345 I2C driver
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Update the current `adxl345.c` in the `Src` folder:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here is a breakdown of the code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: The `adxl_read_address` function reads a single byte of data from a specified
    register in the ADXL345 accelerometer. It uses the `i2c1_byte_read` function to
    communicate over the I2C bus, fetching the data from the register identified by
    the `reg` parameter and storing it in the `data` variable.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `adxl_write` function writes a single byte of data to a specific register
    in the ADXL345\. It prepares a single-element array, containing the value to be
    written, and then uses `i2c1_burst_write` to send this data to the register specified
    by the `reg` parameter, over the I2C interface.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `adxl_read_values` function reads a block of data from the ADXL345 – specifically,
    `i2c1_burst_read` to pull this data, starting from the register specified by the
    `reg` parameter, and stores it in `data_buffer` for further processing.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `adxl_init` function initializes the ADXL345 accelerometer. It first enables
    I2C communication by calling `i2c1_init`, and then it checks the device’s identity
    by reading the `DEVID` register. Following this, it configures the data format
    to a range of `±4g`, resets the power control register, and finally, sets the
    power control register to start measuring acceleration.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we update the current `adxl345.h` in the `Inc` folder:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '#include <stdio.h>'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '#include <stdint.h>'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '#include "stm32f4xx.h"'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '#include "uart.h"'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '#include "adxl345.h"'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: //Variables for storing accelerometer data
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: int16_t accel_x, accel_y, accel_z;
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: double accel_x_g, accel_y_g, accel_z_g;
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: extern uint8_t data_buffer[6];
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: int main(void)
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: uart_init();
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: // Initialize the ADXL345 accelerometer
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: adxl_init();
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: while (1)
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: // Read accelerometer data starting from the data start
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: // register
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: adxl_read_values(ADXL345_REG_DATA_START);
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: // Combine high and low bytes to form the accelerometer data
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: accel_x = (int16_t)((data_buffer[1] << 8) | data_buffer[0]);
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: accel_x = (int16_t)((data_buffer[1] << 8) | data_buffer[0]);
- en: accel_y = (int16_t)((data_buffer[3] << 8) | data_buffer[2]);
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: accel_y = (int16_t)((data_buffer[3] << 8) | data_buffer[2]);
- en: accel_z = (int16_t)((data_buffer[5] << 8) | data_buffer[4]);
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: accel_z = (int16_t)((data_buffer[5] << 8) | data_buffer[4]);
- en: // Convert raw data to g values
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: // 将原始数据转换为g值
- en: accel_x_g = accel_x * 0.0078;
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: accel_x_g = accel_x * 0.0078;
- en: accel_y_g = accel_y * 0.0078;
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: accel_y_g = accel_y * 0.0078;
- en: accel_z_g = accel_z * 0.0078;
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: accel_z_g = accel_z * 0.0078;
- en: 'printf("accel_x : %d accel_y : %d  accel_z : %d\n\'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 'printf("accel_x : %d accel_y : %d  accel_z : %d\n\'
- en: r",accel_x,accel_y,accel_z);
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: r",accel_x,accel_y,accel_z);
- en: '}'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return 0;
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: return 0;
- en: '}'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE18]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
