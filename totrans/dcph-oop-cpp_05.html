<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer032">
<h1 class="chapter-number" id="_idParaDest-99"><a id="_idTextAnchor222"/>5</h1>
<h1 id="_idParaDest-100"><a id="_idTextAnchor223"/>Exploring Classes in Detail</h1>
<p>This chapter will begin our<a id="_idIndexMarker298"/> pursuit of <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>) in C++. We will begin by introducing <strong class="bold">object-oriented</strong> (<strong class="bold">OO</strong>) concepts<a id="_idIndexMarker299"/> and then progress to understanding how these concepts can be implemented in C++. Many times, implementing OOP ideas will be through <em class="italic">direct language support</em>, such as the features in this chapter. Sometimes, however, we will utilize various programming techniques to implement object-oriented concepts. These techniques will be seen in later chapters. In all cases, it is important to understand the object-oriented concepts and how these concepts relate to well-thought-out designs, and then have a clear understanding of how to implement these designs with robust code. </p>
<p>This chapter will detail C++ class usage in extreme detail. Subtle features and nuances are detailed beyond the basics. The goal of this chapter will be to allow you to understand OO concepts, and for you to begin to think in terms of object-oriented programming. Embracing core OO ideals, such as encapsulation and information hiding, will allow you to write code that is easier to maintain, and will allow you to modify others’ code more easily.</p>
<p>In this chapter, we will cover the following main topics:</p>
<ul>
<li>Defining object-oriented terminology and concepts – object, class, instance, encapsulation and information hiding</li>
<li>Applying class and member function basics</li>
<li>Examining member function internals; the <strong class="source-inline">this</strong> pointer</li>
<li>Using access labels and access regions</li>
<li>Understanding constructors – default, overloaded, copy, conversion constructors, and in-class initializers</li>
<li>Understanding destructors and their proper usage</li>
<li>Applying qualifiers to data members and member functions – <strong class="source-inline">inline</strong>, <strong class="source-inline">const</strong>, and <strong class="source-inline">static</strong></li>
</ul>
<p>By the end of this chapter, you will understand core object-oriented terminology applicable to classes, and how key OO ideas such as encapsulation and information hiding will lead to software that is easier to maintain.</p>
<p>You will also appreciate how C++ provides built-in language features to support object-oriented programming. You will become well versed in the use of member functions and will understand their underlying implementation through the <strong class="source-inline">this</strong> pointer. You will understand how to correctly use access labels and access regions to promote encapsulation and information hiding. </p>
<p>You will understand how constructors can be used to initialize objects, and the many varieties of constructors from basic to typical (overloaded) to the copy constructor, and even conversion constructors. Similarly, you will understand how to make proper use of the destructor prior to an object’s end of existence. </p>
<p>You will also understand how qualifiers, such as <strong class="source-inline">const</strong>, <strong class="source-inline">static</strong>, and <strong class="source-inline">inline</strong>, may be applied to member functions to support either object-oriented concepts or efficiency. Likewise, you will understand how to apply qualifiers, such as <strong class="source-inline">const</strong> and <strong class="source-inline">static</strong>, to data members to additionally support OO ideals.</p>
<p>C++ can be used as an object-oriented programming language, but it is not automatic. To do so, you must understand OO concepts, ideology, and language features that will allow you to support this endeavor. Let us begin our pursuit of writing code that is easier to modify and maintain by understanding the core and essential building block found in object-oriented C++ programs, the C++ class.</p>
<h1 id="_idParaDest-101"><a id="_idTextAnchor224"/>Technical requirements</h1>
<p>Online code for full program examples can be found in the following GitHub URL: <a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter05">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter05</a>. Each full program example can be found in the GitHub under the appropriate chapter heading (subdirectory) in a file that corresponds to the chapter number, followed by a dash, followed by the example number in the chapter at hand. For example, the first full program in this chapter can be found in the subdirectory <strong class="source-inline">Chapter05</strong> in a file named <strong class="source-inline">Chp5-Ex1.cpp</strong> under the aforementioned GitHub directory.</p>
<p>The CiA video for this chapter can be viewed at: <a href="https://bit.ly/3KaiQ39">https://bit.ly/3KaiQ39</a><a id="_idTextAnchor225"/><a id="_idTextAnchor226"/>.</p>
<h1 id="_idParaDest-102"><a id="_idTextAnchor227"/>Introducing object-oriented terminology and concepts</h1>
<p>In this section, we will introduce core object-oriented concepts as well as applicable terminology that will accompany these key ideas. Though new terms will come up throughout this chapter, we will begin with essential terms necessary to begin our journey in this section.</p>
<p>Let’s get started with basic object-oriented terminology.</p>
<h2 id="_idParaDest-103"><a id="_idTextAnchor228"/>Understanding object-oriented terminology</h2>
<p>We will <a id="_idIndexMarker300"/>begin with basic object-oriented terminology, and then as we introduce new concepts, we will extend the terminology to include C++ specific terminology. </p>
<p>The terms object, class, and instance are all important and related terms with which we can start our definitions. An <strong class="bold">object</strong> embodies <a id="_idIndexMarker301"/>a meaningful grouping of characteristics and behaviors. An object can be manipulated and can receive the action or consequences of a behavior. Objects may undergo transformations and can change repeatedly over time. Objects can interact with other object<a id="_idTextAnchor229"/>s. </p>
<p>The term object, at times, may be used to describe the blueprint for groupings of like items. The term <strong class="bold">class</strong> may <a id="_idIndexMarker302"/>be used interchangeably with this usage of an object. The term object may also (and more often) be used to describe a specific ite<a id="_idTextAnchor230"/>m in such a grouping. The <a id="_idIndexMarker303"/>term <strong class="bold">instance</strong> may be used interchangeably with this meaning of an object. The context of usage will often make clear which meaning of the term <em class="italic">object</em> is being applied. To avoid potential confusion, the terms <em class="italic">class</em> and <em class="italic">instance</em> can preferably be u<a id="_idTextAnchor231"/>sed.<em class="italic"> </em></p>
<p>Let’s consider some examples, using the aforementioned terms:</p>
<div>
<div class="IMG---Figure" id="_idContainer029">
<img alt="" height="262" src="image/Table_5.1_B19087.jpg" width="1131"/>
</div>
</div>
<p>Objects also have components. The characteristics of a class are referred to as <strong class="bold">attributes</strong>. Behaviors <a id="_idIndexMarker304"/>of a class are referred to<a id="_idIndexMarker305"/> as <strong class="bold">operations</strong>. The specific implementation of a behavior or operation is referred to<a id="_idIndexMarker306"/> as its <strong class="bold">method</strong>. In other words, the method is how an operation is implemented, or the body of code defining the function, whereas the operation is the function’s prototype or protocol for usage.</p>
<p>Let’s consider some high-level examples, using the aforementioned te<a id="_idTextAnchor232"/><a id="_idTextAnchor233"/>rms:</p>
<div>
<div class="IMG---Figure" id="_idContainer030">
<img alt="" height="323" src="image/Table_5.2_B19087.jpg" width="1565"/>
</div>
</div>
<p>Each instance of a <a id="_idIndexMarker307"/>class will most likely have distinct values for its attributes. For example:</p>
<div>
<div class="IMG---Figure" id="_idContainer031">
<img alt="" height="259" src="image/Table_5.3_B19087.jpg" width="1432"/>
</div>
</div>
<p>Now that we have the basic OO terms under our belt, let’s move on to important object-oriented concepts that are relevant to this chapter.</p>
<h2 id="_idParaDest-104">Understanding object-oriented co<a id="_idTextAnchor234"/>ncepts</h2>
<p>The key<a id="_idIndexMarker308"/> object-oriented concepts relating to this chapter are <em class="italic">encapsulation</em> and <em class="italic">information hiding</em>. Incorporating these interrelated ideals into your design will provide the basis for writing more easily modifiable and maintainable programs. </p>
<p>The grouping of meaningful characteristics (attributes) and behaviors (operations) that operate on those attributes, bundled<a id="_idIndexMarker309"/> together in a single unit, is known as <strong class="bold">encapsulation</strong>. In C++, we typically group these items together in a class. The interface to each class instance is made through operations that model the behaviors relevant to each class. These operations may additionally modify the internal state of the object by changing the values of its attributes. Concealing attributes within a class and providing an interface for operating on those details leads us to explore the supportive concept of information hiding.</p>
<p><strong class="bold">Information hiding</strong> refers to the <a id="_idIndexMarker310"/>process of <em class="italic">abstracting</em> the details of performing an operation into a class method. That is, the user needs only to understand which operation to utilize and its overall purpose; the implementation details are hidden within the method (function<a id="_idTextAnchor235"/>’s body). In this fashion, changing the underlying implementation (method) will not change the operation’s interface. Information hiding can additionally refer to keeping the underlying implementation of a class’ attributes hidden. We will explore this further when we introduce access regions. Information hiding is a means to achieve proper encapsulation of a class. A properly encapsulated class will enable proper class abstraction and thus the support of OO designs.</p>
<p>Object-oriented<a id="_idIndexMarker311"/> systems are inherently more easily maintained because classes allow upgrades and modifications to be made quickly and without impact to the entire system due to encapsulation and information hiding.</p>
<h1 id="_idParaDest-105"><a id="_idTextAnchor236"/>Understanding class and member function basics</h1>
<p>A C++ <strong class="bold">class</strong> is a<a id="_idIndexMarker312"/> fundamental<a id="_idIndexMarker313"/> building block in C++ that allows a programmer to specify a user defined type, encapsulating related data and behaviors. A C++ class definition will contain attributes, operations, and sometimes methods. C++ classes support encapsulation.</p>
<p>Creating a variable of a class type is known<a id="_idIndexMarker314"/> as <strong class="bold">instantiation</strong>. The attributes in a class are<a id="_idIndexMarker315"/> known as <strong class="bold">data members</strong> in C++. Operations in a class are known as <strong class="bold">member functions</strong> in C++ and are used to model behaviors. In OO terms, an operation implies the signature of a function, or its prototype (declaration), and the method implies its underlying implementation or the body of the function (definition). In some OO languages, the term <em class="italic">method</em> is used more loosely to imply either the operation or its method, based on the context of usage. In C++, the terms <em class="italic">data member</em> and <em class="italic">member function</em> are most often used. </p>
<p>The prototype for a member function must be placed in a class definition. Most often, the member function definition is placed outside of the class definition. The scope resolution operator <strong class="source-inline">::</strong> is then used to associate a given member function definition to the class in which it is a member. Dot <strong class="source-inline">.</strong> or arrow <strong class="source-inline">-&gt;</strong> notation is used to access all class members, including member functions, depending on whether we are accessing members through an instance or through a pointer to an instance.</p>
<p>C++ structures may also be used to encapsulate data and their related behaviors. A C++ <strong class="source-inline">struct</strong> can do anything a C++ <strong class="source-inline">class</strong> can do; in fact, <strong class="source-inline">class</strong> is implemented in terms of <strong class="source-inline">struct</strong> in C++. Though structures and classes may behave identically (other than default visibility), classes are more often used to model objects, relationships between object types, and implement object-oriented systems. </p>
<p>Let’s take a look at a simple example in which we instantiate a <strong class="source-inline">class</strong> and a <strong class="source-inline">struct</strong>, each with<a id="_idIndexMarker316"/> member<a id="_idIndexMarker317"/> functions, for comparison with one another. We will break this example into several segments. The full program example can be found in the GitHub repository:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex1.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex1.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
using std::cout;    // preferred to: using namespace std;
using std::endl;
using std::string;
struct student
{ 
    string name;
    float gpa;
    <strong class="bold">void Initialize(string, float);</strong>  // fn. prototype
    <strong class="bold">void Print();</strong>
};
class University
{
public:
    string name;
    int numStudents;
    <strong class="bold">void Initialize(string, int);</strong>   // fn. prototype
    <strong class="bold">void Print();</strong>
};</pre>
<p>In the preceding example, we first define a <strong class="source-inline">student</strong> type using a <strong class="source-inline">struct</strong>, and a <strong class="source-inline">University</strong> type using a <strong class="source-inline">class</strong>. Notice, by convention, that user defined types created using structures are not capitalized, yet user defined types created using classes begin with a capital letter. Also notice that the <strong class="source-inline">class</strong> definition requires the label <strong class="source-inline">public:</strong> toward <a id="_idIndexMarker318"/>the <a id="_idIndexMarker319"/>beginning of its definition. We will explore the use of this label later in this chapter; however, for now, the <strong class="source-inline">public</strong> label is present so that this <strong class="source-inline">class</strong> will have the same default visibility of its members as does the <strong class="source-inline">struct</strong>.</p>
<p>In both the <strong class="source-inline">class</strong> and <strong class="source-inline">struct</strong> definitions, notice the function prototypes for <strong class="source-inline">Initialize()</strong> and <strong class="source-inline">Print()</strong>. We will tie these prototypes to member function definitions in the next program segment using <strong class="source-inline">::</strong>, the scope resolution operator. </p>
<p>Let’s examine the various member function definitions:</p>
<pre class="source-code">
<strong class="bold">void student::Initialize(string n, float avg)</strong>
{ 
    name = n;    // simple assignment
    gpa = avg;   // we'll see preferred init. shortly
}
<strong class="bold">void student::Print()</strong>
{ 
    cout &lt;&lt; name &lt;&lt; " GPA: " &lt;&lt; gpa &lt;&lt; endl;
}
<strong class="bold">void University::Initialize(string n, int num)</strong>
{ 
    name = n;           // simple assignment; we will see
    numStudents = num;  // preferred initialization shortly
} 
<strong class="bold">void University::Print()</strong>
{ 
    cout &lt;&lt; name &lt;&lt; " Enrollment: " &lt;&lt; numStudents &lt;&lt; endl;
}</pre>
<p>Now, let’s <a id="_idIndexMarker320"/>review<a id="_idIndexMarker321"/> the various member function definitions for each user defined type. The definitions for <strong class="source-inline">void student::Initialize(string, float)</strong>, <strong class="source-inline">void student::Print()</strong>, <strong class="source-inline">void University::Initialize(string, int)</strong>, and <strong class="source-inline">void University::Print()</strong> appear consecutively in the preceding fragment. Notice how the scope resolution operator <strong class="source-inline">::</strong> allows us to tie the relevant function definition back to the <strong class="source-inline">class</strong> or <strong class="source-inline">struct</strong> in which it is a member. </p>
<p>Additionally, notice that in each <strong class="source-inline">Initialize()</strong> member function, the input parameters are used as values to load the relevant data members for a specific instance of a specific class or struct type. For example, in the function definition of <strong class="source-inline">void University::Initialize(string n, int num)</strong>, the input parameter <strong class="source-inline">num</strong> is used to initialize <strong class="source-inline">numStudents</strong> for a particular <strong class="source-inline">University</strong> instance.</p>
<p class="callout-heading">Note</p>
<p class="callout">The scope resolution operator <strong class="source-inline">::</strong> associates member function definitions with the class (or struct) in which they are a member.</p>
<p>Let’s see how member functions are called by considering <strong class="source-inline">main()</strong> in this example:</p>
<pre class="source-code">
int main()
{ 
    student s1;  // instantiate a student (struct instance)
    <strong class="bold">s1.Initialize("Gabby Doone", 4.0);</strong>
    <strong class="bold">s1.Print();</strong>
    University u1;  // instantiate a University (class)
    <strong class="bold">u1.Initialize("GWU", 25600);</strong>
    <strong class="bold">u1.Print();</strong>
    University *u2;         // pointer declaration
    u2 = new University();  // instantiation with new()
    <strong class="bold">u2-&gt;Initialize("UMD", 40500);</strong>  
    <strong class="bold">u2-&gt;Print();</strong>  // or alternatively: (*u2).Print();
    delete u2;  
    return 0;
}</pre>
<p>Here, in <strong class="source-inline">main()</strong>, we <a id="_idIndexMarker322"/>simply <a id="_idIndexMarker323"/>define a variable, <strong class="source-inline">s1</strong>, of type <strong class="source-inline">student</strong>, and a variable, <strong class="source-inline">u1</strong>, of type <strong class="source-inline">University</strong>. In object-oriented terms, it is preferable to say that <strong class="source-inline">s1</strong> is an instance of <strong class="source-inline">student</strong>, and <strong class="source-inline">u1</strong> is an instance of <strong class="source-inline">University</strong>. The instantiation occurs when the memory for an object is made available. For this reason, declaring pointer variable <strong class="source-inline">u2</strong> using: <strong class="source-inline">University *u2;</strong> does not instantiate a <strong class="source-inline">University</strong>; it merely declares a pointer to a possible future instance. Rather, on the following line, <strong class="source-inline">u2 = new University();</strong>, we instantiate a <strong class="source-inline">University</strong> when the memory is allocated.</p>
<p>For each of the instances, we initialize their data members by calling their respective <strong class="source-inline">Initialize()</strong> member functions, such as <strong class="source-inline">s1.Initialize("Gabby Doone", 4.0);</strong> or <strong class="source-inline">u1.Initialize("UMD", 4500);</strong>. We then call <strong class="source-inline">Print()</strong> through each respective instance, such as <strong class="source-inline">u2-&gt;Print();</strong>. Recall that <strong class="source-inline">u2-&gt;Print();</strong> may also be written as <strong class="source-inline">(*u2).Print();</strong>, which more easily allows us to remember that the instance here is <strong class="source-inline">*u2</strong>, whereas <strong class="source-inline">u2</strong> is a pointer to that instance.</p>
<p>Notice that when we call <strong class="source-inline">Initialize()</strong> through <strong class="source-inline">s1</strong>, we call <strong class="source-inline">student::Initialize()</strong> because <strong class="source-inline">s1</strong> is of type <strong class="source-inline">student</strong>, and we initialize <strong class="source-inline">s1</strong>’s data members in the body of this function. Similarly, when we call <strong class="source-inline">Print()</strong> through <strong class="source-inline">u1</strong> or <strong class="source-inline">*u2</strong>, we call <strong class="source-inline">University::Print()</strong> because <strong class="source-inline">u1</strong> and <strong class="source-inline">*u2</strong> are of type <strong class="source-inline">University</strong> and<a id="_idIndexMarker324"/> we<a id="_idIndexMarker325"/> subsequently print out a particular university’s data members.</p>
<p>Since instance <strong class="source-inline">u1</strong> was dynamically allocated on the heap, we are responsible for releasing its memory using <strong class="source-inline">delete()</strong> toward the end of <strong class="source-inline">main()</strong>.</p>
<p>The output to accompany thi<a id="_idTextAnchor237"/>s program is as follows:</p>
<p class="source-code">Gabby Doone GPA: 4.4</p>
<p class="source-code">GWU Enrollment: 25600</p>
<p class="source-code">UMD Enrollment: 40500</p>
<p>Now that we are creating class definitions with their associated member function definitions, it is important to know how developers typically organize their code in files. Most often, a class will be broken into a header (<strong class="source-inline">.h</strong>) file, which will contain the class definition, and a source code (<strong class="source-inline">.cpp</strong>) file, which will <strong class="source-inline">#include</strong> the header file, and then follow with the member function definitions themselves. For example, a class named <strong class="source-inline">University</strong> would have a <strong class="source-inline">University.h</strong> header file and a <strong class="source-inline">University.cpp</strong> source code file.</p>
<p>Now, let’s move forward with our understanding of the details of how member functions work by exa<a id="_idTextAnchor238"/><a id="_idTextAnchor239"/>mining the <strong class="source-inline">this</strong> pointer.</p>
<h1 id="_idParaDest-106"><a id="_idTextAnchor240"/>Examining member function internals; the “this” pointer</h1>
<p>So far, we have <a id="_idIndexMarker326"/>noticed <a id="_idIndexMarker327"/>that member functions are invoked through objects. We have noticed that in the scope of a member function, it is the data members (and other member functions) of the particular object that invoked the function that may be utilized (in addition to any input parameters). Alas, how, and why does this work?</p>
<p>It turns out that most often, member functions are invoked through objects. Whenever a member function is invoked in this fashion, that member function receives a pointer to the instance that invoked the function. A pointer to the object calling the function is then passed as an implicit first argument to the function. The name of this pointer is <strong class="bold">this</strong>.</p>
<p>Though the <strong class="source-inline">this</strong> pointer may be referred to explicitly in the definition of each such member function, it usually is not. Even without its explicit use, the data members utilized in the scope of the function belong to <strong class="source-inline">this</strong>, a pointer to the object that invoked the function.</p>
<p>Let us take a look at a full program example. Though the example is broken into segments, the full program can be found in the<a id="_idTextAnchor241"/> following GitHub location:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex2.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex2.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;cstring&gt; // though we'll prefer std::string, one
                   // pointer data member will illustrate 
                   // important concepts
using std::cout;   // preferred to: using namespace std;
using std::endl;
using std::string;
class Student
{
// for now, let's put everything p<a id="_idTextAnchor242"/>ublic access region
public:  
    string firstName;  // data members
    string lastName;
    char middleInitial;
    float gpa;
    char *currentCourse;  // ptr to illustrate key concepts 
    // member function prototypes
    void Initialize(string, string, char, float,
                    const char *);
    void Print();
};</pre>
<p>In the first segment of the program, we define class <strong class="source-inline">Student</strong> with a variety of data members, and <a id="_idIndexMarker328"/>two <a id="_idIndexMarker329"/>member function prototypes. For now, we will place everything in the <strong class="source-inline">public</strong> access region.</p>
<p>Now, let’s examine the member function definitions for <strong class="source-inline">void Student::Initialize()</strong> and <strong class="source-inline">void Student::Print()</strong>. We will also examine how each of these functions looks internally to C++:</p>
<pre class="source-code">
// Member function definition
void Student::Initialize(string fn, string ln, char mi,
                         float gpa, const char *course)
{
    firstName = fn;
    lastName = ln;  
    <strong class="bold">this</strong>-&gt;middleInitial = <a id="_idTextAnchor243"/>mi;  <strong class="bold">// optional use of 'this</strong>'
    <strong class="bold">this</strong>-&gt;gpa = gpa;  <strong class="bold">// required, explicit use of </strong>'<strong class="bold">this</strong>'
    // remember to allocate memory for ptr data members
    currentCourse = new char [strlen(course) + 1];
    strcpy(currentCourse, course);
}
// It is as if Student::Initialize() is written as:
// void Student_Initialize_str_str_char_float_constchar*
//     (<strong class="bold">Student *const this</strong>, string fn, string ln,
//      char mi, float avg, const char *course) 
// {
//    <strong class="bold">this</strong>-&gt;firstName = fn;
//    <strong class="bold">this</strong>-&gt;lastName = ln;
//    <strong class="bold">this</strong>-&gt;middleInitial = mi;
//    <strong class="bold">this</strong>-&gt;gpa = avg;
//    <strong class="bold">this</strong>-&gt;currentCourse = new char [strlen(course) + 1];
//    strcpy(<strong class="bold">this</strong>-&gt;currentCourse, course);
// }
// Member function definition
void Student::Print()
{
   cout &lt;&lt; firstName &lt;&lt; " ";
   cout &lt;&lt; middleInitial &lt;&lt; ". ";
   cout &lt;&lt; lastName &lt;&lt; " has a gpa of: ";
   cout &lt;&lt; gpa &lt;&lt; " and is enrolled in: ";
   cout &lt;&lt; currentCourse &lt;&lt; endl;
}
// It is as if Student::Print() is written as:
// void Student_Print(<strong class="bold">Student *const this</strong>)
// {
//    cout &lt;&lt; <strong class="bold">this</strong>-&gt;firstName &lt;&lt; " ";
//    cout &lt;&lt; <strong class="bold">this</strong>-&gt;middleInitial &lt;&lt; ". ";
//    cout &lt;&lt; <strong class="bold">this</strong>-&gt;lastName &lt;&lt; " has a gpa of: ";
//    cout &lt;&lt; <strong class="bold">this</strong>-&gt;gpa &lt;&lt; " and is enrolled in: ";
//    cout &lt;&lt; <strong class="bold">this</strong>-&gt;currentCourse &lt;&lt; endl;
// }</pre>
<p>First, we see the member function definition for <strong class="source-inline">void Student::Initialize()</strong>, which takes a variety of parameters. Notice that in the body of this function, we first assign input parameter <strong class="source-inline">fn</strong> to data member <strong class="source-inline">firstName</strong>. We proceed similarly, using the various<a id="_idIndexMarker330"/> input <a id="_idIndexMarker331"/>parameters, to initialize the various data members for the specific object that will invoke this function. Also notice that we allocate memory for pointer data member <strong class="source-inline">currentCourse</strong> to be enough characters to hold what input parameter <strong class="source-inline">course</strong> requires (plus one for the terminating null character). We then <strong class="source-inline">strcpy()</strong> the string from the input parameter, <strong class="source-inline">course</strong>, to data member <strong class="source-inline">currentCourse</strong>. </p>
<p>Also, notice in <strong class="source-inline">void Student::Initialize()</strong>, the assignment <strong class="source-inline">this-&gt;middleInitial = mi;</strong>. Here, we have an optional, explicit use of the <strong class="source-inline">this</strong> pointer. It is not necessary or customary in this situation to qualify <strong class="source-inline">middleInitial</strong> with <strong class="source-inline">this</strong>, but we may choose to do so. However, in the assignment <strong class="source-inline">this-&gt;gpa = gpa;</strong>, the use of <strong class="source-inline">this</strong> is required. Why? Notice that the input parameter is named <strong class="source-inline">gpa</strong> and the data member is also <strong class="source-inline">gpa</strong>. Simply assigning <strong class="source-inline">gpa = gpa;</strong> would set the most local version of <strong class="source-inline">gpa</strong> (the input parameter) to itself and would not affect the data member. Here, disambiguating <strong class="source-inline">gpa</strong> with <strong class="source-inline">this</strong> on the left-hand side of the assignment indicates to set the data member, <strong class="source-inline">gpa</strong>, which is pointed to by <strong class="source-inline">this</strong>, to the value of the input parameter, <strong class="source-inline">gpa</strong>. Another solution is to use distinct names for data members versus input parameters, such as renaming <strong class="source-inline">gpa</strong> in the formal parameter list to <strong class="source-inline">avg</strong> (which we will do in later versions of this code).</p>
<p>Now, notice the commented-out version of <strong class="source-inline">void Student::Initialize()</strong>, which is below the utilized version of <strong class="source-inline">void Student::Initialize()</strong>. Here, we can see how most member functions are internally represented. First, notice th<a id="_idTextAnchor244"/>at the name of the function is <em class="italic">name mangled</em> to include the data types of its parameters. This is internally how functions are represented, and consequentially, allows function overloading (that is, two functions with seemingly the same name; internally, each has a unique name). Next, notice that among the input parameters, there is an additional, first, input parameter. The name of this additional (hidden) input parameter is <strong class="source-inline">this</strong>, and it is defined as <strong class="source-inline">Student *const this</strong>. </p>
<p>Now, in the body of the internalized function view of <strong class="source-inline">void Student::Initialize()</strong>, notice that each data member’s name is preceded with <strong class="source-inline">this</strong>. We are, in fact, accessing the data member of an object that is pointed to by <strong class="source-inline">this</strong>. Where is <strong class="source-inline">this</strong> defined? Recall that <strong class="source-inline">this</strong> is the implicit first input parameter to this function, and is a constant pointer to the object that invoked this function.</p>
<p>Similarly, we can <a id="_idIndexMarker332"/>review<a id="_idIndexMarker333"/> the member function definition for <strong class="source-inline">void Student::Print()</strong>. In this function, each data member is neatly printed out using <strong class="source-inline">cout</strong> and the insertion operator <strong class="source-inline">&lt;&lt;</strong>. However, notice below this function definition, the commented-out internal version of <strong class="source-inline">void Student::Print()</strong>. Again, <strong class="source-inline">this</strong> is actually an implicit input parameter of type <strong class="source-inline">Student *const</strong>. Also, each data member usage is preceded with access through the <strong class="source-inline">this</strong> pointer, such as <strong class="source-inline">this-&gt;gpa</strong>. Again, we can clearly see that a specific instance’s members are accessed in the scope of a member function; these members are implicitly accessed through the <strong class="source-inline">this</strong> pointer.</p>
<p>Lastly, note that explicit use of <strong class="source-inline">this</strong> is permitted in the body of a member function. We can almost always precede usage of a data member or member function, accessed in the body of a member function, with explicit use of <strong class="source-inline">this</strong>. Later in this chapter, we will see the one contrary case (using a static method). Also, later in this book, we will see situations in which explicit usage of <strong class="source-inline">this</strong> will be necessary to implement more intermediate-level OO concepts. </p>
<p>Nonetheless, let’s move forward by examining <strong class="source-inline">main()</strong> to complete this program example:</p>
<pre class="source-code">
int main()
{
    Student s1;   // instance
    Student *s2 = new Student; // ptr to an instance
   <a id="_idTextAnchor245"/> s1.Initialize("Mary", "Jacobs", 'I', 3.9, "C++");
    s2-&gt;Initialize("Sam", "Nelson", 'B', 3.2, "C++");
    s1.Print();
    s2-&gt;Print(); // or use (*s2).Print();
    delete [] s1.currentCourse;     // delete dynamically 
    delete [] s2-&gt;currentCourse; // allocated data members
    delete s2;    // delete dynamically allocated instance
    return 0;
}</pre>
<p>In the last segment of this program, we instantiate <strong class="source-inline">Student</strong> twice in <strong class="source-inline">main()</strong>. <strong class="source-inline">Student</strong> <strong class="source-inline">s1</strong> is an instance, whereas <strong class="source-inline">s2</strong> is a pointer to a <strong class="source-inline">Student</strong>. Next, we utilize either <strong class="source-inline">.</strong> or <strong class="source-inline">-&gt;</strong> notation <a id="_idIndexMarker334"/>to invoke the various member <a id="_idIndexMarker335"/>functions through each relevant instance. </p>
<p>Note, when <strong class="source-inline">s1</strong> invokes <strong class="source-inline">Initialize()</strong>, the <strong class="source-inline">this</strong> pointer (in the scope of the member function) will point to <strong class="source-inline">s1</strong>. It will be as if <strong class="source-inline">&amp;s1</strong> is passed as a first argument to this function. Likewise, when <strong class="source-inline">*s2</strong> invokes <strong class="source-inline">Initialize()</strong>, the <strong class="source-inline">this</strong> pointer will point to <strong class="source-inline">s2</strong>; it will be as if <strong class="source-inline">s2</strong> (which is already a pointer) is passed as an implicit first argument to this function. </p>
<p>After each instance invokes <strong class="source-inline">Print()</strong> to display the data members for each <strong class="source-inline">Student</strong>, notice that we release various levels of dynamically allocated memory. We start with the dynamically allocated data members for each instance, releasing each such member using <strong class="source-inline">delete()</strong>. Then, because <strong class="source-inline">s2</strong> is a pointer to an instance that we have dynamically allocated, we must also remember to release the heap memory comprising the instance itself. We again do so with <strong class="source-inline">delete s2;</strong>.</p>
<p>Here is the output for the full program example:</p>
<p class="source-code">Mary I. Jacobs has a gpa of: 3.9 and is enrolled in: C++</p>
<p class="source-code">Sam B. Nelson has a gpa of: 3.2 and is enrolled in: C++</p>
<p>Now, let’s add to <a id="_idIndexMarker336"/>our<a id="_idIndexMarker337"/> understanding of classes and information hiding by examining access labels and regions.</p>
<h1 id="_idParaDest-107"><a id="_idTextAnchor246"/>Using access labels and access regions</h1>
<p>Labels may be<a id="_idIndexMarker338"/> introduced <a id="_idIndexMarker339"/>into a class (or structure) definition to control the access or visibility of class (or structure) members. By controlling the direct access of members from various scopes in our application, we can support encapsulation and information hiding. That is, we can insist that users of our classes use the functions that we select, with the protocols we select, to manipulate data and other member functions within the class in ways we, the programmers, find reasonable and acceptable. Furthermore, we can hide the implementation details of the class by advertising to the user only the desired public interface for a given class. </p>
<p>Data members or member functions, collectively referred to<a id="_idIndexMarker340"/> as <strong class="bold">members</strong>, can be individually labeled, or grouped together into access regions. The three labels or <strong class="bold">access regions</strong> that may be specified are as follows:</p>
<ul>
<li><strong class="bold">private</strong>: Data members and member functions in this access region are only accessible within the scope of the class. The scope of a class includes member functions of that class.</li>
<li><strong class="bold">protected</strong>: Behaves like <strong class="source-inline">private</strong> until we introduce inheritance. When inheritance is introduced, <strong class="source-inline">protected</strong> will provide a mechanism for allowing access within the derived class scope.</li>
<li><strong class="bold">public</strong>: Data members and member functions in this access region are accessible from any scope in the program.</li>
</ul>
<p class="callout-heading">Reminder</p>
<p class="callout">Data members and member functions are most always accessed via instances. You will ask, <em class="italic">in what scope is my instance?</em>, and <em class="italic">may I access a particular member from this particular scope?</em></p>
<p>As many members as required by the programmer may be grouped under a given label or <strong class="bold">access region</strong>. Should access labels be omitted in a class definition, the default member access is <strong class="source-inline">private</strong>. If access labels are omitted in a structure definition, default member access is <strong class="source-inline">public</strong>. When access labels are explicitly introduced, rather than relying on default visibility, a <strong class="source-inline">class</strong> and a <strong class="source-inline">struct</strong> are identical. Nonetheless, in object-oriented programming, we tend to utilize classes for user defined types. </p>
<p>It is interesting to note that data members, when grouped into an access region collectively under the same access label, are guaranteed to be laid out in memory in the order specified. However, if multiple access regions exist containing data members within a given class, the compiler is free to reorder those respective groupings for efficient memory layout.</p>
<p>Let’s examine<a id="_idIndexMarker341"/> an<a id="_idIndexMarker342"/> example to illustrate access regions. Though this example will be broken into several segments, the full example will be shown and c<a id="_idTextAnchor247"/>an also be found in the GitHub repository:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex3.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex3.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
#include &lt;cstring&gt;    // though we'll prefer std::string, 
// one ptr data member will illustrate important concepts
using std::cout;      // preferred to: using namespace std;
using std::endl;
using std::string;
class Student
{
// private members are accessible only within the scope of
// the class (that is, within member functions or friends) 
<strong class="bold">private:</strong> 
    string firstName;     // data members
    string lastName;
    char middleInitial;
    float gpa;
    char *currentCourse;  // ptr to illustrate key concepts
<strong class="bold">public:</strong>   // public members are accessible from any scope
    // member function prototypes
    void Initialize();  
    void Initialize(string, string, char, float,  
                    const char *);
    void CleanUp();
    void Print();
};</pre>
<p>In this <a id="_idIndexMarker343"/>example, we<a id="_idIndexMarker344"/> first define the <strong class="source-inline">Student</strong> class. Notice that we add a <strong class="source-inline">private</strong> access region near the top of the class definition and place all of the data members within this region. This placement will ensure that these data members will only be able to be directly accessed and modified within the scope of this class, which means by member functions of this class (and friends, which we will much later see). By limiting the access of data members only to member functions of their own class, safe handling of those data members is ensured; only access through intended and safe functions that the class designer has introduced themself will be allowed. </p>
<p>Next, notice that the label <strong class="source-inline">public</strong> has been added in the class definition prior to the prototypes of the member functions. The implication is that these functions will be accessible in any scope of our program. Of course, we will generally need to access these functions each via an instance. But the instance can be in the scope of <strong class="source-inline">main()</strong> or any other function (even in the scope of another class’ member functions) when the instance accesses these public member functions. This is known as a class’ <strong class="source-inline">public</strong> interface.</p>
<p class="callout-heading">Access regions support encapsulation and information hiding</p>
<p class="callout">A good rule of thumb is to place your data members in the <strong class="source-inline">private</strong> access region and then specify a safe, appropriate <strong class="source-inline">public</strong> interface to access them using <strong class="source-inline">public</strong> member functions. By doing so, the only access to data members is in manners that the class designer has intended, through member functions the class designer has written, which have been well tested. With this strategy, the underlying implementation of the class may also be changed without causing any calls to the public interface to change. This practice supports encapsulation and information hiding.</p>
<p>Let’s continue<a id="_idIndexMarker345"/> by<a id="_idIndexMarker346"/> taking a look at the various member function definitions in our program:</p>
<pre class="source-code">
void Student::Initialize()
{   // even though string data members are initialized with
    // empty strings, we are showing how to clear these 
    // strings, should Initialize() be called more than 1x
    firstName.clear();   
    lastName.clear(); 
    middleInitial = '\0';      // null character
    gpa = 0.0;
    currentCourse = nullptr; 
}
// Overloaded member function definition
void Student::Initialize(string fn, string ln, char mi,
                         float avg, const char *course) 
{
    firstName = fn;
    lastName = ln;
    middleInitial = mi; 
    gpa = avg;   
    // dynamically allocate memory for pointer data member
    currentCourse = new char [strlen(cours<a id="_idTextAnchor248"/>e) + 1];
    strcpy(currentCourse, course);
}
// Member <a id="_idTextAnchor249"/>function definition
void Student::CleanUp()
{   // deallocate previously allocated memory
    delete [] currentCourse;  
}                          
// Member function definition
void Student::Print()
{
    cout &lt;&lt; firstName &lt;&lt; " " &lt;&lt; middleInitial &lt;&lt; ". ";
    cout &lt;&lt; lastName &lt;&lt; " has gpa: " &lt;&lt; gpa;
    cout &lt;&lt; " and enrolled in: " &lt;&lt; currentCourse &lt;&lt; endl;
}</pre>
<p>Here, we <a id="_idIndexMarker347"/>have<a id="_idIndexMarker348"/> defined the various member functions that were prototyped in our class definition. Notice the use of the scope resolution operator <strong class="source-inline">::</strong> to tie the class name to the member function name. Internally, these two identifiers are <em class="italic">name mangled</em> together to provide a unique, internal function name. Notice that the <strong class="source-inline">void Student::Initialize()</strong> function has been overloaded; one version simply initializes all data members to some form of null or zero, whereas the overloaded version uses input parameters to initialize the various data members.</p>
<p>Now, let’s continue by examining our <strong class="source-inline">main()</strong> function in the following segment of code:</p>
<pre class="source-code">
int main()
{
    Student s1;
    // Initialize() is publ<a id="_idTextAnchor250"/>ic; accessible<a id="_idTextAnchor251"/> from any scope
    s1.Initialize("Ming", "Li", 'I', 3.9, "C++", "178GW"); 
    s1.Print(); // public Print() accessible from main() 
    // Error! private firstName is not accessible in main()
    // cout &lt;&lt; s1.firstName &lt;&lt; endl;  
    // CleanUp() is public, accessible from any scope
    s1.CleanUp(); 
    return 0;
}</pre>
<p>In <a id="_idIndexMarker349"/>the<a id="_idIndexMarker350"/> aforementioned <strong class="source-inline">main()</strong> function, we first instantiate a <strong class="source-inline">Student</strong> with the declaration <strong class="source-inline">Student s1;</strong>. Next, <strong class="source-inline">s1</strong> invokes the <strong class="source-inline">Initialize()</strong> function with the signature matching the parameters provided. Since this member function is in the <strong class="source-inline">public</strong> access region, it can be accessed in any scope of our program, including <strong class="source-inline">main()</strong>. Similarly, <strong class="source-inline">s1</strong> invokes <strong class="source-inline">Print()</strong>, which is also <strong class="source-inline">public</strong>. These functions are in the <strong class="source-inline">Student</strong> class’ public interface, and represent some of the core functionality for manipulating any given <strong class="source-inline">Student</strong> instance.</p>
<p>Next, in the commented-out line of code, notice that <strong class="source-inline">s1</strong> tries to access <strong class="source-inline">firstName</strong> directly using <strong class="source-inline">s1.firstName</strong>. Because <strong class="source-inline">firstName</strong> is <strong class="source-inline">private</strong>, this data member can only be accessed in the scope of its own class, which means member functions (and later friends) of its class. The <strong class="source-inline">main()</strong> function is not a member function of <strong class="source-inline">Student</strong>, hence <strong class="source-inline">s1</strong> may not access <strong class="source-inline">firstName</strong> in the scope of <strong class="source-inline">main()</strong>, that is, a scope outside its own class.</p>
<p>Lastly, we invoke <strong class="source-inline">s1.CleanUp();</strong>, which also works because <strong class="source-inline">CleanUp()</strong> is <strong class="source-inline">public</strong> and is hence accessible from any scope (including <strong class="source-inline">main()</strong>). </p>
<p>The output for this complete example is as follows:</p>
<p class="source-code">Ming I. Li has gpa: 3.9 and enrolled in: C++</p>
<p>Now that we <a id="_idIndexMarker351"/>understand<a id="_idIndexMarker352"/> how access regions work, let’s move forward by examining a concept known as a constructor, and the <a id="_idTextAnchor252"/>various types of constructors available within C++.</p>
<h1 id="_idParaDest-108"><a id="_idTextAnchor253"/>Understanding constructors</h1>
<p>Did you notice how <a id="_idIndexMarker353"/>convenient it has been for the program examples in this chapter to have an <strong class="source-inline">Initialize()</strong> member function for each <strong class="source-inline">class</strong> or <strong class="source-inline">struct</strong>? Certainly, it is desirable to initialize all data members for a given instance. More so, it is crucial to ensure that data members for any instance have bonafide values, as we know that memory is not provided <em class="italic">clean</em> or <em class="italic">zeroed-out</em> by C++. Accessing an uninitialized data member, and utilizing its value as if it were bonafide, is a potential pitfall awaiting the careless programmer.</p>
<p>Initializing each data member individually each time a class is instantiated can be tedious work. What if we simply overlook setting a value? What if the values are <strong class="source-inline">private</strong>, and are therefore not directly accessible? We have seen that an <strong class="source-inline">Initialize()</strong> function is beneficial because once written, it provides a means to set all data members for a given instance. The only drawback is that the programmer must now remember to call <strong class="source-inline">Initialize()</strong> on each instance in the application. Instead, what if there is a way to ensure that an <strong class="source-inline">Initialize()</strong> function is called every time a class is instantiated? What if we could overload a variety of versions to initialize an instance, and the appropriate version could be called based on data available at the time? This premise is the basis for a constructor in C++. The language provides for an overloaded series of initialization functions, which will be automatically called once the memory for an <a id="_idIndexMarker354"/>instance becomes available. </p>
<p>Let’s take a look at this family of initialization member functions by examining the C++ constructor.</p>
<h2 id="_idParaDest-109"><a id="_idTextAnchor254"/>Applying constructor basics and overloading constructors</h2>
<p>A <strong class="bold">constructor</strong> is a<a id="_idIndexMarker355"/> member <a id="_idIndexMarker356"/>function that is automatically invoked after the memory for an instance is made available. Constructors are used to initialize the data members that comprise a newly instantiated object (except for static data members, which we’ll examine later in this chapter). A constructor will have the same name as the class or struct in which it is a member. Constructors may be overloaded, which enables a <strong class="source-inline">class</strong> (or <strong class="source-inline">struct</strong>) to define multiple means by which to initialize an object. The return type of a constructor may not be specified.</p>
<p>Should your <strong class="source-inline">class</strong> or <strong class="source-inline">struct</strong> not contain a constructor, one will be made for you in the <strong class="source-inline">public</strong> access region, with no arguments. This is known as a default constructor. Behind the scenes, every time an object is instantiated, a constructor call is patched in by the compiler. When a class without a constructor is instantiated, the default constructor is patched in as a function call immediately following the instantiation. This system-supplied member function will have an empty body (method) and it will be linked into your program so that any compiler-added, implicit calls to this function upon instantiation can occur without a linker error. As needed per the design, a programmer may often write their own default (no-argument) constructor; that is, one that is used for the default means of instantiation with no arguments. </p>
<p>Most programmers provide at least one constructor, in addition to their own no-argument, default constructor. Recall that constructors can be overloaded. It is important to note that if you provide any constructor yourself, you will not then receive the system supplied no-argument default constructor, and that subsequently using such an i<a id="_idTextAnchor255"/><a id="_idTextAnchor256"/>nterface for instantiation will cause a compiler error.</p>
<p class="callout-heading">Reminder</p>
<p class="callout">Constructors have the same name as the class. You may not specify their return type. They can be overloaded. The compiler only creates a public, default (no-argument) constructor if you have not provided any constructors (that is, means for instantiation) in your class.</p>
<p>Let’s introduce <a id="_idIndexMarker357"/>a simple example to understand constructor <a id="_idIndexMarker358"/>basics:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex4.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex4.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
using std::cout;   // preferred to: using namespace std;
using std::endl;
using std::string;
class University
{
private:
    string name;
    int numStudents;
public: 
    // construc<a id="_idTextAnchor257"/>tor prototypes
    <strong class="bold">University();</strong> // default constructor
    <strong class="bold">University(const string &amp;, int);</strong>
    void Print();
    void CleanUp();
};
<strong class="bold">University::University()</strong>
{   // Because a string is a class type, all strings are 
    // constructed with an empty value by default. 
    // For that reason, we do not need to explicitly 
    // initialize strings if an empty string is desired. 
    // We'll see a preferred manner of initialization 
    // for all data members shortly in this chapter.    
    // Hence, name is cons<a id="_idTextAnchor258"/>tructed by default (empty string)
    numStudents = 0;
}
<strong class="bold">University::University(const string &amp;n, int num)</strong>
{   // any pointer data members should be allocated here
    name = n; // assignment between strings is deep assign.
    numStudents = num;
}
void University::Print()
{
    cout &lt;&lt; "University: " &lt;&lt; name;
    cout &lt;&lt; " Enrollment: <a id="_idTextAnchor259"/>" &lt;&lt; numStudents &lt;&lt; endl;
}
void University::Clean<a id="_idTextAnchor260"/>Up()
{   // deallocate any previously allocated memory
}
int main()
{
    University u1; // Implicit call to default constructor
    // alternate c<a id="_idTextAnchor261"/>onstructor instantiation and invocation
    University u2("University of Delaware", 23800);
    University u3{"Temple University", 20500}; // note {}  
    u1.Print();
    u2.Print();
    u3.Print();
    u1.CleanUp();
    u2.CleanUp();
    u3.CleanUp();
    return 0;
}</pre>
<p>In the previous<a id="_idIndexMarker359"/> program<a id="_idIndexMarker360"/> segment, we first define <strong class="source-inline">class University</strong>; the data members are <strong class="source-inline">private</strong>, and the three member functions are <strong class="source-inline">public</strong>. Notice that the first two member functions prototyped are constructors. Both have the same name as the class; neither has its return type specified. The two constructors are overloaded, in that each has a different signature. </p>
<p>Next, notice that the three member functions are defined. Notice the use of the scope resolution operator <strong class="source-inline">::</strong> preceding each member function name, in each of their definitions. Each constructor provides a different means for initializing an instance. The <strong class="source-inline">void University::Print()</strong> member function merely provides a means to provide simple output for our example.</p>
<p>Now, in <strong class="source-inline">main()</strong>, let’s create three instances of <strong class="source-inline">University</strong>. The first line of code, <strong class="source-inline">University u1;</strong>, instantiates a <strong class="source-inline">University</strong> and then implicitly invokes the default constructor to initialize the data members. On the next line of code, <strong class="source-inline">University u2("University of Delaware", 23800);</strong>, we instantiate a second <strong class="source-inline">University</strong>. Once the memory for that instance has been made available on the stack in <strong class="source-inline">main()</strong>, the constructor matching the signature of the arguments provided, namely <strong class="source-inline">University::University(const string &amp;, int)</strong>, will be implicitly invoked to initialize the instance. </p>
<p>Finally, we instantiate a third <strong class="source-inline">University</strong> using <strong class="source-inline">University u3{"Temple University", 20500};</strong>, which also makes use of the alternate constructor. Notice the use of <strong class="source-inline">{}</strong>’s versus <strong class="source-inline">()</strong>’s in the instantiation and construction of <strong class="source-inline">u3</strong>. Either style may be utilized. The latter style was introduced in an effort to create uniformity; neither construct results in a performance advantage. </p>
<p>We can see that<a id="_idIndexMarker361"/> based <a id="_idIndexMarker362"/>upon how we instantiate an object, we can specify which constructor we would l<a id="_idTextAnchor262"/>ike to be called on our behalf to perform the initialization. </p>
<p>The output for this example is as follows:</p>
<p class="source-code">University: Enrollment: 0</p>
<p class="source-code">University: University of Delaware Enrollment: 23800</p>
<p class="source-code">University: Temple Enrollment: 20000</p>
<p class="callout-heading">Parameter comparison</p>
<p class="callout">Did you notice the signature to the alternate <strong class="source-inline">University</strong> constructor is <strong class="source-inline">University(const string &amp;, int);</strong>? That is, the first parameter is a <strong class="source-inline">const string &amp;</strong> rather than a <strong class="source-inline">string</strong>, as used in previous examples for our <strong class="source-inline">Initialize()</strong> member function? Both are acceptable. A <strong class="source-inline">string</strong> parameter will pass a copy of the formal parameter on the stack to the member function. If the formal parameter is a string literal in quotes (such as <strong class="source-inline">"University of Delaware"</strong>), a <strong class="source-inline">string</strong> instance will first be made to house this literal string of characters. In comparison, if the parameter to the constructor is a <strong class="source-inline">const string &amp;</strong>, then a reference to the formal parameter will be passed to this function and the object referenced will be treated as <strong class="source-inline">const</strong>. In the body of the constructor, we use assignment to copy the value of the input parameter to the data member. Not to worry, the implementation of the assignment operator for the <strong class="source-inline">string</strong> class performs a deep assignment from the source to the destination string. The implication is that we do not have to worry about the data member sharing memory (that is, not having its own copy) with the initialization data (string). Therefore, either use of a <strong class="source-inline">string</strong> or <strong class="source-inline">con<a id="_idTextAnchor263"/>st string &amp;</strong> as a parameter for the constructor is acceptable.</p>
<p>Now, let’s <a id="_idIndexMarker363"/>complement <a id="_idIndexMarker364"/>our use of constructors with in-class initializers. </p>
<h2 id="_idParaDest-110"><a id="_idTextAnchor264"/>Constructors and in-class initializers</h2>
<p>In addition to <a id="_idIndexMarker365"/>initializing data members within<a id="_idIndexMarker366"/> a constructor, a class may optionally contain <strong class="bold">in-class initializers</strong>. That is, default values that can be specified in a class definition as a means to initialize data members in the absence of specific constructor initialization (or assignment) of those<a id="_idTextAnchor265"/> data members.</p>
<p>Let’s consider a revision of our previous example:</p>
<pre class="source-code">
class University
{
private:
    string name <strong class="bold">{"None"}</strong>; <strong class="bold">// in-class initializer to be</strong>
    int numStudents <strong class="bold">{0}</strong>;  <strong class="bold">// used when values not set in</strong>
<strong class="bold">                          // constructor</strong>
    // Above line same as: int numStudents = 0;
publ<a id="_idTextAnchor266"/>ic:                   
    University(); // default constructor
    <strong class="bold">// assume remainder of class def is as previously shown</strong>
};
University::University()
{   // Because there are no initializations (or
    // assignments) of data members name, numStudents 
    // in this constructor, the in-class initializer
    // values will persist.
    // This constructor, with its signature, is still 
    // required for the instantiation below, in main()
}
<strong class="bold">// assume remaining member functions exist here</strong>
int main()
{
    University u1;  // in-class initializers are used
}</pre>
<p>In the previous<a id="_idIndexMarker367"/> code <a id="_idIndexMarker368"/>fragment, notice that our class definition for <strong class="source-inline">University</strong> contains two in-class initializers for data members <strong class="source-inline">name</strong> and <strong class="source-inline">numStudents</strong>. These values will be used to initialize data members for a <strong class="source-inline">University</strong> instance when a <strong class="source-inline">University</strong> constructor does not otherwise set these values. More specifically, if a <strong class="source-inline">University</strong> constructor uses initialization to set these values, the in-class initializers will be ignored (we will see formal constructor initialization with the member initialization list shortly in this chapter). </p>
<p>Additionally, if a constructor sets these data members through assignment within the body of a constructor (as we have seen in the previous constructor example), the assignments will overwrite any in-class initialization that was otherwise done on our behalf. However, if we do not set data members in a constructor (as shown in the current code fragment), the in-class initializers will be utilized.</p>
<p>In-class initializers can be used to simplify default constructors or to alleviate default values specified within a constructor’s prototype (a style that is becoming less popular). </p>
<p>As we have seen in this example, in-class initializers can lead to a default constructor having no work (that is, initialization) remaining to be conducted in the method body itself. Yet, we can see that in some cases, a default constructor is necessary if we would like to use the default interface for instantiation. In cases such as these, <strong class="source-inline">=default</strong> may be added to the prototype of the default constructor to indicate that the system-supplied default constructor (with an empty body) should be linked in on our behalf, alleviating our need to provide an empty, default constructor ourselves (as in our previous example). </p>
<p>With <a id="_idIndexMarker369"/>this<a id="_idIndexMarker370"/> improvement, our class definition will become the following:</p>
<pre class="source-code">
class University
{
private:
    string name <strong class="bold">{"None"}; // in-class init. to be used when</strong>
    int numStudents <strong class="bold">{0};  // values not set in constructor</strong>
public: 
    <strong class="bold">// request the default constructor be linked in</strong>     
    University() <strong class="bold">= default</strong>; 
    University(const string &amp;, int);
    void Print();
    void CleanUp();
};</pre>
<p>In the previous class definition, we have now requested the system-supplied default constructor (with an empty body) in a situation where we would not have otherwise gotten one automatically (because we have provided a constructor with another signature). We have saved specifying an empty-bodied default constructor ourselves, as in our original example.</p>
<p>Next, let’s add to our knowledge of constructors by examining a copy constructor. </p>
<h2 id="_idParaDest-111"><a id="_idTextAnchor267"/>Creating copy constructors</h2>
<p>A <strong class="bold">copy constructor</strong> is a<a id="_idIndexMarker371"/> specialized constructor that is invoked whenever a copy of an object may need to be made. Copy constructors may be invoked during the construction of another object. They may also be invoked when an object is passed by value to a function via an input parameter or returned by value from a function.</p>
<p>Often, it is easier to make a copy of an object and modify the copy slightly than to construct a new object with its individual attributes from scratch. This is especially true if a programmer requires a copy of an object that has undergone many changes during the life of the application. It may be impossible to recall the order of various transformations that may have been applied to the object in question in order to create a duplicate. Instead, having the means to copy an object is desirable, and possibly crucial.</p>
<p>The signature of a copy constructor is <strong class="source-inline">ClassName::ClassName(const ClassName &amp;);</strong>. Notice that a single object is explicitly passed as a parameter, and that parameter will be a reference to a constant object. The copy constructor, as do most member functions, will receive an implicit argument to the function, the <strong class="source-inline">this</strong> pointer. The purpose of the copy constructor’s definition will be to make a copy of the explicit parameter to initialize the object pointed to by <strong class="source-inline">this</strong>.</p>
<p>If no copy constructor is implemented by the <strong class="source-inline">class</strong> (or <strong class="source-inline">struct</strong>) designer, one will be provided for you (in the <strong class="source-inline">public</strong> access region) that performs a shallow, member-wise copy. This is unlikely not what you want if you have data members in your class that are pointers. Instead, the best thing to do is to write a copy constructor yourself, and write it to perform a deep cop<a id="_idTextAnchor268"/>y (allocating memory as necessary) for data members that are pointers.</p>
<p>Should the programmer wish to disallow copying during construction, <strong class="source-inline">=delete</strong> can be used in the prototype of the copy constructor as follows:</p>
<pre class="source-code">
    <strong class="bold">// disallow copying during construction</strong>
    Student(const Student &amp;) <strong class="bold">= delete</strong>;   // prototype</pre>
<p>Alternatively, if the programmer wishes to prohibit object copying, a copy constructor may be prototyped in the <strong class="source-inline">private</strong> access region. In this case, the compiler will link in the default copy constructor (which performs a shallow copy), but it will be considered private. Therefore, instantiations that would utilize the copy constructor outside the scope of the class will be prohibited. This technique is used less frequently since the advent of <strong class="source-inline">=delete</strong>; however, it may be seen in existing code, so it is useful to understand.</p>
<p>Let’s examine a copy constructor, starting with the class definition. Though the program is presented in several <a id="_idIndexMarker372"/>fragments, the full program example may be found in the GitHub repository:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex5.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex5.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;  
#include &lt;cstring&gt;    // though we'll prefer std::string, 
// one ptr data member will illustrate important concepts
using std::cout;      // preferred to: using namespace std;
using std::endl;
using std::string;
class Student
{
private: 
    // data members
    string firstName;
    string lastName;
    char middleInitial;
    float gpa;
    char *currentCourse;  // ptr to illustrate key concepts
public:
    // member function prototypes
    Student();  // default constructor
    Student(const string &amp;, const string &amp;, char, float, 
            const char *); 
    <strong class="bold">Student(const Student &amp;);</strong>  // copy constructor proto.
    void CleanUp();
    void Print();
    void SetFirstName(const string &amp;);
};</pre>
<p>In this program segment, we start by defining <strong class="source-inline">class Student</strong>. Notice the usual assortment of <strong class="source-inline">private</strong> data members and <strong class="source-inline">public</strong> member function prototypes, including the default constructor and an overloaded constructor. Also notice the prototype for the copy constructor <strong class="source-inline">Student(const Student &amp;);</strong>. </p>
<p>Next, let’s take a <a id="_idIndexMarker373"/>look at the member function definitions with the following co<a id="_idTextAnchor269"/>ntinuation of our program:</p>
<pre class="source-code">
// default constructor
Student::Student()
{
    // Because firstName and lastName are member objects of
    // type string, they are default constructed and hence
    // 'empty' by default. They HAVE been initialized.
    middleInitial = '\0';   // with a relevant value
    gpa = 0.0;
    currentCourse = 0;
}
// Alternate constructor member function definition
Student::Student(const string &amp;fn, const string &amp;ln, 
                 char mi, float avg, const char *course)
{
    firstName = fn;  // not to worry, assignment for string
    lastName = ln;   // is a deep copy into destination str
    middleInitial = mi;
    gpa = avg;
    // dynamically allocate memory for pointer data member
    currentCourse = new char [strlen(course) + 1];
    strcpy(currentCo<a id="_idTextAnchor270"/>urse, course);
}
// Copy constructor definition – implement a deep copy
<strong class="bold">Student::Student(const Student &amp;s)</strong>
{   // assignment between strings will do a deep 'copy'
    firstName = s.firstName;
    lastName = s.lastName;
    middleInitial = s.middleInitial;
    gpa = s.gpa;
    // for ptr data members, ensure a deep copy 
    // allocate memory for destination
    currentCourse = new char [strlen(s.currentCourse) + 1];
    // then copy contents from source to destination
    strcpy(currentCourse, s.currentCourse); 
}
// Member function definition
void Student::CleanUp()
{   // deallocate any previously allocated memory
    delete [] currentCourse;   
}
   
// Member function definitions
void Student::Print()
{
    cout &lt;&lt; firstName &lt;&lt; " " &lt;&lt; middleInitial &lt;&lt; ". ";
    cout &lt;&lt; lastName &lt;&lt; " has a gpa of: " &lt;&lt; gpa;
    cout &lt;&lt; " and is enrolled in: " &lt;&lt; currentCourse;
    cout &lt;&lt; endl;
}
void Student::SetFirstName(const string &amp;fn)
{
    firstName = fn;
}</pre>
<p>In the aforementioned<a id="_idIndexMarker374"/> code fragment, we have various member function definitions. Most notably, let’s consider the copy constructor definition, which is the member function with the signature of <strong class="source-inline">Student::Student(const Student &amp;s)</strong>. </p>
<p>Notice that the input parameter, <strong class="source-inline">s</strong>, is a reference to a <strong class="source-inline">Student</strong> that is <strong class="source-inline">const</strong>. This means that the source object, which we will be copying from, may not be modified. The destination object, which we will be copying into, will be the object pointed to by the <strong class="source-inline">this</strong> pointer.</p>
<p>As we carefully navigate the copy constructor, notice that we successively allocate space, as necessary, for any pointer data members that belong to the object pointed to by <strong class="source-inline">this</strong>. The space allocated is the same size as required by the data members referred to by <strong class="source-inline">s</strong>. We then carefully copy from source data member to destination data member. We meticulously ensure that we make an exact copy in the destination object of the source object.</p>
<p>Notice that we are making a <em class="italic">deep copy</em> in the destination object. That is, rather than simply copying the pointers contained in <strong class="source-inline">s.currentCourse</strong> to <strong class="source-inline">this-&gt;currentCourse</strong>, for example, we instead allocate space for <strong class="source-inline">this-&gt;currentCourse</strong> and then copy over the source data. The result of a shallow copy would instead be that the pointer data members in each object would share the same dereferenced memory (that is, the memory to which each pointer points). This is most likely not what you would want in a copy. Also recall that the default behavior of a system-supplied<a id="_idIndexMarker375"/> copy constructor would be to provide a shallow copy from the source to the destination object. It is also worthy to note that the assignment between two strings such as <strong class="source-inline">firstName = s.firstName;</strong> in the copy constructor will perform a deep assignment from source to destination string because t<a id="_idTextAnchor271"/>hat is the behavior of the assignment operator defined by the string class. </p>
<p>Now, let’s take a look at our <strong class="source-inline">main()</strong> function to see the various ways in which the copy constructor could be invoked:</p>
<pre class="source-code">
int m<a id="_idTextAnchor272"/>ain()
{ 
 <a id="_idTextAnchor273"/>   // instantiate two Students
    <a id="_idTextAnchor274"/>Student s1("Zachary", "Moon", 'R', 3.7, "C++");
    Student s2("Gabrielle", "Doone", 'A', 3.7, "C++");
    <strong class="bold">// These inits implicitly invoke copy constructor</strong>
    Student s3(s1);  
    Student s4 = s2;
    s3.SetFirstName("Zack");// alter each object slightly
    s4.SetFirstName("Gabby"); 
    // This sequence does not invoke copy co<a id="_idTextAnchor275"/>nstructor 
  <a id="_idTextAnchor276"/>  // This is instead an assignment.
    // Student s5("Giselle", "LeBrun", 'A', 3.1, "C++);
    // Student s6;
    // s6 = s5;   // this is assignment, not initialization
    s1.Print();   // print each instance
    s3.Print();
    s2.Print();
    s4.Print();
    s1.CleanUp(); // Since some data members are pointers,
    s2.CleanUp(); // let's call a function to delete() them
    s3.CleanUp();
    s4.CleanUp();
    return 0;
}</pre>
<p>In <strong class="source-inline">main()</strong>, we declare<a id="_idIndexMarker376"/> two instances of <strong class="source-inline">Student</strong>, <strong class="source-inline">s1</strong> and <strong class="source-inline">s2</strong>, and each is initialized with the constructor that matches the signature of <strong class="source-inline">Student::Student(const string &amp;, const string &amp;, char, float, const char *);</strong>. Notice that the signature used in instantiation is how we select which constructor should be implicitly called.</p>
<p>Next, we instantiate <strong class="source-inline">s3</strong> and pass as an argument to its constructor the object <strong class="source-inline">s1</strong> with <strong class="source-inline">Student s3(s1);</strong>. Here, <strong class="source-inline">s1</strong> is of type <strong class="source-inline">Student</strong>, so this instantiation will match the constructor that accepts a reference to a <strong class="source-inline">Student</strong>, the copy constructor. Once in the copy constructor, we know that we will make a deep copy of <strong class="source-inline">s1</strong> to initialize the newly instantiated object, <strong class="source-inline">s3</strong>, which will be pointed to by the <strong class="source-inline">this</strong> pointer in the scope of the copy constructor method. </p>
<p>Additionally, we instantiate <strong class="source-inline">s4</strong> with the following line of code: <strong class="source-inline">Student s4 = s2;</strong>. Here, because this line of code is an initialization (that is, <strong class="source-inline">s4</strong> is both declared and given a value in the same statement), the copy constructor will also be invoked. The source object of the copy will be <strong class="source-inline">s2</strong> and the destination object will be <strong class="source-inline">s4</strong>. Notice that we then modify each of the copies (<strong class="source-inline">s3</strong> and <strong class="source-inline">s4</strong>) slightly by modifying their <strong class="source-inline">firstName</strong> data members.</p>
<p>Next, in the commented-out section of code, we instantiate two objects of type <strong class="source-inline">Student</strong>, <strong class="source-inline">s5</strong> and <strong class="source-inline">s6</strong>. We then try to assign one to the other with <strong class="source-inline">s5 = s6;</strong>. Though this looks similar to the initialization between <strong class="source-inline">s4</strong> and <strong class="source-inline">s2</strong>, it is not. The line <strong class="source-inline">s5 = s6;</strong> is an assignment. Each of the objects existed previously. As such, the copy constructor is not called for this<a id="_idIndexMarker377"/> segment of code. Nonetheless, this code is legal and has similar implications as with the assignment operator. We will examine these details later in the book when we discuss operator overloading in <a href="B19087_12.xhtml#_idTextAnchor526"><em class="italic">Chapter 12</em></a>, <em class="italic">Friends and Operator Overloading</em>.</p>
<p>We then print out objects <strong class="source-inline">s1</strong>, <strong class="source-inline">s2</strong>, <strong class="source-inline">s3</strong>, and <strong class="source-inline">s4</strong>. Then, we call <strong class="source-inline">Cleanup()</strong> on each of these four objects. Why? Each object contained data members that were pointers, so it is appropriate to delete the heap memory contained within each instance (that is, selected pointer data members) prior to these outer stack objects g<a id="_idTextAnchor277"/>oing out of scope.</p>
<p>Here is the output to accompany the full program example:</p>
<p class="source-code">Zachary R. Moon has a gpa of: 3.7 and is enrolled in: C++</p>
<p class="source-code">Zack R. Moon has a gpa of: 3.7 and is enrolled in: C++</p>
<p class="source-code">Gabrielle A. Doone has a gpa of: 3.7 and <a id="_idTextAnchor278"/>is enrolled in: C++</p>
<p class="source-code">Gabby A. Doone has a gpa of: 3.7 and is enrolled in: C++</p>
<p>The output for this example shows each original <strong class="source-inline">Student</strong> instance, paired with its copy. Notice that<a id="_idTextAnchor279"/> <a id="_idTextAnchor280"/><a id="_idTextAnchor281"/>each copy has been modified slightly from the original (<strong class="source-inline">firstName</strong> differs). </p>
<p class="callout-heading">Related topic</p>
<p class="callout">It is interesting to note that the assignment operator shares many similarities with the copy constructor, in that it can allow data to be copied from a source to destination instance. However, the copy constructor is implicitly invoked for the initialization of a new object, whereas the assignment operator will be invoked when performing an assignment between two existing objects. Nonetheless, the methods of each will look strikingly similar! We will examine overloading the assignment operator to customize its behavior to perform a deep assignment (much like a deep copy) in <a href="B19087_12.xhtml#_idTextAnchor526"><em class="italic">Chapter 12</em></a>, <em class="italic">Friends and Operator Overloading</em>.</p>
<p>Now that we have a <a id="_idIndexMarker378"/>deep understanding of copy constructor<a id="_idTextAnchor282"/>s, let’s look at one last variety of constructor, the conversion constructor.</p>
<h2 id="_idParaDest-112"><a id="_idTextAnchor283"/>Creating conversion constructors</h2>
<p>Type conversions <a id="_idIndexMarker379"/>can be performed from one user defined type to another, or from a standard type to a user defined type. A conversion constructor is a language mechanism that allows such conversions to occur. </p>
<p>A <strong class="bold">conversion constructor</strong> is a <a id="_idIndexMarker380"/>constructor that accepts one explicit argument of a standard or user defined type and applies a reasonable conversion or transformation on that object to initialize the object being instantiated.</p>
<p>Let’s take a look at an example illustrating this idea. Though the example will be broken into several segments and also abbreviated, the full program can be found in the GitHub repository:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex6.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex6.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;   
#include &lt;cstring&gt;   // though we'll prefer std::string, 
// one ptr data member will illustrate important concepts
using std::cout;     // preferred to: using namespace std;
using std::endl;
using std::string;
class Student;      // forward declaration of Student class
class Employee
{
private:
    string firstName;
    string lastName;
    float salary;
public:
    Employee();
    Employee(const string &amp;, const string &amp;, float);
    <strong class="bold">Employee(Student &amp;);</strong>  // conversion constructor
    void Print();
};
class Student
{
private: // data members
    string firstName;
    string lastName;
    char middleInitial;
    float gpa;
    char *currentCourse;  // ptr to illustrate key concepts
public:               
    // constructor prototypes
    Student();  // default constructor
    Student(const string &amp;, const string &amp;, char, float, 
            const char *);
    Student(const Student &amp;);  // copy constructor
    void Print();
    void CleanUp();
    float GetGpa(); // access function for private data mbr
    const string &amp;GetFirstName();
    const string &amp;GetLastName();
};</pre>
<p>In the previous program segment, we first include a forward declaration to <strong class="source-inline">class Student;</strong> – this declaration allows us to refer to the <strong class="source-inline">Student</strong> type prior to its definition. We then define <strong class="source-inline">class Employee</strong>. Notice that this class includes several <strong class="source-inline">private</strong> data members and three constructor prototypes – a default, alternative, and conversion <a id="_idIndexMarker381"/>constructor. As a side note, notice that a copy constructor has not been programmer-specified. This means that a default (shallow) copy constructor will be provided by the compiler. In this case, since there are no pointer data members, the shallow copy is acceptable. </p>
<p>Nonetheless, let us continue by examining the <strong class="source-inline">Employee</strong> conversion constructor prototype. Notice that in the prototype, this constructor takes a single argument. The argument is a <strong class="source-inline">Student &amp;</strong>, which is why we needed the forward declaration for <strong class="source-inline">Student</strong>. Preferably, we might use a <strong class="source-inline">const Student &amp;</strong> as the parameter type, but we will need to understand const member functions (later in this chapter) in order to do so. The type conversion that will take place will be to convert a <strong class="source-inline">Student</strong> into a newly constructed <strong class="source-inline">Employee</strong>. It will be our job to provide a meaningful conversion to accomplish this in the definition for the conversion constructor, which we will see shortly.</p>
<p>Next, we define our <strong class="source-inline">Student</strong> class, which is much the same as we have seen in previous examples. </p>
<p>Now, let us continue with the example to see the member function definitions for <strong class="source-inline">Employee</strong> and <strong class="source-inline">Student</strong>, and our <strong class="source-inline">main()</strong> function, in the following code segment. To conserve space, selected member function definitions will be omitted, however, the online code will show the program in its entirety. </p>
<p>Moving onward, our<a id="_idIndexMarker382"/> member functions for <strong class="source-inline">Employee</strong> and <strong class="source-inline">Student</strong> are as follows:</p>
<pre class="source-code">
Employee::Employee()  // default constructor
{
    // Remember, firstName, lastName are member objects of
    // type string; they are default constructed and hence
    // 'empty' by default. They HAVE been initialized.
    salary = 0.0;
}
// alternate constructor
Employee::Employee(const string &amp;fn, const string &amp;ln, 
                   float money)
{
    firstName = fn;
    lastName = ln;
    salary = money;
}
// conversion constructor param. is a Student not Employee
// Eventually, we can properly const qualify parameter, but
// we'll need to learn about const member functions first…
<strong class="bold">Employee::Employee(Student &amp;s)</strong>
{
    firstName = s.GetFirstName();
    lastName = s.GetLastName();
    if (s.GetGpa() &gt;= 4.0)
        salary = 75000;
    else if (s.GetGpa() &gt;= 3.0)
        salary = 60000;
    else
        salary = 50000; 
}
void Employee::Print()
{
    cout &lt;&lt; firstName &lt;&lt; " " &lt;&lt; lastName &lt;&lt; " " &lt;&lt; salary;
    cout &lt;&lt; endl;
}
<strong class="bold">// Definitions for Student's default, alternate, copy</strong>
<strong class="bold">// constructors, Print()and CleanUp() have been omitted </strong>
<strong class="bold">// for space, but are same as the prior Student example.</strong>
float Student::GetGpa()
{
    return gpa;
}
const string &amp;Student::GetFirstName()
{
    return firstName;
}
const string &amp;Student::GetLastName()
{
    return lastName;
}</pre>
<p>In the previous segment of code, we notice several constructor definitions for <strong class="source-inline">Employee</strong>. We have <a id="_idIndexMarker383"/>a default, alternate, and conversion constructor.</p>
<p>Examining the definition of the <strong class="source-inline">Employee</strong> conversion constructor, notice that the formal parameter for the source object is <strong class="source-inline">s</strong>, which is of type <strong class="source-inline">Student</strong>. The destination object will be the <strong class="source-inline">Employee</strong> that is being constructed, which will be pointed to by the <strong class="source-inline">this</strong> pointer. In the body of this function, we carefully copy the <strong class="source-inline">firstName</strong> and <strong class="source-inline">lastName</strong> from <strong class="source-inline">Student &amp;s</strong> to the newly instantiated <strong class="source-inline">Employee</strong>. Note that we use access functions <strong class="source-inline">const string &amp;Student::GetFirstName()</strong> and <strong class="source-inline">const string &amp;Student::GetLastName()</strong> to do so (via an instance of <strong class="source-inline">Student</strong>), as these data members are <strong class="source-inline">private</strong>. </p>
<p>Let’s continue with the conversion constructor. It is our job to provide a meaningful conversion from one type to another. In that endeavor, we try to establish an initial salary for the <strong class="source-inline">Employee</strong> based on the <strong class="source-inline">gpa</strong> of the source <strong class="source-inline">Student</strong> object. Because <strong class="source-inline">gpa</strong> is <strong class="source-inline">private</strong>, an access function, <strong class="source-inline">Student::GetGpa()</strong>, is used to retrieve this value (via the source <strong class="source-inline">Student</strong>). Notice that because <strong class="source-inline">Employee</strong> did not have any dynamically allocated data members, we did not need to allocate memory to assist in a deep copy in the body of this function.</p>
<p>To conserve space, the member function definitions for the <strong class="source-inline">Student</strong> default, alternate, and copy constructor have been omitted, as have the definition for the <strong class="source-inline">void Student::Print()</strong> and <strong class="source-inline">void Student::CleanUp()</strong> member functions. However, they are the same as in the previous full program example illustrating the <strong class="source-inline">Student</strong> class.</p>
<p>Notice that access functions for <strong class="source-inline">private</strong> data members in <strong class="source-inline">Student</strong>, such as <strong class="source-inline">float Student::GetGpa()</strong>, have been added to provide safe access to those data members. Note that the value returned from <strong class="source-inline">float Student::GetGpa()</strong> on the stack is a copy of the <strong class="source-inline">gpa</strong> data member. The original <strong class="source-inline">gpa</strong> is in no worry of being breached by the use of this function. The same applies for member functions <strong class="source-inline">const string &amp;Student::GetFirstName()</strong> and <strong class="source-inline">const string &amp;Student::GetLastName()</strong>, which each returns a <strong class="source-inline">const string &amp;</strong>, ensuring that the data that will be returned will not be breached.</p>
<p>Let’s complete <a id="_idIndexMarker384"/>our program by examining our <strong class="source-inline">main()</strong> function:</p>
<pre class="source-code">
int main()
{
    Student s1("Giselle", "LeBrun", 'A', 3.5, "C++");
    <strong class="bold">Employee e1(s1);</strong>  <strong class="bold">// conversion constructor</strong>
    e1.Print();
    s1.CleanUp();  // CleanUp() will delete() s1's 
    return 0;      // dynamically allocated data members
}</pre>
<p>In our <strong class="source-inline">main()</strong> function, we instantiate a <strong class="source-inline">Student</strong>, namely <strong class="source-inline">s1</strong>, which is implicitly initialized with the matching constructor. Then we instantiate an <strong class="source-inline">Employee</strong>, <strong class="source-inline">e1</strong>, using the conversion constructor in the call <strong class="source-inline">Employee e1(s1);</strong>. At a quick glance, it may seem that we are utilizing the <strong class="source-inline">Employee</strong> copy constructor. But at a closer look, we notice that the actual parameter <strong class="source-inline">s1</strong> is of type <strong class="source-inline">Student</strong>, not <strong class="source-inline">Employee</strong>. Hence, we are using <strong class="source-inline">Student s1</strong> as a basis to initialize <strong class="source-inline">Employee e1</strong>. Note that in no manner is the <strong class="source-inline">Student,</strong> <strong class="source-inline">s1</strong>, harmed or altered in this conversion. For this reason, it would be preferable to define the source object as a <strong class="source-inline">const Student &amp;</strong> in the formal parameter list; once we understand const member functions, which will then be required for usage in the body of the conversion constructor, we can do so.</p>
<p>To conclude this program, we print out the <strong class="source-inline">Employee</strong> using <strong class="source-inline">Employee::Print()</strong>, which enables us to visualize the conversion we applied for a <strong class="source-inline">Student</strong> to an <strong class="source-inline">Employee</strong>.</p>
<p>Here is the output to accompany our example:</p>
<p class="source-code">Giselle LeBrun 60000</p>
<p>Before we move forward, there’s one final, subtle detail about conversion constructors that is very important to understand.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Any constructor that takes a single argument is considered a conversion constructor, which can potentially be used to convert the parameter type to the object type of the class to which it belongs. For example, if you have a constructor in the <strong class="source-inline">Student</strong> class that takes only a <strong class="source-inline">float</strong>, this constructor could be employed not only in the manner shown in the preceding example but also in places where an argument of type <strong class="source-inline">Student</strong> is expected (such as a function call), when an argument of type <strong class="source-inline">float</strong> is instead supplied. This may not be what you intend, which is why this interesting feature is being called out. If you don’t want implicit conversions to take place, you can disable this behavior by declaring the constructor with the <strong class="source-inline">explicit</strong> keyword at the beginning of its prototype. </p>
<p>Now that we<a id="_idIndexMarker385"/> understand basic, alternative, copy and conversion constructors in C++, let’s move forward and explore the constructor’s complementary member function, the C++ destructor.</p>
<h1 id="_idParaDest-113"><a id="_idTextAnchor284"/>Understanding destructors</h1>
<p>Recall how<a id="_idIndexMarker386"/> conveniently a class constructor provides us with a way to initialize a newly instantiated object? Rather than having to remember to call an <strong class="source-inline">Initialize()</strong> method for each instance of a given type, the constructor allows initialization automatically. The signature used in construction helps specify which of a series of constructors should be used. </p>
<p>What about object clean-up? Many classes contain dynamically allocated data members, which are often allocated in a constructor. Shouldn’t the memory comprising these data members be released when the programmer is done with an instance? Certainly. We have written a <strong class="source-inline">CleanUp()</strong> member function for several of our example programs. And we have remembered to call <strong class="source-inline">CleanUp()</strong>. Conveniently, similar to a constructor, C++ has an automatically built-in feature to serve as a clean-up function. This function is known as the<a id="_idIndexMarker387"/> destructor.</p>
<p>Let’s look at the destructor to understand its proper usage.</p>
<h2 id="_idParaDest-114"><a id="_idTextAnchor285"/>Applying destructor basics and proper usage</h2>
<p>A <strong class="bold">destructor</strong> is a member<a id="_idIndexMarker388"/> function<a id="_idIndexMarker389"/> whose purpose is to relinquish the resources an object may have acquired during its existence. A destructor is automatically invoked when a class or struct instance has either of the following occur:</p>
<ul>
<li>Goes out of scope (this applies to non-pointer variables)</li>
<li>Is explicitly deallocated using <strong class="source-inline">delete</strong> (for pointers to objects)</li>
</ul>
<p>A destructor should (most often) clean up any memory that may have been allocated by the constructor. The destructor’s name is a <strong class="source-inline">~</strong> character followed by the <strong class="source-inline">class</strong> name. A destructor will have no arguments; therefore, it cannot be overloaded. Lastly, the return type for a destructor may not be specified. Both classes and structures may have destructors.</p>
<p>In addition to deallocating memory that a constructor may have allocated, a destructor may be used to perform other end-of-life tasks for an instance, such as logging a value to a database. More complex tasks may include informing objects pointed to by class data members (whose memory is not being released) that the object at hand will be concluding. This may be important if the linked object contains a pointer back to the terminating object. We will see examples of this later in the book, in <a href="B19087_10.xhtml#_idTextAnchor454"><em class="italic">Chapter 10</em></a>, <em class="italic">Implementing Association, Aggregation, and Composition</em>.</p>
<p>If you have not provided a destructor, the compiler will create and link in a <strong class="source-inline">public</strong> destructor with an empty body. This is necessary because a destructor call is automatically patched in just prior to the point when local instances are popped off the stack, and with <strong class="source-inline">delete()</strong>, just prior to the memory release of dynamically allocated instances. It is easier for the compiler to always patch in this call, rather than constantly looking to see whether your class has a destructor or not. Be sure to provide a class destructor yourself when there are resources to clean up or dynamically allocated memory requiring release. If the destructor will be empty, consider using <strong class="source-inline">=default</strong> in its prototype to acknowledge its automatic inclusion (and to forego providing a definition yourself); this practice, however, adds unnecessary code and therefore is becoming less popular.</p>
<p>There are some potential pitfalls. For example, if you forget to delete a dynamically allocated instance, the destructor call will not be patched in for you. C++ is a language that gives you the flexibility and power to do (or not do) anything. If you do not delete memory using a given identifier (perhaps two pointers refer to the same memory), please remember to delete it through the other identifier at a later date.</p>
<p>There’s one last item worth mentioning. Though you may call a destructor explicitly, you will rarely ever need to do so. Destructor calls are implicitly patched in by the compiler on your behalf in the aforementioned scenarios. Only in very few advanced programming situations will you need to explicitly call a destructor yourself. </p>
<p>Let’s take<a id="_idIndexMarker390"/> a<a id="_idIndexMarker391"/> look at a simple example illustrating a class destructor, which will be broken into three segments. Its full example can be seen in the GitHub repository listed here:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex7.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex7.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;  
#include &lt;cstring&gt;    // though we'll prefer std::string, 
// one ptr data member will illustrate important concepts
using std::cout;      // preferred to: using namespace std;
using std::endl;
using std::string;
class University
{
private:
    char *name;   // ptr data member shows destructor 
                  // purpose
    int numStudents;
public: 
    // constructor prototypes
    University(); // default constructor
    University(const char *, int); // alternate constructor
    University(const University &amp;);  // copy constructor
    <strong class="bold">~University();</strong>  // destructor prototype
    void Print();
};</pre>
<p>In the previous segment of code, we first define <strong class="source-inline">class University</strong>. Notice the <strong class="source-inline">private</strong> access region filled with data members, and the <strong class="source-inline">public</strong> interface, which includes prototypes for a default, alternate, and copy constructor, as well as for the destructor and a <strong class="source-inline">Print()</strong> method. </p>
<p>Next, let’s take <a id="_idIndexMarker392"/>a<a id="_idIndexMarker393"/> look at the various member function definitions: </p>
<pre class="source-code">
University::University()  // default constructor
{
    name = nullptr;
    numStudents = 0;
}
University::University(const char *n, int num) 
{   // allocate memory for pointer data member
    name = new char [strlen(n) + 1];
    strcpy(name, n);
    numStudents = num;
}
University::University(const University &amp;u) // copy const
{
    name = new char [strlen(u.name) + 1];  // deep copy
    strcpy(name, u.name);
    numStudents = u.numStudents;
}
<strong class="bold">University::~University()</strong>  // destructor definition
{  
    delete [] name;  // deallocate previously allocated mem
    cout &lt;&lt; "Destructor called " &lt;&lt; this &lt;&lt; endl;
}
void University::Print()
{
    cout &lt;&lt; "University: " &lt;&lt; name;
    cout &lt;&lt; " Enrollment: " &lt;&lt; numStudents &lt;&lt; endl;
}</pre>
<p>In the<a id="_idIndexMarker394"/> aforementioned <a id="_idIndexMarker395"/>code fragment, we see the various overloaded constructors we are now accustomed to seeing, plus <strong class="source-inline">void University::Print()</strong>. The new addition is the destructor definition. </p>
<p>Notice the destructor <strong class="source-inline">University::~University()</strong> takes no arguments; it may not be overloaded. The destructor simply deallocates memory that may have been allocated in any of the constructors. Note that we simply <strong class="source-inline">delete [] name;</strong>, which will work whether <strong class="source-inline">name</strong> points to a valid address or contains a null pointer (yes, applying <strong class="source-inline">delete</strong> to a null pointer is OK). We additionally print the <strong class="source-inline">this</strong> pointer in the destructor, just for fun, so that we can see the address of the instance that is approaching non-existence. </p>
<p>Next, let’s take a look at <strong class="source-inline">main()</strong> to see when the destructor may be called:</p>
<pre class="source-code">
int main()
{
    University u1("Temple University", 39500);
    University *u2 = new University("Boston U", 32500);
    u1.Print();
    u2-&gt;Print();
    delete u2; // destructor will be called before delete()
               // and destructor for u1 will be called 
    return 0;  // before program completes 
}</pre>
<p>Here, we<a id="_idIndexMarker396"/> instantiate <a id="_idIndexMarker397"/>two <strong class="source-inline">University</strong> instances; <strong class="source-inline">u1</strong> is an instance, and <strong class="source-inline">u2</strong> points to an instance. We know that <strong class="source-inline">u2</strong> is instantiated when its memory becomes available with <strong class="source-inline">new()</strong> and that once the memory has become available, the applicable constructor is called. Next, we call <strong class="source-inline">University::Print()</strong> for both instances to have some output. </p>
<p>Finally, toward the end of <strong class="source-inline">main()</strong>, we delete <strong class="source-inline">u2</strong> to return this memory to the heap management facility. Just prior to memory release, with the call to <strong class="source-inline">delete()</strong>, C++ will patch in a call to the destructor for the object pointed to by <strong class="source-inline">u2</strong>. It is as if a secret function call <strong class="source-inline">u2-&gt;~University();</strong> has been patched in prior to <strong class="source-inline">delete u2;</strong> (note, this is done automatically, no need for you to do so as well). The implicit call to the destructor will delete the memory that may have been allocated for any data members within the class. The memory release is now complete for <strong class="source-inline">u2</strong>. </p>
<p>What about instance <strong class="source-inline">u1</strong>? Will its destructor be called? Yes; <strong class="source-inline">u1</strong> is a stack instance. Just prior to its memory being popped off the stack in <strong class="source-inline">main()</strong>, the compiler will have patched in a call to its destructor, as if the call <strong class="source-inline">u1.~University();</strong> was added on your behalf (again, no need to do so yourself). For the instance <strong class="source-inline">u1</strong>, the destructor will also deallocate any memory for data members that may have been allocated. Likewise, the memory release is now complete for <strong class="source-inline">u1</strong>.</p>
<p>Notice that in each destructor call, we have printed a message to illustrate when the destructor is called, and have also printed out t<a id="_idTextAnchor286"/>he memory address for <strong class="source-inline">this</strong> to allow you to visualize each specific instance as it is destructed.</p>
<p>Here is the output to accompany our full program example:</p>
<p class="source-code">University: Temple University Enrollment: 39500</p>
<p class="source-code">University: Boston U Enrollment: 32500</p>
<p class="source-code">Destructor called 0x10d1958</p>
<p class="source-code">Destructor called 0x60fe74</p>
<p>With this <a id="_idIndexMarker398"/>example, we<a id="_idIndexMarker399"/> have now examined the destructor, the complement to the series of class constructors. Let us move on to another set of useful topics relating to classes: various keyword qualifications of data members and member functions.</p>
<h1 id="_idParaDest-115"><a id="_idTextAnchor287"/>Applying qualifiers to data members and member functions</h1>
<p>In this<a id="_idIndexMarker400"/> section, we <a id="_idIndexMarker401"/>will investigate qualifiers that can be added to both data members and member functions. The various qualifiers – <strong class="source-inline">inline</strong>, <strong class="source-inline">const</strong>, and <strong class="source-inline">static</strong> – can support program efficiency, aid in keeping private data members safe, support encapsulation and information hiding, and additionally be used to implement various object-oriented concepts. </p>
<p>Let’s get started with the various types of member qualifications.</p>
<h2 id="_idParaDest-116"><a id="_idTextAnchor288"/>Adding inline functions for potential efficiency</h2>
<p>Imagine a set of<a id="_idIndexMarker402"/> short member functions in your program that are repeatedly called by various instances. As an object-oriented programmer, you appreciate using a <strong class="source-inline">public</strong> member function to provide safe and controlled access to <strong class="source-inline">private</strong> data. However, for very short functions, you worry about efficiency. That is, the overhead of calling a small function repeatedly. Certainly, it would be more efficient to just paste in the two or three lines of code comprising the function. Yet, you resist because that may mean providing <strong class="source-inline">public</strong> access to otherwise hidden class information, such as data members, which you are hesitant to do. An <strong class="source-inline">inline</strong> function can solve this dilemma, allowing you to have the safety of a member function to access and manipulate your private data, yet the efficiency of executing several lines of code without the overhead of a function call. </p>
<p>An <strong class="bold">inline</strong> function is a function whose invocation is substituted with the body of the function itself. Inline functions can help eliminate the overhead associated with calling very small functions. </p>
<p>Why would calling a function have overhead? When a function is called, input parameters (including <strong class="source-inline">this</strong>) are pushed onto the stack, space is reserved for a return value of the function (though sometimes registers are used), and moving to another section of code requires storing information in registers to jump to that section of code, and so on. Replacing very small function bodies with inline functions can add to program efficiency.</p>
<p>An inline function <a id="_idIndexMarker403"/>may be specified using either of the following mechanisms:</p>
<ul>
<li>Placing the function definition inside the class definition </li>
<li>Placing the keyword <strong class="source-inline">inline</strong> prior to the return type in the (typical) function definition, found outside the class definition</li>
</ul>
<p>Specifying a function as <strong class="source-inline">inline</strong> in one of the aforementioned two fashions is merely a request to the compiler to consider the substitution of the function body for its function call. This substitution is not guaranteed. When might the compiler not actually inline a given function? If a function is recursive, it cannot be made <strong class="source-inline">inline</strong>. Likewise, if a function is lengthy, the compiler will not inline the function. Also, if the function call is dynamically bound with the specific implementation determined at run time (virtual functions), it cannot be made <strong class="source-inline">inline</strong>. </p>
<p>An <strong class="source-inline">inline</strong> function definition should be declared in the header file with the corresponding class definition. This will allow for any revisions to the function to be re-expanded correctly should the need arise. </p>
<p>Let’s see an example using <strong class="source-inline">inline</strong> functions. The program will be broken into two segments, <a id="_idTextAnchor289"/>with some well-known functions removed. However, the full program may be seen in the<a id="_idIndexMarker404"/> GitHub repository:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex8.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex8.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;  
#include &lt;cstring&gt;   // though we'll prefer std::string, 
                     // one ptr data member will illustrate
                     // important concepts
using std::cout;     // preferred to: using namespace std;
using std::endl;
using std::string;
class Student
{
private: 
    // data members
    string firstName;
    string lastName;
    char middleInitial;
    float gpa;
    char *currentCourse;  // ptr to illustrate key concepts
public:
    // member function prototypes
    Student();  // default constructor
    Student(const student &amp;, const student &amp;, char, float, 
            const char *); 
    Student(const Student &amp;);  // copy constructor
    ~Student();  // destructor
    void Print();
    // inline function definitions
    <strong class="bold">const string &amp;GetFirstName() { return firstName; }</strong>  
    <strong class="bold">const string &amp;GetLastName() { return lastName; }</strong>    
    <strong class="bold">char GetMiddleInitial() { return middleInitial; }</strong>
    <strong class="bold">float GetGpa() { return gpa; }</strong>
    <strong class="bold">const char *GetCurrentCourse() </strong>
<strong class="bold">        { return currentCourse; }</strong>
<a id="_idTextAnchor290"/>    // prototype only, see inline function definition below
    <strong class="bold">void SetCurrentCourse(const char *);</strong>
};
<strong class="bold">inline void Student::SetCurrentCourse(const char *c)</strong>
{   // notice the detailed work to reset ptr data member;
    // it's more involved than if currentCourse was a str
    delete [] currentCourse;  
    currentCourse = new char [strlen(c) + 1];
    strcpy(currentCourse, c); 
}</pre>
<p>In the previous program fragment, let’s start with the class definition. Notice that several access function definitions have been added in the class definition itself, namely, functions such as <strong class="source-inline">GetFirstName()</strong>, <strong class="source-inline">GetLastName()</strong>, and so on. Look closely; these functions are actually defined within the class definition. For example, <strong class="source-inline">float GetGpa() { return gpa; }</strong> is not just the prototype, but the full function definition. By virtue of the function placement within the class definition, functions such as these are considered <strong class="source-inline">inline</strong>.</p>
<p>These small functions provide safe access to private data members. Notice <strong class="source-inline">const char *GetCurrentCourse()</strong>, for example. This function returns a pointer to <strong class="source-inline">currentCourse</strong>, which is stored in the class as a <strong class="source-inline">char *</strong>. But because the return value of this function is a <strong class="source-inline">const char *</strong>, this means that anyone calling this function must treat the return value as a <strong class="source-inline">const char *</strong>, which means treating it as unmodifiable. Should this function’s return value be stored in a variable, that variable must also be defined as <strong class="source-inline">const char *</strong>. By upcasting this pointer to an unmodifiable version of itself with the return value, we are adding the provision that no one can get their hands on a <strong class="source-inline">private</strong> data member (which is a pointer) and then change its value. </p>
<p>Now, notice toward the end of the class definition, we have a prototype for <strong class="source-inline">void SetCurrentCourse(const char *);</strong>. Then, outside of this class definition, we will see the <a id="_idIndexMarker405"/>definition for this member function. Notice the keyword <strong class="source-inline">inline</strong> prior to the <strong class="source-inline">void</strong> return type of this function definition. The keyword must be explicitly used here since the function is defined outside of the class definition. Remember, with either style of <strong class="source-inline">inline</strong> designation for a method, the <strong class="source-inline">inline</strong> specification is merely a request to the compiler to make the substitution of function body for function call. As with any function, if you provide a prototype (without <strong class="source-inline">=default</strong>), be sure to provide a function definition (or else the linker will definitely complain).</p>
<p>Let’s continue this example by examining the remainder of our program:</p>
<pre class="source-code">
<strong class="bold">// Definitions for default, alternate, copy constructor,</strong>
<strong class="bold">// and Print() have been omitted for space,</strong>
<strong class="bold">// but are same as last example for class Student</strong>
// the destructor is shown because we have not yet seen
// an example destructor for the Student class
Student::~Student()
{   // deallocate previously allocated memory
    delete [] currentCourse;
}
int main()
{
    Student s1("Jo", "Muritz", 'Z', 4.0, "C++"); 
    cout &lt;&lt; <strong class="bold">s1.GetFirstName()</strong> &lt;&lt; " " &lt;&lt; <strong class="bold">s1.GetLastName()</strong>;
    cout &lt;&lt; " Enrolled in: " &lt;&lt; <strong class="bold">s1.GetCurrentCourse()</strong>;
    cout &lt;&lt; endl;
    <strong class="bold">s1.SetCurrentCourse("Advanced C++ Programming");</strong> 
    cout &lt;&lt; <strong class="bold">s1.GetFirstName()</strong> &lt;&lt; " " &lt;&lt; <strong class="bold">s1.GetLastName()</strong>;
    cout &lt;&lt; " New course: " &lt;&lt; <strong class="bold">s1.GetCurrentCourse()</strong>; 
    cout &lt;&lt; endl;
    return 0;
}</pre>
<p>Notice that in the <a id="_idIndexMarker406"/>remainder of our program example, several member function definitions have been omitted. The bodies of these functions are identical to the previous example illustrating a <strong class="source-inline">Student</strong> class in full, and can also be viewed online. </p>
<p>Let’s focus instead on our <strong class="source-inline">main()</strong> function. Here, we instantiate a <strong class="source-inline">Student</strong>, namely <strong class="source-inline">s1</strong>. We then invoke several <strong class="source-inline">inline</strong> function calls via <strong class="source-inline">s1</strong>, such as <strong class="source-inline">s1.GetFirstName();</strong>. Because <strong class="source-inline">Student::GetFirstName()</strong> is inline, it is as if we are accessing data member <strong class="source-inline">firstName</strong> directly, as the body of this function merely has a <strong class="source-inline">return firstName;</strong> statement. We have the safety of using a function to access a <strong class="source-inline">private</strong> data member (meaning that no one can modify this data member outside the scope of the class), but the speed of an inline function’s code expansion to eliminate the overhead of a function call. </p>
<p>Throughout <strong class="source-inline">main()</strong>, we make several other calls to <strong class="source-inline">inline</strong> functions in this same manner, including <strong class="source-inline">s1.SetCurrentCourse();</strong>. We now have the safety of encapsulated access with the speed of direct access to data members using small <strong class="source-inline">inline</strong> functions. </p>
<p>Here is the output to accompany our full program example:</p>
<p class="source-code">Jo Muritz Enrolled in: C++</p>
<p class="source-code">Jo Muritz New course: Advanced C++ Programming</p>
<p>Let’s now move <a id="_idIndexMarker407"/>onward by investigating another qualifier we can add to class members, the <strong class="source-inline">const</strong> qualifier.</p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor291"/>Adding const data members and the member initialization list</h2>
<p>We have already seen<a id="_idIndexMarker408"/> earlier<a id="_idIndexMarker409"/> in this book how to constant-qualify variables and the implications of doing so. To briefly recap, the implication of adding a <strong class="source-inline">const</strong> qualifier to a variable is that the variable must be initialized when it is declared and that its value may never again be modified. We previously also saw how to add <strong class="source-inline">const</strong> qualification to pointers, such that we could qualify the data being pointed to, the pointer itself, or both. Let us now examine what it means to add a <strong class="source-inline">const</strong> qualifier to data members within a class, and learn about specific language mechanisms that must be employed to initialize those data members.</p>
<p>Data members that should never be modified should be qualified as <strong class="source-inline">const</strong>. A <strong class="bold">const data member</strong> is one that may only be initialized, and never assigned a new value. Just as with <strong class="source-inline">const</strong> variables, <em class="italic">never modified</em> means that the data member may not be modified using its own identifier. It will then be our job to ensure that we do not initialize our data members that are pointers to <strong class="source-inline">const</strong> objects with objects that are not labeled as <strong class="source-inline">const</strong> (lest we provide a back door to change our private data). </p>
<p>Keep in mind that in C++, a programmer can always cast the const-ness away from a pointer variable. Not that they should. Nonetheless, we will employ safety measures to ensure that by using access regions and appropriate return values from access functions, we do not easily provide modifiable access to our <strong class="source-inline">private</strong> data members.</p>
<p>The <strong class="bold">member initialization list</strong> must be used in a constructor to initialize any data members that are constant, or that are references. A member initialization list offers a mechanism to initialize data members that may never be l-values in an assignment. A member initialization list may also be used to initialize non-const data members. For performance reasons, the member initialization list is most often the preferred way to initialize any data member (const or non-const). The member initialization list also provides a manner to specify preferred construction for any data members that are of class types themselves (that is, member objects).</p>
<p>A member initialization list may appear in any constructor, and to indicate this list, simply place a <strong class="source-inline">:</strong> after the formal parameter list, followed by a comma-separated list of data members, paired with the initial value for each data member in parentheses. For example, here we <a id="_idIndexMarker410"/>use<a id="_idIndexMarker411"/> the member initialization list to set two data members, <strong class="source-inline">gpa</strong> and <strong class="source-inline">middleInitial</strong>:</p>
<pre class="source-code">
Student::Student()<strong class="bold">: gpa(0.0), middleInitial('\0')</strong>
{   
    // Remember, firstName, lastName are member objects of
    // type string; they are default constructed and hence
    // 'empty' by default. They HAVE been initialized. 
    currentCourse = nullptr; // don't worry – we'll change
}                        // currentCourse to a string next!</pre>
<p>Though we have used the member initialization list to initialize two data members in the previous constructor, we could have used it to set all of the data members! We’ll see this proposition (and preferred usage) momentarily.</p>
<p>Data members in the member initialization list are initialized in the order in which they appear (that is, declared) in the class definition (except static data members, which we will see shortly). Next, the body of the constructor is executed. It is a nice convention to order the data members in the member initialization list to appear in the same order as the class definition. But remember, the order of actual initialization matches the order that the data members are specified in the class definition, irrespective of member initialization list ordering.</p>
<p>It is interesting to note that a reference must use the member initialization list because references are implemented as constant pointers. That is, the pointer itself points to a specific other object and may not point elsewhere. The values of that object may change, but the reference always references a specific object, the one in which it was initialized.</p>
<p>Using <strong class="source-inline">const</strong> qualification with pointers can be tricky to determine which scenarios require initialization with this list, and which do not. For example, a pointer to a constant object does not need to be initialized with the member initialization list. The pointer could point to any object, but once it does, it may not change the dereferenced value. However, a constant pointer must be initialized with the member initialization list because the pointer itself is fixed to a specific address.</p>
<p>Let’s take a look at a <strong class="source-inline">const</strong> data member and how to use the member initialization list to initialize its value in a full program example. We will also see how to use this list to initialize non-const <a id="_idIndexMarker412"/>data members. Though this example is segmented<a id="_idIndexMarker413"/> and not shown in its entirety, the full program can be found in the GitHub repository:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex9.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex9.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;  
using std::cout;    // preferred to: using namespace std;
using std::endl;
using std::string;
class Student
{
private: 
    // data members
    string firstName;
    string lastName;
    char middleInitial;
    float gpa;
    string currentCourse; // let's finally change to string
    <strong class="bold">const int studentId;</strong>  // added, constant data member
public:
    // member function prototypes
    Student();  // default constructor
    Student(const string &amp;, const string &amp;, char, float, 
            const string &amp;, int); 
    Student(const Student &amp;);  // copy constructor
    ~Student();  // destructor
    void Print();
    const string &amp;GetFirstName() { return firstName; }  
    const string &amp;GetLastName() { return lastName; }    
    char GetMiddleInitial() { return middleInitial; }
    float GetGpa() { return gpa; }
    const string &amp;GetCurrentCourse() 
        { return currentCourse; }
    void SetCurrentCourse(const string &amp;);  // proto. only
}; </pre>
<p>In<a id="_idIndexMarker414"/> the<a id="_idIndexMarker415"/> aforesaid <strong class="source-inline">Student</strong> class, notice that we have added a data member, <strong class="source-inline">const int studentId;</strong>, to the class definition. This data member will require the use of the member initialization list to initialize this constant data member in each of<a id="_idTextAnchor292"/> the constructors.</p>
<p>Let’s take a look at how the use of the member initialization list will work with constructors:</p>
<pre class="source-code">
<strong class="bold">// Definitions for the destructor, Print(),<a id="_idTextAnchor293"/> and </strong>
<strong class="bold">// SetCurrentCourse() have been omitted to save space.</strong>
<strong class="bold">// They are similar to what we have seen previously.</strong>
// Constructor w/ member init. list to set data mbrs
Student::Student()<strong class="bold">: firstName(), lastName(),</strong>
<strong class="bold">                    middleInitial('\0'), gpa(0.0), </strong>
<strong class="bold">                    currentCourse(), studentId(0)</strong> 
{
    // You may still set data members here, but using above
    // initialization is more efficient than assignment
    // Note: firstName, lastName are shown in member init.
    // list selecting default constructor for init.
    // However, as this is the default action for member 
    // objects (string), we don't need to explicitly inc<a id="_idTextAnchor294"/><a id="_idTextAnchor295"/>l.
    // these members in the member initialization list
    // (nor will we include them in future examples).
}
Student::Student(const string &amp;fn, const string &amp;ln, 
         char mi, float avg, const string &amp;course, int id)<strong class="bold">: </strong>
         <strong class="bold">firstName(fn), lastName(ln), middleInitial(mi),</strong>
         <strong class="bold">gpa(avg), currentCourse(course), studentId (id)</strong> 
{
   // For string data members, the above init. calls    
   // the string constructor that matches the arg in ().
   // This is preferred to default constructing a string
   // and then resetting it via assignment in the
   // constructor body.
}
Student::Student(const Student &amp;s)<strong class="bold">: firstName(s.firstName),</strong>
<strong class="bold">      lastName(s.lastName), middleInitial(s.middleInitial),</strong>
<strong class="bold">      gpa(s.gpa), currentCourse(s.currentCourse), </strong>
<strong class="bold">      studentId(s.stu<a id="_idTextAnchor296"/>dentId)</strong>
{
   // remember to do a deep copy for any ptr data members
}
int main()
{ 
    Student s1("Renee", "Alexander", 'Z', 3.7, 
               "C++", 1290);
    cout &lt;&lt; s1.GetFirstName() &lt;&lt; " " &lt;&lt; s1.GetLastName();
    cout &lt;&lt; " has gpa of: " &lt;&lt; s1.GetGpa() &lt;&lt; endl;
    return 0;
}</pre>
<p>In the preceding <a id="_idIndexMarker416"/>code<a id="_idIndexMarker417"/> fragment, we see three <strong class="source-inline">Student</strong> constructors. Notice the various member initialization lists, designated by a <strong class="source-inline">:</strong> after the formal parameter list for each of the three constructors.</p>
<p>Of particular interest is the member initialization list usage for data members that are of type <strong class="source-inline">string</strong> (or as we’ll later see, of any class type). In this usage, the string data members are constructed using the member initialization list using the specified constructor; that is, the one whose signature matches the argument in <strong class="source-inline">()</strong>. This is inevitably more efficient than default constructing each string (which is what happened previously behind the scenes) and then resetting its value via assignment within the constructor method body.</p>
<p>With this in mind, the default <strong class="source-inline">string</strong> constructor selection in the member initialization list of the <strong class="source-inline">Student</strong> default constructor – that is, <strong class="source-inline">:firstName(), lastName(), currentCourse()</strong> – is shown to emphasize that these data members are member objects (of type <strong class="source-inline">string</strong>) and will be constructed. In this case, they will each be default constructed, which will provide their contents with an empty string. However, member objects will always be default constructed unless otherwise directed using the member initialization list. For this reason, the <strong class="source-inline">:firstName()</strong>,<strong class="source-inline"> lastName()</strong>, and <strong class="source-inline">currentCourse()</strong> specifications in the member initialization list are optional and will not be included in future examples.</p>
<p>Each <a id="_idIndexMarker418"/>constructor<a id="_idIndexMarker419"/> will make use of the member initialization list to set the values of data members that are <strong class="source-inline">const</strong>, such as <strong class="source-inline">studentId</strong>. Additionally, the member initialization list can be used as a simple (and more efficient) way to initialize any other data member. We can see examples of the member initialization list being used to simply set non-const data members by viewing the member initialization list in either the default or alternate constructor, for example, <strong class="source-inline">Student::Student() <a id="_idTextAnchor297"/><a id="_idTextAnchor298"/>: studentId(0), gpa(0.0)</strong>. In this example, <strong class="source-inline">gpa</strong> is not <strong class="source-inline">const</strong>, so its use in the member init<a id="_idTextAnchor299"/><a id="_idTextAnchor300"/><a id="_idTextAnchor301"/>ialization list is optional.</p>
<p>Here is the output to accompany our full program example:</p>
<p class="source-code">Renee Alexander has gpa of: 3.7</p>
<p class="callout-heading">Important note</p>
<p class="callout">Even though the constructor’s member initialization list is the only mechanism that can be used to initialize const data members (or those that are references or member objects), it is also often the preferred mechanism to perform simple initialization for any data member for performance reasons. In many cases (such as member objects – for example, a string), this saves data members from being first initialized (constructed themselves) with a default state and then re-assigned a value in the body of the constructor. </p>
<p>It is interesting to note that programmers may choose to utilize either <strong class="source-inline">()</strong> or <strong class="source-inline">{}</strong> in the member initialization list to initialize data members. Notice the use of <strong class="source-inline">{}</strong> in the following code:</p>
<pre class="source-code">
Student::Student(const string &amp;fn, const string &amp;ln, 
         char mi, float avg, const string &amp;course, int id)<strong class="bold">: </strong>
         firstName<strong class="bold">{</strong>fn<strong class="bold">}</strong>, lastName<strong class="bold">{</strong>ln<strong class="bold">}</strong>, middleInitial<strong class="bold">{</strong>mi<strong class="bold">}</strong>,
         gpa<strong class="bold">{</strong>avg<strong class="bold">}</strong>, currentCourse<strong class="bold">{</strong>course<strong class="bold">}</strong>, studentId<strong class="bold">{</strong>id<strong class="bold">}</strong> 
{
}</pre>
<p>The <strong class="source-inline">{}</strong> as used here were originally added for instantiation in C++ (and hence with usage within member initialization lists to fully construct data members) in an effort to provide a uniform initialization syntax. The <strong class="source-inline">{}</strong> also potentially control the narrowing of data types. However, when <strong class="source-inline">std::initializer_list</strong> is used with templates (a feature we will see in <a href="B19087_13.xhtml#_idTextAnchor561"><em class="italic">Chapter 13</em></a>, <em class="italic">Working with Templates</em>), the <strong class="source-inline">{}</strong> provides semantic confusion. Due to complexities such as these interfering with the goal of language<a id="_idIndexMarker420"/> uniformity, the next C++ standard may revert to<a id="_idIndexMarker421"/> preferring the use of <strong class="source-inline">()</strong> and so shall we. It is interesting to note that neither <strong class="source-inline">()</strong> nor <strong class="source-inline">{}</strong> has an advantage from the perspective of performance.</p>
<p>Next, let’s now move forward by adding the <strong class="source-inline">const</strong> qualifier to member functions.</p>
<h2 id="_idParaDest-118"><a id="_idTextAnchor302"/>Using const member functions</h2>
<p>We have seen<a id="_idIndexMarker422"/> the constant qualifier used quite exhaustively now with data. It can also be used in conjunction with member functions. C++ provides a language mechanism to ensure that selected functions may not modify data; this mechanism is the <strong class="source-inline">const</strong> qualifier as applied to member functions.</p>
<p>A <strong class="bold">const member function</strong> is a member function that specifies (and enforces) that the method can only perform read-only activities on the object invoking the function. </p>
<p>A constant member function means that no portion of <strong class="source-inline">this</strong> may be modified. However, because C++ allows typecasting, it is possible to cast <strong class="source-inline">this</strong> to its non-const counterpart and then change data members. However, if the class designer truly meant to be able to modify data members, they simply would not label a member function as <strong class="source-inline">const</strong>. </p>
<p>Constant instances declared in your program may only invoke <strong class="source-inline">const</strong> member functions. Otherwise, these objects could be directly modified. </p>
<p>To label a member function as <strong class="source-inline">const</strong>, the keyword <strong class="source-inline">const</strong> should be specified after the argument list in the function prototype and in the function definition.</p>
<p>Let’s see an<a id="_idIndexMarker423"/> example. It wi<a id="_idTextAnchor303"/>ll be divided into two sections with some portions omitted; however, the full example can be seen in the GitHub repository:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex10.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/master/Chapter05/Chp5-Ex10.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;  
using std::cout;   // preferred to: using namespace std;
using std::endl;
using std::string;
class Student
{
private: 
    // data members
    string firstName;
    string lastName;
    char middleInitial;
    float gpa;
    string currentCourse;
    const int studentId;   // constant data member
public:
    // member function prototypes
    Student();  // default constructor
    Student(const string &amp;, const string &amp;, char, float, 
            const string &amp;, int); 
    Student(const Student &amp;);  // copy constructor
    ~Student();  // destructor
    void Print() <strong class="bold">const</strong>;
    const string &amp;GetFirstName() <strong class="bold">const</strong> 
        { return firstName; }  
    const s<a id="_idTextAnchor304"/>tring &amp;GetLastName() <strong class="bold">const</strong> 
        { return lastName; }    
    char GetMiddleInitial() <strong class="bold">const</strong> { return middleInitial; }
    float GetGpa() <strong class="bold">const</strong> { return gpa; }
    const string &amp;GetCurrentCourse() <strong class="bold">const</strong>
        { return currentCourse; }
    int GetStudentId() <strong class="bold">const</strong> { return studentId; }
    void SetCurrentCourse(const string &amp;);  // proto. only
};</pre>
<p>In the previous program fragment, we see a class definition for <strong class="source-inline">Student</strong>, which is becoming very familiar to us. Notice, however, that we have added the <strong class="source-inline">const</strong> qualifier to most of the access member functions, that is, to those methods that are only providing read-only access to data. </p>
<p>For example, let us consider <strong class="source-inline">float GetGpa() const { return gpa; }</strong>. The <strong class="source-inline">const</strong> keyword after the argument list indicates that this is a constant member function. Notice that this function does not modify any data member pointed to by <strong class="source-inline">this</strong>. It cannot do so, as it is marked as a <strong class="source-inline">const</strong> member function.</p>
<p>Now, let’s move<a id="_idIndexMarker424"/> on to the remainder of this example:</p>
<pre class="source-code">
<strong class="bold">// Definitions for the constructors, destructor, and </strong>
<strong class="bold">// SetCurrentCourse() have been omitted to save space.</strong>
// Student::Print() has been revised, so it is shown below:
void Student::Print() <strong class="bold">const</strong>
{
    cout &lt;&lt; firstName &lt;&lt; " " &lt;&lt; middleInitial &lt;&lt; ". ";
    cout &lt;&lt; lastName &lt;&lt; " with id: " &lt;&lt; studentId;
    cout &lt;&lt; " and gpa: " &lt;&lt; gpa &lt;&lt; " is en<a id="_idTextAnchor305"/>rolled in: ";
    cout &lt;&lt; currentCourse &lt;&lt; endl;
}
int main()
{
    Student s1("Zack", "Moon", 'R', 3.75, "C++", 1378); 
    cout<a id="_idTextAnchor306"/> &lt;&lt; s1.GetFirstName() &lt;&lt; " " &lt;&lt; s1.GetLastName();
    cout &lt;&lt; " Enrolled in " &lt;&lt; s1.GetCurrentCourse();
    cout &lt;&lt; endl;
    s1.SetCurrentCourse("Advanced C++ Programming");  
    cout &lt;&lt; s1.GetFirstName() &lt;&lt; " " &lt;&lt; s1.GetLastName();
    cout &lt;&lt; " New course: " &lt;&lt; s1.GetCurrentCourse();
    cout &lt;&lt; endl;
    <strong class="bold">const</strong> Student s2("Gabby", "Doone", 'A', 4.0, 
                     "C++", 2239);
    s2.Print();
    // Not allowed, s2 is const
    // s2.SetCurrentCourse("Advanced C++ Programming");  
    return 0;
}</pre>
<p>In the remainder of this program, notice that we have again chosen not to include the definitions for member functions with which we are already familiar, such as the constructors, the destructor, and <strong class="source-inline">void Student::SetCurrentCourse()</strong>. </p>
<p>Instead, let’s focus our attention on the member function with the signature: <strong class="source-inline">void Student::Print() const</strong>. Here, the <strong class="source-inline">const</strong> keyword after the argument list indicates that no data<a id="_idIndexMarker425"/> members pointed to by <strong class="source-inline">this</strong> can be altered in the scope of this function. And none are. Likewise, any member functions called on this within <strong class="source-inline">void Student::Print()</strong> must also be <strong class="source-inline">const</strong> member functions. Otherwise, they could modify <strong class="source-inline">this</strong>.</p>
<p>Moving forward to examine our <strong class="source-inline">main()</strong> function, we instantiate a <strong class="source-inline">Student</strong>, namely <strong class="source-inline">s1</strong>. This <strong class="source-inline">Student</strong> calls several member functions, including some that are <strong class="source-inline">const</strong>. <strong class="source-inline">Student s1</strong> then changes their current course using <strong class="source-inline">Student::SetCurrentCourse()</strong>, and then the new value of this course is printed. </p>
<p>Next, we instantiate another <strong class="source-inline">Student</strong>, <strong class="source-inline">s2</strong>, which is qualified as <strong class="source-inline">const</strong>. Notice that once this student is instantiated, the only member functions that may be applied to <strong class="source-inline">s2</strong> are those that are labeled as <strong class="source-inline">const</strong>. Otherwise, the instance may be modified. We then print out data for <strong class="source-inline">s2</strong> using <strong class="source-inline">Student::Print();</strong>, which is a <strong class="source-inline">const</strong> member function.</p>
<p>Did you notice the commented-out line of code: <strong class="source-inline">s2.SetCurrentCourse("Advanced C++ Programming");</strong>? This line is illegal and would not compile, because <strong class="source-inline">SetCurrentCourse()</strong> is not a constant member function and is hence inappropriate to be called via a constant instance, such as <strong class="source-inline">s2</strong>.</p>
<p>Let’s take a look at the output for the full program example:</p>
<p class="source-code">Zack Moon Enrolled in C++</p>
<p class="source-code">Zack Moon New course: Advanced C++ Programming</p>
<p class="source-code">Gabby A. Doone with id: 2239 and gpa: 3.9 is enrolled in: C++</p>
<p>Now that we<a id="_idIndexMarker426"/> have fully explored <strong class="source-inline">const</strong> member functions, let’s continue to the final section of this chapter to delve into <strong class="source-inline">static</strong> data members and <strong class="source-inline">static</strong> member functions.</p>
<h2 id="_idParaDest-119"><a id="_idTextAnchor307"/>Utilizing static data members and static member functions</h2>
<p>Now that <a id="_idIndexMarker427"/>we <a id="_idIndexMarker428"/>have been using C++ classes to define and instantiate objects, let’s add to our knowledge of object-oriented concepts by exploring the idea of a class attribute. A data member that is intended to be shared by all instances of a particular class is known as<a id="_idIndexMarker429"/> a <strong class="bold">class attribute</strong>. </p>
<p>Typically, each instance of a given class has distinct values for each of its data members. However, on occasion, it may be useful for all instances of a given class to share one data member containing a single value. The object-oriented concept of a class attribute can be modeled in C++ using a <strong class="bold">static data member</strong>. </p>
<p>Static data members themselves are implemented as external (global) variables whose scope is tied back t<a id="_idTextAnchor308"/>o the class in question using <em class="italic">name mangling</em>. Hence, each static data member can have its scope limited to the class in question.</p>
<p>Static data members are designated in the class definition with the keyword <strong class="source-inline">static</strong> preceding the data type. To finish modeling a <strong class="source-inline">static</strong> data member, an external variable definition, outside the class, must additionally follow the <strong class="source-inline">static</strong> data member specification in the class definition. Storage for this <em class="italic">class member</em> is obtained by the external variable that comprises its underlying implementation.</p>
<p><strong class="bold">A static member function</strong> is one that encapsulates access to <strong class="source-inline">static</strong> data members within a class or structure. A <strong class="source-inline">static</strong> member function does not receive a <strong class="source-inline">this</strong> pointer, hence it may only manipulate <strong class="source-inline">static</strong> data members and other external (global) variables.</p>
<p>To indicate a <strong class="source-inline">static</strong> member function, the keyword <strong class="source-inline">static</strong> must be specified in front of the function’s return type in the member function prototype only. The keyword <strong class="source-inline">static</strong> must not appear in the member function definition. If the keyword <strong class="source-inline">static</strong> appears in the function definition, the function will additionally be <strong class="source-inline">static</strong> in the C programming sense; that is, the function will be limited in scope to the file in which it is defined.</p>
<p>Let’s take a look at an example of <strong class="source-inline">static</strong> data member and member function usage. The following example will be broken into segments, however, it will appear without any <a id="_idIndexMarker430"/>functions <a id="_idIndexMarker431"/>omitted or abbreviated, as it is the final example in this chapter. It can also be found in full in the GitHub repository:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex11.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter05/Chp5-Ex11.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;  
#include &lt;cstring&gt;   // though we'll prefer std::string, 
// one pointer data member will illustrate one last concept
using std::cout;     // preferred to: using namespace std;
using std::endl;
using std::string;
class Student
{
private: 
    // data members
    string firstName;
    string lastName;
    char middleInitial;
    float gpa;
    string currentCourse;
    const char *studentId;  // pointer to constant string
    <strong class="bold">static</strong> int numStudents; // static data member
public:
    // member function prototypes
    Student();  // default constructor
    Student(const string &amp;, const string &amp;, char, float, 
            const string &amp;, const char *); 
    Student(const Student &amp;);  // copy constructor
    ~Student();  // destructor
    void Print() const;
    const string &amp;GetFirstName() const 
        { return firstName; }  
    const string &amp;GetLastName() const { return lastName; } 
    char GetMiddleInitial() const { return middleInitial; }
    float GetGpa() const { return gpa; }
    const string &amp;GetCurrentCourse() const 
        { return currentCourse; }
    const char *GetStudentId() const { return studentId; }
    void SetCurrentCourse(const string &amp;);
    <strong class="bold">static</strong> int GetNumberStudents(); // static mbr function 
};
<strong class="bold">// definition for static data member </strong>
// (which is implemented as an external variable)
<strong class="bold">int Student::numStudents = 0;</strong>  // notice initial value of 0
                    // which is default for integral values
<strong class="bold">// Definition for static member function</strong>
<strong class="bold">inline int Student::GetNumberStudents()</strong>
{
    return numStudents;
}
inline void Student::SetCurrentCourse(const char *c) 
{
    // far easier implementation to reset using a string
    currentCourse = c;
}</pre>
<p>In the first segment <a id="_idIndexMarker432"/>of <a id="_idIndexMarker433"/>code comprising our full example, we have our <strong class="source-inline">Student</strong> class definition. In the <strong class="source-inline">private</strong> access region, we have added a data member, <strong class="source-inline">static int numStudents;</strong>, to model the object-oriented concept of a class attribute, a data member that will be shared by all instances of this class.</p>
<p>Next, notice toward the end of this class definition that we have added a <strong class="source-inline">static</strong> member function, <strong class="source-inline">static int GetNumberStudents();</strong>, to provide encapsulated access to the <strong class="source-inline">private</strong> data member <strong class="source-inline">numStudents</strong>. Note the keyword <strong class="source-inline">static</strong> is added in the prototype only. If we glance outside of the class definition to find the member function definition of <strong class="source-inline">int Student::GetNumberStudents()</strong>, we notice that there is no usage of the <strong class="source-inline">static</strong> keyword within the definition of this function itself. The body of this member function simply returns the shared <strong class="source-inline">numStudents</strong>, the static data member.</p>
<p>Also notice that just below the class definition is the external variable definition to support the implementation of the static data member: <strong class="source-inline">int Student::numStudents = 0;</strong>. Notice with this declaration the use of <strong class="source-inline">::</strong> (the scope resolution operator) to associate the class name to the identifier <strong class="source-inline">numStudents</strong>. Though this data member is implemented as an external variable, and because the data member is labeled as <strong class="source-inline">private</strong>, it may only be accessed by member functions within the <strong class="source-inline">Student</strong> class. The implementation of a <strong class="source-inline">static</strong> data member as an external variable helps us understand where the memory for this shared data comes from; it is not part of any instance of the class but stored as a separate entity in the global namespace. Also notice that the declaration <strong class="source-inline">int Student::numStudents = 0;</strong> initializes this shared variable to a value of zero.</p>
<p>As an interesting aside, notice that the data member <strong class="source-inline">studentId</strong> has been changed from a <strong class="source-inline">const int</strong> to <strong class="source-inline">const char *studentId;</strong> in this new version of our <strong class="source-inline">Student</strong> class. Keep <a id="_idIndexMarker434"/>in mind that this means <strong class="source-inline">studentId</strong> is a<a id="_idIndexMarker435"/> pointer to a constant string, not a constant pointer. Because the memory for the pointer itself is not <strong class="source-inline">const</strong>, this data member will not need to be initialized using the member initialization list, but it will require some special handling.</p>
<p>Let’s continue onward to review additional member functions comprising this class:</p>
<pre class="source-code">
// Default constructor (note member init. list usage)
// Note: firstName, lastName, currentCourse as member 
// objects (type string), will be default constructed 
// to empty strings
Student::Student(): middleInitial('\0'), gpa(0.0), 
                    studentId(nullptr)
{
    <strong class="bold">numStudents++;</strong>       // increment static counter
}
// Alternate constructor member function definition
Student::Student(const char *fn, const char *ln, char mi, 
          float avg, const char *course, const char *id): 
          firstName(fn), lastName(ln), middleInitial(mi),
          gpa(avg), currentCourse(course)
{   
    // Because studentId is a const char *, we can't change
    // value pointed to directly! We enlist temp for help.
    char *temp = new char [strl<a id="_idTextAnchor309"/>en(id) + 1];
    strcpy (temp, id);  // studentId can't be an l-value,  
    studentId = temp;   // but temp can!
    <strong class="bold">numStudents++;</strong>      // increment static counter
}
// copy constructor
Student::Student(const Student &amp;s): firstName(s.firstName),
       lastName(s.lastName),middleInitial(s.middleInitial),
       gpa(s.gpa), currentCourse(s.currentCourse)
{
    delete studentId;  // release prev. allocated studentId
    // Because studentId is a const char *, we can't change
    // value pointed to directly! Temp helps w deep copy.
    char *temp = new char [strlen(s.studentId) + 1];
    strcpy (temp, s.studentId); // studentId can't be an 
    studentId = temp;           // l-value, but temp can!
    <strong class="bold">numStudents++;</strong>    // increment static counter
}
   
Student::~Student()    // destructor definition
{   
    delete [] studentId;
    <strong class="bold">numStudents--;</strong>   // decrement static counter
}
void Student::Print() const
{
   cout &lt;&lt; firstName &lt;&lt; " " &lt;&lt; middleInitial &lt;&lt; ". ";
   cout &lt;&lt; lastName &lt;&lt; " with id: " &lt;&lt; studentId;
   cout &lt;&lt; " and gpa: " &lt;&lt; gpa &lt;&lt; " and is enrolled in: ";
   cout &lt;&lt; currentCourse &lt;&lt; endl;
}</pre>
<p>In the previous<a id="_idIndexMarker436"/> program<a id="_idIndexMarker437"/> segment of member functions, most member functions look as we’ve grown accustomed to seeing, but there are some subtle differences. </p>
<p>One difference, which relates to our <strong class="source-inline">static</strong> data member, is that <strong class="source-inline">numStudents</strong> is incremented in each of the constructors and decremented in the destructor. Since this <strong class="source-inline">static</strong> data member is shared by all instances of <strong class="source-inline">class Student</strong>, each time a new <strong class="source-inline">Student</strong> is instantiated, the counter will increase, and when an instance of a <strong class="source-inline">Student</strong> ceases to exist and its destructor is implicitly called, the counter will be decremented to reflect the removal of such an instance. In this way, <strong class="source-inline">numStudents</strong> will accurately reflect how many <strong class="source-inline">Student</strong> instances exist in our application.</p>
<p>This section of code has a few other interesting details to notice, unrelated to <strong class="source-inline">static</strong> data members and member functions. For example, in our class definition, we changed <strong class="source-inline">studentId</strong> from a <strong class="source-inline">const int</strong> to a <strong class="source-inline">const char *</strong>. This means that the data pointed to is constant, not the pointer itself, so we are not required to use the member initialization list to initialize this data member.</p>
<p>Nonetheless, in the default constructor, we choose to use the member initialization list to initialize <strong class="source-inline">studentId</strong> to a null pointer, <strong class="source-inline">nullptr</strong>. Recall that we may use the member initialization list for any data member, but we must use them to initialize <strong class="source-inline">const</strong> data members. That is, if the <strong class="source-inline">const</strong> part equates to memory that is allocated with an instance. Since the memory allocated within the instance for data member <strong class="source-inline">studentId</strong> is a pointer and the pointer part of this data member is not <strong class="source-inline">const</strong> (just the data pointed to), we do not need to use the member initialization list for this data member. We just choose to.</p>
<p>However, because <strong class="source-inline">studentId</strong> is a <strong class="source-inline">const char *</strong>, this means that the identifier <strong class="source-inline">studentId</strong> may<a id="_idIndexMarker438"/> not<a id="_idIndexMarker439"/> serve as an l-value, or be on the left-hand side of an assignment. In the alternate and copy constructors, we wish to initialize <strong class="source-inline">studentId</strong> and need the ability to use <strong class="source-inline">studentId</strong> as an l-value. But we cannot. We circumvent this dilemma by instead declaring a helper variable, <strong class="source-inline">char *temp;</strong>, and allocating it to contain the amount of memory we need to load the desired data. Then, we load the desired data into <strong class="source-inline">temp</strong>, and finally, we have <strong class="source-inline">studentId</strong> point to <strong class="source-inline">temp</strong> to establish a value for <strong class="source-inline">studentId</strong>. When we leave each constructor, the local pointer <strong class="source-inline">temp</strong> is popped off the stack; however, the memory is now captured by <strong class="source-inline">studentId</strong> and treated as <strong class="source-inline">const</strong>.</p>
<p>Lastly, in the destructor, we delete the memory associated with <strong class="source-inline">const char *studentid</strong>, using <strong class="source-inline">delete [] studentId;</strong>. It is interesting to note that in less-recent compilers, we instead needed to typecast <strong class="source-inline">studentId</strong> to a non-constant <strong class="source-inline">char *</strong>; that is, <strong class="source-inline">delete const_cast&lt;char *&gt; (studentId);</strong>, as operator <strong class="source-inline">delete()</strong> previously did not expect a constant qualified pointer.</p>
<p>Now that we have completed reviewing new details in the member functions, let us continue by examining the final portion of this program example:</p>
<pre class="source-code">
int main()
{
   Student s1("Nick", "Cole", 'S', 3.65, "C++", "1<a id="_idTextAnchor310"/>12HAV"); 
   Student s2("Alex", "Tost", 'A', 3.78, "C++", "674HOP"); 
   cout &lt;&lt; s1.GetFirstName() &lt;&lt; " " &lt;&lt; s1.GetLastName();
   cout &lt;&lt; " Enrolled in " &lt;&lt; s1.GetCurrentCourse();
   cout &lt;&lt; endl;
   cout &lt;&lt; s2.GetFirstName() &lt;&lt; " " &lt;&lt; s2.GetLastName();
   cout &lt;&lt; " Enrolled in " &lt;&lt; s2.GetCurrentCourse();
   cout &lt;&lt; endl;
   
   <strong class="bold">// call a static member function in the preferred manner</strong>
   cout &lt;&lt; "There are " &lt;&lt; <strong class="bold">Student::GetNumberStudents()</strong>; 
   cout &lt;&lt; " students" &lt;&lt; endl;
   // Though not preferable, we could also use:
   // cout &lt;&lt; "There are " &lt;&lt; s1.GetNumberStudents(); 
   // cout &lt;&lt; " students" &lt;&lt; endl;
   return 0;
}</pre>
<p>In the <strong class="source-inline">main()</strong> function<a id="_idIndexMarker440"/> of <a id="_idIndexMarker441"/>our program, we start by instantiating two <strong class="source-inline">Students</strong>, <strong class="source-inline">s1</strong> and <strong class="source-inline">s2</strong>. As each instance is initialized with a constructor, the shared data member value of <strong class="source-inline">numStudents</strong> is incremented to reflect the number of students in our application. Note that the external variable <strong class="source-inline">Student::numStudents</strong>, which holds the memory for this shared data member, was initialized to <strong class="source-inline">0</strong> when the program started with the statement earlier in our code: <strong class="source-inline">int Student::numStudents = 0;</strong>.</p>
<p>After we print out some details for each <strong class="source-inline">Student</strong>, we then print out the <strong class="source-inline">static</strong> data member <strong class="source-inline">numStudents</strong> using a <strong class="source-inline">static</strong> access function<strong class="source-inline"> Student::GetNumStudents()</strong>. The preferred way to call this function is <strong class="source-inline">Student::GetNumStudents();</strong>. Because <strong class="source-inline">numStudents</strong> is <strong class="source-inline">private</strong>, only a method of the <strong class="source-inline">Student</strong> class may access this data member. We have now provided safe, encapsulated access to a <strong class="source-inline">static</strong> data member using a <strong class="source-inline">static</strong> member function.</p>
<p>It is interesting to remember that <strong class="source-inline">static</strong> member functions do not receive a <strong class="source-inline">this</strong> pointer, therefore, the only data they may manipulate will be <strong class="source-inline">static</strong> data in the class (or other external variables). Likewise, the only other functions they may call will be other <strong class="source-inline">static</strong> member functions in the same class or external non-member functions.</p>
<p>It is also interesting to note that we can seemingly call <strong class="source-inline">Student::GetNumStudents()</strong> via any instance, such as <strong class="source-inline">s1.GetNumStudents();</strong>, as we see in the commented-out section of code. Though it seems as though we are calling the member function through an instance, the function will not receive a <strong class="source-inline">this</strong> pointer. Instead, the compiler reinterprets the call, which is seemingly through an instance, and replaces the invocation with a call to the internal, <em class="italic">name mangled</em> function. It is clearer from a programming point of view to call <strong class="source-inline">static</strong> member functions using the first calling method, and not seemingly through an instance that would never be passed along to the function itself.</p>
<p>Finally, here is the output for our full program example:</p>
<p class="source-code">Nick Cole Enrolled in C++</p>
<p class="source-code">Alex Tost Enrolled in C++</p>
<p class="source-code">There are 2 students</p>
<p>Now that we<a id="_idIndexMarker442"/> have<a id="_idIndexMarker443"/> reviewed our final example of this chapter, it is time to recap everything that we have learned.</p>
<h1 id="_idParaDest-120"><a id="_idTextAnchor311"/>Summary</h1>
<p>In this chapter, we have begun our journey with object-oriented programming. We have learned many object-oriented concepts and terms, and have seen how C++ has direct language support to implement these concepts. We have seen how C++ classes support encapsulation and information hiding, and how implementing designs supporting these ideals can lead to code that is easier to modify and maintain. </p>
<p>We have detailed class basics, including member functions. We’ve moved deeper into member functions by examining member function internals, including understanding what the <strong class="source-inline">this</strong> pointer is and how it works – including the underlying implementation of member functions that implicitly receive a <strong class="source-inline">this</strong> pointer. </p>
<p>We have explored access labels and access regions. By grouping our data members in the <strong class="source-inline">private</strong> access region and providing a suite of <strong class="source-inline">public</strong> member functions to manipulate these data members, we have found that we can provide a safe, well-controlled, and well-tested means to manipulate data from the confines of each class. We have seen that making changes to a class can be limited to the member functions themselves. The user of the class need not know the underlying representation of data members – these details are hidden and can be changed as needed without causing a wave of changes elsewhere in an application. </p>
<p>We have deeply explored the many facets of constructors, by examining default, typical (overloaded) constructors, copy constructors, and even conversion constructors. We have been introduced to the destructor, and understand its proper usage.</p>
<p>We’ve added additional flavor to our classes by using various qualifiers to both data members and member functions, such as <strong class="source-inline">inline</strong> for efficiency, <strong class="source-inline">const</strong> to safeguard data and to ensure functions will as well, <strong class="source-inline">static</strong> data members to model the OO concept of class attributes, and <strong class="source-inline">static</strong> methods to provide safe interfaces to these <strong class="source-inline">static</strong> data members. </p>
<p>By immersing ourselves in object-oriented programming, we have gained a comprehensive set of skills relating to classes in C++. With a well-rounded set of skills and experience using classes under our respective belts and an appreciation for object-oriented programming, we can now move forward with <a href="B19087_06.xhtml#_idTextAnchor314"><em class="italic">Chapter 6</em></a>, <em class="italic">Implementing Hierarchies with Single Inheritance</em>, to learn how to grow a hierarchy of related classes. Let’s move forward!</p>
<h1 id="_idParaDest-121"><a id="_idTextAnchor312"/>Questions</h1>
<ol>
<li>Create a C++ program to encapsulate a <strong class="source-inline">Student</strong>. You may use portions of your previous exercises. Try to do this yourself, rather than relying on any online code. You will need t<a id="_idTextAnchor313"/>his class as a basis to move forward with future examples; now is a good time to try each feature on your own. Incorporate the following steps:<ol><li>Create, or modify your previous <strong class="source-inline">Student</strong> class to fully encapsulate a student. Be sure to include several data members that be dynamically allocated. Provide several overloaded constructors to provide the means to initialize your class. Be sure to include a copy constructor. Also, include a destructor to release any dynamically allocated data members. </li><li>Add an assortment of access functions to your class to provide safe access to data members within your class. Decide for which data members you will offer a <strong class="source-inline">GetDataMember()</strong> interface, and whether any of these data members should have the ability to be reset after construction with a <strong class="source-inline">SetDataMember()</strong> interface. Apply the <strong class="source-inline">const</strong> and <strong class="source-inline">inline</strong> qualifiers to these methods as appropriate.</li><li>Be sure to utilize appropriate access regions – <strong class="source-inline">private</strong> for data members, and possibly for some helper member functions to break up a larger task. Add <strong class="source-inline">public</strong> member functions as necessary above and beyond your previous access functions. </li><li>Include at least one <strong class="source-inline">const</strong> data member in your class and utilize the member initialization list to set this member. Add at least one <strong class="source-inline">static</strong> data member and one <strong class="source-inline">static</strong> member function.</li><li>Instantiate a <strong class="source-inline">Student</strong> using each constructor signature, including the copy constructor. Make several instances dynamically allocated using <strong class="source-inline">new()</strong>. Be sure to <strong class="source-inline">delete()</strong> each of these instances when you are done with them (so that their destructor will be called).</li></ol></li>
</ol>
</div>
<div>
<div id="_idContainer033">
</div>
</div>
</div></body></html>