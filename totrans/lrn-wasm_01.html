<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">What is WebAssembly?</h1>
                </header>
            
            <article>
                
<p class="p1"><strong>WebAssembly</strong> (<strong>Wasm</strong>) represents an important stepping stone for the web platform.<span class="Apple-converted-space"> </span>Enabling a developer to run compiled code on the web without a plugin or browser lock-in presents many new opportunities.<span class="Apple-converted-space"> </span>Some confusion exists about what WebAssembly is, as does some skepticism about its staying power.</p>
<p class="p1"><span class="s1">I</span>n this chapter, we will discuss how WebAssembly came to be, what WebAssembly is with regard to the official definition, and the technologies it encompasses.<span class="Apple-converted-space"> </span>The potential use cases, supported languages, and limitations will be covered, as well as where to find additional information.</p>
<p class="mce-root">Our goal for this chapter is to understand the following:</p>
<ul>
<li class="mce-root">The technologies that led the way for WebAssembly</li>
<li class="mce-root">What WebAssembly is and some of its potential use cases</li>
<li class="mce-root">Which programming languages can be used with WebAssembly</li>
<li class="mce-root">The current limitations of WebAssembly</li>
<li class="mce-root">How WebAssembly relates to Emscripten and asm.js</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The road to WebAssembly</h1>
                </header>
            
            <article>
                
<p class="p1">Web development has had an interesting history, to say the least.<span class="Apple-converted-space"> </span>Several (failed) attempts have been made to expand the platform to support different languages.<span class="Apple-converted-space"> </span>Clunky solutions such as plugins failed to stand the test of time, and limiting a user to a single browser is a recipe for disaster.</p>
<p class="p1">WebAssembly was developed as an elegant solution to a problem that has existed since browsers were first able to execute code: <em>If you want to develop for the web, you have to use JavaScript</em>. Fortunately, using JavaScript doesn't have the same negative connotations it had back in the early 2000s, but it continues to have certain limitations as a programming language. In this section, we're going to discuss the technologies that led to WebAssembly to get a better grasp of why this new technology is needed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The evolution of JavaScript</h1>
                </header>
            
            <article>
                
<p>JavaScript was created by Brendan Eich in just 10 days back in 1995. Originally seen as a <em>toy</em> language by programmers, it was used primarily to make buttons flash or banners appear on a web page. The last decade has seen JavaScript evolve from a toy to a platform with profound capabilities and a massive following.</p>
<p class="p1">In 2008 heavy competition in the browser market resulted in the addition of <strong>just-in-time</strong> (<strong>JIT</strong>) compilers, which increased the execution speed of JavaScript by a factor of 10. Node.js debuted in 2009 and represented a paradigm shift in web development. Ryan Dahl combined Google's V8 JavaScript engine, an event loop, and a low-level I/O API to build a platform that allowed for the use of JavaScript across the server and client side. Node.js led to <kbd>npm</kbd>, a package manager that allowed for the development of libraries to be used within the Node.js ecosystem. As of the time of writing, there are over 600,000 packages available with hundreds being added every day:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="" src="assets/d473abb9-dda2-4db0-acfb-0a63607c8190.png"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Package count growth on npm since 2012, taken from Modulecounts</div>
<p class="mce-root">It's not just the Node.js ecosystem that is growing; JavaScript itself is being actively developed. The ECMA <strong>Technical Committee 39</strong> (<strong>TC39</strong>), which dictates the standards for JavaScript and oversees the addition of new language features, releases <em>yearly</em> updates to JavaScript with a community-driven proposal process. Between its wealth of libraries and tooling, constant improvements to the language, and possessing one of the largest communities of programmers, JavaScript has become a force to be reckoned with.</p>
<p class="mce-root">But the language does have some shortcomings:</p>
<ul>
<li class="mce-root">Up until recently, JavaScript only included 64-bit floating point numbers. This can cause issues with very large or very small numbers. <kbd>BigInt</kbd>, a new numeric primitive that can alleviate some of these issues, is in the the process of being added to the ECMAScript specification, but it may take some time until it's fully supported in browsers.</li>
<li class="mce-root">JavaScript is weakly typed, which adds to its flexibility, but can cause confusion and bugs.<span class="Apple-converted-space"> </span>It essentially gives you enough rope to hang yourself.</li>
<li class="mce-root">JavaScript isn't as performant as compiled languages despite the best efforts of the browser vendors.</li>
<li class="mce-root">If a developer wants to create a web application, they need to learn JavaScript—whether they like it or not.</li>
</ul>
<p class="p1">To avoid having to write more than a few lines of JavaScript, some developers built <strong>transpilers</strong> to convert other languages to JavaScript. Transpilers (or source-to-source compilers) are types of compilers that convert source code in one programming language to equivalent source code in another programming language. TypeScript, which is a popular tool for frontend JavaScript development, transpiles TypeScript to valid JavaScript targeted for browsers or Node.js. Pick any programming language and there's a good chance that someone created a JavaScript transpiler for it. For example, if you prefer to write Python, you have about 15 different tools that you can use to generate JavaScript. In the end, though, it's still JavaScript, so you're still subject to the idiosyncrasies of the language.</p>
<p class="p1">As the web evolved into a valid platform for building and distributing applications, more and more complex and resource-intensive applications were created.<span class="Apple-converted-space"> </span>In order to meet the demands of these applications, browser vendors began working on new technologies to integrate into their software without disrupting the normal course of web development.<span class="Apple-converted-space"> </span>Google and Mozilla, creators of Chrome and Firefox, respectively, took two different paths to achieve this goal, culminating in the creation of WebAssembly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Google and Native Client</h1>
                </header>
            
            <article>
                
<p class="p1">Google developed <strong>Native Client</strong> (<strong>NaCl</strong>) with the intent to safely run native code within a web browser.<span class="Apple-converted-space"> </span>The executable code would run in a <strong>sandbox</strong> and offered the performance advantages of native code execution.</p>
<div class="packt_infobox">In the context of software development, a sandbox is an environment that prevents executable code from interacting with other parts of your system. It is intended to prevent the spread of malicious code and place restrictions on what software can do.</div>
<p class="p1">NaCl was tied to a specific architecture, while <strong>Portable Native Client</strong> (<strong>PNaCl</strong>) was an architecture-independent version of NaCl developed to run on any platform.<span class="Apple-converted-space"> </span>The technology consisted of two elements:</p>
<ul>
<li class="p1">Toolchains which could transform C/C++ code to NaCl modules</li>
<li class="p1">Runtime components which were components embedded in the browser that allowed execution of NaCl modules:</li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ee7ab5c5-f671-4caa-8073-2c3ef941c399.png" style="width:33.83em;height:30.33em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">The Native Client toolchains and their outputs</div>
<p class="p1">NaCl's architecture-specific executable (<kbd>nexe</kbd>) was limited to applications and extensions that were installed from Google's Chrome Web Store, but PNaCl executables (<kbd>pexe</kbd>) can be freely distributed on the web and embedded in web applications.<span class="Apple-converted-space"> </span>Portability was made possible with Pepper, an open source API for creating NaCl modules, and its corresponding plugin API (PPAPI).<span class="Apple-converted-space"> </span>Pepper enabled communication between NaCl modules and the hosting browser, and allowed for access to system-level functions in a safe and portable way.<span class="Apple-converted-space"> </span>Applications could be easily distributed by including a manifest file and a compiled module (<kbd>pexe</kbd>) with the corresponding HTML, CSS, and JavaScript:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0a230248-b946-4f66-b811-ff2530fc48d1.png" style="width:25.08em;height:10.50em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Pepper's role in a Native Client application</div>
<p class="p1">NaCl offered promising opportunities to overcome the performance limitations of the web, but it had some drawbacks.<span class="Apple-converted-space"> </span>Although Chrome had built-in support for PNaCl executables and Pepper, other major browser did not.<span class="Apple-converted-space"> </span>Detractors of the technology took issue with the black-box nature of the applications as well as the potential security risks and complexity.</p>
<p class="p1">Mozilla focused its efforts on improving the performance of JavaScript with <kbd>asm.js</kbd>.<span class="Apple-converted-space"> </span>They wouldn't add support for Pepper to Firefox due to the incompleteness of its API specification and limited documentation.<span class="Apple-converted-space"> </span>In the end, NaCl was deprecated in May, 2017, in favor of WebAssembly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Mozilla and asm.js</h1>
                </header>
            
            <article>
                
<p class="p1">Mozilla debuted <kbd>asm.js</kbd> in 2013 and provided a way for developers to translate their C and C++ source code to JavaScript.<span class="Apple-converted-space"> </span>The official specification for <kbd>asm.js</kbd> defines it as a strict subset of JavaScript that can be used as a low-level, efficient target language for compilers.<span class="Apple-converted-space"> </span>It's still valid JavaScript, but the language features are limited to those that are amenable to <strong>ahead-of-time</strong> (<strong>AOT</strong>) optimization.<span class="Apple-converted-space"> </span>AOT <span>is a technique that the browser's JavaScript engine uses to execute code more efficiently by compiling it down to native machine code. </span><kbd>asm.js</kbd> achieves these performance gains by having 100% type consistency and manual memory management.</p>
<p class="mce-root"/>
<p class="p1">Using a tool such as Emscripten, C/C++ code can be transpiled down to <kbd>asm.js</kbd> and easily distributed using the same means as normal JavaScript.<span class="Apple-converted-space"> </span>Accessing the functions in an <kbd>asm.js</kbd> module requires <strong>linking</strong>, which involves calling its function to obtain an object with the module's exports.</p>
<p class="p1"><kbd>asm.js</kbd> is incredibly flexible, however, certain interactions with the module can cause a loss of performance.<span class="Apple-converted-space"> </span>For example, if an <kbd>asm.js</kbd> module is given access to a custom JavaScript function that fails dynamic or static validation, the code can't take advantage of AOT and falls back to the interpreter:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3b40bcf8-0a50-4ed5-806e-3f3a5f64679a.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The asm.js AOT compilation workflow</div>
<div>
<p class="p1"><kbd>asm.js</kbd> isn't just a stepping stone. It forms the basis for WebAssembly's <strong>Minimum Viable Product</strong> (<strong>MVP</strong>).<span class="Apple-converted-space"> </span>The official WebAssembly site explicitly mentions <kbd>asm.js</kbd> in the section entitled <em>WebAssembly High-Level Goals</em>.</p>
<p class="p1">So why create WebAssembly when you could use <kbd>asm.js</kbd>?<span class="Apple-converted-space"> </span>Aside from the potential performance loss, an <kbd>asm.js</kbd> module is a text file that must be transferred over the network before any compilation can take place.<span class="Apple-converted-space"> </span>A WebAssembly module is in a binary format, which makes it much more efficient to transfer due to its smaller size. </p>
<p>WebAssembly modules use a promise-based approach to instantiation, which takes advantage of modern JavaScript and eliminates the need for any <em>is this loaded</em> <em>yet?</em> code.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">WebAssembly is born</h1>
                </header>
            
            <article>
                
<p class="p1">The <strong>World Wide Web Consortium</strong> (<strong>W3C</strong>), an international community built to develop web standards, formed the WebAssembly Working Group in April, 2015, to standardize WebAssembly and oversee the specification and proposal process.<span class="Apple-converted-space"> </span>Since then, the <em>Core Specification</em> and corresponding <em>JavaScript API</em> and <em>Web API</em> have been released.<span class="Apple-converted-space"> </span>The initial implementation of WebAssembly support in browsers was based on the feature set of <kbd>asm.js</kbd>.<span class="Apple-converted-space"> </span>WebAssembly's binary format and corresponding <kbd>.wasm</kbd> file combined facets of <kbd>asm.js</kbd> output with PNaCl's concept of a distributed executable.</p>
<p class="p1">So how will WebAssembly succeed where NaCl failed? According to Dr. Axel Rauschmayer, there are three reasons detailed at <a href="http://2ality.com/2015/06/web-assembly.html#what-is-different-this-time">http://2ality.com/2015/06/web-assembly.html#what-is-different-this-time</a>:</p>
<div style="padding-left: 30px" class="packt_quote">"First, this is a collaborative effort, no single company goes it alone. At the moment, the following projects are involved: Firefox, Chromium, Edge and WebKit.<br/>
<br/>
<span>Second, the interoperability with the web platform and JavaScript is excellent. Using WebAssembly code from JavaScript will be as simple as importing a module.<br/>
<br/></span> <span>Third, this is not about replacing JavaScript engines, it is more about adding a new feature to them. That greatly reduces the amount of work to implement WebAssembly and should help with getting the support of the web development community."<br/>
<br/></span></div>
<div style="padding-left: 330px" class="packt_quote packt_figref CDPAlignCenter CDPAlign"><span>- Dr. Axel Rauschmayer</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What exactly is WebAssembly and where can I use it?</h1>
                </header>
            
            <article>
                
<p class="p1">WebAssembly has a succinct and descriptive definition on the official site, but it's only a piece of the puzzle.<span class="Apple-converted-space"> </span>There are several other components that fall under the umbrella of WebAssembly.<span class="Apple-converted-space"> </span>Understanding the role each component plays will give you a better understanding of the technology as a whole.<span class="Apple-converted-space"> </span>In this section, we will provide a detailed breakdown of WebAssembly's definition and describe potential use cases.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Official definition</h1>
                </header>
            
            <article>
                
<p>The official WebAssembly website (<a href="https://webassembly.org">https://webassembly.org</a>) offers this definition:</p>
<div class="packt_quote"> Wasm is a binary instruction format for a stack-based virtual machine. Wasm is designed as a portable target for compilation of high-level languages like C/C++/Rust, enabling deployment on the web for client and server applications.</div>
<p>Let's break that definition down into parts to add some clarification.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Binary instruction format</h1>
                </header>
            
            <article>
                
<p class="p1">WebAssembly actually encompasses several elements—a binary format and text format, which are documented in the <em>Core Specification</em>, the corresponding APIs (JavaScript and web), and a compilation target.<span class="Apple-converted-space"> </span>The binary and text format both map to a common structure in the form of an <strong>abstract syntax</strong>.<span class="Apple-converted-space"> </span>To better understand abstract syntax, it can be explained in the context of an <strong>abstract syntax tree</strong> (<strong>AST</strong>).<span class="Apple-converted-space"> </span>An AST is a tree representation of the structure of source code for a programming language.<span class="Apple-converted-space"> </span>Tools such as ESLint use JavaScript's AST to find linting errors.<span class="Apple-converted-space"> </span>The following example contains a function and the corresponding AST for JavaScript (taken from <a href="https://astexplorer.net">https://astexplorer.net</a>).</p>
<p>A simple JavaScript function follows:</p>
<pre style="padding-left: 60px">function doStuff(thingToDo) {<br/>  console.log(thingToDo);<br/>}</pre>
<p>The corresponding AST is as follows:</p>
<pre style="padding-left: 60px">{<br/>  "type": "Program",<br/>  "start": 0,<br/>  "end": 57,<br/>  "body": [<br/>    {<br/>      "type": "FunctionDeclaration",<br/>      "start": 9,<br/>      "end": 16,<br/>      "id": {<br/>        "type": "Identifier",<br/>        "start": 17,<br/>        "end": 26,<br/>        "name": "doStuff"<br/>      },<br/>      "generator": false,<br/>      "expression": false,<br/>      "params": [<br/>        {<br/>          "type": "Identifier",<br/>          "start": 28,<br/>          "end": 57,<br/>          "name": "thingToDo"<br/>        }<br/>      ],<br/>      "body": {<br/>        "type": "BlockStatement",<br/>        "start": 32,<br/>        "end": 55,<br/>        "body": [<br/>          {<br/>            "type": "ExpressionStatement",<br/>            "start": 32,<br/>            "end": 55,<br/>            "expression": {<br/>              "type": "CallExpression",<br/>              "start": 32,<br/>              "end": 54,<br/>              "callee": {<br/>                "type": "MemberExpression",<br/>                "start": 32,<br/>                "end": 43,<br/>                "object": {<br/>                  "type": "Identifier",<br/>                  "start": 32,<br/>                  "end": 39,<br/>                  "name": "console"<br/>                },<br/>                "property": {<br/>                  "type": "Identifier",<br/>                  "start": 40,<br/>                  "end": 43,<br/>                  "name": "log"<br/>                },<br/>                "computed": false<br/>              },<br/>              "arguments": [<br/>                {<br/>                  "type": "Identifier",<br/>                  "start": 44,<br/>                  "end": 53,<br/>                  "name": "thingToDo"<br/>                }<br/>              ]<br/>            }<br/>          }<br/>        ]<br/>      }<br/>    }<br/>  ],<br/>  "sourceType": "module"<br/>}</pre>
<p class="mce-root">An AST may be verbose, but it does an excellent job at describing the components of a program. Representing source code in an AST makes verification and compilation simple and efficient. WebAssembly code in text format is serialized into an AST and compiled to the binary format (as a <kbd>.wasm</kbd> file), which is fetched, loaded, and utilized by a web page. When the module is loaded, the browser's JavaScript engine utilizes a <strong>decoding stack</strong> to decode the <kbd>.wasm</kbd> file into an AST, perform type checking, and interpret it to execute functions. WebAssembly started as a binary instruction format for an AST. Due to the performance implications of verifying Wasm expressions that return <kbd>void</kbd>, the binary instruction format was updated to target a <strong>stack machine</strong>.</p>
<p class="mce-root">A stack machine consists of two elements: a stack and instructions. A stack is a data structure with two operations: <em>push</em> and <em>pop</em>. Items are pushed onto the stack and subsequently popped from the stack in <strong>last in, first out</strong> (<strong>LIFO</strong>) order. A stack also includes a <strong>pointer</strong>, which points to the item at the top of the stack. Instructions represent actions to perform on the items in the stack. For example, an <kbd>ADD</kbd> instruction might pop the top two items from the stack (the values <kbd>100</kbd> and <kbd>10</kbd>), and push a single item with the sum back onto the stack (the value <kbd>110</kbd>):</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/1e2d75b9-2021-4486-8049-726f6134410d.png" style="width:43.83em;height:19.58em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">A simple stack machine</div>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">WebAssembly's stack machine operates in the same way. A program counter (pointer) maintains the execution position within the code and a virtual control stack keeps track of <kbd>blocks</kbd> and <kbd>if</kbd> constructs as they are entered (pushed) and exited (popped). The instructions are executed with no reference to an AST.<span class="Apple-converted-space"> </span>Thus, the <strong>binary instruction format</strong> portion of the definition refers to a binary representation of instructions that are in a format readable by the decoding stack in the browser.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Portable target for compilation</h1>
                </header>
            
            <article>
                
<p class="p1">WebAssembly was designed from the beginning with portability in mind.<span class="Apple-converted-space"> </span>Portability in this context means that WebAssembly's binary format can be executed efficiently on a variety of operating systems and instruction set architectures, on and off the web.<span class="Apple-converted-space"> </span>The specification for WebAssembly defines portability in the context of an execution environment.<span class="Apple-converted-space"> </span>WebAssembly was designed to run efficiently in environments that meet certain characteristics, most of which are related to memory.<span class="Apple-converted-space"> </span>WebAssembly's portability can also be attributed to the absence of a specific API around the core technologies.<span class="Apple-converted-space"> </span>Instead, it defines an <kbd>import</kbd> mechanism where the set of available imports is defined by the host environment.</p>
<p class="p1">In a nutshell, this means that WebAssembly isn't tied to a specific environment, such as the web or desktop.<span class="Apple-converted-space"> </span>The WebAssembly Working Group has defined a <em>Web API</em>, but that's separate from the <em>Core Specification</em>.<span class="Apple-converted-space"> </span>The <em>Web API</em> caters to WebAssembly, not the other way around.</p>
<p class="p1">The <strong>compilation</strong> aspect of the definition indicates that WebAssembly will be simple to compile down to its binary format from source code written in high-level languages.<span class="Apple-converted-space"> </span>The MVP focuses on two languages, C and C++, but Rust can also be used given its similarities to C++. Compilation will be achieved through the use of a Clang/LLVM backend, although we'll be using Emscripten in this book to generate our Wasm modules.<span class="Apple-converted-space"> </span>The plan is to eventually add support for other languages and compilers (such as GCC), but the MVP is focused on LLVM.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The core specification</h1>
                </header>
            
            <article>
                
<p class="p1">The official definition gives some high-level insight into the overall technology, but for the sake of completeness, it's worth digging a little deeper.<span class="Apple-converted-space"> </span>WebAssembly's <em>Core Specification</em> is the official document to reference if you want to understand WebAssembly at a very granular level.<span class="Apple-converted-space"> </span>If you're interested in learning about the characteristics of the runtime structure with regard to the execution environment, check out section 4: <em>Execution</em>.<span class="Apple-converted-space"> </span>We won't cover that here, but understanding where the <em>Core Specification</em> fits in will help in establishing a complete definition of WebAssembly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Language concepts</h1>
                </header>
            
            <article>
                
<p class="p1">The <em>Core Specification</em> states WebAssembly encodes a low-level, assembly-like programming language. The specification defines the structure, execution, and validation of this language as well as the details of the binary and text formats. The language itself is structured around the following concepts:</p>
<ul>
<li><strong>Values</strong>, or rather value types that WebAssembly provides</li>
<li><strong>Instructions</strong> that are executed within the stack machine</li>
<li><strong>Traps</strong> produced under error conditions and abort execution</li>
<li><strong>Functions </strong>into which code is organized, each of which takes a sequence of values as parameters and returns a sequence of values as a result</li>
<li><strong>Tables</strong>, which are arrays of values of a particular element type (such as function references) that are selectable by the executing program</li>
<li><strong>Linear Memory</strong>, which is an array of raw bytes that can be used to store and load values</li>
<li><strong>Modules</strong>, WebAssembly binary (<kbd>.wasm</kbd> file) that contains function, tables, and linear memories</li>
<li><strong>Embedder</strong>, the mechanism by which WebAssembly can be executed in a host environment, such as a web browser</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Functions, tables, memory, and modules have direct correlations with the <em>JavaScript API</em> and are important to be aware of. These concepts describe the underlying structure of the language itself and how to write or encode WebAssembly. With regard to usage, understanding the corresponding semantic phases of WebAssembly provides a complete definition of the technology:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/52382cbb-fa93-4206-adde-c38848bf1429.png" style="width:48.75em;height:27.83em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Language concepts and their relationship</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Semantic phases</h1>
                </header>
            
            <article>
                
<p>The <em>Core Specification</em> describes the different phases an encoded module (<kbd>.wasm</kbd> file) undergoes when it is being utilized in a host environment (such as a web browser). This aspect of the specification represents how the output is handled and executed:</p>
<ul>
<li><strong>Decoding</strong>: The binary format is converted into a module</li>
<li><strong>Validation</strong>: The decoded module undergoes validation checks (such as type checking) to ensure the module is well formed and safe</li>
<li><strong>Execution, Part 1: Instantiation</strong>: A module instance, which is the dynamic representation of the module, is instantiated by initializing the <strong>Globals</strong>, <strong>Memories</strong>, and <strong>Tables</strong>, and invokes the module's <kbd>start()</kbd> function</li>
<li><strong>Execution, Part 2: Invocation</strong>: Exported functions are called from the module instance:</li>
</ul>
<p> The following diagram provides a visual representation of the semantic phases:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/51755ca6-f4c7-43b3-93d3-81575523ae30.png"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Semantic phases of module use</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The JavaScript and Web APIs</h1>
                </header>
            
            <article>
                
<p class="p1">The WebAssembly Working Group also released API specifications for interacting with JavaScript and the web, which qualifies them for inclusion in the WebAssembly technology space. The <em>JavaScript API</em> is scoped to the JavaScript language itself, without being specifically tied to an environment (for example, web browsers or Node.js). It defines classes, methods, and objects for interacting with WebAssembly and managing the compilation and instantiation processes. The <em>Web API</em> is an extension of the <em>JavaScript API</em> that defines functionality specific to web browsers. The <em>Web API</em> specification currently only defines two methods, <kbd>compileStreaming</kbd> and <kbd>instantiateStreaming</kbd>, which are convenience methods that simplify the use of Wasm modules in the browser. These will be covered in greater detail in <a href="0b30dfc9-4624-48b6-a968-0342540d1ef5.xhtml">Chapter 2</a>, <em>Elements of WebAssembly - Wat, Wasm, and the JavaScript API</em>.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">So will it replace JavaScript?</h1>
                </header>
            
            <article>
                
<p class="p1">WebAssembly's ultimate goal is not to replace JavaScript, but rather to complement it.<span class="Apple-converted-space"> </span>JavaScript's rich ecosystem and flexibility still makes it the ideal language for the web.<span class="Apple-converted-space"> </span>WebAssembly's JavaScript API makes interoperability between the two technologies relatively simple.<span class="Apple-converted-space"> </span>So will you be able to build a web application using just WebAssembly?<span class="Apple-converted-space"> </span>One of the explicit goals of WebAssembly is portability, and replicating all of JavaScript's functionality could inhibit that goal.<span class="Apple-converted-space"> </span>However, the official site includes a goal to execute and integrate well with the existing web platform, so only time will tell.<span class="Apple-converted-space"> </span>It may not be practical to write the entire code base in a language that compiles down to WebAssembly, but moving some of the application logic to Wasm modules could be beneficial in terms of performance and load times.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Where can I use it?</h1>
                </header>
            
            <article>
                
<p class="mce-root">WebAssembly's official site has an extensive list of potential use cases. I'm not going to cover them all here, but there are several that represent significant enhancements to the capabilities of the web platform:</p>
<ul>
<li class="mce-root">Image/video editing</li>
<li class="mce-root">Games</li>
<li class="mce-root">Music applications (streaming, caching)</li>
<li class="mce-root">Image recognition</li>
<li class="mce-root">Live video augmentation</li>
<li class="mce-root">VR and augmented reality</li>
</ul>
<p class="p1">Although some of these use cases are technically feasible with JavaScript, HTML, and CSS, using WebAssembly can offer significant performance gains.<span class="Apple-converted-space"> </span>Serving up a binary file (instead of a single JavaScript file) can greatly reduce the bundle size, and instantiating the Wasm module on page load speeds up code execution.</p>
<p class="p1">WebAssembly isn't just limited to the browser.<span class="Apple-converted-space"> </span>Outside the browser, you could use it to build hybrid native apps on mobile devices or perform server-side computations of untrusted code.<span class="Apple-converted-space"> </span>Using Wasm modules for phone apps could be incredibly beneficial in terms of power usage and performance.</p>
<p class="p1">WebAssembly also offers flexibility with regard to how it can be used.<span class="Apple-converted-space"> </span>You can write your entire code base in WebAssembly, although this may not be practical in its current form or in the context of a web application.<span class="Apple-converted-space"> </span>Given WebAssembly's robust JavaScript API, you could write the UI in JavaScript/HTML and use Wasm modules for functionality that doesn't directly access the DOM.<span class="Apple-converted-space"> </span>Once additional languages are supported, objects can be easily passed between the Wasm module and JavaScript code, which will greatly simplify integration and increase developer adoption.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What languages are supported?</h1>
                </header>
            
            <article>
                
<p class="p1">WebAssembly's high-level goals for their MVP was to provide roughly the same functionality as <kbd>asm.js</kbd>.<span class="Apple-converted-space"> </span>The two technologies are very closely related.<span class="Apple-converted-space"> </span>C, C++, and Rust are very popular languages that support manual memory allocation, which made them ideal candidates for the initial implementation.<span class="Apple-converted-space"> </span>In this section, we're going to provide a brief overview of each programming language.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">C and C++</h1>
                </header>
            
            <article>
                
<p class="p1">C and C++ are low-level programming languages that have been around for over 30 years.<span class="Apple-converted-space"> </span>C is procedural and doesn't inherently support object-oriented programming concepts such as classes and inheritance, but it's fast, portable, and widely used.<span class="Apple-converted-space"> </span></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="p1">C++ was built to fill the gaps in C by adding features such as operator overloading and improved type checking. Both languages consistently rank in the top 10 most popular programming languages, which make them ideally suited for the MVP:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/049542c7-ebe1-4b35-b4a1-de0ec95a532c.png" style="width:43.33em;height:25.17em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">TIOBE Very Long Term History of the top 10 programming languages</div>
<p class="mce-root">C and C++ support is also baked into Emscripten, so in addition to simplifying the compilation process, it allows you to take advantage of WebAssembly's full capabilities. It is also possible to compile C/C++ code down to a <kbd>.wasm</kbd> file using LLVM. <span>LLVM is a collection of modular and reusable compiler and toolchain technologies. In a nutshell, it's a framework that simplifies the configuration of a compilation process from source code to machine code. If you made your own programming language and would like to build a compiler, LLVM has tools to simplify the process. </span>I'll cover how to compile C/C++ into <kbd>.wasm</kbd> files using LLVM in <a href="93d51e00-521f-4908-ae9d-eeaecb58a01d.xhtml">Chapter 10</a>, <em>Advanced Tools and Upcoming Features</em>.</p>
<p>The following snippet demonstrates how to print <kbd>Hello World!</kbd> to the console using C++:</p>
<pre>#include &lt;iostream&gt;<br/><br/>int main() {<br/>    std::cout &lt;&lt; "Hello, World!\n";<br/>    return 0;<br/>}</pre>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Rust</h1>
                </header>
            
            <article>
                
<p class="mce-root">C and C++ were intended to be the primary languages used for WebAssembly, but Rust is a perfectly suitable substitute. Rust is a systems programming language that is syntactically similar to C++. It was designed with memory safety in mind, but still retains the performance advantages of C and C++. The current nightly build of Rust's compiler can generate <kbd>.wasm</kbd> files from Rust source code, so if you prefer Rust and are familiar with C++, you should be able to use Rust for most of the examples in this book.</p>
<p>The following snippet demonstrates how to print <kbd>Hello World!</kbd> to the console using Rust:</p>
<pre>fn main() {<br/>    println!("Hello World!");<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Other languages</h1>
                </header>
            
            <article>
                
<p class="mce-root">Various tooling exists to enable the use of WebAssembly with some of the other popular programming languages, although they are mostly experimental:</p>
<ul>
<li class="mce-root">C# via Blazor</li>
<li class="mce-root">Haxe via WebIDL</li>
<li class="mce-root">Java via TeaVM or Bytecoder</li>
<li class="mce-root">Kotlin via TeaVM</li>
<li class="mce-root">TypeScript via AssemblyScript</li>
</ul>
<p class="mce-root">It is also technically possible to transpile a language to C and consequently compile that to a Wasm module, but the success of compilation is contingent on the output of the transpiler. More than likely, you'd have to make significant changes to the code to get it to work.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What are the limitations?</h1>
                </header>
            
            <article>
                
<p class="mce-root">Admittedly, WebAssembly is not without its limitations. New features are being actively developed and the technology is constantly evolving, but the MVP functionality represents only a portion of WebAssembly's capabilities. In this section, we'll cover some of these limitations and how they impact the development process.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">No garbage collection</h1>
                </header>
            
            <article>
                
<p class="mce-root">WebAssembly supports a flat linear memory, which isn't a limitation per se, but requires some understanding of how to explicitly allocate memory to execute code. C and C++ were logical choices for the MVP because memory management is built into the language. The reason why some of the more popular high-level languages such as Java weren't included initially is due to something called <strong>garbage collection</strong> (<strong>GC</strong>).</p>
<p class="mce-root">GC is a form of automated memory management wherein memory occupied by objects that are no longer in use by the program is reclaimed automatically. GC is analogous to an automatic transmission on a car. It has been heavily optimized by skilled engineers to operate as efficiently as possible, but limits the amount of control the driver has. Manually allocating memory is like driving a car with a manual transmission. It affords greater control over speed and torque, but misuse or lack of experience can leave you stranded with a severely damaged car. Part of C and C++'s excellent performance and speed can be attributed to the manual allocation of memory.</p>
<p class="mce-root">GC languages allow you to program without having to worry about memory availability or allocation. JavaScript is an example of a GC language. The browser engine employs something called a mark-and-sweep algorithm to collect unreachable objects and free up the corresponding memory. Support for GC languages is currently being worked on in WebAssembly, but it's hard to say exactly when it will be completed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">No direct DOM access</h1>
                </header>
            
            <article>
                
<p>WebAssembly is unable to access the DOM, so any DOM manipulation needs to be done indirectly through JavaScript or using a tool such as Emscripten. There are plans to add the ability to reference DOM and other Web API objects directly, but that's still in the proposal phase. DOM manipulation will likely go hand in hand with GC languages, since it will allow the seamless passing of objects between WebAssembly and JavaScript code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">No support in older browsers</h1>
                </header>
            
            <article>
                
<p>Older browsers don't have the global <kbd>WebAssembly</kbd> object available to instantiate and load Wasm modules. There are experimental polyfills that utilize <kbd>asm.js</kbd> if the object isn't found, but the WebAssembly Working Group currently has no plans to create one. Since <kbd>asm.js</kbd> and WebAssembly are closely related, simply serving up an <kbd>asm.js</kbd> file if the <kbd>WebAssembly</kbd> object is unavailable will still offer performance gains while accommodating for backward compatibility. You can see which browsers currently support WebAssembly at <a href="https://caniuse.com/#feat=wasm">https://caniuse.com/#feat=wasm</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How does it relate to Emscripten?</h1>
                </header>
            
            <article>
                
<p class="mce-root">Emscripten is the source-to-source compiler that can generate <kbd>asm.js</kbd> from C and C++ source code. We'll use it as a build tool to generate the Wasm modules. In this section, we'll quickly review how Emscripten relates to WebAssembly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Emscripten's role</h1>
                </header>
            
            <article>
                
<p class="mce-root">Emscripten is an LLVM-to-JavaScript compiler, which means it takes LLVM bitcode output of a compiler such as Clang (for C and C++), and converts that to JavaScript. It isn't one specific technology, but rather a combination of technologies that work together to build, compile, and run <kbd>asm.js</kbd>. To generate Wasm modules, we'll use the <strong>Emscripten SDK</strong> (<strong>EMSDK</strong>) <span> Manager:</span></p>
<p class="mce-root CDPAlignCenter CDPAlign"><img src="assets/4d92b3fc-da38-44bc-97b4-e1be3b1fc6a3.png" style="width:31.83em;height:31.92em;"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Wasm module generation with the EMSDK</div>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The EMSDK and Binaryen</h1>
                </header>
            
            <article>
                
<p>In <a href="d03f5dbf-8b6e-49aa-96be-9bb64681be24.xhtml">Chapter 4</a>, <em>Installing the Required Dependencies</em>, we'll install the EMSDK and use it to manage the dependencies required to compile C and C++ to Wasm modules. Emscripten uses Binaryen's <kbd>asm2wasm</kbd> tool to compile the <kbd>asm.js</kbd> output by Emscripten to a <kbd>.wasm</kbd> file. Binaryen is a compiler and toolchain infrastructure library that includes tools to compile various formats to WebAssembly modules and vice versa. Understanding the inner workings of Binaryen isn't required to use WebAssembly, but it is important to be aware of the underlying technologies and how they work together. By passing certain flags into the compile command for Emscripten (<kbd>emcc</kbd>), we can pipe the resultant <kbd>asm.js</kbd> code to Binaryen to output our <kbd>.wasm</kbd> file.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, we discussed the history of WebAssembly with regard to the technologies that led to its creation. A detailed overview of the definition of WebAssembly was provided to allow for a greater understanding of the underlying technologies involved.</p>
<p class="mce-root">The <em>Core Specificati</em>on, <em>JavaScript API</em>, and <em>Web API</em> were presented as important elements of WebAssembly and demonstrate how the technology will evolve. We also reviewed potentials use cases, currently supported languages, and tools that enable the use of non-supported languages.</p>
<p class="mce-root">The limitations of WebAssembly are the absence of GC, the inability to communicate directly with the DOM, and the lack of support for older browsers. These were discussed to convey the newness of the technology and shed light on some of its shortcomings. Finally, we discussed Emscripten's role in the development process and where it fits into the WebAssembly development workflow.</p>
<p class="mce-root">In <a href="0b30dfc9-4624-48b6-a968-0342540d1ef5.xhtml"/><a href="0b30dfc9-4624-48b6-a968-0342540d1ef5.xhtml">Chapter 2</a>, <span class="cdp-organizer-chapter-title"><span class="cdp-organize-title-label"><em>Elements of WebAssembly - Wat, Wasm</em>, and <em>the JavaScript API</em>,</span></span> we'll be diving deeper into the elements that make up WebAssembly: the <strong><span>WebAssembly </span>text format</strong> (<strong>Wat</strong>), binary format (Wasm), JavaScript, and Web APIs.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li class="mce-root">Which two technologies influenced the creation of WebAssembly?</li>
<li class="mce-root">What is a stack machine and how does it relate to WebAssembly?</li>
<li class="mce-root">In what ways does WebAssembly complement JavaScript?</li>
<li class="mce-root">Which three programming languages can be compiled to Wasm modules?</li>
<li class="mce-root">What role does LLVM play with regard to WebAssembly?</li>
<li class="mce-root">What are three potential use cases for WebAssembly?</li>
<li class="mce-root">How are DOM access and GC related?</li>
<li class="mce-root">What tool does Emscripten use to generate Wasm modules?</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li class="mce-root">Official WebAssembly site: <a href="https://webassembly.org">https://webassembly.org</a></li>
<li class="mce-root">Native Client technical overview: <a href="https://developer.chrome.com/native-client/overview">https://developer.chrome.com/native-client/overview</a></li>
<li class="mce-root">The LLVM Compiler Infrastructure Project: <a href="https://llvm.org">https://llvm.org</a></li>
<li>About Emscripten: <a href="http://kripken.github.io/emscripten-site/docs/introducing_emscripten/about_emscripten.html">http://kripken.github.io/emscripten-site/docs/introducing_emscripten/about_emscripten.html</a></li>
<li>asm.js specification: <a href="http://asmjs.org/spec/latest">http://asmjs.org/spec/latest</a></li>
</ul>


            </article>

            
        </section>
    </body></html>