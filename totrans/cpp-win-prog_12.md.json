["```cpp\nnamespace SmallWindows { \n\n```", "```cpp\n  class Size; \n  extern const Size ZeroSize;  \n  class Size { \n    public: \n\n```", "```cpp\n      Size(); \n      Size(int width, int height); \n      Size(const Size& size); \n      Size& operator=(const Size& size); \n\n```", "```cpp\n      Size(const SIZE& size); \n      Size& operator=(const SIZE& size); \n      operator SIZE() const; \n\n```", "```cpp\n      bool operator==(const Size& size) const; \n      bool operator!=(const Size& size) const; \n      bool operator<(const Size& size) const; \n      bool operator<=(const Size& size) const; \n      bool operator>(const Size& size) const; \n      bool operator>=(const Size& size) const;  \n      friend Size Min(const Size& left, const Size& right); \n      friend Size Max(const Size& left, const Size& right); \n\n```", "```cpp\n      Size operator*=(double factor); \n      friend Size operator*(const Size& size, double factor); \n      friend Size operator*(double factor, const Size& size); \n\n```", "```cpp\n      Size operator*=(pair<double,double> factorPair); \n      friend Size operator*(const Size& size, \n                            pair<double,double> factorPair); \n      friend Size operator*(pair<double,double> factorPair, \n                            const Size& size); \n\n```", "```cpp\n      Size operator+=(int distance); \n      Size operator-=(int distance); \n      friend Size operator+(const Size& size, int distance); \n      friend Size operator-(const Size& size, int distance); \n\n```", "```cpp\n      Size operator+=(const Size& size); \n      Size operator-=(const Size& size); \n      friend Size operator+(const Size& left, const Size& right); \n      friend Size operator-(const Size& left, const Size& right); \n\n```", "```cpp\n      bool WriteSizeToStream(ostream& outStream) const;   \n      bool ReadSizeFromStream(istream& inStream); \n      void WriteSizeToClipboard(InfoList& infoList) const; \n      void ReadSizeFromClipboard(InfoList& infoList); \n      void WriteSizeToRegistry(String key) const; \n      void ReadSizeFromRegistry(String key, \n                                Size defaultSize = ZeroSize); \n\n```", "```cpp\n      int Width() const {return width;} \n      int Height() const {return height;} \n      int& Width() {return width;} \n      int& Height() {return height;}  \n\n    private: \n      int width, height; \n  }; \n}; \n\n```", "```cpp\n#include \"SmallWindows.h\"  \nnamespace SmallWindows { \n  Size::Size() \n   :width(0), \n\n    height(0) { \n    // Empty. \n  }  \n\n  Size::Size(int width, int height) \n   :width(width), \n    height(height) { \n    // Empty. \n  } \n\n  Size::Size(const Size& size) \n   :width(size.width), \n    height(size.height) { \n    // Empty. \n  } \n\n  Size& Size::operator=(const Size& size) { \n    if (this != &size) { \n      width = size.width; \n      height = size.height; \n    } \n    return *this; \n  } \n\n  Size::Size(const SIZE& size) \n   :width(size.cx), \n    height(size.cy) { \n    // Empty. \n  } \n\n  Size& Size::operator=(const SIZE& size) { \n    width = size.cx; \n    height = size.cy; \n    return *this; \n  } \n\n  Size::operator SIZE() const { \n    SIZE size = {width, height}; \n    return size; \n  } \n\n  bool Size::operator==(const Size& size) const { \n    return (width == size.width) && (height == size.height); \n  } \n\n  bool Size::operator!=(const Size& size) const { \n    return !(*this == size); \n  } \n\n```", "```cpp\n  bool Size::operator<(const Size& size) const { \n    return (width < size.width) || \n           ((width == size.width) && (height < size.height)); \n  }\n\n  bool Size::operator<=(const Size& size) const { \n    return ((*this < size) || (*this == size)); \n  }\n\n  bool Size::operator>(const Size& size) const { \n    return !(*this <= size); \n  }\n\n  bool Size::operator>=(const Size& size) const { \n    return !(*this < size); \n  } \n\n```", "```cpp\n  Size Min(const Size& left, const Size& right) { \n    return (left < right) ? left : right; \n  }\n\n  Size Max(const Size& left, const Size& right) { \n    return (left > right) ? left : right; \n  } \n\n```", "```cpp\n  Size Size::operator*=(double factor) { \n    width = (int) (factor * width); \n    height = (int) (factor * height); \n    return *this; \n  }  \n\n  Size operator*(const Size& size, double factor) { \n    return Size((int) (size.width * factor), \n                (int) (size.height * factor)); \n  } \n\n  Size operator*(double factor, const Size& size) { \n    return Size((int) (factor * size.width), \n                (int) (factor * size.height)); \n  } \n\n  Size Size::operator*=(pair<double,double> factorPair) { \n    width = (int) (factorPair.first * width); \n    height = (int) (factorPair.second * height); \n    return *this; \n  } \n\n  Size operator*(const Size& size, \n                 pair<double,double> factorPair) { \n    return Size((int) (size.width * factorPair.first), \n                (int) (size.height * factorPair.second)); \n  } \n\n  Size operator*(pair<double,double> factorPair, \n                 const Size& size) { \n    return Size((int) (factorPair.first * size.width), \n                (int) (factorPair.second * size.height)); \n  } \n\n  Size Size::operator+=(int distance) { \n    width += distance; \n    height += distance; \n    return *this; \n  } \n  Size Size::operator-=(int distance) { \n    width -= distance; \n    height -= distance; \n    return *this; \n  }  \n\n  Size operator+(const Size& size, int distance) { \n    return Size(size.width + distance, size.height + distance); \n  } \n\n  Size operator-(const Size& size, int distance) { \n    return Size(size.width - distance, size.height - distance); \n  } \n\n  Size Size::operator+=(const Size& size) { \n    width += size.width; \n    height += size.height; \n    return *this; \n  } \n\n  Size Size::operator-=(const Size& size) { \n    width -= size.width; \n    height -= size.height; \n    return *this; \n  } \n\n  Size operator+(const Size& left, const Size& right) { \n    return Size(left.width + right.width, \n                right.height + right.height); \n  } \n\n  Size operator-(const Size& left, const Size& right) { \n    return Size(left.width - right.width, \n                right.height - right.height); \n  } \n\n  bool Size::WriteSizeToStream(ostream& outStream) const { \n    outStream.write((char*) &width, sizeof width); \n    outStream.write((char*) &height, sizeof height); \n    return ((bool) outStream); \n  } \n\n  bool Size::ReadSizeFromStream(istream& inStream) { \n    inStream.read((char*) &width, sizeof width); \n    inStream.read((char*) &height, sizeof height); \n    return ((bool) inStream); \n  } \n\n  void Size::WriteSizeToClipboard(InfoList& infoList) const { \n    infoList.AddValue<int>(width); \n    infoList.AddValue<int>(height); \n  } \n\n  void Size::ReadSizeFromClipboard(InfoList& infoList) { \n    infoList.GetValue<int>(width); \n    infoList.GetValue<int>(height); \n  } \n\n```", "```cpp\n  void Size::WriteSizeToRegistry(String key) const { \n    SIZE sizeStruct = (SIZE) *this; \n    Registry::WriteBuffer(key, &sizeStruct, sizeof sizeStruct); \n  } \n\n```", "```cpp\n  void Size::ReadSizeFromRegistry(String key, \n                                  Size defaultSize /*=ZeroSize*/){ \n    SIZE sizeStruct, defaultSizeStruct = (SIZE) defaultSize; \n    Registry::ReadBuffer(key, &sizeStruct, sizeof sizeStruct, \n                         &defaultSizeStruct); \n    *this = Size(sizeStruct); \n  } \n  const Size ZeroSize(0, 0); \n}; \n\n```", "```cpp\nnamespace SmallWindows { \n  class Point { \n    public: \n\n```", "```cpp\n      Point(); \n      Point(int x, int y); \n      Point(const Point& point); \n\n```", "```cpp\n      Point& operator=(const Point& point); \n\n```", "```cpp\n      Point(const POINT& point); \n      Point& operator=(const POINT& point); \n      operator POINT() const; \n\n```", "```cpp\n      bool operator==(const Point& point) const; \n      bool operator!=(const Point& point) const; \n      bool operator<(const Point& point) const; \n      bool operator<=(const Point& point) const; \n      bool operator>(const Point& point) const; \n      bool operator>=(const Point& point) const;  \n      friend Point Min(const Point& left, const Point& right); \n      friend Point Max(const Point& left, const Point& right); \n\n```", "```cpp\n      Point& operator*=(double factor); \n      friend Point operator*(const Point& point, double factor); \n      friend Point operator*(double factor, const Point& point); \n\n```", "```cpp\n      Point& operator*=(pair<double,double> factorPair); \n      friend Point operator*(const Point& point, \n                             pair<double,double> factorPair); \n      friend Point operator*(pair<double,double> factorPair, \n                             const Point& point); \n\n```", "```cpp\n      Point& operator+=(const int distance); \n      Point& operator-=(const int distance); \n      friend Point operator+(const Point& left, int distance); \n      friend Point operator-(const Point& left, int distance); \n\n```", "```cpp\n      Point& operator+=(const Size& size); \n      Point& operator-=(const Size& size); \n      friend Point operator+(const Point& point,const Size& size); \n      friend Point operator-(const Point& point,const Size& size); \n\n```", "```cpp\n      Point& operator+=(const Point& point); \n      Point& operator-=(const Point& point); \n      friend Point operator+(const Point&left, const Point&right); \n      friend Size operator-(const Point& left, const Point&right); \n\n```", "```cpp\n      bool WritePointToStream(ostream& outStream) const; \n      bool ReadPointFromStream(istream& inStream); \n      void WritePointToClipboard(InfoList& infoList) const; \n      void ReadPointFromClipboard(InfoList& infoList); \n      void WritePointToRegistry(String key) const;  \n      void ReadPointFromRegistry(String key, \n                            Point defaultPoint /* = ZeroPoint */); \n\n```", "```cpp\n      int X() const {return x;} \n      int Y() const {return y;} \n      int& X() {return x;} \n      int& Y() {return y;} \n\n    private: \n      int x, y; \n  }; \n\n  extern const Point ZeroPoint; \n}; \n\n```", "```cpp\n#include \"SmallWindows.h\"\n\nnamespace SmallWindows { \n  Point::Point() \n   :x(0), y(0) { \n    // Empty. \n  } \n\n  Point::Point(int x, int y) \n   :x(x), y(y) { \n    // Empty. \n  } \n\n  Point::Point(const Point& point) \n   :x(point.x), \n    y(point.y) { \n    // Empty. \n  } \n\n```", "```cpp\n  Point& Point::operator=(const Point& point) { \n    if (this != &point) { \n      x = point.x; \n      y = point.y; \n    } \n\n    return *this; \n  } \n\n  Point::Point(const POINT& point) \n   :x(point.x), \n    y(point.y) { \n    // Empty. \n  } \n\n  Point& Point::operator=(const POINT& point) { \n    x = point.x; \n    y = point.y; \n    return *this; \n  } \n\n  Point::operator POINT() const { \n    POINT point = {x, y}; \n    return point; \n  } \n\n  bool Point::operator==(const Point& point) const { \n    return ((x == point.x) && (y == point.y)); \n  } \n\n  bool Point::operator!=(const Point& point) const { \n    return !(*this == point); \n  } \n\n  bool Point::operator<(const Point& point) const { \n    return (x < point.x) || ((x == point.x) && (y < point.y)); \n  } \n\n  bool Point::operator<=(const Point& point) const { \n    return ((*this < point) || (*this == point)); \n  } \n\n  bool Point::operator>(const Point& point) const { \n    return !(*this <= point); \n  } \n\n  bool Point::operator>=(const Point& point) const { \n    return !(*this < point); \n  } \n\n  Point Min(const Point& left, const Point& right) { \n    return (left < right) ? left : right; \n  } \n\n  Point Max(const Point& left, const Point& right) { \n    return (left > right) ? left : right; \n  } \n\n  Point& Point::operator*=(double factor) { \n    x = (int) (factor * x); \n    y = (int) (factor * y); \n    return *this; \n  } \n\n  Point operator*(const Point& point, double factor) { \n    return Point((int) (point.x * factor), \n                 (int) (point.y * factor)); \n  } \n\n  Point operator*(double factor, const Point& point) { \n    return Point((int) (factor * point.x), \n                 (int) (factor * point.y)); \n  } \n\n  Point& Point::operator*=(pair<double,double> factorPair) { \n    x = (int) (factorPair.first * x); \n    y = (int) (factorPair.second * y); \n    return *this; \n  } \n\n  Point operator*(const Point& point, \n                  pair<double,double> factorPair) { \n    return Point((int) (point.x * factorPair.first), \n                 (int) (point.y * factorPair.second)); \n  } \n\n  Point operator*(pair<double,double> factorPair, \n                  const Point& point) { \n    return Point((int) (factorPair.first * point.x), \n                 (int) (factorPair.second * point.y)); \n  } \n\n  Point& Point::operator+=(const int distance) { \n    x += distance; \n    y += distance; \n    return *this; \n  } \n\n  Point& Point::operator-=(const int distance) { \n    x -= distance; \n    y -= distance; \n    return *this; \n  } \n\n  Point& Point::operator+=(const Size& size) { \n    x += size.Width(); \n    y += size.Height(); \n    return *this; \n  } \n\n  Point& Point::operator-=(const Size& size) { \n    x -= size.Width(); \n    y -= size.Height(); \n    return *this; \n  } \n\n  Point& Point::operator+=(const Point& point) { \n    x += point.x; \n    y += point.y; \n    return *this; \n  } \n\n  Point& Point::operator-=(const Point& point) { \n    x -= point.x; \n    y -= point.y; \n    return *this; \n  } \n\n  Point operator+(const Point& left, int distance) { \n    return Point(left.x + distance, left.y + distance); \n  } \n\n  Point operator-(const Point& left, int distance) { \n    return Point(left.x - distance, left.y - distance); \n  } \n\n  Point operator+(const Point& point, const Size& size) { \n    return Point(point.x + size.Width(), point.y + size.Height()); \n  } \n\n  Point operator-(const Point& point, const Size& size) { \n    return Point(point.x - size.Width(), point.y - size.Height()); \n  } \n\n  Point operator+(const Point& left, const Point& right) { \n    return Point(left.x + right.x, left.y + right.y); \n  } \n\n  Size operator-(const Point& left, const Point& right) { \n    return Size(left.x - right.x, left.y - right.y); \n  } \n\n  bool Point::WritePointToStream(ostream& outStream) const { \n    outStream.write((char*) &x, sizeof x); \n    outStream.write((char*) &y, sizeof y); \n    return ((bool) outStream); \n  } \n\n  bool Point::ReadPointFromStream(istream& inStream) { \n    inStream.read((char*) &x, sizeof x); \n    inStream.read((char*) &y, sizeof y); \n    return ((bool) inStream); \n  } \n\n  void Point::WritePointToClipboard(InfoList& infoList) const { \n    infoList.AddValue<int>(x); \n    infoList.AddValue<int>(y); \n  } \n\n  void Point::ReadPointFromClipboard(InfoList& infoList) { \n    infoList.GetValue<int>(x); \n    infoList.GetValue<int>(y); \n  } \n\n  void Point::WritePointToRegistry(String key) const { \n    POINT pointStruct = (POINT) *this; \n    Registry::WriteBuffer(key, &pointStruct, sizeof pointStruct); \n  } \n\n  void Point::ReadPointFromRegistry(String key, \n                           Point defaultPoint /* = ZeroPoint */) { \n    POINT pointStruct, defaultPointStruct = (POINT) defaultPoint; \n    Registry::ReadBuffer(key, &pointStruct, sizeof pointStruct, \n                         &defaultPointStruct); \n    *this = Point(pointStruct); \n  } \n\n  const Point ZeroPoint(0, 0); \n}; \n\n```", "```cpp\nnamespace SmallWindows { \n  class Rect; \n  extern const Rect ZeroRect; \n\n  class Rect { \n    public: \n\n```", "```cpp\n      Rect(); \n      Rect(int left, int top, int right, int bottom); \n      Rect(const Rect& rect); \n      Rect& operator=(const Rect& rect); \n      Rect(Point topLeft, Point bottomRight); \n      Rect(Point topLeft, Size size); \n\n```", "```cpp\n      Rect(const RECT& rect); \n      Rect& operator=(const RECT& rect); \n      operator RECT() const; \n\n```", "```cpp\n      bool operator==(const Rect& rect) const; \n      bool operator!=(const Rect& rect) const; \n      bool operator<(const Rect& rect) const; \n      bool operator<=(const Rect& rect) const; \n      bool operator>(const Rect& rect) const; \n      bool operator>=(const Rect& rect) const; \n\n```", "```cpp\n      Rect& operator*=(double factor); \n      friend Rect operator*(const Rect& rect, double factor); \n      friend Rect operator*(double factor, const Rect& rect); \n\n```", "```cpp\n      Rect& operator*=(pair<double,double> factorPair); \n      friend Rect operator*(const Rect& rect, \n                            pair<double,double> factorPair); \n      friend Rect operator*(pair<double,double> factorPair, \n                            const Rect& rect); \n\n```", "```cpp\n      Rect& operator+=(const Size& size); \n      Rect& operator-=(const Size& size); \n\n```", "```cpp\n      friend Rect operator+(const Rect& rect, const Size& size); \n      friend Rect operator-(const Rect& rect, const Size& size); \n\n```", "```cpp\n      Rect& operator+=(const Point& point); \n      Rect& operator-=(const Point& point); \n      friend Rect operator+(const Rect& rect, const Point& point); \n      friend Rect operator+(const Point& point, const Rect& rect); \n      friend Rect operator-(const Rect& rect, const Point& point); \n\n```", "```cpp\n      int Width() const {return abs(right - left);} \n      int Height() const {return abs(bottom - top);} \n\n```", "```cpp\n      Size GetSize() const {return Size(Width(), Height());} \n      operator Size() const {return GetSize();} \n      operator Point() const {return TopLeft();} \n\n```", "```cpp\n      Point TopLeft() const {return Point(left, top);} \n      Point BottomRight() const {return Point(right, bottom);} \n\n      void SetTopLeft(Point topLeft) {left = topLeft.X(); \n                                      right = topLeft.Y();} \n      void SetBottomRight(Point bottomRight) \n                         {right = bottomRight.X(); \n                          bottom = bottomRight.Y();} \n\n```", "```cpp\n      void Clear(); \n      void Normalize(); \n      bool PointInside(Point point) const; \n\n```", "```cpp\n      bool WriteRectToStream(ostream& outStream) const; \n      bool ReadRectFromStream(istream& inStream); \n      void WriteRectToClipboard(InfoList& infoList) const; \n      void ReadRectFromClipboard(InfoList& infoList); \n      void WriteRectToRegistry(String key) const; \n      void ReadRectFromRegistry(String key, \n                                Rect defaultRect = ZeroRect); \n\n```", "```cpp\n      int Left() const {return left;} \n      int Right() const {return right;} \n      int Top() const {return top;} \n      int Bottom() const {return bottom;} \n\n      int& Left() {return left;} \n      int& Right() {return right;} \n      int& Top() {return top;} \n      int& Bottom() {return bottom;} \n\n    private: \n      int left, top, right, bottom; \n  }; \n}; \n\n```", "```cpp\n#include \"SmallWindows.h\"\n\nnamespace SmallWindows { \n  Rect::Rect() \n   :left(0), top(0), right(0), bottom(0) { \n    // Empty. \n  } \n\n  Rect::Rect(int left, int top, int right, int bottom) \n   :left(left), \n    top(top), \n    right(right), \n    bottom(bottom) { \n    // Empty. \n  } \n\n  Rect::Rect(const Rect& rect) \n   :left(rect.left), \n    top(rect.top), \n    right(rect.right), \n    bottom(rect.bottom) { \n    // Empty. \n  } \n\n  Rect& Rect::operator=(const Rect& rect) { \n    if (this != &rect) { \n      left = rect.left; \n      top = rect.top; \n      right = rect.right; \n      bottom = rect.bottom; \n    } \n\n    return *this; \n  } \n\n  Rect::Rect(Point topLeft, Point bottomRight) \n   :left(topLeft.X()), \n    top(topLeft.Y()), \n    right(bottomRight.X()), \n    bottom(bottomRight.Y()) { \n    // Empty. \n  } \n\n  Rect::Rect(Point topLeft, Size size) \n   :left(topLeft.X()), \n    top(topLeft.Y()), \n    right(topLeft.X() + size.Width()), \n    bottom(topLeft.Y() + size.Height()) { \n    // Empty. \n  } \n\n  Rect::Rect(const RECT& rect) \n   :left(rect.left), \n    top(rect.top), \n    right(rect.right), \n    bottom(rect.bottom) { \n    // Empty. \n  } \n\n  Rect& Rect::operator=(const RECT& rect) { \n    left = rect.left; \n    top = rect.top; \n    right = rect.right; \n    bottom = rect.bottom; \n    return *this; \n  } \n\n  Rect::operator RECT() const { \n    RECT rect = {left, top, right, bottom}; \n    return rect; \n  } \n\n  bool Rect::operator==(const Rect& rect) const { \n    return (left == rect.left) && (top == rect.top) && \n           (right == rect.right) && (bottom == rect.bottom); \n  } \n\n  bool Rect::operator!=(const Rect& rect) const { \n    return !(*this == rect); \n  } \n\n  bool Rect::operator<(const Rect& rect) const { \n    return (TopLeft() < rect.TopLeft()) || \n           ((TopLeft() == rect.TopLeft()) && \n            (BottomRight() < rect.BottomRight())); \n  } \n\n  bool Rect::operator<=(const Rect& rect) const { \n    return ((*this < rect) || (*this == rect)); \n  } \n\n  bool Rect::operator>(const Rect& rect) const { \n    return !(*this <= rect); \n  } \n\n  bool Rect::operator>=(const Rect& rect) const { \n    return !(*this < rect); \n  } \n\n  Rect& Rect::operator*=(double factor) { \n    left = (int) (factor * left); \n    top = (int) (factor * top); \n    right = (int) (factor * right); \n    bottom = (int) (factor * bottom); \n    return *this; \n  } \n\n  Rect operator*(const Rect& rect, double factor) { \n    return Rect(rect.TopLeft() * factor, \n                rect.BottomRight() * factor); \n  } \n\n  Rect operator*(double factor, const Rect& rect) { \n    return Rect(factor * rect.TopLeft(), \n                factor * rect.BottomRight()); \n  } \n\n  Rect& Rect::operator*=(pair<double,double> factorPair) { \n    left = (int) (factorPair.first * left); \n    top = (int) (factorPair.second * top); \n    right = (int) (factorPair.first * right); \n    bottom = (int) (factorPair.second * bottom); \n    return *this; \n  } \n\n  Rect operator*(const Rect& rect, \n                 pair<double,double> factorPair) { \n    return Rect(rect.TopLeft() * factorPair, \n                rect.BottomRight() * factorPair); \n  } \n\n  Rect operator*(pair<double,double> factorPair, \n                 const Rect& rect) { \n    return Rect(factorPair * rect.TopLeft(), \n                factorPair * rect.BottomRight()); \n  } \n\n  Rect& Rect::operator+=(const Size& size) { \n    right += size.Width(); \n    bottom += size.Height(); \n    return *this; \n  } \n\n  Rect& Rect::operator-=(const Size& size) { \n    left -= size.Width(); \n    top -= size.Height(); \n    return *this; \n  } \n\n  Rect operator+(const Rect& rect, const Size& size) { \n    return Rect(rect.left + size.Width(), \n                rect.top + size.Height(), \n                rect.right + size.Width(), \n                rect.bottom + size.Height()); \n  } \n\n  Rect operator-(const Rect& rect, const Size& size) { \n    return Rect(rect.left - size.Width(), \n                rect.top - size.Height(), \n                rect.right - size.Width(), \n                rect.bottom - size.Height()); \n  } \n\n  Rect& Rect::operator+=(const Point& point) { \n    left += point.X(); \n    top += point.Y(); \n    right += point.X(); \n    bottom += point.Y(); \n    return *this; \n  } \n\n  Rect& Rect::operator-=(const Point& point) { \n    left -= point.X(); \n    top -= point.Y(); \n    right -= point.X(); \n    bottom -= point.Y(); \n    return *this; \n  } \n\n  Rect operator+(const Rect& rect, const Point& point) { \n    return Rect(rect.left + point.X(), rect.top + point.Y(), \n                rect.right + point.X(), rect.bottom + point.Y()); \n  } \n\n  Rect operator+(const Point& point, const Rect& rect) { \n    return Rect(point.X() + rect.left, point.Y() + rect.top, \n                point.X() + rect.right, point.Y() + rect.bottom); \n  } \n\n  Rect operator-(const Rect& rect, const Point& point) { \n    return Rect(rect.left - point.X(), rect.top - point.Y(), \n                rect.right - point.X(), rect.bottom - point.Y()); \n  }  \n\n  void Rect::Clear() { \n    left = top = right = bottom = 0; \n  }  \n\n  void Rect::Normalize() { \n    int minX = min(left, right), minY = min(top, bottom), \n        maxX = max(left, right), maxY = max(top, bottom);  \n    left = minX; \n    top = minY; \n    right = maxX; \n    bottom = maxY; \n  } \n\n  bool Rect::PointInside(Point point) const { \n    return ((left <= point.X()) && (point.X() <= right) && \n            (top <= point.Y()) && (point.Y() <= bottom)); \n  } \n\n  bool Rect::WriteRectToStream(ostream& outStream) const { \n    outStream.write((char*) &left, sizeof left); \n    outStream.write((char*) &top, sizeof top); \n    outStream.write((char*) &right, sizeof right); \n    outStream.write((char*) &bottom, sizeof bottom); \n    return ((bool) outStream); \n  } \n\n  bool Rect::ReadRectFromStream(istream& inStream) { \n    inStream.read((char*) &left, sizeof left); \n    inStream.read((char*) &top, sizeof top); \n    inStream.read((char*) &right, sizeof right); \n    inStream.read((char*) &bottom, sizeof bottom); \n    return ((bool) inStream); \n  } \n\n  void Rect::WriteRectToClipboard(InfoList& infoList) const { \n    infoList.AddValue<int>(left); \n    infoList.AddValue<int>(top); \n    infoList.AddValue<int>(right); \n    infoList.AddValue<int>(bottom); \n  }  \n\n  void Rect::ReadRectFromClipboard(InfoList& infoList) { \n    infoList.GetValue<int>(left); \n    infoList.GetValue<int>(top); \n    infoList.GetValue<int>(right); \n    infoList.GetValue<int>(bottom); \n  } \n\n  void Rect::WriteRectToRegistry(String key) const { \n    RECT pointStruct = (RECT) *this; \n    Registry::WriteBuffer(key, &pointStruct, sizeof pointStruct); \n  } \n\n  void Rect::ReadRectFromRegistry(String key, \n                             Rect defaultRect /* = ZeroRect */) { \n    RECT rectStruct, defaultRectStruct = (RECT) defaultRect; \n    Registry::ReadBuffer(key, &rectStruct, sizeof rectStruct, \n                         &defaultRectStruct); \n    *this = Rect(rectStruct); \n  } \n\n  const Rect ZeroRect(0, 0, 0, 0); \n}; \n\n```", "```cpp\nnamespace SmallWindows { \n  class Color; \n  extern const Color SystemColor; \n\n```", "```cpp\n  class Color { \n    public: \n      Color(); \n      Color(int red, int green, int blue); \n      Color(const Color& color); \n      Color& operator=(const Color& color); \n\n```", "```cpp\n      bool operator==(const Color& color) const; \n      bool operator!=(const Color& color) const; \n\n```", "```cpp\n      Color Inverse(); \n      void GrayScale(); \n\n```", "```cpp\n      bool WriteColorToStream(ostream& outStream) const; \n      bool ReadColorFromStream(istream& inStream); \n      void WriteColorToClipboard(InfoList& infoList) const; \n      void ReadColorFromClipboard(InfoList& infoList); \n      void WriteColorToRegistry(String key) const; \n      void ReadColorFromRegistry(String key, \n                                 Color defaultColor =SystemColor); \n\n```", "```cpp\n      COLORREF ColorRef() const {return colorRef;} \n      COLORREF& ColorRef() {return colorRef;} \n\n    private: \n      COLORREF colorRef; \n  }; \n\n```", "```cpp\n  extern const Color \n    AliceBlue, AntiqueWhite, Aqua, Aquamarine, \n    Azure, Beige, Bisque, Black, BlanchedAlmond, \n    Blue, BlueViolet, Brown, Burlywood, CadetBlue, \n    Chartreuse, Chocolate, Coral, CornflowerBlue, \n    Cornsilk, Crimson, Cyan, DarkBlue, DarkCyan, \n    DarkGoldenRod, DarkGray, DarkGreen, DarkKhaki, \n    DarkMagenta, DarkOliveGreen, DarkOrange, DarkOrchid, \n    DarkRed, DarkSalmon, DarkSeaGreen, DarkSlateBlue, \n    DarkSlateGray, DarkTurquoise, DarkViolet, DeepPink, \n    DeepSkyBlue, DimGray, DodgerBlue, FireBrick, \n    FloralWhite, ForestGreen, Fuchsia, Gainsboro, \n    GhostWhite, Gold, GoldenRod, Gray, Green, GreenYellow, \n    HoneyDew, HotPink, IndianRed, Indigo, Ivory, Khaki, \n    Lavender, LavenderBlush, Lawngreen, LemonChiffon, \n    LightBlue, LightCoral, LightCyan, LightGoldenRodYellow, \n    LightGreen, LightGray, LightPink, LightSalmon, \n    LightSeaGreen, LightSkyBlue, LightSlateGray, \n    LightSteelBlue, LightYellow, Lime, LimeGreen, Linen, \n    Magenta, Maroon, MediumAquamarine, MediumBlue, \n    MediumOrchid, MediumPurple, MediumSeaGreen, \n    MediumSlateBlue, MediumSpringGreen, MediumTurquoise, \n    MediumVioletRed, MidnightBlue, MintCream, MistyRose, \n    Moccasin, NavajoWhite, Navy, Navyblue, OldLace, Olive, \n    OliveDrab, Orange, OrangeRed, Orchid, PaleGoldenRod, \n    PaleGreen, PaleTurquoise, PaleVioletRed, PapayaWhip, \n    PeachPuff, Peru, Pink, Plum, PowderBlue, Purple, \n    Red, RosyBrown, RoyalBlue, SaddleBrown, Salmon, \n    SandyBrown, SeaGreen, SeaShell, Sienna, Silver, SkyBlue, \n    SlateBlue, SlateGray, Snow, SpringGreen, SteelBlue, \n    SystemColor, Tan, Teal, Thistle, Tomato, Turquoise, \n    Violet, Wheat, White, WhiteSmoke, Yellow, YellowGreen; \n}; \n\n```", "```cpp\n#include \"SmallWindows.h\" \n\nnamespace SmallWindows { \n  Color::Color() \n   :colorRef(RGB(0, 0, 0)) { \n    // Empty. \n  } \n\n  Color::Color(COLORREF colorRef) \n   :colorRef(colorRef) { \n    // Empty. \n  } \n\n  Color::Color(int red, int green, int blue) \n   :colorRef(RGB(red, green, blue)) { \n    // Empty. \n  } \n\n  Color::Color(const Color& color) \n   :colorRef(color.colorRef) { \n    // Empty. \n  } \n\n  Color& Color::operator=(const Color& color) { \n    if (this != &color) { \n      colorRef = color.colorRef; \n    } \n\n    return *this; \n  } \n\n```", "```cpp\n  bool Color::operator==(const Color& color) const { \n    return (colorRef == color.colorRef); \n  } \n\n  bool Color::operator!=(const Color& color) const { \n    return !(*this == color); \n  } \n\n```", "```cpp\n  Color Color::Inverse() { \n    int inverseRed = 255 - GetRValue(colorRef); \n    int inverseGreen = 255 - GetGValue(colorRef); \n    int inverseBlue = 255 - GetBValue(colorRef); \n    return Color(inverseRed, inverseGreen, inverseBlue); \n  } \n\n  void Color::GrayScale() { \n    int red = GetRValue(colorRef); \n    int green = GetGValue(colorRef); \n    int blue = GetBValue(colorRef); \n\n    int average = (red + green + blue) / 3; \n    colorRef = RGB(average, average, average); \n  } \n\n  bool Color::WriteColorToStream(ostream& outStream) const { \n    outStream.write((char*) &colorRef, sizeof colorRef); \n    return ((bool) outStream); \n  } \n\n  bool Color::ReadColorFromStream(istream& inStream) { \n    inStream.read((char*) &colorRef, sizeof colorRef); \n    return ((bool) inStream); \n  } \n\n  void Color::WriteColorToClipboard(InfoList& infoList) const { \n    infoList.AddValue<COLORREF>(colorRef); \n  } \n\n  void Color::ReadColorFromClipboard(InfoList& infoList) { \n    infoList.GetValue<COLORREF>(colorRef); \n  } \n\n  void Color::WriteColorToRegistry(String key) const { \n    Registry::WriteBuffer(key, &colorRef, sizeof colorRef); \n  } \n\n  void Color::ReadColorFromRegistry(String key, \n                           Color defaultColor /*=SystemColor */) { \n    Registry::ReadBuffer(key, &colorRef, sizeof colorRef, \n                         &defaultColor.colorRef); \n  } \n\n```", "```cpp\n  const Color \n    AliceBlue(240, 248, 255), AntiqueWhite(250, 235, 215), \n    Aqua(0, 255, 255), Aquamarine(127, 255, 212), \n    Azure(240, 255, 255), Beige(245, 245, 220), \n    Bisque(255, 228, 196), Black(0, 0, 0), \n    BlanchedAlmond(255, 255, 205), Blue(0, 0, 255), \n    BlueViolet(138, 43, 226), Brown(165, 42, 42), \n    Burlywood(222, 184, 135), CadetBlue(95, 158, 160), \n    Chartreuse(127, 255, 0), Chocolate(210, 105, 30), \n    Coral(255, 127, 80), CornflowerBlue(100, 149, 237), \n    Cornsilk(255, 248, 220), Crimson(220, 20, 60), \n    Cyan(0, 255, 255), DarkBlue(0, 0, 139), \n    DarkCyan(0, 139, 139), DarkGoldenRod(184, 134, 11), \n    DarkGray(169, 169, 169), DarkGreen(0, 100, 0), \n    DarkKhaki(189, 183, 107), DarkMagenta(139, 0, 139), \n    DarkOliveGreen(85, 107, 47), DarkOrange(255, 140, 0), \n    DarkOrchid(153, 50, 204), DarkRed(139, 0, 0), \n    DarkSalmon(233, 150, 122), DarkSeaGreen(143, 188, 143), \n    DarkSlateBlue(72, 61, 139), DarkSlateGray(47, 79, 79), \n    DarkTurquoise(0, 206, 209), DarkViolet(148, 0, 211), \n    DeepPink(255, 20, 147), DeepSkyBlue(0, 191, 255), \n    DimGray(105, 105, 105), DodgerBlue(30, 144, 255), \n    FireBrick(178, 34, 34), FloralWhite(255, 250, 240), \n    ForestGreen(34, 139, 34), Fuchsia(255, 0, 255), \n    Gainsboro(220, 220, 220), GhostWhite(248, 248, 255), \n    Gold(255, 215, 0),  GoldenRod(218, 165, 32), \n    Gray(127, 127, 127), Green(0, 128, 0), \n    GreenYellow(173, 255, 47), HoneyDew(240, 255, 240), \n    HotPink(255, 105, 180), IndianRed(205, 92, 92), \n    Indigo(75, 0, 130), Ivory(255, 255, 240), \n    Khaki(240, 230, 140), Lavender(230, 230, 250), \n    LavenderBlush(255, 240, 245), Lawngreen(124, 252, 0), \n    LemonChiffon(255, 250, 205), LightBlue(173, 216, 230), \n    LightCoral(240, 128, 128), LightCyan(224, 255, 255), \n    LightGoldenRodYellow(250, 250, 210), \n    LightGreen(144, 238, 144), LightGray(211, 211, 211), \n    LightPink(255, 182, 193), LightSalmon(255, 160, 122), \n    LightSeaGreen(32, 178, 170), LightSkyBlue(135, 206, 250), \n    LightSlateGray(119, 136, 153), LightSteelBlue(176, 196, 222), \n    LightYellow(255, 255, 224), Lime(0, 255, 0), \n    LimeGreen(50, 205, 50), Linen(250, 240, 230), \n    Magenta(255, 0, 255), Maroon(128, 0, 0), \n    MediumAquamarine(102, 205, 170), MediumBlue(0, 0, 205), \n    MediumOrchid(186, 85, 211), MediumPurple(147, 112, 219), \n    MediumSeaGreen(60, 179, 113), MediumSlateBlue(123, 104, 238), \n    MediumSpringGreen(0, 250, 154), MediumTurquoise(72, 209, 204), \n    MediumVioletRed(199, 21, 133), MidnightBlue(25, 25, 112), \n    MintCream(245, 255, 250), MistyRose(255, 228, 225), \n    Moccasin(255, 228, 181), NavajoWhite(255, 222, 173), \n    Navy(0, 0, 128), Navyblue(159, 175, 223), \n    OldLace(253, 245, 230), Olive(128, 128, 0), \n    OliveDrab(107, 142, 35), Orange(255, 165, 0), \n    OrangeRed(255, 69, 0), Orchid(218, 112, 214), \n    PaleGoldenRod(238, 232, 170), PaleGreen(152, 251, 152), \n    PaleTurquoise(175, 238, 238), PaleVioletRed(219, 112, 147), \n    PapayaWhip(255, 239, 213), PeachPuff(255, 218, 185), \n    Peru(205, 133, 63), Pink(255, 192, 203), \n    Plum(221, 160, 221), PowderBlue(176, 224, 230), \n    Purple(128, 0, 128), Red(255, 0, 0), \n    RosyBrown(188, 143, 143), RoyalBlue(65, 105, 225), \n    SaddleBrown(139, 69, 19), Salmon(250, 128, 114), \n    SandyBrown(244, 164, 96), SeaGreen(46, 139, 87), \n    SeaShell(255, 245, 238), Sienna(160, 82, 45), \n    Silver(192, 192, 192), SkyBlue(135, 206, 235), \n    SlateBlue(106, 90, 205), SlateGray(112, 128, 144), \n    Snow(255, 250, 250), SpringGreen(0, 255, 127), \n    SteelBlue(70, 130, 180), SystemColor(0, 0, 0), \n    Tan(210, 180, 140), Teal(0, 128, 128), \n    Thistle(216, 191, 216), Tomato(255, 99, 71), \n    Turquoise(64, 224, 208), Violet(238, 130, 238), \n    Wheat(245, 222, 179), White(255, 255, 255), \n    WhiteSmoke(245, 245, 245), Yellow(255, 255, 0), \n    YellowGreen(139, 205, 50); \n}; \n\n```", "```cpp\nnamespace SmallWindows { \n  class Font; \n  extern const Font SystemFont; \n\n  class Font { \n    public: \n\n```", "```cpp\n      Font(); \n      Font(String name, int size, \n           bool italic = false, bool bold = false); \n      Font(const Font& Font); \n      Font& operator=(const Font& font); \n\n```", "```cpp\n      bool operator==(const Font& font) const; \n      bool operator!=(const Font& font) const; \n\n```", "```cpp\n      bool WriteFontToStream(ostream& outStream) const; \n      bool ReadFontFromStream(istream& inStream); \n      void WriteFontToClipboard(InfoList& infoList) const; \n      void ReadFontFromClipboard(InfoList& infoList); \n      void WriteFontToRegistry(String key); \n      void ReadFontFromRegistry(String key, \n                                Font defaultFont = SystemFont); \n\n```", "```cpp\n      void PointsToLogical(double zoom = 1.0); \n\n```", "```cpp\n      LOGFONT LogFont() const {return logFont;} \n      LOGFONT& LogFont() {return logFont;} \n\n```", "```cpp\n      Color FontColor() const {return color;} \n      Color& FontColor() {return color;} \n\n    private: \n      LOGFONT logFont; \n      Color color; \n  }; \n}; \n\n```", "```cpp\n#include \"SmallWindows.h\" \n\nnamespace SmallWindows { \n  Font::Font() { \n    memset(&logFont, 0, sizeof logFont); \n  } \n\n  Font::Font(String name, int size, bool italic, bool bold) { \n    memset(&logFont, 0, sizeof logFont); \n    wcscpy_s(logFont.lfFaceName, LF_FACESIZE, name.c_str()); \n    logFont.lfHeight = size; \n    logFont.lfItalic = (italic ? TRUE : FALSE); \n    logFont.lfWeight = (bold ? FW_BOLD : FW_NORMAL); \n  } \n\n  Font::Font(const Font& font) { \n    logFont = font.LogFont(); \n    color = font.color; \n  } \n\n  Font& Font::operator=(const Font& font) { \n    if (this != &font) { \n      logFont = font.LogFont(); \n      color = font.color; \n    } \n\n    return *this; \n  } \n\n```", "```cpp\n  bool Font::operator==(const Font& font) const { \n    return (::memcmp(&logFont, &font.logFont, \n                     sizeof logFont) == 0) && \n           (color == font.color); \n  } \n\n  bool Font::operator!=(const Font& font) const { \n    return !(*this == font); \n  } \n\n```", "```cpp\n  bool Font::WriteFontToStream(ostream& outStream) const { \n    outStream.write((char*) &logFont, sizeof logFont); \n    color.WriteColorToStream(outStream); \n    return ((bool) outStream); \n  } \n\n  bool Font::ReadFontFromStream(istream& inStream) { \n    inStream.read((char*) &logFont, sizeof logFont); \n    color.ReadColorFromStream(inStream); \n    return ((bool) inStream); \n  } \n\n  void Font::WriteFontToClipboard(InfoList& infoList) const { \n    infoList.AddValue<LOGFONT>(logFont); \n    color.WriteColorToClipboard(infoList); \n  }  \n\n  void Font::ReadFontFromClipboard(InfoList& infoList) { \n    infoList.GetValue<LOGFONT>(logFont); \n    color.ReadColorFromClipboard(infoList); \n  }  \n\n  void Font::WriteFontToRegistry(String key) { \n    Registry::WriteBuffer(key, &logFont, sizeof logFont); \n    color.WriteColorToRegistry(key); \n  }  \n\n  void Font::ReadFontFromRegistry(String key, \n                         Font defaultFont /* = SystemFont */) { \n    Registry::ReadBuffer(key, &logFont, sizeof logFont, \n                         &defaultFont.logFont); \n    color.ReadColorFromRegistry(key); \n  } \n\n```", "```cpp\n  void Font::PointsToLogical(double zoom /* = 1.0 */) { \n    logFont.lfWidth = \n      (int) (zoom * 2540.0 * logFont.lfWidth / 72.0); \n    logFont.lfHeight = \n      (int) (zoom * 2540.0 * logFont.lfHeight / 72.0); \n  }  \n\n  const Font SystemFont; \n}; \n\n```", "```cpp\nnamespace SmallWindows { \n  typedef LPCTSTR CursorType; \n\n  class Cursor { \n    public: \n      static const CursorType Normal; \n      static const CursorType Arrow; \n      static const CursorType ArrowHourGlass; \n      static const CursorType Crosshair; \n      static const CursorType Hand; \n      static const CursorType ArrowQuestionMark; \n      static const CursorType IBeam; \n      static const CursorType SlashedCircle; \n      static const CursorType SizeAll; \n      static const CursorType SizeNorthEastSouthWest; \n      static const CursorType SizeNorthSouth; \n      static const CursorType SizeNorthWestSouthEast; \n      static const CursorType SizeWestEast; \n      static const CursorType VerticalArrow; \n      static const CursorType HourGlass; \n\n      static void Set(CursorType cursor); \n   }; \n}; \n\n```", "```cpp\n#include \"SmallWindows.h\" \n\nnamespace SmallWindows { \n  const CursorType Cursor::Normal = IDC_ARROW; \n  const CursorType Cursor::Arrow = IDC_ARROW; \n  const CursorType Cursor::ArrowHourGlass = IDC_APPSTARTING; \n  const CursorType Cursor::Crosshair = IDC_CROSS; \n  const CursorType Cursor::Hand = IDC_HAND; \n  const CursorType Cursor::ArrowQuestionMark = IDC_HELP; \n  const CursorType Cursor::IBeam = IDC_IBEAM; \n  const CursorType Cursor::SlashedCircle = IDC_NO; \n  const CursorType Cursor::SizeAll = IDC_SIZEALL; \n  const CursorType Cursor::SizeNorthEastSouthWest = IDC_SIZENESW; \n  const CursorType Cursor::SizeNorthSouth = IDC_SIZENS; \n  const CursorType Cursor::SizeNorthWestSouthEast = IDC_SIZENWSE; \n  const CursorType Cursor::SizeWestEast = IDC_SIZEWE; \n  const CursorType Cursor::VerticalArrow = IDC_UPARROW; \n  const CursorType Cursor::HourGlass = IDC_WAIT; \n\n```", "```cpp\n  void Cursor::Set(CursorType cursor) { \n    ::SetCursor(::LoadCursor(nullptr, cursor)); \n  } \n}; \n\n```", "```cpp\nnamespace SmallWindows { \n  template <class Type> \n  class DynamicList { \n    public: \n\n```", "```cpp\n      typedef bool (*IfFuncPtr)(const Type& value, void* voidPtr); \n      typedef void (*DoFuncPtr)(Type& value, void* voidPtr); \n\n```", "```cpp\n      DynamicList(); \n      DynamicList(const DynamicList& list); \n      DynamicList& operator=(const DynamicList& list); \n      ~DynamicList(); \n\n```", "```cpp\n      bool Empty() const; \n      int Size() const; \n      void Clear(); \n      int IndexOf(Type& value) const; \n\n```", "```cpp\n      Type* begin(); \n      const Type* begin() const; \n      Type* end(); \n      const Type* end() const; \n\n```", "```cpp\n      Type operator[](int index) const; \n      Type& operator[](int index); \n\n```", "```cpp\n      Type Front() const {return (*this)[0];} \n      Type& Front() {return (*this)[0];} \n      Type Back() const {return (*this)[size - 1];} \n      Type& Back() {return (*this)[size - 1];} \n\n```", "```cpp\n      void PushBack(const Type& value); \n      void PushBack(const DynamicList& list); \n      void PushFront(const Type& value); \n      void PushFront(const DynamicList& list); \n      void Insert(int index, const Type& value); \n      void Insert(int index, const DynamicList& list); \n\n```", "```cpp\n      void Erase(int deleteIndex); \n      void Remove(int firstIndex = 0, int lastIndex = -1); \n\n```", "```cpp\n      void Copy(DynamicList& copyList, int firstIndex = 0, \n                int lastIndex = -1) const; \n\n```", "```cpp\n      bool AnyOf(IfFuncPtr ifFuncPtr, void* ifVoidPtr = nullptr) \n                 const; \n      bool AllOf(IfFuncPtr ifFuncPtr, void* ifVoidPtr = nullptr) \n                 const; \n\n```", "```cpp\n      bool FirstOf(IfFuncPtr ifFuncPtr, Type& value, \n                   void* ifVoidPtr = nullptr) const; \n      bool LastOf(IfFuncPtr ifFuncPtr, Type& value, \n                  void* ifVoidPtr = nullptr) const; \n\n```", "```cpp\n      void Apply(DoFuncPtr doFuncPtr, void* ifVoidPtr = nullptr); \n      void ApplyIf(IfFuncPtr ifFuncPtr, DoFuncPtr doFuncPtr, \n                   void* ifVoidPtr = nullptr, \n                   void* doVoidPtr = nullptr); \n\n```", "```cpp\n      void CopyIf(IfFuncPtr ifFuncPtr, DynamicList& copyList, \n                  void* ifVoidPtr = nullptr) const; \n      void RemoveIf(IfFuncPtr ifFuncPtr, \n                    void* ifVoidPtr = nullptr); \n\n```", "```cpp\n      void ApplyRemoveIf(IfFuncPtr ifFuncPtr, DoFuncPtr doFuncPtr, \n                         void* ifVoidPtr=nullptr, \n                         void* doVoidPtr=nullptr); \n\n```", "```cpp\n    private: \n      int size; \n      Type* buffer; \n  }; \n\n  template <class Type> \n  DynamicList<Type>::DynamicList() \n   :size(0), \n    buffer(nullptr) { \n    // Empty. \n  } \n\n```", "```cpp\n  template <class Type> \n  DynamicList<Type>::DynamicList(const DynamicList& list) \n   :size(list.size), \n    buffer(new Type[list.size]) { \n    assert(buffer != nullptr);  \n    for (int index = 0; index < size; ++index) { \n      buffer[index] = list.buffer[index]; \n    } \n  } \n\n```", "```cpp\n  template <class Type> \n  DynamicList<Type>& DynamicList<Type>::operator= \n                                      (const DynamicList& list) { \n    if (this != &list) { \n      delete[] buffer; \n      size = list.size; \n      assert((buffer = new Type[size]) != nullptr); \n\n      for (int index = 0; index < size; ++index) { \n        buffer[index] = list.buffer[index]; \n      } \n    } \n\n    return *this; \n  } \n\n```", "```cpp\n  template <class Type> \n  DynamicList<Type>::~DynamicList() { \n    delete[] buffer; \n  } \n\n  template <class Type> \n  bool DynamicList<Type>::Empty() const { \n    return (size == 0); \n  } \n\n  template <class Type> \n  int DynamicList<Type>::Size() const { \n    return size; \n  } \n\n```", "```cpp\n  template <class Type> \n  void DynamicList<Type>::Clear() { \n    size = 0; \n    delete[] buffer; \n    buffer = nullptr; \n  } \n\n```", "```cpp\n  template <class Type> \n  int DynamicList<Type>::IndexOf(Type& value) const { \n    for (int index = 0; index < size; ++index) { \n\n      if (buffer[index] == value) { \n        return index; \n      } \n    } \n\n    return -1; \n  } \n\n```", "```cpp\n  template <class Type> \n  Type* DynamicList<Type>::begin() { \n    return &buffer[0]; \n  } \n\n  template <class Type> \n  const Type* DynamicList<Type>::begin() const { \n    return &buffer[0]; \n  } \n\n```", "```cpp\n  template <class Type> \n  Type* DynamicList<Type>::end() { \n    return &buffer[size]; \n  } \n\n  template <class Type> \n  const Type* DynamicList<Type>::end() const { \n    return &buffer[size]; \n  } \n\n```", "```cpp\n  template <class Type> \n  Type DynamicList<Type>::operator[](int index) const { \n    assert((index >= 0) && (index < size)); \n    return buffer[index]; \n  } \n\n  template <class Type> \n  Type& DynamicList<Type>::operator[](int index) { \n    assert((index >= 0) && (index < size)); \n    return buffer[index]; \n  } \n\n```", "```cpp\n  template <class Type> \n  void DynamicList<Type>::PushBack(const Type& value) { \n    Type* newBuffer = new Type[size + 1]; \n    assert(newBuffer != nullptr); \n\n    for (int index = 0; index < size; ++index) { \n      newBuffer[index] = buffer[index]; \n    } \n\n    newBuffer[size++] = value; \n    delete[] buffer; \n    buffer = newBuffer; \n  } \n\n```", "```cpp\n  template <class Type> \n  void DynamicList<Type>::PushBack(const DynamicList& list) { \n    Type* newBuffer = new Type[size + list.size]; \n    assert(newBuffer != nullptr); \n\n    for (int index = 0; index < size; ++index) { \n      newBuffer[index] = buffer[index]; \n    } \n\n    for (int index = 0; index < list.size; ++index) { \n      newBuffer[size + index] = list.buffer[index]; \n    } \n\n    delete[] buffer; \n    buffer = newBuffer; \n    size += list.size; \n  } \n\n```", "```cpp\n  template <class Type> \n  void DynamicList<Type>::PushFront(const Type& value) { \n    Type* newBuffer = new Type[size + 1]; \n    assert(newBuffer != nullptr); \n    newBuffer[0] = value; \n\n    for (int index = 0; index < size; ++index) { \n      newBuffer[index + 1] = buffer[index]; \n    } \n\n    delete[] buffer; \n    buffer = newBuffer; \n    ++size; \n  } \n\n```", "```cpp\n  template <class Type> \n  void DynamicList<Type>::PushFront(const DynamicList& list) { \n    Type* newBuffer = new Type[size + list.size]; \n    assert(newBuffer != nullptr); \n\n```", "```cpp\n    for (int index = 0; index < list.size; ++index) { \n      newBuffer[index] = list.buffer[index]; \n    } \n\n```", "```cpp\n    for (int index = 0; index < size; ++index) { \n      newBuffer[index + list.size] = buffer[index]; \n    } \n\n    delete[] buffer; \n    buffer = newBuffer; \n    size += list.size; \n  } \n\n```", "```cpp\n  template <class Type> \n  void DynamicList<Type>::Insert(int insertIndex, \n                                 const Type& value) { \n    assert((insertIndex >= 0) && (insertIndex <= size)); \n    Type* newBuffer = new Type[size + 1]; \n    assert(newBuffer != nullptr); \n\n    for (int index = 0; index < insertIndex; ++index) { \n      newBuffer[index] = buffer[index]; \n    } \n\n    newBuffer[insertIndex] = value; \n\n    for (int index = 0; index < (size - insertIndex); ++index) { \n      newBuffer[insertIndex + index + 1] = \n        buffer[insertIndex + index]; \n    } \n\n    delete[] buffer; \n    buffer = newBuffer; \n    ++size; \n  } \n\n  template <class Type> \n  void DynamicList<Type>::Insert(int insertIndex, \n                                 const DynamicList& list){ \n    assert((insertIndex >= 0) && (insertIndex <= size)); \n    Type* newBuffer = new Type[size + list.size]; \n    assert(newBuffer != nullptr); \n\n    for (int index = 0; index < insertIndex; ++index) { \n      newBuffer[index] = buffer[index]; \n    } \n\n    for (int index = 0; index < list.size; ++index) { \n      newBuffer[insertIndex + index] = list.buffer[index]; \n    } \n\n    for (int index = 0; index < (size - insertIndex); ++index) { \n      newBuffer[insertIndex + index + list.size] = \n        buffer[insertIndex + index]; \n    } \n\n    delete[] buffer; \n    buffer = newBuffer; \n    size += list.size; \n  } \n\n```", "```cpp\n  template <class Type> \n  void DynamicList<Type>::Erase(int eraseIndex) { \n    assert((eraseIndex >= 0) && (eraseIndex < size)); \n    Type* newBuffer = new Type[size - 1]; \n    assert(newBuffer != nullptr); \n\n```", "```cpp\n    for (int index = 0; index < eraseIndex; ++index) { \n      newBuffer[index] = buffer[index]; \n    } \n\n```", "```cpp\n    for (int index = 0; index < (size - (eraseIndex + 1)); \n         ++index) { \n      newBuffer[eraseIndex + index] = \n        buffer[eraseIndex + index + 1]; \n    } \n\n    delete[] buffer; \n    buffer = newBuffer; \n    --size; \n  } \n\n```", "```cpp\n  template <class Type> \n  void DynamicList<Type>::Remove(int firstIndex /* = 0 */,  \n                                 int lastIndex /* = -1 */) { \n    if (lastIndex == -1) { \n      lastIndex = size - 1; \n    } \n\n    assert((firstIndex >= 0) && (firstIndex < size)); \n    assert((lastIndex >= 0) && (lastIndex < size)); \n    assert(firstIndex <= lastIndex); \n\n    int removeSize = lastIndex - firstIndex + 1; \n    Type* newBuffer = new Type[size - removeSize]; \n    assert(newBuffer != nullptr);  \n    for (int index = 0; index < firstIndex; ++index) { \n      newBuffer[index] = buffer[index]; \n    }  \n\n    for (int index = 0; \n         index < (size - (firstIndex + removeSize)); ++index){ \n      newBuffer[firstIndex + index] = \n        buffer[firstIndex + index + removeSize]; \n    }  \n\n    delete[] buffer; \n    buffer = newBuffer; \n    size -= removeSize; \n  } \n\n```", "```cpp\n  template <class Type> \n void DynamicList<Type>::Copy(DynamicList& copyList,\n int firstIndex/* =0 */,\n int lastIndex /* = -1 */) const {\n    if (lastIndex == -1) { \n      lastIndex = size - 1; \n    } \n\n    assert((firstIndex >= 0) && (firstIndex < size)); \n    assert((lastIndex >= 0) && (lastIndex < size)); \n    assert(firstIndex <= lastIndex); \n\n    for (int index = firstIndex; index <= lastIndex; ++index) { \n      copyList.PushBack(buffer[index]); \n    } \n  } \n\n```", "```cpp\n  template <class Type> \n  bool DynamicList<Type>::AnyOf(IfFuncPtr ifFuncPtr, \n                          void* ifVoidPtr /* = nullptr */) const { \n    for (int index = 0; index < size; ++index) { \n      if (ifFuncPtr(buffer[index], ifVoidPtr)) { \n        return true; \n      } \n    } \n\n    return false; \n  } \n\n```", "```cpp\n  template <class Type> \n  bool DynamicList<Type>::AllOf(IfFuncPtr ifFuncPtr, \n                          void* ifVoidPtr /* = nullptr */) const { \n    for (int index = 0; index < size; ++index) { \n      if (!ifFuncPtr(buffer[index], ifVoidPtr)) { \n        return false; \n      } \n    } \n\n    return true; \n  } \n\n```", "```cpp\n  template <class Type> \n  bool DynamicList<Type>::FirstOf(IfFuncPtr ifFuncPtr, \n              Type& value, void* ifVoidPtr /* = nullptr */) const{ \n    for (int index = 0; index < size; ++index) { \n      if (ifFuncPtr(buffer[index], ifVoidPtr)) { \n        value = buffer[index]; \n        return true; \n      } \n    } \n\n    return false; \n  } \n\n```", "```cpp\n  template <class Type> \n  bool DynamicList<Type>::LastOf(IfFuncPtr ifFuncPtr, Type& value, \n                          void* ifVoidPtr /* = nullptr */) const { \n    for (int index = (size - 1); index >= 0; --index) { \n      if (ifFuncPtr(buffer[index], ifVoidPtr)) { \n        value = buffer[index]; \n        return true; \n      } \n    } \n\n    return false; \n  } \n\n```", "```cpp\n  template <class Type> \n  void DynamicList<Type>::Apply(DoFuncPtr doFuncPtr, \n                                void* doVoidPtr /* = nullptr */) { \n    for (int index = 0; index < size; ++index) { \n      doFuncPtr(buffer[index], doVoidPtr); \n    } \n  } \n\n```", "```cpp\n  template <class Type> \n  void DynamicList<Type>::ApplyIf(IfFuncPtr ifFuncPtr, \n         DoFuncPtr doFuncPtr, void* ifVoidPtr /* = nullptr */, \n         void* doVoidPtr /* = nullptr */){ \n    for (int index = 0; index < size; ++index) { \n      if (ifFuncPtr(buffer[index], ifVoidPtr)) { \n        doFuncPtr(buffer[index], doVoidPtr); \n      } \n    } \n  } \n\n```", "```cpp\n  template <class Type> \n  void DynamicList<Type>::CopyIf(IfFuncPtr ifFuncPtr, \n                          DynamicList& copyList, \n                          void* ifVoidPtr /* = nullptr */) const { \n    for (int index = 0; index < size; ++index) { \n      if (ifFuncPtr(buffer[index], ifVoidPtr)) { \n        copyList.PushBack(buffer[index]); \n      } \n    } \n  } \n\n```", "```cpp\n  template <class Type> \n  void DynamicList<Type>::RemoveIf(IfFuncPtr ifFuncPtr, \n                                void* ifVoidPtr /* = nullptr */) { \n    for (int index = 0; index < size; ++index) { \n      if (ifFuncPtr(buffer[index], ifVoidPtr)) { \n        Erase(index--); \n      } \n    } \n  } \n\n```", "```cpp\n  template <class Type> \n  void DynamicList<Type>::ApplyRemoveIf(IfFuncPtr ifFuncPtr, \n         DoFuncPtr doFuncPtr, void* ifVoidPtr /* = nullptr */, \n         void* doVoidPtr /* = nullptr */) { \n    for (int index = 0; index < size; ++index) { \n      if (ifFuncPtr(buffer[index], ifVoidPtr)) { \n        doFuncPtr(buffer[index], doVoidPtr); \n        Erase(index--); \n      } \n    } \n  } \n}; \n\n```", "```cpp\nnamespace SmallWindows { \n  template <class NodeType> \n  class Tree { \n    public: \n      Tree(); \n      Tree(NodeType nodeValue, \n           initializer_list<Tree<NodeType>*> childList = {}); \n      Tree(const Tree& tree); \n      Tree& operator=(const Tree& tree); \n      void Init(const Tree& tree); \n      ~Tree(); \n\n```", "```cpp\n      bool WriteTreeToStream(ostream& outStream) const; \n      bool ReadTreeFromStream(istream& inStream); \n      void WriteTreeToClipboard(InfoList& infoList) const; \n      void ReadTreeFromClipboard(InfoList& infoList); \n\n```", "```cpp\n      NodeType NodeValue() const {return nodeValue;} \n      NodeType& NodeValue() {return nodeValue;} \n\n```", "```cpp\n      const DynamicList<Tree*>& ChildList() const \n                                            {return childList;} \n      DynamicList<Tree*>& ChildList() {return childList;} \n\n     private: \n      NodeType nodeValue; \n     DynamicList<Tree*> childList; \n  }; \n\n  template <class NodeType> \n  Tree<NodeType>::Tree() { \n    // Empty. \n  } \n\n```", "```cpp\n  template <class NodeType>   \n  Tree<NodeType>::Tree(NodeType nodeValue, \n           initializer_list<Tree<NodeType>*> childList /* = {} */) \n   :nodeValue(nodeValue) { \n    for (Tree<NodeType>* childNodePtr : childList) { \n      this->childList.PushBack(childNodePtr); \n    } \n  } \n\n```", "```cpp\n  template <class NodeType> \n  Tree<NodeType>::Tree(const Tree& tree) { \n    Init(tree); \n  } \n\n  template <class NodeType> \n  Tree<NodeType>& Tree<NodeType>::operator=(const Tree& tree) { \n    if (this != &tree) { \n      Init(tree); \n    } \n\n    return *this; \n  } \n\n  template <class NodeType> \n  void Tree<NodeType>::Init(const Tree& tree) { \n    nodeValue = tree.nodeValue; \n\n    for (Tree* childPtr : tree.childList) { \n      Tree* childClonePtr = new Tree(*childPtr); \n      assert(childClonePtr != nullptr); \n      childList.PushBack(childClonePtr); \n    } \n  } \n\n```", "```cpp\n  template <class NodeType> \n  Tree<NodeType>::~Tree() { \n    for (Tree* childPtr : childList) { \n      delete childPtr; \n    } \n  } \n\n```", "```cpp\n  template <class NodeType> \n  bool Tree<NodeType>::WriteTreeToStream(ostream& outStream)const{ \n    nodeValue.WriteTreeNodeToStream(outStream);  \n\n    int childListSize = childList.Size(); \n    outStream.write((char*) &childListSize, sizeof childListSize);  \n\n    for (Tree* childPtr : childList) { \n      childPtr->WriteTreeToStream(outStream); \n    } \n\n    return ((bool) outStream); \n  } \n\n```", "```cpp\n  template <class NodeType> \n  bool Tree<NodeType>::ReadTreeFromStream(istream& inStream) { \n    nodeValue.ReadTreeNodeFromStream(inStream);  \n\n    int childListSize; \n    inStream.read((char*) &childListSize, sizeof childListSize); \n\n    for (int count = 0; count < childListSize; ++count) { \n      Tree* childPtr = new Tree(); \n      assert(childPtr != nullptr); \n      childPtr->ReadTreeFromStream(inStream); \n      childList.PushBack(childPtr); \n    } \n\n    return ((bool) inStream); \n  } \n\n```", "```cpp\n  template <class NodeType> \n  void Tree<NodeType>::WriteTreeToClipboard(InfoList& infoList) \n                                            const { \n    nodeValue.WriteTreeNodeToClipboard(infoList); \n\n    infoList.AddValue<int>( childList.Size()); \n\n    for (Tree* childPtr : childList) { \n      childPtr->WriteTreeToClipboard(infoList); \n    } \n  } \n\n  template <class NodeType> \n  void Tree<NodeType>::ReadTreeFromClipboard(InfoList& infoList) { \n    nodeValue.ReadTreeNodeFromClipboard(infoList); \n\n    int childListSize; \n    infoList.GetValue<int>(childListSize); \n\n    for (int count = 0; count < childListSize; ++count) { \n      Tree* childPtr = new Tree(); \n      assert(childPtr != nullptr); \n      childPtr->ReadTreeFromClipboard(infoList); \n      childList.PushBack(childPtr); \n    } \n  } \n}; \n\n```", "```cpp\nnamespace SmallWindows { \n  class InfoList { \n    public: \n      template <class AlignType> void Align(); \n      template <class ListType> \n        void AddValue(const ListType value); \n      template <class ListType> \n        void PeekValue(ListType& value, int index); \n      template <class ListType> void GetValue(ListType& value); \n      template <class CharType> \n        void AddString(basic_string<CharType> text); \n      template <class CharType> \n        basic_string<CharType> GetString(); \n      void FromBuffer(const void* voidBuffer, int size); \n      void ToBuffer(void* voidBuffer); \n      int Size() const {return list.Size();} \n\n    private: \n      DynamicList<char> list; \n  }; \n\n```", "```cpp\n  template <class AlignType> \n  void InfoList::Align() { \n    int size = sizeof(AlignType); \n\n    while ((list.Size() % size) > 0) { \n      list.PushBack(0); \n    } \n  } \n\n```", "```cpp\n  template <class ListType> \n  void InfoList::AddValue(const ListType value) { \n    int size = sizeof(ListType); \n    const char* buffer = (char*) &value; \n\n    for (int count = 0; count < size; ++count) { \n      list.PushBack(*(buffer++)); \n    } \n  } \n\n  template <class ListType> \n  void InfoList::PeekValue(ListType& value, int index) { \n    int size = sizeof(ListType); \n    char* buffer = (char*) &value; \n\n    for (int count = 0; count < size; ++count) { \n      *(buffer++) = list[index + count]; \n    } \n  } \n\n  template <class ListType> \n  void InfoList::GetValue(ListType& value) { \n    int size = sizeof(ListType); \n    char* buffer = (char*) &value; \n\n    for (int count = 0; count < size; ++count) { \n      *(buffer++) = list.Front(); \n      list.Erase(0); \n    } \n  } \n\n```", "```cpp\n  template <class CharType> \n  void InfoList::AddString(basic_string<CharType> text) { \n    for (CharType c : text) { \n      AddValue<CharType>(c); \n    } \n\n    AddValue<CharType>(0); \n  } \n\n  template <class CharType> \n  basic_string<CharType> InfoList::GetString() { \n    bacic_string<CharType> text; \n\n    CharType c, zero = (CharType) 0; \n    while ((c = GetValue<CharType>()) != zero) { \n      text.append(c); \n    } \n\n    return text; \n  } \n}; \n\n```", "```cpp\n#include \"SmallWindows.h\" \n\n```", "```cpp\nvoid InfoList::FromBuffer(const void* voidBuffer, int size) { \n  const char* charBuffer = (const char*) voidBuffer; \n\n  for (int count = 0; count < size; ++count) { \n    list.PushBack(*(charBuffer++)); \n  } \n} \n\nvoid InfoList::ToBuffer(void* voidBuffer) { \n  char* charBuffer = (char*) voidBuffer; \n\n  for (char c : list) { \n    *(charBuffer++) = c; \n  } \n} \n\n```", "```cpp\nnamespace SmallWindows { \n  extern String CharPtrToGenericString(char* text); \n  extern vector<String> Split(String text, TCHAR c = TEXT(' ')); \n  extern bool IsNumeric(String text); \n  extern String Trim(String text); \n  void ReplaceAll(String& text, String from, String to); \n  extern bool WriteStringToStream(const String& text, \n                                  ostream& outStream); \n  extern bool ReadStringFromStream(String& text, \n                                   istream& inStream); \n  extern bool StartsWith(String text, String part); \n  extern bool EndsWith(String text, String part); \n}; \n\n```", "```cpp\n#include \"SmallWindows.h\" \n\nnamespace SmallWindows { \n  String CharPtrToGenericString(char* text) { \n    String result; \n\n    for (int index = 0; text[index] != '\\0'; ++index) { \n      result += (TCHAR) text[index]; \n    } \n\n    return result; \n  } \n\n  vector<String> Split(String text, TCHAR c /* = TEXT(' ') */) { \n    vector<String> list; \n    int spaceIndex = -1, size = text.size(); \n\n    for (int index = 0; index < size; ++index) { \n      if (text[index] == c) { \n        String word = \n          text.substr(spaceIndex + 1, index - spaceIndex - 1); \n        list.push_back(word); \n        spaceIndex = index; \n      } \n    } \n\n    String lastWord = text.substr(spaceIndex + 1); \n    list.push_back(lastWord); \n    return list; \n  } \n\n```", "```cpp\n      bool IsNumeric(String text) { \n    IStringStream stringStream(Trim(text)); \n    double value; \n    stringStream >> value; \n    return stringStream.eof(); \n  } \n\n  String Trim(String text) { \n    while (!text.empty() && isspace(text[0])) { \n      text.erase(0, 1); \n    } \n\n    while (!text.empty() && isspace(text[text.length() - 1])) { \n      text.erase(text.length() - 1, 1); \n    } \n\n    return text; \n  } \n\n  void ReplaceAll(String& text, String from, String to) { \n    int index, fromSize = from.size(); \n\n    while ((index = text.find(from)) != -1) { \n      text.erase(index, fromSize); \n      text.insert(index, to); \n    } \n  } \n\n  bool WriteStringToStream(const String& text,ostream& outStream){ \n    int size = text.size(); \n    outStream.write((char*) &size, sizeof size); \n\n    for (TCHAR tChar : text) { \n      outStream.write((char*) &tChar, sizeof tChar); \n    } \n\n    return ((bool) outStream); \n  } \n\n  bool ReadStringFromStream(String& text, istream& inStream) { \n    int size; \n    inStream.read((char*) &size, sizeof size); \n\n    for (int count = 0; count < size; ++count) { \n      TCHAR tChar; \n      inStream.read((char*) &tChar, sizeof tChar); \n      text.push_back(tChar); \n    } \n\n    return ((bool) inStream); \n  } \n\n  bool StartsWith(String text, String part) { \n    return (text.find(part) == 0); \n  } \n\n  bool EndsWith(String text, String part) { \n    int index = text.rfind(part), \n        difference = text.length() - part.length(); \n    return ((index != -1) && (index == difference)); \n  } \n}; \n\n```"]