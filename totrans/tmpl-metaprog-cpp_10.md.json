["```cpp\nstruct game_unit\n```", "```cpp\n{\n```", "```cpp\n   virtual void attack() = 0;\n```", "```cpp\n};\n```", "```cpp\nstruct knight : game_unit\n```", "```cpp\n{\n```", "```cpp\n   void attack() override\n```", "```cpp\n   { std::cout << \"draw sword\\n\"; }\n```", "```cpp\n};\n```", "```cpp\nstruct mage : game_unit\n```", "```cpp\n{\n```", "```cpp\n   void attack() override\n```", "```cpp\n   { std::cout << \"spell magic curse\\n\"; }\n```", "```cpp\n};\n```", "```cpp\nvoid fight(std::vector<game_unit*> const & units)\n```", "```cpp\n{\n```", "```cpp\n   for (auto unit : units)\n```", "```cpp\n   {\n```", "```cpp\n      unit->attack();\n```", "```cpp\n   }\n```", "```cpp\n}\n```", "```cpp\nknight k;\n```", "```cpp\nmage m;\n```", "```cpp\nfight({&k, &m});\n```", "```cpp\nknight_mage km = k + m;\n```", "```cpp\nkm.attack();\n```", "```cpp\nstruct knight_mage : game_unit\n```", "```cpp\n{\n```", "```cpp\n   void attack() override\n```", "```cpp\n   { std::cout << \"draw magic sword\\n\"; }\n```", "```cpp\n};\n```", "```cpp\nknight_mage operator+(knight const& k, mage const& m)\n```", "```cpp\n{\n```", "```cpp\n   return knight_mage{};\n```", "```cpp\n}\n```", "```cpp\nstruct attack  { int value; };\n```", "```cpp\nstruct defense { int value; };\n```", "```cpp\nvoid increment(attack& a)  { a.value++; }\n```", "```cpp\nvoid increment(defense& d) { d.value++; }\n```", "```cpp\nattack a{ 42 };\n```", "```cpp\ndefense d{ 50 };\n```", "```cpp\nincrement(a);\n```", "```cpp\nincrement(d);\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nvoid increment(T& t) { t.value++; }\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct game_unit\n```", "```cpp\n{\n```", "```cpp\n   void attack()\n```", "```cpp\n   {\n```", "```cpp\n      static_cast<T*>(this)->do_attack();\n```", "```cpp\n   }\n```", "```cpp\n};\n```", "```cpp\nstruct knight : game_unit<knight>\n```", "```cpp\n{\n```", "```cpp\n   void do_attack()\n```", "```cpp\n   { std::cout << \"draw sword\\n\"; }\n```", "```cpp\n};\n```", "```cpp\nstruct mage : game_unit<mage>\n```", "```cpp\n{\n```", "```cpp\n   void do_attack()\n```", "```cpp\n   { std::cout << \"spell magic curse\\n\"; }\n```", "```cpp\n};\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nvoid fight(std::vector<game_unit<T>*> const & units)\n```", "```cpp\n{\n```", "```cpp\n   for (auto unit : units)\n```", "```cpp\n   {\n```", "```cpp\n      unit->attack();\n```", "```cpp\n   }\n```", "```cpp\n}\n```", "```cpp\nknight k;\n```", "```cpp\nmage   m;\n```", "```cpp\nfight<knight>({ &k });\n```", "```cpp\nfight<mage>({ &m });\n```", "```cpp\ntemplate <typename T, size_t N>\n```", "```cpp\nstruct limited_instances \n```", "```cpp\n{\n```", "```cpp\n   static std::atomic<size_t> count;\n```", "```cpp\n   limited_instances()\n```", "```cpp\n   {\n```", "```cpp\n      if (count >= N)\n```", "```cpp\n         throw std::logic_error{ \"Too many instances\" };\n```", "```cpp\n      ++count;\n```", "```cpp\n   }\n```", "```cpp\n   ~limited_instances() { --count; }\n```", "```cpp\n};\n```", "```cpp\ntemplate <typename T, size_t N>\n```", "```cpp\nstd::atomic<size_t> limited_instances<T, N>::count = 0;\n```", "```cpp\nstruct excalibur : limited_instances<excalibur, 1>\n```", "```cpp\n{};\n```", "```cpp\nstruct book_of_magic : limited_instances<book_of_magic, 3>\n```", "```cpp\n{};\n```", "```cpp\nexcalibur e1;\n```", "```cpp\ntry\n```", "```cpp\n{\n```", "```cpp\n   excalibur e2;\n```", "```cpp\n}\n```", "```cpp\ncatch (std::exception& e)\n```", "```cpp\n{\n```", "```cpp\n   std::cout << e.what() << '\\n';\n```", "```cpp\n}\n```", "```cpp\nbook_of_magic b1;\n```", "```cpp\nbook_of_magic b2;\n```", "```cpp\nbook_of_magic b3;\n```", "```cpp\ntry\n```", "```cpp\n{\n```", "```cpp\n   book_of_magic b4;\n```", "```cpp\n}\n```", "```cpp\ncatch (std::exception& e)\n```", "```cpp\n{\n```", "```cpp\n   std::cout << e.what() << '\\n';\n```", "```cpp\n}\n```", "```cpp\nstruct knight\n```", "```cpp\n{\n```", "```cpp\n   void step_forth();\n```", "```cpp\n   void step_back();\n```", "```cpp\n};\n```", "```cpp\nstruct mage\n```", "```cpp\n{\n```", "```cpp\n   void step_forth();\n```", "```cpp\n   void step_back();\n```", "```cpp\n};\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct movable_unit\n```", "```cpp\n{\n```", "```cpp\n   void advance(size_t steps)\n```", "```cpp\n   {\n```", "```cpp\n      while (steps--)\n```", "```cpp\n         static_cast<T*>(this)->step_forth();\n```", "```cpp\n   }\n```", "```cpp\n   void retreat(size_t steps)\n```", "```cpp\n   {\n```", "```cpp\n      while (steps--)\n```", "```cpp\n         static_cast<T*>(this)->step_back();\n```", "```cpp\n   }\n```", "```cpp\n};\n```", "```cpp\nstruct knight : movable_unit<knight>\n```", "```cpp\n{\n```", "```cpp\n   void step_forth() \n```", "```cpp\n   { std::cout << \"knight moves forward\\n\"; }\n```", "```cpp\n   void step_back()\n```", "```cpp\n   { std::cout << \"knight moves back\\n\"; }\n```", "```cpp\n};\n```", "```cpp\nstruct mage : movable_unit<mage>\n```", "```cpp\n{\n```", "```cpp\n   void step_forth()\n```", "```cpp\n   { std::cout << \"mage moves forward\\n\"; }\n```", "```cpp\n   void step_back()\n```", "```cpp\n   { std::cout << \"mage moves back\\n\"; }\n```", "```cpp\n};\n```", "```cpp\nknight k;\n```", "```cpp\nk.advance(3);\n```", "```cpp\nk.retreat(2);\n```", "```cpp\nmage m;\n```", "```cpp\nm.advance(5);\n```", "```cpp\nm.retreat(3);\n```", "```cpp\nstruct knight\n```", "```cpp\n{\n```", "```cpp\n   void step_forth()\n```", "```cpp\n   { std::cout << \"knight moves forward\\n\"; }\n```", "```cpp\n   void step_back()\n```", "```cpp\n   { std::cout << \"knight moves back\\n\"; }\n```", "```cpp\n};\n```", "```cpp\nstruct mage\n```", "```cpp\n{\n```", "```cpp\n   void step_forth()\n```", "```cpp\n   { std::cout << \"mage moves forward\\n\"; }\n```", "```cpp\n   void step_back()\n```", "```cpp\n   { std::cout << \"mage moves back\\n\"; }\n```", "```cpp\n};\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nvoid advance(T& t, size_t steps)\n```", "```cpp\n{\n```", "```cpp\n   while (steps--) t.step_forth();\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nvoid retreat(T& t, size_t steps)\n```", "```cpp\n{\n```", "```cpp\n   while (steps--) t.step_back();\n```", "```cpp\n}\n```", "```cpp\nknight k;\n```", "```cpp\nadvance(k, 3);\n```", "```cpp\nretreat(k, 2);\n```", "```cpp\nmage m;\n```", "```cpp\nadvance(m, 5);\n```", "```cpp\nretreat(m, 3);\n```", "```cpp\nstruct hero\n```", "```cpp\n{\n```", "```cpp\n   hero(std::string_view n) : name(n) {}\n```", "```cpp\n   void ally_with(hero& u)\n```", "```cpp\n   {\n```", "```cpp\n      connections.insert(&u);\n```", "```cpp\n      u.connections.insert(this);\n```", "```cpp\n   }\n```", "```cpp\nprivate:\n```", "```cpp\n   std::string name;\n```", "```cpp\n   std::set<hero*> connections;\n```", "```cpp\n   friend std::ostream& operator<<(std::ostream& os, \n```", "```cpp\n                                   hero const& obj);\n```", "```cpp\n};\n```", "```cpp\nstd::ostream& operator<<(std::ostream& os, \n```", "```cpp\n                         hero const& obj)\n```", "```cpp\n{\n```", "```cpp\n   for (hero* u : obj.connections)\n```", "```cpp\n      os << obj.name << \" --> [\" << u->name << \"]\" << '\\n';\n```", "```cpp\n   return os;\n```", "```cpp\n}\n```", "```cpp\nhero k1(\"Arthur\");\n```", "```cpp\nhero k2(\"Sir Lancelot\");\n```", "```cpp\nhero k3(\"Sir Gawain\");\n```", "```cpp\nk1.ally_with(k2);\n```", "```cpp\nk2.ally_with(k3);\n```", "```cpp\nstd::cout << k1 << '\\n';\n```", "```cpp\nstd::cout << k2 << '\\n';\n```", "```cpp\nstd::cout << k3 << '\\n';\n```", "```cpp\nArthur --> [Sir Lancelot]\nSir Lancelot --> [Arthur]\nSir Lancelot --> [Sir Gawain]\nSir Gawain --> [Sir Lancelot]\n```", "```cpp\nstruct hero_party;\n```", "```cpp\nstruct hero\n```", "```cpp\n{\n```", "```cpp\n   void ally_with(hero& u);\n```", "```cpp\n   void ally_with(hero_party& p);\n```", "```cpp\n};\n```", "```cpp\nstruct hero_party : std::vector<hero>\n```", "```cpp\n{\n```", "```cpp\n   void ally_with(hero& u);\n```", "```cpp\n   void ally_with(hero_party& p);\n```", "```cpp\n};\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct base_unit\n```", "```cpp\n{\n```", "```cpp\n   template <typename U>\n```", "```cpp\n   void ally_with(U& other);\n```", "```cpp\n};\n```", "```cpp\nstruct hero : base_unit<hero>\n```", "```cpp\n{\n```", "```cpp\n   hero(std::string_view n) : name(n) {}\n```", "```cpp\n   hero* begin() { return this; }\n```", "```cpp\n   hero* end() { return this + 1; }\n```", "```cpp\nprivate:\n```", "```cpp\n   std::string name;\n```", "```cpp\n   std::set<hero*> connections;\n```", "```cpp\n   template <typename U>\n```", "```cpp\n   friend struct base_unit;\n```", "```cpp\n   template <typename U>\n```", "```cpp\n   friend std::ostream& operator<<(std::ostream& os,\n```", "```cpp\n                                   base_unit<U>& object);\n```", "```cpp\n};\n```", "```cpp\nstruct hero_party : std::vector<hero>, \n```", "```cpp\n                    base_unit<hero_party>\n```", "```cpp\n{};\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\ntemplate <typename U>\n```", "```cpp\nvoid base_unit<T>::ally_with(U& other)\n```", "```cpp\n{\n```", "```cpp\n   for (hero& from : *static_cast<T*>(this))\n```", "```cpp\n   {\n```", "```cpp\n      for (hero& to : other)\n```", "```cpp\n      {\n```", "```cpp\n         from.connections.insert(&to);\n```", "```cpp\n         to.connections.insert(&from);\n```", "```cpp\n      }\n```", "```cpp\n   }\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstd::ostream& operator<<(std::ostream& os,\n```", "```cpp\n                         base_unit<T>& object)\n```", "```cpp\n{\n```", "```cpp\n   for (hero& obj : *static_cast<T*>(&object))\n```", "```cpp\n   {\n```", "```cpp\n      for (hero* n : obj.connections)\n```", "```cpp\n         os << obj.name << \" --> [\" << n->name << \"]\" \n```", "```cpp\n            << '\\n';\n```", "```cpp\n   }\n```", "```cpp\n   return os;\n```", "```cpp\n}\n```", "```cpp\nhero k1(\"Arthur\");\n```", "```cpp\nhero k2(\"Sir Lancelot\");\n```", "```cpp\nhero_party p1;\n```", "```cpp\np1.emplace_back(\"Bors\");\n```", "```cpp\nhero_party p2;\n```", "```cpp\np2.emplace_back(\"Cador\");\n```", "```cpp\np2.emplace_back(\"Constantine\");\n```", "```cpp\nk1.ally_with(k2);\n```", "```cpp\nk1.ally_with(p1);\n```", "```cpp\np1.ally_with(k2);\n```", "```cpp\np1.ally_with(p2);\n```", "```cpp\nstd::cout << k1 << '\\n';\n```", "```cpp\nstd::cout << k2 << '\\n';\n```", "```cpp\nstd::cout << p1 << '\\n';\n```", "```cpp\nstd::cout << p2 << '\\n';\n```", "```cpp\nArthur --> [Sir Lancelot]\nArthur --> [Bors]\nSir Lancelot --> [Arthur]\nSir Lancelot --> [Bors]\nBors --> [Arthur]\nBors --> [Sir Lancelot]\nBors --> [Cador]\nBors --> [Constantine]\nCador --> [Bors]\nConstantine --> [Bors]\n```", "```cpp\nstruct building {};\n```", "```cpp\nbuilding* b = new building();\n```", "```cpp\nstd::shared_ptr<building> p1{ b }; // [1]\n```", "```cpp\nstd::shared_ptr<building> p2{ b }; // [2] bad\n```", "```cpp\nstruct building : std::enable_shared_from_this<building>\n```", "```cpp\n{\n```", "```cpp\n};\n```", "```cpp\nbuilding* b = new building();\n```", "```cpp\nstd::shared_ptr<building> p1{ b };    // [1]\n```", "```cpp\nstd::shared_ptr<building> p2{ \n```", "```cpp\n   b->shared_from_this()};            // [2] OK\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nclass enable_shared_from_this\n```", "```cpp\n{\n```", "```cpp\npublic:\n```", "```cpp\n  std::shared_ptr<T>       shared_from_this();\n```", "```cpp\n  std::shared_ptr<T const> shared_from_this() const;\n```", "```cpp\n  std::weak_ptr<T>       weak_from_this() noexcept;\n```", "```cpp\n  std::weak_ptr<T const> weak_from_this() const noexcept;\n```", "```cpp\n  enable_shared_from_this<T>& operator=(\n```", "```cpp\n     const enable_shared_from_this<T> &obj ) noexcept;\n```", "```cpp\n};\n```", "```cpp\nstruct executor\n```", "```cpp\n{\n```", "```cpp\n   void execute(std::function<void(void)> const& task)\n```", "```cpp\n   {\n```", "```cpp\n      threads.push_back(std::thread([task]() { \n```", "```cpp\n         using namespace std::chrono_literals;\n```", "```cpp\n         std::this_thread::sleep_for(250ms);\n```", "```cpp\n         task(); \n```", "```cpp\n      }));\n```", "```cpp\n   }\n```", "```cpp\n   ~executor()\n```", "```cpp\n   {\n```", "```cpp\n      for (auto& t : threads)\n```", "```cpp\n         t.join();\n```", "```cpp\n   }\n```", "```cpp\nprivate:\n```", "```cpp\n   std::vector<std::thread> threads;\n```", "```cpp\n};\n```", "```cpp\nstruct building\n```", "```cpp\n{\n```", "```cpp\n   building()  { std::cout << \"building created\\n\"; }\n```", "```cpp\n   ~building() { std::cout << \"building destroyed\\n\"; }\n```", "```cpp\n   void upgrade()\n```", "```cpp\n   {\n```", "```cpp\n      if (exec)\n```", "```cpp\n      {\n```", "```cpp\n         exec->execute([self = this]() {\n```", "```cpp\n            self->do_upgrade();\n```", "```cpp\n         });\n```", "```cpp\n      }\n```", "```cpp\n   }      \n```", "```cpp\n   void set_executor(executor* e) { exec = e; }\n```", "```cpp\nprivate:\n```", "```cpp\n   void do_upgrade()\n```", "```cpp\n   {\n```", "```cpp\n      std::cout << \"upgrading\\n\";\n```", "```cpp\n      operational = false;\n```", "```cpp\n      using namespace std::chrono_literals;\n```", "```cpp\n      std::this_thread::sleep_for(1000ms);\n```", "```cpp\n      operational = true;\n```", "```cpp\n      std::cout << \"building is functional\\n\";\n```", "```cpp\n   }\n```", "```cpp\n   bool operational = false;\n```", "```cpp\n   executor* exec = nullptr;\n```", "```cpp\n};\n```", "```cpp\nint main()\n```", "```cpp\n{\n```", "```cpp\n   executor e;\n```", "```cpp\n   std::shared_ptr<building> b = \n```", "```cpp\n      std::make_shared<building>();\n```", "```cpp\n   b->set_executor(&e);\n```", "```cpp\n   b->upgrade();\n```", "```cpp\n   std::cout << \"main finished\\n\";\n```", "```cpp\n}\n```", "```cpp\nbuilding created\nmain finished\nbuilding destroyed\nupgrading\nbuilding is functional\n```", "```cpp\nexec->execute([self = this]() {\n```", "```cpp\n   self->do_upgrade();\n```", "```cpp\n});\n```", "```cpp\nstruct building : std::enable_shared_from_this<building>\n```", "```cpp\n{\n```", "```cpp\n   /* … */\n```", "```cpp\n};\n```", "```cpp\nexec->execute([self = shared_from_this()]() {\n```", "```cpp\n   self->do_upgrade();\n```", "```cpp\n});\n```", "```cpp\nbuilding created\nmain finished\nupgrading\nbuilding is functional\nbuilding destroyed\n```", "```cpp\nstruct knight\n```", "```cpp\n{\n```", "```cpp\n   void step_forth()\n```", "```cpp\n   {\n```", "```cpp\n      std::cout << \"knight moves forward\\n\";\n```", "```cpp\n   }\n```", "```cpp\n   void step_back()\n```", "```cpp\n   {\n```", "```cpp\n      std::cout << \"knight moves back\\n\";\n```", "```cpp\n   }\n```", "```cpp\n};\n```", "```cpp\nstruct mage\n```", "```cpp\n{\n```", "```cpp\n   void step_forth()\n```", "```cpp\n   {\n```", "```cpp\n      std::cout << \"mage moves forward\\n\";\n```", "```cpp\n   }\n```", "```cpp\n   void step_back()\n```", "```cpp\n   {\n```", "```cpp\n      std::cout << \"mage moves back\\n\";\n```", "```cpp\n   }\n```", "```cpp\n};\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct movable_unit : T\n```", "```cpp\n{\n```", "```cpp\n   void advance(size_t steps)\n```", "```cpp\n   {\n```", "```cpp\n      while (steps--)\n```", "```cpp\n         T::step_forth();\n```", "```cpp\n   }\n```", "```cpp\n   void retreat(size_t steps)\n```", "```cpp\n   {\n```", "```cpp\n      while (steps--)\n```", "```cpp\n         T::step_back();\n```", "```cpp\n   }\n```", "```cpp\n};\n```", "```cpp\nmovable_unit<knight> k;\n```", "```cpp\nk.advance(3);\n```", "```cpp\nk.retreat(2);\n```", "```cpp\nmovable_unit<mage> m;\n```", "```cpp\nm.advance(5);\n```", "```cpp\nm.retreat(3);\n```", "```cpp\nstruct aggressive_style\n```", "```cpp\n{\n```", "```cpp\n   void fight()\n```", "```cpp\n   {\n```", "```cpp\n      std::cout << \"attack! attack attack!\\n\";\n```", "```cpp\n   }\n```", "```cpp\n};\n```", "```cpp\nstruct moderate_style\n```", "```cpp\n{\n```", "```cpp\n   void fight()\n```", "```cpp\n   {\n```", "```cpp\n      std::cout << \"attack then defend\\n\";\n```", "```cpp\n   }\n```", "```cpp\n};\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct lone_warrior : T\n```", "```cpp\n{\n```", "```cpp\n   void fight()\n```", "```cpp\n   {\n```", "```cpp\n      std::cout << \"fighting alone.\";\n```", "```cpp\n      T::fight();\n```", "```cpp\n   }\n```", "```cpp\n};\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct team_warrior : T\n```", "```cpp\n{\n```", "```cpp\n   void fight()\n```", "```cpp\n   {\n```", "```cpp\n      std::cout << \"fighting with a team.\";\n```", "```cpp\n      T::fight();\n```", "```cpp\n   }\n```", "```cpp\n};\n```", "```cpp\nstruct game_unit\n```", "```cpp\n{\n```", "```cpp\n   virtual void attack() = 0;\n```", "```cpp\n   virtual ~game_unit() = default;\n```", "```cpp\n};\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct knight : T, game_unit\n```", "```cpp\n{\n```", "```cpp\n   void attack()\n```", "```cpp\n   {\n```", "```cpp\n      std::cout << \"draw sword.\";\n```", "```cpp\n      T::fight();\n```", "```cpp\n   }\n```", "```cpp\n};\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct mage : T, game_unit\n```", "```cpp\n{\n```", "```cpp\n   void attack()\n```", "```cpp\n   {\n```", "```cpp\n      std::cout << \"spell magic curse.\";\n```", "```cpp\n      T::fight();\n```", "```cpp\n   }\n```", "```cpp\n};\n```", "```cpp\nstd::vector<std::unique_ptr<game_unit>> units;\n```", "```cpp\nunits.emplace_back(new knight<aggressive_style>());\n```", "```cpp\nunits.emplace_back(new knight<moderate_style>());\n```", "```cpp\nunits.emplace_back(new mage<aggressive_style>());\n```", "```cpp\nunits.emplace_back(new mage<moderate_style>());\n```", "```cpp\nunits.emplace_back(\n```", "```cpp\n   new knight<lone_warrior<aggressive_style>>());\n```", "```cpp\nunits.emplace_back(\n```", "```cpp\n   new knight<lone_warrior<moderate_style>>());\n```", "```cpp\nunits.emplace_back(\n```", "```cpp\n   new knight<team_warrior<aggressive_style>>());\n```", "```cpp\nunits.emplace_back(\n```", "```cpp\n   new knight<team_warrior<moderate_style>>());\n```", "```cpp\nunits.emplace_back(\n```", "```cpp\n   new mage<lone_warrior<aggressive_style>>());\n```", "```cpp\nunits.emplace_back(\n```", "```cpp\n   new mage<lone_warrior<moderate_style>>());\n```", "```cpp\nunits.emplace_back(\n```", "```cpp\n   new mage<team_warrior<aggressive_style>>());\n```", "```cpp\nunits.emplace_back(\n```", "```cpp\n   new mage<team_warrior<moderate_style>>());\n```", "```cpp\nfor (auto& u : units)\n```", "```cpp\n   u->attack();\n```", "```cpp\ndraw sword.attack! attack attack!\ndraw sword.attack then defend\nspell magic curse.attack! attack attack!\nspell magic curse.attack then defend\ndraw sword.fighting alone.attack! attack attack!\ndraw sword.fighting alone.attack then defend\ndraw sword.fighting with a team.attack! attack attack!\ndraw sword.fighting with a team.attack then defend\nspell magic curse.fighting alone.attack! attack attack!\nspell magic curse.fighting alone.attack then defend\nspell magic curse.fighting with a team.attack! attack attack!\nspell magic curse.fighting with a team.attack then defend\n```", "```cpp\nstruct knight\n```", "```cpp\n{\n```", "```cpp\n   void attack() { std::cout << \"draw sword\\n\"; }\n```", "```cpp\n};\n```", "```cpp\nstruct mage\n```", "```cpp\n{\n```", "```cpp\n   void attack() { std::cout << \"spell magic curse\\n\"; }\n```", "```cpp\n};\n```", "```cpp\nvoid fight_knight(void* k)\n```", "```cpp\n{\n```", "```cpp\n   reinterpret_cast<knight*>(k)->attack();\n```", "```cpp\n}\n```", "```cpp\nvoid fight_mage(void* m)\n```", "```cpp\n{\n```", "```cpp\n   reinterpret_cast<mage*>(m)->attack();\n```", "```cpp\n}\n```", "```cpp\nusing fight_fn = void(*)(void*);\n```", "```cpp\nvoid fight(\n```", "```cpp\n   std::vector<std::pair<void*, fight_fn>> const& units)\n```", "```cpp\n{\n```", "```cpp\n   for (auto& u : units)\n```", "```cpp\n   {\n```", "```cpp\n      u.second(u.first);\n```", "```cpp\n   }\n```", "```cpp\n}\n```", "```cpp\nknight k;\n```", "```cpp\nmage m;\n```", "```cpp\nstd::vector<std::pair<void*, fight_fn>> units {\n```", "```cpp\n   {&k, &fight_knight},\n```", "```cpp\n   {&m, &fight_mage},\n```", "```cpp\n};\n```", "```cpp\nfight(units);\n```", "```cpp\nstruct game_unit\n```", "```cpp\n{\n```", "```cpp\n   virtual void attack() = 0;\n```", "```cpp\n};\n```", "```cpp\nstruct knight : game_unit\n```", "```cpp\n{\n```", "```cpp\n   void attack() override \n```", "```cpp\n   { std::cout << \"draw sword\\n\"; }\n```", "```cpp\n};\n```", "```cpp\nstruct mage : game_unit\n```", "```cpp\n{\n```", "```cpp\n   void attack() override \n```", "```cpp\n   { std::cout << \"spell magic curse\\n\"; }\n```", "```cpp\n};\n```", "```cpp\nvoid fight(std::vector<game_unit*> const & units)\n```", "```cpp\n{\n```", "```cpp\n   for (auto unit : units)\n```", "```cpp\n      unit->attack();\n```", "```cpp\n}\n```", "```cpp\nstruct knight\n```", "```cpp\n{\n```", "```cpp\n   void attack() { std::cout << \"draw sword\\n\"; }\n```", "```cpp\n};\n```", "```cpp\nstruct mage\n```", "```cpp\n{\n```", "```cpp\n   void attack() { std::cout << \"spell magic curse\\n\"; }\n```", "```cpp\n};\n```", "```cpp\nstruct game_unit\n```", "```cpp\n{\n```", "```cpp\n   virtual void attack() = 0;\n```", "```cpp\n   virtual ~game_unit() = default;\n```", "```cpp\n};\n```", "```cpp\nstruct knight_unit : game_unit\n```", "```cpp\n{\n```", "```cpp\n   knight_unit(knight& u) : k(u) {}\n```", "```cpp\n   void attack() override { k.attack(); }\\\n```", "```cpp\nprivate:\n```", "```cpp\n   knight& k;\n```", "```cpp\n};\n```", "```cpp\nstruct mage_unit : game_unit\n```", "```cpp\n{\n```", "```cpp\n   mage_unit(mage& u) : m(u) {}\n```", "```cpp\n   void attack() override { m.attack(); }\n```", "```cpp\nprivate:\n```", "```cpp\n   mage& m;\n```", "```cpp\n};\n```", "```cpp\nvoid fight(std::vector<game_unit*> const & units)\n```", "```cpp\n{\n```", "```cpp\n   for (auto u : units)\n```", "```cpp\n      u->attack();\n```", "```cpp\n}\n```", "```cpp\nknight k;\n```", "```cpp\nmage m;\n```", "```cpp\nknight_unit ku{ k };\n```", "```cpp\nmage_unit mu{ m };\n```", "```cpp\nstd::vector<game_unit*> v{ &ku, &mu };\n```", "```cpp\nfight(v);\n```", "```cpp\ntemplate <typename T>\n```", "```cpp\nstruct game_unit_wrapper : public game_unit\n```", "```cpp\n{\n```", "```cpp\n   game_unit_wrapper(T& unit) : t(unit) {}\n```", "```cpp\n   void attack() override { t.attack(); }\n```", "```cpp\nprivate:\n```", "```cpp\n   T& t;\n```", "```cpp\n};\n```", "```cpp\nknight k;\n```", "```cpp\nmage m;\n```", "```cpp\ngame_unit_wrapper ku{ k };\n```", "```cpp\ngame_unit_wrapper mu{ m };\n```", "```cpp\nstd::vector<game_unit*> v{ &ku, &mu };\n```", "```cpp\nfight(v);\n```", "```cpp\nstruct game\n```", "```cpp\n{\n```", "```cpp\n   struct game_unit\n```", "```cpp\n   {\n```", "```cpp\n      virtual void attack() = 0;\n```", "```cpp\n      virtual ~game_unit() = default;\n```", "```cpp\n   };\n```", "```cpp\n   template <typename T>\n```", "```cpp\n   struct game_unit_wrapper : public game_unit\n```", "```cpp\n   {\n```", "```cpp\n      game_unit_wrapper(T& unit) : t(unit) {}\n```", "```cpp\n      void attack() override { t.attack(); }\n```", "```cpp\n   private:\n```", "```cpp\n      T& t;\n```", "```cpp\n   };\n```", "```cpp\n   template <typename T>\n```", "```cpp\n   void addUnit(T& unit)\n```", "```cpp\n   {\n```", "```cpp\n      units.push_back(\n```", "```cpp\n         std::make_unique<game_unit_wrapper<T>>(unit));\n```", "```cpp\n   }\n```", "```cpp\n   void fight()\n```", "```cpp\n   {\n```", "```cpp\n      for (auto& u : units)\n```", "```cpp\n         u->attack();\n```", "```cpp\n   }\n```", "```cpp\nprivate:\n```", "```cpp\n   std::vector<std::unique_ptr<game_unit>> units;\n```", "```cpp\n};\n```", "```cpp\nknight k;\n```", "```cpp\nmage m;\n```", "```cpp\ngame g;\n```", "```cpp\ng.addUnit(k);\n```", "```cpp\ng.addUnit(m);\n```", "```cpp\ng.fight();\n```", "```cpp\nstruct unit\n```", "```cpp\n{\n```", "```cpp\n   template <typename T>\n```", "```cpp\n   unit(T&& obj) : \n```", "```cpp\n      unit_(std::make_shared<unit_model<T>>(\n```", "```cpp\n               std::forward<T>(obj))) \n```", "```cpp\n   {}\n```", "```cpp\n   void attack()\n```", "```cpp\n   {\n```", "```cpp\n      unit_->attack();\n```", "```cpp\n   }\n```", "```cpp\n   struct unit_concept\n```", "```cpp\n   {\n```", "```cpp\n      virtual void attack() = 0;\n```", "```cpp\n      virtual ~unit_concept() = default;\n```", "```cpp\n   };\n```", "```cpp\n   template <typename T>\n```", "```cpp\n   struct unit_model : public unit_concept\n```", "```cpp\n   {\n```", "```cpp\n      unit_model(T& unit) : t(unit) {}\n```", "```cpp\n      void attack() override { t.attack(); }\n```", "```cpp\n   private:\n```", "```cpp\n      T& t;\n```", "```cpp\n   };\n```", "```cpp\nprivate:\n```", "```cpp\n   std::shared_ptr<unit_concept> unit_;\n```", "```cpp\n};\n```", "```cpp\nvoid fight(std::vector<unit>& units)\n```", "```cpp\n{\n```", "```cpp\n   for (auto& u : units)\n```", "```cpp\n      u.attack();\n```", "```cpp\n}\n```", "```cpp\nknight k;\n```", "```cpp\nmage m;\n```", "```cpp\nstd::vector<unit> v{ unit(k), unit(m) };\n```", "```cpp\nfight(v);\n```", "```cpp\n    class async_bool\n    {\n       std::function<bool()> check;\n    public:\n       async_bool() = delete;\n       async_bool(std::function<bool()> checkIt)\n          : check(checkIt)\n       { }\n       async_bool(bool val)\n          : check([val]() {return val; })\n       { }\n       operator bool() const { return check(); }\n    };\n    async_bool b1{ false };\n    async_bool b2{ true };\n    async_bool b3{ []() { std::cout << \"Y/N? \"; \n                          char c; std::cin >> c; \n                          return c == 'Y' || c == 'y'; } };\n    if (b1) { std::cout << \"b1 is true\\n\"; }\n    if (b2) { std::cout << \"b2 is true\\n\"; }\n    if (b3) { std::cout << \"b3 is true\\n\"; }\n    ```", "```cpp\n    std::any u;\n    u = knight{};\n    if (u.has_value())\n       std::any_cast<knight>(u).attack();\n    u = mage{};\n    if (u.has_value())\n       std::any_cast<mage>(u).attack();\n    ```", "```cpp\ntemplate<typename InputIt, typename Distance>\n```", "```cpp\nvoid advance(InputIt& it, Distance n);\n```", "```cpp\nstruct input_iterator_tag {};\n```", "```cpp\nstruct output_iterator_tag {};\n```", "```cpp\nstruct forward_iterator_tag : input_iterator_tag {};\n```", "```cpp\nstruct bidirectional_iterator_tag : \n```", "```cpp\n   forward_iterator_tag {};\n```", "```cpp\nstruct random_access_iterator_tag : \n```", "```cpp\n   bidirectional_iterator_tag {};\n```", "```cpp\nnamespace std\n```", "```cpp\n{\n```", "```cpp\n   namespace details \n```", "```cpp\n   {\n```", "```cpp\n      template <typename Iter, typename Distance>\n```", "```cpp\n      void advance(Iter& it, Distance n, \n```", "```cpp\n                   std::random_access_iterator_tag)\n```", "```cpp\n      {\n```", "```cpp\n         it += n;\n```", "```cpp\n      }\n```", "```cpp\n      template <typename Iter, typename Distance>\n```", "```cpp\n      void advance(Iter& it, Distance n, \n```", "```cpp\n                   std::bidirectional_iterator_tag)\n```", "```cpp\n      {\n```", "```cpp\n         if (n > 0)\n```", "```cpp\n         {\n```", "```cpp\n            while (n--) ++it;\n```", "```cpp\n         }\n```", "```cpp\n         else\n```", "```cpp\n         {\n```", "```cpp\n            while (n++) --it;\n```", "```cpp\n         }\n```", "```cpp\n      }\n```", "```cpp\n      template <typename Iter, typename Distance>\n```", "```cpp\n      void advance(Iter& it, Distance n, \n```", "```cpp\n                   std::input_iterator_tag)\n```", "```cpp\n      {\n```", "```cpp\n         while (n--)\n```", "```cpp\n         {\n```", "```cpp\n            ++it;\n```", "```cpp\n         }\n```", "```cpp\n      }\n```", "```cpp\n   }\n```", "```cpp\n}\n```", "```cpp\nnamespace std\n```", "```cpp\n{\n```", "```cpp\n   template <typename Iter, typename Distance>\n```", "```cpp\n   void advance(Iter& it, Distance n)\n```", "```cpp\n   {\n```", "```cpp\n      details::advance(it, n,\n```", "```cpp\n         typename std::iterator_traits<Iter>::\n```", "```cpp\n                          iterator_category{});\n```", "```cpp\n   }\n```", "```cpp\n}\n```", "```cpp\nstd::vector<int> v{ 1,2,3,4,5 };\n```", "```cpp\nauto sv = std::begin(v);\n```", "```cpp\nstd::advance(sv, 2);\n```", "```cpp\nstd::list<int> l{ 1,2,3,4,5 };\n```", "```cpp\nauto sl = std::begin(l);\n```", "```cpp\nstd::advance(sl, 2);\n```", "```cpp\ntemplate<typename It, typename Distance>\n```", "```cpp\nconstexpr void advance(It& it, Distance n)\n```", "```cpp\n{\n```", "```cpp\n   using category = \n```", "```cpp\n     typename std::iterator_traits<It>::iterator_category;\n```", "```cpp\n   static_assert(std::is_base_of_v<std::input_iterator_tag,\n```", "```cpp\n                                   category>);\n```", "```cpp\n   auto dist = \n```", "```cpp\n     typename std::iterator_traits<It>::difference_type(n);\n```", "```cpp\n   if constexpr (std::is_base_of_v<\n```", "```cpp\n                    std::random_access_iterator_tag, \n```", "```cpp\n                    category>)\n```", "```cpp\n   {\n```", "```cpp\n      it += dist;\n```", "```cpp\n   }\n```", "```cpp\n   else\n```", "```cpp\n   {\n```", "```cpp\n      while (dist > 0)\n```", "```cpp\n      {\n```", "```cpp\n         --dist;\n```", "```cpp\n         ++it;\n```", "```cpp\n      }\n```", "```cpp\n      if constexpr (std::is_base_of_v<\n```", "```cpp\n                       std::bidirectional_iterator_tag, \n```", "```cpp\n                       category>)\n```", "```cpp\n      {\n```", "```cpp\n         while (dist < 0)\n```", "```cpp\n         {\n```", "```cpp\n            ++dist;\n```", "```cpp\n            --it;\n```", "```cpp\n         }\n```", "```cpp\n      }\n```", "```cpp\n   }\n```", "```cpp\n}\n```", "```cpp\ntemplate<class I>\n```", "```cpp\n   concept input_iterator =\n```", "```cpp\n      std::input_or_output_iterator<I> &&\n```", "```cpp\n      std::indirectly_readable<I> &&\n```", "```cpp\n      requires { typename /*ITER_CONCEPT*/<I>; } &&\n```", "```cpp\n      std::derived_from</*ITER_CONCEPT*/<I>, \n```", "```cpp\n                        std::input_iterator_tag>;\n```", "```cpp\ntemplate <std::random_access_iterator Iter, class Distance>\n```", "```cpp\nvoid advance(Iter& it, Distance n)\n```", "```cpp\n{\n```", "```cpp\n   it += n;\n```", "```cpp\n}\n```", "```cpp\ntemplate <std::bidirectional_iterator Iter, class Distance>\n```", "```cpp\nvoid advance(Iter& it, Distance n)\n```", "```cpp\n{\n```", "```cpp\n   if (n > 0)\n```", "```cpp\n   {\n```", "```cpp\n      while (n--) ++it;\n```", "```cpp\n   }\n```", "```cpp\n   else\n```", "```cpp\n   {\n```", "```cpp\n      while (n++) --it;\n```", "```cpp\n   }\n```", "```cpp\n}\n```", "```cpp\ntemplate <std::input_iterator Iter, class Distance>\n```", "```cpp\nvoid advance(Iter& it, Distance n)\n```", "```cpp\n{\n```", "```cpp\n   while (n--)\n```", "```cpp\n   {\n```", "```cpp\n      ++it;\n```", "```cpp\n   }\n```", "```cpp\n}\n```", "```cpp\nauto r1 = m1 + m2;\n```", "```cpp\nauto r2 = m1 + m2 + m3;\n```", "```cpp\nauto r3 = m1 * m2 + m3 * m4;\n```", "```cpp\nauto r4 = m1 + 5 * m2;\n```", "```cpp\ntemplate<typename T>\n```", "```cpp\nstruct vector\n```", "```cpp\n{\n```", "```cpp\n   vector(std::size_t const n) : data_(n) {}\n```", "```cpp\n   vector(std::initializer_list<T>&& l) : data_(l) {}\n```", "```cpp\n   std::size_t size() const noexcept\n```", "```cpp\n   { \n```", "```cpp\n      return data_.size();\n```", "```cpp\n   }\n```", "```cpp\n   T const & operator[](const std::size_t i) const\n```", "```cpp\n   {\n```", "```cpp\n      return data_[i];\n```", "```cpp\n   }\n```", "```cpp\n   T& operator[](const std::size_t i)\n```", "```cpp\n   {\n```", "```cpp\n      return data_[i];\n```", "```cpp\n   }\n```", "```cpp\nprivate:\n```", "```cpp\n   std::vector<T> data_;\n```", "```cpp\n};\n```", "```cpp\ntemplate<typename T, typename U>\n```", "```cpp\nauto operator+ (vector<T> const & a, vector<U> const & b)\n```", "```cpp\n{\n```", "```cpp\n   using result_type = decltype(std::declval<T>() + \n```", "```cpp\n                                std::declval<U>());\n```", "```cpp\n   vector<result_type> result(a.size());\n```", "```cpp\n   for (std::size_t i = 0; i < a.size(); ++i)\n```", "```cpp\n   {\n```", "```cpp\n      result[i] = a[i] + b[i];\n```", "```cpp\n   }\n```", "```cpp\n   return result;\n```", "```cpp\n}\n```", "```cpp\ntemplate<typename T, typename U>\n```", "```cpp\nauto operator* (vector<T> const & a, vector<U> const & b)\n```", "```cpp\n{\n```", "```cpp\n   using result_type = decltype(std::declval<T>() + \n```", "```cpp\n                                std::declval<U>());\n```", "```cpp\n   vector<result_type> result(a.size());\n```", "```cpp\n   for (std::size_t i = 0; i < a.size(); ++i)\n```", "```cpp\n   {\n```", "```cpp\n      result[i] = a[i] * b[i];\n```", "```cpp\n   }\n```", "```cpp\n   return result;\n```", "```cpp\n}\n```", "```cpp\ntemplate<typename T, typename S>\n```", "```cpp\nauto operator* (S const& s, vector<T> const& v)\n```", "```cpp\n{\n```", "```cpp\n   using result_type = decltype(std::declval<T>() + \n```", "```cpp\n                                std::declval<S>());\n```", "```cpp\n   vector<result_type> result(v.size());\n```", "```cpp\n   for (std::size_t i = 0; i < v.size(); ++i)\n```", "```cpp\n   {\n```", "```cpp\n      result[i] = s * v[i];\n```", "```cpp\n   }\n```", "```cpp\n   return result;\n```", "```cpp\n}\n```", "```cpp\nvector<int> v1{ 1,2,3 };\n```", "```cpp\nvector<int> v2{ 4,5,6 };\n```", "```cpp\ndouble a{ 1.5 };\n```", "```cpp\nvector<double> v3 = v1 + a * v2;       // {7.0, 9.5, 12.0}\n```", "```cpp\nvector<int>    v4 = v1 * v2 + v1 + v2; // {9, 17, 27}\n```", "```cpp\ntemplate<typename T, typename C = std::vector<T>>\n```", "```cpp\nstruct vector\n```", "```cpp\n{\n```", "```cpp\n   vector() = default;\n```", "```cpp\n   vector(std::size_t const n) : data_(n) {}\n```", "```cpp\n   vector(std::initializer_list<T>&& l) : data_(l) {}\n```", "```cpp\n   vector(C const & other) : data_(other) {}\n```", "```cpp\n   template<typename U, typename X>\n```", "```cpp\n   vector(vector<U, X> const& other) : data_(other.size()) \n```", "```cpp\n   {\n```", "```cpp\n      for (std::size_t i = 0; i < other.size(); ++i)\n```", "```cpp\n         data_[i] = static_cast<T>(other[i]);\n```", "```cpp\n   }\n```", "```cpp\n   template<typename U, typename X>\n```", "```cpp\n   vector& operator=(vector<U, X> const & other)\n```", "```cpp\n   {\n```", "```cpp\n      data_.resize(other.size());\n```", "```cpp\n      for (std::size_t i = 0; i < other.size(); ++i)\n```", "```cpp\n         data_[i] = static_cast<T>(other[i]);\n```", "```cpp\n      return *this;\n```", "```cpp\n   }\n```", "```cpp\n   std::size_t size() const noexcept\n```", "```cpp\n   {\n```", "```cpp\n      return data_.size();\n```", "```cpp\n   }\n```", "```cpp\n   T operator[](const std::size_t i) const\n```", "```cpp\n   {\n```", "```cpp\n      return data_[i];\n```", "```cpp\n   }\n```", "```cpp\n   T& operator[](const std::size_t i)\n```", "```cpp\n   {\n```", "```cpp\n      return data_[i];\n```", "```cpp\n   }\n```", "```cpp\n   C& data() noexcept { return data_; }\n```", "```cpp\n   C const & data() const noexcept { return data_; }\n```", "```cpp\nprivate:\n```", "```cpp\n   C data_;\n```", "```cpp\n};\n```", "```cpp\ntemplate<typename L, typename R>\n```", "```cpp\nstruct vector_add \n```", "```cpp\n{\n```", "```cpp\n   vector_add(L const & a, R const & b) : lhv(a), rhv(b) {}\n```", "```cpp\n   auto operator[](std::size_t const i) const\n```", "```cpp\n   {\n```", "```cpp\n      return lhv[i] + rhv[i];\n```", "```cpp\n   }\n```", "```cpp\n   std::size_t size() const noexcept\n```", "```cpp\n   {\n```", "```cpp\n      return lhv.size();\n```", "```cpp\n   }\n```", "```cpp\nprivate:\n```", "```cpp\n   L const & lhv;\n```", "```cpp\n   R const & rhv;\n```", "```cpp\n};\n```", "```cpp\ntemplate<typename L, typename R>\n```", "```cpp\nstruct vector_mul\n```", "```cpp\n{\n```", "```cpp\n   vector_mul(L const& a, R const& b) : lhv(a), rhv(b) {}\n```", "```cpp\n   auto operator[](std::size_t const i) const\n```", "```cpp\n   {\n```", "```cpp\n      return lhv[i] * rhv[i];\n```", "```cpp\n   }\n```", "```cpp\n   std::size_t size() const noexcept\n```", "```cpp\n   {\n```", "```cpp\n      return lhv.size();\n```", "```cpp\n   }\n```", "```cpp\nprivate:\n```", "```cpp\n   L const & lhv;\n```", "```cpp\n   R const & rhv;\n```", "```cpp\n};\n```", "```cpp\ntemplate<typename S, typename R>\n```", "```cpp\nstruct vector_scalar_mul\n```", "```cpp\n{\n```", "```cpp\n   vector_scalar_mul(S const& s, R const& b) : \n```", "```cpp\n      scalar(s), rhv(b) \n```", "```cpp\n   {}\n```", "```cpp\n   auto operator[](std::size_t const i) const\n```", "```cpp\n   {\n```", "```cpp\n      return scalar * rhv[i];\n```", "```cpp\n   }\n```", "```cpp\n   std::size_t size() const noexcept\n```", "```cpp\n   {\n```", "```cpp\n      return rhv.size();\n```", "```cpp\n   }\n```", "```cpp\nprivate:\n```", "```cpp\n   S const & scalar;\n```", "```cpp\n   R const & rhv;\n```", "```cpp\n};\n```", "```cpp\ntemplate<typename T, typename L, typename U, typename R>\n```", "```cpp\nauto operator+(vector<T, L> const & a, \n```", "```cpp\n               vector<U, R> const & b)\n```", "```cpp\n{\n```", "```cpp\n   using result_type = decltype(std::declval<T>() +\n```", "```cpp\n                                std::declval<U>());\n```", "```cpp\n   return vector<result_type, vector_add<L, R>>(\n```", "```cpp\n      vector_add<L, R>(a.data(), b.data()));\n```", "```cpp\n}\n```", "```cpp\ntemplate<typename T, typename L, typename U, typename R>\n```", "```cpp\nauto operator*(vector<T, L> const & a, \n```", "```cpp\n               vector<U, R> const & b)\n```", "```cpp\n{\n```", "```cpp\n   using result_type = decltype(std::declval<T>() + \n```", "```cpp\n                                std::declval<U>());\n```", "```cpp\n   return vector<result_type, vector_mul<L, R>>(\n```", "```cpp\n      vector_mul<L, R>(a.data(), b.data()));\n```", "```cpp\n}\n```", "```cpp\ntemplate<typename T, typename S, typename E>\n```", "```cpp\nauto operator*(S const& a, vector<T, E> const& v)\n```", "```cpp\n{\n```", "```cpp\n   using result_type = decltype(std::declval<T>() + \n```", "```cpp\n                                std::declval<S>());\n```", "```cpp\n   return vector<result_type, vector_scalar_mul<S, E>>(\n```", "```cpp\n      vector_scalar_mul<S, E>(a, v.data()));\n```", "```cpp\n}\n```", "```cpp\nnamespace rv = ranges::views;\n```", "```cpp\nstd::vector<int> v1{ 1, 2, 3 };\n```", "```cpp\nstd::vector<int> v2{ 4, 5, 6 };\n```", "```cpp\ndouble a { 1.5 };\n```", "```cpp\nauto sv2 = v2 | \n```", "```cpp\n           rv::transform([&a](int val) {return a * val; });\n```", "```cpp\nauto v3 = rv::zip_with(std::plus<>{}, v1, sv2);\n```", "```cpp\nnamespace rv = std::ranges::views;\n```", "```cpp\nstd::vector<int> v1{ 1, 2, 3 };\n```", "```cpp\nstd::vector<int> v2{ 4, 5, 6 };\n```", "```cpp\ndouble a { 1.5 };\n```", "```cpp\nauto sv2 = v2 | \n```", "```cpp\n           rv::transform([&a](int val) {return a * val; });\n```", "```cpp\nauto v3 = rv::zip_wiew(std::plus<>{}, v1, sv2);\n```", "```cpp\ntemplate <class T, class U>\n```", "```cpp\nstruct Typelist\n```", "```cpp\n{\n```", "```cpp\n  typedef T Head;\n```", "```cpp\n  typedef U Tail;\n```", "```cpp\n};\n```", "```cpp\nclass null_typelist {};\n```", "```cpp\ntypedef Typelist<int, \n```", "```cpp\n                 Typelist<double, null_typelist>> MyList;\n```", "```cpp\ntemplate <typename ... Ts>\n```", "```cpp\nstruct typelist {};\n```", "```cpp\nusing MyList = typelist<int, double>;\n```", "```cpp\ntemplate <typename ... Ts>\n```", "```cpp\nstruct transformer\n```", "```cpp\n{\n```", "```cpp\n   using input_types  = Ts...;\n```", "```cpp\n   using output_types = std::add_const_t<Ts>...;\n```", "```cpp\n};\n```", "```cpp\ntemplate <typename ... Ts>\n```", "```cpp\nstruct transformer\n```", "```cpp\n{\n```", "```cpp\n   using input_types  = typelist<Ts...>;\n```", "```cpp\n   using output_types = typelist<std::add_const_t<Ts>...>;\n```", "```cpp\n};\n```", "```cpp\nstatic_assert(\n```", "```cpp\n   std::is_same_v<\n```", "```cpp\n      transformer<int, double>::output_types, \n```", "```cpp\n      typelist<int const, double const>>);\n```", "```cpp\nstruct game_unit\n```", "```cpp\n{\n```", "```cpp\n   int attack;\n```", "```cpp\n   int defense;\n```", "```cpp\n};\n```", "```cpp\nstruct upgrade_defense\n```", "```cpp\n{\n```", "```cpp\n   void operator()(game_unit& u)\n```", "```cpp\n   {\n```", "```cpp\n      u.defense = static_cast<int>(u.defense * 1.2);\n```", "```cpp\n   }\n```", "```cpp\n};\n```", "```cpp\nstruct upgrade_attack\n```", "```cpp\n{\n```", "```cpp\n   void operator()(game_unit& u)\n```", "```cpp\n   {\n```", "```cpp\n      u.attack += 2;\n```", "```cpp\n   }\n```", "```cpp\n};\n```", "```cpp\nvoid upgrade_unit(game_unit& unit)\n```", "```cpp\n{\n```", "```cpp\n   using upgrade_types = \n```", "```cpp\n      typelist<upgrade_defense, upgrade_attack>;\n```", "```cpp\n   apply_functors<upgrade_types>{}(unit);\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename TL>\n```", "```cpp\nstruct apply_functors\n```", "```cpp\n{\n```", "```cpp\nprivate:\n```", "```cpp\n   template <size_t I>\n```", "```cpp\n   static void apply(game_unit& unit)\n```", "```cpp\n   {\n```", "```cpp\n      using F = at_t<I, TL>;\n```", "```cpp\n      std::invoke(F{}, unit);\n```", "```cpp\n   }\n```", "```cpp\n   template <size_t... I>\n```", "```cpp\n   static void apply_all(game_unit& unit, \n```", "```cpp\n                         std::index_sequence<I...>)\n```", "```cpp\n   {\n```", "```cpp\n      (apply<I>(unit), ...);\n```", "```cpp\n   }\n```", "```cpp\npublic:\n```", "```cpp\n   void operator()(game_unit& unit) const\n```", "```cpp\n   {\n```", "```cpp\n      apply_all(unit, \n```", "```cpp\n                std::make_index_sequence<length_v<TL>>{});\n```", "```cpp\n   }\n```", "```cpp\n};\n```", "```cpp\ngame_unit u{ 100, 50 };\n```", "```cpp\nstd::cout << std::format(\"{},{}\\n\", u.attack, u.defense);\n```", "```cpp\n// prints 100,50\n```", "```cpp\nupgrade_unit(u);\n```", "```cpp\nstd::cout << std::format(\"{},{}\\n\", u.attack, u.defense);\n```", "```cpp\n// prints 102,60\n```", "```cpp\nnamespace detail\n```", "```cpp\n{\n```", "```cpp\n   template <typename TL>\n```", "```cpp\n   struct length;\n```", "```cpp\n   template <template <typename...> typename TL, \n```", "```cpp\n             typename... Ts>\n```", "```cpp\n   struct length<TL<Ts...>>\n```", "```cpp\n   {\n```", "```cpp\n      using type = \n```", "```cpp\n        std::integral_constant<std::size_t, sizeof...(Ts)>;\n```", "```cpp\n   };\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename TL>\n```", "```cpp\nusing length_t = typename detail::length<TL>::type;\n```", "```cpp\ntemplate <typename TL>\n```", "```cpp\nconstexpr std::size_t length_v = length_t<TL>::value;\n```", "```cpp\nstatic_assert(\n```", "```cpp\n   length_t<typelist<int, double, char>>::value == 3);\n```", "```cpp\nstatic_assert(length_v<typelist<int, double, char>> == 3);\n```", "```cpp\nstatic_assert(length_v<typelist<int, double>> == 2);\n```", "```cpp\nstatic_assert(length_v<typelist<int>> == 1);\n```", "```cpp\nstruct empty_type {};\n```", "```cpp\nnamespace detail\n```", "```cpp\n{\n```", "```cpp\n   template <typename TL>\n```", "```cpp\n   struct front_type;\n```", "```cpp\n   template <template <typename...> typename TL, \n```", "```cpp\n             typename T, typename... Ts>\n```", "```cpp\n   struct front_type<TL<T, Ts...>>\n```", "```cpp\n   {\n```", "```cpp\n      using type = T;\n```", "```cpp\n   };\n```", "```cpp\n   template <template <typename...> typename TL>\n```", "```cpp\n   struct front_type<TL<>>\n```", "```cpp\n   {\n```", "```cpp\n      using type = empty_type;\n```", "```cpp\n   };\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename TL>\n```", "```cpp\nusing front_t = typename detail::front_type<TL>::type;\n```", "```cpp\nstatic_assert(\n```", "```cpp\n   std::is_same_v<front_t<typelist<>>, empty_type>);\n```", "```cpp\nstatic_assert(\n```", "```cpp\n   std::is_same_v<front_t<typelist<int>>, int>);\n```", "```cpp\nstatic_assert(\n```", "```cpp\n   std::is_same_v<front_t<typelist<int, double, char>>, \n```", "```cpp\n                  int>);\n```", "```cpp\nnamespace detail\n```", "```cpp\n{\n```", "```cpp\n   template <typename TL>\n```", "```cpp\n   struct back_type;\n```", "```cpp\n   template <template <typename...> typename TL, \n```", "```cpp\n             typename T, typename... Ts>\n```", "```cpp\n   struct back_type<TL<T, Ts...>>\n```", "```cpp\n   {\n```", "```cpp\n      using type = back_type<TL<Ts...>>::type;\n```", "```cpp\n   };\n```", "```cpp\n   template <template <typename...> typename TL, \n```", "```cpp\n             typename T>\n```", "```cpp\n   struct back_type<TL<T>>\n```", "```cpp\n   {\n```", "```cpp\n      using type = T;\n```", "```cpp\n   };\n```", "```cpp\n   template <template <typename...> typename TL>\n```", "```cpp\n   struct back_type<TL<>>\n```", "```cpp\n   {\n```", "```cpp\n      using type = empty_type;\n```", "```cpp\n   };\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename TL>\n```", "```cpp\nusing back_t = typename detail::back_type<TL>::type;\n```", "```cpp\nstatic_assert(\n```", "```cpp\n   std::is_same_v<back_t<typelist<>>, empty_type>);\n```", "```cpp\nstatic_assert(\n```", "```cpp\n   std::is_same_v<back_t<typelist<int>>, int>);\n```", "```cpp\nstatic_assert(\n```", "```cpp\n   std::is_same_v<back_t<typelist<int, double, char>>,\n```", "```cpp\n                  char>);\n```", "```cpp\nnamespace detail\n```", "```cpp\n{\n```", "```cpp\n   template <std::size_t I, std::size_t N, typename TL>\n```", "```cpp\n   struct at_type;\n```", "```cpp\n   template <std::size_t I, std::size_t N,\n```", "```cpp\n             template <typename...> typename TL, \n```", "```cpp\n             typename T, typename... Ts>\n```", "```cpp\n   struct at_type<I, N, TL<T, Ts...>>\n```", "```cpp\n   {\n```", "```cpp\n      using type = \n```", "```cpp\n         std::conditional_t<\n```", "```cpp\n            I == N, \n```", "```cpp\n            T, \n```", "```cpp\n            typename at_type<I, N + 1, TL<Ts...>>::type>;\n```", "```cpp\n   };\n```", "```cpp\n   template <std::size_t I, std::size_t N>\n```", "```cpp\n   struct at_type<I, N, typelist<>>\n```", "```cpp\n   {\n```", "```cpp\n      using type = empty_type;\n```", "```cpp\n   };\n```", "```cpp\n}\n```", "```cpp\ntemplate <std::size_t I, typename TL>\n```", "```cpp\nusing at_t = typename detail::at_type<I, 0, TL>::type;\n```", "```cpp\nstatic_assert(\n```", "```cpp\n   std::is_same_v<at_t<0, typelist<>>, empty_type>);\n```", "```cpp\nstatic_assert(\n```", "```cpp\n   std::is_same_v<at_t<0, typelist<int>>, int>);\n```", "```cpp\nstatic_assert(\n```", "```cpp\n   std::is_same_v<at_t<0, typelist<int, char>>, int>);\n```", "```cpp\nstatic_assert(\n```", "```cpp\n   std::is_same_v<at_t<1, typelist<>>, empty_type>);\n```", "```cpp\nstatic_assert(\n```", "```cpp\n   std::is_same_v<at_t<1, typelist<int>>, empty_type>);\n```", "```cpp\nstatic_assert(\n```", "```cpp\n   std::is_same_v<at_t<1, typelist<int, char>>, char>);\n```", "```cpp\nstatic_assert(\n```", "```cpp\n   std::is_same_v<at_t<2, typelist<>>, empty_type>);\n```", "```cpp\nstatic_assert(\n```", "```cpp\n   std::is_same_v<at_t<2, typelist<int>>, empty_type>);\n```", "```cpp\nstatic_assert(\n```", "```cpp\n   std::is_same_v<at_t<2, typelist<int, char>>, \n```", "```cpp\n                  empty_type>);\n```", "```cpp\nnamespace detail\n```", "```cpp\n{\n```", "```cpp\n   template <typename TL, typename T>\n```", "```cpp\n   struct push_back_type;\n```", "```cpp\n   template <template <typename...> typename TL, \n```", "```cpp\n             typename T, typename... Ts>\n```", "```cpp\n   struct push_back_type<TL<Ts...>, T>\n```", "```cpp\n   {\n```", "```cpp\n      using type = TL<Ts..., T>;\n```", "```cpp\n   };\n```", "```cpp\n   template <typename TL, typename T>\n```", "```cpp\n   struct push_front_type;\n```", "```cpp\n   template <template <typename...> typename TL, \n```", "```cpp\n             typename T, typename... Ts>\n```", "```cpp\n   struct push_front_type<TL<Ts...>, T>\n```", "```cpp\n   {\n```", "```cpp\n      using type = TL<T, Ts...>;\n```", "```cpp\n   };\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename TL, typename T>\n```", "```cpp\nusing push_back_t = \n```", "```cpp\n   typename detail::push_back_type<TL, T>::type;\n```", "```cpp\ntemplate <typename TL, typename T>\n```", "```cpp\nusing push_front_t = \n```", "```cpp\n   typename detail::push_front_type<TL, T>::type;\n```", "```cpp\nnamespace detail\n```", "```cpp\n{\n```", "```cpp\n   template <typename TL>\n```", "```cpp\n   struct pop_front_type;\n```", "```cpp\n   template <template <typename...> typename TL, \n```", "```cpp\n             typename T, typename... Ts>\n```", "```cpp\n   struct pop_front_type<TL<T, Ts...>>\n```", "```cpp\n   {\n```", "```cpp\n      using type = TL<Ts...>;\n```", "```cpp\n   };\n```", "```cpp\n   template <template <typename...> typename TL>\n```", "```cpp\n   struct pop_front_type<TL<>>\n```", "```cpp\n   {\n```", "```cpp\n      using type = TL<>;\n```", "```cpp\n   };\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename TL>\n```", "```cpp\nusing pop_front_t = \n```", "```cpp\n   typename detail::pop_front_type<TL>::type;\n```", "```cpp\nnamespace detail\n```", "```cpp\n{\n```", "```cpp\n   template <std::ptrdiff_t N, typename R, typename TL>\n```", "```cpp\n   struct pop_back_type;\n```", "```cpp\n   template <std::ptrdiff_t N, typename... Ts, \n```", "```cpp\n             typename U, typename... Us>\n```", "```cpp\n   struct pop_back_type<N, typelist<Ts...>, \n```", "```cpp\n                           typelist<U, Us...>> \n```", "```cpp\n   { \n```", "```cpp\n      using type = \n```", "```cpp\n         typename pop_back_type<N - 1, \n```", "```cpp\n                                typelist<Ts..., U>,\n```", "```cpp\n                                typelist<Us...>>::type;\n```", "```cpp\n   };\n```", "```cpp\n   template <typename... Ts, typename... Us>\n```", "```cpp\n   struct pop_back_type<0, typelist<Ts...>, \n```", "```cpp\n                           typelist<Us...>>\n```", "```cpp\n   { \n```", "```cpp\n      using type = typelist<Ts...>;\n```", "```cpp\n   };\n```", "```cpp\n   template <typename... Ts, typename U, typename... Us>\n```", "```cpp\n   struct pop_back_type<0, typelist<Ts...>, \n```", "```cpp\n                           typelist<U, Us...>>\n```", "```cpp\n   { \n```", "```cpp\n      using type = typelist<Ts...>;\n```", "```cpp\n   };\n```", "```cpp\n   template <>\n```", "```cpp\n   struct pop_back_type<-1, typelist<>, typelist<>>\n```", "```cpp\n   {\n```", "```cpp\n      using type = typelist<>;\n```", "```cpp\n   };\n```", "```cpp\n}\n```", "```cpp\ntemplate <typename TL>\n```", "```cpp\nusing pop_back_t = typename detail::pop_back_type<\n```", "```cpp\n   static_cast<std::ptrdiff_t>(length_v<TL>)-1, \n```", "```cpp\n               typelist<>, TL>::type;\n```", "```cpp\nstatic_assert(std::is_same_v<pop_back_t<typelist<>>, \n```", "```cpp\n                             typelist<>>);\n```", "```cpp\nstatic_assert(std::is_same_v<pop_back_t<typelist<double>>, \n```", "```cpp\n                             typelist<>>);\n```", "```cpp\nstatic_assert(\n```", "```cpp\n   std::is_same_v<pop_back_t<typelist<double, char>>, \n```", "```cpp\n                             typelist<double>>);\n```", "```cpp\nstatic_assert(\n```", "```cpp\n   std::is_same_v<pop_back_t<typelist<double, char, int>>,\n```", "```cpp\n                             typelist<double, char>>);\n```"]