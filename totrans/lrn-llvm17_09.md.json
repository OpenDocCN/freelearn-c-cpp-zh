["```cpp\n\n    #include \"llvm/ADT/Statistic.h\"\n    #include \"llvm/IR/Function.h\"\n    #include \"llvm/IR/PassManager.h\"\n    #include \"llvm/Passes/PassBuilder.h\"\n    #include \"llvm/Passes/PassPlugin.h\"\n    #include \"llvm/Support/Debug.h\"\n    ```", "```cpp\n\n    using namespace llvm;\n    ```", "```cpp\n\n    #define DEBUG_TYPE \"ppprofiler\"\n    ```", "```cpp\n\n    ALWAYS_ENABLED_STATISTIC(\n        NumOfFunc, \"Number of instrumented functions.\");\n    ```", "```cpp\n\n    namespace {\n    class PPProfilerIRPass\n        : public llvm::PassInfoMixin<PPProfilerIRPass> {\n    public:\n      llvm::PreservedAnalyses\n      run(llvm::Module &M, llvm::ModuleAnalysisManager &AM);\n    private:\n      void instrument(llvm::Function &F,\n                      llvm::Function *EnterFn,\n                      llvm::Function *ExitFn);\n    };\n    }\n    ```", "```cpp\n\n    void PPProfilerIRPass::instrument(llvm::Function &F,\n                                      Function *EnterFn,\n                                      Function *ExitFn) {\n    ```", "```cpp\n\n      ++NumOfFunc;\n    ```", "```cpp\n\n      IRBuilder<> Builder(&*F.getEntryBlock().begin());\n    ```", "```cpp\n\n      GlobalVariable *FnName =\n          Builder.CreateGlobalString(F.getName());\n    ```", "```cpp\n\n      Builder.CreateCall(EnterFn->getFunctionType(), EnterFn,\n                         {FnName});\n    ```", "```cpp\n\n      for (BasicBlock &BB : F) {\n        for (Instruction &Inst : BB) {\n          if (Inst.getOpcode() == Instruction::Ret) {\n            Builder.SetInsertPoint(&Inst);\n            Builder.CreateCall(ExitFn->getFunctionType(),\n                               ExitFn, {FnName});\n          }\n        }\n      }\n    }\n    ```", "```cpp\n\n    PreservedAnalyses\n    PPProfilerIRPass::run(Module &M,\n                          ModuleAnalysisManager &AM) {\n    ```", "```cpp\n\n      if (M.getFunction(\"__ppp_enter\") ||\n          M.getFunction(\"__ppp_exit\")) {\n        return PreservedAnalyses::all();\n      }\n    ```", "```cpp\n\n      Type *VoidTy = Type::getVoidTy(M.getContext());\n      PointerType *PtrTy =\n          PointerType::getUnqual(M.getContext());\n      FunctionType *EnterExitFty =\n          FunctionType::get(VoidTy, {PtrTy}, false);\n      Function *EnterFn = Function::Create(\n          EnterExitFty, GlobalValue::ExternalLinkage,\n          \"__ppp_enter\", M);\n      Function *ExitFn = Function::Create(\n          EnterExitFty, GlobalValue::ExternalLinkage,\n          \"__ppp_exit\", M);\n    ```", "```cpp\n\n      for (auto &F : M.functions()) {\n        if (!F.isDeclaration() && F.hasName())\n          instrument(F, EnterFn, ExitFn);\n      }\n    ```", "```cpp\n\n      return PreservedAnalyses::none();\n    }\n    ```", "```cpp\n\n    void RegisterCB(PassBuilder &PB) {\n      PB.registerPipelineParsingCallback(\n          [](StringRef Name, ModulePassManager &MPM,\n             ArrayRef<PassBuilder::PipelineElement>) {\n            if (Name == \"ppprofiler\") {\n              MPM.addPass(PPProfilerIRPass());\n              return true;\n            }\n            return false;\n          });\n    }\n    ```", "```cpp\n\n    llvm::PassPluginLibraryInfo getPPProfilerPluginInfo() {\n      return {LLVM_PLUGIN_API_VERSION, \"PPProfiler\", \"v0.1\",\n              RegisterCB};\n    }\n    ```", "```cpp\n\n    #ifndef LLVM_PPPROFILER_LINK_INTO_TOOLS\n    extern \"C\" LLVM_ATTRIBUTE_WEAK ::llvm::PassPluginLibraryInfo\n    llvmGetPassPluginInfo() {\n      return getPPProfilerPluginInfo();\n    }\n    #endif\n    ```", "```cpp\n\nadd_llvm_pass_plugin(PPProfiler PPProfiler.cpp)\n```", "```cpp\n\nadd_subdirectory(PPProfiler)\n```", "```cpp\n\n$ ninja install\n```", "```cpp\n\n-- Registering PPProfiler as a pass plugin (static build: OFF)\n```", "```cpp\n\n-- Registering PPProfiler as a pass plugin (static build: ON)\n```", "```cpp\n\n    HANDLE_EXTENSION(PPProfiler)\n    ```", "```cpp\n\n#ifndef LLVM_TRANSFORMS_PPPROFILER_PPPROFILER_H\n#define LLVM_TRANSFORMS_PPPROFILER_PPPROFILER_H\n#include \"llvm/IR/PassManager.h\"\nnamespace llvm {\nclass PPProfilerIRPass\n    : public llvm::PassInfoMixin<PPProfilerIRPass> {\npublic:\n  llvm::PreservedAnalyses\n  run(llvm::Module &M, llvm::ModuleAnalysisManager &AM);\nprivate:\n  void instrument(llvm::Function &F,\n                  llvm::Function *EnterFn,\n                  llvm::Function *ExitFn);\n};\n} // namespace llvm\n#endif\n```", "```cpp\n\n    #include \"llvm/Transforms/PPProfiler/PPProfiler.h\"\n    ```", "```cpp\n\nadd_llvm_component_library(LLVMPPProfiler\n  PPProfiler.cpp\n  LINK_COMPONENTS\n  Core\n  Support\n)\n```", "```cpp\n\nadd_subdirectory(PPProfiler)\n```", "```cpp\n\nMODULE_PASS(\"ppprofiler\", PPProfilerIRPass())\n```", "```cpp\n\n#include \"llvm/Transforms/PPProfiler/PPProfiler.h\"\n```", "```cpp\n\n  PPProfiler\n```", "```cpp\n\n#include <stdio.h>\nint main(int argc, char *argv[]) {\n  puts(\"Hello\");\n  return 0;\n}\n```", "```cpp\n\n$ clang -S -emit-llvm -O1 hello.c\n```", "```cpp\n\n$ cat hello.ll\n@.str = private unnamed_addr constant [6 x i8] c\"Hello\\00\",\n        align 1\ndefine dso_local i32 @main(\n          i32 noundef %0, ptr nocapture noundef readnone %1) {\n  %3 = tail call i32 @puts(\n                 ptr noundef nonnull dereferenceable(1) @.str)\n  ret i32 0\n}\n```", "```cpp\n\n$ opt --load-pass-plugin=./PPProfile.so \\\n      --passes=\"ppprofiler\" --stats hello.ll -o hello_inst.bc\n```", "```cpp\n\n===--------------------------------------------------------===\n                 ... Statistics Collected ...\n===--------------------------------------------------------===\n1 ppprofiler - Number of instrumented functions.\n```", "```cpp\n\nStatistics are disabled.  Build with asserts or with\n-DLLVM_FORCE_ENABLE_STATS\n```", "```cpp\n\n$ llvm-dis hello_inst.bc -o –\n@.str = private unnamed_addr constant [6 x i8] c\"Hello\\00\",\n        align 1\n@0 = private unnamed_addr constant [5 x i8] c\"main\\00\",\n     align 1\ndefine dso_local i32 @main(i32 noundef %0,\n                          ptr nocapture noundef readnone %1) {\n  call void @__ppp_enter(ptr @0)\n  %3 = tail call i32 @puts(\n                 ptr noundef nonnull dereferenceable(1) @.str)\n  call void @__ppp_exit(ptr @0)\n  ret i32 0\n}\n```", "```cpp\n\n    #include <stdio.h>\n    #include <stdlib.h>\n    #include <time.h>\n    ```", "```cpp\n\n    static FILE *FileFD = NULL;\n    static void cleanup() {\n      if (FileFD == NULL) {\n        fclose(FileFD);\n        FileFD = NULL;\n      }\n    }\n    ```", "```cpp\n\n    static void init() {\n      if (FileFD == NULL) {\n        FileFD = fopen(\"ppprofile.csv\", \"w\");\n        atexit(&cleanup);\n      }\n    }\n    ```", "```cpp\n\n    typedef unsigned long long Time;\n    static Time get_time() {\n      struct timespec ts;\n      clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &ts);\n      return 1000000000L * ts.tv_sec + ts.tv_nsec;\n    }\n    ```", "```cpp\n\n    void __ppp_enter(const char *FnName) {\n      init();\n      Time T = get_time();\n      void *Frame = __builtin_frame_address(1);\n      fprintf(FileFD,\n              // \"enter|name|clock|frame\"\n              „enter|%s|%llu|%p\\n\", FnName, T, Frame);\n    }\n    ```", "```cpp\n\n    void __ppp_exit(const char *FnName) {\n      init();\n      Time T = get_time();\n      void *Frame = __builtin_frame_address(1);\n      fprintf(FileFD,\n              // \"exit|name|clock|frame\"\n              „exit|%s|%llu|%p\\n\", FnName, T, Frame);\n    }\n    ```", "```cpp\n\n$ clang hello_inst.bc runtime.c\n$ ./a.out\n```", "```cpp\n\n$ cat ppprofile.csv\nenter|main|3300868|0x1\nexit|main|3760638|0x1\n```", "```cpp\n\n  PB.registerPipelineStartEPCallback(\n      [](ModulePassManager &PM, OptimizationLevel Level) {\n        PM.addPass(PPProfilerIRPass());\n      });\n```", "```cpp\n\n$ clang -fpass-plugin=./PPProfiler.so hello.c runtime.c\n```", "```cpp\n\n-DCMAKE_CXX_FLAGS=\"-fpass-plugin=<PluginPath>/PPProfiler.so\"\n```", "```cpp\n\n-DCMAKE_EXE_LINKER_FLAGS=\"<RuntimePath>/runtime.o\"\n```", "```cpp\n\nexport CC=clang\nexport CXX=clang++\n```", "```cpp\n\nBEGIN { FS = \"|\"; OFS = \"|\" }\n/enter/ { record[$2] = $0 }\n/exit/ { split(record[$2],val,\"|\")\n         print val[2], val[3], $3, $3-val[3], val[4] }\n```", "```cpp\n\nBEGIN { FS = \"|\"; count[\"\"] = 0; sum[\"\"] = 0 }\n{ count[$1]++; sum[$1] += $4 }\nEND { for (i in count) {\n        if (i != \"\") {\n          print count[i], sum[i], sum[i]/count[i], I }\n} }\n```", "```cpp\n\n{ cmd = \"llvm-cxxfilt \" $4\n  (cmd) | getline name\n  close(cmd); $4 = name; print }\n```", "```cpp\n\n$ cat ppprofile.csv | awk -f join.awk | awk -f avg.awk |\\\n  sort -nr | head -15 | awk -f demangle.awk\n```", "```cpp\n\n446 1545581 3465.43 charinfo::isASCII(char)\n409 826261 2020.2 llvm::StringRef::StringRef()\n382 899471 2354.64\n           tinylang::Token::is(tinylang::tok::TokenKind) const\n171 1561532 9131.77 charinfo::isIdentifierHead(char)\n```", "```cpp\n\n    #include \"llvm/Passes/PassBuilder.h\"\n    #include \"llvm/Passes/PassPlugin.h\"\n    #include \"llvm/Analysis/TargetTransformInfo.h\"\n    ```", "```cpp\n\n    static cl::opt<bool>\n        DebugPM(\"debug-pass-manager\", cl::Hidden,\n                cl::desc(\"Print PM debugging information\"));\n    static cl::opt<std::string> PassPipeline(\n        \"passes\",\n        cl::desc(\"A description of the pass pipeline\"));\n    static cl::list<std::string> PassPlugins(\n        \"load-pass-plugin\",\n        cl::desc(\"Load passes from plugin library\"));\n    ```", "```cpp\n\n    static cl::opt<signed char> OptLevel(\n        cl::desc(\"Setting the optimization level:\"),\n        cl::ZeroOrMore,\n        cl::values(\n            clEnumValN(3, \"O\", \"Equivalent to -O3\"),\n            clEnumValN(0, \"O0\", \"Optimization level 0\"),\n            clEnumValN(1, \"O1\", \"Optimization level 1\"),\n            clEnumValN(2, \"O2\", \"Optimization level 2\"),\n            clEnumValN(3, \"O3\", \"Optimization level 3\"),\n            clEnumValN(-1, \"Os\",\n                       \"Like -O2 with extra optimizations \"\n                       \"for size\"),\n            clEnumValN(\n                -2, \"Oz\",\n                \"Like -Os but reduces code size further\")),\n        cl::init(0));\n    ```", "```cpp\n\n    #define HANDLE_EXTENSION(Ext)                          \\\n      llvm::PassPluginLibraryInfo get##Ext##PluginInfo();\n    #include \"llvm/Support/Extension.def\"\n    ```", "```cpp\n\n    bool emit(StringRef Argv0, llvm::Module *M,\n              llvm::TargetMachine *TM,\n              StringRef InputFilename) {\n      PassBuilder PB(TM);\n    ```", "```cpp\n\n      for (auto &PluginFN : PassPlugins) {\n        auto PassPlugin = PassPlugin::Load(PluginFN);\n        if (!PassPlugin) {\n          WithColor::error(errs(), Argv0)\n              << \"Failed to load passes from '\" << PluginFN\n              << \"'. Request ignored.\\n\";\n          continue;\n        }\n        PassPlugin->registerPassBuilderCallbacks(PB);\n      }\n    ```", "```cpp\n\n    #define HANDLE_EXTENSION(Ext)                          \\\n      get##Ext##PluginInfo().RegisterPassBuilderCallbacks( \\\n          PB);\n    #include \"llvm/Support/Extension.def\"\n    ```", "```cpp\n\n      LoopAnalysisManager LAM(DebugPM);\n      FunctionAnalysisManager FAM(DebugPM);\n      CGSCCAnalysisManager CGAM(DebugPM);\n      ModuleAnalysisManager MAM(DebugPM);\n    ```", "```cpp\n\n      FAM.registerPass(\n          [&] { return PB.buildDefaultAAPipeline(); });\n      PB.registerModuleAnalyses(MAM);\n      PB.registerCGSCCAnalyses(CGAM);\n      PB.registerFunctionAnalyses(FAM);\n      PB.registerLoopAnalyses(LAM);\n      PB.crossRegisterProxies(LAM, FAM, CGAM, MAM);\n    ```", "```cpp\n\n      ModulePassManager MPM(DebugPM);\n    ```", "```cpp\n\n      if (!PassPipeline.empty()) {\n        if (auto Err = PB.parsePassPipeline(\n                MPM, PassPipeline)) {\n          WithColor::error(errs(), Argv0)\n              << toString(std::move(Err)) << \"\\n\";\n          return false;\n        }\n      }\n    ```", "```cpp\n\n      else {\n        StringRef DefaultPass;\n        switch (OptLevel) {\n        case 0: DefaultPass = \"default<O0>\"; break;\n        case 1: DefaultPass = \"default<O1>\"; break;\n        case 2: DefaultPass = \"default<O2>\"; break;\n        case 3: DefaultPass = \"default<O3>\"; break;\n        case -1: DefaultPass = \"default<Os>\"; break;\n        case -2: DefaultPass = \"default<Oz>\"; break;\n        }\n        if (auto Err = PB.parsePassPipeline(\n                MPM, DefaultPass)) {\n          WithColor::error(errs(), Argv0)\n              << toString(std::move(Err)) << \"\\n\";\n          return false;\n        }\n      }\n    ```", "```cpp\n\n      std::error_code EC;\n      sys::fs::OpenFlags OpenFlags = sys::fs::OF_None;\n      CodeGenFileType FileType = codegen::getFileType();\n      if (FileType == CGFT_AssemblyFile)\n        OpenFlags |= sys::fs::OF_Text;\n      auto Out = std::make_unique<llvm::ToolOutputFile>(\n          outputFilename(InputFilename), EC, OpenFlags);\n      if (EC) {\n        WithColor::error(errs(), Argv0)\n            << EC.message() << '\\n';\n        return false;\n      }\n    ```", "```cpp\n\n      legacy::PassManager CodeGenPM;\n      CodeGenPM.add(createTargetTransformInfoWrapperPass(\n          TM->getTargetIRAnalysis()));\n    ```", "```cpp\n\n      if (FileType == CGFT_AssemblyFile && EmitLLVM) {\n        CodeGenPM.add(createPrintModulePass(Out->os()));\n      }\n    ```", "```cpp\n\n      else {\n        if (TM->addPassesToEmitFile(CodeGenPM, Out->os(),\n                                    nullptr, FileType)) {\n          WithColor::error()\n              << \"No support for file type\\n\";\n          return false;\n        }\n      }\n    ```", "```cpp\n\n      MPM.run(*M, MAM);\n      CodeGenPM.run(*M);\n      Out->keep();\n      return true;\n    }\n    ```", "```cpp\n\n    set(LLVM_LINK_COMPONENTS ${LLVM_TARGETS_TO_BUILD}\n      AggressiveInstCombine Analysis AsmParser\n      BitWriter CodeGen Core Coroutines IPO IRReader\n      InstCombine Instrumentation MC ObjCARCOpts Remarks\n      ScalarOpts Support Target TransformUtils Vectorize\n      Passes)\n    ```", "```cpp\n\n    add_tinylang_tool(tinylang Driver.cpp SUPPORT_PLUGINS)\n    ```", "```cpp\n\n    target_link_libraries(tinylang\n      PRIVATE tinylangBasic tinylangCodeGen\n      tinylangLexer tinylangParser tinylangSema)\n    ```", "```cpp\n\n    $ ninja\n    ```", "```cpp\n\nPB.registerPipelineStartEPCallback(\n    [](ModulePassManager &MPM) {\n        MPM.addPass(PPProfilerIRPass());\n    });\n```", "```cpp\n\n    static cl::opt<std::string> PipelineStartEPPipeline(\n        \"passes-ep-pipeline-start\",\n        cl::desc(\"Pipeline start extension point));\n    ```", "```cpp\n\n      PB.registerPipelineStartEPCallback(\n          [&PB, Argv0](ModulePassManager &PM) {\n            if (auto Err = PB.parsePassPipeline(\n                    PM, PipelineStartEPPipeline)) {\n              WithColor::error(errs(), Argv0)\n                  << \"Could not parse pipeline \"\n                  << PipelineStartEPPipeline.ArgStr << \": \"\n                  << toString(std::move(Err)) << \"\\n\";\n            }\n          });\n    ```", "```cpp\n\n        PassBuilder::OptimizationLevel Olevel = …;\n        if (OLevel == PassBuilder::OptimizationLevel::O0)\n          MPM.addPass(AlwaysInlinerPass());\n        else\n          MPM = PB.buildPerModuleDefaultPipeline(OLevel, DebugPM);\n    ```"]