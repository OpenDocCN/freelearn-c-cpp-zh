<html><head></head><body>
  <div id="_idContainer031">
   <h1 class="chapter-number" id="_idParaDest-98">
    <a id="_idTextAnchor097">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     5
    </span>
   </h1>
   <h1 id="_idParaDest-99">
    <a id="_idTextAnchor098">
    </a>
    <span class="koboSpan" id="kobo.2.1">
     Atomic Operations
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.3.1">
     In
    </span>
    <a href="B22219_04.xhtml#_idTextAnchor074">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.4.1">
        Chapter 4
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.5.1">
     , we learned about lock-based thread synchronization.
    </span>
    <span class="koboSpan" id="kobo.5.2">
     We learned about mutexes, condition variables, and other thread synchronization primitives, which are all based on acquiring and releasing locks.
    </span>
    <span class="koboSpan" id="kobo.5.3">
     Those synchronization mechanisms are built on top of
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.6.1">
      atomic types and operations
     </span>
    </em>
    <span class="koboSpan" id="kobo.7.1">
     , this
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.8.1">
      chapter’s topic.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.9.1">
     We will study what atomic operations are and how they differ from lock-based synchronization primitives.
    </span>
    <span class="koboSpan" id="kobo.9.2">
     After reading this chapter, you will have a basic knowledge of atomic operations and some of their applications.
    </span>
    <span class="koboSpan" id="kobo.9.3">
     Lock-free (not using locks) synchronization based on atomic operations is a very complex subject requiring years to master, but we will give you what we hope will be a good introduction to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.10.1">
      the subject.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.11.1">
     In this chapter, we will cover the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.12.1">
      main topics:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.13.1">
      What are
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.14.1">
       atomic operations?
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.15.1">
      An introduction to the C++
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.16.1">
       memory model
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.17.1">
      What atomic types and operations are provided by the C++
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.18.1">
       Standard Library?
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.19.1">
      Some examples of atomic operations, from a simple counter to be used to gather statistics and a basic mutex-like lock to a full
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.20.1">
       single-producer-single-consumer
      </span>
     </strong>
     <span class="koboSpan" id="kobo.21.1">
      (
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.22.1">
       SPSC
      </span>
     </strong>
     <span class="koboSpan" id="kobo.23.1">
      ) lock-free
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.24.1">
       bounded queue
      </span>
     </span>
    </li>
   </ul>
   <h1 id="_idParaDest-100">
    <a id="_idTextAnchor099">
    </a>
    <span class="koboSpan" id="kobo.25.1">
     Technical requirements
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.26.1">
     You will need a recent C++ compiler with C++20 support.
    </span>
    <span class="koboSpan" id="kobo.26.2">
     Some short code examples will be provided as links to the very useful godbolt website (
    </span>
    <a href="https://godbolt.org">
     <span class="koboSpan" id="kobo.27.1">
      https://godbolt.org
     </span>
    </a>
    <span class="koboSpan" id="kobo.28.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.28.2">
     For full code examples, we will use the book repo, which is available
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.29.1">
      at
     </span>
    </span>
    <a href="https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.30.1">
       https://github.com/PacktPublishing/Asynchronous-Programming-with-CPP
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.31.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.32.1">
     The examples can be compiled and run locally.
    </span>
    <span class="koboSpan" id="kobo.32.2">
     We have tested the code on an Intel CPU computer running Linux (Ubuntu 24.04 LTS).
    </span>
    <span class="koboSpan" id="kobo.32.3">
     For atomic operations and especially for memory ordering (more on this later in this chapter), Intel CPUs are different from
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.33.1">
      Arm CPUs.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.34.1">
     Please note here that code performance and profiling will be the subject of
    </span>
    <a href="B22219_13.xhtml#_idTextAnchor267">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.35.1">
        Chapter 13
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.36.1">
     .
    </span>
    <span class="koboSpan" id="kobo.36.2">
     We will just make some remarks on performance in this chapter to avoid making it
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.37.1">
      unnecessarily long.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-101">
    <a id="_idTextAnchor100">
    </a>
    <span class="koboSpan" id="kobo.38.1">
     Introduction to atomic operations
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.39.1">
     Atomic operations are
    </span>
    <a id="_idIndexMarker322">
    </a>
    <span class="koboSpan" id="kobo.40.1">
     indivisible (hence the word atomic, from the Greek
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.41.1">
      ἄτομος
     </span>
    </em>
    <span class="koboSpan" id="kobo.42.1">
     ,
    </span>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.43.1">
       atomos
      </span>
     </em>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.44.1">
      , indivisible).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.45.1">
     In this section, we will introduce atomic operations, what they are, and some reasons to use (and not to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.46.1">
      use!) them.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-102">
    <a id="_idTextAnchor101">
    </a>
    <span class="koboSpan" id="kobo.47.1">
     Atomic operations versus non-atomic operations – an example
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.48.1">
     If you remember the simple counter example from
    </span>
    <a href="B22219_04.xhtml#_idTextAnchor074">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.49.1">
        Chapter 4
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.50.1">
     , we needed to use a synchronization mechanism (we used a mutex) for modifying the counter variable from different threads to avoid race
    </span>
    <a id="_idIndexMarker323">
    </a>
    <span class="koboSpan" id="kobo.51.1">
     conditions.
    </span>
    <span class="koboSpan" id="kobo.51.2">
     The cause of the race condition was that incrementing the counter required three operations: reading the
    </span>
    <a id="_idIndexMarker324">
    </a>
    <span class="koboSpan" id="kobo.52.1">
     counter value, incrementing it, and writing the modified counter value back to memory.
    </span>
    <span class="koboSpan" id="kobo.52.2">
     If only we could do that in one go, there would be no
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.53.1">
      race condition.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.54.1">
     This is exactly what could be achieved with an atomic operation: if we had some kind of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.55.1">
      atomic_increment
     </span>
    </strong>
    <span class="koboSpan" id="kobo.56.1">
     operation, each thread would read, increment, and write the counter in a single instruction, avoiding the race condition because at any time, incrementing the counter would be fully done.
    </span>
    <span class="koboSpan" id="kobo.56.2">
     By fully done we mean that each thread would either increment the counter or do nothing at all, making interruptions in the middle of a counter increment
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.57.1">
      operation impossible.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.58.1">
     The following two examples are for illustration purposes only and are not multithreaded.
    </span>
    <span class="koboSpan" id="kobo.58.2">
     We focus here on just the operations, whether atomic
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.59.1">
      or non-atomic.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.60.1">
     Let’s see this in the code.
    </span>
    <span class="koboSpan" id="kobo.60.2">
     For the C++ code and the generated assembly language shown in the following example, refer
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.61.1">
      to
     </span>
    </span>
    <a href="https://godbolt.org/z/f4dTacsKW">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.62.1">
       https://godbolt.org/z/f4dTacsKW
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.63.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.64.1">
int counter {0};
int main() {
    counter++;
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.65.1">
     The code increments a global counter.
    </span>
    <span class="koboSpan" id="kobo.65.2">
     Now let’s see the assembly code generated by the compiler and what
    </span>
    <a id="_idIndexMarker325">
    </a>
    <span class="koboSpan" id="kobo.66.1">
     instructions the CPU executes (the full assembly can be found in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.67.1">
      previous link):
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.68.1">
    Mov    eax, DWORD PTR counter[rip]
    Add    eax, 1
    Move    DWORD PTR counter[rip], eax</span></pre>
   <p>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.69.1">
      [1]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.70.1">
     copies the value stored in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.71.1">
      counter
     </span>
    </strong>
    <span class="koboSpan" id="kobo.72.1">
     to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.73.1">
      eax
     </span>
    </strong>
    <span class="koboSpan" id="kobo.74.1">
     register,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.75.1">
      [2]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.76.1">
     adds
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.77.1">
      1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.78.1">
     to the value stored in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.79.1">
      eax
     </span>
    </strong>
    <span class="koboSpan" id="kobo.80.1">
     , and finally,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.81.1">
      [3]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.82.1">
     copies back the content of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.83.1">
      eax
     </span>
    </strong>
    <span class="koboSpan" id="kobo.84.1">
     register to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.85.1">
      counter
     </span>
    </strong>
    <span class="koboSpan" id="kobo.86.1">
     variable.
    </span>
    <span class="koboSpan" id="kobo.86.2">
     So, a thread
    </span>
    <a id="_idIndexMarker326">
    </a>
    <span class="koboSpan" id="kobo.87.1">
     could execute
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.88.1">
      [1]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.89.1">
     and then be scheduled out, and another thread execute all three instructions after that.
    </span>
    <span class="koboSpan" id="kobo.89.2">
     When the first thread finishes incrementing the result, the counter will be incremented just once and thus the result will
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.90.1">
      be incorrect.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.91.1">
     The following code does the same: it increments a global counter.
    </span>
    <span class="koboSpan" id="kobo.91.2">
     This time, though, it uses atomic types and operations.
    </span>
    <span class="koboSpan" id="kobo.91.3">
     To get the code and the generated assembly in the following example, refer
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.92.1">
      to
     </span>
    </span>
    <a href="https://godbolt.org/z/9hrbo31vx">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.93.1">
       https://godbolt.org/z/9hrbo31vx
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.94.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.95.1">
#include &lt;atomic&gt;
std::atomic&lt;int&gt; counter {0};
int main() {
    counter++;
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.96.1">
     We will explain the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.97.1">
      std::atomic&lt;int&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.98.1">
     type and the atomic increment
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.99.1">
      operation later.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.100.1">
     The generated assembly code is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.101.1">
      the following:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.102.1">
    lock add    DWORD PTR counter[rip], 1</span></pre>
   <p>
    <span class="koboSpan" id="kobo.103.1">
     Just one instruction has been generated to add
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.104.1">
      1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.105.1">
     to the value stored in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.106.1">
      counter
     </span>
    </strong>
    <span class="koboSpan" id="kobo.107.1">
     variable.
    </span>
    <span class="koboSpan" id="kobo.107.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.108.1">
      lock
     </span>
    </strong>
    <span class="koboSpan" id="kobo.109.1">
     prefix here means that the following instruction (in this case
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.110.1">
      add
     </span>
    </strong>
    <span class="koboSpan" id="kobo.111.1">
     ) is going to be executed atomically.
    </span>
    <span class="koboSpan" id="kobo.111.2">
     Hence, in this second example, a thread cannot be interrupted in the middle of incrementing the counter.
    </span>
    <span class="koboSpan" id="kobo.111.3">
     As a side note, some Intel x64 instructions execute atomically and don’t use the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.112.1">
       lock
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.113.1">
      prefix.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.114.1">
     Atomic operations allow threads to read, modify (for example, increase a value), and write indivisibly, and can also be used as synchronization primitives (similar to the mutexes we saw in
    </span>
    <a href="B22219_04.xhtml#_idTextAnchor074">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.115.1">
        Chapter 4
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.116.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.116.2">
     In fact, all the lock-based synchronization primitives we have seen so far in this book are implemented using atomic operations.
    </span>
    <span class="koboSpan" id="kobo.116.3">
     Atomic operations must be provided by the CPU (as in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.117.1">
      lock
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.118.1">
       add
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.119.1">
      instruction).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.120.1">
     In this section, we have introduced atomic operations, defined what they are, and studied a very simple example
    </span>
    <a id="_idIndexMarker327">
    </a>
    <span class="koboSpan" id="kobo.121.1">
     of how they are implemented by looking at the assembly instructions that the
    </span>
    <a id="_idIndexMarker328">
    </a>
    <span class="koboSpan" id="kobo.122.1">
     compiler generates.
    </span>
    <span class="koboSpan" id="kobo.122.2">
     In the next section, we will look at some of the advantages and disadvantages of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.123.1">
      atomic operations.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-103">
    <a id="_idTextAnchor102">
    </a>
    <span class="koboSpan" id="kobo.124.1">
     When to use (and when not to use) atomic operations
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.125.1">
     Using atomic operations is a complex subject and it can be very difficult (or at least quite tricky) to master.
    </span>
    <span class="koboSpan" id="kobo.125.2">
     It requires a lot of experience, and we have attended some courses on this very subject where we were advised not to do it!
    </span>
    <span class="koboSpan" id="kobo.125.3">
     Anyway, you can always learn the basics and experiment as you do so.
    </span>
    <span class="koboSpan" id="kobo.125.4">
     We hope this book will help you progress in your
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.126.1">
      learning journey.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.127.1">
     Atomic operations can be used in the
    </span>
    <a id="_idIndexMarker329">
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.128.1">
      following cases:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.129.1">
       If multiple threads share a mutable state
      </span>
     </strong>
     <span class="koboSpan" id="kobo.130.1">
      : The need to synchronize threads is the most common case.
     </span>
     <span class="koboSpan" id="kobo.130.2">
      Of course, it is possible to use locks such as mutexes, but atomic
     </span>
     <a id="_idIndexMarker330">
     </a>
     <span class="koboSpan" id="kobo.131.1">
      operations, in some cases, will provide better performance.
     </span>
     <span class="koboSpan" id="kobo.131.2">
      Please note, however, that the use of atomic operations
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.132.1">
       does not
      </span>
     </em>
     <span class="koboSpan" id="kobo.133.1">
      guarantee
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.134.1">
       better performance.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.135.1">
       If synchronized access to shared state is fine-grained
      </span>
     </strong>
     <span class="koboSpan" id="kobo.136.1">
      : If the data we must synchronize is an integer or a pointer or any other variable of a C++ intrinsic type, then using atomic operations may be better than
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.137.1">
       using locks.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.138.1">
       To improve performance
      </span>
     </strong>
     <span class="koboSpan" id="kobo.139.1">
      : If you want to achieve maximum performance, then atomic operations can help reduce thread context switches (see
     </span>
     <a href="B22219_02.xhtml#_idTextAnchor035">
      <span class="No-Break">
       <em class="italic">
        <span class="koboSpan" id="kobo.140.1">
         Chapter 2
        </span>
       </em>
      </span>
     </a>
     <span class="koboSpan" id="kobo.141.1">
      ) and reduce the overhead introduced by locks, thus lowering latency.
     </span>
     <span class="koboSpan" id="kobo.141.2">
      Remember to always profile your code to be sure that performance is improved (we will see this in depth in
     </span>
     <a href="B22219_13.xhtml#_idTextAnchor267">
      <span class="No-Break">
       <em class="italic">
        <span class="koboSpan" id="kobo.142.1">
         Chapter 13
        </span>
       </em>
      </span>
     </a>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.143.1">
       ).
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.144.1">
     Locks can be used in the
    </span>
    <a id="_idIndexMarker331">
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.145.1">
      following cases:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.146.1">
       If the protected data is not fine-grained
      </span>
     </strong>
     <span class="koboSpan" id="kobo.147.1">
      : For example, we are synchronizing access to a data structure or an object bigger than 8 bytes (in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.148.1">
       modern CPUs).
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.149.1">
       If performance is not an issue
      </span>
     </strong>
     <span class="koboSpan" id="kobo.150.1">
      : Locks are much simpler to use and reason about (in some cases using locks gives better performance than using
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.151.1">
       atomic operations).
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.152.1">
       To avoid the need to acquire low-level knowledge
      </span>
     </strong>
     <span class="koboSpan" id="kobo.153.1">
      : To get the maximum performance out of atomic operations, a lot of low-level knowledge is required.
     </span>
     <span class="koboSpan" id="kobo.153.2">
      We will introduce some of it in the section,
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.154.1">
       The C++
      </span>
     </em>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.155.1">
        memory model
       </span>
      </em>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.156.1">
       .
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.157.1">
     We have just learned when to use and when not to use atomic operations.
    </span>
    <span class="koboSpan" id="kobo.157.2">
     Some applications such as low-latency/high-frequency trading systems require maximum performance and use atomic operations to achieve the lowest latency possible.
    </span>
    <span class="koboSpan" id="kobo.157.3">
     Most applications will work just fine synchronizing
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.158.1">
      with locks.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.159.1">
     In the next section, we will study the differences between blocking and non-blocking data structures and some related
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.160.1">
      concept definitions.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-104">
    <a id="_idTextAnchor103">
    </a>
    <span class="koboSpan" id="kobo.161.1">
     Non-blocking data structures
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.162.1">
     In
    </span>
    <a href="B22219_04.xhtml#_idTextAnchor074">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.163.1">
        Chapter 4
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.164.1">
     we studied the implementation of a synchronized queue.
    </span>
    <span class="koboSpan" id="kobo.164.2">
     We used mutexes and condition variables
    </span>
    <a id="_idIndexMarker332">
    </a>
    <span class="koboSpan" id="kobo.165.1">
     as synchronization primitives.
    </span>
    <span class="koboSpan" id="kobo.165.2">
     Data structures synchronized with locks are called
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.166.1">
      blocking data structures
     </span>
    </strong>
    <span class="koboSpan" id="kobo.167.1">
     because threads are
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.168.1">
      blocked
     </span>
    </em>
    <span class="koboSpan" id="kobo.169.1">
     (by the operating system), waiting until the locks
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.170.1">
      become available.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.171.1">
     Data structures that don’t use locks
    </span>
    <a id="_idIndexMarker333">
    </a>
    <span class="koboSpan" id="kobo.172.1">
     are called
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.173.1">
      non-blocking data structures
     </span>
    </strong>
    <span class="koboSpan" id="kobo.174.1">
     .
    </span>
    <span class="koboSpan" id="kobo.174.2">
     Most (but not all) of them
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.175.1">
      are lock-free.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.176.1">
     A data structure or algorithm is considered lock-free if each synchronized action completes in a finite number of steps, not allowing indefinite waiting for a condition to become true
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.177.1">
      or false.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.178.1">
     The types of lock-free data structures are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.179.1">
      the following:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.180.1">
       Obstruction-free
      </span>
     </strong>
     <span class="koboSpan" id="kobo.181.1">
      : A thread will complete its operation in a bounded number of steps if all other threads
     </span>
     <a id="_idIndexMarker334">
     </a>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.182.1">
       are suspended
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.183.1">
       Lock-free
      </span>
     </strong>
     <span class="koboSpan" id="kobo.184.1">
      : A thread
     </span>
     <a id="_idIndexMarker335">
     </a>
     <span class="koboSpan" id="kobo.185.1">
      will complete its operation in a bounded number of steps while multiple threads are working on the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.186.1">
       data structure
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.187.1">
       Wait-free
      </span>
     </strong>
     <span class="koboSpan" id="kobo.188.1">
      : All the threads
     </span>
     <a id="_idIndexMarker336">
     </a>
     <span class="koboSpan" id="kobo.189.1">
      will complete their operations in a bounded number of steps while multiple threads are working on the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.190.1">
       data structure
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.191.1">
     Implementing lock-free data
    </span>
    <a id="_idIndexMarker337">
    </a>
    <span class="koboSpan" id="kobo.192.1">
     structures is very complicated and before doing it, we need to be sure it’s necessary.
    </span>
    <span class="koboSpan" id="kobo.192.2">
     The reasons to use lock-free data structures are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.193.1">
      the following:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.194.1">
       Achieving maximum concurrency
      </span>
     </strong>
     <span class="koboSpan" id="kobo.195.1">
      : As we saw earlier, atomic operations are a good choice when the
     </span>
     <a id="_idIndexMarker338">
     </a>
     <span class="koboSpan" id="kobo.196.1">
      data access synchronization involves fine-grained data (such as native-type variables).
     </span>
     <span class="koboSpan" id="kobo.196.2">
      From the preceding definitions, a lock-free data structure will allow at least one of the threads accessing the data structure to make some progress in a bounded number of steps.
     </span>
     <span class="koboSpan" id="kobo.196.3">
      A wait-free structure will allow all the threads accessing the data structure to make
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.197.1">
       some progress.
      </span>
     </span>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.198.1">
       When we use locks, however, a thread owns the lock while the rest of the threads are just waiting for the lock to be available, so the concurrency achievable with lock-free data structures can be
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.199.1">
        much better.
       </span>
      </span>
     </p>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.200.1">
       No deadlocks
      </span>
     </strong>
     <span class="koboSpan" id="kobo.201.1">
      : Because there are no locks involved, it is impossible to have any deadlocks in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.202.1">
       our code.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.203.1">
       Performance
      </span>
     </strong>
     <span class="koboSpan" id="kobo.204.1">
      : Some applications must achieve the lowest latency possible and so waiting for a lock can be unacceptable.
     </span>
     <span class="koboSpan" id="kobo.204.2">
      When a thread tries to acquire the lock, and it is not available, then the operating system blocks the thread.
     </span>
     <span class="koboSpan" id="kobo.204.3">
      While the thread is blocked, there
     </span>
     <a id="_idIndexMarker339">
     </a>
     <span class="koboSpan" id="kobo.205.1">
      is a context switch for the scheduler to be able to schedule another thread for execution.
     </span>
     <span class="koboSpan" id="kobo.205.2">
      These context switches take time, and that time may be too
     </span>
     <a id="_idIndexMarker340">
     </a>
     <span class="koboSpan" id="kobo.206.1">
      much in a low-latency application such as a high-performance network
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.207.1">
       packet receiver/processor.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.208.1">
     We have now looked at what blocking and non-blocking data structures are and what lock-free code is.
    </span>
    <span class="koboSpan" id="kobo.208.2">
     We will introduce the C++ memory model in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.209.1">
      next section.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-105">
    <a id="_idTextAnchor104">
    </a>
    <span class="koboSpan" id="kobo.210.1">
     The C++ memory model
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.211.1">
     This section explains the
    </span>
    <a id="_idIndexMarker341">
    </a>
    <span class="koboSpan" id="kobo.212.1">
     C++ memory model and how it deals with concurrency.
    </span>
    <span class="koboSpan" id="kobo.212.2">
     The C++ memory model comes with C++11, and defines the two main features of memory
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.213.1">
      in C++:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.214.1">
      How objects are laid out in memory (that is, structural aspects).
     </span>
     <span class="koboSpan" id="kobo.214.2">
      This subject won’t be covered in this book, which is about
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.215.1">
       asynchronous programming.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.216.1">
      Memory modification order (that is, concurrency aspects).
     </span>
     <span class="koboSpan" id="kobo.216.2">
      We will see the different memory modification orders specified in the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.217.1">
       memory model.
      </span>
     </span>
    </li>
   </ul>
   <h2 id="_idParaDest-106">
    <a id="_idTextAnchor105">
    </a>
    <span class="koboSpan" id="kobo.218.1">
     Memory access order
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.219.1">
     Before we explain the C++ memory model and the different memory orderings it supports, let’s clarify
    </span>
    <a id="_idIndexMarker342">
    </a>
    <span class="koboSpan" id="kobo.220.1">
     what we mean by memory order.
    </span>
    <span class="koboSpan" id="kobo.220.2">
     Memory order refers to the order in which memory (that is, the variables in a program) is accessed.
    </span>
    <span class="koboSpan" id="kobo.220.3">
     Memory access can be either read or write (load and store).
    </span>
    <span class="koboSpan" id="kobo.220.4">
     But what is the actual order in which the variables of a program are accessed?
    </span>
    <span class="koboSpan" id="kobo.220.5">
     For the following code, there are three points of view: the written code order, the compiler-generated instructions order, and finally, the order in which the instructions are executed by the CPU.
    </span>
    <span class="koboSpan" id="kobo.220.6">
     These three orderings can all be the same or (more
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.221.1">
      likely) different.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.222.1">
     The first and obvious ordering is the one in the code.
    </span>
    <span class="koboSpan" id="kobo.222.2">
     An example of this is in the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.223.1">
      code snippet:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.224.1">
void func_a(int&amp; a, int&amp; b) {
    a += 1;
    b += 10;
    a += 2;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.225.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.226.1">
      func_a
     </span>
    </strong>
    <span class="koboSpan" id="kobo.227.1">
     function first adds 1 to variable
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.228.1">
      a
     </span>
    </strong>
    <span class="koboSpan" id="kobo.229.1">
     , then adds 10 to variable
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.230.1">
      b
     </span>
    </strong>
    <span class="koboSpan" id="kobo.231.1">
     , and finally, adds 2 to variable
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.232.1">
      a
     </span>
    </strong>
    <span class="koboSpan" id="kobo.233.1">
     .
    </span>
    <span class="koboSpan" id="kobo.233.2">
     This is our intention and the order in which we define the statements to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.234.1">
      be executed.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.235.1">
     The compiler will
    </span>
    <a id="_idIndexMarker343">
    </a>
    <span class="koboSpan" id="kobo.236.1">
     transform the preceding code into assembly instructions.
    </span>
    <span class="koboSpan" id="kobo.236.2">
     The compiler can change the order of our statements to make the generated code more efficient if the outcome of the code execution is unchanged.
    </span>
    <span class="koboSpan" id="kobo.236.3">
     For example, with the preceding code, the compiler could either do the two additions with variable
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.237.1">
      a
     </span>
    </strong>
    <span class="koboSpan" id="kobo.238.1">
     first and then the addition with variable
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.239.1">
      b
     </span>
    </strong>
    <span class="koboSpan" id="kobo.240.1">
     , or it could simply add 3 to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.241.1">
      a
     </span>
    </strong>
    <span class="koboSpan" id="kobo.242.1">
     and then 10 to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.243.1">
      b
     </span>
    </strong>
    <span class="koboSpan" id="kobo.244.1">
     .
    </span>
    <span class="koboSpan" id="kobo.244.2">
     As we mentioned previously, the compiler can do whatever it wants to optimize the code if the result is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.245.1">
      the same.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.246.1">
     Let’s now consider the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.247.1">
      following code:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.248.1">
void func_a(int&amp; a, int&amp; b) {
    a += 1;
    b += 10 + a;
    a += 2;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.249.1">
     In this case, the operation on
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.250.1">
      b
     </span>
    </strong>
    <span class="koboSpan" id="kobo.251.1">
     depends on the previous operation on
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.252.1">
      a
     </span>
    </strong>
    <span class="koboSpan" id="kobo.253.1">
     , so the compiler cannot reorder the statements, and the generated code will be like the code we write (same order
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.254.1">
      of operations).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.255.1">
     The CPU (which used in this book is a modern Intel x64 CPU) will run the generated code.
    </span>
    <span class="koboSpan" id="kobo.255.2">
     It can execute the compiler-generated instructions in a different order.
    </span>
    <span class="koboSpan" id="kobo.255.3">
     This is called out-of-order execution.
    </span>
    <span class="koboSpan" id="kobo.255.4">
     The CPU
    </span>
    <a id="_idIndexMarker344">
    </a>
    <span class="koboSpan" id="kobo.256.1">
     can do this, again, if the result
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.257.1">
      is correct.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.258.1">
     See this link for the generated code shown in the preceding
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.259.1">
      example:
     </span>
    </span>
    <a href="https://godbolt.org/z/Mhrcnsr9e">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.260.1">
       https://godbolt.org/z/Mhrcnsr9e
      </span>
     </span>
    </a>
   </p>
   <p>
    <span class="koboSpan" id="kobo.261.1">
     First, the generated instructions for
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.262.1">
      func_1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.263.1">
     show an optimization: the compiler combined both additions into one by adding 3 to variable
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.264.1">
      a
     </span>
    </strong>
    <span class="koboSpan" id="kobo.265.1">
     in one instruction.
    </span>
    <span class="koboSpan" id="kobo.265.2">
     Second, the generated instructions for
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.266.1">
      func_2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.267.1">
     are in the same order as the C++ statements we wrote.
    </span>
    <span class="koboSpan" id="kobo.267.2">
     In this case, the CPU could execute the instructions out of order, as there is no dependency among
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.268.1">
      the operations.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.269.1">
     To conclude, we can say that the code that the CPU will run can be different from the code we wrote (again, given that the result of the execution is the same as we intended in the program
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.270.1">
      we wrote).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.271.1">
     All the examples we have shown are fine for code that runs in a single thread.
    </span>
    <span class="koboSpan" id="kobo.271.2">
     The code instructions may be executed in different order depending on the compiler optimizations and the CPU out-of-order execution and the result will still
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.272.1">
      be correct.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.273.1">
     See the following
    </span>
    <a id="_idIndexMarker345">
    </a>
    <span class="koboSpan" id="kobo.274.1">
     code for an example of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.275.1">
      out-of-order execution:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.276.1">
    mov    eax, [var1]  ; load variable var1 into reg eax
    inc    eax          ; eax += 1
    mov    [var1], eax  ; store reg eax into var1
    xor    ecx, ecx     ; ecx = 0
    inc    ecx          ; ecx += 1
    add    eax, ecx     ; eax = eax + ecx</span></pre>
   <p>
    <span class="koboSpan" id="kobo.277.1">
     The CPU could execute the instructions in the order shown in the preceding code, that is,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.278.1">
      load var1 [1]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.279.1">
     .
    </span>
    <span class="koboSpan" id="kobo.279.2">
     Then, while the variable is being read, it could issue some of the later instructions, such as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.280.1">
      [4]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.281.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.282.1">
      [5]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.283.1">
     , and then, once
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.284.1">
      var1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.285.1">
     has been read, execute
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.286.1">
      [2]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.287.1">
     , then
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.288.1">
      [3]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.289.1">
     , and, finally,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.290.1">
      [6]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.291.1">
     .
    </span>
    <span class="koboSpan" id="kobo.291.2">
     The instructions were executed in a different order, but the result is still the same.
    </span>
    <span class="koboSpan" id="kobo.291.3">
     This is a typical example of out-of-order execution: the CPU issues a load instruction and instead of waiting for the data to become available, it executes some other instructions, if possible, to avoid being idle and to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.292.1">
      maximize performance.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.293.1">
     All the optimizations we have mentioned (both compiler and CPU) are always done without considering the interactions between threads.
    </span>
    <span class="koboSpan" id="kobo.293.2">
     Neither the compiler nor the CPU knows about different threads.
    </span>
    <span class="koboSpan" id="kobo.293.3">
     In these cases, we need to tell the compiler what it can and cannot do.
    </span>
    <span class="koboSpan" id="kobo.293.4">
     Atomic operations and locks are the way to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.294.1">
      do this.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.295.1">
     When, for example, we use atomic variables, we may not only require the operations to be atomic but also to follow a certain order for the code to work properly when running multiple threads.
    </span>
    <span class="koboSpan" id="kobo.295.2">
     This cannot be done by just the compiler or the CPU because neither has any information involving multiple threads.
    </span>
    <span class="koboSpan" id="kobo.295.3">
     To specify what order we want to use, the C++
    </span>
    <a id="_idIndexMarker346">
    </a>
    <span class="koboSpan" id="kobo.296.1">
     memory model offers
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.297.1">
      different
     </span>
    </span>
    <span class="No-Break">
     <a id="_idIndexMarker347">
     </a>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.298.1">
      options:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.299.1">
       Relaxed
      </span>
     </strong>
     <span class="No-Break">
      <strong class="bold">
       <span class="koboSpan" id="kobo.300.1">
        ordering
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.301.1">
       :
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.302.1">
        std::memory_order_relaxed
       </span>
      </strong>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.303.1">
       Acquire and release ordering
      </span>
     </strong>
     <span class="koboSpan" id="kobo.304.1">
      :
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.305.1">
       std::memory_order_acquire
      </span>
     </strong>
     <span class="koboSpan" id="kobo.306.1">
      ,
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.307.1">
       std::memory_order_release
      </span>
     </strong>
     <span class="koboSpan" id="kobo.308.1">
      ,
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.309.1">
       std::memory_order_acq_rel
      </span>
     </strong>
     <span class="koboSpan" id="kobo.310.1">
      ,
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.311.1">
       and
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.312.1">
        std::memory_order_consume
       </span>
      </strong>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.313.1">
       Sequential consistency
      </span>
     </strong>
     <span class="No-Break">
      <strong class="bold">
       <span class="koboSpan" id="kobo.314.1">
        ordering
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.315.1">
       :
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.316.1">
        std::memory_order_seq_cst
       </span>
      </strong>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.317.1">
     The C++ memory model defines an abstract
    </span>
    <a id="_idIndexMarker348">
    </a>
    <span class="koboSpan" id="kobo.318.1">
     machine to achieve independence from any specific CPU.
    </span>
    <span class="koboSpan" id="kobo.318.2">
     However, the CPU is still there and the features available in the memory model may not be
    </span>
    <a id="_idIndexMarker349">
    </a>
    <span class="koboSpan" id="kobo.319.1">
     available to a specific CPU.
    </span>
    <span class="koboSpan" id="kobo.319.2">
     For example, the Intel x64 architecture is quite restrictive and enforces quite a strong
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.320.1">
      memory order.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.321.1">
     The Intel x64 architecture uses a processor-ordered memory-ordering model that can be defined as being
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.322.1">
      write-ordered with store-buffer forwarding
     </span>
    </em>
    <span class="koboSpan" id="kobo.323.1">
     .
    </span>
    <span class="koboSpan" id="kobo.323.2">
     In a single-processor system, the memory-ordering model respects the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.324.1">
      following principles:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.325.1">
      Reads are not reordered with
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.326.1">
       any reads
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.327.1">
      Writes are not reordered with
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.328.1">
       any writes
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.329.1">
      Writes are not reordered with
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.330.1">
       older reads
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.331.1">
      Reads may be reordered with older writes (if the read and write to be reordered refer to different
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.332.1">
       memory locations)
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.333.1">
      Reads and writes are not reordered with locked (
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.334.1">
       atomic) instructions
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.335.1">
     There are more details in the Intel manuals (see the references at the end of the chapter), but the preceding principles are the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.336.1">
      most relevant.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.337.1">
     In a multi-processor system, the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.338.1">
      principles apply:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.339.1">
      Each of the individual processors uses the same ordering principles as in a
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.340.1">
       single-processor system
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.341.1">
      Writes by a single processor are observed in the same order by
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.342.1">
       all processors
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.343.1">
      Writes from an individual processor are not ordered with respect to the writes from
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.344.1">
       other processors
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.345.1">
      Memory ordering
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.346.1">
       obeys causality
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.347.1">
      Any two stores are seen in a consistent order by processors other than those performing
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.348.1">
       the store
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.349.1">
      Locked (atomic) instructions have
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.350.1">
       total order
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.351.1">
     The Intel architecture is strongly ordered; the store operations (write instructions) for each processor are observed by other processors in the same order they were performed, and each processor
    </span>
    <a id="_idIndexMarker350">
    </a>
    <span class="koboSpan" id="kobo.352.1">
     executes the stores in the same order as they appear in the program.
    </span>
    <span class="koboSpan" id="kobo.352.2">
     This is called
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.353.1">
      Total Store
     </span>
    </strong>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.354.1">
       Ordering
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.355.1">
      (
     </span>
    </span>
    <span class="No-Break">
     <strong class="bold">
      <span class="koboSpan" id="kobo.356.1">
       TSO
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.357.1">
      ).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.358.1">
     The ARM
    </span>
    <a id="_idIndexMarker351">
    </a>
    <span class="koboSpan" id="kobo.359.1">
     architecture supports
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.360.1">
      Weak Ordering
     </span>
    </strong>
    <span class="koboSpan" id="kobo.361.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.362.1">
      WO
     </span>
    </strong>
    <span class="koboSpan" id="kobo.363.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.363.2">
     These are the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.364.1">
      main principles:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.365.1">
      Reads and
     </span>
     <a id="_idIndexMarker352">
     </a>
     <span class="koboSpan" id="kobo.366.1">
      writes can be performed out of order.
     </span>
     <span class="koboSpan" id="kobo.366.2">
      In contrast to TSO where, as we have seen, there is no local reordering except of reads after writes to different addresses, the ARM architecture allows local reordering (unless otherwise specified using
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.367.1">
       special instructions).
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.368.1">
      A write is not guaranteed to be visible to all threads at the same time as it was in the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.369.1">
       Intel architecture.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.370.1">
      In general, this relatively non-restrictive memory ordering allows the cores to reorder instructions more freely, potentially increasing
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.371.1">
       multicore performance.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.372.1">
     We must say here that the more relaxed the memory order is, the more difficult it is to reason about the executed code, and the more challenging it becomes to correctly synchronize multiple threads with atomic operations.
    </span>
    <span class="koboSpan" id="kobo.372.2">
     Also, you should bear in mind that the atomicity is always guaranteed irrespective of the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.373.1">
      memory order.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.374.1">
     In this section, we have seen what is meant by order when accessing memory and how the ordering we specify in the code may not be the same order in which the CPU executes the code.
    </span>
    <span class="koboSpan" id="kobo.374.2">
     In the next section, we will see how to enforce some ordering using atomic types
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.375.1">
      and operations.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-107">
    <a id="_idTextAnchor106">
    </a>
    <span class="koboSpan" id="kobo.376.1">
     Enforcing ordering
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.377.1">
     We have seen already in
    </span>
    <a href="B22219_04.xhtml#_idTextAnchor074">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.378.1">
        Chapter 4
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.379.1">
     and earlier in this chapter that non-atomic operations on the same memory addresses executed from different threads may cause data races and undefined behavior.
    </span>
    <span class="koboSpan" id="kobo.379.2">
     To enforce the ordering of the operations between threads, we will use atomic types and their operations.
    </span>
    <span class="koboSpan" id="kobo.379.3">
     This section will explore what the use of atomics
    </span>
    <a id="_idIndexMarker353">
    </a>
    <span class="koboSpan" id="kobo.380.1">
     achieves in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.381.1">
      multithreaded code.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.382.1">
     The following simple example will help us to see what can be done with
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.383.1">
      atomic operations:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.384.1">
#include &lt;atomic&gt;
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;thread&gt;
std::string message;
std::atomic&lt;bool&gt; ready{false};
void reader() {
    using namespace std::chrono::literals;
    while (!ready.load()) {
        std::this_thread::sleep_for(1ms);
    }
    std::cout &lt;&lt; "Message received = " &lt;&lt; message &lt;&lt; std::endl;
}
void writer() {
    message = "Hello, World!";
    ready.store(true);
}
int main() {
    std::thread t1(reader);
    std::thread t2(writer);
    t1.join();
    t2.join();
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.385.1">
     In this example,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.386.1">
      reader()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.387.1">
     waits until the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.388.1">
      ready
     </span>
    </strong>
    <span class="koboSpan" id="kobo.389.1">
     variable is
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.390.1">
      true
     </span>
    </strong>
    <span class="koboSpan" id="kobo.391.1">
     and then prints a message set by
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.392.1">
      writer()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.393.1">
     .
    </span>
    <span class="koboSpan" id="kobo.393.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.394.1">
      writer()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.395.1">
     function sets the message and then sets the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.396.1">
      store
     </span>
    </strong>
    <span class="koboSpan" id="kobo.397.1">
     variable
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.398.1">
      to
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.399.1">
       true
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.400.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.401.1">
     Atomic
    </span>
    <a id="_idIndexMarker354">
    </a>
    <span class="koboSpan" id="kobo.402.1">
     operations provide us with two features for enforcing a certain order of execution in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.403.1">
      multithreaded code:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.404.1">
       Happens before
      </span>
     </strong>
     <span class="koboSpan" id="kobo.405.1">
      : In the preceding code,
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.406.1">
       [1]
      </span>
     </strong>
     <span class="koboSpan" id="kobo.407.1">
      (setting the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.408.1">
       message
      </span>
     </strong>
     <span class="koboSpan" id="kobo.409.1">
      variable) happens before
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.410.1">
       [2]
      </span>
     </strong>
     <span class="koboSpan" id="kobo.411.1">
      (setting the atomic
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.412.1">
       ready
      </span>
     </strong>
     <span class="koboSpan" id="kobo.413.1">
      variable to
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.414.1">
       true
      </span>
     </strong>
     <span class="koboSpan" id="kobo.415.1">
      ).
     </span>
     <span class="koboSpan" id="kobo.415.2">
      Also,
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.416.1">
       [3]
      </span>
     </strong>
     <span class="koboSpan" id="kobo.417.1">
      , reading the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.418.1">
       ready
      </span>
     </strong>
     <span class="koboSpan" id="kobo.419.1">
      variable in a loop until it is
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.420.1">
       true
      </span>
     </strong>
     <span class="koboSpan" id="kobo.421.1">
      , happens before
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.422.1">
       [4]
      </span>
     </strong>
     <span class="koboSpan" id="kobo.423.1">
      , printing the message.
     </span>
     <span class="koboSpan" id="kobo.423.2">
      In this case, we are using sequential consistency memory order (the default
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.424.1">
       memory order).
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.425.1">
       Synchronizes with
      </span>
     </strong>
     <span class="koboSpan" id="kobo.426.1">
      : This only happens between atomic operations.
     </span>
     <span class="koboSpan" id="kobo.426.2">
      In the preceding example, this means that when
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.427.1">
       ready
      </span>
     </strong>
     <span class="koboSpan" id="kobo.428.1">
      is set by
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.429.1">
       [1]
      </span>
     </strong>
     <span class="koboSpan" id="kobo.430.1">
      the value will be visible for subsequent reads (or writes) in different threads (of course, it is visible in the
     </span>
     <a id="_idIndexMarker355">
     </a>
     <span class="koboSpan" id="kobo.431.1">
      current thread), and when
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.432.1">
       ready
      </span>
     </strong>
     <span class="koboSpan" id="kobo.433.1">
      is read by
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.434.1">
       [3]
      </span>
     </strong>
     <span class="koboSpan" id="kobo.435.1">
      , the changed value will
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.436.1">
       be visible.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.437.1">
     Now that we have seen how atomic operations enforce memory access order from different threads, let’s see in detail each of the memory order options provided by the C++
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.438.1">
      memory model.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.439.1">
     Before we start, let’s remember here that the Intel x64 architecture (Intel and AMD desktop processors) is quite restrictive in relation to memory order, that there is no need for any additional instructions for acquire/release, and sequential consistency is cheap in terms of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.440.1">
      performance cost.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-108">
    <a id="_idTextAnchor107">
    </a>
    <span class="koboSpan" id="kobo.441.1">
     Sequential consistency
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.442.1">
     Sequential consistency
    </span>
    <a id="_idIndexMarker356">
    </a>
    <span class="koboSpan" id="kobo.443.1">
     guarantees the execution of the program in the way you wrote it.
    </span>
    <span class="koboSpan" id="kobo.443.2">
     In 1979 Leslie Lamport defined sequential consistency as being “
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.444.1">
      the result of an execution is the same as if the reads and writes occurred in some order, and the operations of each individual processor appear in this sequence in the order specified by
     </span>
    </em>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.445.1">
       its program.
      </span>
     </em>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.446.1">
      ”
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.447.1">
     In C++, sequential consistency is specified with the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.448.1">
      std::memory_order_seq_cst
     </span>
    </strong>
    <span class="koboSpan" id="kobo.449.1">
     option.
    </span>
    <span class="koboSpan" id="kobo.449.2">
     This is the most stringent memory order and it’s also the default one.
    </span>
    <span class="koboSpan" id="kobo.449.3">
     If no ordering option is specified, then sequential consistency will
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.450.1">
      be used.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.451.1">
     The C++ memory model by default ensures sequential consistency in the absence of race conditions within your code.
    </span>
    <span class="koboSpan" id="kobo.451.2">
     Consider it a pact: if we properly synchronize our program to prevent race conditions, C++ will maintain the appearance that the program executes in the sequence it
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.452.1">
      was written.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.453.1">
     In this model, all threads must see the same order of operations.
    </span>
    <span class="koboSpan" id="kobo.453.2">
     Operations can still be reordered as far as the visible result of the computation has the same result as the result of the unordered code.
    </span>
    <span class="koboSpan" id="kobo.453.3">
     The instructions and operations can be reordered if the reads and writes are performed in the same order as in the compiled code.
    </span>
    <span class="koboSpan" id="kobo.453.4">
     The CPU is free to reorder any other instructions between the reads and writes if the dependencies are satisfied.
    </span>
    <span class="koboSpan" id="kobo.453.5">
     Because of the consistent ordering it defines, sequential consistency is the most intuitive form of ordering.
    </span>
    <span class="koboSpan" id="kobo.453.6">
     To illustrate sequential consistency, let’s consider the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.454.1">
      following
     </span>
    </span>
    <span class="No-Break">
     <a id="_idIndexMarker357">
     </a>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.455.1">
      example:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.456.1">
#include &lt;atomic&gt;
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;
std::atomic&lt;bool&gt; x{ false };
std::atomic&lt;bool&gt; y{ false };
std::atomic&lt;int&gt; z{ 0 };
void write_x() {
    x.store(true, std::memory_order_seq_cst);
}
void write_y() {
    y.store(true, std::memory_order_seq_cst);
}
void read_x_then_y() {
    while (!x.load(std::memory_order_seq_cst)) {}
    if (y.load(std::memory_order_seq_cst)) {
        ++z;
    }
}
void read_y_then_x()
{
    while (!y.load(std::memory_order_seq_cst)) {}
    if (x.load(std::memory_order_seq_cst)) {
        ++z;
    }
}
int main() {
    std::thread t1(write_x);
    std::thread t2(write_y);
    std::thread t3(read_x_then_y);
    std::thread t4(read_y_then_x);
    t1.join();
    t2.join();
    t3.join();
    t4.join();
    if (z.load() == 0) {
        std::cout &lt;&lt; "This will never happen\n";
    }
    {
        std::cout &lt;&lt; "This will always happen and z = " &lt;&lt; z &lt;&lt; "\n";
    }
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.457.1">
     Because we are using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.458.1">
      std::memory_order_seq_cst
     </span>
    </strong>
    <span class="koboSpan" id="kobo.459.1">
     when running the code, we should note
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.460.1">
      the
     </span>
    </span>
    <span class="No-Break">
     <a id="_idIndexMarker358">
     </a>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.461.1">
      following:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.462.1">
      Operations in each thread are executed in the given order (no reordering of
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.463.1">
       atomic operations).
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.464.1">
       t1
      </span>
     </strong>
     <span class="koboSpan" id="kobo.465.1">
      and
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.466.1">
       t2
      </span>
     </strong>
     <span class="koboSpan" id="kobo.467.1">
      update
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.468.1">
       x
      </span>
     </strong>
     <span class="koboSpan" id="kobo.469.1">
      and
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.470.1">
       y
      </span>
     </strong>
     <span class="koboSpan" id="kobo.471.1">
      in order, and
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.472.1">
       t3
      </span>
     </strong>
     <span class="koboSpan" id="kobo.473.1">
      and
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.474.1">
       t4
      </span>
     </strong>
     <span class="koboSpan" id="kobo.475.1">
      see the same order.
     </span>
     <span class="koboSpan" id="kobo.475.2">
      Without this property,
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.476.1">
       t3
      </span>
     </strong>
     <span class="koboSpan" id="kobo.477.1">
      could see
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.478.1">
       x
      </span>
     </strong>
     <span class="koboSpan" id="kobo.479.1">
      and
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.480.1">
       y
      </span>
     </strong>
     <span class="koboSpan" id="kobo.481.1">
      change in order, but
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.482.1">
       t4
      </span>
     </strong>
     <span class="koboSpan" id="kobo.483.1">
      could see
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.484.1">
       the opposite.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.485.1">
      Any other ordering may print
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.486.1">
       This will never happen
      </span>
     </strong>
     <span class="koboSpan" id="kobo.487.1">
      because
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.488.1">
       t3
      </span>
     </strong>
     <span class="koboSpan" id="kobo.489.1">
      and
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.490.1">
       t4
      </span>
     </strong>
     <span class="koboSpan" id="kobo.491.1">
      could see the changes to
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.492.1">
       x
      </span>
     </strong>
     <span class="koboSpan" id="kobo.493.1">
      and
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.494.1">
       y
      </span>
     </strong>
     <span class="koboSpan" id="kobo.495.1">
      in the opposite order.
     </span>
     <span class="koboSpan" id="kobo.495.2">
      We will see an example of this in the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.496.1">
       next section.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.497.1">
     The sequential consistency in this example means that the following two things
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.498.1">
      will happen:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.499.1">
      Each store is seen by all the threads; that is, each store operation synchronizes with all the load operations for each variable, and all the threads see these changes in the same order they
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.500.1">
       are made
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.501.1">
      The operations happen in the same order for each thread (operations run in the same order as in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.502.1">
       the code)
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.503.1">
     Please note that the order between operations in different threads is not guaranteed and instructions from different threads may be executed in any order because the threads may
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.504.1">
      be scheduled.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-109">
    <a id="_idTextAnchor108">
    </a>
    <span class="koboSpan" id="kobo.505.1">
     Acquire-release ordering
    </span>
   </h2>
   <p>
    <strong class="bold">
     <span class="koboSpan" id="kobo.506.1">
      Acquire-release ordering
     </span>
    </strong>
    <span class="koboSpan" id="kobo.507.1">
     is less stringent than sequential consistency ordering.
    </span>
    <span class="koboSpan" id="kobo.507.2">
     We don’t get the total
    </span>
    <a id="_idIndexMarker359">
    </a>
    <span class="koboSpan" id="kobo.508.1">
     ordering of operations we had with sequential consistency ordering, but some synchronization is still possible.
    </span>
    <span class="koboSpan" id="kobo.508.2">
     In general, as we add more freedom to the memory ordering we may see a performance gain, but it will get more difficult to reason about the execution order of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.509.1">
      our code.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.510.1">
     In this ordering model, the atomic load operations are the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.511.1">
      std::memory_order_acquire
     </span>
    </strong>
    <span class="koboSpan" id="kobo.512.1">
     operations, the atomic store operations are the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.513.1">
      std::memory_order_release
     </span>
    </strong>
    <span class="koboSpan" id="kobo.514.1">
     operations, and the atomic read-modify-write operations may be the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.515.1">
      std::memory_order_acquire
     </span>
    </strong>
    <span class="koboSpan" id="kobo.516.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.517.1">
      std::memory_order_release
     </span>
    </strong>
    <span class="koboSpan" id="kobo.518.1">
     or
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.519.1">
       std::memory_order_acq_rel
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.520.1">
      operations.
     </span>
    </span>
   </p>
   <p>
    <strong class="bold">
     <span class="koboSpan" id="kobo.521.1">
      Acquire semantics
     </span>
    </strong>
    <span class="koboSpan" id="kobo.522.1">
     (used with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.523.1">
      std::memory_order_acquire
     </span>
    </strong>
    <span class="koboSpan" id="kobo.524.1">
     ) ensure that all of the read or write operations in
    </span>
    <a id="_idIndexMarker360">
    </a>
    <span class="koboSpan" id="kobo.525.1">
     one thread that appear
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.526.1">
      after
     </span>
    </em>
    <span class="koboSpan" id="kobo.527.1">
     the acquire operation in the source code happen after the acquire operation.
    </span>
    <span class="koboSpan" id="kobo.527.2">
     This prevents the memory from reordering the reads and writes that follow the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.528.1">
      acquire operation.
     </span>
    </span>
   </p>
   <p>
    <strong class="bold">
     <span class="koboSpan" id="kobo.529.1">
      Release semantics
     </span>
    </strong>
    <span class="koboSpan" id="kobo.530.1">
     (used with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.531.1">
      std::memory_order_release
     </span>
    </strong>
    <span class="koboSpan" id="kobo.532.1">
     ) ensure that the read or write operations in one thread that appear
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.533.1">
      before
     </span>
    </em>
    <span class="koboSpan" id="kobo.534.1">
     the release operation in the source code are completed before
    </span>
    <a id="_idIndexMarker361">
    </a>
    <span class="koboSpan" id="kobo.535.1">
     the release operation.
    </span>
    <span class="koboSpan" id="kobo.535.2">
     This prevents the memory reordering of the reads and writes that follow the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.536.1">
      release operation.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.537.1">
     The following example shows the same code as that shown in the previous section about sequential consistency, but in this case, we use the acquire-release memory order for the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.538.1">
      atomic operations:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.539.1">
#include &lt;atomic&gt;
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;
std::atomic&lt;bool&gt; x{ false };
std::atomic&lt;bool&gt; y{ false };
std::atomic&lt;int&gt; z{ 0 };
void write_x() {
    x.store(true, std::memory_order_release);
}
void write_y() {
    y.store(true, std::memory_order_release);
}
void read_x_then_y() {
    while (!x.load(std::memory_order_acquire)) {}
    if (y.load(std::memory_order_acquire)) {
        ++z;
    }
}
void read_y_then_x() {
    while (!y.load(std::memory_order_acquire)) {}
    if (x.load(std::memory_order_acquire)) {
        ++z;
    }
}
int main() {
    std::thread t1(write_x);
    std::thread t2(write_y);
    std::thread t3(read_x_then_y);
    std::thread t4(read_y_then_x);
    t1.join();
    t2.join();
    t3.join();
    t4.join();
    if (z.load() == 0) {
        std::cout &lt;&lt; "This will never happen\n";
    }
    {
        std::cout &lt;&lt; "This will always happen and z = " &lt;&lt; z &lt;&lt; "\n";
    }
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.540.1">
     In this case, it is possible for the value of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.541.1">
      z
     </span>
    </strong>
    <span class="koboSpan" id="kobo.542.1">
     to be 0.
    </span>
    <span class="koboSpan" id="kobo.542.2">
     Because we don’t have sequential consistency anymore
    </span>
    <a id="_idIndexMarker362">
    </a>
    <span class="koboSpan" id="kobo.543.1">
     after
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.544.1">
      t1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.545.1">
     sets
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.546.1">
      x
     </span>
    </strong>
    <span class="koboSpan" id="kobo.547.1">
     to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.548.1">
      true
     </span>
    </strong>
    <span class="koboSpan" id="kobo.549.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.550.1">
      t2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.551.1">
     sets
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.552.1">
      y
     </span>
    </strong>
    <span class="koboSpan" id="kobo.553.1">
     to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.554.1">
      true
     </span>
    </strong>
    <span class="koboSpan" id="kobo.555.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.556.1">
      t3
     </span>
    </strong>
    <span class="koboSpan" id="kobo.557.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.558.1">
      t4
     </span>
    </strong>
    <span class="koboSpan" id="kobo.559.1">
     may have different views of how memory access is being performed.
    </span>
    <span class="koboSpan" id="kobo.559.2">
     Because of the use of the acquire-release memory ordering,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.560.1">
      t3
     </span>
    </strong>
    <span class="koboSpan" id="kobo.561.1">
     may see
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.562.1">
      x
     </span>
    </strong>
    <span class="koboSpan" id="kobo.563.1">
     as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.564.1">
      true
     </span>
    </strong>
    <span class="koboSpan" id="kobo.565.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.566.1">
      y
     </span>
    </strong>
    <span class="koboSpan" id="kobo.567.1">
     as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.568.1">
      false
     </span>
    </strong>
    <span class="koboSpan" id="kobo.569.1">
     (remember, there is no enforce ordering) and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.570.1">
      t4
     </span>
    </strong>
    <span class="koboSpan" id="kobo.571.1">
     may see
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.572.1">
      x
     </span>
    </strong>
    <span class="koboSpan" id="kobo.573.1">
     as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.574.1">
      false
     </span>
    </strong>
    <span class="koboSpan" id="kobo.575.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.576.1">
      y
     </span>
    </strong>
    <span class="koboSpan" id="kobo.577.1">
     as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.578.1">
      true
     </span>
    </strong>
    <span class="koboSpan" id="kobo.579.1">
     .
    </span>
    <span class="koboSpan" id="kobo.579.2">
     When this happens, the value of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.580.1">
      z
     </span>
    </strong>
    <span class="koboSpan" id="kobo.581.1">
     will
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.582.1">
      be 0.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.583.1">
     Besides
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.584.1">
      std::memory_order_acquire
     </span>
    </strong>
    <span class="koboSpan" id="kobo.585.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.586.1">
      std::memory_order_release
     </span>
    </strong>
    <span class="koboSpan" id="kobo.587.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.588.1">
      std::memory_order_acq_rel
     </span>
    </strong>
    <span class="koboSpan" id="kobo.589.1">
     , the acquire-release memory ordering also includes the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.590.1">
      std::memory_order_consume
     </span>
    </strong>
    <span class="koboSpan" id="kobo.591.1">
     option.
    </span>
    <span class="koboSpan" id="kobo.591.2">
     We won’t be describing it because according to the online
    </span>
    <a id="_idIndexMarker363">
    </a>
    <span class="koboSpan" id="kobo.592.1">
     C++ reference, “
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.593.1">
      the specification of release-consume ordering is being revised, and the use of std::memory_order_consume is
     </span>
    </em>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.594.1">
       temporarily discouraged
      </span>
     </em>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.595.1">
      .”
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-110">
    <a id="_idTextAnchor109">
    </a>
    <span class="koboSpan" id="kobo.596.1">
     Relaxed memory ordering
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.597.1">
     To perform the atomic
    </span>
    <a id="_idIndexMarker364">
    </a>
    <span class="koboSpan" id="kobo.598.1">
     operation with
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.599.1">
      relaxed memory ordering
     </span>
    </strong>
    <span class="koboSpan" id="kobo.600.1">
     , we specify
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.601.1">
      std::memory_order_relaxed
     </span>
    </strong>
    <span class="koboSpan" id="kobo.602.1">
     as the memory
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.603.1">
      order option.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.604.1">
     Relaxed memory ordering is the
    </span>
    <a id="_idIndexMarker365">
    </a>
    <span class="koboSpan" id="kobo.605.1">
     weakest form of synchronization.
    </span>
    <span class="koboSpan" id="kobo.605.2">
     It offers
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.606.1">
      two guarantees:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.607.1">
      Atomicity of
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.608.1">
       the operations.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.609.1">
      Atomic operations on the same atomic variable in a single thread are not reordered.
     </span>
     <span class="koboSpan" id="kobo.609.2">
      This is called
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.610.1">
       modification order consistency
      </span>
     </strong>
     <span class="koboSpan" id="kobo.611.1">
      .
     </span>
     <span class="koboSpan" id="kobo.611.2">
      There is no guarantee, however, that the other
     </span>
     <a id="_idIndexMarker366">
     </a>
     <span class="koboSpan" id="kobo.612.1">
      threads will see these operations in the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.613.1">
       same order.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.614.1">
     Let’s consider the following scenario: one thread (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.615.1">
      th1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.616.1">
     ) stores values into an atomic variable.
    </span>
    <span class="koboSpan" id="kobo.616.2">
     After a certain random interval of time, the variable will be overwritten with a new random value.
    </span>
    <span class="koboSpan" id="kobo.616.3">
     We should assume for the sake of this example, that the sequence written is 2, 12, 23, 4, 6.
    </span>
    <span class="koboSpan" id="kobo.616.4">
     Another thread,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.617.1">
      th2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.618.1">
     , reads the same variable periodically.
    </span>
    <span class="koboSpan" id="kobo.618.2">
     The first time the variable is read,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.619.1">
      th2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.620.1">
     gets the value 23.
    </span>
    <span class="koboSpan" id="kobo.620.2">
     Remember that the variable is atomic and that both load and store operations are done using the relaxed
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.621.1">
      memory order.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.622.1">
     If
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.623.1">
      th2
     </span>
    </strong>
    <span class="koboSpan" id="kobo.624.1">
     reads the variable again, it can get the same value or any value written
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.625.1">
      after
     </span>
    </em>
    <span class="koboSpan" id="kobo.626.1">
     the previously read value.
    </span>
    <span class="koboSpan" id="kobo.626.2">
     It cannot read any value written before because the modification order consistency property would be violated.
    </span>
    <span class="koboSpan" id="kobo.626.3">
     In the current example, the second read may get 23, 4, or 6 but not 2 or 12.
    </span>
    <span class="koboSpan" id="kobo.626.4">
     If we get 4, th1 will go on to write 8, 19, and 7.
    </span>
    <span class="koboSpan" id="kobo.626.5">
     Now th2 may get 4, 6, 8, 19, or 7 but not any number before 4 and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.627.1">
      so on.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.628.1">
     Between two or more threads, there is no guarantee of any order, but once a value is read, a previously written value cannot
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.629.1">
      be read.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.630.1">
     The relaxed model cannot be used to synchronize threads, because there is no visibility order guarantee, but it is useful in scenarios where operations do not need to be coordinated tightly between threads, which can lead to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.631.1">
      performance improvements.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.632.1">
     It is generally safe to use when the order of execution does not affect the correctness of the program, such as incrementing counters used for statistics or reference counters where the exact order of increment is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.633.1">
      not important.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.634.1">
     In this section, we learned
    </span>
    <a id="_idIndexMarker367">
    </a>
    <span class="koboSpan" id="kobo.635.1">
     about the C++ memory model and how it allows the order and synchronization of atomic operations with different memory order constraints.
    </span>
    <span class="koboSpan" id="kobo.635.2">
     In the next section, we will see the atomic types and operations provided by the C++
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.636.1">
      Standard Library.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-111">
    <a id="_idTextAnchor110">
    </a>
    <span class="koboSpan" id="kobo.637.1">
     C++ Standard Library atomic types and operations
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.638.1">
     We will now introduce the data types and functions provided by the C++ Standard Library to support atomic types and operations.
    </span>
    <span class="koboSpan" id="kobo.638.2">
     As we have already seen, an atomic operation is an indivisible operation.
    </span>
    <span class="koboSpan" id="kobo.638.3">
     To be able to perform atomic operations in C++, we need to use the atomic types provided by the C++
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.639.1">
      Standard Library.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-112">
    <a id="_idTextAnchor111">
    </a>
    <span class="koboSpan" id="kobo.640.1">
     C++ Standard Library atomic types
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.641.1">
     The atomic types provided
    </span>
    <a id="_idIndexMarker368">
    </a>
    <span class="koboSpan" id="kobo.642.1">
     by the C++ Standard Library are defined in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.643.1">
      &lt;atomic&gt;
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.644.1">
      header file.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.645.1">
     You can see the documentation for all the atomic types defined in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.646.1">
      &lt;atomic&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.647.1">
     header in the online C++ reference, which you can access at
    </span>
    <a href="https://en.cppreference.com/w/cpp/atomic/atomic">
     <span class="koboSpan" id="kobo.648.1">
      https://en.cppreference.com/w/cpp/atomic/atomic
     </span>
    </a>
    <span class="koboSpan" id="kobo.649.1">
     .
    </span>
    <span class="koboSpan" id="kobo.649.2">
     We won’t include all the content in this reference here (that’s what the reference is for!), but we will introduce the main concepts and use examples to further elaborate
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.650.1">
      our explanations.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.651.1">
     The atomic types provided by the C++ Standard Library are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.652.1">
      the following:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.653.1">
       std::atomic_flag
      </span>
     </strong>
     <span class="koboSpan" id="kobo.654.1">
      : Atomic Boolean type (but different from
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.655.1">
       std::atomic&lt;bool&gt;
      </span>
     </strong>
     <span class="koboSpan" id="kobo.656.1">
      ).
     </span>
     <span class="koboSpan" id="kobo.656.2">
      It is the only atomic type that is guaranteed to be lock-free.
     </span>
     <span class="koboSpan" id="kobo.656.3">
      It does not provide load or store operations.
     </span>
     <span class="koboSpan" id="kobo.656.4">
      It is the most basic atomic type of all.
     </span>
     <span class="koboSpan" id="kobo.656.5">
      We will use it to implement a very simple
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.657.1">
       mutex-like lock.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.658.1">
       std::atomic&lt;T&gt;
      </span>
     </strong>
     <span class="koboSpan" id="kobo.659.1">
      : This is a template for defining atomic types.
     </span>
     <span class="koboSpan" id="kobo.659.2">
      All the intrinsic types have their own corresponding atomic type defined using this template.
     </span>
     <span class="koboSpan" id="kobo.659.3">
      The following are some examples of
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.660.1">
       these types:
      </span>
     </span>
     <ul>
      <li>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.661.1">
         std::atomic&lt;bool&gt;
        </span>
       </strong>
       <span class="koboSpan" id="kobo.662.1">
        (and its alias
       </span>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.663.1">
         atomic_bool
        </span>
       </strong>
       <span class="koboSpan" id="kobo.664.1">
        ): We will use this atomic type to implement the lazy one-time initialization of a variable from
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.665.1">
         several threads.
        </span>
       </span>
      </li>
      <li>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.666.1">
         std::atomic&lt;int&gt;
        </span>
       </strong>
       <span class="koboSpan" id="kobo.667.1">
        (and its alias
       </span>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.668.1">
         atomic_int
        </span>
       </strong>
       <span class="koboSpan" id="kobo.669.1">
        ): We have seen this atomic type
       </span>
       <a id="_idIndexMarker369">
       </a>
       <span class="koboSpan" id="kobo.670.1">
        already in the simple counter example.
       </span>
       <span class="koboSpan" id="kobo.670.2">
        We will use it again in an example to gather statistics (very similar to the
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.671.1">
         counter example).
        </span>
       </span>
      </li>
      <li>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.672.1">
         std::atomic&lt;intptr_t&gt;
        </span>
       </strong>
       <span class="koboSpan" id="kobo.673.1">
        (and its
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.674.1">
         alias
        </span>
       </span>
       <span class="No-Break">
        <strong class="source-inline">
         <span class="koboSpan" id="kobo.675.1">
          atomic_intptr_t
         </span>
        </strong>
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.676.1">
         ).
        </span>
       </span>
      </li>
      <li>
       <span class="koboSpan" id="kobo.677.1">
        C++20 introduced atomic smart pointers:
       </span>
       <strong class="source-inline">
        <span class="koboSpan" id="kobo.678.1">
         std::atomic&lt;std::shared_ptr&lt;U&gt;&gt;
        </span>
       </strong>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.679.1">
         and
        </span>
       </span>
       <span class="No-Break">
        <strong class="source-inline">
         <span class="koboSpan" id="kobo.680.1">
          std::atomic&lt;std::weak_ptr&lt;U&gt;&gt;
         </span>
        </strong>
       </span>
       <span class="No-Break">
        <span class="koboSpan" id="kobo.681.1">
         .
        </span>
       </span>
      </li>
     </ul>
    </li>
    <li>
     <span class="koboSpan" id="kobo.682.1">
      Since the release of C++20, there is a new atomic
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.683.1">
       type,
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.684.1">
        std::atomic_ref&lt;T&gt;
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.685.1">
       .
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.686.1">
     In this chapter, we will focus on
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.687.1">
      std::atomic_flag
     </span>
    </strong>
    <span class="koboSpan" id="kobo.688.1">
     and some of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.689.1">
      std::atomic
     </span>
    </strong>
    <span class="koboSpan" id="kobo.690.1">
     types.
    </span>
    <span class="koboSpan" id="kobo.690.2">
     For the other atomic types we have mentioned here, you can access the online C++ reference using the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.691.1">
      previous link.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.692.1">
     Before any further explanation of some of these types, there is a very important clarification to be made: just because a type is
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.693.1">
      atomic
     </span>
    </em>
    <span class="koboSpan" id="kobo.694.1">
     , that doesn’t guarantee it is
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.695.1">
      lock-free
     </span>
    </em>
    <span class="koboSpan" id="kobo.696.1">
     .
    </span>
    <span class="koboSpan" id="kobo.696.2">
     By atomic here, we mean indivisible operation, and by lock-free, we mean with special CPU atomic instructions support.
    </span>
    <span class="koboSpan" id="kobo.696.3">
     If there is no hardware support for certain atomic operations, they will be implemented using locks by the C++
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.697.1">
      Standard Library.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.698.1">
     To check whether an atomic type is lock-free we can use the following member function of any of the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.699.1">
       std::atomic&lt;T&gt;
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.700.1">
      types:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.701.1">
       bool is_lock_free() const noexcept
      </span>
     </strong>
     <span class="koboSpan" id="kobo.702.1">
      : This returns
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.703.1">
       true
      </span>
     </strong>
     <span class="koboSpan" id="kobo.704.1">
      if all the atomic operations of this type are lock-free, and
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.705.1">
       false
      </span>
     </strong>
     <span class="koboSpan" id="kobo.706.1">
      otherwise (except for
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.707.1">
       std::atomic_flag
      </span>
     </strong>
     <span class="koboSpan" id="kobo.708.1">
      , which is guaranteed to always be lock-free).
     </span>
     <span class="koboSpan" id="kobo.708.2">
      The rest of the atomic types can be implemented using locks such as mutexes to guarantee the atomicity of the operations.
     </span>
     <span class="koboSpan" id="kobo.708.3">
      Also, some atomic types may be lock-free only sometimes.
     </span>
     <span class="koboSpan" id="kobo.708.4">
      If only aligned memory access can be lock-free in a certain CPU, then the misaligned
     </span>
     <a id="_idIndexMarker370">
     </a>
     <span class="koboSpan" id="kobo.709.1">
      objects of that same atomic type will be implemented
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.710.1">
       using locks.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.711.1">
     There is also a constant used to indicate whether an atomic type is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.712.1">
      always lock-free:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.713.1">
       static constexpr bool is_always_lock_free = /* implementation defined */
      </span>
     </strong>
     <span class="koboSpan" id="kobo.714.1">
      : The value of this constant will be
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.715.1">
       true
      </span>
     </strong>
     <span class="koboSpan" id="kobo.716.1">
      if the atomic type is always lock-free (even for misaligned objects,
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.717.1">
       for example)
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.718.1">
     It is important to be aware of this: an atomic type is not guaranteed to be lock-free.
    </span>
    <span class="koboSpan" id="kobo.718.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.719.1">
      std::atomic&lt;T&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.720.1">
     template is not a magic mechanism that can turn all atomic types into lock-free
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.721.1">
      atomic types.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-113">
    <a id="_idTextAnchor112">
    </a>
    <span class="koboSpan" id="kobo.722.1">
     C++ Standard Library atomic operations
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.723.1">
     There are two main types of
    </span>
    <a id="_idIndexMarker371">
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.724.1">
      atomic operations:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.725.1">
       Member functions of atomic types
      </span>
     </strong>
     <span class="koboSpan" id="kobo.726.1">
      : For example,
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.727.1">
       std::atomic&lt;int&gt;
      </span>
     </strong>
     <span class="koboSpan" id="kobo.728.1">
      has the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.729.1">
       load()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.730.1">
      member function to atomically read
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.731.1">
       its value
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.732.1">
       Free functions
      </span>
     </strong>
     <span class="koboSpan" id="kobo.733.1">
      : The
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.734.1">
       const std::atomic_load(const std::atomic&lt;T&gt;* obj)
      </span>
     </strong>
     <span class="koboSpan" id="kobo.735.1">
      function does exactly the same as the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.736.1">
       previous one
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.737.1">
     You can access the following code (and the generated assembly code, if you are interested) at
    </span>
    <a href="https://godbolt.org/z/Yhdr3Y1Y8">
     <span class="koboSpan" id="kobo.738.1">
      https://godbolt.org/z/Yhdr3Y1Y8
     </span>
    </a>
    <span class="koboSpan" id="kobo.739.1">
     .
    </span>
    <span class="koboSpan" id="kobo.739.2">
     This code shows the use of both member functions and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.740.1">
      free functions:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.741.1">
#include &lt;atomic&gt;
#include &lt;iostream&gt;
std::atomic&lt;int&gt; counter {0};
int main() {
    // Using member functions
    int count = counter.load();
    std::cout &lt;&lt; count &lt;&lt; std::endl;
    count++;
    counter.store(count);
    // Using free functions
    count = std::atomic_load(&amp;counter);
    std::cout &lt;&lt; count &lt;&lt; std::endl;
    count++;
    std::atomic_store(&amp;counter, count);
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.742.1">
     Most of the atomic operation functions have a parameter to indicate the memory order.
    </span>
    <span class="koboSpan" id="kobo.742.2">
     We have already explained
    </span>
    <a id="_idIndexMarker372">
    </a>
    <span class="koboSpan" id="kobo.743.1">
     what the memory order is, and what memory ordering types are provided by C++ in the section about the C++
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.744.1">
      memory model.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-114">
    <a id="_idTextAnchor113">
    </a>
    <span class="koboSpan" id="kobo.745.1">
     Example – simple spin-lock implemented using the C++ atomic flag
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.746.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.747.1">
      std::atomic_flag
     </span>
    </strong>
    <span class="koboSpan" id="kobo.748.1">
     atomic type is the most basic standard atomic type.
    </span>
    <span class="koboSpan" id="kobo.748.2">
     It only has two states: set
    </span>
    <a id="_idIndexMarker373">
    </a>
    <span class="koboSpan" id="kobo.749.1">
     and not set (which we can also call true and false).
    </span>
    <span class="koboSpan" id="kobo.749.2">
     It is always lock-free, in contrast to any other standard atomic type.
    </span>
    <span class="koboSpan" id="kobo.749.3">
     Because it is so simple, it is mainly used as a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.750.1">
      building block.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.751.1">
     This is the code for the atomic
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.752.1">
      flag example:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.753.1">
#include &lt;atomic&gt;
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;
class spin_lock {
public:
    spin_lock() = default;
    spin_lock(const spin_lock &amp;) = delete;
    spin_lock &amp;operator=(const spin_lock &amp;) = delete;
    void lock() {
        while  (flag.test_and_set(std::memory_order_acquire)) {
        }
    }
    void unlock() {
        flag.clear(std::memory_order_release);
    }
private:
    std::atomic_flag flag = ATOMIC_FLAG_INIT;
};</span></pre>
   <p>
    <span class="koboSpan" id="kobo.754.1">
     We need to initialize
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.755.1">
      std::atomic_flag
     </span>
    </strong>
    <span class="koboSpan" id="kobo.756.1">
     before using it.
    </span>
    <span class="koboSpan" id="kobo.756.2">
     The following code shows how to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.757.1">
      do that:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.758.1">
std::atomic_flag flag = ATOMIC_FLAG_INIT;</span></pre>
   <p>
    <span class="koboSpan" id="kobo.759.1">
     This is the only way to initialize
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.760.1">
      std::atomic_flag
     </span>
    </strong>
    <span class="koboSpan" id="kobo.761.1">
     to a definite value.
    </span>
    <span class="koboSpan" id="kobo.761.2">
     The value of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.762.1">
      ATOMIC_FLAG_INIT
     </span>
    </strong>
    <span class="koboSpan" id="kobo.763.1">
     is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.764.1">
      implementation defined.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.765.1">
     Once the flag is initialized, we
    </span>
    <a id="_idIndexMarker374">
    </a>
    <span class="koboSpan" id="kobo.766.1">
     can perform two atomic operations
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.767.1">
      on it:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.768.1">
       clear
      </span>
     </strong>
     <span class="koboSpan" id="kobo.769.1">
      : This atomically sets the flag
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.770.1">
       to
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.771.1">
        false
       </span>
      </strong>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.772.1">
       test_and_set
      </span>
     </strong>
     <span class="koboSpan" id="kobo.773.1">
      : This atomically sets the flag to
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.774.1">
       true
      </span>
     </strong>
     <span class="koboSpan" id="kobo.775.1">
      and obtains its
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.776.1">
       previous value
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.777.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.778.1">
      clear
     </span>
    </strong>
    <span class="koboSpan" id="kobo.779.1">
     function can only be called with a relaxed, release, or sequential consistency memory order.
    </span>
    <span class="koboSpan" id="kobo.779.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.780.1">
      test_and_set
     </span>
    </strong>
    <span class="koboSpan" id="kobo.781.1">
     function can only be called with relaxed, acquire, or sequential consistency.
    </span>
    <span class="koboSpan" id="kobo.781.2">
     Using any other memory order will result in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.782.1">
      undefined behavior.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.783.1">
     Now let’s see how we can implement a simple spinlock using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.784.1">
      std::atomic_flag
     </span>
    </strong>
    <span class="koboSpan" id="kobo.785.1">
     .
    </span>
    <span class="koboSpan" id="kobo.785.2">
     First, we know that the operations are atomic, so the thread either clears the flag or it doesn’t, and if a thread clears the flag, it is fully cleared.
    </span>
    <span class="koboSpan" id="kobo.785.3">
     It is not possible for the thread to
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.786.1">
      half-clear
     </span>
    </em>
    <span class="koboSpan" id="kobo.787.1">
     the flag (remember this would be possible for some non-atomic flags).
    </span>
    <span class="koboSpan" id="kobo.787.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.788.1">
      test_and_set
     </span>
    </strong>
    <span class="koboSpan" id="kobo.789.1">
     function is atomic too, so the flag is set to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.790.1">
      true
     </span>
    </strong>
    <span class="koboSpan" id="kobo.791.1">
     , and we get the previous state in just
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.792.1">
      one go.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.793.1">
     To implement the basic spinlock, we need an atomic flag to atomically handle the lock status and two functions:
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.794.1">
      lock()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.795.1">
     to acquire the lock (as we have for a mutex) and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.796.1">
      unlock()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.797.1">
     to release
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.798.1">
      the lock.
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.799.1">
     Simple spin lock unlock() function
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.800.1">
     We will begin with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.801.1">
      unlock()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.802.1">
     , the simplest
    </span>
    <a id="_idIndexMarker375">
    </a>
    <span class="koboSpan" id="kobo.803.1">
     function.
    </span>
    <span class="koboSpan" id="kobo.803.2">
     It will only reset the flag (by making it false) and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.804.1">
      nothing more:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.805.1">
void unlock()
{
    flag.clear(std::memory_order_release);
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.806.1">
     The code is straightforward.
    </span>
    <span class="koboSpan" id="kobo.806.2">
     If we leave out the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.807.1">
      std::memory_order_seq_cst
     </span>
    </strong>
    <span class="koboSpan" id="kobo.808.1">
     parameter, the strictest memory order option, sequential consistency, will
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.809.1">
      be applied.
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.810.1">
     Simple spin lock lock() function
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.811.1">
     The lock function has more steps.
    </span>
    <span class="koboSpan" id="kobo.811.2">
     First, let’s explain what it does:
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.812.1">
      lock()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.813.1">
     must see whether the atomic flag is on.
    </span>
    <span class="koboSpan" id="kobo.813.2">
     If it is off, then
    </span>
    <a id="_idIndexMarker376">
    </a>
    <span class="koboSpan" id="kobo.814.1">
     turn it on and finish.
    </span>
    <span class="koboSpan" id="kobo.814.2">
     If the flag is on, then keep on looking until another thread turns it off.
    </span>
    <span class="koboSpan" id="kobo.814.3">
     We will use
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.815.1">
      test_and_set()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.816.1">
     to make this
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.817.1">
      function work:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.818.1">
void lock()
{
    while (flag.test_and_set(std::memory_order_acquire)) {}
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.819.1">
     The preceding code works in the following way: inside a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.820.1">
      while
     </span>
    </strong>
    <span class="koboSpan" id="kobo.821.1">
     loop,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.822.1">
      test_and_set
     </span>
    </strong>
    <span class="koboSpan" id="kobo.823.1">
     sets the flag to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.824.1">
      true
     </span>
    </strong>
    <span class="koboSpan" id="kobo.825.1">
     and returns the previous value.
    </span>
    <span class="koboSpan" id="kobo.825.2">
     If the flag is already set, setting it again doesn’t change anything and the function returns
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.826.1">
      true
     </span>
    </strong>
    <span class="koboSpan" id="kobo.827.1">
     , so the loop keeps on setting the flag.
    </span>
    <span class="koboSpan" id="kobo.827.2">
     When, eventually,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.828.1">
      test_and_set
     </span>
    </strong>
    <span class="koboSpan" id="kobo.829.1">
     returns
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.830.1">
      false
     </span>
    </strong>
    <span class="koboSpan" id="kobo.831.1">
     , this means that the flag was cleared and we can exit
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.832.1">
      the loop.
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.833.1">
     Simple spin lock issues
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.834.1">
     The simple spin lock implementation has been included in this chapter to introduce the use of atomic types (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.835.1">
      std::atomic_flag
     </span>
    </strong>
    <span class="koboSpan" id="kobo.836.1">
     , the simplest standard atomic type) and operations (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.837.1">
      clear
     </span>
    </strong>
    <span class="koboSpan" id="kobo.838.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.839.1">
      test_and_set
     </span>
    </strong>
    <span class="koboSpan" id="kobo.840.1">
     ), but it has some
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.841.1">
      serious issues:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.842.1">
      The first of these is its bad performance.
     </span>
     <span class="koboSpan" id="kobo.842.2">
      The code in the repo will let you experiment.
     </span>
     <span class="koboSpan" id="kobo.842.3">
      Expect the
     </span>
     <a id="_idIndexMarker377">
     </a>
     <span class="koboSpan" id="kobo.843.1">
      spinlock performance to be much worse than that of
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.844.1">
       the mutex.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.845.1">
      The thread is spinning all the time waiting for the flag to be cleared.
     </span>
     <span class="koboSpan" id="kobo.845.2">
      This busy wait is something to avoid, especially if there is
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.846.1">
       thread contention.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.847.1">
     You can try out the preceding code for this example.
    </span>
    <span class="koboSpan" id="kobo.847.2">
     We got these results, shown in
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.848.1">
      Table 5.1
     </span>
    </em>
    <span class="koboSpan" id="kobo.849.1">
     , when we ran it.
    </span>
    <span class="koboSpan" id="kobo.849.2">
     The code adds 1 to a counter 200 million times in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.850.1">
      each thread.
     </span>
    </span>
   </p>
   <table class="No-Table-Style _idGenTablePara-1" id="table001-2">
    <colgroup>
     <col/>
     <col/>
     <col/>
     <col/>
    </colgroup>
    <thead>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="bold">
          <span class="koboSpan" id="kobo.851.1">
           std::mutex
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="bold">
          <span class="koboSpan" id="kobo.852.1">
           spinlock
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="bold">
          <span class="koboSpan" id="kobo.853.1">
           atomic counter
          </span>
         </strong>
        </span>
       </p>
      </td>
     </tr>
    </thead>
    <tbody>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.854.1">
          One thread
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.855.1">
          1.03 s
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.856.1">
          1.33 s
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.857.1">
          0.82 s
         </span>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.858.1">
          Two threads
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.859.1">
          10.15 s
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.860.1">
          39.14 s
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.861.1">
          4.52 s
         </span>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.862.1">
          Four threads
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.863.1">
          24.61 s
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.864.1">
          128.84 s
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.865.1">
          9.13 s
         </span>
        </span>
       </p>
      </td>
     </tr>
    </tbody>
   </table>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.866.1">
     Table 5.1: Synchronization primitives profiling results
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.867.1">
     We can see from the preceding table how poorly the simple spinlock works and how it worsens with the addition of threads.
    </span>
    <span class="koboSpan" id="kobo.867.2">
     Note that this simple example is only for learning and that both the simple
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.868.1">
      std::mutex
     </span>
    </strong>
    <span class="koboSpan" id="kobo.869.1">
     spinlock and the atomic counter can be improved so that the atomic type
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.870.1">
      performs better.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.871.1">
     In this section, we have looked at
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.872.1">
      std::atomic_flag
     </span>
    </strong>
    <span class="koboSpan" id="kobo.873.1">
     , the most basic atomic type provided by the C++ Standard Library.
    </span>
    <span class="koboSpan" id="kobo.873.2">
     For further information about this type and about the new functionality added in C++20 please refer to the online C++ reference, which is available
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.874.1">
      at
     </span>
    </span>
    <a href="https://en.cppreference.com/w/cpp/atomic/atomic_flag">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.875.1">
       https://en.cppreference.com/w/cpp/atomic/atomic_flag
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.876.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.877.1">
     In the following section, we will look at how to create a simple way for a thread to tell the main thread how many items it
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.878.1">
      has processed.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-115">
    <a id="_idTextAnchor114">
    </a>
    <span class="koboSpan" id="kobo.879.1">
     Example – thread progress reporting
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.880.1">
     Sometimes we want to
    </span>
    <a id="_idIndexMarker378">
    </a>
    <span class="koboSpan" id="kobo.881.1">
     check the progress of a thread or be notified when it finishes.
    </span>
    <span class="koboSpan" id="kobo.881.2">
     This can be done in different ways, for example, using a mutex and a condition variable, or a shared variable synchronized by a mutex, as we have seen in
    </span>
    <a href="B22219_04.xhtml#_idTextAnchor074">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.882.1">
        Chapter 4
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.883.1">
     .
    </span>
    <span class="koboSpan" id="kobo.883.2">
     We also saw how to use atomic operations to synchronize a counter in this chapter.
    </span>
    <span class="koboSpan" id="kobo.883.3">
     We will use a similar counter in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.884.1">
      following example:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.885.1">
#include &lt;atomic&gt;
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;
constexpr int NUM_ITEMS{100000};
int main() {
    std::atomic&lt;int&gt; progress{0};
    std::thread worker([&amp;progress] {
        for (int i = 1; i &lt;= NUM_ITEMS; ++i) {
            progress.store(i, std::memory_order_relaxed);
            std::this_thread::sleep_for(std::chrono::milliseconds(1));
        }
    });
    while (true) {
        int processed_items = progress.load(std::memory_order_relaxed);
        std::cout &lt;&lt; "Progress: "
                  &lt;&lt; processed_items &lt;&lt; " / " &lt;&lt; NUM_ITEMS
                  &lt;&lt; std::endl;
        if (processed_items == NUM_ITEMS) {
            break;
        }
        std::this_thread::sleep_for(std::chrono::seconds(10));
    }
    worker.join();
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.886.1">
     The preceding code implements a thread (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.887.1">
      worker
     </span>
    </strong>
    <span class="koboSpan" id="kobo.888.1">
     ) that handles a certain number of items (here the handling is simulated just by making the thread sleep).
    </span>
    <span class="koboSpan" id="kobo.888.2">
     Every time the thread handles an item, it increments
    </span>
    <a id="_idIndexMarker379">
    </a>
    <span class="koboSpan" id="kobo.889.1">
     the variable progress.
    </span>
    <span class="koboSpan" id="kobo.889.2">
     The main thread executes a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.890.1">
      while
     </span>
    </strong>
    <span class="koboSpan" id="kobo.891.1">
     loop and, in each iteration, it accesses the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.892.1">
      progress
     </span>
    </strong>
    <span class="koboSpan" id="kobo.893.1">
     variable and writes a report of the progress (number of items handled).
    </span>
    <span class="koboSpan" id="kobo.893.2">
     Once all the items are handled, the loop
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.894.1">
      is finished.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.895.1">
     In this example, we use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.896.1">
      std::atomic&lt;int&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.897.1">
     atomic type (an atomic integer) and two
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.898.1">
      atomic operations:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.899.1">
       load()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.900.1">
      : This atomically retrieves the value of the
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.901.1">
        progress
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.902.1">
       variable
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.903.1">
       store()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.904.1">
      : This atomically modifies the value of the
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.905.1">
        progress
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.906.1">
       variable
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.907.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.908.1">
      worker
     </span>
    </strong>
    <span class="koboSpan" id="kobo.909.1">
     thread processing
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.910.1">
      progress
     </span>
    </strong>
    <span class="koboSpan" id="kobo.911.1">
     is read and written atomically, so no race conditions occur when two threads access the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.912.1">
       progress
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.913.1">
      variable.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.914.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.915.1">
      load()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.916.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.917.1">
      store()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.918.1">
     atomic operations have an extra parameter to indicate the memory order.
    </span>
    <span class="koboSpan" id="kobo.918.2">
     In this example, we have used
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.919.1">
      std::memory_order_relaxed
     </span>
    </strong>
    <span class="koboSpan" id="kobo.920.1">
     .
    </span>
    <span class="koboSpan" id="kobo.920.2">
     This is a typical example of the use of the relaxed memory order: one thread increases a counter, and another reads it.
    </span>
    <span class="koboSpan" id="kobo.920.3">
     The only ordering we need is reading increasing values and for that, the relaxed memory order
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.921.1">
      is enough.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.922.1">
     Having introduced the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.923.1">
      load()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.924.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.925.1">
      store()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.926.1">
     atomic operations to atomically read and write a variable, let’s see another example of a simple
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.927.1">
      statistic-gathering application.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-116">
    <a id="_idTextAnchor115">
    </a>
    <span class="koboSpan" id="kobo.928.1">
     Example – simple statistics
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.929.1">
     This example builds on the same idea as the previous one: a thread can use atomic operations to communicate progress (for example, the number of items processed) to another thread.
    </span>
    <span class="koboSpan" id="kobo.929.2">
     In this new example, one thread will produce some data that another thread will read.
    </span>
    <span class="koboSpan" id="kobo.929.3">
     We need to synchronize memory access because we have two threads sharing the same memory and
    </span>
    <a id="_idIndexMarker380">
    </a>
    <span class="koboSpan" id="kobo.930.1">
     at least one of them is changing the memory.
    </span>
    <span class="koboSpan" id="kobo.930.2">
     As in the previous example, we will use atomic operations for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.931.1">
      this purpose.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.932.1">
     The following code declares the atomic variables we are going to use to gather statistics – one for the number of items processed and two more (for the total processing time and average processing time for each
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.933.1">
      item, respectively):
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.934.1">
std::atomic&lt;int&gt; processed_items{0};
std::atomic&lt;float&gt; total_time{0.0f};
std::atomic&lt;double&gt; average_time{0.0};</span></pre>
   <p>
    <span class="koboSpan" id="kobo.935.1">
     We use atomic float and double for total time and average time.
    </span>
    <span class="koboSpan" id="kobo.935.2">
     In the full example code, we make sure both types are lock-free, which means they use atomic instructions from the CPU (all modern CPUs should
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.936.1">
      have that).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.937.1">
     Now let’s see how the worker thread uses
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.938.1">
      the variables:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.939.1">
processed_items.fetch_add(1, std::memory_order_relaxed);
total_time.fetch_add(elapsed_s, std::memory_order_relaxed);
average_time.store(total_time.load() / processed_items.load(), std::memory_order_relaxed);</span></pre>
   <p>
    <span class="koboSpan" id="kobo.940.1">
     The first line increments the processed items by 1 in an atomic way.
    </span>
    <span class="koboSpan" id="kobo.940.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.941.1">
      fetch_add
     </span>
    </strong>
    <span class="koboSpan" id="kobo.942.1">
     function adds
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.943.1">
      1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.944.1">
     to the variable value and gives back the old value (we are not using it in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.945.1">
      this case).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.946.1">
     The second line adds
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.947.1">
      elapsed_s
     </span>
    </strong>
    <span class="koboSpan" id="kobo.948.1">
     (the time it took to process one item in seconds) to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.949.1">
      total_time
     </span>
    </strong>
    <span class="koboSpan" id="kobo.950.1">
     variable, which we use to keep track of the time it takes to process all
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.951.1">
      the items.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.952.1">
     Then, the third line computes the mean time for each item by atomically reading
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.953.1">
      total_time
     </span>
    </strong>
    <span class="koboSpan" id="kobo.954.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.955.1">
      processed_items
     </span>
    </strong>
    <span class="koboSpan" id="kobo.956.1">
     and atomically writing the result in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.957.1">
      average_time
     </span>
    </strong>
    <span class="koboSpan" id="kobo.958.1">
     .
    </span>
    <span class="koboSpan" id="kobo.958.2">
     Alternatively, we could use the values from the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.959.1">
      fetch_add()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.960.1">
     calls to calculate the mean time, but they don’t include the last item that was processed.
    </span>
    <span class="koboSpan" id="kobo.960.2">
     We could also do the calculation of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.961.1">
      average_time
     </span>
    </strong>
    <span class="koboSpan" id="kobo.962.1">
     in the main thread, but we do it in the worker thread here, just as an example and to practice using atomic operations.
    </span>
    <span class="koboSpan" id="kobo.962.2">
     Keep in mind that our aim (at least in this chapter) is not so much speed but learning how to use
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.963.1">
      atomic operations.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.964.1">
     The following is
    </span>
    <a id="_idIndexMarker381">
    </a>
    <span class="koboSpan" id="kobo.965.1">
     the full code for the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.966.1">
      statistics example:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.967.1">
#include &lt;atomic&gt;
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;random&gt;
#include &lt;thread&gt;
constexpr int NUM_ITEMS{10000};
void process() {
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution&lt;&gt; dis(1, 20);
    int sleep_duration = dis(gen);
        std::this_thread::sleep_for(std::chrono::milliseconds(sleep_duration));
}
int main() {
    std::atomic&lt;int&gt; processed_items{0};
    std::atomic&lt;float&gt; total_time{0.0f};
    std::atomic&lt;double&gt; average_time{0.0};
    std::thread worker([&amp;] {
        for (int i = 1; i &lt;= NUM_ITEMS; ++i) {
            auto now = std::chrono::high_resolution_clock::now();
            process();
            auto elapsed = 
                std::chrono::high_resolution_clock::now() - now;
            float elapsed_s =
                std::chrono::duration&lt;float&gt;(elapsed).count();
            processed_items.fetch_add(1, std::memory_order_relaxed);
            total_time.fetch_add(elapsed_s, std::memory_order_relaxed);
            average_time.store(total_time.load() / processed_items.load(), std::memory_order_relaxed);
        }
    });
    while (true) {
        int items = processed_items.load(std::memory_order_relaxed);
        std::cout &lt;&lt; "Progress: " &lt;&lt; items &lt;&lt; " / " &lt;&lt; NUM_ITEMS &lt;&lt; std::endl;
        float time = total_time.load(std::memory_order_relaxed);
        std::cout &lt;&lt; "Total time: " &lt;&lt; time &lt;&lt; " sec" &lt;&lt; std::endl;
        double average = average_time.load(std::memory_order_relaxed);
        std::cout &lt;&lt; "Average time: " &lt;&lt; average * 1000 &lt;&lt; " ms" &lt;&lt; std::endl;
        if (items == NUM_ITEMS) {
            break;
        }
        std::this_thread::sleep_for(std::chrono::seconds(5));
    }
    worker.join();
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.968.1">
     Let’s summarize what we have seen up to this point in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.969.1">
      current section:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.970.1">
      C++ standard atomic types: we used
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.971.1">
       std::atomic_flag
      </span>
     </strong>
     <span class="koboSpan" id="kobo.972.1">
      to implement a simple spinlock and we have used some of the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.973.1">
       std::atomic&lt;T&gt;
      </span>
     </strong>
     <span class="koboSpan" id="kobo.974.1">
      types to implement
     </span>
     <a id="_idIndexMarker382">
     </a>
     <span class="koboSpan" id="kobo.975.1">
      communication of simple data between threads.
     </span>
     <span class="koboSpan" id="kobo.975.2">
      All the atomic types that we have seen
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.976.1">
       are lock-free.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.977.1">
      The
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.978.1">
       load()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.979.1">
      atomic operation to atomically read the value of an
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.980.1">
       atomic variable.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.981.1">
      The
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.982.1">
       store()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.983.1">
      atomic operation to atomically write a new value to an
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.984.1">
       atomic variable.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.985.1">
       clear()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.986.1">
      and
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.987.1">
       test_and_set()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.988.1">
      , the special atomic operations provided
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.989.1">
       by
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.990.1">
        std::atomic_flag
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.991.1">
       .
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.992.1">
       fetch_add()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.993.1">
      , to atomically add some value to an atomic variable and get its previous value.
     </span>
     <span class="koboSpan" id="kobo.993.2">
      Integral and floating-point types also implement
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.994.1">
       fetch_sub()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.995.1">
      , to subtract a certain value from an atomic variable and return its previous value.
     </span>
     <span class="koboSpan" id="kobo.995.2">
      Some
     </span>
     <a id="_idIndexMarker383">
     </a>
     <span class="koboSpan" id="kobo.996.1">
      functions for performing bitwise logic operations have been implemented just for integral types:
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.997.1">
       fetch_and()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.998.1">
      ,
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.999.1">
       fetch_or()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1000.1">
      ,
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1001.1">
       and
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1002.1">
        fetch_xor()
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1003.1">
       .
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.1004.1">
     The following table summarizes atomic types and operations.
    </span>
    <span class="koboSpan" id="kobo.1004.2">
     For an exhaustive description, please refer to the online C++
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1005.1">
      reference:
     </span>
    </span>
    <a href="https://en.cppreference.com/w/cpp/atomic/atomic">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1006.1">
       https://en.cppreference.com/w/cpp/atomic/atomic
      </span>
     </span>
    </a>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1007.1">
     The table shows three new operations:
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1008.1">
      exchange
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1009.1">
     ,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1010.1">
      compare_exchange_weak
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1011.1">
     , and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1012.1">
      compare_exchange_strong
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1013.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1013.2">
     We will explain them using an example later.
    </span>
    <span class="koboSpan" id="kobo.1013.3">
     Most of the operations (that is, the functions, not the operators) have another parameter for the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1014.1">
      memory order.
     </span>
    </span>
   </p>
   <table class="No-Table-Style _idGenTablePara-1" id="table002-1">
    <colgroup>
     <col/>
     <col/>
     <col/>
     <col/>
     <col/>
     <col/>
    </colgroup>
    <thead>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="bold">
          <span class="koboSpan" id="kobo.1015.1">
           Operation
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="bold">
          <span class="koboSpan" id="kobo.1016.1">
           atomic_
          </span>
         </strong>
        </span>
       </p>
       <p>
        <span class="No-Break">
         <strong class="bold">
          <span class="koboSpan" id="kobo.1017.1">
           flag
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="bold">
          <span class="koboSpan" id="kobo.1018.1">
           atomic &lt;bool&gt;
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="bold">
          <span class="koboSpan" id="kobo.1019.1">
           atomic &lt;integral&gt;
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="bold">
          <span class="koboSpan" id="kobo.1020.1">
           atomic &lt;floating-point&gt;
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="bold">
          <span class="koboSpan" id="kobo.1021.1">
           atomic &lt;other&gt;
          </span>
         </strong>
        </span>
       </p>
      </td>
     </tr>
    </thead>
    <tbody>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="source-inline" lang="en-US" xml:lang="en-US">
          <span class="koboSpan" id="kobo.1022.1">
           test_and_set
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.1023.1">
          YES
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
      </td>
      <td class="No-Table-Style">
      </td>
      <td class="No-Table-Style">
      </td>
      <td class="No-Table-Style">
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.1024.1">
           Clear
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.1025.1">
          YES
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
      </td>
      <td class="No-Table-Style">
      </td>
      <td class="No-Table-Style">
      </td>
      <td class="No-Table-Style">
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.1026.1">
           Load
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.1027.1">
          YES
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.1028.1">
          YES
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.1029.1">
          YES
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.1030.1">
          YES
         </span>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.1031.1">
           Store
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.1032.1">
          YES
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.1033.1">
          YES
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.1034.1">
          YES
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.1035.1">
          YES
         </span>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="source-inline" lang="en-US" xml:lang="en-US">
          <span class="koboSpan" id="kobo.1036.1">
           fetch_add, +=
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
      </td>
      <td class="No-Table-Style">
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.1037.1">
          YES
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.1038.1">
          YES
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.1039.1">
           fetch_sub, -=
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
      </td>
      <td class="No-Table-Style">
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.1040.1">
          YES
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.1041.1">
          YES
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.1042.1">
           fetch_and, &amp;=
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
      </td>
      <td class="No-Table-Style">
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.1043.1">
          YES
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
      </td>
      <td class="No-Table-Style">
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.1044.1">
           fetch_or, |=
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
      </td>
      <td class="No-Table-Style">
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.1045.1">
          YES
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
      </td>
      <td class="No-Table-Style">
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.1046.1">
           fetch_xor, ^=
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
      </td>
      <td class="No-Table-Style">
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.1047.1">
          YES
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
      </td>
      <td class="No-Table-Style">
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         <span class="koboSpan" id="kobo.1048.1">
          ++, --
         </span>
        </strong>
       </p>
      </td>
      <td class="No-Table-Style">
      </td>
      <td class="No-Table-Style">
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.1049.1">
          YES
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
      </td>
      <td class="No-Table-Style">
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="source-inline">
          <span class="koboSpan" id="kobo.1050.1">
           Exchange
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.1051.1">
          YES
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.1052.1">
          YES
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.1053.1">
          YES
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.1054.1">
          YES
         </span>
        </span>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <strong class="source-inline" lang="en-US" xml:lang="en-US">
          <span class="koboSpan" id="kobo.1055.1">
           compare_exchange_weak,
          </span>
         </strong>
        </span>
       </p>
       <p>
        <span class="No-Break">
         <strong class="source-inline" lang="en-US" xml:lang="en-US">
          <span class="koboSpan" id="kobo.1056.1">
           compare_exchange_strong
          </span>
         </strong>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.1057.1">
          YES
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.1058.1">
          YES
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.1059.1">
          YES
         </span>
        </span>
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <span class="No-Break">
         <span class="koboSpan" id="kobo.1060.1">
          YES
         </span>
        </span>
       </p>
      </td>
     </tr>
    </tbody>
   </table>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.1061.1">
     Table 5.2: Atomic types and operations
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1062.1">
     Let’s review the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1063.1">
      is_lock_free()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1064.1">
     function and the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1065.1">
      is_always_lock_free
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1066.1">
     constant.
    </span>
    <span class="koboSpan" id="kobo.1066.2">
     We saw that if
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1067.1">
      is_lock_free()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1068.1">
     is true, then the atomic type has lock-free operations with special CPU instructions.
    </span>
    <span class="koboSpan" id="kobo.1068.2">
     An atomic type can be lock-free only sometimes, so the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1069.1">
      is_always_lock_free
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1070.1">
     constant tells us if the type is always lock-free.
    </span>
    <span class="koboSpan" id="kobo.1070.2">
     So far, all the
    </span>
    <a id="_idIndexMarker384">
    </a>
    <span class="koboSpan" id="kobo.1071.1">
     types we have seen are lock-free.
    </span>
    <span class="koboSpan" id="kobo.1071.2">
     Let’s see what happens when an atomic type
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1072.1">
      is non-lock-free.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1073.1">
     The following shows the code for the non-lock-free
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1074.1">
      atomic type:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1075.1">
#include &lt;atomic&gt;
#include &lt;iostream&gt;
struct no_lock_free {
    int a[128];
    no_lock_free() {
        for (int i = 0; i &lt; 128; ++i) {
            a[i] = i;
        }
    }
};
int main() {
    std::atomic&lt;no_lock_free&gt; s;
    std::cout &lt;&lt; "Size of no_lock_free: " &lt;&lt; sizeof(no_lock_free) &lt;&lt; " bytes\n";
    std::cout &lt;&lt; "Size of std::atomic&lt;no_lock_free&gt;: " &lt;&lt; sizeof(s) &lt;&lt; " bytes\n";
    std::cout &lt;&lt; "Is std::atomic&lt;no_lock_free&gt; always lock-free: " &lt;&lt; std::boolalpha
              &lt;&lt; std::atomic&lt;no_lock_free&gt;::is_always_lock_free &lt;&lt; std::endl;
    std::cout &lt;&lt; "Is std::atomic&lt;no_lock_free&gt; lock-free: " &lt;&lt; std::boolalpha &lt;&lt; s.is_lock_free() &lt;&lt; std::endl;
    no_lock_free s1;
    s.store(s1);
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1076.1">
     When you execute the code, you will notice that the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1077.1">
      std::atomic&lt;no_lock_free&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1078.1">
     type is not lock-free.
    </span>
    <span class="koboSpan" id="kobo.1078.2">
     Its size, 512 bytes, is the cause of this.
    </span>
    <span class="koboSpan" id="kobo.1078.3">
     When we assign a value to the atomic variable, that value is written
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1079.1">
      atomically
     </span>
    </em>
    <span class="koboSpan" id="kobo.1080.1">
     , but this operation does not use CPU atomic instructions, that is, it is not lock-free.
    </span>
    <span class="koboSpan" id="kobo.1080.2">
     The implementation of this operation depends on the compiler but, in general, it uses either a mutex or a special spinlock (such as Microsoft
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1081.1">
      Visual C++).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1082.1">
     The lesson here is that all
    </span>
    <a id="_idIndexMarker385">
    </a>
    <span class="koboSpan" id="kobo.1083.1">
     atomic types have atomic operations, but they are not all magically lock-free.
    </span>
    <span class="koboSpan" id="kobo.1083.2">
     If an atomic type is not lock-free, it is always better to implement it
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1084.1">
      using locks.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1085.1">
     We learned that some atomic types are not lock-free.
    </span>
    <span class="koboSpan" id="kobo.1085.2">
     Now we will look at another example that shows the atomic operations we have not covered yet: the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1086.1">
      exchange
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1087.1">
     and
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1088.1">
       compare_exchange
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1089.1">
      operations.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-117">
    <a id="_idTextAnchor116">
    </a>
    <span class="koboSpan" id="kobo.1090.1">
     Example – lazy one-time initialization
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.1091.1">
     Sometimes initializing an
    </span>
    <a id="_idIndexMarker386">
    </a>
    <span class="koboSpan" id="kobo.1092.1">
     object can be costly.
    </span>
    <span class="koboSpan" id="kobo.1092.2">
     For example, a given object may need to connect to a database or a server, and establishing this connection can take a long time.
    </span>
    <span class="koboSpan" id="kobo.1092.3">
     In these cases, we should initialize the object just before its use, and not when we define it in our program.
    </span>
    <span class="koboSpan" id="kobo.1092.4">
     This is called
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.1093.1">
      lazy initialization
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1094.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1094.2">
     Now let’s assume that more than one thread needs to use the object for the first time.
    </span>
    <span class="koboSpan" id="kobo.1094.3">
     If more than one thread initializes the object, then different connections would be created, and that would be wrong because the object opens and closes only one connection.
    </span>
    <span class="koboSpan" id="kobo.1094.4">
     For this reason, multiple initializations must be avoided.
    </span>
    <span class="koboSpan" id="kobo.1094.5">
     To ensure the object is initialized only once, we will utilize a method known as lazy
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1095.1">
      one-time initialization.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1096.1">
     The following shows the code for lazy
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1097.1">
      one-time initialization:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1098.1">
#include &lt;atomic&gt;
#include &lt;iostream&gt;
#include &lt;random&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;
constexpr int NUM_THREADS{8};
void process() {
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution&lt;&gt; dis(1, 1000000);
    int sleep_duration = dis(gen);
    std::this_thread::sleep_for(std::chrono::microseconds(sleep_duration));
}
int main() {
    std::atomic&lt;int&gt; init_thread{0};
    auto worker = [&amp;init_thread](int i) {
        process();
        int init_value = init_thread.load(std::memory_order::seq_cst);
        if (init_value == 0) {
            int expected = 0;
            if (init_thread.compare_exchange_strong(expected, i, std::memory_order::seq_cst)) {
                std::cout &lt;&lt; "Previous value of init_thread: " &lt;&lt; expected &lt;&lt; "\n";
                std::cout &lt;&lt; "Thread " &lt;&lt; i &lt;&lt; " initialized\n";
            } else {
                // init_thread was already initialized
            }
        } else {
            // init_thread was already initialized
        }
    };
    std::vector&lt;std::thread&gt; threads;
    for (int i = 1; i &lt;= NUM_THREADS; ++i) {
        threads.emplace_back(worker, i);
    }
    for (auto &amp;t: threads) {
        t.join();
    }
    std::cout &lt;&lt; "Thread: " &lt;&lt; init_thread.load() &lt;&lt; " initialized\n";
    return 0;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1099.1">
     There are some operations in the atomic type operations table that we saw earlier in this chapter that we have not yet discussed.
    </span>
    <span class="koboSpan" id="kobo.1099.2">
     We will now explain
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1100.1">
      compare_exchange_strong
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1101.1">
     using an example.
    </span>
    <span class="koboSpan" id="kobo.1101.2">
     In the example, we have a variable that starts with a value of 0.
    </span>
    <span class="koboSpan" id="kobo.1101.3">
     Several threads are running, each with a unique integer ID (1, 2, 3, and so on).
    </span>
    <span class="koboSpan" id="kobo.1101.4">
     We want to set the variable’s value to the ID of the thread that sets it first and initialize the
    </span>
    <a id="_idIndexMarker387">
    </a>
    <span class="koboSpan" id="kobo.1102.1">
     variable only once.
    </span>
    <span class="koboSpan" id="kobo.1102.2">
     In
    </span>
    <a href="B22219_04.xhtml#_idTextAnchor074">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.1103.1">
        Chapter 4
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.1104.1">
     , we learned about
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1105.1">
      std::once_flag
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1106.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1107.1">
      std::call_once
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1108.1">
     , which we could use to implement this one-time initialization, but this chapter is about atomic types and operations, so we will use those to achieve
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1109.1">
      our goal.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1110.1">
     To be sure that the initialization of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1111.1">
      init_thread
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1112.1">
     variable is done only once and to avoid race conditions due to write access from more than one thread, we use an atomic
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1113.1">
      int
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1114.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1114.2">
     Line
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1115.1">
      [1]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1116.1">
     atomically reads the content of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1117.1">
      init_thread
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1118.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1118.2">
     If the value is not 0, then that means it has been already initialized and the worker thread does
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1119.1">
      nothing else.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1120.1">
     The current value of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1121.1">
      init_thread
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1122.1">
     is stored in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1123.1">
      expected
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1124.1">
     variable, which represents the value we expect
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1125.1">
      init_thread
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1126.1">
     will have when we try to initialize it.
    </span>
    <span class="koboSpan" id="kobo.1126.2">
     Now line
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1127.1">
      [2]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1128.1">
     performs the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1129.1">
      following steps:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.1130.1">
      Compare the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1131.1">
       init_thread
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1132.1">
      current value to the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1133.1">
       expected
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1134.1">
      value (which, again, is equal
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1135.1">
       to 0).
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1136.1">
      If the comparison is not successful, copy the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1137.1">
       init_thread
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1138.1">
      current value into
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1139.1">
       expected
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1140.1">
      and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1141.1">
       return
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1142.1">
        false
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1143.1">
       .
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1144.1">
      If the comparison is successful, copy the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1145.1">
       init_thread
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1146.1">
      current value into
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1147.1">
       expected
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1148.1">
      , then set the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1149.1">
       init_thread
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1150.1">
      current value to
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1151.1">
       i
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1152.1">
      and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1153.1">
       return
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1154.1">
        true
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1155.1">
       .
      </span>
     </span>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.1156.1">
     The current thread will have initialized
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1157.1">
      init_thread
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1158.1">
     only if
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1159.1">
      compare_exchange_strong
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1160.1">
     returns
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1161.1">
      true
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1162.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1162.2">
     Also, note that we need to perform a comparison again (even if line
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1163.1">
      [1]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1164.1">
     returned 0 as the current value of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1165.1">
      init_thread
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1166.1">
     ) because it is possible that another thread has already initialized
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1167.1">
      the variable.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1168.1">
     It is very important to note that if
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1169.1">
      compare_exchange_strong
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1170.1">
     returns
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1171.1">
      false
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1172.1">
     , then the comparison has failed, and if it returns
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1173.1">
      true
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1174.1">
     , then the comparison was successful.
    </span>
    <span class="koboSpan" id="kobo.1174.2">
     This is always true of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1175.1">
      compare_exchange_strong
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1176.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1176.2">
     On the other hand,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1177.1">
      compare_exchange_weak
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1178.1">
     can fail (i.e., return
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1179.1">
      false
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1180.1">
     ) even if the comparison is successful.
    </span>
    <span class="koboSpan" id="kobo.1180.2">
     The reason for using it is that in some platforms it gives better performance when it is called inside
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1181.1">
      a loop.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1182.1">
     For more information on these two functions, please refer to the online C++
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1183.1">
      reference:
     </span>
    </span>
    <a href="https://en.cppreference.com/w/cpp/atomic/atomic/compare_exchange">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1184.1">
       https://en.cppreference.com/w/cpp/atomic/atomic/compare_exchange
      </span>
     </span>
    </a>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1185.1">
     In this section about
    </span>
    <a id="_idIndexMarker388">
    </a>
    <span class="koboSpan" id="kobo.1186.1">
     the C++ Standard Library atomic types and operations, we have seen
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1187.1">
      the following:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.1188.1">
      The most commonly used standard atomic types, such as
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1189.1">
       std::atomic_flag
      </span>
     </strong>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1190.1">
       and
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1191.1">
        std::atomic&lt;int&gt;
       </span>
      </strong>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1192.1">
      The most-used atomic operations:
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1193.1">
       load()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1194.1">
      ,
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1195.1">
       store()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1196.1">
      ,
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1197.1">
       and
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1198.1">
        exchange_compare_strong()
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1199.1">
       /
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1200.1">
        exchange_compare_weak()
       </span>
      </strong>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1201.1">
      Basic examples incorporating these atomic types and operations, including lazy one-time initialization and thread
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1202.1">
       progress communication
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.1203.1">
     We have mentioned several times that most of the atomic operations (functions) let us pick the memory order we want to use.
    </span>
    <span class="koboSpan" id="kobo.1203.2">
     In the next section, we will implement a lock-free programming example: an SPSC
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1204.1">
      lock-free queue.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-118">
    <a id="_idTextAnchor117">
    </a>
    <span class="koboSpan" id="kobo.1205.1">
     SPSC lock-free queue
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.1206.1">
     We have already looked at the C++ Standard Library’s features for atomics, such as atomic types and operations
    </span>
    <a id="_idIndexMarker389">
    </a>
    <span class="koboSpan" id="kobo.1207.1">
     and the memory model and orderings.
    </span>
    <span class="koboSpan" id="kobo.1207.2">
     Now we will see a complete example of using atomics to implement an SPSC
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1208.1">
      lock-free queue.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1209.1">
     The main features of this
    </span>
    <a id="_idIndexMarker390">
    </a>
    <span class="koboSpan" id="kobo.1210.1">
     queue are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1211.1">
      the following:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.1212.1">
       SPSC
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1213.1">
      : This queue is designed to
     </span>
     <a id="_idIndexMarker391">
     </a>
     <span class="koboSpan" id="kobo.1214.1">
      work with two threads, one pushing elements to the queue and another getting elements from
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1215.1">
       the queue.
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.1216.1">
       Bounded
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1217.1">
      : This queue has a fixed size.
     </span>
     <span class="koboSpan" id="kobo.1217.2">
      We need a method for checking when the queue reaches its capacity and
     </span>
     <a id="_idIndexMarker392">
     </a>
     <span class="koboSpan" id="kobo.1218.1">
      when it has
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1219.1">
       no elements).
      </span>
     </span>
    </li>
    <li>
     <strong class="bold">
      <span class="koboSpan" id="kobo.1220.1">
       Lock-free
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1221.1">
      : This queue uses
     </span>
     <a id="_idIndexMarker393">
     </a>
     <span class="koboSpan" id="kobo.1222.1">
      atomic types that are always lock-free on modern Intel
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1223.1">
       x64 CPUs.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.1224.1">
     Before you begin to develop the queue, keep in mind that lock-free is not the same as wait-free (also keep in mind that wait-free does not eliminate waiting entirely; it just ensures that there is a limit to the number of steps required for each queue push/pop).
    </span>
    <span class="koboSpan" id="kobo.1224.2">
     Some aspects that mostly affect performance will be discussed in
    </span>
    <a href="B22219_13.xhtml#_idTextAnchor267">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.1225.1">
        Chapter 13
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.1226.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1226.2">
     In that chapter, we will also optimize the queue’s performance.
    </span>
    <span class="koboSpan" id="kobo.1226.3">
     For now, in this chapter, we will build an SPSC lock-free queue that is correct and performs adequately – we will show how its performance can be
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1227.1">
      improved later.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1228.1">
     We used mutex and
    </span>
    <a id="_idIndexMarker394">
    </a>
    <span class="koboSpan" id="kobo.1229.1">
     condition variables to make an SPSC queue in
    </span>
    <a href="B22219_04.xhtml#_idTextAnchor074">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.1230.1">
        Chapter 4
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.1231.1">
     that consumer and producer threads could access safely.
    </span>
    <span class="koboSpan" id="kobo.1231.2">
     This chapter will use atomic operations to achieve the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1232.1">
      same goal.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1233.1">
     We will store the items in the queue using the same data structure:
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1234.1">
      std::vector&lt;T&gt;
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1235.1">
     with a fixed size, that is, a power of 2.
    </span>
    <span class="koboSpan" id="kobo.1235.2">
     This way, we can improve performance and find the next head and tail indices quickly without using the modulo operator that needs a division instruction.
    </span>
    <span class="koboSpan" id="kobo.1235.3">
     When using lock-free atomic types for better performance, we need to pay attention to everything that
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1236.1">
      affects performance.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-119">
    <a id="_idTextAnchor118">
    </a>
    <span class="koboSpan" id="kobo.1237.1">
     Why do we use a power of 2 buffer size?
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.1238.1">
     We will use a vector to hold the queue items.
    </span>
    <span class="koboSpan" id="kobo.1238.2">
     The vector will have a fixed size, say
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1239.1">
      N
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1240.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1240.2">
     We will make the vector act
    </span>
    <a id="_idIndexMarker395">
    </a>
    <span class="koboSpan" id="kobo.1241.1">
     similarly to a ring buffer, meaning that the index for accessing an element in the vector will loop back to the start after the end.
    </span>
    <span class="koboSpan" id="kobo.1241.2">
     The first element will follow the last one.
    </span>
    <span class="koboSpan" id="kobo.1241.3">
     As we learned in
    </span>
    <a href="B22219_04.xhtml#_idTextAnchor074">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.1242.1">
        Chapter 4
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.1243.1">
     , we can do this with the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1244.1">
      modulo operator:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1245.1">
size_t next_index = (curr_index + 1) % N;</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1246.1">
     If the size is, for example, four elements, the index to the next element will be calculated as in the preceding code.
    </span>
    <span class="koboSpan" id="kobo.1246.2">
     For the last index, we have the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1247.1">
      following code:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1248.1">
next_index = (3 + 1) % 4 = 4 % 4 = 0;</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1249.1">
     Therefore, as we said, the vector will be a ring buffer because, after the last element, we will go back to the first one, then the second one, and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1250.1">
      so on.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1251.1">
     We can use this method to get the next index for any buffer size
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1252.1">
      N
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1253.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1253.2">
     But why do we only use sizes that are powers of 2?
    </span>
    <span class="koboSpan" id="kobo.1253.3">
     The answer is easy: performance.
    </span>
    <span class="koboSpan" id="kobo.1253.4">
     The modulo (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1254.1">
      %
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1255.1">
     ) operator requires a division
    </span>
    <a id="_idIndexMarker396">
    </a>
    <span class="koboSpan" id="kobo.1256.1">
     instruction, which is expensive.
    </span>
    <span class="koboSpan" id="kobo.1256.2">
     When the size
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1257.1">
      N
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1258.1">
     is a power of 2, we can just do
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1259.1">
      the following:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1260.1">
size_t next_index = curr_index &amp; (N – 1);</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1261.1">
     This is much faster than using the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1262.1">
      modulo operator.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-120">
    <a id="_idTextAnchor119">
    </a>
    <span class="koboSpan" id="kobo.1263.1">
     Buffer access synchronization
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.1264.1">
     To access the queue buffer, we need
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1265.1">
      two indices:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1266.1">
       head
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1267.1">
      : The index of the current element to
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1268.1">
       be read
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1269.1">
       tail
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1270.1">
      : The index of the next element to
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1271.1">
       be written
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.1272.1">
     The consumer thread will use the head index to read and write.
    </span>
    <span class="koboSpan" id="kobo.1272.2">
     The producer thread will use the tail index to read and
    </span>
    <a id="_idIndexMarker397">
    </a>
    <span class="koboSpan" id="kobo.1273.1">
     write.
    </span>
    <span class="koboSpan" id="kobo.1273.2">
     We need to synchronize access to these variables because
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1274.1">
      of this:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.1275.1">
      Only one thread (the consumer) writes
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1276.1">
       head
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1277.1">
      , meaning that it can read it with relaxed memory ordering because it always sees its own changes.
     </span>
     <span class="koboSpan" id="kobo.1277.2">
      Reading
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1278.1">
       tail
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1279.1">
      is done by the reader thread and it needs to synchronize with the producer’s writing of
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1280.1">
       tail
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1281.1">
      , so it needs acquire memory ordering.
     </span>
     <span class="koboSpan" id="kobo.1281.2">
      We could use sequential consistency for everything, but we want the best performance.
     </span>
     <span class="koboSpan" id="kobo.1281.3">
      When the consumer thread writes
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1282.1">
       head
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1283.1">
      , it needs to synchronize with the producer’s read of it, so it needs release
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1284.1">
       memory ordering.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1285.1">
      For
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1286.1">
       tail
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1287.1">
      , only the producer thread writes it, so we can use relaxed memory ordering to read it, but we need release memory ordering to write it and synchronize it with the consumer thread’s reading.
     </span>
     <span class="koboSpan" id="kobo.1287.2">
      To synchronize with the consumer thread’s writing, we need acquire memory ordering to
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1288.1">
       read
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1289.1">
        head
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1290.1">
       .
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.1291.1">
     The queue class member variables are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1292.1">
      the following:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1293.1">
const std::size_t capacity_; // power of two buffer size
std::vector&lt;T&gt; buffer_; // buffer to store queue items handled like a ring buffer
std::atomic&lt;std::size_t&gt; head_{ 0 };
std::atomic&lt;std::size_t&gt; tail_{ 0 };</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1294.1">
     In this section, we have seen how to synchronize access to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1295.1">
      queue buffer.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-121">
    <a id="_idTextAnchor120">
    </a>
    <span class="koboSpan" id="kobo.1296.1">
     Pushing elements into the queue
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.1297.1">
     Once we have decided
    </span>
    <a id="_idIndexMarker398">
    </a>
    <span class="koboSpan" id="kobo.1298.1">
     on the data representation of the queue and how to synchronize access to its elements, let’s implement the function for pushing elements into
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1299.1">
      the queue:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1300.1">
bool push(const T&amp; item) {
    std::size_t tail =
        tail_.load(std::memory_order_relaxed);
    std::size_t next_tail =
       (tail + 1) &amp; (capacity_ - 1);
    if (next_tail != head_.load(std::memory_order_acquire)) {
        buffer_[tail] = item;
        tail_.store(next_tail, std::memory_order_release);
        return true;
    }
    return false;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1301.1">
     The current tail index, which is the buffer slot where the data item is to be pushed (if possible) into the queue, is atomically read in line
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1302.1">
      [1]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1303.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1303.2">
     As we mentioned earlier, this read can use
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1304.1">
      std::memory_order_relaxed
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1305.1">
     because only the producer thread changes this variable, and it is the only thread that
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1306.1">
      calls push.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1307.1">
     Line
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1308.1">
      [2]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1309.1">
     calculates the next index modulo capacity (remember that the buffer is a ring).
    </span>
    <span class="koboSpan" id="kobo.1309.2">
     We need to do this to check whether the queue
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1310.1">
      is full.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1311.1">
     We perform the check in line
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1312.1">
      [3]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1313.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1313.2">
     We first atomically read the current value of the head using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1314.1">
      std::memory_order_acquire
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1315.1">
     because we want the producer thread to observe the modifications that the consumer thread has made to this variable.
    </span>
    <span class="koboSpan" id="kobo.1315.2">
     Then we compare its value with the next
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1316.1">
      head index.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1317.1">
     If the next tail value is equal to the current head value, then (as per our convention) the queue is full, and we
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1318.1">
      return
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1319.1">
       false
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1320.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1321.1">
     If the queue is not full, line
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1322.1">
      [4]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1323.1">
     copies the data item to the queue buffer.
    </span>
    <span class="koboSpan" id="kobo.1323.2">
     It is worth commenting here
    </span>
    <a id="_idIndexMarker399">
    </a>
    <span class="koboSpan" id="kobo.1324.1">
     that the data copy is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1325.1">
      not atomic.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1326.1">
     Line
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1327.1">
      [5]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1328.1">
     atomically writes the new tail index value into
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1329.1">
      tail_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1330.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1330.2">
     Then,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1331.1">
      std::memory_order_release
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1332.1">
     is used to make the changes visible to the consumer thread that atomically reads this variable
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1333.1">
      with
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1334.1">
       std::memory_order_acquire
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1335.1">
      .
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-122">
    <a id="_idTextAnchor121">
    </a>
    <span class="koboSpan" id="kobo.1336.1">
     Popping elements from the queue
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.1337.1">
     Let’s now
    </span>
    <a id="_idIndexMarker400">
    </a>
    <span class="koboSpan" id="kobo.1338.1">
     see how the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1339.1">
      pop
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1340.1">
     function
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1341.1">
      is implemented:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1342.1">
bool pop(T&amp; item) {
    std::size_t head =
        head_.load(std::memory_order_relaxed);
    if (head == tail_.load(std::memory_order_acquire)) {
        return false;
    }
    item = buffer_[head];
    head_.store((head + 1) &amp; (capacity_ - 1), std::memory_order_release);
    return true;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1343.1">
     Line
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1344.1">
      [1]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1345.1">
     atomically reads the current value of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1346.1">
      head_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1347.1">
     (index for the next item to be read).
    </span>
    <span class="koboSpan" id="kobo.1347.2">
     We use
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1348.1">
      std::memory_order_relaxed
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1349.1">
     because no order enforcement is required due to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1350.1">
      head_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1351.1">
     variable being modified only by the consumer thread, which is the only thread
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1352.1">
      calling
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1353.1">
       pop
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1354.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1355.1">
     Line
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1356.1">
      [2]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1357.1">
     checks whether the queue is empty.
    </span>
    <span class="koboSpan" id="kobo.1357.2">
     If the current value of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1358.1">
      head_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1359.1">
     is the same as the current value of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1360.1">
      tail_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1361.1">
     , then the queue is empty, and the function just returns
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1362.1">
      false
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1363.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1363.2">
     We atomically
    </span>
    <a id="_idIndexMarker401">
    </a>
    <span class="koboSpan" id="kobo.1364.1">
     read the value of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1365.1">
      tail_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1366.1">
     with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1367.1">
      std::memory_order_acquire
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1368.1">
     to see the latest change done to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1369.1">
      tail_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1370.1">
     by the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1371.1">
      producer thread.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1372.1">
     Line
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1373.1">
      [3]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1374.1">
     copies the data from the queue to the item reference passed as an argument to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1375.1">
      pop
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1376.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1376.2">
     Again, this copy is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1377.1">
      not atomic.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1378.1">
     Finally, line
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1379.1">
      [4]
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1380.1">
     updates the value of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1381.1">
      head_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1382.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1382.2">
     Again, we atomically write the value using
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1383.1">
      std::memory order_release
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1384.1">
     for the consumer thread to see the changes made to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1385.1">
      head_
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1386.1">
     by the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1387.1">
      consumer thread.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1388.1">
     The code for the SPSC lock-free queue implementation is
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1389.1">
      the following:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1390.1">
#include &lt;atomic&gt;
#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;thread&gt;
template&lt;typename T&gt;
class spsc_lock_free_queue {
public:
    // capacity must be power of two to avoid using modulo operator when calculating the index
    explicit spsc_lock_free_queue(size_t capacity) : capacity_(capacity), buffer_(capacity) {
        assert((capacity &amp; (capacity - 1)) == 0 &amp;&amp; "capacity must be a power of 2");
    }
    spsc_lock_free_queue(const spsc_lock_free_queue &amp;) = delete;
    spsc_lock_free_queue &amp;operator=(const spsc_lock_free_queue &amp;) = delete;
    bool push(const T &amp;item) {
        std::size_t tail = tail_.load(std::memory_order_relaxed);
        std::size_t next_tail = (tail + 1) &amp; (capacity_ - 1);
        if (next_tail != head_.load(std::memory_order_acquire)) {
            buffer_[tail] = item;
            tail_.store(next_tail, std::memory_order_release);
            return true;
        }
        return false;
    }
    bool pop(T &amp;item) {
        std::size_t head = head_.load(std::memory_order_relaxed);
        if (head == tail_.load(std::memory_order_acquire)) {
            return false;
        }
        item = buffer_[head];
        head_.store((head + 1) &amp; (capacity_ - 1), std::memory_order_release);
        return true;
    }
private:
    const std::size_t capacity_;
    std::vector&lt;T&gt; buffer_;
    std::atomic&lt;std::size_t&gt; head_{0};
    std::atomic&lt;std::size_t&gt; tail_{0};
};</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1391.1">
     The code for the full example can be found in the following book
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1392.1">
      repo:
     </span>
    </span>
    <a href="https://github.com/PacktPublishing/Asynchronous-Programming-in-CPP/blob/main/Chapter_05/5x09-SPSC_lock_free_queue.cpp">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1393.1">
       https://github.com/PacktPublishing/Asynchronous-Programming-in-CPP/blob/main/Chapter_05/5x09-SPSC_lock_free_queue.cpp
      </span>
     </span>
    </a>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1394.1">
     In this section, we have
    </span>
    <a id="_idIndexMarker402">
    </a>
    <span class="koboSpan" id="kobo.1395.1">
     implemented an SPSC lock-free queue as an application of atomic types and operations.
    </span>
    <span class="koboSpan" id="kobo.1395.2">
     In
    </span>
    <a href="B22219_13.xhtml#_idTextAnchor267">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.1396.1">
        Chapter 13
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.1397.1">
     , we will revisit this implementation and improve
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1398.1">
      its performance.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-123">
    <a id="_idTextAnchor122">
    </a>
    <span class="koboSpan" id="kobo.1399.1">
     Summary
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.1400.1">
     This chapter has introduced atomic types and operations, the C++ memory model, and a basic implementation of an SPSC
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1401.1">
      lock-free queue.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1402.1">
     The following is a summary of what we have
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1403.1">
      looked at:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.1404.1">
      The C++ Standard Library atomic types and operations, what they are, and how to use them with
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1405.1">
       some examples.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1406.1">
      The C++ memory model, and especially the different memory orderings it defines.
     </span>
     <span class="koboSpan" id="kobo.1406.2">
      Bear in mind that this is a very complex subject and that this section was just a basic introduction
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1407.1">
       to it.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1408.1">
      How to implement a basic SPSC lock-free queue.
     </span>
     <span class="koboSpan" id="kobo.1408.2">
      As we mentioned previously, we will demonstrate how to improve its performance in
     </span>
     <a href="B22219_13.xhtml#_idTextAnchor267">
      <span class="No-Break">
       <em class="italic">
        <span class="koboSpan" id="kobo.1409.1">
         Chapter 13
        </span>
       </em>
      </span>
     </a>
     <span class="koboSpan" id="kobo.1410.1">
      .
     </span>
     <span class="koboSpan" id="kobo.1410.2">
      Examples of performance-improving actions include eliminating false sharing (what happens when two variables are in the same cache line and each variable is just modified by one thread) and reducing true sharing.
     </span>
     <span class="koboSpan" id="kobo.1410.3">
      Don’t worry if you don’t understand any of this now.
     </span>
     <span class="koboSpan" id="kobo.1410.4">
      We will cover it later and demonstrate how to run
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1411.1">
       performance tests.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.1412.1">
     This is a basic introduction to atomic operations to synchronize memory access from different threads.
    </span>
    <span class="koboSpan" id="kobo.1412.2">
     In some cases, the use of atomic operations is quite easy, similar to gathering statistics and simple counters.
    </span>
    <span class="koboSpan" id="kobo.1412.3">
     More involved applications, such as the implementation of an SPSC lock-free queue, require a deeper knowledge of atomic operations.
    </span>
    <span class="koboSpan" id="kobo.1412.4">
     The material we have seen in this chapter helps build an understanding of the basics and builds a foundation for further study of this
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1413.1">
      complex subject.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1414.1">
     In the next chapter, we will look at promises and futures, two fundamental building blocks of asynchronous programming
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1415.1">
      in C++.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-124">
    <a id="_idTextAnchor123">
    </a>
    <span class="koboSpan" id="kobo.1416.1">
     Further reading
    </span>
   </h1>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.1417.1">
      [Butenhof, 1997] David R.
     </span>
     <span class="koboSpan" id="kobo.1417.2">
      Butenhof, Programming with POSIX Threads, Addison
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1418.1">
       Wesley, 1997.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1419.1">
      [Williams, 2019] Anthony Williams, C++ Concurrency in Action, Second Edition,
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1420.1">
       Manning, 2019.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1421.1">
      Memory Model: Get Your Shared Data Under Control, Jana
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1422.1">
       Machutová,
      </span>
     </span>
     <a href="https://www.youtube.com/watch?v=L5RCGDAan2Y">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1423.1">
        https://www.youtube.com/watch?v=L5RCGDAan2Y
       </span>
      </span>
     </a>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1424.1">
       .
      </span>
     </span>
    </li>
    <li>
     <em class="italic">
      <span class="koboSpan" id="kobo.1425.1">
       C++ Atomics: From Basic To Advanced
      </span>
     </em>
     <span class="koboSpan" id="kobo.1426.1">
      , Fedor
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1427.1">
       Pikus,
      </span>
     </span>
     <a href="https://www.youtube.com/watch?v=ZQFzMfHIxng">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1428.1">
        https://www.youtube.com/watch?v=ZQFzMfHIxng
       </span>
      </span>
     </a>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1429.1">
       .
      </span>
     </span>
    </li>
    <li>
     <em class="italic">
      <span class="koboSpan" id="kobo.1430.1">
       Intel 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A: System Programming Guide, Part 1
      </span>
     </em>
     <span class="koboSpan" id="kobo.1431.1">
      , Intel
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1432.1">
       Corporation,
      </span>
     </span>
     <a href="https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-3a-part-1-manual.pdf">
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1433.1">
        https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-3a-part-1-manual.pdf
       </span>
      </span>
     </a>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1434.1">
       .
      </span>
     </span>
    </li>
   </ul>
  </div>
 

  <div class="Content" id="_idContainer032">
   <h1 id="_idParaDest-125" lang="en-US" xml:lang="en-US">
    <a id="_idTextAnchor124">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     Part 3: Asynchronous Programming with Promises, Futures, and Coroutines
    </span>
   </h1>
  </div>
  <div id="_idContainer033">
   <p>
    <span class="koboSpan" id="kobo.2.1">
     In this part, we shift our focus to the core subject of this book, asynchronous programming, a critical aspect of building responsive, high-performance applications.
    </span>
    <span class="koboSpan" id="kobo.2.2">
     We will learn how to execute tasks concurrently without blocking the main execution flow by utilizing tools such as promises, futures, packaged tasks, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.3.1">
      std::async
     </span>
    </strong>
    <span class="koboSpan" id="kobo.4.1">
     function, and coroutines, a revolutionary feature enabling asynchronous programming without the overhead of creating threads.
    </span>
    <span class="koboSpan" id="kobo.4.2">
     We will also cover advanced techniques for sharing futures and examine real-world scenarios where these concepts are essential.
    </span>
    <span class="koboSpan" id="kobo.4.3">
     These powerful mechanisms allow us to develop efficient, scalable, and maintainable asynchronous software needed for modern
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.5.1">
      software systems.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.6.1">
     This part has the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.7.1">
      following chapters:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <a href="B22219_06.xhtml#_idTextAnchor125">
      <em class="italic">
       <span class="koboSpan" id="kobo.8.1">
        Chapter 6
       </span>
      </em>
     </a>
     <span class="koboSpan" id="kobo.9.1">
      ,
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.10.1">
       Promises and Futures
      </span>
     </em>
    </li>
    <li>
     <a href="B22219_07.xhtml#_idTextAnchor143">
      <em class="italic">
       <span class="koboSpan" id="kobo.11.1">
        Chapter 7
       </span>
      </em>
     </a>
     <span class="koboSpan" id="kobo.12.1">
      ,
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.13.1">
       The Async Function
      </span>
     </em>
    </li>
    <li>
     <a href="B22219_08.xhtml#_idTextAnchor164">
      <em class="italic">
       <span class="koboSpan" id="kobo.14.1">
        Chapter 8
       </span>
      </em>
     </a>
     <span class="koboSpan" id="kobo.15.1">
      ,
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.16.1">
       Asynchronous Programming Using Coroutines
      </span>
     </em>
    </li>
   </ul>
  </div>
  <div>
   <div id="_idContainer034">
   </div>
  </div>
  <div>
   <div class="Basic-Graphics-Frame" id="_idContainer035">
   </div>
  </div>
 </body></html>