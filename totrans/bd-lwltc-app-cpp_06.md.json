["```cpp\n#pragma once\n#include <cstdint>\n#include <limits>\n#include \"common/macros.h\"\n```", "```cpp\nnamespace Common {\n  typedef uint64_t OrderId;\n  constexpr auto OrderId_INVALID =\n    std::numeric_limits<OrderId>::max();\n  inline auto orderIdToString(OrderId order_id) ->\n    std::string {\n    if (UNLIKELY(order_id == OrderId_INVALID)) {\n      return \"INVALID\";\n    }\n    return std::to_string(order_id);\n  }\n```", "```cpp\n  typedef uint32_t TickerId;\n  constexpr auto TickerId_INVALID =\n    std::numeric_limits<TickerId>::max();\n  inline auto tickerIdToString(TickerId ticker_id) ->\n    std::string {\n    if (UNLIKELY(ticker_id == TickerId_INVALID)) {\n      return \"INVALID\";\n    }\n    return std::to_string(ticker_id);\n  }\n```", "```cpp\n  typedef uint32_t ClientId;\n  constexpr auto ClientId_INVALID =\n    std::numeric_limits<ClientId>::max();\n  inline auto clientIdToString(ClientId client_id) ->\n    std::string {\n    if (UNLIKELY(client_id == ClientId_INVALID)) {\n      return \"INVALID\";\n    }\n    return std::to_string(client_id);\n  }\n```", "```cpp\n  typedef int64_t Price;\n  constexpr auto Price_INVALID =\n    std::numeric_limits<Price>::max();\n  inline auto priceToString(Price price) -> std::string {\n    if (UNLIKELY(price == Price_INVALID)) {\n      return \"INVALID\";\n    }\n    return std::to_string(price);\n  }\n```", "```cpp\n  typedef uint32_t Qty;\n  constexpr auto Qty_INVALID =\n    std::numeric_limits<Qty>::max();\n  inline auto qtyToString(Qty qty) -> std::string {\n    if (UNLIKELY(qty == Qty_INVALID)) {\n      return \"INVALID\";\n    }\n    return std::to_string(qty);\n  }\n```", "```cpp\n  typedef uint64_t Priority;\n  constexpr auto Priority_INVALID =\n    std::numeric_limits<Priority>::max();\n  inline auto priorityToString(Priority priority) ->\n    std::string {\n    if (UNLIKELY(priority == Priority_INVALID)) {\n      return \"INVALID\";\n    }\n    return std::to_string(priority);\n  }\n```", "```cpp\n  enum class Side : int8_t {\n    INVALID = 0,\n    BUY = 1,\n    SELL = -1\n  };\n  inline auto sideToString(Side side) -> std::string {\n    switch (side) {\n      case Side::BUY:\n        return \"BUY\";\n      case Side::SELL:\n        return \"SELL\";\n      case Side::INVALID:\n        return \"INVALID\";\n    }\n    return \"UNKNOWN\";\n  }\n}\n```", "```cpp\nnamespace Common {\n  constexpr size_t LOG_QUEUE_SIZE = 8 * 1024 * 1024;\n  constexpr size_t ME_MAX_TICKERS = 8;\n  constexpr size_t ME_MAX_CLIENT_UPDATES = 256 * 1024;\n  constexpr size_t ME_MAX_MARKET_UPDATES = 256 * 1024;\n  constexpr size_t ME_MAX_NUM_CLIENTS = 256;\n  constexpr size_t ME_MAX_ORDER_IDS = 1024 * 1024;\n  constexpr size_t ME_MAX_PRICE_LEVELS = 256;\n}\n```", "```cpp\n#pragma once\n#include <sstream>\n#include \"common/types.h\"\n#include \"common/lf_queue.h\"\nusing namespace Common;\nnamespace Exchange {\n```", "```cpp\n#pragma pack(push, 1)\n  enum class ClientRequestType : uint8_t {\n    INVALID = 0,\n    NEW = 1,\n    CANCEL = 2\n  };\n  inline std::string\n    clientRequestTypeToString(ClientRequestType type) {\n    switch (type) {\n      case ClientRequestType::NEW:\n        return \"NEW\";\n      case ClientRequestType::CANCEL:\n        return \"CANCEL\";\n      case ClientRequestType::INVALID:\n        return \"INVALID\";\n    }\n    return \"UNKNOWN\";\n  }\n```", "```cpp\n  struct MEClientRequest {\n    ClientRequestType type_ = ClientRequestType::INVALID;\n    ClientId client_id_ = ClientId_INVALID;\n    TickerId ticker_id_ = TickerId_INVALID;\n    OrderId order_id_ = OrderId_INVALID;\n    Side side_ = Side::INVALID;\n    Price price_ = Price_INVALID;\n    Qty qty_ = Qty_INVALID;\n    auto toString() const {\n      std::stringstream ss;\n      ss << \"MEClientRequest\"\n         << \" [\"\n         << \"type:\" << clientRequestTypeToString(type_)\n         << \" client:\" << clientIdToString(client_id_)\n         << \" ticker:\" << tickerIdToString(ticker_id_)\n         << \" oid:\" << orderIdToString(order_id_)\n         << \" side:\" << sideToString(side_)\n         << \" qty:\" << qtyToString(qty_)\n         << \" price:\" << priceToString(price_)\n         << \"]\";\n      return ss.str();\n    }\n  };\n```", "```cpp\n#pragma pack(pop)\n  typedef LFQueue<MEClientRequest> ClientRequestLFQueue;\n}\n```", "```cpp\n#pragma once\n#include <sstream>\n#include \"common/types.h\"\n#include \"common/lf_queue.h\"\nusing namespace Common;\nnamespace Exchange {\n```", "```cpp\n#pragma pack(push, 1)\n  enum class ClientResponseType : uint8_t {\n    INVALID = 0,\n    ACCEPTED = 1,\n    CANCELED = 2,\n    FILLED = 3,\n    CANCEL_REJECTED = 4\n  };\n  inline std::string\n    clientResponseTypeToString(ClientResponseType type) {\n    switch (type) {\n      case ClientResponseType::ACCEPTED:\n        return \"ACCEPTED\";\n      case ClientResponseType::CANCELED:\n        return \"CANCELED\";\n      case ClientResponseType::FILLED:\n        return \"FILLED\";\n      case ClientResponseType::CANCEL_REJECTED:\n        return \"CANCEL_REJECTED\";\n      case ClientResponseType::INVALID:\n        return \"INVALID\";\n    }\n    return \"UNKNOWN\";\n  }\n```", "```cpp\n  struct MEClientResponse {\n    ClientResponseType type_ = ClientResponseType::INVALID;\n    ClientId client_id_ = ClientId_INVALID;\n    TickerId ticker_id_ = TickerId_INVALID;\n    OrderId client_order_id_ = OrderId_INVALID;\n    OrderId market_order_id_ = OrderId_INVALID;\n    Side side_ = Side::INVALID;\n    Price price_ = Price_INVALID;\n    Qty exec_qty_ = Qty_INVALID;\n    Qty leaves_qty_ = Qty_INVALID;\n    auto toString() const {\n      std::stringstream ss;\n      ss << \"MEClientResponse\"\n         << \" [\"\n         << \"type:\" << clientResponseTypeToString(type_)\n         << \" client:\" << clientIdToString(client_id_)\n         << \" ticker:\" << tickerIdToString(ticker_id_)\n         << \" coid:\" << orderIdToString(client_order_id_)\n         << \" moid:\" << orderIdToString(market_order_id_)\n         << \" side:\" << sideToString(side_)\n         << \" exec_qty:\" << qtyToString(exec_qty_)\n         << \" leaves_qty:\" << qtyToString(leaves_qty_)\n         << \" price:\" << priceToString(price_)\n         << \"]\";\n      return ss.str();\n    }\n  };\n#pragma pack(pop)\n```", "```cpp\n  typedef LFQueue<MEClientResponse> ClientResponseLFQueue;\n}\n```", "```cpp\n#pragma once\n#include <sstream>\n#include \"common/types.h\"\nusing namespace Common;\nnamespace Exchange {\n```", "```cpp\n#pragma pack(push, 1)\n  enum class MarketUpdateType : uint8_t {\n    INVALID = 0,\n    ADD = 1,\n    MODIFY = 2,\n    CANCEL = 3,\n    TRADE = 4\n  };\n  inline std::string\n    marketUpdateTypeToString(MarketUpdateType type) {\n    switch (type) {\n      case MarketUpdateType::ADD:\n        return \"ADD\";\n      case MarketUpdateType::MODIFY:\n        return \"MODIFY\";\n      case MarketUpdateType::CANCEL:\n        return \"CANCEL\";\n      case MarketUpdateType::TRADE:\n        return \"TRADE\";\n      case MarketUpdateType::INVALID:\n        return \"INVALID\";\n    }\n    return \"UNKNOWN\";\n  }\n```", "```cpp\n  struct MEMarketUpdate {\n    MarketUpdateType type_ = MarketUpdateType::INVALID;\n    OrderId order_id_ = OrderId_INVALID;\n    TickerId ticker_id_ = TickerId_INVALID;\n    Side side_ = Side::INVALID;\n    Price price_ = Price_INVALID;\n    Qty qty_ = Qty_INVALID;\n    Priority priority_ = Priority_INVALID;\n    auto toString() const {\n      std::stringstream ss;\n      ss << \"MEMarketUpdate\"\n         << \" [\"\n         << \" type:\" << marketUpdateTypeToString(type_)\n         << \" ticker:\" << tickerIdToString(ticker_id_)\n         << \" oid:\" << orderIdToString(order_id_)\n         << \" side:\" << sideToString(side_)\n         << \" qty:\" << qtyToString(qty_)\n         << \" price:\" << priceToString(price_)\n         << \" priority:\" << priorityToString(priority_)\n         << \"]\";\n      return ss.str();\n    }\n  };\n#pragma pack(pop)\n  typedef Common::LFQueue<Exchange::MEMarketUpdate>\n    MEMarketUpdateLFQueue;\n}\n```", "```cpp\n#pragma once\n#include <array>\n#include <sstream>\n#include \"common/types.h\"\nusing namespace Common;\nnamespace Exchange {\n  struct MEOrder {\n    TickerId ticker_id_ = TickerId_INVALID;\n    ClientId client_id_ = ClientId_INVALID;\n    OrderId client_order_id_ = OrderId_INVALID;\n    OrderId market_order_id_ = OrderId_INVALID;\n    Side side_ = Side::INVALID;\n    Price price_ = Price_INVALID;\n    Qty qty_ = Qty_INVALID;\n    Priority priority_ = Priority_INVALID;\n    MEOrder *prev_order_ = nullptr;\n    MEOrder *next_order_ = nullptr;\n    // only needed for use with MemPool.\n    MEOrder() = default;\n    MEOrder(TickerId ticker_id, ClientId client_id, OrderId\n      client_order_id, OrderId market_order_id, Side side,\n      Price price,Qty qty, Priority priority, MEOrder\n      *prev_order, MEOrder *next_order) noexcept\n        :     ticker_id_(ticker_id),\n              client_id_(client_id),\n              client_order_id_(client_order_id),\n              market_order_id_(market_order_id),\n              side_(side),\n              price_(price),\n              qty_(qty),\n              priority_(priority),\n              prev_order_(prev_order),\n              next_order_(next_order) {}\n    auto toString() const -> std::string;\n  };\n```", "```cpp\n  typedef std::array<MEOrder *, ME_MAX_ORDER_IDS>\n    OrderHashMap;\n  Typedef std::array<OrderHashMap, ME_MAX_NUM_CLIENTS>\n    ClientOrderHashMap;\n}\n```", "```cpp\n#include \"me_order.h\"\nnamespace Exchange {\n  auto MEOrder::toString() const -> std::string {\n    std::stringstream ss;\n    ss << \"MEOrder\" << \"[\"\n       << \"ticker:\" << tickerIdToString(ticker_id_) << \" \"\n       << \"cid:\" << clientIdToString(client_id_) << \" \"\n       << \"oid:\" << orderIdToString(client_order_id_) << \" \"\n       << \"moid:\" << orderIdToString(market_order_id_) << \" \"\n       << \"side:\" << sideToString(side_) << \" \"\n       << \"price:\" << priceToString(price_) << \" \"\n       << \"qty:\" << qtyToString(qty_) << \" \"\n       << \"prio:\" << priorityToString(priority_) << \" \"\n       << \"prev:\" << orderIdToString(prev_order_ ?\n         prev_order_->market_order_id_ :\n         OrderId_INVALID) << \" \"\n       << \"next:\" << orderIdToString(next_order_ ?\n         next_order_->market_order_id_ :\n         OrderId_INVALID) << \"]\";\n    return ss.str();\n  }\n}\n```", "```cpp\nnamespace Exchange {\n  struct MEOrdersAtPrice {\n    Side side_ = Side::INVALID;\n    Price price_ = Price_INVALID;\n    MEOrder *first_me_order_ = nullptr;\n    MEOrdersAtPrice *prev_entry_ = nullptr;\n    MEOrdersAtPrice *next_entry_ = nullptr;\n```", "```cpp\n    MEOrdersAtPrice() = default;\n    MEOrdersAtPrice(Side side, Price price, MEOrder\n      *first_me_order, MEOrdersAtPrice *prev_entry,\n      MEOrdersAtPrice *next_entry)\n        : side_(side), price_(price),\n        first_me_order_(first_me_order),\n        prev_entry_(prev_entry), next_entry_(next_entry) {}\n```", "```cpp\n    auto toString() const {\n      std::stringstream ss;\n      ss << \"MEOrdersAtPrice[\"\n         << \"side:\" << sideToString(side_) << \" \"\n         << \"price:\" << priceToString(price_) << \" \"\n         << \"first_me_order:\" << (first_me_order_ ?\n           first_me_order_->toString() : \"null\") << \" \"\n         << \"prev:\" << priceToString(prev_entry_ ?\n           prev_entry_->price_ : Price_INVALID) << \" \"\n         << \"next:\" << priceToString(next_entry_ ?\n           next_entry_->price_ : Price_INVALID) << \"]\";\n      return ss.str();\n    }\n  };\n```", "```cpp\n  typedef std::array<MEOrdersAtPrice *,\n    ME_MAX_PRICE_LEVELS> OrdersAtPriceHashMap;\n}\n```", "```cpp\n#pragma once\n#include \"common/thread_utils.h\"\n#include \"common/lf_queue.h\"\n#include \"common/macros.h\"\n#include \"order_server/client_request.h\"\n#include \"order_server/client_response.h\"\n#include \"market_data/market_update.h\"\n#include \"me_order_book.h\"\n```", "```cpp\nnamespace Exchange {\n  class MatchingEngine final {\n  public:\n    MatchingEngine(ClientRequestLFQueue *client_requests,\n                   ClientResponseLFQueue *client_responses,\n                   MEMarketUpdateLFQueue *market_updates);\n    ~MatchingEngine();\n    auto start() -> void;\n    auto stop() -> void;\n```", "```cpp\n    // Deleted default, copy & move constructors and\n    // assignment-operators.\n    MatchingEngine() = delete;\n    MatchingEngine(const MatchingEngine &) = delete;\n    MatchingEngine(const MatchingEngine &&) = delete;\n    MatchingEngine &operator=(const MatchingEngine &) =\n      delete;\n    MatchingEngine &operator=(const MatchingEngine &&) =\n      delete;\n```", "```cpp\n  private:\n    OrderBookHashMap ticker_order_book_;\n    ClientRequestLFQueue *incoming_requests_ = nullptr;\n    ClientResponseLFQueue *outgoing_ogw_responses_ =\n      nullptr;\n    MEMarketUpdateLFQueue *outgoing_md_updates_ = nullptr;\n    volatile bool run_ = false;\n    std::string time_str_;\n    Logger logger_;\n  };\n}\n```", "```cpp\n#include \"matching_engine.h\"\nnamespace Exchange {\n  MatchingEngine::MatchingEngine(ClientRequestLFQueue\n    *client_requests, ClientResponseLFQueue\n    *client_responses, MEMarketUpdateLFQueue\n    *market_updates)\n      : incoming_requests_(client_requests),\n        outgoing_ogw_responses_(client_responses),\n        outgoing_md_updates_(market_updates),\n        logger_(\"exchange_matching_engine.log\") {\n    for(size_t i = 0; i < ticker_order_book_.size(); ++i) {\n      ticker_order_book_[i] = new MEOrderBook(i, &logger_,\n        this);\n    }\n  }\n```", "```cpp\n  MatchingEngine::~MatchingEngine() {\n    run_ = false;\n    using namespace std::literals::chrono_literals;\n    std::this_thread::sleep_for(1s);\n    incoming_requests_ = nullptr;\n    outgoing_ogw_responses_ = nullptr;\n    outgoing_md_updates_ = nullptr;\n    for(auto& order_book : ticker_order_book_) {\n      delete order_book;\n      order_book = nullptr;\n    }\n  }\n```", "```cpp\n  auto MatchingEngine::start() -> void {\n    run_ = true;\n    ASSERT(Common::createAndStartThread(-1,\n      \"Exchange/MatchingEngine\", [this]() { run(); }) !=\n      nullptr, \"Failed to start MatchingEngine thread.\");\n  }\n```", "```cpp\n  auto MatchingEngine::stop() -> void {\n    run_ = false;\n  }\n}\n```", "```cpp\nauto run() noexcept {\n  logger_.log(\"%:% %() %\\n\", __FILE__, __LINE__,\n    __FUNCTION__, Common::getCurrentTimeStr(&time_str_));\n  while (run_) {\n    const auto me_client_request =\n      incoming_requests_->getNextToRead();\n    if (LIKELY(me_client_request)) {\n      logger_.log(\"%:% %() % Processing %\\n\", __FILE__,\n        __LINE__, __FUNCTION__,\n        Common::getCurrentTimeStr(&time_str_),\n                  me_client_request->toString());\n      processClientRequest(me_client_request);\n      incoming_requests_->updateReadIndex();\n    }\n  }\n}\n```", "```cpp\nauto processClientRequest(const MEClientRequest *client_request) noexcept {\n  auto order_book = ticker_order_book_[client_request\n    ->ticker_id_];\n```", "```cpp\n  switch (client_request->type_) {\n    case ClientRequestType::NEW: {\n      order_book->add(client_request->client_id_,\n        client_request->order_id_,\n        client_request->ticker_id_,\n        client_request->side_, client_request->price_,\n        client_request->qty_);\n    }\n      break;\n```", "```cpp\n    case ClientRequestType::CANCEL: {\n      order_book->cancel(client_request->client_id_,\n        client_request->order_id_,\n        client_request->ticker_id_);\n    }\n      break;\n    default: {\n      FATAL(\"Received invalid client-request-type:\" +\n        clientRequestTypeToString(client_request->type_));\n    }\n      break;\n  }\n}\n```", "```cpp\nauto sendClientResponse(const MEClientResponse *client_response) noexcept {\n  logger_.log(\"%:% %() % Sending %\\n\", __FILE__, __LINE__,\n    __FUNCTION__, Common::getCurrentTimeStr(&time_str_),\n    client_response->toString());\n  auto next_write = outgoing_ogw_responses_\n    ->getNextToWriteTo();\n  *next_write = std::move(*client_response);\n  outgoing_ogw_responses_->updateWriteIndex();\n}\n```", "```cpp\nauto sendMarketUpdate(const MEMarketUpdate *market_update) noexcept {\n  logger_.log(\"%:% %() % Sending %\\n\", __FILE__, __LINE__,\n    __FUNCTION__, Common::getCurrentTimeStr(&time_str_),\n    market_update->toString());\n  auto next_write = outgoing_md_updates_\n    ->getNextToWriteTo();\n  *next_write = *market_update;\n  outgoing_md_updates_->updateWriteIndex();\n}\n```", "```cpp\n#include <csignal>\n#include \"matcher/matching_engine.h\"\nCommon::Logger* logger = nullptr;\nExchange::MatchingEngine* matching_engine = nullptr;\nvoid signal_handler(int) {\n  using namespace std::literals::chrono_literals;\n  std::this_thread::sleep_for(10s);\n  delete logger; logger = nullptr;\n  delete matching_engine; matching_engine = nullptr;\n  std::this_thread::sleep_for(10s);\n  exit(EXIT_SUCCESS);\n}\n```", "```cpp\nint main(int, char **) {\n  logger = new Common::Logger(\"exchange_main.log\");\n  std::signal(SIGINT, signal_handler);\n  const int sleep_time = 100 * 1000;\n  Exchange::ClientRequestLFQueue\n    client_requests(ME_MAX_CLIENT_UPDATES);\n  Exchange::ClientResponseLFQueue\n    client_responses(ME_MAX_CLIENT_UPDATES);\n  Exchange::MEMarketUpdateLFQueue\n    market_updates(ME_MAX_MARKET_UPDATES);\n```", "```cpp\n  std::string time_str;\n  logger->log(\"%:% %() % Starting Matching Engine...\\n\",\n    __FILE__, __LINE__, __FUNCTION__,\n    Common::getCurrentTimeStr(&time_str));\n  matching_engine = new\n    Exchange::MatchingEngine(&client_requests,\n    &client_responses, &market_updates);\n  matching_engine->start();\n  while (true) {\n    logger->log(\"%:% %() % Sleeping for a few\n    milliseconds..\\n\", __FILE__, __LINE__, __FUNCTION__,\n    Common::getCurrentTimeStr(&time_str));\n    usleep(sleep_time * 1000);\n  }\n}\n```", "```cpp\nsghosh@sghosh-ThinkPad-X1-Carbon-3rd:~/Building-Low-Latency-Applications-with-CPP/Chapter6$ ./cmake-build-release/exchange_main\nSet core affinity for Common/Logger exchange_main.log 139685103920704 to -1\nSet core affinity for Common/Logger exchange_matching_engine.log 139684933506624 to -1\nSet core affinity for Exchange/MatchingEngine 139684925113920 to -1\n```", "```cpp\nexchange_main.log exchange_matching_engine.log\n```", "```cpp\n#pragma once\n#include \"common/types.h\"\n#include \"common/mem_pool.h\"\n#include \"common/logging.h\"\n#include \"order_server/client_response.h\"\n#include \"market_data/market_update.h\"\n#include \"me_order.h\"\nusing namespace Common;\nnamespace Exchange {\n  class MatchingEngine;\n  class MEOrderBook final {\n```", "```cpp\nprivate:\n  TickerId ticker_id_ = TickerId_INVALID;\n  MatchingEngine *matching_engine_ = nullptr;\n  ClientOrderHashMap cid_oid_to_order_;\n  MemPool<MEOrdersAtPrice> orders_at_price_pool_;\n  MEOrdersAtPrice *bids_by_price_ = nullptr;\n  MEOrdersAtPrice *asks_by_price_ = nullptr;\n  OrdersAtPriceHashMap price_orders_at_price_;\n  MemPool<MEOrder> order_pool_;\n  MEClientResponse client_response_;\n  MEMarketUpdate market_update_;\n  OrderId next_market_order_id_ = 1;\n  std::string time_str_;\n  Logger *logger_ = nullptr;\n```", "```cpp\n typedef std::array<MEOrderBook *, ME_MAX_TICKERS> OrderBookHashMap;\n  };\n}\n```", "```cpp\n#include \"me_order_book.h\"\n#include \"matcher/matching_engine.h\"\nMEOrderBook::MEOrderBook(TickerId ticker_id, Logger *logger, MatchingEngine *matching_engine)\n    : ticker_id_(ticker_id),\n      matching_engine_(matching_engine),\n      orders_at_price_pool_(ME_MAX_PRICE_LEVELS),\n      order_pool_(ME_MAX_ORDER_IDS), logger_(logger) {\n}\nMEOrderBook::~MEOrderBook() {\n  logger_->log(\"%:% %() % OrderBook\\n%\\n\", __FILE__,\n    __LINE__, __FUNCTION__,\n    Common::getCurrentTimeStr(&time_str_),\n              toString(false, true));\n  matching_engine_ = nullptr;\n  bids_by_price_ = asks_by_price_ = nullptr;\n  for (auto &itr: cid_oid_to_order_) {\n    itr.fill(nullptr);\n  }\n}\n```", "```cpp\n// Deleted default, copy & move constructors and\n// assignment-operators.\nMEOrderBook() = delete;\nMEOrderBook(const MEOrderBook &) = delete;\nMEOrderBook(const MEOrderBook &&) = delete;\nMEOrderBook &operator=(const MEOrderBook &) = delete;\nMEOrderBook &operator=(const MEOrderBook &&) = delete;\n```", "```cpp\nnamespace Exchange {\n  class MatchingEngine;\n  class MEOrderBook final {\nprivate:\n```", "```cpp\n  auto generateNewMarketOrderId() noexcept -> OrderId {\n    return next_market_order_id_++;\n  }\n```", "```cpp\n  auto priceToIndex(Price price) const noexcept {\n    return (price % ME_MAX_PRICE_LEVELS);\n  }\n```", "```cpp\n  auto getOrdersAtPrice(Price price) const noexcept ->\n    MEOrdersAtPrice * {\n    return price_orders_at_price_.at(priceToIndex(price));\n  }\n  };\n}\n```", "```cpp\nauto MEOrderBook::add(ClientId client_id, OrderId client_order_id, TickerId ticker_id, Side side, Price price, Qty qty) noexcept -> void {\n```", "```cpp\n  const auto new_market_order_id =\n    generateNewMarketOrderId();\n  client_response_ = {ClientResponseType::ACCEPTED,\n    client_id, ticker_id, client_order_id,\n    new_market_order_id, side, price, 0, qty};\n  matching_engine_->sendClientResponse(&client_response_);\n```", "```cpp\n  const auto leaves_qty = checkForMatch(client_id,\n    client_order_id, ticker_id, side, price, qty,\n    new_market_order_id);\n```", "```cpp\n  if (LIKELY(leaves_qty)) {\n    const auto priority = getNextPriority(ticker_id,\n    price);\n    auto order = order_pool_.allocate(ticker_id, client_id,\n      client_order_id, new_market_order_id, side, price,\n      leaves_qty, priority, nullptr, nullptr);\n    addOrder(order);\n    market_update_ = {MarketUpdateType::ADD,\n      new_market_order_id, ticker_id, side, price,\n      leaves_qty, priority};\n    matching_engine_->sendMarketUpdate(&market_update_);\n  }\n}\n```", "```cpp\nauto getNextPriority(Price price) noexcept {\n  const auto orders_at_price = getOrdersAtPrice(price);\n  if (!orders_at_price)\n    return 1lu;\n  return orders_at_price->first_me_order_->prev_order_\n    ->priority_ + 1;\n}\n```", "```cpp\nauto addOrder(MEOrder *order) noexcept {\n```", "```cpp\n  const auto orders_at_price = getOrdersAtPrice(order\n    ->price_);\n  if (!orders_at_price) {\n    order->next_order_ = order->prev_order_ = order;\n    auto new_orders_at_price =\n      orders_at_price_pool_.allocate(order->side_,\n      order->price_, order, nullptr, nullptr);\n    addOrdersAtPrice(new_orders_at_price);\n  }\n```", "```cpp\n  else {\n    auto first_order = (orders_at_price ?\n      orders_at_price->first_me_order_ : nullptr);\n    first_order->prev_order_->next_order_ = order;\n    order->prev_order_ = first_order->prev_order_;\n    order->next_order_ = first_order;\n    first_order->prev_order_ = order;\n  }\n```", "```cpp\n  cid_oid_to_order_.at(order->client_id_)\n    .at(order->client_order_id_) = order;\n}\n```", "```cpp\nauto addOrdersAtPrice(MEOrdersAtPrice *new_orders_at_price) noexcept {\n  price_orders_at_price_.at(priceToIndex(\n    new_orders_at_price->price_)) = new_orders_at_price;\n```", "```cpp\n  const auto best_orders_by_price = (new_orders_at_price->\n    side_ == Side::BUY ? bids_by_price_ : asks_by_price_);\n```", "```cpp\n  if (UNLIKELY(!best_orders_by_price)) {\n    (new_orders_at_price->side_ == Side::BUY ?\n      bids_by_price_ : asks_by_price_) =\n      new_orders_at_price;\n    new_orders_at_price->prev_entry_ =\n      new_orders_at_price->next_entry_ =\n      new_orders_at_price;\n  }\n```", "```cpp\n  else {\n    auto target = best_orders_by_price;\n    bool add_after = ((new_orders_at_price->side_ ==\n      Side::SELL && new_orders_at_price->price_ >\n      target->price_) || (new_orders_at_price->side_ ==\n      Side::BUY && new_orders_at_price->price_ <\n      target->price_));\n    if (add_after) {\n      target = target->next_entry_;\n      add_after = ((new_orders_at_price->side_ ==\n        Side::SELL && new_orders_at_price->price_ >\n        target->price_) || (new_orders_at_price->side_ ==\n        Side::BUY && new_orders_at_price->price_ <\n        target->price_));\n    }\n    while (add_after && target != best_orders_by_price) {\n      add_after = ((new_orders_at_price->side_ ==\n      Side::SELL && new_orders_at_price->price_ >\n      target->price_) || (new_orders_at_price->side_ ==\n      Side::BUY && new_orders_at_price->price_ <\n      target->price_));\n      if (add_after)\n        target = target->next_entry_;\n    }\n```", "```cpp\n    if (add_after) { // add new_orders_at_price after\n                     // target.\n      if (target == best_orders_by_price) {\n        target = best_orders_by_price->prev_entry_;\n      }\n      new_orders_at_price->prev_entry_ = target;\n      target->next_entry_->prev_entry_ =\n        new_orders_at_price;\n      new_orders_at_price->next_entry_ =\n        target->next_entry_;\n      target->next_entry_ = new_orders_at_price;\n    } else { // add new_orders_at_price before target.\n      new_orders_at_price->prev_entry_ =\n        target->prev_entry_;\n      new_orders_at_price->next_entry_ = target;\n      target->prev_entry_->next_entry_ =\n        new_orders_at_price;\n      target->prev_entry_ = new_orders_at_price;\n```", "```cpp\n      if ((new_orders_at_price->side_ == Side::BUY &&\n        new_orders_at_price->price_ > best_orders_by_price\n        ->price_) || new_orders_at_price->side_ ==\n        Side::SELL && new_orders_at_price->price_ <\n        best_orders_by_price->price_)) {\n        target->next_entry_ = (target->next_entry_ ==\n        best_orders_by_price ? new_orders_at_price :\n        target->next_entry_);\n        (new_orders_at_price->side_ == Side::BUY ?\n          bids_by_price_ : asks_by_price_) =\n          new_orders_at_price;\n      }\n    }\n  }\n}\n```", "```cpp\nauto MEOrderBook::cancel(ClientId client_id, OrderId order_id, TickerId ticker_id) noexcept -> void {\n  auto is_cancelable = (client_id <\n    cid_oid_to_order_.size());\n  MEOrder *exchange_order = nullptr;\n  if (LIKELY(is_cancelable)) {\n    auto &co_itr = cid_oid_to_order_.at(client_id);\n    exchange_order = co_itr.at(order_id);\n    is_cancelable = (exchange_order != nullptr);\n  }\n```", "```cpp\n  if (UNLIKELY(!is_cancelable)) {\n    client_response_ =\n      {ClientResponseType::CANCEL_REJECTED, client_id,\n      ticker_id, order_id, OrderId_INVALID,\n      Side::INVALID, Price_INVALID, Qty_INVALID,\n      Qty_INVALID};\n  }\n```", "```cpp\n  else {\n    client_response_ = {ClientResponseType::CANCELED,\n      client_id, ticker_id, order_id,\n      exchange_order->market_order_id_,\n      exchange_order->side_, exchange_order->price_,\n      Qty_INVALID, exchange_order->qty_};\n    market_update_ = {MarketUpdateType::CANCEL,\n      exchange_order->market_order_id_, ticker_id,\n      exchange_order->side_, exchange_order->price_, 0,\n      exchange_order->priority_};\n    removeOrder(exchange_order);\n    matching_engine_->sendMarketUpdate(&market_update_);\n  }\n  matching_engine_->sendClientResponse(&client_response_);\n}\n```", "```cpp\nauto removeOrder(MEOrder *order) noexcept {\n  auto orders_at_price = getOrdersAtPrice(order->price_);\n  if (order->prev_order_ == order) { // only one element.\n    removeOrdersAtPrice(order->side_, order->price_);\n  } else { // remove the link.\n    const auto order_before = order->prev_order_;\n    const auto order_after = order->next_order_;\n    order_before->next_order_ = order_after;\n    order_after->prev_order_ = order_before;\n    if (orders_at_price->first_me_order_ == order) {\n      orders_at_price->first_me_order_ = order_after;\n    }\n    order->prev_order_ = order->next_order_ = nullptr;\n  }\n  cid_oid_to_order_.at(order->client_id_).at(order\n    ->client_order_id_) = nullptr;\n  order_pool_.deallocate(order);\n}\n```", "```cpp\nauto removeOrdersAtPrice(Side side, Price price) noexcept {\n  const auto best_orders_by_price = (side == Side::BUY ?\n    bids_by_price_ : asks_by_price_);\n  auto orders_at_price = getOrdersAtPrice(price);\n  if (UNLIKELY(orders_at_price->next_entry_ ==\n    orders_at_price)) { // empty side of book.\n    (side == Side::BUY ? bids_by_price_ : asks_by_price_) =\n      nullptr;\n  } else {\n    orders_at_price->prev_entry_->next_entry_ =\n      orders_at_price->next_entry_;\n    orders_at_price->next_entry_->prev_entry_ =\n      orders_at_price->prev_entry_;\n    if (orders_at_price == best_orders_by_price) {\n      (side == Side::BUY ? bids_by_price_ : asks_by_price_)\n      = orders_at_price->next_entry_;\n    }\n    Orders_at_price->prev_entry_ = orders_at_price\n      ->next_entry_ = nullptr;\n  }\n  price_orders_at_price_.at(priceToIndex(price)) = nullptr;\n  orders_at_price_pool_.deallocate(orders_at_price);\n}\n```", "```cpp\nauto MEOrderBook::checkForMatch(ClientId client_id, OrderId client_order_id, TickerId ticker_id, Side side, Price price, Qty qty, Qty new_market_order_id) noexcept {\n  auto leaves_qty = qty;\n```", "```cpp\n  if (side == Side::BUY) {\n    while (leaves_qty && asks_by_price_) {\n      const auto ask_itr = asks_by_price_->first_me_order_;\n      if (LIKELY(price < ask_itr->price_)) {\n        break;\n      }\n      match(ticker_id, client_id, side, client_order_id,\n        new_market_order_id, ask_itr, &leaves_qty);\n    }\n  }\n```", "```cpp\n  if (side == Side::SELL) {\n    while (leaves_qty && bids_by_price_) {\n      const auto bid_itr = bids_by_price_->first_me_order_;\n      if (LIKELY(price > bid_itr->price_)) {\n        break;\n      }\n      match(ticker_id, client_id, side, client_order_id,\n        new_market_order_id, bid_itr, &leaves_qty);\n    }\n  }\n  return leaves_qty;\n}\n```", "```cpp\nauto MEOrderBook::match(TickerId ticker_id, ClientId client_id, Side side, OrderId client_order_id, OrderId new_market_order_id, MEOrder* itr, Qty* leaves_qty) noexcept {\n```", "```cpp\n  const auto order = itr;\n  const auto order_qty = order->qty_;\n  const auto fill_qty = std::min(*leaves_qty, order_qty);\n  *leaves_qty -= fill_qty;\n  order->qty_ -= fill_qty;\n```", "```cpp\n  client_response_ = {ClientResponseType::FILLED,\n    client_id, ticker_id, client_order_id,\n    new_market_order_id, side, itr->price_, fill_qty,\n    *leaves_qty};\n  matching_engine_->sendClientResponse(&client_response_);\n```", "```cpp\n  client_response_ = {ClientResponseType::FILLED, order\n    ->client_id_, ticker_id, order->client_order_id_,\n    order->market_order_id_, order->side_, itr->price_,\n    fill_qty, order->qty_};\n  matching_engine_->sendClientResponse(&client_response_);\n```", "```cpp\n  market_update_ = {MarketUpdateType::TRADE,\n    OrderId_INVALID, ticker_id, side, itr->price_,\n    fill_qty, Priority_INVALID};\n  matching_engine_->sendMarketUpdate(&market_update_);\n```", "```cpp\n  if (!order->qty_) {\n    market_update_ = {MarketUpdateType::CANCEL,\n      order->market_order_id_, ticker_id, order->side_,\n      order->price_, order_qty, Priority_INVALID};\n    matching_engine_->sendMarketUpdate(&market_update_);\n    removeOrder(order);\n  } else {\n    market_update_ = {MarketUpdateType::MODIFY,\n      order->market_order_id_, ticker_id, order->side_,\n      order->price_, order->qty_, order->priority_};\n    matching_engine_->sendMarketUpdate(&market_update_);\n  }\n}\n```"]