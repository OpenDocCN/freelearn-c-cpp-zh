["```cpp\nlayout (location = 0) in vec3 VertexPosition; \n\nout vec4 Position; \nout vec3 Normal; \n\nuniform float Time;  // The animation time \n\n// Wave parameters \nuniform float K;        // Wavenumber \nuniform float Velocity; // Wave's velocity \nuniform float Amp;      // Wave's amplitude \n\nuniform mat4 ModelViewMatrix; \nuniform mat3 NormalMatrix; \nuniform mat4 MVP; \n\nvoid main() {\n  vec4 pos = vec4(VertexPosition,1.0); \n\n  // Translate the y coordinate \n  float u = K * (pos.x - Velocity * Time); \n  pos.y = Amp * sin( u ); \n\n  // Compute the normal vector \n  vec3 n = vec3(0.0); \n  n.xy = normalize(vec2(-K * Amp *cos( u ), 1.0)); \n\n  // Send position and normal (in camera cords) to frag. \n  Position = ModelViewMatrix * pos; \n  Normal = NormalMatrix * n; \n\n  // The position in clip coordinates \n  gl_Position = MVP * pos; \n} \n```", "```cpp\nglDrawArraysInstanced( GL_TRIANGLES, 0, 3, 3);\n```", "```cpp\nglm::mat3 emitterBasis = ...; // Rotation matrix \nauto nParticles = 10000;\nglGenBuffers(1, &initVel);\nglBindBuffer(GL_ARRAY_BUFFER, initVel);\nglBufferData(GL_ARRAY_BUFFER, \n    nParticles * sizeof(float) * 3, nullptr, GL_STATIC_DRAW);\n\nglm::vec3 v(0);\nfloat velocity, theta, phi; \nstd::vector<GLfloat> data(nParticles * 3); \nfor( uint32_t i = 0; i < nParticles; i++ ) { \n  // Pick the direction of the velocity \n  theta = glm::mix(0.0f, glm::pi<float>() / 20.0f, randFloat()); \n  phi = glm::mix(0.0f, glm::two_pi<float>(), randFloat()); \n\n  v.x = sinf(theta) * cosf(phi); \n  v.y = cosf(theta); \n  v.z = sinf(theta) * sinf(phi); \n\n  // Scale to set the magnitude of the velocity (speed) \n  velocity = glm::mix(1.25f,1.5f,randFloat()); \n  v = glm::normalize(emitterBasis * v) * velocity; \n\n  data[3*i]   = v.x; \n  data[3*i+1] = v.y; \n  data[3*i+2] = v.z; \n} \nglBindBuffer(GL_ARRAY_BUFFER, initVel); \nglBufferSubData(GL_ARRAY_BUFFER, 0,  \n                nParticles * 3 * sizeof(float), data.data()); \n```", "```cpp\nglGenBuffers(1, &startTime);\nglBindBuffer(GL_ARRAY_BUFFER, startTime);\nglBufferData(GL_ARRAY_BUFFER, nParticles * sizeof(float), \n   nullptr, GL_STATIC_DRAW);\n\nfloat rate = particleLifetime / nParticles;  \nfor( uint32_t i = 0; i < nParticles; i++ ) { \n  data[i] = rate * i;\n} \nglBindBuffer(GL_ARRAY_BUFFER, startTime); \nglBufferSubData(GL_ARRAY_BUFFER, 0, nParticles * sizeof(float), data.data()); \n```", "```cpp\nglVertexAttribDivisor(0,1);\nglVertexAttribDivisor(1,1);\n```", "```cpp\nglEnable(GL_BLEND); \nglBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); \n```", "```cpp\nlayout (location = 0) in vec3 VertexInitVel;    // Particle initial velocity\nlayout (location = 1) in float VertexBirthTime; // Particle birth time\n\nout float Transp;  // Transparency of the particle\nout vec2 TexCoord; // Texture coordinate\n\nuniform float Time; // Animation time\nuniform vec3 Gravity; // Gravity vector in world coords\nuniform float ParticleLifetime; // Max particle lifetime\nuniform float ParticleSize; // Particle size\nuniform vec3 EmitterPos;    // Emitter position in world coordinates\n\n// Transformation matrices\nuniform mat4 MV, Proj;\n\n// Offsets to the position in camera coordinates for each vertex of the\n// particle's quad\nconst vec3 offsets[] = vec3[](\n    vec3(-0.5,-0.5,0), vec3(0.5,-0.5,0), vec3(0.5,0.5,0),\n    vec3(-0.5,-0.5,0), vec3(0.5,0.5,0), vec3(-0.5,0.5,0) );\n// Texture coordinates for each vertex of the particle's quad\nconst vec2 texCoords[] = vec2[](\n     vec2(0,0), vec2(1,0), vec2(1,1), \n     vec2(0,0), vec2(1,1), vec2(0,1)); \n\nvoid main() {\n    vec3 cameraPos; // Position in camera coordinates\n    float t = Time - VertexBirthTime;\n    if( t >= 0 && t < ParticleLifetime ) {\n        vec3 pos = EmitterPos + VertexInitVel * t + Gravity * t * t;\n        cameraPos = (MV * vec4(pos,1)).xyz + (offsets[gl_VertexID] * \n        ParticleSize);\n        Transp = mix( 1, 0, t / ParticleLifetime );\n    } else {\n        // Particle doesn't \"exist\", draw fully transparent\n        cameraPos = vec3(0);\n        Transp = 0.0;\n    }\n\n    TexCoord = texCoords[gl_VertexID];\n    gl_Position = Proj * vec4(cameraPos, 1);\n} \n```", "```cpp\nin float Transp; \nin vec2 TexCoord;\nuniform sampler2D ParticleTex; \n\nlayout ( location = 0 ) out vec4 FragColor; \n\nvoid main() {\n  FragColor = texture(ParticleTex, TexCoord); \n  FragColor.a *= Transp;\n} \n```", "```cpp\nglDepthMask(GL_FALSE);\nglBindVertexArray(particles);\nglDrawArraysInstanced(GL_TRIANGLES, 0, 6, nParticles);\nglBindVertexArray(0);\nglDepthMask(GL_TRUE);\n```", "```cpp\nTransp = mix( 1, 0, t / ParticleLifetime );\n```", "```cpp\nGLuint feedback[2];  // Transform feedback objects \nGLuint posBuf[2];    // Position buffers (A and B) \nGLuint velBuf[2];    // Velocity buffers (A and B) \nGLuint age[2];       // Age buffers (A and B) \n\n// Create and allocate buffers A and B for posBuf, velBuf, and age\n\n// Fill in the first age buffer\nstd::vector<GLfloat> tempData(nParticles);\nfloat rate = particleLifetime / nParticles;\nfor( int i = 0; i < nParticles; i++ ) {\n    tempData[i] = rate * (i - nParticles);\n}\nglBindBuffer(GL_ARRAY_BUFFER, age[0]);\nglBufferSubData(GL_ARRAY_BUFFER, 0, nParticles * sizeof(float),\n tempData.data()); \n// Setup the feedback objects \nglGenTransformFeedbacks(2, feedback); \n\n// Transform feedback 0 \nglBindTransformFeedback(GL_TRANSFORM_FEEDBACK, feedback[0]); \nglBindBufferBase(GL_TRANSFORM_FEEDBACK_BUFFER,0,posBuf[0]); \nglBindBufferBase(GL_TRANSFORM_FEEDBACK_BUFFER,1,velBuf[0]); \nglBindBufferBase(GL_TRANSFORM_FEEDBACK_BUFFER,2,age[0]); \n\n// Transform feedback 1 \nglBindTransformFeedback(GL_TRANSFORM_FEEDBACK, feedback[1]); \nglBindBufferBase(GL_TRANSFORM_FEEDBACK_BUFFER,0,posBuf[1]); \nglBindBufferBase(GL_TRANSFORM_FEEDBACK_BUFFER,1,velBuf[1]); \nglBindBufferBase(GL_TRANSFORM_FEEDBACK_BUFFER,2,age[1]);\n```", "```cpp\nconst float PI = 3.14159265359;\nlayout (location = 0) in vec3 VertexPosition;\nlayout (location = 1) in vec3 VertexVelocity;\nlayout (location = 2) in float VertexAge;\n\n// Render pass\nuniform int Pass;\n\n// Output to transform feedback buffers (pass 1)\nout vec3 Position;\nout vec3 Velocity;\nout float Age;\n\n// Out to fragment shader (pass 2)\nout float Transp; // Transparency\nout vec2 TexCoord; // Texture coordinate \n\n// Uniform variables here... (omitted)\n\nvec3 randomInitialVelocity() {\n  // Access the texture containing random velocities using gl_VertexID...\n}\n\nvoid update() {\n  if( VertexAge < 0 || VertexAge > ParticleLifetime ) {\n    // Recycle particle (or particle isn't born yet)\n    Position = Emitter;\n    Velocity = randomInitialVelocity();\n    if( VertexAge < 0 ) Age = VertexAge + DeltaT;\n    else Age = (VertexAge - ParticleLifetime) + DeltaT;\n } else {\n    // The particle is alive, update.\n    Position = VertexPosition + VertexVelocity * DeltaT;\n    Velocity = VertexVelocity + Accel * DeltaT;\n    Age = VertexAge + DeltaT;\n  }\n}\n\nvoid render() {\n  Transp = 0.0;\n  vec3 posCam = vec3(0.0);\n  if(VertexAge >= 0.0) {\n    posCam = (MV * vec4(VertexPosition,1)).xyz + offsets[gl_VertexID] * \n    ParticleSize;\n    Transp = clamp(1.0 - VertexAge / ParticleLifetime, 0, 1);\n  }\n  TexCoord = texCoords[gl_VertexID];\n  gl_Position = Proj * vec4(posCam,1);\n}\n\nvoid main() {\n if( Pass == 1 ) update();\n else render();\n}\n\n```", "```cpp\nconst char * outputNames[] = { \"Position\", \"Velocity\", \"Age\" };\nglTransformFeedbackVaryings(progHandle, 3, outputNames, GL_SEPARATE_ATTRIBS);\n```", "```cpp\n// Update pass\nprog.setUniform(\"Pass\", 1);\n\nglEnable(GL_RASTERIZER_DISCARD);\nglBindTransformFeedback(GL_TRANSFORM_FEEDBACK, feedback[drawBuf]);\nglBeginTransformFeedback(GL_POINTS);\n\nglBindVertexArray(particleArray[1-drawBuf]);\nglVertexAttribDivisor(0,0);\nglVertexAttribDivisor(1,0);\nglVertexAttribDivisor(2,0);\nglDrawArrays(GL_POINTS, 0, nParticles);\nglBindVertexArray(0);\n\nglEndTransformFeedback();\nglDisable(GL_RASTERIZER_DISCARD);\n```", "```cpp\n// Render pass\nprog.setUniform(\"Pass\", 2);\n\nglDepthMask(GL_FALSE);\nglBindVertexArray(particleArray[drawBuf]);\nglVertexAttribDivisor(0,1);\nglVertexAttribDivisor(1,1);\nglVertexAttribDivisor(2,1);\nglDrawArraysInstanced(GL_TRIANGLES, 0, 6, nParticles);\nglBindVertexArray(0);\nglDepthMask(GL_TRUE);\n```", "```cpp\ndrawBuf = 1 - drawBuf; \n```", "```cpp\nGLuint query; \nglGenQueries(1, &query); \n```", "```cpp\nglBeginQuery(GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, query); \n```", "```cpp\nglEndQuery(GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN); \n```", "```cpp\nGLuintprimWritten; \nglGetQueryObjectuiv(query, GL_QUERY_RESULT, &primWritten); \nprintf(\"Primitives written: %dn\", primWritten); \n```", "```cpp\n// Mesh attributes\nlayout (location = 0) in vec3 VertexPosition;\nlayout (location = 1) in vec3 VertexNormal;\n\n// Per-particle attributes\nlayout (location = 3) in vec3 ParticlePosition;\nlayout (location = 4) in vec3 ParticleVelocity;\nlayout (location = 5) in float ParticleAge;\nlayout (location = 6) in vec2 ParticleRotation;\n```", "```cpp\n// To transform feedback\nout vec3 Position;\nout vec3 Velocity;\nout float Age;\nout vec2 Rotation;\n\n// To fragment shader\nout vec3 fPosition;\nout vec3 fNormal;\n```", "```cpp\nvoid update() {\n    if( ParticleAge < 0 || ParticleAge > ParticleLifetime ) {\n        // The particle is past it's lifetime, recycle.\n        Position = Emitter;\n        Velocity = randomInitialVelocity();\n        Rotation = vec2( 0.0, randomInitialRotationalVelocity() );\n        if( ParticleAge < 0 ) Age = ParticleAge + DeltaT;\n        else Age = (ParticleAge - ParticleLifetime) + DeltaT;\n    } else {\n        // The particle is alive, update.\n        Position = ParticlePosition + ParticleVelocity * DeltaT;\n        Velocity = ParticleVelocity + Accel * DeltaT;\n        Rotation.x = mod( ParticleRotation.x + ParticleRotation.y \n        * DeltaT, 2.0 * PI );\n        Rotation.y = ParticleRotation.y;\n        Age = ParticleAge + DeltaT;\n    }\n}\n```", "```cpp\nvoid render() {\n    float cs = cos(ParticleRotation.x);\n    float sn = sin(ParticleRotation.x);\n    mat4 rotationAndTranslation = mat4(\n        1, 0, 0, 0,\n        0, cs, sn, 0,\n        0, -sn, cs, 0,\n        ParticlePosition.x, ParticlePosition.y, ParticlePosition.z, 1\n    );\n    mat4 m = MV * rotationAndTranslation;\n    fPosition = (m * vec4(VertexPosition, 1)).xyz;\n    fNormal = (m * vec4(VertexNormal, 0)).xyz;\n    gl_Position = Proj * vec4(fPosition, 1.0);\n}\n```", "```cpp\nglEnable(GL_RASTERIZER_DISCARD);\nglBindTransformFeedback(GL_TRANSFORM_FEEDBACK, feedback[drawBuf]);\nglBeginTransformFeedback(GL_POINTS);\nglBindVertexArray(particleArray[1-drawBuf]);\nglDisableVertexAttribArray(0);\nglDisableVertexAttribArray(1);\nglVertexAttribDivisor(3,0);\nglVertexAttribDivisor(4,0);\nglVertexAttribDivisor(5,0);\nglVertexAttribDivisor(6,0);\nglDrawArrays(GL_POINTS, 0, nParticles);\nglBindVertexArray(0);\nglEndTransformFeedback();\nglDisable(GL_RASTERIZER_DISCARD);; \n```", "```cpp\nglBindVertexArray(particleArray[drawBuf]);\nglEnableVertexAttribArray(0);\nglEnableVertexAttribArray(1);\nglVertexAttribDivisor(3,1);\nglVertexAttribDivisor(4,1);\nglVertexAttribDivisor(5,1);\nglVertexAttribDivisor(6,1);\nglDrawElementsInstanced(GL_TRIANGLES, torus.getNumVerts(), \n   GL_UNSIGNED_INT, 0, nParticles);\n```", "```cpp\nvec3 randomInitialVelocity() {\n    float velocity = mix(0.1, 0.5, texelFetch(RandomTex, 2 * \n    gl_VertexID, 0).r );\n    return EmitterBasis * vec3(0, velocity, 0);\n}\n\nvec3 randomInitialPosition() {\n    float offset = mix(-2.0, 2.0, texelFetch(RandomTex, 2 *\n    gl_VertexID + 1, 0).r);\n    return Emitter + vec3(offset, 0, 0);\n} \n```", "```cpp\nFragColor = texture(ParticleTex, TexCoord);\n// Mix with black as it gets older, to simulate a bit of smoke\nFragColor = vec4(mix( vec3(0,0,0), FragColor.xyz, Transp ), FragColor.a);\nFragColor.a *= Transp;\n```", "```cpp\nuniform float MinParticleSize = 0.1; \nuniform float MaxParticleSize = 2.5; \n```", "```cpp\nvoid render() {\n    Transp = 0.0;\n    vec3 posCam = vec3(0.0);\n    if( VertexAge >= 0.0 ) {\n        float agePct = VertexAge / ParticleLifetime;\n        Transp = clamp(1.0 - agePct, 0, 1);\n        posCam =\n            (MV * vec4(VertexPosition,1)).xyz +\n            offsets[gl_VertexID] *\n            mix(MinParticleSize, MaxParticleSize, agePct);\n    }\n    TexCoord = texCoords[gl_VertexID];\n    gl_Position = Proj * vec4(posCam,1);\n} \n```"]