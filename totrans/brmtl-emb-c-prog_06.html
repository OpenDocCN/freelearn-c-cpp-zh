<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer075">
			<h1 id="_idParaDest-109" class="chapter-number"><a id="_idTextAnchor192"/>6</h1>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor193"/>The Common Microcontroller Software Interface Standard (CMSIS)</h1>
			<p>In<a id="_idIndexMarker476"/> this chapter, we will delve into the <strong class="bold">Common Microcontroller Software Interface Standard</strong> (<strong class="bold">CMSIS</strong>), a critical framework for Cortex-M and some Cortex-A processors. We will begin by learning how to define hardware registers using C structures. This foundational knowledge will enable us to read and understand CMSIS-compliant header files provided by <span class="No-Break">microcontroller manufacturers.</span></p>
			<p>Next, we will explore CMSIS itself, discussing its components and how it facilitates efficient software development. Finally, we will set up the necessary header files from our silicon manufacturer, demonstrating how CMSIS compliance can streamline production and improve <span class="No-Break">code portability.</span></p>
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Defining peripheral registers with <span class="No-Break">C structures</span></li>
				<li><span class="No-Break">Understanding CMSIS</span></li>
				<li>Setting up the required <span class="No-Break">CMSIS files</span></li>
			</ul>
			<p>By the end of this chapter, you will be equipped with a solid understanding of CMSIS and how to use it to enhance code portability in your Arm <span class="No-Break">Cortex-M projects.</span></p>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor194"/>Technical requirements</h1>
			<p>All the code examples for this chapter can be found on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming"><span class="No-Break">https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-112"><a id="_idTextAnchor195"/>Defining peripheral registers with C structures</h1>
			<p>In <a id="_idIndexMarker477"/>embedded systems development, defining <a id="_idIndexMarker478"/>hardware registers using C structures is a fundamental technique that enhances code readability and maintainability. In this section, we will explore how to use C structures to represent peripherals and their registers, drawing on practical examples and analogies to simplify <span class="No-Break">the concept.</span></p>
			<p>In previous chapters, we configured a <strong class="bold">General Purpose Input/Output</strong> (<strong class="bold">GPIO</strong>) pin (PA5) to turn on an LED by <a id="_idIndexMarker479"/>manually defining the address of each required register. We learned how to find the correct addresses from documentation, define registers, and define register bits. This method, while effective, can become cumbersome as projects grow <span class="No-Break">in complexity.</span></p>
			<p>To streamline this process, we can use C structures to represent peripherals and their registers. This approach groups related registers into a cohesive unit to match the hardware architecture and memory map of our microcontroller, making the code <span class="No-Break">more intuitive.</span></p>
			<p>Let’s create a structure to represent the GPIO peripherals and their <span class="No-Break">associated registers.</span></p>
			<p>To achieve this, we need to get the base address of each GPIO port and the offset of each register within these ports. Here, offset refers to the register’s address relative to the peripheral’s <span class="No-Break">base address.</span></p>
			<p>Before diving into the details of creating the structure, it’s important to understand how to obtain the necessary base addresses <span class="No-Break">and offsets.</span></p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor196"/>Getting the base address and offsets of registers</h2>
			<p>In <a href="B21914_02.xhtml#_idTextAnchor039"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, we<a id="_idIndexMarker480"/> learned how to locate the base <a id="_idIndexMarker481"/>addresses of peripherals in our datasheet. Specifically, we examined pages 54 to 56 of the STM32F411 datasheet, which lists the base addresses for the microcontroller’s periphe<a id="_idTextAnchor197"/>rals. Here are the extracted base addresses for the GPIO <a id="_idIndexMarker482"/>and <strong class="bold">Reset and Clock Control</strong> (<span class="No-Break"><strong class="bold">RCC</strong></span><span class="No-Break">) peripherals:</span></p>
			<table id="table001-3" class="T---Table _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Header">
							<p><span class="No-Break"><strong class="bold">Peripheral</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><span class="No-Break"><strong class="bold">Base Address</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="bold">GPIOA</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">0x4002 0000</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="bold">GPIOB</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">0x4002 0400</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="bold">GPIOC</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">0x4002 0800</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="bold">GPIOD</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">0x4002 0C00</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="bold">GPIOE</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">0x4002 1000</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="bold">GPIOH</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">0x4002 1C00</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="bold">RCC</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><a id="_idTextAnchor198"/><span class="No-Break">0x4002 3800</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 6.1: Base addresses of GPIO and RCC</p>
			<p>Also, in <a href="B21914_02.xhtml#_idTextAnchor039"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, we covered <a id="_idIndexMarker483"/>how to extract the register offsets from<a id="_idIndexMarker484"/> the reference manual (<strong class="bold">RM383</strong>). Here are the extracted offsets for all the <span class="No-Break">GPIO registers:</span></p>
			<table id="table002-2" class="T---Table _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Header">
							<p><span class="No-Break"><strong class="bold">Register</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><span class="No-Break"><strong class="bold">Offset</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="bold" lang="en-US" xml:lang="en-US">GPIOx_MODER</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">0x00</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><strong class="bold" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor199"/></strong><span class="No-Break"><strong class="bold" lang="en-US" xml:lang="en-US">GPIOx_OTYPE</strong></span><span class="No-Break"><strong class="bold">R</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">0x04</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><strong class="bold" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor200"/></strong><span class="No-Break"><strong class="bold" lang="en-US" xml:lang="en-US">GPIOx_OSPEED</strong></span><span class="No-Break"><strong class="bold">R</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">0x08</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><strong class="bold" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor201"/></strong><span class="No-Break"><strong class="bold" lang="en-US" xml:lang="en-US">GPIOx_PUPD</strong></span><span class="No-Break"><strong class="bold">R</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">0x0C</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="bold" lang="en-US" xml:lang="en-US">GPIOx_IDR</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">0x10</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="bold" lang="en-US" xml:lang="en-US">GPIOx_ODR</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">0x14</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="bold" lang="en-US" xml:lang="en-US">GPIOx_BSRR</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">0x18</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="bold" lang="en-US" xml:lang="en-US">GPIOx_LCKR</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">0x1C</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="bold" lang="en-US" xml:lang="en-US">GPIOx_AFRL</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">0x20</span></p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break"><strong class="bold" lang="en-US" xml:lang="en-US">GPIOx_AFRH</strong></span></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><span class="No-Break">0x24</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 6.2: Offsets of GPIO register</p>
			<p><em class="italic">Table 6.1</em> shows all the<a id="_idIndexMarker485"/> GPIO registers of our STM32F411 <a id="_idIndexMarker486"/>microcontroller along with their offsets, arranged in the same order they appear in memory. Almost all registers in our microcontroller are 32 bits (4 bytes) in size. As illustrated in <em class="italic">Table 6.1</em>, each register is offset by 4 bytes from the previous one. For instance, the <strong class="source-inline">GPIOx_OTYPER</strong> register at <strong class="source-inline">0x04</strong> is 4 bytes from the <strong class="source-inline">GPIOx_MODER</strong> register at <strong class="source-inline">0x00</strong> (0x04 - 0x00 = 4). Similarly, the <strong class="source-inline">GPIOx_PUPDR</strong> register at <strong class="source-inline">0x0C</strong> is 4 bytes from the <strong class="source-inline">GPIOx_OSPEEDR</strong> register <span class="No-Break">at </span><span class="No-Break"><strong class="source-inline">0x08</strong></span><span class="No-Break">.</span></p>
			<p>This tells us that the registers are contiguously arranged in that memory region, since we know that each register is 4 bytes <span class="No-Break">in size.</span></p>
			<p>However, this contiguous arrangement is not always the case. There are instances where gaps of a few bytes are left between registers within <span class="No-Break">a peripheral.</span></p>
			<p><em class="italic">Now, what’s the relationship between the offset and the </em><span class="No-Break"><em class="italic">base address?</em></span></p>
			<p>Imagine your microcontroller as a large apartment complex. Each apartment represents a peripheral, such as GPIO or RCC, and the entrance to each apartment is the peripheral’s base address. Inside each apartment, there are several rooms, which represent the registers. Each room has a specific purpose and is located at a certain distance from the entrance, known as<a id="_idIndexMarker487"/> <span class="No-Break">the </span><span class="No-Break"><strong class="bold">offset</strong></span><span class="No-Break">.</span></p>
			<p>For example, when you enter the GPIO apartment (peripheral), the living room might be the <strong class="source-inline">GPIOx_MODER</strong> register located right at the entrance (offset 0x00). The kitchen could be the <strong class="source-inline">GPIOx_OTYPER</strong> register, located a bit further down the hallway (offset 0x04). The bedroom might be the <strong class="source-inline">GPIOx_OSPEEDR</strong> register, located even further down the hallway (offset 0x08), and <span class="No-Break">so on.</span></p>
			<p>This arrangement shows that each room (register) is placed at a fixed distance (offset) from the entrance (base address). In our case, since each room is 4 bytes in size, every subsequent room is 4 bytes away from the previous one. However, in some apartments (peripherals), there might be extra space between rooms, indicating non-contiguous placement of registers. This is similar to having a small hallway between rooms, which you’ll notice when you examine peripherals such as the RCC peripheral in the <span class="No-Break">reference manual.</span></p>
			<p>Now, let’s go ahead with implementing the peripheral structures using what we have learned <span class="No-Break">so far.</span></p>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor202"/>Implementing the peripheral structures</h2>
			<p>The following is <a id="_idIndexMarker488"/>our <strong class="source-inline">GPIO_TypeDef</strong> structure, representing the <span class="No-Break">GPIO peripherals:</span></p>
			<pre class="source-code">
typedef struct
{
  volatile uint32_t MODER;    /*offset: 0x00      */
  volatile uint32_t OTYPER;   /*offset: 0x04      */
  volatile uint32_t OSPEEDR;  /*offset: 0x08      */
  volatile uint32_t PUPDR;    /*offset: 0x0C      */
  volatile uint32_t IDR;      /*offset: 0x10      */
  volatile uint32_t ODR;      /*offset: 0x14      */
  volatile uint32_t BSRR;     /*offset: 0x18      */
  volatile uint32_t LCKR;     /*offset: 0x1C      */
  volatile uint32_t AFRL;     /*offset: 0x20     */
  volatile uint32_t AFRH;     /*offset: 0x24      */<a id="_idTextAnchor203"/>
} GPIO_TypeDef;</pre>			<p>Let’s break down <span class="No-Break">the syntax:</span></p>
			<p>The line <strong class="source-inline">typedef struct</strong> begins the definition of a new structure type. <strong class="source-inline">typedef</strong> is used to create an alias for the structure, allowing us to use <strong class="source-inline">GPIO_TypeDef</strong> as a type name later in <span class="No-Break">the code.</span></p>
			<p>Each member of the structure is declared as <strong class="source-inline">volatile uint32_t</strong>. Here’s <span class="No-Break">the breakdown:</span></p>
			<ul>
				<li><strong class="source-inline">volatile</strong>: This keyword indicates that the value of the variable can change at any time, often due to hardware changes. The compiler should not optimize accesses to <span class="No-Break">this variable.</span></li>
				<li><strong class="source-inline">uint32_t</strong>: This indicates that each member of the structure is a 32-bit (4-byte) unsigned integer. This is important because the registers we are working with are also 32 bits in size. To ensure that the structure members accurately represent these registers, they must match this size. This alignment guarantees that each member corresponds correctly to its respective register in the <span class="No-Break">memory map.</span></li>
			</ul>
			<p>Also note that the structure members are arranged in the same order and have the same size as the registers, as specified in the <span class="No-Break">reference manual.</span></p>
			<p>Now, as we<a id="_idIndexMarker489"/> discussed in <a href="B21914_02.xhtml#_idTextAnchor039"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, to use any peripheral in the microcontroller, we first need to enable clock access to that peripheral. This is done through the RCC peripheral. Let’s create the structure for the <span class="No-Break">RCC peripheral.</span></p>
			<p>This is our <span class="No-Break">RCC structure:</span></p>
			<pre class="source-code">
typedef struct
{
  volatile uint32_t DUMMY[12];
  volatile uint32_t AHB1ENR;       /*offset: 0x30*/
} RCC_TypeDef;</pre>			<p>The RCC peripheral of the STM32F411 microcontroller has about 24 registers, which are not contiguous, leaving gaps in the memory region. The register we are interested in for the purposes of GPIO peripherals is the <strong class="source-inline">AHB1ENR</strong> register, which has an offset <span class="No-Break">of 0x30.</span></p>
			<p>In our <strong class="source-inline">RCC_TypeDef</strong>, we have added padding to the structure with the number of <strong class="source-inline">uint32_t</strong> (4 bytes) items required to reach the offset 0x30. In this case, it is 12 items. This is <em class="italic">because 4 bytes multiplied by 12 equals 48 bytes</em>, which corresponds to <em class="italic">0x30 in </em><span class="No-Break"><em class="italic">hexadecimal notation</em></span><span class="No-Break">.</span></p>
			<p>At this point, we have <a id="_idIndexMarker490"/>defined two important structures (<strong class="source-inline">GPIO_TypeDef</strong> and <strong class="source-inline">RCC_TypeDef</strong>) required to configure and control our GPIO pins. The next step involves creating pointers to the base addresses of the GPIO and RCC peripherals using these structures. This allows us to access and manipulate the peripheral registers in a structured and readable manner. Here is the code snippet that <span class="No-Break">accomplishes this:</span></p>
			<pre class="source-code">
#define     RCC_BASE     0x40023800
#define     GPIOA_BASE  0x40020000
#define     RCC         ((RCC_TypeDef*) RCC_BASE)
#define    GPIOA         ((GPIO_TypeDef*)GPIOA_BASE)</pre>			<p>Let’s break <span class="No-Break">it down:</span></p>
			<ul>
				<li><strong class="source-inline">#define </strong><span class="No-Break"><strong class="source-inline">RCC_BASE 0x40023800</strong></span><p class="list-inset">This line defines the base address of the RCC peripheral. The address value is taken from <span class="No-Break"><em class="italic">Table 6.1</em></span><span class="No-Break">.</span></p></li>
				<li><strong class="source-inline">#define </strong><span class="No-Break"><strong class="source-inline">GPIOA_BASE 0x40020000</strong></span><p class="list-inset">This line defines the base address of the <span class="No-Break">GPIOA peripheral.</span></p></li>
				<li><strong class="source-inline">#define RCC ((</strong><span class="No-Break"><strong class="source-inline">RCC_TypeDef*) RCC_BASE)</strong></span><p class="list-inset">This line defines a macro, <strong class="source-inline">RCC</strong>, that casts the <strong class="source-inline">RCC_BASE</strong> base address to a pointer of <span class="No-Break">type </span><span class="No-Break"><strong class="source-inline">RCC_TypeDef*</strong></span><span class="No-Break">.</span></p><p class="list-inset">By doing this, <strong class="source-inline">RCC</strong> becomes a pointer to the RCC peripheral, allowing us to access its registers through the <span class="No-Break"><strong class="source-inline">RCC_TypeDef</strong></span><span class="No-Break"> structure.</span></p></li>
				<li><strong class="source-inline">#define GPIOA ((</strong><span class="No-Break"><strong class="source-inline">GPIO_TypeDef*) GPIOA_BASE)</strong></span><p class="list-inset">Similarly, this line defines a macro, <strong class="source-inline">GPIOA</strong>, that casts the <strong class="source-inline">GPIOA_BASE</strong> base address to a pointer of <span class="No-Break">type </span><span class="No-Break"><strong class="source-inline">GPIO_TypeDef*</strong></span><span class="No-Break">.</span></p><p class="list-inset">This makes <strong class="source-inline">GPIOA</strong> a pointer to the GPIOA peripheral, enabling access to its registers via the <span class="No-Break"><strong class="source-inline">GPIO_TypeDef</strong></span><span class="No-Break"> structure.</span></p></li>
			</ul>
			<p>With this accomplished, we are now ready to test out our implementation. Let’s do that in the <span class="No-Break">next section.</span></p>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor204"/>Evaluating the structure-based register access method</h2>
			<p>Let’s update our previous <a id="_idIndexMarker491"/>project to use the structure-based register <span class="No-Break">access approach:</span></p>
			<pre class="source-code">
// 0: Include standard integer types header for fixed-width //integer types
#include &lt;stdint.h&gt;
// 1: GPIO_TypeDef structure definition
typedef struct
{
  volatile uint32_t MODER;    /*offset: 0x00      */
  volatile uint32_t OTYPER;   /*offset: 0x04      */
  volatile uint32_t OSPEEDR;  /*offset: 0x08      */
  volatile uint32_t PUPDR;    /*offset: 0x0C      */
  volatile uint32_t IDR;      /*offset: 0x10      */
  volatile uint32_t ODR;      /*offset: 0x14      */
  volatile uint32_t BSRR;     /*offset: 0x18      */
  volatile uint32_t LCKR;     /*offset: 0x1C      */
  volatile uint32_t AFRL;     /*offset: 0x20     */
  volatile uint32_t AFRH;     /*offset: 0x24      */
} GPIO_TypeDef;
// 2: RCC_TypeDef structure definition
typedef struct
{
  volatile uint32_t DUMMY[12];
  volatile uint32_t AHB1ENR;       /*offset: 0x30*/
} RCC_TypeDef;
// 3: Base address definitions
#define     RCC_BASE     0x40023800
#define     GPIOA_BASE   0x40020000
// 4: Peripheral pointer definitions
#define RCC            ((RCC_TypeDef*) RCC_BASE)
#define GPIOA        ((GPIO_TypeDef*)GPIOA_BASE)
//5: Bit mask for enabling GPIOA (bit 0)
#define GPIOAEN       (1U&lt;&lt;0)
//6: Bit mask for GPIOA pin 5
#define PIN5          (1U&lt;&lt;5)
//7: Alias for PIN5 representing LED pin
#define LED_PIN       PIN5
//  8: Start of main function
int main(void)
{
    //  9: Enable clock access to GPIOA
     RCC-&gt;AHB1ENR |=  GPIOAEN;
     GPIOA-&gt;MODER |= (1U&lt;&lt;10);  //  10: Set bit 10 to 1
     GPIOA-&gt;MODER &amp;= ~(1U&lt;&lt;11); //  11: Set bit 11 to 0
    //  21: Start of infinite loop
    while(1)
    {
        //  12: Set PA5(LED_PIN) high
        GPIOA-&gt;ODR^= LED_PIN;
        // 13: Simple delay
                for(int i=0;i&lt;100000;i++){}
    }
}</pre>			<p>In this new<a id="_idIndexMarker492"/> implementation, we access the required registers using the C structure pointer operator (<strong class="source-inline">-&gt;</strong>). Here’s a breakdown <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">RCC-&gt;AHB1ENR</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="source-inline">RCC</strong>: This is the pointer to a structure of type <strong class="source-inline">RCC_TypeDef</strong>. This pointer allows us to access the RCC registers using the <span class="No-Break">structure’s members.</span></li>
				<li><strong class="source-inline">-&gt;</strong>: This is the structure pointer operator in C. It is used to access a member of a structure through <span class="No-Break">a pointer.</span></li>
				<li><strong class="source-inline">AHB1ENR</strong>: This is a member of the <span class="No-Break"><strong class="source-inline">RCC_TypeDef</strong></span><span class="No-Break"> structure.</span></li>
			</ul>
			<p>Similarly, we use the same approach to access <span class="No-Break">GPIOA registers.</span></p>
			<p>Here’s a breakdown of <strong class="source-inline">GPIOA-&gt;MODER</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">GPIOA-&gt;ODR</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="source-inline">GPIOA</strong>: This is a pointer to the structure of type <strong class="source-inline">GPIO_TypeDef</strong>, allowing access to <span class="No-Break">GPIOA registers</span></li>
				<li><strong class="source-inline">MODER</strong>: A member of the <strong class="source-inline">GPIO_TypeDef</strong> structure, representing the GPIO port <span class="No-Break">mode register</span></li>
				<li><strong class="source-inline">ODR</strong>: Another member of the <strong class="source-inline">GPIO_TypeDef</strong> structure, representing the GPIO port output <span class="No-Break">data register</span></li>
			</ul>
			<p>Build the project and<a id="_idIndexMarker493"/> run it on your development board. It should work the same way as the <span class="No-Break">previous project.</span></p>
			<p>In this section, we learned how to define hardware registers using C structures. This technique is an important step toward understanding CMSIS-compliant code, which will be covered in the <span class="No-Break">next sections.</span></p>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor205"/>Understanding CMSIS</h1>
			<p>In this section, we will explore CMSIS, an i<a id="_idTextAnchor206"/>mportant framework designed for Arm Cortex-M and some Cortex-A <a id="_idIndexMarker494"/>processors. <strong class="bold">CMSIS</strong> is a vendor-independent hardware abstraction layer that standardizes software interfaces across various Arm Cortex-based microcontroller platforms, promoting software portability and reusability. Let’s start by understanding CMSIS and its <span class="No-Break">key benefits.</span></p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor207"/>What is CMSIS?</h2>
			<p>CMSIS, pronounced <em class="italic">See-M-Sys</em>, is a standard developed by Arm to provide a consistent and efficient way to<a id="_idIndexMarker495"/> interface with Cortex-based microcontrollers. It includes a comprehensive set of APIs, software components, tools, and workflows designed to simplify and streamline the development process for <span class="No-Break">embedded systems.</span></p>
			<p>Its key benefits<a id="_idIndexMarker496"/> include <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Standardization</strong>: CMSIS standardizes the interface for all Cortex-based microcontrollers, making it easier for you to switch between different microcontrollers and tools without having to relearn or reconfigure your <span class="No-Break">code base</span></li>
				<li><strong class="bold">Portability</strong>: By providing a consistent API, CMSIS allows software developed for one microcontroller to be easily ported to another, enhancing code reuse and reducing <span class="No-Break">development time</span></li>
				<li><strong class="bold">Efficiency</strong>: CMSIS <a id="_idIndexMarker497"/>includes optimized libraries and functions, such as <strong class="bold">Digital Signal Processing</strong> (<strong class="bold">DSP</strong>) and neural <a id="_idIndexMarker498"/>network kernels, which improve performance and reduce the <span class="No-Break">memory footprint</span></li>
			</ul>
			<p>CMSIS has several components. Let’s explore some of the commonly <span class="No-Break">used ones.</span></p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor208"/>Key components of CMSIS</h2>
			<p>CMSIS comprises several <a id="_idIndexMarker499"/>components, each serving a <span class="No-Break">unique purpose:</span></p>
			<ul>
				<li><strong class="bold">CMSIS-Core (M)</strong>: This component <a id="_idIndexMarker500"/>is designed for all Cortex-M and SecurCore processors. It provides standardized APIs for configuring the Cortex-M processor core and peripherals. It also standardizes the naming of device peripheral registers, which helps reduce the learning curve when switching between <span class="No-Break">different microcontrollers.</span></li>
				<li><strong class="bold">CMSIS-Driver</strong>: This<a id="_idIndexMarker501"/> provides generic peripheral driver interfaces for middleware, facilitating the connection between microcontroller peripherals and middleware such as communication stacks, filesystems, or graphical <span class="No-Break">user interfaces.</span></li>
				<li><strong class="bold">CMSIS-DSP</strong>: This<a id="_idIndexMarker502"/> component offers a library of over 60 functions for various data types, optimized for the <strong class="bold">Single Instruction Multiple Data</strong> (<strong class="bold">SIMD</strong>) instruction sets<a id="_idIndexMarker503"/> available on Cortex-M4, M7, M33, and <span class="No-Break">M35P processors.</span></li>
				<li><strong class="bold">CMSIS-NN</strong>: This <a id="_idIndexMarker504"/>stands for <strong class="bold">neural network</strong>. It includes a collection of efficient neural network kernels <a id="_idIndexMarker505"/>optimized to maximize the performance and minimize the memory footprint on Cortex-M <span class="No-Break">processor cores.</span></li>
				<li><strong class="bold">CMSIS-RTOS</strong>: There are <a id="_idIndexMarker506"/>two versions, RTOS v1 and RTOS v2. RTOS v1 supports Cortex-M0, M0+, M3, M4, and M7 processors, providing a common API for real-time operating systems. RTOS v2 extends support to Cortex-A5, A7, and A9 processors, including features such as dynamic object creation and multi-core <span class="No-Break">system support.</span></li>
				<li><strong class="bold">CMSIS-Pack</strong>: Pack <a id="_idIndexMarker507"/>outlines a delivery system for software components, device parameters, and evaluation board support. It streamlines software reuse and facilitates effective product life <span class="No-Break">cycle management.</span></li>
				<li><strong class="bold">CMSIS-SVD</strong>: <strong class="bold">SVD</strong> stands for <strong class="bold">System Viewer Description</strong>. It defines device description<a id="_idIndexMarker508"/> files maintained by<a id="_idIndexMarker509"/> the silicon vendor, containing comprehensive descriptions of the microcontroller peripherals and registers in XML format. Development tools import these files to automatically construct peripheral <span class="No-Break">debug </span><span class="No-Break"><a id="_idIndexMarker510"/></span><span class="No-Break">windows.</span></li>
			</ul>
			<p>Another crucial aspect of CMSIS is its coding standard. Let’s take a closer look to familiarize ourselves with <span class="No-Break">these guidelines.</span></p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor209"/>The CMSIS coding rules</h2>
			<p>Here are the essential coding<a id="_idIndexMarker511"/> rules and conventions used <span class="No-Break">in CMSIS:</span></p>
			<ul>
				<li><strong class="bold">Compliance with ANSI C (C99) and C++ (C++03)</strong>: This ensures compatibility with widely accepted <span class="No-Break">programming standards.</span></li>
				<li><strong class="bold">Standard data types</strong>: Uses ANSI C standard data types defined in <strong class="source-inline">&lt;stdint.h&gt;</strong>, ensuring consistency in <span class="No-Break">data representation.</span></li>
				<li><strong class="bold">Complete data types</strong>: Variables and parameters are defined with complete data types, <span class="No-Break">avoiding ambiguity.</span></li>
				<li><strong class="bold">MISRA 2012 conformance</strong>: While CMSIS conforms to the MISRA 2012 guidelines, it does not claim full MISRA compliance. Any rule violations are documented <span class="No-Break">for transparency.</span></li>
			</ul>
			<p>Additionally, CMSIS uses <span class="No-Break">specific </span><span class="No-Break"><a id="_idIndexMarker512"/></span><span class="No-Break">qualifiers:</span></p>
			<ul>
				<li><strong class="source-inline">__I</strong> for read-only variables (equivalent to <strong class="bold">volatile const</strong> in <span class="No-Break">ANSI C)</span></li>
				<li><strong class="source-inline">__O</strong> for <span class="No-Break">write-only variables</span></li>
				<li><strong class="source-inline">__IO</strong> for read and write variables (equivalent to <strong class="bold">volatile</strong> in <span class="No-Break">ANSI C)</span></li>
			</ul>
			<p>These<a id="_idIndexMarker513"/> qualifiers in CMSIS provide a convenient way to specify the intended access mode for variables, particularly for memory-mapped <span class="No-Break">peripheral registers.</span></p>
			<p>With this background knowledge, let’s go ahead and learn how to use CMSIS in our <span class="No-Break">embedded projects.</span></p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor210"/>The CMSIS-Core files</h2>
			<p>The CMSIS-Core files are <a id="_idIndexMarker514"/>categorized into two primary groups, each serving a specific purpose in the development process. These groups are the CMSIS-Core standard files and the CMSIS-Core device files. <span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.1</em> provides a comprehensive overview of the CMSIS-Core file structure, illustrating the different types of files and their roles in <span class="No-Break">a project.</span></p>
			<div>
				<div id="_idContainer072" class="IMG---Figure">
					<img src="image/B21914_06_1.jpg" alt="Figure 6.1: The CMSIS-Core files" width="1650" height="735"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1: The CMSIS-Core files</p>
			<p>Let’s analyze <span class="No-Break">the diagram.</span></p>
			<p>The files are divided into three categories: <strong class="bold">CMSIS-Core Standard Files</strong>, <strong class="bold">CMSIS-Core Device Files</strong>, and <strong class="bold">User </strong><span class="No-Break"><strong class="bold">Program Files</strong></span><span class="No-Break">.</span></p>
			<p>The <strong class="bold">CMSIS-Core Standard Files</strong> category<a id="_idIndexMarker515"/> of files is provided by Arm and typically does not require modifications. They<a id="_idIndexMarker516"/> include <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="source-inline">core_&lt;cpu&gt;.h</strong>: This provides access to the CPU and <span class="No-Break">core-specific functionalities</span></li>
				<li><strong class="source-inline">cmsis_compiler.h</strong>: This contains core peripheral functions, CPU instruction access, and SIMD <span class="No-Break">instruction access</span></li>
				<li><strong class="source-inline">&lt;arch&gt;_&lt;feature&gt;.h</strong>: This defines architecture-specific attributes <span class="No-Break">and features</span></li>
				<li><strong class="source-inline">cmsis_&lt;compiler&gt;_m.h</strong>: This is<a id="_idIndexMarker517"/> a toolchain-specific file that aids in compiler compatibility <span class="No-Break">and optimization</span></li>
			</ul>
			<p>The next category<a id="_idIndexMarker518"/> is <strong class="bold">CMSIS-Core Device Files</strong>. These files are provided by silicon vendors (such as STMicroelectronics) and may require application-specific modifications. They include <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="source-inline">system_&lt;Device&gt;.c</strong>: This file handles system and <span class="No-Break">clock configuration</span></li>
				<li><strong class="source-inline">partition_&lt;Device&gt;.h</strong>: This manages secure attributes and <span class="No-Break">interrupt assignments</span></li>
				<li><strong class="source-inline">startup_&lt;Device&gt;.c</strong>: This contains the device startup <span class="No-Break">interrupt vectors</span></li>
				<li><strong class="source-inline">&lt;Device&gt;.h</strong>: This provides access to the CMSIS device <span class="No-Break">peripheral functionalities</span></li>
				<li><strong class="source-inline">system_&lt;Device&gt;.h</strong>: This assists in system and <span class="No-Break">clock configuration</span></li>
			</ul>
			<p>The third category <a id="_idIndexMarker519"/>is <strong class="bold">User Program Files</strong>. These are created by us, the developers, and include the main application code along with other user-defined functionalities essential for the <span class="No-Break">project’s operation.</span></p>
			<p>Understanding CMSIS is<a id="_idIndexMarker520"/> fundamental for efficient and standardized development across various Arm Cortex-based microcontroller platforms. In this section, we have explored its key components, the CMSIS coding standards, and the CMSIS-Core files crucial to the development of embedded projects. In the next section, we will learn how to include the required CMSIS files in our project, enabling us to leverage the full potential of this robust framework for developing <span class="No-Break">embedded systems.</span></p>
			<h1 id="_idParaDest-121"><a id="_idTextAnchor211"/>Setting up the required CMSIS files</h1>
			<p>In this section, we will <a id="_idIndexMarker521"/>work through the process of integrating CMSIS files into our project. These files also contain the definitions of all the registers and their respective bits, making it easier to manage and configure peripherals without manually defining <span class="No-Break">each register.</span></p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor212"/>Getting the right header files</h2>
			<p>Let’s start by<a id="_idIndexMarker522"/> downloading the package for our microcontroller from the <span class="No-Break">STMicroelectronics website:</span></p>
			<ol>
				<li>Open your browser and go <span class="No-Break">to </span><a href="https://www.st.com/content/st_com/en.html"><span class="No-Break">https://www.st.com/content/st_com/en.html</span></a><span class="No-Break">.</span></li>
				<li>Search for <strong class="source-inline">STM32CubeF4</strong> to locate the package for the STM32F4 <span class="No-Break">microcontroller series.</span></li>
				<li>Next, download the <span class="No-Break">STM32CubeF4 package:</span><ol><li class="upper-roman">Locate the STM32CubeF4 package and download the latest version. Make sure not to download the <span class="No-Break">patch version.</span></li><li class="upper-roman">Once the download is complete, unzip the package. You will find several subfolders inside, including the <span class="No-Break"><strong class="source-inline">Drivers</strong></span><span class="No-Break"> folder.</span></li></ol></li>
			</ol>
			<p>Our next steps involve organizing <span class="No-Break">the files:</span></p>
			<ol>
				<li>Inside your project workspace, create a new folder <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">chip_headers</strong></span><span class="No-Break">.</span></li>
				<li>Within the <strong class="source-inline">chip_headers</strong> folder, create another folder <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">CMSIS</strong></span><span class="No-Break">.</span></li>
				<li>Navigate to <strong class="source-inline">Drivers/CMSIS</strong> in the <span class="No-Break">extracted package.</span></li>
				<li>Copy the entire <strong class="source-inline">Include</strong> folder from <strong class="source-inline">Drivers/CMSIS</strong> <span class="No-Break">into </span><span class="No-Break"><strong class="source-inline">chip_headers/CMSIS</strong></span><span class="No-Break">.</span></li>
				<li>Next, copy the <strong class="source-inline">Device</strong> folder from <strong class="source-inline">Drivers/CMSIS</strong> <span class="No-Break">into </span><span class="No-Break"><strong class="source-inline">chip_headers/CMSIS</strong></span><span class="No-Break">.</span></li>
			</ol>
			<p>Finally, we clean up the <span class="No-Break"><strong class="source-inline">Device</strong></span><span class="No-Break"> folder:</span></p>
			<ol>
				<li>Navigate <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">chip_headers/CMSIS/Device/ST/STM32F4xx</strong></span><span class="No-Break">.</span></li>
				<li>Delete all files and folders, <em class="italic">except the Include folder</em>. This ensures you keep only the necessary<a id="_idIndexMarker523"/> header files for your <span class="No-Break">specific microcontroller.</span></li>
			</ol>
			<p>Moving forward, we will consistently include the <strong class="source-inline">chip_headers</strong> folder in our project directories. This practice ensures that anyone running our projects on a different computer won’t encounter errors due to missing <span class="No-Break">header files.</span></p>
			<p>In the next section, we’ll create a new project in STM32CubeIDE. After setting up the project, we’ll copy the <strong class="source-inline">chip_headers</strong> folder and paste it into the project directory. Subsequently, we’ll add the subfolders within <strong class="source-inline">chip_headers</strong> to our project’s <strong class="source-inline">include</strong> paths, ensuring seamless integration of the necessary <span class="No-Break">CMSIS files.</span></p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor213"/>Working with CMSIS files</h2>
			<p>In this section, we will integrate the <a id="_idIndexMarker524"/>CMSIS files into our project by adding the relevant folders to our project’s <strong class="source-inline">include</strong> paths. We will then test our setup by updating our <strong class="source-inline">main.c</strong> file to use these CMSIS files instead of our manually defined <span class="No-Break">peripheral structures.</span></p>
			<p>Let’s begin by creating a new project following the steps outlined in <a href="B21914_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>. I will name my project <strong class="source-inline">header_files</strong>. Once the project is created, I’ll copy and paste the <strong class="source-inline">chip_headers</strong> folder into the <span class="No-Break">project folder.</span></p>
			<p>Our next task involves adding the paths of the subfolders within the <strong class="source-inline">chip_headers</strong> folder to our project’s <span class="No-Break"><strong class="source-inline">include</strong></span><span class="No-Break"> paths:</span></p>
			<ol>
				<li>Open STM32CubeIDE, right-click on your project, and <span class="No-Break">select </span><span class="No-Break"><strong class="bold">Properties</strong></span><span class="No-Break">.</span></li>
				<li>Once the <strong class="bold">Properties</strong> window opens, expand the <strong class="bold">C/C++ </strong><span class="No-Break"><strong class="bold">General</strong></span><span class="No-Break"> options.</span></li>
				<li>Select <strong class="bold">Paths </strong><span class="No-Break"><strong class="bold">and Symbols</strong></span><span class="No-Break">.</span></li>
				<li>Under the <strong class="bold">Includes</strong> tab, click <strong class="bold">Add</strong> to add a <span class="No-Break">new directory.</span></li>
				<li>Enter <strong class="source-inline">${ProjDirPath}\chip_headers\CMSIS\Include</strong> to add the <strong class="source-inline">Include</strong> folder located in our <strong class="source-inline">CMSIS</strong> folder, and then click <strong class="bold">OK</strong> <span class="No-Break">to save.</span></li>
				<li>Click <strong class="bold">Add</strong> again to add <span class="No-Break">another directory.</span></li>
				<li>Enter <strong class="source-inline">${ProjDirPath}\chip_headers\CMSIS\Device\ST\STM32F4xx\Include</strong> to add the <strong class="source-inline">Include</strong> folder located in the <strong class="source-inline">STM32F<a id="_idTextAnchor214"/>4xx</strong> subdirectory and click <strong class="bold">OK</strong> <span class="No-Break">to save.</span></li>
			</ol>
			<p><span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.2</em> illustrates the Project Properties window after adding these directories to the project’s <span class="No-Break"><strong class="source-inline">include</strong></span><span class="No-Break"> paths.</span></p>
			<div>
				<div id="_idContainer073" class="IMG---Figure">
					<img src="image/B21914_06_2.jpg" alt="Figure 6.2: The Includes tab in the project properties window" width="1000" height="793"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2: The Includes tab in the project properties window</p>
			<p>Let’s break down the two<a id="_idIndexMarker525"/> lines we have <span class="No-Break">just added:</span></p>
			<ul>
				<li><strong class="source-inline">${</strong><span class="No-Break"><strong class="source-inline">ProjDirPath}\chip_headers\CMSIS\Include</strong></span><span class="No-Break">:</span><ul><li><strong class="source-inline">${ProjDirPath}</strong>: This is a macro in STM32CubeIDE that represents the root directory of your current project. It’s a placeholder that dynamically points to the directory where your project <span class="No-Break">is located.</span></li><li><strong class="source-inline">\chip_headers\CMSIS\Include</strong>: This specifies the path relative to the project’s root directory. It points to the <strong class="source-inline">Include</strong> folder within the <strong class="source-inline">CMSIS</strong> directory inside the <strong class="source-inline">chip_headers</strong> folder. This folder contains general CMSIS include files, which provide core functionalities and definitions for the <span class="No-Break">Cortex-M processor.</span></li></ul></li>
				<li><strong class="source-inline">${</strong><span class="No-Break"><strong class="source-inline">ProjDirPath}\chip_headers\CMSIS\Device\ST\STM32F4xx\Include</strong></span><span class="No-Break">:</span><ul><li><strong class="source-inline">${ProjDirPath}</strong>: As mentioned earlier, this macro represents the root directory of your <span class="No-Break">current project.</span></li><li><strong class="source-inline">\chip_headers\CMSIS\Device\ST\STM32F4xx\Include</strong>: This specifies another path relative to the project’s root directory. It points to the <strong class="source-inline">Include</strong> folder within the <strong class="source-inline">STM32F4xx</strong> subdirectory inside the <strong class="source-inline">Device</strong> directory, which is located in the <strong class="source-inline">CMSIS</strong> directory in the <strong class="source-inline">chip_headers</strong> folder. This folder contains device-specific include files for the STM32F4xx series microcontrollers, providing definitions and configurations specific to this family <span class="No-Break">of microcontrollers.</span></li></ul></li>
			</ul>
			<p>Before closing the project properties dialog box, we need to specify the exact version of the STM32F4 microcontroller we are using. This ensures that the appropriate header file for our specific microcontroller is<a id="_idIndexMarker526"/> enabled in our project. As we can see, the <strong class="source-inline">STM32F4xx\Include</strong> subfolder contains header files for various microcontrollers within the STM32F4 family. The NUCLEO-F411 development board has the <span class="No-Break">STM32F411 microcontroller.</span></p>
			<p>To configure our project for the <span class="No-Break">STM32F411 microcontroller:</span></p>
			<ol>
				<li>Click on the <strong class="bold"># </strong><span class="No-Break"><strong class="bold">Symbols</strong></span><span class="No-Break"> tab.</span></li>
				<li>Click <strong class="bold">Add…</strong> to add a <span class="No-Break">new symbol.</span></li>
				<li>In the <strong class="bold">Add Symbol</strong> dialog box, enter <strong class="source-inline">STM32F411xE</strong> in the <strong class="bold">Name</strong> field and then <span class="No-Break">click </span><span class="No-Break"><strong class="bold">OK</strong></span><span class="No-Break">.</span></li>
				<li>Click <strong class="bold">Apply and Close</strong> to save all changes and close the Project <span class="No-Break">Properties window.</span></li>
			</ol>
			<p><span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.3</em> illustrates the <strong class="bold">Symbols</strong> tab of the project properties window after adding the <span class="No-Break"><strong class="source-inline">STM32F411xE</strong></span><span class="No-Break"> symbol.</span></p>
			<div>
				<div id="_idContainer074" class="IMG---Figure">
					<img src="image/B21914_06_3.jpg" alt="Figure 6.3: The Symbols tab in the project properties window" width="1000" height="789"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3: The Symbols tab in the project properties window</p>
			<p>To test our <a id="_idIndexMarker527"/>setup, let’s follow <span class="No-Break">these steps:</span></p>
			<ol>
				<li>Copy the entire content of the <strong class="source-inline">main.c</strong> file from our previous project that used the structure-based <span class="No-Break">access approach.</span></li>
				<li>Open the <strong class="source-inline">main.c</strong> file in the <span class="No-Break">current project.</span></li>
				<li>Delete all the existing content in the <span class="No-Break"><strong class="source-inline">main.c</strong></span><span class="No-Break"> file.</span></li>
				<li>Paste the copied content into the <span class="No-Break"><strong class="source-inline">main.c</strong></span><span class="No-Break"> file.</span></li>
				<li>In the <strong class="source-inline">main.c</strong> file, delete all the code related to manually defined addresses and structures, as we will now use the register definitions provided in our <span class="No-Break">header files.</span></li>
				<li>Include the <strong class="source-inline">stm32f4xx.h</strong> header file in your project to access <span class="No-Break">these definitions.</span></li>
				<li>Build the project in the IDE and run it on the <span class="No-Break">development board.</span></li>
			</ol>
			<p>The following snippet shows the updated <span class="No-Break"><strong class="source-inline">main.c</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
//1: In<a id="_idTextAnchor215"/>clude the stm32f4 header file
<strong class="bold">#include</strong> "stm32f4xx.h"
//2: Bit mask for enabling GPIOA (bit 0)
<strong class="bold">#define</strong> GPIOAEN       (1U&lt;&lt;0)
//3: Bit mask for GPIOA pin 5
<strong class="bold">#define</strong> PIN5          (1U&lt;&lt;5)
//4: Alias for PIN5 representing LED pin
<strong class="bold">#define</strong> LED_PIN       PIN5
<strong class="bold">int main(void)</strong>
{
     //  5: Enable clock access to GPIOA
     RCC-&gt;AHB1ENR |=  GPIOAEN;
     //  6: Set PA5 to output mode
     GPIOA-&gt;MODER |= (1U&lt;&lt;10);
     GPIOA-&gt;MODER &amp;= ~(1U&lt;&lt;11);
    <strong class="bold">while</strong>(1)
    {
        //  7: Set PA5(LED_PIN) high
        GPIOA-&gt;ODR^= LED_PIN;
        // 8: Simple delay
        <strong class="bold">for</strong>(<strong class="bold">int</strong> i=0;i&lt;100000;i++){}
    }
}</pre>			<p>You’ll observe that this<a id="_idIndexMarker528"/> project builds without any errors and works in the same way as our previous one. This implementation accesses the microcontroller registers defined <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">chip_headers/CMSIS/Device/ST/STM32F4xx/Include/stm32f411xe.h</strong></span><span class="No-Break">.</span></p>
			<p>Upon inspecting <a id="_idIndexMarker529"/>this file, you will find that it contains a <strong class="source-inline">typedef</strong> structure for each peripheral of our microcontroller, similar to the one we manually created a few sections ago. This means that moving forward, we don’t need to manually extract the base addresses and register offsets from the documentation. Instead, we can simply include the <strong class="source-inline">stm32f4xx.h</strong> header file in our project. This header file will in turn include the <strong class="source-inline">stm32f411xe.h</strong> file because we specified in the <strong class="bold">Symbols</strong> tab of the project properties window that we are using the <span class="No-Break"><em class="italic">STM32F411xE</em></span><span class="No-Break"> microcontroller.</span></p>
			<p>Setting up the required header files significantly simplifies configuring and using peripherals on our STM32 microcontroller. This approach allows us to leverage pre-defined register addresses and bit definitions, making our code more readable and maintainable while also reducing <span class="No-Break">development time.</span></p>
			<h1 id="_idParaDest-124"><a id="_idTextAnchor216"/>Summary</h1>
			<p>In this chapter, we explored CMSIS, a critical framework for Cortex-M and some Cortex-A processors. This chapter gave us the foundational knowledge to enhance code portability and efficiency in our Arm <span class="No-Break">Cortex-M projects.</span></p>
			<p>We began by learning how to define hardware registers using C structures, a fundamental technique for improving code readability and maintainability. This knowledge allowed us to understand how the CMSIS-compliant header files provided by microcontroller manufacturers give us access to the <span class="No-Break">register definitions.</span></p>
			<p>Next, we explored CMSIS itself, discussing its components and how it facilitates efficient software development. We examined the key benefits of CMSIS, such as standardization, portability, and efficiency, and introduced its main components, including CMSIS-Core, CMSIS-Driver, CMSIS-DSP, CMSIS-NN, CMSIS-RTOS, CMSIS-Pack, <span class="No-Break">and CMSIS-SVD.</span></p>
			<p>We then moved on to setting up the necessary CMSIS files from our silicon manufacturer. This process involved downloading the relevant packages, organizing the files, and integrating them into <span class="No-Break">our project.</span></p>
			<p>Finally, we tested our setup by updating our previous project to use CMSIS files instead of our manually defined peripheral structures. This practical application showcased how CMSIS simplifies accessing microcontroller registers, making the code more readable, maintainable, <span class="No-Break">and efficient.</span></p>
			<p>In the next chapter, we will learn about the GPIO peripheral. This chapter will provide a comprehensive understanding of how to configure and use GPIO for input/output applications in <span class="No-Break">embedded systems.</span></p>
		</div>
	</div>
</div>
</body></html>