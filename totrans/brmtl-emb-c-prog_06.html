<html><head></head><body>
<div><div><div><h1 id="_idParaDest-109" class="chapter-number"><a id="_idTextAnchor192"/>6</h1>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor193"/>The Common Microcontroller Software Interface Standard (CMSIS)</h1>
			<p>In<a id="_idIndexMarker476"/> this chapter, we will delve into the <strong class="bold">Common Microcontroller Software Interface Standard</strong> (<strong class="bold">CMSIS</strong>), a critical framework for Cortex-M and some Cortex-A processors. We will begin by learning how to define hardware registers using C structures. This foundational knowledge will enable us to read and understand CMSIS-compliant header files provided by microcontroller manufacturers.</p>
			<p>Next, we will explore CMSIS itself, discussing its components and how it facilitates efficient software development. Finally, we will set up the necessary header files from our silicon manufacturer, demonstrating how CMSIS compliance can streamline production and improve code portability.</p>
			<p>In this chapter, we’re going to cover the following main topics:</p>
			<ul>
				<li>Defining peripheral registers with C structures</li>
				<li>Understanding CMSIS</li>
				<li>Setting up the required CMSIS files</li>
			</ul>
			<p>By the end of this chapter, you will be equipped with a solid understanding of CMSIS and how to use it to enhance code portability in your Arm Cortex-M projects.</p>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor194"/>Technical requirements</h1>
			<p>All the code examples for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming">https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming</a>.</p>
			<h1 id="_idParaDest-112"><a id="_idTextAnchor195"/>Defining peripheral registers with C structures</h1>
			<p>In <a id="_idIndexMarker477"/>embedded systems development, defining <a id="_idIndexMarker478"/>hardware registers using C structures is a fundamental technique that enhances code readability and maintainability. In this section, we will explore how to use C structures to represent peripherals and their registers, drawing on practical examples and analogies to simplify the concept.</p>
			<p>In previous chapters, we configured a <strong class="bold">General Purpose Input/Output</strong> (<strong class="bold">GPIO</strong>) pin (PA5) to turn on an LED by <a id="_idIndexMarker479"/>manually defining the address of each required register. We learned how to find the correct addresses from documentation, define registers, and define register bits. This method, while effective, can become cumbersome as projects grow in complexity.</p>
			<p>To streamline this process, we can use C structures to represent peripherals and their registers. This approach groups related registers into a cohesive unit to match the hardware architecture and memory map of our microcontroller, making the code more intuitive.</p>
			<p>Let’s create a structure to represent the GPIO peripherals and their associated registers.</p>
			<p>To achieve this, we need to get the base address of each GPIO port and the offset of each register within these ports. Here, offset refers to the register’s address relative to the peripheral’s base address.</p>
			<p>Before diving into the details of creating the structure, it’s important to understand how to obtain the necessary base addresses and offsets.</p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor196"/>Getting the base address and offsets of registers</h2>
			<p>In <a href="B21914_02.xhtml#_idTextAnchor039"><em class="italic">Chapter 2</em></a>, we<a id="_idIndexMarker480"/> learned how to locate the base <a id="_idIndexMarker481"/>addresses of peripherals in our datasheet. Specifically, we examined pages 54 to 56 of the STM32F411 datasheet, which lists the base addresses for the microcontroller’s periphe<a id="_idTextAnchor197"/>rals. Here are the extracted base addresses for the GPIO <a id="_idIndexMarker482"/>and <strong class="bold">Reset and Clock Control</strong> (<strong class="bold">RCC</strong>) peripherals:</p>
			<table id="table001-3" class="T---Table _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Header">
							<p><strong class="bold">Peripheral</strong></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><strong class="bold">Base Address</strong></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><strong class="bold">GPIOA</strong></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>0x4002 0000</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><strong class="bold">GPIOB</strong></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>0x4002 0400</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><strong class="bold">GPIOC</strong></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>0x4002 0800</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><strong class="bold">GPIOD</strong></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>0x4002 0C00</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><strong class="bold">GPIOE</strong></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>0x4002 1000</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><strong class="bold">GPIOH</strong></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>0x4002 1C00</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><strong class="bold">RCC</strong></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p><a id="_idTextAnchor198"/>0x4002 3800</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 6.1: Base addresses of GPIO and RCC</p>
			<p>Also, in <a href="B21914_02.xhtml#_idTextAnchor039"><em class="italic">Chapter 2</em></a>, we covered <a id="_idIndexMarker483"/>how to extract the register offsets from<a id="_idIndexMarker484"/> the reference manual (<strong class="bold">RM383</strong>). Here are the extracted offsets for all the GPIO registers:</p>
			<table id="table002-2" class="T---Table _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Header">
							<p><strong class="bold">Register</strong></p>
						</td>
						<td class="T---Table T---Body T---Header">
							<p><strong class="bold">Offset</strong></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><strong class="bold" lang="en-US" xml:lang="en-US">GPIOx_MODER</strong></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>0x00</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><strong class="bold" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor199"/></strong><strong class="bold" lang="en-US" xml:lang="en-US">GPIOx_OTYPE</strong><strong class="bold">R</strong></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>0x04</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><strong class="bold" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor200"/></strong><strong class="bold" lang="en-US" xml:lang="en-US">GPIOx_OSPEED</strong><strong class="bold">R</strong></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>0x08</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><strong class="bold" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor201"/></strong><strong class="bold" lang="en-US" xml:lang="en-US">GPIOx_PUPD</strong><strong class="bold">R</strong></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>0x0C</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><strong class="bold" lang="en-US" xml:lang="en-US">GPIOx_IDR</strong></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>0x10</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><strong class="bold" lang="en-US" xml:lang="en-US">GPIOx_ODR</strong></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>0x14</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><strong class="bold" lang="en-US" xml:lang="en-US">GPIOx_BSRR</strong></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>0x18</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><strong class="bold" lang="en-US" xml:lang="en-US">GPIOx_LCKR</strong></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>0x1C</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><strong class="bold" lang="en-US" xml:lang="en-US">GPIOx_AFRL</strong></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>0x20</p>
						</td>
					</tr>
					<tr class="T---Table">
						<td class="T---Table T---Body T---Body">
							<p><strong class="bold" lang="en-US" xml:lang="en-US">GPIOx_AFRH</strong></p>
						</td>
						<td class="T---Table T---Body T---Body">
							<p>0x24</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 6.2: Offsets of GPIO register</p>
			<p><em class="italic">Table 6.1</em> shows all the<a id="_idIndexMarker485"/> GPIO registers of our STM32F411 <a id="_idIndexMarker486"/>microcontroller along with their offsets, arranged in the same order they appear in memory. Almost all registers in our microcontroller are 32 bits (4 bytes) in size. As illustrated in <em class="italic">Table 6.1</em>, each register is offset by 4 bytes from the previous one. For instance, the <code>GPIOx_OTYPER</code> register at <code>0x04</code> is 4 bytes from the <code>GPIOx_MODER</code> register at <code>0x00</code> (0x04 - 0x00 = 4). Similarly, the <code>GPIOx_PUPDR</code> register at <code>0x0C</code> is 4 bytes from the <code>GPIOx_OSPEEDR</code> register at <code>0x08</code>.</p>
			<p>This tells us that the registers are contiguously arranged in that memory region, since we know that each register is 4 bytes in size.</p>
			<p>However, this contiguous arrangement is not always the case. There are instances where gaps of a few bytes are left between registers within a peripheral.</p>
			<p><em class="italic">Now, what’s the relationship between the offset and the </em><em class="italic">base address?</em></p>
			<p>Imagine your microcontroller as a large apartment complex. Each apartment represents a peripheral, such as GPIO or RCC, and the entrance to each apartment is the peripheral’s base address. Inside each apartment, there are several rooms, which represent the registers. Each room has a specific purpose and is located at a certain distance from the entrance, known as<a id="_idIndexMarker487"/> the <strong class="bold">offset</strong>.</p>
			<p>For example, when you enter the GPIO apartment (peripheral), the living room might be the <code>GPIOx_MODER</code> register located right at the entrance (offset 0x00). The kitchen could be the <code>GPIOx_OTYPER</code> register, located a bit further down the hallway (offset 0x04). The bedroom might be the <code>GPIOx_OSPEEDR</code> register, located even further down the hallway (offset 0x08), and so on.</p>
			<p>This arrangement shows that each room (register) is placed at a fixed distance (offset) from the entrance (base address). In our case, since each room is 4 bytes in size, every subsequent room is 4 bytes away from the previous one. However, in some apartments (peripherals), there might be extra space between rooms, indicating non-contiguous placement of registers. This is similar to having a small hallway between rooms, which you’ll notice when you examine peripherals such as the RCC peripheral in the reference manual.</p>
			<p>Now, let’s go ahead with implementing the peripheral structures using what we have learned so far.</p>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor202"/>Implementing the peripheral structures</h2>
			<p>The following is <a id="_idIndexMarker488"/>our <code>GPIO_TypeDef</code> structure, representing the GPIO peripherals:</p>
			<pre class="source-code">
typedef struct
{
  volatile uint32_t MODER;    /*offset: 0x00      */
  volatile uint32_t OTYPER;   /*offset: 0x04      */
  volatile uint32_t OSPEEDR;  /*offset: 0x08      */
  volatile uint32_t PUPDR;    /*offset: 0x0C      */
  volatile uint32_t IDR;      /*offset: 0x10      */
  volatile uint32_t ODR;      /*offset: 0x14      */
  volatile uint32_t BSRR;     /*offset: 0x18      */
  volatile uint32_t LCKR;     /*offset: 0x1C      */
  volatile uint32_t AFRL;     /*offset: 0x20     */
  volatile uint32_t AFRH;     /*offset: 0x24      */<a id="_idTextAnchor203"/>
} GPIO_TypeDef;</pre>			<p>Let’s break down the syntax:</p>
			<p>The line <code>typedef struct</code> begins the definition of a new structure type. <code>typedef</code> is used to create an alias for the structure, allowing us to use <code>GPIO_TypeDef</code> as a type name later in the code.</p>
			<p>Each member of the structure is declared as <code>volatile uint32_t</code>. Here’s the breakdown:</p>
			<ul>
				<li><code>volatile</code>: This keyword indicates that the value of the variable can change at any time, often due to hardware changes. The compiler should not optimize accesses to this variable.</li>
				<li><code>uint32_t</code>: This indicates that each member of the structure is a 32-bit (4-byte) unsigned integer. This is important because the registers we are working with are also 32 bits in size. To ensure that the structure members accurately represent these registers, they must match this size. This alignment guarantees that each member corresponds correctly to its respective register in the memory map.</li>
			</ul>
			<p>Also note that the structure members are arranged in the same order and have the same size as the registers, as specified in the reference manual.</p>
			<p>Now, as we<a id="_idIndexMarker489"/> discussed in <a href="B21914_02.xhtml#_idTextAnchor039"><em class="italic">Chapter 2</em></a>, to use any peripheral in the microcontroller, we first need to enable clock access to that peripheral. This is done through the RCC peripheral. Let’s create the structure for the RCC peripheral.</p>
			<p>This is our RCC structure:</p>
			<pre class="source-code">
typedef struct
{
  volatile uint32_t DUMMY[12];
  volatile uint32_t AHB1ENR;       /*offset: 0x30*/
} RCC_TypeDef;</pre>			<p>The RCC peripheral of the STM32F411 microcontroller has about 24 registers, which are not contiguous, leaving gaps in the memory region. The register we are interested in for the purposes of GPIO peripherals is the <code>AHB1ENR</code> register, which has an offset of 0x30.</p>
			<p>In our <code>RCC_TypeDef</code>, we have added padding to the structure with the number of <code>uint32_t</code> (4 bytes) items required to reach the offset 0x30. In this case, it is 12 items. This is <em class="italic">because 4 bytes multiplied by 12 equals 48 bytes</em>, which corresponds to <em class="italic">0x30 in </em><em class="italic">hexadecimal notation</em>.</p>
			<p>At this point, we have <a id="_idIndexMarker490"/>defined two important structures (<code>GPIO_TypeDef</code> and <code>RCC_TypeDef</code>) required to configure and control our GPIO pins. The next step involves creating pointers to the base addresses of the GPIO and RCC peripherals using these structures. This allows us to access and manipulate the peripheral registers in a structured and readable manner. Here is the code snippet that accomplishes this:</p>
			<pre class="source-code">
#define     RCC_BASE     0x40023800
#define     GPIOA_BASE  0x40020000
#define     RCC         ((RCC_TypeDef*) RCC_BASE)
#define    GPIOA         ((GPIO_TypeDef*)GPIOA_BASE)</pre>			<p>Let’s break it down:</p>
			<ul>
				<li><code>#define </code><code>RCC_BASE 0x40023800</code><p class="list-inset">This line defines the base address of the RCC peripheral. The address value is taken from <em class="italic">Table 6.1</em>.</p></li>
				<li><code>#define </code><code>GPIOA_BASE 0x40020000</code><p class="list-inset">This line defines the base address of the GPIOA peripheral.</p></li>
				<li><code>#define RCC ((</code><code>RCC_TypeDef*) RCC_BASE)</code><p class="list-inset">This line defines a macro, <code>RCC</code>, that casts the <code>RCC_BASE</code> base address to a pointer of type <code>RCC_TypeDef*</code>.</p><p class="list-inset">By doing this, <code>RCC</code> becomes a pointer to the RCC peripheral, allowing us to access its registers through the <code>RCC_TypeDef</code> structure.</p></li>
				<li><code>#define GPIOA ((</code><code>GPIO_TypeDef*) GPIOA_BASE)</code><p class="list-inset">Similarly, this line defines a macro, <code>GPIOA</code>, that casts the <code>GPIOA_BASE</code> base address to a pointer of type <code>GPIO_TypeDef*</code>.</p><p class="list-inset">This makes <code>GPIOA</code> a pointer to the GPIOA peripheral, enabling access to its registers via the <code>GPIO_TypeDef</code> structure.</p></li>
			</ul>
			<p>With this accomplished, we are now ready to test out our implementation. Let’s do that in the next section.</p>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor204"/>Evaluating the structure-based register access method</h2>
			<p>Let’s update our previous <a id="_idIndexMarker491"/>project to use the structure-based register access approach:</p>
			<pre class="source-code">
// 0: Include standard integer types header for fixed-width //integer types
#include &lt;stdint.h&gt;
// 1: GPIO_TypeDef structure definition
typedef struct
{
  volatile uint32_t MODER;    /*offset: 0x00      */
  volatile uint32_t OTYPER;   /*offset: 0x04      */
  volatile uint32_t OSPEEDR;  /*offset: 0x08      */
  volatile uint32_t PUPDR;    /*offset: 0x0C      */
  volatile uint32_t IDR;      /*offset: 0x10      */
  volatile uint32_t ODR;      /*offset: 0x14      */
  volatile uint32_t BSRR;     /*offset: 0x18      */
  volatile uint32_t LCKR;     /*offset: 0x1C      */
  volatile uint32_t AFRL;     /*offset: 0x20     */
  volatile uint32_t AFRH;     /*offset: 0x24      */
} GPIO_TypeDef;
// 2: RCC_TypeDef structure definition
typedef struct
{
  volatile uint32_t DUMMY[12];
  volatile uint32_t AHB1ENR;       /*offset: 0x30*/
} RCC_TypeDef;
// 3: Base address definitions
#define     RCC_BASE     0x40023800
#define     GPIOA_BASE   0x40020000
// 4: Peripheral pointer definitions
#define RCC            ((RCC_TypeDef*) RCC_BASE)
#define GPIOA        ((GPIO_TypeDef*)GPIOA_BASE)
//5: Bit mask for enabling GPIOA (bit 0)
#define GPIOAEN       (1U&lt;&lt;0)
//6: Bit mask for GPIOA pin 5
#define PIN5          (1U&lt;&lt;5)
//7: Alias for PIN5 representing LED pin
#define LED_PIN       PIN5
//  8: Start of main function
int main(void)
{
    //  9: Enable clock access to GPIOA
     RCC-&gt;AHB1ENR |=  GPIOAEN;
     GPIOA-&gt;MODER |= (1U&lt;&lt;10);  //  10: Set bit 10 to 1
     GPIOA-&gt;MODER &amp;= ~(1U&lt;&lt;11); //  11: Set bit 11 to 0
    //  21: Start of infinite loop
    while(1)
    {
        //  12: Set PA5(LED_PIN) high
        GPIOA-&gt;ODR^= LED_PIN;
        // 13: Simple delay
                for(int i=0;i&lt;100000;i++){}
    }
}</pre>			<p>In this new<a id="_idIndexMarker492"/> implementation, we access the required registers using the C structure pointer operator (<code>-&gt;</code>). Here’s a breakdown of <code>RCC-&gt;AHB1ENR</code>:</p>
			<ul>
				<li><code>RCC</code>: This is the pointer to a structure of type <code>RCC_TypeDef</code>. This pointer allows us to access the RCC registers using the structure’s members.</li>
				<li><code>-&gt;</code>: This is the structure pointer operator in C. It is used to access a member of a structure through a pointer.</li>
				<li><code>AHB1ENR</code>: This is a member of the <code>RCC_TypeDef</code> structure.</li>
			</ul>
			<p>Similarly, we use the same approach to access GPIOA registers.</p>
			<p>Here’s a breakdown of <code>GPIOA-&gt;MODER</code> and <code>GPIOA-&gt;ODR</code>:</p>
			<ul>
				<li><code>GPIOA</code>: This is a pointer to the structure of type <code>GPIO_TypeDef</code>, allowing access to GPIOA registers</li>
				<li><code>MODER</code>: A member of the <code>GPIO_TypeDef</code> structure, representing the GPIO port mode register</li>
				<li><code>ODR</code>: Another member of the <code>GPIO_TypeDef</code> structure, representing the GPIO port output data register</li>
			</ul>
			<p>Build the project and<a id="_idIndexMarker493"/> run it on your development board. It should work the same way as the previous project.</p>
			<p>In this section, we learned how to define hardware registers using C structures. This technique is an important step toward understanding CMSIS-compliant code, which will be covered in the next sections.</p>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor205"/>Understanding CMSIS</h1>
			<p>In this section, we will explore CMSIS, an i<a id="_idTextAnchor206"/>mportant framework designed for Arm Cortex-M and some Cortex-A <a id="_idIndexMarker494"/>processors. <strong class="bold">CMSIS</strong> is a vendor-independent hardware abstraction layer that standardizes software interfaces across various Arm Cortex-based microcontroller platforms, promoting software portability and reusability. Let’s start by understanding CMSIS and its key benefits.</p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor207"/>What is CMSIS?</h2>
			<p>CMSIS, pronounced <em class="italic">See-M-Sys</em>, is a standard developed by Arm to provide a consistent and efficient way to<a id="_idIndexMarker495"/> interface with Cortex-based microcontrollers. It includes a comprehensive set of APIs, software components, tools, and workflows designed to simplify and streamline the development process for embedded systems.</p>
			<p>Its key benefits<a id="_idIndexMarker496"/> include the following:</p>
			<ul>
				<li><strong class="bold">Standardization</strong>: CMSIS standardizes the interface for all Cortex-based microcontrollers, making it easier for you to switch between different microcontrollers and tools without having to relearn or reconfigure your code base</li>
				<li><strong class="bold">Portability</strong>: By providing a consistent API, CMSIS allows software developed for one microcontroller to be easily ported to another, enhancing code reuse and reducing development time</li>
				<li><strong class="bold">Efficiency</strong>: CMSIS <a id="_idIndexMarker497"/>includes optimized libraries and functions, such as <strong class="bold">Digital Signal Processing</strong> (<strong class="bold">DSP</strong>) and neural <a id="_idIndexMarker498"/>network kernels, which improve performance and reduce the memory footprint</li>
			</ul>
			<p>CMSIS has several components. Let’s explore some of the commonly used ones.</p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor208"/>Key components of CMSIS</h2>
			<p>CMSIS comprises several <a id="_idIndexMarker499"/>components, each serving a unique purpose:</p>
			<ul>
				<li><strong class="bold">CMSIS-Core (M)</strong>: This component <a id="_idIndexMarker500"/>is designed for all Cortex-M and SecurCore processors. It provides standardized APIs for configuring the Cortex-M processor core and peripherals. It also standardizes the naming of device peripheral registers, which helps reduce the learning curve when switching between different microcontrollers.</li>
				<li><strong class="bold">CMSIS-Driver</strong>: This<a id="_idIndexMarker501"/> provides generic peripheral driver interfaces for middleware, facilitating the connection between microcontroller peripherals and middleware such as communication stacks, filesystems, or graphical user interfaces.</li>
				<li><strong class="bold">CMSIS-DSP</strong>: This<a id="_idIndexMarker502"/> component offers a library of over 60 functions for various data types, optimized for the <strong class="bold">Single Instruction Multiple Data</strong> (<strong class="bold">SIMD</strong>) instruction sets<a id="_idIndexMarker503"/> available on Cortex-M4, M7, M33, and M35P processors.</li>
				<li><strong class="bold">CMSIS-NN</strong>: This <a id="_idIndexMarker504"/>stands for <strong class="bold">neural network</strong>. It includes a collection of efficient neural network kernels <a id="_idIndexMarker505"/>optimized to maximize the performance and minimize the memory footprint on Cortex-M processor cores.</li>
				<li><strong class="bold">CMSIS-RTOS</strong>: There are <a id="_idIndexMarker506"/>two versions, RTOS v1 and RTOS v2. RTOS v1 supports Cortex-M0, M0+, M3, M4, and M7 processors, providing a common API for real-time operating systems. RTOS v2 extends support to Cortex-A5, A7, and A9 processors, including features such as dynamic object creation and multi-core system support.</li>
				<li><strong class="bold">CMSIS-Pack</strong>: Pack <a id="_idIndexMarker507"/>outlines a delivery system for software components, device parameters, and evaluation board support. It streamlines software reuse and facilitates effective product life cycle management.</li>
				<li><strong class="bold">CMSIS-SVD</strong>: <strong class="bold">SVD</strong> stands for <strong class="bold">System Viewer Description</strong>. It defines device description<a id="_idIndexMarker508"/> files maintained by<a id="_idIndexMarker509"/> the silicon vendor, containing comprehensive descriptions of the microcontroller peripherals and registers in XML format. Development tools import these files to automatically construct peripheral debug <a id="_idIndexMarker510"/>windows.</li>
			</ul>
			<p>Another crucial aspect of CMSIS is its coding standard. Let’s take a closer look to familiarize ourselves with these guidelines.</p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor209"/>The CMSIS coding rules</h2>
			<p>Here are the essential coding<a id="_idIndexMarker511"/> rules and conventions used in CMSIS:</p>
			<ul>
				<li><strong class="bold">Compliance with ANSI C (C99) and C++ (C++03)</strong>: This ensures compatibility with widely accepted programming standards.</li>
				<li><code>&lt;stdint.h&gt;</code>, ensuring consistency in data representation.</li>
				<li><strong class="bold">Complete data types</strong>: Variables and parameters are defined with complete data types, avoiding ambiguity.</li>
				<li><strong class="bold">MISRA 2012 conformance</strong>: While CMSIS conforms to the MISRA 2012 guidelines, it does not claim full MISRA compliance. Any rule violations are documented for transparency.</li>
			</ul>
			<p>Additionally, CMSIS uses specific <a id="_idIndexMarker512"/>qualifiers:</p>
			<ul>
				<li><code>__I</code> for read-only variables (equivalent to <strong class="bold">volatile const</strong> in ANSI C)</li>
				<li><code>__O</code> for write-only variables</li>
				<li><code>__IO</code> for read and write variables (equivalent to <strong class="bold">volatile</strong> in ANSI C)</li>
			</ul>
			<p>These<a id="_idIndexMarker513"/> qualifiers in CMSIS provide a convenient way to specify the intended access mode for variables, particularly for memory-mapped peripheral registers.</p>
			<p>With this background knowledge, let’s go ahead and learn how to use CMSIS in our embedded projects.</p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor210"/>The CMSIS-Core files</h2>
			<p>The CMSIS-Core files are <a id="_idIndexMarker514"/>categorized into two primary groups, each serving a specific purpose in the development process. These groups are the CMSIS-Core standard files and the CMSIS-Core device files. <em class="italic">Figure 6</em><em class="italic">.1</em> provides a comprehensive overview of the CMSIS-Core file structure, illustrating the different types of files and their roles in a project.</p>
			<div><div><img src="img/B21914_06_1.jpg" alt="Figure 6.1: The CMSIS-Core files" width="1650" height="735"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1: The CMSIS-Core files</p>
			<p>Let’s analyze the diagram.</p>
			<p>The files are divided into three categories: <strong class="bold">CMSIS-Core Standard Files</strong>, <strong class="bold">CMSIS-Core Device Files</strong>, and <strong class="bold">User </strong><strong class="bold">Program Files</strong>.</p>
			<p>The <strong class="bold">CMSIS-Core Standard Files</strong> category<a id="_idIndexMarker515"/> of files is provided by Arm and typically does not require modifications. They<a id="_idIndexMarker516"/> include the following:</p>
			<ul>
				<li><code>core_&lt;cpu&gt;.h</code>: This provides access to the CPU and core-specific functionalities</li>
				<li><code>cmsis_compiler.h</code>: This contains core peripheral functions, CPU instruction access, and SIMD instruction access</li>
				<li><code>&lt;arch&gt;_&lt;feature&gt;.h</code>: This defines architecture-specific attributes and features</li>
				<li><code>cmsis_&lt;compiler&gt;_m.h</code>: This is<a id="_idIndexMarker517"/> a toolchain-specific file that aids in compiler compatibility and optimization</li>
			</ul>
			<p>The next category<a id="_idIndexMarker518"/> is <strong class="bold">CMSIS-Core Device Files</strong>. These files are provided by silicon vendors (such as STMicroelectronics) and may require application-specific modifications. They include the following:</p>
			<ul>
				<li><code>system_&lt;Device&gt;.c</code>: This file handles system and clock configuration</li>
				<li><code>partition_&lt;Device&gt;.h</code>: This manages secure attributes and interrupt assignments</li>
				<li><code>startup_&lt;Device&gt;.c</code>: This contains the device startup interrupt vectors</li>
				<li><code>&lt;Device&gt;.h</code>: This provides access to the CMSIS device peripheral functionalities</li>
				<li><code>system_&lt;Device&gt;.h</code>: This assists in system and clock configuration</li>
			</ul>
			<p>The third category <a id="_idIndexMarker519"/>is <strong class="bold">User Program Files</strong>. These are created by us, the developers, and include the main application code along with other user-defined functionalities essential for the project’s operation.</p>
			<p>Understanding CMSIS is<a id="_idIndexMarker520"/> fundamental for efficient and standardized development across various Arm Cortex-based microcontroller platforms. In this section, we have explored its key components, the CMSIS coding standards, and the CMSIS-Core files crucial to the development of embedded projects. In the next section, we will learn how to include the required CMSIS files in our project, enabling us to leverage the full potential of this robust framework for developing embedded systems.</p>
			<h1 id="_idParaDest-121"><a id="_idTextAnchor211"/>Setting up the required CMSIS files</h1>
			<p>In this section, we will <a id="_idIndexMarker521"/>work through the process of integrating CMSIS files into our project. These files also contain the definitions of all the registers and their respective bits, making it easier to manage and configure peripherals without manually defining each register.</p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor212"/>Getting the right header files</h2>
			<p>Let’s start by<a id="_idIndexMarker522"/> downloading the package for our microcontroller from the STMicroelectronics website:</p>
			<ol>
				<li>Open your browser and go to <a href="https://www.st.com/content/st_com/en.html">https://www.st.com/content/st_com/en.html</a>.</li>
				<li>Search for <code>STM32CubeF4</code> to locate the package for the STM32F4 microcontroller series.</li>
				<li>Next, download the STM32CubeF4 package:<ol><li class="upper-roman">Locate the STM32CubeF4 package and download the latest version. Make sure not to download the patch version.</li><li class="upper-roman">Once the download is complete, unzip the package. You will find several subfolders inside, including the <code>Drivers</code> folder.</li></ol></li>
			</ol>
			<p>Our next steps involve organizing the files:</p>
			<ol>
				<li>Inside your project workspace, create a new folder named <code>chip_headers</code>.</li>
				<li>Within the <code>chip_headers</code> folder, create another folder named <code>CMSIS</code>.</li>
				<li>Navigate to <code>Drivers/CMSIS</code> in the extracted package.</li>
				<li>Copy the entire <code>Include</code> folder from <code>Drivers/CMSIS</code> into <code>chip_headers/CMSIS</code>.</li>
				<li>Next, copy the <code>Device</code> folder from <code>Drivers/CMSIS</code> into <code>chip_headers/CMSIS</code>.</li>
			</ol>
			<p>Finally, we clean up the <code>Device</code> folder:</p>
			<ol>
				<li>Navigate to <code>chip_headers/CMSIS/Device/ST/STM32F4xx</code>.</li>
				<li>Delete all files and folders, <em class="italic">except the Include folder</em>. This ensures you keep only the necessary<a id="_idIndexMarker523"/> header files for your specific microcontroller.</li>
			</ol>
			<p>Moving forward, we will consistently include the <code>chip_headers</code> folder in our project directories. This practice ensures that anyone running our projects on a different computer won’t encounter errors due to missing header files.</p>
			<p>In the next section, we’ll create a new project in STM32CubeIDE. After setting up the project, we’ll copy the <code>chip_headers</code> folder and paste it into the project directory. Subsequently, we’ll add the subfolders within <code>chip_headers</code> to our project’s <code>include</code> paths, ensuring seamless integration of the necessary CMSIS files.</p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor213"/>Working with CMSIS files</h2>
			<p>In this section, we will integrate the <a id="_idIndexMarker524"/>CMSIS files into our project by adding the relevant folders to our project’s <code>include</code> paths. We will then test our setup by updating our <code>main.c</code> file to use these CMSIS files instead of our manually defined peripheral structures.</p>
			<p>Let’s begin by creating a new project following the steps outlined in <a href="B21914_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>. I will name my project <code>header_files</code>. Once the project is created, I’ll copy and paste the <code>chip_headers</code> folder into the project folder.</p>
			<p>Our next task involves adding the paths of the subfolders within the <code>chip_headers</code> folder to our project’s <code>include</code> paths:</p>
			<ol>
				<li>Open STM32CubeIDE, right-click on your project, and select <strong class="bold">Properties</strong>.</li>
				<li>Once the <strong class="bold">Properties</strong> window opens, expand the <strong class="bold">C/C++ </strong><strong class="bold">General</strong> options.</li>
				<li>Select <strong class="bold">Paths </strong><strong class="bold">and Symbols</strong>.</li>
				<li>Under the <strong class="bold">Includes</strong> tab, click <strong class="bold">Add</strong> to add a new directory.</li>
				<li>Enter <code>${ProjDirPath}\chip_headers\CMSIS\Include</code> to add the <code>Include</code> folder located in our <code>CMSIS</code> folder, and then click <strong class="bold">OK</strong> to save.</li>
				<li>Click <strong class="bold">Add</strong> again to add another directory.</li>
				<li>Enter <code>${ProjDirPath}\chip_headers\CMSIS\Device\ST\STM32F4xx\Include</code> to add the <code>Include</code> folder located in the <code>STM32F<a id="_idTextAnchor214"/>4xx</code> subdirectory and click <strong class="bold">OK</strong> to save.</li>
			</ol>
			<p><em class="italic">Figure 6</em><em class="italic">.2</em> illustrates the Project Properties window after adding these directories to the project’s <code>include</code> paths.</p>
			<div><div><img src="img/B21914_06_2.jpg" alt="Figure 6.2: The Includes tab in the project properties window" width="1000" height="793"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2: The Includes tab in the project properties window</p>
			<p>Let’s break down the two<a id="_idIndexMarker525"/> lines we have just added:</p>
			<ul>
				<li><code>${</code><code>ProjDirPath}\chip_headers\CMSIS\Include</code>:<ul><li><code>${ProjDirPath}</code>: This is a macro in STM32CubeIDE that represents the root directory of your current project. It’s a placeholder that dynamically points to the directory where your project is located.</li><li><code>\chip_headers\CMSIS\Include</code>: This specifies the path relative to the project’s root directory. It points to the <code>Include</code> folder within the <code>CMSIS</code> directory inside the <code>chip_headers</code> folder. This folder contains general CMSIS include files, which provide core functionalities and definitions for the Cortex-M processor.</li></ul></li>
				<li><code>${</code><code>ProjDirPath}\chip_headers\CMSIS\Device\ST\STM32F4xx\Include</code>:<ul><li><code>${ProjDirPath}</code>: As mentioned earlier, this macro represents the root directory of your current project.</li><li><code>\chip_headers\CMSIS\Device\ST\STM32F4xx\Include</code>: This specifies another path relative to the project’s root directory. It points to the <code>Include</code> folder within the <code>STM32F4xx</code> subdirectory inside the <code>Device</code> directory, which is located in the <code>CMSIS</code> directory in the <code>chip_headers</code> folder. This folder contains device-specific include files for the STM32F4xx series microcontrollers, providing definitions and configurations specific to this family of microcontrollers.</li></ul></li>
			</ul>
			<p>Before closing the project properties dialog box, we need to specify the exact version of the STM32F4 microcontroller we are using. This ensures that the appropriate header file for our specific microcontroller is<a id="_idIndexMarker526"/> enabled in our project. As we can see, the <code>STM32F4xx\Include</code> subfolder contains header files for various microcontrollers within the STM32F4 family. The NUCLEO-F411 development board has the STM32F411 microcontroller.</p>
			<p>To configure our project for the STM32F411 microcontroller:</p>
			<ol>
				<li>Click on the <strong class="bold"># </strong><strong class="bold">Symbols</strong> tab.</li>
				<li>Click <strong class="bold">Add…</strong> to add a new symbol.</li>
				<li>In the <code>STM32F411xE</code> in the <strong class="bold">Name</strong> field and then click <strong class="bold">OK</strong>.</li>
				<li>Click <strong class="bold">Apply and Close</strong> to save all changes and close the Project Properties window.</li>
			</ol>
			<p><em class="italic">Figure 6</em><em class="italic">.3</em> illustrates the <code>STM32F411xE</code> symbol.</p>
			<div><div><img src="img/B21914_06_3.jpg" alt="Figure 6.3: The Symbols tab in the project properties window" width="1000" height="789"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3: The Symbols tab in the project properties window</p>
			<p>To test our <a id="_idIndexMarker527"/>setup, let’s follow these steps:</p>
			<ol>
				<li>Copy the entire content of the <code>main.c</code> file from our previous project that used the structure-based access approach.</li>
				<li>Open the <code>main.c</code> file in the current project.</li>
				<li>Delete all the existing content in the <code>main.c</code> file.</li>
				<li>Paste the copied content into the <code>main.c</code> file.</li>
				<li>In the <code>main.c</code> file, delete all the code related to manually defined addresses and structures, as we will now use the register definitions provided in our header files.</li>
				<li>Include the <code>stm32f4xx.h</code> header file in your project to access these definitions.</li>
				<li>Build the project in the IDE and run it on the development board.</li>
			</ol>
			<p>The following snippet shows the updated <code>main.c</code> file:</p>
			<pre class="source-code">
//1: In<a id="_idTextAnchor215"/>clude the stm32f4 header file
<strong class="bold">#include</strong> "stm32f4xx.h"
//2: Bit mask for enabling GPIOA (bit 0)
<strong class="bold">#define</strong> GPIOAEN       (1U&lt;&lt;0)
//3: Bit mask for GPIOA pin 5
<strong class="bold">#define</strong> PIN5          (1U&lt;&lt;5)
//4: Alias for PIN5 representing LED pin
<strong class="bold">#define</strong> LED_PIN       PIN5
<strong class="bold">int main(void)</strong>
{
     //  5: Enable clock access to GPIOA
     RCC-&gt;AHB1ENR |=  GPIOAEN;
     //  6: Set PA5 to output mode
     GPIOA-&gt;MODER |= (1U&lt;&lt;10);
     GPIOA-&gt;MODER &amp;= ~(1U&lt;&lt;11);
    <strong class="bold">while</strong>(1)
    {
        //  7: Set PA5(LED_PIN) high
        GPIOA-&gt;ODR^= LED_PIN;
        // 8: Simple delay
        <strong class="bold">for</strong>(<strong class="bold">int</strong> i=0;i&lt;100000;i++){}
    }
}</pre>			<p>You’ll observe that this<a id="_idIndexMarker528"/> project builds without any errors and works in the same way as our previous one. This implementation accesses the microcontroller registers defined in <code>chip_headers/CMSIS/Device/ST/STM32F4xx/Include/stm32f411xe.h</code>.</p>
			<p>Upon inspecting <a id="_idIndexMarker529"/>this file, you will find that it contains a <code>typedef</code> structure for each peripheral of our microcontroller, similar to the one we manually created a few sections ago. This means that moving forward, we don’t need to manually extract the base addresses and register offsets from the documentation. Instead, we can simply include the <code>stm32f4xx.h</code> header file in our project. This header file will in turn include the <code>stm32f411xe.h</code> file because we specified in the <strong class="bold">Symbols</strong> tab of the project properties window that we are using the <em class="italic">STM32F411xE</em> microcontroller.</p>
			<p>Setting up the required header files significantly simplifies configuring and using peripherals on our STM32 microcontroller. This approach allows us to leverage pre-defined register addresses and bit definitions, making our code more readable and maintainable while also reducing development time.</p>
			<h1 id="_idParaDest-124"><a id="_idTextAnchor216"/>Summary</h1>
			<p>In this chapter, we explored CMSIS, a critical framework for Cortex-M and some Cortex-A processors. This chapter gave us the foundational knowledge to enhance code portability and efficiency in our Arm Cortex-M projects.</p>
			<p>We began by learning how to define hardware registers using C structures, a fundamental technique for improving code readability and maintainability. This knowledge allowed us to understand how the CMSIS-compliant header files provided by microcontroller manufacturers give us access to the register definitions.</p>
			<p>Next, we explored CMSIS itself, discussing its components and how it facilitates efficient software development. We examined the key benefits of CMSIS, such as standardization, portability, and efficiency, and introduced its main components, including CMSIS-Core, CMSIS-Driver, CMSIS-DSP, CMSIS-NN, CMSIS-RTOS, CMSIS-Pack, and CMSIS-SVD.</p>
			<p>We then moved on to setting up the necessary CMSIS files from our silicon manufacturer. This process involved downloading the relevant packages, organizing the files, and integrating them into our project.</p>
			<p>Finally, we tested our setup by updating our previous project to use CMSIS files instead of our manually defined peripheral structures. This practical application showcased how CMSIS simplifies accessing microcontroller registers, making the code more readable, maintainable, and efficient.</p>
			<p>In the next chapter, we will learn about the GPIO peripheral. This chapter will provide a comprehensive understanding of how to configure and use GPIO for input/output applications in embedded systems.</p>
		</div>
	</div>
</div>
</body></html>