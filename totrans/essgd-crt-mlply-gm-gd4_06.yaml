- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building an Online Checkers Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will delve into the captivating realm of creating an online
    multiplayer checkers game. We will apply the knowledge and skills we have acquired
    throughout this book to develop an engaging and interactive gaming experience.
  prefs: []
  type: TYPE_NORMAL
- en: Checkers, a classic board game enjoyed by players of all ages, provides the
    perfect canvas to explore the complexity of online multiplayer game development.
    We will learn how to leverage the power of the Godot Engine and its versatile
    features to create a seamless multiplayer experience that will have players strategizing,
    competing, and enjoying the game together.
  prefs: []
  type: TYPE_NORMAL
- en: To facilitate the synchronization of the game state across multiple players,
    we will introduce a powerful tool called the `MultiplayerSynchronizer` node. This
    node will play a crucial role in updating the positions of the checkers pieces
    across the boards of all connected players. By using this node, we can ensure
    that each player’s game view remains consistent and up to date, enhancing the
    overall multiplayer experience.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, we will cover essential concepts, such as client-server
    architecture, game synchronization, and player interactions, which are fundamental
    to the development of any multiplayer game. By understanding these concepts and
    applying them to our checkers game, we will create a robust and engaging multiplayer
    experience that will captivate players from around the world. The following diagram
    showcases the final project, where players are playing against each other online!
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Player 1’s game instance view and Player 2’s game instance view
    during the Black Team’s turn](img/Figure_06.01_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – Player 1’s game instance view and Player 2’s game instance view
    during the Black Team’s turn
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the technical aspects, we will also focus on creating an intuitive
    user experience that allows players to seamlessly navigate the game and interact
    with the checkers pieces. A well-designed interface is crucial in enhancing the
    player experience and ensuring a smooth and enjoyable gameplay session. Using
    some visual cues, we will ensure that players know the current game state intuitively.
  prefs: []
  type: TYPE_NORMAL
- en: As we progress, we will explore strategies to manage player interactions, such
    as handling player turns and validating moves. These features are vital in maintaining
    fairness and ensuring that the game follows the established rules of checkers.
    By incorporating these elements, we will create an authentic and immersive checkers
    experience that will engage players for hours on end.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have gained valuable insights into the
    intricacies of online multiplayer game development. You will have the knowledge
    and skills necessary to create your own multiplayer games, with the ability to
    synchronize game states, handle player interactions, and deliver an immersive
    multiplayer experience.
  prefs: []
  type: TYPE_NORMAL
- en: So, get ready to embark on this exciting journey as we delve into the world
    of online multiplayer checkers game development. To do so, we will learn about
    the `MultiplayerSynchronizer` node and RPC functions, as they will be our key
    allies in synchronizing the players’ boards. Let’s begin this chapter and unlock
    the immense potential of multiplayer game development together.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Checkers project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serializing players’ turns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deserializing the opponent’s turn
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing win and lose conditions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll be working with the fourth folder of our Godot Engine
    project repository, which you can access through the following link: [https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0](https://github.com/PacktPublishing/The-Essential-Guide-to-Creating-Multiplayer-Games-with-Godot-4.0).'
  prefs: []
  type: TYPE_NORMAL
- en: Another requirement you will need to accomplish before following with our project
    import is to download Godot Engine version 4.0, as this is the version we will
    use throughout the whole book.
  prefs: []
  type: TYPE_NORMAL
- en: After opening your Godot Engine 4.0, open the project using the project manager.
    Then, navigate to the `06.building-online-checkers` folder. Here, you’ll find
    all the files we used to build this chapter’s project. You can test the game opening
    and playing the `res://06.building-online-checkers/CheckersGame.tscn` scene.
  prefs: []
  type: TYPE_NORMAL
- en: This scene showcases most of the features of our game. In this chapter, we are
    also going to implement the lobby system we have worked with throughout the book.
    On top of that, we will turn some local features into online multiplayer features
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: So, stay tuned.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Checkers project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome, respected network engineer of our esteemed fictional indie development
    studio! As we embark on this chapter, let us take a moment to familiarize ourselves
    with the existing Checkers project. Currently, the project is designed for local
    multiplayers, allowing players to engage in thrilling matches offline. This understanding
    will serve as a solid foundation as we explore the path toward transforming our
    Checkers game into a captivating online multiplayer experience.
  prefs: []
  type: TYPE_NORMAL
- en: In this endeavor, our goal is to seamlessly transition the existing local multiplayer
    functionality into an online environment, without encountering significant obstacles
    along the way. By leveraging our existing knowledge and skills, we can effectively
    adapt the game to support online multiplayer, thus expanding its reach and providing
    players with the opportunity to compete with opponents from around the globe.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this section, we will unravel our Checkers project’s inner workings,
    gaining valuable insights into its structure and mechanics. Armed with this understanding,
    we will be better equipped to navigate the porting process with confidence and
    efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: As the designated network engineer, you play a pivotal role in this endeavor.
    Your expertise and problem-solving abilities will be put to the test. With careful
    consideration and strategic implementation, we can minimize any potential challenges
    and ensure a seamless transition to the online multiplayer realm.
  prefs: []
  type: TYPE_NORMAL
- en: Together, we will examine the project’s architecture, dissect its components,
    and identify the necessary modifications required to facilitate online multiplayer
    functionality. By applying our knowledge of networking concepts and programming
    techniques, we will construct a robust foundation upon which the online multiplayer
    features will thrive.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, you are an integral part of this process; as a network engineer, it
    is your job to implement all online multiplayer code, so you play a fundamental
    role here. Your skills will contribute to the realization of our vision – a thrilling
    online multiplayer Checkers game that captivates players across the digital landscape.
    So, let us embark on this journey. In the upcoming sections, we will understand
    the ins and outs of our local Checkers game.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Checkers Piece scene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Piece** implements the functionality of a checkers game piece in our checkers’
    game. It allows players to interact with the Piece by selecting or deselecting
    it, keeping track of its selected state. In the following screenshot, we can see
    the SceneTree structure’s Piece.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – The Piece scene node hierarchy](img/Figure_06.02_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – The Piece scene node hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: To enhance the player experience and decision-making during their turns, we
    utilize visual cues provided by the `EnabledColorRect` and `SelectedColorRect`
    nodes. `EnabledColorRect` becomes visible when the Piece is capable of making
    a valid move within a player’s turn. Conversely, `SelectedColorRect` becomes visible
    when a player chooses this specific Piece over others, allowing for clear differentiation
    between them.
  prefs: []
  type: TYPE_NORMAL
- en: The `Sprite2D` node is responsible for displaying the current texture of the
    Piece. Depending on the player’s team and whether the Piece has been promoted
    to a king piece, the texture can represent either a white piece, a black piece,
    or their respective king versions.
  prefs: []
  type: TYPE_NORMAL
- en: The `SelectionArea2D` node plays a crucial role in detecting player input. By
    using the `input_event` signal, we establish communication between the player’s
    clicks and the Piece. This enables us to toggle the Piece’s selection state, determining
    whether it is currently selected or deselected.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at its code to understand how each of these nodes plays a
    role in this whole logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Overall, this code forms a crucial component of the online multiplayer checkers
    game, providing the necessary functionality to interact with and manage the behavior
    of individual checkers pieces within the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by defining some variables to store information about the Piece’s
    team – whether it’s a king, and its texture. It also has references to some child
    nodes in the scene and a variable to track whether the Piece is currently selected.
    Signals are defined to indicate when the Piece is selected or deselected. Next,
    we will declare the setter function we stated in the `_is_king` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When this variable is set to a new value, the code checks whether the node
    is part of the scene tree. If not, it waits until the node is ready, this prevents
    any errors when changing the variable’s value through the inspector. If the variable
    is set to `true`, it updates the visual appearance of the game piece to represent
    a king, using a specific texture. This allows for dynamic visual changes in the
    game piece when it becomes a king. After that, we have a signal callback from
    the `Area2D` node’s `input_event` signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'It listens for left mouse button clicks and, when detected, calls the `select()`
    method, which, as we will see next, performs the procedures related to selecting
    the Piece. This code enables interaction within the game when the player clicks
    the left mouse button while hovering over the Piece’s `Area2D`. Here, we have
    the code for the `select()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In this function, we define what happens when the Piece is selected. It ensures
    that any previously selected objects are deselected, marks the current object
    as selected, shows a visual indicator, updates a variable to reflect the selection
    status, and emits the `selected` signal to notify other parts of the game about
    the selection event. This code is fundamental for managing and conveying the selected
    state of Pieces in the game. Then, we also have the opposite function, `deselect()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we define what happens when an object is deselected. The code removes
    the object from the `"selected"` group, hides the visual indicator of selection,
    updates the `is_selected` variable to reflect the deselection status, and emits
    the `deselected` signal to notify other parts of the game about the deselection
    event. Now, it’s time to enable the change in selection states; without that,
    the Piece shouldn’t be selectable. This helps to prevent players from selecting
    Pieces from the opponent’s team:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In this part, we make the `Area2D` responsive to input events, and we also
    make a visual indicator visible on the screen. This is important to allow players
    to interact with and manipulate Pieces in the game when they are in an enabled
    state. Now, let’s see its counterpart, the `disable()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It’s essentially the opposite of the previous method. We make the `Area2D` non-responsive
    to input events, effectively making it non-interactive. On top of that, we hide
    the visual indicator on the screen that represents the Piece’s availability, visually
    representing the Piece’s disabled state. This is useful for controlling when and
    how players can interact with Pieces in the game.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming section, we are going to see how the FreeCell scene works. It’s
    a scene we use to highlight the available free cells that a selected Piece can
    move to.
  prefs: []
  type: TYPE_NORMAL
- en: Comprehending the FreeCell scene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our game project, we have a concept called **FreeCell**, which represents
    a valid cell that a Piece can move to. Think of it as a designated area where
    the Piece is allowed to go. Each time the player selects a Piece with valid movement,
    we visually indicate the available cells by showing them in green. These cells
    are actually instances of the FreeCell scene, which we dynamically create and
    display on the game board.
  prefs: []
  type: TYPE_NORMAL
- en: To provide a clear example, imagine a scenario where a king Piece is selected.
    In the following diagram, you can see that all the cells where this king Piece
    can move to are highlighted in green. Each of these highlighted cells is an instance
    of the FreeCell scene, which allows the player to quickly identify the possible
    movement options for the selected Piece.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – Free cells available to the selected king piece](img/Figure_06.03_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – Free cells available to the selected king piece
  prefs: []
  type: TYPE_NORMAL
- en: By using the FreeCell concept, we enhance the player’s experience by visually
    communicating the valid movement possibilities. This empowers them to make informed
    decisions and strategize their next move effectively. It’s a powerful tool that
    adds clarity and depth to the gameplay mechanics.
  prefs: []
  type: TYPE_NORMAL
- en: The FreeCell scene is an essential component of our game, composed of three
    distinct nodes. The main node is an `Area2D`, which serves as the foundation for
    the FreeCell. It encompasses two child nodes – a `CollisionShape2D` and a `ColorRect`.
  prefs: []
  type: TYPE_NORMAL
- en: The `CollisionShape2D` node is responsible for defining the shape and boundaries
    of the FreeCell. It ensures that the cell can properly interact with other game
    objects, such as Pieces or other elements within the game world. As we are about
    to see, `CollisionShape2D` also defines the boundaries in which the `Area2D` detects
    mouse inputs, which is fundamental for the FreeCell’s behavior.
  prefs: []
  type: TYPE_NORMAL
- en: The `ColorRect` node, conversely, controls the visual representation of the
    FreeCell. It determines the color and appearance of the cell, providing a visual
    indicator to distinguish it from other elements on the game board.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – The FreeCell scene node hierarchy'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_06.04_B18527.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.4 – The FreeCell scene node hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand the functionality and behavior of the FreeCell, let’s
    explore its accompanying script. By examining the script code, we will gain insights
    into how the FreeCell operates and interacts with other game elements, ultimately
    contributing to the overall game logic and mechanics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This code allows the cell, represented by `Area2D`, to respond to right mouse
    button events within its area. When a cell is selected, it emits a signal with
    the position of the cell. This signal can be used to inform other objects or scripts
    about the selection and provide them with the cell’s position for further processing.
    We’ll use this in the `CheckerBoard` script to map the FreeCell’s position into
    the board’s cell.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming section, we will introduce the game board, an essential component
    of our game. We will then shift our focus to the core of this chapter, which involves
    implementing methods that we will turn into RPCs. These RPCs will enable the game
    to work seamlessly in an online environment, allowing players to interact with
    each other and synchronize their actions over the network.
  prefs: []
  type: TYPE_NORMAL
- en: By leveraging the power of RPCs, we will create a dynamic and engaging multiplayer
    experience for our players. Let’s dive into the details and explore how these
    methods will bring our game to life in an online setting.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the CheckerBoard scene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, let’s delve into the primary role of the game board, as this
    will serve as a foundation for our upcoming sections. By understanding the key
    responsibilities of the board, we can naturally identify the specific areas we
    will be focusing on in the subsequent sections. This understanding will pave the
    way for a clear and structured approach as we continue exploring our checker’s
    development process.
  prefs: []
  type: TYPE_NORMAL
- en: The primary role of our game board is to manage the relationship between the
    black and white pieces in the game. To achieve this, the board utilizes the built-in
    `TileMap` functions to map the pieces onto cartesian coordinates. Additionally,
    it employs a hash map to associate the content of each cell on the board.
  prefs: []
  type: TYPE_NORMAL
- en: This means that we can access the content of a specific cell by providing its
    corresponding `Vector2i` coordinate. For example, by using the `meta_board[Vector2i(0,3)]`
    expression, we can retrieve the contents of the cell located in the first column
    and fourth row of the board. The result of this access will either be `null`,
    indicating that the cell is free, or it will return the Piece that is currently
    mapped to that particular cell. This mechanism allows for efficient retrieval
    and manipulation of the contents on the board, enabling seamless gameplay and
    interaction with the pieces.
  prefs: []
  type: TYPE_NORMAL
- en: The CheckerBoard plays a vital role in our game by overseeing various aspects
    of gameplay. Firstly, it manages the available movements for each cell on the
    board, taking into account the current team in play and whether a Piece has been
    promoted to a king. This ensures that players can only make valid moves based
    on the rules of the game.
  prefs: []
  type: TYPE_NORMAL
- en: The CheckerBoard is also responsible for controlling the turns in the game.
    It enables and disables the Pieces according to the active team, allowing only
    the team in play to make moves during their turn. This mechanism ensures fair
    gameplay and maintains the flow of the game.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, the CheckerBoard keeps track of the number of Pieces each team
    possesses at the end of each turn. This count is crucial, as it determines the
    win-lose condition of the game. If a team has no remaining Pieces on the board,
    the CheckerBoard triggers the appropriate `win` condition, declaring the opposing
    team as the winner.
  prefs: []
  type: TYPE_NORMAL
- en: 'By managing the cell movements, regulating turns, and monitoring the Piece
    count, the CheckerBoard maintains the game’s rules and progression. Its role is
    fundamental to providing clear conditions for victory or defeat. Let’s take a
    look at the CheckerBoard scene structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – The CheckerBoard scene node hierarchy](img/Figure_06.05_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 – The CheckerBoard scene node hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that the CheckerBoard is implemented as `TileMap`, a
    useful class in our game. We use specific methods provided by the `TileMap` class,
    such as `map_to_local()`, `local_to_map()`, and `get_used_cells()`, to establish
    our cell-mapping functionality. The `map_to_local()` method will help us map the
    game to cell positions in `TileMap`, while `local_to_map()` will help us convert
    the Pieces’ positions to cells in the map. This will help us abstract the game
    in terms of rows and columns instead of floating-point numbers. As for the `get_used_cells()`
    method, it will help us access only the cells that have a tile set to them and
    avoid dealing with blank cells in `TileMap`. This will be useful when we create
    a matrix of the cells’ contents.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `CheckerBoard` class, we’ll focus on understanding the significance
    of the `meta_board` `create_meta_board()` and `map_pieces()` methods within the
    `CheckerBoard` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `create_meta_board()` method is responsible for setting up the `meta_board`
    Dictionary. This Dictionary acts as a data structure that maps cell coordinates
    to their corresponding contents. By leveraging the `TileMap` methods mentioned
    earlier, the `create_meta_board()` method populates `meta_board` with the appropriate
    cell coordinates and initializes them with null values, indicating empty cells.
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, the `map_pieces()` method performs an essential role in updating
    the `meta_board` to reflect the current state of the game. This method iterates
    over all the Pieces on the provided team, which is passed as a reference to either
    the `BlackTeam` node or the `WhiteTeam` node. Then, it converts the Pieces’ positions
    using the `TileMap.local_to_map()` method and maps each Piece to its respective
    cell coordinate in `meta_board`. This ensures that `meta_board` accurately represents
    the placement of Pieces on the visual board.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, the code establishes a connection between the `Piece.selected` signal
    and the `_on_piece_selected()` callback function. By connecting this signal, we
    bind the current Piece to the callback function as its argument. This enables
    us to conveniently access the `Piece` node whenever the player selects it.
  prefs: []
  type: TYPE_NORMAL
- en: This connection ensures that when the Piece emits the selected signal, the associated
    callback function, `_on_piece_selected()`, will be invoked and provided with the
    `Piece` node as its argument. This mechanism allows us to perform specific actions
    or access properties of the `Piece` node, in response to the player’s selection.
  prefs: []
  type: TYPE_NORMAL
- en: By establishing this connection, we create a seamless interaction between the
    `Piece` node and the corresponding callback function, enhancing the flexibility
    and responsiveness of our game.
  prefs: []
  type: TYPE_NORMAL
- en: There are some auxiliary functions that help us calculate available cells and
    coordinate the Piece’s movement; feel free to check them out and understand how
    we check for available cells, how we capture cells, and other gameplay features.
    In the next section, we will explore a different aspect of our checkers development
    journey.
  prefs: []
  type: TYPE_NORMAL
- en: We will focus on how we can package and transmit all the pertinent information
    about a player’s turn across the network, ensuring that other players are promptly
    updated with the current state of the game board.
  prefs: []
  type: TYPE_NORMAL
- en: By understanding this process, we will be able to establish efficient communication
    between players, facilitating a seamless multiplayer experience. This functionality
    is essential for maintaining synchronization and enabling real-time gameplay in
    our online multiplayer game. Stay tuned as we dive into the intricacies of transmitting
    and updating the game state across the network.
  prefs: []
  type: TYPE_NORMAL
- en: Serializing players’ turns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 2*](B18527_02.xhtml#_idTextAnchor037), *Sending and Receiving Data*,
    we explored an essential technique to recreate the game state across multiple
    players in a network. By serializing the relevant data and transmitting it in
    small portions, we ensure efficient utilization of network bandwidth while maintaining
    synchronization among peers.
  prefs: []
  type: TYPE_NORMAL
- en: Developing an understanding of what information is crucial to replicate the
    game state among players involves mastering the concept of abstraction in game
    development. In our case, this primarily revolves around `meta_board`, which is
    an abstraction of the relevant metadata of our game, such as the positional data
    and king state of the Pieces and the empty cells in the board.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we need to consider the availability of Pieces, depending on the
    players’ turn. Fortunately, most other elements of the game can be managed locally
    without requiring network synchronization.
  prefs: []
  type: TYPE_NORMAL
- en: To simplify the process of synchronizing node properties across networked peers,
    I would like to introduce you to `MultiplayerSynchronizer`. This powerful node
    takes on the responsibility of automatically synchronizing properties across peers,
    relieving us from the tedious task of manual synchronization.
  prefs: []
  type: TYPE_NORMAL
- en: With `MultiplayerSynchronizer` in place, we can focus on developing the game’s
    logic and let the node handle the efficient transmission of data among players.
  prefs: []
  type: TYPE_NORMAL
- en: Working with MultiplayerSynchronizer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`MultiplayerSynchronizer` plays a vital role by allowing us to effortlessly
    sync and share the state of nodes across multiple players, without writing any
    additional code. To begin utilizing this functionality, we will add a `MultiplayerSynchronizer`
    node to the Piece’s scene. This will ensure consistency in the game state of each
    player. Let’s dive into the process of integrating the `MultiplayerSynchronizer`
    and harnessing its capabilities.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up MultiplayerSynchronizer in the Piece scene
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Open the `res://06.building-online-checkers/Piece.tscn` scene and add a `MultiplayerSynchronizer`
    as a child of the `Piece` node. Then, we’ll set up the properties we want to synchronize:'
  prefs: []
  type: TYPE_NORMAL
- en: With the `MultiplayerSychronizer` node selected, in the bottom panel on the
    **Replication** tab, click the **Add property to** **sync** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.6 – The Replication menu from the MultiplayerSynchronizer node](img/Figure_06.06_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.6 – The Replication menu from the MultiplayerSynchronizer node
  prefs: []
  type: TYPE_NORMAL
- en: From the pop-up menu, select the **Piece** node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 6.7 – Selecting the Piece node from the Pick a \uFEFFnode to \uFEFF\
    synchronize pop-up menu](img/Figure_06.07_B18527.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 6.7 – Selecting the Piece node from the Pick a node to synchronize pop-up
    menu
  prefs: []
  type: TYPE_NORMAL
- en: After selecting the **Piece** node, another pop-up menu will appear, asking
    you to select the property you want to sync. From there, select the **position**
    property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.8 – Choosing the position property from the Select Property pop-up
    menu](img/Figure_06.08_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.8 – Choosing the position property from the Select Property pop-up
    menu
  prefs: []
  type: TYPE_NORMAL
- en: And that’s it. With that, as soon as the players are connected to the same network,
    they will automatically sync their Pieces’ positions on the board. However, we
    still have an issue as this only updates the visual representation of the Piece,
    and we still need to update its data in `meta_board`. Now comes the fun part.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will start to understand the methods in the CheckerBoard
    that we need to turn into RPCs, keeping players on the same page.
  prefs: []
  type: TYPE_NORMAL
- en: Updating and syncing the CheckerBoard
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A core issue when developing any application is that we have limited resources.
    In the case of transmitting data over a network, we are talking about bandwidth.
    Games are a special case because everything should happen in real time, so we
    can’t risk heavy data transmission that hurts network performance.
  prefs: []
  type: TYPE_NORMAL
- en: To turn this in our favor, we need to pass data in the most abstract and lightweight
    way we can. In our case, we have our `meta_board` as a means to represent the
    game’s current state. By using `Vector2i` coordinates, we can access and change
    the game states. And that’s how we are going to keep players updated. In the next
    section, we are going to work with the `CheckerBoard.update_cells()` method, which
    is the core of our update system.
  prefs: []
  type: TYPE_NORMAL
- en: Using coordinates to update the board
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since `meta_board` is a Dictionary, we can access and set the values of its
    keys using Godot Engine’s built-in types. For instance, if we want to change the
    content of the cell in the third row second column to `null`, we can write `meta_board[Vectori(1,
    2)] =` `null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When Pieces perform a move, we just need to know the content of the previous
    and new cell of this movement, so that we can update it. And that’s exactly what
    the `update_cells()` method does. Let’s take a look at it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Since this is the very core of our update system, we need to turn it into an
    RPC function and call it as such.
  prefs: []
  type: TYPE_NORMAL
- en: 'For that, let’s make the appropriate changes in our script:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `@rpc` annotation to this method, using the `any_peer` and `call_local`
    options. We use these because we want every player to update others about changes
    in their board, and we also want their own board to update itself, hence the `call_local`
    option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `move_selected_piece()` method, change the `update_cells(current_cell,
    target_cell)` line to an RPC call instead. This will make the call of this method
    both local and remote on other peers as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With that, every time the CheckerBoard moves a Piece, it updates its `meta_board`
    data on all peers on the network.
  prefs: []
  type: TYPE_NORMAL
- en: Note that there’s another method that we can turn into an RPC as well. Every
    player should update `Piece.is_king` of a Piece that reached their opponent’s
    king row. For that, we have the `crown()`method that `move_selected_piece()` calls
    at the bottom of its logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s do the same thing we did with `update_cells()` with the `crown()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we add the `@rpc` annotation to it with the `any_peer` and `call_local`
    options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we change the `crown(target_cell)` call to its `rpc()` version:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With that, when a Piece reaches the king row, all players’ CheckerBoards update
    their king state, be it an opponent Piece or an ally Piece.
  prefs: []
  type: TYPE_NORMAL
- en: Our work isn’t done yet. In the next section, we will see how we update the
    `meta_board` content when players perform a capturing movement, meaning we need
    to remove a Piece from the board.
  prefs: []
  type: TYPE_NORMAL
- en: Removing a Piece from the board
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a player makes a move that ends up capturing an opponent Piece, we should
    update the game board accordingly. This means that on top of updating the cells
    involved in the movement, we should also update the cell where the captured Piece
    was, setting its content to null – in other words, turning it into a free cell.
    That’s what the `remove_piece()` method does.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at its code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Since this behavior impacts both players, we need to turn this method into an
    RPC as well so that every time a player captures a Piece, they update their opponent
    with this sad fact.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s make the appropriate changes so that this feature is compliant with our
    online multiplayer demands:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `@rpc` annotation to the `remove_piece()` method with the `any_peer`
    and `call_local` options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `capture_piece()` method, update the `remove_piece(cell)` line to its
    `rpc()` version:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, every time a player captures a cell, it calls the `remove_piece()` method
    both locally and remotely on all connected peers!
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have our players turn properly serialized and ready to be passed
    through the network to other peers, with good performance and little data usage,
    leaving a good bandwidth for us if we so desire. For instance, we can add a chat
    feature using a new RPC channel if we want to in the future.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about the importance of abstracting relevant data
    for our network communication and how to turn local functionalities into remote
    functionalities, while maintaining all their logic and overall structure. Here,
    we saw the relevance of the `call_local` RPC option as well as the simplicity
    of turning a method call into an RPC call with the `rpc()` method.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will see how we manage the turn logic. This is an important
    feature to handle because there we will need to actively add a layer of network
    verification to properly handle the turns. The logic of a local turn shift and
    a remote turn shift is very distinct.
  prefs: []
  type: TYPE_NORMAL
- en: Handling remote turn shifts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important aspects of playing a game online is to maintain players’
    autonomy and authority over their resources – in this case, their team’s Pieces.
    Godot Engine offers an interesting system where a SceneTree can structure its
    nodes’ hierarchies with distinct Multiplayer Authorities.
  prefs: []
  type: TYPE_NORMAL
- en: To set up a node and its children’s Multiplayer Authority, recursively, we can
    use `set_multiplayer_authority()` and pass the respective peer’s ID as an argument.
    In our case, we are going to change the `BlackTeam` and `WhiteTeam` nodes’ Multiplayer
    Authority to match their respective players’ peer IDs.
  prefs: []
  type: TYPE_NORMAL
- en: This will be done by the server, so to keep the application simple, we are going
    to allow clients and server to share the same script, and we will check which
    one is running the server instance by using `is_multiplayer_authority()` on the
    CheckerBoard. We should only run this logic if the game is running in a network
    and there are peers connected. For that, we can check whether `multiplayer.get_peers().size()`
    is greater than `0`, meaning there are peers connected. Let’s see this in practice,
    shall we?
  prefs: []
  type: TYPE_NORMAL
- en: Setting up players’ teams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing we need to understand to handle players’ turn shifts is that
    each one of the nodes that represent the team – in other words, the `BlackTeam`
    and the `WhiteTeam` nodes – should have its respective players’ peer IDs set as
    their Multiplayer Authorities.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that sense, we need to create a method in the `CheckerBoard` class that
    receives the team and the peer ID as arguments. Remember, we can’t pass objects
    as arguments in this method because it needs to work in the network. So, we need
    to abstract teams as an `enum` that we can pass around through RPCs, and then
    all peers will be able to understand the message and access the correct team node
    at their end. Let’s dive into the action and create a method called `setup_team()`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `@rpc("authority", "call_local")` decorator before the `setup_team()`
    function definition. The `authority` option indicates that this RPC can only be
    called by the Multiplayer Authority; remember that the authority of the CheckerBoard
    will still be the server. The `call_local` argument specifies that the function
    should also be executed locally on the calling peers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the function, check whether the value of `team` is equal to `Teams.BLACK`;
    if this is the case, call the `set_multiplayer_authority()` method on the `black_team`
    object and pass `peer_id` as an argument. This effectively designates the specified
    peer as the authority for `BlackTeam` and all its children – in other words, the
    black Pieces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Otherwise, call the `set_multiplayer_authority()` method on the `white_team`
    object and pass `peer_id` as an argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method sets up the Multiplayer Authority of a team node based on the received
    team, `black_team` or `white_team`, using the provided `peer_id`. This ensures
    that the Multiplayer Authority for each team is correctly established, allowing
    the game logic to be synchronized across networked peers. Since the server calls
    this method on all peers, both players and the server will sync their team nodes
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to ensure that this mechanism will be established among all peers, we
    are going to add the following lines of code right inside the `_ready()` callback:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `_ready()` callback, check whether there are peers connected in
    the multiplayer session by checking whether the size of `multiplayer.get_peers()`
    array is greater than `0`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If this is the case, check whether the current node is the Multiplayer Authority
    by using the `is_multiplayer_authority()` function. This ensures that we will
    only call the following logic in the server peer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, make an RPC using the `rpc()` method, with the `"setup_team "` , `Teams.BLACK`,
    and `multiplayer.get_peers()[0]` arguments. This will call the `setup_team()`
    method on all connected peers, telling them to set the BlackTeam’s Multiplayer
    Authority using the first peer ID in the list of connected peers. So, the first
    player connected in the session will be responsible for the black Pieces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Right below the previous line, we are going to do the same thing but use `Teams.WHITE`
    and the connected peers’ list second index, meaning the second player that connected
    to the session:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With that, we have our team setup in place. Note that, since the server has
    both team nodes’ Multiplayer Authorities assigned to each of the players in the
    match, the server itself can’t perform any movement in the board’s Pieces.
  prefs: []
  type: TYPE_NORMAL
- en: Talking about that prevention mechanism, how does it work? How does the CheckerBoard
    prevent players from interacting with Pieces, especially with their opponent Pieces?
    In the next section, we are going to see how we can detect which player is assigned
    to which team and only re-enable their appropriate team Pieces.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling and disabling team pieces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our game, when players end a turn, we disable all their pieces using the
    `disable_pieces()` method. In turn shifts, we make sure to disable both teams’
    Pieces, and we also check whether there’s a winner from the past turn; if not,
    we start the procedure to re-enable players’ Pieces based on the turn’s team.
  prefs: []
  type: TYPE_NORMAL
- en: All of that happens in the `toggle_turn()` method, but as it is, it won’t work
    in an online multiplayer scenario because, currently, the method performs only
    local logic. So, let’s turn it into a method that will work for our improved online
    multiplayer checkers game.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, before that, let’s see how the code is right now so we can already
    pick where we will need to make adjustments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This function is responsible for managing the turn-based logic of a game. It
    first clears the available cells for movements and then disables the pieces of
    both teams. Then, it checks whether there is a winner and, if so, emits a signal
    to the `CheckersGame` script’s `_on_checker_board_player_won()` method, indicating
    the winning team. If there is no winner, it switches the turn to the other team
    and enables the pieces of the corresponding team.
  prefs: []
  type: TYPE_NORMAL
- en: 'Can you point out where we need to make the necessary changes in order to make
    it work in our online version of the game? Remember that the game should work
    both locally and remotely, so we need to maintain the overall outcome of this
    method. Let’s begin the process:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Decorate the `toggle_turn()` method with the `@rpc` annotation, using the `any_peer`
    and the `call_local` options. This indicates that any peer can call this method
    remotely in the multiplayer session, but they should also call it locally. This
    ensures that even if we are playing the game without joining a multiplayer session,
    we can call this method locally, using the `rpc()` method, and everything will
    still work:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside that, check whether the `current_turn` is `Teams.BLACK`; we are going
    to move `enable_pieces(white_team)` inside yet another check. This time, we are
    going to check whether we don’t have any peers connected, meaning we are playing
    the game alone or locally:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we are not playing the game locally, we need to check whether the current
    player is the WhiteTeam’s Multiplayer Authority, using the `multiplayer.get_unique_id()`
    method; if so, we can enable the **WhiteTeam** Pieces. And that’s how we ensure
    that only the correct player will have their Pieces re-enabled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We are going to do the same thing, but inside the `else` statement, which handles
    whether the `current_turn` was from `Teams.WHITE`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With that, every time we call the `toggle_turn()` method, we are going to check
    whether the peer has authority over the current Pieces in play, and we only allow
    them to select the Pieces from their team. Now, we still need to make a small
    change in order for this to be compliant with our network requirements. In the
    `_free_cell_selected()` callback, let’s change the line that makes a direct call
    to the `toggle_turn()` method, making it a remote call using the `rpc()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `can_capture()` method is responsible for checking whether there’s
    any enemy Piece around `selected_piece`, which can lead to a capture move. If
    this is the case, we call the `capture_pieces()` method, which will perform the
    capture movement on all possible enemy Pieces in the selected direction. Otherwise,
    if there’s no capture movement available, we perform a simple movement calling
    the `move_selected_piece()` method, passing around `free_cell` as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: Now, every time a player selectes an available free cell to perform a move with
    a Piece, they will make a remote procedure call to `toggle_turn()`, telling all
    the connected peers to properly disable and re-enable their respective Pieces.
    Awesome, isn’t it?
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have all the core mechanisms of our game in place, and we
    can play an online match with other players connected to our network. There’s
    only one thing missing. We still need to communicate over the network when a player
    wins a match and allow players to play again.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to create a simple mechanism to allow players
    to rematch after one of them won the match for good.
  prefs: []
  type: TYPE_NORMAL
- en: Managing win and lose conditions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Excellent! We have successfully completed the development of the CheckerBoard
    scene, and our game’s core functionalities are now in place. The next step is
    to transition the logic of the CheckersGame scene from local to remote gameplay.
  prefs: []
  type: TYPE_NORMAL
- en: To begin, let’s open the `res://06.building-online-checkers/CheckersGame.tscn`
    file and familiarize ourselves with its structure.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9 – The CheckersGame’s scene node hierarchy](img/Figure_06.09_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.9 – The CheckersGame’s scene node hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: Take note that the CheckerBoard’s `player_won` signal is connected to the `CheckersGame._on_checker_board_player_won()`
    callback. This callback is responsible for handling situations when a player’s
    team has no remaining pieces on the board. Now, let’s proceed by opening the script
    for CheckersGame.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be working on all the methods within the script, ensuring they are
    properly adjusted for online multiplayer functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, let’s add the `@rpc` annotation to the `update_winner()` method
    with the `any_peer` and `call_local` options.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we are going to do the same thing with the `rematch()` method. This one
    is called by RematchButton’s `pressed` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to call these methods remotely, using the `rpc()` method instead
    of directly calling them in `CheckersGame`. Let’s do that in `_on_checker_board_player_won()`,
    turning the `update_winner(winner)` into `rpc("update_winner", winner)` instead.
    This is the method that the CheckerBoard’s `player_won signals` is connected to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, we do the same thing with `_on_rematch_button_pressed()`, turning the
    `rematch()` call into `rpc("rematch")`. This is the method that`pressed` signal
    of **RematchButton** connects to, so when players press the button, this is what
    should happen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the adjustments we’ve made, our game is now fully equipped to run smoothly,
    whether it’s played locally or remotely. When a player successfully captures their
    opponent’s pieces, the game will transition all peers into a rematch state, where
    any peer can initiate a new match and start a fresh game. This ensures that players
    have the option to engage in continuous gameplay sessions without the need to
    exit and restart the game manually.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10 – The CheckersGame rematch screen](img/Figure_06.10_B18527.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.10 – The CheckersGame rematch screen
  prefs: []
  type: TYPE_NORMAL
- en: Our game is finally working! We have a fully functional checkers game that players
    can play online and challenge each other playing multiple matches.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To recap, in this chapter, we introduced the `MultiplayerSynchronizer` node
    to synchronize properties across a network, established the concept of abstraction
    for effective data transmission, utilized the `@rpc` annotations to enable multiplayer
    functionality, and learned how to assign and manage Multiplayer Authority to ensure
    player autonomy and resource protection.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming chapter, we will see how to develop an online Pong game. There,
    we will cover the modifications necessary to turn the local game into an online
    multiplayer one, setting up online multiplayer paddles, syncing remote objects
    in real time, and coordinating the paddle’s position. For that, will use the `MultiplayerSynchronizer`
    node with a bit more depth than we did in this chapter. Also, we will talk about
    the importance of maintaining a shared game world for players in action-based
    games, which is very different from turn-based games.
  prefs: []
  type: TYPE_NORMAL
