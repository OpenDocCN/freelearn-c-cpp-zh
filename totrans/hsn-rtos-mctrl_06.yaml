- en: Selecting the Right MCU
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is a crash course on **microcontroller unit** (**MCU**) selection,
    targeted at engineers who don't have a deep hardware background. It doesn't try
    to be an exhaustive list of absolutely everything you need to know and consider
    when selecting hardware for your new project. It does provide an introduction
    to many of the contributing factors for differentiating between and selecting
    MCU devices. By the end, you'll be aware of enough key considerations to efficiently
    research MCUs and discuss potential candidates with the hardware engineers on
    the team. By increasing hardware/firmware collaboration and selecting the right
    MCU for the project the first time around, you'll avoid both hardware redesigns
    and schedule delays.
  prefs: []
  type: TYPE_NORMAL
- en: We'll start by introducing a wide range of considerations that go into selecting
    a suitable MCU for your project. After that, trade-offs between different development
    hardware will be discussed. A short introduction to the STM32 line is provided
    to show how vendors tend to group their product families. At the end of this chapter,
    we'll compare a few different **development boards** (**dev boards**) with STM32
    MCUs at their heart to show why we're using the dev board we are!
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The importance of MCU selection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MCU considerations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dev board considerations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the STM32 MCU product line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How our dev board was selected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All you need for this chapter is access to the internet in order to browse a
    few websites.
  prefs: []
  type: TYPE_NORMAL
- en: The importance of MCU selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After reading the title of this section, you might be asking yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Hey! I thought this was a book about how to program a microcontroller using
    an RTOS—what''s all this about MCU selection? I''m a software developer!"'
  prefs: []
  type: TYPE_NORMAL
- en: FreeRTOS is almost exclusively targeted at MCUs. It is primarily a scheduling
    kernel with a stable API, which makes it very well-suited to extremely low-level
    design. Unlike a full-blown CPU system with practically unlimited virtual addressing
    space and more clock cycles than you know what to do with, you're going to be
    working with a resource-constrained system. If you're developing firmware on this
    type of system, it means you're going to be much closer to the hardware than if
    you were writing software—which, in turn, means you're very likely going to be
    getting your hands very dirty, compared to your software counterparts. By dirty,
    we're talking *logic analyzer probing pins* dirty. . . *DMM permanently sitting
    on your desk* dirty. . . *learn how to solder so you can tack a lead onto the
    MCU in the quad flat pack* dirty. . . you get the idea! If you're from an exclusively
    software background, you've got some learning to do because we're about to dive
    into the gray area that resides between software and hardware—firmware—and it
    should be a lot of fun!
  prefs: []
  type: TYPE_NORMAL
- en: Firmware and hardware are very closely linked, which is why it is so important
    that firmware engineers are brought into the fray early on in the development
    process. In some organizations, there is still only one person performing the
    electrical design work and writing the firmware. However, there is a growing trend
    that drives disciplines to be more and more specialized in their domains of expertise.
    Even in this case, it is important that multiple team members are brought in to
    make important design decisions up front, so everyone is aware of the trade-offs
    being made.
  prefs: []
  type: TYPE_NORMAL
- en: If you're not the person immediately responsible for selecting an MCU, then
    there's a chance a design might be *thrown over the wall* to you. This is almost
    always a bad thing because it encourages sub-optimal system designs to avoid schedule
    delays caused by hardware being significantly redesigned after some core piece
    of functionality of the system is discovered. Instead of committing to a significant
    board revision to address a major design shortcoming, many teams are pressured
    to *just fix it with some code*.
  prefs: []
  type: TYPE_NORMAL
- en: So, assuming you have some input in selecting an MCU—even if your involvement
    is just a case of "*Hey, Ted, what do you think of this micro for that new project?", *it's
    on you to arm yourself with enough background knowledge to form an intelligent
    opinion (or at least ask intelligent questions). This chapter isn't meant to be
    an exhaustive list with absolutely everything you need to know and consider when
    selecting hardware for your new project, but it does aim to provide an introduction
    to many of the contributing factors for differentiating and selecting between
    MCU devices. The other thing to keep in mind when reading this chapter is that
    it only applies to deciding between MCUs. As we saw from *[Chapter 1](39404421-bf7a-4283-bf78-c396818be4b4.xhtml), Introducing
    Real-Time Systems*, there's more than one way to skin a real-time system cat—MCUs
    aren't *always* the best choice.
  prefs: []
  type: TYPE_NORMAL
- en: In order to limit the scope of this chapter to what is immediately relevant,
    for the examples presented in the remainder of the book, we'll be limiting our
    discussion to features found in ARM Cortex-M-based devices. We're focusing on
    ARM Cortex-M MCUs because the devices based on the Cortex-M core bring a really
    useful blend of features that enable engineers to create medium to highly complex
    real-time embedded systems using a **real-time operating system** (**RTOS**),
    while still being able to architect the solution in such a way that modules are
    reusable for other projects. STM32 MCUs have been selected because of their popularity,
    the wide range of MCUs available, their approachable **integrated circuit** (**IC**)
    packaging, and the included hardware peripherals. While we're focusing on STM32
    parts in this chapter, keep in mind that there are plenty of other manufacturers
    out there with tons of great products and the vast majority of what's covered
    will apply to non-STM32 (and non-ARM) parts as well.
  prefs: []
  type: TYPE_NORMAL
- en: MCU considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few considerations that need to be made into selecting a microcontroller
    itself, rather than the dev board. Assuming the project contains fully custom
    electronics, there is no limitation on the exact MCU chosen as there would be
    if you were only selecting between dev boards. Students and hobbyists sometimes
    artificially limit themselves even further, sometimes staying loyal to certain
    ecosystems and only selecting from dev boards within those ecosystems (such as
    Arduino or mBed). While there is certainly nothing inherently *wrong* with any
    of the ecosystems, you'll fail to grow as a professional engineer if you're incapable
    of considering other solutions or appreciating the unique strengths each piece
    of hardware brings to a particular project.
  prefs: []
  type: TYPE_NORMAL
- en: Core considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we''ll discuss how to address some key questions that will immediately
    narrow down the field of potential MCU candidates for a project:'
  prefs: []
  type: TYPE_NORMAL
- en: Will it fit?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can it run all of my code?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How much does it cost?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is it readily available?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's answer these questions one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Physical size
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Depending on the design, the MCU's size can be an important factor. If you're
    developing a wearable or portable device, size is likely to be at the top of your
    list. Sometimes, pre-packaged MCUs are too large and the designers are required
    to resort to *chip on board* (where the MCU silicon die is directly bonded to
    the **printed circuit board** (**PCB**), instead of being placed in a separate
    plastic package). On the other hand, large pieces of rack-mounted equipment tend
    to have more than enough space for any size MCU that is suitable to do the job.
  prefs: []
  type: TYPE_NORMAL
- en: A note to those of you who are interested in designing your own hardware—the
    packaging type will play a role in the PCB complexity as well as the ease of assembly
    (especially at the prototyping stage). If your prototypes will be hand-assembled,
    any of the gull-wing packages, such as **quad flat pack** (**QFP**), are the most
    approachable. After QFPs, **quad flat pack no-lead** (**QFN**) packages are still
    easily hand soldered. **Ball grid arrays** (**BGAs**) are generally best avoided
    for hand assembly, unless you're a soldering wizard!
  prefs: []
  type: TYPE_NORMAL
- en: ROM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Read-only memory** (**ROM**) is a fairly large differentiating factor for
    MCUs in the same family, with ROM size being strongly correlated to price. Depending
    on the number of different models available in a product family, there could be
    multiple MCUs with very similar peripheral sets. These MCUs will likely share
    the same physical footprint but have significantly different amounts of memory.
    If your application is cost-sensitive but the required ROM is unknown, consider
    the following approach:'
  prefs: []
  type: TYPE_NORMAL
- en: Select an MCU family that provides multiple flash sizes in a compatible footprint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start development with the MCU that has the most ROM in the family. This provides
    the most flexibility for adding features.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the final image size is known, the exact MCU (with a smaller flash size)
    can be selected before beginning mass production.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When taking this approach, you'll need to be sure to leave enough room for future
    features, assuming your product will be capable of receiving field-updates to
    its firmware. Also, be sure to double-check peripheral assignments between models—*pin
    compatible* doesn't always mean *firmware compatible*!
  prefs: []
  type: TYPE_NORMAL
- en: The amount of ROM required varies greatly and is dependent on how much code
    needs to be loaded onto the device. If you've been working with 8-bit MCUs, then
    you might be in for a nasty surprise when moving to a 32-bit architecture such
    as ARM. A similar program will require more flash space to implement on a 32-bit
    architecture versus an 8-bit architecture. The good news here is that flash sizes
    have kept up, so it's nearly always possible to find an MCU with enough onboard
    flash to accommodate your application. Pulling third-party libraries into your
    code base is generally fairly costly in terms of flash, so be mindful if you choose
    to go down this route.
  prefs: []
  type: TYPE_NORMAL
- en: RAM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The amount of on-chip **random access memory** (**RAM**) is another factor to
    consider—it will generally follow the amount of flash a given device has. Parts
    with larger ROM will usually have more RAM. A few examples where large amounts
    of RAM will be required are data processing that requires large buffers for data,
    complex network stacks, deep buffers for communication, GUIs (especially those
    that require frame buffers), and any interpreted languages that run a virtual
    machine (that is, MicroPython and Lua).
  prefs: []
  type: TYPE_NORMAL
- en: For example, let's say your application calls for a high-resolution display.
    If the display doesn't have an on-board controller with its own frame buffer,
    you're likely already in external RAM territory. The size buffer required to drive
    that type of display will likely exceed the RAM available on board the MCU. On
    the other hand, if you're building a simple control system with limited connectivity
    and UI capability, then a small amount of RAM may be all that is required.
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that each task in FreeRTOS requires its own stack (generally with
    a bare minimum of 512 bytes on the Cortex-M port), so if a large number of tasks
    is required, it will be easy to quickly utilize several KB of RAM.
  prefs: []
  type: TYPE_NORMAL
- en: From a firmware engineer's perspective, external RAM seems like a get-out-of-jail-free
    card (who wouldn't want to increase the available RAM by nearly an order of magnitude)—but
    all of that functionality does come at a cost. Unless your system absolutely requires
    it, external RAM on the MCU's address/data bus is best avoided. It will require
    additional PCB real estate, consume more power, and ultimately, drive up PCB and
    bill of materials (**BOM**) costs. The PCB layout can be considerably more complicated
    when adding an external high-speed parallel bus used for accessing an external
    RAM because of length-tuning requirements and the number of signals involved.
    The design will also be more likely to emit EMI because of all the high-speed
    signals. Although it offers plenty of space, external RAM is often marginally
    slower than on-board RAM, which can lead to a more complex linker file (if certain
    functions have very tight timing constraints). Other factors worthy of consideration include properly
    setting up RAM timing parameters and caching coherency issues if you attempt to
    speed up access to external RAM by using data caching (refer to *Further reading*
    section for details).
  prefs: []
  type: TYPE_NORMAL
- en: With all of its downsides, having external RAM enables a lot of functionality,
    such as the ability to cache entire firmware images in RAM for upgrades, feature-rich
    GUI frameworks, complex networking stacks, and sophisticated signal processing
    techniques. As with any other requirement, there are trade-offs to be made.
  prefs: []
  type: TYPE_NORMAL
- en: The CPU clock rate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we're limiting our discussion to MCUs with the same underlying architecture,
    an MCU with a faster core clock rate will execute the same set of pure software
    functions faster than one with a slower clock rate. Notice the keyword *pure*
    in the previous statement—sometimes, there are on-board hardware peripherals that
    can make a huge difference to execution speed that have nothing to do with the
    CPU clock rate (such as the hardware floating point and DSP functionality available
    on the Cortex-M4 core).
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to be mindful of is the absolute maximum clock rate of the device
    versus the practical clock rate for an application. For example, some MCUs' maximum
    clock frequency is incompatible with generating an internal 48 MHz clock required
    for a USB peripheral, so it can't be used at maximum speed if the USB peripheral
    is also used.
  prefs: []
  type: TYPE_NORMAL
- en: Interrupt processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within the ARM Cortex-M family, interrupt processing is all very similar. All
    of the devices include a **nested vector interrupt controller** (**NVIC**) with
    a relocatable vector table and an **external interrupt controller** (**EXTI**).
    Device-specific considerations include the exact peripheral interrupts that are
    available and how they are mapped to the NVIC, as well as how external interrupts
    are multiplexed into the EXTI.
  prefs: []
  type: TYPE_NORMAL
- en: Price
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Depending on the application, the BOM's cost may be a significant driver or
    hardly a consideration. Generally, BOM costs come under increasing scrutiny in
    high-volume applications. However, with lower volume products, it is often wise
    to focus more on minimizing the development time and effort of a product, rather
    than achieving the lowest BOM cost possible. By focusing on minimizing the amount
    of engineering effort and development time for a low-volume product, the product
    will get to market sooner. Not only does the product start generating revenue
    faster, but it also accrues less **non-recurring engineering** (**NRE**) costs.
    Less NRE leads to a faster **return on investment** (**ROI**) for the product
    being developed. Faster ROI ultimately makes managers and CEOs really happy! In
    these situations, worrying about spending a few dollars on a BOM for a product
    selling dozens per year—at the expense of weeks or months of development effort—is
    rarely a wise trade-off.
  prefs: []
  type: TYPE_NORMAL
- en: Availability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An often-overlooked aspect of an MCU by junior engineers is its expected and
    guaranteed availability. Just because a part is available for purchase at the
    beginning of the project does not mean it will be available for the entire time
    that the end product will be sold. In the case of consumer devices, this probably
    isn't a huge issue. This is because these devices can have extremely high volumes,
    but any single revision is only in production for a limited amount of time (from
    months to a year or two).
  prefs: []
  type: TYPE_NORMAL
- en: Contrast the consumer electronics mindset of planned obsolescence with something
    on the industrial, telecom, or aerospace side. In these industries, development
    timelines can be measured in years and required support periods are often a decade
    or more. This is why part availability is a very real consideration. Be sure to
    investigate the manufacture guarantees on availability and weigh these against
    their history, reputation, and the risk to the project—it's not a pleasant experience
    to get 80% of a design complete only to find out that the MCU can't be sourced
    during a pre-production run!
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've covered some of the initial considerations to be aware of, we'll
    move on to some of the more unique considerations for embedded processors—hardware
    peripherals.
  prefs: []
  type: TYPE_NORMAL
- en: Hardware peripherals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Compared to the desktop world of CPUs, where the processor itself is generally
    the center of attention, selecting the *right* MCU is more complex due to the
    increase in scope. Many different pieces of hardware are included on the same
    chip, which enables us to optimize the solution for speed, power, CPU utilization,
    or BOM cost. In a highly constrained design, all of these factors can come into
    play and trade-offs will need to be made.
  prefs: []
  type: TYPE_NORMAL
- en: This section will cover some of the hardware peripherals commonly available
    on Cortex-M- based MCUs and aims to provide an extremely brief introduction to
    them, with the goal of informing you why each type of peripheral may be helpful
    to have in a design.
  prefs: []
  type: TYPE_NORMAL
- en: Connectivity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In today's ever-increasingly connected ecosystem of the **Internet of Things**
    (**IoT**), having on-board networking capability on the MCU can be a boon to a
    project. . . as long as the right firmware exists to drive it. It is important
    to realize that having a peripheral is not the same as having full functionality.
    For example, just because an MCU supports a **reduced media independent interface**
    (**RMII**) and a **physical layer in networking** (**PHY**) does not mean you
    can immediately get a full TCP/IP stack—all of that firmware functionality needs
    to come from somewhere. Potential connectivity baked into devices can include
    Ethernet, RMII, 802.11 (WiFi), 802.15.1 (Bluetooth), and 802.15.4 (Zigbee, HART,
    and so on).
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to wireless communications, things get a bit more complex, since
    the product will need to be pushed through an approval process from the appropriate
    agency, depending on geographic location. Pre-certified **radio frequency** (**RF**)
    modules can be used to minimize the amount of effort and cost to develop a properly
    certified end product.
  prefs: []
  type: TYPE_NORMAL
- en: Due to a specialized PCB layout, regulatory requirements, and complex network
    stacks, on-board MCU peripherals that facilitate wireless communications aren't
    quite as useful as they first appear for a low-volume product. Again, don't be
    lulled into a false sense of accomplishment by simply specifying a part that has
    hardware available, since wireless communication stacks can be extremely complex
    and wireless certification testing is expensive.
  prefs: []
  type: TYPE_NORMAL
- en: Memory protection units
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Memory protection units** (**MPUs**) are used to ensure that code only accesses
    the range of RAM it is permitted to. When used correctly, MPUs ensure greater
    system stability and increased security, since the application is less likely
    to cause unintended consequences by accessing memory it shouldn''t.'
  prefs: []
  type: TYPE_NORMAL
- en: FreeRTOS includes support for MPU-protected tasks, which we'll cover in *[Chapter
    15](0f98e454-9804-4589-9854-5c38c9d8d416.xhtml), FreeRTOS Memory Management*.
  prefs: []
  type: TYPE_NORMAL
- en: Hardware floating-point units
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If your application is going to be crunching lots of floating point numbers,
    a **hardware** **floating-point unit** (**FPU**) can be extremely helpful. Until
    the past decade or so, floating point numbers were generally best avoided in most
    MCU-based embedded systems. The availability of faster processors started to change
    this. Now, FPUs are often implemented in hardware. Thanks to FPUs, many different
    applications can benefit from using floating point math, without incurring the
    CPU performance penalty commonly associated with software-based library implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Single-precision (32-bit) FPUs are optional on Cortex-M4 processors, while Cortex-M7-based
    processors add optional hardware support for double-precision (64-bit) floating
    point arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: Digital signal processing functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Along with increased performance from hardware-based, floating point support,
    the Cortex-M4- and Cortex-M7-based MCUs also have optional **digital signal processing** (**DSP**)
    functionality baked into the hardware, which can greatly accelerate some complex
    algorithms and potentially help reduce the coding burden for firmware engineers.
  prefs: []
  type: TYPE_NORMAL
- en: Direct memory access channels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Direct memory access** (**DMA**) can be extremely useful in a variety of
    situations where high bandwidth or highly event-driven code is desired. DMA controllers
    are typically able to interact with MCU peripherals, as well as different parts
    of RAM. They take care of populating peripheral registers and RAM without involving
    the CPU at all. These autonomous transfers can free up significant CPU time by
    greatly reducing the interrupt load and context switching.'
  prefs: []
  type: TYPE_NORMAL
- en: One thing to keep in mind regarding DMA peripherals is that all channels aren't
    always mapped to all peripherals. Certain channels can be of a higher bandwidth
    than others. This is most significant in systems that require multiple high-bandwidth
    devices. For challenging systems such as these, it is important for firmware and
    hardware engineers to work together to ensure that a hardware design doesn't cause
    a handicap for firmware down the road.
  prefs: []
  type: TYPE_NORMAL
- en: Communication interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve already introduced external network connectivity relative to Ethernet
    and wireless technologies. There are many different communication interfaces that
    are more traditionally associated with embedded devices and are commonly available
    as hardware peripherals on an MCU. The interfaces that are used for communicating
    with on- and off-board sensors and actuators are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Inter-IC Communication** (**I2C**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Serial peripheral interface** (**SPI**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Universal Synchronous/Asynchronous Receiver Transmitter** (**USART**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following peripherals are regularly used in automotive and industrial environments
    for inter-module communication:'
  prefs: []
  type: TYPE_NORMAL
- en: '**USARTs**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controller area network** (**CAN**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Local interconnect network** (**LIN**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardware crypto engines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If your application calls for external connectivity, then your mind should also
    be focused on security. In the same way that FPUs make floating point operations
    more CPU efficient, hardware-based cryptography engines are available on some
    MCUs, which will greatly reduce the CPU burden required to securely transfer data
    over public networks.
  prefs: []
  type: TYPE_NORMAL
- en: Timing hardware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are often several different timing peripherals included on an MCU. The
    peripherals themselves will often include input capture, output compare, and **pulse
    width modulation** (**PWM**) functionality as a minimum. Some devices will also
    include timing hardware for interfacing with quadrature encoders.
  prefs: []
  type: TYPE_NORMAL
- en: Input capture deals with *capturing* the time a digital input to the MCU changes
    state. MCU peripherals do this with a much higher resolution than firmware because
    they use high-frequency counters and hardware gates to capture the signal transition
    (rather than relying on multiple CPU instructions). There are often several channels
    of input capture available, which can be used in parallel. Output compare is effectively
    the reverse of input capture (a signal is output with precise timing characteristics)—*compare*
    refers to the hardware comparator used to determine when to perform the transition.
  prefs: []
  type: TYPE_NORMAL
- en: PWM and input capture are both very commonly used in control systems to interact
    with sensors and actuators. Some actuators will take PWM as inputs. PWM can also
    be used to provide proportional control of a binary driver (such as a transistor),
    which can be used to precisely change the amount of power delivered to a load.
    Many different encoders will often supply information in PWM format as well, which
    can be read by the MCU using a timer peripheral's input capture mode.
  prefs: []
  type: TYPE_NORMAL
- en: '**Quadrature encoder inputs** (**QEIs**) are extremely useful in motion feedback
    systems. Although similar functionality can be achieved using multiple channels
    of input capture (or slowly, without any dedicated hardware), having dedicated
    QEI hardware allows for very minimal CPU intervention, even at high input rates.'
  prefs: []
  type: TYPE_NORMAL
- en: Integrated analog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Digital to Analog Converters** (**DACs**) and **Analog to Digital Converters**
    (**ADCs**) are used when converting between continuously varying analog values
    and associated digital representations of that value. Most often, these types
    of on-board peripherals will be lower resolution and lower frequency than what
    you''ll find with external chips. However, depending on the requirements of your
    system, they can be extremely useful. Another useful peripheral is on-board comparators,
    which will signal the processor when an analog value is above or below a given
    threshold.'
  prefs: []
  type: TYPE_NORMAL
- en: Some more specialized devices (for example, Cypress PSoC) include fully reconfigurable
    analog peripherals (including op-amps, DACs, and ADCs) as well as flexible digital
    peripherals, flexibly integrating a very large feature set into a signal chip.
    Analog Devices and Maxim offer some of the more exotic mixed-signal MCUs, which
    tend to integrate application-specific components onto the same chip as the MCU,
    making development for a specific end product easier. You can find a very wide
    range of application-specific MCUs aimed at everything from industrial process
    control, automotive distance sensing, and IoT sensors to TV remote control applications.
  prefs: []
  type: TYPE_NORMAL
- en: If there is a popular use case for a mixed-signal problem, chances are, there
    is also a fully integrated piece of silicone that integrates an MCU with most
    of the required analog frontend available to solve most of the problem. The question
    then becomes one of balancing the BOM cost, detailed specifications, the size,
    development time, and long-term sourcing risk mitigation.
  prefs: []
  type: TYPE_NORMAL
- en: Dedicated touch interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thanks to the increased prevalence of touch interfaces, full implementations
    of touch controllers are now included on some MCUs. This can greatly reduce the
    amount of expertise and effort required to have a fully functional and robust
    touch interface implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Display interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generally found in higher performance devices with larger pin counts, sophisticated
    display interfaces and even graphics acceleration are becoming fairly common.
    Expect to find parallel LCD/TFT interfaces (for example, 6800 and 8080) on a large
    number of parts, with interfaces such as MIPI DSI capable of driving inexpensive,
    high-resolution displays to displays with only a few lines. Hardware protocol
    conversion ICs can be used to adapt to a number of different display standards,
    such as LVDS and HDMI. MCUs are now capable of delivering a rich user experience,
    with added hardware acceleration and efficiently written middleware and drivers.
    The CPU load is perfectly tolerable as well.
  prefs: []
  type: TYPE_NORMAL
- en: External memory support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In higher pin count packages, expect to find support for **static random access
    memory** (**SRAM**). **Synchronous dynamic random access memory** (**SDRAM**)
    support, with an on-board controller taking care of the tight timing requirements
    and refresh cycles, can be found in higher performance devices. Devices aimed
    at performance will generally bring in support for quad-SPI. Often, external RAM—and
    even quad-SPI devices—can be memory-mapped and used similar to internal storage,
    albeit with a performance hit. Many devices have **MultiMediaCard** (**MMC**)
    and **secure digital card** (**SD card**) controllers as well, so commodity consumer-grade
    removable storage is easily added.
  prefs: []
  type: TYPE_NORMAL
- en: Real-time clock
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hardware calendars are available on some devices as well; all that is needed
    is a 32 kHz crystal and a back-up power source, such as a CR2032 primary lithium
    battery. Something that is also generally offered with this capability is a limited
    amount of battery backed-up RAM.
  prefs: []
  type: TYPE_NORMAL
- en: Audio support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: High-fidelity audio support through **Inter-IC Sound** (**I²S**) is commonly
    available. Expect to find DMA channels attached to the I²S peripheral to minimize
    the amount of CPU intervention required for feeding data-hungry DACs and collecting
    data from ADCs on these buses.
  prefs: []
  type: TYPE_NORMAL
- en: 'This concludes our long list of hardware peripherals to look out for when evaluating
    MCUs. Next up is a topic that will be of specific interest to anyone interested
    in designing battery-or energy-harvesting devices: power consumption.'
  prefs: []
  type: TYPE_NORMAL
- en: Power consumption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lower-power MCUs have been the trend for well over a decade. However, what was
    historically a specialized use case with limited options (such as the 16-bit MSP430)
    has now become mainstream, thanks to the plethora of battery-powered, IoT-based
    devices coming onto the market. Now, full 32-bit MCUs are available, which can
    quickly cycle between low deep sleep and high-clockrate, data-crunching run modes.
  prefs: []
  type: TYPE_NORMAL
- en: Power efficiency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It may sound simple, but a fairly good way of making sure something draws less
    power is to turn it off (don't laugh—this can be surprisingly complicated depending
    on the parts involved, thanks to various leakage currents!). If complex MCUs with
    dozens of peripherals have any hope of being power efficient, there needs to be
    a way to turn off whatever functionality isn't required to minimize wasted power.
    This is typically accomplished by shutting off clocks to peripherals that aren't
    in use and ensuring that CMOS-based I/O pins are not floating (remember, it's
    the transitions in CMOS devices that draw the most power).
  prefs: []
  type: TYPE_NORMAL
- en: Another spec that is commonly found in datasheets is how much power is consumed
    per MHz of CPU clock—generally specified in µA/MHz. If the amount of processing
    per wake-up period is fairly constant, this provides another metric to compare
    different MCU models.
  prefs: []
  type: TYPE_NORMAL
- en: Low-power modes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Devices that are aimed at lower-power applications will typically have a few
    different levels of shutdown states to choose from. These states will allow the
    programmer to trade off between current consumption, available features (such
    as keeping RAM content intact and some peripherals on), the number of interrupts
    available to trigger a wake-up event, and the wake-up time. Thankfully, many lower-power
    IoT applications are fairly limited in their scope of operations, so sometimes
    a combination of novel features in a particular MCU will prove to be a very good
    fit for a specific application.
  prefs: []
  type: TYPE_NORMAL
- en: Wake-up time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If a device has an amazingly low shutdown current, but takes an abnormally long
    time to *wakeup* and get itself into a usable running state, it might not be the
    best choice for an application that requires fairly frequent wake-ups, since significant
    time will be spent getting the system up and running instead of getting it to
    perform the necessary processing and then going back to sleep.
  prefs: []
  type: TYPE_NORMAL
- en: Power supply voltage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lower power supply voltages will typically lead to lower current consumption.
    Depending on the design, trade-offs can be made between eliminating power conditioning
    circuitry (which consumes current due to less than 100% efficiency) and extending
    the usable operating voltage range of a given battery cell. The MCU's voltage
    requirement (as well as any ancillary circuitry) will be a driving factor for
    how much flexibility there is on the regulation side. Also, be aware that the
    maximum clock typically scales with supply voltage as well, so don't expect to
    be able to drive the CPU at the maximum specified frequency and lowest possible
    supply voltage.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating MCUs mid-project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Occasionally, 100% of the project requirements won't be known up front, or everyone
    might not be 100% confident about how exactly to solve every detailed problem
    on day 1\. If you happen to be fortunate enough to know that there is a high level
    of uncertainty, then it is always better to plan for it, rather than be caught
    by surprise. Here are a few areas where selecting an MCU that's part of a larger
    family or ecosystem can help to mitigate some of the risks associated with project
    uncertainty.
  prefs: []
  type: TYPE_NORMAL
- en: Importance of pin compatibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When planning for a potential MCU shift, if possible, identify alternative MCUs that
    are pin-compatible ahead of time. For example, the NXP LPC1850's parts are pin-compatible
    with LPC 4350 MCUs. STM32 devices are all pin-compatible within a family (and
    package) but will occasionally be *almost* pin-compatible with other families
    as well (STM32M4 and STM32M7, for example). ST regularly publishes migration guides
    for engineers that have *outgrown* one MCU family and need something a bit more
    capable. If a few likely candidates and alternatives are selected up front, some
    simple jumper populations on the PCB may facilitate migration between different
    MCUs with significantly different performance (and cost), helping to eliminate
    the time required for PCB reworking mid-project.
  prefs: []
  type: TYPE_NORMAL
- en: Peripheral similarity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most MCUs, within a given family, will inherit the same peripheral IP. Silicon
    vendors don't necessarily redesign peripherals from scratch every time they create
    a new MCU family, so there is often a significant amount of overlap in the register
    maps and behavior for peripherals belonging to a given vendor. Often, if your
    applications only use a subset of the most basic peripheral functions, to begin
    with, you might be lucky enough to use largely the same driver, even if the vendor
    decides to drastically change their API between MCU families. Ironically, sometimes,
    the raw hardware proves to be more consistent over time than the abstraction layers
    above it.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of an MCU family
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many silicon vendors have concepts of device families, and **STMicroelectronics**
    (**STM**) is no exception—datasheets are typically written for entire families
    of devices. The most notable differences between devices in an STM family are
    typically RAM/ROM and the package size. However, additional peripherals are added
    to more capable devices as well—for example, larger packages will start to include
    parallel RAM controllers. Devices with more RAM/ROM will include more capable
    timer peripherals, more comm peripherals, or domain-specific peripherals, such
    as cryptographic modules.
  prefs: []
  type: TYPE_NORMAL
- en: Moving between devices in a given device family should be easy to do, so it
    is advisable to start on one end of the family (high is usually advisable) and
    see where the project goes. If scope creep was kept to a minimum, it may be possible
    to painlessly downgrade the MCU after all of the major features have been developed,
    saving some BOM cost.
  prefs: []
  type: TYPE_NORMAL
- en: That wraps up our list of considerations for the raw MCU. However, going out
    and buying a single chip and letting it sit on a desk won't do us much good for
    writing firmware. We need a way of powering the device, and communicating with
    it—we need a dev board!
  prefs: []
  type: TYPE_NORMAL
- en: Development board considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A dev board is any piece of hardware that engineers use during the early development
    phase of a project. Dev boards aren't just for MCUs; they are useful for many
    different types of hardware—anything from op-amps to **field-programmable gat
    arrays** (**FPGAs**).
  prefs: []
  type: TYPE_NORMAL
- en: 'MCU dev boards should provide a few key functions:'
  prefs: []
  type: TYPE_NORMAL
- en: Ancillary circuitry, required to power and run the MCU
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A way to program and communicate with the MCU
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connectors for easy connection to external circuitry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Possibly, some useful on-board ICs to exercise some of the peripherals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many different routes that can be taken when it comes to evaluating
    MCUs. We're currently enjoying a period of time where hardware is inexpensive
    and commonly available. Because of this, there are a plethora of options to choose
    from for evaluating hardware. There are three major groupings that a piece of
    prototyping hardware tends to fall into, each of which has strengths and weaknesses.
    Of course, you can also roll your own dev board or prototype, if you have specific
    requirements.
  prefs: []
  type: TYPE_NORMAL
- en: What a development platform is and why it matters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For our purposes, a development platform is an ecosystem of products that allows
    for a high degree of abstraction across multiple vendors. The primary focus of
    a platform is delivering large amounts of functionality with the smallest amount
    of effort possible, which is excellent when the main purpose is to create a prototype
    as quickly as possible.
  prefs: []
  type: TYPE_NORMAL
- en: In order to deliver large amounts of functionality across multiple vendors,
    standardized interfaces, ease of use, and flexibility tends to be emphasized.
    With these values, the platform itself is what the focal point is (as it should
    be) and individual differentiating features of particular devices tend to go largely
    unnoticed, that is, unless you're interested in coding them specifically, which
    takes additional time and ends up requiring you to put more focus into developing *for*
    the platform instead of *with* the platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ecosystems develop around platforms, gently guiding platform users into tooling,
    workflows, least-common denominator feature sets, and available hardware. This
    is all well and good if the goal is to produce a proof-of-concept in the least
    amount of time possible. However, if a long-term development and production-worthy
    solution is to be found using the platform approach, the platform will likely
    need to be high quality, extremely well established, and stable. This generally
    means using platforms based on industrial standards available from multiple vendors
    (such as SMARC, QSeven, and COM Express), rather than the current "flavor of the
    year" in the maker space:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e8665d67-e955-4b25-971f-f2dd3d5542c3.png)'
  prefs: []
  type: TYPE_IMG
- en: The bottom line is that a platform's interest is generally making the platform
    easy to use so that it gains further adoption. This accessibility can lead to
    common interfaces (as seen in the preceding diagram), which can be a boon to productivity
    during fast prototyping efforts but abstract away considerable differences in
    the underlying hardware. Often, platform-specific functionality is so important
    that the platform code will simply virtualize interfaces to make them more accessible,
    often at very significant costs (that is, bit-banging PWM or SPI so they can be
    assigned to specific predetermined pins). So, if you choose to use a platform
    to evaluate hardware (or specifically, an MCU), you should realize that you're
    likely evaluating the platform and its implementation on a given piece of hardware,
    rather than the hardware itself.
  prefs: []
  type: TYPE_NORMAL
- en: Evaluation kits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An **evaluation kit** (**eval kit**) is at the other end of the spectrum when
    it comes to standardized footprints versus focus on the hardware itself. Eval
    kits are generally outfitted with the biggest, most feature-filled model of MCU
    available and are made with the sole intent of *showing off* that piece of hardware.
    This means they will generally not share a common footprint or connectors between
    different target MCUs (refer to the following diagram) because each MCU has different
    primary features and is targeted at a different market. Eval boards will have
    as many peripherals broken out to actual connectors as possible (such as serial,
    Ethernet, SD cards, a CAN bus, and multiple USBs). They also typically include
    a slew of peripheral hardware, such as RAM, eMMC, buttons, sliders, potentiometers,
    displays, and audio codecs to drive speakers. They will almost always break out
    all the interesting MCU pins to easily accessible headers, so developers are able
    to quickly try out any specific hardware configuration they can dream up. Manufacturers
    typically showcase their other non-MCU silicons on eval kit boards as well, in
    an effort to drive more sales in relation to their own products:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3bdbf332-8153-40e1-a3fc-8123197b4fbf.png)'
  prefs: []
  type: TYPE_IMG
- en: To best demonstrate a device's capabilities, eval kits will also ship with a
    plethora of working example code that allows an engineer to interact with all
    of the peripherals included. Unlike the generalized implementations you'd generally
    find with a platform-based implementation, these examples are tailored to demonstrate
    the unique differentiating features of the target device to be evaluated. In the
    first part of this chapter, we discussed choosing hardware based on specific use
    cases. If you're seeking a specific solution to a challenging aspect of a design,
    the importance of having a guided example to working code that exemplifies the
    key differentiating aspects of an MCU can be a serious timesaver (and eye opener)
    compared to having to implement all of those features from scratch yourself.
  prefs: []
  type: TYPE_NORMAL
- en: All of this functionality comes at a cost—full-blown eval kits typically cost
    a few hundred dollars. However, if your goal is to quickly evaluate a potential
    MCU with a specific purpose in mind, they can quickly pay for themselves by saving
    engineering time and mitigating risk.
  prefs: []
  type: TYPE_NORMAL
- en: Low-cost demonstration boards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Low-cost demonstration boards have really come into their own in recent years.
    Prices have come down significantly; manufacturers will occasionally sell demonstration
    boards for the same cost as the bare IC that sits on them (occasionally, they
    were actually *less* expensive than buying individual ICs!). Unlike hardware platforms,
    these boards will often have *similar *footprints, but not necessarily the same
    connectors or pinouts.
  prefs: []
  type: TYPE_NORMAL
- en: Recently, more low-cost demonstration boards that blur the line between platforms
    and demonstration boards (also called demo boards) have come to the market. Thanks
    to the ubiquity of Arduino®, most low-cost boards will have at least a set of
    Arduino headers that are pin-compatible. However, the availability of compatible
    headers and having a development board that fully embraces an ecosystem are very
    different things. The demo board may not have any software to accompany those
    headers; just because hardware exists and can be plugged into the board does not
    automatically mean you'll get compatible libraries for the target MCU to drive
    the hardware. This doesn't make them incompatible, but the amount of effort to
    get something up and running will be much greater than simply plugging a board
    in and following along with a "hello world" demo.
  prefs: []
  type: TYPE_NORMAL
- en: Some manufacturers are also creating their own standardized headers that are
    common between demo boards, which is at least helpful when migrating between different
    product families (but is obviously limited to that manufacturer). The ST Nucleo
    and NXP Freedom standardized headers are some examples. In an attempt to become
    more user-friendly, these boards will also typically feature mBed compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you've been introduced to the different types of development boards,
    we'll take a more detailed look at a single manufacturer's microcontroller line—the
    STM32 line.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the STM32 product line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the past several years, STM has developed a fairly wide range of MCUs.
    Here, we'll discuss how a few of the major swaths of that portfolio fall into
    place relative to the considerations discussed in the *MCU considerations* section
    of this chapter . Most other vendors also arrange their products into major segments
    as well, which tends to make the selection process a bit easier.
  prefs: []
  type: TYPE_NORMAL
- en: Mainstream
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The STM32 line started with the STM32F1, a Cortex-M3-based MCU, back in 2007\.
    This portion of the product line is meant to serve the majority of high volume
    applications, where cost and performance must be balanced, with minimally complex
    applications. The STM32F0 and the STM32G0 portions of the line are Cortex-M0-
    and Cortex-M0+-based devices that are aimed at low-cost applications. The original
    STM32F1 is Cortex-M3-based and has a very wide range of feature sets, but is starting
    to show its age when its performance is compared to other devices.
  prefs: []
  type: TYPE_NORMAL
- en: The STM32F3 was STM's first attempt at providing integrated, higher precision
    analog peripherals (other vendors offer higher precision analog components than
    STM); however, the line falls short of offering truly high-performance analog.
    It includes a 16-bit sigma delta ADC, but the **effective number of bits** (**ENOB**)
    is only stated to be 14 bits, which is slightly better than STM's 12-bit **successive
    approximation** (**SAR**) ADC peripherals, which are included most often. The
    newer Cortex-M4+-based STM32G4 family has the most analog peripherals available,
    including many instances of **programmable gain op-amps** (**PGA**), DACs, ADCs,
    and several comparators, but there are no integrated high-precision ADCs available
    at the time of writing.
  prefs: []
  type: TYPE_NORMAL
- en: Look out for the STM32G0 and STM32G4 families increasing the breadth of their
    offerings through 2020—they are both newer lines and STM will likely start filling
    these out with many more devices.
  prefs: []
  type: TYPE_NORMAL
- en: High performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: High-performance MCUs from STM started with the Cortex-M4-based STM32F4\. The
    Cortex-M4 is very similar to the Cortex-M3, but it includes (optional) hardware
    32-bit FPU and DSP instructions, which are both present on all STM3F4 devices.
    All of the devices in the high-performance line are capable of comfortably driving
    very attractive GUIs on controllerless displays, as long as the required RAM is
    available (usually external to the MCU). Acceleration provided by various hardware
    peripherals (such as MIPI **Display Serial Interface** (**DSI**), memory transfers
    via FMC and DMA, and some basic graphics acceleration using the **Chrom-Adaptive
    Real-Time** (**Chrom-ART**) accelerator) make it possible to off-load a fair amount
    of the effort involved with communicating with the display to various peripherals
    so that the CPU can spend time performing other tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a quick breakdown of the two major members of the family and some notable
    features:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **MCU line** | **CPU** | **Features** |'
  prefs: []
  type: TYPE_TB
- en: '| STM32H7 | Cortex-M7 (480 MHz)Cortex-M4 (240 MHz) (opt) | Highest performance
    MCU from STM64-bit FPU and extended DSP instructions |'
  prefs: []
  type: TYPE_TB
- en: '| STM32F7 | Cortex-M7 (216 MHz) | 64-bit FPU and extended DSP instructions
    |'
  prefs: []
  type: TYPE_TB
- en: '| STM32F2 | Cortex-M3 | Offers trade-off for performance versus costHigh level
    of integration (camera interface and USB OTG) |'
  prefs: []
  type: TYPE_TB
- en: This class of MCU can be thought of as *crossover* MCUs. They are powerful enough
    that they can be used for some application tasks that were traditionally reserved
    for full-blown CPUs, but they still have the ease of use of an MCU.
  prefs: []
  type: TYPE_NORMAL
- en: The heterogeneous multi-core approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In 2019, STM launched the STM32MP line, which was the company's first entry
    into the application processor space. This family offers a single or dual-core
    Cortex-A7 at 650 MHz, along with a single Cortex-M4 running at 209 MHz. STM appears
    to be targeting the high-volume, low-cost portion of the market with these solutions
    by focusing on a lower core count and packages that require fewer PCB layers using
    less expensive fabrication techniques.
  prefs: []
  type: TYPE_NORMAL
- en: From a software perspective, the main difference between STM's MCU offerings
    and the new **micro-processor unit** (**MPU**) is that since the MPUs have **memory
    management units** (**MMUs**), they are capable of running a *full OS* via mainline
    Linux kernels, which opens up an entirely different ecosystem of open source software
    (that you don't personally need to write).
  prefs: []
  type: TYPE_NORMAL
- en: The heterogeneous multi-core approach allows designers to split up portions
    of a design and solve them in the domain that they are best suited to. For example,
    a dedicated process controller with a GUI and networking capability could use
    the Cortex-A7 to leverage Linux and gain access to the Qt framework and complex
    networking stacks, while using the Cortex-M4 for all of the real-time control
    aspects.
  prefs: []
  type: TYPE_NORMAL
- en: Implementations of μClinux have been available for the STM32F4 and STM32F7 MCUs
    for years, but because of the lack of MMU on these devices, there is typically
    a pretty hefty performance penalty.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, with additional capability comes additional complexity. Unlike MCUs,
    there's no way to get around integrating external RAM with the STM32MP line, so
    be prepared for some fairly involved PCB layout (compared to a stand-alone MCU
    solution).
  prefs: []
  type: TYPE_NORMAL
- en: Low power
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'STM''s low power line is squarely aimed at battery-powered devices. Here''s
    a quick comparison between all of the different family members:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **MCU version** | **CPU** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| STM32L | Cortex-M0 | Lowest performance and RAM and ROM space of the family,
    but offers fairly good efficiency. |'
  prefs: []
  type: TYPE_TB
- en: '| STM32L1 | Cortex-M3 | Higher ROM capacity and offers faster performance with
    the trade-off of increased power consumption. |'
  prefs: []
  type: TYPE_TB
- en: '| STM32L4 and STM32L4+ | Cortex-M4 | Have increased number-crunching capability
    (the STM32L4+ also offers faster clock speeds and larger internal flash storage).
    |'
  prefs: []
  type: TYPE_TB
- en: '| STM32L5 | Cortex-M33 | Blends performance and power and incorporates the
    latest ARM v8 architecture. Cortex-M33 offers additional security features, such
    as Trust.Zone, and executes instructions more efficiently than Cortex-M4, which
    allows for some additional performance while still keeping power consumption in
    check. |'
  prefs: []
  type: TYPE_TB
- en: Depending on the exact workload of a given IoT application, it may make sense
    to use a low-power 32-bit MCU, such as the ones in the preceding table. However,
    for very simple applications, low-power 8- and 16-bit MCUs should also be considered.
  prefs: []
  type: TYPE_NORMAL
- en: Wireless
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The STM32WB implements a Cortex-M4 with a dedicated Cortex-M0+ to run a Bluetooth
    BLE stack. This line provides a lot of integration, from large flash memory and
    RAM to mixed-signal analog peripherals, including touch sensors and small segment
    LCDs. Various security features, such as crypto algorithms and a random number
    generator, are also present. Since FCC certification is required for products
    using this family of devices, they will make the most sense for high volume applications.
  prefs: []
  type: TYPE_NORMAL
- en: With a wide range of MCUs to choose from, STM *probably* has something we can
    use to experiment with an RTOS! It's time to move on to selecting a development
    board to use.
  prefs: []
  type: TYPE_NORMAL
- en: How our development board was selected
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've covered the important considerations for MCU selection and the
    general types of development hardware, let's see how the development board that
    will be used in this book was selected. STM is the only manufacturer that we are
    evaluating in order to limit the examples to something easily digestible. In an
    actual product engineering effort, it behooves the designer to take a fresh look
    at all possible vendors. While everybody has their own preferred way of accomplishing
    cross-vendor searches, an easy way is to use distributor websites.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to well-curated prototyping-oriented distributor websites (such as Digikey
    and Mouser), an engineer is able to perform parametric searches and comparisons
    across many different vendors. One downside to this approach is the searches are
    limited to whatever product lines that specific distributor carries. Another potential
    downside is that the parametric search results are at the mercy of the distributor's
    data entry accuracy and categorization. The upsides to using a distributor website
    directly are that many different vendors are all in one spot, product availability
    can be checked immediately, and semi-real-world pricing is easily seen and filtered.
  prefs: []
  type: TYPE_NORMAL
- en: Pricing from prototyping-oriented distributors is considered *semi-real-world*
    because oftentimes, after a product goes into full production it is generally
    more economical to use a quantity-oriented distributor or go directly to the vendor
    for high volumes.
  prefs: []
  type: TYPE_NORMAL
- en: Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Up to this point, we''ve covered all of the considerations that go into selecting
    an MCU for a project at a theoretical level. Now, it''s time to put all of that
    into action and select the MCU that will be used for all of the actual *hands-on*
    exercises. A few things to keep in mind are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We'll be selecting a dev board *and* MCU—therefore, some of the requirements
    will be aimed at the dev board, which generally isn't a good idea if you're making
    a product that needs to go into long-term production.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requirements are going to be specific to this book—the requirements that make
    something a good choice for a book probably don't translate to the project you're
    working on. Obviously, your selection criteria will be tailored to your project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The must-haves—that is, the *requirements—* are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The target MCU on your dev board will be an STM32 Cortex-M-based CPU.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The target MCU must have a **memory protection unit** (**MPU**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dev board must have a visible means of displaying status.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A relatively low cost (such as < USD 50).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The nice-to-haves—that is, the *desirements* needed—are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Versatility: It would be nice if the dev board could be used with other hardware.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Virtual communication over USB available as a debug port.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple cores.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requirements justification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re going to be limiting our search to STM32 parts since that''s the example
    family we''re using throughout this book. In [Chapter 15](0f98e454-9804-4589-9854-5c38c9d8d416.xhtml),
    *FreeRTOS Memory Management* we''ll be covering how to prevent tasks from accessing
    memory they shouldn''t, which will require us to make use of a part with a memory
    protection unit. One of the goals of this book is to keep hardware interaction
    as accessible as possible, which leads to the next two requirements: status display
    and cost.'
  prefs: []
  type: TYPE_NORMAL
- en: Some means of displaying *status* will likely translate into a simple LED (ideally
    multiple). There should be some form of feedback for the programmer to be able
    to see what's going on at a glance in order to ensure the code is actually doing
    something. In a real embedded environment, this would likely take the form of
    additional instrumentation, such as oscilloscopes, logic analyzers, and DMMs.
    In the spirit of keeping this accessible for as many people as possible, we'll
    be explicitly avoiding those tools. So, rather than relying on external tools
    and the debugger alone, we're going to be on the lookout for on-board indicators.
  prefs: []
  type: TYPE_NORMAL
- en: The nice-to-haves aren't hard requirements, but they are desirable qualities
    the system would possess in a perfect world. Ideally, the target dev board would
    also be part of a larger hardware ecosystem, which would enable people to use
    existing hardware they might already have to further explore the concepts in this
    book. A USB port attached to the target MCU would also be great to have—that way,
    we would be able to use a virtual comm port to output debug instead of using only
    the debugger. Finally, in [Chapter 16](19872ca7-d0fe-44e7-a4fc-1bdbfda87e59.xhtml),* Multi-Processor
    and Multi-Core Systems*, we will look at a brief introduction and a few tips on
    developing our board with multiple CPUs. Although this topic is deserving of its
    own book (many have already been written from an architectural perspective), it
    would be nice to have some code that we could put into action on actual hardware.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the dev board
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Alright—we now know what we''re looking for, so let''s get started! As mentioned
    before, distributor websites can be a great place to start because they offer
    excellent parametric search capabilities. If you''re a hardware person, using
    the same search engine will reduce the amount of time spent hunting for parts.
    Of course, this approach isn''t perfect, so if there''s a really specific part
    you''re looking for, you might be better off going directly to your favourite
    manufacturer''s site and searching there instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8fe693bd-e9ad-4345-93f0-a825f36f5bf7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s an example of the steps we''ve used to narrow down our search using
    a popular distributor in the United States, DigiKey:'
  prefs: []
  type: TYPE_NORMAL
- en: From DigiKey's home page, [https://www.digikey.com/](https://www.digikey.com/),
    we've started with a search for STM32 and selected eval boards for the MCUs and
    DSPs from the selections.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We're only interested in parts that are currently available (not obsolete).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The dev kit must also be in stock.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here are the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fb4cf50a-5fca-4f68-8721-dd1c90cdc286.png)'
  prefs: []
  type: TYPE_IMG
- en: From our knowledge of the STM32 product line, the MCUs with memory protection
    units have been selected. Currently, this criteria provides 73 available dev platforms,
    ranging from USD 9-550—quite a range. We have most of the hard requirements covered
    already—with the exception of the on-board indicator, which isn't likely to show
    up in a search. Let's see if we can't narrow the field a bit more by including
    some of the *desirements* as well.
  prefs: []
  type: TYPE_NORMAL
- en: STM refers to their micro-processors as micro-processor units (MPU), which has
    created an overloaded term and some ambiguity when also talking about memory protection
    units (MPU). You'll likely run into both uses of this acronym when browsing websites
    and documentation.
  prefs: []
  type: TYPE_NORMAL
- en: If we're looking for multiple cores, then the STM32H7 and STM32MP1 lines are
    valid options. It turns out there are discovery boards with these parts available
    at a relatively reasonable cost (for what they include) of USD 80, but we're ideally
    looking for hardware closer to the USD 20 range—let's not let the desirements
    interfere with the hard requirements!
  prefs: []
  type: TYPE_NORMAL
- en: 'Narrowing the focus to only the processors that don''t violate the pricing
    requirement of < USD 50 leads us to the STM Nucleo line of dev boards. All of
    the Nucleo line is mBed- compatible, which will allow the use of that entire ecosystem,
    should we choose to use it. The other realization that STM had with Nucleo was
    it was a good idea to support existing popular platforms—so, in addition to breaking
    out nearly all of the more relevant MCU pins on a proprietary header, Nucleo boards
    also provide various Arduino-style headers. All Nucleo boards also include an
    ST-Link on-board programmer, some of which can be re-flashed to appear identical
    to a SEGGER J-Link , which is a *huge* plus and will eliminate the need to purchase
    an additional piece of hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Manufacturer ****part number** | **Description** | **Relevant features**
    |'
  prefs: []
  type: TYPE_TB
- en: '| NUCLEO-L432KC | Nucl32 platform | Cortex-M4, one user LED, user USB, Arduino
    Nano v3 compatible, NOT listed as SEGGER J-Link on-board compatible |'
  prefs: []
  type: TYPE_TB
- en: '| NUCLEO-F401RE | Nucleo64 platform  | Cortex-M4, one user LED, user USB via
    re-enumeration, Arduino Uno v3 headers, SEGGER J-Link on-board compatible |'
  prefs: []
  type: TYPE_TB
- en: '| NUCLEO-L4R5ZI | Nucleo144 platform | Cortex-M4, three user LEDs, a dedicated
    user USB OTB, ST Morpho, Arduino Uno v3 headers, SEGGER J-Link on-board compatible
    |'
  prefs: []
  type: TYPE_TB
- en: '| **NUCLEO-F767ZI** | **Nucleo144 platform** | **Cortex-M7, three user LEDs,
    a dedicated user USB, Ethernet, Arduino Uno v3 headers, SEGGER J-Link on-board
    compatible** |'
  prefs: []
  type: TYPE_TB
- en: 'Our target platform will be the Nucleo-F767ZI, which incorporates the widest
    range of connectivity and includes the most flexibility for debugging. We''ll
    cover re-flashing the on-board ST-Link to use SEGGER J-Link firmware in [Chapter
    6](699daa80-06ae-4acc-8b93-a81af2eb774b.xhtml), *Debugging Tools for Real-Time
    Systems*. The three user LEDs will make communicating firmware status feedback
    very simple since no additional interfaces will need to be configured. Built-in
    Ethernet allows the development of networked applications. It would have been
    convenient to have a multi-core MCU for our target platform, but none were available
    that met our cost requirement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dd45871d-0ac9-4599-afcd-f8e59b5e855b.png)'
  prefs: []
  type: TYPE_IMG
- en: Although there are many options when selecting an MCU or development board,
    it doesn't need to be a daunting process, especially when you know your requirements
    and the trade-offs to be made.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has touched on many considerations for selecting an appropriate
    MCU and we've explained the selection process by going through the trade-offs
    made when selecting the dev board used in this book. You should now understand
    the importance of MCU selection and have enough background to begin researching
    and selecting MCUs for your projects. If you're part of a multi-disciplinary team,
    you'll be better positioned to converse with your peers on the trade-offs of using
    various MCUs for a given application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll go through a similar exercise, comparing various
    classes of **Integrated Development Environments** (**IDEs**) and choose a suitable
    IDE to code the exercises you'll find in this book, starting with [Chapter 7](2fa909fe-91a6-48c1-8802-8aa767100b8f.xhtml),
    *The FreeRTOS Scheduler*.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter''s material. You will find the answers in the *Assessments*
    section of the Appendix:'
  prefs: []
  type: TYPE_NORMAL
- en: Why is it important for firmware engineers to be knowledgeable about the MCU
    they are programming on?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When selecting an MCU for performance, clock speed is the only factor at play:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Today's MCUs contain many different pieces of hardware in addition to the CPU.
    What is the general name given to these pieces of hardware?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Batteries
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardware peripherals
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Bugs
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Name one advantage of using a *platform* approach for development.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name one advantage of using a fully featured evaluation board for development.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name two significant device characteristics when designing low-power applications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why was an inexpensive development board chosen for this book?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'AN4839: An STM application note regarding the level 1 cache system on STM32F7
    devices: [https://www.st.com/content/ccc/resource/technical/document/application_note/group0/08/dd/25/9c/4d/83/43/12/DM00272913/files/DM00272913.pdf/jcr:content/translations/en.DM00272913.pdf](https://www.st.com/content/ccc/resource/technical/document/application_note/group0/08/dd/25/9c/4d/83/43/12/DM00272913/files/DM00272913.pdf/jcr:content/translations/en.DM00272913.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More information regarding SEGGER ST-Link on-board: [https://www.segger.com/products/debug-probes/j-link/models/other-j-links/st-link-on-board/](https://www.segger.com/products/debug-probes/j-link/models/other-j-links/st-link-on-board/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
