- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Implementing Patterns and Idioms
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现模式和惯用语
- en: Design patterns are general reusable solutions that can be applied to common
    problems that appear in software development. Idioms are patterns, algorithms,
    or ways to structure the code in one or more programming languages. A great number
    of books has been written on design patterns. This chapter is not intended to
    reiterate them, but rather to show how to implement several useful patterns and
    idioms, with a focus on readability, performance, and robustness, in terms of
    modern C++.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式是一般可重用的解决方案，可以应用于软件开发中出现的常见问题。惯用法是模式、算法或结构代码的一种或多种编程语言的方式。关于设计模式已经编写了大量的书籍。本章的目的不是重复它们，而是展示如何实现几个有用的模式和惯用法，重点关注可读性、性能和健壮性，从现代C++的角度出发。
- en: 'The recipes included in this chapter are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节包含的食谱如下：
- en: Avoiding repetitive `if-else` statements in factory patterns
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免在工厂模式中重复使用`if-else`语句
- en: Implementing the pimpl idiom
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现pimpl惯用法
- en: Implementing the named parameter idiom
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现命名参数习语
- en: Separating interfaces and implementations with the non-virtual interface idiom
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用非虚拟接口惯用语分离接口和实现
- en: Handling friendship with the attorney-client idiom
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用律师-客户习语处理友谊
- en: Static polymorphism with the curiously recurring template pattern
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 奇异重复模板模式下的静态多态
- en: Adding functionality to classes with mixins
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用混入（mixins）向类添加功能
- en: Handling unrelated types generically with the type erasure idiom
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类型擦除惯用语泛型处理无关类型
- en: Implementing a thread-safe singleton
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现线程安全的单例
- en: The first recipe of this chapter presents a simple mechanism for avoiding repetitive
    `if-else` statements. Let’s explore how this mechanism works.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第一个菜谱介绍了一种避免重复`if-else`语句的简单机制。让我们来探究这个机制是如何工作的。
- en: Avoiding repetitive if-else statements in factory patterns
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免在工厂模式中重复使用if-else语句
- en: It is often the case that we end up writing repetitive `if...else` statements
    (or an equivalent `switch` statement) that do similar things, often with little
    variation and often done by copying and pasting with small changes. As the number
    of alternative conditions increases, the code becomes both hard to read and hard
    to maintain. Repetitive `if...else` statements can be replaced with various techniques,
    such as polymorphism. In this recipe, we will see how to avoid `if...else` statements
    in factory patterns (a factory is a function or object that is used to create
    other objects) using a map of functions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，我们会陷入编写重复的`if...else`语句（或等效的`switch`语句），这些语句执行类似的事情，通常变化很小，而且常常是通过复制粘贴并做些小改动来完成的。随着可选条件的数量增加，代码既难以阅读也难以维护。重复的`if...else`语句可以用各种技术来替换，例如多态。在这个菜谱中，我们将看到如何使用函数映射来避免在工厂模式（工厂是一个用于创建其他对象的函数或对象）中使用`if...else`语句。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'In this recipe, we will consider the following problem: building a system that
    can handle image files in various formats, such as bitmap, PNG, JPG, and so on.
    Obviously, the details are beyond the scope of this recipe; the part we are concerned
    with is creating objects that handle various image formats. For this, we will
    consider the following hierarchy of classes:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将考虑以下问题：构建一个能够处理各种格式图像文件的系统，例如位图、PNG、JPG等等。显然，这些细节超出了本菜谱的范围；我们关注的部分是创建处理各种图像格式的对象。为此，我们将考虑以下类的层次结构：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'On the other hand, we’ll define an interface for a factory class that can create
    instances of the aforementioned classes, as well as a typical implementation using
    `if...else` statements:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们将定义一个用于工厂类的接口，该接口可以创建上述类的实例，以及使用`if...else`语句的典型实现：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The goal of this recipe is to see how this implementation can be refactored
    to avoid repetitive `if...else` statements.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的目标是查看如何重构此实现以避免重复的`if...else`语句。
- en: How to do it...
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Perform the following steps to refactor the factory shown earlier to avoid
    using `if...else` statements:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以重构前面展示的工厂，避免使用`if...else`语句：
- en: 'Implement the factory interface:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现工厂接口：
- en: '[PRE2]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Define a map where the key is the type of objects to create and the value is
    a function that creates objects:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个映射，其中键是要创建的对象类型，值是创建对象的函数：
- en: '[PRE3]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To create an object, look up the object type in the map and, if it is found,
    use the associated function to create a new instance of the type:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个对象，请在映射中查找对象类型，如果找到，则使用关联的函数来创建该类型的新实例：
- en: '[PRE4]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The repetitive `if...else` statements in the first implementation are very
    similar – they check the value of the `type` parameter and create an instance
    of the appropriate `Image` class. If the argument to check was an integral type
    (for instance, an enumeration type), the sequence of `if...else` statements could
    have also been written in the form of a `switch` statement. That code can be used
    like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第一实现中的重复`if...else`语句非常相似——它们检查`type`参数的值并创建适当的`Image`类的实例。如果检查的参数是整型（例如枚举类型），`if...else`语句的序列也可以写成`switch`语句的形式。这段代码可以这样使用：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Regardless of whether the implementation was using `if...else` statements or
    a `switch`, refactoring to avoid repetitive checks is relatively simple. In the
    refactored code, we used a map that has the key type `std::string` representing
    the type, that is, the name of the image format. The value is an `std::function<std::unique_ptr<Image>()>`.
    This is a wrapper for a function that takes no arguments and returns an `std::unique_ptr<Image>`
    (a `unique_ptr` of a derived class is implicitly converted to a `unique_ptr` of
    a base class).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 无论实现是使用`if...else`语句还是`switch`，重构以避免重复检查相对简单。在重构的代码中，我们使用了一个键类型为`std::string`的映射，表示类型，即图像格式的名称。值是一个`std::function<std::unique_ptr<Image>()>`。这是一个用于无参数且返回`std::unique_ptr<Image>`（派生类的`unique_ptr`隐式转换为基类的`unique_ptr`）的函数包装器。
- en: Now that we have this map of functions that create objects, the actual implementation
    of the factory is much simpler; check the type of the object to be created in
    the map and, if present, use the associated value from the map as the actual function
    to create the object, or return `nullptr` if the object type is not present in
    the map.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了创建对象的函数映射，工厂的实际实现就简单多了；在映射中检查要创建的对象的类型，如果存在，则使用映射中关联的值作为创建对象的实际函数，如果映射中不存在该对象类型，则返回`nullptr`。
- en: This refactoring is transparent for the client code, as there are no changes
    in the way clients use the factory. On the other hand, this approach does require
    more memory to handle the static map, which, for some classes of applications,
    such as IoT, might be an important aspect. The example presented here is relatively
    simple because the purpose is to demonstrate the concept. In real-world code,
    it might be necessary to create objects differently, such as using a different
    number of arguments and different types of arguments. However, this is not specific
    to the refactored implementation, and the solution with the `if...else`/`switch`
    statement needs to account for that too. Therefore, in practice, the solution
    to this problem that worked with `if...else` statements should also work with
    the map.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这种重构对客户端代码来说是透明的，因为客户端使用工厂的方式没有变化。另一方面，这种方法确实需要更多的内存来处理静态映射，对于某些应用程序类别，如物联网（IoT），这可能是一个重要的方面。这里提供的示例相对简单，因为目的是演示这个概念。在实际代码中，可能需要以不同的方式创建对象，例如使用不同数量的参数和不同类型的参数。然而，这并不特定于重构的实现，使用`if...else`/`switch`语句的解决方案也需要考虑这一点。因此，在实践中，使用`if...else`语句解决问题的解决方案也应该适用于映射。
- en: There’s more...
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In the preceding implementation, the map is a local static to the virtual function,
    but it can also be a member of the class or even a global. The following implementation
    has the map defined as a static member of the class. The objects are not created
    based on the format name, but on the type information, as returned by the `typeid`
    operator:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的实现中，映射是一个属于虚拟函数的局部静态变量，但它也可以是类的成员，甚至是一个全局变量。在下面的实现中，映射被定义为类的静态成员。对象不是基于格式名称创建的，而是基于类型信息创建的，这是由`typeid`运算符返回的：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In this case, the client code is slightly different, because instead of passing
    a name representing the type to create, such as PNG, we pass the value returned
    by the `typeid` operator, such as `typeid(PngImage)`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，客户端代码略有不同，因为我们不是传递一个表示要创建的类型名称，例如PNG，而是传递`typeid`运算符返回的值，例如`typeid(PngImage)`：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This alternative is arguably more robust because the map keys are not strings,
    which could be more prone to errors. This recipe proposes a pattern as the solution
    to a common problem, and not an actual implementation. As in the case of most
    patterns, there are different ways they can be implemented, and it is up to you
    to pick the one that is the most suitable for each context.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这种替代方案可以说是更健壮的，因为映射键不是字符串，这可能会更容易出错。本食谱提出了一种模式作为解决常见问题的方案，而不是实际的实现。正如大多数模式的情况一样，它们有不同的实现方式，取决于你选择最适合每个上下文的那一种。
- en: See also
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Implementing the pimpl idiom,* to learn a technique that enables the separation
    of the implementation details from an interface'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实现pimpl习语*，学习一种能够将实现细节与接口分离的技术'
- en: '*Chapter 9**, Using unique_ptr to uniquely own a memory resource*, to learn
    about the `std::unique_ptr` class, which represents a smart pointer that owns
    and manages another object or array of objects allocated on the heap'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第9章，使用unique_ptr唯一拥有内存资源*，了解`std::unique_ptr`类，它代表一个智能指针，它拥有并管理在堆上分配的另一个对象或对象数组'
- en: Implementing the pimpl idiom
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现pimpl习语
- en: '**pimpl** stands for **pointer to implementation** (also known as the **Cheshire
    cat idiom** or the **compiler firewall idiom**) and is an opaque pointer technique
    that enables the separation of the implementation details from an interface. This
    has the advantage that it enables changing the implementation without modifying
    the interface and, therefore, avoiding the need to recompile the code that is
    using the interface. This has the potential of making libraries using the pimpl
    idiom on their ABIs backward-compatible with older versions when only implementation
    details change. In this recipe, we will see how to implement the pimpl idiom using
    modern C++ features.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**pimpl**代表**指向实现**（也称为**查理猫习语**或**编译器防火墙习语**）是一种不透明的指针技术，它能够将实现细节与接口分离。这种技术的优点是它允许在不修改接口的情况下更改实现，因此避免了需要重新编译使用该接口的代码。这使得使用pimpl习语的库在实现细节更改时，其ABIs与旧版本向后兼容。在本食谱中，我们将看到如何使用现代C++特性实现pimpl习语。'
- en: The term **ABI** stands for **Application Binary Interface**, and refers to
    the interface between two binary modules. Typically, one such module is a library
    or operating system, and the other is a program executed by a user.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**ABI**这个术语代表**应用程序二进制接口**，指的是两个二进制模块之间的接口。通常，其中一个模块是库或操作系统，另一个是用户执行的程序。'
- en: Getting ready
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The reader is expected to be familiar with smart pointers and `std::string_view`,
    both of which were discussed in previous chapters of this book.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 读者应熟悉智能指针和`std::string_view`，这两者都在本书的前几章中讨论过。
- en: 'To demonstrate the pimpl idiom in a practical manner, we will consider the
    following class, which we will then refactor following the pimpl pattern:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以实际的方式演示pimpl习语，我们将考虑以下类，然后我们将根据pimpl模式对其进行重构：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This class represents a control that has properties such as text, size, and
    visibility. Every time these properties are changed, the control is redrawn. In
    this mocked implementation, drawing means printing the value of the properties
    to the console.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类表示具有文本、大小和可见性等属性的控件。每次这些属性发生变化时，控件都会重新绘制。在这个模拟实现中，绘制意味着将属性的值打印到控制台。
- en: How to do it...
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Take the following steps to implement the pimpl idiom, exemplified here by
    refactoring the `control` class shown earlier:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现pimpl习语，以下以重构前面展示的`control`类为例：
- en: Put all private members, both data and functions, into a separate class. We
    will call this the **pimpl class** and the original class the **public class**.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有私有成员，包括数据和函数，放入一个单独的类中。我们将这个类称为**pimpl类**，而原始类称为**公共类**。
- en: 'In the header file of the public class, put a forward declaration to the pimpl
    class:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在公共类的头文件中，对pimpl类进行前置声明：
- en: '[PRE9]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the public class definition, declare a pointer to the pimpl class using
    `unique_ptr`. This should be the only private data member of the class:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在公共类定义中，使用`unique_ptr`声明对pimpl类的指针。这应该是类的唯一私有数据成员：
- en: '[PRE10]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Put the pimpl class definition in the source file of the public class. The
    pimpl class mirrors the public interface of the public class:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将pimpl类定义放在公共类的源文件中。pimpl类反映了公共类的公共接口：
- en: '[PRE11]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The pimpl class is instantiated in the constructor of the public class:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: pimpl类在公共类的构造函数中被实例化：
- en: '[PRE12]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Public class member functions call the corresponding member functions of the
    pimpl class:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 公共类成员函数调用pimpl类的相应成员函数：
- en: '[PRE13]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works...
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The pimpl idiom enables hiding the internal implementation of a class from
    the clients of the library or module the class is part of. This provides several
    benefits:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: pimpl习语允许隐藏类内部实现，从而为库或模块的客户端提供以下好处：
- en: A clean interface for a class that its clients see.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于其客户端可见的类，提供一个干净的接口。
- en: Changes in the internal implementation do not affect the public interface, which
    enables binary backward-compatibility for newer versions of a library (when the
    public interface remains unchanged).
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部实现的变化不会影响公共接口，这使库的新版本（当公共接口保持不变时）具有二进制向后兼容性。
- en: Clients of a class that use this idiom do not need to be recompiled when changes
    to the internal implementation occur. This leads to shorter build times.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当内部实现发生变化时，使用这种习语的类的客户端无需重新编译。这导致构建时间更短。
- en: The header file does not need to include the headers for the types and functions
    used in the private implementation. This, again, leads to shorter build times.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 头文件不需要包含私有实现中使用的类型和函数的头文件。这同样导致构建时间更短。
- en: 'The benefits mentioned above do not come for free; there are also several drawbacks
    that need to be mentioned:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 提到的上述好处并非免费获得；也存在一些需要提到的缺点：
- en: There is more code to write and maintain.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要编写和维护的代码更多。
- en: The code can arguably be less readable, as there is a level of indirection and
    all the implementation details need to be looked up in the other files. In this
    recipe, the pimpl class definition was provided in the source file of the public
    class, but in practice, it could be in separate files.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码的可读性可能较低，因为存在一定程度的间接引用，并且所有实现细节都需要在其他文件中查找。在本例中，pimpl类定义在公共类的源文件中提供，但在实践中，它可能位于单独的文件中。
- en: There is a slight runtime overhead because of the level of indirection from
    the public class to the pimpl class, but in practice, this is rarely significant.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于从公共类到pimpl类的间接引用级别，存在轻微的运行时开销，但在实践中，这很少是显著的。
- en: This approach does not work with private and protected members because these
    have to be available to the derived classes.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种方法不适用于私有和受保护的成员，因为这些成员必须对派生类可用。
- en: This approach does not work with the private virtual functions, which have to
    appear in the class, either because they override functions from a base class
    or have to be available for overriding in a derived class.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种方法不适用于私有虚拟函数，这些函数必须出现在类中，要么是因为它们覆盖了基类的函数，要么是因为它们必须对派生类中的覆盖可用。
- en: As a rule of thumb, when implementing the pimpl idiom, always put all the private
    member data and functions, except for the virtual ones, in the pimpl class and
    leave the protected data members and functions and all the private virtual functions
    in the public class.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 作为经验法则，在实现pimpl习语时，始终将所有私有成员数据和函数（除了虚拟函数外）放在pimpl类中，并将受保护的成员数据和函数以及所有私有虚拟函数留在公共类中。
- en: In the example in this recipe, the `control_pimpl` class is basically identical
    to the original `control` class. In practice, where classes are larger and have
    virtual functions and protected members and both functions and data, the pimpl
    class is not a complete equivalent of how the class would have looked like if
    it was not pimpled. Also, in practice, the pimpl class may require a pointer to
    the public class in order to call members that were not moved into the pimpl class.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，`control_pimpl`类基本上与原始的`control`类相同。在实践中，当类更大，具有虚拟函数和受保护的成员以及函数和数据时，pimpl类不是类未进行pimpl化时的完整等价物。此外，在实践中，pimpl类可能需要一个指向公共类的指针，以便调用未移动到pimpl类的成员。
- en: 'Concerning the implementation of the refactored `control` class, the pointer
    to the `control_pimpl` object is managed by a `unique_ptr`. In the declaration
    of this pointer, we have used a custom deleter:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 关于重构后的`control`类的实现，`control_pimpl`对象的指针由`unique_ptr`管理。在声明此指针时，我们使用了自定义的删除器：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The reason for this is that the `control` class has a destructor implicitly
    defined by the compiler, at a point where the `control_pimpl` type is still incomplete
    (that is, in the header). This would result in an error with `unique_ptr`, which
    cannot delete an incomplete type. This problem can be solved in two ways:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 原因在于`control`类在`control_pimpl`类型仍然不完整（即在头文件中）的地方被编译器隐式定义了析构函数。这会导致`unique_ptr`出错，因为`unique_ptr`不能删除一个不完整类型。这个问题可以通过两种方式解决：
- en: Provide a user-defined destructor for the `control` class that is explicitly
    implemented (even if declared as `default`) after the complete definition of the
    `control_pimpl` class is available.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为`control`类提供一个用户定义的析构函数，该析构函数在`control_pimpl`类的完整定义可用后显式实现（即使声明为`default`）。
- en: Provide a custom deleter for the `unique_ptr`, as we did in this example.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为`unique_ptr`提供一个自定义的删除器，就像在这个例子中所做的那样。
- en: There’s more...
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The original `control` class was both copyable and movable:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的`control`类既可复制也可移动：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The refactored `control` class is only movable, not copyable. The following
    code shows an implementation of the `control` class that is both copyable and
    movable:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 重新设计的`control`类仅可移动，不可复制。以下代码展示了实现既可复制也可移动的`control`类的示例：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The class `control_copyable` is both copyable and movable, but to make it so,
    we provided the copy constructor and copy assignment operator and both the move
    constructor and move assignment operator. The latter ones can be defaulted, but
    the former ones were explicitly implemented to create a new `control_pimpl` object
    from the object that it is copied from.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`control_copyable`类既可复制也可移动，但为了使其如此，我们提供了复制构造函数和复制赋值运算符，以及移动构造函数和移动赋值运算符。后两者可以省略，但前两者被显式实现，以便从被复制的对象中创建一个新的`control_pimpl`对象。'
- en: See also
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Chapter 9,* *Using unique_ptr to uniquely own a memory resource*, to learn
    about the `std::unique_ptr` class, which represents a smart pointer that owns
    and manages another object or array of objects allocated on the heap'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第9章*，*使用`unique_ptr`唯一拥有内存资源*，了解`std::unique_ptr`类，它表示一个智能指针，它拥有并管理在堆上分配的另一个对象或对象数组'
- en: Implementing the named parameter idiom
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现命名参数惯例
- en: C++ supports only positional parameters, which means arguments are passed to
    a function based on the parameter’s position. Other languages also support named
    parameters – that is, they specify parameter names when making a call and invoking
    arguments. This is particularly useful with parameters that have default values.
    A function may have parameters with default values, although they always appear
    after all the non-defaulted parameters.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: C++只支持位置参数，这意味着参数是根据参数的位置传递给函数的。其他语言也支持命名参数——即在调用时指定参数名称并调用参数。这对于具有默认值的参数特别有用。一个函数可能有具有默认值的参数，尽管它们总是出现在所有非默认参数之后。
- en: However, if you want to provide values for only some of the defaulted parameters,
    there is no way to do this without providing arguments for the parameters that
    are positioned before them in the function parameters list.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您只想为一些默认参数提供值，没有提供在函数参数列表中位于它们之前的参数的参数，就无法做到这一点。
- en: A technique called the **named parameter idiom** provides a method to emulate
    named parameters and help solve this problem. We will explore this technique in
    this recipe.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一种称为**命名参数惯例**的技术提供了一种模拟命名参数并帮助解决这个问题的方法。我们将在本食谱中探讨这项技术。
- en: Getting ready
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To exemplify the named parameter idiom, we will use the `control` class shown
    in the following code snippet:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明命名参数惯例，我们将使用以下代码片段中的`control`类：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `control` class represents a visual control, such as a button or an input,
    and has properties such as numerical identifier, text, size, and visibility. These
    are provided to the constructor and, except for the ID, all the others have default
    values. In practice, such a class would have many more properties, such as text
    brush, background brush, border style, font size, font family, and many others.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`control`类表示一个视觉控件，如按钮或输入，具有数值标识符、文本、大小和可见性等属性。这些属性被提供给构造函数，除了ID之外，所有其他属性都有默认值。实际上，此类会有更多属性，如文本画笔、背景画笔、边框样式、字体大小、字体家族等。'
- en: How to do it...
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To implement the named parameter idiom for a function (usually with many default
    parameters), do the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要为函数实现命名参数惯例（通常具有许多默认参数），请执行以下操作：
- en: 'Create a class to wrap the parameters of the function:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个类来封装函数的参数：
- en: '[PRE18]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The class or function that needs to access these properties could be declared
    as `friend` to avoid writing getters:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要访问这些属性的类或函数可以声明为`friend`以避免编写getter：
- en: '[PRE19]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Every positional parameter of the original function that does not have a default
    value should become a positional parameter, without a default value in the constructor
    of the class:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原始函数的每个没有默认值的定位参数都应该成为没有默认值的定位参数，在类的构造函数中：
- en: '[PRE20]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For every positional parameter of the original function that has a default
    value, there should be a function (with the same name) that sets the value internally
    and returns a reference to the class:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于原始函数的每个具有默认值的定位参数，应该有一个具有相同名称的函数，该函数在内部设置值并返回对类的引用：
- en: '[PRE21]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The original function should be modified, or an overload should be provided,
    to take an argument of the new class from which the property values will be read:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原始函数应该被修改，或者提供一个重载，以接受来自新类的新参数，从该类中读取属性值：
- en: '[PRE22]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If we put all that together, the result is the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将所有这些放在一起，结果如下：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How it works...
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The initial `control` class had a constructor with many parameters. In real-world
    code, you can find examples like this where the number of parameters is much higher.
    A possible solution, often found in practice, is to group common Boolean type
    properties in bit flags, which could be passed together as a single integral argument
    (an example could be the border style for a control that defines the position
    where the border should be visible: top, bottom, left, right, or any combination
    of these four). Creating a `control` object with the initial implementation is
    done like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 初始的`control`类有一个带有许多参数的构造函数。在实际代码中，你可以找到类似这样的例子，其中参数的数量要高得多。一个可能的解决方案，通常在实践中找到，是将常见的布尔类型属性分组在位标志中，可以作为一个单独的整型参数一起传递（一个例子可以是控制器的边框样式，它定义了边框应该可见的位置：顶部、底部、左侧、右侧，或这些四个位置的任意组合）。使用初始实现创建`control`对象的方式如下：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The named parameter idiom has the advantage that it allows you to specify values
    only for the parameters that you want, in any order, using a name, which is much
    more intuitive than a fixed, positional order.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 命名参数习语的优势在于，它允许你使用名称指定你想要的参数值，顺序不限，这比固定的定位顺序更加直观。
- en: Although there isn’t a single strategy for implementing the idiom, the example
    in this recipe is rather typical. The properties of the `control` class, provided
    as parameters in the constructor, have been put into a separate class, called
    `control_properties`, that declares the `control` class as a friend class to allow
    it to access its private data members without providing getters. This has the
    side effect that it limits the use of `control_properties` outside the `control`
    class. The non-optional parameters of the constructor of the `control` class are
    also non-optional parameters of the `control_properties` constructor. For all
    the other parameters with default values, the `control_properties` class defines
    a function with a relevant name that simply sets the data member to the provided
    argument, and then returns a reference to `control_properties`. This enables the
    client to chain calls to these functions in any order.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然没有单一的策略来实现习语，但本食谱中的示例相当典型。`control`类的属性，作为构造函数中的参数提供，已被放入一个单独的类中，称为`control_properties`，该类将`control`类声明为友元类，以允许它访问其私有数据成员而不提供getter。这有一个副作用，即限制了`control_properties`在`control`类之外的用途。`control`类构造函数的非可选参数也是`control_properties`构造函数的非可选参数。对于所有其他具有默认值的参数，`control_properties`类定义了一个具有相关名称的函数，该函数简单地设置数据成员为提供的参数，然后返回对`control_properties`的引用。这使得客户端可以以任何顺序链式调用这些函数。
- en: The constructor of the control class has been replaced with a new one that has
    a single parameter, a constant reference to a `control_properties` object, whose
    data members are copied into the `control` object’s data members.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 控制类构造函数已被替换为一个新的构造函数，它只有一个参数，即对`control_properties`对象的常量引用，其数据成员被复制到`control`对象的数据成员中。
- en: 'Creating a `control` object with the named parameter idiom implemented in this
    manner is done as in the following snippet:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式实现命名参数习语的`control`对象创建，如下代码片段所示：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: See also
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Separating interfaces and implementations with the non-virtual interface idiom*,
    to explore an idiom that promotes the separation of concerns of interfaces and
    implementations by making (public) interfaces non-virtual and virtual functions
    private'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用非虚接口惯用法来分离接口和实现*，探索一个通过使（公共）接口非虚和虚函数私有来促进接口和实现关注点分离的惯用法'
- en: '*Handling friendship with the attorney-client idiom*, to learn about a simple
    mechanism to restrict friends’ access to only designated, private members of a
    class'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用律师-客户惯用法处理友谊*，了解一个简单的机制来限制朋友对类中指定、私有成员的访问'
- en: Separating interfaces and implementations with the non-virtual interface idiom
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用非虚接口惯用法来分离接口和实现
- en: Virtual functions provide specialization points for a class by allowing derived
    classes to modify implementations from a base class. When a derived class object
    is handled through a pointer or a reference to a base class, calls to overridden
    virtual functions end up invoking the overridden implementation from the derived
    class. On the other hand, customization is an implementation detail, and a good
    design separates interfaces from implementation.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 虚函数通过允许派生类修改从基类继承的实现，为类提供了特殊化的点。当一个派生类对象通过基类指针或引用来处理时，对重写的虚函数的调用最终会调用派生类中的重写实现。另一方面，定制是实现细节，良好的设计将接口与实现分离。
- en: The **non-virtual interface idiom**, proposed by Herb Sutter in an article about
    virtuality in the *C/C++ Users Journal*, promotes the separation of concerns of
    interfaces and implementations by making (public) interfaces non-virtual and virtual
    functions private.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Herb Sutter 在 *C/C++ Users Journal* 关于虚函数的文章中提出的 **非虚接口惯用法**，通过使（公共）接口非虚和虚函数私有，促进了接口和实现的关注点分离。
- en: Public virtual interfaces prevent a class from enforcing pre- and post-conditions
    on its interface. Users expecting an instance of a base class do not have the
    guarantee that the expected behavior of a public virtual method is delivered,
    since it can be overridden in a derived class. This idiom helps enforce the promised
    contract of an interface.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 公共虚接口阻止类在其接口上强制执行前条件和后条件。期望基类实例的用户不能保证公共虚方法会提供预期的行为，因为它可以在派生类中被重写。这个惯用法有助于强制执行接口的承诺合同。
- en: Getting ready
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The reader should be familiar with aspects related to virtual functions, such
    as defining and overriding virtual functions, abstract classes, and pure specifiers.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 读者应该熟悉与虚函数相关的方面，例如定义和重写虚函数、抽象类和纯指定符。
- en: How to do it...
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Implementing this idiom requires following several simple design guidelines,
    formulated by Herb Sutter in the *C/C++ Users Journal*, 19(9), September 2001:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这个惯用法需要遵循几个简单的设计准则，这些准则由 Herb Sutter 在 *C/C++ Users Journal*，19(9)，2001 年
    9 月提出：
- en: Make (public) interfaces non-virtual.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将（公共）接口设为非虚。
- en: Make virtual functions private.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将虚函数设为私有。
- en: Make virtual functions protected only if the base implementation has to be called
    from a derived class.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有当基类实现必须从派生类中调用时，才将虚函数设为保护。
- en: Make the base class destructor either public and virtual or protected and nonvirtual.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将基类析构函数设为公共和虚的或保护和非虚的。
- en: 'The following example of a simple hierarchy of controls abides by all these
    four guidelines:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单的控件层次结构的示例，遵循所有这四个准则：
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How it works...
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The NVI idiom uses the **template method** design pattern, which allows derived
    classes to customize parts (that is, steps) of a base class functionality (that
    is, an algorithm). This is done by splitting the overall algorithm into smaller
    parts, each of them implemented by a virtual function. The base class may provide,
    or not, a default implementation, and the derived classes could override them
    while maintaining the overall structure and meaning of the algorithm.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: NVI 惯用法使用 **模板方法** 设计模式，允许派生类定制基类功能（即算法）的部分（即步骤）。这是通过将整体算法拆分为更小的部分来实现的，每个部分都由一个虚函数实现。基类可以提供或不需要默认实现，派生类可以覆盖它们，同时保持算法的整体结构和意义。
- en: 'The core principle of the NVI idiom is that virtual functions should not be
    public; they should be either private or protected, in case the base class implementation
    could be called from a derived class. The interface of a class, the public part
    accessible to its clients, should be comprised exclusively of nonvirtual functions.
    This provides several advantages:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: NVI 习语的核心理念是虚拟函数不应该公开；它们应该是私有或受保护的，以防基类实现可以从派生类中调用。类的接口，其客户端可以访问的公共部分，应该仅由非虚拟函数组成。这提供了几个优点：
- en: It separates the interface from the details of implementation that are no longer
    exposed to the client.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将接口与不再暴露给客户端的实现细节分离。
- en: It enables changing the details of the implementation without altering the public
    interface and without requiring changes to the client code, therefore making base
    classes more robust.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使得在不改变公共接口且不需要修改客户端代码的情况下更改实现细节成为可能，因此使基类更加健壮。
- en: It allows a class to have sole control of its interface. If the public interface
    contains virtual methods, a derived class can alter the promised functionality,
    and therefore, the class cannot ensure its preconditions and postconditions. When
    none of the virtual methods (except for the destructor) are accessible to its
    clients, the class can enforce pre- and post-conditions on its interface.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许一个类对其接口拥有完全控制权。如果公共接口包含虚拟方法，派生类可以改变承诺的功能，因此，类不能确保其前置条件和后置条件。当没有虚拟方法（除了析构函数）可供其客户端访问时，类可以在其接口上强制执行前置条件和后置条件。
- en: A special mention of the destructor of a class is required for this idiom. It
    is often stressed that base class destructors should be virtual so that objects
    can be deleted polymorphically (through a pointer or references to a base class).
    Destructing objects polymorphically when the destructor is not virtual incurs
    undefined behavior. However, not all base classes are intended to be deleted polymorphically.
    For those particular cases, the base class destructor should not be virtual. However,
    it should also not be public, but protected.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个习语，需要特别提及类的析构函数。通常强调基类析构函数应该是虚拟的，这样对象就可以通过基类指针或引用进行多态删除。当析构函数不是虚拟的时，进行多态删除对象会导致未定义的行为。然而，并非所有基类都旨在进行多态删除。对于这些特定情况，基类析构函数不应该虚拟，但也应该不是公共的，而是受保护的。
- en: 'The example from the previous section defines a hierarchy of classes representing
    visual controls:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节中的例子定义了一个表示视觉控件的类层次结构：
- en: '`control` is the base class, but there are derived classes, such as `button`
    and `checkbox`, which are a type of button and, therefore, are derived from this
    class.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`control` 是基类，但存在派生类，如 `button` 和 `checkbox`，它们是按钮类型，因此从这个类派生出来。'
- en: The only functionality defined by the `control` class is drawing the controls.
    The `draw()` method is nonvirtual, but it calls two virtual methods, `erase_background()`
    and `paint()`, to implement the two phases of drawing the control.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`control` 类定义的唯一功能是绘制控件。`draw()` 方法是非虚拟的，但它调用了两个虚拟方法，`erase_background()` 和
    `paint()`，以实现绘制控件的两个阶段。'
- en: '`erase_background()` is a protected virtual method because derived classes
    need to call it in their own implementation.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`erase_background()` 是一个受保护的虚拟方法，因为派生类需要在它们自己的实现中调用它。'
- en: '`paint()` is a private pure virtual method. Derived classes must implement
    it, but are not supposed to call a base implementation.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`paint()` 是一个私有的纯虚拟方法。派生类必须实现它，但不应该调用基类实现。'
- en: The destructor of the control class is public and virtual because objects are
    expected to be deleted polymorphically.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控件类的析构函数是公共的且虚拟的，因为预期对象将通过多态删除。
- en: 'An example of using these classes is shown as follows. Instances of these classes
    are managed by smart pointers to the base class:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 下面展示了使用这些类的示例。这些类的实例由基类智能指针管理：
- en: '[PRE27]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output of this program is as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的输出如下：
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The NVI idiom introduces a level of indirection when a public function calls
    a non-public virtual function that does the actual implementation. In the previous
    example, the `draw()` method called several other functions, but in many cases,
    it could be only one call:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: NVI 习语在公共函数调用实际实现的非公共虚拟函数时引入了一层间接性。在先前的例子中，`draw()` 方法调用了几个其他函数，但在许多情况下，可能只需要一个调用：
- en: '[PRE29]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this example, the class `control` has an additional method called `initialize()`
    (the previous content of the class was not shown to keep it simple) that calls
    a single non-public virtual method called `initialize_impl()`, implemented differently
    in each derived class. This does not incur much overhead – if any at all – since
    simple functions like this are most likely inlined by the compiler anyway.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，类`control`有一个额外的名为`initialize()`的方法（为了保持简单，没有显示类的前置内容），它调用一个单独的非公共虚拟方法`initialize_impl()`，该方法在每个派生类中实现不同。这不会产生太多开销——如果有的话——因为像这样的简单函数很可能被编译器内联。
- en: See also
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Chapter 1,* *Use override and final for virtual methods*, to learn how to
    specify that a virtual function overrides another virtual function, as well as
    how to specify that a virtual function cannot be overridden in a derived class'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第一章*，*使用override和final指定虚拟方法*，了解如何指定一个虚拟函数覆盖另一个虚拟函数，以及如何指定在派生类中不能覆盖虚拟函数'
- en: Handling friendship with the attorney-client idiom
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用律师-客户习语处理友元关系
- en: Granting functions and classes access to the non-public parts of a class with
    a friend declaration is usually seen as a sign of bad design, as friendship breaks
    encapsulation and ties classes and functions. Friends, whether they are classes
    or functions, get access to all the private members of a class, although they
    may only need to access parts of it.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用友元声明授予函数和类对类非公共部分的访问权限通常被视为设计不佳的标志，因为友元关系破坏了封装性，并使类和函数之间产生了联系。无论友元是类还是函数，它们都可以访问类的所有私有成员，尽管它们可能只需要访问其中的一部分。
- en: The **attorney-client idiom** provides a simple mechanism to restrict friends
    access to only designated private members of a class.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**律师-客户习语**提供了一个简单的机制，以限制友元对类中仅指定的私有成员的访问。'
- en: Getting ready
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To demonstrate how to implement this idiom, we will consider the following
    classes: `Client`, which has some private member data and functions (the public
    interface is not important here), and `Friend`, which is supposed to access only
    parts of the private details, for instance, `data1` and `action1()`, but has access
    to everything:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何实现这个习语，我们将考虑以下类：`Client`，它具有一些私有成员数据和函数（在这里，公共接口并不重要），以及`Friend`，它应该只访问私有细节的一部分，例如`data1`和`action1()`，但它可以访问一切：
- en: '[PRE30]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: To understand this idiom, you must be familiar with how friendship is declared
    in the C++ language and how it works.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这个习语，你必须熟悉C++语言中如何声明友元关系以及它是如何工作的。
- en: How to do it...
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Take the following steps to restrict a friend’s access to only the private
    members of a class that you need access to:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 采取以下步骤以限制友元对您需要访问的类中私有成员的访问：
- en: 'In the `Client` class, which provides access to all its private members to
    a friend, declare the friendships to an intermediate class, called the `Attorney`
    class:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Client`类中，该类将其所有私有成员对友元类提供访问权限，将友元关系声明给一个中间类，称为`Attorney`类：
- en: '[PRE31]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Create a class that contains only private (inline) functions that access the
    private members of the client. This intermediate class allows the actual friend
    to access its private members:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个只包含私有（内联）函数的类，这些函数访问客户端的私有成员。这个中间类允许实际的友元访问其私有成员：
- en: '[PRE32]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the `Friend` class, access the private members of only the `Client` class
    indirectly through the `Attorney` class:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Friend`类中，通过`Attorney`类间接访问`Client`类的私有成员：
- en: '[PRE33]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: How it works...
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The attorney-client idiom lays out a simple mechanism to restrict access to
    the private members of the client by introducing a middleman, the attorney. Instead
    of providing friendship directly to those using its internal state, the client
    class offers friendship to an attorney, which, in turn, provides access to a restricted
    set of private data or functions of the client. It does so by defining private
    static functions. Usually, these are also inline functions, which avoids any runtime
    overhead due to the level of indirection the attorney class introduces. The client’s
    friend gets access to its private members by actually using the private members
    of the attorney. This idiom is called **attorney-client** because it is similar
    to the way an attorney-client relationship works, with the attorney knowing all
    the secrets of the client, but exposing only some of them to other parties.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 律师-客户惯用法通过引入中间人律师来限制对客户端私有成员的访问。客户端类不是直接向使用其内部状态的人提供友元关系，而是向律师提供友元关系，律师反过来提供对客户端受限的私有数据或函数的访问。它是通过定义私有静态函数来实现的。通常，这些也是内联函数，这避免了律师类引入的间接级别导致的任何运行时开销。客户端的友元通过实际使用律师的私有成员来访问其私有成员。这种惯用法被称为**律师-客户**，因为它与律师-客户关系的方式相似，律师知道客户的所有秘密，但只向其他方透露其中的一部分。
- en: In practice, it might be necessary to create more than one attorney for a client
    class if different friend classes or functions must access different private members.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，如果不同的友元类或函数必须访问客户端类的不同私有成员，可能需要为客户端类创建多个律师。
- en: 'On the other hand, friendship is not inheritable, which means that a class
    or function that is friend to class `B` is not friend with class `D`, which is
    derived from `B`. However, virtual functions overridden in `D` are still accessible
    polymorphically through a pointer or reference to `B` from a friend class. Such
    an example is shown as follows, where calling the `run()` method from `F` prints
    `base` and `derived`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，友元关系是不可继承的，这意味着一个与类`B`为友元的类或函数不会与从`B`派生出的类`D`为友元。然而，`D`中重写的虚拟函数仍然可以通过指向或引用`B`的指针或引用从友元类以多态方式访问。以下是一个示例，其中从`F`调用`run()`方法会打印出`base`和`derived`：
- en: '[PRE34]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: There are always trade-offs to using a design pattern, and this one is no exception.
    There are situations when using this pattern may lead to too much overhead on
    development, testing, and maintenance. However, the pattern could prove extremely
    valuable for some types of applications, such as extensible frameworks.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用设计模式总会有权衡，这个也不例外。在某些情况下，使用此模式可能会导致在开发、测试和维护方面产生过多的开销。然而，对于某些类型的应用程序，例如可扩展框架，该模式可能非常有价值。
- en: See also
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Implementing the pimpl idiom,* to learn a technique that enables the separation
    of the implementation details from an interface'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实现pimpl惯用法*，学习一种能够将实现细节与接口分离的技术'
- en: Static polymorphism with the curiously recurring template pattern
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用奇特重复的模板模式实现静态多态
- en: Polymorphism provides us with the ability to have multiple forms for the same
    interface. Virtual functions allow derived classes to override implementations
    from a base class. They represent the most common elements of a form of polymorphism,
    called **runtime polymorphism**, because the decision to call a particular virtual
    function from the class hierarchy happens at runtime. It is also called **late
    binding**, because the binding between a function call and the invocation of the
    function happens late, during the execution of the program. The opposite of this
    is called **early binding**, **static polymorphism**, or **compile-time polymorphism**
    because it occurs at compile time through functions and operators overloading.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 多态为我们提供了具有相同接口的多种形式的能力。虚拟函数允许派生类覆盖基类中的实现。它们是多态形式中最常见的元素，称为**运行时多态**，因为从类层次结构中调用特定虚拟函数的决定是在运行时发生的。它也称为**后期绑定**，因为函数调用与函数调用的绑定是在程序执行期间较晚发生的。与此相反的是称为**早期绑定**、**静态多态**或**编译时多态**，因为它在编译时通过函数和运算符重载发生。
- en: On the other hand, a technique called the **curiously recurring template pattern**
    (or **CRTP**) allows simulating the virtual functions-based runtime polymorphism
    at compile time, by deriving classes from a base class template parameterized
    with the derived class. This technique is used extensively in some libraries,
    including Microsoft’s **Active Template Library** (**ATL**) and **Windows Template
    Library** (**WTL**). In this recipe, we will explore CRTP and learn how to implement
    it and how it works.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，一种称为**奇特重复的模板模式**（或**CRTP**）的技术允许通过从基类模板派生类来在编译时模拟基于虚函数的运行时多态。这种技术在某些库中得到了广泛的应用，包括微软的**活动模板库**（**ATL**）和**Windows模板库**（**WTL**）。在这个配方中，我们将探索CRTP，了解如何实现它以及它是如何工作的。
- en: Getting ready
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To demonstrate how CRTP works, we will revisit the example with the hierarchy
    of control classes we implemented in the *Separating interfaces and implementations
    with the non-virtual interface idiom* recipe. We will define a set of control
    classes that have functionalities such as drawing the control, which is (in our
    example) an operation done in two phases: erasing the background and then painting
    the control. For simplicity, in our implementation, these will be operations that
    will only print text to the console.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示CRTP的工作原理，我们将回顾我们在*使用非虚拟接口习惯用法分离接口和实现*配方中实现的控制类层次结构的示例。我们将定义一组具有诸如绘制控件等功能的控制类，在我们的示例中，这是一个分为两个阶段进行的操作：擦除背景然后绘制控件。为了简单起见，在我们的实现中，这些将只打印文本到控制台的操作。
- en: How to do it...
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To implement the curiously recurring template pattern in order to achieve static
    polymorphism, do the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现奇特重复的模板模式以实现静态多态，请执行以下操作：
- en: 'Provide a class template that will represent the base class for other classes
    that should be treated polymorphically at compile time. Polymorphic functions
    are invoked from this class:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供一个类模板，它将代表其他应在编译时进行多态处理的类的基类。多态函数从此类调用：
- en: '[PRE35]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Derived classes use the class template as their base class; the derived class
    is also the template argument for the base class. The derived class implements
    the functions that are invoked from the base class:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 派生类使用类模板作为它们的基类；派生类也是基类的模板参数。派生类实现了从基类调用的函数：
- en: '[PRE36]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Function templates can handle derived classes polymorphically through a pointer
    or reference to the base class template:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数模板可以通过基类模板的指针或引用来多态地处理派生类：
- en: '[PRE37]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How it works...
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Virtual functions can represent a performance issue, especially when they are
    small and called multiple times in a loop. Modern hardware has made most of these
    situations rather irrelevant, but there are still some categories of applications
    where performance is critical and any performance gains are important. The curiously
    recurring template pattern enables the simulation of virtual calls at compile
    time using metaprogramming, which eventually translates to functions overloading.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 虚函数可能会引起性能问题，尤其是在它们很小并且在循环中多次调用时。现代硬件使得这些情况中的大多数变得相当无关紧要，但仍然有一些应用类别，性能至关重要，任何性能提升都很重要。奇特重复的模板模式允许使用元编程在编译时模拟虚函数调用，这最终转化为函数重载。
- en: This pattern may look rather strange at first glance, but it is perfectly legal.
    The idea is to derive a class from a base class that is a template class, and
    then pass the derived class itself for the type template parameter of the base
    class. The base class then makes calls to the derived class functions. In our
    example, `control<button>::draw()` is declared before the `button` class is known
    to the compiler. However, the `control` class is a class template, which means
    it is instantiated only when the compiler encounters code that uses it. At that
    point, the `button` class, in this example, is already defined and known to the
    compiler, so calls to `button::erase_background()` and `button::paint()` can be
    made.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式乍一看可能相当奇怪，但它完全合法。想法是从一个基类派生一个类，该基类是一个模板类，然后传递派生类本身作为基类的类型模板参数。基类随后调用派生类函数。在我们的示例中，`control<button>::draw()`在`button`类对编译器已知之前声明。然而，`control`类是一个类模板，这意味着它仅在编译器遇到使用它的代码时实例化。在那个时刻，在这个例子中，`button`类已经定义并且对编译器已知，因此可以调用`button::erase_background()`和`button::paint()`。
- en: 'To invoke the functions from the derived class, we must first obtain a pointer
    to the derived class. That is done with a `static_cast` conversion, as seen in
    `static_cast<T*>(this)->erase_background()`. If this has to be done many times,
    the code can be simplified by providing a private function to do that:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用派生类的函数，我们首先需要获得派生类的指针。这通过`static_cast`转换完成，如`static_cast<T*>(this)->erase_background()`所示。如果需要多次这样做，可以通过提供一个执行此操作的私有函数来简化代码：
- en: '[PRE38]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'There are some pitfalls when using CRTP that you must be aware of:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用CRTP时，有一些陷阱你必须注意：
- en: 'All the functions in the derived classes that are called from the base class
    template must be public; otherwise, the base class specialization must be declared
    a friend of the derived class:'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有从基类模板调用的派生类中的函数都必须是公共的；否则，基类特化必须声明为派生类的友元：
- en: '[PRE39]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: It is not possible to store, in a homogeneous container, such as a `vector`
    or `list`, objects of CRTP types because each base class is a unique type (such
    as `control<button>` and `control<checkbox>`). If this is actually necessary,
    then a workaround can be used to implement it. This will be discussed and exemplified
    in the next section.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在同质容器，例如`vector`或`list`中，无法存储CRTP类型的对象，因为每个基类都是一个独特的类型（例如`control<button>`和`control<checkbox>`）。如果这确实是必要的，那么可以使用一种变通方法来实现它。这将在下一节中进行讨论和示例。
- en: When using this technique, the size of a program may increase, because of the
    way templates are instantiated.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用这种技术时，程序的大小可能会增加，因为模板的实例化方式。
- en: There’s more...
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'When objects of types implementing CRTP need to be stored homogeneously in
    a container, an additional idiom must be used. The base class template must itself
    be derived from another class with pure virtual functions (and a virtual public
    destructor). To exemplify this on the `control` class, the following changes are
    necessary:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要将实现CRTP类型的对象同质地存储在容器中时，必须使用一个额外的惯用用法。基类模板本身必须从另一个具有纯虚拟函数（以及虚拟公共析构函数）的类派生。为了在`control`类上说明这一点，需要以下更改：
- en: '[PRE40]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'No changes need to be made to the derived classes, such as `button` and `checkbox`.
    Then, we can store pointers to the abstract class in a container, such as `std::vector`,
    as shown here:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要对派生类，如`button`和`checkbox`，进行任何更改。然后，我们可以在容器中存储抽象类的指针，例如`std::vector`，如下所示：
- en: '[PRE41]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: See also
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Implementing the pimpl idiom*, to learn a technique that enables the separation
    of the implementation details from an interface'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现pimpl惯用用法，学习一种使实现细节与接口分离的技术
- en: '*Separating interfaces and implementations with the non-virtual interface idiom*,
    to explore an idiom that promotes the separation of concerns of interfaces and
    implementations by making (public) interfaces non-virtual and virtual functions
    private'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用非虚拟接口惯用用法来分离接口和实现，以探索一种惯用用法，通过使（公共）接口非虚拟和虚拟函数私有，来促进接口和实现的关注点分离
- en: Adding functionality to classes with mixins
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向混入类添加功能
- en: In the previous recipe, we learned about a pattern called the curiously recurring
    template pattern, or CRTP for short, and how it can be used to add common functionality
    to classes. This is not its only use; other use cases include limiting the number
    of times that a type can be instantiated and implementing the composite pattern.
    Related to this pattern, there is another one called **mixins**. Mixins are small
    classes that are designed to add functionality to other existing classes. You
    can probably find articles about this pattern claiming that it’s implemented using
    CRTP. That is not correct. Indeed, CRTP and mixins are similar patterns and both
    are used to add functionality to classes, but they don’t have the same structure.
    With CRTP, the base class adds functionality to the classes that derive from it.
    A mixin class adds functionality to a class that it derives from. Therefore, in
    a way, it is an upside-down CRTP. In this recipe, you will learn how to use mixins
    to add common functionality to classes. For this purpose, we will examine the
    same example of drawing controls (such as buttons and checkboxes). This will enable
    a good comparison with CRTP, which will allow you to better understand the differences
    (and similarities) between the two.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的菜谱中，我们了解了一个称为“好奇地反复出现的模板模式”或简称CRTP的模式，以及它是如何被用来向类添加共同功能的。这并不是它的唯一用途；其他用例包括限制类型的实例化次数和实现组合模式。与这个模式相关，还有一个称为**混合**的模式。混合是设计用来向其他现有类添加功能的小类。你可能可以找到关于这个模式的文章，声称它是使用CRTP实现的。这是不正确的。确实，CRTP和混合是相似的模式，两者都用于向类添加功能，但它们的结构并不相同。在CRTP中，基类向从它派生的类添加功能。混合类向它派生的类添加功能。因此，从某种意义上说，它是一个颠倒的CRTP。在这个菜谱中，你将学习如何使用混合向类添加共同功能。为此，我们将检查绘制控件（如按钮和复选框）的相同示例。这将允许与CRTP进行良好的比较，这将帮助你更好地理解两者之间的差异（和相似之处）。
- en: How to do it…
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'To implement the mixins pattern to add common functionality to existing classes,
    do the following (in the following example the common functionality in question
    is painting the background and content of controls):'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现混合模式以向现有类添加共同功能，请按照以下步骤操作（在以下示例中，所涉及的共同功能是绘制控件的背景和内容）：
- en: 'Consider (possibly unrelated) classes that exhibit common functionality:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑（可能无关的）表现出共同功能（的）类：
- en: '[PRE42]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Create a class template that derives from its type template parameter. This
    mixin class defines some new functionality that is implemented in terms of existing
    functionality from the base class:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个从其类型模板参数派生的类模板。这个混合类定义了一些新的功能，这些功能是通过基类中现有的功能实现的：
- en: '[PRE43]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Instantiate and use objects of the mixin class to utilize the added functionality:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化和使用混合类的对象以利用添加的功能：
- en: '[PRE44]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: How it works…
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'A mixin is a concept that allows us to add new functionality to existing classes.
    The pattern is implemented differently in many programming languages. In C++,
    a mixin is a small class that adds functionality to an existing one (without having
    to make any changes to the existing class). For this, you need to:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 混合是一个允许我们向现有类添加新功能的概念。在许多编程语言中，这种模式有不同的实现方式。在C++中，混合是一个小的类，它向现有的类添加功能（而不需要对现有类进行任何修改）。为此，你需要：
- en: Make the mixin class a template. In our example, this was the `control` class.
    If there is only one type that is supposed to be extended, then there is no need
    to use a template, since there would be no code duplication. However, in practice,
    this is usually intended to add common functionality for multiple similar classes.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将混合类做成模板。在我们的例子中，这是`control`类。如果只有一个类型需要扩展，那么不需要使用模板，因为没有代码重复。然而，在实践中，这通常是为了向多个类似类添加共同功能。
- en: Derive it from its type template parameter, which is supposed to be instantiated
    with the types to be extended. Implement the added functionality by reusing functionality
    from the type template parameter class. In our example, the new functionality
    was `draw()`, which used `T::erase_background()` and `T::paint()`.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从其类型模板参数派生它，该参数应该实例化为要扩展的类型。通过重用类型模板参数类的功能来实现添加的功能。在我们的例子中，新的功能是`draw()`，它使用了`T::erase_background()`和`T::paint()`。
- en: 'Since the mixin class is a template, it cannot be handled polymorphically.
    For instance, perhaps you want to have a function that should be able to draw
    both buttons and checkboxes and any other drawable controls. This function could
    look as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 由于混入类是一个模板，它不能被多态处理。例如，也许您想要一个能够绘制按钮、复选框以及其他可绘制控件的函数。这个函数可以看起来如下：
- en: '[PRE45]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'But what does `???` stand for in this snippet? We need a non-template base
    class for this to work polymorphically. Such a base class can look as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 但在这个片段中`???`代表什么？我们需要一个非模板基类才能使其以多态方式工作。这样的基类可以看起来如下：
- en: '[PRE46]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The mixin class (`control`) needs to also derive from this base class (`control_base`)
    and the `draw()` function becomes an overridden virtual function:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 混入类（`control`）还需要从该基类（`control_base`）派生，并且`draw()`函数成为一个被重写的虚函数：
- en: '[PRE47]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This allows us to treat control objects polymorphically, as shown in the following
    example:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们以多态方式处理控件对象，如下面的示例所示：
- en: '[PRE48]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As you can see from this recipe and the previous one, mixins and CRTP are both
    used for the same purpose of adding functionality to classes. Moreover, they look
    similar, although the actual pattern structure is different.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从本食谱和上一个食谱中可以看到，混入和CRTP都用于添加功能到类的相同目的。此外，它们看起来很相似，尽管实际的模式结构是不同的。
- en: See also
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Static polymorphism with the curiously recurring template pattern*, to learn
    about CRTP, which allows the simulation of runtime polymorphism at compile time
    by deriving classes from a base class template parameterized with the derived
    class'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用好奇地重复出现的模板模式进行静态多态*，要了解CRTP，它允许通过从基类模板派生类来在编译时模拟运行时多态'
- en: Handling unrelated types generically with the type erasure idiom
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类型擦除惯用语泛型处理无关类型
- en: Polymorphism (and more specifically runtime polymorphism in C++) allows us to
    treat hierarchies of classes in a generic way. However, there are cases when we
    want to do the same but with classes that do not inherit from a common base class.
    This can happen when we do not own the code or, for various reasons, cannot change
    the code to create a hierarchy. This process of utilizing unrelated types that
    have some certain members (functions or variables) for given tasks (and only use
    those common members) is called **duck typing**. A simple solution to this problem
    is to build a hierarchy of wrapper classes, one for each class that we want to
    handle generically. This has drawbacks because there is a lot of boilerplate code
    and every time a new class needs to be handled in the same manner, a new wrapper
    must be created. The alternative to this approach is an idiom known as **type
    erasure**. The term refers to the fact that information about concrete types is
    erased, allowing different and even unrelated types to be handled generically.
    In this recipe, we will learn how this idiom works.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 多态（特别是C++中的运行时多态）允许我们以通用方式处理类的层次结构。然而，有些情况下我们想要做的是相同的，但与不继承自公共基类的类。这可能发生在我们不拥有代码或由于各种原因无法更改代码以创建层次结构时。这个过程是利用具有某些特定成员（函数或变量）的不相关类型来完成给定任务（并且只使用那些公共成员）的过程，称为**鸭子类型**。解决这个问题的一个简单方法是为我们想要以通用方式处理的每个类构建一个包装类层次结构。这有缺点，因为有很多样板代码，并且每次需要以相同方式处理新类时，都必须创建一个新的包装器。这种方法的替代方法是称为**类型擦除**的惯用语。这个术语指的是擦除了有关具体类型的信息，允许以通用方式处理不同甚至不相关的类型。在本食谱中，我们将学习这个惯用语是如何工作的。
- en: Getting ready
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To showcase the type erasure idiom, we will use the following two classes,
    representing a button and a checkbox control:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示类型擦除惯用语，我们将使用以下两个类，分别代表按钮和复选框控件：
- en: '[PRE49]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: These are the same classes we have seen in various forms in the previous recipes.
    They both have `erase_background()` and `paint()` member functions but they do
    not have a common base class; therefore, they are not part of a hierarchy that
    would allow us to treat them polymorphically.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们之前在各种形式中看到过的相同类。它们都有`erase_background()`和`paint()`成员函数，但没有一个共同的基类；因此，它们不是属于允许我们以多态方式处理它们的层次结构的一部分。
- en: How to do it…
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To implement the type erasure idiom, you need to follow these steps:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现类型擦除惯用语，您需要遵循以下步骤：
- en: 'Define a class that will provide the mechanism for erasing type information.
    For the example that we showcase in this recipe that deals with controls, we will
    simply call it `control`:'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个将提供擦除类型信息机制的类。对于本食谱中展示的与控件相关的示例，我们将简单地称其为`control`：
- en: '[PRE50]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Create an inner class (of the `control` class) that defines the common interface
    for the types that need to be handled generically. This interface is called a
    **concept**; therefore, we will call this class `control_concept`:'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个内部类（`control`类的内部类），该类定义了需要通用处理的类型所共有的接口。这个接口被称为**概念**；因此，我们将称这个类为`control_concept`：
- en: '[PRE51]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Create another inner class (of the `control` class) that derives from the concept
    class. However, this will be a class template, and its type template parameter
    represents a type that needs to be handled generically. In our example, it will
    be substituted with `button` and `checkbox`. This implementation is called a **model**,
    and, therefore, we will call this class template `control_model`:'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建另一个内部类（`control` 类的内部类），它从概念类派生。然而，这将是一个类模板，其类型模板参数代表一个需要通用处理的类型。在我们的例子中，它将被替换为
    `button` 和 `checkbox`。这种实现称为 **模型**，因此我们将这个类模板称为 `control_model`：
- en: '[PRE52]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Add a data member to the `control` class, representing a pointer to an instance
    of the concept. In this recipe, we will use a smart pointer for this purpose:'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向`control`类添加一个数据成员，表示指向该概念实例的指针。在这个菜谱中，我们将使用智能指针来完成这个目的：
- en: '[PRE53]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Define a constructor for the `control` class. This must be a function template,
    and it must set the concept pointer to an instance of a model:'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义`control`类的构造函数。这必须是一个函数模板，并且它必须将概念指针设置为模型的一个实例：
- en: '[PRE54]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Define the public interface that clients of the `control` class should be able
    to invoke. In our example, this is a function to draw the control. We will call
    it `draw()` (although it does not have to have the same name as the virtual method
    in the concept):'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义`control`类客户端能够调用的公共接口。在我们的示例中，这是一个用于绘制控制的函数。我们将称之为`draw()`（尽管它不必与概念中的虚拟方法同名）：
- en: '[PRE55]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Putting all this together, the type erasure idiom that handles unrelated control
    classes together looks as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We can use this wrapper class to handle buttons and checkboxes (and similar
    other classes) polymorphically, such as in the following snippet:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个包装类来多态地处理按钮和复选框（以及类似的其它类），例如在以下代码片段中：
- en: '[PRE57]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: How it works…
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The most rudimentary form of type erasure (and arguably the ultimate one) is
    to employ `void` pointers. Although this provides the mechanism for implementing
    the idiom in C, it should be avoided in C++ because it’s not type safe. It requires
    casting from a pointer to a type to a pointer to `void` and then the other way
    around, which is error prone, as shown in the following example:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的类型擦除形式（也许可以说是最终形式）是使用`void`指针。尽管这为在C语言中实现该惯用表达式提供了机制，但在C++中应避免使用，因为它不保证类型安全。它需要从指向类型的指针转换为指向`void`的指针，然后再反过来，这很容易出错，如下面的示例所示：
- en: '[PRE58]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In C++, the approach to this problem is to define a hierarchy of wrappers to
    handle the individual classes. For this, we can start with a base class that defines
    the interface for the wrapper classes. In our case, we are interested in drawing
    a control, so the only virtual method is one called `draw()`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，解决这个问题的方法是定义一个处理单个类的包装器层次结构。为此，我们可以从一个定义包装器类接口的基类开始。在我们的情况下，我们感兴趣的是绘制一个控件，因此唯一的虚方法是名为`draw()`的方法。
- en: 'We will call this class `control_concept`. Its definition is shown below:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个类称为`control_concept`。其定义如下：
- en: '[PRE59]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The next step is to derive it for each type of control that can be drawn (using
    the two `erase_background()` and `paint()` functions). The wrappers for `button`
    and `checkbox` are as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是针对可以绘制的每种控制类型推导出相应的实现（使用两个 `erase_background()` 和 `paint()` 函数）。`button`
    和 `checkbox` 的包装器如下：
- en: '[PRE60]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Having this hierarchy of wrappers, we can write a function that draws controls
    polymorphically, by using pointers to `control_concept` (the base class of the
    wrapper hierarchy):'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 有这样的包装器层次结构，我们可以编写一个函数，通过使用指向`control_concept`（包装器层次结构的基类）的指针，以多态方式绘制控件：
- en: '[PRE61]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Although this works, `button_wrapper` and `control_wrapper` are almost identical.
    Therefore, they are good candidates for templating. A class template that encapsulates
    the functionality seen in these two classes is shown next:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这样做是可行的，`button_wrapper` 和 `control_wrapper` 几乎完全相同。因此，它们是模板化的良好候选者。下面展示了一个封装了这两个类中看到的功能的类模板：
- en: '[PRE62]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The client code needs only a small change: replacing `button_wrapper` and `checkbox_wrapper`
    with `control_wrapper<button>` and `control_wrapper<checkbox>`, as in the following
    snippet:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端代码只需进行微小修改：将`button_wrapper`和`checkbox_wrapper`替换为`control_wrapper<button>`和`control_wrapper<checkbox>`，如下所示片段：
- en: '[PRE63]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: At this point, you have probably noticed how this approach leads to the type
    erasure idiom described in the *How to do it…* section. The `control_concept`
    class is the same as we saw in the pattern, and `control_wrapper<T>` is the same
    as `control_model<T>`. In addition, however, the pattern defines a way to encapsulate
    the model.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also move the `draw()` free function that handles these control types
    inside the `control` class. The resulting implementation is the following:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将处理这些控制类型的`draw()`自由函数移动到`control`类内部。得到的实现如下：
- en: '[PRE64]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This requires small changes to the client code (seen in the *How to do it…*
    section), which will look like the following snippet:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要对客户端代码进行一些小的修改（见 *如何操作…* 部分），它将类似于以下代码片段：
- en: '[PRE65]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Although we have seen a simple example in this recipe, this idiom is used in
    real-world scenarios, including the C++ standard library, where it is employed
    for the implementation of:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在本食谱中看到了一个简单的例子，但这个习语在现实世界的场景中也被使用，包括C++标准库，其中它被用于实现：
- en: '`std::function`, which is a polymorphic function wrapper that allows us to
    store, copy, and invoke callables: functions, function objects, pointers to member
    functions, pointers to member data, lambda expressions, and bind expressions.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::function`，这是一个多态函数包装器，允许我们存储、复制和调用可调用项：函数、函数对象、成员函数指针、成员数据指针、lambda 表达式和绑定表达式。'
- en: '`std::any`, which is a type that represents a container to a value of any type
    that is copy-constructible.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::any`，这是一个表示任何可复制构造类型值的容器类型。'
- en: See also
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Static polymorphism with the curiously recurring template pattern,* to learn
    about CRTP, which allows simulating runtime polymorphism at compile time by deriving
    classes from a base class template parameterized with the derived class'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*静态多态与古怪重复出现的模板模式*，了解CRTP，它允许通过从使用派生类参数化的基类模板派生类来在编译时模拟运行时多态'
- en: '*Adding functionality to classes with mixins,* to learn how you can add common
    functionality to existing classes without changing them'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通过混入（mixins）向类添加功能，* 了解如何在不更改现有类的情况下向其添加通用功能'
- en: '*Chapter 6*, *Using std::any to Store Any Value*, to learn how to use the C++17
    `std::any` class, which represents a type-safe container for single values of
    any type'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第6章*，*使用 std::any 存储任何值*，学习如何使用 C++17 的 `std::any` 类，它代表了一个任何类型单值的类型安全容器'
- en: Implementing a thread-safe singleton
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现线程安全的单例
- en: Singleton is probably one of the most well-known design patterns. It restricts
    the instantiation of a single object of a class, something that is necessary in
    some cases, although many times the use of a singleton is rather an anti-pattern
    that can be avoided with other design choices.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式可能是最广为人知的设计模式之一。它限制了类中单个对象的实例化，这在某些情况下是必要的，尽管很多时候单例的使用更像是一种可以避免的反模式，可以通过其他设计选择来替代。
- en: Since a singleton means a single instance of a class is available to an entire
    program, it is likely that such a unique instance might be accessible from different
    threads. Therefore, when you implement a singleton, you should also make it thread-safe.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 由于单例意味着一个类的单个实例对整个程序都是可用的，因此这种独特的实例可能可以从不同的线程中访问。因此，当你实现单例时，你也应该使其线程安全。
- en: Before C++11, doing that was not an easy job, and a double-checked locking technique
    was the typical approach. However, Scott Meyers and Andrei Alexandrescu showed,
    in a paper called *C++ and the Perils of Double-Checked Locking*, that using this
    pattern did not guarantee a thread-safe singleton implementation in portable C++.
    Fortunately, this changed in C++11, and this recipe shows how to write a thread-safe
    singleton in modern C++.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++11之前，做这件事并不容易，双重检查锁定技术是典型的解决方案。然而，Scott Meyers和Andrei Alexandrescu在一篇名为《C++与双重检查锁定之危险》的论文中表明，使用这种模式并不能保证在可移植的C++中实现线程安全的单例。幸运的是，这种情况在C++11中得到了改变，这个配方展示了如何在现代C++中编写线程安全的单例。
- en: Getting ready
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: For this recipe, you need to know how static storage duration, internal linkage,
    and deleted and defaulted functions work. You should also read the previous recipe
    *Static polymorphism with the curiously recurring template pattern* first if you
    have not done that yet and are not familiar with that pattern, as we will use
    it later in this recipe.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，你需要了解静态存储持续时间、内部链接以及删除和默认函数是如何工作的。如果你还没有阅读过，并且不熟悉该模式，你应该首先阅读之前的食谱 *使用奇特重复模板模式的静态多态性*，因为我们将在本食谱中稍后使用它。
- en: How to do it...
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To implement a thread-safe singleton, you should do the following:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现线程安全的单例，你应该做以下事情：
- en: 'Define the `Singleton` class:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`Singleton`类：
- en: '[PRE66]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Make the default constructor private:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将默认构造函数设置为私有：
- en: '[PRE67]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Make the copy constructor and copy assignment operator `public` and `delete`,
    respectively:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将复制构造函数和复制赋值运算符分别设置为`public`和`delete`：
- en: '[PRE68]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The function that creates and returns the single instance should be static
    and should return a reference to the class type. It should declare a static object
    of the class type and return a reference to it:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并返回单个实例的函数应该是静态的，并且应该返回对类类型的引用。它应该声明一个类类型的静态对象，并返回对其的引用：
- en: '[PRE69]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: How it works...
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Since singleton objects are not supposed to be created by the user directly,
    all constructors are either private or public and `deleted`. The default constructor
    is private and not deleted because an instance of the class must actually be created
    in the class code. A static function, called `instance()`, in this implementation,
    returns the single instance of the class.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 由于单例对象不应该由用户直接创建，所有构造函数要么是私有的，要么是公共的并且`deleted`。默认构造函数是私有的且未被删除，因为类代码中必须实际创建类的实例。在这个实现中，有一个名为`instance()`的静态函数，它返回类的单个实例。
- en: Though most implementations return a pointer, it actually makes more sense to
    return a reference, as there is no circumstance under which this function would
    return a null pointer (no object).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大多数实现返回一个指针，但实际上返回一个引用更有意义，因为在这个函数返回null指针（没有对象）的情况下是没有情况的。
- en: The implementation of the `instance()` method may look simplistic and not thread-safe
    at first glance, especially if you are familiar with the **double-checked locking
    pattern** (**DCLP**). In C++11, this is actually no longer necessary due to a
    key detail of how objects with static storage durations are initialized. Initialization
    happens only once, even if several threads attempt to initialize the same static
    object at the same time. The responsibility of DCLP has been moved from the user
    to the compiler, although the compiler may use another technique to guarantee
    the result.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`instance()`方法的实现可能看起来很简单且不是线程安全的，尤其是如果你熟悉**双重检查锁定模式**（**DCLP**）。在C++11中，这实际上不再是必要的，因为对象具有静态存储持续时间初始化的关键细节。初始化只发生一次，即使多个线程同时尝试初始化相同的静态对象也是如此。DCLP的责任已经从用户转移到编译器，尽管编译器可能使用另一种技术来保证结果。'
- en: 'The following quote from the C++ standard document, version N4917, paragraph
    8.8.3, defines the rules for static object initialization (the highlight is the
    part related to concurrent initialization):'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '来自C++标准文档版本N4917的第8.8.3段落的以下引文定义了静态对象初始化的规则（高亮显示的部分与并发初始化相关）： '
- en: Dynamic initialization of a block variable with static storage duration (6.7.5.2)
    or thread storage duration (6.7.5.3) is performed the first time control passes
    through its declaration; such a variable is considered initialized upon the completion
    of its initialization. If the initialization exits by throwing an exception, the
    initialization is not complete, so it will be tried again the next time control
    enters the declaration. **If control enters the declaration concurrently while
    the variable is being initialized, the concurrent execution shall wait for completion
    of the initialization.**
  id: totrans-312
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 块变量的动态初始化具有静态存储持续时间（6.7.5.2）或线程存储持续时间（6.7.5.3）是在控制首次通过其声明时执行的；这样的变量在其初始化完成后被认为是初始化过的。如果初始化通过抛出异常退出，则初始化未完成，因此它将在下一次控制进入声明时再次尝试。**如果在变量初始化的同时控制并发进入声明，则并发执行应等待初始化完成。**
- en: ''
  id: totrans-313
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Note 2: A conforming implementation cannot introduce any deadlock around execution
    of the initializer. Deadlocks might still be caused by the program logic; the
    implementation need only avoid deadlocks due to its own synchronization operations.
    —end note]'
  id: totrans-314
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[注2：符合规范的实现不能在初始化器的执行过程中引入任何死锁。死锁可能仍然由程序逻辑引起；实现只需避免由于自己的同步操作引起的死锁。—结束注]'
- en: ''
  id: totrans-315
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If control re-enters the declaration recursively while the variable is being
    initialized, the behavior is undefined.
  id: totrans-316
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果在变量初始化过程中控制递归地重新进入声明，则行为是未定义的。
- en: The static local object has static storage duration, but it is instantiated
    only when it is first used (at the first call to the method `instance()`). The
    object is deallocated when the program exits. As a side note, the only possible
    advantage of returning a pointer and not a reference is the ability to delete
    this single instance at some point, before the program exists, and then maybe
    recreate it. This, again, does not make too much sense, as it conflicts with the
    idea of a single, global instance of a class, accessible at any point from any
    place in the program.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 静态局部对象具有静态存储持续时间，但它仅在首次使用时（在第一次调用 `instance()` 方法时）实例化。程序退出时对象将被释放。作为旁注，返回指针而不是引用的唯一可能优势是在程序退出之前某个时刻删除此单个实例，然后可能重新创建它。这再次没有太多意义，因为它与类单例、全局实例的概念相冲突，该实例可以从程序的任何地方访问。
- en: There’s more...
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'There might be situations in larger code bases where you need more than one
    singleton type. In order to avoid writing the same pattern several times, you
    can implement it in a generic way. For this, we need to employ the **curiously
    recurring template pattern** (or **CRTP**) seen earlier in the chapter. The actual
    singleton is implemented as a class template. The `instance()` method creates
    and returns an object of the type template parameter, which will be the derived
    class:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在较大的代码库中，可能存在需要多个单例类型的情况。为了避免多次编写相同的模式，可以以通用方式实现它。为此，我们需要使用本章前面看到的 **好奇重复模板模式**（或
    **CRTP**）。实际的单例作为类模板实现。`instance()` 方法创建并返回一个类型为模板参数的对象，这将是一个派生类：
- en: '[PRE70]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The `Singleton` class from the previous section has become the `SingletonBase`
    class template. The default constructor is no longer private but protected because
    it must be accessible from the derived class. In this example, the class that
    needs to have a single object instantiated is called `Single`. Its constructors
    must be private, but the default constructor must also be available to the base
    class template; therefore, `SingletonBase<Single>` is a friend of the `Single`
    class.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个部分中的 `Singleton` 类已变为 `SingletonBase` 类模板。默认构造函数不再是私有的，而是受保护的，因为它必须可以从派生类访问。在这个例子中，需要实例化单个对象的类被称为
    `Single`。它的构造函数必须是私有的，但默认构造函数也必须对基类模板可用；因此，`SingletonBase<Single>` 是 `Single`
    类的朋友。
- en: See also
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Static polymorphism with the curiously recurring template pattern,* to learn
    about CRTP, which allows simulating runtime polymorphism at compile time by deriving
    classes from a base class template parameterized with the derived class'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用好奇重复模板模式实现静态多态性*，了解 CRTP，它允许通过从使用派生类参数化的基类模板派生类来在编译时模拟运行时多态'
- en: '*Chapter 3*, *Defaulted and deleted functions*, to learn about the use of the
    default specifier on special member functions and how to define functions as deleted
    with the delete specifier'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第三章*，*已弃用和已删除的函数*，了解在特殊成员函数上使用默认指定符以及如何使用 delete 指定符定义已删除的函数'
- en: Learn more on Discord
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://discord.gg/7xRaTCeEhx](Chapter_10.xhtml)'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://discord.gg/7xRaTCeEhx](Chapter_10.xhtml)'
- en: '![](img/QR_Code2659294082093549796.png)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code2659294082093549796.png)'
