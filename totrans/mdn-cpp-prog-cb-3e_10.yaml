- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing Patterns and Idioms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Design patterns are general reusable solutions that can be applied to common
    problems that appear in software development. Idioms are patterns, algorithms,
    or ways to structure the code in one or more programming languages. A great number
    of books has been written on design patterns. This chapter is not intended to
    reiterate them, but rather to show how to implement several useful patterns and
    idioms, with a focus on readability, performance, and robustness, in terms of
    modern C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'The recipes included in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding repetitive `if-else` statements in factory patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the pimpl idiom
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the named parameter idiom
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separating interfaces and implementations with the non-virtual interface idiom
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling friendship with the attorney-client idiom
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static polymorphism with the curiously recurring template pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding functionality to classes with mixins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling unrelated types generically with the type erasure idiom
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a thread-safe singleton
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first recipe of this chapter presents a simple mechanism for avoiding repetitive
    `if-else` statements. Let’s explore how this mechanism works.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding repetitive if-else statements in factory patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is often the case that we end up writing repetitive `if...else` statements
    (or an equivalent `switch` statement) that do similar things, often with little
    variation and often done by copying and pasting with small changes. As the number
    of alternative conditions increases, the code becomes both hard to read and hard
    to maintain. Repetitive `if...else` statements can be replaced with various techniques,
    such as polymorphism. In this recipe, we will see how to avoid `if...else` statements
    in factory patterns (a factory is a function or object that is used to create
    other objects) using a map of functions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will consider the following problem: building a system that
    can handle image files in various formats, such as bitmap, PNG, JPG, and so on.
    Obviously, the details are beyond the scope of this recipe; the part we are concerned
    with is creating objects that handle various image formats. For this, we will
    consider the following hierarchy of classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, we’ll define an interface for a factory class that can create
    instances of the aforementioned classes, as well as a typical implementation using
    `if...else` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The goal of this recipe is to see how this implementation can be refactored
    to avoid repetitive `if...else` statements.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to refactor the factory shown earlier to avoid
    using `if...else` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the factory interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a map where the key is the type of objects to create and the value is
    a function that creates objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To create an object, look up the object type in the map and, if it is found,
    use the associated function to create a new instance of the type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The repetitive `if...else` statements in the first implementation are very
    similar – they check the value of the `type` parameter and create an instance
    of the appropriate `Image` class. If the argument to check was an integral type
    (for instance, an enumeration type), the sequence of `if...else` statements could
    have also been written in the form of a `switch` statement. That code can be used
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Regardless of whether the implementation was using `if...else` statements or
    a `switch`, refactoring to avoid repetitive checks is relatively simple. In the
    refactored code, we used a map that has the key type `std::string` representing
    the type, that is, the name of the image format. The value is an `std::function<std::unique_ptr<Image>()>`.
    This is a wrapper for a function that takes no arguments and returns an `std::unique_ptr<Image>`
    (a `unique_ptr` of a derived class is implicitly converted to a `unique_ptr` of
    a base class).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have this map of functions that create objects, the actual implementation
    of the factory is much simpler; check the type of the object to be created in
    the map and, if present, use the associated value from the map as the actual function
    to create the object, or return `nullptr` if the object type is not present in
    the map.
  prefs: []
  type: TYPE_NORMAL
- en: This refactoring is transparent for the client code, as there are no changes
    in the way clients use the factory. On the other hand, this approach does require
    more memory to handle the static map, which, for some classes of applications,
    such as IoT, might be an important aspect. The example presented here is relatively
    simple because the purpose is to demonstrate the concept. In real-world code,
    it might be necessary to create objects differently, such as using a different
    number of arguments and different types of arguments. However, this is not specific
    to the refactored implementation, and the solution with the `if...else`/`switch`
    statement needs to account for that too. Therefore, in practice, the solution
    to this problem that worked with `if...else` statements should also work with
    the map.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the preceding implementation, the map is a local static to the virtual function,
    but it can also be a member of the class or even a global. The following implementation
    has the map defined as a static member of the class. The objects are not created
    based on the format name, but on the type information, as returned by the `typeid`
    operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the client code is slightly different, because instead of passing
    a name representing the type to create, such as PNG, we pass the value returned
    by the `typeid` operator, such as `typeid(PngImage)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This alternative is arguably more robust because the map keys are not strings,
    which could be more prone to errors. This recipe proposes a pattern as the solution
    to a common problem, and not an actual implementation. As in the case of most
    patterns, there are different ways they can be implemented, and it is up to you
    to pick the one that is the most suitable for each context.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Implementing the pimpl idiom,* to learn a technique that enables the separation
    of the implementation details from an interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 9**, Using unique_ptr to uniquely own a memory resource*, to learn
    about the `std::unique_ptr` class, which represents a smart pointer that owns
    and manages another object or array of objects allocated on the heap'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the pimpl idiom
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**pimpl** stands for **pointer to implementation** (also known as the **Cheshire
    cat idiom** or the **compiler firewall idiom**) and is an opaque pointer technique
    that enables the separation of the implementation details from an interface. This
    has the advantage that it enables changing the implementation without modifying
    the interface and, therefore, avoiding the need to recompile the code that is
    using the interface. This has the potential of making libraries using the pimpl
    idiom on their ABIs backward-compatible with older versions when only implementation
    details change. In this recipe, we will see how to implement the pimpl idiom using
    modern C++ features.'
  prefs: []
  type: TYPE_NORMAL
- en: The term **ABI** stands for **Application Binary Interface**, and refers to
    the interface between two binary modules. Typically, one such module is a library
    or operating system, and the other is a program executed by a user.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The reader is expected to be familiar with smart pointers and `std::string_view`,
    both of which were discussed in previous chapters of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate the pimpl idiom in a practical manner, we will consider the
    following class, which we will then refactor following the pimpl pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This class represents a control that has properties such as text, size, and
    visibility. Every time these properties are changed, the control is redrawn. In
    this mocked implementation, drawing means printing the value of the properties
    to the console.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Take the following steps to implement the pimpl idiom, exemplified here by
    refactoring the `control` class shown earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: Put all private members, both data and functions, into a separate class. We
    will call this the **pimpl class** and the original class the **public class**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the header file of the public class, put a forward declaration to the pimpl
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the public class definition, declare a pointer to the pimpl class using
    `unique_ptr`. This should be the only private data member of the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Put the pimpl class definition in the source file of the public class. The
    pimpl class mirrors the public interface of the public class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The pimpl class is instantiated in the constructor of the public class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Public class member functions call the corresponding member functions of the
    pimpl class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The pimpl idiom enables hiding the internal implementation of a class from
    the clients of the library or module the class is part of. This provides several
    benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: A clean interface for a class that its clients see.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changes in the internal implementation do not affect the public interface, which
    enables binary backward-compatibility for newer versions of a library (when the
    public interface remains unchanged).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clients of a class that use this idiom do not need to be recompiled when changes
    to the internal implementation occur. This leads to shorter build times.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The header file does not need to include the headers for the types and functions
    used in the private implementation. This, again, leads to shorter build times.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The benefits mentioned above do not come for free; there are also several drawbacks
    that need to be mentioned:'
  prefs: []
  type: TYPE_NORMAL
- en: There is more code to write and maintain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code can arguably be less readable, as there is a level of indirection and
    all the implementation details need to be looked up in the other files. In this
    recipe, the pimpl class definition was provided in the source file of the public
    class, but in practice, it could be in separate files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a slight runtime overhead because of the level of indirection from
    the public class to the pimpl class, but in practice, this is rarely significant.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This approach does not work with private and protected members because these
    have to be available to the derived classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This approach does not work with the private virtual functions, which have to
    appear in the class, either because they override functions from a base class
    or have to be available for overriding in a derived class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a rule of thumb, when implementing the pimpl idiom, always put all the private
    member data and functions, except for the virtual ones, in the pimpl class and
    leave the protected data members and functions and all the private virtual functions
    in the public class.
  prefs: []
  type: TYPE_NORMAL
- en: In the example in this recipe, the `control_pimpl` class is basically identical
    to the original `control` class. In practice, where classes are larger and have
    virtual functions and protected members and both functions and data, the pimpl
    class is not a complete equivalent of how the class would have looked like if
    it was not pimpled. Also, in practice, the pimpl class may require a pointer to
    the public class in order to call members that were not moved into the pimpl class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Concerning the implementation of the refactored `control` class, the pointer
    to the `control_pimpl` object is managed by a `unique_ptr`. In the declaration
    of this pointer, we have used a custom deleter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason for this is that the `control` class has a destructor implicitly
    defined by the compiler, at a point where the `control_pimpl` type is still incomplete
    (that is, in the header). This would result in an error with `unique_ptr`, which
    cannot delete an incomplete type. This problem can be solved in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Provide a user-defined destructor for the `control` class that is explicitly
    implemented (even if declared as `default`) after the complete definition of the
    `control_pimpl` class is available.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide a custom deleter for the `unique_ptr`, as we did in this example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The original `control` class was both copyable and movable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The refactored `control` class is only movable, not copyable. The following
    code shows an implementation of the `control` class that is both copyable and
    movable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The class `control_copyable` is both copyable and movable, but to make it so,
    we provided the copy constructor and copy assignment operator and both the move
    constructor and move assignment operator. The latter ones can be defaulted, but
    the former ones were explicitly implemented to create a new `control_pimpl` object
    from the object that it is copied from.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Chapter 9,* *Using unique_ptr to uniquely own a memory resource*, to learn
    about the `std::unique_ptr` class, which represents a smart pointer that owns
    and manages another object or array of objects allocated on the heap'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the named parameter idiom
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ supports only positional parameters, which means arguments are passed to
    a function based on the parameter’s position. Other languages also support named
    parameters – that is, they specify parameter names when making a call and invoking
    arguments. This is particularly useful with parameters that have default values.
    A function may have parameters with default values, although they always appear
    after all the non-defaulted parameters.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you want to provide values for only some of the defaulted parameters,
    there is no way to do this without providing arguments for the parameters that
    are positioned before them in the function parameters list.
  prefs: []
  type: TYPE_NORMAL
- en: A technique called the **named parameter idiom** provides a method to emulate
    named parameters and help solve this problem. We will explore this technique in
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To exemplify the named parameter idiom, we will use the `control` class shown
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `control` class represents a visual control, such as a button or an input,
    and has properties such as numerical identifier, text, size, and visibility. These
    are provided to the constructor and, except for the ID, all the others have default
    values. In practice, such a class would have many more properties, such as text
    brush, background brush, border style, font size, font family, and many others.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To implement the named parameter idiom for a function (usually with many default
    parameters), do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class to wrap the parameters of the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The class or function that needs to access these properties could be declared
    as `friend` to avoid writing getters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Every positional parameter of the original function that does not have a default
    value should become a positional parameter, without a default value in the constructor
    of the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For every positional parameter of the original function that has a default
    value, there should be a function (with the same name) that sets the value internally
    and returns a reference to the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The original function should be modified, or an overload should be provided,
    to take an argument of the new class from which the property values will be read:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we put all that together, the result is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The initial `control` class had a constructor with many parameters. In real-world
    code, you can find examples like this where the number of parameters is much higher.
    A possible solution, often found in practice, is to group common Boolean type
    properties in bit flags, which could be passed together as a single integral argument
    (an example could be the border style for a control that defines the position
    where the border should be visible: top, bottom, left, right, or any combination
    of these four). Creating a `control` object with the initial implementation is
    done like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The named parameter idiom has the advantage that it allows you to specify values
    only for the parameters that you want, in any order, using a name, which is much
    more intuitive than a fixed, positional order.
  prefs: []
  type: TYPE_NORMAL
- en: Although there isn’t a single strategy for implementing the idiom, the example
    in this recipe is rather typical. The properties of the `control` class, provided
    as parameters in the constructor, have been put into a separate class, called
    `control_properties`, that declares the `control` class as a friend class to allow
    it to access its private data members without providing getters. This has the
    side effect that it limits the use of `control_properties` outside the `control`
    class. The non-optional parameters of the constructor of the `control` class are
    also non-optional parameters of the `control_properties` constructor. For all
    the other parameters with default values, the `control_properties` class defines
    a function with a relevant name that simply sets the data member to the provided
    argument, and then returns a reference to `control_properties`. This enables the
    client to chain calls to these functions in any order.
  prefs: []
  type: TYPE_NORMAL
- en: The constructor of the control class has been replaced with a new one that has
    a single parameter, a constant reference to a `control_properties` object, whose
    data members are copied into the `control` object’s data members.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a `control` object with the named parameter idiom implemented in this
    manner is done as in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Separating interfaces and implementations with the non-virtual interface idiom*,
    to explore an idiom that promotes the separation of concerns of interfaces and
    implementations by making (public) interfaces non-virtual and virtual functions
    private'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Handling friendship with the attorney-client idiom*, to learn about a simple
    mechanism to restrict friends’ access to only designated, private members of a
    class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separating interfaces and implementations with the non-virtual interface idiom
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Virtual functions provide specialization points for a class by allowing derived
    classes to modify implementations from a base class. When a derived class object
    is handled through a pointer or a reference to a base class, calls to overridden
    virtual functions end up invoking the overridden implementation from the derived
    class. On the other hand, customization is an implementation detail, and a good
    design separates interfaces from implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The **non-virtual interface idiom**, proposed by Herb Sutter in an article about
    virtuality in the *C/C++ Users Journal*, promotes the separation of concerns of
    interfaces and implementations by making (public) interfaces non-virtual and virtual
    functions private.
  prefs: []
  type: TYPE_NORMAL
- en: Public virtual interfaces prevent a class from enforcing pre- and post-conditions
    on its interface. Users expecting an instance of a base class do not have the
    guarantee that the expected behavior of a public virtual method is delivered,
    since it can be overridden in a derived class. This idiom helps enforce the promised
    contract of an interface.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The reader should be familiar with aspects related to virtual functions, such
    as defining and overriding virtual functions, abstract classes, and pure specifiers.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Implementing this idiom requires following several simple design guidelines,
    formulated by Herb Sutter in the *C/C++ Users Journal*, 19(9), September 2001:'
  prefs: []
  type: TYPE_NORMAL
- en: Make (public) interfaces non-virtual.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make virtual functions private.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make virtual functions protected only if the base implementation has to be called
    from a derived class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the base class destructor either public and virtual or protected and nonvirtual.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following example of a simple hierarchy of controls abides by all these
    four guidelines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The NVI idiom uses the **template method** design pattern, which allows derived
    classes to customize parts (that is, steps) of a base class functionality (that
    is, an algorithm). This is done by splitting the overall algorithm into smaller
    parts, each of them implemented by a virtual function. The base class may provide,
    or not, a default implementation, and the derived classes could override them
    while maintaining the overall structure and meaning of the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'The core principle of the NVI idiom is that virtual functions should not be
    public; they should be either private or protected, in case the base class implementation
    could be called from a derived class. The interface of a class, the public part
    accessible to its clients, should be comprised exclusively of nonvirtual functions.
    This provides several advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: It separates the interface from the details of implementation that are no longer
    exposed to the client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It enables changing the details of the implementation without altering the public
    interface and without requiring changes to the client code, therefore making base
    classes more robust.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows a class to have sole control of its interface. If the public interface
    contains virtual methods, a derived class can alter the promised functionality,
    and therefore, the class cannot ensure its preconditions and postconditions. When
    none of the virtual methods (except for the destructor) are accessible to its
    clients, the class can enforce pre- and post-conditions on its interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A special mention of the destructor of a class is required for this idiom. It
    is often stressed that base class destructors should be virtual so that objects
    can be deleted polymorphically (through a pointer or references to a base class).
    Destructing objects polymorphically when the destructor is not virtual incurs
    undefined behavior. However, not all base classes are intended to be deleted polymorphically.
    For those particular cases, the base class destructor should not be virtual. However,
    it should also not be public, but protected.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example from the previous section defines a hierarchy of classes representing
    visual controls:'
  prefs: []
  type: TYPE_NORMAL
- en: '`control` is the base class, but there are derived classes, such as `button`
    and `checkbox`, which are a type of button and, therefore, are derived from this
    class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The only functionality defined by the `control` class is drawing the controls.
    The `draw()` method is nonvirtual, but it calls two virtual methods, `erase_background()`
    and `paint()`, to implement the two phases of drawing the control.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`erase_background()` is a protected virtual method because derived classes
    need to call it in their own implementation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`paint()` is a private pure virtual method. Derived classes must implement
    it, but are not supposed to call a base implementation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The destructor of the control class is public and virtual because objects are
    expected to be deleted polymorphically.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example of using these classes is shown as follows. Instances of these classes
    are managed by smart pointers to the base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The NVI idiom introduces a level of indirection when a public function calls
    a non-public virtual function that does the actual implementation. In the previous
    example, the `draw()` method called several other functions, but in many cases,
    it could be only one call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the class `control` has an additional method called `initialize()`
    (the previous content of the class was not shown to keep it simple) that calls
    a single non-public virtual method called `initialize_impl()`, implemented differently
    in each derived class. This does not incur much overhead – if any at all – since
    simple functions like this are most likely inlined by the compiler anyway.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Chapter 1,* *Use override and final for virtual methods*, to learn how to
    specify that a virtual function overrides another virtual function, as well as
    how to specify that a virtual function cannot be overridden in a derived class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling friendship with the attorney-client idiom
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Granting functions and classes access to the non-public parts of a class with
    a friend declaration is usually seen as a sign of bad design, as friendship breaks
    encapsulation and ties classes and functions. Friends, whether they are classes
    or functions, get access to all the private members of a class, although they
    may only need to access parts of it.
  prefs: []
  type: TYPE_NORMAL
- en: The **attorney-client idiom** provides a simple mechanism to restrict friends
    access to only designated private members of a class.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To demonstrate how to implement this idiom, we will consider the following
    classes: `Client`, which has some private member data and functions (the public
    interface is not important here), and `Friend`, which is supposed to access only
    parts of the private details, for instance, `data1` and `action1()`, but has access
    to everything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: To understand this idiom, you must be familiar with how friendship is declared
    in the C++ language and how it works.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Take the following steps to restrict a friend’s access to only the private
    members of a class that you need access to:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Client` class, which provides access to all its private members to
    a friend, declare the friendships to an intermediate class, called the `Attorney`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a class that contains only private (inline) functions that access the
    private members of the client. This intermediate class allows the actual friend
    to access its private members:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `Friend` class, access the private members of only the `Client` class
    indirectly through the `Attorney` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The attorney-client idiom lays out a simple mechanism to restrict access to
    the private members of the client by introducing a middleman, the attorney. Instead
    of providing friendship directly to those using its internal state, the client
    class offers friendship to an attorney, which, in turn, provides access to a restricted
    set of private data or functions of the client. It does so by defining private
    static functions. Usually, these are also inline functions, which avoids any runtime
    overhead due to the level of indirection the attorney class introduces. The client’s
    friend gets access to its private members by actually using the private members
    of the attorney. This idiom is called **attorney-client** because it is similar
    to the way an attorney-client relationship works, with the attorney knowing all
    the secrets of the client, but exposing only some of them to other parties.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, it might be necessary to create more than one attorney for a client
    class if different friend classes or functions must access different private members.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, friendship is not inheritable, which means that a class
    or function that is friend to class `B` is not friend with class `D`, which is
    derived from `B`. However, virtual functions overridden in `D` are still accessible
    polymorphically through a pointer or reference to `B` from a friend class. Such
    an example is shown as follows, where calling the `run()` method from `F` prints
    `base` and `derived`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: There are always trade-offs to using a design pattern, and this one is no exception.
    There are situations when using this pattern may lead to too much overhead on
    development, testing, and maintenance. However, the pattern could prove extremely
    valuable for some types of applications, such as extensible frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Implementing the pimpl idiom,* to learn a technique that enables the separation
    of the implementation details from an interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static polymorphism with the curiously recurring template pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Polymorphism provides us with the ability to have multiple forms for the same
    interface. Virtual functions allow derived classes to override implementations
    from a base class. They represent the most common elements of a form of polymorphism,
    called **runtime polymorphism**, because the decision to call a particular virtual
    function from the class hierarchy happens at runtime. It is also called **late
    binding**, because the binding between a function call and the invocation of the
    function happens late, during the execution of the program. The opposite of this
    is called **early binding**, **static polymorphism**, or **compile-time polymorphism**
    because it occurs at compile time through functions and operators overloading.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, a technique called the **curiously recurring template pattern**
    (or **CRTP**) allows simulating the virtual functions-based runtime polymorphism
    at compile time, by deriving classes from a base class template parameterized
    with the derived class. This technique is used extensively in some libraries,
    including Microsoft’s **Active Template Library** (**ATL**) and **Windows Template
    Library** (**WTL**). In this recipe, we will explore CRTP and learn how to implement
    it and how it works.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To demonstrate how CRTP works, we will revisit the example with the hierarchy
    of control classes we implemented in the *Separating interfaces and implementations
    with the non-virtual interface idiom* recipe. We will define a set of control
    classes that have functionalities such as drawing the control, which is (in our
    example) an operation done in two phases: erasing the background and then painting
    the control. For simplicity, in our implementation, these will be operations that
    will only print text to the console.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To implement the curiously recurring template pattern in order to achieve static
    polymorphism, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Provide a class template that will represent the base class for other classes
    that should be treated polymorphically at compile time. Polymorphic functions
    are invoked from this class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Derived classes use the class template as their base class; the derived class
    is also the template argument for the base class. The derived class implements
    the functions that are invoked from the base class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Function templates can handle derived classes polymorphically through a pointer
    or reference to the base class template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Virtual functions can represent a performance issue, especially when they are
    small and called multiple times in a loop. Modern hardware has made most of these
    situations rather irrelevant, but there are still some categories of applications
    where performance is critical and any performance gains are important. The curiously
    recurring template pattern enables the simulation of virtual calls at compile
    time using metaprogramming, which eventually translates to functions overloading.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern may look rather strange at first glance, but it is perfectly legal.
    The idea is to derive a class from a base class that is a template class, and
    then pass the derived class itself for the type template parameter of the base
    class. The base class then makes calls to the derived class functions. In our
    example, `control<button>::draw()` is declared before the `button` class is known
    to the compiler. However, the `control` class is a class template, which means
    it is instantiated only when the compiler encounters code that uses it. At that
    point, the `button` class, in this example, is already defined and known to the
    compiler, so calls to `button::erase_background()` and `button::paint()` can be
    made.
  prefs: []
  type: TYPE_NORMAL
- en: 'To invoke the functions from the derived class, we must first obtain a pointer
    to the derived class. That is done with a `static_cast` conversion, as seen in
    `static_cast<T*>(this)->erase_background()`. If this has to be done many times,
    the code can be simplified by providing a private function to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'There are some pitfalls when using CRTP that you must be aware of:'
  prefs: []
  type: TYPE_NORMAL
- en: 'All the functions in the derived classes that are called from the base class
    template must be public; otherwise, the base class specialization must be declared
    a friend of the derived class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It is not possible to store, in a homogeneous container, such as a `vector`
    or `list`, objects of CRTP types because each base class is a unique type (such
    as `control<button>` and `control<checkbox>`). If this is actually necessary,
    then a workaround can be used to implement it. This will be discussed and exemplified
    in the next section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When using this technique, the size of a program may increase, because of the
    way templates are instantiated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When objects of types implementing CRTP need to be stored homogeneously in
    a container, an additional idiom must be used. The base class template must itself
    be derived from another class with pure virtual functions (and a virtual public
    destructor). To exemplify this on the `control` class, the following changes are
    necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'No changes need to be made to the derived classes, such as `button` and `checkbox`.
    Then, we can store pointers to the abstract class in a container, such as `std::vector`,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Implementing the pimpl idiom*, to learn a technique that enables the separation
    of the implementation details from an interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Separating interfaces and implementations with the non-virtual interface idiom*,
    to explore an idiom that promotes the separation of concerns of interfaces and
    implementations by making (public) interfaces non-virtual and virtual functions
    private'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding functionality to classes with mixins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we learned about a pattern called the curiously recurring
    template pattern, or CRTP for short, and how it can be used to add common functionality
    to classes. This is not its only use; other use cases include limiting the number
    of times that a type can be instantiated and implementing the composite pattern.
    Related to this pattern, there is another one called **mixins**. Mixins are small
    classes that are designed to add functionality to other existing classes. You
    can probably find articles about this pattern claiming that it’s implemented using
    CRTP. That is not correct. Indeed, CRTP and mixins are similar patterns and both
    are used to add functionality to classes, but they don’t have the same structure.
    With CRTP, the base class adds functionality to the classes that derive from it.
    A mixin class adds functionality to a class that it derives from. Therefore, in
    a way, it is an upside-down CRTP. In this recipe, you will learn how to use mixins
    to add common functionality to classes. For this purpose, we will examine the
    same example of drawing controls (such as buttons and checkboxes). This will enable
    a good comparison with CRTP, which will allow you to better understand the differences
    (and similarities) between the two.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To implement the mixins pattern to add common functionality to existing classes,
    do the following (in the following example the common functionality in question
    is painting the background and content of controls):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider (possibly unrelated) classes that exhibit common functionality:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a class template that derives from its type template parameter. This
    mixin class defines some new functionality that is implemented in terms of existing
    functionality from the base class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Instantiate and use objects of the mixin class to utilize the added functionality:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A mixin is a concept that allows us to add new functionality to existing classes.
    The pattern is implemented differently in many programming languages. In C++,
    a mixin is a small class that adds functionality to an existing one (without having
    to make any changes to the existing class). For this, you need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Make the mixin class a template. In our example, this was the `control` class.
    If there is only one type that is supposed to be extended, then there is no need
    to use a template, since there would be no code duplication. However, in practice,
    this is usually intended to add common functionality for multiple similar classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Derive it from its type template parameter, which is supposed to be instantiated
    with the types to be extended. Implement the added functionality by reusing functionality
    from the type template parameter class. In our example, the new functionality
    was `draw()`, which used `T::erase_background()` and `T::paint()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since the mixin class is a template, it cannot be handled polymorphically.
    For instance, perhaps you want to have a function that should be able to draw
    both buttons and checkboxes and any other drawable controls. This function could
    look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'But what does `???` stand for in this snippet? We need a non-template base
    class for this to work polymorphically. Such a base class can look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The mixin class (`control`) needs to also derive from this base class (`control_base`)
    and the `draw()` function becomes an overridden virtual function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows us to treat control objects polymorphically, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from this recipe and the previous one, mixins and CRTP are both
    used for the same purpose of adding functionality to classes. Moreover, they look
    similar, although the actual pattern structure is different.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Static polymorphism with the curiously recurring template pattern*, to learn
    about CRTP, which allows the simulation of runtime polymorphism at compile time
    by deriving classes from a base class template parameterized with the derived
    class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling unrelated types generically with the type erasure idiom
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Polymorphism (and more specifically runtime polymorphism in C++) allows us to
    treat hierarchies of classes in a generic way. However, there are cases when we
    want to do the same but with classes that do not inherit from a common base class.
    This can happen when we do not own the code or, for various reasons, cannot change
    the code to create a hierarchy. This process of utilizing unrelated types that
    have some certain members (functions or variables) for given tasks (and only use
    those common members) is called **duck typing**. A simple solution to this problem
    is to build a hierarchy of wrapper classes, one for each class that we want to
    handle generically. This has drawbacks because there is a lot of boilerplate code
    and every time a new class needs to be handled in the same manner, a new wrapper
    must be created. The alternative to this approach is an idiom known as **type
    erasure**. The term refers to the fact that information about concrete types is
    erased, allowing different and even unrelated types to be handled generically.
    In this recipe, we will learn how this idiom works.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To showcase the type erasure idiom, we will use the following two classes,
    representing a button and a checkbox control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: These are the same classes we have seen in various forms in the previous recipes.
    They both have `erase_background()` and `paint()` member functions but they do
    not have a common base class; therefore, they are not part of a hierarchy that
    would allow us to treat them polymorphically.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To implement the type erasure idiom, you need to follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a class that will provide the mechanism for erasing type information.
    For the example that we showcase in this recipe that deals with controls, we will
    simply call it `control`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an inner class (of the `control` class) that defines the common interface
    for the types that need to be handled generically. This interface is called a
    **concept**; therefore, we will call this class `control_concept`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create another inner class (of the `control` class) that derives from the concept
    class. However, this will be a class template, and its type template parameter
    represents a type that needs to be handled generically. In our example, it will
    be substituted with `button` and `checkbox`. This implementation is called a **model**,
    and, therefore, we will call this class template `control_model`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a data member to the `control` class, representing a pointer to an instance
    of the concept. In this recipe, we will use a smart pointer for this purpose:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a constructor for the `control` class. This must be a function template,
    and it must set the concept pointer to an instance of a model:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the public interface that clients of the `control` class should be able
    to invoke. In our example, this is a function to draw the control. We will call
    it `draw()` (although it does not have to have the same name as the virtual method
    in the concept):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Putting all this together, the type erasure idiom that handles unrelated control
    classes together looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use this wrapper class to handle buttons and checkboxes (and similar
    other classes) polymorphically, such as in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most rudimentary form of type erasure (and arguably the ultimate one) is
    to employ `void` pointers. Although this provides the mechanism for implementing
    the idiom in C, it should be avoided in C++ because it’s not type safe. It requires
    casting from a pointer to a type to a pointer to `void` and then the other way
    around, which is error prone, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: In C++, the approach to this problem is to define a hierarchy of wrappers to
    handle the individual classes. For this, we can start with a base class that defines
    the interface for the wrapper classes. In our case, we are interested in drawing
    a control, so the only virtual method is one called `draw()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will call this class `control_concept`. Its definition is shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to derive it for each type of control that can be drawn (using
    the two `erase_background()` and `paint()` functions). The wrappers for `button`
    and `checkbox` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Having this hierarchy of wrappers, we can write a function that draws controls
    polymorphically, by using pointers to `control_concept` (the base class of the
    wrapper hierarchy):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Although this works, `button_wrapper` and `control_wrapper` are almost identical.
    Therefore, they are good candidates for templating. A class template that encapsulates
    the functionality seen in these two classes is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The client code needs only a small change: replacing `button_wrapper` and `checkbox_wrapper`
    with `control_wrapper<button>` and `control_wrapper<checkbox>`, as in the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you have probably noticed how this approach leads to the type
    erasure idiom described in the *How to do it…* section. The `control_concept`
    class is the same as we saw in the pattern, and `control_wrapper<T>` is the same
    as `control_model<T>`. In addition, however, the pattern defines a way to encapsulate
    the model.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also move the `draw()` free function that handles these control types
    inside the `control` class. The resulting implementation is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'This requires small changes to the client code (seen in the *How to do it…*
    section), which will look like the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Although we have seen a simple example in this recipe, this idiom is used in
    real-world scenarios, including the C++ standard library, where it is employed
    for the implementation of:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::function`, which is a polymorphic function wrapper that allows us to
    store, copy, and invoke callables: functions, function objects, pointers to member
    functions, pointers to member data, lambda expressions, and bind expressions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::any`, which is a type that represents a container to a value of any type
    that is copy-constructible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Static polymorphism with the curiously recurring template pattern,* to learn
    about CRTP, which allows simulating runtime polymorphism at compile time by deriving
    classes from a base class template parameterized with the derived class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Adding functionality to classes with mixins,* to learn how you can add common
    functionality to existing classes without changing them'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 6*, *Using std::any to Store Any Value*, to learn how to use the C++17
    `std::any` class, which represents a type-safe container for single values of
    any type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a thread-safe singleton
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Singleton is probably one of the most well-known design patterns. It restricts
    the instantiation of a single object of a class, something that is necessary in
    some cases, although many times the use of a singleton is rather an anti-pattern
    that can be avoided with other design choices.
  prefs: []
  type: TYPE_NORMAL
- en: Since a singleton means a single instance of a class is available to an entire
    program, it is likely that such a unique instance might be accessible from different
    threads. Therefore, when you implement a singleton, you should also make it thread-safe.
  prefs: []
  type: TYPE_NORMAL
- en: Before C++11, doing that was not an easy job, and a double-checked locking technique
    was the typical approach. However, Scott Meyers and Andrei Alexandrescu showed,
    in a paper called *C++ and the Perils of Double-Checked Locking*, that using this
    pattern did not guarantee a thread-safe singleton implementation in portable C++.
    Fortunately, this changed in C++11, and this recipe shows how to write a thread-safe
    singleton in modern C++.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you need to know how static storage duration, internal linkage,
    and deleted and defaulted functions work. You should also read the previous recipe
    *Static polymorphism with the curiously recurring template pattern* first if you
    have not done that yet and are not familiar with that pattern, as we will use
    it later in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To implement a thread-safe singleton, you should do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the `Singleton` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make the default constructor private:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make the copy constructor and copy assignment operator `public` and `delete`,
    respectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The function that creates and returns the single instance should be static
    and should return a reference to the class type. It should declare a static object
    of the class type and return a reference to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since singleton objects are not supposed to be created by the user directly,
    all constructors are either private or public and `deleted`. The default constructor
    is private and not deleted because an instance of the class must actually be created
    in the class code. A static function, called `instance()`, in this implementation,
    returns the single instance of the class.
  prefs: []
  type: TYPE_NORMAL
- en: Though most implementations return a pointer, it actually makes more sense to
    return a reference, as there is no circumstance under which this function would
    return a null pointer (no object).
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of the `instance()` method may look simplistic and not thread-safe
    at first glance, especially if you are familiar with the **double-checked locking
    pattern** (**DCLP**). In C++11, this is actually no longer necessary due to a
    key detail of how objects with static storage durations are initialized. Initialization
    happens only once, even if several threads attempt to initialize the same static
    object at the same time. The responsibility of DCLP has been moved from the user
    to the compiler, although the compiler may use another technique to guarantee
    the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following quote from the C++ standard document, version N4917, paragraph
    8.8.3, defines the rules for static object initialization (the highlight is the
    part related to concurrent initialization):'
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic initialization of a block variable with static storage duration (6.7.5.2)
    or thread storage duration (6.7.5.3) is performed the first time control passes
    through its declaration; such a variable is considered initialized upon the completion
    of its initialization. If the initialization exits by throwing an exception, the
    initialization is not complete, so it will be tried again the next time control
    enters the declaration. **If control enters the declaration concurrently while
    the variable is being initialized, the concurrent execution shall wait for completion
    of the initialization.**
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Note 2: A conforming implementation cannot introduce any deadlock around execution
    of the initializer. Deadlocks might still be caused by the program logic; the
    implementation need only avoid deadlocks due to its own synchronization operations.
    —end note]'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If control re-enters the declaration recursively while the variable is being
    initialized, the behavior is undefined.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The static local object has static storage duration, but it is instantiated
    only when it is first used (at the first call to the method `instance()`). The
    object is deallocated when the program exits. As a side note, the only possible
    advantage of returning a pointer and not a reference is the ability to delete
    this single instance at some point, before the program exists, and then maybe
    recreate it. This, again, does not make too much sense, as it conflicts with the
    idea of a single, global instance of a class, accessible at any point from any
    place in the program.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There might be situations in larger code bases where you need more than one
    singleton type. In order to avoid writing the same pattern several times, you
    can implement it in a generic way. For this, we need to employ the **curiously
    recurring template pattern** (or **CRTP**) seen earlier in the chapter. The actual
    singleton is implemented as a class template. The `instance()` method creates
    and returns an object of the type template parameter, which will be the derived
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The `Singleton` class from the previous section has become the `SingletonBase`
    class template. The default constructor is no longer private but protected because
    it must be accessible from the derived class. In this example, the class that
    needs to have a single object instantiated is called `Single`. Its constructors
    must be private, but the default constructor must also be available to the base
    class template; therefore, `SingletonBase<Single>` is a friend of the `Single`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Static polymorphism with the curiously recurring template pattern,* to learn
    about CRTP, which allows simulating runtime polymorphism at compile time by deriving
    classes from a base class template parameterized with the derived class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 3*, *Defaulted and deleted functions*, to learn about the use of the
    default specifier on special member functions and how to define functions as deleted
    with the delete specifier'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://discord.gg/7xRaTCeEhx](Chapter_10.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code2659294082093549796.png)'
  prefs: []
  type: TYPE_IMG
