<html><head></head><body>

		<p>&#13;
			<h1 id="_idParaDest-563" class="chapter-number"><a id="_idTextAnchor563"/>15</h1>&#13;
			<h1 id="_idParaDest-564"><a id="_idTextAnchor564"/>STL with Ranges</h1>&#13;
			<p>This chapter discusses the transformative adoption of ranges in C++, marking a paradigm shift from traditional iterators. As an integral facet of modern C++, ranges champion expressive and ergonomic code. Through this chapter, you will grasp the mechanics of utilizing ranges with standard algorithms, achieving cleaner code that’s simultaneously intuitive and powerful. By mastering ranges, C++ developers can harness a more compositional and streamlined approach to algorithm application, setting the stage for more maintainable and efficient code bases.</p>&#13;
			<p>This chapter will cover the following topics:</p>&#13;
			<ul>&#13;
				<li>Introduction to ranges</li>&#13;
				<li>Ranges for sorting algorithms</li>&#13;
				<li>Ranges for searching algorithms</li>&#13;
				<li>Best practices</li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-565"><a id="_idTextAnchor565"/>Technical requirements</h1>&#13;
			<p>The code in this chapter can be found on GitHub:</p>&#13;
			<p><a href="https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL">https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL</a></p>&#13;
			<h1 id="_idParaDest-566"><a id="_idTextAnchor566"/>Introduction to ranges</h1>&#13;
			<p>Programming <a id="_idIndexMarker887"/>paradigms evolve, and C++ is no exception. As the journey through the vast landscape of the C++ <strong class="bold">Standard Template Library</strong> (<strong class="bold">STL</strong>) unfolds, it is evident that adaptability and growth have been at their core. One such evolutionary step, which stands out for its expressiveness and efficiency, is the advent of ranges in modern C++. But what exactly are ranges?</p>&#13;
			<h2 id="_idParaDest-567"><a id="_idTextAnchor567"/>Understanding the essence of ranges</h2>&#13;
			<p><code>begin</code> and <code>end</code> to define a sequence, ranges encapsulate this information within a unified entity. This seemingly subtle shift has profound implications, reshaping how we approach algorithms and data manipulations.</p>&#13;
			<p>At a glance, the following shows the verbose legacy way to sort a vector:</p>&#13;
			<pre class="source-code">&#13;
std::sort(v.begin(), v.end());</pre>			<p>However, with ranges, we could express it as follows:</p>&#13;
			<pre class="source-code">&#13;
std::ranges::sort(v);</pre>			<p>The beauty lies in the clarity and conciseness. No longer must we juggle multiple iterators; the range elegantly conveys the intent.</p>&#13;
			<h2 id="_idParaDest-568"><a id="_idTextAnchor568"/>Why the shift to ranges?</h2>&#13;
			<p>The evolution<a id="_idIndexMarker889"/> from iterators to ranges wasn’t just a whimsical design choice; it addressed pressing needs in the C++ community, such as the following:</p>&#13;
			<ul>&#13;
				<li><strong class="bold">Expressiveness</strong>: The preceding example shows that the code becomes more readable. Expressing algorithms over entire sequences without explicitly mentioning boundary iterators facilitates a more natural, declarative style of coding.</li>&#13;
				<li><strong class="bold">Composability</strong>: Ranges enable a more functional approach to programming in C++. This means algorithms can be seamlessly composed, leading to modular and easily understandable code.</li>&#13;
				<li><strong class="bold">Error minimization</strong>: By reducing the need to manage individual iterators, there’s a lower chance of errors related to mismatched or incorrectly used iterators. This leads to safer and more maintainable code.</li>&#13;
			</ul>&#13;
			<h2 id="_idParaDest-569"><a id="_idTextAnchor569"/>A glimpse into range operations</h2>&#13;
			<p>Ranges aren’t just about <a id="_idIndexMarker890"/>cleaner syntax; they offer a plethora of operations that can transform sequences in expressive ways. Some operations include the following:</p>&#13;
			<ul>&#13;
				<li><strong class="bold">Filtering</strong>: Easily refine sequences based on certain conditions</li>&#13;
				<li><strong class="bold">Transformations</strong>: Modify sequences by applying functions to their elements</li>&#13;
				<li><strong class="bold">Concatenation</strong>: Seamlessly join multiple sequences</li>&#13;
			</ul>&#13;
			<p>With ranges, these operations can be chained, leading to code that’s both intuitive and powerful. For instance, transforming and filtering a sequence becomes a straightforward task with ranges.</p>&#13;
			<h2 id="_idParaDest-570"><a id="_idTextAnchor570"/>Looking ahead – the power of modern STL</h2>&#13;
			<p>The introduction <a id="_idIndexMarker891"/>of ranges in the STL represents a significant stride toward a more expressive and ergonomic C++. As developers embark on this new chapter, they’ll find that the familiar operations they have come to rely on have been enhanced and primed for the modern challenges of the software industry.</p>&#13;
			<p>Ranges in C++ significantly<a id="_idIndexMarker892"/> enhance code quality and developer productivity. Ranges offer a more declarative approach to data manipulation, promoting cleaner and more readable code. They enable operations on collections of data without the explicit need to handle iterators or create temporary containers. This abstraction not only reduces boilerplate but also minimizes the likelihood of errors associated with manual iterator management. Furthermore, ranges facilitate lazy evaluation, where computations are deferred until values are actually needed. This can lead to performance improvements, especially in scenarios involving large datasets or complex filtering criteria. Looking ahead, ranges have the potential to revolutionize C++ coding practices by simplifying algorithm applications, enhancing composability, and potentially introducing more opportunities for compiler optimizations. As the C++ language evolves, ranges will likely become integral in writing more efficient, maintainable, and intuitive code.</p>&#13;
			<p>In this section, we explored the concept of ranges in modern C++, a significant advancement in the C++ STL. Ranges represent an abstraction over sequences, offering a unified way to handle data sequences as opposed to the traditional pair of iterators. This shift to ranges improves code expressiveness, readability, and maintainability. Ranges reduce the need for verbose iterator management, minimizing errors and enhancing code clarity. They support a variety of operations such as filtering, transformations, and concatenation, which can be seamlessly chained for more intuitive and powerful <a id="_idIndexMarker893"/>coding. The advent of ranges in C++ marks a step toward more declarative data manipulation, promising improvements in developer productivity and code quality. As C++ continues to evolve, ranges are poised to play a crucial role in shaping more efficient and ergonomic coding practices.</p>&#13;
			<p>In the following sections, we’ll delve deeper into the nuances of ranges, exploring their applications with classic STL algorithms, and uncovering best practices to ensure that they’re leveraged to their utmost potential.</p>&#13;
			<h1 id="_idParaDest-571"><a id="_idTextAnchor571"/>Ranges for sorting algorithms</h1>&#13;
			<p><strong class="bold">Sorting</strong> is a <a id="_idIndexMarker894"/>fundamental operation, a bedrock in the vast universe of<a id="_idIndexMarker895"/> algorithms. Over the years, the STL has empowered us with robust sorting capabilities. With the introduction of ranges, this power has been augmented by simplifying the syntax and infusing a heightened sense of expressiveness into the mix.</p>&#13;
			<p>In this section, we will explore how ranges simplify the implementation of sorting algorithms in C++. We will examine how range-based sorting reduces the syntactical overhead and potential errors associated with traditional iterator-based methods. Furthermore, we will discuss how ranges enhance the readability and maintainability of sorting code, making it easier to understand and modify.</p>&#13;
			<h2 id="_idParaDest-572"><a id="_idTextAnchor572"/>Traditional STL sorting – a recap</h2>&#13;
			<p>Before diving <a id="_idIndexMarker896"/>into the enhancements brought by ranges, let’s quickly recall the conventional STL sorting approach. Traditionally, the <code>std::sort</code> function is employed, requiring two iterators marking the beginning and the end of the sequence:</p>&#13;
			<pre class="source-code">&#13;
std::vector&lt;int&gt; nums = {4, 1, 3, 2};&#13;
std::sort(nums.begin(), nums.end());</pre>			<p>While effective, this approach leaves room for enhancement in readability and user-friendliness. To address this, enter the STL’s range-based sorting.</p>&#13;
			<h2 id="_idParaDest-573"><a id="_idTextAnchor573"/>Range-based sorting – the basics</h2>&#13;
			<p>Redefining <a id="_idIndexMarker897"/>elegance, the range-based <code>std::ranges::sort</code> function allows us to pass the sequence to be sorted directly. No fussing with iterators. Given our earlier example, with ranges, the sorting becomes the following:</p>&#13;
			<pre class="source-code">&#13;
std::vector&lt;int&gt; nums = {4, 1, 3, 2};&#13;
std::ranges::sort(nums);</pre>			<p>The concise nature of range-based sorting makes it a joy to use, reducing potential error avenues and enhancing readability.</p>&#13;
			<h2 id="_idParaDest-574"><a id="_idTextAnchor574"/>Embracing composability in sorting</h2>&#13;
			<p>One of the crown <a id="_idIndexMarker898"/>jewels of ranges is their ability to facilitate composability, which shines exceptionally bright in sorting scenarios. Consider the need to sort only a subset of a sequence or the necessity to chain multiple operations before sorting. Ranges cater to such needs seamlessly.</p>&#13;
			<p>For example, imagine the requirement to sort only the even numbers from a sequence in reverse order. With ranges, this can be expressed in a few lines, harnessing the power of filtering combined with sorting:</p>&#13;
			<pre class="source-code">&#13;
#include &lt;algorithm&gt;&#13;
#include &lt;iostream&gt;&#13;
#include &lt;ranges&gt;&#13;
#include &lt;vector&gt;&#13;
int main() {&#13;
  std::vector&lt;int&gt; data = {5, 2, 9, 1, 5, 6, 8, 7, 3, 4};&#13;
  // Create a view of the data that filters even numbers&#13;
  // and then sorts them&#13;
  auto even_sorted =&#13;
      data | std::views::filter([](int x) {&#13;
        return x % 2 == 0;&#13;
      }) |&#13;
      std::views::transform([](int x) { return -x; }) |&#13;
      std::ranges::to&lt;std::vector&lt;int&gt;&gt;();&#13;
  std::sort(even_sorted.begin(), even_sorted.end());&#13;
  // Display the sorted even numbers&#13;
  std::cout &lt;&lt; "Sorted even numbers: ";&#13;
  for (int num : even_sorted) { std::cout &lt;&lt; num &lt;&lt; " "; }&#13;
  std::cout &lt;&lt; "\n";&#13;
  return 0;&#13;
}</pre>			<p>Here is the example output<a class="_idFootnoteLink _idGenColorInherit" href="B21945_15.xhtml#footnote-000">1</a>:</p>&#13;
			<div>&#13;
				<p><a class="_idFootnoteAnchor _idGenColorInherit" href="B21945_15.xhtml#footnote-000-backlink">1</a> This example has been tested to work with Visual Studio v17.8.6 but does not yet compile with GCC v13.2 or Clang v17.0.1.</p>&#13;
			</p>&#13;
			<pre class="console">&#13;
Sorted even numbers: -8 -6 -4 -2</pre>			<p>In this <a id="_idIndexMarker899"/>example, vector data contains a sequence of integers. We use a range pipeline to create a view that first filters out the even numbers using <code>std::views::filter</code>. Then, we use <code>std::views::transform</code> to negate the numbers, allowing them to be sorted in reverse order. Finally, <code>std::ranges::to</code> is used to convert the view into a vector. The sorted even numbers are then displayed. This showcases the composability of ranges, allowing for concise and expressive manipulation of data sequences.</p>&#13;
			<p>The ability to chain operations, leading from filtering to sorting fluidly, exemplifies the compositional strength of ranges.</p>&#13;
			<h2 id="_idParaDest-575"><a id="_idTextAnchor575"/>Advantages beyond syntax – why ranges shine in sorting</h2>&#13;
			<p>Beyond the evident syntactical elegance, using ranges with STL sorting algorithms offers a buffet of <a id="_idIndexMarker900"/>benefits, such as the following:</p>&#13;
			<ul>&#13;
				<li><code>begin</code> and <code>end</code> in a single entity diminishes the risk of mismatched iterators, elevating code safety.</li>&#13;
				<li><strong class="bold">Flexibility</strong>: Ranges, coupled with views, provide a dynamic toolkit. Whether sorting with custom comparators or adapting to different data structures, the range-based approach remains consistent and straightforward.</li>&#13;
				<li><strong class="bold">Expressive power</strong>: Ranges foster a declarative coding style, wherein the intent of the code stands out. This expressiveness proves invaluable when sorting complex data types or applying multifaceted logic.</li>&#13;
			</ul>&#13;
			<h2 id="_idParaDest-576"><a id="_idTextAnchor576"/>The revolution of ranges in sorting</h2>&#13;
			<p>Sorting, an<a id="_idIndexMarker901"/> operation as old as programming itself, witnesses a rejuvenation with the introduction of ranges. Combining traditional STL sorting prowess with the modern elegance of ranges can revolutionize our implementations with more intuitive, maintainable, and efficient code.</p>&#13;
			<p>Ranges have transformed sorting algorithms in modern C++. We have seen the traditional iterator-based approach of STL sorting with the more streamlined and readable range-based approach. The traditional method, using <code>std::sort</code> with iterators, is effective but can be improved in terms of readability and user-friendliness. Range-based sorting, using <code>std::ranges::sort</code>, simplifies this by allowing direct passing of the sequence, reducing syntactical complexity and potential errors. A key highlight is the composability of ranges, particularly beneficial in sorting scenarios.</p>&#13;
			<p>The advantages of using ranges in sorting extend beyond syntax. They provide safety by encapsulating the beginning and end of sequences into a single entity, reducing the risk of mismatched iterators. They offer flexibility with dynamic tools for sorting using custom comparators or different data structures. Moreover, ranges enable a declarative coding style, making the code’s intent more apparent, especially beneficial for sorting complex data<a id="_idIndexMarker902"/> types or applying intricate logic.</p>&#13;
			<p>The introduction of ranges in C++ has married the traditional strength of STL sorting algorithms with the modern finesse of ranges. This revolution leads to more intuitive, maintainable, and efficient code implementations. The exploration continues in subsequent sections, delving deeper into the interaction of ranges with other STL algorithms for searching and uncovering best practices for their effective utilization.</p>&#13;
			<h1 id="_idParaDest-577"><a id="_idTextAnchor577"/>Ranges for searching algorithms</h1>&#13;
			<p>When <a id="_idIndexMarker903"/>delving into the domain of algorithmic searching within the STL, it’s evident that the advent of ranges heralds an era of simplified and expressive code. To appreciate this evolution, looking back at the traditional search methods in the STL is essential.</p>&#13;
			<p>The classic way of searching within a container involved using functions such as <code>std::find</code> or <code>std::find_if</code>, wherein you’d provide iterators marking the search range:</p>&#13;
			<pre class="source-code">&#13;
std::vector&lt;int&gt; nums = {1, 2, 3, 4, 5};&#13;
auto it = std::find(nums.begin(), nums.end(), 3);</pre>			<p>Effective? Yes. Optimal in terms of expressiveness and adaptability? Perhaps not.</p>&#13;
			<h2 id="_idParaDest-578"><a id="_idTextAnchor578"/>Finding elegance – range-based searching</h2>&#13;
			<p>The<a id="_idIndexMarker904"/> transition to more readable and concise code is evident using the range-based approach. With ranges, searching operations become inherently more declarative, as shown in the following code:</p>&#13;
			<pre class="source-code">&#13;
std::vector&lt;int&gt; nums = {1, 2, 3, 4, 5};&#13;
auto it = std::ranges::find(nums, 3);</pre>			<p>Beyond mere simplicity, the real power of range-based searching emerges when combined with other range adaptors, opening a gateway to more adaptive and modular code.</p>&#13;
			<h2 id="_idParaDest-579"><a id="_idTextAnchor579"/>Chaining and filtering – the beauty of composability</h2>&#13;
			<p>The elegance<a id="_idIndexMarker905"/> of code often lies in its ability to express complex operations in a simple, readable manner. Ranges, with their composability, play a pivotal role in achieving such elegance. Let’s consider a nuanced example to <a id="_idIndexMarker906"/>understand this better: finding the first three numbers in a sequence that are both prime and greater than a specified<a id="_idIndexMarker907"/> value. This task, when approached with traditional STL methods, might involve cumbersome loops and condition checks. However, ranges transform it into an efficient and easily understandable series of operations.</p>&#13;
			<p>Let’s look at an interesting example to illustrate this concept:</p>&#13;
			<pre class="source-code">&#13;
#include &lt;iostream&gt;&#13;
#include &lt;ranges&gt;&#13;
#include &lt;vector&gt;&#13;
bool is_prime(int number) {&#13;
  if (number &lt;= 1) return false;&#13;
  for (int i = 2; i * i &lt;= number; i++) {&#13;
    if (number % i == 0) return false;&#13;
  }&#13;
  return true;&#13;
}&#13;
int main() {&#13;
  std::vector&lt;int&gt; nums = {4,  6,  8,  9,  10, 11,&#13;
                           13, 15, 17, 19, 23, 25};&#13;
  auto prime_greater_than_10 =&#13;
      nums |&#13;
      std::views::filter([](int n) { return n &gt; 10; }) |&#13;
      std::views::filter(is_prime) | std::views::take(3);&#13;
  std::cout&#13;
      &lt;&lt; "First three prime numbers greater than 10: ";&#13;
  for (int num : prime_greater_than_10) {&#13;
    std::cout &lt;&lt; num &lt;&lt; " ";&#13;
  }&#13;
  std::cout &lt;&lt; "\n";&#13;
  return 0;&#13;
}</pre>			<p>Here is the example output:</p>&#13;
			<pre class="console">&#13;
First three prime numbers greater than 10: 11 13 17</pre>			<p>In this <a id="_idIndexMarker908"/>example, we start with a <code>nums</code> vector containing a sequence of integers. Using ranges, we chain together three operations:</p>&#13;
			<ol>&#13;
				<li>Filtering for numbers greater than 10: <code>std::views::filter([](int n) { return n &gt; 10; })</code> selects numbers greater than.</li>&#13;
				<li>Filtering for prime numbers: <code>std::views::filter(is_prime)</code> uses the <code>is_prime</code> function to keep only prime numbers</li>&#13;
			</ol>&#13;
			<p>Taking the first three elements: <code>std::views::take(3)</code> limits the results to the first three elements that meet the previous criteria.</p>&#13;
			<p>The result is <a id="_idIndexMarker909"/>a seamless integration of conditions in a single, readable line of code. This example not only demonstrates the power of chaining and filtering but also highlights how ranges can significantly enhance the expressiveness and adaptability of C++ code. The combination of simplicity and expressiveness is what makes ranges an invaluable feature in modern C++ development.</p>&#13;
			<h2 id="_idParaDest-580"><a id="_idTextAnchor580"/>Understanding views in searches</h2>&#13;
			<p><strong class="bold">Views</strong> are <a id="_idIndexMarker910"/>pivotal in the range-based landscape, especially in searching scenarios. Unlike containers, views don’t own their elements. They present a transformed <em class="italic">view</em> of their source data, which can be another range (such as a container). When incorporated into searches, views don’t modify the original data but provide a new perspective, which can be particularly useful in modular and reusable code.</p>&#13;
			<h2 id="_idParaDest-581"><a id="_idTextAnchor581"/>The extended toolkit – more than just find</h2>&#13;
			<p>While <code>std::ranges::find</code> is a <a id="_idIndexMarker911"/>cornerstone, the<a id="_idIndexMarker912"/> modern range-based approach offers a broad spectrum of searching algorithms. Functions such as <code>std::ranges::search</code>, which <a id="_idIndexMarker913"/>locates a subsequence, or <code>std::ranges::find_end</code>, which <a id="_idIndexMarker914"/>finds the last occurrence of a sequence, encapsulate the richness of range-based searching. Their true power is unlocked with other range adaptors, offering a palette of possibilities for efficient and expressive searching tasks.</p>&#13;
			<p>Transitioning from traditional methods, range-based searching in the STL stands as a testament to the evolution of C++ toward more readable, modular, and expressive code. As we advance further into the world of ranges, harnessing these tools and techniques will be paramount for those eager to craft efficient and maintainable code.</p>&#13;
			<h1 id="_idParaDest-582"><a id="_idTextAnchor582"/>Best practices</h1>&#13;
			<p>The <a id="_idIndexMarker915"/>transition to range-based STL is undoubtedly exhilarating. With this newfound expressiveness and clarity, we have powerful tools at our fingertips. However, understanding a set of best practices is essential to maximize the potential of ranges and ensure the maintainability of your code base. Let us look at some of the best practices that we can implement.</p>&#13;
			<h2 id="_idParaDest-583"><a id="_idTextAnchor583"/>Embracing the power of chaining</h2>&#13;
			<p>One of the standout features of ranges is their natural ability to chain operations. Chaining not only enhances readability but also improves efficiency by avoiding intermediary storage:</p>&#13;
			<pre class="source-code">&#13;
std::vector&lt;int&gt; nums = {5, 8, 10, 14, 18};&#13;
auto result = nums | std::views::filter([](int n) { return n % 2 == 0; })&#13;
                   | std::views::transform([](int n) { return n * 2; });</pre>			<p>This elegant one-liner filters out odd numbers and then doubles the even ones. By promoting such chaining, you can foster cleaner, more concise code.</p>&#13;
			<h2 id="_idParaDest-584"><a id="_idTextAnchor584"/>Guarding against range pitfalls – lifetime awareness</h2>&#13;
			<p>Going all out with ranges is tempting, especially with their composability. Yet, caution is advised. One of the most common pitfalls is the unintentional dangling of views, as shown in the following code:</p>&#13;
			<pre class="source-code">&#13;
auto doubledEvens() {&#13;
    std::vector&lt;int&gt; nums = {1, 2, 3, 4, 5};&#13;
    return nums | std::views::filter([](int n) { return n % 2 == 0; })&#13;
                | std::views::transform([](int n) { return n * 2; });&#13;
}</pre>			<p>The preceding code returns a view on a local variable. As this function exits, the local variable will be destroyed. Since a view of this destroyed variable is being returned, it will lead to undefined behavior. Always be aware of the lifetime of the underlying data when working with views.</p>&#13;
			<h2 id="_idParaDest-585"><a id="_idTextAnchor585"/>Performance considerations – laziness and evaluation</h2>&#13;
			<p>Ranges, especially<a id="_idIndexMarker916"/> views, operate lazily. This means that they evaluate their elements only when accessed. While this can be a boon for efficiency, it might also lead to pitfalls, especially when combined with stateful operations or side effects, as illustrated in the following example:</p>&#13;
			<pre class="source-code">&#13;
int x = 0;&#13;
auto range = std::views::iota(1) | std::views::transform([&amp;x](int n) { return x += n; });</pre>			<p>If <code>range</code> is evaluated multiple times, the side effect in the lambda accumulates, leading to unexpected results. It is advisable to force an eager evaluation for such scenarios, perhaps by converting the range to a container.</p>&#13;
			<h2 id="_idParaDest-586"><a id="_idTextAnchor586"/>Readability over brevity – striking the balance</h2>&#13;
			<p>While ranges enable concise code, remember the cardinal rule: code is read more often than written. Overly compacted chains of range operations can be challenging to understand, especially for those new to the code base. Strike a balance between brevity and clarity.</p>&#13;
			<h2 id="_idParaDest-587"><a id="_idTextAnchor587"/>Adhering to range idioms – keep it standard</h2>&#13;
			<p>As with other parts of the C++ language, certain idioms and patterns have emerged for using ranges. When possible, prefer the standard idioms. (For example, use <code>std::ranges::sort</code> for sorting and <code>std::ranges::find</code> for finding. Both of these are better than writing your own loops to do essentially the same thing.) This makes your code more understandable to other C++ developers and ensures that you benefit from community-tested patterns.</p>&#13;
			<p>This section highlights key best practices for effectively using range-based STL in C++. It emphasizes the importance of embracing the power of chaining, which enhances code readability and efficiency by avoiding intermediary storage. However, it also cautions against common pitfalls, such as dangling views, and advises awareness of the lifetime of underlying data. The section notes the lazy evaluation nature of ranges, recommending eager evaluation in scenarios involving stateful operations or side effects to avoid unexpected results. Additionally, it advises maintaining a balance between code conciseness <a id="_idIndexMarker917"/>and readability, ensuring that code remains accessible and understandable. Finally, it suggests adhering to established range idioms, leveraging standard patterns for better clarity and community alignment. These practices aim to maximize the potential of ranges while ensuring maintainable and robust code.</p>&#13;
			<h1 id="_idParaDest-588"><a id="_idTextAnchor588"/>Summary</h1>&#13;
			<p>In this chapter, we explored the concept of ranges in the C++ STL and how they enhance how we work with sequences of elements. We began with an introduction to ranges, understanding their essence and the motivations behind the shift to this new paradigm. We saw how range operations facilitate more expressive and readable code, and we delved into the composability that ranges introduce to sorting algorithms.</p>&#13;
			<p>The chapter then focused on range-based sorting, discussing the basic concepts and the advantages ranges bring to the table, such as cleaner syntax and improved composability. We also examined the application of ranges in searching algorithms, appreciating the elegant and powerful ways ranges enable us to chain operations and apply filters.</p>&#13;
			<p>Ranges help us write cleaner code in a way that better expresses our intent. The shift to ranges represents a significant evolution in the STL, offering enhanced clarity and efficiency in code. It allows us to compose complex operations in a more readable and maintainable way, which is beneficial for both the development process and the longevity of the code base.</p>&#13;
			<p>Now that we have a strong understanding of STL data types, algorithms, and other core concepts, we will use this knowledge in the next chapter to create our own container types that integrate seamlessly with the existing STL algorithms and iterators. We will cover the essential requirements for STL compatibility, such as iterator implementation and value semantics. We will guide you through the effective use of operator overloading and the creation of custom hash functions. By learning to create STL-compatible containers, we can extend the STL to suit their specific needs, ensuring that their custom types can benefit from the power and flexibility of the STL algorithms and practices.</p>&#13;
		</div>&#13;
	

		<div><h1 id="_idParaDest-589" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor589"/>Part 4:  Creating STL-Compatible  Types and Algorithms</h1>
		</div>
		<div><p>This part of our book is dedicated to the creation and integration of custom types and algorithms within the C++ Standard Template Library ecosystem. We start by exploring the construction of STL-compatible containers, detailing the essential requirements for seamless interoperability with STL algorithms. We discuss the importance of crafting robust iterators and the nuances of operator overloading to provide intuitive and consistent behavior for custom types. Special attention is given to creating custom hash functions to facilitate the use of user-defined types with unordered associative containers.</p>
			<p>Next, we get into the intricacies of developing STL-compatible algorithms. This includes mastering template functions, understanding the subtleties of overloading, and leveraging inline functions for performance. We will emphasize the use of predicates and functors for enhanced flexibility.</p>
			<p>Finally, we are introduced to type traits and policies, powerful tools that allow developers to craft more adaptable and modular code. We gain insights into implementing these concepts effectively, ensuring that your custom types and algorithms not only integrate well with the STL but also adhere to best practices in modern C++ programming.</p>
			<p>By the end of this part, you will have gained the knowledge to extend the STL to fit your unique requirements, fostering a deeper understanding of template metaprogramming and the powerful abstractions provided by C++.</p>
			<p>This part has the following chapters:</p>
			<ul>
				<li><a href="B21945_16.xhtml#_idTextAnchor590"><em class="italic">Chapter 16</em></a><em class="italic">: Creating STL-Types Containers</em></li>
				<li><a href="B21945_17.xhtml#_idTextAnchor636"><em class="italic">Chapter 17</em></a><em class="italic">: Creating STL-Compatible Algorithms</em></li>
				<li><a href="B21945_18.xhtml#_idTextAnchor658"><em class="italic">Chapter 18</em></a><em class="italic">: Type Traits and Policies</em></li>
			</ul>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
	</body></html>