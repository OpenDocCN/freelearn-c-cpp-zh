<html><head></head><body>
		<div id="_idContainer033">&#13;
			<h1 id="_idParaDest-563" class="chapter-number"><a id="_idTextAnchor563"/>15</h1>&#13;
			<h1 id="_idParaDest-564"><a id="_idTextAnchor564"/>STL with Ranges</h1>&#13;
			<p>This chapter discusses the transformative adoption of ranges in C++, marking a paradigm shift from traditional iterators. As an integral facet of modern C++, ranges champion expressive and ergonomic code. Through this chapter, you will grasp the mechanics of utilizing ranges with standard algorithms, achieving cleaner code that’s simultaneously intuitive and powerful. By mastering ranges, C++ developers can harness a more compositional and streamlined approach to algorithm application, setting the stage for more maintainable and efficient <span class="No-Break">code bases.</span></p>&#13;
			<p>This chapter will cover the <span class="No-Break">following topics:</span></p>&#13;
			<ul>&#13;
				<li>Introduction <span class="No-Break">to ranges</span></li>&#13;
				<li>Ranges for <span class="No-Break">sorting algorithms</span></li>&#13;
				<li>Ranges for <span class="No-Break">searching algorithms</span></li>&#13;
				<li><span class="No-Break">Best practices</span></li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-565"><a id="_idTextAnchor565"/>Technical requirements</h1>&#13;
			<p>The code in this chapter can be found <span class="No-Break">on GitHub:</span></p>&#13;
			<p><a href="https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL"><span class="No-Break">https://github.com/PacktPublishing/Data-Structures-and-Algorithms-with-the-CPP-STL</span></a></p>&#13;
			<h1 id="_idParaDest-566"><a id="_idTextAnchor566"/>Introduction to ranges</h1>&#13;
			<p>Programming <a id="_idIndexMarker887"/>paradigms evolve, and C++ is no exception. As the journey through the vast landscape of the C++ <strong class="bold">Standard Template Library</strong> (<strong class="bold">STL</strong>) unfolds, it is evident that adaptability and growth have been at their core. One such evolutionary step, which stands out for its expressiveness and efficiency, is the advent of ranges in modern C++. But what exactly <span class="No-Break">are ranges?</span></p>&#13;
			<h2 id="_idParaDest-567"><a id="_idTextAnchor567"/>Understanding the essence of ranges</h2>&#13;
			<p><strong class="bold">Ranges</strong>, in <a id="_idIndexMarker888"/>the simplest of terms, are an abstraction over sequences of values. Unlike traditional iterators, which typically require pairs of <strong class="source-inline">begin</strong> and <strong class="source-inline">end</strong> to define a sequence, ranges encapsulate this information within a unified entity. This seemingly subtle shift has profound implications, reshaping how we approach algorithms and <span class="No-Break">data manipulations.</span></p>&#13;
			<p>At a glance, the following shows the verbose legacy way to sort <span class="No-Break">a vector:</span></p>&#13;
			<pre class="source-code">&#13;
std::sort(v.begin(), v.end());</pre>			<p>However, with ranges, we could express it <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code">&#13;
std::ranges::sort(v);</pre>			<p>The beauty lies in the clarity and conciseness. No longer must we juggle multiple iterators; the range elegantly conveys <span class="No-Break">the intent.</span></p>&#13;
			<h2 id="_idParaDest-568"><a id="_idTextAnchor568"/>Why the shift to ranges?</h2>&#13;
			<p>The evolution<a id="_idIndexMarker889"/> from iterators to ranges wasn’t just a whimsical design choice; it addressed pressing needs in the C++ community, such as <span class="No-Break">the following:</span></p>&#13;
			<ul>&#13;
				<li><strong class="bold">Expressiveness</strong>: The preceding example shows that the code becomes more readable. Expressing algorithms over entire sequences without explicitly mentioning boundary iterators facilitates a more natural, declarative style <span class="No-Break">of coding.</span></li>&#13;
				<li><strong class="bold">Composability</strong>: Ranges enable a more functional approach to programming in C++. This means algorithms can be seamlessly composed, leading to modular and easily <span class="No-Break">understandable code.</span></li>&#13;
				<li><strong class="bold">Error minimization</strong>: By reducing the need to manage individual iterators, there’s a lower chance of errors related to mismatched or incorrectly used iterators. This leads to safer and more <span class="No-Break">maintainable code.</span></li>&#13;
			</ul>&#13;
			<h2 id="_idParaDest-569"><a id="_idTextAnchor569"/>A glimpse into range operations</h2>&#13;
			<p>Ranges aren’t just about <a id="_idIndexMarker890"/>cleaner syntax; they offer a plethora of operations that can transform sequences in expressive ways. Some operations include <span class="No-Break">the following:</span></p>&#13;
			<ul>&#13;
				<li><strong class="bold">Filtering</strong>: Easily refine sequences based on <span class="No-Break">certain conditions</span></li>&#13;
				<li><strong class="bold">Transformations</strong>: Modify sequences by applying functions to <span class="No-Break">their elements</span></li>&#13;
				<li><strong class="bold">Concatenation</strong>: Seamlessly join <span class="No-Break">multiple sequences</span></li>&#13;
			</ul>&#13;
			<p>With ranges, these operations can be chained, leading to code that’s both intuitive and powerful. For instance, transforming and filtering a sequence becomes a straightforward task <span class="No-Break">with ranges.</span></p>&#13;
			<h2 id="_idParaDest-570"><a id="_idTextAnchor570"/>Looking ahead – the power of modern STL</h2>&#13;
			<p>The introduction <a id="_idIndexMarker891"/>of ranges in the STL represents a significant stride toward a more expressive and ergonomic C++. As developers embark on this new chapter, they’ll find that the familiar operations they have come to rely on have been enhanced and primed for the modern challenges of the <span class="No-Break">software industry.</span></p>&#13;
			<p>Ranges in C++ significantly<a id="_idIndexMarker892"/> enhance code quality and developer productivity. Ranges offer a more declarative approach to data manipulation, promoting cleaner and more readable code. They enable operations on collections of data without the explicit need to handle iterators or create temporary containers. This abstraction not only reduces boilerplate but also minimizes the likelihood of errors associated with manual iterator management. Furthermore, ranges facilitate lazy evaluation, where computations are deferred until values are actually needed. This can lead to performance improvements, especially in scenarios involving large datasets or complex filtering criteria. Looking ahead, ranges have the potential to revolutionize C++ coding practices by simplifying algorithm applications, enhancing composability, and potentially introducing more opportunities for compiler optimizations. As the C++ language evolves, ranges will likely become integral in writing more efficient, maintainable, and <span class="No-Break">intuitive code.</span></p>&#13;
			<p>In this section, we explored the concept of ranges in modern C++, a significant advancement in the C++ STL. Ranges represent an abstraction over sequences, offering a unified way to handle data sequences as opposed to the traditional pair of iterators. This shift to ranges improves code expressiveness, readability, and maintainability. Ranges reduce the need for verbose iterator management, minimizing errors and enhancing code clarity. They support a variety of operations such as filtering, transformations, and concatenation, which can be seamlessly chained for more intuitive and powerful <a id="_idIndexMarker893"/>coding. The advent of ranges in C++ marks a step toward more declarative data manipulation, promising improvements in developer productivity and code quality. As C++ continues to evolve, ranges are poised to play a crucial role in shaping more efficient and ergonomic <span class="No-Break">coding practices.</span></p>&#13;
			<p>In the following sections, we’ll delve deeper into the nuances of ranges, exploring their applications with classic STL algorithms, and uncovering best practices to ensure that they’re leveraged to their <span class="No-Break">utmost potential.</span></p>&#13;
			<h1 id="_idParaDest-571"><a id="_idTextAnchor571"/>Ranges for sorting algorithms</h1>&#13;
			<p><strong class="bold">Sorting</strong> is a <a id="_idIndexMarker894"/>fundamental operation, a bedrock in the vast universe of<a id="_idIndexMarker895"/> algorithms. Over the years, the STL has empowered us with robust sorting capabilities. With the introduction of ranges, this power has been augmented by simplifying the syntax and infusing a heightened sense of expressiveness into <span class="No-Break">the mix.</span></p>&#13;
			<p>In this section, we will explore how ranges simplify the implementation of sorting algorithms in C++. We will examine how range-based sorting reduces the syntactical overhead and potential errors associated with traditional iterator-based methods. Furthermore, we will discuss how ranges enhance the readability and maintainability of sorting code, making it easier to understand <span class="No-Break">and modify.</span></p>&#13;
			<h2 id="_idParaDest-572"><a id="_idTextAnchor572"/>Traditional STL sorting – a recap</h2>&#13;
			<p>Before diving <a id="_idIndexMarker896"/>into the enhancements brought by ranges, let’s quickly recall the conventional STL sorting approach. Traditionally, the <strong class="source-inline">std::sort</strong> function is employed, requiring two iterators marking the beginning and the end of <span class="No-Break">the sequence:</span></p>&#13;
			<pre class="source-code">&#13;
std::vector&lt;int&gt; nums = {4, 1, 3, 2};&#13;
std::sort(nums.begin(), nums.end());</pre>			<p>While effective, this approach leaves room for enhancement in readability and user-friendliness. To address this, enter the STL’s <span class="No-Break">range-based sorting.</span></p>&#13;
			<h2 id="_idParaDest-573"><a id="_idTextAnchor573"/>Range-based sorting – the basics</h2>&#13;
			<p>Redefining <a id="_idIndexMarker897"/>elegance, the range-based <strong class="source-inline">std::ranges::sort</strong> function allows us to pass the sequence to be sorted directly. No fussing with iterators. Given our earlier example, with ranges, the sorting becomes <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code">&#13;
std::vector&lt;int&gt; nums = {4, 1, 3, 2};&#13;
std::ranges::sort(nums);</pre>			<p>The concise nature of range-based sorting makes it a joy to use, reducing potential error avenues and <span class="No-Break">enhancing readability.</span></p>&#13;
			<h2 id="_idParaDest-574"><a id="_idTextAnchor574"/>Embracing composability in sorting</h2>&#13;
			<p>One of the crown <a id="_idIndexMarker898"/>jewels of ranges is their ability to facilitate composability, which shines exceptionally bright in sorting scenarios. Consider the need to sort only a subset of a sequence or the necessity to chain multiple operations before sorting. Ranges cater to such <span class="No-Break">needs seamlessly.</span></p>&#13;
			<p>For example, imagine the requirement to sort only the even numbers from a sequence in reverse order. With ranges, this can be expressed in a few lines, harnessing the power of filtering combined <span class="No-Break">with sorting:</span></p>&#13;
			<pre class="source-code">&#13;
#include &lt;algorithm&gt;&#13;
#include &lt;iostream&gt;&#13;
#include &lt;ranges&gt;&#13;
#include &lt;vector&gt;&#13;
int main() {&#13;
  std::vector&lt;int&gt; data = {5, 2, 9, 1, 5, 6, 8, 7, 3, 4};&#13;
  // Create a view of the data that filters even numbers&#13;
  // and then sorts them&#13;
  auto even_sorted =&#13;
      data | std::views::filter([](int x) {&#13;
        return x % 2 == 0;&#13;
      }) |&#13;
      std::views::transform([](int x) { return -x; }) |&#13;
      std::ranges::to&lt;std::vector&lt;int&gt;&gt;();&#13;
  std::sort(even_sorted.begin(), even_sorted.end());&#13;
  // Display the sorted even numbers&#13;
  std::cout &lt;&lt; "Sorted even numbers: ";&#13;
  for (int num : even_sorted) { std::cout &lt;&lt; num &lt;&lt; " "; }&#13;
  std::cout &lt;&lt; "\n";&#13;
  return 0;&#13;
}</pre>			<p>Here is the <span class="No-Break">example output</span><span class="No-Break"><span id="footnote-000-backlink"><a class="_idFootnoteLink _idGenColorInherit" href="B21945_15.xhtml#footnote-000">1</a></span></span><span class="No-Break">:</span></p>&#13;
			<div id="footnote-000" class="_idFootnote" epub:type="footnote">&#13;
				<p><a class="_idFootnoteAnchor _idGenColorInherit" href="B21945_15.xhtml#footnote-000-backlink">1</a> This example has been tested to work with Visual Studio v17.8.6 but does not yet compile with GCC v13.2 or <span class="No-Break">Clang v17.0.1.</span></p>&#13;
			</div>&#13;
			<pre class="console">&#13;
Sorted even numbers: -8 -6 -4 -2</pre>			<p>In this <a id="_idIndexMarker899"/>example, vector data contains a sequence of integers. We use a range pipeline to create a view that first filters out the even numbers using <strong class="source-inline">std::views::filter</strong>. Then, we use <strong class="source-inline">std::views::transform</strong> to negate the numbers, allowing them to be sorted in reverse order. Finally, <strong class="source-inline">std::ranges::to</strong> is used to convert the view into a vector. The sorted even numbers are then displayed. This showcases the composability of ranges, allowing for concise and expressive manipulation of <span class="No-Break">data sequences.</span></p>&#13;
			<p>The ability to chain operations, leading from filtering to sorting fluidly, exemplifies the compositional strength <span class="No-Break">of ranges.</span></p>&#13;
			<h2 id="_idParaDest-575"><a id="_idTextAnchor575"/>Advantages beyond syntax – why ranges shine in sorting</h2>&#13;
			<p>Beyond the evident syntactical elegance, using ranges with STL sorting algorithms offers a buffet of <a id="_idIndexMarker900"/>benefits, such as <span class="No-Break">the following:</span></p>&#13;
			<ul>&#13;
				<li><strong class="bold">Safety</strong>: The encapsulation of <strong class="source-inline">begin</strong> and <strong class="source-inline">end</strong> in a single entity diminishes the risk of mismatched iterators, elevating <span class="No-Break">code safety.</span></li>&#13;
				<li><strong class="bold">Flexibility</strong>: Ranges, coupled with views, provide a dynamic toolkit. Whether sorting with custom comparators or adapting to different data structures, the range-based approach remains consistent <span class="No-Break">and straightforward.</span></li>&#13;
				<li><strong class="bold">Expressive power</strong>: Ranges foster a declarative coding style, wherein the intent of the code stands out. This expressiveness proves invaluable when sorting complex data types or applying <span class="No-Break">multifaceted logic.</span></li>&#13;
			</ul>&#13;
			<h2 id="_idParaDest-576"><a id="_idTextAnchor576"/>The revolution of ranges in sorting</h2>&#13;
			<p>Sorting, an<a id="_idIndexMarker901"/> operation as old as programming itself, witnesses a rejuvenation with the introduction of ranges. Combining traditional STL sorting prowess with the modern elegance of ranges can revolutionize our implementations with more intuitive, maintainable, and <span class="No-Break">efficient code.</span></p>&#13;
			<p>Ranges have transformed sorting algorithms in modern C++. We have seen the traditional iterator-based approach of STL sorting with the more streamlined and readable range-based approach. The traditional method, using <strong class="source-inline">std::sort</strong> with iterators, is effective but can be improved in terms of readability and user-friendliness. Range-based sorting, using <strong class="source-inline">std::ranges::sort</strong>, simplifies this by allowing direct passing of the sequence, reducing syntactical complexity and potential errors. A key highlight is the composability of ranges, particularly beneficial in <span class="No-Break">sorting scenarios.</span></p>&#13;
			<p>The advantages of using ranges in sorting extend beyond syntax. They provide safety by encapsulating the beginning and end of sequences into a single entity, reducing the risk of mismatched iterators. They offer flexibility with dynamic tools for sorting using custom comparators or different data structures. Moreover, ranges enable a declarative coding style, making the code’s intent more apparent, especially beneficial for sorting complex data<a id="_idIndexMarker902"/> types or applying <span class="No-Break">intricate logic.</span></p>&#13;
			<p>The introduction of ranges in C++ has married the traditional strength of STL sorting algorithms with the modern finesse of ranges. This revolution leads to more intuitive, maintainable, and efficient code implementations. The exploration continues in subsequent sections, delving deeper into the interaction of ranges with other STL algorithms for searching and uncovering best practices for their <span class="No-Break">effective utilization.</span></p>&#13;
			<h1 id="_idParaDest-577"><a id="_idTextAnchor577"/>Ranges for searching algorithms</h1>&#13;
			<p>When <a id="_idIndexMarker903"/>delving into the domain of algorithmic searching within the STL, it’s evident that the advent of ranges heralds an era of simplified and expressive code. To appreciate this evolution, looking back at the traditional search methods in the STL <span class="No-Break">is essential.</span></p>&#13;
			<p>The classic way of searching within a container involved using functions such as <strong class="source-inline">std::find</strong> or <strong class="source-inline">std::find_if</strong>, wherein you’d provide iterators marking the <span class="No-Break">search range:</span></p>&#13;
			<pre class="source-code">&#13;
std::vector&lt;int&gt; nums = {1, 2, 3, 4, 5};&#13;
auto it = std::find(nums.begin(), nums.end(), 3);</pre>			<p>Effective? Yes. Optimal in terms of expressiveness and adaptability? <span class="No-Break">Perhaps not.</span></p>&#13;
			<h2 id="_idParaDest-578"><a id="_idTextAnchor578"/>Finding elegance – range-based searching</h2>&#13;
			<p>The<a id="_idIndexMarker904"/> transition to more readable and concise code is evident using the range-based approach. With ranges, searching operations become inherently more declarative, as shown in the <span class="No-Break">following code:</span></p>&#13;
			<pre class="source-code">&#13;
std::vector&lt;int&gt; nums = {1, 2, 3, 4, 5};&#13;
auto it = std::ranges::find(nums, 3);</pre>			<p>Beyond mere simplicity, the real power of range-based searching emerges when combined with other range adaptors, opening a gateway to more adaptive and <span class="No-Break">modular code.</span></p>&#13;
			<h2 id="_idParaDest-579"><a id="_idTextAnchor579"/>Chaining and filtering – the beauty of composability</h2>&#13;
			<p>The elegance<a id="_idIndexMarker905"/> of code often lies in its ability to express complex operations in a simple, readable manner. Ranges, with their composability, play a pivotal role in achieving such elegance. Let’s consider a nuanced example to <a id="_idIndexMarker906"/>understand this better: finding the first three numbers in a sequence that are both prime and greater than a specified<a id="_idIndexMarker907"/> value. This task, when approached with traditional STL methods, might involve cumbersome loops and condition checks. However, ranges transform it into an efficient and easily understandable series <span class="No-Break">of operations.</span></p>&#13;
			<p>Let’s look at an interesting example to illustrate <span class="No-Break">this concept:</span></p>&#13;
			<pre class="source-code">&#13;
#include &lt;iostream&gt;&#13;
#include &lt;ranges&gt;&#13;
#include &lt;vector&gt;&#13;
bool is_prime(int number) {&#13;
  if (number &lt;= 1) return false;&#13;
  for (int i = 2; i * i &lt;= number; i++) {&#13;
    if (number % i == 0) return false;&#13;
  }&#13;
  return true;&#13;
}&#13;
int main() {&#13;
  std::vector&lt;int&gt; nums = {4,  6,  8,  9,  10, 11,&#13;
                           13, 15, 17, 19, 23, 25};&#13;
  auto prime_greater_than_10 =&#13;
      nums |&#13;
      std::views::filter([](int n) { return n &gt; 10; }) |&#13;
      std::views::filter(is_prime) | std::views::take(3);&#13;
  std::cout&#13;
      &lt;&lt; "First three prime numbers greater than 10: ";&#13;
  for (int num : prime_greater_than_10) {&#13;
    std::cout &lt;&lt; num &lt;&lt; " ";&#13;
  }&#13;
  std::cout &lt;&lt; "\n";&#13;
  return 0;&#13;
}</pre>			<p>Here is the <span class="No-Break">example output:</span></p>&#13;
			<pre class="console">&#13;
First three prime numbers greater than 10: 11 13 17</pre>			<p>In this <a id="_idIndexMarker908"/>example, we start with a <strong class="source-inline">nums</strong> vector containing a sequence of integers. Using ranges, we chain together <span class="No-Break">three operations:</span></p>&#13;
			<ol>&#13;
				<li>Filtering for numbers greater than 10: <strong class="source-inline">std::views::filter([](int n) { return n &gt; 10; })</strong> selects numbers <span class="No-Break">greater than.</span></li>&#13;
				<li>Filtering for prime numbers: <strong class="source-inline">std::views::filter(is_prime)</strong> uses the <strong class="source-inline">is_prime</strong> function to keep only <span class="No-Break">prime numbers</span></li>&#13;
			</ol>&#13;
			<p>Taking the first three elements: <strong class="source-inline">std::views::take(3)</strong> limits the results to the first three elements that meet the <span class="No-Break">previous criteria.</span></p>&#13;
			<p>The result is <a id="_idIndexMarker909"/>a seamless integration of conditions in a single, readable line of code. This example not only demonstrates the power of chaining and filtering but also highlights how ranges can significantly enhance the expressiveness and adaptability of C++ code. The combination of simplicity and expressiveness is what makes ranges an invaluable feature in modern <span class="No-Break">C++ development.</span></p>&#13;
			<h2 id="_idParaDest-580"><a id="_idTextAnchor580"/>Understanding views in searches</h2>&#13;
			<p><strong class="bold">Views</strong> are <a id="_idIndexMarker910"/>pivotal in the range-based landscape, especially in searching scenarios. Unlike containers, views don’t own their elements. They present a transformed <em class="italic">view</em> of their source data, which can be another range (such as a container). When incorporated into searches, views don’t modify the original data but provide a new perspective, which can be particularly useful in modular and <span class="No-Break">reusable code.</span></p>&#13;
			<h2 id="_idParaDest-581"><a id="_idTextAnchor581"/>The extended toolkit – more than just find</h2>&#13;
			<p>While <strong class="source-inline">std::ranges::find</strong> is a <a id="_idIndexMarker911"/>cornerstone, the<a id="_idIndexMarker912"/> modern range-based approach offers a broad spectrum of searching algorithms. Functions such as <strong class="source-inline">std::ranges::search</strong>, which <a id="_idIndexMarker913"/>locates a subsequence, or <strong class="source-inline">std::ranges::find_end</strong>, which <a id="_idIndexMarker914"/>finds the last occurrence of a sequence, encapsulate the richness of range-based searching. Their true power is unlocked with other range adaptors, offering a palette of possibilities for efficient and expressive <span class="No-Break">searching tasks.</span></p>&#13;
			<p>Transitioning from traditional methods, range-based searching in the STL stands as a testament to the evolution of C++ toward more readable, modular, and expressive code. As we advance further into the world of ranges, harnessing these tools and techniques will be paramount for those eager to craft efficient and <span class="No-Break">maintainable code.</span></p>&#13;
			<h1 id="_idParaDest-582"><a id="_idTextAnchor582"/>Best practices</h1>&#13;
			<p>The <a id="_idIndexMarker915"/>transition to range-based STL is undoubtedly exhilarating. With this newfound expressiveness and clarity, we have powerful tools at our fingertips. However, understanding a set of best practices is essential to maximize the potential of ranges and ensure the maintainability of your code base. Let us look at some of the best practices that we <span class="No-Break">can implement.</span></p>&#13;
			<h2 id="_idParaDest-583"><a id="_idTextAnchor583"/>Embracing the power of chaining</h2>&#13;
			<p>One of the standout features of ranges is their natural ability to chain operations. Chaining not only enhances readability but also improves efficiency by avoiding <span class="No-Break">intermediary storage:</span></p>&#13;
			<pre class="source-code">&#13;
std::vector&lt;int&gt; nums = {5, 8, 10, 14, 18};&#13;
auto result = nums | std::views::filter([](int n) { return n % 2 == 0; })&#13;
                   | std::views::transform([](int n) { return n * 2; });</pre>			<p>This elegant one-liner filters out odd numbers and then doubles the even ones. By promoting such chaining, you can foster cleaner, more <span class="No-Break">concise code.</span></p>&#13;
			<h2 id="_idParaDest-584"><a id="_idTextAnchor584"/>Guarding against range pitfalls – lifetime awareness</h2>&#13;
			<p>Going all out with ranges is tempting, especially with their composability. Yet, caution is advised. One of the most common pitfalls is the unintentional dangling of views, as shown in the <span class="No-Break">following code:</span></p>&#13;
			<pre class="source-code">&#13;
auto doubledEvens() {&#13;
    std::vector&lt;int&gt; nums = {1, 2, 3, 4, 5};&#13;
    return nums | std::views::filter([](int n) { return n % 2 == 0; })&#13;
                | std::views::transform([](int n) { return n * 2; });&#13;
}</pre>			<p>The preceding code returns a view on a local variable. As this function exits, the local variable will be destroyed. Since a view of this destroyed variable is being returned, it will lead to undefined behavior. Always be aware of the lifetime of the underlying data when working <span class="No-Break">with views.</span></p>&#13;
			<h2 id="_idParaDest-585"><a id="_idTextAnchor585"/>Performance considerations – laziness and evaluation</h2>&#13;
			<p>Ranges, especially<a id="_idIndexMarker916"/> views, operate lazily. This means that they evaluate their elements only when accessed. While this can be a boon for efficiency, it might also lead to pitfalls, especially when combined with stateful operations or side effects, as illustrated in the <span class="No-Break">following example:</span></p>&#13;
			<pre class="source-code">&#13;
int x = 0;&#13;
auto range = std::views::iota(1) | std::views::transform([&amp;x](int n) { return x += n; });</pre>			<p>If <strong class="source-inline">range</strong> is evaluated multiple times, the side effect in the lambda accumulates, leading to unexpected results. It is advisable to force an eager evaluation for such scenarios, perhaps by converting the range to <span class="No-Break">a container.</span></p>&#13;
			<h2 id="_idParaDest-586"><a id="_idTextAnchor586"/>Readability over brevity – striking the balance</h2>&#13;
			<p>While ranges enable concise code, remember the cardinal rule: code is read more often than written. Overly compacted chains of range operations can be challenging to understand, especially for those new to the code base. Strike a balance between brevity <span class="No-Break">and clarity.</span></p>&#13;
			<h2 id="_idParaDest-587"><a id="_idTextAnchor587"/>Adhering to range idioms – keep it standard</h2>&#13;
			<p>As with other parts of the C++ language, certain idioms and patterns have emerged for using ranges. When possible, prefer the standard idioms. (For example, use <strong class="source-inline">std::ranges::sort</strong> for sorting and <strong class="source-inline">std::ranges::find</strong> for finding. Both of these are better than writing your own loops to do essentially the same thing.) This makes your code more understandable to other C++ developers and ensures that you benefit from <span class="No-Break">community-tested patterns.</span></p>&#13;
			<p>This section highlights key best practices for effectively using range-based STL in C++. It emphasizes the importance of embracing the power of chaining, which enhances code readability and efficiency by avoiding intermediary storage. However, it also cautions against common pitfalls, such as dangling views, and advises awareness of the lifetime of underlying data. The section notes the lazy evaluation nature of ranges, recommending eager evaluation in scenarios involving stateful operations or side effects to avoid unexpected results. Additionally, it advises maintaining a balance between code conciseness <a id="_idIndexMarker917"/>and readability, ensuring that code remains accessible and understandable. Finally, it suggests adhering to established range idioms, leveraging standard patterns for better clarity and community alignment. These practices aim to maximize the potential of ranges while ensuring maintainable and <span class="No-Break">robust code.</span></p>&#13;
			<h1 id="_idParaDest-588"><a id="_idTextAnchor588"/>Summary</h1>&#13;
			<p>In this chapter, we explored the concept of ranges in the C++ STL and how they enhance how we work with sequences of elements. We began with an introduction to ranges, understanding their essence and the motivations behind the shift to this new paradigm. We saw how range operations facilitate more expressive and readable code, and we delved into the composability that ranges introduce to <span class="No-Break">sorting algorithms.</span></p>&#13;
			<p>The chapter then focused on range-based sorting, discussing the basic concepts and the advantages ranges bring to the table, such as cleaner syntax and improved composability. We also examined the application of ranges in searching algorithms, appreciating the elegant and powerful ways ranges enable us to chain operations and <span class="No-Break">apply filters.</span></p>&#13;
			<p>Ranges help us write cleaner code in a way that better expresses our intent. The shift to ranges represents a significant evolution in the STL, offering enhanced clarity and efficiency in code. It allows us to compose complex operations in a more readable and maintainable way, which is beneficial for both the development process and the longevity of the <span class="No-Break">code base.</span></p>&#13;
			<p>Now that we have a strong understanding of STL data types, algorithms, and other core concepts, we will use this knowledge in the next chapter to create our own container types that integrate seamlessly with the existing STL algorithms and iterators. We will cover the essential requirements for STL compatibility, such as iterator implementation and value semantics. We will guide you through the effective use of operator overloading and the creation of custom hash functions. By learning to create STL-compatible containers, we can extend the STL to suit their specific needs, ensuring that their custom types can benefit from the power and flexibility of the STL algorithms <span class="No-Break">and practices.</span></p>&#13;
		</div>&#13;
	

		<div id="_idContainer034" class="Content">
			<h1 id="_idParaDest-589" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor589"/>Part 4:  Creating STL-Compatible  Types and Algorithms</h1>
		</div>
		<div id="_idContainer035">
			<p>This part of our book is dedicated to the creation and integration of custom types and algorithms within the C++ Standard Template Library ecosystem. We start by exploring the construction of STL-compatible containers, detailing the essential requirements for seamless interoperability with STL algorithms. We discuss the importance of crafting robust iterators and the nuances of operator overloading to provide intuitive and consistent behavior for custom types. Special attention is given to creating custom hash functions to facilitate the use of user-defined types with unordered <span class="No-Break">associative containers.</span></p>
			<p>Next, we get into the intricacies of developing STL-compatible algorithms. This includes mastering template functions, understanding the subtleties of overloading, and leveraging inline functions for performance. We will emphasize the use of predicates and functors for <span class="No-Break">enhanced flexibility.</span></p>
			<p>Finally, we are introduced to type traits and policies, powerful tools that allow developers to craft more adaptable and modular code. We gain insights into implementing these concepts effectively, ensuring that your custom types and algorithms not only integrate well with the STL but also adhere to best practices in modern <span class="No-Break">C++ programming.</span></p>
			<p>By the end of this part, you will have gained the knowledge to extend the STL to fit your unique requirements, fostering a deeper understanding of template metaprogramming and the powerful abstractions provided <span class="No-Break">by C++.</span></p>
			<p>This part has the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B21945_16.xhtml#_idTextAnchor590"><em class="italic">Chapter 16</em></a><em class="italic">: Creating STL-Types Containers</em></li>
				<li><a href="B21945_17.xhtml#_idTextAnchor636"><em class="italic">Chapter 17</em></a><em class="italic">: Creating STL-Compatible Algorithms</em></li>
				<li><a href="B21945_18.xhtml#_idTextAnchor658"><em class="italic">Chapter 18</em></a><em class="italic">: Type Traits and Policies</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer036">
			</div>
		</div>
		<div>
			<div id="_idContainer037" class="Basic-Graphics-Frame">
			</div>
		</div>
	</body></html>