<html><head></head><body>
<div id="_idContainer026">
<h1 class="chapter-number" id="_idParaDest-180"><a id="_idTextAnchor453"/><a id="_idTextAnchor454"/><a id="_idTextAnchor455"/><a id="_idTextAnchor456"/><span class="koboSpan" id="kobo.1.1">10</span></h1>
<h1 id="_idParaDest-181"><a id="_idTextAnchor457"/><span class="koboSpan" id="kobo.2.1">Local Buffer Optimization</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Not all design patterns are concerned with designing class hierarchies. </span><span class="koboSpan" id="kobo.3.2">For commonly occurring problems, a software design pattern is the most general and reusable solution, and, for those programming in C++, one of the most commonly occurring problems is inadequate performance. </span><span class="koboSpan" id="kobo.3.3">One of the most common causes of such poor performance is inefficient memory management. </span><span class="koboSpan" id="kobo.3.4">Patterns were developed to deal with these problems. </span><span class="koboSpan" id="kobo.3.5">In this chapter, we will explore one such pattern that addresses, in particular, the overhead of small, frequent </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">memory allocations.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">The following topics will be covered in </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">What is the overhead of small memory allocations, and how can it </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">be measured?</span></span></li>
<li><span class="koboSpan" id="kobo.9.1">What is local buffer optimization, how does it improve performance, and how can the improvements </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">be measured?</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">When can the local buffer optimization pattern be </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">used effectively?</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">What are the possible downsides of, and restrictions on, the use of the local buffer </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">optimization pattern?</span></span></li>
</ul>
<h1 id="_idParaDest-182"><a id="_idTextAnchor458"/><span class="koboSpan" id="kobo.15.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.16.1">You will need the Google Benchmark library installed and configured, details for which can be found here: </span><a href="https://github.com/google/benchmark"><span class="koboSpan" id="kobo.17.1">https://github.com/google/benchmark</span></a><span class="koboSpan" id="kobo.18.1"> (see </span><a href="B19262_04.xhtml#_idTextAnchor152"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.19.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.20.1">, </span><em class="italic"><span class="koboSpan" id="kobo.21.1">Swap – From Simple to Subtle</span></em><span class="koboSpan" id="kobo.22.1">, for </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">installation instructions).</span></span></p>
<p><span class="koboSpan" id="kobo.24.1">Example code can be found at the following </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">link: </span></span><a href="https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/main/Chapter10"><span class="No-Break"><span class="koboSpan" id="kobo.26.1">https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/main/Chapter10</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.27.1">.</span></span></p>
<h1 id="_idParaDest-183"><a id="_idTextAnchor459"/><a id="_idTextAnchor460"/><a id="_idTextAnchor461"/><span class="koboSpan" id="kobo.28.1">The overhead of small memory allocations</span></h1>
<p><span class="koboSpan" id="kobo.29.1">The local buffer </span><a id="_idIndexMarker545"/><span class="koboSpan" id="kobo.30.1">optimization is just that - an optimization. </span><span class="koboSpan" id="kobo.30.2">It is a performance-oriented pattern, and we must, therefore, keep in mind the first rule of performance - never guess anything about performance. </span><span class="koboSpan" id="kobo.30.3">Performance, and the effect of any optimization, must </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">be</span><a id="_idTextAnchor462"/><span class="koboSpan" id="kobo.32.1"> measured.</span></span><a id="_idTextAnchor463"/></p>
<h2 id="_idParaDest-184"><a id="_idTextAnchor464"/><span class="koboSpan" id="kobo.33.1">The cost of memory allocations</span></h2>
<p><span class="koboSpan" id="kobo.34.1">Since we are exploring the overhead of memory allocations and the ways to reduce it, the first question we must answer is how expensive a memory allocation is. </span><span class="koboSpan" id="kobo.34.2">After all, nobody wants </span><a id="_idIndexMarker546"/><span class="koboSpan" id="kobo.35.1">to optimize something so fast that it needs no optimization. </span><span class="koboSpan" id="kobo.35.2">We can use Google Benchmark (or any other microbenchmark, if you prefer) to answer this question. </span><span class="koboSpan" id="kobo.35.3">The simplest benchmark to measure the cost of memory allocation might look </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.37.1">
void BM_malloc(benchmark::State&amp; state) {
  for (auto _ : state) {
    void* p = malloc(64);
    benchmark::DoNotOptimize(p);
  }
  state.SetItemsProcessed(state.iterations());
}
BENCHMARK(BM_malloc_free);</span></pre>
<p><span class="koboSpan" id="kobo.38.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.39.1">benchmark::DoNotOptimize</span></strong><span class="koboSpan" id="kobo.40.1"> wrapper prevents the compiler from optimizing away the unused variable. </span><span class="koboSpan" id="kobo.40.2">Alas, this experiment is probably not going to end well; the microbenchmark library needs to run the test many times, often millions of times, to accumulate a sufficiently accurate average runtime. </span><span class="koboSpan" id="kobo.40.3">It is highly likely that the machine will run out of memory before the benchmark is complete. </span><span class="koboSpan" id="kobo.40.4">The fix is easy enough, we must also free the memory </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">we allocated:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.42.1">
// Example 01
void BM_malloc_free(benchmark::State&amp; state) {
  const size_t S = state.range(0);
  for (auto _ : state) {
    void* p = malloc(S);
    benchmark::DoNotOptimize(p); free(p);
  }
  state.SetItemsProcessed(state.iterations());
}
BENCHMARK(BM_malloc_free)-&gt;Arg(64);</span></pre>
<p><span class="koboSpan" id="kobo.43.1">We must note that we now measure the cost of both allocation and deallocation, which is reflected in the changed name of the function. </span><span class="koboSpan" id="kobo.43.2">This is not an unreasonable change; any allocated </span><a id="_idIndexMarker547"/><span class="koboSpan" id="kobo.44.1">memory will need to be deallocated sometime later, so the cost must be paid at some point. </span><span class="koboSpan" id="kobo.44.2">We have also changed the benchmark to be parameterized by the allocation size. </span><span class="koboSpan" id="kobo.44.3">If you run this benchmark, you should get something </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.46.1">
Benchmark                 Time   Items per second
BM_malloc_free/64        19.2 ns 52.2041M/s</span></pre>
<p><span class="koboSpan" id="kobo.47.1">This tells us that the allocation and deallocation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.48.1">64</span></strong><span class="koboSpan" id="kobo.49.1"> bytes of memory cost about </span><strong class="source-inline"><span class="koboSpan" id="kobo.50.1">19</span></strong><span class="koboSpan" id="kobo.51.1"> nanoseconds on this particular machine, which adds up to 52 million allocations/deallocations per second. </span><span class="koboSpan" id="kobo.51.2">If you’re curious whether the </span><em class="italic"><span class="koboSpan" id="kobo.52.1">64 bytes</span></em><span class="koboSpan" id="kobo.53.1"> size is special in some way, you can change the size value in the argument of the benchmark, or run the benchmark for a whole range </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">of sizes:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.55.1">
void BM_malloc_free(benchmark::State&amp; state) {
  const size_t S = state.range(0);
  for (auto _ : state) {
    void* p = malloc(S);
    benchmark::DoNotOptimize(p); free(p);
  }
  state.SetItemsProcessed(state.iterations());
}
BENCHMARK(BM_malloc_free)-&gt;
  RangeMultiplier(2)-&gt;Range(32,   256);</span></pre>
<p><span class="koboSpan" id="kobo.56.1">You might also note that, so far, we have measured the time it takes to make the very first memory allocation in the program since we have not allocated anything else. </span><span class="koboSpan" id="kobo.56.2">The C++ runtime </span><a id="_idIndexMarker548"/><span class="koboSpan" id="kobo.57.1">system probably did some dynamic allocations at the startup of the program, but still, this is not a very realistic benchmark. </span><span class="koboSpan" id="kobo.57.2">We can make the measurement more relevant by reallocating some amount </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">of memory:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.59.1">
// Example 02
#define REPEAT2(x) x x
#define REPEAT4(x) REPEAT2(x) REPEAT2(x)
#define REPEAT8(x) REPEAT4(x) REPEAT4(x)
#define REPEAT16(x) REPEAT8(x) REPEAT8(x)
#define REPEAT32(x) REPEAT16(x) REPEAT16(x)
#define REPEAT(x) REPEAT32(x)
void BM_malloc_free(benchmark::State&amp; state) {
  const size_t S = state.range(0);
  const size_t N = state.range(1);
  std::vector&lt;void*&gt; v(N);
  for (size_t i = 0; i &lt; N; ++i) v[i] = malloc(</span><a id="_idTextAnchor465"/><span class="koboSpan" id="kobo.60.1">S);
  for (auto _ : state) {
    REPEAT({
      void* p = malloc(S);
      benchmark::DoNotOptimize(p);
      free(p);
    });
  }
  state.SetItemsProcessed(32*state.iterations());
  for (size_t i = 0; i &lt; N; ++i) free(v[i]);
}
BENCHMARK(BM_malloc_free)-&gt;
  RangeMultiplier(2)-&gt;Ranges({{32, 256}, {1&lt;&lt;15, 1&lt;&lt;15}});</span></pre>
<p><span class="koboSpan" id="kobo.61.1">Here, we make </span><strong class="source-inline"><span class="koboSpan" id="kobo.62.1">N</span></strong><span class="koboSpan" id="kobo.63.1"> calls to </span><strong class="source-inline"><span class="koboSpan" id="kobo.64.1">malloc</span></strong><span class="koboSpan" id="kobo.65.1"> before starting the benchmark. </span><span class="koboSpan" id="kobo.65.2">Further improvements can be achieved by varying the allocation size during the reallocations. </span><span class="koboSpan" id="kobo.65.3">We have also </span><a id="_idIndexMarker549"/><span class="koboSpan" id="kobo.66.1">replicated the body of the benchmark loop </span><strong class="source-inline"><span class="koboSpan" id="kobo.67.1">32</span></strong><span class="koboSpan" id="kobo.68.1"> times (using the C preprocessor macro) to reduce the overhead of the loop itself on the measurement. </span><span class="koboSpan" id="kobo.68.2">The time reported by the benchmark is now the time it takes to do </span><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">32</span></strong><span class="koboSpan" id="kobo.70.1"> allocations and deallocations, which is not very convenient, but the allocation rate remains valid, since we have accounted for the loop unrolling, and multiplied the number of iterations by </span><strong class="source-inline"><span class="koboSpan" id="kobo.71.1">32</span></strong><span class="koboSpan" id="kobo.72.1"> when setting the number of processed items (in Google Benchmark, an item is whatever you want it to be, and the number of items per second is reported at the end of the benchmark, so we have declared one allocation/deallocation to be </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">an item).</span></span></p>
<p><span class="koboSpan" id="kobo.74.1">Even with all these modifications and improvements, the final result is going to be pretty close to our initial measurement of </span><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">54</span></strong><span class="koboSpan" id="kobo.76.1"> million allocations per second. </span><span class="koboSpan" id="kobo.76.2">This seems very fast, just </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">18</span></strong><span class="koboSpan" id="kobo.78.1"> nanoseconds. </span><span class="koboSpan" id="kobo.78.2">Remember, however, that a modern CPU can do dozens of instructions in this time. </span><span class="koboSpan" id="kobo.78.3">As we are dealing with small allocations, it is highly likely that the processing time spent on each allocated memory fragment is also small, and the overhead of allocation is non-trivial. </span><span class="koboSpan" id="kobo.78.4">This, of course, represents guessing about performance and is something I warned you against, and so we will confirm this claim via </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">direct experiments.</span></span></p>
<p><span class="koboSpan" id="kobo.80.1">First, however, I want to show you another reason why small memory allocations are particularly inefficient. </span><span class="koboSpan" id="kobo.80.2">So far, we have explored the cost of memory allocations on only one thread. </span><span class="koboSpan" id="kobo.80.3">Today, most programs that have any performance requirements at all are concurrent, and C++ supports concurrency and multi-threading. </span><span class="koboSpan" id="kobo.80.4">Let’s take a look at how the cost of memory allocations changes when we do it on several threads </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">at once:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.82.1">
// Example 03
void BM_malloc_free(benchmark::State&amp; state) {
  const size_t S = state.range(0);
  const size_t N = state.range(1);
  std::vector&lt;void*&gt; v(N);
  for (size_t i = 0; i &lt; N; ++i) v[i] = malloc(S);
  for (auto _ : state) {
    REPE</span><a id="_idTextAnchor466"/><span class="koboSpan" id="kobo.83.1">AT({
      void* p = malloc(S);
      benchmark::DoNotOptimize(p);
      free(p);
    });
  }
  state.SetItemsProcessed(32*state.iterations());
  for (size_t i = 0; i &lt; N; ++i) free(v[i]);
}
BENCHMARK(BM_malloc_free)-&gt;
  RangeMultiplier(2)-&gt;Ranges({{32, 256}, {1&lt;&lt;15, 1&lt;&lt;15}})
  -&gt;ThreadRange(1, 2);</span></pre>
<p><span class="koboSpan" id="kobo.84.1">The result greatly </span><a id="_idIndexMarker550"/><span class="koboSpan" id="kobo.85.1">depends on the hardware and the version of </span><strong class="source-inline"><span class="koboSpan" id="kobo.86.1">malloc</span></strong><span class="koboSpan" id="kobo.87.1"> used by the system. </span><span class="koboSpan" id="kobo.87.2">Also, on large machines with many CPUs, you can have many more than </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">two threads.</span></span></p>
<p><span class="koboSpan" id="kobo.89.1">Nonetheless, the overall trend should look something </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.91.1">
Benchmark                          Time   Items per second
BM_malloc_free/32/32768/threads:1  778 ns 41.1468M/s
BM_malloc_free/32/32768/threads:2  657 ns 24.3749M/s
BM_malloc_free/32/32768/threads:4  328 ns 24.3854M/s
BM_malloc_free/32/32768/threads:8  242 ns 16.5146M/s</span></pre>
<p><span class="koboSpan" id="kobo.92.1">This is quite dismal; the cost of allocations increased several times when we went from one thread to two (on a larger machine, a similar increase is going to happen, but probably with more than two threads). </span><span class="koboSpan" id="kobo.92.2">The system memory allocator appears to be the bane of effective </span><a id="_idIndexMarker551"/><span class="koboSpan" id="kobo.93.1">concurrency. </span><span class="koboSpan" id="kobo.93.2">There are better allocators that can be used to replace the default </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">malloc()</span></strong><span class="koboSpan" id="kobo.95.1"> allocator, but they have their own downsides. </span><span class="koboSpan" id="kobo.95.2">Plus, it would be better if our C++ program did not depend on a particular, non-standard, system library replacement f</span><a id="_idTextAnchor467"/><span class="koboSpan" id="kobo.96.1">or its performance. </span><span class="koboSpan" id="kobo.96.2">We need a better way to allocate memory. </span><span class="koboSpan" id="kobo.96.3">Let’s have a look </span><a id="_idTextAnchor468"/><span class="No-Break"><span class="koboSpan" id="kobo.97.1">at it.</span></span></p>
<h1 id="_idParaDest-185"><a id="_idTextAnchor469"/><span class="koboSpan" id="kobo.98.1">Introducing local buffer optimization</span></h1>
<p><span class="koboSpan" id="kobo.99.1">The least amount of work a program can do to accomplish a certain task is no work at all. </span><span class="koboSpan" id="kobo.99.2">Free stuff </span><a id="_idIndexMarker552"/><span class="koboSpan" id="kobo.100.1">is great. </span><span class="koboSpan" id="kobo.100.2">Similarly, the fastest way to allocate and deallocate memory is this - don’t. </span><span class="koboSpan" id="kobo.100.3">Local buffer optimization is a way to get something for nothing; in this case, to get some memory for no additional </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">computin</span><a id="_idTextAnchor470"/><a id="_idTextAnchor471"/><a id="_idTextAnchor472"/><span class="koboSpan" id="kobo.102.1">g cost.</span></span></p>
<h2 id="_idParaDest-186"><a id="_idTextAnchor473"/><span class="koboSpan" id="kobo.103.1">The main idea</span></h2>
<p><span class="koboSpan" id="kobo.104.1">To understand local buffer optimization, you have to remember that memory allocations do </span><a id="_idIndexMarker553"/><span class="koboSpan" id="kobo.105.1">not happen in isolation. </span><span class="koboSpan" id="kobo.105.2">Usually, if a small amount of memory is needed, the allocated memory is used as a part of some data structure. </span><span class="koboSpan" id="kobo.105.3">For example, let’s consider a very simple </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">character string:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.107.1">
// Example 04
class simple_string {
  public:
  simple_string() = default;
  explicit simple_string(const char* s) : s_(strdup(s)) {}
  simple_string(const simple_string&amp; s)
    : s_(strdup(s.s_)) {}
  simple_string&amp; operator=(const char* s) {
    free(s_);
    s_ = strdup(s);
    return *this;
  }
  simple_string&amp; operator=(const simple_string&amp; s) {
    if (this == &amp;s) return *this;
    free(s_);
    s_ = strdup(s.s_);
    return *this;
  }
  bool operator==(const simple_string&amp; rhs) const {
    return strcmp(s_, rhs.s_) == 0;
  }
  ~simple_string() { free(s_); }
  private:
  char* s_ = nullptr;
};</span></pre>
<p><span class="koboSpan" id="kobo.108.1">The string allocates </span><a id="_idIndexMarker554"/><span class="koboSpan" id="kobo.109.1">its memory from </span><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">malloc()</span></strong><span class="koboSpan" id="kobo.111.1"> via a </span><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">strdup()</span></strong><span class="koboSpan" id="kobo.113.1"> call and returns it by calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">free()</span></strong><span class="koboSpan" id="kobo.115.1">. </span><span class="koboSpan" id="kobo.115.2">To be in any way useful, the string would need many more member functions, but these are sufficient for now to explore the overhead of memory allocation. </span><span class="koboSpan" id="kobo.115.3">Speaking of allocation, every time a string is constructed, copied, or assigned, an allocation happens. </span><span class="koboSpan" id="kobo.115.4">To be more precise, every time a string is constructed, an additional allocation happens; the string object itself has to be allocated somewhere, which may be on the stack for a local variable, or on the heap if the string is a part of some dynamically allocated data structure. </span><span class="koboSpan" id="kobo.115.5">In addition to that, an allocation for the string data happens, and the memory is always taken </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">malloc()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.119.1">This, then, is the idea of the local buffer optimization - why don’t we make the string object larger so it can contain its own data? </span><span class="koboSpan" id="kobo.119.2">That really would be getting something for nothing; the memory for the string object has to be allocated anyway, but the additional memory for the string data we would get at no extra cost. </span><span class="koboSpan" id="kobo.119.3">Of course, a string can be arbitrarily long, so we do not know in advance how much larger we need to make the string object to store any string the program will encounter. </span><span class="koboSpan" id="kobo.119.4">Even if we did, it would be a tremendous waste of memory to always allocate an object of that large size, even for very </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">short</span><a id="_idTextAnchor474"/><span class="koboSpan" id="kobo.121.1"> strings.</span></span></p>
<p><span class="koboSpan" id="kobo.122.1">We can, however, make an observation - the longer the string is, the longer it takes to process it (copy, search, convert, or whatever we need to do </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">with it).</span></span></p>
<p><span class="koboSpan" id="kobo.124.1">For very long strings, the cost of allocations is going to be small compared to the cost of processing. </span><span class="koboSpan" id="kobo.124.2">For short strings, on the other hand, the cost of the allocation could be significant. </span><span class="koboSpan" id="kobo.124.3">Therefore, the most performance benefit can be obtained by storing short strings in the </span><a id="_idIndexMarker555"/><span class="koboSpan" id="kobo.125.1">object itself, while any string that is too long to fit in the object will be stored in allocated memory as before. </span><span class="koboSpan" id="kobo.125.2">This is, in a nutshell, local buffer </span><a id="_idIndexMarker556"/><span class="koboSpan" id="kobo.126.1">optimization, which for strings is also known as </span><strong class="bold"><span class="koboSpan" id="kobo.127.1">short string optimization</span></strong><span class="koboSpan" id="kobo.128.1">; the object (string) contains a local buffer of a certain size, and any string that fits into that buffer is stored directly inside </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">the object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.130.1">
// Example 04
class small_string {
  public:
  small_string() = default;
  explicit small_string(const char* s) :
    s_((strlen(s) + 1 &lt; sizeof(buf_)) ? </span><span class="koboSpan" id="kobo.130.2">strcpy(buf_, s)
                                      : strdup(s)) {}
  small_string(const small_string&amp; s) :
    s_((s.s_ == s.buf_) ? </span><span class="koboSpan" id="kobo.130.3">strcpy(buf_, s.buf_)
                        : strdup(s.s_)) {}
  small_string&amp; operator=(const char* s) {
    if (s_ != buf_) free(s_);
    s_ = (strlen(s) + 1 &lt; sizeof(buf_)) ? </span><span class="koboSpan" id="kobo.130.4">strcpy(buf_, s)
                                        : strdup(s);
    return *this;
  }
  small_string&amp; operator=(const small_string&amp; s) {
    if (this == &amp;s) return *this;
    if (s_ != buf_) free(s_);
    s_ = (s.s_ == s.buf_) ? </span><span class="koboSpan" id="kobo.130.5">strcpy(buf_, s.buf_)
                          : strdup(s.s_);
    return *this;
  }
  bool operator==(const small_string&amp; rhs) const {
    return strcmp(s_, rhs.s_) == 0;
  }
  ~small_string() {
    if (s_ != buf_) free(s_);
  }
  private:
  char* s_ = nullptr;
  char b</span><a id="_idTextAnchor475"/><span class="koboSpan" id="kobo.131.1">uf_[16];
};</span></pre>
<p><span class="koboSpan" id="kobo.132.1">In the preceding </span><a id="_idIndexMarker557"/><span class="koboSpan" id="kobo.133.1">code example, the buffer size is set statically at </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">16</span></strong><span class="koboSpan" id="kobo.135.1"> characters, including the null character used to terminate the string. </span><span class="koboSpan" id="kobo.135.2">Any string that is longer than </span><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">16</span></strong><span class="koboSpan" id="kobo.137.1"> is allocated from </span><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">malloc()</span></strong><span class="koboSpan" id="kobo.139.1">. </span><span class="koboSpan" id="kobo.139.2">When assigning or destroying a string object, we must check whether the allocation was done or the internal buffer was used, in order to appropriately</span><a id="_idTextAnchor476"/><span class="koboSpan" id="kobo.140.1"> release the memory used by</span><a id="_idTextAnchor477"/> <span class="No-Break"><span class="koboSpan" id="kobo.141.1">the string.</span></span></p>
<h2 id="_idParaDest-187"><a id="_idTextAnchor478"/><span class="koboSpan" id="kobo.142.1">Effect of local buffer optimization</span></h2>
<p><span class="koboSpan" id="kobo.143.1">How much faster is </span><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">small_string</span></strong><span class="koboSpan" id="kobo.145.1"> compared to </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">simple_string</span></strong><span class="koboSpan" id="kobo.147.1">? </span><span class="koboSpan" id="kobo.147.2">That depends, of course, on what </span><a id="_idIndexMarker558"/><span class="koboSpan" id="kobo.148.1">you need to do with it. </span><span class="koboSpan" id="kobo.148.2">Let’s start with just creating and deleting the strings. </span><span class="koboSpan" id="kobo.148.3">To avoid typing the same benchmark code twice, we can use the template benchmark, </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.150.1">
// Example 04
template &lt;typename T&gt;
void BM_string_create_short(benchmark::State&amp; state) {
  const char* s = "Simple string";
  for (auto _ : state) {
    REPEAT({
      T S(s);
      benchmark::DoNotOptimize(S);
    })
  }
  state.SetItemsProcessed(32*state.iterations());
}
BENCHMARK_TEMPLATE1(BM_string_create_short, simple_string);
BENCHMARK_TEMPLATE1(BM_string_create_short, small_string);</span></pre>
<p><span class="koboSpan" id="kobo.151.1">The result is </span><span class="No-Break"><span class="koboSpan" id="kobo.152.1">quite impressive:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.153.1">
Benchmark                                Time Items per sec
BM_string_create_short&lt;simple_string&gt;     835 ns 38.34M/s
BM_string_create_short&lt;small_string&gt;     18.7 ns 1.71658G/s</span></pre>
<p><span class="koboSpan" id="kobo.154.1">It gets even better when we try the same test on </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">multiple threads:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.156.1">
Benchmark                                Time Items per sec
BM_create&lt;simple_string&gt;/threads:2        743 ns 21.5644M/s
BM_create&lt;simple_string&gt;/threads:4        435 ns 18.4288M/s
BM_create&lt;small_string&gt;/threads:2        9.34 ns 1.71508G/s
BM_create&lt;small_string&gt;/threads:4        4.77 ns 1.67998G/s</span></pre>
<p><span class="koboSpan" id="kobo.157.1">Regular string creation is slightly faster on two threads, but creating short strings is almost exactly twice as fast (and again twice as fast on four threads). </span><span class="koboSpan" id="kobo.157.2">Of course, this is pretty much the best-case scenario for small string optimization - firstly because all we do is create and delete strings, which is the very part we optimized, and secondly because the string is a local variable its memory is allocated as a part of the stack frame, so there is no additional </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">allocation cost.</span></span></p>
<p><span class="koboSpan" id="kobo.159.1">However, this is not an unreasonable case; after all, local variables are not rare at all, and if the string </span><a id="_idIndexMarker559"/><span class="koboSpan" id="kobo.160.1">is a part of some larger data structure, the allocation cost for that structure has to be paid anyway, so allocating anything else at the same time and without additional cost is </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">effectively free.</span></span></p>
<p><span class="koboSpan" id="kobo.162.1">Nonetheless, it is unlikely that we only allocate the strings to immediately deallocate them, so we should consider the cost of other operations. </span><span class="koboSpan" id="kobo.162.2">We can expect similar improvements for copying or assigning strings, as long as they stay short, </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">of course:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.164.1">
template &lt;typename T&gt;
void BM_string_copy_short(benchmark::State&amp; state) {
  const T s("Simple string");
  for (auto _ : state) {
    REPEAT({
      T S(s);
      benchmark::DoNotOptimize(S);
    })
  }
  state.SetItemsProcessed(32*state.iterations());
}
template &lt;typename T&gt;
void BM_string_assign_short(benchmark::State&amp; state) {
  const T s("Simple string");
  T S;
  for (auto _ : state) {
    REPEAT({ benchmark::DoNotOptimize(S = s); })
  }
  state.SetItemsProcessed(32*state.iterations());
}
BENCHMARK_TEMPLATE1(BM_string_copy_short, simple_string);
BENCHMARK_TEMPLATE1(BM_string_copy_short, small_string);
BENCHMARK_TEMPLATE1(BM_string_assign_short, simple_string);
BENCHMARK_TEMPLATE1(BM_string_assign_short, small_string);</span></pre>
<p><span class="koboSpan" id="kobo.165.1">Indeed, a similar </span><a id="_idIndexMarker560"/><span class="koboSpan" id="kobo.166.1">dramatic performance gain </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">is observed:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.168.1">
Benchmark                                Time Items per sec
BM_string_copy_short&lt;simple_string&gt;       786 ns 40.725M/s
BM_string_copy_short&lt;small_string&gt;       53.5 ns 598.847M/s
BM_string_assign_short&lt;simple_string&gt;     770 ns 41.5977M/s
BM_string_assign_short&lt;small_string&gt;     46.9 ns 683.182M/s</span></pre>
<p><span class="koboSpan" id="kobo.169.1">We are also likely to need to read the data in the strings at least once, to compare them or search for a specific string or character, or compute some derived value. </span><span class="koboSpan" id="kobo.169.2">We do not expect improvements of a similar scale for these operations, of course, since none of them involves any allocations or deallocations. </span><span class="koboSpan" id="kobo.169.3">You might ask why, then, should we expect any improvements </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">at all?</span></span></p>
<p><span class="koboSpan" id="kobo.171.1">Indeed, a simple test of string comparison, for example, shows no difference between the two versions of the string. </span><span class="koboSpan" id="kobo.171.2">In order to see any benefit, we have to create many string objects and </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">compare them:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.173.1">
template &lt;typename T&gt;
void BM_string_compare_short(benchmark::State&amp; state) {
  const size_t N = state.range(0);
  const T s("Simple string");
  std::vector&lt;T&gt; v1, v2;
  ... </span><span class="koboSpan" id="kobo.173.2">populate the vectors with strings ...
</span><span class="koboSpan" id="kobo.173.3">  for (auto _ : state) {
    for (size_t i = 0; i &lt; N; ++i) {
      benchmark::DoNotOptimize(v1[i] == v2[i]);
    }
  }
  state.SetItemsProcessed(N*state.iterations());
}
BENCHMARK_TEMPLATE1(BM_string_compare_short,
                    simple_string)-&gt;Arg(1&lt;&lt;22);
BENCHMARK_TEMPLATE1(BM_string_compare_short,
                    small_string)-&gt;Arg(1&lt;&lt;22);</span></pre>
<p><span class="koboSpan" id="kobo.174.1">For small values of </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">N</span></strong><span class="koboSpan" id="kobo.176.1"> (a small total number of strings), there won’t be any significant benefit from </span><a id="_idIndexMarker561"/><span class="koboSpan" id="kobo.177.1">the optimization. </span><span class="koboSpan" id="kobo.177.2">But when we have to process many strings, comparing strings with the small string optimization can be approximately twice </span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">as fast:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.179.1">
Benchmark                                Time Items per sec
BM_compare&lt;simple_string&gt;/4194304    30230749 ns 138.855M/s
BM_compare&lt;small_string&gt;/4194304     15062582 ns 278.684M/s</span></pre>
<p><span class="koboSpan" id="kobo.180.1">Why is that happening, if there are no allocations at all? </span><span class="koboSpan" id="kobo.180.2">This experiment shows the second, very important, benefit of local buffer optimization - improved cache locality. </span><span class="koboSpan" id="kobo.180.3">The string object itself has to be accessed before the string data can be read; it contains the pointer to the data. </span><span class="koboSpan" id="kobo.180.4">For the regular string, accessing the string characters involves two memory accesses at different, generally unrelated addresses. </span><span class="koboSpan" id="kobo.180.5">If the total amount of data is large, then the second access, to the string data, is likely to miss the cache and wait for the </span><a id="_idIndexMarker562"/><span class="koboSpan" id="kobo.181.1">data to be brought from the main memory. </span><span class="koboSpan" id="kobo.181.2">On the other hand, the optimized string keeps the data close to the string object, so that once the string itself is in the cache, so is the data. </span><span class="koboSpan" id="kobo.181.3">The reason that we need a sufficient amount of different strings to see this benefit is that with few strings, all string objects and their data can reside in the cache permanently. </span><span class="koboSpan" id="kobo.181.4">Only when the total size of the strings exceeds the size of the cache will the performance benefits manifest themselves. </span><span class="koboSpan" id="kobo.181.5">Now, let’s dive deeper into some </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">addition</span><a id="_idTextAnchor479"/><a id="_idTextAnchor480"/><a id="_idTextAnchor481"/><span class="koboSpan" id="kobo.183.1">al optimizations.</span></span></p>
<h2 id="_idParaDest-188"><a id="_idTextAnchor482"/><span class="koboSpan" id="kobo.184.1">Additional optimizations</span></h2>
<p><span class="koboSpan" id="kobo.185.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">small_string</span></strong><span class="koboSpan" id="kobo.187.1"> class we have implemented has an obvious inefficiency - when the string is </span><a id="_idIndexMarker563"/><span class="koboSpan" id="kobo.188.1">stored in the local buffer, we do not really need the pointer to the data. </span><span class="koboSpan" id="kobo.188.2">We know exactly where the data is, in the local buffer. </span><span class="koboSpan" id="kobo.188.3">We do need to know, somehow, whether the data is in the local buffer or in the externally allocated memory, but we don’t need to use 8 bytes (on a 64-bit machine) just to store that. </span><span class="koboSpan" id="kobo.188.4">Of course, we still need the pointer for storing longer strings, but we could reuse that memory for the buffer when the string </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">is short:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.190.1">
// Example 05
class small_string {
  ...
</span><span class="koboSpan" id="kobo.190.2">  private:
  union {
    char* s_;
    struct {
      char buf[15];
      char tag;
    } b_;
  };
};</span></pre>
<p><span class="koboSpan" id="kobo.191.1">Here, we use the last byte as a </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">tag</span></strong><span class="koboSpan" id="kobo.193.1"> to indicate whether the string is stored locally (</span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">tag == 0</span></strong><span class="koboSpan" id="kobo.195.1">) or in a separate allocation (</span><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">tag == 1</span></strong><span class="koboSpan" id="kobo.197.1">). </span><span class="koboSpan" id="kobo.197.2">Note that the total buffer size is still </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">16</span></strong><span class="koboSpan" id="kobo.199.1"> characters, </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">15</span></strong><span class="koboSpan" id="kobo.201.1"> for the string itself and </span><strong class="source-inline"><span class="koboSpan" id="kobo.202.1">1</span></strong><span class="koboSpan" id="kobo.203.1"> for the tag, which also doubles at the trailing zero if the string needs all </span><strong class="source-inline"><span class="koboSpan" id="kobo.204.1">16</span></strong><span class="koboSpan" id="kobo.205.1"> bytes (this is why we have to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">tag == 0</span></strong><span class="koboSpan" id="kobo.207.1"> to indicate local storage, as it would cost us an extra byte to do otherwise). </span><span class="koboSpan" id="kobo.207.2">The pointer is overlaid in memory with the first </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">8</span></strong><span class="koboSpan" id="kobo.209.1"> bytes of the character buffer. </span><span class="koboSpan" id="kobo.209.2">In this example, we have chosen to </span><a id="_idIndexMarker564"/><span class="koboSpan" id="kobo.210.1">optimize the total memory occupied by the string; this string still has a 16-character local buffer, just like the previous version, but the object itself is now only 16 bytes, not 24. </span><span class="koboSpan" id="kobo.210.2">If we were willing to keep the object size the same, we could have used a larger buffer and stored longer strings locally. </span><span class="koboSpan" id="kobo.210.3">The benefit of the small string optimization does, generally, diminish as the strings become longer. </span><span class="koboSpan" id="kobo.210.4">The optimal crossover point from local to remote str</span><a id="_idTextAnchor483"/><span class="koboSpan" id="kobo.211.1">ings depends on the particular application and must of course be determined by </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">benc</span><a id="_idTextAnchor484"/><span class="koboSpan" id="kobo.213.1">hmark measurements.</span></span></p>
<h1 id="_idParaDest-189"><a id="_idTextAnchor485"/><span class="koboSpan" id="kobo.214.1">Local buffer optimization beyond strings</span></h1>
<p><span class="koboSpan" id="kobo.215.1">The local buffer </span><a id="_idIndexMarker565"/><span class="koboSpan" id="kobo.216.1">optimization can be used effectively for much more than just short strings. </span><span class="koboSpan" id="kobo.216.2">In fact, any time a small dynamic allocation of a size that is determined at runtime is needed, this optimization should be considered. </span><span class="koboSpan" id="kobo.216.3">In this section, we will consider several s</span><a id="_idTextAnchor486"/><a id="_idTextAnchor487"/><a id="_idTextAnchor488"/><span class="koboSpan" id="kobo.217.1">uch </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">data structures.</span></span></p>
<h2 id="_idParaDest-190"><a id="_idTextAnchor489"/><span class="koboSpan" id="kobo.219.1">Small vector</span></h2>
<p><span class="koboSpan" id="kobo.220.1">Another very </span><a id="_idIndexMarker566"/><span class="koboSpan" id="kobo.221.1">common data structure that often benefits from local buffer optimization is vectors. </span><span class="koboSpan" id="kobo.221.2">Vectors are essentially dynamic contiguous arrays of data elements of the specified type (in this sense, a string is a vector of bytes, although null termination gives strings their own specifics). </span><span class="koboSpan" id="kobo.221.3">A basic vector, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">std::vector</span></strong><span class="koboSpan" id="kobo.223.1"> found in the C++ standard library, needs two data members, a data pointer and the </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">data size:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.225.1">
// Example 06
class simple_vector {
  public:
  simple_vector() = default;
  simple_vector(std::initializer_list&lt;int&gt; il) :
    n_(il.size()),
    p_(static_cast&lt;int*&gt;(malloc(sizeof(int)*n_)))
  {
    int* p = p_;
    for (auto x : il) *p++ = x;
  }
  ~simple_vector() { free(p_); }
  size_t size() const { return n_; }
  private:
  size_t n_ = 0;
  int* p_ = nullptr;
};</span></pre>
<p><span class="koboSpan" id="kobo.226.1">Vectors are </span><a id="_idIndexMarker567"/><span class="koboSpan" id="kobo.227.1">usually templates, like the standard </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">std::vector</span></strong><span class="koboSpan" id="kobo.229.1">, but we have simplified this example to show a vector of integers (converting this vector class to a template is left as an exercise for you, and does not in any way alter the application of the local buffer optimization pattern). </span><span class="koboSpan" id="kobo.229.2">We can apply </span><em class="italic"><span class="koboSpan" id="kobo.230.1">small vector optimization</span></em><span class="koboSpan" id="kobo.231.1"> and store the vector data in the body of the vector object as long as it is </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">small enough:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.233.1">
// Example 06
class small_vector {
  public:
  small_vector() = default;
  small_vector(std::initializer_list&lt;int&gt; il) :
    n_(il.size()), p_((n_ &lt; sizeof(buf_)/sizeof(buf_[0]))
      ? </span><span class="koboSpan" id="kobo.233.2">buf_ : static_cast&lt;int*&gt;(malloc(sizeof(int)*n_)))
  {
    int* p = p_;
    for (auto x : il) *p++ = x;
  }
  ~small_vector() {
    if (p_ != buf_) free(p_);
  }
  private:
  size_t n_ = nullptr;
  int* p_ = nullptr;
  int buf_[16];
};</span></pre>
<p><span class="koboSpan" id="kobo.234.1">We can further optimize the vector in a similar manner to the string and overlay the local buffer </span><a id="_idIndexMarker568"/><span class="koboSpan" id="kobo.235.1">with the pointer. </span><span class="koboSpan" id="kobo.235.2">We cannot use the last byte as a </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">tag</span></strong><span class="koboSpan" id="kobo.237.1">, as we did before, since any element of the vector can have any value, and the value of zero is, in general, not special. </span><span class="koboSpan" id="kobo.237.2">However, we need to store the size of the vector anyway, so we can use it at any time to determine whether the local buffer is used or not. </span><span class="koboSpan" id="kobo.237.3">We can take further advantage of the fact that if the local buffer optimization is used, the size of the vector cannot be very large, so we do not need a field of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">size_t</span></strong><span class="koboSpan" id="kobo.239.1"> type to </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">store it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.241.1">
// Example 07
class small_vector {
  public:
  small_vector() = default;
  small_vector(std::initializer_list&lt;int&gt; il) {
    int* p;
    if (il.size() &lt; sizeof(short_.buf)/
                    sizeof(short_.buf[0])) {
      short_.n = il.size();
      p = short_.buf;
    } else {
      short_.n = UCHAR_MAX;
      long_.n = il.size();
      p = long_.p = static_cast&lt;int*&gt;(
        malloc(sizeof(int)*long_.n));
    }
    for (auto x : il) *p++ = x;
  }
  ~small_vector() {
    if (short_.n == UCHAR_MAX) free(long_.p);
  }
  private:
  union {
    struct {
      int buf[15];
      unsigned char n;
    } short_ = { {}, '\0' };
    struct {
      size_t n;
      int* </span><a id="_idTextAnchor490"/><span class="koboSpan" id="kobo.242.1">p;
    } long_;
  };
};</span></pre>
<p><span class="koboSpan" id="kobo.243.1">Here, we store the vector size either in </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">size_t</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.245.1">long_.n</span></strong><span class="koboSpan" id="kobo.246.1"> or in </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">unsigned</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.248.1">char</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.249.1">short_.n</span></strong><span class="koboSpan" id="kobo.250.1">, depending on whether or not the local buffer is used. </span><span class="koboSpan" id="kobo.250.2">A remote buffer is indicated by storing </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">UCHAR_MAX</span></strong><span class="koboSpan" id="kobo.252.1"> (that is, 255) in the short size. </span><span class="koboSpan" id="kobo.252.2">Since this value is larger than the size of the local buffer, this </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">tag</span></strong><span class="koboSpan" id="kobo.254.1"> is unambiguous (were the local buffer increased to store more than 255 elements, the type of </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">short_.n</span></strong><span class="koboSpan" id="kobo.256.1"> would need to be changed to a </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">longer integer).</span></span></p>
<p><span class="koboSpan" id="kobo.258.1">We can </span><a id="_idIndexMarker569"/><span class="koboSpan" id="kobo.259.1">measure the performance gains from small vector optimization using a benchmark similar to the one we used for the strings. </span><span class="koboSpan" id="kobo.259.2">Depending on the actual size of the vector, gains of about 10x can be expected in creating and copying the vectors, and more if the benchmark runs on multiple threads. </span><span class="koboSpan" id="kobo.259.3">Of course, other data structur</span><a id="_idTextAnchor491"/><span class="koboSpan" id="kobo.260.1">es can be optimized in a similar manner when they store small amounts of dynamically allocated data. </span><span class="koboSpan" id="kobo.260.2">The optimizations of these data structures are fundamentally similar, but there is one noteworthy variant we </span><span class="No-Break"><span class="koboSpan" id="kobo.261.1">should highlight.</span></span></p>
<h2 id="_idParaDest-191"><a id="_idTextAnchor492"/><span class="koboSpan" id="kobo.262.1">Small queue</span></h2>
<p><span class="koboSpan" id="kobo.263.1">The small vector we have just seen uses a local buffer to store a small array of vector elements. </span><span class="koboSpan" id="kobo.263.2">This is the standard way of optimizing data structures that store a variable number of </span><a id="_idIndexMarker570"/><span class="koboSpan" id="kobo.264.1">elements when this number is often small. </span><span class="koboSpan" id="kobo.264.2">A particular version of this optimization is used for data structures based on a queue, where the buffer grows on one end and is consumed on the other end. </span><span class="koboSpan" id="kobo.264.3">If there are only a few elements in the queue at any time, the queue can be optimized with a local buffer. </span><span class="koboSpan" id="kobo.264.4">The technique commonly employed here is a </span><strong class="bold"><span class="koboSpan" id="kobo.265.1">circular buffer</span></strong><span class="koboSpan" id="kobo.266.1">: our buffer </span><a id="_idIndexMarker571"/><span class="koboSpan" id="kobo.267.1">is an array of fixed size </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">buffer[N]</span></strong><span class="koboSpan" id="kobo.269.1">, so, as the elements are added to the end of the queue, we are going to reach the end of the array. </span><span class="koboSpan" id="kobo.269.2">By then some elements were taken from the queue, so the first few elements of the array are no longer used. </span><span class="koboSpan" id="kobo.269.3">When we reach the end of the array, the next enqueued value goes into the first element of the array, </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">buffer[0]</span></strong><span class="koboSpan" id="kobo.271.1">. </span><span class="koboSpan" id="kobo.271.2">The array is treated like a ring, after the element </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">buffer[N-1]</span></strong><span class="koboSpan" id="kobo.273.1"> comes the element </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">buffer[0]</span></strong><span class="koboSpan" id="kobo.275.1"> (hence another name for this </span><a id="_idIndexMarker572"/><span class="koboSpan" id="kobo.276.1">technique, a </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.277.1">ring buffer</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.279.1">The circular buffer technique is commonly used for queues and other data structures where data is added and removed many times while the total volume of data stored at any given </span><a id="_idIndexMarker573"/><span class="koboSpan" id="kobo.280.1">time is limited. </span><span class="koboSpan" id="kobo.280.2">Here is one possible implementation of a circular </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">buffer queue:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.282.1">
// Example 08
class small_queue {
  public:
  bool push(int i) {
    if (front_ - tail_ &gt; buf_size_) return false;
    buf_[(++front_) &amp; (buf_size_ - 1)] = i;
    return true;
  }
  int front() const {
    return buf_[tail_ &amp; (buf_size_ - 1)];
  }
  void pop() { ++tail_; }
  size_t size() const { return front_ - tail_; }
  bool empty() const { return front_ == tail_; }
  private:
  static constexpr size_t buf_size_ = 16;
  static_assert((buf_size_ &amp; (buf_size_ - 1)) == 0,
                "Buffer size must be a power of 2");
  int buf_[buf_size_];
  size_t front_ = 0;
  size_t tail_ = 0;
};</span></pre>
<p><span class="koboSpan" id="kobo.283.1">In this example, we support only the local buffer; if the number of elements the queue must hold exceeds the size of the buffer, the call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">push()</span></strong><span class="koboSpan" id="kobo.285.1"> returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">false</span></strong><span class="koboSpan" id="kobo.287.1">. </span><span class="koboSpan" id="kobo.287.2">We could have switched to a heap-allocated array instead, just like we did in </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">Example 07</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.289.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">small_vector</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.292.1">In this implementation, we increment the indices </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">front_</span></strong><span class="koboSpan" id="kobo.294.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">tail_</span></strong><span class="koboSpan" id="kobo.296.1"> without bounds, but when these values are used as indices into the local buffer, we take the index value modulo buffer size. </span><span class="koboSpan" id="kobo.296.2">Of note is the optimization that is very common when dealing with circular buffers: the size of the buffer is a power of two (enforced by the assert). </span><span class="koboSpan" id="kobo.296.3">This allows us to </span><a id="_idIndexMarker574"/><span class="koboSpan" id="kobo.297.1">replace the general (and slow) modulo calculation such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">front_ % buf_size_</span></strong><span class="koboSpan" id="kobo.299.1"> by much faster bitwise arithmetic. </span><span class="koboSpan" id="kobo.299.2">We do not have to worry about integer overflow either: even if we call </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">push()</span></strong><span class="koboSpan" id="kobo.301.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">pop()</span></strong><span class="koboSpan" id="kobo.303.1"> more than </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">2^64</span></strong><span class="koboSpan" id="kobo.305.1"> times, the unsigned integer index values will overflow and go back to zero and the queue continues to </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">work fine.</span></span></p>
<p><span class="koboSpan" id="kobo.307.1">As expected, the queue with the local buffer optimization far outperforms a general queue such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">std::queue&lt;int&gt;</span></strong><span class="koboSpan" id="kobo.309.1"> (as long as the optimization remains valid and the number of elements in the queue is small, </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">of course):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.311.1">
Benchmark                         Time   items_per_second
BM_queue&lt;std::queue&lt;int&gt;&gt;       472 ns          67.787M/s
BM_queue&lt;small_queue&gt;           100 ns         319.857M/s</span></pre>
<p><span class="koboSpan" id="kobo.312.1">The circular local buffer can be used very effectively in many situations where we need to process large volumes of data but hold only a few elements at a time. </span><span class="koboSpan" id="kobo.312.2">Possible applications include network and I/O buffers, pipelines for exchanging data between threads in concurrent programs, and </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">many more.</span></span></p>
<p><span class="koboSpan" id="kobo.314.1">Let us now look at applications of local buffer optimizations b</span><a id="_idTextAnchor493"/><span class="koboSpan" id="kobo.315.1">eyond common </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">data structures.</span></span></p>
<h2 id="_idParaDest-192"><a id="_idTextAnchor494"/><span class="koboSpan" id="kobo.317.1">Type-erased and callable objects</span></h2>
<p><span class="koboSpan" id="kobo.318.1">There is another, very different, type of application where the local buffer optimization can be used </span><a id="_idIndexMarker575"/><span class="koboSpan" id="kobo.319.1">very effectively - storing </span><a id="_idIndexMarker576"/><span class="koboSpan" id="kobo.320.1">callable objects, which are objects that can be invoked as functions. </span><span class="koboSpan" id="kobo.320.2">Many template classes provide an option to customize some part of their behavior using a callable object. </span><span class="koboSpan" id="kobo.320.3">For example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">std::shared_ptr</span></strong><span class="koboSpan" id="kobo.322.1">, the standard shared pointer in C++, allows the user to specify a custom deleter. </span><span class="koboSpan" id="kobo.322.2">This deleter will be called with the address of the object to be deleted, so it is a callable with one argument of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">void*</span></strong><span class="koboSpan" id="kobo.324.1"> type. </span><span class="koboSpan" id="kobo.324.2">It could be a function pointer, a member function pointer, or a functor object (an object with an </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">operator()</span></strong><span class="koboSpan" id="kobo.326.1"> defined) - any type that can be called on a </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">p</span></strong><span class="koboSpan" id="kobo.328.1"> pointer; that is, any type that compiles in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">callable(p)</span></strong><span class="koboSpan" id="kobo.330.1"> function call syntax can be used. </span><span class="koboSpan" id="kobo.330.2">The deleter, however, is more than a type; it is an object and is specified at runtime, and so it needs to be stored someplace </span><a id="_idIndexMarker577"/><span class="koboSpan" id="kobo.331.1">where the shared pointer can </span><a id="_idIndexMarker578"/><span class="koboSpan" id="kobo.332.1">get to it. </span><span class="koboSpan" id="kobo.332.2">Were the deleter a part of the shared pointer type, we could simply declare a data member of that type in the shared pointer object (or, in the case of the C++ shared pointer, in its reference object that is shared between all copies of the shared pointer). </span><span class="koboSpan" id="kobo.332.3">You could consider it a trivial application of the local buffer optimization, as in the following smart pointer that automatically deletes the object when the pointer goes out of scope (just </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">like </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">std::unique_ptr</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.336.1">
// Example 09
template &lt;typename T, typename Deleter&gt; class smartptr {
  public:
  smartptr(T* p, Deleter d) : p_(p), d_(d) {}
  ~smartptr() { d_(p_); }
  T* operator-&gt;() { return p_; }
  const T* operator-&gt;() const { return p_; } private:
  T* p_;
  Deleter d_;
};</span></pre>
<p><span class="koboSpan" id="kobo.337.1">We are after more interesting things, however, and one such thing can be found when we deal with type-erased objects. </span><span class="koboSpan" id="kobo.337.2">The details of such objects were considered in the chapter dedicated to type erasure, but in a nutshell, they are objects where the callable is not a part of the type itself (as in, it is </span><em class="italic"><span class="koboSpan" id="kobo.338.1">erased</span></em><span class="koboSpan" id="kobo.339.1"> from the type of the containing object). </span><span class="koboSpan" id="kobo.339.2">The callable is instead stored in a polymorphic object, and a virtual function is used to call the object of the right type at runtime. </span><span class="koboSpan" id="kobo.339.3">The polymorphic object, in turn, is manipulated through the base </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">class pointer.</span></span></p>
<p><span class="koboSpan" id="kobo.341.1">Now, we have a problem that is, in a sense, similar to the preceding small vector - we need to store some data, in our case the callable object, whose type, and therefore size, is not </span><a id="_idIndexMarker579"/><span class="koboSpan" id="kobo.342.1">statically known. </span><span class="koboSpan" id="kobo.342.2">The general solution </span><a id="_idIndexMarker580"/><span class="koboSpan" id="kobo.343.1">is to dynamically allocate such objects and access them through the base class pointer. </span><span class="koboSpan" id="kobo.343.2">In the case of a smart pointer </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">deleter</span></strong><span class="koboSpan" id="kobo.345.1">, we could do it </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.347.1">
// Example 09
template &lt;typename T&gt; class smartptr_te {
  struct deleter_base {
    virtual void apply(void*) = 0;
    virtual ~deleter_base() {}
  };
  template &lt;typename Deleter&gt;
  struct deleter : public deleter_base {
    deleter(Deleter d) : d_(d) {}
    void apply(void* p) override {
      d_(static_cast&lt;T*&gt;(p));
    }
    Deleter d_;
  };
  public:
  template &lt;typename Deleter&gt;
  smartptr_te(T* p, Deleter d) : p_(p),
    d_(new deleter&lt;Deleter&gt;(d)) {}
  ~smartptr_te() {
    d_-&gt;apply(p_);
    delete d_;
  }
  T* operator-&gt;() { return p_; }
  const T* operator-&gt;() const { return p_; }
  private:
  T* p_;
  deleter_base* d_;
};</span></pre>
<p><span class="koboSpan" id="kobo.348.1">Note that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">Deleter</span></strong><span class="koboSpan" id="kobo.350.1"> type is no longer a part of the smart pointer type; it was </span><em class="italic"><span class="koboSpan" id="kobo.351.1">erased</span></em><span class="koboSpan" id="kobo.352.1">. </span><span class="koboSpan" id="kobo.352.2">All smart pointers for the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">T</span></strong><span class="koboSpan" id="kobo.354.1"> object type have the same type, </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">smartptr_te&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.356.1"> (here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">te</span></strong><span class="koboSpan" id="kobo.358.1"> stands for </span><em class="italic"><span class="koboSpan" id="kobo.359.1">type-erased</span></em><span class="koboSpan" id="kobo.360.1">). </span><span class="koboSpan" id="kobo.360.2">However, we have to pay a steep price </span><a id="_idIndexMarker581"/><span class="koboSpan" id="kobo.361.1">for this syntactic convenience - every time </span><a id="_idIndexMarker582"/><span class="koboSpan" id="kobo.362.1">a smart pointer is created, there is an additional memory allocation. </span><span class="koboSpan" id="kobo.362.2">How steep? </span><span class="koboSpan" id="kobo.362.3">The first rule of performance must again be remembered - </span><em class="italic"><span class="koboSpan" id="kobo.363.1">steep</span></em><span class="koboSpan" id="kobo.364.1"> is only a guess until confirmed by an experiment, such as the </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">following benchmark:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.366.1">
// Example 09
struct deleter {    // Very simple deleter for operator new
  template &lt;typename T&gt; void operator()(T* p) { delete p; }
};
void BM_smartptr(benchmark::State&amp; state) {
  deleter d;
  for (auto _ : state) {
    smartptr&lt;int, deleter&gt; p(new int, d);
  }
  state.SetItemsProcessed(state.iterations());
}
void BM_smartptr_te(benchmark::State&amp; state) {
  deleter d;
  for (auto _ : state) {
    smartptr_te&lt;int&gt; p(new int, d);
  }
  state.SetItemsProcessed(state.iterations());
}
BENCHMARK(BM_smartptr);
BENCHMARK(BM_smartptr_te);
BENCHMARK_MAIN();</span></pre>
<p><span class="koboSpan" id="kobo.367.1">For a smart </span><a id="_idIndexMarker583"/><span class="koboSpan" id="kobo.368.1">pointer with a statically defined deleter, we can </span><a id="_idIndexMarker584"/><span class="koboSpan" id="kobo.369.1">expect the cost of each iteration to be very similar to the cost of calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">malloc()</span></strong><span class="koboSpan" id="kobo.371.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">free()</span></strong><span class="koboSpan" id="kobo.373.1">, which we </span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">measured earlier:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.375.1">
Benchmark                  Time Items per second
BM_smartptr             21.0 ns 47.5732M/s
BM_smartptr_te          44.2 ns 22.6608M/s</span></pre>
<p><span class="koboSpan" id="kobo.376.1">For a type-erased smart pointer, there are two allocations instead of one, and so the time it takes to create the pointer object is doubled. </span><span class="koboSpan" id="kobo.376.2">By the way, we can also measure the performance of a raw pointer, and it should be the same as the smart pointer within the accuracy of the measurements (this was, in fact, a stated design </span><a id="_idTextAnchor495"/><span class="koboSpan" id="kobo.377.1">goal for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">std::unique_ptr</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.379.1"> standard).</span></span></p>
<p><span class="koboSpan" id="kobo.380.1">We can apply the same idea of local buffer optimization here, and it is likely to be even more effective than it was for strings; after all, most callable objects are small. </span><span class="koboSpan" id="kobo.380.2">We can’t completely count on that, however, and must handle the case of a callable object that is larger than the </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">local buffer:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.382.1">
// Example 09
template &lt;typename T&gt; class smartptr_te_lb {
  struct deleter_base {
    virtual void apply(void*) = 0;
    virtual ~deleter_base() {}
  };
  template &lt;typename Deleter&gt;
    struct deleter : public deleter_base {
    deleter(Deleter d) : d_(d) {}
    void apply(void* p) override {
      d_(static_cast&lt;T*&gt;(p));
    }
    Deleter d_;
  };
  public:
  template &lt;typename Deleter&gt;
    smartptr_te_lb(T* p, Deleter d) : p_(p),
      d_((sizeof(Deleter) &gt; sizeof(buf_))
         ? </span><span class="koboSpan" id="kobo.382.2">new deleter&lt;Deleter&gt;(d)
         : new (buf_) deleter&lt;Deleter&gt;(d)) {}
  ~smartptr_te_lb() {
    d_-&gt;apply(p_);
    if ((void*)(d_) == (void*)(buf_)) {
      d_-&gt;~deleter_base();
    } else {
      delete d_;
    }
  }
  T* operator-&gt;() { return p_; }
  const T* operator-&gt;() const { return p_; }
  private:
  T* p_;
  deleter_base* d_;
  char buf_[16];
};</span></pre>
<p><span class="koboSpan" id="kobo.383.1">Using the </span><a id="_idIndexMarker585"/><span class="koboSpan" id="kobo.384.1">same benchmark as before, we can </span><a id="_idIndexMarker586"/><span class="koboSpan" id="kobo.385.1">measure the performance of the type-erased smart pointer with local </span><span class="No-Break"><span class="koboSpan" id="kobo.386.1">buffer optimization:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.387.1">
Benchmark                  Time Items per second
BM_smartptr             21.0 ns 47.5732M/s
BM_smartptr_te          44.2 ns 22.6608M/s
BM_smartptr_te_lb       22.3 ns 44.8747M/s</span></pre>
<p><span class="koboSpan" id="kobo.388.1">While the construction and deletion of a smart pointer without type erasure took 21 nanoseconds, and 44 nanoseconds with type erasure, the optimized type-erased shared pointer test takes 22 nanoseconds on the same machine. </span><span class="koboSpan" id="kobo.388.2">The slight overhead comes from checking whether t</span><a id="_idTextAnchor496"/><a id="_idTextAnchor497"/><a id="_idTextAnchor498"/><span class="koboSpan" id="kobo.389.1">he </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">deleter</span></strong><span class="koboSpan" id="kobo.391.1"> is stored locally </span><span class="No-Break"><span class="koboSpan" id="kobo.392.1">or remotely.</span></span></p>
<h2 id="_idParaDest-193"><a id="_idTextAnchor499"/><span class="koboSpan" id="kobo.393.1">Local buffer optimization in the standard library</span></h2>
<p><span class="koboSpan" id="kobo.394.1">We should </span><a id="_idIndexMarker587"/><span class="koboSpan" id="kobo.395.1">note that the last application of local buffer optimization, storing callables for type-erased objects, is widely used in the C++ standard template library. </span><span class="koboSpan" id="kobo.395.2">For example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">std::shared_ptr</span></strong><span class="koboSpan" id="kobo.397.1"> has a type-erased deleter, and most implementations use the local buffer optimization; the deleter is stored with the reference object and not with each copy of the shared pointer, of course. </span><span class="koboSpan" id="kobo.397.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">std::unique_pointer</span></strong><span class="koboSpan" id="kobo.399.1"> standard, on the other hand, is not type-erased at all, to avoid even a small overhead, or potentially a much larger overhead should the deleter not fit into the </span><span class="No-Break"><span class="koboSpan" id="kobo.400.1">local buffer.</span></span></p>
<p><span class="koboSpan" id="kobo.401.1">The “</span><em class="italic"><span class="koboSpan" id="kobo.402.1">ultimate</span></em><span class="koboSpan" id="kobo.403.1">” type-erased object of the C++ standard library, </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">std::function</span></strong><span class="koboSpan" id="kobo.405.1">, is also typically implemented with a local buffer for storing small callable objects without the expense of an additional allocation. </span><span class="koboSpan" id="kobo.405.2">The universal container ob</span><a id="_idTextAnchor500"/><span class="koboSpan" id="kobo.406.1">ject for any type, </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">std::any</span></strong><span class="koboSpan" id="kobo.408.1"> (since C++17), is also typically implemented without a dynamic allocation </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">when possible.</span></span></p>
<h1 id="_idParaDest-194"><a id="_idTextAnchor501"/><span class="koboSpan" id="kobo.410.1">Local buffer optimization in detail</span></h1>
<p><span class="koboSpan" id="kobo.411.1">We have seen the applications of local buffer optimization; for simplicity, we stayed with the most </span><a id="_idIndexMarker588"/><span class="koboSpan" id="kobo.412.1">basic implementation of it. </span><span class="koboSpan" id="kobo.412.2">This simple implementation misses several important details, which we will </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">now highlight.</span></span></p>
<p><span class="koboSpan" id="kobo.414.1">First of all, we completely neglected the alignment of the buffer. </span><span class="koboSpan" id="kobo.414.2">The type we used to reserve the space inside an object is </span><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">char</span></strong><span class="koboSpan" id="kobo.416.1">; therefore, our buffer is byte-aligned. </span><span class="koboSpan" id="kobo.416.2">Most data types have higher alignment requirements: the exact requirements are platform-specific, but most built-in types are aligned on their own size (double is 8-byte-aligned on a 64-bit platform such as x86). </span><span class="koboSpan" id="kobo.416.3">Higher alignments are needed for some machine-specific types such as packed integer or floating-point arrays for </span><span class="No-Break"><span class="koboSpan" id="kobo.417.1">AVX instructions.</span></span></p>
<p><span class="koboSpan" id="kobo.418.1">Alignment is important: depending on the processor and the code generated by the compiler, accessing memory not aligned as required by the data type can result in poor performance or memory access violations (crashes). </span><span class="koboSpan" id="kobo.418.2">For example, most AVX instructions require 16- or 32-byte alignment, and the unaligned versions of these instructions are significantly slower. </span><span class="koboSpan" id="kobo.418.3">Another example is atomic operations such as the ones used in mutexes and other concurrent data structures: they also don’t work if the data type is not properly aligned (for example, an atomic </span><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">long</span></strong><span class="koboSpan" id="kobo.420.1"> must be aligned on an </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">8-byte boundary).</span></span></p>
<p><span class="koboSpan" id="kobo.422.1">Specifying the minimum alignment for our buffer is not hard, at least if we know the type we want to store in the buffer. </span><span class="koboSpan" id="kobo.422.2">For example, if we have a small vector for an arbitrary type </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">T</span></strong><span class="koboSpan" id="kobo.424.1">, we can </span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">simply write:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.426.1">
template &lt;typename T&gt;
class small_vector {
  alignas(T) char buffer_[buffer_size_];
  …
};</span></pre>
<p><span class="koboSpan" id="kobo.427.1">If the buffer is used for storing an object of one of several types, we have to use the highest alignment of all possible types. </span><span class="koboSpan" id="kobo.427.2">Finally, if the type of the object to be stored is unknown – the typical case for type-erased implementations – we have to select a “</span><em class="italic"><span class="koboSpan" id="kobo.428.1">high enough</span></em><span class="koboSpan" id="kobo.429.1">” alignment and add a compile-time check at the point where a specific object is constructed in </span><span class="No-Break"><span class="koboSpan" id="kobo.430.1">the buffer.</span></span></p>
<p><span class="koboSpan" id="kobo.431.1">The second important subtlety to remember is how the buffer is defined. </span><span class="koboSpan" id="kobo.431.2">Usually, it is an aligned array of characters (or </span><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">std::byte_t</span></strong><span class="koboSpan" id="kobo.433.1">). </span><span class="koboSpan" id="kobo.433.2">In the previous section, we used an array of </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">int</span></strong><span class="koboSpan" id="kobo.435.1"> for the small vector of integers. </span><span class="koboSpan" id="kobo.435.2">Again, there is a subtlety here: declaring the buffer as an object or an array of objects of the right type will cause these objects to be destroyed automatically when the object containing the buffer is destroyed. </span><span class="koboSpan" id="kobo.435.3">For trivially destructible types such as integers, it makes no difference at all – their destructors </span><span class="No-Break"><span class="koboSpan" id="kobo.436.1">do nothing.</span></span></p>
<p><span class="koboSpan" id="kobo.437.1">In general, this is not so, and an arbitrary destructor can be invoked only if an object was constructed </span><a id="_idIndexMarker589"/><span class="koboSpan" id="kobo.438.1">at this location. </span><span class="koboSpan" id="kobo.438.2">For our small vector, this is not always the case: the vector may be empty or contain fewer objects than the buffer can hold. </span><span class="koboSpan" id="kobo.438.3">This is the most common case by far: usually, if we employ local buffer optimization, we cannot be sure that an object was constructed in the buffer. </span><span class="koboSpan" id="kobo.438.4">In this case, declaring the buffer as an array of non-trivially-destructible objects would be a mistake. </span><span class="koboSpan" id="kobo.438.5">However, if you have a guarantee that, in your particular case, the buffer always contains an object (or several objects, for an array), declaring them with the corresponding type greatly simplifies the implementation of the destructor, as well as the </span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">copy/move operations.</span></span></p>
<p><span class="koboSpan" id="kobo.440.1">You should have noticed by now that a typical implementation of a local buffer needs a lot of boilerplate code. </span><span class="koboSpan" id="kobo.440.2">There are </span><strong class="source-inline"><span class="koboSpan" id="kobo.441.1">reinterpret_cast</span></strong><span class="koboSpan" id="kobo.442.1"> casts everywhere, you have to remember to add the alignment, there are some compile-time checks you should always add to make sure only suitable types are stored in the buffer, and so on. </span><span class="koboSpan" id="kobo.442.2">It is good to combine these details together in a single general reusable implementation. </span><span class="koboSpan" id="kobo.442.3">Unfortunately, as is often the case, there is a tension between reusability and complexity, so we will have to settle for several general </span><span class="No-Break"><span class="koboSpan" id="kobo.443.1">reusable implementations.</span></span></p>
<p><span class="koboSpan" id="kobo.444.1">If we put together everything we have learned about local buffers, we can come up with something </span><span class="No-Break"><span class="koboSpan" id="kobo.445.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.446.1">
// Example 10
template&lt;size_t S, size_t A = alignof(void*)&gt;
struct Buffer {
  constexpr static auto size = S, alignment = A;
  alignas(alignment) char space_[size];
  …
};</span></pre>
<p><span class="koboSpan" id="kobo.447.1">Here we have a buffer of arbitrary size and alignment (both are template parameters). </span><span class="koboSpan" id="kobo.447.2">Now that we </span><a id="_idIndexMarker590"/><span class="koboSpan" id="kobo.448.1">have a space to store objects, we have to make sure the type we want to erase fits into this space. </span><span class="koboSpan" id="kobo.448.2">To this end, it is convenient to add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">constexpr</span></strong><span class="koboSpan" id="kobo.450.1"> validator function (it’s used only in compile-time </span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">syntax checks):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.452.1">
template&lt;size_t S, size_t A = alignof(void*)&gt;
struct Buffer {
  template &lt;typename T&gt; static constexpr bool valid_type()
  {
    return sizeof(T) &lt;= S &amp;&amp; (A % alignof(T)) == 0;
  }
  …
};</span></pre>
<p><span class="koboSpan" id="kobo.453.1">The buffer can be used as if it contained an object of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">T</span></strong><span class="koboSpan" id="kobo.455.1"> by calling the member </span><span class="No-Break"><span class="koboSpan" id="kobo.456.1">function </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.457.1">as&lt;T&gt;()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.459.1">
template&lt;size_t S, size_t A = alignof(void*)&gt;
struct Buffer {
  …
  template &lt;typename T&gt; requires(valid_type&lt;T&gt;())
    T* as() noexcept {
    return reinterpret_cast&lt;T*&gt;(&amp;space_);
  }
  template &lt;typename T&gt; requires(valid_type&lt;T&gt;())
    const T* as() const noexcept {
    return const_cast&lt;Buffer*&gt;(this)-&gt;as&lt;T&gt;();
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.460.1">The buffer can be constructed empty (default-constructed) or with an immediately constructed object. </span><span class="koboSpan" id="kobo.460.2">In the former case, the object can be emplaced later. </span><span class="koboSpan" id="kobo.460.3">Either way, we validate that the </span><a id="_idIndexMarker591"/><span class="koboSpan" id="kobo.461.1">type fits into the buffer and meets the alignment requirements (if C++20 and concepts are not available, SFINAE can be used instead). </span><span class="koboSpan" id="kobo.461.2">The default constructor is trivial, but the emplacing constructor and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">emplace()</span></strong><span class="koboSpan" id="kobo.463.1"> method have constraints on the type and the </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">constructor arguments:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.465.1">
template&lt;size_t S, size_t A = alignof(void*)&gt;
struct Buffer {
  …
  Buffer() = default;
  template &lt;typename T, typename... </span><span class="koboSpan" id="kobo.465.2">Args&gt;
    requires(valid_type&lt;T&gt;() &amp;&amp;
             std::constructible_from&lt;T, Args...&gt;)
  Buffer(std::in_place_type_t&lt;T&gt;, Args&amp;&amp; ...args)
    noexcept(std::is_nothrow_constructible_v&lt;T, Args...&gt;)
  {
    ::new (static_cast&lt;void*&gt;(as&lt;T&gt;()))
      T(std::forward&lt;Args&gt;(args)...);
  }
  template&lt;typename T, typename... </span><span class="koboSpan" id="kobo.465.3">Args&gt;
    requires(valid_type&lt;T&gt;() &amp;&amp;
             std::constructible_from&lt;T, Args...&gt;)
  T* emplace(Args&amp;&amp; ...args)
    noexcept(std::is_nothrow_constructible_v&lt;T, Args...&gt;)
  {
    return ::new (static_cast&lt;void*&gt;(as&lt;T&gt;()))
      T(std::forward&lt;Args&gt;(args)...);
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.466.1">Note that we do check that the requested type can be stored in the buffer but no checking is done at run time to ensure that the buffer does indeed contain such an object. </span><span class="koboSpan" id="kobo.466.2">Such checking can be added at the cost of additional space and run-time computations </span><a id="_idIndexMarker592"/><span class="koboSpan" id="kobo.467.1">and might make sense as a debugging instrumentation. </span><span class="koboSpan" id="kobo.467.2">We do not do anything special for copying, moving, or deleting the buffer. </span><span class="koboSpan" id="kobo.467.3">As-is, this implementation is suitable for trivially copyable and trivially destructible objects. </span><span class="koboSpan" id="kobo.467.4">In this case, we will want to assert these restrictions when an object is constructed in the buffer (in both the constructor and the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">emplace()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.469.1"> method):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.470.1">
template&lt;size_t S, size_t A = alignof(void*)&gt;
struct Buffer {
  template &lt;typename T&gt;
  Buffer(std::in_place_type_t&lt;T&gt;, Args&amp;&amp; ...args) … {
    static_assert(std::is_trivially_destructible_v&lt;T&gt;, "");
    static_assert(std::is_trivially_copyable_v&lt;T&gt;, "");
    …
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.471.1">In this case, it may also make sense to add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">swap()</span></strong><span class="koboSpan" id="kobo.473.1"> method to </span><span class="No-Break"><span class="koboSpan" id="kobo.474.1">the class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.475.1">
template&lt;size_t S, size_t A = alignof(void*)&gt;
struct Buffer {
  …
  void swap(Buffer&amp; that) noexcept {
    alignas(alignment) char tmp[size];
    ::memcpy(tmp, this-&gt;space_, size);
    ::memcpy(this-&gt;space_, that.space_, size);
    ::memcpy(that.space_, tmp, size);
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.476.1">On the other hand, if we’re using this buffer for storing objects of a single known type and that type is not trivially destructible, we end up writing something like this all </span><span class="No-Break"><span class="koboSpan" id="kobo.477.1">the time:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.478.1">
buffer_.as&lt;T&gt;()-&gt;~T();</span></pre>
<p><span class="koboSpan" id="kobo.479.1">We can simplify </span><a id="_idIndexMarker593"/><span class="koboSpan" id="kobo.480.1">the client code by adding another generally </span><span class="No-Break"><span class="koboSpan" id="kobo.481.1">usable method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.482.1">
template&lt;size_t S, size_t A = alignof(void*)&gt;
struct Buffer {
  …
  template &lt;typename T&gt; void destroy() {
    this-&gt;as&lt;T&gt;()-&gt;~T();
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.483.1">We can add similar methods to copy and move objects stored in the buffer, or leave that to </span><span class="No-Break"><span class="koboSpan" id="kobo.484.1">the client.</span></span></p>
<p><span class="koboSpan" id="kobo.485.1">Our general local buffer implementation works for all trivially copyable and destructible types, as well as for all cases where the type is known and the client of our code handles copying and destroying the objects stored in the buffer. </span><span class="koboSpan" id="kobo.485.2">There is one special case that is left out but is nonetheless worth considering: when a local buffer is used in type-erased classes, the stored (erased) type may require non-trivial copying or deletion but the client cannot do these operations since the whole point of type erasure is that the client code does not know the erased type after it was emplaced into the buffer. </span><span class="koboSpan" id="kobo.485.3">In this special case, we need to capture the type at the point when it was stored and generate the corresponding copy, move, and deletion operations. </span><span class="koboSpan" id="kobo.485.4">In other words, we have to combine our </span><a id="_idIndexMarker594"/><span class="koboSpan" id="kobo.486.1">local buffer with the techniques we learned earlier, in </span><a href="B19262_06.xhtml#_idTextAnchor266"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.487.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.488.1">, </span><em class="italic"><span class="koboSpan" id="kobo.489.1">Understanding Type Erasure</span></em><span class="koboSpan" id="kobo.490.1">, about type erasure. </span><span class="koboSpan" id="kobo.490.2">The most suitable variant of type erasure, in this case, is </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">vtable</span></strong><span class="koboSpan" id="kobo.492.1"> – a table of function pointers we generate using templates. </span><span class="koboSpan" id="kobo.492.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">vtable</span></strong><span class="koboSpan" id="kobo.494.1"> itself is an aggregate (</span><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">struct</span></strong><span class="koboSpan" id="kobo.496.1">) holding function pointers that will do the deletion, copying, </span><span class="No-Break"><span class="koboSpan" id="kobo.497.1">or moving:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.498.1">
// Example 11
template&lt;size_t S, size_t A = alignof(void*)&gt;
struct Buffer {
  …
  struct vtable_t {
    using deleter_t = void(Buffer*);
    using copy_construct_t = void(Buffer*, const Buffer*);
    using move_construct_t = void(Buffer*, Buffer*);
    deleter_t*  deleter_;
    copy_construct_t* copy_construct_;
    move_construct_t* move_construct_;
  };
  const vtable_t* vtable_ = nullptr;
};</span></pre>
<p><span class="koboSpan" id="kobo.499.1">We need one class member, </span><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">vtable_</span></strong><span class="koboSpan" id="kobo.501.1">, to store a pointer to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">vtable</span></strong><span class="koboSpan" id="kobo.503.1">. </span><span class="koboSpan" id="kobo.503.2">The object that we will point to needs to be created by the constructor or the </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">emplace()</span></strong><span class="koboSpan" id="kobo.505.1"> method, of course – that is the only time we know the real type and how to delete or copy it. </span><span class="koboSpan" id="kobo.505.2">But we are not going to do dynamic memory allocation for it. </span><span class="koboSpan" id="kobo.505.3">Instead, we create a static template variable and initialize it with pointers to static member functions (also templates). </span><span class="koboSpan" id="kobo.505.4">The compiler creates an instance of this static variable for every type we store in the buffer. </span><span class="koboSpan" id="kobo.505.5">Of course, we also need static template functions (a pointer to a static member function is the same as a regular function pointer, rather than a member function pointer). </span><span class="koboSpan" id="kobo.505.6">These </span><a id="_idIndexMarker595"/><span class="koboSpan" id="kobo.506.1">functions are instantiated by the compiler with the same type </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">T</span></strong><span class="koboSpan" id="kobo.508.1"> of the object that is stored in </span><span class="No-Break"><span class="koboSpan" id="kobo.509.1">the buffer:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.510.1">
template&lt;size_t S, size_t A = alignof(void*)&gt;
struct Buffer {
  …
  template &lt;typename U, typename T&gt;
  constexpr static vtable_t vtable = {
    U::template deleter&lt;T&gt;,
    U::template copy_construct&lt;T&gt;,
    U::template move_construct&lt;T&gt;
  };
  template &lt;typename T&gt;
    requires(valid_type&lt;T&gt;() &amp;&amp;
    std::is_nothrow_destructible_v&lt;T&gt;)
  static void deleter(Buffer* space) {
    space-&gt;as&lt;T&gt;()-&gt;~T();
  }
  template &lt;typename T&gt;
    requires(valid_type&lt;T&gt;())
  static void copy_construct(Buffer* to,
                             const Buffer* from)
    noexcept(std::is_nothrow_copy_constructible_v&lt;T&gt;)
  {
    ::new (static_cast&lt;void*&gt;(to-&gt;as&lt;T&gt;()))
      T(*from-&gt;as&lt;T&gt;());
    to-&gt;vtable_ = from-&gt;vtable_;
  }
  template &lt;typename T&gt;
    requires(valid_type&lt;T&gt;())
    static void move_construct(Buffer* to, Buffer* from)
    noexcept(std::is_nothrow_move_constructible_v&lt;T&gt;)
  {
    ::new (static_cast&lt;void*&gt;(to-&gt;as&lt;T&gt;()))
      T(std::move(*from-&gt;as&lt;T&gt;()));
    to-&gt;vtable_ = from-&gt;vtable_;
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.511.1">As shown in </span><a href="B19262_06.xhtml#_idTextAnchor266"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.512.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.513.1">, </span><em class="italic"><span class="koboSpan" id="kobo.514.1">Understanding Type Erasure</span></em><span class="koboSpan" id="kobo.515.1">, we first use template static functions to generate copy, move, and delete operations for any type </span><strong class="source-inline"><span class="koboSpan" id="kobo.516.1">T</span></strong><span class="koboSpan" id="kobo.517.1"> we need. </span><span class="koboSpan" id="kobo.517.2">We store the </span><a id="_idIndexMarker596"/><span class="koboSpan" id="kobo.518.1">pointers to these functions in an instance of a static template variable </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">vtable</span></strong><span class="koboSpan" id="kobo.520.1">, and a pointer to that instance in a (non-static) data member </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">vtable_</span></strong><span class="koboSpan" id="kobo.522.1">. </span><span class="koboSpan" id="kobo.522.2">The latter is our only cost, size-wise (the rest is static variables and functions that are generated by the compiler once for each type stored in </span><span class="No-Break"><span class="koboSpan" id="kobo.523.1">the buffer).</span></span></p>
<p><span class="koboSpan" id="kobo.524.1">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">vtable_</span></strong><span class="koboSpan" id="kobo.526.1"> has to be initialized at the time the object is emplaced in the buffer since this is the last time we explicitly know the type of the </span><span class="No-Break"><span class="koboSpan" id="kobo.527.1">stored object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.528.1">
// Example 11
template&lt;size_t S, size_t A = alignof(void*)&gt;
struct Buffer {
  template &lt;typename T, typename... </span><span class="koboSpan" id="kobo.528.2">Args&gt;
    requires(valid_type&lt;T&gt;() &amp;&amp;
    std::constructible_from&lt;T, Args...&gt;)
  Buffer(std::in_place_type_t&lt;T&gt;, Args&amp;&amp; ...args)
    noexcept(std::is_nothrow_constructible_v&lt;T, Args...&gt;)
    : vtable_(&amp;vtable&lt;Buffer, T&gt;)
  {
    ::new (static_cast&lt;void*&gt;(as&lt;T&gt;()))
      T(std::forward&lt;Args&gt;(args)...);
  }
  template&lt;typename T, typename... </span><span class="koboSpan" id="kobo.528.3">Args&gt;
    requires(valid_type&lt;T&gt;() &amp;&amp;
    std::constructible_from&lt;T, Args...&gt;)
  T* emplace(Args&amp;&amp; ...args)
    noexcept(std::is_nothrow_constructible_v&lt;T, Args...&gt;)
  {
    if (this-&gt;vtable_) this-&gt;vtable_-&gt;deleter_(this);
    this-&gt;vtable_ = &amp;vtable&lt;Buffer, T&gt;;
    return ::new (static_cast&lt;void*&gt;(as&lt;T&gt;()))
      T(std::forward&lt;Args&gt;(args)...);
  }
  …
};</span></pre>
<p><span class="koboSpan" id="kobo.529.1">Note the </span><a id="_idIndexMarker597"/><span class="koboSpan" id="kobo.530.1">initialization of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">vtable_</span></strong><span class="koboSpan" id="kobo.532.1"> member in the constructor. </span><span class="koboSpan" id="kobo.532.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">emplace()</span></strong><span class="koboSpan" id="kobo.534.1"> method, we also have to delete the object previously constructed in the buffer, if </span><span class="No-Break"><span class="koboSpan" id="kobo.535.1">one exists.</span></span></p>
<p><span class="koboSpan" id="kobo.536.1">With the type erasure machinery in place, we can finally implement the destructors and the copy/move operations. </span><span class="koboSpan" id="kobo.536.2">They all use a similar approach – call the corresponding function in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">vtable</span></strong><span class="koboSpan" id="kobo.538.1">. </span><span class="koboSpan" id="kobo.538.2">Here are the </span><span class="No-Break"><span class="koboSpan" id="kobo.539.1">copy operations:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.540.1">
// Example 11
template&lt;size_t S, size_t A = alignof(void*)&gt;
struct Buffer {
  …
  Buffer(const Buffer&amp; that) {
    if (that.vtable_)
      that.vtable_-&gt;copy_construct_(this, &amp;that);
  }
  Buffer&amp; operator=(const Buffer&amp; that) {
    if (this == &amp;that) return *this;
    if (this-&gt;vtable_) this-&gt;vtable_-&gt;deleter_(this);
    if (that.vtable_)
      that.vtable_-&gt;copy_construct_(this, &amp;that);
    else this-&gt;vtable_ = nullptr;
    return *this;
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.541.1">The move </span><a id="_idIndexMarker598"/><span class="koboSpan" id="kobo.542.1">operations are similar, only they use the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">move_construct_</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.544.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.545.1">
template&lt;size_t S, size_t A = alignof(void*)&gt;
struct Buffer {
  …
  Buffer(Buffer&amp;&amp; that) {
    if (that.vtable_)
      that.vtable_-&gt;move_construct_(this, &amp;that);
  }
  Buffer&amp; operator=(Buffer&amp;&amp; that) {
    if (this == &amp;that) return *this;
    if (this-&gt;vtable_) this-&gt;vtable_-&gt;deleter_(this);
    if (that.vtable_)
      that.vtable_-&gt;move_construct_(this, &amp;that);
    else this-&gt;vtable_ = nullptr;
    return *this;
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.546.1">Note that the </span><a id="_idIndexMarker599"/><span class="koboSpan" id="kobo.547.1">move-assignment operator is not required to check for self-assignment, but it’s also not wrong to do so. </span><span class="koboSpan" id="kobo.547.2">It is highly desirable for the move operations to be </span><strong class="source-inline"><span class="koboSpan" id="kobo.548.1">noexcept</span></strong><span class="koboSpan" id="kobo.549.1">; unfortunately, we cannot guarantee that because we do not know the erased type at compile time. </span><span class="koboSpan" id="kobo.549.2">We can make a design choice and declare them </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">noexcept</span></strong><span class="koboSpan" id="kobo.551.1"> anyway. </span><span class="koboSpan" id="kobo.551.2">If we do, we can also assert, at compile-time, that the object we store in the buffer is </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">noexcept</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.553.1"> movable.</span></span></p>
<p><span class="koboSpan" id="kobo.554.1">Finally, we have the destruction operations. </span><span class="koboSpan" id="kobo.554.2">Since we allow the caller to destroy the contained object without destroying the buffer itself (by calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.555.1">destroy()</span></strong><span class="koboSpan" id="kobo.556.1">), we have to take care to ensure that the object gets destroyed </span><span class="No-Break"><span class="koboSpan" id="kobo.557.1">only once:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.558.1">
template&lt;size_t S, size_t A = alignof(void*)&gt;
struct Buffer {
  …
  ~Buffer() noexcept {
    if (this-&gt;vtable_) this-&gt;vtable_-&gt;deleter_(this);
  }
  // Destroy the object stored in the aligned space.
</span><span class="koboSpan" id="kobo.558.2">  void destroy() noexcept {
    if (this-&gt;vtable_) this-&gt;vtable_-&gt;deleter_(this);
    this-&gt;vtable_ = nullptr;
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.559.1">Having the type-erased </span><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">vtable</span></strong><span class="koboSpan" id="kobo.561.1"> allows us to reconstruct, at run time, the type stored in the buffer (it is embedded in the code generated for the static functions such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.562.1">copy_construct()</span></strong><span class="koboSpan" id="kobo.563.1">). </span><span class="koboSpan" id="kobo.563.2">There is, of course, a cost to it; we already noted the additional data member </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">vtable_</span></strong><span class="koboSpan" id="kobo.565.1">, but there is also some run-time cost arising from the indirect function calls. </span><span class="koboSpan" id="kobo.565.2">We can estimate it by using both implementations of the local buffer (with and without type erasure) to store and copy some trivially copyable object, for example, a lambda with a </span><span class="No-Break"><span class="koboSpan" id="kobo.566.1">captured reference:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.567.1">
Benchmark                        Time
BM_lambda_copy_trivial          5.45 ns
BM_lambda_copy_typeerased       4.02 ns</span></pre>
<p><span class="koboSpan" id="kobo.568.1">The overhead of (well-implemented) type erasure is non-negligible but modest. </span><span class="koboSpan" id="kobo.568.2">An added advantage </span><a id="_idIndexMarker600"/><span class="koboSpan" id="kobo.569.1">is that we could also verify at run-time whether or not our calls to </span><strong class="source-inline"><span class="koboSpan" id="kobo.570.1">as&lt;T&gt;()</span></strong><span class="koboSpan" id="kobo.571.1"> refer to a valid type and that the object is indeed constructed. </span><span class="koboSpan" id="kobo.571.2">Relatively to the very cheap implementation of an unchecked method, this would add significant overhead, so probably should be restricted to </span><span class="No-Break"><span class="koboSpan" id="kobo.572.1">debug builds.</span></span></p>
<p><span class="koboSpan" id="kobo.573.1">We have seen significant, sometimes dramatic, improvements to the performance of many different data structures and classes provided by the local buffer optimization. </span><span class="koboSpan" id="kobo.573.2">With the easy-to-use general implementations we just learned, why would you not use this optimization all the time? </span><span class="koboSpan" id="kobo.573.3">As is the case for any design pattern, our exploration is not comple</span><a id="_idTextAnchor502"/><span class="koboSpan" id="kobo.574.1">te without mentioning the trade-offs and </span><span class="No-Break"><span class="koboSpan" id="kobo.575.1">the downsides.</span></span></p>
<h1 id="_idParaDest-195"><a id="_idTextAnchor503"/><span class="koboSpan" id="kobo.576.1">Downsides of local buffer optimization</span></h1>
<p><span class="koboSpan" id="kobo.577.1">Local buffer </span><a id="_idIndexMarker601"/><span class="koboSpan" id="kobo.578.1">optimization is not without its downsides. </span><span class="koboSpan" id="kobo.578.2">The most obvious one is that all objects with a local buffer are larger than they would be without one. </span><span class="koboSpan" id="kobo.578.3">If the typical data stored in the buffer is smaller than the chosen buffer size, then every object is wasting some memory, but at least the optimization is paying off. </span><span class="koboSpan" id="kobo.578.4">Worse, if our choice of buffer size is badly off and most data is, in fact, larger than the local buffer, the data is stored remotely but the local buffers are still created inside every object, and all that memory </span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">is wasted.</span></span></p>
<p><span class="koboSpan" id="kobo.580.1">There is an obvious trade-off between the amount of memory we are willing to waste and the range of data sizes where the optimization is effective. </span><span class="koboSpan" id="kobo.580.2">The size of the local buffer should be carefully chosen with the application </span><span class="No-Break"><span class="koboSpan" id="kobo.581.1">in mind.</span></span></p>
<p><span class="koboSpan" id="kobo.582.1">The more </span><a id="_idIndexMarker602"/><span class="koboSpan" id="kobo.583.1">subtle complication is this - the data that used to be external to the object is now stored inside the object. </span><span class="koboSpan" id="kobo.583.2">This has several consequences, in addition to the performance benefits we were so focused on. </span><span class="koboSpan" id="kobo.583.3">First of all, every copy of the object contains its own copy of the data as long as it fits into the local buffer. </span><span class="koboSpan" id="kobo.583.4">This prevents </span><a id="_idIndexMarker603"/><span class="koboSpan" id="kobo.584.1">designs such as the reference counting of data; for example, a </span><strong class="bold"><span class="koboSpan" id="kobo.585.1">Copy-On-Write </span></strong><span class="koboSpan" id="kobo.586.1">(</span><strong class="bold"><span class="koboSpan" id="kobo.587.1">COW</span></strong><span class="koboSpan" id="kobo.588.1">) string, where the data is not copied as long as all string copies </span><a id="_idTextAnchor504"/><span class="koboSpan" id="kobo.589.1">remain the same, cannot use the small </span><span class="No-Break"><span class="koboSpan" id="kobo.590.1">string optimization.</span></span></p>
<p><span class="koboSpan" id="kobo.591.1">Secondly, the data must be moved if the object itself is moved. </span><span class="koboSpan" id="kobo.591.2">Contrast this with </span><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">std::vector</span></strong><span class="koboSpan" id="kobo.593.1">, which is moved or swapped, essentially like a pointer - the pointer to the data is moved but the data remains in place. </span><span class="koboSpan" id="kobo.593.2">A similar consideration exists for the object contained inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.594.1">std::any</span></strong><span class="koboSpan" id="kobo.595.1">. </span><span class="koboSpan" id="kobo.595.2">You could dismiss this concern as trivial; after all, local buffer optimization is used primarily for small amounts of data, and the cost of moving them should be comparable to the cost of copying the pointer. </span><span class="koboSpan" id="kobo.595.3">However, more than performance is at stake here - moving an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.596.1">std::vector</span></strong><span class="koboSpan" id="kobo.597.1"> (or </span><strong class="source-inline"><span class="koboSpan" id="kobo.598.1">std::any</span></strong><span class="koboSpan" id="kobo.599.1">, for that matter) is guaranteed not to throw an exception. </span><span class="koboSpan" id="kobo.599.2">However, no such guarantees are offered when moving an arbitrary object. </span><span class="koboSpan" id="kobo.599.3">Therefore, </span><strong class="source-inline"><span class="koboSpan" id="kobo.600.1">std::any</span></strong><span class="koboSpan" id="kobo.601.1"> can be implemented with a local buffer optimization only if the object it contains </span><span class="No-Break"><span class="koboSpan" id="kobo.602.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.603.1">std::is_nothrow_move_constructible</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.604.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.605.1">Even such a guarantee does not suffice for the case of </span><strong class="source-inline"><span class="koboSpan" id="kobo.606.1">std::vector</span></strong><span class="koboSpan" id="kobo.607.1">, however; the standard explicitly states that moving, or swapping, a vector does not invalidate iterators pointing to any element of the vector. </span><span class="koboSpan" id="kobo.607.2">Obviously, this requirement is incompatible with local buffer optimization, since moving a small vector would relocate all its elements to a different region of memory. </span><span class="koboSpan" id="kobo.607.3">For that reason, many high-efficiency libraries offer a custom vector-like container that supports small vector optimization, at the</span><a id="_idTextAnchor505"/><span class="koboSpan" id="kobo.608.1"> expense of the standard iterator </span><span class="No-Break"><span class="koboSpan" id="kobo.609.1">invalidation guarantees.</span></span></p>
<h1 id="_idParaDest-196"><a id="_idTextAnchor506"/><span class="koboSpan" id="kobo.610.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.611.1">We have just introduced a design pattern aimed solely at improved performance. </span><span class="koboSpan" id="kobo.611.2">Efficiency is an important consideration for the C++ language; thus, the C++ community developed patterns to address the most common inefficiencies. </span><span class="koboSpan" id="kobo.611.3">Repeated or wasteful memory allocation is perhaps the most common of all. </span><span class="koboSpan" id="kobo.611.4">The design pattern we have just seen - local buffer optimization - is a powerful tool that can greatly reduce such allocations. </span><span class="koboSpan" id="kobo.611.5">We have seen how it can be applied to compact data structures, as well as to store small objects, such as callables. </span><span class="koboSpan" id="kobo.611.6">We have also reviewed the possible downsides of using </span><span class="No-Break"><span class="koboSpan" id="kobo.612.1">this pattern.</span></span></p>
<p><span class="koboSpan" id="kobo.613.1">With the next chapter, </span><a href="B19262_11.xhtml#_idTextAnchor509"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.614.1">Chapter 11</span></em></span></a><span class="koboSpan" id="kobo.615.1">, </span><em class="italic"><span class="koboSpan" id="kobo.616.1">ScopeGuard</span></em><span class="koboSpan" id="kobo.617.1">, we move on to study more complex patterns that address broader design issues. </span><span class="koboSpan" id="kobo.617.2">The idioms we have learned so f</span><a id="_idTextAnchor507"/><span class="koboSpan" id="kobo.618.1">ar are often used in the implementation of </span><span class="No-Break"><span class="koboSpan" id="kobo.619.1">these patterns.</span></span></p>
<h1 id="_idParaDest-197"><a id="_idTextAnchor508"/><span class="koboSpan" id="kobo.620.1">Questions</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.621.1">How can we measure the performance of a small fragment </span><span class="No-Break"><span class="koboSpan" id="kobo.622.1">of code?</span></span></li>
<li><span class="koboSpan" id="kobo.623.1">Why are small and frequent memory allocations particularly bad </span><span class="No-Break"><span class="koboSpan" id="kobo.624.1">for performance?</span></span></li>
<li><span class="koboSpan" id="kobo.625.1">What is local buffer optimization, and how does </span><span class="No-Break"><span class="koboSpan" id="kobo.626.1">it work?</span></span></li>
<li><span class="koboSpan" id="kobo.627.1">Why is an allocation of an additional buffer inside an object </span><span class="No-Break"><span class="koboSpan" id="kobo.628.1">effectively </span></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.629.1">free</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.630.1">?</span></span></li>
<li><span class="koboSpan" id="kobo.631.1">What is short </span><span class="No-Break"><span class="koboSpan" id="kobo.632.1">string optimization?</span></span></li>
<li><span class="koboSpan" id="kobo.633.1">What is small </span><span class="No-Break"><span class="koboSpan" id="kobo.634.1">vector optimization?</span></span></li>
<li><span class="koboSpan" id="kobo.635.1">Why is local buffer optimization particularly effective for </span><span class="No-Break"><span class="koboSpan" id="kobo.636.1">callable objects?</span></span></li>
<li><span class="koboSpan" id="kobo.637.1">What are the trade-offs to consider when using local </span><span class="No-Break"><span class="koboSpan" id="kobo.638.1">buffer optimization?</span></span></li>
<li><span class="koboSpan" id="kobo.639.1">When should an object not be placed in a </span><span class="No-Break"><span class="koboSpan" id="kobo.640.1">local buffer?</span></span></li>
</ol>
</div>
</body></html>