<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Qt Graphical Applications</h1>
                </header>
            
            <article>
                
<p>In <a href="34ba2c98-98be-433d-b868-9aa7745dd6a6.xhtml" target="_blank">Chapter 4</a>, <em>Library Management System with Pointers</em>, we developed abstract datatypes and a library management system. However, those applications were text-based. In this chapter, we will look into three graphical applications that we will develop with the Qt graphical library:</p>
<ul>
<li><strong>Clock</strong>: We will develop an analog clock with hour, minute, and second hands, with lines to mark hours, minutes, and seconds</li>
<li><strong>The drawing program</strong>: A program that draws lines, rectangles, and ellipses in different colors</li>
<li><strong>The editor</strong>: A program where the user can input and edit text</li>
</ul>
<p class="chapter-content">We will also learn about the Qt library:</p>
<ul>
<li>Windows and widgets</li>
<li>Menus and toolbars</li>
<li>Drawing figures and writing text in the window</li>
<li>How to catch mouse and keyboard events</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the clock application</h1>
                </header>
            
            <article>
                
<p>In this chapter and the next chapter, we will work with Qt, which is an object-oriented class library for graphical applications. We will also work with Qt Creator, instead of Visual Studio, which is an integrated development environment.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up the environment</h1>
                </header>
            
            <article>
                
<p>When creating a new graphical project in Qt Creator, we select <span class="packt_screen">New File or Project </span>in the <span class="packt_screen">File</span> menu, which makes the <span class="packt_screen">New File or Project</span> dialog window become visible. We select <span class="packt_screen">Qt Widgets Application</span>, and click the <span class="packt_screen">Choose</span> button.</p>
<p>Then the <span class="packt_screen">Introduction and Project Location</span> dialog becomes visible. We name the project <kbd>Clock</kbd>, place it in an appropriate location, and click the <span class="packt_screen">Next</span> button. In the <span class="packt_screen">Kit</span><span class="packt_screen">Selection</span> dialog, we select the latest version of the Qt library, and click <span class="packt_screen">Next</span>. In the <span class="packt_screen">Class </span><span class="packt_screen">Information</span> dialog, we name the base class of the application <kbd>clock</kbd>. Normally, the window of a graphical application inherits a <kbd>window</kbd> class. In this case, however, we are dealing with a relatively simple application. Therefore, we inherit the Qt class <kbd>QWidget</kbd>, even though a widget often refers to a smaller graphical object that is often embedded in the window. In Qt Creator, it is possible to add forms. However, we do not use that feature in this chapter. Therefore, we uncheck the <span class="packt_screen">Generate</span> form option.</p>
<div class="packt_tip">All class names in Qt start with the letter <kbd>Q</kbd>.</div>
<p>Finally, in the <span class="packt_screen">Project</span> <span class="packt_screen">Management</span> dialog, we simply accept the default values and click <span class="packt_screen">Finish</span> to generate the project, with the files <kbd>Clock.h</kbd> and <kbd>Clock.cpp</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Clock class</h1>
                </header>
            
            <article>
                
<p>The project is made up by the files <kbd>Clock.h</kbd>, <kbd>Clock.cpp</kbd>, and <kbd>Main.cpp</kbd>. The class definition looks a little bit different compared to the classes of the previous chapters. We enclose the class definition with <em>include guards</em>. That is, we must enclose the class definition with the preprocessor directive <kbd>ifndef</kbd>, <kbd>define</kbd>, and <kbd>endif</kbd>. The preprocessor performs text substitutions.</p>
<p>The <kbd>ifndef</kbd> and <kbd>endif</kbd> directives work as the <kbd>if</kbd> statement in C++. If the condition is not true, the code between the directives is omitted. In this case, the code is included only if the <kbd>CLOCK_H</kbd> macro has not previously been defined. If the code is included, the macro becomes defined at the next line with the <kbd>define</kbd> directive. In this way, the class definition is included in the project only once. Moreover, we also include the system header files <kbd>QWidget</kbd> and <kbd>QTimer</kbd> in the <kbd>Clock.h</kbd> header file rather than the <kbd>Clock.cpp</kbd> definition file.</p>
<p><strong>Clock.h:</strong></p>
<pre>    #ifndef CLOCK_H 
    #define CLOCK_H 
 
    #include &lt;QWidget&gt; 
    #include &lt;QTimer&gt; </pre>
<p>Since <kbd>Clock</kbd> is a subclass of the Qt <kbd>QWidget</kbd> class, the <kbd>Q_OBJECT</kbd> macro must be included, which includes certain code from the Qt library. We need it to use the <kbd>SIGNAL</kbd> and <kbd>SLOT</kbd> macros shown here:</p>
<pre>    class Clock : public QWidget { 
      Q_OBJECT </pre>
<p>The constructor takes a pointer to its parent widget, for which the default is <kbd>nullptr</kbd>:</p>
<pre>    public: 
      Clock(QWidget* parentWidgetPtr = nullptr); </pre>
<p>The <kbd>paintEvent</kbd> method is called by the framework every time the window needs to be repainted. It takes a pointer to a <kbd>QPaintEvent</kbd> object as parameter, which can be used to determine in which way the repainting shall be performed:</p>
<pre>    void paintEvent(QPaintEvent *eventPtr); </pre>
<p><kbd>QTimer</kbd> is a Qt system class that handles a timer. We will use that to move the hands of the clock:</p>
<pre>      private: 
        QTimer m_timer; 
    }; 
 
    #endif // CLOCK_H </pre>
<p>The definition file is mainly made up of the <kbd>paintEvent</kbd> method, which handles the painting of the clock.</p>
<p><strong>Clock.cpp:</strong><a><br/></a></p>
<pre>    #include &lt;QtWidgets&gt; 
    #include "Clock.h"</pre>
<p>In the constructor, we call the base class <kbd>QWidget</kbd> with the <kbd>parentWidgetPtr</kbd> parameter (which may be <kbd>nullptr</kbd>):</p>
<pre>    Clock::Clock(QWidget* parentWidgetPtr /* = nullptr */) 
     :QWidget(parentWidgetPtr) { </pre>
<p>We set the title of the window to <kbd>Clock</kbd>. In Qt, we always use the <kbd>tr</kbd> function for literal text, which in turn calls the Qt method <kbd>translate</kbd> in the Qt <kbd>QCoreApplication</kbd> class that makes sure the text is translated into a form suitable to be displayed. We also resize the size of the window to 1000 x 500 pixels, which is appropriate for most screens:</p>
<pre>    setWindowTitle(tr("Clock")); 
    resize(1000, 500); </pre>
<p>We need a way to connect the timer with the clock widget: when the timer has finished its countdown, the clock shall be updated. For that purpose, Qt provides us with the Signal and Slot system. When the timer reaches its countdown, it calls its method <kbd>timeout</kbd>. We use the <kbd>connect</kbd> method together with the <kbd>SIGNAL</kbd> and <kbd>SLOT</kbd> macros to connect the call to <kbd>timeout</kbd> with the call to the <kbd>update</kbd> method in the Qt <kbd>QWidget</kbd> class, which updates the drawing of the clock. The <kbd>SIGNAL</kbd> macro registers that the call to timeout shall raise a signal, the <kbd>SLOT</kbd> macro registers that the update method shall be called when the signal is raised, and the <kbd>connect</kbd> method connects the signal with the slot. We have set up a connection between the timer's timeout and the update of the clock:</p>
<pre>      m_timer.setParent(this); 
      connect(&amp;m_timer, SIGNAL(timeout()), this, SLOT(update())); 
      m_timer.start(100); 
    }</pre>
<p>The <kbd>paintEvent</kbd> method is called every time the window needs to be repainted. It may be due to some external cause, such as the user resizes the window. It may also be due to a call to the <kbd>update</kbd> method of the <kbd>QMainWindow</kbd> class, which in turn eventually calls <kbd>paintEvent</kbd>.</p>
<p>In this case, we do not need any information about the event, so we enclose the <kbd>eventPtr</kbd> parameter in comments. The <kbd>width</kbd> and <kbd>height</kbd> methods give the width and height of the paintable part of the window, in pixels. We call the <kbd>qMin</kbd> method to decide the minimum side of the window, and the <kbd>currentTime</kbd> method of the <kbd>QTime</kbd> class to find the current time for the clock:</p>
<pre>    void Clock::paintEvent(QPaintEvent* /* eventPtr */) { 
      int side = qMin(width(), height()); 
      QTime time = QTime::currentTime();</pre>
<p>The <kbd>QPainter</kbd> class can be viewed as a painting canvas. We start by initializing it to appropriate aliasing. We then call the <kbd>translate</kbd> and <kbd>scale</kbd> methods to transform the physical size in pixels to the logical size of <kbd>200</kbd> * <kbd>200</kbd> units:</p>
<pre>      QPainter painter(this); 
      painter.setRenderHint(QPainter::Antialiasing); 
      painter.setRenderHint(QPainter::TextAntialiasing); 
      painter.translate(width() / 2, height() / 2); 
      painter.scale(side / 200.0, side / 200.0); </pre>
<p>We paint 60 lines for the minutes. Every fifth line shall be a little bit longer to mark the current hours. For each minute, we draw a line, and then we call the Qt <kbd>rotate</kbd> method, which rotates the drawing by <kbd>6</kbd> degrees. In this way, we rotate the drawing by 6 degrees 60 times, which sums up to 360 degrees, a whole lap:</p>
<pre>      for (int second = 0; second &lt;= 60; ++second) { 
        if ((second % 5) == 0) { 
          painter.drawLine(QPoint(0, 81), QPoint(0, 98)); 
        } 
        else { 
          painter.drawLine(QPoint(0, 90), QPoint(0, 98)); 
        } </pre>
<p>A complete leap is 360 degrees. For each line we rotate by <kbd>6</kbd> degrees, since 360 divided by 60 is <kbd>6</kbd> degrees. When we are finished with the rotations, the drawing is reset to its original settings:</p>
<pre>        painter.rotate(6); 
      }  </pre>
<p>We obtain the current hour, minute, second, and millisecond from the <kbd>QTime</kbd> object:</p>
<pre>      double hours = time.hour(), minutes = time.minute(), 
             seconds = time.second(), milliseconds = time.msec(); </pre>
<p>We set the pen color to black and the background color to gray:</p>
<pre>      painter.setPen(Qt::black); 
      painter.setBrush(Qt::gray);</pre>
<p>We define the endpoints of the hour hand. The hour hand is a little bit thicker and shorter than the minute and second hands. We define three points that constitute the endpoint of the hour hand. The base of the hour hand is 16 units long and located 8 units from the origin. Therefore, we set the x coordinate of the base points to <kbd>8</kbd> and <kbd>-8</kbd>, and the y coordinate to <kbd>8</kbd>. Finally, we define the length of the hour hand to <kbd>60</kbd> units. The value is negative in order to correspond with current rotation:</p>
<pre>      { static const QPoint hourHand[3] = 
          {QPoint(8, 8), QPoint(-8, 8), QPoint(0, -60)};</pre>
<p>The <kbd>save</kbd> method saves the current settings of the <kbd>QPointer</kbd> object. The settings are later restored by the <kbd>restore</kbd> method:</p>
<pre>        painter.save(); </pre>
<p>We find out the exact angle of the current hour hand by calculating the hours, minutes, seconds, and milliseconds. We then rotate to set the hour hand. Each hour corresponds to 30 degrees, since we have 12 hours, and 360 degrees divided by 12 is 30 degrees:</p>
<pre>        double hour = hours + (minutes / 60.0) + (seconds / 3600.0) + 
                      (milliseconds / 3600000.0); 
        painter.rotate(30.0 * hour); </pre>
<p>We call the <kbd>drawConvexPloygon</kbd> method with the three points of the hour hand:</p>
<pre>        painter.drawConvexPolygon(hourHand, 3); 
        painter.restore(); 
      } </pre>
<p>We draw the minute hand in the same way. It is a little bit thinner and longer than the hour hand. Another difference is that while we had 12 hours, we now have 60 minutes. This gives that each minute corresponds to <kbd>6</kbd> degrees, since 360 degrees divided by 60 is 6 degrees:</p>
<pre>      { static const QPoint minuteHand[3] = 
          {QPoint(6, 8), QPoint(-6, 8), QPoint(0, -70)}; 
        painter.save(); </pre>
<p>When calculating the current minute angle, we use the minutes, seconds, and milliseconds:</p>
<pre>        double minute = minutes + (seconds / 60.0) + 
                        (milliseconds / 60000.0); 
        painter.rotate(6.0 * minute); 
        painter.drawConvexPolygon(minuteHand, 3); 
        painter.restore(); 
      }</pre>
<p>The drawing of the second hand is almost identical to the drawing of the previous minute hand. The only difference is that we only use seconds and milliseconds to calculate the second angle:</p>
<pre>      { static const QPoint secondHand[3] = 
          {QPoint(4, 8), QPoint(-4, 8), QPoint(0, -80)}; 
 
        painter.save(); 
        double second = seconds + (milliseconds / 1000); 
        painter.rotate(6.0 * second); 
        painter.drawConvexPolygon(secondHand, 3); 
        painter.restore(); 
      } 
    } </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The main function</h1>
                </header>
            
            <article>
                
<p>In the <kbd>main</kbd> function, we initialize and start the Qt application. The <kbd>main</kbd> function can take the parameters <kbd>argc</kbd> and <kbd>argv</kbd>. It holds the command-line arguments of the applications; <kbd>argc</kbd> holds the number of arguments and the <kbd>argv</kbd> array holds the arguments themselves. The first entry of <kbd>argv</kbd> always holds the path to the execution file, and the last entry is always <kbd>nullptr</kbd>. The <kbd>QApplication</kbd> class takes <kbd>argc</kbd> and <kbd>argv</kbd> and initializes the Qt application. We create an object of our <kbd>Clock</kbd> class, and call <kbd>show</kbd> to make it visible. Finally, we call <kbd>exec</kbd> of the <kbd>QApplication</kbd> object.</p>
<p><strong>Main.cpp:</strong><a><br/></a></p>
<pre>    #include &lt;QApplication&gt; 
    #include "Clock.h" 
 
    int main(int argc, char *argv[]) { 
      QApplication application(argc, argv); 
      Clock Clock; 
      Clock.show(); 
      return application.exec(); 
    }</pre>
<p>To execute the application, we select the <span class="packt_screen">Run</span> option on the project:</p>
<div class="packt_figure CDPAlignCenter"><img height="341" src="assets/4e8a7f8f-c0bc-4cfb-b4b7-8aa2fa5e81f1.png" width="333"/></div>
<p>The execution will continue until the user closes the <kbd>Clock</kbd> window by pressing the close button in the top-right corner:</p>
<div class="packt_figure CDPAlignCenter"><img height="227" src="assets/f489094c-a214-400d-bdb7-32e03e57e385.png" width="424"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up reusable classes for windows and widgets</h1>
                </header>
            
            <article>
                
<p>In graphical applications, there are windows and widgets. A window is often a complete window with a frame holding title, menu bar, and buttons for closing and resizing the window. A widget is often a smaller graphical object, often embedded in a window. In the <em>Clock</em> project, we used only a <kbd>widget</kbd> class that inherits the <kbd>QWidget</kbd> class. However, in this section we will leave the <em>Clock</em> project and look into more advanced applications with both a window and a widget. The window holds the frame with the menu bar and toolbar, while the widget is located in the window and takes care of the graphical content.</p>
<p>In the following sections of this chapter, we will look into a drawing program and an editor. Those applications are typical document applications, where we open and save documents, as well as also cut, copy, paste, and delete elements of the document. In order to add menus and toolbars to the window, we need to inherit the two Qt classes, <kbd>QMainWindow</kbd> and <kbd>QWidget</kbd>. We need <kbd>QMainWindow</kbd> to add menus and toolbars to the window frame, and <kbd>QWidget</kbd> to draw images in the window's area.</p>
<p>In order to reuse the document code in the applications introduced in the remaining part of this chapter and in the next chapter, in this section, we define the classes <kbd>MainWindow</kbd> and <kbd>DocumentWidget</kbd>. Those classes will then be used by the drawing program and the editor later in the following sections of this chapter. <kbd>MainWindow</kbd> sets up a window with the <kbd>File</kbd> and <kbd>Edit</kbd> menus and toolbars, while <kbd>DocumentWidget</kbd> provides a framework that sets up skeleton code for the <kbd>New</kbd>, <kbd>Open</kbd>, <kbd>Save</kbd>, <kbd>SaveAs</kbd>, <kbd>Cut</kbd>, <kbd>Copy</kbd>, <kbd>Paste</kbd>, <kbd>Delete</kbd>, and <kbd>Exit</kbd> items. In this section, we will not create a new Qt project, we will just write the classes <kbd>MainWindow</kbd> and <kbd>DocumentWidget</kbd>, which are used as base classes in the drawing program and editor later in this chapter, and the <kbd>LISTENER</kbd> macro, which is used to set up menu and toolbar items.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding a listener</h1>
                </header>
            
            <article>
                
<p>A <span class="Keyword">listener</span> is a method that is called when the user selects a menu item or a toolbar item. The <kbd>Listener</kbd> macro adds a listener to the class.</p>
<p><strong>Listener.h:</strong></p>
<pre>    #ifndef LISTENER_H 
    #define LISTENER_H 
 
    #include &lt;QObject&gt;</pre>
<p>Due to Qt rules regarding menus and toolbars, the listener called by the Qt Framework in response to a user action must be a function rather than a method.</p>
<div class="packt_tip">A method belongs to a class, while a function is free-standing.</div>
<p>The <kbd>DefineListener</kbd> macro defines both a friendly function and a method. The Qt Framework calls the function, which in turns calls the method:</p>
<pre>    #define DEFINE_LISTENER(BaseClass, Listener)           
      friend bool Listener(QObject* baseObjectPtr) {       
         return ((BaseClass*) baseObjectPtr)-&gt;Listener();  
      }                                                    
      bool Listener()                                      </pre>
<p>The <kbd>Listener</kbd> macro is defined as a pointer to the method:</p>
<pre>    #define LISTENER(Listener) (&amp;::Listener) </pre>
<p>The listener method takes an <kbd>QObject</kbd> pointer as a parameter and returns a Boolean value:</p>
<pre>    typedef bool (*Listener)(QObject*); 
    #endif // LISTENER_H </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The base window class</h1>
                </header>
            
            <article>
                
<p>The <kbd>MainWindow</kbd> class sets up a document window with the <kbd>File</kbd> and <kbd>Edit</kbd> menus and toolbars. It also provides the <kbd>addAction</kbd> method, which is intended for subclasses to add application-specific menus and toolbars.</p>
<p><strong>MainWindow.h:</strong></p>
<pre>    #ifndef MAINWINDOW_H 
    #define MAINWINDOW_H 
 
    #include &lt;QMainWindow&gt; 
    #include &lt;QActionGroup&gt; 
    #include &lt;QPair&gt; 
    #include &lt;QMap&gt; 
 
    #include "Listener.h" 
    #include "DocumentWidget.h" 
 
    class MainWindow : public QMainWindow { 
      Q_OBJECT 
 
      public: 
        MainWindow(QWidget* parentWidgetPtr = nullptr); 
        ~MainWindow(); 
 
      protected: 
        void addFileMenu(); 
        void addEditMenu(); </pre>
<p>The <kbd>addAction</kbd> method adds a menu item, with a potential accelerator key, toolbar icon, and listeners to mark the item with a checkbox or a radio button:</p>
<pre>      protected: 
        void addAction(QMenu* menuPtr, QString text, 
                       const char* onSelectPtr, 
                       QKeySequence acceleratorKey = 0, 
                       QString iconName = QString(), 
                       QToolBar* toolBarPtr = nullptr, 
                       QString statusTip = QString(), 
                       Listener enableListener = nullptr, 
                       Listener checkListener = nullptr, 
                       QActionGroup* groupPtr = nullptr); </pre>
<p>We use the <kbd>DefineListener</kbd> macro to add a listener to decide whether a menu item shall be enabled. The listeners return <kbd>true</kbd> if the item shall be enabled. <kbd>DocumentWidget</kbd> is a sub class of the Qt class <kbd>QWidget</kbd>, which we will define in the next section. With the <kbd>DEFINE_LISTENER</kbd> macro, we add the <kbd>isSaveEnabled</kbd>, <kbd>isCutEnabled</kbd>, <kbd>isCopyEnabled</kbd>, <kbd>isPasteEnabled</kbd>, and <kbd>isDeleteEnabled</kbd> methods to the <kbd>MainWindow</kbd> class. They will be called when the user selects a menu item:</p>
<pre>        DEFINE_LISTENER(DocumentWidget, isSaveEnabled); 
        DEFINE_LISTENER(DocumentWidget, isCutEnabled); 
        DEFINE_LISTENER(DocumentWidget, isCopyEnabled); 
        DEFINE_LISTENER(DocumentWidget, isPasteEnabled); 
        DEFINE_LISTENER(DocumentWidget, isDeleteEnabled); </pre>
<p>The <kbd>onMenuShow</kbd> method is called before a menu becomes visible; it calls the listener of the items of the menu to decide whether they shall be disabled or annotated by a checkbox or a radio button. It is also called by the framework in order to disable toolbar icons:</p>
<pre>      public slots: 
        void onMenuShow();</pre>
<p>The <kbd>m_enableMap</kbd> and <kbd>m_checkMap</kbd> fields hold maps of listeners for the menu items. The preceding <kbd>onMenuShow</kbd> method uses them to decide whether to disable the item, or annotate it with a checkbox or a radio button:</p>
<pre>      private: 
        QMap&lt;QAction*,QPair&lt;QObject*,Listener&gt;&gt; m_enableMap, 
                                                m_checkMap; 
    }; 
 
    #endif // MAINWINDOW_H </pre>
<p><strong>MainWindow.cpp:</strong><a><br/></a></p>
<pre>    #include "MainWindow.h" 
    #include &lt;QtWidgets&gt; </pre>
<p>The constructor calls the constructor of the Qt <kbd>QMainWindow</kbd> class, with the parent widget pointer as its parameter:</p>
<pre>    MainWindow::MainWindow(QWidget* parentWidgetPtr /*= nullptr*/) 
     :QMainWindow(parentWidgetPtr) { 
    } </pre>
<p>When a menu item is added, it is connected to an action. The destructor deallocates all actions of the menu bar:</p>
<pre>    MainWindow::~MainWindow() { 
      for (QAction* actionPtr : menuBar()-&gt;actions()) { 
        delete actionPtr; 
      } 
    } </pre>
<p>The <kbd>addFileMenu</kbd> method adds the standard <kbd>File</kbd> menu to the menu bar; <kbd>menubar</kbd> is a Qt method that returns a pointer to the menu bar of the window:</p>
<pre>    void MainWindow::addFileMenu() { 
      QMenu* fileMenuPtr = menuBar()-&gt;addMenu(tr("&amp;File"));</pre>
<p>Similar to the <kbd>connect</kbd> method which connects the menu item with the <kbd>onMenuShow</kbd> method in the following code snippet. The Qt macros <kbd>SIGNAL</kbd> and <kbd>SLOT</kbd> ensure that <kbd>onMenuShow</kbd> is called before the menu becomes visible. The <kbd>onMenuShow</kbd> method sets the enable, checkbox, and radio bottom status for each item of the menu before the menu becomes visible. It also sets the enable status of toolbars images. The <kbd>aboutToShow</kbd> method is called before each menu becomes visible in order to enable or disable the items, and to possibly mark them with check boxes or radio buttons:</p>
<pre>      connect(fileMenuPtr, SIGNAL(aboutToShow()), this, 
              SLOT(onMenuShow())); </pre>
<p>The Qt <kbd>addToolBar</kbd> method adds a toolbar to the window's frame. When we call <kbd>addAction</kbd> here, the menu item will be added to the menu and, if present, to the toolbar:</p>
<pre>      QToolBar *fileToolBarPtr = addToolBar(tr("File")); </pre>
<p>The <kbd>addAction</kbd> method adds the <kbd>New</kbd>, <kbd>Open</kbd>, <kbd>Save</kbd>, <kbd>SaveAs</kbd>, and <kbd>Exit</kbd> menu items. It takes the following parameters:</p>
<ul>
<li>A pointer to the menu the item shall belong to.</li>
<li>The item text. The ampersand (<kbd>&amp;</kbd>) before the text (<kbd>&amp;New</kbd>) indicates that the next letter (<kbd>N</kbd>) will be underlined, and that the user can select that item by pressing <em>Alt</em>-<em>N</em>.</li>
<li>Accelerator information. <kbd>QKeySequence</kbd> is a Qt enumeration holding accelerator key combinations. <kbd>QKeySequence::New</kbd> indicates that the user can select the item by pressing <em>Ctrl</em>-<em>N</em>. The text <kbd>Ctrl+N</kbd> will also be added to the item text.</li>
<li>The name of an icon file (<kbd>new</kbd>). The icon of the file is displayed both to the left of the item text and on the toolbar. The icon file itself is added to the project in Qt Creator.</li>
<li>A pointer to the toolbar, <kbd>nullptr</kbd> if the item is not connected to a toolbar.</li>
<li>The text displayed when the user hovers with the mouse over the toolbar item. Ignored if the item is not connected to a toolbar.</li>
<li>Listeners (default <kbd>nullptr</kbd>) that are called before the menu and toolbar become visible, and deciding whether the item is enabled or marked with a checkbox or a radio button:</li>
</ul>
<pre>  addAction(fileMenuPtr, tr("&amp;New"), SLOT(onNew()), 
            QKeySequence::New, tr("new"), fileToolBarPtr, 
            tr("Create a new file")); 
 
  addAction(fileMenuPtr, tr("&amp;Open"), SLOT(onOpen()), 
            QKeySequence::Open, tr("open"), fileToolBarPtr, 
            tr("Open an existing file")); </pre>
<p>When there are no changes in the document since it was last saved, the document does not need to be saved and the <kbd>Save</kbd> item shall be disabled. Therefore, we add an extra parameter, indicating that the <kbd>isSaveEnabled</kbd> method shall be called to enable or disable the menu and toolbar item:</p>
<pre>      addAction(fileMenuPtr, tr("&amp;Save"), SLOT(onSave()), 
                QKeySequence::Save, tr("save"), fileToolBarPtr, 
                tr("Save the document to disk"), 
                LISTENER(isSaveEnabled)); </pre>
<p>The <kbd>SaveAs</kbd> menu item has no key sequence. Moreover, it does not have a toolbar entry. Therefore, the name of the icon file and the toolbar text are default <kbd>QString</kbd> objects and the toolbar pointer is <kbd>nullptr</kbd>:</p>
<pre>      addAction(fileMenuPtr, tr("Save &amp;As"), SLOT(onSaveAs()), 
                0, QString(), nullptr, QString(), 
                LISTENER(isSaveEnabled)); </pre>
<p>The <kbd>addSeparator</kbd> method adds a horizontal line between two items:</p>
<pre>      fileMenuPtr-&gt;addSeparator(); 
      addAction(fileMenuPtr, tr("E&amp;xit"), 
                SLOT(onExit()), QKeySequence::Quit); 
    } </pre>
<p>The <kbd>addEditMenu</kbd> method adds the <kbd>Edit</kbd> menu to the window's menu bar in the same way as the preceding <kbd>File</kbd> menu:</p>
<pre>    void MainWindow::addEditMenu() { 
      QMenu* editMenuPtr = menuBar()-&gt;addMenu(tr("&amp;Edit")); 
      QToolBar* editToolBarPtr = addToolBar(tr("Edit")); 
      connect(editMenuPtr, SIGNAL(aboutToShow()), 
              this, SLOT(onMenuShow())); 
 
      addAction(editMenuPtr, tr("&amp;Cut"), SLOT(onCut()), 
                QKeySequence::Cut, tr("cut"), editToolBarPtr, 
          tr("Cut the current selection's contents to the clipboard"), 
                LISTENER(isCutEnabled)); 
 
      addAction(editMenuPtr, tr("&amp;Copy"), SLOT(onCopy()), 
                QKeySequence::Copy, tr("copy"), editToolBarPtr, 
         tr("Copy the current selection's contents to the clipboard"), 
                LISTENER(isCopyEnabled)); 
 
      addAction(editMenuPtr, tr("&amp;Paste"), SLOT(onPaste()), 
                QKeySequence::Paste, tr("paste"), editToolBarPtr, 
        tr("Paste the current selection's contents to the clipboard"), 
                LISTENER(isPasteEnabled)); 
 
      editMenuPtr-&gt;addSeparator(); 
      addAction(editMenuPtr, tr("&amp;Delete"), SLOT(onDelete()), 
                QKeySequence::Delete, tr("delete"), editToolBarPtr, 
                tr("Delete the current selection"), 
                LISTENER(isDeleteEnabled)); 
    } </pre>
<p>The <kbd>addAction</kbd> method adds a menu item to the menu bar and a toolbar icon to the toolbar. It also connects the item with the <kbd>onSelectPtr</kbd> method that is called when the user selects the item, and methods that enable the item and annotate it with a checkbox or radio button. An accelerator is added to the action, unless it is zero. The <kbd>groupPtr</kbd> parameter defines whether the item is part of a group. If <kbd>checkListener</kbd> is not <kbd>nullptr</kbd>, the item is annotated with a checkbox if <kbd>groupPtr</kbd> is <kbd>nullptr</kbd>, and with a radio button if it is not. In the case of radio buttons, only one radio button in the group will be marked at the same time:</p>
<pre>    void MainWindow::addAction(QMenu* menuPtr, QString itemText, 
                               const char* onSelectPtr, 
                               QKeySequence acceleratorKey /* = 0 */, 
                               QString iconName /*= QString()*/, 
                               QToolBar* toolBarPtr /*= nullptr*/, 
                               QString statusTip /*= QString()*/, 
                               Listener enableListener /*= nullptr*/, 
                               Listener checkListener /*= nullptr*/, 
                               QActionGroup* groupPtr /*= nullptr*/) { 
      QAction* actionPtr; </pre>
<p>If <kbd>iconName</kbd> is not empty, we load the icon from the file in the project resource and then create a new <kbd>QAction</kbd> object with the icon:</p>
<pre>      if (!iconName.isEmpty()) { 
        const QIcon icon = QIcon::fromTheme("document-" + iconName, 
                           QIcon(":/images/" + iconName + ".png")); 
        actionPtr = new QAction(icon, itemText, this); 
      } </pre>
<p>If <kbd>iconName</kbd> is empty, we create a new <kbd>QAction</kbd> object without the icon:</p>
<pre>      else { 
        actionPtr = new QAction(itemText, this); 
      }</pre>
<p>We connect the menu item to the selection method. When the user selects the item, or clicks on the toolbar icon, <kbd>onSelectPtr</kbd> is called:</p>
<pre>      connect(actionPtr, SIGNAL(triggered()), 
              centralWidget(), onSelectPtr); </pre>
<p>If the accelerator key is not zero, we add it to the action pointer:</p>
<pre>      if (acceleratorKey != 0) { 
        actionPtr-&gt;setShortcut(acceleratorKey); 
      } </pre>
<p>Finally, we add the action pointer to the menu pointer in order for it to process the user's item selection:</p>
<pre>      menuPtr-&gt;addAction(actionPtr); </pre>
<p>If <kbd>toolBarPtr</kbd> is not <kbd>nullptr</kbd>, we add the action to the toolbar of the window:</p>
<pre>      if (toolBarPtr != nullptr) { 
        toolBarPtr-&gt;addAction(actionPtr); 
      } </pre>
<p>If the status tip is not empty, we add it to the tooltip and status tip of the toolbar:</p>
<pre>      if (!statusTip.isEmpty()) { 
          actionPtr-&gt;setToolTip(statusTip); 
          actionPtr-&gt;setStatusTip(statusTip); 
      } </pre>
<p>If the enable listener is not null, we add to <kbd>m_enableMap</kbd> a pair made up of a pointer to the central widget of the window and the listener. We also call the listener to initialize the enable status of the menu item and toolbar icon:</p>
<pre>      if (enableListener != nullptr) { 
        QWidget* widgetPtr = centralWidget(); 
        m_enableMap[actionPtr] = 
          QPair&lt;QObject*,Listener&gt;(widgetPtr, enableListener); 
        actionPtr-&gt;setEnabled(enableListener(widgetPtr)); 
      } </pre>
<p>In the same way, if the check listener is not null, we add a pointer to the central widget of the window and the listener to <kbd>m_checkMap</kbd>. Both <kbd>m_enableMap</kbd> and <kbd>m_checkMap</kbd> are used by <kbd>onMenuShow</kbd>, as follows. We also call the listener to initialize the check status of the menu item (toolbar icons are not checked):</p>
<pre>      if (checkListener != nullptr) { 
        actionPtr-&gt;setCheckable(true); 
        QWidget* widgetPtr = centralWidget(); 
        m_checkMap[actionPtr] = 
          QPair&lt;QObject*,Listener&gt;(widgetPtr, checkListener); 
        actionPtr-&gt;setChecked(checkListener(widgetPtr)); 
      } </pre>
<p>Finally, if the group pointer is not null, we add the action to it. In that way, the menu item will be annotated by a radio button rather than a checkbox. The framework does also keep track of the groups and makes sure only one of the radio buttons of each group is marked at the same time:</p>
<pre>      if (groupPtr != nullptr) { 
        groupPtr-&gt;addAction(actionPtr); 
      } 
    } </pre>
<p>The <kbd>onMenuShow</kbd> method is called before a menu or toolbar icon becomes visible. It makes sure each item is enabled or disabled, and that the items are annotated with checkboxes or radio buttons.</p>
<p>We start by iterating through the enable map. For each entry in the map, we look up the widget and the enable function. We call the function, which returns <kbd>true</kbd> or <kbd>false</kbd>, and use the result to enable or disable the item by calling <kbd>setEnabled</kbd> on the action object pointer:</p>
<pre>    void MainWindow::onMenuShow() { 
      for (QMap&lt;QAction*,QPair&lt;QObject*,Listener&gt;&gt;::iterator i = 
           m_enableMap.begin(); i != m_enableMap.end(); ++i) { 
        QAction* actionPtr = i.key(); 
        QPair&lt;QObject*,Listener&gt; pair = i.value(); 
        QObject* baseObjectPtr = pair.first; 
        Listener enableFunction = pair.second; 
        actionPtr-&gt;setEnabled(enableFunction(baseObjectPtr)); 
      } </pre>
<p>In the same way, we iterate through the check map. For each entry in the map, we look up the widget and the check function. We call the function and use the result to check the item by calling <kbd>setCheckable</kbd> and <kbd>setChecked</kbd> on the action object pointer. The Qt Framework makes sure the item is annotated by radio buttons if it belongs to a group, and a checkbox if it does not:</p>
<pre>      for (QMap&lt;QAction*,QPair&lt;QObject*,Listener&gt;&gt;::iterator i = 
           m_checkMap.begin(); i != m_checkMap.end(); ++i) { 
        QAction* actionPtr = i.key(); 
        QPair&lt;QObject*,Listener&gt; pair = i.value(); 
        QObject* baseObjectPtr = pair.first; 
        Listener checkFunction = pair.second; 
        actionPtr-&gt;setCheckable(true); 
        actionPtr-&gt;setChecked(checkFunction(baseObjectPtr)); 
      } 
    } </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The base widget class</h1>
                </header>
            
            <article>
                
<p><kbd>DocumentWidget</kbd> is a skeleton framework for applications that handle documents. It handles the loading and saving of the document, and provides methods to be overridden by subclasses for the <kbd>Cut</kbd>, <kbd>Copy</kbd>, <kbd>Paste</kbd>, and <kbd>Delete</kbd> menu items.</p>
<p>While the preceding <kbd>MainWindow</kbd> class handles the window frame, with its menus and toolbars, the <kbd>DocumentWidget</kbd> class handles the drawing of the window's content. The idea is that the subclass of <kbd>MainWindow</kbd> creates an object of a subclass to <kbd>DocumentWidget</kbd> that it puts at the centrum of the window. See the constructors of <kbd>DrawingWindow</kbd> and <kbd>EditorWindow</kbd> in the following sections.</p>
<p><strong>DocumentWidget.h:</strong></p>
<pre>    #ifndef DOCUMENTWIDGET_H 
    #define DOCUMENTWIDGET_H 
 
    #include "Listener.h" 
    #include &lt;QWidget&gt; 
    #include &lt;QtWidgets&gt; 
    #include &lt;FStream&gt; 
    using namespace std; 
 
    class DocumentWidget : public QWidget { 
      Q_OBJECT </pre>
<p>The constructor takes the name of the application, to be displayed at the top banner of the window, the filename mask to be used when loading and storing documents with the standard file dialogs, and a pointer to a potential parent widget (normally the enclosing main window):</p>
<pre>      public: 
        DocumentWidget(const QString&amp; name, const QString&amp; fileMask, 
                       QWidget* parentWidgetPtr); 
        ~DocumentWidget();</pre>
<p>The <kbd>setFilePath</kbd> method sets the path of the current document. The path is displayed at the top banner of the window and is given as a default path in the standard load and save dialogs:</p>
<pre>      protected: 
        void setFilePath(QString filePath); </pre>
<p>When a document has been changed, the modified flag (sometimes called the dirty flag) is set. This causes an asterisk (<kbd>*</kbd>) to appear next to the file path at the top banner of the window, and the <kbd>Save</kbd> and <kbd>SaveAs</kbd> menu items to be enabled:</p>
<pre>      public: 
        void setModifiedFlag(bool flag); </pre>
<p>The <kbd>setMainWindowTitle</kbd> method is an auxiliary method that puts together the title of the window. It is made up by the file path and a potential asterisk (<kbd>*</kbd>) to indicate whether the modified flag is set:</p>
<pre>      private: 
        void setMainWindowTitle(); </pre>
<p>The <kbd>closeEvent</kbd> method is overridden from <kbd>QWidget</kbd> and is called when the user closes the window. By setting fields of the <kbd>eventPtr</kbd> parameter, the closing can be prevented. For example, if the document has not been saved, the user can be asked if they want to save the document or cancel the closing of the window:</p>
<pre>      public: 
        virtual void closeEvent(QCloseEvent* eventPtr); </pre>
<p>The <kbd>isClearOk</kbd> method is an auxiliary method that displays a message box if the user tries to close the window or exit the application without saving the document:</p>
<pre>      private: 
        bool isClearOk(QString title); </pre>
<p>The following methods are called by the framework when the user selects a menu item or clicks a toolbar icon. In order for that to work, we mark the methods as <span class="Keyword">slots</span>, which is necessary for the <kbd>SLOT</kbd> macro in the <kbd>connect</kbd> call:</p>
<pre>      public slots: 
        virtual void onNew(); 
        virtual void onOpen(); 
        virtual bool onSave(); 
        virtual bool onSaveAs(); 
        virtual void onExit();</pre>
<p>When a document has not been changed, it is not necessary to save it. In that case, the <kbd>Save</kbd> and <kbd>SaveAs</kbd> menu items and toolbars images shall be disabled. The <kbd>isSaveEnabled</kbd> method is called by <kbd>onMenuShow</kbd> before the <kbd>File</kbd> menu becomes visible. It returns true only when the document has been changed and needs to be saved:</p>
<pre>    virtual bool isSaveEnabled(); </pre>
<p>The <kbd>tryWriteFile</kbd> method is an auxiliary method that tries to write the file. If it fails, a message box displays an error message:</p>
<pre>    private: 
        bool tryWriteFile(QString filePath); </pre>
<p>The following methods are virtual methods intended to be overridden by subclasses. They are called when the user selects the <kbd>New</kbd>, <kbd>Save</kbd>, <kbd>SaveAs</kbd>, and <kbd>Open</kbd> menu items:</p>
<pre>      protected: 
        virtual void newDocument() = 0; 
        virtual bool writeFile(const QString&amp; filePath) = 0; 
        virtual bool readFile(const QString&amp; filePath) = 0; </pre>
<p>The following methods are called before the edit menu becomes visible, and they decide whether the <kbd>Cut</kbd>, <kbd>Copy</kbd>, <kbd>Paste</kbd>, and <kbd>Delete</kbd> items shall be enabled:</p>
<pre>      public: 
        virtual bool isCutEnabled(); 
        virtual bool isCopyEnabled(); 
        virtual bool isPasteEnabled(); 
        virtual bool isDeleteEnabled(); </pre>
<p>The following methods are called when the user selects the <kbd>Cut</kbd>, <kbd>Copy</kbd>, <kbd>Paste</kbd>, and <kbd>Delete</kbd> items or toolbar icons:</p>
<pre>      public slots: 
        virtual void onCut(); 
        virtual void onCopy(); 
        virtual void onPaste(); 
        virtual void onDelete(); </pre>
<p>The <kbd>m_applicationName</kbd> field holds the name of the application, not the document. In the next sections, the names will be <em>Drawing</em> and <em>Editor</em>. The <kbd>m_fileMask</kbd> field holds the mask that is used when loading and saving the document with the standard dialogs. For instance, let us say that we have documents with the ending <kbd>.abc</kbd>. Then the mask could be <kbd>Abc files (.abc)</kbd>. The <kbd>m_filePath</kbd> field holds the path of the current document. When the document is new and not yet saved, the field holds the empty string.</p>
<p>Finally, <kbd>m_modifiedFlag</kbd> is true when the document has been modified and needs to be saved before the application quits:</p>
<pre>      private: 
        QString m_applicationName, m_fileMask, m_filePath; 
        bool m_modifiedFlag = false; 
    }; </pre>
<p>Finally, there are some overloaded auxiliary operators. The addition and subtraction operators add and subtract a point with a size, and a rectangle with a size:</p>
<pre>    QPoint&amp; operator+=(QPoint&amp; point, const QSize&amp; size); 
    QPoint&amp; operator-=(QPoint&amp; point, const QSize&amp; size); 
 
    QRect&amp; operator+=(QRect&amp; rect, int size); 
    QRect&amp; operator-=(QRect&amp; rect, int size); </pre>
<p>The <kbd>writePoint</kbd> and <kbd>readPoint</kbd> methods write and read a point from an input stream:</p>
<pre>    void writePoint(ofstream&amp; outStream, const QPoint&amp; point); 
    void readPoint(ifstream&amp; inStream, QPoint&amp; point); </pre>
<p>The <kbd>writeColor</kbd> and <kbd>readColor</kbd> methods write and read a color from an input stream:</p>
<pre>    void writeColor(ofstream&amp; outStream, const QColor&amp; color); 
    void readColor(ifstream&amp; inStream, QColor&amp; color); </pre>
<p>The <kbd>makeRect</kbd> method creates a rectangle with <kbd>point</kbd> as its center and <kbd>size</kbd> as its size:</p>
<pre>    QRect makeRect(const QPoint&amp; centerPoint, int halfSide); 
    #endif // DOCUMENTWIDGET_H </pre>
<p><strong>DocumentWidget.cpp:</strong></p>
<pre>    #include &lt;QtWidgets&gt; 
    #include &lt;QMessageBox&gt; 
 
    #include "MainWindow.h" 
    #include "DocumentWidget.h" </pre>
<p>The constructor sets the name of the application, the file mask for the save and load standard dialogs, and a pointer to the enclosing parent widget (usually the enclosing main window):</p>
<pre>    DocumentWidget::DocumentWidget(const QString&amp; name, 
                    const QString&amp; fileMask, QWidget* parentWidgetPtr) 
     :m_applicationName(name), 
      m_fileMask(fileMask), 
      QWidget(parentWidgetPtr) { 
        setMainWindowTitle(); 
      } </pre>
<p>The destructor does nothing, it is included for completeness only:</p>
<pre>    DocumentWidget::~DocumentWidget() { 
      // Empty. 
    } </pre>
<p>The <kbd>setFilePath</kbd> method calls <kbd>setMainWindowTitle</kbd> to update the text on the top banner of the window:</p>
<pre>    void DocumentWidget::setFilePath(QString filePath) { 
      m_filePath = filePath; 
      setMainWindowTitle(); 
    } </pre>
<p>The <kbd>setModifiedFlag</kbd> method also calls <kbd>setMainWindowTitle</kbd> to update the text on the top banner of the window. Moreover, it calls <kbd>onMenuShow</kbd> on the parent widget to update the icons of the toolbars:</p>
<pre>    void DocumentWidget::setModifiedFlag(bool modifiedFlag) { 
      m_modifiedFlag = modifiedFlag; 
      setMainWindowTitle(); 
      ((MainWindow*) parentWidget())-&gt;onMenuShow(); 
    } </pre>
<p>The title displayed at the top banner of the toolbar is the application name, the document file path (if not empty), and an asterisk if the document has been modified without being saved:</p>
<pre>    void DocumentWidget::setMainWindowTitle() { 
      QString title= m_applicationName + 
              (m_filePath.isEmpty() ? "" : (" [" + m_filePath + "]"))+ 
              (m_modifiedFlag ? " *" : ""); 
      this-&gt;parentWidget()-&gt;setWindowTitle(title); 
    } </pre>
<p>The <kbd>isClearOk</kbd> method displays a message box if the document has been modified without being saved. The user can select one of the following buttons:</p>
<ul>
<li><span class="packt_screen">Yes</span>: The document is saved, and the application quits. However, if the saving fails, an error message is displayed and the application does not quit.</li>
<li><span class="packt_screen">No</span>: The application quits without saving the document.</li>
<li><span class="packt_screen">Cancel</span>: The closing of the application is cancelled. The document is not saved.</li>
</ul>
<pre>    bool DocumentWidget::isClearOk(QString title) { 
      if (m_modifiedFlag) { 
        QMessageBox messageBox(QMessageBox::Warning, 
                               title, QString()); 
        messageBox.setText(tr("The document has been modified.")); 
        messageBox.setInformativeText( 
                   tr("Do you want to save your changes?")); 
        messageBox.setStandardButtons(QMessageBox::Yes | 
                              QMessageBox::No | QMessageBox::Cancel); 
        messageBox.setDefaultButton(QMessageBox::Yes); 
 
        switch (messageBox.exec()) { 
          case QMessageBox::Yes: 
            return onSave(); 
 
          case QMessageBox::No: 
            return true; 
 
          case QMessageBox::Cancel: 
            return false; 
        } 
      } 
 
      return true; 
    } </pre>
<p>If the document is cleared, <kbd>newDocument</kbd> is called, which is intended to be overridden by a subclass to perform application-specific initialization. Moreover, the modified flag and the file path are cleared. Finally, the Qt <kbd>update</kbd> method is called to force a repainting of the window's content:</p>
<pre>    void DocumentWidget::onNew() { 
      if (isClearOk(tr("New File"))) { 
        newDocument(); 
        setModifiedFlag(false); 
        setFilePath(QString()); 
        update(); 
      } 
    } </pre>
<p>If the document is cleared, <kbd>onOpen</kbd> uses the standard open dialog to obtain the file path of the document:</p>
<pre>    void DocumentWidget::onOpen() { 
      if (isClearOk(tr("Open File"))) { 
        QString file = 
          QFileDialog::getOpenFileName(this, tr("Open File"), 
                       tr("C:\Users\Stefan\Documents\" 
                          "A A_Cpp_By_Example\Draw"), 
                  m_fileMask + tr(";;Text files (*.txt)")); </pre>
<p>If the file was successfully read, the modified flag is cleared, the file path is set, and <kbd>update</kbd> is called to force a repainting of the window:</p>
<pre>        if (!file.isEmpty()) { 
          if (readFile(file)) { 
            setModifiedFlag(false); 
            setFilePath(file); 
            update(); 
          } </pre>
<p>However, if the reading was not successful, a message box with an error message is displayed:</p>
<pre>          else { 
            QMessageBox messageBox; 
            messageBox.setIcon(QMessageBox::Critical); 
            messageBox.setText(tr("Read File")); 
            messageBox.setInformativeText(tr("Could not read "") + 
                                          m_filePath  + tr(""")); 
            messageBox.setStandardButtons(QMessageBox::Ok); 
            messageBox.setDefaultButton(QMessageBox::Ok); 
            messageBox.exec(); 
          } 
        } 
      } 
    } </pre>
<p>The <kbd>ifSaveEnabled</kbd> method simply returns the value of <kbd>m_modifiedFlag</kbd>. However, we need the method for the listener to work:</p>
<pre>    bool DocumentWidget::isSaveEnabled() { 
      return m_modifiedFlag; 
    } </pre>
<p>The <kbd>onSave</kbd> method is called when the user selects the <kbd>Save</kbd> or <kbd>SaveAs</kbd> menu item or toolbar icon. If the document has already been given a name, we simply try to write the file. However, if it has not yet been given a name we call <kbd>OnSaveAs</kbd>, which displays the standard Save dialog for the user:</p>
<pre>    bool DocumentWidget::onSave() { 
      if (!m_filePath.isEmpty()) { 
        return tryWriteFile(m_filePath); 
      } 
      else { 
        return onSaveAs(); 
      } 
    } </pre>
<p>The <kbd>onSaveAs</kbd> method is called when the user selects the <kbd>SaveAs</kbd> menu item (there is no toolbar icon for this item). It opens the standard open dialog and tries to write the file. If the writing was not successful, <kbd>false</kbd> is returned. The reason for this is that <kbd>isClearOk</kbd> closes the window only if the writing was successful:</p>
<pre>    bool DocumentWidget::onSaveAs() { 
      QString filePath = 
              QFileDialog::getSaveFileName(this, tr("Save File"), 
                   tr("C:\Users\Stefan\Documents\" 
                      "A A_Cpp_By_Example\Draw"), 
                m_fileMask + tr(";;Text files (*.txt)")); 
 
      if (!filePath.isEmpty()) { 
        return tryWriteFile(filePath); 
      } 
      else { 
        return false; 
      } 
    } </pre>
<p>The <kbd>tryWriteFile</kbd> method tries to write the file by calling write, which is intended to be overridden by a subclass. If it succeeded, the modified flag and the file path are set. If the file was not successfully written, a message box with an error message is displayed:</p>
<pre>    bool DocumentWidget::tryWriteFile(QString filePath) { 
      if (writeFile(filePath)) { 
        setModifiedFlag(false); 
        setFilePath(filePath); 
        return true; 
      } 
      else { 
        QMessageBox messageBox; 
        messageBox.setIcon(QMessageBox::Critical); 
        messageBox.setText(tr("Write File")); 
        messageBox.setInformativeText(tr("Could not write "") + 
                                      filePath  + tr(""")); 
        messageBox.setStandardButtons(QMessageBox::Ok); 
        messageBox.setDefaultButton(QMessageBox::Ok); 
        messageBox.exec(); 
        return false; 
      } 
    } </pre>
<p>The <kbd>onExit</kbd> method is called when the user selects the <kbd>Exit</kbd> menu item. It checks whether it is clear to close the window, and exits the application if it is:</p>
<pre>    void DocumentWidget::onExit() { 
      if (isClearOk(tr("Exit"))) { 
        qApp-&gt;exit(0); 
      } 
    } </pre>
<p>The default behavior of <kbd>isCutEnabled</kbd> and <kbd>isDeleteEnabled</kbd> is to call <kbd>isCopyEnabled</kbd>, since they often are enabled on the same conditions:</p>
<pre>    bool DocumentWidget::isCutEnabled() { 
      return isCopyEnabled(); 
    } 
 
    bool DocumentWidget::isDeleteEnabled() { 
      return isCopyEnabled(); 
    } </pre>
<p>The default behavior of <kbd>onCut</kbd> is to simply call <kbd>onCopy</kbd> and <kbd>onDelete</kbd>:</p>
<pre>    void DocumentWidget::onCut() { 
      onCopy(); 
      onDelete(); 
    } </pre>
<p>The default behavior of the rest of the cut-and-copy methods is to return <kbd>false</kbd> and do nothing, which will leave the menu items disabled unless the subclass overrides the methods:</p>
<pre>    bool DocumentWidget::isCopyEnabled() { 
      return false; 
    } 
 
    void DocumentWidget::onCopy() { 
      // Empty. 
    } 
 
    bool DocumentWidget::isPasteEnabled() { 
      return false; 
    } 
 
    void DocumentWidget::onPaste() { 
      // Empty. 
    } 
     
    void DocumentWidget::onDelete() { 
      // Empty. 
} </pre>
<p>Finally, <kbd>closeEvent</kbd> is called when the user tries to close the window. If the window is ready to be cleared, <kbd>accept</kbd> is called on <kbd>eventPtr</kbd>, which causes the window to be closed, and <kbd>exit</kbd> is called on the global <kbd>qApp</kbd> object, which causes the application to quit:</p>
<pre>    void DocumentWidget::closeEvent(QCloseEvent* eventPtr) { 
      if (isClearOk(tr("Close Window"))) { 
        eventPtr-&gt;accept(); 
        qApp-&gt;exit(0); 
      } </pre>
<p>However, if the window is not ready to be cleared, <kbd>ignore</kbd> is called on <kbd>eventPtr</kbd>, which causes the window to remain open (and the application to continue):</p>
<pre>      else { 
        eventPtr-&gt;ignore(); 
      } 
    } </pre>
<p>Moreover, there are also the set of auxiliary functions for handling points, sizes, rectangles, and color. The following operators add and subtract a point with a size, and return the resulting point:</p>
<pre>    QPoint&amp; operator+=(QPoint&amp; point, const QSize&amp; size) { 
      point.setX(point.x() + size.width()); 
      point.setY(point.y() + size.height()); 
      return point; 
    } 
 
    QPoint&amp; operator-=(QPoint&amp; point, const QSize&amp; size) { 
      point.setX(point.x() - size.width()); 
      point.setY(point.y() - size.height()); 
      return point; 
    } </pre>
<p>The following operators add and subtract an integer from a rectangle, and return the resulting rectangle. The addition operator expands the size of the rectangle in every direction, while the subtraction operator shrinks the rectangle in every direction:</p>
<pre>    QRect&amp; operator+=(QRect&amp; rect, int size) { 
      rect.setLeft(rect.left() - size); 
      rect.setTop(rect.top() - size); 
      rect.setWidth(rect.width() + size); 
      rect.setHeight(rect.height() + size); 
      return rect; 
    } 
 
    QRect&amp; operator-=(QRect&amp; rect, int size) { 
      rect.setLeft(rect.left() + size); 
      rect.setTop(rect.top() + size); 
      rect.setWidth(rect.width() - size); 
      rect.setHeight(rect.height() - size); 
      return rect; 
    } </pre>
<p>The <kbd>writePoint</kbd> and <kbd>readPoint</kbd> functions write and read a point from a file. They write and read the <em>x</em> and <em>y</em> coordinates separately:</p>
<pre>    void writePoint(ofstream&amp; outStream, const QPoint&amp; point) { 
      int x = point.x(), y = point.y(); 
      outStream.write((char*) &amp;x, sizeof x); 
      outStream.write((char*) &amp;y, sizeof y); 
    } 
 
    void readPoint(ifstream&amp; inStream, QPoint&amp; point) { 
      int x, y; 
      inStream.read((char*) &amp;x, sizeof x); 
      inStream.read((char*) &amp;y, sizeof y); 
      point = QPoint(x, y); 
    } </pre>
<p>The <kbd>writeColor</kbd> and <kbd>readColor</kbd> functions write and read a color from a file. A color is made up of the <kbd>red</kbd>, <kbd>green</kbd>, and <kbd>blue</kbd> components. Each component is an integer value between <kbd>0</kbd> and <kbd>255</kbd> inclusive. The methods write and read the components from a file stream:</p>
<pre>    void writeColor(ofstream&amp; outStream, const QColor&amp; color) { 
      int red = color.red(), green = color.green(), 
      blue = color.blue(); 
      outStream.write((char*) &amp;red, sizeof red); 
      outStream.write((char*) &amp;green, sizeof green); 
      outStream.write((char*) &amp;blue, sizeof blue); 
    } 
 
    void readColor(ifstream&amp; inStream, QColor&amp; color) { 
      int red, green, blue; 
      inStream.read((char*) &amp;red, sizeof red); 
      inStream.read((char*) &amp;green, sizeof green); 
      inStream.read((char*) &amp;blue, sizeof blue);</pre>
<p>When the components have been read, we create a <kbd>QColor</kbd> object that we assign the <kbd>color</kbd> parameter:</p>
<pre>      color = QColor(red, green, blue); 
    } </pre>
<p>The <kbd>makeRect</kbd> function creates a rectangle centered around the point:</p>
<pre>    QRect makeRect(const QPoint&amp; centerPoint, int halfSide) { 
      return QRect(centerPoint.x() - halfSide, 
                   centerPoint.y() - halfSide, 
                   2 * halfSide, 2 * halfSide); 
    } </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building the drawing program</h1>
                </header>
            
            <article>
                
<p>Let's now start a new project, where we take advantage of the main window and document widget classes of the previous section—<em>The drawing program</em>. We will start with a basic version in this chapter, and we will continue to build a more advanced version in the next chapter. With the drawing program of this chapter we can draw lines, rectangles, and ellipses in different colors. We can also save and load our drawings. Note that in this project the window and widget classes inherit from the <kbd>MainWindow</kbd> and <kbd>DocumentWidget</kbd> classes of the previous section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Figure base class</h1>
                </header>
            
            <article>
                
<p>The figures of the application constitute a class hierarchy where the <kbd>Figure</kbd> is the base class. Its subclasses are <kbd>Line</kbd>, <kbd>RectangleX</kbd>, and <kbd>EllipseX</kbd>, which are described later on. We cannot use the names <em>Rectangle</em> and <em>Ellipse</em> for our classes, since that would clash with Qt methods with the same names. I have chosen to simply add an '<kbd>X</kbd>' to the names.</p>
<p>The <kbd>Figure</kbd> class is <span class="Keyword">abstract</span>, which means that we cannot create an object of the class. We can only use it as a base class, which sub classes inherit.</p>
<p><strong>Figure.h:</strong></p>
<pre>    #ifndef FIGURE_H 
    #define FIGURE_H 
 
    enum FigureId {LineId, RectangleId, EllipseId}; 
 
    #include &lt;QtWidgets&gt; 
    #include &lt;FStream&gt; 
    using namespace std; 
 
    class Figure { 
      public: 
        Figure(); </pre>
<p>The following methods are <span class="Keyword">pure </span><span class="Keyword">virtual</span>, which means that they do not need to be defined. A class with at least one pure virtual method becomes abstract. The sub classes must define all the pure virtual methods of all its base classes, or become abstract themselves. In this way, it is guaranteed that all methods of all non-abstract classes are defined.</p>
<p>Each sub class defines <kbd>getId</kbd> and returns the identity enumeration of its class:</p>
<pre>    virtual FigureId getId() const = 0; </pre>
<p>Each figure has a first and last point, and it is up to each sub class to define them:</p>
<pre>    virtual void initializePoints(QPoint point) = 0; 
    virtual void setLastPoint(QPoint point) = 0; </pre>
<p>The <kbd>isClick</kbd> method returns <kbd>true</kbd> if the figure is hit by the point:</p>
<pre>    virtual bool isClick(QPoint mousePoint) = 0; </pre>
<p>The <kbd>move</kbd> method moves the figures a certain distance:</p>
<pre>    virtual void move(QSize distance) = 0; </pre>
<p>The <kbd>draw</kbd> method draws the figure on the painter area:</p>
<pre>    virtual void draw(QPainter &amp;painter) const = 0; </pre>
<p>The <kbd>write</kbd> and <kbd>read</kbd> methods write and read the figure from a file; <kbd>write</kbd> is constant since it does not change the figure:</p>
<pre>    virtual bool write(ofstream&amp; outStream) const; 
    virtual bool read(ifstream&amp; inStream); </pre>
<p>The <kbd>color</kbd> method returns the color of the figure. It comes in two versions, where the first version is constant and returns a reference to a constant <kbd>QColor</kbd> object, while the second version is non-constant and returns a reference to a non-constant object:</p>
<pre>    const QColor&amp; color() const {return m_color;} 
    QColor&amp; color() {return m_color;}</pre>
<p>The <kbd>filled</kbd> methods apply to two-dimensional figures (rectangles and ellipses) only. They return <kbd>true</kbd> if the figure is filled. Note that the second version returns a reference to the <kbd>m_filled</kbd> field, which allows the caller of the method to modify the value of <kbd>m_filled</kbd>:</p>
<pre>    virtual bool filled() const {return m_filled;} 
    virtual bool&amp; filled() {return m_filled;} </pre>
<p>When a figure is marked, it is drawn with small squares at its corners. The side of the squares are defined by the static field <kbd>Tolerance</kbd>:</p>
<pre>    static const int Tolerance; </pre>
<p>The <kbd>writeColor</kbd> and <kbd>readColor</kbd> methods are auxiliary methods that read and write a color. They are static since they are called by methods outside the <kbd>Figure</kbd> class hierarchy:</p>
<pre>        static void writeColor(ofstream&amp; outStream, 
 
                               const QColor&amp; color); 
        static void readColor(ifstream&amp; inStream, QColor&amp; color); </pre>
<p>Each figure has a color, and it could be marked or filled:</p>
<pre>      private: 
        QColor m_color; 
        bool m_marked = false, m_filled = false; 
    }; 
 
    #endif </pre>
<p>The <kbd>Figure.cpp</kbd> <span>file </span>holds the definitions of the <kbd>Figure</kbd> class. It defines the <kbd>Tolerance</kbd> field as well as the <kbd>write</kbd> and <kbd>read</kbd> methods.</p>
<p><strong>Figure.cpp:</strong><a><br/></a></p>
<pre>    #include "..\MainWindow\DocumentWidget.h" 
    #include "Figure.h" </pre>
<p><kbd>Tolerance</kbd> must be defined and initialized in global space since it is static. We define the size of the mark squares to be <kbd>6</kbd> pixels:</p>
<pre>    const int Figure::Tolerance(6); </pre>
<p>The default constructor is called only when figures are read from a file:</p>
<pre>    Figure::Figure() { 
      // Empty. 
    }</pre>
<p>The <kbd>write</kbd> and <kbd>read</kbd> methods write and read the color of the figure, and whether the figure is filled:</p>
<pre>    bool Figure::write(ofstream&amp; outStream) const { 
      writeColor(outStream, m_color); 
      outStream.write((char*) &amp;m_filled, sizeof m_filled); 
      return ((bool) outStream); 
    } 
 
    bool Figure::read(ifstream&amp; inStream) { 
      readColor(inStream, m_color); 
      inStream.read((char*) &amp;m_filled, sizeof m_filled); 
      return ((bool) inStream); 
    } </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Line sub class</h1>
                </header>
            
            <article>
                
<p>The <kbd>Line</kbd> class is a sub class of <kbd>Figure</kbd>. It becomes non-abstract by defining each pure virtual method of <kbd>Figure</kbd>. A line is drawn between two end-points, represented by the <kbd>m_firstPoint</kbd> to <kbd>m_lastPoint</kbd> fields in <kbd>Line</kbd>:</p>
<div class="packt_figure CDPAlignCenter"><img height="126" src="assets/4723c801-7788-48b8-8399-9bc2e7f4d2b2.png" width="455"/></div>
<p><strong>Line.h:</strong></p>
<pre>    #ifndef LINE_H 
    #define LINE_H 
 
    #include &lt;FStream&gt; 
    using namespace std; 
 
    #include "Figure.h" 
 
    class Line : public Figure { 
      public:</pre>
<p>The default constructor is called only when reading <kbd>Line</kbd> objects from a file; <kbd>getId</kbd> simply returns the identity enumeration of the line:</p>
<pre>    Line(); 
    FigureId getId() const {return LineId;} </pre>
<p>A line has two endpoints. Both points are set when the line is created, the second point is then modified when the user moves it:</p>
<pre>    void initializePoints(QPoint point); 
    void setLastPoint(QPoint point); </pre>
<p>The <kbd>isClick</kbd> method returns <kbd>true</kbd> if the mouse click is located on the line (with some tolerance):</p>
<pre>    bool isClick(QPoint mousePoint); </pre>
<p>The <kbd>move</kbd> method moves the line (both its end-points) the given distance:</p>
<pre>    void move(QSize distance); </pre>
<p>The <kbd>draw</kbd> method draws the line on the <kbd>QPainter</kbd> object:</p>
<pre>    void draw(QPainter&amp; painter) const; </pre>
<p>The <kbd>write</kbd> and <kbd>read</kbd> methods write and read the end-points of the line from a file stream:</p>
<pre>    bool write(ofstream&amp; outStream) const; 
    bool read(ifstream&amp; inStream); </pre>
<p>The first and last points of the line are stored in the <kbd>Line</kbd> object:</p>
<pre>    private: 
      QPoint m_firstPoint, m_lastPoint; 
    }; 
 
    #endif </pre>
<p>The <kbd>Line.cpp</kbd> file defines the methods of the <kbd>Line</kbd> class.</p>
<p><strong>Line.cpp:<a><br/></a></strong></p>
<pre>    #include "..\MainWindow\DocumentWidget.h" 
    #include "Line.h" 
 
    Line::Line() { 
      // Empty. 
    }</pre>
<p>The <kbd>initializePoints</kbd> method is called when the user adds a new line to the drawing. It sets both its end-points:</p>
<pre>    void Line::initializePoints(QPoint point) { 
      m_firstPoint = point; 
      m_lastPoint = point; 
    } </pre>
<p>The <kbd>setLastPoint</kbd> method is called when the user has added the line and modifies its shape. It sets the last point:</p>
<pre>    void Line::setLastPoint(QPoint point) { 
      m_lastPoint = point; 
    } </pre>
<p>The <kbd>isClick</kbd> method tests whether the user has clicked with the mouse on the line. We have two cases to consider. The first case is a special case that occurs when the line is completely vertical, when the <em>x</em>-coordinates of the end-points are equal. We use the Qt <kbd>QRect</kbd> class to create a rectangle surrounding the line, and test whether the point is enclosed in the rectangle:</p>
<div class="packt_figure CDPAlignCenter"><img height="222" src="assets/d9377e8e-8a2a-4fdf-8c0f-3e6f23276884.png" width="81"/></div>
<pre>    bool Line::isClick(QPoint mousePoint) { 
      if (m_firstPoint.x() == m_lastPoint.x()) { 
        QRect lineRect(m_firstPoint, m_lastPoint); 
        lineRect.normalized(); 
        lineRect += Tolerance; 
        return lineRect.contains(mousePoint); 
      }</pre>
<p>In a general case, where the line is not vertical, we start by creating an enclosing rectangle and test if the mouse point is in it. If it is, we set <kbd>leftPoint</kbd> to the leftmost point of <kbd>firstPoint</kbd> and <kbd>lastPoint</kbd>, and <kbd>rightPoint</kbd> to the rightmost point. We then calculate the width (<kbd>lineWidth</kbd>) and height (<kbd>lineHeight</kbd>) of the enclosing rectangle, as well as the distance between <kbd>rightPoint</kbd> and <kbd>mousePoint</kbd> in the <em>x</em> and <em>y</em> directions (<kbd>diffWidth</kbd> and <kbd>diffHeight</kbd>).</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="187" src="assets/f051abb6-3200-45a4-bd8e-1ce97c0443a2.png" width="359"/></div>
<p>Due to uniformity, the following equation is true if the mouse pointer hits the line:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="76" src="assets/94c97888-f928-420d-9f23-9f7308d283d9.png" width="230"/></div>
<p>However, in order for the left-hand expression to become exactly zero, the user has to click exactly on the line. Therefore, let us allow for a small tolerance. Let's use the <kbd>Tolerance</kbd> field:</p>
<div class="CDPAlignCenter"><img height="43" src="assets/fb006091-e45c-4af5-9ac4-13234e8b1bfe.png" width="300"/></div>
<pre>        else { 
          QPoint leftPoint = (m_firstPoint.x() &lt; m_lastPoint.x()) 
                             ? m_firstPoint : m_lastPoint, 
                 rightPoint = (m_firstPoint.x() &lt; m_lastPoint.x()) 
                              ? m_lastPoint : m_firstPoint; 
 
          if ((leftPoint.x() &lt;= mousePoint.x()) &amp;&amp; 
              (mousePoint.x() &lt;= rightPoint.x())) { 
            int lineWidth = rightPoint.x() - leftPoint.x(), 
                lineHeight = rightPoint.y() - leftPoint.y(); 
 
            int diffWidth = mousePoint.x() - leftPoint.x(), 
                diffHeight = mousePoint.y() - leftPoint.y(); </pre>
<p>We must convert <kbd>lineHeight</kbd> to a double in order to perform non-integer division:</p>
<pre>          return (fabs(diffHeight - (((double) lineHeight) / 
                       lineWidth) * diffWidth) &lt;= Tolerance); 
        } </pre>
<p>If the mouse point is located outside the rectangle enclosing the line, we simply return <kbd>false</kbd>:</p>
<pre>        return false; 
      } 
    } </pre>
<p>The <kbd>move</kbd> method simply moves both the endpoints of the line:</p>
<pre>    void Line::move(QSize distance) { 
      m_firstPoint += distance; 
      m_lastPoint += distance; 
    } </pre>
<p>When drawing the line, we set the pen color and draw the line. The <kbd>color</kbd> method of the <kbd>Figure</kbd> class returns the color of the line:</p>
<pre>    void Line::draw(QPainter&amp; painter) const { 
      painter.setPen(color()); 
      painter.drawLine(m_firstPoint, m_lastPoint); 
    } </pre>
<p>When writing the line, we first call <kbd>write</kbd> in <kbd>Figure</kbd> to write the color of the figure. We then write the endpoints of the line. Finally, we return the Boolean value of the output stream, which is <kbd>true</kbd> if the writing was successful:</p>
<pre>    bool Line::write(ofstream&amp; outStream) const { 
      Figure::write(outStream); 
      writePoint(outStream, m_firstPoint); 
      writePoint(outStream, m_lastPoint); 
      return ((bool) outStream); 
    }</pre>
<p>In the same way, when reading the line, we first call <kbd>read</kbd> in <kbd>Figure</kbd> to read the color of the line. We then read the endpoints of the line and return the Boolean value of the input stream:</p>
<pre>    bool Line::read(ifstream&amp; inStream) { 
      Figure::read(inStream); 
      readPoint(inStream, m_firstPoint); 
      readPoint(inStream, m_lastPoint); 
      return ((bool) inStream); 
    } </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Rectangle sub class</h1>
                </header>
            
            <article>
                
<p><kbd>RectangleX</kbd> is a sub class of <kbd>Figure</kbd> that handles a rectangle. Similar to <kbd>Line</kbd>, it holds two points, which holds opposite corners of the rectangle:</p>
<p><strong>Rectangle.h</strong><a><br/></a></p>
<pre>    #ifndef RECTANGLE_H 
    #define RECTANGLE_H 
 
    #include &lt;FStream&gt; 
    using namespace std; 
 
    #include "Figure.h" 
 
    class RectangleX : public Figure { 
      public: </pre>
<p>Similar to the preceding <kbd>Line</kbd> class, <kbd>RectangleX</kbd> has a default constructor that is used when reading the object from a file:</p>
<pre>        RectangleX(); 
        virtual FigureId getId() const {return RectangleId;} 
 
        RectangleX(const RectangleX&amp; rectangle); 
 
        virtual void initializePoints(QPoint point); 
        virtual void setLastPoint(QPoint point); 
 
        virtual bool isClick(QPoint mousePoint); 
        virtual void move(QSize distance); 
        virtual void draw(QPainter&amp; painter) const; 
     
        virtual bool write(ofstream&amp; outStream) const; 
        virtual bool read(ifstream&amp; inStream); 
 
      protected: 
        QPoint m_topLeft, m_bottomRight; 
    }; 
 
    #endif </pre>
<p><strong>Rectangle.cpp</strong><a><br/></a></p>
<pre>    #include "..\MainWindow\DocumentWidget.h" 
    #include "Rectangle.h" 
 
    RectangleX::RectangleX() { 
      // Empty. 
    } </pre>
<p>The <kbd>initializePoints</kbd> and <kbd>setLastPoint</kbd> methods work in a way similar to their counterparts in <kbd>Line</kbd>: <kbd>initializePoints</kbd> sets both the corner points, while <kbd>setLastPoint</kbd> sets the last corner point:</p>
<pre>    void RectangleX::initializePoints(QPoint point) { 
      m_topLeft = point; 
      m_bottomRight = point; 
    } 
 
    void RectangleX::setLastPoint(QPoint point) { 
      m_bottomRight = point; 
    } </pre>
<p>The <kbd>isClick</kbd> method is simpler than its counterpart in <kbd>Line</kbd>:</p>
<pre>    bool RectangleX::isClick(QPoint mousePoint) { 
      QRect areaRect(m_topLeft, m_bottomRight); </pre>
<p>If the rectangle is filled, we simply check whether the mouse click hit the rectangle by calling <kbd>contains</kbd> in <kbd>QRect</kbd>:</p>
<pre>      if (filled()) { 
        return areaRect.contains(mousePoint); 
      } </pre>
<p>If the rectangle is not filled, we need to check whether the mouse clicked on the border of the rectangle. To do so, we create two slightly smaller and larger rectangles. If the mouse click hit the larger rectangle, but not the smaller one, we consider the rectangle border to be hit:</p>
<pre>      else { 
        QRect largeAreaRect(areaRect), smallAreaRect(areaRect); 
 
        largeAreaRect += Tolerance; 
        smallAreaRect -= Tolerance; 
     
        return largeAreaRect.contains(mousePoint) &amp;&amp; 
               !smallAreaRect.contains(mousePoint); 
      } 
 
      return false; 
    } </pre>
<p>When moving the rectangle, we simply move the first and last corners:</p>
<pre>    void RectangleX::move(QSize distance) { 
      addSizeToPoint(m_topLeft, distance); 
      addSizeToPoint(m_bottomRight, distance); 
    } </pre>
<p>When drawing a rectangle, we first set the pen color by calling <kbd>color</kbd> in <kbd>Figure</kbd>:</p>
<pre>    void RectangleX::draw(QPainter&amp; painter) const { 
      painter.setPen(color()); </pre>
<p>If the rectangle is filled, we simply call <kbd>fillRect</kbd> on the <kbd>QPainter</kbd> object:</p>
<pre>      if (filled()) { 
        painter.fillRect(QRect(m_topLeft, m_bottomRight), color()); 
      } </pre>
<p>If the rectangle is unfilled, we disable the brush to make the rectangle hollow, and we then call <kbd>drawRect</kbd> on the <kbd>QPainter</kbd> object to draw the border of the rectangle:</p>
<pre>      else { 
        painter.setBrush(Qt::NoBrush); 
        painter.drawRect(QRect(m_topLeft, m_bottomRight)); 
      } 
    } </pre>
<p>The <kbd>write</kbd> method first calls <kbd>write</kbd> in <kbd>Figure</kbd>, and it then writes the first and last corners of the rectangle:</p>
<pre>    bool RectangleX::write(ofstream&amp; outStream) const { 
      Figure::write(outStream); 
      writePoint(outStream, m_topLeft); 
      writePoint(outStream, m_bottomRight); 
      return ((bool) outStream); 
    }</pre>
<p>In the same way, <kbd>read</kbd> first calls <kbd>read</kbd> in <kbd>Figure</kbd>, and then reads the first and last corners of the rectangle:</p>
<pre>    bool RectangleX::read (ifstream&amp; inStream) { 
      Figure::read(inStream); 
      readPoint(inStream, m_topLeft); 
      readPoint(inStream, m_bottomRight); 
      return ((bool) inStream); 
    } </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Ellipse sub class</h1>
                </header>
            
            <article>
                
<p><kbd>EllipseX</kbd> is a sub class of <kbd>RectangleX</kbd> that handles an ellipse. Part of the functionality of <kbd>RectangleX</kbd> is reused in <kbd>EllipseX</kbd>. More specifically, <kbd>initializePoints</kbd>, <kbd>setLastPoint</kbd>, <kbd>move</kbd>, <kbd>write</kbd>, and <kbd>read</kbd> are overridden from <kbd>RectangleX</kbd>.</p>
<p><strong>Ellipse.h:</strong><a><br/></a></p>
<pre>    #ifndef ELLIPSE_H 
    #define ELLIPSE_H 
 
    #include "Rectangle.h" 
 
    class EllipseX : public RectangleX { 
      public: 
        EllipseX(); 
        FigureId getId() const {return EllipseId;} 
 
        EllipseX(const EllipseX&amp; ellipse); 
 
        bool isClick(QPoint mousePoint); 
        void draw(QPainter&amp; painter) const; 
    }; 
 
    #endif </pre>
<p><strong>Ellipse.cpp:</strong><a><br/></a></p>
<pre>    #include "..\MainWindow\DocumentWidget.h" 
    #include "Ellipse.h" 
 
    EllipseX::EllipseX() { 
      // Empty. 
    }</pre>
<p>The <kbd>isClick</kbd> method of <kbd>EllipseX</kbd> is similar to its counterpart in <kbd>RectangleX</kbd>. We use the Qt <kbd>QRegion</kbd> class to create elliptic objects that we compare to the mouse click:</p>
<pre>    bool EllipseX::isClick(QPoint mousePoint) { 
      QRect normalRect(m_topLeft, m_bottomRight); 
      normalRect.normalized(); </pre>
<p>If the ellipse is filled, we create an elliptic region and test whether the mouse click hit the region:</p>
<pre>      if (filled()) { 
        QRegion normalEllipse(normalRect, QRegion::Ellipse); 
        return normalEllipse.contains(mousePoint); 
      } </pre>
<p>If the ellipse in unfilled, we create slightly smaller and larger elliptic regions. If the mouse click hit the smaller region, but not the smaller one, we consider the border of the ellipse to be hit:</p>
<pre>      else { 
        QRect largeRect(normalRect), smallRect(normalRect); 
        largeRect += Tolerance; 
        smallRect -= Tolerance; 
 
        QRegion largeEllipse(largeRect, QRegion::Ellipse), 
                smallEllipse(smallRect, QRegion::Ellipse); 
 
        return (largeEllipse.contains(mousePoint) &amp;&amp; 
                !smallEllipse.contains(mousePoint)); 
      } 
    } </pre>
<p>When drawing an ellipse, we first set the pen color by calling <kbd>color</kbd> in <kbd>Figure</kbd>:</p>
<pre>    void EllipseX::draw(QPainter&amp; painter) const { 
      painter.setPen(color()); </pre>
<p>If the ellipse is filled, we set the brush and draw the ellipse:</p>
<pre>      if (filled()) { 
        painter.setBrush(color()); 
        painter.drawEllipse(QRect(m_topLeft, m_bottomRight)); 
      }</pre>
<p>If the ellipse is unfilled, we set the brush to hollow and draw the ellipse border:</p>
<pre>      else { 
        painter.setBrush(Qt::NoBrush); 
        painter.drawEllipse(QRect(m_topLeft, m_bottomRight)); 
      } 
    }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Drawing the window</h1>
                </header>
            
            <article>
                
<p>The <kbd>DrawingWindow</kbd> class is a sub class to the <kbd>MainWindow</kbd> class of the previous section.</p>
<p><strong>DrawingWindow.h:</strong><a><br/></a></p>
<pre>    #ifndef DRAWINGWINDOW_H 
    #define DRAWINGWINDOW_H 
 
    #include &lt;QMainWindow&gt; 
    #include &lt;QActionGroup&gt; 
 
    #include "..\MainWindow\MainWindow.h" 
    #include "DrawingWidget.h" 
 
    class DrawingWindow : public MainWindow { 
      Q_OBJECT 
 
      public: 
        DrawingWindow(QWidget* parentWidgetPtr = nullptr); 
        ~DrawingWindow(); 
 
      public: 
        void closeEvent(QCloseEvent *eventPtr)
             { m_drawingWidgetPtr-&gt;closeEvent(eventPtr); } 
 
      private: 
        DrawingWidget* m_drawingWidgetPtr; 
        QActionGroup* m_figureGroupPtr; 
    }; 
 
    #endif // DRAWINGWINDOW_H </pre>
<p><strong>DrawingWindow.cpp:</strong><a><br/></a></p>
<pre>    #include "..\MainWindow\DocumentWidget.h" 
    #include "DrawingWindow.h"</pre>
<p>The constructor sets the size of the window to <kbd>1000</kbd> * <kbd>500</kbd> pixels:</p>
<pre>    DrawingWindow::DrawingWindow(QWidget* parentWidgetPtr 
                                 /* = nullptr */) 
     :MainWindow(parentWidgetPtr) { 
      resize(1000, 500); </pre>
<p>The <kbd>m_drawingWidgetPtr</kbd> field is initialized to point at an object of the <kbd>DrawingWidget</kbd> class, which is then set to the center part of the window:</p>
<pre>      m_drawingWidgetPtr = new DrawingWidget(this); 
      setCentralWidget(m_drawingWidgetPtr); </pre>
<p>The standard file menu is added to the window menu bar:</p>
<pre>      addFileMenu(); </pre>
<p>We then add the application-specific format menu. It is connected to the <kbd>onMenuShow</kbd> method of the <kbd>DocumentWidget</kbd> class of the previous section:</p>
<pre>      { QMenu* formatMenuPtr = menuBar()-&gt;addMenu(tr("F&amp;ormat")); 
        connect(formatMenuPtr, SIGNAL(aboutToShow()), 
                this, SLOT(onMenuShow())); </pre>
<p>The format menu holds the color and fill items:</p>
<pre>        addAction(formatMenuPtr, tr("&amp;Color"), 
                  SLOT(onColor()), QKeySequence(Qt::ALT + Qt::Key_C), 
                  QString(), nullptr, tr("Figure Color")); </pre>
<p>The fill item will be enabled when the next figure of the drawing program is a two-dimensional figure (rectangle or ellipse):</p>
<pre>        addAction(formatMenuPtr, tr("&amp;Fill"), 
                  SLOT(onFill()), QKeySequence(Qt::CTRL + Qt::Key_F), 
                  QString(), nullptr, tr("Figure Fill"), 
                  LISTENER(isFillEnabled)); 
      } </pre>
<p>For the figure menu, we create a new action group for the line, rectangle, and ellipse item. Only one of them shall be marked at the same time:</p>
<pre>      { m_figureGroupPtr = new QActionGroup(this); 
 
        QMenu* figureMenuPtr = menuBar()-&gt;addMenu(tr("F&amp;igure")); 
        connect(figureMenuPtr, SIGNAL(aboutToShow()), 
                this, SLOT(onMenuShow()));</pre>
<p>The currently selected item shall be marked with a radio button:</p>
<pre>        addAction(figureMenuPtr, tr("&amp;Line"), 
                  SLOT(onLine()), QKeySequence(Qt::CTRL + Qt::Key_L), 
                  QString(), nullptr, tr("Line Figure"), nullptr, 
                  LISTENER(isLineChecked), m_figureGroupPtr); 
        addAction(figureMenuPtr, tr("&amp;Rectangle"), 
                  SLOT(onRectangle()), 
                  QKeySequence(Qt::CTRL + Qt::Key_R), 
                  QString(), nullptr, tr("Rectangle Figure"), nullptr, 
                  LISTENER(isRectangleChecked), m_figureGroupPtr); 
        addAction(figureMenuPtr, tr("&amp;Ellipse"), 
                  SLOT(onEllipse()), 
                  QKeySequence(Qt::CTRL + Qt::Key_E), 
                  QString(), nullptr, tr("Ellipse Figure"), nullptr, 
                  LISTENER(isEllipseChecked), m_figureGroupPtr); 
      } 
    } </pre>
<p>The destructor deallocates the figure group that was dynamically allocated in the constructor:</p>
<pre>    DrawingWindow::~DrawingWindow() { 
      delete m_figureGroupPtr; 
    } </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Drawing the widget</h1>
                </header>
            
            <article>
                
<p><kbd>DrawingWidget</kbd> is a sub class of <kbd>DocumentWidget</kbd> in the previous section. It handles mouse input, painting of the figures, as well as saving and loading of the drawing. It also provides methods for deciding when the menu items shall be marked and enabled.</p>
<p><strong>DrawingWidget.h:</strong><a><br/></a></p>
<pre>    #ifndef DRAWINGWIDGET_H 
    #define DRAWINGWIDGET_H 
 
    #include "..\MainWindow\MainWindow.h" 
    #include "..\MainWindow\DocumentWidget.h" 
    #include "Figure.h" 
 
    class DrawingWidget : public DocumentWidget { 
      Q_OBJECT 
 
      public: 
        DrawingWidget(QWidget* parentWidgetPtr); 
        ~DrawingWidget(); </pre>
<p>The <kbd>mousePressEvent</kbd>, <kbd>mouseReleaseEvent</kbd>, and <kbd>mouseMoveEvent</kbd> are overridden methods that are called when the user presses or releases one of the mouse keys or moves the mouse:</p>
<pre>      public: 
        void mousePressEvent(QMouseEvent *eventPtr); 
        void mouseReleaseEvent(QMouseEvent *eventPtr); 
        void mouseMoveEvent(QMouseEvent *eventPtr); </pre>
<p>The <kbd>paintEvent</kbd> method is called when the window needs to be repainted. That can happen for several reasons. For instance, the user can modify the size of the window. The repainting can also be forced by a call to the <kbd>update</kbd> method, which causes <kbd>paintEvent</kbd> to be called eventually:</p>
<pre>        void paintEvent(QPaintEvent *eventPtr); </pre>
<p>The <kbd>newDocument</kbd> method is called when the user selects the new menu item, <kbd>writeFile</kbd> is called when the user selects the save or save as item, and <kbd>readFile</kbd> is called when the user selects the open item:</p>
<pre>      private: 
        void newDocument() override; 
        bool writeFile(const QString&amp; filePath); 
        bool readFile(const QString&amp; filePath); 
        Figure* createFigure(FigureId figureId); </pre>
<p>The <kbd>onColor</kbd> and <kbd>onFill</kbd> methods are called when the user selects the color and fill menu items:</p>
<pre>      public slots: 
        void onColor(); 
        void onFill(); </pre>
<p>The <kbd>isFillEnabled</kbd> method is called before the user selects the format menu. If it returns <kbd>true</kbd>, the fill item becomes enabled:</p>
<pre>        DEFINE_LISTENER(DrawingWidget, isFillEnabled);</pre>
<p>The <kbd>isLineChecked</kbd>, <kbd>isRectangleChecked</kbd>, and <kbd>isEllipseChecked</kbd> methods are also called before the figure menu becomes visible. The items become marked with a radio button if the methods return <kbd>true</kbd>:</p>
<pre>        DEFINE_LISTENER(DrawingWidget, isLineChecked); 
        DEFINE_LISTENER(DrawingWidget, isRectangleChecked); 
        DEFINE_LISTENER(DrawingWidget, isEllipseChecked); </pre>
<p>The <kbd>onLine</kbd>, <kbd>onRectangle</kbd>, and <kbd>isEllipse</kbd> methods are called when the user selects the line, rectangle, and ellipse menu items:</p>
<pre>        void onLine(); 
        void onRectangle(); 
        void onEllipse(); </pre>
<p>When running, the application can hold the <kbd>Idle</kbd>, <kbd>Create</kbd>, or <kbd>Move</kbd> modes:</p>
<ul>
<li><kbd>Idle</kbd>: When the application is waiting for input from the user.</li>
<li><kbd>Create</kbd>: When the user is adding a new figure to the drawing. Occurs when the user presses the left mouse button without hitting a figure. A new figure is added and its end-point is modified until the user releases the mouse button.</li>
<li><kbd>Move</kbd>: When the user is moving a figure. Occurs when the user presses the left mouse button and hitting a figure. The figure is moved until the user releases the mouse button.</li>
</ul>
<pre>      private: 
        enum ApplicationMode {Idle, Create, Move}; 
        ApplicationMode m_applicationMode = Idle; 
        void setApplicationMode(ApplicationMode mode); </pre>
<p>The <kbd>m_currColor</kbd> field holds the color of the next figure to be added by the user; <kbd>m_currFilled</kbd> decides whether the next figure (if it is a rectangle or an ellipse) shall be filled. The <kbd>m_addFigureId</kbd> method holds the identity integer of the next type of figure (line, rectangle, or ellipse) to be added by the user:</p>
<pre>        QColor m_currColor = Qt::black; 
        bool m_currFilled = false; 
        FigureId m_addFigureId = LineId; </pre>
<p>When the user presses a mouse button and moves a figure, we need to store the previous mouse point in order to calculate the distance the figure has been moved since the last mouse events:</p>
<pre>        QPoint m_mousePoint;</pre>
<p>Finally, <kbd>m_figurePtrList</kbd> holds pointers to the figures of the drawing. The top-most figure in the drawing is placed at the end of the list:</p>
<pre>        QList&lt;Figure*&gt; m_figurePtrList; 
    }; 
 
    #endif // DRAWINGWIDGET_H </pre>
<p><strong>DrawingWidget.cpp:</strong></p>
<pre>    #include "..\MainWindow\DocumentWidget.h" 
    #include "DrawingWidget.h" 
 
    #include "Line.h" 
    #include "Rectangle.h" 
    #include "Ellipse.h" </pre>
<p>The constructor calls the constructor the base class <kbd>DocumentWidget</kbd> with the title <kbd>Drawing</kbd>. It also sets the save and load mask to <kbd>Drawing files (*.drw)</kbd>, which means that the default files selected by the standard save and load dialogs have the suffix <kbd>drw</kbd>:</p>
<pre>    DrawingWidget::DrawingWidget(QWidget* parentWidgetPtr) 
     :DocumentWidget(tr("Drawing"), tr("Drawing files (*.drw)"), 
                     parentWidgetPtr) { 
      // Empty. 
    } </pre>
<p>The destructor deallocates the figure pointers of the figure pointer list:</p>
<pre>    DrawingWidget::~DrawingWidget() { 
      for (Figure* figurePtr : m_figurePtrList) { 
        delete figurePtr; 
      } 
    } </pre>
<p>The <kbd>setApplicationMode</kbd> method sets the application mode and calls <kbd>onMenuShow</kbd> in the main window for the toolbar icons to be correctly enabled:</p>
<pre>    void DrawingWidget::setApplicationMode(ApplicationMode mode) { 
      m_applicationMode = mode; 
      ((MainWindow*) parent())-&gt;onMenuShow(); 
    }</pre>
<p>When the user selects the new menu item, <kbd>newDocument</kbd> is called. The figures of the figure pointer list are deallocated, and the list itself is cleared:</p>
<pre>    void DrawingWidget::newDocument() { 
      for (Figure* figurePtr : m_figurePtrList) { 
        delete figurePtr; 
      } 
      m_figurePtrList.clear(); </pre>
<p>The next figure to be added by the user is a black line, and the filled status is <kbd>false</kbd>:</p>
<pre>      m_currColor = Qt::black; 
      m_addFigureId = LineId; 
      m_currFilled = false; 
    } </pre>
<p>The <kbd>writeFile</kbd> method is called when the user selects the save or save as menu items:</p>
<pre>    bool DrawingWidget::writeFile(const QString&amp; filePath) { 
      ofstream outStream(filePath.toStdString()); </pre>
<p>We start by writing the current color and fill status. We then continue by writing the size of the figure pointer list, and the figures themselves:</p>
<pre>      if (outStream) { 
        writeColor(outStream, m_currColor); 
        outStream.write((char*) &amp;m_currFilled, sizeof m_currFilled); 
 
        int size = m_figurePtrList.size(); 
        outStream.write((char*) &amp;size, sizeof size); </pre>
<p>For each figure, we first write its identity number, and we then write the figure itself:</p>
<pre>        for (Figure* figurePtr : m_figurePtrList) { 
          FigureId figureId = figurePtr-&gt;getId(); 
          outStream.write((char*) &amp;figureId, sizeof figureId); 
          figurePtr-&gt;write(outStream); 
        } 
 
        return ((bool) outStream); 
      } </pre>
<p>If the file was not possible to open, <kbd>false</kbd> is returned:</p>
<pre>      return false; 
    }</pre>
<p>The <kbd>readFile</kbd> method is called when the user selects the open menu item. In the same way as in <kbd>writeFile</kbd> previously, we read the color and fill status, the size of the figure pointer list, and then the figures themselves:</p>
<pre>    bool DrawingWidget::readFile(const QString&amp; filePath) { 
      ifstream inStream(filePath.toStdString()); 
 
      if (inStream) { 
        readColor(inStream, m_currColor); 
        inStream.read((char*) &amp;m_currFilled, sizeof m_currFilled); 
 
        int size; 
        inStream.read((char*) &amp;size, sizeof size); </pre>
<p>When reading the figure, we first read its identity number, and call <kbd>createFigure</kbd> to create an object of the class corresponding to the figure's identity number. We then read the fields of the figure by calling <kbd>read</kbd> on its pointer. Note that we do not really know (or care) what kind of figure it is. We simply call read to the figure pointer, which in fact points to an object of <kbd>Line</kbd>, <kbd>RectangleX</kbd>, or <kbd>EllipseX</kbd>:</p>
<pre>        for (int count = 0; count &lt; size; ++count) { 
          FigureId figureId = (FigureId) 0; 
          inStream.read((char*) &amp;figureId, sizeof figureId); 
          Figure* figurePtr = createFigure(figureId); 
          figurePtr-&gt;read(inStream); 
          m_figurePtrList.push_back(figurePtr); 
        } 
 
        return ((bool) inStream); 
      } 
 
      return false; 
    } </pre>
<p>The <kbd>createFigure</kbd> method dynamically creates an object of the <kbd>Line</kbd>, <kbd>RectangleX</kbd>, or <kbd>EllipseX</kbd> class, depending on the value of the <kbd>figureId</kbd> parameter:</p>
<pre>    Figure* DrawingWidget::createFigure(FigureId figureId) { 
      Figure* figurePtr = nullptr; 
 
      switch (figureId) { 
        case LineId: 
          figurePtr = new Line(); 
          break; 
 
        case RectangleId: 
          figurePtr = new RectangleX(); 
          break; 
 
        case EllipseId: 
          figurePtr = new EllipseX(); 
          break; 
      } 
 
      return figurePtr; 
    } </pre>
<p>The <kbd>onColor</kbd> method is called when the user selects the color menu item. It sets the color of the next figure to be added by the user:</p>
<pre>    void DrawingWidget::onColor() { 
      QColor newColor = QColorDialog::getColor(m_currColor, this); 
 
      if (newColor.isValid() &amp;&amp; (m_currColor != newColor)) { 
        m_currColor = newColor; 
        setModifiedFlag(true); 
      } 
    } </pre>
<p>The <kbd>isFillEnabled</kbd> method is called before the format menu becomes visible, and returns <kbd>true</kbd> if the next figure to be added by the user is a rectangle or an ellipse:</p>
<pre>    bool DrawingWidget::isFillEnabled() { 
      return (m_addFigureId == RectangleId) || 
             (m_addFigureId == EllipseId); 
    } </pre>
<p>The <kbd>onFill</kbd> method is called when the user selects fill menu item. It inverts the <kbd>m_currFilled</kbd> field. It also sets the modified flag since the document has been affected:</p>
<pre>    void DrawingWidget::onFill() { 
      m_currFilled = !m_currFilled; 
      setModifiedFlag(true); 
    } </pre>
<p>The <kbd>isLineChecked</kbd>, <kbd>isRectangleChecked</kbd>, and <kbd>isEllipseChecked</kbd> methods are called before the figure menu becomes visible. If they return <kbd>true</kbd>, the items become checked with a radio button if the next figure to be added is the figure in question:</p>
<pre>    bool DrawingWidget::isLineChecked() { 
      return (m_addFigureId == LineId); 
    } 
 
    bool DrawingWidget::isRectangleChecked() { 
      return (m_addFigureId == RectangleId); 
    } 
 
    bool DrawingWidget::isEllipseChecked() { 
      return (m_addFigureId == EllipseId); 
    } </pre>
<p>The <kbd>onLine</kbd>, <kbd>onRectangle</kbd>, and <kbd>onEllipse</kbd> methods are called when the user selects the items in the figure menu. They set the next figure to be added by the user to the figure in question:</p>
<pre>    void DrawingWidget::onLine() { 
      m_addFigureId = LineId; 
    } 
 
    void DrawingWidget::onRectangle() { 
      m_addFigureId = RectangleId; 
    } 
 
    void DrawingWidget::onEllipse() { 
      m_addFigureId = EllipseId; 
    } </pre>
<p>The <kbd>mousePressEvent</kbd> method is called every time the user presses one of the mouse keys. First, we need to check if they have pressed the left mouse key:</p>
<pre>    void DrawingWidget::mousePressEvent(QMouseEvent* eventPtr) { 
      if (eventPtr-&gt;buttons() == Qt::LeftButton) { </pre>
<p>In the call to <kbd>mouseMoveEvent</kbd> in the following snippet, we need to keep track of the latest mouse point in order to calculate the distance between mouse movements. Therefore, we set <kbd>m_mousePoint</kbd> to the mouse point:</p>
<pre>        m_mousePoint = eventPtr-&gt;pos(); </pre>
<p>We iterate through the figure pointer list and, for each figure, we check if the figure has been hit by the mouse click by calling <kbd>isClick</kbd>. We need to iterate backwards in a rather awkward manner in order to find the top-most figure first. We use the <kbd>reverse_iterator</kbd> class and the <kbd>rbegin</kbd> and <kbd>rend</kbd> methods in order to iterate backwards:</p>
<pre>        for (QList&lt;Figure*&gt;::reverse_iterator iterator = 
             m_figurePtrList.rbegin(); 
             iterator != m_figurePtrList.rend(); ++iterator) {</pre>
<p>We use the dereference operator (<kbd>*</kbd>) to obtain the figure pointer in the list:</p>
<pre>              Figure* figurePtr = *iterator; </pre>
<p>If the figure has been hit by the mouse click, we set the application mode to move. We also place the figure at the end of the list, so that it appears to be top-most in the drawing, by calling <kbd>removeOne</kbd> and <kbd>push_back</kbd> on the list. Finally, we break the loop since we have found the figure we are looking for:</p>
<pre>          if (figurePtr-&gt;isClick(m_mousePoint)) { 
            setApplicationMode(Move); 
            m_figurePtrList.removeOne(figurePtr); 
            m_figurePtrList.push_back(figurePtr); 
            break; 
          } 
        } </pre>
<p>If the application mode is <span>still </span>idle (has not moved), we have not found a figure hit by the mouse click. In that case, we set the application mode to create and call <kbd>createFigure</kbd> to find a figure to copy. We then set the color and filled status as well as the points of the figure. Finally, we add the figure pointer to the figure pointer list by calling <kbd>push_back</kbd> (which is added at the end of the list in order for it to appear at the top of the drawing) and set the modified flag to <kbd>true</kbd>, since the drawing has been modified:</p>
<pre>        if (m_applicationMode == Idle) { 
          setApplicationMode(Create); 
          Figure* newFigurePtr = createFigure(m_addFigureId); 
          newFigurePtr-&gt;color() = m_currColor; 
          newFigurePtr-&gt;filled() = m_currFilled; 
          newFigurePtr-&gt;initializePoints(m_mousePoint); 
          m_figurePtrList.push_back(newFigurePtr); 
          setModifiedFlag(true); 
        } 
      } 
    } </pre>
<p>The <kbd>mouseMoveEvent</kbd> is called every time the user moves the mouse. First, we need to check that the user presses the left mouse key when they move the mouse:</p>
<pre>    void DrawingWidget::mouseMoveEvent(QMouseEvent* eventPtr) { 
      if (eventPtr-&gt;buttons() == Qt::LeftButton) { 
        QPoint newMousePoint = eventPtr-&gt;pos();</pre>
<p>We then check the application mode. If we are in the process of adding a new figure to the drawing, we modify its last point:</p>
<pre>        switch (m_applicationMode) { 
          case Create: 
            m_figurePtrList.back()-&gt;setLastPoint(m_mousePoint); 
            break; </pre>
<p>If we are in the process of moving a figure, we calculate the distance since the last mouse event and move the figure placed at the end of the figure pointer list. Remember that the figure hit by the mouse click was placed at the end of the figure pointer list in the preceding <kbd>mousePressEvent</kbd>:</p>
<pre>          case Move: { 
              QSize distance(newMousePoint.x() - m_mousePoint.x(), 
                             newMousePoint.y() - m_mousePoint.y()); 
              m_figurePtrList.back()-&gt;move(distance); 
              setModifiedFlag(true); 
            } 
            break; 
        } </pre>
<p>Finally, we update the current mouse point for the next call to <kbd>mouseMoveEvent</kbd>. We also call the update method to force a repainting of the window:</p>
<pre>        m_mousePoint = newMousePoint; 
        update(); 
      } 
    } </pre>
<p>The <kbd>mouseReleaseEvent</kbd> method is called when the user releases one of the mouse buttons. We set the application mode to idle:</p>
<pre>    void DrawingWidget::mouseReleaseEvent(QMouseEvent* eventPtr) { 
      if (eventPtr-&gt;buttons() == Qt::LeftButton) { 
        setApplicationMode(Idle); 
      } 
    } </pre>
<p>The <kbd>paintEvent</kbd> method is called every time the window needs to be repainted. It may happen for several reasons. For instance, the user may have changed the size of the window. It may also be a result of a call to <kbd>update</kbd> in the Qt <kbd>QWidget</kbd> class, which forces a repainting of the window and an eventual call to <kbd>paintEvent</kbd>.</p>
<p>We start by creating a <kbd>QPainter</kbd> object, which can be regarded as canvas to paint on, and set suitable rendering. We then iterate through the figure pointer list, and draw each figure. In this way, the last figure in the list is drawn at the top of the drawing:</p>
<pre>    void DrawingWidget::paintEvent(QPaintEvent* /* eventPtr */) { 
      QPainter painter(this); 
      painter.setRenderHint(QPainter::Antialiasing); 
      painter.setRenderHint(QPainter::TextAntialiasing); 
 
      for (Figure* figurePtr : m_figurePtrList) { 
        figurePtr-&gt;draw(painter); 
      } 
    } </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The main function</h1>
                </header>
            
            <article>
                
<p>Finally, we start the application in the <kbd>main</kbd> function by creating an application object, showing the main window and executing the application.</p>
<p><strong>Main.cpp:</strong></p>
<pre>    #include "DrawingWindow.h" 
    #include &lt;QApplication&gt; 
 
    int main(int argc, char *argv[]) { 
      QApplication application(argc, argv); 
      DrawingWindow drawingWindow; 
      drawingWindow.show(); 
      return application.exec(); 
    }</pre>
<p>The following output is received:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="187" src="assets/25b6b2a9-d07d-4e9e-b8c8-28b2475353a8.png" width="349"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building an editor</h1>
                </header>
            
            <article>
                
<p>The next application is an editor, where the user can input and edit text. The current input position is indicated by a caret. It is possible to move the caret with the arrow keys and by clicking with the mouse.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Caret class</h1>
                </header>
            
            <article>
                
<p>The <kbd>Caret</kbd> class handles the caret; that is, the blinking vertical line marking the position of the next character to be input.</p>
<p><strong>Caret.h:</strong></p>
<pre>    #ifndef CARET_H 
    #define CARET_H 
 
    #include &lt;QObject&gt; 
    #include &lt;QWidget&gt; 
    #include &lt;QTimer&gt; 
 
    class Caret : public QObject { 
      Q_OBJECT 
 
      public: 
        Caret(QWidget* parentWidgetPtr = nullptr);</pre>
<pre> </pre>
<p>The <kbd>show</kbd> and <kbd>hide</kbd> methods show and hide the caret. In this application, the caret is never hidden. However, in the advanced version in the next chapter, the caret will be hidden on some occasions:</p>
<pre>        void show(); 
        void hide(); </pre>
<p>The <kbd>set</kbd> method sets the current size and position of the caret, and <kbd>paint</kbd> paints it on the <kbd>QPainter</kbd> object:</p>
<pre>        void set(QRect rect); 
        void paint(QPainter&amp; painter); </pre>
<p>The <kbd>onTimer</kbd> method is called every time the caret blinks:</p>
<pre>      public slots: 
        void onTimer(void); 
 
      private: 
        QWidget* m_parentWidgetPtr; </pre>
<p>The <kbd>m_visible</kbd> field is true when the caret is visible:</p>
<pre>        bool m_visible, m_blink; </pre>
<p>The <kbd>m_rect</kbd> field handles the timer that makes the caret blink:</p>
<pre>        QRect m_rect; </pre>
<p>The <kbd>m_timer</kbd> field handles the timer that makes the caret blink:</p>
<pre>        QTimer m_timer; 
    }; 
 
    #endif // CARET_H </pre>
<p>The <kbd>Caret.cpp</kbd> file holds the definitions of the methods of the <kbd>Caret</kbd> class.</p>
<p><strong>Caret.cpp:</strong></p>
<pre>    #include "Caret.h" 
    #include &lt;QPainter&gt;</pre>
<p>The constructor connects the timer signal to <kbd>onTimer</kbd>, with the result that <kbd>onTimer</kbd> is called for every timeout. The timer is then initialized to <kbd>500</kbd> milliseconds. That is, <kbd>onTimer</kbd> will be called every <kbd>500</kbd> milliseconds, and the caret becomes shown and hidden every 500 milliseconds:</p>
<pre>    Caret::Caret(QWidget* parentWidgetPtr) 
      :m_parentWidgetPtr(parentWidgetPtr) { 
      m_timer.setParent(this); 
      connect(&amp;m_timer, SIGNAL(timeout()), this, SLOT(onTimer())); 
      m_timer.start(500); 
    } </pre>
<p>The <kbd>show</kbd> and <kbd>hide</kbd> methods set the <kbd>m_visible</kbd> field and force a repainting of the caret area by calling <kbd>update</kbd> on the parent window:</p>
<pre>    void Caret::show() { 
      m_visible = true; 
      m_parentWidgetPtr-&gt;update(m_rect); 
    } 
 
    void Caret::hide() { 
      m_visible = false; 
      m_parentWidgetPtr-&gt;update(m_rect); 
    } </pre>
<p>The <kbd>set</kbd> method sets the size and position of the caret. However, the width of the caret is always set to one, which makes it appear as a thin vertical line:</p>
<pre>    void Caret::set(QRect rect) { 
      m_rect = rect; 
      m_rect.setWidth(1); 
      m_parentWidgetPtr-&gt;update(m_rect); 
    } </pre>
<p>The <kbd>onTimer</kbd> method is called every 500 milliseconds. It inverts <kbd>m_blink</kbd> and forces a repaint of the caret. This gives the result that the caret blinks at an interval of one second:</p>
<pre>    void Caret::onTimer(void) { 
      m_blink = !m_blink; 
      m_parentWidgetPtr-&gt;update(m_rect); 
    }</pre>
<p>The <kbd>paint</kbd> method is called every time the caret needs to be repainted. The caret is drawn if both <kbd>m_visible</kbd> and <kbd>m_blink</kbd> are true, which they are if the caret is set to be visible and the caret is blinking; that is, that the caret is visible in the blinking interval. The area of the caret is cleared before the call to paint, so that if no drawing occurs, the caret is cleared:</p>
<pre>    void Caret::paint(QPainter&amp; painter) { 
      if (m_visible &amp;&amp; m_blink) { 
        painter.save(); 
        painter.setPen(Qt::NoPen); 
        painter.setBrush(Qt::black); 
        painter.drawRect(m_rect); 
        painter.restore(); 
      } 
    } </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Drawing the editor window</h1>
                </header>
            
            <article>
                
<p><kbd>EditorWindow</kbd> is a sub class of <kbd>MainWindow</kbd> in the previous section. It handles the closing of the window. Moreover, it also handles the key press event.</p>
<p><strong>EditorWindow.h:</strong><a><br/></a></p>
<pre>    #ifndef EDITORWINDOW_H 
    #define EDITORWINDOW_H 
 
    #include &lt;QMainWindow&gt; 
    #include &lt;QActionGroup&gt; 
    #include &lt;QPair&gt; 
    #include &lt;QMap&gt; 
 
    #include "..\MainWindow\MainWindow.h" 
    #include "EditorWidget.h" 
 
    class EditorWindow : public MainWindow { 
      Q_OBJECT 
 
      public: 
        EditorWindow(QWidget* parentWidgetPtr = nullptr); 
        ~EditorWindow(); </pre>
<p>The <kbd>keyPressEvent</kbd> method is called every time the user presses a key, and <kbd>closeEvent</kbd> is called when the user tries closing the window:</p>
<pre>      protected: 
        void keyPressEvent(QKeyEvent* eventPtr); 
        void closeEvent(QCloseEvent* eventPtr); 
 
      private: 
        EditorWidget* m_editorWidgetPtr; 
    }; 
 
    #endif // EDITORWINDOW_H </pre>
<p>The <kbd>EditorWindow</kbd> class is in fact rather small. It only defines the constructor and the destructor, as well as the <kbd>keyPressEvent</kbd> and <kbd>closePressEvent</kbd> methods.</p>
<p><strong>EditorWindow.cpp:</strong></p>
<pre>    #include "EditorWindow.h" 
    #include &lt;QtWidgets&gt; </pre>
<p>The constructor sets the size of the window to <kbd>1000</kbd> * <kbd>500</kbd> pixels and adds the standard file menu to the menu bar:</p>
<pre>    EditorWindow::EditorWindow(QWidget* parentWidgetPtr /*= nullptr*/) 
     :MainWindow(parentWidgetPtr) { 
      resize(1000, 500); 
      m_editorWidgetPtr = new EditorWidget(this); 
      setCentralWidget(m_editorWidgetPtr); 
      addFileMenu(); 
    } 
 
    EditorWindow::~EditorWindow() { 
      // Empty. 
    } </pre>
<p>The <kbd>keyPressEvent</kbd> and <kbd>closeEvent</kbd> methods just pass the message to their counterpart methods in the editor widget, which is located at the center of the window:</p>
<pre>    void EditorWindow::keyPressEvent(QKeyEvent* eventPtr) { 
      m_editorWidgetPtr-&gt;keyPressEvent(eventPtr); 
    } 
 
    void EditorWindow::closeEvent(QCloseEvent* eventPtr) { 
      m_editorWidgetPtr-&gt;closeEvent(eventPtr); 
    }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Drawing the editor widget</h1>
                </header>
            
            <article>
                
<p>The <kbd>EditorWidget</kbd> class is a sub class of <kbd>DocumentWidget</kbd> of the previous section. It catches the key, mouse, resizing, and closing events. It also overrides the methods for saving and loading documents.</p>
<p><strong>EditorWidget.h:</strong></p>
<pre>    #ifndef EDITORWIDGET_H 
    #define EDITORWIDGET_H 
 
    #include &lt;QWidget&gt; 
    #include &lt;QMap&gt; 
    #include &lt;QMenu&gt; 
    #include &lt;QToolBar&gt; 
    #include &lt;QPair&gt; 
    #include "Caret.h" 
 
    #include "..\MainWindow\DocumentWidget.h" 
 
    class EditorWidget : public DocumentWidget { 
      Q_OBJECT 
 
      public: 
        EditorWidget(QWidget* parentWidgetPtr); </pre>
<p>The <kbd>keyPressEvent</kbd> is called when the user presses a key, and <kbd>mousePressEvent</kbd> is called when the user clicks with the mouse:</p>
<pre>        void keyPressEvent(QKeyEvent* eventPtr); 
        void mousePressEvent(QMouseEvent* eventPtr); </pre>
<p>The <kbd>mouseToIndex</kbd> method is an auxiliary method that calculates the index of the character the user clicks at with the mouse:</p>
<pre>      private: 
        int mouseToIndex(QPoint point); </pre>
<p>The <kbd>paintEvent</kbd> method is called when the window needs to be repainted, and <kbd>resizeEvent</kbd> is called when the user resizes the window. We catch the resize event in this application because we want to recalculate the number of characters that fits on each line:</p>
<pre>      public: 
        void paintEvent(QPaintEvent* eventPtr); 
        void resizeEvent(QResizeEvent* eventPtr);</pre>
<p>Similar to the drawing program in the previous section, <kbd>newDocument</kbd> is called when the user selects the New menu item, <kbd>writeFile</kbd> is called when the user selects the save or save as items, and <kbd>readFile</kbd> is called when the user selects the open item:</p>
<pre>      private: 
        void newDocument(void); 
        bool writeFile(const QString&amp; filePath); 
        bool readFile(const QString&amp; filePath); </pre>
<p>The <kbd>setCaret</kbd> method is called to set the caret as a response to user input or a mouse click:</p>
<pre>      private: 
        void setCaret(); </pre>
<p>When the user moves the caret up or down, we need to find the index of character over or under the caret. The easiest way to do that is to simulate a mouse click:</p>
<pre>        void simulateMouseClick(int x, int y); </pre>
<p>The <kbd>calculate</kbd> method is an auxiliary method that calculates the number of lines, and the position of each character on each line:</p>
<pre>      private: 
        void calculate(); </pre>
<p>The <kbd>m_editIndex</kbd> field holds the index of the position for the user to input text. That position is also where the caret is visible:</p>
<pre>        int m_editIndex = 0; </pre>
<p>The <kbd>m_caret</kbd> field holds the caret of the application:</p>
<pre>        Caret m_caret; </pre>
<p>The text of the editor is stored in <kbd>m_editorText</kbd>:</p>
<pre>        QString m_editorText; </pre>
<p>The text of the editor may be distributed over several lines; <kbd>m_lineList</kbd> keeps track of the first and last index of each line:</p>
<pre>        QList&lt;QPair&lt;int,int&gt;&gt; m_lineList; </pre>
<p>The preceding <kbd>calculate</kbd> method calculates the rectangle of each character in the editor text, and places them in <kbd>m_rectList</kbd>:</p>
<pre>        QList&lt;QRect&gt; m_rectList;</pre>
<p>In the application of this chapter, all characters hold the same font, which is stored in <kbd>TextFont</kbd>:</p>
<pre>        static const QFont TextFont; </pre>
<p><kbd>FontWidth</kbd> and <kbd>FontHeight</kbd> hold the width and height of a character in <kbd>TextFont</kbd>:</p>
<pre>         int FontWidth, FontHeight; 
    }; 
 
    #endif // EDITORWIDGET_H </pre>
<p>The <kbd>EditorWidget</kbd> class is rather large. It defines the functionality of the editor.</p>
<p><strong>EditorWidget.cpp:</strong></p>
<pre>    #include "EditorWidget.h" 
    #include &lt;QtWidgets&gt; 
    using namespace std; </pre>
<p>We initialize the text font to 12-point <kbd>Courier New</kbd>:</p>
<pre>    const QFont EditorWidget::TextFont("Courier New", 12); </pre>
<p>The constructor sets the title to <kbd>Editor</kbd> and the file suffix for the standard Load and Save dialogs to <kbd>edi</kbd>. The height and average width, in pixels, of a character in the text font are set with the Qt <kbd>QMetrics</kbd> class. The rectangle of each character is calculated, and the caret is set to the first character in the text:</p>
<pre>    EditorWidget::EditorWidget(QWidget* parentWidgetPtr) 
     :DocumentWidget(tr("Editor"), tr("Editor files (*.edi)"), 
                     parentWidgetPtr), 
      m_caret(this), 
      m_editorText(tr("Hello World")) { 
      QFontMetrics metrics(TextFont);<br/>      FontHeight = metrics.height();<br/>      FontWidth = metrics.averageCharWidth();<br/>      calculate(); 
      setCaret(); 
      m_caret.show(); 
    } </pre>
<p>The <kbd>newDocument</kbd> method is called when the user selects the new menu item. It clears the text, sets the caret, and recalculates the character rectangles:</p>
<pre>    void EditorWidget::newDocument(void) { 
      m_editIndex = 0; 
      m_editorText.clear(); 
      calculate(); 
      setCaret(); 
    } </pre>
<p>The <kbd>writeFile</kbd> method is called when the user selects the save or save as menu items. It simply writes the current text of the editor:</p>
<pre>    bool EditorWidget::writeFile(const QString&amp; filePath) { 
      QFile file(filePath); 
      if (file.open(QIODevice::WriteOnly | QIODevice::Text)) { 
        QTextStream outStream(&amp;file); 
        outStream &lt;&lt; m_editorText; </pre>
<p>We use the <kbd>Ok</kbd> field of the input stream to decide if the writing was successful:</p>
<pre>        return ((bool) outStream.Ok); 
      } </pre>
<p>If it was not possible to open the file for writing, <kbd>false</kbd> is returned:</p>
<pre>      return false; 
    } </pre>
<p>The <kbd>readFile</kbd> method is called when the user selects the load menu item. It reads all the text of the editor by calling <kbd>readAll</kbd> on the input stream:</p>
<pre>    bool EditorWidget::readFile(const QString&amp; filePath) { 
      QFile file(filePath); 
 
      if (file.open(QIODevice::ReadOnly | QIODevice::Text)) { 
        QTextStream inStream(&amp;file); 
        m_editorText = inStream.readAll(); </pre>
<p>When the text has been read, the character rectangles are calculated, and the caret is set:</p>
<pre>        calculate(); 
        setCaret(); </pre>
<p>We use the <kbd>Ok</kbd> field of the input stream to decide if the reading was successful:</p>
<pre>        return ((bool) inStream.Ok); 
      } </pre>
<p>If it was not possible to open the file for reading, <kbd>false</kbd> is returned:</p>
<pre>      return false; 
    }</pre>
<p>The <kbd>mousePressEvent</kbd> is called when the user presses one of the mouse buttons. If the user presses the left button, we call <kbd>mouseToIndex</kbd> to calculate the index of the character clicked at, and set the caret to that index:</p>
<pre>    void EditorWidget::mousePressEvent(QMouseEvent* eventPtr) { 
      if (eventPtr-&gt;buttons() == Qt::LeftButton) { 
        m_editIndex = mouseToIndex(eventPtr-&gt;pos()); 
        setCaret(); 
      } 
    } </pre>
<p>The <kbd>keyPressEvent</kbd> is called when the user presses a key. First, we check if it is an arrow key, the delete, backspace, or return key. If it is not, we insert the character at the position indicated by the caret:</p>
<pre>    void EditorWidget::keyPressEvent(QKeyEvent* eventPtr) { 
      switch (eventPtr-&gt;key()) { </pre>
<p>If the key is the left-arrow key, and if the edit caret is not already located at the beginning of the text, we decrease the edit index:</p>
<pre>        case Qt::Key_Left: 
          if (m_editIndex &gt; 0) { 
            --m_editIndex; 
          } 
          break; </pre>
<p>If the key is the right-arrow key, and if the edit caret is not already located at the end of the text, we increase the edit index:</p>
<pre>        case Qt::Key_Right: 
          if (m_editIndex &lt; m_editorText.size()) { 
            ++m_editIndex; 
          } 
          break; </pre>
<p>If the key is the up-arrow key, and if the edit caret is not already located at the top of the editor, we call <kbd>similateMouseClick</kbd> to simulate that the user clicks with the mouse at a point slightly over the current index. In that way, the new edit index will at the line over the current line:</p>
<pre>        case Qt::Key_Up: { 
            QRect charRect = m_rectList[m_editIndex]; 
 
            if (charRect.top() &gt; 0) { 
              int x = charRect.left() + (charRect.width() / 2), 
                  y = charRect.top() - 1; 
              simulateMouseClick(x, y); 
            } 
          } 
          break; </pre>
<p>If the key is the down-arrow key, we call <kbd>similateMouseClick</kbd> to simulate that the user clicks with the mouse at a point slightly under the current index. In that way, we the edit carat will be located at the character directly beneath the current character. Note that if the index is already at the bottom line, nothing happens:</p>
<pre>        case Qt::Key_Down: { 
            QRect charRect = m_rectList[m_editIndex]; 
            int x = charRect.left() + (charRect.width() / 2), 
                y = charRect.bottom() + 1; 
            simulateMouseClick(x, y); 
          } 
          break; </pre>
<p>If the user presses the delete key, and the edit index is not already beyond the end of the text, the current character is removed:</p>
<pre>        case Qt::Key_Delete: 
          if (m_editIndex &lt; m_editorText.size()) { 
            m_editorText.remove(m_editIndex, 1); 
            setModifiedFlag(true); 
          } 
          break; </pre>
<p>If the user presses the backspace key, and the edit index is not already at the beginning of the text, the character before the current character is removed:</p>
<pre>        case Qt::Key_Backspace: 
          if (m_editIndex &gt; 0) { 
            m_editorText.remove(--m_editIndex, 1); 
            setModifiedFlag(true); 
          } 
          break; </pre>
<p>If the user presses the return key, the newline character (<kbd>n</kbd>) is inserted:</p>
<pre>        case Qt::Key_Return: 
          m_editorText.insert(m_editIndex++, 'n'); 
          setModifiedFlag(true); 
          break;</pre>
<p>If the user presses a readable character, it is given by the <kbd>text</kbd> method, and we insert its first character at the edit index:</p>
<pre>        default: { 
            QString text = eventPtr-&gt;text(); 
 
            if (!text.isEmpty()) { 
              m_editorText.insert(m_editIndex++, text[0]); 
              setModifiedFlag(true); 
            } 
          } 
          break; 
      }  </pre>
<p>When the text has been modified, we need to calculate the character rectangles, set the caret, and force a repaint by calling <kbd>update</kbd>:</p>
<pre>      calculate(); 
      setCaret(); 
      update(); 
    } </pre>
<p>The <kbd>similateMouseClick</kbd> method simulates a mouse click by calling <kbd>mousePressEvent</kbd> and <kbd>mousePressRelease</kbd> with the given point:</p>
<pre>    void EditorWidget::simulateMouseClick(int x, int y) { 
      QMouseEvent pressEvent(QEvent::MouseButtonPress, QPointF(x, y), 
                       Qt::LeftButton, Qt::NoButton, Qt::NoModifier); 
      mousePressEvent(&amp;pressEvent); 
      QMouseEvent releaseEvent(QEvent::MouseButtonRelease, 
                               QPointF(x, y), Qt::LeftButton, 
                               Qt::NoButton, Qt::NoModifier); 
      mousePressEvent(&amp;releaseEvent); 
    } </pre>
<p>The <kbd>setCaret</kbd> method creates a rectangle holding the size and position of the caret, and then hides, sets, and shows the caret:</p>
<pre>    void EditorWidget::setCaret() { 
      QRect charRect = m_rectList[m_editIndex]; 
      QRect caretRect(charRect.left(), charRect.top(), 
                      1, charRect.height()); 
      m_caret.hide(); 
      m_caret.set(caretRect); 
      m_caret.show(); 
    }</pre>
<p>The <kbd>mouseToIndex</kbd> method calculates the edit index of the given mouse point:</p>
<pre>    int EditorWidget::mouseToIndex(QPoint mousePoint) { 
      int x = mousePoint.x(), y = mousePoint.y(); </pre>
<p>First, we set the <kbd>y</kbd> coordinate to the text, in case it is below the text:</p>
<pre>      if (y &gt; (FontHeight * m_lineList.size())) { 
        y = ((FontHeight * m_lineList.size()) - 1); 
      } </pre>
<p>We calculate the line of the mouse point:</p>
<pre>      int lineIndex = y / FontHeight; 
      QPair&lt;int,int&gt; lineInfo = m_lineList[lineIndex]; 
      int firstIndex = lineInfo.first, lastIndex = lineInfo.second; </pre>
<p>We find the index on that line:</p>
<pre>      if (x &gt; ((lastIndex - firstIndex + 1) * FontWidth)) { 
        return (lineIndex == (m_lineList.size() - 1)) 
               ? (lineInfo.second + 1) : lineInfo.second; 
      } 
      else { 
        return firstIndex + (x / FontWidth); 
      } 
  
      return 0; 
    } </pre>
<p>The <kbd>resizeEvent</kbd> method is called when the user changes the size of the window. The character rectangles are recalculated since the lines may be shorter or longer:</p>
<pre>    void EditorWidget::resizeEvent(QResizeEvent* eventPtr) { 
      calculate(); 
      DocumentWidget::resizeEvent(eventPtr); 
    } </pre>
<p>The <kbd>calculate</kbd> method is called every time there has been a change in the text or when the window size has been changed. It iterates through the text and calculates the rectangle for each character:</p>
<pre>    void EditorWidget::calculate() { 
      m_lineList.clear(); 
      m_rectList.clear(); 
      int windowWidth = width();</pre>
<p>First, we need to divide the text into lines. Each line continues until it does not fit in the window, until we reach a new line, or until the text ends:</p>
<pre>      { int firstIndex = 0, lineWidth = 0; 
        for (int charIndex = 0; charIndex &lt; m_editorText.size(); 
             ++charIndex) { 
          QChar c = m_editorText[charIndex]; 
 
          if (c == 'n') { 
            m_lineList.push_back 
                       (QPair&lt;int,int&gt;(firstIndex, charIndex)); 
            firstIndex = charIndex + 1; 
            lineWidth = 0; 
          } 
          else { 
            if ((lineWidth + FontWidth) &gt; windowWidth) { 
              if (firstIndex == charIndex) { 
                m_lineList.push_back 
                           (QPair&lt;int,int&gt;(firstIndex, charIndex)); 
                firstIndex = charIndex + 1; 
              } 
              else { 
                m_lineList.push_back(QPair&lt;int,int&gt;(firstIndex, 
                                                    charIndex - 1)); 
                firstIndex = charIndex; 
              } 
 
              lineWidth = 0; 
            } 
            else { 
              lineWidth += FontWidth; 
            } 
          } 
        } 
 
        m_lineList.push_back(QPair&lt;int,int&gt;(firstIndex, 
                                            m_editorText.size() - 1)); 
      } </pre>
<p>We then iterate through the lines and, for each line, calculate the rectangle of each character:</p>
<pre>      { int top = 0; 
        for (int lineIndex = 0; lineIndex &lt; m_lineList.size(); 
             ++lineIndex) { 
          QPair&lt;int,int&gt; lineInfo = m_lineList[lineIndex]; 
          int firstIndex = lineInfo.first, 
              lastIndex = lineInfo.second, left = 0; 
 
          for (int charIndex = firstIndex; 
               charIndex &lt;= lastIndex; ++charIndex){ 
            QRect charRect(left, top, FontWidth, FontHeight); 
            m_rectList.push_back(charRect); 
            left += FontWidth; 
          } 
 
          if (lastIndex == (m_editorText.size() - 1)) { 
            QRect lastRect(left, top, 1, FontHeight); 
            m_rectList.push_back(lastRect); 
          } 
 
          top += FontHeight; 
        } 
      } 
    } </pre>
<p>The <kbd>paintEvent</kbd> method is called when the window needs to be repainted:</p>
<pre>    void EditorWidget::paintEvent(QPaintEvent* /*eventPtr*/) { 
      QPainter painter(this); 
      painter.setRenderHint(QPainter::Antialiasing); 
      painter.setRenderHint(QPainter::TextAntialiasing); 
      painter.setFont(TextFont); 
      painter.setPen(Qt::black); 
      painter.setBrush(Qt::white); </pre>
<p>We iterate through the text of the editor and, for each character except the new line, we write in its appropriate position:</p>
<pre>      for (int index = 0; index &lt; m_editorText.length(); ++index) { 
        QChar c = m_editorText[index]; 
 
        if (c != 'n') { 
          QRect rect = m_rectList[index]; 
          painter.drawText(rect, c); 
        } 
      } 
 
      m_caret.paint(painter); 
    }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The main function</h1>
                </header>
            
            <article>
                
<p>Finally, the <kbd>main</kbd> function works in a way similar to the previous applications of this chapter—we create an application, create an editor window, and execute the application.</p>
<p><strong>Main.cpp:</strong></p>
<pre>#include "EditorWindow.h" 
#include &lt;QApplication&gt; 
 
int main(int argc, char *argv[]) { 
  QApplication application(argc, argv); 
  EditorWindow editorWindow; 
  editorWindow.show(); 
  return application.exec(); 
} </pre>
<p>The following output is obtained:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/a562a9ab-9bc0-4cbc-99f8-d3d7382a9605.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have developed three graphical applications with the Qt library—an analog clock, a drawing program, and an editor. The clock shows the current hour, minute, and second. In the drawing program we can draw lines, rectangles, and ellipses, and in the editor, we can input and edit text.</p>
<p>In the next chapter, we will continue to work with the applications, and develop more advanced versions.</p>
<p> </p>


            </article>

            
        </section>
    </body></html>