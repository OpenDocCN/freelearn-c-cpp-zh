["```cpp\nVkPhysicalDeviceDescriptorIndexingFeatures indexing\n_features{ VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR\n           _INDEXING_FEATURES, nullptr };\n    VkPhysicalDeviceFeatures2 device_features{\n        VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,\n            &indexing_features };\n    vkGetPhysicalDeviceFeatures2( vulkan_physical_device,\n                                  &device_features );\n    bindless_supported = indexing_features.\n                         descriptorBindingPartiallyBound &&\n                         indexing_features.\n                         runtimeDescriptorArray;\n```", "```cpp\nVkPhysicalDeviceFeatures2 physical_features2 = {\n    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2 };\nvkGetPhysicalDeviceFeatures2( vulkan_physical_device,\n                              &physical_features2 );\nVkDeviceCreateInfo device_create_info = {};\n// same code as chapter 1\ndevice_create_info.pNext = &physical_features2;\nif ( bindless_supported ) {\n    physical_features2.pNext = &indexing_features;\n}\nvkCreateDevice( vulkan_physical_device,\n                &device_create_info,\n                vulkan_allocation_callbacks,\n                &vulkan_device );\n```", "```cpp\nVkDescriptorPoolSize pool_sizes_bindless[] =\n{\n    { VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER,\n      k_max_bindless_resources },\n      { VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,\n      k_max_bindless_resources },\n};\npool_info.flags = VK_DESCRIPTOR_POOL_CREATE_UPDATE\n                  _AFTER_BIND_BIT_EXT;\npool_info.maxSets = k_max_bindless_resources * ArraySize(\n                    pool_sizes_bindless );\npool_info.poolSizeCount = ( u32 )ArraySize(\n                            pool_sizes_bindless );\npool_info.pPoolSizes = pool_sizes_bindless;\nvkCreateDescriptorPool( vulkan_device, &pool_info,\n                        vulkan_allocation_callbacks,\n                        &vulkan_bindless_descriptor_pool);\n```", "```cpp\nconst u32 pool_count = ( u32 )ArraySize(\n                         pool_sizes_bindless );\nVkDescriptorSetLayoutBinding vk_binding[ 4 ];\nVkDescriptorSetLayoutBinding& image_sampler_binding =\n    vk_binding[ 0 ];\nimage_sampler_binding.descriptorType = VK_DESCRIPTOR\n                                       _TYPE_COMBINED\n                                       _IMAGE_SAMPLER;\nimage_sampler_binding.descriptorCount =\n    k_max_bindless_resources;\nimage_sampler_binding.binding = k_bindless_texture_binding;\nVkDescriptorSetLayoutBinding& storage_image_binding =\n    vk_binding[ 1 ];\nstorage_image_binding.descriptorType = VK_DESCRIPTOR\n                                       _TYPE_STORAGE_IMAGE;\nstorage_image_binding.descriptorCount =\n    k_max_bindless_resources;\nstorage_image_binding.binding = k_bindless_texture_binding\n                                + 1;\n```", "```cpp\nVkDescriptorSetLayoutCreateInfo layout_info = {\n    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO };\nlayout_info.bindingCount = pool_count;\nlayout_info.pBindings = vk_binding;\nlayout_info.flags = VK_DESCRIPTOR_SET_LAYOUT_CREATE\n                    _UPDATE_AFTER_BIND_POOL_BIT_EXT;\nVkDescriptorBindingFlags bindless_flags =\n    VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT |\n        VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT;\nVkDescriptorBindingFlags binding_flags[ 4 ];\nbinding_flags[ 0 ] = bindless_flags;\nbinding_flags[ 1 ] = bindless_flags;\nVkDescriptorSetLayoutBindingFlagsCreateInfoEXT\nextended_info{\n    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT\n        _BINDING_FLAGS_CREATE_INFO_EXT, nullptr };\nextended_info.bindingCount = pool_count;\nextended_info.pBindingFlags = binding_flags;\nlayout_info.pNext = &extended_info;\nvkCreateDescriptorSetLayout( vulkan_device, &layout_info,\n                             vulkan_allocation_callbacks,\n                             &vulkan_bindless\n                             _descriptor_layout );\n```", "```cpp\nVkDescriptorSetAllocateInfo alloc_info{\n    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO };\nalloc_info.descriptorPool = vulkan_bindless\n                            _descriptor_pool;\nalloc_info.descriptorSetCount = 1;\nalloc_info.pSetLayouts = &vulkan_bindless_descriptor\n                         _layout;\nvkAllocateDescriptorSets( vulkan_device, &alloc_info,\n                          &vulkan_bindless_descriptor_set\n                         );\n```", "```cpp\nif ( gpu.bindless_supported ) {\n    ResourceUpdate resource_update{\n        ResourceDeletionType::Texture,\n            texture->handle.index, gpu.current_frame };\n    gpu.texture_to_update_bindless.push( resource_update );\n}\n```", "```cpp\ngpu.link_texture_sampler( diffuse_texture_gpu.handle,\n                          diffuse_sampler_gpu.handle );\n```", "```cpp\nfor ( i32 it = texture_to_update_bindless.size - 1;\n  it >= 0; it-- ) {\n    ResourceUpdate& texture_to_update =\n        texture_to_update_bindless[ it ];\n   Texture* texture = access_texture( {\n                      texture_to_update.handle } );\n    VkWriteDescriptorSet& descriptor_write =\n        bindless_descriptor_writes[ current_write_index ];\n    descriptor_write = {\n        VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET };\n    descriptor_write.descriptorCount = 1;\n    descriptor_write.dstArrayElement =\n        texture_to_update.handle;\n    descriptor_write.descriptorType =\n        VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER;\n    descriptor_write.dstSet =\n        vulkan_bindless_descriptor_set;\n    descriptor_write.dstBinding =\n        k_bindless_texture_binding;\n    Sampler* vk_default_sampler = access_sampler(\n                                  default_sampler );\n    VkDescriptorImageInfo& descriptor_image_info =\n        bindless_image_info[ current_write_index ];\n    if ( texture->sampler != nullptr ) {\n        descriptor_image_info.sampler =\n        texture->sampler->vk_sampler;\n    }\n    else {\n        descriptor_image_info.sampler =\n        vk_default_sampler->vk_sampler;\n    }\ndescriptor_image_info.imageView = \n        texture->vk_format != VK_FORMAT_UNDEFINED ? \n        texture->vk_image_view : vk_dummy_texture-> \n        vk_image_view;\n    descriptor_image_info.imageLayout =\n        VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;\n    descriptor_write.pImageInfo = &descriptor_image_info;\n    texture_to_update.current_frame = u32_max;\n    texture_to_update_bindless.delete_swap( it );\n    ++current_write_index;\n}\n```", "```cpp\n#extension GL_EXT_nonuniform_qualifier : enable\n```", "```cpp\nlayout ( set = 1, binding = 10 ) uniform sampler2D global_textures[];\nlayout ( set = 1, binding = 10 ) uniform sampler3D global_textures_3d[];\n```", "```cpp\ntexture(global_textures[nonuniformEXT(texture_index)],\n        vTexcoord0)\n```", "```cpp\n#version 450\nlayout ( std140, binding = 0 ) uniform LocalConstants {\n    mat4        model;\n    mat4        view_projection;\n    mat4        model_inverse;\n    vec4        eye;\n    vec4        light;\n};\nlayout(location=0) in vec3 position;\nlayout(location=1) in vec4 tangent;\nlayout(location=2) in vec3 normal;\nlayout(location=3) in vec2 texCoord0;\nlayout (location = 0) out vec2 vTexcoord0;\nlayout (location = 1) out vec3 vNormal;\nlayout (location = 2) out vec4 vTangent;\nlayout (location = 3) out vec4 vPosition;\nvoid main() {\n    gl_Position = view_projection * model * vec4(position,\n                                                 1);\n    vPosition = model * vec4(position, 1.0);\n    vTexcoord0 = texCoord0;\n    vNormal = mat3(model_inverse) * normal;\n    vTangent = tangent;\n}\n```", "```cpp\nglslangValidator -V main.vert -o main.vert.spv\n```", "```cpp\nspirv-dis main.vert.spv\n```", "```cpp\n      OpCapability Shader\n%1 = OpExtInstImport \"GLSL.std.450\"\n      OpMemoryModel Logical GLSL450\n      OpEntryPoint Vertex %main \"main\" %_ %position\n      %vPosition %vTexcoord0 %texCoord0 %vNormal %normal\n      %vTangent %tangent\n      OpSource GLSL 450\n      OpName %main \"main\"\n```", "```cpp\nOpName %gl_PerVertex \"gl_PerVertex\"\nOpMemberName %gl_PerVertex 0 \"gl_Position\"\nOpMemberName %gl_PerVertex 1 \"gl_PointSize\"\nOpMemberName %gl_PerVertex 2 \"gl_ClipDistance\"\nOpMemberName %gl_PerVertex 3 \"gl_CullDistance\"\nOpName %_ \"\"\n```", "```cpp\nOpName %LocalConstants \"LocalConstants\"\nOpMemberName %LocalConstants 0 \"model\"\nOpMemberName %LocalConstants 1 \"view_projection\"\nOpMemberName %LocalConstants 2 \"model_inverse\"\nOpMemberName %LocalConstants 3 \"eye\"\nOpMemberName %LocalConstants 4 \"light\"\nOpName %__0 \"\"\n```", "```cpp\nOpMemberDecorate %LocalConstants 0 ColMajor\nOpMemberDecorate %LocalConstants 0 Offset 0\nOpMemberDecorate %LocalConstants 0 MatrixStride 16\nOpMemberDecorate %LocalConstants 1 ColMajor\nOpMemberDecorate %LocalConstants 1 Offset 64\nOpMemberDecorate %LocalConstants 1 MatrixStride 16\nOpMemberDecorate %LocalConstants 2 ColMajor\nOpMemberDecorate %LocalConstants 2 Offset 128\nOpMemberDecorate %LocalConstants 2 MatrixStride 16\nOpMemberDecorate %LocalConstants 3 Offset 192\nOpMemberDecorate %LocalConstants 4 Offset 208\nOpDecorate %LocalConstants Block\n```", "```cpp\nOpDecorate %__0 DescriptorSet 0\nOpDecorate %__0 Binding 0\n```", "```cpp\n%float = OpTypeFloat 32\n%v4float = OpTypeVector %float 4\n%uint = OpTypeInt 32 0\n%uint_1 = OpConstant %uint 1\n%_arr_float_uint_1 = OpTypeArray %float %uint_1\n%gl_PerVertex = OpTypeStruct %v4float %float\n                %_arr_float_uint_1 %_arr_float_uint_1\n%_ptr_Output_gl_PerVertex = OpTypePointer Output\n                            %gl_PerVertex\n%_ = OpVariable %_ptr_Output_gl_PerVertex Output\n```", "```cpp\n%LocalConstants = OpTypeStruct %mat4v4float %mat4v4float\n                  %mat4v4float %v4float %v4float\n%_ptr_Uniform_LocalConstants = OpTypePointer Uniform\n                               %LocalConstants\n%__0 = OpVariable %_ptr_Uniform_LocalConstants\n       Uniform\n```", "```cpp\nspirv::ParseResult parse_result{ };\nspirv::parse_binary( ( u32* )spv_vert_data,\n                       spv_vert_data_size, name_buffer,\n                       &parse_result );\nspirv::parse_binary( ( u32* )spv_frag_data,\n                       spv_frag_data_size, name_buffer,\n                       &parse_result );\n```", "```cpp\nstruct ParseResult {\n    u32 set_count;\n    DescriptorSetLayoutCreation sets[MAX_SET_COUNT];\n};\n```", "```cpp\nu32 spv_word_count = safe_cast<u32>( data_size / 4 );\nu32 magic_number = data[ 0 ];\nRASSERT( magic_number == 0x07230203 );\nu32 id_bound = data[3];\n```", "```cpp\nSpvOp op = ( SpvOp )( data[ word_index ] & 0xFF );\nu16 word_count = ( u16 )( data[ word_index ] >> 16 );\n```", "```cpp\ncase ( SpvOpEntryPoint ):\n{\n    SpvExecutionModel model = ( SpvExecutionModel )data[\n                                word_index + 1 ];\n    stage = parse_execution_model( model );\n    break;\n}\n```", "```cpp\ncase ( SpvOpDecorate ):\n{\n    u32 id_index = data[ word_index + 1 ];\n    Id& id= ids[ id_index ];\n    SpvDecoration decoration = ( SpvDecoration )data[\n                                 word_index + 2 ];\n    switch ( decoration )\n    {\n        case ( SpvDecorationBinding ):\n        {\n            id.binding = data[ word_index + 3 ];\n            break;\n        }\n        case ( SpvDecorationDescriptorSet ):\n        {\n            id.set = data[ word_index + 3 ];\n            break;\n        }\n    }\n    break;\n}\n```", "```cpp\ncase ( SpvOpTypeVector ):\n{\n    u32 id_index = data[ word_index + 1 ];\n    Id& id= ids[ id_index ];\n    id.op = op;\n    id.type_index = data[ word_index + 2 ];\n    id.count = data[ word_index + 3 ];\n    break;\n}\n```", "```cpp\ncase ( SpvOpTypeSampler ):\n{\n    u32 id_index = data[ word_index + 1 ];\n    RASSERT( id_index < id_bound );\n    Id& id= ids[ id_index ];\n    id.op = op;\n    break;\n}\n```", "```cpp\ncase ( SpvOpVariable ):\n{\n    u32 id_index = data[ word_index + 2 ];\n    Id& id= ids[ id_index ];\n    id.op = op;\n    id.type_index = data[ word_index + 1 ];\n    id.storage_class = ( SpvStorageClass )data[\n                         word_index + 3 ];\n    break;\n}\n```", "```cpp\nfor ( u32 id_index = 0; id_index < ids.size; ++id_index ) {\n    Id& id= ids[ id_index ];\n    if ( id.op == SpvOpVariable ) {\n```", "```cpp\nswitch ( id.storage_class ) {\n    case ( SpvStorageClassUniform ):\n    case ( SpvStorageClassUniformConstant ):\n    {\n```", "```cpp\nId& uniform_type = ids[ ids[ id.type_index ].type_index ];\nDescriptorSetLayoutCreation& setLayout =\nparse_result->sets[ id.set ];\nsetLayout.set_set_index( id.set );\nDescriptorSetLayoutCreation::Binding binding{ };\nbinding.start = id.binding;\nbinding.count = 1;\n```", "```cpp\nswitch ( uniform_type.op ) {\n    case (SpvOpTypeStruct):\n    {\n        binding.type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;\n        binding.name = uniform_type.name.text;\n        break;\n    }\n    case (SpvOpTypeSampledImage):\n    {\n        binding.type = VK_DESCRIPTOR_TYPE_COMBINED\n        _IMAGE_SAMPLER;\n        binding.name = id.name.text;\n        break;\n    }\n}\nsetLayout.add_binding_at_index( binding, id.binding );\n```", "```cpp\nGpuDevice::create_pipeline( const PipelineCreation&\n                            creation, const char*\n                            cache_path )\n```", "```cpp\nVkPipelineCache pipeline_cache = VK_NULL_HANDLE;\nVkPipelineCacheCreateInfo pipeline_cache_create_info {\n    VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO };\n```", "```cpp\nFileReadResult read_result = file_read_binary( cache_path,\n                                               allocator );\npipeline_cache_create_info.initialDataSize =\n  read_result.size;\npipeline_cache_create_info.pInitialData = read_result.data;\n```", "```cpp\nvkCreatePipelineCache( vulkan_device,\n                       &pipeline_cache_create_info,\n                       vulkan_allocation_callbacks,\n                       &pipeline_cache );\n```", "```cpp\nvkCreateGraphicsPipelines( vulkan_device, pipeline_cache,\n                           1, &pipeline_info,\n                           vulkan_allocation_callbacks,\n                           &pipeline->vk_pipeline );\n```", "```cpp\nvkCreateComputePipelines( vulkan_device, pipeline_cache, 1,\n                          &pipeline_info,\n                          vulkan_allocation_callbacks,\n                          &pipeline->vk_pipeline );\n```", "```cpp\nsizet cache_data_size = 0;\nvkGetPipelineCacheData( vulkan_device, pipeline_cache,\n                        &cache_data_size, nullptr );\nvoid* cache_data = allocator->allocate( cache_data_size, 64 );\nvkGetPipelineCacheData( vulkan_device, pipeline_cache,\n                        &cache_data_size, cache_data );\nfile_write_binary( cache_path, cache_data, cache_data_size );\n```", "```cpp\nvkDestroyPipelineCache( vulkan_device, pipeline_cache,\n                        vulkan_allocation_callbacks );\n```", "```cpp\nstruct VkPipelineCacheHeaderVersionOne {\n    uint32_t                       headerSize;\n    VkPipelineCacheHeaderVersion   headerVersion;\n    uint32_t                       vendorID;\n    uint32_t                       deviceID;\n    uint8_t                        pipeline\n                                   CacheUUID[VK_UUID_SIZE];\n}\n```", "```cpp\nVkPipelineCacheHeaderVersionOne* cache_header =\n    (VkPipelineCacheHeaderVersionOne*)read_result.data;\nif ( cache_header->deviceID == vulkan_physical\n     _properties.deviceID && cache_header->vendorID ==\n     vulkan_physical_properties.vendorID &&\n     memcmp( cache_header->pipelineCacheUUID,\n     vulkan_physical_properties.pipelineCacheUUID,\n     VK_UUID_SIZE ) == 0 ) {\n    pipeline_cache_create_info.initialDataSize =\n    read_result.size;\n    pipeline_cache_create_info.pInitialData =\n    read_result.data;\n}\nelse\n{\n    cache_exists = false;\n}\n```"]