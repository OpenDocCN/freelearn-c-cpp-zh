- en: Resource-Restricted Embedded Systems
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源受限的嵌入式系统
- en: Using a smaller embedded system such as a microcontroller (MCU) means having
    small amounts of RAM, CPU power, and storage. This chapter deals with planning
    for and making efficient use of limited resources taking into account the wide
    range of currently available MCUs and **System-on-Chip** (**SoC**) solutions.
    We will be considering the following aspects
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用较小的嵌入式系统，如微控制器（MCU），意味着拥有少量的RAM、CPU性能和存储。本章讨论了在考虑目前可用的广泛MCU和**片上系统**（**SoC**）解决方案时，如何规划和高效利用有限的资源。我们将考虑以下方面
- en: Selecting the right MCU for a project
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为项目选择合适的MCU
- en: Concurrency and memory management
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发性和内存管理
- en: Adding sensors, actuators, and network access
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加传感器、执行器和网络访问
- en: Bare-metal development versus real-time OSes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件开发与实时操作系统
- en: The big picture for small systems
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小型系统的整体图景
- en: When first confronted with a new project that requires the use of at least one
    type of MCU, it can seem like an overwhelming task to. As we saw in [Chapter 1](0ff8cac9-3155-45e1-af05-7005fc419dd6.xhtml), *What
    are Embedded Systems?*, there is a large number of MCUs to choose from, even if
    we limit ourselves to just those that have been released recently.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当首次面对一个需要至少一种类型MCU的新项目时，这可能看起来像是一项艰巨的任务。正如我们在[第1章](0ff8cac9-3155-45e1-af05-7005fc419dd6.xhtml)，“什么是嵌入式系统？”中看到的，即使我们只限制在最近发布的那些MCU中，可供选择的MCU数量也非常庞大。
- en: It may seem obvious to start by asking how many bits one needs, as in selecting
    between 8-bit, 16-bit, and 32-bit MCUs, or something as easy to quantify as clock
    speed, but these metrics are sometimes misleading and often don't lend themselves
    well to narrowing down the product selection. As it turns out, the parent categories
    are availability of sufficient I/O and the integrated peripherals to make the
    hardware happen in a lean and reliable way, as well as processing power tailored
    to the requirements faced at design-time and predicted to emerge throughout the
    product life-time.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎很明显，首先应该询问需要多少位，比如在8位、16位和32位MCU之间进行选择，或者像时钟速度这样容易量化的指标，但这些指标有时具有误导性，并且通常不利于缩小产品选择范围。实际上，父类别包括足够的I/O和集成外围设备，以实现硬件的精简和可靠运行，以及针对设计时面临的和要求在整个产品生命周期内预测出现的处理能力。
- en: 'So in more detail we need to answer questions like these:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要更详细地回答如下问题：
- en: '**Peripherals**: Which peripherals are needed to interact with the rest of
    the system?'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外围设备**: 需要哪些外围设备来与系统其他部分交互？'
- en: '**CPU**: What level of CPU power is needed to run the application code?'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPU**: 运行应用程序代码需要多少CPU性能？'
- en: '**Floating point**: Do we need hardware floating point support?'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**浮点数**: 我们需要硬件浮点数支持吗？'
- en: '**ROM**: How much ROM do we need to store the code?'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ROM**: 我们需要多少ROM来存储代码？'
- en: '**RAM**: How much RAM is required to run the code?'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RAM**: 运行代码需要多少RAM？'
- en: '**Power and thermals**: What are the electrical power and thermal limitations?'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**电源和热管理**: 电力和热限制是什么？'
- en: Each MCU family has its own strengths and weaknesses, though one of the most
    important factors to pick one MCU family over another the quality of its development
    tools. For hobby and other noncommercial projects, one would primarily consider
    the strength of the community and the available free development tools, while
    in the context of commercial projects one would also look at the support one could
    expect from the MCU manufacturer and possible third parties.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 每个MCU系列都有其自身的优点和缺点，尽管选择一个MCU系列而不是另一个最重要的因素是其开发工具的质量。对于爱好者和其他非商业项目，人们主要会考虑社区的力量和可用的免费开发工具，而在商业项目的背景下，人们还会考虑从MCU制造商和可能的第三方那里可以期望得到的支持。
- en: A key aspect of embedded development is in-system programming and debugging.
    Since programming and debugging are intertwined, we'll be looking at the corresponding
    interface options later to be able to identify what satisfies our requirements
    and constraints.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式开发的一个关键方面是在系统编程和调试。由于编程和调试是相互交织的，我们将在稍后查看相应的接口选项，以便能够确定哪些满足我们的需求和限制。
- en: A popular and powerful debugging interface has become synonymous to the underlying
    Joint Test Action Group (JTAG) IEEE standard 1149.1 and easily recognized by signals
    frequently labeled TDI, TDO, TCK, TMS and TRST, defining the aptly-named Test
    Action Port (TAP). The larger standard has since been expanded up to 1149.8 and
    not all versions apply to digital logic, so we'll limit our scope to 1149.1 and
    a reduced pin count version described under 1149.7\. For now we just require that
    at least one of the full-featured JTAG, SWD and UPDI interfaces be supported.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一个流行且强大的调试接口已经成为底层联合测试行动小组（Joint Test Action Group，JTAG）IEEE标准1149.1的同义词，并且可以通过经常标记为TDI、TDO、TCK、TMS和TRST的信号轻松识别，这些信号定义了恰如其分的测试行动端口（TAP）。该更大的标准已经扩展到1149.8，但并非所有版本都适用于数字逻辑，因此我们将我们的范围限制在1149.1和1149.7下描述的减少引脚数量的版本。目前，我们只需要至少支持一个全功能的JTAG、SWD和UPDI接口。
- en: Debugging MCU-based systems along with on-chip debugging, using both command-line
    tools and IDEs, is something that we will take an in-depth look at in [Chapter
    7](d8237285-fcb7-4bbc-84f3-e45568598865.xhtml), *Testing Resource-Limited Platforms*.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](d8237285-fcb7-4bbc-84f3-e45568598865.xhtml)中，我们将深入探讨基于MCU的系统调试以及片上调试，使用命令行工具和IDE进行调试。
- en: Finally, if we are going to be making products containing the chosen MCU for
    an active production phase of a few years, it's vital that we ensure the MCU availability
    (or that of compatible replacements) for at least that period. Reputable manufacturers
    provide product life cycle information as part of their supply chain management,
    with discontinuation notices being sent 1 to 2 years in advance, and recommendations
    for lifetime buys.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们打算在接下来的几年内生产包含所选MCU的产品，确保MCU（或兼容替代品）至少在此期间可用是至关重要的。信誉良好的制造商将产品生命周期信息作为其供应链管理的一部分提供，提前1到2年发送停产通知，并推荐终身购买。
- en: For many applications, it is hard to ignore the wide availability of cheap,
    powerful, and easy-to-use Arduino compatible boards, especially the popular ones
    designed around the AVR family of MCUs. Among these, the ATmega MCUs—the mega168/328,
    and in particular the mega1280/2560 variants—provide significant amounts of processing
    power, ROM, and RAM for both high-level functionality and the handling of data
    for input, control, and telemetry, as well as a differentiated but rich sets of
    peripherals and GPIO.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多应用来说，很难忽视那些价格低廉、功能强大且易于使用的Arduino兼容板的广泛可用性，尤其是围绕AVR系列MCU设计的流行板。在这些板中，ATmega
    MCU——包括mega168/328，尤其是mega1280/2560变体——为高级功能以及处理输入、控制和遥测数据提供了大量的处理能力、ROM和RAM，以及一套丰富且差异化的外设和GPIO。
- en: All of these aspects make prototyping exceedingly simple before even committing
    to a more definitive variant with lower specifications and (hopefully) better
    BOM cost. As an example, the ATmega2560 "MEGA" board is shown as follows, and
    we will look at other boards in more detail later in this chapter as we work through
    a number of examples on how to develop for the AVR platform.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方面都使得在承诺使用更低规格且（希望）更好的BOM成本更确定的变体之前进行原型制作变得极其简单。例如，ATmega2560 "MEGA"板如下所示，我们将在本章后面更详细地探讨其他板，当我们处理AVR平台上的多个示例时。
- en: '![](img/bf763d40-f2e9-4f8c-88ca-e25e963aa6c8.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bf763d40-f2e9-4f8c-88ca-e25e963aa6c8.png)'
- en: Generally, one would pick a number of MCUs that might work for the project,
    get the development boards, hook them up to the rest of the projected system components
    (often on their own development or breakout boards), and start developing the
    software for the MCU that will make everything work together.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，人们会选择一些可能适用于项目的MCU，获取开发板，将它们连接到项目系统的其他组件（通常是在它们自己的开发或分线板上），然后开始为MCU开发软件，使其协同工作。
- en: As more and more parts of the system become finalized, the number of development
    boards and bread-boarded components will dwindle until one reaches the point where
    one starts working on the final **printed circuit board** (**PCB**) layout. This
    will go through a number of iterations as well, as issues get ironed out, last-minute
    features are added, and the system as a whole is tested and optimized.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 随着系统越来越多的部分最终确定，开发板和面包板组件的数量将逐渐减少，直到达到开始工作于最终**印刷电路板**（**PCB**）布局的点。这一过程也将经历多次迭代，因为问题得到解决，最后时刻的功能被添加，整个系统被测试和优化。
- en: MCUs in such systems work on a physical level with the hardware, thus it is
    often a requirement to specify both hardware and software in tandem, if only because
    the software is so reliant on the hardware functionality. A common theme encountered
    in the industry is hardware modularity, either as small add-on PCBs with minimum
    added complexity, adding sensor or communication interfaces to devices such as
    temperature controllers and variable-frequency drives, or as full-fledged DIN
    rail modules connected to a common serial bus.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在此类系统中，微控制器（MCUs）在物理层面上与硬件协同工作，因此通常需要同时指定硬件和软件，至少因为软件如此依赖于硬件功能。在行业中遇到的一个常见主题是硬件模块化，无论是作为具有最小附加复杂性的小型附加PCB，向温度控制器和变频驱动器等设备添加传感器或通信接口，还是作为连接到公共串行总线的完整DIN轨道模块。
- en: Example – Machine controller for a laser cutter
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 - 激光切割机控制器
- en: 'One of the fastest and most accurate ways to cut a wide range of materials
    is using a high-power laser. With the price of carbon dioxide (CO[2]) having dropped
    sharply over the years, this has led to widespread use of affordable (cheap) laser
    cutters as shown in the following image:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用高功率激光是切割各种材料最快、最准确的方法之一。随着近年来二氧化碳（CO2）价格的急剧下降，这导致了经济实惠（便宜）的激光切割器被广泛使用，如下面的图片所示：
- en: '![](img/1db0afad-701b-4921-aa11-cebb4a9fb4e3.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1db0afad-701b-4921-aa11-cebb4a9fb4e3.png)'
- en: While it's perfectly possible to operate a laser cutter with nothing more than
    just a basic enclosure and the stepper motion control board that move the head
    across the machin bed, from a usability and safety point of view, this is not
    desirable. Still, many of the cheap laser cutters one can purchase online, however, do
    not come with any safety or usability features whatsoever.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然完全可以用一个基本的机罩和移动头部跨越机床的步进运动控制板来操作激光切割机，但从可用性和安全性的角度来看，这并不理想。然而，许多在网上可以购买的廉价激光切割机，然而，没有任何安全或可用性功能。
- en: Functional specification
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能规范
- en: 'To complete the product, we need to add a control system that uses sensors
    and actuators to monitor and control the state of the machine, ensuring that it
    is always in a safe state and shutting down the laser beam if necessary. This
    means protecting access to each of the following three sections:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成产品，我们需要添加一个控制系统，该系统使用传感器和执行器来监控和控制机器的状态，确保它始终处于安全状态，并在必要时关闭激光束。这意味着要保护以下三个部分的访问：
- en: '![](img/897f1ff6-32a8-4358-b81d-d2bdd82b8d69.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/897f1ff6-32a8-4358-b81d-d2bdd82b8d69.png)'
- en: The cutting beam is usually generated by a CO[2] laser, a type of gas laser
    that was invented in 1964\. The application of a high voltage causes current flow
    and thereby excitement of the gas molecules in the bore that make up the gain
    medium, ultimately resulting in the formation of a coherent beam of **long-wavelength
    infrared** (**LWIR**) or IR-C, light at a wavelength of 9.4 or 10.6 µm.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 切割光束通常由二氧化碳（CO2）激光器产生，这是一种在1964年发明的气体激光器。高压的应用导致电流流动，从而激发构成增益介质的腔体中的气体分子，最终形成波长为9.4或10.6微米的**长波红外**（LWIR）或IR-C光的有序光束。
- en: One characteristic of LWIR is that it is strongly absorbed by a large number
    of materials, so that it can be used for engraving, cutting, and even surgery
    on tissues as the water in biological tissues efficiently absorbs the laser beam.
    This also makes it obvious why even brief exposure of one's skin to a CO[2] laser's
    beam is extremely dangerous.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: LWIR的一个特点是它被大量材料强烈吸收，因此它可以用于雕刻、切割，甚至在组织上进行手术，因为生物组织中的水有效地吸收了激光束。这也清楚地说明了为什么人体皮肤对二氧化碳激光束的短暂暴露是极其危险的。
- en: To achieve safe operation, exposure to laser light must be inhibited by locking
    the enclosure during normal operation, deactivating the laser power supply, and
    closing a beam shutter or preferably a combination of these measures when any
    of the interlocks is opened or any other safety condition is no longer satisfied.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现安全操作，必须在正常操作期间锁定机罩，关闭激光电源，并在任何联锁打开或任何其他安全条件不再满足时关闭光束快门或最好是这些措施的组合。
- en: 'For example, temperature limits have to be upheld: most CO[2] lasers comprise
    of water-cooled gas discharge tube, which can quickly crack or bend in case of
    a cooling fault. What''s more, the cutting process creates irritating or toxic
    fumes that need to be continuously removed from the enclosure so as not to contaminate
    the optics and exit into the environment when the lid is opened.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，必须遵守温度限制：大多数二氧化碳激光器由水冷气体放电管组成，如果出现冷却故障，可能会迅速开裂或弯曲。更重要的是，切割过程会产生令人烦恼或有毒的烟雾，需要不断从封闭空间中移除，以免在打开盖子时污染光学器件并排放到环境中。
- en: These requirements necessitate that we monitor cooling water flow and temperature,
    air flow for the exhaust, and the air flow resistance (pressure drop over mass
    flow) of over the exhaust filter.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这些要求需要我们监控冷却水的流量和温度、排气空气流量以及排气过滤器上的空气流量阻力（质量流量压降）。
- en: Finally, we also want to make it convenient to use the laser cutter and avoid
    having to "bring your own device" to process the design in a machine-specific
    way, then convert it and upload it to the stepper motion controller board via
    USB. Instead, we want to load the design project from an SD card or USB stick
    and use a simple LCD and buttons to set options.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还想使激光切割机易于使用，避免需要“自带设备”以特定方式处理设计，然后将其转换并上传到步进运动控制器板。相反，我们希望从SD卡或USB棒加载设计项目，并使用简单的LCD和按钮设置选项。
- en: The design requirements
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计要求
- en: 'With the earlier requirements in mind, we can formulate a list of features
    needed for the control system:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到早期要求，我们可以制定出控制系统所需的功能列表：
- en: 'Operator safety:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作员安全：
- en: Interlock switches on access panels (closed with the panel closed)
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存取面板上的互锁开关（面板关闭时关闭）
- en: Locking mechanism (mechanically locking access panel; redundant)
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁定机制（机械锁定存取面板；冗余）
- en: Emergency stop
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 紧急停止
- en: 'Laser cooling:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 激光冷却：
- en: Pump relay
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泵继电器
- en: Temperature sensor in water tank (cooling capacity, inlet temperature)
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 水箱中的温度传感器（冷却能力，进口温度）
- en: Temperature sensor on valve cooling exhaust (mantle temperature)
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阀门冷却排气中的温度传感器（套管温度）
- en: Flow sensor (water flow speed; redundant)
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流量传感器（水流速度；冗余）
- en: 'Air exhaust:'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空气排气：
- en: Fan relay
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 风扇继电器
- en: Air filter status (differential pressure sensor)
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空气过滤器状态（差压传感器）
- en: Fan speed (RPM)
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 风扇速度（RPM）
- en: 'Laser module:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 激光模块：
- en: Laser power relay
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 激光功率继电器
- en: Beam shutter (redundant)
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 光束快门（冗余）
- en: User interface
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户界面
- en: 'Alert indicators for:'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 警报指示器：
- en: Panel interlock
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面板互锁
- en: Air filter condition
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空气过滤器状况
- en: Fan status
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 风扇状态
- en: Pump status
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泵状态
- en: Water temperature
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 水温
- en: 'Indicator LEDs for:'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指示LED灯：
- en: Standby
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待
- en: Starting
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动
- en: Operation
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作
- en: Emergency stop
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 紧急停止
- en: Cool down
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 冷却
- en: 'Communication:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通信：
- en: USB communication with stepper board (UART)
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与步进板进行USB通信（UART）
- en: 'Motion control: generate stepper motor instructions'
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运动控制：生成步进电机指令
- en: Read files from SD card/USB stick
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从SD卡/USB棒读取文件
- en: Accept files over Ethernet/Wi-Fi
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过以太网/Wi-Fi接受文件
- en: NFC reader to identify users
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: NFC读卡器以识别用户
- en: Implementation-related choices
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与实现相关的选择
- en: 'As pointed out at the beginning of this chapter, mid-range MCUs are currently
    capable of providing the resources to satisfy most, if not all of our design requirements.
    So one of the tough questions is what we''ll be spending our money on: hardware
    components or software development? Imponderabilities aside, we''ll now take a
    closer look at three candidate solutions:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章开头所指出的，中端微控制器目前能够提供满足我们大部分，如果不是全部设计要求所需的资源。因此，一个棘手的问题是我们将把钱花在哪里：硬件组件还是软件开发？抛开这些难以确定的因素，我们现在将更详细地研究三个候选解决方案：
- en: A single mid-range AVR MCU board (ATmega2560)
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一块单的中端AVR微控制器板（ATmega2560）
- en: A higher-end Cortex-M3 MCU board (SAM3X8E)
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一块高端Cortex-M3微控制器板（SAM3X8E）
- en: A tandem of mid-range MCU board and an SBC with OS
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一套中端微控制器板和带有操作系统的单板计算机
- en: We're pretty close to meeting hte design requirements with just an Arduino Mega
    (ATmega2560), as the first five sections require little in terms of CPU speed,
    just a number of digital input and output pins and a few analog ones depending
    on the exact sensors we'll be using or at most a peripheral interface to make
    use of (for example, for MEMS pressure sensors).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用Arduino Mega（ATmega2560）就几乎能满足设计要求，因为前五个部分对CPU速度的要求不高，只需要一些数字输入和输出引脚，以及一些模拟引脚，具体取决于我们将使用或最多使用的外围接口（例如，用于MEMS压力传感器）。
- en: The challenge starts with motion control feature under communications in the
    previous feature list, where we suddenly have to convert a **vector graphics file**
    (**.svg**) to a series of stepper commands. This is a compound problem of data
    transfer, file parsing, path generation, and what is known in the robotic world
    as inverse kinematics. USB communications can also be problematic for our 8-bit
    MCU, mostly because of peak processor loads coinciding with timeouts for USB endpoint
    communication or UART RX buffer register handling.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战始于上一个功能列表中的通信功能下的运动控制功能，我们突然需要将**矢量图形文件**（**.svg**）转换为一系列步进器命令。这是一个数据传输、文件解析、路径生成和机器人世界中所称的反向运动学问题的复合问题。USB通信也可能对我们8位MCU造成问题，主要是因为峰值处理器负载与USB端点通信超时或UART
    RX缓冲寄存器处理超时同时发生。
- en: 'The key is knowing when to change gears. Motion control is time critical as
    it''s tied to the inertia of the physical world. Additionally, we''re constrained
    by the processing and bandwidth resources of our controller to make control and
    data transfers, buffering, and ultimately the processing and output generation
    itself happen. As a general pattern, more capable internal or external peripherals
    can relax timing requirements by handling events and memory transactions themselves,
    reducing context switching and processing overhead. Here''s an incomplete list
    of such considerations:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于知道何时换挡。运动控制是时间敏感的，因为它与物理世界的惯性相关联。此外，我们受限于控制器的处理和带宽资源，以进行控制和数据传输、缓冲以及最终的处理和输出生成。作为一个一般模式，更强大的内部或外部外围设备可以通过处理事件和内存事务来放宽时序要求，减少上下文切换和处理开销。以下是一个此类考虑的不完整列表：
- en: Simple UART requires collecting every byte upon RX Complete (RXC). Failure to
    do so results in data loss, as indicated by the DOR flag. A few controllers such
    as ATmega8u2 through ATmega32u4 provide native hardware flow control via RTS/CTS
    lines, which can prevent USB-UART converters such as PL2303 and FT232 from sending,
    forcing them to do the buffering instead until UDR is conveniently emptied again.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的UART需要在RX Complete（RXC）时收集每个字节。未能这样做会导致数据丢失，如DOR标志所示。一些控制器，如ATmega8u2到ATmega32u4，通过RTS/CTS线路提供本机硬件流控制，这可以防止PL2303和FT232等USB-UART转换器发送数据，迫使它们在UDR方便地再次清空之前进行缓冲。
- en: Dedicated USB host peripherals such as the MAX3421 are connected via SPI and
    effectively remove USB timing requirements for mass storage integration.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专用USB主机外围设备，如MAX3421，通过SPI连接，有效地消除了大规模存储集成对USB时序的要求。
- en: UART aside, network communication peripherals are inherently buffered in software
    due to the complexity of the layer stack. For Ethernet, the W5500 is an attractive
    solution.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了UART之外，网络通信外围设备由于层堆栈的复杂性，在软件中固有地进行了缓冲。对于以太网，W5500是一个有吸引力的解决方案。
- en: It sometimes makes sense to add another smaller MCU that independently handles
    I/O and pattern generation while implementing an interface of our choice – e.g.
    serial or parallel. This is already the case with some Arduino boards featuring
    an ATmega16u2 for USB serial conversion.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时候，在实现我们选择的接口（例如串行或并行）的同时添加另一个较小的MCU，独立处理I/O和模式生成是有意义的。这已经在一些具有ATmega16u2的Arduino板上成为现实，用于USB串行转换。
- en: The NFC reader feature requirement calls for **Near-Field Communication** (**NFC**,
    a subset of RFID) to prevent unauthorized use of the laser cutter, which would
    add the biggest burden of all. Not due to the communicating with the NFC reader
    itself, but due to the increase in code size and CPU requirements to handle cryptography
    with certificates depending on the security level chosen. We would also need a
    secure place to store the certificates which usually bumps up MCU specs.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: NFC读卡器功能需求要求使用**近场通信**（**NFC**，RFID的一个子集）来防止激光切割机的未经授权使用，这将带来最大的负担。并非因为与NFC读卡器的通信本身，而是由于代码大小和CPU要求的增加，以处理依赖于所选安全级别的证书的加密。我们还需要一个安全的地方来存储证书，这通常会增加MCU的规格。
- en: Now we are at the point where we consider the more advanced options. The simpler
    ATmega2560 remains a great fit with its large amount of GPIO and can read SD cards
    over SPI along with communicating with an external integrated ethernet chip. However,
    the computationally or memory intensive tasks in motion control and NFC reader
    feature list would likely overburden the MCU or lead to convoluted "optimized"
    solutions with inferior maintainability if one were to try.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经到了考虑更高级选项的阶段。简单的ATmega2560仍然是一个很好的选择，因为它有大量的GPIO，可以通过SPI读取SD卡，并与外部集成以太网芯片通信。然而，在运动控制和NFC读取器功能列表中的计算密集型或内存密集型任务可能会过载MCU，或者如果尝试优化，可能会导致复杂且维护性差的解决方案。
- en: Upgrading the MCU to an ARM Cortex-M3 such as found on the Arduino Due development
    board, would likely resolve all those bottlenecks. It would preserve the large
    number of GPIO we got accustomed to on the ATmega2560, while increasing CPU performance
    significantly. The stepper drive patterns can be generated on the MCU, which also
    presents with native USB support, along with other advanced peripherals (USART,
    SPI and I2C and HSMCI, which also have DMA).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 将MCU升级到Arduino Due开发板上找到的ARM Cortex-M3，可能会解决所有这些瓶颈。它将保留我们在ATmega2560上习惯的大量GPIO，同时显著提高CPU性能。步进驱动模式可以在MCU上生成，它还提供了本地的USB支持，以及其他高级外设（USART、SPI和I2C以及HSMCI，这些也有DMA）。
- en: 'A basic NFC tag reader could be connected via a UART, SPI, or I2C, and this
    design choice would lead to a system as shown:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一个基本的NFC标签读取器可以通过UART、SPI或I2C连接，这个设计选择将导致一个如下的系统：
- en: '![](img/a97fac06-4f02-4255-b48c-c2ba8fb95b60.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a97fac06-4f02-4255-b48c-c2ba8fb95b60.png)'
- en: The third embodiment involving an SBC would again make use of the ATmega2560
    and add a low-powered SBC running an OS. This SBC would handle any CPU-intensive
    tasks, Ethernet and Wi-Fi connectivity, USB (host) tasks, and so on. It would
    communicate with the ATmega side via a UART, possibly adding a digital isolator
    or level shifter in between the boards to accommodate the 3.3V (SBC) and 5V TTL
    (Atmega) logic levels.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种涉及SBC的方案将再次使用ATmega2560，并添加一个低功耗的SBC运行操作系统。这个SBC将处理任何CPU密集型任务、以太网和Wi-Fi连接、USB（主机）任务等。它将通过UART与ATmega侧通信，可能需要在板之间添加数字隔离器或电平转换器，以适应3.3V（SBC）和5V
    TTL（Atmega）逻辑电平。
- en: 'Choosing the SBC + MCU solution would substantially change the software challenges
    but only slightly reorganize our system on the hardware side. This would look
    as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 选择SBC + MCU解决方案将极大地改变软件挑战，但在硬件方面只会稍微重新组织我们的系统。这看起来如下：
- en: '![](img/07063017-8a6b-4a0e-98ce-25e7f373a6fa.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/07063017-8a6b-4a0e-98ce-25e7f373a6fa.png)'
- en: As with most development processes, there are only a few absolute answers, and
    many solutions pass functional requirements as *good enough* after trade-offs
    between power usage, complexity, and maintenance requirements affecting the final
    design choice.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数开发过程一样，只有少数绝对答案，许多解决方案在权衡功耗、复杂性和影响最终设计选择的维护要求后，将功能需求视为“足够好”。
- en: In this particular example, one could choose either the higher-end single or
    dual-board solution, and it would most likely entail the same amount of effort
    to satisfy the requirements. One of the main differences would be that the OS-based
    solution adds the need to perform frequent OS updates, on account of it being
    a network-connected system running a full-blown OS whereas embedded ethernet controllers
    with offloaded hardwired TCP/IP stack and memories tend to be more robust and
    proven.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的例子中，可以选择高端的单板或双板解决方案，并且很可能会需要相同数量的努力来满足要求。主要区别之一是，基于操作系统的解决方案需要频繁更新操作系统，因为它是一个运行完整操作系统的网络连接系统，而具有卸载的硬编码TCP/IP堆栈和内存的嵌入式以太网控制器则通常更稳健且经过验证。
- en: The Cortex-M3-based option (or the even faster Cortex-M4) would feature just
    our own code, and thus would be unlikely to have any common security issues that
    could be easily targeted. We wouldn't be off the hook for maintenance, but our
    code would be small enough to validate and read through in its entirety, with
    the only letdown that the Arduino Due design fails to break out the pins for RMII
    to hook up an external Ethernet PHY, discouraging the use of its internal Ethernet
    MAC.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Cortex-M3的选项（或更快的Cortex-M4）将仅包含我们自己的代码，因此不太可能存在任何容易被攻击的常见安全问题。我们不会摆脱维护的责任，但我们的代码足够小，可以完全验证和阅读，唯一的遗憾是Arduino
    Due的设计未能将引脚断开以连接外部以太网PHY，这阻碍了其内部以太网MAC的使用。
- en: 'Running down the checklist we put together at the beginning of this chapter,
    but this time with the ATmega2560 + SBC and application in mind, gives us the
    following distribution of duties:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 检查我们在本章开头制定的清单，但这次考虑到ATmega2560 + SBC和应用，我们得到以下任务分配：
- en: '**Peripherals**: The MCU side will mostly need GPIO, some analog (ADC) inputs,
    Ethernet, USB, along with SPI and/or I2C.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外围设备**: MCU端将主要需要GPIO、一些模拟（ADC）输入、以太网、USB，以及SPI和/或I2C。'
- en: '**CPU**: The required MCU performance is time-critical but minor, except for
    when we need to do the processing of the vector path elements into stepper instructions.
    The SBC side can be sophisticated as long as enough commands can be queued for
    MCU-side execution and time-critical interaction is avoided.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPU**: 所需的MCU性能是时间敏感的但微不足道的，除了当我们需要将矢量路径元素转换为步进指令时。只要可以为MCU端执行排队足够的命令，并且避免时间敏感的交互，SBC端可以很复杂。'
- en: '**Floating point**: The stepper instruction conversion algorithm on an MCU
    executes substantially faster if we have hardware floating point support. The
    length and time scales involved may make fixed point arithmetic feasible, relaxing
    this requirement.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**浮点数**: 如果我们有硬件浮点支持，MCU上的步进指令转换算法将执行得更快。涉及的长度和时间尺度可能使得定点运算可行，从而放宽这一要求。'
- en: '**ROM**: The entire MCU code will likely fit into a few kilobytes since it''s
    not very complex. The SBC code will be larger by orders of magnitude just by invoking
    high-level libraries to provide the desired functionality but this will be more
    than offset by the similarly scaled mass storage and processing capabilities.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ROM**: 整个MCU代码可能只需几KB，因为它并不复杂。SBC代码会因为调用高级库以提供所需功能而大得多，但这将被类似规模的大容量存储和处理能力所超过。'
- en: '**RAM**: A few KB of SRAM on the MCU should suffice. The stepper instruction
    conversion algorithm may require modifications to fit into the SRAM limitations
    with its buffering and processing data requirements. In a worst-case scenario,
    buffers can be downsized.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RAM**: MCU上只需要几KB的SRAM就足够了。步进指令转换算法可能需要修改以适应SRAM的限制，包括缓冲和处理数据的要求。在最坏的情况下，缓冲区可以缩小。'
- en: '**Power and thermals**: In the light of the laser cutter system''s power needs
    and cooling system, we have got no significant power or thermal limitations. The
    section containing the control system also houses the main power supply and is
    already equipped with an appropriately sized cooling fan.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**电源和散热**: 考虑到激光切割系统的功率需求和冷却系统，我们没有明显的电源或散热限制。包含控制系统的部分还包含主电源，并且已经配备了适当尺寸的冷却风扇。'
- en: It's important to note at this point that although we realized the complexity
    and requirements of the task at hand sufficiently to draw conclusions leading
    us to a selection of hardware components, the aspects of how to achieve them in
    detail are still left to the software developer.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，重要的是要注意，尽管我们已经充分认识到手头任务的复杂性和要求，足以得出结论，引导我们选择硬件组件，但如何详细实现这些方面仍然留给软件开发者。
- en: For example, we could define our own data structures and formats and implement
    the machine-specific path generation and motion control ourselves, or adopt a
    (RS-274) G-code intermediate format which has been well-established in numerical
    control applications for several decades, and that lends itself well to generating
    motion control commands. G-code and has also found widespread acceptance in the
    diy hardware community, expecially for FDM 3D printing.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以定义自己的数据结构和格式，并自行实现针对特定机器的路径生成和运动控制，或者采用（RS-274）G代码中间格式，该格式已在数控应用中确立了几十年，非常适合生成运动控制命令。G代码在DIY硬件社区也得到了广泛接受，尤其是在FDM
    3D打印方面。
- en: 'One noteworthy mature open source implementation of G-code based motion control
    is GRBL, introduced as:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一个值得注意的成熟开源G代码运动控制实现是GRBL，介绍如下：
- en: Grbl is a free, open source, high performance software for controlling the motion
    of machines that move, that make things, or that make things move, and will run
    on a straight Arduino. If the maker movement was an industry, Grbl would be the
    industry standard.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Grbl是一个免费、开源、高性能的软件，用于控制移动机器的运动，制造物品或使物品移动，并且可以在Arduino上运行。如果创客运动是一个行业，Grbl将是行业标准。
- en: --https://github.com/gnea/grbl
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: --https://github.com/gnea/grbl
- en: Most likely we'll have to add halt and emergency stop features for different
    violations of our safety checks. While temperature excursions or a clogged filter
    would preferably just halt the laser cutter and permit resuming the job with the
    issues resolved, an interlock tripped by opening the enclosure must result in
    immediate shutdown of the laser, even without finishing the last command for a
    path segment and motion.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能我们需要为我们的安全检查的不同违规行为添加停止和紧急停止功能。虽然温度异常或堵塞的过滤器可能只是停止激光切割机，并允许在问题解决后继续工作，但由打开外壳触发的互锁必须导致激光立即关闭，即使没有完成路径段和运动的最后一条命令。
- en: The choice to modularize the motion control task and produce G-code for it has
    benefits beyond the availability of proven implementations, allowing us to easily
    add usability features like manual control for setup and calibration as well as
    testability using previously generated, human-readable codes on the machine side
    just as inspection on the output of our file interpretation and path generation
    algorithms.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 将运动控制任务模块化并为其生成G-code的选择，除了提供经过验证的实现之外，还有其他好处，使我们能够轻松添加诸如手动控制设置和校准以及使用在机器侧预先生成、可读的代码进行测试等可用性功能，就像检查我们的文件解释和路径生成算法的输出一样。
- en: With the list of requirements, the initial design completed, and a deepened
    understanding of how we are going to achieve our goals, the next step would be
    to obtain a development board (or boards) with the chosen MCU and/or SoC, along
    with any peripherals so that one can get started on developing the firmware and
    integrating the system.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成需求列表、初步设计和对如何实现目标的深入理解之后，下一步将是获取带有所选MCU和/或SoC以及任何外围设备的发展板（或多个板），以便开始开发固件和集成系统。
- en: While the full implementation of the machine control system as described in
    this example is beyond the scope of this book, an in-depth understanding of the
    development for both microcontroller and SBC target varieties will be strived
    for in the remainder of this chapter and [Chapter 6](7d5d654f-a027-4825-ab9e-92c369b576a8.xhtml),
    *Testing OS-Based Applications*, [Chapter 8](4416b2de-d86a-4001-863d-b167635a0e10.xhtml),
    *Example - Linux-Based Infotainment* System, and [Chapter 11](c90e29ad-2e13-4838-a9c2-885209717513.xhtml),
    *Developing for Hybrid SoC/FPGA Systems*, respectively.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本例中描述的机器控制系统的完整实现超出了本书的范围，但本章剩余部分以及[第6章](7d5d654f-a027-4825-ab9e-92c369b576a8.xhtml)、“基于操作系统的应用程序测试”，[第8章](4416b2de-d86a-4001-863d-b167635a0e10.xhtml)、“示例
    - 基于Linux的信息娱乐系统”，以及[第11章](c90e29ad-2e13-4838-a9c2-885209717513.xhtml)、“为混合SoC/FPGA系统开发”，将努力深入理解针对微控制器和SBC目标类型的开发。
- en: Embedded IDEs and frameworks
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌入式IDE和框架
- en: While the application development for SoCs tends to be quite similar to desktop
    and server environments, as we saw in the previous chapter, MCU development requires
    a far more intimate knowledge of the hardware that one is developing for, sometimes
    down to the exact bits to set in a particular register.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然SoC的应用程序开发通常与桌面和服务器环境相似，正如我们在上一章中看到的，但MCU开发需要对所开发硬件的深入了解，有时甚至需要知道在特定寄存器中设置的确切位。
- en: There exist some frameworks that seek to abstract away such details for particular
    MCU series, so that one can develop for a common API without having to worry about
    how it is implemented on a specific MCU. Of these, the Arduino framework is the
    most well-known outside of industrial applications, though there are also a number
    of commercial frameworks that are certified for production use.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一些框架试图为特定MCU系列抽象出这些细节，以便可以在不担心如何在特定MCU上实现的情况下为通用API开发。在这些框架中，Arduino框架在工业应用之外最为知名，尽管也有许多经过认证可用于生产使用的商业框架。
- en: Frameworks such as the **Advanced Software Framework** (**ASF**) for AVR and
    SAM MCUs can be used with a variety of IDEs, including Atmel Studio, Keil µVision,
    and IAR Embedded Workbench.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对于AVR和SAM MCU，可以使用各种IDE，例如Atmel Studio、Keil µVision和IAR嵌入式工作台的高级软件框架（**ASF**）。
- en: 'A non-exhaustive list of popular embedded IDEs follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些流行的嵌入式IDE的非详尽列表：
- en: '| **Name** | **Company** | **License** | **Platforms** | **Notes** |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **公司** | **许可** | **平台** | **备注** |'
- en: '| Atmel Studio | Microchip | Proprietary | AVR, SAM (ARM Cortex-M). | Originally
    developed by Atmel before being bought by Microchip. |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| Atmel Studio | Microchip | 专有 | AVR, SAM (ARM Cortex-M)。 | 原先由Atmel开发，后被Microchip收购。
    |'
- en: '| µVision | Keil (ARM) | Proprietary | ARM Cortex-M, 166, 8051, 251. | Part
    of the **Microcontroller Development Kit** (**MDK**) toolchain. |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| µVision | Keil (ARM) | 专有 | ARM Cortex-M, 166, 8051, 251. | **微控制器开发工具包**（**MDK**）的一部分。|'
- en: '| Embedded Workbench | IAR | Proprietary | ARM Cortex-M, 8051, MSP430, AVR,
    Coldfire, STM8, H8, SuperH, etc. | Separate IDE for each MCU architecture. |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| Embedded Workbench | IAR | 专有 | ARM Cortex-M, 8051, MSP430, AVR, Coldfire,
    STM8, H8, SuperH等。 | 每个MCU架构都有独立的IDE。|'
- en: '| MPLAB X | Microchip | Proprietary | PIC, AVR. | Uses the Java-based NetBeans
    IDE as foundation. |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| MPLAB X | Microchip | 专有 | PIC, AVR。 | 以基于Java的NetBeans IDE为基础。|'
- en: '| Arduino | Arduino | GPLv2 | Some AVR and SAM MCUs (extendable). | Java-based
    IDE. Only supports its own C dialect language. |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| Arduino | Arduino | GPLv2 | 一些AVR和SAM MCU（可扩展）。 | 基于Java的IDE。仅支持其自己的C方言语言。|'
- en: The main goal of an IDE is to integrate the entire workflow into a single application,
    from writing the initial code to programming the MCU memory with the compiled
    code and debugging the application while it runs on the platform.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: IDE的主要目标是整合整个工作流程到一个单一的应用程序中，从编写初始代码到使用编译后的代码编程MCU内存，并在平台上运行时调试应用程序。
- en: Whether to use a full IDE is a matter of preference, however. All of the essential
    features are still there when using a basic editor and the tools from the command
    line, although frameworks such as the ASF are written to deeply integrate with
    IDEs.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 是否使用完整的IDE是一个个人喜好问题，然而。当使用基本编辑器和命令行工具时，所有基本功能仍然存在，尽管像ASF这样的框架是为了与IDE深度集成而编写的。
- en: One of the main advantages of the popular Arduino framework is that it has more
    or less standardized an API for various MCU peripherals and other functionality
    that is supported across an ever-growing number of MCU architectures. Coupled
    with the open source nature of the framework, it makes for an attractive target
    for a new project. This is particularly attractive when it comes to prototyping,
    courtesy of a large number of libraries and drivers written for this API.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 流行Arduino框架的主要优势之一是它或多或少地标准化了各种MCU外设和其他功能的应用程序编程接口（API），这些功能支持越来越多的MCU架构。结合框架的开源特性，它成为新项目的吸引目标。这在原型设计方面尤其吸引人，得益于为该API编写的众多库和驱动程序。
- en: Unfortunately, the Arduino IDE is unfortunately focused purely on a stripped-down
    dialect of the C programming language, despite its core libraries making widespread
    use of C++. Still this enables us to integrate just the libraries into our own
    embedded C++ projects, as we will see later in this chapter.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Arduino IDE不幸地专注于C编程语言的简化版本，尽管其核心库广泛使用C++。尽管如此，这使我们能够将库集成到我们自己的嵌入式C++项目中，正如我们将在本章后面看到的那样。
- en: Programming MCUs
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编程MCU
- en: After we have compiled our code for the target MCU, the binary image needs to
    be written to a controller memory prior to execution and debugging. In this section
    we will look at the varied ways in which this can be accomplished. These days
    only factory-side programming is done with test sockets, or better yet at the
    wafer level before a known good die is bonded to a leadframe and encapsulated.
    Surface-mount parts already rule out easy removal of an MCU for (repeated) programming.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们为目标MCU编译代码之后，需要在执行和调试之前将二进制映像写入控制器内存。在本节中，我们将探讨实现这一目标的多种方式。如今，只有通过测试插座进行工厂侧编程，或者在已知良好的晶圆上将其粘接到引线框架并封装之前，才在晶圆级别进行编程。表面贴装组件已经排除了（重复）编程时轻松移除MCU的可能性。
- en: A number of (frequently vendor-specific) options for in-circuit programming
    exist, distinguished by the peripherals they use and the memories they affect.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 存在许多（通常是供应商特定的）在电路编程选项，这些选项根据它们使用的外设和影响的内存来区分。
- en: So a pristine MCU often needs to be programmed using an external programming
    adapter. These generally work by setting the pins of the MCU so that it enters
    programming mode, after which the MCU accepts the data stream containing the new
    ROM image.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个原始的MCU通常需要使用外部编程适配器进行编程。这些适配器通常通过设置MCU的引脚，使其进入编程模式，然后MCU接受包含新ROM映像的数据流。
- en: Another option that is commonly used is to add a boot loader to the first section
    of the ROM, which allows the MCU to program itself. This works by having the boot
    loader check on startup whether it should switch to programming mode or continue
    loading the actual program, placed right after the boot loader section.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常用的选项是在 ROM 的第一部分添加引导加载程序，这允许微控制器自行编程。这是通过引导加载程序在启动时检查是否应该切换到编程模式或继续加载实际程序来实现的，该程序位于引导加载程序部分之后。
- en: Memory programming and device debugging
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存编程和设备调试
- en: 'External programming adapters often utilize dedicated interfaces and associated
    protocols which permit programming and debugging of the target device. Protocols
    with which one can program an MCU include the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 外部编程适配器通常使用专用接口和相关协议，这些协议允许对目标设备进行编程和调试。可以用于编程 MCU 的协议包括以下几种：
- en: '| **Name** | **Pins** | **Features** | **Description** |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **引脚** | **特性** | **描述** |'
- en: '| **SPI (ISP)** | **4** | program | **Serial Peripheral Interface** (**SPI**),
    used with older AVR MCUs to access its Serial Programmer mode (**In-circuit Serial
    Programming** (**ISP**)). |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| **SPI (ISP)** | **4** | 编程 | **串行外围设备接口** (**SPI**), 与较老的 AVR 微控制器一起使用以访问其串行编程器模式
    (**在电路串行编程** (**ISP**)). |'
- en: '| **JTAG** | **5** | program debug'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '| **JTAG** | **5** | 编程调试'
- en: boundary | Dedicated, industry-standard on-chip interface for programming and
    debugging support. Supported on AVR ATxmega devices. |
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 边界 | 专用、行业标准片上编程和调试支持接口。支持 AVR ATxmega 设备。 |
- en: '| **UPDI** | **1** | program debug | The **Unified Programming and Debug Interface**
    (**UDPI**) used with newer AVR MCUs, including ATtiny devices. It''s a single-wire
    interface that''s the successor to the two-wire PDI found on ATxmega devices.
    |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| **UPDI** | **1** | 编程调试 | 与较新的 AVR 微控制器（包括 ATtiny 设备）一起使用的 **统一编程和调试接口**
    (**UDPI**)。它是一个单线接口，是 ATxmega 设备上发现的二线 PDI 的后继者。 |'
- en: '| **HVPP/****HVSP** | **17/****5** | program | High Voltage Parallel Programming
    / High Voltage Serial Programming. AVR programming mode using 12V on the reset
    pin and direct access to 8+ pins. Ignores any internal fuse setting or other configuration
    option. Mostly used for in-factory programming and for recovery. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| **HVPP/HVSP** | **17/5** | 编程 | 高压并行编程 / 高压串行编程。AVR 编程模式使用复位引脚上的 12V 并直接访问
    8+ 个引脚。忽略任何内部熔丝设置或其他配置选项。主要用于工厂编程和恢复。 |'
- en: '| **TPI** | **3** | program | Tiny Programming Interface, used with some ATtiny
    AVR devices. These devices also lack the number of pins for HVPP or HVSP. |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| **TPI** | **3** | 编程 | 小型编程接口，用于一些 ATtiny AVR 设备。这些设备也缺少 HVPP 或 HVSP 所需的引脚数量。
    |'
- en: '| **SWD** | **3** | program debug'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '| **SWD** | **3** | 编程调试'
- en: boundary | Serial Wire Debug. Similar to reduced pin count JTAG with two lines,
    but uses ARM Debug Interface features, allowing a connected debugger to become
    a bus master with access to the MCU's memory and peripherals. |
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 边界 | 串行线调试。类似于具有两条线的简化 JTAG，但使用 ARM 调试接口功能，允许连接的调试器成为总线主控，并访问微控制器的内存和外设。 |
- en: ARM MCUs generally provide JTAG as their primary means of programming and debugging.
    On 8-bit MCUs, JTAG is far less common, which is mostly due to the complexity
    of its requirements.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ARM 微控制器通常提供 JTAG 作为其主要的编程和调试手段。在 8 位微控制器上，JTAG 的使用频率远低于其他类型，这主要归因于其要求的复杂性。
- en: AVR MCUs tend to offer In-System Programming (ISP) via SPI in addition to high
    voltage programming modes. Entering programming mode requires that the reset pin
    be held low during programming and verification and released and strobed at the
    end of the programming cycle.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: AVR 微控制器除了高压编程模式外，通常还提供通过 SPI 的在系统编程 (ISP)。进入编程模式需要在编程和验证期间保持复位引脚低电平，并在编程周期结束时释放并触发。
- en: One requirement for ISP is that the relevant (SPIEN fuse bit) in the MCU is
    set to enable the in-system programming interface. Without this bit set, the device
    won’t respond on the SPI lines. Without JTAG available and enabled via the JTAGEN
    fuse bit, only HVPP or HVSP are available to recover and reprogram the chip. In
    the latter case, the unusual set of pins and the 12V supply voltage do not necessarily
    integrate well into the board circuitry.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ISP 的一个要求是在 MCU 中设置相关的 (SPIEN 熔丝位) 以启用在系统编程接口。如果没有设置此位，设备将不会在 SPI 线上响应。如果没有通过
    JTAGEN 熔丝位启用 JTAG，则只能使用 HVPP 或 HVSP 来恢复和重新编程芯片。在后一种情况下，不寻常的引脚集和 12V 供电电压不一定很好地集成到电路板上。
- en: 'The physical connections required for most serial programming interfaces are
    fairly simple, even when the MCU has already been integrated into a circuit as
    shown in the following diagram:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数串行编程接口所需的物理连接相当简单，即使 MCU 已经如图所示集成到电路中：
- en: '![](img/b03d2974-c53c-4473-aec3-c599459b49e2.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b03d2974-c53c-4473-aec3-c599459b49e2.png)'
- en: Here, the external oscillator is optional if an internal one exists. The **PDI**,
    **PDO**, and **SCK** lines correspond to their respective SPI lines. The Reset
    line is held active (low) during programming. After connecting to the MCU in this
    manner, we are free to write to its flash memory, EEPROM, and configuration fuses.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，如果存在内部振荡器，外部振荡器是可选的。**PDI**、**PDO** 和 **SCK** 线对应于它们各自的 SPI 线。复位线在编程期间保持激活（低电平）。以这种方式连接到
    MCU 后，我们可以自由地向其闪存、EEPROM 和配置熔丝写入。
- en: On newer AVR devices, we find the **Unified Programming and Debug Interface**
    (**UPDI**), which uses just a single wire (in addition to the power and ground
    lines) to connect to the target MCU to provide both programming and debug support.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在较新的 AVR 设备上，我们发现 **统一编程和调试接口**（**UPDI**），它仅使用一根线（除了电源和地线）连接到目标 MCU，以提供编程和调试支持。
- en: 'This interface simplifies the previous connection diagram to the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 此接口简化了之前的连接图到以下：
- en: '![](img/b0bfa79c-4d7e-4d8e-bec0-5e232d4c017f.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b0bfa79c-4d7e-4d8e-bec0-5e232d4c017f.png)'
- en: 'This favorably compares to JTAG (IEEE 1149.1) on the ATxmega (when enabled)
    as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 ATxmega 上的 JTAG（IEEE 1149.1）相比是有利的：
- en: '![](img/bd797ef1-480e-4ff2-91b1-9b42f5bd02d6.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bd797ef1-480e-4ff2-91b1-9b42f5bd02d6.png)'
- en: Thereduced pin count JTAG standard (IEEE 1149) implemented on the ATxmega requires
    only one clock TCKC, one data wire TMSC and is aptly called Compact JTAG. Of these
    interfaces, UPDI still requires the fewest connections with the target device.
    Apart from that, both support similar features for AVR MCUs.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ATxmega 上实现的简化引脚计数 JTAG 标准（IEEE 1149）只需要一个时钟 TCKC，一根数据线 TMSC，因此被称为紧凑型 JTAG。在这些接口中，UPDI
    仍然需要与目标设备的最少连接。除此之外，两者都支持类似的功能，用于 AVR MCU。
- en: For other systems using JTAG for programming and debugging, no standard connection
    exists. Each manufacturer uses their own preferred connector, ranging from 2 x
    5 pins (Altera, AVR) to 2 x 10 pins (ARM), or a single 8-pin connector (Lattice).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用 JTAG 进行编程和调试的其他系统，没有标准连接。每个制造商都使用他们自己的首选连接器，从 2 x 5 引脚（Altera, AVR）到 2
    x 10 引脚（ARM），或者一个单独的 8 引脚连接器（Lattice）。
- en: With JTAG being more a protocol standard rather than a physical specification,
    one should consult the documentation for one's target platform for the specific
    details.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 JTAG 更像是一个协议标准而不是物理规范，因此应查阅目标平台的文档以获取具体细节。
- en: Boot loader
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引导加载程序
- en: The boot loader has been introduced as a small extra application that uses an
    existing interface (for example, UART or Ethernet) to provide self-programming
    capabilities. On the AVR, a boot loader section of 256 bytes to 4 KB can be reserved
    in its flash. This code can perform any number of user-defined tasks, from setting
    up a serial link with a remote system, to booting from a remote image over Ethernet
    using PXE.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 引导加载程序被引入作为一个小的额外应用程序，它使用现有的接口（例如 UART 或 Ethernet）来提供自我编程能力。在 AVR 上，可以在其闪存中保留
    256 字节到 4 KB 的引导加载程序部分。此代码可以执行任何数量的用户定义的任务，从设置与远程系统的串行连接，到通过 PXE 在以太网上从远程图像引导。
- en: 'At its core, an AVR boot loader is no different from any other AVR application,
    except that when compiling it one extra linker flag is added to set the starting
    byte address for the boot loader:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本质上，AVR 引导加载程序与任何其他 AVR 应用程序没有不同，只是在编译时添加了一个额外的链接器标志来设置引导加载程序的起始字节地址：
- en: '[PRE0]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Replace this address with a similar one for the specific MCU that you''re using
    (for AVR depending on the BOOTSZ flags set and controller used, see datasheet
    table about Boot Size Configuration: Boot Reset Address, where, for example, the
    boot reset address is 0xC00 is in words and the section start is defined in bytes).
    This ensures that the boot loader code will be written to the proper location
    in the MCU''s ROM. Writing the boot loader code to the ROM is almost always done
    via ISP.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 将此地址替换为您所使用的特定 MCU 的类似地址（对于 AVR，根据设置的 BOOTSZ 标志和控制器，请参阅有关引导大小配置的数据表表格：引导重置地址，例如，引导重置地址为
    0xC00，以字为单位，而节起始地址以字节为单位）。这确保引导加载程序代码将被写入 MCU ROM 的正确位置。将引导加载程序代码写入 ROM 几乎总是通过
    ISP 完成。
- en: 'AVR MCUs divide the flash ROM into two sections: the **no-read-while-write **(**NRWW**)
    (for most, if not all application memory space) and **read-while-write** (**RWW**)
    sections. In brief, this means that the RWW section can be safely erased and rewritten
    without affecting the CPU''s operation. This is why the boot loader resides in
    the NRWW section and also why it''s not easy to have the boot loader update itself.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: AVR MCU将闪存ROM分为两个部分：**不可读/写**（**NRWW**）（对于大多数，如果不是所有应用内存空间）和**可读/写**（**RWW**）部分。简而言之，这意味着RWW部分可以安全地擦除和重写，而不会影响CPU的操作。这就是为什么引导加载程序位于NRWW部分，也是为什么引导加载程序不容易自我更新的原因。
- en: Another important detail is that the boot loader can also not update the fuses
    that set various flags in the MCU. To change these, one has to externally program
    the device.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的细节是，引导加载程序也不能更新设置MCU中各种标志的熔丝。要更改这些，必须外部编程设备。
- en: After programming the MCU with a boot loader, one would generally set the flags
    in the MCU that let the processor know that a boot loader has been installed.
    In the case of AVR, these flags are BOOTSZ and BOOTRST.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用引导加载程序编程MCU后，通常会设置MCU中的标志，让处理器知道已安装了引导加载程序。在AVR的情况下，这些标志是BOOTSZ和BOOTRST。
- en: Memory management
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存管理
- en: The storage and memory system of microcontrollers consists out of multiple components.
    There is a section of **read-only-memory** (**ROM**) that is only written to once
    when the chip is programmed, but which cannot normally be altered by the MCU itself,
    as we saw in the previous section.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 微控制器的存储和内存系统由多个组件组成。其中有一个**只读存储器**（**ROM**）部分，在芯片编程时只写入一次，但通常不能由MCU本身修改，正如我们在上一节中看到的。
- en: 'The MCU may also have a bit of persistent storage, in the form of EEPROM or
    equivalent. Finally, there are CPU registers and the **random-access memory**
    (**RAM**). This results in the following exemplary memory layout:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: MCU还可能有一小块持久存储，形式为EEPROM或等效设备。最后，有CPU寄存器和**随机存取存储器**（**RAM**）。这导致了以下示例内存布局：
- en: '![](img/eefb6e49-e5ff-4360-b08c-a862fb6e0530.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/eefb6e49-e5ff-4360-b08c-a862fb6e0530.png)'
- en: The use of a modified Harvard architecture (split program and data memory at
    some architectural level, generally with the data buses) is common with MCUs.
    With the AVR architecture, for example, the program memory is found in the ROM,
    which for the ATmega2560 is connected using its own bus with the CPU core, as
    one can seen on the block diagram for this MCU, which we looked at previously
    in [Chapter 1](0ff8cac9-3155-45e1-af05-7005fc419dd6.xhtml), *What Are Embedded
    Systems?*
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在MCU中，使用修改后的哈佛架构（在某些架构级别上分割程序和数据内存，通常使用数据总线）是常见的。例如，在AVR架构中，程序内存位于ROM中，对于ATmega2560来说，它使用自己的总线与CPU核心连接，这可以在我们之前在[第1章](0ff8cac9-3155-45e1-af05-7005fc419dd6.xhtml)“什么是嵌入式系统？”中看到的该MCU的框图中看到。
- en: A major advantage of having separate buses for these memory spaces is that one
    can address each of them separately, which makes better use of the limited addressing
    space available to an 8-bit processor (1 and 2 byte wide address). It also allows
    for concurrent accesses while the CPU is busy with the other memory space, further
    optimizing the available resources.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为这些内存空间拥有单独的总线的主要优点是，可以分别对它们进行寻址，这可以更好地利用8位处理器（1和2字节宽的地址）可用的有限寻址空间。这也允许在CPU忙于处理其他内存空间时进行并发访问，从而进一步优化可用资源。
- en: For the data memory in the SRAM, we are then free to use it as we want. Here,
    we do need at least a stack to be able to run a program. Depending on how much
    SRAM is left in the MCU, we can then also add a heap. Applications of moderate
    complexity can be realized with only stack and statically allocated memory though,
    not involving higher-level language features that produce code with heap allocations.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 对于SRAM中的数据内存，我们可以自由地按需使用它。在这里，我们至少需要一个堆栈才能运行程序。根据MCU中剩余的SRAM量，我们还可以添加堆。使用堆栈和静态分配的内存可以实现中等复杂度的应用程序，而不涉及产生堆分配代码的高级语言功能。
- en: Stack and heap
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆栈和堆
- en: 'Whether one needs to initialize the stack on the MCU that one is programming
    for depends on how low-level one wishes to go. When using the C-runtime (on AVR:
    `avr-libc`), the runtime will handle initializing the stack and other details
    by letting the linker place naked code into init sections, for example specified
    by:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 是否需要初始化正在编程的MCU的堆栈取决于你希望达到多低级别。当使用C运行时（在AVR中：`avr-libc`）时，运行时会通过让链接器将裸代码放入初始化部分来处理堆栈和其他细节，例如以下指定的：
- en: '[PRE1]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Preceding the execution of any of our own application code.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行我们自己的应用程序代码之前。
- en: 'The standard RAM layout on AVR is to start with the `.data` variables at the
    beginning of the RAM, followed by `.bss`. The stack is started from the opposite
    site of the RAM, growing towards the beginning. There will be room left between
    the end of the `.bss` section and the end of the stack illustrated as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在AVR上的标准RAM布局是从RAM的起始位置开始`.data`变量，然后是`.bss`。堆栈从RAM的相反端开始，向起始方向增长。在`.bss`部分的末尾和堆栈的末尾之间将留有空间，如下所示：
- en: '![](img/c84909aa-7715-46f6-9538-5760568e9748.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c84909aa-7715-46f6-9538-5760568e9748.png)'
- en: 'Since the stack grows depending on the depth of the function calls in the application
    being run, it is hard to say how much space is available. Some MCUs allow one
    to use external RAM as well, which would be a possible location for the heap as
    follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 由于堆栈的大小取决于正在运行的应用程序中函数调用的深度，因此很难确定有多少空间可用。一些MCU允许使用外部RAM，这将是堆的一个可能位置，如下所示：
- en: '![](img/e568f5de-0419-4838-bbe9-3b238d5f9280.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e568f5de-0419-4838-bbe9-3b238d5f9280.png)'
- en: The AVR Libc library implements a `malloc()` memory allocator routine, optimized
    for the AVR architecture. Using it, one can implement one's own `new` and `delete`
    functionality as well—if one so desires—since the AVR toolchain does not implement
    either.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: AVR Libc库实现了一个`malloc()`内存分配器例程，针对AVR架构进行了优化。使用它，可以实现自己的`new`和`delete`功能——如果需要的话——因为AVR工具链没有实现这两个功能。
- en: 'In order to use external memory with an AVR MCU for heap storage, one would
    have to make sure that the external memory has been initialized, after which the
    address space becomes available to `malloc()`. The start and end of the heap space
    is hereby defined by these global variables:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用AVR MCU的外部内存作为堆存储，必须确保外部内存已初始化，之后地址空间才对`malloc()`可用。堆空间的起始和结束由以下全局变量定义：
- en: '[PRE2]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The AVR documentation has the following advice regarding adjusting the heap:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: AVR文档关于调整堆的建议如下：
- en: If the heap is going to be moved to external RAM, `__malloc_heap_end` must be
    adjusted accordingly. This can either be done at runtime, by writing directly
    to this variable, or it can be done automatically at link-time, by adjusting the
    value of the symbol `__heap_end`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要将堆移动到外部RAM，必须相应地调整`__malloc_heap_end`。这可以通过在运行时直接写入此变量来完成，或者可以在链接时自动完成，通过调整符号`__heap_end`的值。
- en: Interrupts, ESP8266 IRAM_ATTR
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中断，ESP8266 IRAM_ATTR
- en: On a desktop PC or server the entire application binary would be loaded into
    RAM. On MCUs though it is common to leave as many of the program instructions
    in the ROM as possible until they are needed. This means that most of our application's
    instructions cannot be executed immediately, but first have to be fetched from
    ROM before the CPU of our MCU can fetch them via the instruction bus to be executed.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在台式PC或服务器上，整个应用程序的二进制文件会被加载到RAM中。然而，在微控制器（MCUs）中，通常会将尽可能多的程序指令保留在ROM中，直到需要时才使用。这意味着我们应用程序的大多数指令不能立即执行，而必须首先从ROM中检索，然后才能通过我们的MCU的指令总线由CPU获取并执行。
- en: 'On the AVR, each possible interrupt is defined in a vector table, which is
    stored in ROM. This offers either default handlers for each interrupt type, or
    the user-defined version. To mark an interrupt routine, one either uses the `__attribute__((signal))`
    attribute, or uses the `ISR()` macro:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在AVR中，每个可能的中断都在一个向量表中定义，该表存储在ROM中。这提供了为每种中断类型提供默认处理程序或用户定义版本的功能。要标记中断例程，可以使用`__attribute__((signal))`属性，或者使用`ISR()`宏：
- en: '[PRE3]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This macro handles the details of registering an interrupt. One just has to
    specify the name and define a function for the interrupt handler. This will then
    get called via the interrupt vector table.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 此宏处理注册中断的细节。只需指定名称并定义中断处理函数即可。然后它将通过中断向量表被调用。
- en: With the ESP8266 (and its successor, the ESP32) we can mark the interrupt handler
    function with a special attribute, `IRAM_ATTR`. Unlike the AVR, the ESP8266 MCU
    does not have built-in ROM, but has to use its SPI peripheral to load any instructions
    into RAM, which is obviously quite slow.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在ESP8266（及其继任者ESP32）中，我们可以使用特殊的属性`IRAM_ATTR`标记中断处理函数。与AVR不同，ESP8266 MCU没有内置的ROM，必须使用其SPI外设将任何指令加载到RAM中，这显然相当慢。
- en: 'An example of using this attribute with an interrupt handler looks as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此属性与中断处理程序一起的示例如下：
- en: '[PRE4]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we have an interrupt handler that is connected to the signal from a motion
    detector, connected to an input pin. As with any well-written interrupt handler,
    it is quite simple and meant to be quickly executed before returning to the normal
    flow of the application.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个与运动检测器信号连接的中断处理程序，该信号连接到一个输入引脚。与任何编写良好的中断处理程序一样，它相当简单，并且旨在在返回到应用程序的正常流程之前快速执行。
- en: Having this handler in ROM would mean that the routine would not respond near-instantly
    to the motion sensor's output changing. Worse, it would cause the handler to take
    much longer to finish, which would consequently delay the execution of the rest
    of the application code.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将此处理程序放在ROM中，这意味着该例程不会对运动传感器输出变化的响应接近即时。更糟糕的是，它会导致处理程序完成所需的时间更长，从而延迟应用程序代码的其余部分的执行。
- en: By marking it with `IRAM_ATTR`, we can avoid this problem, since the entire
    handler will already be in RAM when it's needed, instead of the whole system stalling
    as it waits for the SPI bus to return the requested data before it can continue.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将其标记为`IRAM_ATTR`，我们可以避免这个问题，因为当需要时，整个处理程序已经在RAM中，而不是整个系统停滞，等待SPI总线返回所需数据才能继续。
- en: Note that, tempting as it may seem, this kind of attribute should be used sparingly,
    as most MCUs have much more ROM than RAM. In the case of ESP8266, there are 64kB
    RAM for code execution complemented by possibly megabytes of external Flash ROM.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管这种属性可能很有吸引力，但它应该被谨慎使用，因为大多数微控制器（MCU）的只读存储器（ROM）比随机存取存储器（RAM）多得多。在ESP8266的情况下，有64KB的RAM用于代码执行，可能还有数兆字节的外部闪存ROM。
- en: When compiling our code, the compiler will put instructions marked with this
    attribute into a special section, so that the MCU knows to load it into RAM.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译我们的代码时，编译器会将带有此属性的指令放入一个特殊部分，这样MCU就知道将其加载到RAM中。
- en: Concurrency
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发
- en: With a few exceptions, MCUs are single-core systems. Multitasking is not something
    that is generally done; instead, there's a single thread of execution with timers
    and interrupts adding asynchronous methods of operation.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 除了少数例外，MCU通常是单核系统。多任务处理通常不执行；相反，有一个单一的执行线程，定时器和中断提供了异步操作方法。
- en: Atomic operations are generally supported by compilers and AVR is no exception.
    The need for atomic blocks of instructions can be seen in the following cases.
    Keep in mind that while a few exceptions exist (MOVW to copy a register pair and
    indirect addressing via X, Y, Z pointers), instructions on an 8 bit architecture
    generally only affect 8 bit values.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 原子操作通常由编译器支持，AVR也不例外。在以下情况下可以看到需要原子指令块的需求。请记住，尽管存在一些例外（如MOVW用于复制寄存器对和通过X、Y、Z指针进行间接寻址），在8位架构上的指令通常只影响8位值。
- en: A 16 bit variable is byte-wise read in the main function and updated in an ISR.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个16位变量在主函数中以字节为单位读取，并在ISR中更新。
- en: A 32 bit variable is read, modified and subsequently stored back in either main
    function or ISR while the other routine could try to access it.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取一个32位变量，修改后将其存储回主函数或ISR中，而其他例程可能会尝试访问它。
- en: The execution of a block of code is time-critical (bitbanging I/O, disabling
    JTAG).
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码块的执行是时间敏感的（位带I/O，禁用JTAG）。
- en: 'A basic example for the first case is given in the AVR libc documentation:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一种情况，AVR libc文档中给出了一个基本示例：
- en: '[PRE5]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this code, a 16-bit integer is being changed in the interrupt handler, while
    the main routine is copying its value into a local variable. We call `sei()` (SEt
    global Interrupt flag) to ensure that the interrupt register is in a known state.
    The `volatile` keyword hints to the compiler that this variable and how it's accessed
    should not be optimized in any way.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，一个16位整数在中断处理程序中被更改，而主例程正在将其值复制到一个局部变量中。我们调用`sei()`（设置全局中断标志）以确保中断寄存器处于已知状态。`volatile`关键字提示编译器，这个变量及其访问方式不应以任何方式进行优化。
- en: Because we included the AVR atomic header, we can use the `ATOMIC_BLOCK` macro,
    along with the `ATOMIC_FORCEON` macro. What this does is create a code section
    that is guaranteed to be executed atomically, without any interference from interrupt
    handlers and the like. The parameter we pass to `ATOMIC_BLOCK` forces the global
    interrupt status flag into an enabled state.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们包含了AVR原子头文件，我们可以使用`ATOMIC_BLOCK`宏以及`ATOMIC_FORCEON`宏。这样做会创建一个保证原子执行的代码段，没有任何中断处理程序等干扰。传递给`ATOMIC_BLOCK`的参数将全局中断状态标志强制设置为启用状态。
- en: Since we set this flag to the same state before we started the atomic block,
    we do not need to save the previous value of this flag, which saves resources.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在开始原子块之前将此标志设置为相同状态，因此我们不需要保存此标志的先前值，这节省了资源。
- en: As noted earlier, MCUs tend to be single-core systems, with limited multitasking
    and multithreading capabilities. For proper multithreading and multitasking, one
    would need to do context switches, whereby not only the stack pointer of the running
    task is saved, but also the state of all registers and related.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，微控制器（MCU）往往是单核系统，具有有限的并行处理和多线程能力。为了进行适当的并行处理和多线程，需要执行上下文切换，这不仅仅涉及保存正在运行的任务的栈指针，还包括所有寄存器和相关状态。
- en: This means that while it would be possible to run multiple threads and tasks
    on a single MCU, in the case of 8-bit MCUs such as the AVR and PIC (8-bit range),
    the effort would most likely not be worth it, and would require a significant
    amount of labor.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着虽然理论上可以在单个MCU上运行多个线程和任务，但在AVR和PIC等8位MCU（8位范围）的情况下，这样做可能不值得，并且需要大量的劳动。
- en: On more powerful MCUs (like the ESP8255 and ARM Cortex-M), one could run **real-time
    OSes** (**RTOSes**), which implement exactly such context switching, without having
    to do all of the heavy lifting. We will look at RTOSes later in this chapter.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在更强大的MCU（如ESP8255和ARM Cortex-M）上，可以运行**实时操作系统**（RTOS），它正好实现了这种上下文切换，无需进行所有繁重的工作。我们将在本章后面讨论RTOS。
- en: AVR development with Nodate
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Nodate进行AVR开发
- en: Microchip provides a binary version of the GCC toolchain for AVR development.
    At the time of writing, the most recent release of AVR-GCC is 3.6.1, containing
    GCC version 5.4.0\. This implies full support for C++14 and limited support for
    C++17.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Microchip为AVR开发提供了GCC工具链的二进制版本。在撰写本文时，AVR-GCC的最新版本是3.6.1，包含GCC版本5.4.0。这意味着完全支持C++14，并有限支持C++17。
- en: Using this toolchain is pretty easy. One can simply download it from the Microchip
    website, extract it to a suitable folder, and add the folder containing the GCC
    executable files to the system path. After this, it can be used to compile AVR
    applications. Some platforms will have the AVR toolchain available via a package
    manager as well, which makes the process even easier.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此工具链相当简单。可以从Microchip网站下载它，将其提取到合适的文件夹中，并将包含GCC可执行文件的文件夹添加到系统路径中。之后，它可以用来编译AVR应用程序。某些平台将通过包管理器提供AVR工具链，这使得过程更加简单。
- en: 'One thing that one may notice after installing this GCC toolchain is that there
    is no C++ STL available. As a result, one is limited to just the C++ language
    features supported by GCC. As the Microchip AVR FAQ notes:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 安装此GCC工具链后，可能会注意到没有提供C++ STL。因此，只能使用GCC支持的C++语言功能。正如Microchip AVR常见问题解答所述：
- en: Obviously, none of the C++ related standard functions, classes, and template
    classes are available.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显然，没有提供与C++相关的标准函数、类和模板类。
- en: The operators new and delete are not implemented; attempting to use them will
    cause the linker to complain about undefined external references. (This could
    perhaps be fixed.)
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新建和删除操作符未实现；尝试使用它们会导致链接器抱怨未定义的外部引用。（这或许可以修复。）
- en: Some of the supplied include files are not C++ safe, that is, they need to be
    wrapped into `extern"C" { . . . }`. (This could certainly be fixed, too.)
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些提供的包含文件不是C++安全的，也就是说，它们需要被包裹在`extern"C" { . . . }`中。（这当然也可以修复。）
- en: Exceptions are not supported. Since exceptions are enabled by default in the
    C++ frontend, they explicitly need to be turned off using `-fno-exceptions` in
    the compiler options. Failing this, the linker will complain about an undefined
    external reference to `__gxx_personality_sj0`.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常不受支持。由于C++前端默认启用异常，因此需要通过编译器选项中的`-fno-exceptions`显式关闭它们。否则，链接器将抱怨对`__gxx_personality_sj0`的未定义外部引用。
- en: With the lack of a Libstdc++ implementation that would contain the STL features,
    we can only add such functionality by using a third-party implementation. These
    include versions that provide essentially the full STL, as well as lightweight
    re-implementations that do not follow the standard STL API. An example of the
    latter is the Arduino AVR core, which provides classes such as String and Vector,
    which are similar to their STL equivalents albeit with some limitations and differences.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 由于缺乏包含STL功能的Libstdc++实现，我们只能通过使用第三方实现来添加此类功能。这些包括提供基本完整STL的版本，以及不遵循标准STL API的轻量级重新实现。后者的一个例子是Arduino
    AVR核心，它提供了String和Vector等类，这些类与它们的STL等效项类似，尽管有一些限制和差异。
- en: An upcoming alternative to the Microchip AVR GCC toolchain is LLVM, a compiler
    framework to which experimental support for AVR as been recently added, and which
    at some point in the future should allow producing binaries for AVR MCUs, all
    the while providing full STL functionality via its Clang frontend (C/C++ support).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Microchip AVR GCC工具链的替代品，即将推出的LLVM是一个编译器框架，最近已添加了对AVR的实验性支持，并在未来的某个时刻应该能够为AVR微控制器（MCU）生成二进制文件，同时通过其Clang前端（C/C++支持）提供完整的STL功能。
- en: '![](img/5b4b8498-6d84-46e3-9887-ab7249b81b3d.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5b4b8498-6d84-46e3-9887-ab7249b81b3d.png)'
- en: Consider this an abstract snapshot of LLVM development—all the while illustrating
    the general concept of LLVM and its emphasis on Intermediate Representation.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以被视为LLVM开发的抽象快照——同时说明了LLVM的一般概念及其对中间表示的重视。
- en: Unfortunately the PIC range of MCUs, despite also being owned by Microchip and
    resembling AVR in many ways, does at this point not have a C++ compiler available
    for it from Microchip until one moves up to the PIC32 (MIPS-based) range of MCUs.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，尽管PIC系列MCU也由Microchip拥有，并且在许多方面与AVR相似，但在这个阶段，Microchip并没有为其提供C++编译器，直到升级到基于MIPS的PIC32系列MCU。
- en: Enter Nodate
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入Nodate
- en: You could at this point opt to use one of the IDEs we discussed previously in
    this chapter, but that wouldn't be nearly as educational for AVR development itself.
    For this reason, we will look at a simple application developed for an ATmega2560
    board that uses a modified version of the Arduino AVR core, called Nodate ([https://github.com/MayaPosch/Nodate](https://github.com/MayaPosch/Nodate)).
    This framework restructures the original core to allow it to be used as a regular
    C++ library instead of only with the Arduino C-dialect parser and frontend.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在此阶段，你可以选择使用本章之前讨论的其中一个IDE，但这对于AVR开发本身的教育意义并不大。因此，我们将查看为ATmega2560板开发的一个简单应用程序，该程序使用Arduino
    AVR核心的修改版，称为Nodate ([https://github.com/MayaPosch/Nodate](https://github.com/MayaPosch/Nodate))。这个框架重构了原始核心，使其能够作为一个常规的C++库使用，而不仅仅是与Arduino
    C方言解析器和前端一起使用。
- en: 'Installing Nodate is pretty easy: simply download to a suitable location on
    one''s system and have the `NODATE_HOME` system variable point to the root folder
    of the Nodate installation. After this, we can take one of the example applications
    as a basis for a new project.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Nodate相当简单：只需将其下载到系统的一个合适位置，并让`NODATE_HOME`系统变量指向Nodate安装的根文件夹。之后，我们可以以其中一个示例应用程序为基础来创建一个新项目。
- en: Example – CMOS IC Tester
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 - CMOS集成电路测试仪
- en: Here, we will look at a more full-featured example project, implementing an
    **integrated circuit** (**IC**) tester for 5V logic chips. In addition to probing
    chips with its GPIO pins, this project also reads a chip description and test
    program (in the form of a logic table) from an SD card over SPI. User control
    is added in the form of a serial-based command-line interface.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将查看一个功能更全面的示例项目，该项目实现了一个5V逻辑芯片的集成电路（IC）测试仪。除了用其GPIO引脚探测芯片外，该项目还通过SPI从SD卡读取芯片描述和测试程序（以逻辑表的形式）。用户控制通过基于串行的命令行界面实现。
- en: 'First, we look at the `Makefile` for this Nodate project, as found in the root
    of the project:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们查看这个Nodate项目的`Makefile`，它位于项目的根目录中：
- en: '[PRE6]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first item we specify is the architecture we are targeting, since Nodate
    can be used to target other MCU types as well. Here, we specify AVR as the architecture.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先指定我们针对的架构，因为Nodate也可以用于其他MCU类型。在这里，我们指定AVR作为架构。
- en: 'Next, we use the preset for the Arduino Mega 2560 development board. Inside
    Nodate, we have a number of presets like these, which define a number of details
    about the board. For the Arduino Mega 2560, we get the following presets:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用Arduino Mega 2560开发板的预设。在Nodate内部，我们有多个这样的预设，它们定义了有关板子的许多细节。对于Arduino
    Mega 2560，我们得到以下预设：
- en: '[PRE7]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If no board preset is defined, one has to define those variables in the project's
    Makefile and pick an existing value for each variable, each of which is defined
    as its own Makefile within the Nodate AVR subfolders. Alternatively, one can add
    one's own MCU, programmer, and (pin) variant file to Nodate, along with a new
    board preset, and use that.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有定义板预设，必须在项目的 Makefile 中定义这些变量，并为每个变量选择一个现有值，每个变量都在 Nodate AVR 子文件夹中的自己的
    Makefile 中定义。或者，可以在 Nodate 中添加自己的 MCU、编程器和（引脚）变体文件，以及一个新的板预设，并使用它。
- en: 'With the makefile complete it is time to implement the main function:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当 makefile 完成后，是时候实现主函数了：
- en: '[PRE8]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The wiring header provides access to all GPIO-related functionality. Furthermore,
    we include headers for the SPI bus, the SD card reader device, and a custom class
    that wraps the serial interface, as we will see in more detail in a moment:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: wiring 标题提供了访问所有 GPIO 相关功能的方法。此外，我们还包含了 SPI 总线、SD 卡读取设备以及一个封装串行接口的自定义类的标题，我们将在稍后更详细地看到：
- en: '[PRE9]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Upon entering the main function, we initialize the GPIO functionality with a
    call to `init()`. The next call loads the pin configuration for the particular
    board we are targeting (the `VARIANT` variable on the top or in the board preset
    Makefile).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 进入主函数后，我们通过调用 `init()` 初始化 GPIO 功能。接下来的调用加载了我们针对的特定板的引脚配置（顶部的 `VARIANT` 变量或在板的预设
    Makefile 中）。
- en: 'After this, we start the first serial port with a speed of 9,600 baud, followed
    by the SPI bus, and finally the output of a welcome message, as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们以 9,600 波特率启动第一个串行端口，然后是 SPI 总线，最后是输出欢迎信息，如下所示：
- en: '[PRE10]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: An SD card is expected to be attached to the Mega board at this point, containing
    a list of available chips we can test. Here, pin 53 is the hardware SPI chip-select
    pin that is conveniently located next to the rest of the SPI pins on the board.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 预期此时 SD 卡已连接到 Mega 板上，其中包含我们可以测试的可用芯片列表。在这里，53 号引脚是位于板上其他 SPI 引脚旁边的硬件 SPI 芯片选择引脚。
- en: 'Assuming the board is hooked up properly and the card can be read without issues,
    we are presented with a command-line prompt on the console screen:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 假设板连接正确且卡可以无问题读取，我们将在控制台屏幕上看到一个命令行提示符：
- en: '[PRE11]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This loop simply waits for input to arrive on the serial input, after which
    it will attempt to execute the received command. The function we call for reading
    from the serial input is blocking, returning only if it has either received a
    newline (user pressed *Enter*), or its internal buffer size was exceeded without
    receiving a newline. In the latter case, we simply dismiss the input and try to
    read from the serial input once more. This concludes the `main()` implementation.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 此循环简单地等待串行输入上的输入到达，之后它将尝试执行接收到的命令。我们用于从串行输入读取的函数是阻塞的，只有在它已经接收到了换行符（用户按下了 *Enter*）或其内部缓冲区大小超出且未收到换行符时才会返回。在后一种情况下，我们简单地忽略输入，并再次尝试从串行输入读取。这完成了
    `main()` 的实现。
- en: 'Let''s now look at the header of the `SerialComm` class:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看 `SerialComm` 类的标题：
- en: '[PRE12]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We include the header for the hardware serial connection support. This gives
    us access to the underlying UART peripheral. The class itself is purely static,
    defining the maximum size of the character buffer, and the function to read a
    line from the serial input.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包含了硬件串行连接支持的标题。这使我们能够访问底层的 UART 外设。该类本身是纯静态的，定义了字符缓冲区的最大大小，以及从串行输入读取一行数据的函数。
- en: 'Next is its implementation:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是其实现：
- en: '[PRE13]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the `while` loop, we first enter a loop that runs while there are no characters
    to be read in the serial input buffer. This makes it a blocking read.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `while` 循环中，我们首先进入一个循环，该循环在串行输入缓冲区中没有要读取的字符时运行。这使得它成为一个阻塞读取。
- en: Since we want to be able to see what we're typing, in the next section we echo
    back any character we have read. After this, we check whether we have received
    a newline character. If we did, we add a terminating null byte to the local buffer
    and read it into the String instance we were provided a reference to, after which
    we return true.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望能够看到我们输入的内容，在下一节中，我们将回显我们读取的任何字符。之后，我们检查是否收到了换行符。如果收到了，我们在本地缓冲区中添加一个终止的空字节，并将其读入我们提供的
    String 实例中，然后返回 true。
- en: A possible improvement one could implement here is that of a backspace feature,
    where the user could delete characters in the read buffer by using the backspace
    key. For this, one would have to add a case for the backspace control character
    (ASCII 0x8), which would delete the last character from the buffer, and optionally
    also have the remote terminal delete its last visible character.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在此处实现的一个可能的改进是回退功能，用户可以通过使用退格键删除读取缓冲区中的字符。为此，必须添加一个用于退格控制字符（ASCII 0x8）的情况，这将删除缓冲区中的最后一个字符，并且可选地远程终端也会删除其最后一个可见字符。
- en: With no newline found yet, we continue to the next section. Here, we check whether
    we have received a valid character considered as ASCII 0x20, or a space. If we
    did, we continue to add the new character to the buffer and finally check whether
    we have reached the end of the read buffer. If we did not, we return false to
    indicate that the buffer is full yet no newline has been found.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 由于尚未找到换行符，我们继续到下一部分。在这里，我们检查是否收到了被认为是 ASCII 0x20 的有效字符，即空格。如果是，我们继续将新字符添加到缓冲区，并最终检查是否已达到读取缓冲区的末尾。如果没有，我们返回
    false 以指示缓冲区已满但尚未找到换行符。
- en: 'Next are the handler functions `readIndex()` and `readChipConfig()` for the
    `index` and `chip` commands, respectively:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是处理函数 `readIndex()` 和 `readChipConfig()`，分别用于 `index` 和 `chip` 命令：
- en: '[PRE14]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This function makes heavy use of the `SD` and associated `File` classes from
    the Arduino SD card library. Essentially, we open the chips index file on the
    SD card, ensure we got a valid file handle, then proceed to read out and print
    each line in the file. This file is a simple line-based text-file, with one chip
    name per line.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数大量使用了 Arduino SD 卡库中的 `SD` 和相关 `File` 类。本质上，我们在 SD 卡上打开芯片索引文件，确保我们得到了有效的文件句柄，然后继续读取并打印文件中的每一行。此文件是一个简单的基于行的文本文件，每行一个芯片名称。
- en: At the end of the handler code, we're done reading from SD and the file handle
    can be closed with `sdFile.close()`. The same applies to the slightly more lengthy
    upcoming `readChipHandler()` implementation.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理程序代码的末尾，我们从 SD 卡读取完成，可以使用 `sdFile.close()` 关闭文件句柄。同样适用于即将到来的 `readChipHandler()`
    实现的稍长版本。
- en: Usage
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用法
- en: As an example, when we run the test with a simple HEF4001 IC (4000 CMOS series
    Quad 2-Input OR Gate) hooked up, we have to add a file to the SD card which contains
    the test description and control data for this IC. The `4001.ic` test file is
    shown here as it lends itself to following along the code that parses it and performs
    the corresponding tests.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当我们使用简单的 HEF4001 IC（4000 CMOS系列四输入或门）进行测试时，我们必须在 SD 卡上添加一个包含此 IC 测试描述和控制数据的文件。`4001.ic`
    测试文件在此处显示，因为它有助于跟随解析它的代码并执行相应的测试。
- en: '[PRE15]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The first three lines are printed verbatim as we saw earlier, with the remaining
    lines specifying individual test scenarios. These tests are lines and use the
    following format:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 前三条行按我们之前看到的方式打印，其余行指定了单独的测试场景。这些测试是行，并使用以下格式：
- en: '[PRE16]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We write this file as `4001.ic` along with an updated `index.idx` file (containing
    the ''4001'' entry on a new line) to the SD card. to support more ICs we would
    simply repeat this pattern with their respective test sequences and list them
    in the index file.Finally there is the handler for the chip configuration, which
    also starts the testing procedure:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将此文件以 `4001.ic` 的形式，以及更新的 `index.idx` 文件（包含新行上的 '4001' 条目）写入 SD 卡。为了支持更多的
    IC，我们只需重复此模式，使用它们各自的测试序列，并在索引文件中列出它们。最后是芯片配置的处理程序，它还启动了测试过程：
- en: '[PRE17]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We start by asking the user for the name of the IC, as printed out earlier
    by the `index` command:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先询问用户 IC 的名称，这是之前由 `index` 命令打印出来的：
- en: '[PRE18]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We attempt to open the file with the IC details, continuing with reading out
    the file contents, starting with the name and description of the IC that we are
    testing:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试打开包含 IC 详细信息的文件，继续读取文件内容，从我们要测试的 IC 的名称和描述开始：
- en: '[PRE19]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After displaying the name and description of this IC, we read out the line
    that contains the instructions on how to connect the IC to the headers of our
    Mega board:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在显示此 IC 的名称和描述后，我们读取包含如何将 IC 连接到 Mega 板头部的指令的行：
- en: '[PRE20]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we ask the user for confirmation on whether to start testing the IC. Any
    command beyond `start` will abort the test and return to the central command loop.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们询问用户是否要开始测试 IC。任何超出 `start` 命令的命令都将终止测试并返回到中央命令循环。
- en: 'Upon receiving `start` as a command, the testing begins:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在接收到 `start` 作为命令后，测试开始：
- en: '[PRE21]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As the first step, we read out the next line in the IC file, which should contain
    the first test. The first section contains the input pin settings, with the section
    after the equal sign containing the IC's output pin and its expected value for
    this test.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，我们读取IC文件中的下一行，它应该包含第一次测试。第一部分包含输入引脚设置，等于号后面的部分包含IC的输出引脚和本次测试的预期值。
- en: 'We print out the board header number that the result pin is connected to and
    the expected value. Next, we set the result pin to be an input pin so that we
    can read it out after the test has finished:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打印出结果引脚连接到的板头编号和预期值。接下来，我们将结果引脚设置为输入引脚，以便测试完成后读取它：
- en: '[PRE22]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: For the actual test, we use the first String we read out from the file for this
    test, parsing it to get the values for the input pins. For each pin, we first
    get its number, then get the value (`0` or `1`).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实际测试，我们使用从文件中读取的第一个字符串，解析它以获取输入引脚的值。对于每个引脚，我们首先获取其编号，然后获取其值（`0`或`1`）。
- en: 'We echo these pin numbers and values to the serial output, before setting the
    pin mode for these pins to output mode and then writing the test value to each
    of them, as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这些引脚编号和值回显到串行输出，然后设置这些引脚的模式为输出模式，并将测试值写入每个引脚，如下所示：
- en: '[PRE23]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: After leaving the inner loop, all of the input values will have been set. We
    just have to wait briefly to ensure that the IC has had time to settle on its
    new output values before we attempt to read out the result value on its output
    pin.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 离开内层循环后，所有输入值都将被设置。我们只需稍等片刻，确保IC有足够的时间稳定在新输出值上，然后我们尝试读取其输出引脚上的结果值。
- en: IC validation is a simple read on the result pin, after which we compare the
    value we received with the expected value. The result of this comparison is then
    printed to the serial output.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: IC验证是对结果引脚的简单读取，之后我们将收到的值与预期值进行比较。然后，将比较结果打印到串行输出。
- en: With the test complete, we close the IC file and return to the central command
    loop to await the next instructions.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 测试完成后，我们关闭IC文件，返回到中央命令循环，等待下一指令。
- en: 'After flashing the program to the Mega board and connecting with it on its
    serial port, we get the following result:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在将程序烧录到Mega板并连接到其串行端口后，我们得到以下结果：
- en: '[PRE24]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: After starting up, we get the message that the SD card was found and successfully
    initialized. We can now read from the SD card. We also see the available commands.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 启动后，我们收到消息，SD卡已找到并成功初始化。我们现在可以读取SD卡。我们还看到了可用的命令。
- en: 'Next, we specify the `index` command to get an overview of the available ICs
    we can test:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们指定`index`命令以获取可测试的IC的概览：
- en: '[PRE25]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: With just one IC available to test, we specify the `chip` command to enter the
    IC entry menu, after which we enter the IC's specifier.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 由于只有一个IC可用于测试，我们指定`chip`命令进入IC入口菜单，然后输入IC的指定器。
- en: This loads the file we put on the SD card and prints the first three lines.
    It then waits to give us time to hook up the chip, following the header numbers
    on the Mega board and the pin designations for the IC as provided by its datasheet.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这加载我们放在SD卡上的文件，并打印前三行。然后它等待给我们时间连接芯片，根据Mega板上的头编号和IC的数据表提供的引脚标识进行连接。
- en: 'After checking that we didn''t get any of our wires crossed, we type `start`
    and confirm. This starts the test:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在确认我们没有交叉任何线后，我们输入`start`并确认。这开始测试：
- en: '[PRE26]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: For each of the four identical OR gates in the chip, we run through the same
    truth table, testing each input combination. This specific IC passed with flying
    colors and can be safely used in a project.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 对于芯片中的四个相同的或门，我们逐一通过相同的真值表，测试每个输入组合。这个特定的集成电路顺利通过测试，可以安全地用于项目。
- en: This kind of testing device would be useful for testing any kind of 5V-level
    IC, including 74 and 4000 logic chips. It would also be possible to adapt the
    design to use the PWM, ADC, and other pins to test ICs that aren't strictly digital
    in their inputs and outputs.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这种测试设备对于测试任何5V级别的IC都很有用，包括74和4000逻辑芯片。还可以将设计修改为使用PWM、ADC和其他引脚来测试输入和输出不是严格数字的IC。
- en: ESP8266 development with Sming
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Sming进行ESP8266开发
- en: For ESP8266-based development, no official development tools exist from its
    creator (Espressif) beyond a bare-metal and RTOS-based SDK. Open source projects
    including Arduino then provide a more developer-friendly framework to develop
    applications with. The C++ alternative to Arduino on ESP8266 is Sming ([https://github.com/SmingHub/Sming](https://github.com/SmingHub/Sming)),
    which is an Arduino-compatible framework, similar to Nodate for AVR, which we
    looked at in the previous section.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于ESP8266的开发，其创造者（Espressif）除了提供基于裸机和RTOS的SDK之外，没有官方的开发工具。包括Arduino在内的开源项目为开发者提供了一个更友好的框架来开发应用程序。ESP8266上Arduino的C++替代方案是Sming
    ([https://github.com/SmingHub/Sming](https://github.com/SmingHub/Sming))，这是一个与Arduino兼容的框架，类似于我们在上一节中查看的AVR的Nodate。
- en: In the next chapter ([Chapter 5](886aecf2-8926-4aec-8045-a07ae2cdde84.xhtml),
    *Example - Soil Humidity Monitor with Wi-Fi*) we will take an in-depth look at
    developing with this framework on the ESP8266.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章（[第5章](886aecf2-8926-4aec-8045-a07ae2cdde84.xhtml)，*示例 - 基于Wi-Fi的土壤湿度监测器*）中，我们将深入探讨在ESP8266上使用此框架进行开发。
- en: ARM MCU development
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ARM MCU开发
- en: Developing for ARM MCU platforms isn't significantly different from developing
    for AVR MCUs, except that C++ is far better supported, and there exists a wide
    range of toolchains to choose from, as we saw at the beginning of this chapter
    with just the list of popular IDEs. The list of available RTOSes for Cortex-M
    is much larger than for AVR or ESP8266 as well.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 为ARM MCU平台开发与为AVR MCU开发没有显著不同，除了C++支持得更好，并且有广泛的工具链可供选择，正如我们在本章开头所看到的，仅是流行的IDE列表。可用于Cortex-M的RTOS列表也比AVR或ESP8266更长。
- en: Using a free and open source compiler including GCC and LLVM to target a wide
    range of ARM MCU architectures (Cortex-M-based and similar) is where developing
    for ARM MCUs offers a lot of freedom, along with easy access to the full C++ STL
    (though one might want to hold off on exceptions).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 使用包括GCC和LLVM在内的免费开源编译器，针对广泛的ARM MCU架构（基于Cortex-M和类似架构）进行开发，这是为ARM MCU开发提供很多自由度的原因之一，同时也能轻松访问完整的C++
    STL（尽管可能需要推迟使用异常）。
- en: 'When doing bare-metal development for Cortex-M MCUs, one may have to add this
    linker flag to provide basic stubs for some functionality that is normally provided
    by the OS:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在为Cortex-M MCU进行裸机开发时，可能需要添加此链接器标志来提供由操作系统通常提供的某些功能的基本存根：
- en: '[PRE27]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: One thing that makes ARM MCUs less attractive is that there are far fewer *standard*
    boards and MCUs, such as with what one sees with AVR in the form of the Arduino
    boards. Although the Arduino foundation at one point made the Arduino Due board
    based around a SAM3X8E Cortex-M3 MCU, this board uses the same form factor and
    roughly same pin layout (just being 3.3V I/O-based instead of 5V) as the ATmega2560-based
    Arduino Mega board.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 使ARM MCU不太吸引人的一个因素是，标准板和MCU的数量远少于AVR，例如Arduino板的形式。尽管Arduino基金会在某个时候基于SAM3X8E
    Cortex-M3 MCU制作了Arduino Due板，但该板使用与基于ATmega2560的Arduino Mega板相同的形态和大约相同的引脚布局（只是基于3.3V
    I/O而不是5V）。
- en: Because of this design choice a lot of the functionality of the MCU has not
    been broken out and is inaccessible unless one is very handy with a soldering
    iron and thin wires. This functionality includes the Ethernet connection, tens
    of GPIO (digital) pins, and so on. This same lack of breaking out all pins also
    happens with the Arduino Mega (ATmega2560) board, but on this Cortex-M MCU it
    becomes even more noticeable.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个设计选择，许多MCU的功能都没有被分离出来，除非非常擅长使用烙铁和细线，否则无法访问。这些功能包括以太网连接、数十个GPIO（数字）引脚等。这种所有引脚都没有分离的情况在Arduino
    Mega（ATmega2560）板上也存在，但在这种Cortex-M MCU上变得更加明显。
- en: The result of this is that as a development and prototyping board, there aren't
    any obvious generic picks. One might be tempted to just use the relatively cheap
    and plentiful prototyping boards like those provided by STMicroelectronics for
    their range of Cortex-M-based MCUs.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，作为一个开发和原型板，没有明显的通用选择。有人可能会倾向于使用相对便宜且丰富的原型板，例如STMicroelectronics为其Cortex-M系列MCU提供的那些。
- en: RTOS usage
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RTOS使用
- en: With the limited resources available on the average MCU, and the generally fairly
    straightforward process loop in the applications that run on them, it is hard
    to make a case for using an RTOS on these MCUs. It's not until one has to do complicated
    resource and task management that it becomes attractive to use an RTOS in order
    to save development time.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 由于平均MCU上可用的资源有限，以及在其上运行的应用程序中通常相当直接的流程循环，很难为在这些MCU上使用RTOS提出合理的论据。只有在必须进行复杂资源和管理任务时，使用RTOS以节省开发时间才变得有吸引力。
- en: The benefit of using an RTOS thus lies mostly in preventing one from having
    to reinvent the wheel. This is however something that has to be decided on a case-by-case
    basis. For most projects, having to integrate an RTOS into the development toolchain
    is more likely than an unrealistic idea that would add more to the workload than
    it would lighten it.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用RTOS的好处主要在于避免重复造轮子。然而，这必须根据具体情况来决定。对于大多数项目来说，将RTOS集成到开发工具链中可能比一个不切实际的想法更可能，后者可能会增加工作量而不是减轻它。
- en: For projects where one is, for example, trying to balance CPU time and system
    resources between different communication and storage interfaces, as well as a
    user interface, the use of an RTOS might make a lot of sense, however.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些需要在不同的通信和存储接口之间，以及用户界面之间平衡CPU时间和系统资源的项目，例如，使用RTOS可能非常有意义。
- en: As we saw in this chapter, a lot of embedded development uses a simple loop
    (super-loop) along with a number of interrupts to handle real-time tasks. When
    sharing data between an interrupt function and the super-loop, it is the responsibility
    of the developer to ensure that it is done safely.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章中看到的，许多嵌入式开发都使用一个简单的循环（超级循环）以及多个中断来处理实时任务。当在中断函数和超级循环之间共享数据时，确保其安全性的责任在于开发者。
- en: Here, an RTOS would offer a scheduler and even the ability to run tasks (processes)
    that are isolated from each other (especially on MCUs that have a **Memory Management
    Unit** (**MMU**)). On a multi-core MCU, an RTOS easily allows one to make effective
    use of all cores without having to do one's own scheduling.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，RTOS将提供调度器，甚至能够运行彼此隔离的任务（进程）（特别是在具有内存管理单元（MMU）的MCU上）。在多核MCU上，RTOS可以轻松地允许用户有效地使用所有核心，而无需进行自己的调度。
- en: As with all things, the use of an RTOS isn't just a collection of advantages.
    Even ignoring the increase in ROM and RAM space requirements that will likely
    result from adding an RTOS to one's project, it will also fundamentally change
    some system interactions and may (paradoxically) result in interrupt latency increasing.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 就像所有事物一样，使用RTOS不仅仅是一系列优势的集合。即使忽略添加RTOS到项目中可能导致的只读存储器（ROM）和随机存取存储器（RAM）空间需求增加，它也会从根本上改变一些系统交互，并且可能（矛盾的是）导致中断延迟增加。
- en: This is why, although the name has *real-time* in it, it is very hard to get
    more real-time than to use a simple execution loop and a handful of interrupts.
    The benefit of an RTOS, thus, is absolutely something about which no blanket statements
    can be made, especially when a support library or framework for bare-metal programming
    (such as the Arduino-compatible ones addressed in this chapter) is already available
    to make prototyping and developing for production as simple as tying a number
    of existing libraries together.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么，尽管其名称中包含“实时”，但要获得比使用简单的执行循环和少量中断更实时的情况是非常困难的。因此，RTOS的好处绝对不是可以一概而论的，尤其是在已经可以提供支持裸机编程的库或框架（如本章中提到的Arduino兼容框架）以简化原型设计和生产开发的情况下。
- en: Summary
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we took a look at how to select the right MCU for a new project,
    as well as how to add peripherals and deal with Ethernet and serial interface
    requirements in a project. We considered how memory is laid out in a variety of
    MCUs and how to deal with the stack and heap. Finally, we looked at an example
    AVR project, how to develop for other MCU architectures, and whether to use an
    RTOS.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何为新项目选择合适的微控制器（MCU），以及如何在项目中添加外设并处理以太网和串行接口的要求。我们考虑了不同MCU中内存的布局以及如何处理堆栈和堆。最后，我们查看了一个AVR项目示例，如何为其他MCU架构进行开发，以及是否使用实时操作系统（RTOS）。
- en: At this point, the reader is expected to be able to argue why they would pick
    one MCU over another, based on a set of project requirements. They should be capable
    of implementing simple projects using the UART and other peripherals, and understand
    proper memory management as well as the use of interrupts.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，读者应该能够根据一系列项目需求，论证为什么选择一个MCU而不是另一个。他们应该能够使用UART和其他外设实现简单的项目，并且理解适当的内存管理以及中断的使用。
- en: In the next chapter, we will take a good look at how to develop for the ESP8266,
    in the form of an embedded project that will keep track of soil moisture levels
    and control a watering pump when needed.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将详细探讨如何为ESP8266开发，形式为一个嵌入式项目，该项目将跟踪土壤湿度水平，并在需要时控制浇水泵。
