- en: Resource-Restricted Embedded Systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using a smaller embedded system such as a microcontroller (MCU) means having
    small amounts of RAM, CPU power, and storage. This chapter deals with planning
    for and making efficient use of limited resources taking into account the wide
    range of currently available MCUs and **System-on-Chip** (**SoC**) solutions.
    We will be considering the following aspects
  prefs: []
  type: TYPE_NORMAL
- en: Selecting the right MCU for a project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrency and memory management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding sensors, actuators, and network access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bare-metal development versus real-time OSes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The big picture for small systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When first confronted with a new project that requires the use of at least one
    type of MCU, it can seem like an overwhelming task to. As we saw in [Chapter 1](0ff8cac9-3155-45e1-af05-7005fc419dd6.xhtml), *What
    are Embedded Systems?*, there is a large number of MCUs to choose from, even if
    we limit ourselves to just those that have been released recently.
  prefs: []
  type: TYPE_NORMAL
- en: It may seem obvious to start by asking how many bits one needs, as in selecting
    between 8-bit, 16-bit, and 32-bit MCUs, or something as easy to quantify as clock
    speed, but these metrics are sometimes misleading and often don't lend themselves
    well to narrowing down the product selection. As it turns out, the parent categories
    are availability of sufficient I/O and the integrated peripherals to make the
    hardware happen in a lean and reliable way, as well as processing power tailored
    to the requirements faced at design-time and predicted to emerge throughout the
    product life-time.
  prefs: []
  type: TYPE_NORMAL
- en: 'So in more detail we need to answer questions like these:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Peripherals**: Which peripherals are needed to interact with the rest of
    the system?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CPU**: What level of CPU power is needed to run the application code?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Floating point**: Do we need hardware floating point support?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ROM**: How much ROM do we need to store the code?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RAM**: How much RAM is required to run the code?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Power and thermals**: What are the electrical power and thermal limitations?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each MCU family has its own strengths and weaknesses, though one of the most
    important factors to pick one MCU family over another the quality of its development
    tools. For hobby and other noncommercial projects, one would primarily consider
    the strength of the community and the available free development tools, while
    in the context of commercial projects one would also look at the support one could
    expect from the MCU manufacturer and possible third parties.
  prefs: []
  type: TYPE_NORMAL
- en: A key aspect of embedded development is in-system programming and debugging.
    Since programming and debugging are intertwined, we'll be looking at the corresponding
    interface options later to be able to identify what satisfies our requirements
    and constraints.
  prefs: []
  type: TYPE_NORMAL
- en: A popular and powerful debugging interface has become synonymous to the underlying
    Joint Test Action Group (JTAG) IEEE standard 1149.1 and easily recognized by signals
    frequently labeled TDI, TDO, TCK, TMS and TRST, defining the aptly-named Test
    Action Port (TAP). The larger standard has since been expanded up to 1149.8 and
    not all versions apply to digital logic, so we'll limit our scope to 1149.1 and
    a reduced pin count version described under 1149.7\. For now we just require that
    at least one of the full-featured JTAG, SWD and UPDI interfaces be supported.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging MCU-based systems along with on-chip debugging, using both command-line
    tools and IDEs, is something that we will take an in-depth look at in [Chapter
    7](d8237285-fcb7-4bbc-84f3-e45568598865.xhtml), *Testing Resource-Limited Platforms*.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if we are going to be making products containing the chosen MCU for
    an active production phase of a few years, it's vital that we ensure the MCU availability
    (or that of compatible replacements) for at least that period. Reputable manufacturers
    provide product life cycle information as part of their supply chain management,
    with discontinuation notices being sent 1 to 2 years in advance, and recommendations
    for lifetime buys.
  prefs: []
  type: TYPE_NORMAL
- en: For many applications, it is hard to ignore the wide availability of cheap,
    powerful, and easy-to-use Arduino compatible boards, especially the popular ones
    designed around the AVR family of MCUs. Among these, the ATmega MCUs—the mega168/328,
    and in particular the mega1280/2560 variants—provide significant amounts of processing
    power, ROM, and RAM for both high-level functionality and the handling of data
    for input, control, and telemetry, as well as a differentiated but rich sets of
    peripherals and GPIO.
  prefs: []
  type: TYPE_NORMAL
- en: All of these aspects make prototyping exceedingly simple before even committing
    to a more definitive variant with lower specifications and (hopefully) better
    BOM cost. As an example, the ATmega2560 "MEGA" board is shown as follows, and
    we will look at other boards in more detail later in this chapter as we work through
    a number of examples on how to develop for the AVR platform.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf763d40-f2e9-4f8c-88ca-e25e963aa6c8.png)'
  prefs: []
  type: TYPE_IMG
- en: Generally, one would pick a number of MCUs that might work for the project,
    get the development boards, hook them up to the rest of the projected system components
    (often on their own development or breakout boards), and start developing the
    software for the MCU that will make everything work together.
  prefs: []
  type: TYPE_NORMAL
- en: As more and more parts of the system become finalized, the number of development
    boards and bread-boarded components will dwindle until one reaches the point where
    one starts working on the final **printed circuit board** (**PCB**) layout. This
    will go through a number of iterations as well, as issues get ironed out, last-minute
    features are added, and the system as a whole is tested and optimized.
  prefs: []
  type: TYPE_NORMAL
- en: MCUs in such systems work on a physical level with the hardware, thus it is
    often a requirement to specify both hardware and software in tandem, if only because
    the software is so reliant on the hardware functionality. A common theme encountered
    in the industry is hardware modularity, either as small add-on PCBs with minimum
    added complexity, adding sensor or communication interfaces to devices such as
    temperature controllers and variable-frequency drives, or as full-fledged DIN
    rail modules connected to a common serial bus.
  prefs: []
  type: TYPE_NORMAL
- en: Example – Machine controller for a laser cutter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the fastest and most accurate ways to cut a wide range of materials
    is using a high-power laser. With the price of carbon dioxide (CO[2]) having dropped
    sharply over the years, this has led to widespread use of affordable (cheap) laser
    cutters as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1db0afad-701b-4921-aa11-cebb4a9fb4e3.png)'
  prefs: []
  type: TYPE_IMG
- en: While it's perfectly possible to operate a laser cutter with nothing more than
    just a basic enclosure and the stepper motion control board that move the head
    across the machin bed, from a usability and safety point of view, this is not
    desirable. Still, many of the cheap laser cutters one can purchase online, however, do
    not come with any safety or usability features whatsoever.
  prefs: []
  type: TYPE_NORMAL
- en: Functional specification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete the product, we need to add a control system that uses sensors
    and actuators to monitor and control the state of the machine, ensuring that it
    is always in a safe state and shutting down the laser beam if necessary. This
    means protecting access to each of the following three sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/897f1ff6-32a8-4358-b81d-d2bdd82b8d69.png)'
  prefs: []
  type: TYPE_IMG
- en: The cutting beam is usually generated by a CO[2] laser, a type of gas laser
    that was invented in 1964\. The application of a high voltage causes current flow
    and thereby excitement of the gas molecules in the bore that make up the gain
    medium, ultimately resulting in the formation of a coherent beam of **long-wavelength
    infrared** (**LWIR**) or IR-C, light at a wavelength of 9.4 or 10.6 µm.
  prefs: []
  type: TYPE_NORMAL
- en: One characteristic of LWIR is that it is strongly absorbed by a large number
    of materials, so that it can be used for engraving, cutting, and even surgery
    on tissues as the water in biological tissues efficiently absorbs the laser beam.
    This also makes it obvious why even brief exposure of one's skin to a CO[2] laser's
    beam is extremely dangerous.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve safe operation, exposure to laser light must be inhibited by locking
    the enclosure during normal operation, deactivating the laser power supply, and
    closing a beam shutter or preferably a combination of these measures when any
    of the interlocks is opened or any other safety condition is no longer satisfied.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, temperature limits have to be upheld: most CO[2] lasers comprise
    of water-cooled gas discharge tube, which can quickly crack or bend in case of
    a cooling fault. What''s more, the cutting process creates irritating or toxic
    fumes that need to be continuously removed from the enclosure so as not to contaminate
    the optics and exit into the environment when the lid is opened.'
  prefs: []
  type: TYPE_NORMAL
- en: These requirements necessitate that we monitor cooling water flow and temperature,
    air flow for the exhaust, and the air flow resistance (pressure drop over mass
    flow) of over the exhaust filter.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we also want to make it convenient to use the laser cutter and avoid
    having to "bring your own device" to process the design in a machine-specific
    way, then convert it and upload it to the stepper motion controller board via
    USB. Instead, we want to load the design project from an SD card or USB stick
    and use a simple LCD and buttons to set options.
  prefs: []
  type: TYPE_NORMAL
- en: The design requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the earlier requirements in mind, we can formulate a list of features
    needed for the control system:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Operator safety:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interlock switches on access panels (closed with the panel closed)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Locking mechanism (mechanically locking access panel; redundant)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Emergency stop
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Laser cooling:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pump relay
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Temperature sensor in water tank (cooling capacity, inlet temperature)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Temperature sensor on valve cooling exhaust (mantle temperature)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Flow sensor (water flow speed; redundant)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Air exhaust:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fan relay
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Air filter status (differential pressure sensor)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Fan speed (RPM)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Laser module:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Laser power relay
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Beam shutter (redundant)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: User interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Alert indicators for:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Panel interlock
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Air filter condition
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Fan status
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Pump status
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Water temperature
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Indicator LEDs for:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Standby
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Operation
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Emergency stop
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Cool down
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Communication:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: USB communication with stepper board (UART)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Motion control: generate stepper motor instructions'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Read files from SD card/USB stick
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Accept files over Ethernet/Wi-Fi
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: NFC reader to identify users
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation-related choices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As pointed out at the beginning of this chapter, mid-range MCUs are currently
    capable of providing the resources to satisfy most, if not all of our design requirements.
    So one of the tough questions is what we''ll be spending our money on: hardware
    components or software development? Imponderabilities aside, we''ll now take a
    closer look at three candidate solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: A single mid-range AVR MCU board (ATmega2560)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A higher-end Cortex-M3 MCU board (SAM3X8E)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A tandem of mid-range MCU board and an SBC with OS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We're pretty close to meeting hte design requirements with just an Arduino Mega
    (ATmega2560), as the first five sections require little in terms of CPU speed,
    just a number of digital input and output pins and a few analog ones depending
    on the exact sensors we'll be using or at most a peripheral interface to make
    use of (for example, for MEMS pressure sensors).
  prefs: []
  type: TYPE_NORMAL
- en: The challenge starts with motion control feature under communications in the
    previous feature list, where we suddenly have to convert a **vector graphics file**
    (**.svg**) to a series of stepper commands. This is a compound problem of data
    transfer, file parsing, path generation, and what is known in the robotic world
    as inverse kinematics. USB communications can also be problematic for our 8-bit
    MCU, mostly because of peak processor loads coinciding with timeouts for USB endpoint
    communication or UART RX buffer register handling.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key is knowing when to change gears. Motion control is time critical as
    it''s tied to the inertia of the physical world. Additionally, we''re constrained
    by the processing and bandwidth resources of our controller to make control and
    data transfers, buffering, and ultimately the processing and output generation
    itself happen. As a general pattern, more capable internal or external peripherals
    can relax timing requirements by handling events and memory transactions themselves,
    reducing context switching and processing overhead. Here''s an incomplete list
    of such considerations:'
  prefs: []
  type: TYPE_NORMAL
- en: Simple UART requires collecting every byte upon RX Complete (RXC). Failure to
    do so results in data loss, as indicated by the DOR flag. A few controllers such
    as ATmega8u2 through ATmega32u4 provide native hardware flow control via RTS/CTS
    lines, which can prevent USB-UART converters such as PL2303 and FT232 from sending,
    forcing them to do the buffering instead until UDR is conveniently emptied again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dedicated USB host peripherals such as the MAX3421 are connected via SPI and
    effectively remove USB timing requirements for mass storage integration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UART aside, network communication peripherals are inherently buffered in software
    due to the complexity of the layer stack. For Ethernet, the W5500 is an attractive
    solution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It sometimes makes sense to add another smaller MCU that independently handles
    I/O and pattern generation while implementing an interface of our choice – e.g.
    serial or parallel. This is already the case with some Arduino boards featuring
    an ATmega16u2 for USB serial conversion.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The NFC reader feature requirement calls for **Near-Field Communication** (**NFC**,
    a subset of RFID) to prevent unauthorized use of the laser cutter, which would
    add the biggest burden of all. Not due to the communicating with the NFC reader
    itself, but due to the increase in code size and CPU requirements to handle cryptography
    with certificates depending on the security level chosen. We would also need a
    secure place to store the certificates which usually bumps up MCU specs.
  prefs: []
  type: TYPE_NORMAL
- en: Now we are at the point where we consider the more advanced options. The simpler
    ATmega2560 remains a great fit with its large amount of GPIO and can read SD cards
    over SPI along with communicating with an external integrated ethernet chip. However,
    the computationally or memory intensive tasks in motion control and NFC reader
    feature list would likely overburden the MCU or lead to convoluted "optimized"
    solutions with inferior maintainability if one were to try.
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading the MCU to an ARM Cortex-M3 such as found on the Arduino Due development
    board, would likely resolve all those bottlenecks. It would preserve the large
    number of GPIO we got accustomed to on the ATmega2560, while increasing CPU performance
    significantly. The stepper drive patterns can be generated on the MCU, which also
    presents with native USB support, along with other advanced peripherals (USART,
    SPI and I2C and HSMCI, which also have DMA).
  prefs: []
  type: TYPE_NORMAL
- en: 'A basic NFC tag reader could be connected via a UART, SPI, or I2C, and this
    design choice would lead to a system as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a97fac06-4f02-4255-b48c-c2ba8fb95b60.png)'
  prefs: []
  type: TYPE_IMG
- en: The third embodiment involving an SBC would again make use of the ATmega2560
    and add a low-powered SBC running an OS. This SBC would handle any CPU-intensive
    tasks, Ethernet and Wi-Fi connectivity, USB (host) tasks, and so on. It would
    communicate with the ATmega side via a UART, possibly adding a digital isolator
    or level shifter in between the boards to accommodate the 3.3V (SBC) and 5V TTL
    (Atmega) logic levels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Choosing the SBC + MCU solution would substantially change the software challenges
    but only slightly reorganize our system on the hardware side. This would look
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/07063017-8a6b-4a0e-98ce-25e7f373a6fa.png)'
  prefs: []
  type: TYPE_IMG
- en: As with most development processes, there are only a few absolute answers, and
    many solutions pass functional requirements as *good enough* after trade-offs
    between power usage, complexity, and maintenance requirements affecting the final
    design choice.
  prefs: []
  type: TYPE_NORMAL
- en: In this particular example, one could choose either the higher-end single or
    dual-board solution, and it would most likely entail the same amount of effort
    to satisfy the requirements. One of the main differences would be that the OS-based
    solution adds the need to perform frequent OS updates, on account of it being
    a network-connected system running a full-blown OS whereas embedded ethernet controllers
    with offloaded hardwired TCP/IP stack and memories tend to be more robust and
    proven.
  prefs: []
  type: TYPE_NORMAL
- en: The Cortex-M3-based option (or the even faster Cortex-M4) would feature just
    our own code, and thus would be unlikely to have any common security issues that
    could be easily targeted. We wouldn't be off the hook for maintenance, but our
    code would be small enough to validate and read through in its entirety, with
    the only letdown that the Arduino Due design fails to break out the pins for RMII
    to hook up an external Ethernet PHY, discouraging the use of its internal Ethernet
    MAC.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running down the checklist we put together at the beginning of this chapter,
    but this time with the ATmega2560 + SBC and application in mind, gives us the
    following distribution of duties:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Peripherals**: The MCU side will mostly need GPIO, some analog (ADC) inputs,
    Ethernet, USB, along with SPI and/or I2C.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CPU**: The required MCU performance is time-critical but minor, except for
    when we need to do the processing of the vector path elements into stepper instructions.
    The SBC side can be sophisticated as long as enough commands can be queued for
    MCU-side execution and time-critical interaction is avoided.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Floating point**: The stepper instruction conversion algorithm on an MCU
    executes substantially faster if we have hardware floating point support. The
    length and time scales involved may make fixed point arithmetic feasible, relaxing
    this requirement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ROM**: The entire MCU code will likely fit into a few kilobytes since it''s
    not very complex. The SBC code will be larger by orders of magnitude just by invoking
    high-level libraries to provide the desired functionality but this will be more
    than offset by the similarly scaled mass storage and processing capabilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RAM**: A few KB of SRAM on the MCU should suffice. The stepper instruction
    conversion algorithm may require modifications to fit into the SRAM limitations
    with its buffering and processing data requirements. In a worst-case scenario,
    buffers can be downsized.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Power and thermals**: In the light of the laser cutter system''s power needs
    and cooling system, we have got no significant power or thermal limitations. The
    section containing the control system also houses the main power supply and is
    already equipped with an appropriately sized cooling fan.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's important to note at this point that although we realized the complexity
    and requirements of the task at hand sufficiently to draw conclusions leading
    us to a selection of hardware components, the aspects of how to achieve them in
    detail are still left to the software developer.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we could define our own data structures and formats and implement
    the machine-specific path generation and motion control ourselves, or adopt a
    (RS-274) G-code intermediate format which has been well-established in numerical
    control applications for several decades, and that lends itself well to generating
    motion control commands. G-code and has also found widespread acceptance in the
    diy hardware community, expecially for FDM 3D printing.
  prefs: []
  type: TYPE_NORMAL
- en: 'One noteworthy mature open source implementation of G-code based motion control
    is GRBL, introduced as:'
  prefs: []
  type: TYPE_NORMAL
- en: Grbl is a free, open source, high performance software for controlling the motion
    of machines that move, that make things, or that make things move, and will run
    on a straight Arduino. If the maker movement was an industry, Grbl would be the
    industry standard.
  prefs: []
  type: TYPE_NORMAL
- en: --https://github.com/gnea/grbl
  prefs: []
  type: TYPE_NORMAL
- en: Most likely we'll have to add halt and emergency stop features for different
    violations of our safety checks. While temperature excursions or a clogged filter
    would preferably just halt the laser cutter and permit resuming the job with the
    issues resolved, an interlock tripped by opening the enclosure must result in
    immediate shutdown of the laser, even without finishing the last command for a
    path segment and motion.
  prefs: []
  type: TYPE_NORMAL
- en: The choice to modularize the motion control task and produce G-code for it has
    benefits beyond the availability of proven implementations, allowing us to easily
    add usability features like manual control for setup and calibration as well as
    testability using previously generated, human-readable codes on the machine side
    just as inspection on the output of our file interpretation and path generation
    algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: With the list of requirements, the initial design completed, and a deepened
    understanding of how we are going to achieve our goals, the next step would be
    to obtain a development board (or boards) with the chosen MCU and/or SoC, along
    with any peripherals so that one can get started on developing the firmware and
    integrating the system.
  prefs: []
  type: TYPE_NORMAL
- en: While the full implementation of the machine control system as described in
    this example is beyond the scope of this book, an in-depth understanding of the
    development for both microcontroller and SBC target varieties will be strived
    for in the remainder of this chapter and [Chapter 6](7d5d654f-a027-4825-ab9e-92c369b576a8.xhtml),
    *Testing OS-Based Applications*, [Chapter 8](4416b2de-d86a-4001-863d-b167635a0e10.xhtml),
    *Example - Linux-Based Infotainment* System, and [Chapter 11](c90e29ad-2e13-4838-a9c2-885209717513.xhtml),
    *Developing for Hybrid SoC/FPGA Systems*, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Embedded IDEs and frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the application development for SoCs tends to be quite similar to desktop
    and server environments, as we saw in the previous chapter, MCU development requires
    a far more intimate knowledge of the hardware that one is developing for, sometimes
    down to the exact bits to set in a particular register.
  prefs: []
  type: TYPE_NORMAL
- en: There exist some frameworks that seek to abstract away such details for particular
    MCU series, so that one can develop for a common API without having to worry about
    how it is implemented on a specific MCU. Of these, the Arduino framework is the
    most well-known outside of industrial applications, though there are also a number
    of commercial frameworks that are certified for production use.
  prefs: []
  type: TYPE_NORMAL
- en: Frameworks such as the **Advanced Software Framework** (**ASF**) for AVR and
    SAM MCUs can be used with a variety of IDEs, including Atmel Studio, Keil µVision,
    and IAR Embedded Workbench.
  prefs: []
  type: TYPE_NORMAL
- en: 'A non-exhaustive list of popular embedded IDEs follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Company** | **License** | **Platforms** | **Notes** |'
  prefs: []
  type: TYPE_TB
- en: '| Atmel Studio | Microchip | Proprietary | AVR, SAM (ARM Cortex-M). | Originally
    developed by Atmel before being bought by Microchip. |'
  prefs: []
  type: TYPE_TB
- en: '| µVision | Keil (ARM) | Proprietary | ARM Cortex-M, 166, 8051, 251. | Part
    of the **Microcontroller Development Kit** (**MDK**) toolchain. |'
  prefs: []
  type: TYPE_TB
- en: '| Embedded Workbench | IAR | Proprietary | ARM Cortex-M, 8051, MSP430, AVR,
    Coldfire, STM8, H8, SuperH, etc. | Separate IDE for each MCU architecture. |'
  prefs: []
  type: TYPE_TB
- en: '| MPLAB X | Microchip | Proprietary | PIC, AVR. | Uses the Java-based NetBeans
    IDE as foundation. |'
  prefs: []
  type: TYPE_TB
- en: '| Arduino | Arduino | GPLv2 | Some AVR and SAM MCUs (extendable). | Java-based
    IDE. Only supports its own C dialect language. |'
  prefs: []
  type: TYPE_TB
- en: The main goal of an IDE is to integrate the entire workflow into a single application,
    from writing the initial code to programming the MCU memory with the compiled
    code and debugging the application while it runs on the platform.
  prefs: []
  type: TYPE_NORMAL
- en: Whether to use a full IDE is a matter of preference, however. All of the essential
    features are still there when using a basic editor and the tools from the command
    line, although frameworks such as the ASF are written to deeply integrate with
    IDEs.
  prefs: []
  type: TYPE_NORMAL
- en: One of the main advantages of the popular Arduino framework is that it has more
    or less standardized an API for various MCU peripherals and other functionality
    that is supported across an ever-growing number of MCU architectures. Coupled
    with the open source nature of the framework, it makes for an attractive target
    for a new project. This is particularly attractive when it comes to prototyping,
    courtesy of a large number of libraries and drivers written for this API.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the Arduino IDE is unfortunately focused purely on a stripped-down
    dialect of the C programming language, despite its core libraries making widespread
    use of C++. Still this enables us to integrate just the libraries into our own
    embedded C++ projects, as we will see later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Programming MCUs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After we have compiled our code for the target MCU, the binary image needs to
    be written to a controller memory prior to execution and debugging. In this section
    we will look at the varied ways in which this can be accomplished. These days
    only factory-side programming is done with test sockets, or better yet at the
    wafer level before a known good die is bonded to a leadframe and encapsulated.
    Surface-mount parts already rule out easy removal of an MCU for (repeated) programming.
  prefs: []
  type: TYPE_NORMAL
- en: A number of (frequently vendor-specific) options for in-circuit programming
    exist, distinguished by the peripherals they use and the memories they affect.
  prefs: []
  type: TYPE_NORMAL
- en: So a pristine MCU often needs to be programmed using an external programming
    adapter. These generally work by setting the pins of the MCU so that it enters
    programming mode, after which the MCU accepts the data stream containing the new
    ROM image.
  prefs: []
  type: TYPE_NORMAL
- en: Another option that is commonly used is to add a boot loader to the first section
    of the ROM, which allows the MCU to program itself. This works by having the boot
    loader check on startup whether it should switch to programming mode or continue
    loading the actual program, placed right after the boot loader section.
  prefs: []
  type: TYPE_NORMAL
- en: Memory programming and device debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'External programming adapters often utilize dedicated interfaces and associated
    protocols which permit programming and debugging of the target device. Protocols
    with which one can program an MCU include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Pins** | **Features** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| **SPI (ISP)** | **4** | program | **Serial Peripheral Interface** (**SPI**),
    used with older AVR MCUs to access its Serial Programmer mode (**In-circuit Serial
    Programming** (**ISP**)). |'
  prefs: []
  type: TYPE_TB
- en: '| **JTAG** | **5** | program debug'
  prefs: []
  type: TYPE_NORMAL
- en: boundary | Dedicated, industry-standard on-chip interface for programming and
    debugging support. Supported on AVR ATxmega devices. |
  prefs: []
  type: TYPE_NORMAL
- en: '| **UPDI** | **1** | program debug | The **Unified Programming and Debug Interface**
    (**UDPI**) used with newer AVR MCUs, including ATtiny devices. It''s a single-wire
    interface that''s the successor to the two-wire PDI found on ATxmega devices.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **HVPP/****HVSP** | **17/****5** | program | High Voltage Parallel Programming
    / High Voltage Serial Programming. AVR programming mode using 12V on the reset
    pin and direct access to 8+ pins. Ignores any internal fuse setting or other configuration
    option. Mostly used for in-factory programming and for recovery. |'
  prefs: []
  type: TYPE_TB
- en: '| **TPI** | **3** | program | Tiny Programming Interface, used with some ATtiny
    AVR devices. These devices also lack the number of pins for HVPP or HVSP. |'
  prefs: []
  type: TYPE_TB
- en: '| **SWD** | **3** | program debug'
  prefs: []
  type: TYPE_NORMAL
- en: boundary | Serial Wire Debug. Similar to reduced pin count JTAG with two lines,
    but uses ARM Debug Interface features, allowing a connected debugger to become
    a bus master with access to the MCU's memory and peripherals. |
  prefs: []
  type: TYPE_NORMAL
- en: ARM MCUs generally provide JTAG as their primary means of programming and debugging.
    On 8-bit MCUs, JTAG is far less common, which is mostly due to the complexity
    of its requirements.
  prefs: []
  type: TYPE_NORMAL
- en: AVR MCUs tend to offer In-System Programming (ISP) via SPI in addition to high
    voltage programming modes. Entering programming mode requires that the reset pin
    be held low during programming and verification and released and strobed at the
    end of the programming cycle.
  prefs: []
  type: TYPE_NORMAL
- en: One requirement for ISP is that the relevant (SPIEN fuse bit) in the MCU is
    set to enable the in-system programming interface. Without this bit set, the device
    won’t respond on the SPI lines. Without JTAG available and enabled via the JTAGEN
    fuse bit, only HVPP or HVSP are available to recover and reprogram the chip. In
    the latter case, the unusual set of pins and the 12V supply voltage do not necessarily
    integrate well into the board circuitry.
  prefs: []
  type: TYPE_NORMAL
- en: 'The physical connections required for most serial programming interfaces are
    fairly simple, even when the MCU has already been integrated into a circuit as
    shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b03d2974-c53c-4473-aec3-c599459b49e2.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, the external oscillator is optional if an internal one exists. The **PDI**,
    **PDO**, and **SCK** lines correspond to their respective SPI lines. The Reset
    line is held active (low) during programming. After connecting to the MCU in this
    manner, we are free to write to its flash memory, EEPROM, and configuration fuses.
  prefs: []
  type: TYPE_NORMAL
- en: On newer AVR devices, we find the **Unified Programming and Debug Interface**
    (**UPDI**), which uses just a single wire (in addition to the power and ground
    lines) to connect to the target MCU to provide both programming and debug support.
  prefs: []
  type: TYPE_NORMAL
- en: 'This interface simplifies the previous connection diagram to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b0bfa79c-4d7e-4d8e-bec0-5e232d4c017f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This favorably compares to JTAG (IEEE 1149.1) on the ATxmega (when enabled)
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bd797ef1-480e-4ff2-91b1-9b42f5bd02d6.png)'
  prefs: []
  type: TYPE_IMG
- en: Thereduced pin count JTAG standard (IEEE 1149) implemented on the ATxmega requires
    only one clock TCKC, one data wire TMSC and is aptly called Compact JTAG. Of these
    interfaces, UPDI still requires the fewest connections with the target device.
    Apart from that, both support similar features for AVR MCUs.
  prefs: []
  type: TYPE_NORMAL
- en: For other systems using JTAG for programming and debugging, no standard connection
    exists. Each manufacturer uses their own preferred connector, ranging from 2 x
    5 pins (Altera, AVR) to 2 x 10 pins (ARM), or a single 8-pin connector (Lattice).
  prefs: []
  type: TYPE_NORMAL
- en: With JTAG being more a protocol standard rather than a physical specification,
    one should consult the documentation for one's target platform for the specific
    details.
  prefs: []
  type: TYPE_NORMAL
- en: Boot loader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The boot loader has been introduced as a small extra application that uses an
    existing interface (for example, UART or Ethernet) to provide self-programming
    capabilities. On the AVR, a boot loader section of 256 bytes to 4 KB can be reserved
    in its flash. This code can perform any number of user-defined tasks, from setting
    up a serial link with a remote system, to booting from a remote image over Ethernet
    using PXE.
  prefs: []
  type: TYPE_NORMAL
- en: 'At its core, an AVR boot loader is no different from any other AVR application,
    except that when compiling it one extra linker flag is added to set the starting
    byte address for the boot loader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace this address with a similar one for the specific MCU that you''re using
    (for AVR depending on the BOOTSZ flags set and controller used, see datasheet
    table about Boot Size Configuration: Boot Reset Address, where, for example, the
    boot reset address is 0xC00 is in words and the section start is defined in bytes).
    This ensures that the boot loader code will be written to the proper location
    in the MCU''s ROM. Writing the boot loader code to the ROM is almost always done
    via ISP.'
  prefs: []
  type: TYPE_NORMAL
- en: 'AVR MCUs divide the flash ROM into two sections: the **no-read-while-write **(**NRWW**)
    (for most, if not all application memory space) and **read-while-write** (**RWW**)
    sections. In brief, this means that the RWW section can be safely erased and rewritten
    without affecting the CPU''s operation. This is why the boot loader resides in
    the NRWW section and also why it''s not easy to have the boot loader update itself.'
  prefs: []
  type: TYPE_NORMAL
- en: Another important detail is that the boot loader can also not update the fuses
    that set various flags in the MCU. To change these, one has to externally program
    the device.
  prefs: []
  type: TYPE_NORMAL
- en: After programming the MCU with a boot loader, one would generally set the flags
    in the MCU that let the processor know that a boot loader has been installed.
    In the case of AVR, these flags are BOOTSZ and BOOTRST.
  prefs: []
  type: TYPE_NORMAL
- en: Memory management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The storage and memory system of microcontrollers consists out of multiple components.
    There is a section of **read-only-memory** (**ROM**) that is only written to once
    when the chip is programmed, but which cannot normally be altered by the MCU itself,
    as we saw in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The MCU may also have a bit of persistent storage, in the form of EEPROM or
    equivalent. Finally, there are CPU registers and the **random-access memory**
    (**RAM**). This results in the following exemplary memory layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eefb6e49-e5ff-4360-b08c-a862fb6e0530.png)'
  prefs: []
  type: TYPE_IMG
- en: The use of a modified Harvard architecture (split program and data memory at
    some architectural level, generally with the data buses) is common with MCUs.
    With the AVR architecture, for example, the program memory is found in the ROM,
    which for the ATmega2560 is connected using its own bus with the CPU core, as
    one can seen on the block diagram for this MCU, which we looked at previously
    in [Chapter 1](0ff8cac9-3155-45e1-af05-7005fc419dd6.xhtml), *What Are Embedded
    Systems?*
  prefs: []
  type: TYPE_NORMAL
- en: A major advantage of having separate buses for these memory spaces is that one
    can address each of them separately, which makes better use of the limited addressing
    space available to an 8-bit processor (1 and 2 byte wide address). It also allows
    for concurrent accesses while the CPU is busy with the other memory space, further
    optimizing the available resources.
  prefs: []
  type: TYPE_NORMAL
- en: For the data memory in the SRAM, we are then free to use it as we want. Here,
    we do need at least a stack to be able to run a program. Depending on how much
    SRAM is left in the MCU, we can then also add a heap. Applications of moderate
    complexity can be realized with only stack and statically allocated memory though,
    not involving higher-level language features that produce code with heap allocations.
  prefs: []
  type: TYPE_NORMAL
- en: Stack and heap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whether one needs to initialize the stack on the MCU that one is programming
    for depends on how low-level one wishes to go. When using the C-runtime (on AVR:
    `avr-libc`), the runtime will handle initializing the stack and other details
    by letting the linker place naked code into init sections, for example specified
    by:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Preceding the execution of any of our own application code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The standard RAM layout on AVR is to start with the `.data` variables at the
    beginning of the RAM, followed by `.bss`. The stack is started from the opposite
    site of the RAM, growing towards the beginning. There will be room left between
    the end of the `.bss` section and the end of the stack illustrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c84909aa-7715-46f6-9538-5760568e9748.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Since the stack grows depending on the depth of the function calls in the application
    being run, it is hard to say how much space is available. Some MCUs allow one
    to use external RAM as well, which would be a possible location for the heap as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e568f5de-0419-4838-bbe9-3b238d5f9280.png)'
  prefs: []
  type: TYPE_IMG
- en: The AVR Libc library implements a `malloc()` memory allocator routine, optimized
    for the AVR architecture. Using it, one can implement one's own `new` and `delete`
    functionality as well—if one so desires—since the AVR toolchain does not implement
    either.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use external memory with an AVR MCU for heap storage, one would
    have to make sure that the external memory has been initialized, after which the
    address space becomes available to `malloc()`. The start and end of the heap space
    is hereby defined by these global variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The AVR documentation has the following advice regarding adjusting the heap:'
  prefs: []
  type: TYPE_NORMAL
- en: If the heap is going to be moved to external RAM, `__malloc_heap_end` must be
    adjusted accordingly. This can either be done at runtime, by writing directly
    to this variable, or it can be done automatically at link-time, by adjusting the
    value of the symbol `__heap_end`.
  prefs: []
  type: TYPE_NORMAL
- en: Interrupts, ESP8266 IRAM_ATTR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On a desktop PC or server the entire application binary would be loaded into
    RAM. On MCUs though it is common to leave as many of the program instructions
    in the ROM as possible until they are needed. This means that most of our application's
    instructions cannot be executed immediately, but first have to be fetched from
    ROM before the CPU of our MCU can fetch them via the instruction bus to be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the AVR, each possible interrupt is defined in a vector table, which is
    stored in ROM. This offers either default handlers for each interrupt type, or
    the user-defined version. To mark an interrupt routine, one either uses the `__attribute__((signal))`
    attribute, or uses the `ISR()` macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This macro handles the details of registering an interrupt. One just has to
    specify the name and define a function for the interrupt handler. This will then
    get called via the interrupt vector table.
  prefs: []
  type: TYPE_NORMAL
- en: With the ESP8266 (and its successor, the ESP32) we can mark the interrupt handler
    function with a special attribute, `IRAM_ATTR`. Unlike the AVR, the ESP8266 MCU
    does not have built-in ROM, but has to use its SPI peripheral to load any instructions
    into RAM, which is obviously quite slow.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of using this attribute with an interrupt handler looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have an interrupt handler that is connected to the signal from a motion
    detector, connected to an input pin. As with any well-written interrupt handler,
    it is quite simple and meant to be quickly executed before returning to the normal
    flow of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Having this handler in ROM would mean that the routine would not respond near-instantly
    to the motion sensor's output changing. Worse, it would cause the handler to take
    much longer to finish, which would consequently delay the execution of the rest
    of the application code.
  prefs: []
  type: TYPE_NORMAL
- en: By marking it with `IRAM_ATTR`, we can avoid this problem, since the entire
    handler will already be in RAM when it's needed, instead of the whole system stalling
    as it waits for the SPI bus to return the requested data before it can continue.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, tempting as it may seem, this kind of attribute should be used sparingly,
    as most MCUs have much more ROM than RAM. In the case of ESP8266, there are 64kB
    RAM for code execution complemented by possibly megabytes of external Flash ROM.
  prefs: []
  type: TYPE_NORMAL
- en: When compiling our code, the compiler will put instructions marked with this
    attribute into a special section, so that the MCU knows to load it into RAM.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With a few exceptions, MCUs are single-core systems. Multitasking is not something
    that is generally done; instead, there's a single thread of execution with timers
    and interrupts adding asynchronous methods of operation.
  prefs: []
  type: TYPE_NORMAL
- en: Atomic operations are generally supported by compilers and AVR is no exception.
    The need for atomic blocks of instructions can be seen in the following cases.
    Keep in mind that while a few exceptions exist (MOVW to copy a register pair and
    indirect addressing via X, Y, Z pointers), instructions on an 8 bit architecture
    generally only affect 8 bit values.
  prefs: []
  type: TYPE_NORMAL
- en: A 16 bit variable is byte-wise read in the main function and updated in an ISR.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 32 bit variable is read, modified and subsequently stored back in either main
    function or ISR while the other routine could try to access it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The execution of a block of code is time-critical (bitbanging I/O, disabling
    JTAG).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A basic example for the first case is given in the AVR libc documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this code, a 16-bit integer is being changed in the interrupt handler, while
    the main routine is copying its value into a local variable. We call `sei()` (SEt
    global Interrupt flag) to ensure that the interrupt register is in a known state.
    The `volatile` keyword hints to the compiler that this variable and how it's accessed
    should not be optimized in any way.
  prefs: []
  type: TYPE_NORMAL
- en: Because we included the AVR atomic header, we can use the `ATOMIC_BLOCK` macro,
    along with the `ATOMIC_FORCEON` macro. What this does is create a code section
    that is guaranteed to be executed atomically, without any interference from interrupt
    handlers and the like. The parameter we pass to `ATOMIC_BLOCK` forces the global
    interrupt status flag into an enabled state.
  prefs: []
  type: TYPE_NORMAL
- en: Since we set this flag to the same state before we started the atomic block,
    we do not need to save the previous value of this flag, which saves resources.
  prefs: []
  type: TYPE_NORMAL
- en: As noted earlier, MCUs tend to be single-core systems, with limited multitasking
    and multithreading capabilities. For proper multithreading and multitasking, one
    would need to do context switches, whereby not only the stack pointer of the running
    task is saved, but also the state of all registers and related.
  prefs: []
  type: TYPE_NORMAL
- en: This means that while it would be possible to run multiple threads and tasks
    on a single MCU, in the case of 8-bit MCUs such as the AVR and PIC (8-bit range),
    the effort would most likely not be worth it, and would require a significant
    amount of labor.
  prefs: []
  type: TYPE_NORMAL
- en: On more powerful MCUs (like the ESP8255 and ARM Cortex-M), one could run **real-time
    OSes** (**RTOSes**), which implement exactly such context switching, without having
    to do all of the heavy lifting. We will look at RTOSes later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: AVR development with Nodate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microchip provides a binary version of the GCC toolchain for AVR development.
    At the time of writing, the most recent release of AVR-GCC is 3.6.1, containing
    GCC version 5.4.0\. This implies full support for C++14 and limited support for
    C++17.
  prefs: []
  type: TYPE_NORMAL
- en: Using this toolchain is pretty easy. One can simply download it from the Microchip
    website, extract it to a suitable folder, and add the folder containing the GCC
    executable files to the system path. After this, it can be used to compile AVR
    applications. Some platforms will have the AVR toolchain available via a package
    manager as well, which makes the process even easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing that one may notice after installing this GCC toolchain is that there
    is no C++ STL available. As a result, one is limited to just the C++ language
    features supported by GCC. As the Microchip AVR FAQ notes:'
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, none of the C++ related standard functions, classes, and template
    classes are available.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The operators new and delete are not implemented; attempting to use them will
    cause the linker to complain about undefined external references. (This could
    perhaps be fixed.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of the supplied include files are not C++ safe, that is, they need to be
    wrapped into `extern"C" { . . . }`. (This could certainly be fixed, too.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exceptions are not supported. Since exceptions are enabled by default in the
    C++ frontend, they explicitly need to be turned off using `-fno-exceptions` in
    the compiler options. Failing this, the linker will complain about an undefined
    external reference to `__gxx_personality_sj0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the lack of a Libstdc++ implementation that would contain the STL features,
    we can only add such functionality by using a third-party implementation. These
    include versions that provide essentially the full STL, as well as lightweight
    re-implementations that do not follow the standard STL API. An example of the
    latter is the Arduino AVR core, which provides classes such as String and Vector,
    which are similar to their STL equivalents albeit with some limitations and differences.
  prefs: []
  type: TYPE_NORMAL
- en: An upcoming alternative to the Microchip AVR GCC toolchain is LLVM, a compiler
    framework to which experimental support for AVR as been recently added, and which
    at some point in the future should allow producing binaries for AVR MCUs, all
    the while providing full STL functionality via its Clang frontend (C/C++ support).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5b4b8498-6d84-46e3-9887-ab7249b81b3d.png)'
  prefs: []
  type: TYPE_IMG
- en: Consider this an abstract snapshot of LLVM development—all the while illustrating
    the general concept of LLVM and its emphasis on Intermediate Representation.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately the PIC range of MCUs, despite also being owned by Microchip and
    resembling AVR in many ways, does at this point not have a C++ compiler available
    for it from Microchip until one moves up to the PIC32 (MIPS-based) range of MCUs.
  prefs: []
  type: TYPE_NORMAL
- en: Enter Nodate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You could at this point opt to use one of the IDEs we discussed previously in
    this chapter, but that wouldn't be nearly as educational for AVR development itself.
    For this reason, we will look at a simple application developed for an ATmega2560
    board that uses a modified version of the Arduino AVR core, called Nodate ([https://github.com/MayaPosch/Nodate](https://github.com/MayaPosch/Nodate)).
    This framework restructures the original core to allow it to be used as a regular
    C++ library instead of only with the Arduino C-dialect parser and frontend.
  prefs: []
  type: TYPE_NORMAL
- en: 'Installing Nodate is pretty easy: simply download to a suitable location on
    one''s system and have the `NODATE_HOME` system variable point to the root folder
    of the Nodate installation. After this, we can take one of the example applications
    as a basis for a new project.'
  prefs: []
  type: TYPE_NORMAL
- en: Example – CMOS IC Tester
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we will look at a more full-featured example project, implementing an
    **integrated circuit** (**IC**) tester for 5V logic chips. In addition to probing
    chips with its GPIO pins, this project also reads a chip description and test
    program (in the form of a logic table) from an SD card over SPI. User control
    is added in the form of a serial-based command-line interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we look at the `Makefile` for this Nodate project, as found in the root
    of the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The first item we specify is the architecture we are targeting, since Nodate
    can be used to target other MCU types as well. Here, we specify AVR as the architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we use the preset for the Arduino Mega 2560 development board. Inside
    Nodate, we have a number of presets like these, which define a number of details
    about the board. For the Arduino Mega 2560, we get the following presets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If no board preset is defined, one has to define those variables in the project's
    Makefile and pick an existing value for each variable, each of which is defined
    as its own Makefile within the Nodate AVR subfolders. Alternatively, one can add
    one's own MCU, programmer, and (pin) variant file to Nodate, along with a new
    board preset, and use that.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the makefile complete it is time to implement the main function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The wiring header provides access to all GPIO-related functionality. Furthermore,
    we include headers for the SPI bus, the SD card reader device, and a custom class
    that wraps the serial interface, as we will see in more detail in a moment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Upon entering the main function, we initialize the GPIO functionality with a
    call to `init()`. The next call loads the pin configuration for the particular
    board we are targeting (the `VARIANT` variable on the top or in the board preset
    Makefile).
  prefs: []
  type: TYPE_NORMAL
- en: 'After this, we start the first serial port with a speed of 9,600 baud, followed
    by the SPI bus, and finally the output of a welcome message, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: An SD card is expected to be attached to the Mega board at this point, containing
    a list of available chips we can test. Here, pin 53 is the hardware SPI chip-select
    pin that is conveniently located next to the rest of the SPI pins on the board.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming the board is hooked up properly and the card can be read without issues,
    we are presented with a command-line prompt on the console screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This loop simply waits for input to arrive on the serial input, after which
    it will attempt to execute the received command. The function we call for reading
    from the serial input is blocking, returning only if it has either received a
    newline (user pressed *Enter*), or its internal buffer size was exceeded without
    receiving a newline. In the latter case, we simply dismiss the input and try to
    read from the serial input once more. This concludes the `main()` implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now look at the header of the `SerialComm` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We include the header for the hardware serial connection support. This gives
    us access to the underlying UART peripheral. The class itself is purely static,
    defining the maximum size of the character buffer, and the function to read a
    line from the serial input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next is its implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the `while` loop, we first enter a loop that runs while there are no characters
    to be read in the serial input buffer. This makes it a blocking read.
  prefs: []
  type: TYPE_NORMAL
- en: Since we want to be able to see what we're typing, in the next section we echo
    back any character we have read. After this, we check whether we have received
    a newline character. If we did, we add a terminating null byte to the local buffer
    and read it into the String instance we were provided a reference to, after which
    we return true.
  prefs: []
  type: TYPE_NORMAL
- en: A possible improvement one could implement here is that of a backspace feature,
    where the user could delete characters in the read buffer by using the backspace
    key. For this, one would have to add a case for the backspace control character
    (ASCII 0x8), which would delete the last character from the buffer, and optionally
    also have the remote terminal delete its last visible character.
  prefs: []
  type: TYPE_NORMAL
- en: With no newline found yet, we continue to the next section. Here, we check whether
    we have received a valid character considered as ASCII 0x20, or a space. If we
    did, we continue to add the new character to the buffer and finally check whether
    we have reached the end of the read buffer. If we did not, we return false to
    indicate that the buffer is full yet no newline has been found.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next are the handler functions `readIndex()` and `readChipConfig()` for the
    `index` and `chip` commands, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This function makes heavy use of the `SD` and associated `File` classes from
    the Arduino SD card library. Essentially, we open the chips index file on the
    SD card, ensure we got a valid file handle, then proceed to read out and print
    each line in the file. This file is a simple line-based text-file, with one chip
    name per line.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the handler code, we're done reading from SD and the file handle
    can be closed with `sdFile.close()`. The same applies to the slightly more lengthy
    upcoming `readChipHandler()` implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As an example, when we run the test with a simple HEF4001 IC (4000 CMOS series
    Quad 2-Input OR Gate) hooked up, we have to add a file to the SD card which contains
    the test description and control data for this IC. The `4001.ic` test file is
    shown here as it lends itself to following along the code that parses it and performs
    the corresponding tests.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The first three lines are printed verbatim as we saw earlier, with the remaining
    lines specifying individual test scenarios. These tests are lines and use the
    following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We write this file as `4001.ic` along with an updated `index.idx` file (containing
    the ''4001'' entry on a new line) to the SD card. to support more ICs we would
    simply repeat this pattern with their respective test sequences and list them
    in the index file.Finally there is the handler for the chip configuration, which
    also starts the testing procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by asking the user for the name of the IC, as printed out earlier
    by the `index` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We attempt to open the file with the IC details, continuing with reading out
    the file contents, starting with the name and description of the IC that we are
    testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'After displaying the name and description of this IC, we read out the line
    that contains the instructions on how to connect the IC to the headers of our
    Mega board:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, we ask the user for confirmation on whether to start testing the IC. Any
    command beyond `start` will abort the test and return to the central command loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon receiving `start` as a command, the testing begins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As the first step, we read out the next line in the IC file, which should contain
    the first test. The first section contains the input pin settings, with the section
    after the equal sign containing the IC's output pin and its expected value for
    this test.
  prefs: []
  type: TYPE_NORMAL
- en: 'We print out the board header number that the result pin is connected to and
    the expected value. Next, we set the result pin to be an input pin so that we
    can read it out after the test has finished:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: For the actual test, we use the first String we read out from the file for this
    test, parsing it to get the values for the input pins. For each pin, we first
    get its number, then get the value (`0` or `1`).
  prefs: []
  type: TYPE_NORMAL
- en: 'We echo these pin numbers and values to the serial output, before setting the
    pin mode for these pins to output mode and then writing the test value to each
    of them, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: After leaving the inner loop, all of the input values will have been set. We
    just have to wait briefly to ensure that the IC has had time to settle on its
    new output values before we attempt to read out the result value on its output
    pin.
  prefs: []
  type: TYPE_NORMAL
- en: IC validation is a simple read on the result pin, after which we compare the
    value we received with the expected value. The result of this comparison is then
    printed to the serial output.
  prefs: []
  type: TYPE_NORMAL
- en: With the test complete, we close the IC file and return to the central command
    loop to await the next instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'After flashing the program to the Mega board and connecting with it on its
    serial port, we get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: After starting up, we get the message that the SD card was found and successfully
    initialized. We can now read from the SD card. We also see the available commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we specify the `index` command to get an overview of the available ICs
    we can test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: With just one IC available to test, we specify the `chip` command to enter the
    IC entry menu, after which we enter the IC's specifier.
  prefs: []
  type: TYPE_NORMAL
- en: This loads the file we put on the SD card and prints the first three lines.
    It then waits to give us time to hook up the chip, following the header numbers
    on the Mega board and the pin designations for the IC as provided by its datasheet.
  prefs: []
  type: TYPE_NORMAL
- en: 'After checking that we didn''t get any of our wires crossed, we type `start`
    and confirm. This starts the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: For each of the four identical OR gates in the chip, we run through the same
    truth table, testing each input combination. This specific IC passed with flying
    colors and can be safely used in a project.
  prefs: []
  type: TYPE_NORMAL
- en: This kind of testing device would be useful for testing any kind of 5V-level
    IC, including 74 and 4000 logic chips. It would also be possible to adapt the
    design to use the PWM, ADC, and other pins to test ICs that aren't strictly digital
    in their inputs and outputs.
  prefs: []
  type: TYPE_NORMAL
- en: ESP8266 development with Sming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For ESP8266-based development, no official development tools exist from its
    creator (Espressif) beyond a bare-metal and RTOS-based SDK. Open source projects
    including Arduino then provide a more developer-friendly framework to develop
    applications with. The C++ alternative to Arduino on ESP8266 is Sming ([https://github.com/SmingHub/Sming](https://github.com/SmingHub/Sming)),
    which is an Arduino-compatible framework, similar to Nodate for AVR, which we
    looked at in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter ([Chapter 5](886aecf2-8926-4aec-8045-a07ae2cdde84.xhtml),
    *Example - Soil Humidity Monitor with Wi-Fi*) we will take an in-depth look at
    developing with this framework on the ESP8266.
  prefs: []
  type: TYPE_NORMAL
- en: ARM MCU development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developing for ARM MCU platforms isn't significantly different from developing
    for AVR MCUs, except that C++ is far better supported, and there exists a wide
    range of toolchains to choose from, as we saw at the beginning of this chapter
    with just the list of popular IDEs. The list of available RTOSes for Cortex-M
    is much larger than for AVR or ESP8266 as well.
  prefs: []
  type: TYPE_NORMAL
- en: Using a free and open source compiler including GCC and LLVM to target a wide
    range of ARM MCU architectures (Cortex-M-based and similar) is where developing
    for ARM MCUs offers a lot of freedom, along with easy access to the full C++ STL
    (though one might want to hold off on exceptions).
  prefs: []
  type: TYPE_NORMAL
- en: 'When doing bare-metal development for Cortex-M MCUs, one may have to add this
    linker flag to provide basic stubs for some functionality that is normally provided
    by the OS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: One thing that makes ARM MCUs less attractive is that there are far fewer *standard*
    boards and MCUs, such as with what one sees with AVR in the form of the Arduino
    boards. Although the Arduino foundation at one point made the Arduino Due board
    based around a SAM3X8E Cortex-M3 MCU, this board uses the same form factor and
    roughly same pin layout (just being 3.3V I/O-based instead of 5V) as the ATmega2560-based
    Arduino Mega board.
  prefs: []
  type: TYPE_NORMAL
- en: Because of this design choice a lot of the functionality of the MCU has not
    been broken out and is inaccessible unless one is very handy with a soldering
    iron and thin wires. This functionality includes the Ethernet connection, tens
    of GPIO (digital) pins, and so on. This same lack of breaking out all pins also
    happens with the Arduino Mega (ATmega2560) board, but on this Cortex-M MCU it
    becomes even more noticeable.
  prefs: []
  type: TYPE_NORMAL
- en: The result of this is that as a development and prototyping board, there aren't
    any obvious generic picks. One might be tempted to just use the relatively cheap
    and plentiful prototyping boards like those provided by STMicroelectronics for
    their range of Cortex-M-based MCUs.
  prefs: []
  type: TYPE_NORMAL
- en: RTOS usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the limited resources available on the average MCU, and the generally fairly
    straightforward process loop in the applications that run on them, it is hard
    to make a case for using an RTOS on these MCUs. It's not until one has to do complicated
    resource and task management that it becomes attractive to use an RTOS in order
    to save development time.
  prefs: []
  type: TYPE_NORMAL
- en: The benefit of using an RTOS thus lies mostly in preventing one from having
    to reinvent the wheel. This is however something that has to be decided on a case-by-case
    basis. For most projects, having to integrate an RTOS into the development toolchain
    is more likely than an unrealistic idea that would add more to the workload than
    it would lighten it.
  prefs: []
  type: TYPE_NORMAL
- en: For projects where one is, for example, trying to balance CPU time and system
    resources between different communication and storage interfaces, as well as a
    user interface, the use of an RTOS might make a lot of sense, however.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in this chapter, a lot of embedded development uses a simple loop
    (super-loop) along with a number of interrupts to handle real-time tasks. When
    sharing data between an interrupt function and the super-loop, it is the responsibility
    of the developer to ensure that it is done safely.
  prefs: []
  type: TYPE_NORMAL
- en: Here, an RTOS would offer a scheduler and even the ability to run tasks (processes)
    that are isolated from each other (especially on MCUs that have a **Memory Management
    Unit** (**MMU**)). On a multi-core MCU, an RTOS easily allows one to make effective
    use of all cores without having to do one's own scheduling.
  prefs: []
  type: TYPE_NORMAL
- en: As with all things, the use of an RTOS isn't just a collection of advantages.
    Even ignoring the increase in ROM and RAM space requirements that will likely
    result from adding an RTOS to one's project, it will also fundamentally change
    some system interactions and may (paradoxically) result in interrupt latency increasing.
  prefs: []
  type: TYPE_NORMAL
- en: This is why, although the name has *real-time* in it, it is very hard to get
    more real-time than to use a simple execution loop and a handful of interrupts.
    The benefit of an RTOS, thus, is absolutely something about which no blanket statements
    can be made, especially when a support library or framework for bare-metal programming
    (such as the Arduino-compatible ones addressed in this chapter) is already available
    to make prototyping and developing for production as simple as tying a number
    of existing libraries together.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a look at how to select the right MCU for a new project,
    as well as how to add peripherals and deal with Ethernet and serial interface
    requirements in a project. We considered how memory is laid out in a variety of
    MCUs and how to deal with the stack and heap. Finally, we looked at an example
    AVR project, how to develop for other MCU architectures, and whether to use an
    RTOS.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the reader is expected to be able to argue why they would pick
    one MCU over another, based on a set of project requirements. They should be capable
    of implementing simple projects using the UART and other peripherals, and understand
    proper memory management as well as the use of interrupts.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a good look at how to develop for the ESP8266,
    in the form of an embedded project that will keep track of soil moisture levels
    and control a watering pump when needed.
  prefs: []
  type: TYPE_NORMAL
