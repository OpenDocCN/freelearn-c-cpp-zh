- en: Shadows
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阴影
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: Rendering shadows with shadow maps
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用阴影贴图渲染阴影
- en: Anti-aliasing shadow edges with PCF
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PCF抗锯齿阴影边缘
- en: Creating soft shadow edges with random sampling
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用随机采样创建柔和的阴影边缘
- en: Creating shadows using shadow volumes and the geometry shader
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用阴影体积和几何着色器创建阴影
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Shadows add a great deal of realism to a scene. Without shadows, it can be easy
    to misjudge the relative location of objects, and the lighting can appear unrealistic,
    as light rays seem to pass right through objects.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 阴影为场景增添了大量的真实感。没有阴影，很容易误判物体的相对位置，并且光照可能看起来不真实，因为光线似乎可以直接穿过物体。
- en: Shadows are important visual cues for realistic scenes, but can be challenging
    to produce in an efficient manner in interactive applications. One of the most
    popular techniques for creating shadows in real-time graphics is the **shadow
    mapping** algorithm (also called **depth shadows**). In this chapter, we'll look
    at several recipes surrounding the shadow mapping algorithm. We'll start with
    the basic algorithm, and discuss it in detail in the first recipe. Then, we'll
    look at a couple of techniques for improving the look of the shadows produced
    by the basic algorithm.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 阴影是真实场景的重要视觉线索，但在交互式应用程序中高效地产生阴影可能具有挑战性。在实时图形中创建阴影最流行的技术之一是**阴影贴图**算法（也称为**深度阴影**）。在本章中，我们将探讨围绕阴影贴图算法的几个配方。我们将从基本算法开始，并在第一个配方中详细讨论它。然后，我们将探讨几种改进基本算法产生的阴影外观的技术。
- en: We'll also look at an alternative technique for shadows called shadow volumes.
    Shadow volumes produce near perfect hard-edged shadows, but are not well-suited
    for creating shadows with soft edges.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将探讨一种称为阴影体积的阴影的替代技术。阴影体积产生几乎完美的硬边缘阴影，但不适合创建具有柔和边缘的阴影。
- en: Rendering shadows with shadow maps
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用阴影贴图渲染阴影
- en: One of the most common and popular techniques for producing shadows is called
    shadow mapping. In its basic form, the algorithm involves two passes. In the first
    pass, the scene is rendered from the point of view of the light source. The depth
    information from this pass is saved into a texture called the **shadow map**.
    This map will help provide information about the visibility of objects from the
    light's perspective. In other words, the shadow map stores the distance (actually
    the pseudo-depth) from the light to whatever the light can *see*. Anything that
    is closer to the light than the corresponding depth stored in the map is lit;
    anything else must be in shadow.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 产生阴影最常见且最受欢迎的技术被称为阴影贴图。在其基本形式中，算法涉及两个遍历。在第一次遍历中，场景从光源的角度渲染。这次遍历的深度信息被保存到一个称为**阴影贴图**的纹理中。这个贴图将帮助提供从光源视角看物体可见性的信息。换句话说，阴影贴图存储了从光源到其可以看到的任何物体的距离（实际上是伪深度）。任何比贴图中存储的相应深度更接近光源的东西都会被照亮；其他所有东西都必须处于阴影中。
- en: In the second pass, the scene is rendered normally, but each fragment's depth
    (from the light's perspective) is first tested against the shadow map to determine
    whether or not the fragment is in shadow. The fragment is then shaded differently
    depending on the result of this test. If the fragment is in shadow, it is shaded
    with ambient lighting only; otherwise, it is shaded normally.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二次遍历中，场景以正常方式渲染，但每个片段的深度（从光源的角度看）首先与阴影贴图进行测试，以确定该片段是否处于阴影中。然后根据测试结果对片段进行不同的着色。如果片段处于阴影中，则仅使用环境光照进行着色；否则，以正常方式着色。
- en: 'The following image shows an example of shadows produced by the basic shadow
    mapping technique:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了使用基本阴影贴图技术产生的阴影示例：
- en: '![](img/3c6d91b7-0823-4486-8d2f-2c5e8f64e576.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3c6d91b7-0823-4486-8d2f-2c5e8f64e576.png)'
- en: Let's look at each step of the algorithm in detail.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细查看算法的每个步骤。
- en: The first step is the creation of the shadow map. We set up our view matrix
    so that we are rendering the scene as if the camera is located at the position
    of the light source, and is oriented toward the shadow-casting objects. We set
    up a projection matrix so that the view frustum encloses all objects that may
    cast shadows as well as the area where the shadows will appear. We then render
    the scene normally and store the information from the depth buffer in a texture.
    This texture is called the shadow map (or simply depth map). We can think of it
    (roughly) as a set of distances from the light source to various surface locations.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建阴影图。我们设置视图矩阵，使得我们渲染的场景就像相机位于光源的位置，并且朝向产生阴影的对象。我们设置投影矩阵，使得视图视锥体包围所有可能产生阴影的对象以及阴影将出现的地方。然后我们正常渲染场景，并将深度缓冲区中的信息存储在纹理中。这个纹理被称为阴影图（或简单地称为深度图）。我们可以将其（大致上）视为从光源到各种表面位置的距离集合。
- en: Technically, these are depth values, not distances. A depth value is not a true
    distance (from the origin), but can be roughly treated as such for the purposes
    of depth testing.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上，这些是深度值，而不是距离。深度值不是一个真正的距离（从原点），但在深度测试的目的上可以大致如此处理。
- en: 'The following diagrams represent an example of the basic shadow mapping setup.
    The left diagram shows the light''s position and its associated perspective frustum.
    The right-hand diagram shows the corresponding shadow map. The greyscale intensities
    in the shadow map correspond to the depth values (darker is closer):'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表示了基本阴影映射设置的示例。左侧图显示了光线的位置及其相关的透视视锥体。右侧图显示了相应的阴影图。阴影图中的灰度强度对应于深度值（越暗越近）：
- en: '![](img/f91f2ae7-7bcf-48f0-befc-e97486ac7fd0.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f91f2ae7-7bcf-48f0-befc-e97486ac7fd0.png)'
- en: Once we have created the shadow map and stored the map in a texture, we render
    the scene again from the point of view of the camera. This time, we use a fragment
    shader that shades each fragment based on the result of a depth test with the
    shadow map. The position of the fragment is first converted into the coordinate
    system of the light source and projected using the light source's projection matrix.
    The result is then biased (in order to get valid texture coordinates) and tested
    against the shadow map. If the depth of the fragment is greater than the depth
    stored in the shadow map, then there must be some surface that is between the
    fragment and the light source. Therefore, the fragment is in shadow and is shaded
    using ambient lighting only. Otherwise, the fragment must have a clear view to
    the light source, and so it is shaded normally.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了阴影图并将该图存储在纹理中，我们再次从相机的视角渲染场景。这次，我们使用一个片段着色器，根据与阴影图的深度测试结果来着色每个片段。首先将片段的位置转换到光源的坐标系中，并使用光源的投影矩阵进行投影。然后结果进行偏置（为了获得有效的纹理坐标）并测试与阴影图。如果片段的深度大于阴影图中存储的深度，那么在片段和光源之间必须有一些表面。因此，该片段处于阴影中，并且仅使用环境光照进行着色。否则，片段必须对光源有清晰的视角，因此它被正常着色。
- en: The key aspect here is the conversion of the fragment's 3D coordinates to the
    coordinates appropriate for a lookup into the shadow map. As the shadow map is
    just a 2D texture, we need coordinates that range from zero to one for points
    that lie within the light's frustum. The light's view matrix will transform points
    in world coordinates to points within the light's coordinate system. The light's
    projection matrix will transform points that are within the light's frustum to
    **homogeneous clip coordinates**.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这里关键的部分是将片段的3D坐标转换为适合在阴影图中查找的坐标。由于阴影图只是一个2D纹理，我们需要坐标范围从零到一的点，这些点位于光线的视锥体内。光线视图矩阵将世界坐标中的点转换到光线的坐标系中。光线的投影矩阵将视锥体内的点转换到**齐次裁剪坐标**。
- en: These are called clip coordinates because the built-in clipping functionality
    takes place when the position is defined in these coordinates. Points within the
    perspective (or orthographic) frustum are transformed by the projection matrix
    to the (homogeneous) space that is contained within a cube centered at the origin,
    with each side of length two. This space is called the **canonical viewing volume**.
    The term *homogeneous* means that these coordinates should not necessarily be
    considered to be true Cartesian positions until they are divided by their fourth
    coordinate. For full details about homogeneous coordinates, refer to your favorite
    textbook on computer graphics.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些被称为裁剪坐标，因为当位置在这些坐标中定义时，内置的裁剪功能就会发生。透视（或正交）视锥体内的点通过投影矩阵变换到以原点为中心、每边长度为二的（齐次）空间。这个空间被称为 **规范视体积**。术语
    *齐次* 意味着在它们被第四个坐标除之前，这些坐标不一定被认为是真正的笛卡尔位置。有关齐次坐标的详细信息，请参阅您喜欢的计算机图形学教科书。
- en: The *x* and *y* components of the position in clip coordinates are roughly what
    we need to access the shadow map. The *z* coordinate contains the depth information
    that we can use to compare with the shadow map. However, before we can use these
    values we need to do two things. First, we need to bias them so that they range
    from zero to one (instead of -1 to 1), and second, we need to apply **perspective
    division** (more on this later).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 裁剪坐标中位置的 *x* 和 *y* 分量大致是我们需要访问阴影图的部分。*z* 坐标包含我们可以用于与阴影图比较的深度信息。然而，在我们能够使用这些值之前，我们需要做两件事。首先，我们需要对它们进行偏差，使它们范围从零到一（而不是从
    -1 到 1），其次，我们需要应用 **透视除法**（关于这一点稍后讨论）。
- en: To convert the value from clip coordinates to a range appropriate for use with
    a shadow map, we need the *x*, *y*, and *z* coordinates to range from zero to
    one (for points within the light's view frustum). The depth that is stored in
    an OpenGL depth buffer (and also our shadow map) is simply a fixed or floating-point
    value between zero and one (typically). A value of zero corresponds to the near
    plane of the perspective frustum, and a value of one corresponds to points on
    the far plane. Therefore, if we are to use our *z* coordinate to accurately compare
    with this depth buffer, we need to scale and translate it appropriately.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要将裁剪坐标的值转换为适合与阴影图一起使用的范围，我们需要将 *x*、*y* 和 *z* 坐标范围从零到一（对于光线视锥体内的点）。存储在 OpenGL
    深度缓冲区（以及我们的阴影图中）的深度只是一个介于零到一之间的固定或浮点值（通常是）。零值对应于透视视锥体的近平面，一值对应于远平面上的点。因此，如果我们想用我们的
    *z* 坐标与这个深度缓冲区进行准确比较，我们需要适当地缩放和转换它。
- en: In clip coordinates (after perspective division) the *z* coordinate ranges from
    -1 to 1\. It is the viewport transformation that (among other things) converts
    the depth to a range between zero and one. Incidentally, if so desired, we can
    configure the viewport transformation to use some other range for the depth values
    (say between 0 and 100) via the `glDepthRange` function.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在裁剪坐标（经过透视除法后）中，*z* 坐标范围从 -1 到 1。是视口变换（以及其他事情）将深度转换为零到一的范围。顺便提一下，如果需要，我们可以通过
    `glDepthRange` 函数配置视口变换，以便使用其他范围（例如 0 到 100）的深度值。
- en: Of course, the *x* and *y* components also need to be biased between zero and
    one because that is the appropriate range for texture access.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，*x* 和 *y* 分量也需要在零到一之间进行偏差，因为这是纹理访问的适当范围。
- en: 'We can use the following *bias* matrix to alter our clip coordinates:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下 *偏差* 矩阵来改变我们的裁剪坐标：
- en: '![](img/cb0a3687-846f-48d0-a82c-6b548e4dbe12.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cb0a3687-846f-48d0-a82c-6b548e4dbe12.png)'
- en: 'This matrix will scale and translate our coordinates such that the *x*, *y*,
    and *z* components range from 0 to 1 (after perspective division) for points within
    the light''s frustum. Now, combining the bias matrix with the light''s view (*V[l]*)
    and projection (*P[l]*) matrices, we have the following equation for converting
    positions in world coordinates (*W*) to homogeneous positions that can be used
    for shadow map access (*Q*):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个矩阵将缩放和转换我们的坐标，使得 *x*、*y* 和 *z* 分量在经过透视除法后范围从 0 到 1。现在，将偏差矩阵与光视图 (*V[l]*) 和投影
    (*P[l]*) 矩阵结合起来，我们得到以下方程，用于将世界坐标 (*W*) 中的位置转换为可用于阴影图访问的齐次位置 (*Q*)：
- en: '![](img/97d4d43c-131d-4406-a214-876f578d281b.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/97d4d43c-131d-4406-a214-876f578d281b.png)'
- en: Finally, before we can use the value of *Q* directly, we need to divide by the
    fourth (*w*) component. This step is sometimes called **perspective division**.
    This converts the position from a homogeneous value to a true Cartesian position,
    and is always required when using a perspective projection matrix.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们能够直接使用 *Q* 的值之前，我们需要除以第四个 (*w*) 分量。这一步有时被称为 **透视除法**。这会将位置从齐次值转换为真正的笛卡尔位置，并且在使用透视投影矩阵时始终是必需的。
- en: Perspective division is automatically done by the OpenGL pipeline prior to rasterization.
    However, since we're working with a value that is not transformed by the pipeline,
    we need to perform the division manually.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 透视除法在光栅化之前由 OpenGL 管道自动执行。然而，由于我们正在处理一个未由管道变换的值，我们需要手动执行除法。
- en: 'In the following equation, we''ll define a shadow matrix (*S*) that also includes
    the model matrix (*M*), so that we can convert directly from the object coordinates
    (*C*) (note that *W = MC*, because the model matrix takes object coordinates as
    world coordinates):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下方程中，我们将定义一个包含模型矩阵 (*M*) 的阴影矩阵 (*S*)，这样我们就可以直接从对象坐标 (*C*) 转换（注意 *W = MC*，因为模型矩阵将对象坐标作为世界坐标）：
- en: '![](img/1b9188be-2e6b-4bf2-a040-51a3eca1a4df.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1b9188be-2e6b-4bf2-a040-51a3eca1a4df.png)'
- en: 'Here, *S* is the shadow matrix, the product of the model matrix with all of
    the preceding matrices:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*S* 是阴影矩阵，是模型矩阵与所有先前矩阵的乘积：
- en: '![](img/676b10b2-95f4-4f7c-a759-6d3249439466.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/676b10b2-95f4-4f7c-a759-6d3249439466.png)'
- en: In this recipe, in order to keep things simple and clear, we'll cover only the
    basic shadow mapping algorithm, without any of the usual improvements. We'll build
    upon this basic algorithm in the following recipes. Before we get into the code,
    we should note that the results will likely be less than satisfying. This is because
    the basic shadow mapping algorithm suffers from significant aliasing artifacts.
    Nevertheless, it is still an effective technique when combined with one of many
    techniques for anti-aliasing. We'll look at some of those techniques in the recipes
    that follow.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，为了保持简单和清晰，我们将只介绍基本的阴影映射算法，而不包括任何通常的改进。我们将在接下来的菜谱中在此基础上构建。在我们进入代码之前，我们应该注意，结果可能不会令人满意。这是因为基本的阴影映射算法存在显著的走样伪影。尽管如此，当与许多抗走样技术之一结合使用时，它仍然是一种有效的技术。我们将在接下来的菜谱中查看一些这些技术。
- en: Getting ready
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The position should be supplied in vertex attribute zero and the normal in vertex
    attribute one. Uniform variables for the ADS shading model should be declared
    and assigned, as well as uniforms for the standard transformation matrices. The
    `ShadowMatrix` variable should be set to the matrix for converting from object
    coordinates to shadow map coordinates (*S* in the preceding equation).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 位置应在顶点属性零中提供，法线在顶点属性一中提供。应声明并分配 ADS 着色模型的常量变量，以及标准变换矩阵的常量。`ShadowMatrix` 变量应设置为从对象坐标转换为阴影映射坐标的矩阵（前述方程中的
    *S*）。
- en: The uniform variable `ShadowMap` is a handle to the shadow map texture, and
    should be assigned to texture unit zero.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 常量变量 `ShadowMap` 是阴影映射纹理的句柄，应分配给纹理单元零。
- en: How to do it...
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To create an OpenGL application that creates shadows using the shadow mapping
    technique, perform the following steps. We''ll start by setting up a **framebuffer
    object** (**FBO**) to contain the shadow map texture, and then move on to the
    required shader code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个使用阴影映射技术创建阴影的 OpenGL 应用程序，请执行以下步骤。我们将首先设置一个 **帧缓冲对象** (**FBO**) 来包含阴影映射纹理，然后继续到所需的着色器代码：
- en: 'In the main OpenGL program, set up an FBO with a depth buffer only. Declare
    a `GLuint` variable named `shadowFBO` to store the handle to this `framebuffer`.
    The depth buffer storage should be a texture object. You can use something similar
    to the following code to accomplish this:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主 OpenGL 程序中，设置一个仅包含深度缓冲区的 FBO。声明一个名为 `shadowFBO` 的 `GLuint` 变量来存储此 `framebuffer`
    的句柄。深度缓冲区存储应是一个纹理对象。您可以使用以下类似代码来完成此操作：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Use the following code for the vertex shader:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码作为顶点着色器：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Use the following code for the fragment shader:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码作为片段着色器：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Within the main OpenGL program, perform the following steps when rendering.
    For pass one:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在主 OpenGL 程序中渲染时，执行以下步骤。对于第一遍：
- en: Set the viewport, view, and projection matrices to those that are appropriate
    for the light source.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置视口、视图和投影矩阵，使其适用于光源。
- en: Bind to the `framebuffer` containing the shadow map (`shadowFBO`).
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绑定包含阴影图的`framebuffer`（`shadowFBO`）。
- en: Clear the depth buffer.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清除深度缓冲区。
- en: Select the subroutine `recordDepth` function.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择子例程`recordDepth`函数。
- en: Enable front-face culling.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用正面剔除。
- en: Draw the scene.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制场景。
- en: 'For pass two:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二次传递：
- en: Select the viewport, view, and projection matrices appropriate for the scene.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择适合场景的视口、视图和投影矩阵。
- en: Bind to the default framebuffer.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绑定到默认的framebuffer。
- en: Disable culling (or switch to back-face culling).
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁用剔除（或切换到背面剔除）。
- en: Select the subroutine function `shadeWithShadow` function.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择子例程函数`shadeWithShadow`。
- en: Draw the scene.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制场景。
- en: How it works...
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The first block of the preceding code demonstrates how to create an FBO for
    our shadow map texture. The FBO contains only a single texture connected to its
    depth buffer attachment. The first few lines of code create the shadow map texture.
    The texture is allocated using the `glTexStorage2D` function with an internal
    format of `GL_DEPTH_COMPONENT24`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的第一部分演示了如何为我们的阴影图纹理创建一个FBO。该FBO仅包含一个连接到其深度缓冲区附加的纹理。代码的前几行创建了阴影图纹理。纹理是通过使用具有`GL_DEPTH_COMPONENT24`内部格式的`glTexStorage2D`函数分配的。
- en: We use `GL_NEAREST` for `GL_TEXTURE_MAG_FILTER` and `GL_TEXTURE_MIN_FILTER`
    here, although `GL_LINEAR` could also be used, and might provide slightly better-looking
    results. We use `GL_NEAREST` here so that we can see the aliasing artifacts clearly,
    and the performance will be slightly better.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用`GL_NEAREST`作为`GL_TEXTURE_MAG_FILTER`和`GL_TEXTURE_MIN_FILTER`，尽管也可以使用`GL_LINEAR`，并且可能提供稍微更好的视觉效果。我们在这里使用`GL_NEAREST`是为了能够清楚地看到锯齿伪影，并且性能会略有提高。
- en: Next, the `GL_TEXTURE_WRAP_*` modes are set to `GL_CLAMP_TO_BORDER`. When a
    fragment is found to lie completely outside of the shadow map (outside of the
    light's frustum), then the texture coordinates for that fragment will be greater
    than one or less than zero. When that happens, we need to make sure that those
    points are not treated as being in shadow. When `GL_CLAMP_TO_BORDER` is used,
    the value that is returned from a texture lookup (for coordinates outside the
    0–1 range) will be the border value. The default border value is `(0,0,0,0)`.
    When the texture contains depth components, the first component is treated as
    the depth value. A value of zero will not work for us here because a depth of
    zero corresponds to points on the near plane. Therefore, all points outside of
    the light's frustum will be treated as being in shadow! Instead, we set the border
    color to `(1,0,0,0)` using the `glTexParameterfv` function, which corresponds
    to the maximum possible depth.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将`GL_TEXTURE_WRAP_*`模式设置为`GL_CLAMP_TO_BORDER`。当一个片段被发现完全位于阴影图（光线的视锥体之外）之外时，该片段的纹理坐标将大于一或小于零。当这种情况发生时，我们需要确保这些点不被视为处于阴影中。当使用`GL_CLAMP_TO_BORDER`时，从纹理查找返回的值（对于0-1范围之外的坐标）将是边界值。默认的边界值是`(0,0,0,0)`。当纹理包含深度分量时，第一个分量被视为深度值。在这里，零值将不起作用，因为零深度对应于近平面上的点。因此，所有位于光视锥体之外的点都将被视为处于阴影中！相反，我们使用`glTexParameterfv`函数将边界颜色设置为`(1,0,0,0)`，这对应于最大可能的深度。
- en: The next two calls to `glTexParameteri` affect settings that are specific to
    depth textures. The first call sets `GL_TEXTURE_COMPARE_MODE` to `GL_COMPARE_REF_TO_TEXTURE`.
    When this setting is enabled, the result of a texture access is the result of
    a comparison, rather than a color value retrieved from the texture. The third
    component of the texture coordinate (the `p` component) is compared against the
    value in the texture at location `(s,t)`. The result of the comparison is returned
    as a single floating-point value. The comparison function that is used is determined
    by the value of `GL_TEXTURE_COMPARE_FUNC`, which is set on the next line. In this
    case, we set it to `GL_LESS`, which means that the result will be `1.0` if the
    `p` value of the texture coordinate is less than the value stored at `(s,t)`.
    (Other options include `GL_LEQUAL`, `GL_ALWAYS`, `GL_GEQUAL`, and so on.)
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 下两个对`glTexParameteri`的调用影响特定于深度纹理的设置。第一个调用将`GL_TEXTURE_COMPARE_MODE`设置为`GL_COMPARE_REF_TO_TEXTURE`。当此设置启用时，纹理访问的结果是比较的结果，而不是从纹理中检索的颜色值。纹理坐标的第三个分量（`p`分量）与纹理中位置`(s,t)`的值进行比较。比较的结果作为一个单精度浮点值返回。所使用的比较函数由`GL_TEXTURE_COMPARE_FUNC`的值确定，该值在下一行设置。在这种情况下，我们将其设置为`GL_LESS`，这意味着如果纹理坐标的`p`值小于存储在`(s,t)`的值，则结果将是`1.0`。（其他选项包括`GL_LEQUAL`、`GL_ALWAYS`、`GL_GEQUAL`等。）
- en: The next few lines create and set up the FBO. The shadow map texture is attached
    to the FBO as the depth attachment with the `glFramebufferTexture2D` function.
    For more details about FBOs, check out the *Rendering to a texture* recipe in
    [Chapter 5](a5d0db76-6dbb-470d-8685-42ab8ae077b1.xhtml), *Using Textures*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几行创建并设置了 FBO。使用 `glFramebufferTexture2D` 函数将阴影贴图纹理附加到 FBO 上作为深度附加。有关 FBO
    的更多详细信息，请参阅第 5 章 *渲染到纹理* 的配方，*使用纹理*。
- en: The vertex shader is fairly simple. It converts the vertex position and normal-to-camera
    coordinates and passes them along to the fragment shader via the output variables
    `Position` and `Normal`. The vertex position is also converted into shadow map
    coordinates using `ShadowMatrix`. This is the matrix *S* that we referred to in
    the previous section. It converts a position from object coordinates to shadow
    coordinates. The result is sent to the fragment shader via the `ShadowCoord` output
    variable.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色器相当简单。它将顶点位置和法线到相机坐标转换，并通过输出变量 `Position` 和 `Normal` 将它们传递到片段着色器。顶点位置也使用
    `ShadowMatrix` 转换为阴影贴图坐标。这就是我们在上一节中提到的矩阵 *S*。它将位置从对象坐标转换为阴影坐标。结果通过 `ShadowCoord`
    输出变量发送到片段着色器。
- en: As usual, the position is also converted to clip coordinates and assigned to
    the built-in `gl_Position` output variable.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 与往常一样，位置也被转换为裁剪坐标并分配给内置的 `gl_Position` 输出变量。
- en: In the fragment shader, we provide different functionality for each pass. In
    the main function, we call `RenderPass`, which is a subroutine uniform that will
    call either `recordDepth` or `shadeWithShadow`. For the first pass (shadow map
    generation), the `recordDepth` subroutine function is executed. This function
    does nothing at all! This is because we only need to write the depth to the depth
    buffer. OpenGL will do this automatically (assuming that `gl_Position` was set
    correctly by the vertex shader), so there is nothing for the fragment shader to
    do.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在片段着色器中，我们为每个遍历提供不同的功能。在主函数中，我们调用 `RenderPass`，这是一个子例程均匀函数，它将调用 `recordDepth`
    或 `shadeWithShadow`。对于第一次遍历（阴影贴图生成），执行 `recordDepth` 子例程函数。这个函数什么都不做！这是因为我们只需要将深度写入深度缓冲区。OpenGL
    会自动完成这项工作（假设顶点着色器正确设置了 `gl_Position`），因此片段着色器没有需要执行的操作。
- en: During the second pass, the `shadeWithShadow` function is executed. We compute
    the ambient component of the shading model and store the result in the `ambient`
    variable.  We then compute the diffuse and specular components and store those
    in the `diffuseAndSpec` variable.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二次遍历期间，执行 `shadeWithShadow` 函数。我们计算着色模型的漫反射分量并将其结果存储在 `ambient` 变量中。然后，我们计算漫反射和镜面分量并将它们存储在
    `diffuseAndSpec` 变量中。
- en: The next step is the key to the shadow mapping algorithm. We use the built-in `textureProj` texture access
    function to access the `ShadowMap` shadow map texture. Before using the texture
    coordinate to access the texture, the `textureProj` function will divide the first
    three components of the texture coordinate by the fourth component. Remember that
    this is exactly what is needed to convert the homogeneous position (`ShadowCoord`)
    to a true Cartesian position.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是阴影映射算法的关键。我们使用内置的 `textureProj` 纹理访问函数来访问 `ShadowMap` 阴影贴图纹理。在用纹理坐标访问纹理之前，`textureProj`
    函数会将纹理坐标的前三个分量除以第四个分量。记住，这正是将齐次位置（`ShadowCoord`）转换为真实笛卡尔位置所需要的。
- en: After this perspective division, the `textureProj` function will use the result
    to access the texture. As this texture's sampler type is `sampler2DShadow`, it
    is treated as a texture containing depth values, and rather than returning a value
    from the texture, it returns the result of a comparison. The first two components
    of `ShadowCoord` are used to access a depth value within the texture. That value
    is then compared against the value of the third component of `ShadowCoord`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行这个视角分割之后，`textureProj` 函数将使用结果来访问纹理。由于这个纹理的采样器类型是 `sampler2DShadow`，它被视为包含深度值的纹理，并且它不是从纹理中返回一个值，而是返回一个比较的结果。`ShadowCoord`
    的前两个分量用于访问纹理内的深度值。然后，该值与 `ShadowCoord` 的第三个分量的值进行比较。
- en: We need to use `vec3` as the lookup coordinate when using a sampler of type
    `sampler2DShadow`,  because we need a 2D position and a depth.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用类型为 `sampler2DShadow` 的采样器时，我们需要使用 `vec3` 作为查找坐标，因为我们需要一个 2D 位置和一个深度。
- en: When `GL_NEAREST` is the interpolation mode (as it is in our case) the result
    will be `1.0`, or `0.0`. As we set the comparison function to `GL_LESS`, this
    will return `1.0`, but only if the value of the third component of `ShadowCoord`
    is less than the value within the depth texture at the sampled location. This
    result is then stored in the `shadow` variable. Finally, we assign a value to
    the output variable `FragColor`. The result of the shadow map comparison (`shadow`)
    is multiplied by the diffuse and specular components, and the result is added
    to the ambient component. If `shadow` is `0.0`, that means that the comparison
    failed, meaning that there is something between the fragment and the light source.
    Therefore, the fragment is only shaded with ambient light. Otherwise, `shadow`
    is `1.0`, and the fragment is shaded with all three shading components.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当`GL_NEAREST`是插值模式（正如我们案例中那样）时，结果将是`1.0`或`0.0`。由于我们将比较函数设置为`GL_LESS`，这将返回`1.0`，但仅当`ShadowCoord`的第三个分量的值小于在采样位置的深度纹理中的值时。然后将此结果存储在`shadow`变量中。最后，我们将一个值赋给输出变量`FragColor`。阴影图比较的结果（`shadow`）乘以漫反射和镜面反射分量，然后将结果添加到环境分量。如果`shadow`是`0.0`，这意味着比较失败，意味着在片段和光源之间有东西。因此，片段只被环境光着色。否则，`shadow`是`1.0`，片段被所有三个着色分量着色。
- en: When rendering the shadow map, note that we culled the front faces. This is
    to avoid the z-fighting that can occur when front faces are included in the shadow
    map. Note that this only works if our mesh is completely closed. If back faces
    are exposed, you may need to use another technique (that uses `glPolygonOffset`)
    to avoid this. I'll talk a bit more about this in the next section.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染阴影图时，请注意我们剪裁了正面。这是为了避免当正面被包含在阴影图中时可能发生的z冲突。请注意，这仅在我们网格完全封闭的情况下有效。如果背面暴露，您可能需要使用另一种技术（使用`glPolygonOffset`）来避免这种情况。我将在下一节中详细谈谈这一点。
- en: There's more...
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There's a number of challenging issues with the shadow mapping technique. Let's
    look at just a few of the most immediate ones.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 阴影映射技术存在许多具有挑战性的问题。让我们看看其中最紧迫的几个。
- en: Aliasing
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混叠
- en: As mentioned earlier, this algorithm often suffers from severe aliasing artifacts
    at the shadow's edges. This is due to the fact that the shadow map is essentially
    projected onto the scene when the depth comparison is made. If the projection
    causes the map to be magnified, aliasing artifacts appear.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，此算法在阴影边缘经常出现严重的混叠伪影。这是因为当进行深度比较时，阴影图实际上被投影到场景中。如果投影导致图放大，就会出现混叠伪影。
- en: 'The following image shows the aliasing of the shadow''s edges:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了阴影边缘的混叠：
- en: '![](img/02d5a3b1-f57a-44dc-8ec5-1197aa9b5ebd.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/02d5a3b1-f57a-44dc-8ec5-1197aa9b5ebd.png)'
- en: The easiest solution is to simply increase the size of the shadow map. However,
    that may not be possible due to memory, CPU speed, or other constraints. There
    is a large number of techniques for improving the quality of the shadows produced
    by the shadow mapping algorithm such as resolution-matched shadow maps, cascaded
    shadow maps, variance shadow maps, perspective shadow maps, and many others. In
    the following recipes, we'll look at some ways to help you soften and anti-alias
    the edges of the shadows.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的解决方案是简单地增加阴影图的大小。然而，由于内存、CPU速度或其他限制，这可能不可行。有许多技术可以提高阴影映射算法产生的阴影质量，例如分辨率匹配阴影图、级联阴影图、方差阴影图、透视阴影图等。在接下来的菜谱中，我们将探讨一些帮助您软化并抗锯齿阴影边缘的方法。
- en: Rendering back faces only for the shadow map
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仅对阴影图渲染背面
- en: 'When creating the shadow map, we only rendered back faces. This is because
    if we were to render front faces, points on certain faces would have nearly the
    same depth as the shadow map''s depth, which can cause fluctuations between light
    and shadow across faces that should be completely lit. The following image shows
    an example of this effect:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建阴影图时，我们只渲染背面。这是因为如果我们渲染正面，某些面上的点将与阴影图的深度几乎相同，这可能导致应该完全照亮的面之间光与影的波动。以下图像显示了这种效果的一个示例：
- en: '![](img/16614eca-2d0c-45b2-9682-01c270fa13c1.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/16614eca-2d0c-45b2-9682-01c270fa13c1.png)'
- en: Since the majority of faces that cause this issue are those that are facing
    the light source, we avoid much of the problem by only rendering back faces during
    the shadow map pass. This, of course, will only work correctly if your meshes
    are completely closed. If that is not the case, `glPolygonOffset` can be used
    to help the situation by offsetting the depth of the geometry from that in the
    shadow map. In fact, even when back faces are only rendered when generating the
    shadow map, similar artifacts can appear on faces that are facing away from the
    light (back faces in the shadow map, but the front from the camera's perspective).
    Therefore, it is quite often the case that a combination of front-face culling
    and `glPolygonOffset` is used when generating the shadow map.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于导致此问题的面中大多数是面向光源的面，我们通过仅在阴影图传递期间渲染背面来避免大部分问题。当然，这只有在你的网格完全封闭的情况下才能正确工作。如果不是这样，可以使用`glPolygonOffset`来帮助解决这个问题，通过将几何体的深度从阴影图中的深度偏移。实际上，即使在生成阴影图时仅渲染背面，类似的艺术效果也可能出现在远离光源的面上（阴影图中的背面，但摄像机视角的正面）。因此，在生成阴影图时，经常结合正面剔除和`glPolygonOffset`。
- en: See also
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter08/sceneshadowmap.cpp` file in the example code
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的`chapter08/sceneshadowmap.cpp`文件
- en: The *Rendering to a texture* recipe in [Chapter 5](a5d0db76-6dbb-470d-8685-42ab8ae077b1.xhtml),
    *Using Textures*
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*渲染到纹理*配方在[第5章](a5d0db76-6dbb-470d-8685-42ab8ae077b1.xhtml)，*使用纹理*'
- en: The *Anti-aliasing shadow edges with PCF* recipe
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用PCF抗走样阴影边缘*配方'
- en: The *Creating soft shadow edges with random sampling* recipe
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用随机采样创建软阴影边缘*配方'
- en: Anti-aliasing shadow edges with PCF
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PCF抗走样阴影边缘
- en: One of the simplest and most common techniques for dealing with the aliasing
    of shadow edges is called **percentage-closer filtering** (**PCF**). The name
    comes from the concept of sampling the area around the fragment and determining
    the percentage of the area that is closer to the light source (in shadow). The
    percentage is then used to scale the amount of shading (diffuse and specular) that
    the fragment receives. The overall effect is a blurring of the shadow's edges.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 处理阴影边缘走样的一种简单且常见的技术被称为**百分比更近过滤**（**PCF**）。这个名字来源于在片段周围采样区域并确定该区域中靠近光源（在阴影中）的部分所占的百分比。然后，这个百分比被用来缩放片段接收的着色量（漫反射和镜面反射）。整体效果是模糊阴影的边缘。
- en: The basic technique was first published by Reeves et al. in a 1987 paper (*SIGGRAPH
    Proceedings, Volume 21, Number 4, July 1987*). The concept involves transforming
    the fragment's extents into shadow space, sampling several locations within that
    region, and computing the percent that is closer than the depth of the fragment.
    The result is then used to attenuate the shading. If the size of this filter region
    is increased, it can have the effect of blurring the shadow's edges.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 基本技术最早由Reeves等人于1987年发表在一篇论文中（*SIGGRAPH会议录，第21卷，第4期，1987年7月*）。该概念涉及将片段的扩展范围转换到阴影空间，在该区域内采样几个位置，并计算比片段深度更近的百分比。然后，该结果被用来衰减着色。如果增加此滤波区域的大小，它可以产生模糊阴影边缘的效果。
- en: A common variant of the PCF algorithm involves just sampling a constant number
    of nearby texels within the shadow map. The percent of those texels that are closer
    to the light is used to attenuate the shading. This has the effect of blurring
    the shadow's edges. While the result may not be physically accurate, the result
    is not objectionable to the eye.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: PCF算法的一种常见变体仅涉及在阴影图中采样附近固定数量的纹理元素。这些纹理元素中靠近光源的比例被用来衰减阴影的着色。这会产生模糊阴影边缘的效果。虽然结果可能不是物理上准确的，但人眼看起来并不令人反感。
- en: 'The following images show shadows rendered with PCF (right) and without PCF
    (left). Note that the shadows in the right-hand image have fuzzier edges and the
    aliasing is less visible:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像展示了使用PCF（右）和不使用PCF（左）渲染的阴影。注意，右图中的阴影边缘更模糊，走样现象不太明显：
- en: '![](img/b5003004-02d5-4e85-9264-0528fc960458.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5003004-02d5-4e85-9264-0528fc960458.png)'
- en: In this recipe, we'll use the latter technique, and sample a constant number
    of texels around the fragment's position in the shadow map. We'll calculate an
    average of the resulting comparisons and use that result to scale the diffuse
    and specular components.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将使用后一种技术，并在阴影图中片段位置周围采样固定数量的纹理元素。我们将计算结果的平均值，并使用该结果来缩放漫反射和镜面反射分量。
- en: We'll make use of OpenGL's built-in support for PCF by using linear filtering
    on the depth texture. When linear filtering is used with this kind of texture,
    the hardware can automatically sample four nearby texels (execute four depth comparisons)
    and average the results (the details of this are implementation dependent). Therefore,
    when linear filtering is enabled, the result of the `textureProj` function can
    be somewhere between 0.0 and 1.0.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用OpenGL对PCF的内建支持，通过在深度纹理上使用线性过滤来实现。当使用这种纹理进行线性过滤时，硬件可以自动采样四个附近的纹理元素（执行四个深度比较）并平均结果（这些细节的实现取决于具体实现）。因此，当启用线性过滤时，`textureProj`函数的结果可以在0.0和1.0之间。
- en: We'll also make use of the built-in functions for texture accesses with offsets.
    OpenGL provides the `textureProjOffset` texture access function, which has a third
    parameter (the offset) that is added to the texel coordinates before the lookup/comparison.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将利用纹理访问偏移的内建函数。OpenGL提供了`textureProjOffset`纹理访问函数，它有一个第三个参数（偏移量），在查找/比较之前添加到纹理元素坐标中。
- en: Getting ready
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Start with the shaders and FBO presented in the previous *Rendering shadows
    with shadow maps* recipe. We'll just make a few minor changes to the code presented
    there.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前*使用阴影图渲染阴影*配方中提供的着色器和FBO开始。我们只需对那里展示的代码进行一些小的修改。
- en: How to do it...
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'To add the PCF technique to the shadow mapping algorithm, use the following
    steps:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要将PCF技术添加到阴影映射算法中，请按照以下步骤操作：
- en: 'When setting up the FBO for the shadow map, make sure to use linear filtering
    on the depth texture. Replace the corresponding lines with the following code:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设置阴影图FBO时，确保使用线性过滤在深度纹理上。用以下代码替换相应的行：
- en: '[PRE3]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Use the following code for the `shadeWithShadow` function within the fragment
    shader:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在片段着色器中的`shadeWithShadow`函数中，使用以下代码：
- en: '[PRE4]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The first step enables linear filtering on the shadow map texture. When this
    is enabled, the OpenGL driver can repeat the depth comparison on the four nearby
    texels within the texture. The results of the four comparisons will be averaged
    and returned.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是在阴影图纹理上启用线性过滤。当启用时，OpenGL驱动程序可以在纹理内重复四个附近的纹理元素的深度比较。四个比较的结果将被平均并返回。
- en: Within the fragment shader, we use the `textureProjOffset` function to sample
    the four texels (diagonally) surrounding the texel nearest to `ShadowCoord`. The
    third argument is the offset. It is added to the texel's coordinates (not the
    texture coordinates) before the lookup takes place.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在片段着色器中，我们使用`textureProjOffset`函数来采样围绕`ShadowCoord`最近的纹理元素（对角线方向）的四个纹理元素。第三个参数是偏移量。在查找发生之前，它被添加到纹理元素的坐标（而不是纹理坐标）中。
- en: As linear filtering is enabled, each lookup will sample an additional four texels,
    for a total of 16 texels. The results are then averaged together and stored within
    the variable shadow.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于启用了线性过滤，每次查找都会采样额外的四个纹理元素，总共16个纹理元素。然后将结果平均并存储在变量shadow中。
- en: As before, the value of `shadow` is used to attenuate the diffuse and specular
    components of the lighting model.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`shadow`的值用于衰减光照模型的漫反射和镜面反射分量。
- en: There's more...
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: An excellent survey of the PCF technique was written by Fabio Pellacini of Pixar,
    and can be found in Chapter 11, *Shadow Map Anti-aliasing*, of *GPU Gems*, edited
    by Randima Fernando, Addison-Wesley Professional, 2004\. If more details are desired,
    I highly recommend reading this short, but informative, chapter.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Pixar的Fabio Pellacini撰写了一份关于PCF技术的优秀调查报告，可以在由Randima Fernando编辑的《GPU Gems》的第11章*阴影图抗锯齿*中找到，Addison-Wesley
    Professional，2004年。如果需要更多细节，我强烈推荐阅读这一章，虽然篇幅不长，但信息丰富。
- en: Because of its simplicity and efficiency, the PCF technique is an extremely
    common method for anti-aliasing the edges of shadows produced by shadow mapping.
    Since it has the effect of blurring the edges, it can also be used to simulate
    soft shadows. However, the number of samples must be increased with the size of
    the blurred edge (the penumbra) to avoid certain artifacts. This can, of course,
    be a computational roadblock. In the next recipe, we'll look at a technique for
    producing soft shadows by randomly sampling a larger region.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其简单性和效率，PCF技术是抗锯齿由阴影映射产生的阴影边缘的极其常见的方法。由于它具有模糊边缘的效果，它也可以用来模拟柔和的阴影。然而，必须随着模糊边缘（半影）的大小增加样本数量，以避免某些伪影。这当然可能成为计算上的障碍。在下一个配方中，我们将探讨一种通过随机采样更大区域来产生柔和阴影的技术。
- en: A penumbra is the region of a shadow where only a portion of the light source
    is obscured.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 半影是阴影区域中只有部分光源被遮挡的部分。
- en: See also
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter08/scenepcf.cpp` file in the example code
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的`chapter08/scenepcf.cpp`文件
- en: The *Rendering shadows with shadow maps* recipe
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用阴影图渲染阴影*的食谱'
- en: Creating soft shadow edges with random sampling
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用随机采样创建软阴影边缘
- en: The basic shadow mapping algorithm combined with PCF can produce shadows with
    soft edges. However, if we desire blurred edges that are substantially wide (to
    approximate true soft shadows), then a large number of samples is required. Additionally,
    there is a good deal of wasted effort when shading fragments that are in the center
    of large shadows, or completely outside of the shadow. For those fragments, all
    of the nearby shadow map texels will evaluate to the same value. Therefore, the
    work of accessing and averaging those texels is essentially a wasted effort.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的阴影映射算法与PCF结合可以产生具有软边缘的阴影。然而，如果我们希望具有较大宽度（以近似真实软阴影）的模糊边缘，则需要大量的样本。此外，当着色位于大阴影中心或完全在阴影之外的片段时，会有大量的无效工作量。对于这些片段，所有附近的阴影图纹理单元都将评估为相同的值。因此，访问和平均这些纹理单元的工作基本上是无效的。
- en: The technique presented in this recipe is based on a chapter published in *GPU
    Gems 2*, edited by Matt Pharr and Randima Fernando, Addison-Wesley Professional,
    2005\. (Chapter 17 by Yury Uralsky.) It provides an approach that can address
    both of the preceding issues to create shadows with soft edges of various widths,
    while avoiding unnecessary texture accesses in areas inside and outside of the
    shadow.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱中介绍的技术基于由Matt Pharr和Randima Fernando编辑的*GPU Gems 2*中出版的一章，Addison-Wesley
    Professional，2005年。（第17章由Yury Uralsky撰写。）它提供了一种方法，可以解决上述两个问题，以创建具有各种宽度的软边缘阴影，同时避免在阴影内部和外部区域不必要的纹理访问。
- en: 'The basic idea is as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 基本思想如下：
- en: Instead of sampling texels around the fragment's position (in shadow map space)
    using a constant set of offsets, we use a random, circular pattern of offsets
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不是使用一组固定的偏移量在片段位置（阴影图空间）周围采样纹理单元，而是使用随机的圆形偏移模式。
- en: In addition, we sample only the outer edges of the circle first in order to
    determine whether or not the fragment is in an area that is completely inside
    or outside of the shadow
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，我们首先对圆的边缘进行采样，以确定片段是否位于完全在阴影内部或外部的区域
- en: 'The following diagram is a visualization of a possible set of shadow map samples.
    The center of the crosshairs is the fragment''s location in the shadow map, and
    each **x** is a sample. The samples are distributed randomly within a circular
    grid around the fragment''s location (one sample per grid cell):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表是可能的阴影图样本集的可视化。十字准线的中心是片段在阴影图中的位置，每个**x**是一个样本。样本在围绕片段位置的圆形网格内随机分布（每个网格单元一个样本）：
- en: '![](img/aacb7906-d478-45ac-8d1d-d0ba4ac6ff0b.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/aacb7906-d478-45ac-8d1d-d0ba4ac6ff0b.png)'
- en: 'Additionally, we vary the sample locations through a set of precomputed sample
    patterns. We compute random sample offsets and store them in a texture prior to
    rendering. Then, in the fragment shader, the samples are determined by first accessing
    the offset texture to grab a set of offsets and using them to vary the fragment''s
    position in the shadow map. The results are then averaged together in a similar
    manner to the basic PCF algorithm. The following diagram shows the difference
    between shadows using the PCF algorithm (left), and the random sampling technique
    described in this recipe (right):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们通过一组预计算的样本模式来改变样本位置。我们在渲染之前计算随机样本偏移并将其存储在纹理中。然后，在片段着色器中，首先通过访问偏移纹理来获取一组偏移量，并使用这些偏移量来改变片段在阴影图中的位置。结果以类似于基本PCF算法的方式平均在一起。以下图表显示了使用PCF算法（左）和本食谱中描述的随机采样技术（右）产生的阴影之间的差异：
- en: '![](img/1dbf1617-75c9-4c89-913f-2150b9de348a.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1dbf1617-75c9-4c89-913f-2150b9de348a.png)'
- en: We'll store the offsets in a three-dimensional texture (*n* x *n* x *d*). The
    first two dimensions are of arbitrary size, and the third dimension contains the
    offsets. Each (*s*,*t*) location contains a list (size *d*) of random offsets
    packed into an RGBA color. Each RGBA color in the texture contains two 2D offsets.
    The *R* and *G* channels contain the first offset, and the *B* and *A* channels
    contain the second. Therefore, each (*s*,*t*) location contains a total of *2*d*
    offsets.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将偏移量存储在一个三维纹理中（*n* x *n* x *d*）。前两个维度的大小是任意的，第三个维度包含偏移量。每个（*s*,*t*）位置包含一个大小为*d*的随机偏移量列表，这些偏移量打包成一个RGBA颜色。纹理中的每个RGBA颜色包含两个2D偏移量。*R*和*G*通道包含第一个偏移量，而*B*和*A*通道包含第二个。因此，每个（*s*,*t*）位置包含总共*2*d*个偏移量。
- en: For example, location (1, 1, 3) contains the sixth and seventh offset at location
    (1,1). The entire set of values at a given (*s*,*t*) comprise a full set of offsets.
    We'll rotate through the texture based on the fragment's screen coordinates. The
    location within the offset texture will be determined by taking the remainder
    of the screen coordinates divided by the texture's size. For example, if the fragment's
    coordinates are (10.0,10.0) and the texture's size is (4,4), then we use the set
    of offsets located in the offset texture at location (2,2).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，位置（1, 1, 3）包含位置（1,1）的第六个和第七个偏移量。给定（*s*,*t*）处的所有值构成一个完整的偏移量集。我们将根据片段的屏幕坐标旋转纹理。偏移纹理中的位置将由屏幕坐标除以纹理大小的余数确定。例如，如果片段的坐标是（10.0,10.0）且纹理的大小是（4,4），那么我们使用位于偏移纹理位置（2,2）的偏移量集。
- en: Getting ready
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Start with the code presented in the *Rendering shadows with shadow maps* recipe.
    There are three additional uniforms that need to be set. They are as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 从*使用阴影图渲染阴影*配方中提供的代码开始。需要设置三个额外的统一变量。它们如下：
- en: '`OffsetTexSize`: This gives the width, height, and depth of the offset texture.
    Note that the depth is same as the number of samples per fragment divided by two.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OffsetTexSize`：这给出了偏移纹理的宽度、高度和深度。注意，深度与每个片段的样本数除以二相同。'
- en: '`OffsetTex`: This is a handle to the texture unit containing the offset texture.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OffsetTex`：这是包含偏移纹理的纹理单元的句柄。'
- en: '`Radius`: This is the blur radius in pixels divided by the size of the shadow
    map texture (assuming a square shadow map). This could be considered as the softness
    of the shadow.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Radius`：这是以像素为单位的模糊半径除以阴影图纹理的大小（假设是正方形阴影图）。这可以被认为是阴影的柔和度。'
- en: How to do it...
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To modify the shadow mapping algorithm and to use this random sampling technique,
    perform the following steps. We''ll build the offset texture within the main OpenGL
    program, and make use of it within the fragment shader:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要修改阴影映射算法并使用这种随机采样技术，请执行以下步骤。我们将在主OpenGL程序中构建偏移纹理，并在片段着色器中使用它：
- en: 'Use the following code within the main OpenGL program to create the offset
    texture. This only needs to be executed once during the program''s initialization:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主OpenGL程序中使用以下代码创建偏移纹理。这只需要在程序初始化期间执行一次：
- en: '[PRE5]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add the following uniform variables to the fragment shader:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下统一变量添加到片段着色器中：
- en: '[PRE6]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Use the following code for the `shadeWithShadow` function in the fragment shader:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在片段着色器中使用以下代码为`shadeWithShadow`函数：
- en: '[PRE7]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works...
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The `buildOffsetTex` function creates our three-dimensional texture of random
    offsets. The first parameter, `texSize`, defines the width and height of the texture.
    To create the preceding images, I used a value of `8`. The second and third parameters,
    `samplesU` and `samplesV`, define the number of samples in the `u` and `v` directions.
    I used a value of `4` and `8`, respectively, for a total of 32 samples. The `u`
    and `v` directions are arbitrary axes that are used to define a grid of offsets.
    To understand this, take a look at the following diagram:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`buildOffsetTex`函数创建我们的随机偏移量的三维纹理。第一个参数`texSize`定义了纹理的宽度和高度。为了创建前面的图像，我使用了`8`的值。第二个和第三个参数`samplesU`和`samplesV`定义了`u`和`v`方向上的样本数。我分别使用了`4`和`8`，总共32个样本。`u`和`v`方向是任意轴，用于定义偏移量的网格。为了理解这一点，请看以下图表：'
- en: '![](img/66af00d9-05d0-4218-ba1a-fdcea2dc58b4.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/66af00d9-05d0-4218-ba1a-fdcea2dc58b4.png)'
- en: The offsets are initially defined to be centered on a grid of size `samplesU`
    x `samplesV` (4 x 4 in the preceding diagram). The coordinates of the offsets
    are scaled such that the entire grid fits in the unit cube (side length `1`) with
    the origin in the lower-left corner. Then, each sample is randomly jittered from
    its position to a random location inside the grid cell. Finally, the jittered
    offsets are warped so that they surround the origin and lie within the circular
    grid shown on the right.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 偏移量最初被定义为位于大小为`samplesU` x `samplesV`（前图中为4 x 4）的网格中心。偏移量的坐标被缩放，使得整个网格适合单位立方体（边长`1`），原点位于左下角。然后，每个样本从其位置随机抖动到网格单元内的随机位置。最后，抖动的偏移量被扭曲，使其围绕原点并位于右侧所示的圆形网格内。
- en: 'The last step can be accomplished by using the *v* coordinate as the distance
    from the origin and the *u* coordinate as the angle scaled from 0 to 360\. The
    following equations should do the trick:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步可以通过使用*v*坐标作为原点的距离，以及使用*u*坐标作为从0到360度缩放的角来实现。以下方程应该可以做到这一点：
- en: '![](img/66de6b0d-9548-4a3f-b258-1e7ce97c2ffd.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/66de6b0d-9548-4a3f-b258-1e7ce97c2ffd.png)'
- en: Here, *w* is the warped coordinate. What we are left with is a set of offsets
    around the origin that are a maximum distance of 1.0 from the origin. Additionally,
    we generate the data such that the first samples are the ones around the outer
    edge of the circle, moving inside toward the center. This will help us avoid taking
    too many samples when we are working completely inside or outside of the shadow.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*w*是扭曲坐标。我们剩下的是一组围绕原点的偏移量，其最大距离为1.0。此外，我们还生成数据，使得第一个样本是围绕圆的外边缘的样本，向内移动到中心。这将帮助我们避免在完全在阴影内部或外部工作时进行过多的采样。
- en: Of course, we also pack the samples in such a way that a single texel contains
    two samples. This is not strictly necessary, but is done to conserve memory space.
    However, it does make the code a bit more complex.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也以这种方式打包样本，使得单个texel包含两个样本。这并非绝对必要，但这样做是为了节省内存空间。然而，这确实使得代码变得更加复杂。
- en: Within the fragment shader, we start by computing the ambient component of the
    shading model separately from the diffuse and specular components. We access the
    offset texture at a location based on the fragment's screen coordinates (`gl_FragCoord`).
    We do so by taking the modulus of the fragment's position and the size of the
    offset texture. The result is stored in the first two components of `offsetCoord`.
    This will give us a different set of offsets for each nearby pixel. The third
    component of `offsetCoord` will be used to access a pair of samples. The number
    of samples is the depth of the texture divided by two. This is stored in `samplesDiv2`.
    We access the sample using the `texelFetch` function. This function allows us
    to access a texel using the integer texel coordinates rather than the usual normalized
    texture coordinates in the range 0-1.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在片段着色器中，我们首先分别计算阴影模型的漫反射和镜面反射分量之外的漫反射分量。我们根据片段的屏幕坐标（`gl_FragCoord`）访问偏移量纹理。我们这样做是通过取片段位置和偏移量纹理大小的模。结果是存储在`offsetCoord`的前两个分量中。这将为我们提供每个附近像素的不同偏移量集。`offsetCoord`的第三个分量将用于访问一对样本。样本的数量是纹理深度除以二。这存储在`samplesDiv2`中。我们使用`texelFetch`函数访问样本。这个函数允许我们使用整数texel坐标而不是通常的0-1范围内的归一化纹理坐标来访问texel。
- en: The offset is retrieved and multiplied by `Radius` and the *w* component of
    `ShadowCoord`. Multiplying by `Radius` simply scales the offsets so that they
    range from `0.0` to `Radius`.  Typically, we want the radius to represent a small
    region in texel space, so a value like `5/width` (where `width` is the width of
    the shadow map) would be appropriate. We multiply by the *w* component because
    `ShadowCoord` is still a homogeneous coordinate, and our goal is to use offsets
    to translate the `ShadowCoord`. In order to do so properly, we need to multiply
    the offset by the *w* component. Another way of thinking of this is that the w
    component will be cancelled when perspective division takes place.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 偏移量被检索并乘以`Radius`以及`ShadowCoord`的`w`分量。乘以`Radius`只是简单地缩放偏移量，使其范围从`0.0`到`Radius`。通常，我们希望半径代表纹理空间中的一个小区域，因此像`5/width`（其中`width`是阴影图的宽度）这样的值是合适的。我们乘以`w`分量，因为`ShadowCoord`仍然是一个齐次坐标，我们的目标是使用偏移量来平移`ShadowCoord`。为了正确地做到这一点，我们需要将偏移量乘以`w`分量。另一种思考方式是，当进行透视除法时，`w`分量将被消除。
- en: Next, we use offsets to translate `ShadowCoord` and access the shadow map to
    do the depth comparison using `textureProj`. We do so for each of the two samples
    stored in the texel, once for the first two components of offsets and again for
    the last two. The result is added to `sum`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用偏移来转换`ShadowCoord`并访问阴影图，使用`textureProj`进行深度比较。我们对存储在texel中的两个样本都这样做，一次用于偏移的前两个分量，再次用于后两个分量。结果被添加到`sum`中。
- en: The first loop repeats this for the first eight samples. If the first eight
    samples are all `0.0` or `1.0`, then we assume that all of the samples will be
    the same (the sample area is completely in or out of the shadow). In that case,
    we skip the evaluation of the rest of the samples. Otherwise, we evaluate the
    following samples and compute the overall average. Finally, the resulting average
    (shadow) is used to attenuate the diffuse and specular components of the lighting
    model.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个循环对前八个样本重复此操作。如果前八个样本都是`0.0`或`1.0`，则我们假设所有样本都将相同（样本区域完全在或不在阴影中）。在这种情况下，我们跳过其余样本的评估。否则，我们评估后续样本并计算整体平均值。最后，得到的平均值（阴影）用于衰减光照模型的漫反射和镜面反射分量。
- en: There's more...
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The use of a small texture containing a set of random offsets helps to blur
    the edges of the shadow better than what we might achieve with the standard PCF
    technique that uses a constant set of offsets. However, artifacts can still appear
    as repeated patterns within the shadow edges because the texture is finite and
    offsets are repeated every few pixels. We could improve this by also using a random
    rotation of the offsets within the fragment shader, or simply compute the offsets
    randomly within the shader.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用包含一组随机偏移的小纹理可以帮助比使用具有恒定偏移集的标准PCF技术更好地模糊阴影边缘。然而，由于纹理是有限的，偏移每几个像素就会重复，因此在阴影边缘仍可能出现重复图案的伪影。我们可以通过在片段着色器中也使用偏移的随机旋转来改进这一点，或者简单地计算着色器内的随机偏移。
- en: It should also be noted that this blurring of the edges may not be desired for
    all shadow edges. For example, edges that are directly adjacent to the occluder,
    that is, creating the shadow, should not be blurred. These may not always be visible,
    but can become so in certain situations, such as when the occluder is a narrow
    object. The effect is to make the object appear as if it is hovering above the
    surface. Unfortunately, there isn't an easy fix for this one.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 还应注意的是，这种边缘模糊可能并不适用于所有阴影边缘。例如，直接相邻于遮挡物、即产生阴影的边缘不应被模糊。这些可能并不总是可见的，但在某些情况下可能会变得可见，例如当遮挡物是一个窄物体时。这种效果是使物体看起来像是在表面上方悬浮。不幸的是，对此并没有简单的解决方案。
- en: See also
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter08/scenejitter.cpp` file in the example code
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的`chapter08/scenejitter.cpp`文件
- en: The *Rendering shadows with shadow maps* recipe
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用阴影图渲染阴影*的配方'
- en: Creating shadows using shadow volumes and the geometry shader
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用阴影体积和几何着色器创建阴影
- en: As we discovered in the previous recipes, one of the main problems with shadow
    maps is aliasing. The problem essentially boils down to the fact that we are sampling
    the shadow map(s) at a different frequency (resolution) than we are using when
    rendering the scene. To minimize the aliasing we can blur the shadow edges (as
    in the previous recipes), or try to sample the shadow map at a frequency that
    is closer to the corresponding resolution in projected screen space. There are
    many techniques that help with the latter; for more details, I recommend the book
    *Real-Time Shadows*.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的配方中发现的，阴影图的主要问题之一是走样。这个问题本质上归结为这样一个事实：我们在渲染场景时，对阴影图（图）的采样频率（分辨率）与我们使用的频率不同。为了最小化走样，我们可以模糊阴影边缘（如前述配方所示），或者尝试以更接近投影屏幕空间中相应分辨率的频率采样阴影图。有许多技术有助于后者；有关更多详细信息，我推荐阅读《实时阴影》这本书。
- en: 'An alternate technique for shadow generation is called **shadow volumes**.
    The shadow volume method completely avoids the aliasing problem that plagues shadow
    maps. With shadow volumes, you get pixel-perfect hard shadows, without the aliasing
    artifacts of shadow maps. The following image shows a scene with shadows that
    are produced using the shadow volume technique:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 用于阴影生成的另一种技术称为**阴影体积**。阴影体积方法完全避免了困扰阴影图的走样问题。使用阴影体积，你可以得到像素完美的硬阴影，而没有阴影图中的走样伪影。以下图像显示了使用阴影体积技术生成的阴影场景：
- en: '![](img/e9d2530d-a853-430f-ad8a-8e635e0c5f2e.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e9d2530d-a853-430f-ad8a-8e635e0c5f2e.png)'
- en: 'The shadow volume technique works by making use of the stencil buffer to mask
    out areas that are in shadow. We do this by drawing the boundaries of the actual
    shadow volumes (more on this next). A shadow volume is the region of space where
    the light source is occluded by an object. For example, the following diagram
    shows a representation of the shadow volumes of a triangle (left) and a sphere
    (right):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 阴影体积技术通过使用模板缓冲区来屏蔽阴影区域来工作。我们通过绘制实际阴影体积的边界（更多内容将在下文中介绍）来实现这一点。阴影体积是光源被物体遮挡的空间区域。例如，以下图表显示了三角形（左侧）和球体（右侧）的阴影体积表示：
- en: '![](img/5e741657-e602-4eb8-b108-75800559aae7.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5e741657-e602-4eb8-b108-75800559aae7.png)'
- en: The boundaries of a shadow volume are made up of quads formed by extending the
    edges of the object away from the light source. For a single triangle, the boundaries
    would consist of three quads, extended from each edge, and triangular caps on
    each end. One cap is the triangle itself and the other is placed at some distance
    from the light source. For an object that consists of many triangles, such as
    the preceding sphere, the volume can be defined by the so-called **silhouette
    edges**. These are edges that are on or near the boundary between the shadow volume
    and the portion of the object that is lit. In general, a silhouette edge borders
    a triangle that faces the light and another triangle that faces away from the
    light. To draw the shadow volume, one would find all of the silhouette edges and
    draw extended quads for each edge. The caps of the volume could be determined
    by making a closed polygon (or triangle fan) that includes all the points on the
    silhouette edges, and similarly on the far end of the volume.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 阴影体积的边界由通过将物体的边缘延伸到光源形成的四边形组成。对于一个单独的三角形，边界将包括从每个边缘延伸出的三个四边形，以及每个端点的三角形盖。一个盖是三角形本身，另一个放置在离光源一定距离的地方。对于由许多三角形组成的物体，例如前面的球体，体积可以通过所谓的**轮廓边缘**来定义。这些是位于或接近阴影体积与被光照物体部分之间的边。一般来说，轮廓边缘与一个面向光源的三角形和另一个背向光源的三角形相邻。要绘制阴影体积，需要找到所有的轮廓边缘并为每个边缘绘制扩展的四边形。体积的盖可以通过创建一个包含所有轮廓边缘点的闭合多边形（或三角形扇）来确定，同样在体积的远端也是如此。
- en: 'The shadow volume technique works in the following way. Imagine a ray that
    originates at the camera position and extends through a pixel on the near plane.
    Suppose that we follow that ray and keep track of a counter that is incremented
    every time that it enters a shadow volume and decremented each time that it exits
    a shadow volume. If we stop counting when we hit a surface, that point on the
    surface is occluded (in shadow) if our count is non-zero, otherwise, the surface
    is lit by the light source. The following diagram shows an example of this idea:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 阴影体积技术的工作方式如下。想象一条从相机位置发出并穿过近平面上的一个像素的射线。假设我们跟随那条射线并跟踪一个计数器，每次它进入阴影体积时计数器增加，每次它离开阴影体积时计数器减少。如果我们停止计数直到碰到表面，那么如果我们的计数非零，该表面的点被遮挡（在阴影中），否则，该表面被光源照亮。以下图表展示了这个想法的一个例子：
- en: '![](img/46a5d757-ce83-47af-a0a9-d9af7a12d099.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/46a5d757-ce83-47af-a0a9-d9af7a12d099.png)'
- en: 'The roughly horizontal line represents a surface that is receiving a shadow.
    The numbers represent the counter for each camera ray. For example, the rightmost
    ray with value **+1** has that value because the ray entered two volumes and exited
    one along the way from the camera to the surface: *1 + 1 - 1 = 1*. The rightmost
    ray has a value of **0** at the surface because it entered and exited both shadow
    volumes: *1 + 1 - 1 - 1 = 0*.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 大约水平的线代表一个正在接收阴影的表面。数字代表每个相机射线的计数器。例如，最右侧的射线值为**+1**，因为这个值是因为射线在从相机到表面的过程中进入了两个体积并离开了一个体积：*1
    + 1 - 1 = 1*。最右侧的射线在表面上的值为**0**，因为它进入了并离开了两个阴影体积：*1 + 1 - 1 - 1 = 0*。
- en: This all sounds fine in theory, but how can we trace rays in OpenGL? The good
    news is that we don't have to. The stencil buffer provides just what we need.
    With the stencil buffer, we can increment/decrement a counter for each pixel based
    on whether a front or back face is rendered into that pixel. So, we can draw the
    boundaries of all of the shadow volumes, then for each pixel, increment the stencil
    buffer's counter when a front face is rendered to that pixel and decrement when
    it is a back face.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上听起来不错，但我们如何在OpenGL中追踪光线？好消息是，我们不必这样做。模板缓冲区正好提供了我们所需要的东西。使用模板缓冲区，我们可以根据是否将正面或背面渲染到每个像素中来增加/减少每个像素的计数器。因此，我们可以绘制所有阴影体积的边界，然后对于每个像素，当正面渲染到该像素时增加模板缓冲区的计数器，当它是背面时减少。
- en: The key here is to realize that each pixel in the rendered figure represents
    an eye-ray (as in the preceding diagram). So, for a given pixel, the value in
    the stencil buffer is the value that we would get if we actually traced a ray
    through that pixel. The depth test helps to stop tracing when we reach a surface.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于意识到渲染图像中的每个像素代表一个视线（如前图所示）。因此，对于给定的像素，模板缓冲区中的值就是我们实际通过该像素追踪光线时得到的值。深度测试有助于在达到表面时停止追踪。
- en: This is just a quick introduction to shadow volumes; a full discussion is beyond
    the scope of this book. For more detail, a great resource is *Real-Time Shadows* by Eisemann et
    al.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个关于阴影体积的快速介绍；完整的讨论超出了本书的范围。更多细节，可以参考Eisemann等人所著的*实时阴影*。
- en: In this recipe, we'll draw our shadow volumes with the help of the geometry
    shader. Rather than computing the shadow volumes on the CPU side, we'll render
    the geometry normally, and have the geometry shader produce the shadow volumes.
    In the *Drawing silhouette lines using the geometry shader* recipe in [Chapter
    7](fab663d4-e210-417c-aa3b-2c4c307ec913.xhtml), *Using Geometry and Tessellation
    Shaders*, we saw how the geometry shader can be provided with adjacency information
    for each triangle. With adjacency information, we can determine whether a triangle
    has a silhouette edge. If the triangle faces the light, and a neighboring triangle
    faces away from the light, then the shared edge can be considered a silhouette
    edge, and used to create a polygon for the shadow volume.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将使用几何着色器绘制阴影体积。而不是在CPU端计算阴影体积，我们将正常渲染几何体，并让几何着色器生成阴影体积。在[第7章](fab663d4-e210-417c-aa3b-2c4c307ec913.xhtml)的*使用几何和细分着色器*配方中，我们看到了几何着色器如何为每个三角形提供相邻信息。有了相邻信息，我们可以确定三角形是否有轮廓边缘。如果一个三角形面向光源，而相邻的三角形背向光源，那么共享的边可以被认为是轮廓边缘，并用于创建阴影体积的多边形。
- en: 'The entire process is done in three passes. They are as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 整个过程分为三个步骤。具体如下：
- en: Render the scene normally, but write the shaded color to two separate buffers.
    We'll store the ambient component in one and the diffuse and specular components
    in another.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正常渲染场景，但将着色后的颜色写入两个独立的缓冲区。我们将存储环境分量在一个缓冲区中，而将漫反射和镜面分量在另一个缓冲区中。
- en: Set up the stencil buffer so that the stencil test always passes, and front
    faces cause an increment and back faces cause a decrement. Make the depth buffer
    read-only, and render only the shadow-casting objects. In this pass, the geometry
    shader will produce the shadow volumes, and only the shadow volumes will be rendered
    to the fragment shader.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置模板缓冲区，使得模板测试始终通过，正面导致增加，背面导致减少。使深度缓冲区为只读，并仅渲染投射阴影的对象。在这个过程中，几何着色器将生成阴影体积，并且只有阴影体积将被渲染到片段着色器中。
- en: Set up the stencil buffer so that the test succeeds when the value is equal
    to zero. Draw a screen-filling quad, and combine the values of the two buffers
    from step one when the stencil test succeeds.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置模板缓冲区，使得当值为零时测试成功。绘制一个填充整个屏幕的四边形，并在模板测试成功时将第一步中两个缓冲区的值合并。
- en: That's the high-level view, and there are many details. Let's go through them
    in the next sections.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个高级视图，其中有很多细节。让我们在下一节中逐一介绍。
- en: Getting ready
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll start by creating our buffers. We'll use a framebuffer object with a depth
    attachment and two color attachments. The ambient component can be stored in a
    renderbuffer (as opposed to a texture) because we'll blit (a fast copy) it over
    to the default framebuffer rather than reading from it as a texture. The *diffuse
    + specular* component will be stored in a texture.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建我们的缓冲区。我们将使用一个具有深度附加组件和两个颜色附加组件的帧缓冲对象。环境分量可以存储在渲染缓冲区中（而不是纹理），因为我们将其快速复制（复制）到默认帧缓冲区，而不是作为纹理读取它。*漫反射+镜面反射*分量将存储在纹理中。
- en: 'Create the ambient buffer (`ambBuf`), a depth buffer (`depthBuf`), and a texture
    (`diffSpecTex`), then set up the FBO:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 创建环境缓冲区（`ambBuf`）、深度缓冲区（`depthBuf`）和纹理（`diffSpecTex`），然后设置FBO：
- en: '[PRE8]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Set up the draw buffers so that we can write to the color attachments:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 设置绘制缓冲区，以便我们可以写入颜色附加组件：
- en: '[PRE9]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How to do it...
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'For the first pass, enable the framebuffer object that we set up earlier, and
    render the scene normally. In the fragment shader, send the ambient component
    and the *diffuse + specular* component to separate outputs:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一次遍历，启用我们之前设置的帧缓冲对象，并正常渲染场景。在片段着色器中，将环境分量和*漫反射+镜面反射*分量发送到不同的输出：
- en: '[PRE10]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the second pass, we''ll render our shadow volumes. We want to set up the
    stencil buffer so that the test always succeeds, and that front faces cause an
    increment, and back faces cause a decrement:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二次遍历中，我们将渲染我们的阴影体积。我们希望设置模板缓冲区，使得测试总是成功，并且正面导致增加，背面导致减少：
- en: '[PRE11]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Also in this pass, we want to use the depth buffer from the first pass, but
    we want to use the default frame buffer, so we need to copy the depth buffer over
    from the FBO used in the first pass. We''ll also copy over the color data, which
    should contain the ambient component:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个遍历中，我们还想使用第一次遍历的深度缓冲区，但我们想使用默认的帧缓冲区，因此我们需要从第一次遍历中使用的FBO复制深度缓冲区。我们还将复制颜色数据，其中应包含环境分量：
- en: '[PRE12]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We don''t want to write to the depth buffer or the color buffer in this pass,
    since our only goal is to update the stencil buffer, so we''ll disable writing
    for those buffers:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望在这次遍历中写入深度缓冲区或颜色缓冲区，因为我们的唯一目标是更新模板缓冲区，所以我们将禁用对这些缓冲区的写入：
- en: '[PRE13]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we render the shadow-casting objects with adjacency information. In the
    geometry shader, we determine the silhouette edges and output only quads that
    define the shadow volume boundaries:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用相邻信息渲染产生阴影的对象。在几何着色器中，我们确定轮廓边缘，并只输出定义阴影体积边界的四边形：
- en: '[PRE14]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the third pass, we''ll set up our stencil buffer so that the test passes
    only when the value in the buffer is equal to zero:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三次遍历中，我们将设置我们的模板缓冲区，使得测试仅在缓冲区中的值等于零时通过：
- en: '[PRE15]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We want to enable blending so that our ambient component is combined with *diffuse
    + specular* when the stencil test succeeds:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望启用混合，以便当模板测试成功时，我们的环境分量与*漫反射+镜面反射*结合：
- en: '[PRE16]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In this pass, we just draw a screen-filling quad, and output the *diffuse +
    specular* value. If the stencil test succeeds, the value will be combined with
    the ambient component, which is already in the buffer (we copied it over earlier
    using `glBlitFramebuffer`):'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次遍历中，我们只绘制一个填充屏幕的四边形，并输出*漫反射+镜面反射*值。如果模板测试成功，该值将与环境分量结合，该分量已经在缓冲区中（我们之前使用`glBlitFramebuffer`复制过来）：
- en: '[PRE17]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works...
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The first pass is fairly straightforward. We draw the entire scene normally,
    except we separate the ambient color from the diffuse and specular color, and
    send the results to different buffers.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次遍历相当直接。我们正常绘制整个场景，除了我们将环境颜色与漫反射和镜面反射颜色分开，并将结果发送到不同的缓冲区。
- en: The second pass is the core of the algorithm. Here, we render only the objects
    that cast shadows and let the geometry shader produce the shadow volumes. Thanks
    to the geometry shader, we don't actually end up rendering the shadow-casting
    objects at all, only the shadow volumes. However, before this pass, we need to
    do a bit of setup. We set up the stencil test so that it increments when a front
    face is rendered and decrements for back faces using `glStencilOpSeparate`, and
    the stencil test is configured to always succeed using `glStencilFunc`. We also
    use `glBlitFramebuffer` to copy over the depth buffer and (ambient) color buffer
    from the FBO used in the first pass. Since we want to only render shadow volumes
    that are not obscured by geometry, we make the depth buffer read-only using `glDepthMask`.
    Lastly, we disable writing to the color buffer using `glColorMask` because we
    don't want to mistakenly overwrite anything in this pass.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次遍历是算法的核心。在这里，我们只渲染产生阴影的对象，并让几何着色器生成阴影体积。多亏了几何着色器，我们实际上并没有渲染产生阴影的对象，而只是渲染了阴影体积。然而，在这个遍历之前，我们需要做一些设置。我们使用`glStencilOpSeparate`设置模板测试，以便在渲染前表面时递增，在渲染后表面时递减，并且使用`glStencilFunc`配置模板测试始终成功。我们还使用`glBlitFramebuffer`将深度缓冲区和（环境）颜色缓冲区从第一次遍历中使用的FBO复制过来。由于我们只想渲染不被几何体遮挡的阴影体积，我们使用`glDepthMask`使深度缓冲区只读。最后，我们使用`glColorMask`禁用颜色缓冲区的写入，因为我们不希望在这个遍历中错误地覆盖任何内容。
- en: 'The geometry shader does the work of producing the silhouette shadow volumes.
    Since we are rendering using adjacency information (see the *Drawing silhouette
    lines using the geometry shader* recipe in [Chapter 7](fab663d4-e210-417c-aa3b-2c4c307ec913.xhtml),
    *Using Geometry and Tessellation Shaders*), the geometry shader has access to
    six vertices that define the current triangle being rendered and the three neighboring
    triangles. The vertices are numbered from 0 to 5, and are available via the input
    array named `VPosition` in this example. Vertices 0, 2, and 4 define the current
    triangle and the others define the adjacent triangles, as shown in the following
    diagram:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 几何着色器负责生成轮廓阴影体积。由于我们正在使用邻接信息进行渲染（参见第7章中关于使用几何和细分着色器的配方“使用几何着色器绘制轮廓线”，[fab663d4-e210-417c-aa3b-2c4c307ec913.xhtml]，*使用几何和细分着色器*），几何着色器可以访问定义当前正在渲染的三角形及其三个相邻三角形的六个顶点。顶点编号从0到5，在本例中通过名为`VPosition`的输入数组提供。顶点0、2和4定义当前三角形，其余的顶点定义相邻的三角形，如下面的图所示：
- en: '![](img/a1daffb5-c408-48ab-9418-1ce337807843.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a1daffb5-c408-48ab-9418-1ce337807843.png)'
- en: The geometry shader starts by testing the main triangle (**0**, **2**, **4**)
    to see if it faces the light source. We do so by computing the normal to the triangle
    (`n`) and the vector from each vertex to the light source. Then, we compute the
    dot product of n and each of the three light source direction vectors (`da`, `db`,
    and `dc`). If any of the three are positive, then the triangle faces the light
    source. If we find that triangle (**0**, **2**, **4**) faces the light, then we
    test each neighboring triangle in the same way. If a neighboring triangle does
    not face the light source, then the edge between them is a silhouette edge and
    can be used as an edge of a face of the shadow volume.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 几何着色器首先测试主三角形（**0**，**2**，**4**）是否面向光源。我们通过计算三角形的法线（`n`）和每个顶点到光源的向量来完成。然后，我们计算n与每个光源方向向量（`da`，`db`，和`dc`）的点积。如果这三个中的任何一个为正，则三角形面向光源。如果我们发现三角形（**0**，**2**，**4**）面向光源，那么我们就以相同的方式测试相邻的每个三角形。如果一个相邻的三角形不面向光源，那么它们之间的边就是轮廓边，可以用作阴影体积的面的边。
- en: We create a shadow volume face in the `emitEdgeQuad` function. The points `a`
    and `b` define the silhouette edge, one edge of the shadow volume face. The other
    two vertices of the face are determined by extending `a` and `b` away from the
    light source. Here, we use a mathematical trick that is enabled by homogeneous
    coordinates. We extend the face out to infinity by using a zero in the `w` coordinate
    of the extended vertices. This effectively defines a homogeneous vector, sometimes
    called a point at infinity. The `x`, `y`, and `z` coordinates define a vector
    in the direction away from the light source, and the `w` value is set to `0`.
    The end result is that we get a quad that extends out to infinity, away from the
    light source.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`emitEdgeQuad`函数中创建一个阴影体积面。点`a`和`b`定义了轮廓边缘，阴影体积面的一个边缘。面的其他两个顶点通过从光源延伸`a`和`b`来确定。在这里，我们使用一个由齐次坐标启用的数学技巧。我们通过在扩展顶点的`w`坐标中使用零来将面延伸到无穷远。这实际上定义了一个齐次向量，有时称为无穷远点。`x`、`y`和`z`坐标定义了一个指向光源方向上的向量，而`w`值被设置为`0`。最终结果是，我们得到了一个延伸到无穷远、远离光源的四边形。
- en: This will only work properly if we use a modified projection matrix that can
    take into account points defined in this way. Essentially, we want a projection
    matrix with a far plane set at infinity. GLM provides just such a projection matrix
    via the `infinitePerspective` function.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这只会在我们使用一个可以考虑到以这种方式定义的点的修改后的投影矩阵时才能正常工作。本质上，我们想要一个远平面设置为无穷远的投影矩阵。GLM通过`infinitePerspective`函数提供了这样的投影矩阵。
- en: We don't worry about drawing the caps of the shadow volume here. We don't need
    a cap at the far end, because we've used the homogeneous trick described earlier,
    and the object itself will serve as the cap on the near end.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不需要担心绘制阴影体积的端盖。我们不需要远端的端盖，因为我们已经使用了之前描述的齐次技巧，物体本身将作为近端的端盖。
- en: In the third and final pass, we reset our stencil test to pass when the value
    in the stencil buffer is equal to zero using `glStencilFunc`. Here, we want to
    sum the ambient with the *diffuse + specular* color when the stencil test succeeds,
    so we enable blending, and set the source and destination blend functions to `GL_ONE`.
    We render just a single screen-filling quad, and output the value from the texture
    that contains our *diffuse + specular* color. The stencil test will take care
    of discarding fragments that are in shadow, and OpenGL's blending support will
    blend the output with the ambient color for fragments that pass the test. (Remember
    that we copied over the ambient color using `glBlitFramebuffer` earlier.)
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三次也是最后一次遍历中，我们使用`glStencilFunc`将模板测试重置为当模板缓冲区中的值等于零时通过。在这里，当模板测试成功时，我们希望将环境光与*漫反射+镜面反射*颜色相加，因此我们启用混合，并将源和目标混合函数设置为`GL_ONE`。我们只渲染一个填充整个屏幕的四边形，并输出包含我们的*漫反射+镜面反射*颜色的纹理中的值。模板测试将负责丢弃处于阴影中的片段，OpenGL的混合支持将输出与通过测试的片段的环境光混合。（记住，我们之前使用`glBlitFramebuffer`复制了环境光。）
- en: There's more...
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The technique described here is often referred to as the **z-pass** technique.
    It has one fatal flaw. If the camera is located within a shadow volume, this technique
    breaks down because the counts in the stencil buffer will be off by at least one.
    A common solution is to basically invert the problem and trace a ray from infinity
    toward the view point. This is called the **z-fail** technique or **Carmack's
    reverse**.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这里描述的技术通常被称为**Z-pass技术**。它有一个致命的缺陷。如果相机位于阴影体积内，这种技术就会失效，因为模板缓冲区中的计数至少会错一位。一个常见的解决方案是基本上反转问题，并从无穷远处向视点追踪一条射线。这被称为**Z-fail技术**或**Carmack的逆向**。
- en: The *fail* and *pass* here refer to whether or not we are counting when the
    depth test passes or fails.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的*失败*和*通过*指的是在深度测试通过或失败时我们是否进行计数。
- en: Care must be taken when using z-fail because it is important to draw the caps
    of the shadow volumes. However, the technique is very similar to z-pass. Instead
    of incrementing/decrementing when the depth test passes, we do so when the depth
    test fails. This effectively *traces *a ray from infinity back toward the view
    point.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Z-fail时必须小心，因为绘制阴影体积的端盖非常重要。然而，这种技术与Z-pass非常相似。不是在深度测试通过时递增/递减，而是在深度测试失败时递增/递减。这实际上*追踪*了一条从无穷远处向视点回溯的射线。
- en: I should also note that the preceding code is not robust enough to degenerate
    triangles (triangles that have sides that are nearly parallel), or non-closed
    meshes. One might need to take care in such situations. For example, to better
    deal with degenerate triangles, we could use another technique for determining
    the normal to the triangle. We could also add additional code to handle edges
    of meshes, or simply always use closed meshes.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我还应该指出，前面的代码不足以处理退化三角形（边几乎平行的三角形）或非封闭网格。在这种情况下可能需要小心处理。例如，为了更好地处理退化三角形，我们可以使用另一种确定三角形法向量的技术。我们还可以添加额外的代码来处理网格的边，或者简单地始终使用封闭网格。
- en: See also
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter08/sceneshadowvolume.cpp` file in the example code
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的`chapter08/sceneshadowvolume.cpp`文件
- en: The *Drawing silhouette lines **using the geometry shader* recipe in [Chapter
    7](fab663d4-e210-417c-aa3b-2c4c307ec913.xhtml), *Using Geometry and Tessellation
    Shaders*
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第7章](fab663d4-e210-417c-aa3b-2c4c307ec913.xhtml)的*使用几何着色器绘制轮廓线**配方中，*使用几何和细分着色器*
