<html><head></head><body>
		<div class="Content" id="_idContainer048">
			<h1 id="_idParaDest-162"><em class="italics"><a id="_idTextAnchor173"/>Chapter 11</em></h1>
		</div>
		<div class="Content" id="_idContainer049">
			<h1 id="_idParaDest-163"><a id="_idTextAnchor174"/>Critical Analysis</h1>
		</div>
		<div class="Content" id="_idContainer050">
			<h2 id="_idParaDest-164"><a id="_idTextAnchor175"/>Introduction</h2>
			<p>During your professional career, people will tell you things that aren't true. Sometimes they're lies, intended to manipulate or deceive; sometimes they're things that the speaker believes (or perhaps wants to believe), but on closer inspection don't pass muster; sometimes people will tell you things that <em class="italics">are</em> true, but irrelevant or of limited use, to persuade you of their position.</p>
			<p>Who will be telling you these things? You've probably already thought of marketing and salespeople, desperate to get you or your company to take their product and win the commission. Speakers at conferences could do it too, trying to convince you that the technique, style, or strategy they're promoting is applicable to your situation in addition to theirs. The website for that new language you want to try out may be making exaggerated claims. Your manager or teammates may be trying a little too hard to sell you on their way of thinking.</p>
			<p>There will also be plenty of occasions on which people tell you things that <em class="italics">are</em> true. Some of these could be surprising, especially if <strong class="bold">common sense</strong>—<a href="http://rationalwiki.org/wiki/Common_sense">http://rationalwiki.org/wiki/Common_sense</a> tells you the opposite is true; some of these could be suspicious; some you might be willing to accept without debate. Though there's no harm in questioning the <strong class="bold">truthiness</strong>—<a href="http://en.wikipedia.org/wiki/Truthiness">http://en.wikipedia.org/wiki/Truthiness</a> of things, even when they are indeed true.</p>
			<p>Critical analysis is about studying arguments to determine their well-formedness. In this context, an "argument" is a collection of statements affirming a particular position; it isn't a verbal sparring match between two people. An argument is well-formed if it contains some premises and reaches a conclusion logically derivable from those premises. Notice that such an argument is <em class="italics">well-formed</em>, not <em class="italics">correct</em>: the argument could rely on contested knowledge or the premises could be unsound for some other reason. Nonetheless, uncovering the rhetorical techniques and fallacies, if any, present in an argument can help you to understand the arguer's position and why they want you to agree with their conclusion, in addition to helping you decide whether you can agree with that conclusion.</p>
			<h2 id="_idParaDest-165"><a id="_idTextAnchor176"/>Criticism Is Often Uncritical</h2>
			<p>"You're wrong." I hope that even without the information presented in the rest of this chapter, it's clear that the statement at the beginning of this chapter is not a well-formed argument. A fragment of a conclusion is presented (I'm wrong, but about what? This argument? Everything? Something in between? Is it my position that's wrong, or am I ethically abhorrent?), with no premises or deduction.</p>
			<p>Criticism has come to mean expressing a negative opinion on some matter, but that's not the sense in which it's used here. The phrase "critical analysis" uses a more academic definition of the word critical. In this context, to be critical means to analyze both the pros and cons of an argument, to understand it in terms of the particular rules of argument formation, and to <em class="italics">discover</em> whether you find the conclusion to be agreeable. Many online discussions can be found that are entirely uncritical; the people taking part have decided on their positions in advance and are trying to find ways to more forcefully present their case and undermine the other.</p>
			<p>Being faced with this sort of response can be frustrating. There's no value to be had from reading the counter argument; it's not critical, so it doesn't tell you <em class="italics">why</em> the other person disagrees with you. It's easy to take such responses personally though (on which, more later), and to get upset or angry at the person (or imagined person behind an online pseudonym). It's these factors that have led a minority of bloggers to switch off comments on their sites. It's easier to present an uninformed or uncritical argument than a well-thought-out one, therefore a large number of comments on the internet are of this unhelpful type.</p>
			<p>Please do not be part of that problem. Read to understand, not to reply. If you're left with problems, try to formulate a rational explanation of why the argument presented did not discuss those problems. If it's still unclear after doing that, then by all means post your explanation. Both of you can probably learn from it.</p>
			<h2 id="_idParaDest-166"><a id="_idTextAnchor177"/>How to Form an Argument?</h2>
			<p>Rather than describe how to analyze an argument, I'll explain how to construct one. It follows that critical analysis is the exploration of whether an argument contains high-quality versions of the features described here, linked coherently to support the conclusion or conclusions of the argument.</p>
			<p>Though they need not be presented at the beginning of an argument (and indeed may not be explicit at all), any argument depends on a collection of assumptions or premises. These are statements accepted as true for the purpose of exploring the subject of the argument. The validity of any assumption depends on the context; in any field, some things are considered uncontested knowledge while others are contested. An example of uncontested knowledge in computing could be the features and operation of a universal Turing machine; the facts were documented and proven mathematically in the 1930s and are generally agreed to represent a sound base on which the rest of computer science is built. The assumption "Java is a useful language to teach beginners" would be considered contested knowledge, being far from universally accepted.</p>
			<p>Such a contested assumption would need to be supported by external evidence that readers or listeners could evaluate to decide the validity of the assumption. In academic fields, acceptable evidence is usually restricted to reviewed literature. Indeed, it's possible to find papers that support the Java assertion made in the previous paragraph. In an academic argument, uncontested knowledge is roughly equivalent to "statements that are found in textbooks."</p>
			<p>Almost tautologically, software creation practiced outside universities is not an academic discipline. There's little dependence on the formalities of academia and great reliance on personal or shared experiences. As a result, argument based on authority ("Martin Fowler says…") or on personal opinion ("I have found…") is often used to justify contested knowledge. In the latter case, the assumption could be presented as an intermediate conclusion: it follows from its own set of premises and is then used as input into a successive argument. Arguments outside those used in critical analysis textbooks are frequently built on chains of intermediate conclusions, combined with other premises to reach the eventual goal.</p>
			<p>Arguments based on opinion or experience are easily, though not particularly usefully, undermined by the existence of people with differing opinions and experiences. Where these bases are used, the scope of the experience and the reasons for drawing particular opinions should be given as justification for reaching the stated conclusion.</p>
			<p>The conclusion itself should be a position taken as a result of reasoning from the assumptions and intermediate conclusions. That is to say, it should be related to the premises; if you feel the need to confuse matters by introducing unrelated facts, then your argument is not particularly strong. The logical process of going from the premises to the conclusion, though potentially complex, should ideally be mechanistic; a "leap of faith" is inappropriate, and any lateral or otherwise devious steps should be explicit. Essay-style arguments are usually expected to reach their conclusions via deductive rather than inductive reasoning; appeals to analogy for example would be considered inappropriate. Practically speaking, as a programmer, you're more likely to be examining a sales pitch or a request from a customer than an academic essay, so the "rules" will be a lot looser.</p>
			<p>The conclusion doesn't need to be the final part of the argument's presentation. Some writers open with the conclusion, to challenge the readers and get them thinking about how the argument might proceed, a technique also used in oral presentations of arguments. Occasionally, the conclusion comes after a bare-bones form of the argument, then further support is given to make the conclusion more compelling. In any case, the conclusion is often reiterated at the end of the argument; after all, it's the part you want to stick most in the minds of the readers or listeners.</p>
			<h2 id="_idParaDest-167"><a id="_idTextAnchor178"/>Forms Of Fallacy</h2>
			<p>This section takes the form of a catalog, of sorts. It's not going to be complete and won't take a formal approach to describing the catalog in the same way that, for example, <em class="italics">Design Patterns</em> deals with its catalogue; a complete catalogue of fallacies would be at least as long as the rest of this book. A formal and consistent catalog would require planning.</p>
			<h3 id="_idParaDest-168"><a id="_idTextAnchor179"/>Post Hoc, Ergo Propter Hoc</h3>
			<p>Translated, this means "After this, therefore because of this." Given two events, X and Y, the argument goes:</p>
			<p>First X, then Y. Y was therefore caused by X.</p>
			<p>This is a form of inductive reasoning that does not necessarily hold. Here's an absurd example:</p>
			<p><em class="italics">The light turned red, and the car came to a halt. Red photons exert a strong retarding effect on cars.</em></p>
			<p>In this case, there <em class="italics">could be</em> a causative relationship, but it is not as direct as the argument proposes.</p>
			<h3 id="_idParaDest-169"><a id="_idTextAnchor180"/>Fundamental Attribution Error</h3>
			<p><em class="italics">Person P did X. Therefore, P is a moron.</em></p>
			<p>This is also called correspondence bias. People often understand the situational basis for actions they take, but ascribe actions taken by others to their innate personalities. Here's a good example for coders to consider: if <em class="italics">I</em> take a shortcut, I'm being pragmatic, because of the pressures of the current project/iteration/whatever. If <em class="italics">you</em> were to take the same shortcut, it's because you don't understand sound software development principles.</p>
			<h3 id="_idParaDest-170"><a id="_idTextAnchor181"/>Argument from Fallacy</h3>
			<p>This is a subtle one, but one that's quite easy to find in online discussions once you know about it:</p>
			<p><em class="italics">Argument A says that X follows Y. Argument A is fallacious. Therefore, X does not follow Y.</em></p>
			<p>Just because an argument contains a fallacy, it does not necessarily follow that its conclusion is incorrect. Consider this concrete example:</p>
			<p><em class="italics">Isaac Newton's law of gravitation says that when I drop an object, it will fall to Earth because of a force called gravity. Einstein showed that gravity is in fact caused by the curvature of space-time. Newton was incorrect; therefore, the object will not fall to Earth when I drop it.</em></p>
			<p>In fact, for pretty much every situation where Newton's law of gravity would predict that an object would fall to earth, so would Einstein's general relativity; and the object would indeed fall to Earth. Neither of these models would be in use if their predictions were not valid in certain scenarios, even though the <em class="italics">reasons</em> they give for the results they predict may not be what <em class="italics">actually</em> happens.</p>
			<h3 id="_idParaDest-171"><a id="_idTextAnchor182"/>Continuum Fallacy</h3>
			<p>The continuum fallacy is one of the more frequently encountered fallacies in online arguments, particularly on media like Twitter, where the length of any statement is limited. The fallacy is to declare an argument incorrect because it is not satisfied in a particular condition. Going back to the example of gravitational theories, a continuum fallacy counterargument to Newton would be "Newton's <strong class="bold">Law of Gravitation </strong>does not predict the precession of Mercury's perihelion, therefore no result of Newton's Law has any value." In fact, within human-scale interactions, Newton's Law is very valuable; it gives reasonably accurate answers that are easy to compute. Einstein's theory is more general, giving answers consistent with Newton (and observation) at human scales <em class="italics">and</em> successfully predicting Mercury's motion. But Newton's significant baby need not be thrown out with the bathwater.</p>
			<p>Here's a theory I have on the prevalence of the continuum fallacy in programmer discussions: our programming activities <em class="italics">train</em> us to look for and cover edge cases. Computers are, in the ways that most programmers use them most of the time, incapable of inductive reasoning. When dealing with a computer, then, a programmer must look for any situation that has not been discussed and explicitly state the results of meeting that situation. This training can lead to continuum fallacies in human interactions, where the programmer applies the same keen sense of edge-case detection to statements made by other people that were implicitly scoped or otherwise depended on induction in their correctness.</p>
			<h3 id="_idParaDest-172"><a id="_idTextAnchor183"/>Slippery Slope</h3>
			<p><em class="italics">If X, then Y. Y, then Z. Z, then dogs and cats living together, mass hysteria.</em></p>
			<p>A slippery slope retort is a popular rhetorical device for undermining an argument. If it's well-constructed, then the individual steps will each look plausible, though they actually represent successive continuum fallacies, or subtle straw-man variants on what was actually proposed. The end result will be absurd or, to the arguer's mind anyway, highly undesirable.</p>
			<h3 id="_idParaDest-173"><a id="_idTextAnchor184"/>Begging the Question</h3>
			<p>This term has a specific meaning in the jargon of critical thinking, which is separate from its casual use as "an argument that raises an obvious question." Formally, an argument begs the question if it is made valid by accepting the conclusion as an implicit assumption: X, therefore X. Theological arguments sometimes beg the question; consider <strong class="bold">this argument</strong>—<a href="http://rationalwiki.org/wiki/Begging_the_question">http://rationalwiki.org/wiki/Begging_the_question</a>):</p>
			<p><em class="italics">The order and magnificence of the world is evidence of God's Creation. Therefore, God exists.</em></p>
			<p>The first statement is only true if you assume that God exists to have created the "order and magnificence of the world"; so, the argument is simply "God exists because God exists."</p>
			<h3 id="_idParaDest-174"><a id="_idTextAnchor185"/>Appeal to Novelty</h3>
			<p>This is also called "argumentum ad novitatem" and says that something that's newer is better just because of its novelty. It's common to see in discussions of which technology is "better," particularly in vendor marketing material: our product is newer than the competitor's product, which means it must be better (This fallacy underpins the <em class="italics">completely rewritten from the ground up</em>—<a href="http://blog.securemacprogramming.com/2013/04/on-rewriting-your-application/">http://blog.securemacprogramming.com/2013/04/on-rewriting-your-application/</a> software product marketing position).</p>
			<p>It doesn't take more than a few seconds of thought to construct questions that circumvent ad novitatem fallacies: just think about what would <em class="italics">actually</em> make one of the options a better choice. If you need relational, table-based storage, then a new NoSQL database would be worse than an RDBMS, despite being newer, for example.</p>
			<h3 id="_idParaDest-175"><a id="_idTextAnchor186"/>Appeal to the Person</h3>
			<p>More commonly known by its Latin name, argumentum ad hominem, this fallacy takes the following form:</p>
			<p><em class="italics">P says X. P is [an idiot, a communist, a fascist, smelly, or some other undesirable property]. Therefore, not X.</em></p>
			<p>Leaving aside interpersonal arguments, it's common to see ad hominem arguments deployed in software architecture justifications. "We're not using that, because it's from [Google, Apple, Microsoft, Apache, and so on]" is the tech-industry version.</p>
			<p>Is there any substance underlying this position? "We're not using that, because it's from Apple and Apple don't offer the support terms we need" could be a good argument. "We're not using that, because it's from Apple and I don't like them" might not be.</p>
			<h2 id="_idParaDest-176"><a id="_idTextAnchor187"/>Further Reading on Arguments</h2>
			<p>This has been a brief overview of the critical analysis of arguments, telling you first why I think it's important, then giving a little information about what's involved. Many more eloquent writers than I have bent themselves to this task, so there are good resources to recommend for exploring this topic further.</p>
			<p><strong class="bold">Rational Wiki</strong>—<a href="http://rationalwiki.org/wiki/Main_Page">http://rationalwiki.org/wiki/Main_Page</a> is mainly a website for debunking pseudoscience, crank claims, and biased presentation of the news. It has a comprehensive section on logic, argument, and fallacies. <strong class="bold">Less Wrong</strong>—<a href="http://lesswrong.com">http://lesswrong.com</a> has a similar scope, and finally, the Skeptics Stack Exchange—<a href="http://skeptics.stackexchange.com">http://skeptics.stackexchange.com</a> Q&amp;A site features community-scored arguments in support or refutation of a wide variety of positions on different topics. (Refutation means constructing an argument against a presented point of view; <em class="italics">repudiation</em> means to deny the truth of an opposing argument without justification. However, both words are commonly used to mean repudiation, and depending on the historical meanings of words this is itself <em class="italics">a form of equivocation</em>—<a href="http://en.wikipedia.org/wiki/Etymological_fallacy">http://en.wikipedia.org/wiki/Etymological_fallacy</a>.)</p>
			<h2 id="_idParaDest-177"><a id="_idTextAnchor188"/>Debates and Programmers</h2>
			<p>Having just concluded the previous section with a footnote on the dangers of the etymological fallacy, it's time for another "there's a specific meaning to this word" section. While debating is commonly taken to mean two or more people expressing different views on the same topic, debates usually have rules dictating the forms in which arguments are presented and either a way of choosing a "winner" or of reaching a consensus view on the topic.</p>
			<p>A specific example of a debating system with rules (which also has the benefit that I'm familiar with it) is the Oxford-style debate. The debate's topic is defined by a motion, in the form "this house moves to [X]." The audience votes on whether they are for or against the motion (or they can abstain). Two speakers, or teams of speakers, then present arguments, one in favor of and one in opposition of the motion. Unlike essay-style arguments, rhetoric and appeal to emotion are important parts of the presentations.</p>
			<p>After the two presentations, a moderator directs a question-and-answer session with questions asked by the audience. After this, speakers give short closing presentations, then the audience votes again. The debate is "won" by the side that swings the vote in its favor (so, if 5% of the audience opposed the motion before the debate and 7% opposed it afterward, the opposition could win despite the majority either abstaining or being for the motion).</p>
			<p>The skills practiced in a competitive debate are of course mainly the construction of persuasive arguments, with the interesting twist that you could be required to debate the position you don't agree with. That's not easy, but it does lead to a deep exploration of the topic and questioning the reasons that you disagree with the assigned position.</p>
			<p>As explored in <strong class="bold">The Leprechauns of Software Engineering</strong>—<a href="https://leanpub.com/leprechauns">https://leanpub.com/leprechauns</a>, a lot of programming practice is based on folk knowledge (or common sense) that turns out to have a shaky evidential basis. Now, we know from research in human-computer interaction that a <strong class="bold">satisficient</strong>—<a href="http://www.interaction-design.org/encyclopedia/satisficing.html">http://www.interaction-design.org/encyclopedia/satisficing.html</a> solution—one that isn't optimal but is "good enough" to get by—allows us to get our work done. Isn't it worth questioning these satisficing approaches to building software, and trying to find optimal approaches instead?</p>
			<p>Debates would be good vehicles for such questioning, because of the equal weight given to supporting and countering a motion. Someone would be responsible for identifying problems or weaknesses in the folk knowledge and presenting a compelling argument to knock it down. As a <em class="italics">gedankenexperiment</em>, could you construct an argument opposing the motion "this house moves to make <strong class="bold">version control mandatory</strong>—<a href="http://www.neverworkintheory.org/?p=457">http://www.neverworkintheory.org/?p=457</a> on all software projects"?</p>
			<h2 id="_idParaDest-178"><a id="_idTextAnchor189"/>Software as Essays</h2>
			<p>Remember, in <em class="italics">Chapter 8, Documentation</em>, that I said code only tells you <em class="italics">what</em> the software is doing; it's hard to use it to interpret <em class="italics">how</em> it's doing it and impossible to discover <em class="italics">why</em> without some supporting material. You also have to think about <em class="italics">who</em> is doing the interpreting; understanding the written word, executable, or otherwise, is a subjective process that depends on the skills and experiences of the reader.</p>
			<p>You could imagine an interpretation in the form of an appeal to satisfaction: who was the author writing for, and how does the work achieve the aim of satisfying those people? What themes was the author exploring, and how does the work achieve the goal of conveying those themes? These questions were, until the modern rise of literary theory, keyways in which literary criticism analyzed texts.</p>
			<p>Let's take these ideas and apply them to programming. We find that we ask of our programmers not "can you please write readable code?" but "can you consider what the themes and audience of this code are, and write in a way that promotes the themes among members of that audience?" The themes are the problems you're trying to solve, and the constraints on solving them. The audience is, well, it's the audience; it's the collection of people who will subsequently have to read and understand the code. This group can be considered to be somewhat exclusive; just as there's no point writing code for features you don't need, there's no point writing it for an audience who won't read it.</p>
			<p>We also find that we can no longer ask the objective-sounding question "did this coder write good code?" Nor can we ask, "is this code readable?" Instead, we ask "how does this code convey its themes to its audience?" The mark of readable code is not merely how the code is structured; it's how the code is interpreted by the reader. It's whether the code convinces the reader of the author's implicit argument, "this is what the code should do."<a id="_idTextAnchor190"/></p>
			<p>In conclusion, then, a sound approach to writing readable code requires authors and readers to meet in the middle. Authors must decide who will read the code, and how to convey the important information to those readers. Readers must analyze the code in terms of how it satisfies this goal of conveyance, not whether they enjoyed the indentation strategy or dislike dots in principle.</p>
			<p>Source code is not software written in a human-readable notation. It's an essay, written in executable notation. The argument is that the code as presented is the solution to its problem. But the code must both <em class="italics">solve</em> this problem and <em class="italics">justify</em> the solution with coherent and rational explanations.</p>
		</div>
	</body></html>