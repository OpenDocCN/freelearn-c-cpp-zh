<html><head></head><body>
		<div><h1 id="_idParaDest-30"><em class="italic"><a id="_idTextAnchor029"/>Chapter 2</em>: Exploring LLVM's Build System Features</h1>
			<p>In the previous chapter, we saw that LLVM's build system is a behemoth: it contains hundreds of build files with thousands of interleaving build dependencies. Not to mention, it contains targets that require custom build instructions for heterogeneous source files. These complexities drove LLVM to adopt some advanced build system features and, more importantly, a more structural build system design. In this chapter, our goal will be to learn about some important directives for the sake of writing more concise and expressive build files when doing both in-tree and out-of-tree LLVM developments.</p>
			<p>In this chapter, we will cover the following main topics:</p>
			<ul>
				<li>Exploring a glossary of LLVM's important CMake directives</li>
				<li>Integrating LLVM via CMake in out-of-tree projects</li>
			</ul>
			<h1 id="_idParaDest-31"><a id="_idTextAnchor030"/>Technical requirements</h1>
			<p>Similar to <a href="B14590_01_Final_JC_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Saving Resources When Building LLVM</em>, you might want to have a copy of LLVM built from its source. Optionally, since this chapter will touch on quite a lot of CMake build files, you may wish to prepare a syntax highlighting plugin for <code>CMakeLists.txt</code> (for example, VSCode's <em class="italic">CMake Tools</em> plugin). All major IDEs and editors should have it off-the-shelf. Also, familiarity with basic <code>CMakeLists.txt</code> syntax is preferable.</p>
			<p>All the code examples in this chapter can be found in this book's GitHub repository: <a href="https://github.com/PacktPublishing/LLVM-Techniques-Tips-and-Best-Practices/tree/main/Chapter02">https://github.com/PacktPublishing/LLVM-Techniques-Tips-and-Best-Practices/tree/main/Chapter02</a>.</p>
			<h1 id="_idParaDest-32"><a id="_idTextAnchor031"/>Exploring a glossary of LLVM's important CMake directives</h1>
			<p>LLVM has switched to <strong class="bold">CMake</strong> from <strong class="bold">GNU autoconf</strong> due to higher flexibility in terms of choosing underlying build systems. Ever since, LLVM has come up with many custom CMake functions, macros, and rules to optimize its own usage. This section will give you an overview of the most important and frequently used ones among them. We will learn how and when to use them.</p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor032"/>Using the CMake function to add new libraries</h2>
			<p>Libraries are<a id="_idIndexMarker040"/> the building blocks of the LLVM framework. However, when writing <code>CMakeLists.txt</code> for a new library, you shouldn't use the normal <code>add_library</code> directive that appears in normal <code>CMakeLists.txt</code> files, as follows:</p>
			<pre># In an in-tree CMakeLists.txt file…
add_library(MyLLVMPass SHARED
  MyPass.cpp) # Do NOT do this to add a new LLVM library</pre>
			<p>There are several drawbacks of using the vanilla <code>add_library</code> here, as follows:</p>
			<ul>
				<li>As shown in <a href="B14590_01_Final_JC_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Saving Resources When Building LLVM,</em> LLVM prefers to use a global CMake argument (that is, <code>BUILD_SHARED_LIBS</code>) to control whether all its component libraries should be built statically or dynamically. It's pretty hard to do that using the built-in directives. </li>
				<li>Similar to the<a id="_idIndexMarker041"/> previous point, LLVM prefers to use <a id="_idIndexMarker042"/>a global CMake arguments to control some compile flags, such as whether or not to enable <strong class="bold">Runtime Type Information</strong> (<strong class="bold">RTTI</strong>) and <strong class="bold">C++ exception handling</strong> in the code base.</li>
				<li>By using custom CMake functions/macros, LLVM can create its own component system, which provides a higher level of abstraction for developers to designate build target dependencies in an easier way.</li>
			</ul>
			<p>Therefore, you should always use the <code>add_llvm_component_library</code> CMake function shown here:</p>
			<pre># In a CMakeLists.txt
add_llvm_component_library(LLVMFancyOpt
  FancyOpt.cpp)</pre>
			<p>Here, <code>LLVMFancyOpt</code> is the final library name and <code>FancyOpt.cpp</code> is the source file. </p>
			<p>In regular CMake scripts, you can use <code>target_link_libraries</code> to designate a given target's library dependencies, and then use <code>add_dependencies</code> to assign dependencies among different build targets to create explicit build orderings. There is an easier way to do those tasks when you're using LLVM's custom CMake functions to create library targets.</p>
			<p>By using the <code>LINK_COMPONENTS</code> argument in <code>add_llvm_component_library</code> (or <code>add_llvm_library</code>, which is the underlying implementation of the former one), you can designate<a id="_idIndexMarker043"/> the target's linked components:</p>
			<pre>add_llvm_component_library(LLVMFancyOpt
  FancyOpt.cpp
  LINK_COMPONENTS
  Analysis ScalarOpts)</pre>
			<p>Alternatively, you can do the same thing with the <code>LLVM_LINK_COMPONENTS</code> variable, which is defined before the function call:</p>
			<pre>set(LLVM_LINK_COMPONENTS
    Analysis ScalarOpts)
add_llvm_component_library(LLVMFancyOpt
   FancyOpt.cpp)</pre>
			<p>Component libraries are nothing but normal libraries with a special meaning when it comes to the <em class="italic">LLVM building blocks you can use</em>. They're also included in the gigantic <code>libLLVM</code> library if you choose to build it. The component names are slightly different from the real library names. If you need the mapping from component names to library names, you can use the following CMake function:</p>
			<pre>llvm_map_components_to_libnames(output_lib_names
  &lt;list of component names&gt;)</pre>
			<p>If you want to directly link against a <em class="italic">normal</em> library (the non-LLVM component one), you can use the <code>LINK_LIBS</code> argument:</p>
			<pre>add_llvm_component_library(LLVMFancyOpt
  FancyOpt.cpp
  LINK_LIBS
  ${BOOST_LIBRARY})</pre>
			<p>To assign general<a id="_idIndexMarker044"/> build target dependencies to a library target (equivalent to <code>add_dependencies</code>), you can use the <code>DEPENDS</code> argument:</p>
			<pre>add_llvm_component_library(LLVMFancyOpt
  FancyOpt.cpp
  DEPENDS
  intrinsics_gen)</pre>
			<p><code>intrinsics_gen</code> is a common target representing the procedure of generating header files containing LLVM intrinsics definitions.</p>
			<h3>Adding one build target per folder</h3>
			<p>Many LLVM<a id="_idIndexMarker045"/> custom CMake functions have a pitfall that involves source file detection. Let's say you have a directory structure like this:</p>
			<pre>/FancyOpt
  |___ FancyOpt.cpp
  |___ AggressiveFancyOpt.cpp
  |___ CMakeLists.txt</pre>
			<p>Here, you have two source files, <code>FancyOpt.cpp</code> and <code>AggressiveFancyOpt.cpp</code>. As their names suggest, <code>FancyOpt.cpp</code> is the basic version of this optimization, while <code>AggressiveFancyOpt.cpp</code> is an alternative, more aggressive version of the same functionality. Naturally, you will want to split them into separate libraries so that users can choose if they wish to include the more aggressive one in their normal workload. So, you might write a <code>CMakeLists.txt</code> file like this:</p>
			<pre># In /FancyOpt/CMakeLists.txt
add_llvm_component_library(LLVMFancyOpt
  FancyOpt.cpp)
add_llvm_component_library(LLVMAggressiveFancyOpt
  AggressiveFancyOpt.cpp)</pre>
			<p>Unfortunately, this would generate error messages telling you something to the effect of <code>Found unknown source AggressiveFancyOpt.cpp …</code> when processing the first <code>add_llvm_component_library</code> statement.</p>
			<p>LLVM's build system enforces a stricter rule to make sure that <em class="italic">all</em> C/C++ source files in the same folder<a id="_idIndexMarker046"/> are added to the same library, executable, or plugin. To fix this, it is necessary to split either file into a separate folder, like so:</p>
			<pre>/FancyOpt
  |___ FancyOpt.cpp
  |___ CMakeLists.txt
  |___ /AggressiveFancyOpt
       |___ AggressiveFancyOpt.cpp
       |___ CMakeLists.txt</pre>
			<p>In <code>/FancyOpt/CMakeLists.txt</code>, we have the following:</p>
			<pre>add_llvm_component_library(LLVMFancyOpt
  FancyOpt.cpp)
add_subdirectory(AggressiveFancyOpt)</pre>
			<p>Finally, in <code>/FancyOpt/AggressiveFancyOpt/CMakeLists.txt</code>, we have the following:</p>
			<pre>add_llvm_component_library(LLVMAggressiveFancyOpt
  AggressiveFancyOpt.cpp)</pre>
			<p>These are the essentials of adding build targets for (component) libraries using LLVM's custom CMake <a id="_idIndexMarker047"/>directives. In the next two sections, we will show you how to add executable and Pass plugin build targets using a different set of LLVM-specific CMake directives.</p>
			<h2 id="_idParaDest-34"><a id="_idTextAnchor033"/>Using the CMake function to add executables and tools</h2>
			<p>Similar<a id="_idIndexMarker048"/> to <code>add_llvm_component_library</code>, to add<a id="_idIndexMarker049"/> a new executable target, we can use <code>add_llvm_executable</code> or <code>add_llvm_tool</code>:</p>
			<pre>add_llvm_tool(myLittleTool
  MyLittleTool.cpp)</pre>
			<p>These two functions have the same syntax. However, only targets created by <code>add_llvm_tool</code> will be included in the installations. There is also a global CMake variable, <code>LLVM_BUILD_TOOLS</code>, that enables/disables those LLVM tool targets.</p>
			<p>Both functions can also use the <code>DEPENDS</code> argument to assign dependencies, similar to <code>add_llvm_library</code>, which we introduced earlier. However, you can only use the <code>LLVM_LINK_COMPONENTS</code> variable to designate components to link.</p>
			<h2 id="_idParaDest-35"><a id="_idTextAnchor034"/>Using the CMake function to add Pass plugins</h2>
			<p>While we will cover <a id="_idIndexMarker050"/>Pass plugin development<a id="_idIndexMarker051"/> later in this book, adding a build target for a Pass plugin couldn't be any easier than now (compared to earlier LLVM versions, which were still using <code>add_llvm_library</code> with some special arguments). We can simply use the following command: </p>
			<pre>add_llvm_pass_plugin(MyPass
   HelloWorldPass.cpp)</pre>
			<p>The <code>LINK_COMPONENTS</code>, <code>LINK_LIBS</code>, and <code>DEPENDS</code> arguments are also available here, with the same usages and functionalities as in <code>add_llvm_component_library</code>.</p>
			<p>These are some of the most common and important LLVM-specific CMake directives. Using these directives can not only make your CMake code more concise but also help synchronize it with LLVM's own build system, in case you want to do some in-tree development. In the next section, we will show you how to integrate LLVM into an out-of-tree CMake<a id="_idIndexMarker052"/> project, and leverage the knowledge <a id="_idIndexMarker053"/>we learned in this chapter.</p>
			<p class="callout-heading">In-tree versus out-of-tree development</p>
			<p class="callout">In this book, <em class="italic">in-tree</em> development means contributing code directly to the LLVM project, such as fixing LLVM bugs or adding new features to the existing LLVM libraries. <em class="italic">Out-of-tree</em> development, on the other hand, either represents creating extensions for LLVM (writing an LLVM pass, for example) or using LLVM libraries in some other projects (using LLVM's code generation libraries to implement your own programming language, for example).</p>
			<h1 id="_idParaDest-36"><a id="_idTextAnchor035"/>Understanding CMake integration for out-of-tree projects</h1>
			<p>Implementing <a id="_idIndexMarker054"/>your features in an in-tree project is good for prototyping, since most of the infrastructure is already there. However, there are many scenarios where pulling the entire LLVM source tree into your code base is not the best idea, compared to<a id="_idIndexMarker055"/> creating an <strong class="bold">out-of-tree project</strong> and linking it against the LLVM libraries. For example, you only want to create a small code refactoring tool using LLVM's features and open source it on GitHub, so telling developers on GitHub to download a multi-gigabyte LLVM source tree along with your little tool might not be a pleasant experience. </p>
			<p>There are at least two ways to configure out-of-tree projects to link against LLVM:</p>
			<ul>
				<li>Using the <code>llvm-config</code> tool</li>
				<li>Using LLVM's CMake modules</li>
			</ul>
			<p>Both approaches help you sort out all the details, including header files and library paths. However, the latter creates more concise and readable CMake scripts, which is preferable for projects that are already using CMake. This section will show the essential steps of using LLVM's CMake modules to integrate it into an out-of-tree CMake project.</p>
			<p>First, we need to prepare an out-of-tree (C/C++) CMake project. The core CMake functions/macros we discussed in the previous section will help us work our way through this. Let's look at our steps:</p>
			<ol>
				<li>We are<a id="_idIndexMarker056"/> assuming that you already have the following <code>CMakeLists.txt</code> skeleton for a project that needs to be linked against LLVM libraries:<pre>project(MagicCLITool)
set(SOURCE_FILES
    main.cpp)
add_executable(magic-cli
  ${SOURCE_FILES})</pre><p>Regardless of whether you're trying to create a project generating executable, just like the one we saw in the preceding code block, or other artifacts such as libraries or even LLVM Pass plugins, the biggest question now is how to get <code>include path</code>, as well as <code>library path</code>.</p></li>
				<li>To resolve <code>include path</code> and <code>library path</code>, LLVM provides the standard CMake package interface for you to use the <code>find_package</code> CMake directive to import various configurations, as follows:<pre>project(MagicCLITool)
<code>find_package</code> trick work, you need to supply the <code>LLVM_DIR</code> CMake variable while invoking the CMake command for this project:</p><pre><code>lib/cmake/llvm</code> subdirectory under <code>LLVM install path</code>.</p></li>
				<li>After resolving <a id="_idIndexMarker057"/>the include path and library, it's time to link the main executable against LLVM's libraries. LLVM's custom CMake functions (for example, <code>add_llvm_executable</code>) will be really useful here. But first, CMake needs to be able to <em class="italic">find</em> those functions. <p>The following snippet imports LLVM's CMake module (more specifically, the <code>AddLLVM</code> CMake module), which contains those LLVM-specific functions/macros that we introduced in the previous section:</p><pre>find_package(LLVM REQUIRED CONFIG)
…
<strong class="bold">list(APPEND CMAKE_MODULE_PATH ${LLVM_CMAKE_DIR})</strong>
<strong class="bold">include(AddLLVM)</strong></pre></li>
				<li>The following snippet adds the executable build target using the CMake function we learned about in the previous section:<pre>find_package(LLVM REQUIRED CONFIG)
…
include(AddLLVM)
<strong class="bold">set(LLVM_LINK_COMPONENTS</strong>
<strong class="bold">  Support</strong>
<strong class="bold">  Analysis)</strong>
<strong class="bold">add_llvm_executable(magic-cli</strong>
<strong class="bold">  main.cpp)</strong></pre></li>
				<li>Adding the library target makes no difference:<pre>find_package(LLVM REQUIRED CONFIG)
…
include(AddLLVM)
<strong class="bold">add_llvm_library(MyMagicLibrary</strong>
<strong class="bold">  lib.cpp</strong>
<strong class="bold">  LINK_COMPONENTS</strong>
<strong class="bold">  Support Analysis)</strong></pre></li>
				<li>Finally, add <a id="_idIndexMarker058"/>the LLVM Pass plugin:<pre>find_package(LLVM REQUIRED CONFIG)
…
include(AddLLVM)
<strong class="bold">add_llvm_pass_plugin(MyMagicPass</strong>
<strong class="bold">  ThePass.cpp)</strong></pre></li>
				<li>In practice, you also need to be careful of <strong class="bold">LLVM-specific definitions</strong> and the RTTI setting:<pre>find_package(LLVM REQUIRED CONFIG)
…
<strong class="bold">add_definitions(${LLVM_DEFINITIONS})</strong>
<strong class="bold">if(NOT ${LLVM_ENABLE_RTTI})</strong>
<strong class="bold">  # For non-MSVC compilers</strong>
<strong class="bold">  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fno-rtti")</strong>
<strong class="bold">endif()</strong>
add_llvm_xxx(source.cpp)</pre><p>This is especially true for the RTTI part because, by default, LLVM is not built with RTTI support, but normal C++ applications are. A compilation error will be thrown if there is an RTTI mismatch between your code and LLVM's libraries.</p></li>
			</ol>
			<p>Despite the convenience of developing inside LLVM's source tree, sometimes, enclosing the entire LLVM source in your project might not be feasible. So, instead, we must create an out-of-tree <a id="_idIndexMarker059"/>project and integrate LLVM as a library. This section showed you how to integrate LLVM into your CMake-based out-of-tree projects and make good use of the LLVM-specific CMake directives we learned about in the <em class="italic">Exploring a glossary of LLVM's important CMake directives</em> section. </p>
			<h1 id="_idParaDest-37"><a id="_idTextAnchor036"/>Summary</h1>
			<p>This chapter dug deeper into LLVM's CMake build system. We saw how to use LLVM's own CMake directives to write concise and effective build scripts, for both in-tree and out-of-tree development. Learning these CMake skills can make your LLVM development more efficient and provide you with more options to engage LLVM features with other existing code bases or custom logic. </p>
			<p>In the next chapter, we will introduce another important infrastructure in the LLVM project known as the LLVM LIT, which is an easy-to-use yet general framework for running various kinds of tests.</p>
		</div>
	</body></html>