<html><head></head><body>
<div><h1 class="chapterNumber">8</h1>
<h1 class="chapterTitle" id="_idParaDest-122">Building Generic and Reusable Code with Templates</h1>
<p class="normal">We have used class templates in previous examples in this book without explaining them in detail. You should by now have a basic understanding of templates in C++ and know how to use template container classes from the standard library to specialize containers with different underlying types. We have also covered the <code class="inlineCode">std::optional</code> and <code class="inlineCode">std::expected</code> template classes, which we can use to handle different return types from functions.</p>
<p class="normal">As you have already seen, templates are used heavily in the C++ standard library. They allow us to implement the same functionality for different types, making our code reusable and generic, which is one of the strengths of C++. Templates are an extremely complex topic; entire books have been written on templates and metaprogramming in C++. This chapter will help you understand templates in C++ in more detail.</p>
<p class="normal">In this chapter, we’re going to cover the following main topics: </p>
<ul>
<li class="bulletList">Template basics</li>
<li class="bulletList">Metaprogramming</li>
<li class="bulletList">Concepts</li>
<li class="bulletList">Compile-time polymorphism</li>
</ul>
<h1 class="heading-1" id="_idParaDest-123">Technical requirements</h1>
<p class="normal">To get the most out of this chapter, I strongly recommend using Compiler Explorer (<a href="https://godbolt.org/">https://godbolt.org/</a>) as you read through the examples. Select GCC as your compiler for x86 architecture. This will allow you to see standard output and better observe the code’s behavior. As we are using modern C++, make sure to select C++23 standard, by adding <code class="inlineCode">-std=c++23</code> in the compiler options box.</p>
<p class="normal">Compiler Explorer makes it easy to try the code, tweak it, and immediately see how it affects the output and generated assembly code. The examples from this chapter are available on GitHub (<a href="https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter08">https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter08</a>).</p>
<h1 class="heading-1" id="_idParaDest-124">Template basics</h1>
<p class="normal">One definition of the word “template” is “a gauge, pattern, or mold (such as a thin plate or board) used as a guide to the form of a piece<a id="_idIndexMarker403"/> being made. “ This definition can be applied to templates in C++.</p>
<p class="normal">In C++, templates serve as patterns or molds for functions and classes, allowing the creation of actual functions and classes. From this perspective, templates are not real functions or types themselves; rather, they act as guides for generating concrete functions and types. To better understand this definition, let us take a look at the following code sample:</p>
<pre class="programlisting code"><code class="hljs-code">#include &lt;cstdio&gt;
template&lt;typename T&gt;
T add(T a, T b) {
   return a + b;
}
int main() {
    int result_int = add(1, 4);
    float result_float = add(1.11f, 1.91f);
    printf("result_int = %d\r\n", result_int);
    printf("result_float = %.2f\r\n", result_float);
    return 0;
}
</code></pre>
<p class="normal">In this example, we have a template function, <code class="inlineCode">add</code>, with the template type parameter <code class="inlineCode">T</code>. In the <code class="inlineCode">main</code> function, we see two calls to<a id="_idIndexMarker404"/> the <code class="inlineCode">add</code> function:</p>
<ul>
<li class="bulletList">The first one has integers as arguments and a return value stored in <code class="inlineCode">result_int</code></li>
<li class="bulletList">The second one has float arguments and a return value stored in the <code class="inlineCode">result_float</code> float variable</li>
</ul>
<p class="normal">Now, we previously said that template types and functions are not actual types and functions, so how can we make a call to the template function if it’s not a real function?</p>
<h2 class="heading-2" id="_idParaDest-125">Making a call to the template function</h2>
<p class="normal">In this example, when the compiler sees a call to add a template function, it deduces the template argument and replaces the <a id="_idIndexMarker405"/>template parameter, in this case, type <code class="inlineCode">T</code>, with type <code class="inlineCode">int</code> in the first call and <code class="inlineCode">float</code> in the second call to <code class="inlineCode">add</code>. After argument deduction, the template is instantiated; that is, the compiler creates two instances of the <code class="inlineCode">add</code> function: one with integers as arguments and one with floats. We can see this in the assembly output of the preceding example shown here:</p>
<pre class="programlisting code"><code class="hljs-code">_Z3addIiET_S0_S0_:
        push    rbp
        mov     rbp, rsp
        mov     DWORD PTR [rbp-4], edi
        mov     DWORD PTR [rbp-8], esi
        mov     edx, DWORD PTR [rbp-4]
        mov     eax, DWORD PTR [rbp-8]
        add     eax, edx
        pop     rbp
        ret
_Z3addIfET_S0_S0_:
        push    rbp
        mov     rbp, rsp
        movss   DWORD PTR s[rbp-4], xmm0
        movss   DWORD PTR [rbp-8], xmm1
        movss   xmm0, DWORD PTR [rbp-4]
        addss   xmm0, DWORD PTR [rbp-8]
        pop     rbp
        ret
</code></pre>
<p class="normal">In the preceding assembly output, we see there are two instances of the <code class="inlineCode">add</code> function: <code class="inlineCode">_Z3addIiET_S0_S0_</code>, accepting integers, and <code class="inlineCode">_Z3addIfET_S0_S0_</code>, accepting floats. The compiler instantiated these two functions from the <code class="inlineCode">add</code> template function, after it deduced template arguments on the call <a id="_idIndexMarker406"/>site of this function. This is the basic working principle of templates in C++.</p>
<p class="normal">In the example of the <code class="inlineCode">add</code> template function, the compiler will instantiate a new function for every type for which there is a defined <code class="inlineCode">operator+</code>. So, what would happen if we tried to call the <code class="inlineCode">add</code> template function on a type for which there is no defined <code class="inlineCode">operator+</code>? Let’s take a look at the following example:</p>
<pre class="programlisting code"><code class="hljs-code">struct point {
    int x;
    int y;
};
int main() {
    point a{1, 2};
    point b{2, 1};
    auto c = add(a, b);
    return 0;
}
</code></pre>
<p class="normal">In the preceding example, we defined a <code class="inlineCode">point</code> struct, for which there is no defined <code class="inlineCode">operator+</code>, and we made a call to the <code class="inlineCode">add</code> template function. This will result in a compiler error similar to the one shown here:</p>
<pre class="programlisting con"><code class="hljs-con">&lt;source&gt;: In instantiation of 'T add(T, T) [with T = point]':
&lt;source&gt;:25:17:   required from here
   25 |     auto c = add(a, b);
      |              ~~~^~~~~~
&lt;source&gt;:6:13: error: no match for 'operator+' (operand types are 'point' and 'point')
    6 |    return a + b;
      |           ~~^~~
</code></pre>
<p class="normal">So, what happened? When the compiler tried to instantiate a function using the <code class="inlineCode">add</code> template with <code class="inlineCode">point</code> as type <code class="inlineCode">T</code>, the compilation<a id="_idIndexMarker407"/> failed due to <code class="inlineCode">no match for 'operator+' (operand types are 'point' and 'point')</code>. We can solve this by defining <code class="inlineCode">operator+</code> for the <code class="inlineCode">point</code> struct as follows:</p>
<pre class="programlisting code"><code class="hljs-code">struct point {
    int x;
    int y;
    point operator+(const point&amp; other) const {
        return point{x + other.x, y + other.y};
    }
    void print() {
        printf("x = %d, y = %d\r\n", x, y);
    }
};
</code></pre>
<p class="normal">In the preceding implementation, we defined <code class="inlineCode">operator+</code> for the <code class="inlineCode">point</code> struct, and we also defined the <code class="inlineCode">print</code> function, which will help us to print the point. After this change, we can compile the example successfully.</p>
<p class="normal">What if we wanted, for some reason, that <code class="inlineCode">add</code> function when used with type <code class="inlineCode">point</code> behaves differently than just applying the <code class="inlineCode">operator+</code>? Let’s say we want to increment both <code class="inlineCode">x</code> and <code class="inlineCode">y</code> by 1 after summation. We can use template<a id="_idIndexMarker408"/> specialization for this.</p>
<h2 class="heading-2" id="_idParaDest-126">Template specialization</h2>
<p class="normal"><strong class="keyWord">Template specialization</strong> allows us <a id="_idIndexMarker409"/>to provide the compiler with the implementation of a template function for a specific type, as in the following example of specializing the <code class="inlineCode">add</code> function for type <code class="inlineCode">point</code>:</p>
<pre class="programlisting code"><code class="hljs-code">template&lt;&gt;
point add&lt;point&gt;(point a, point b) {
   return point{a.x+b.x+1, a.y+b.y+1};
}
</code></pre>
<p class="normal">In this case, when the <code class="inlineCode">add</code> function is called with arguments of type <code class="inlineCode">point</code>, the compiler skips the generic template instantiation and uses this specialized version instead. This allows us to customize the behavior of the function specifically for point objects, adding an extra 1 to each coordinate when two point instances are added together. Let us take a look at the full <code class="inlineCode">main</code> function now:</p>
<pre class="programlisting code"><code class="hljs-code">int main() {
    point a{1, 2};
    point b{2, 1};
    auto c = add(a, b);
    c.print();
    static_assert(std::is_same_v&lt;decltype(c), point&gt;);
    return 0;
}
</code></pre>
<p class="normal">If we run the example with template specialization from the previous step, we will get the following output:</p>
<pre class="programlisting code"><code class="hljs-code">x = 4, y = 4
</code></pre>
<p class="normal">The compiler used function specialization for the <code class="inlineCode">point</code> type. Template specialization makes templates a flexible tool, allowing us to provide compilers with custom implementations when needed.</p>
<p class="normal">In the preceding example, we can see that for variable <code class="inlineCode">c</code>, we used <code class="inlineCode">auto</code> as a type specifier. The <code class="inlineCode">auto</code> keyword was introduced in C++11, and when used, the compiler deduces the actual type of a variable from the initialization <a id="_idIndexMarker410"/>expression. In order to confirm that the deduced type of variable <code class="inlineCode">c</code> is <code class="inlineCode">point</code>, we used <code class="inlineCode">static_assert</code>, which performs compile-time assertion checking.</p>
<p class="normal">As the argument of <code class="inlineCode">static_assert</code>, we use a type trait from the metaprogramming library, <code class="inlineCode">std::is_same_v</code>, which checks whether two types are identical and evaluates to <code class="inlineCode">true</code> if they are. We determine the type of <code class="inlineCode">c</code> using the <code class="inlineCode">decltype</code> specifier, which retrieves the type of an expression at compile time. This allows us to verify that the type deduced for <code class="inlineCode">c</code> is indeed <code class="inlineCode">point</code>. If this assertion fails, the compiler will generate an error.</p>
<h1 class="heading-1" id="_idParaDest-127">Template metaprogramming</h1>
<p class="normal"><strong class="keyWord">Template metaprogramming</strong> involves using templates to write code that generates different functions, types, and constants at compile time based on the types used in the template arguments. Template metaprogramming is an <a id="_idIndexMarker411"/>advanced technique heavily utilized in modern C++ libraries. It may be overwhelming, so it is perfectly fine if it appears to be hard to understand. Take this as merely an introduction and an exploration of this interesting topic.</p>
<p class="normal">Let us go back to the example of the <code class="inlineCode">add</code> template function. Is there something we can do if we want to enforce that this template function is used only for arithmetic types such as integers and floats?</p>
<p class="normal"><code class="inlineCode">&lt;type_traits&gt;</code> header from metaprogramming library provides us with the <code class="inlineCode">std::enable_if</code> template type, which accepts two parameters, a Boolean and a type. If a Boolean is true, the resulting type will have a public <code class="inlineCode">typedef</code> member, <code class="inlineCode">type</code>. Let’s take a look at the following example:</p>
<pre class="programlisting code"><code class="hljs-code">#include &lt;type_traits&gt;
template&lt;typename T&gt;
std::enable_if&lt;true, T&gt;::type
add(T a, T b) {
   return a + b;
}
</code></pre>
<p class="normal">In the preceding example, we used <code class="inlineCode">std::enable_if</code> in place of the return type of the <code class="inlineCode">add</code> template function. As we set the Boolean argument to <code class="inlineCode">true</code>, it will have a public <code class="inlineCode">typedef</code> type, <code class="inlineCode">T</code>, meaning that the return type of the <code class="inlineCode">add</code> function template will be <code class="inlineCode">T</code>.</p>
<p class="normal">We will expand this example using <a id="_idIndexMarker412"/>type trait class template <code class="inlineCode">std::is_arithmetic&lt;T&gt;</code>, which will have a public Boolean named <code class="inlineCode">value</code> set to <code class="inlineCode">true</code> if <code class="inlineCode">T</code> is an arithmetic type. The preceding example will result in the following code:</p>
<pre class="programlisting code"><code class="hljs-code">template&lt;typename T&gt;
std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value, T&gt;::type
add(T a, T b) {
   return a + b;
}
</code></pre>
<p class="normal">In the preceding example, instead of hardcoding <code class="inlineCode">true</code> as the condition for <code class="inlineCode">std::enable_if</code>, we use the <code class="inlineCode">std::is_arithmetic&lt;T&gt;::value</code>. Let’s take a look at the <code class="inlineCode">main</code> function using this template function and the <code class="inlineCode">point</code> type from the previous example:</p>
<pre class="programlisting code"><code class="hljs-code">int main() {
    auto a = add(1, 2); // OK
    auto b = add(1.1, 2.1); // OK
    point p_a{1, 2};
    point p_b{2, 1}; 
    auto p_c = add(p_a, p_b); // compile-error
    return 0;
}
</code></pre>
<p class="normal">If we try to compile this code, the compilation will fail with a lengthy error message containing the following:</p>
<pre class="programlisting con"><code class="hljs-con">&lt;source&gt;: In function 'int main()':
&lt;source&gt;:30:17: error: no matching function for call to 'add(point&amp;, point&amp;)'
  30 |     auto c = add(p_a, p_b); // compile-error
     |              ~~~^~~~~~~~~~
&lt;source&gt;:30:17: note: there is 1 candidate
&lt;source&gt;:19:1: note: candidate 1: 'template&lt;class T&gt; typename std::enable_if&lt;std::is_arithmetic&lt;_Tp&gt;::value, T&gt;::type add(T, T)'
  19 | add(T a, T b) {
     | ^~~
&lt;source&gt;:19:1: note: template argument deduction/substitution failed:
&lt;source&gt;: In substitution of 'template&lt;class T&gt; typename std::enable_if&lt;std::is_arithmetic&lt;_Tp&gt;::value, T&gt;::type add(T, T) [with T = point]':
&lt;source&gt;:30:17:   required from here
  30 |     auto c = add(p_a, p_b); // compile-error
     |              ~~~^~~~~~~~~~
&lt;source&gt;:19:1: error: no type named 'type' in 'struct std::enable_if&lt;false, point&gt;'
  19 | add(T a, T b) {
     | ^~~
</code></pre>
<p class="normal">The preceding compiler error looks intimidating, and it is hard to read. This is one of those things that templates are<a id="_idIndexMarker413"/> notorious for. Before we tackle this concern, let’s focus on analyzing what happened in this case.</p>
<p class="normal">Template argument deduction/substitution failed as <code class="inlineCode">std::is_arithmetic&lt;point&gt;::value</code> results in <code class="inlineCode">false</code>, meaning that the <code class="inlineCode">std::enable_if</code> template type will not have a public typedef <code class="inlineCode">type T</code>. Effectively, any attempt at the usage of the <code class="inlineCode">add</code> template function in this example with a type that’s not arithmetic will result in a compiler error, even if <code class="inlineCode">operator+</code> is defined for that type. We can think of <code class="inlineCode">std::enable_if</code> as an enabler or disabler of a template function in C++.</p>
<p class="normal">Let’s modify the <code class="inlineCode">add</code> template function so that it prints the result of the sum operation. As both integers and floats are arithmetic types, we need to treat them differently. We could use <code class="inlineCode">std::enable_if</code> and create two template functions using the <code class="inlineCode">std::is_integral</code> and <code class="inlineCode">std::is_floating_point</code> type traits as in the following example:</p>
<pre class="programlisting code"><code class="hljs-code">template&lt;typename T&gt;
std::enable_if&lt;std::is_integral&lt;T&gt;::value, T&gt;::type
add(T a, T b) {
    T result = a + b;
    printf("%d + %d = %d\r\n", a, b, result);
    return result;
}
template&lt;typename T&gt;
std::enable_if&lt;std::is_floating_point&lt;T&gt;::value, T&gt;::type
add(T a, T b) {
    T result = a + b;
    printf("%.2f + %.2f = %.2f\r\n", a, b, result);
    return result;
}
</code></pre>
<p class="normal">As you remember, <code class="inlineCode">std::enable_if</code> is a template enabler or disabler, meaning it will enable the first template function for integer types and print them using <code class="inlineCode">printf</code> and the <code class="inlineCode">%d</code> format specifier. Template substitution will fail for the second template function with integer types, but this will not be treated as <a id="_idIndexMarker414"/>an error as there is a valid function candidate for integer arguments from the first template. This principle is called <strong class="keyWord">Subsitution Failure Is Not An Error</strong> (<strong class="keyWord">SFINAE</strong>). For the<a id="_idIndexMarker415"/> floating-point types, the first template function will be disabled, but the second one will be enabled.</p>
<p class="normal">Now, the example functions we used are very simple, but let’s for a moment pretend that the <code class="inlineCode">add</code> function template is doing a heavy-lifting task and that between integer and floating-point versions, the only difference is how we print the result. So, if we used two different function templates, we would copy a lot of the same code. We can avoid this by using <code class="inlineCode">constexpr if</code>, which will enable or disable certain paths in code at compile time. Let us take a look at a modified example:</p>
<pre class="programlisting code"><code class="hljs-code">std::enable_if_t&lt;std::is_arithmetic_v&lt;T&gt;, T&gt;
add(T a, T b) {
    T result = a + b;
    if constexpr (std::is_integral_v&lt;T&gt;) {
        printf("%d + %d = %d\r\n", a, b, result);
    } else if constexpr (std::is_floating_point_v&lt;T&gt;) {
        printf("%.2f + %.2f = %.2f\r\n", a, b, result);
    }
    return a + b;
}
</code></pre>
<p class="normal">In the preceding example, we used the <code class="inlineCode">constexpr if</code> statement to enable certain paths of the program based on the compile-time evaluation of the <code class="inlineCode">std::is_integral_v&lt;T&gt;</code> and <code class="inlineCode">std::is_floating_point_v&lt;T&gt;</code> expressions. <code class="inlineCode">constexpr if</code> was introduced in C++17. You can also notice that we used <a id="_idIndexMarker416"/>aliases for type traits as <code class="inlineCode">std::enable_if_t&lt;T&gt;</code>, which is equivalent to <code class="inlineCode">std::enable_if&lt;T&gt;::type</code>, and <code class="inlineCode">std::is_floating_point_v&lt;T&gt;</code>, which is equivalent to <code class="inlineCode">std::is_floating_point&lt;T&gt;::value</code>.</p>
<p class="normal">In this example, we used type traits and <code class="inlineCode">std::enable_if</code> to enable the <code class="inlineCode">add</code> function template only for arithmetic types. C++20 introduced concepts, which we can use to put restraints on template types.</p>
<h1 class="heading-1" id="_idParaDest-128">Concepts</h1>
<p class="normal"><strong class="keyWord">Concepts</strong> are named sets of template parameter requirements. They are evaluated at compile time and are used during overload<a id="_idIndexMarker417"/> resolution to select the most appropriate function overload; that is, they are used to determine which function template will be instantiated and compiled.</p>
<p class="normal">We will create a concept for arithmetic types and use it in our <code class="inlineCode">add</code> template function, as follows:</p>
<pre class="programlisting code"><code class="hljs-code">template&lt;typename T&gt;
concept Arithmetic = std::is_arithmetic_v&lt;T&gt;;
template&lt;Arithmetic T&gt;
T add(T a, T b) {
    T result = a + b;
    if constexpr (std::is_integral_v&lt;T&gt;) {
        printf("%d + %d = %d\r\n", a, b, result);
    } else if constexpr (std::is_floating_point_v&lt;T&gt;) {
        printf("%.2f + %.2f = %.2f\r\n", a, b, result);
    }
    return a + b;
}
</code></pre>
<p class="normal">In the preceding code, we created the <code class="inlineCode">Arithmetic</code> concept and used it in the <code class="inlineCode">add</code> function template to put requirements on the <code class="inlineCode">T</code> template type. The <code class="inlineCode">add</code> template function is now easier to read. It is visible from the template declaration that type <code class="inlineCode">T</code> must meet the requirements of the <code class="inlineCode">Arithmetic</code> concept, which makes the code easier to read and comprehend.</p>
<p class="normal">Concepts not only make the<a id="_idIndexMarker418"/> code easier to read but also improve readability of compiler errors. If we tried to call the function template <code class="inlineCode">add</code> on type <code class="inlineCode">point</code>, we would now get an error similar to the following one:</p>
<pre class="programlisting con"><code class="hljs-con">&lt;source&gt;: In function 'int main()':
&lt;source&gt;:41:17: error: no matching function for call to 'add(point&amp;, point&amp;)'
  41 |     auto c = add(p_a, p_b); // compile-error
     |              ~~~^~~~~~~~~~
&lt;source&gt;:41:17: note: there is 1 candidate
&lt;source&gt;:22:3: note: candidate 1: 'template&lt;class T&gt;  requires  Arithmetic&lt;T&gt; T add(T, T)'
  22 | T add(T a, T b) {
     |   ^~~
&lt;source&gt;:22:3: note: template argument deduction/substitution failed:
&lt;source&gt;:22:3: note: constraints not satisfied
&lt;source&gt;: In substitution of 'template&lt;class T&gt;  requires  Arithmetic&lt;T&gt; T add(T, T) [with T = point]':
&lt;source&gt;:41:17:   required from here
  41 |     auto c = add(p_a, p_b); // compile-error
     |              ~~~^~~~~~~~~~
&lt;source&gt;:18:9:   required for the satisfaction of 'Arithmetic&lt;T&gt;' [with T = point]
&lt;source&gt;:18:27: note: the expression 'is_arithmetic_v&lt;T&gt; [with T = point]' evaluated to 'false'
  18 | concept Arithmetic = std::is_arithmetic_v&lt;T&gt;;
     |                      ~~~~~^~~~~~~~~~~~~~~~~~
</code></pre>
<p class="normal">The preceding compiler error is way easier to read and understand what happened than the one we had previously when we didn’t use concepts. We can easily trace the origin of the error to the fact that constraints<a id="_idIndexMarker419"/> imposed by the <code class="inlineCode">Arithmetic</code> concept are not satisfied for the <code class="inlineCode">point</code> type.</p>
<p class="normal">Next, we will move on to discuss compile-time polymorphism and see how we can utilize concepts to help us enforce strong interfaces.</p>
<h1 class="heading-1" id="_idParaDest-129">Compile-time polymorphism</h1>
<p class="normal">In <a href="Chapter_05.xhtml"><em class="italic">Chapter 5</em></a>, we discussed dynamic, or runtime, polymorphism. We used it to define an interface for <code class="inlineCode">uart</code>, which was implemented by the <code class="inlineCode">uart_stm32</code> class. The <code class="inlineCode">gsm_lib</code> class has a dependency on the <code class="inlineCode">uart</code> interface only, not on<a id="_idIndexMarker420"/> the concrete implementation, which is <a id="_idIndexMarker421"/>contained in <code class="inlineCode">uart_stm32</code>. This is called <strong class="keyWord">loose coupling</strong> and allows us to have portable code for the <code class="inlineCode">gsm_lib</code> class.</p>
<p class="normal">We can easily supply <code class="inlineCode">gsm_lib</code> with another <code class="inlineCode">uart</code> interface implementation on a different hardware platform. This principle is <a id="_idIndexMarker422"/>called <strong class="keyWord">dependency inversion</strong>. It says that high-level modules (classes) shouldn’t depend on low-level modules and that both should depend on abstractions (interfaces). We can implement this principle by using inheritance and virtual functions in C++.</p>
<p class="normal">Virtual functions result in indirection, causing the runtime overhead and increased binary size needed for their implementation. They allow runtime dispatching of function calls, but they come with a price. In embedded applications, we usually know all our types, meaning that we can use templates and overload<a id="_idIndexMarker423"/> resolution for the static or compile-time dispatch of function calls.</p>
<h3 class="heading-3" id="_idParaDest-130">Using Class Templates for Compile-Time Polymorphism</h3>
<p class="normal">We can make <code class="inlineCode">gsm_lib</code> a class template <a id="_idIndexMarker424"/>that has one parameter that we will use for the <code class="inlineCode">uart</code> type, as shown in the following example:</p>
<pre class="programlisting code"><code class="hljs-code">#include &lt;span&gt;
#include &lt;cstdio&gt;
#include &lt;cstdint&gt;
class uart_stm32 {
public:
    void init(std::uint32_t baudrate = 9600) {
        printf("uart_stm32::init: setting baudrate to %d\r\n", baudrate);
    }
    void write(std::span&lt;const char&gt; data) {
        printf("uart_stm32::write: ");
        for(auto ch: data) {
            putc(ch, stdout);
        }
    }
};
template&lt;typename T&gt;
class gsm_lib{
public:
    gsm_lib(T &amp;u) : uart_(u) {}
    void init() {
        printf("gsm_lib::init: sending AT command\r\n");
        uart_.write("AT");
    }
private:
    T &amp;uart_;
};
int main() {
    uart_stm32 uart_stm32_obj;
    uart_stm32_obj.init(115200);
    gsm_lib gsm(uart_stm32_obj);
    gsm.init();
    return 0;
}
</code></pre>
<p class="normal">In the preceding example, the compiler will instantiate the <code class="inlineCode">gsm_lib</code> template class using the <code class="inlineCode">uart_stm32</code> class as a template argument. This <a id="_idIndexMarker425"/>will result in using a reference to an object of the <code class="inlineCode">uart_stm32</code> class in the <code class="inlineCode">gsm_lib</code> code. We can still easily reuse <code class="inlineCode">gsm_lib</code> by using it with a different type that provides all the methods needed to compile it. In this example, the type that used with the <code class="inlineCode">gsm_lib</code> class template must provide a <code class="inlineCode">write</code> method accepting <code class="inlineCode">std::span&lt;char&gt; </code>as its parameter. But this also means that any type that has such a method will allow us to compile the code.</p>
<p class="normal">Dynamic polymorphism requires interface classes implemented in concrete classes and used in high-level code. It makes intended behavior of the code clear when reading it. Can we do something similar using templates? It turns out we can. We can use the <strong class="keyWord">curiously recurring template pattern</strong> (<strong class="keyWord">CRTP</strong>) to implement compile-time subtype polymorphism.</p>
<h2 class="heading-2" id="_idParaDest-131">Curiously recurring template pattern (CRTP)</h2>
<p class="normal">CRTP is a C++ idiom where the derived <a id="_idIndexMarker426"/>class uses a template<a id="_idIndexMarker427"/> class instantiated with itself as a base class. Yes, it sounds confusing, so let’s jump into the code to better understand this:</p>
<pre class="programlisting code"><code class="hljs-code">template&lt;typename U&gt;
class uart_interface {
public:
    void init(std::uint32_t baudrate = 9600) {
       static_cast&lt;U*&gt;(this)-&gt;initImpl(baudrate);
    }
};
class uart_stm32 : public uart_interface&lt;uart_stm32&gt; {
public:
    void initImpl(std::uint32_t baudrate = 9600) {
        printf("uart_stm32::init: setting baudrate to %d\r\n", baudrate);
    }
};
</code></pre>
<p class="normal">The preceding code implements CRTP. The <code class="inlineCode">uart_stm32</code> derived class inherits from the <code class="inlineCode">uart_interface</code> class template instantiated <a id="_idIndexMarker428"/>with the <code class="inlineCode">uart_stm32</code> class itself. The base class template exposes an interface<a id="_idIndexMarker429"/> from which it can access the derived class using <code class="inlineCode">static_cast</code> on <code class="inlineCode">this</code> (pointer to itself). It provides the <code class="inlineCode">init</code> method, which calls <code class="inlineCode">initImpl</code> on the object of the <code class="inlineCode">uart_stm32</code> class.</p>
<p class="normal">CRTP allows us to define our interface in the base class and implement it in a derived class, similar to the inheritance mechanism we are using for runtime polymorphism. The remaining part to ensure that this interface is used in <code class="inlineCode">gsm_lib</code> is to create type constraints using concepts, as follows:</p>
<pre class="programlisting code"><code class="hljs-code">template&lt;typename T&gt;
concept TheUart = std::derived_from&lt;T, uart_interface&lt;T&gt;&gt;;
</code></pre>
<p class="normal">The preceding code is a concept that we will use to restrain types accepted by the <code class="inlineCode">gsm_lib</code> class template. It will accept only types that are derived from the <code class="inlineCode">uart_interface</code> class template instantiated by that type itself. The following is the full code example:</p>
<pre class="programlisting code"><code class="hljs-code">#include &lt;span&gt;
#include &lt;cstdio&gt;
#include &lt;cstdint&gt;
template&lt;typename U&gt;
class uart_interface {
public:
    void init(std::uint32_t baudrate = 9600) {
       static_cast&lt;U*&gt;(this)-&gt;initImpl(baudrate);
    }
    void write(std::span&lt;const char&gt; data) {
       static_cast&lt;U*&gt;(this)-&gt;writeImpl(data);
    }
};
class uart_stm32 : public uart_interface&lt;uart_stm32&gt; {
public:
    void initImpl(std::uint32_t baudrate = 9600) {
        printf("uart_stm32::init: setting baudrate to %d\r\n", baudrate);
    }
    void writeImpl(std::span&lt;const char&gt; data) {
        printf("uart_stm32::write: ");
        for(auto ch: data) {
            putc(ch, stdout);
        }
    }
};
template&lt;typename T&gt;
concept TheUart = std::derived_from&lt;T, uart_interface&lt;T&gt;&gt;;
template&lt;TheUart T&gt;
class gsm_lib{
public:
    gsm_lib(T &amp;u) : uart_(u) {}
    void init() {
        printf("gsm_lib::init: sending AT command\r\n");
        uart_.write("AT");
    }
private:
    T &amp;uart_;
};
int main() {
    uart_stm32 uart_stm32_obj;
    uart_stm32_obj.init(115200);
    gsm_lib gsm(uart_stm32_obj);
    gsm.init();
    return 0;
}
</code></pre>
<p class="normal">In the preceding code, we used CRTP to implement compile-time or static subtype polymorphism. <code class="inlineCode">uart_stm32</code> is a concrete class that depends on the interface defined by the <code class="inlineCode">uart_interface</code> class template. We used<a id="_idIndexMarker430"/> the <code class="inlineCode">TheUart</code> concept to constrain high-level code in <code class="inlineCode">gsm_lib</code> on types derived<a id="_idIndexMarker431"/> from <code class="inlineCode">uart_interface</code>. We achieved dependency inversion, and it is clearly defined thanks to CRTP and concepts.</p>
<p class="normal">The major benefit of compile-time polymorphism over inheritance (runtime polymorphism) is static binding; that is, there are no virtual functions. This comes at the price of template syntax, which may make the code harder to read and understand.</p>
<h1 class="heading-1" id="_idParaDest-132">Summary</h1>
<p class="normal">In this chapter, we covered template basics, template metaprogramming, concepts, and compile-time polymorphism. While templates are an advanced topic that encompasses many deeper concepts, this chapter aims to serve as a solid starting point for new learners. By understanding the fundamentals covered here, you should be well equipped to explore more complex aspects of templates and leverage their full potential in embedded systems programming.</p>
<p class="normal">In the next chapter, we will discuss type safety in C++.</p>
</div>
</body></html>