<html><head></head><body>
<div id="_idContainer054">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">8</span></h1>
<h1 class="chapterTitle" id="_idParaDest-122"><span class="koboSpan" id="kobo.2.1">Building Generic and Reusable Code with Templates</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">We have used class templates in previous examples in this book without explaining them in detail. </span><span class="koboSpan" id="kobo.3.2">You should by now have a basic understanding of templates in C++ and know how to use template container classes from the standard library to specialize containers with different underlying types. </span><span class="koboSpan" id="kobo.3.3">We have also covered the </span><code class="inlineCode"><span class="koboSpan" id="kobo.4.1">std::optional</span></code><span class="koboSpan" id="kobo.5.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.6.1">std::expected</span></code><span class="koboSpan" id="kobo.7.1"> template classes, which we can use to handle different return types from functions.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.8.1">As you have already seen, templates are used heavily in the C++ standard library. </span><span class="koboSpan" id="kobo.8.2">They allow us to implement the same functionality for different types, making our code reusable and generic, which is one of the strengths of C++. </span><span class="koboSpan" id="kobo.8.3">Templates are an extremely complex topic; entire books have been written on templates and metaprogramming in C++. </span><span class="koboSpan" id="kobo.8.4">This chapter will help you understand templates in C++ in more detail.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.9.1">In this chapter, we’re going to cover the following main topics: </span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.10.1">Template basics</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.11.1">Metaprogramming</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.12.1">Concepts</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.13.1">Compile-time polymorphism</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-123"><span class="koboSpan" id="kobo.14.1">Technical requirements</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.15.1">To get the most out of this chapter, I strongly recommend using Compiler Explorer (</span><a href="https://godbolt.org/"><span class="url"><span class="koboSpan" id="kobo.16.1">https://godbolt.org/</span></span></a><span class="koboSpan" id="kobo.17.1">) as you read through the examples. </span><span class="koboSpan" id="kobo.17.2">Select GCC as your compiler for x86 architecture. </span><span class="koboSpan" id="kobo.17.3">This will allow you to see standard output and better observe the code’s behavior. </span><span class="koboSpan" id="kobo.17.4">As we are using modern C++, make sure to select C++23 standard, by adding </span><code class="inlineCode"><span class="koboSpan" id="kobo.18.1">-std=c++23</span></code><span class="koboSpan" id="kobo.19.1"> in the compiler options box.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.20.1">Compiler Explorer makes it easy to try the code, tweak it, and immediately see how it affects the output and generated assembly code. </span><span class="koboSpan" id="kobo.20.2">The examples from this chapter are available on GitHub (</span><a href="https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter08"><span class="url"><span class="koboSpan" id="kobo.21.1">https://github.com/PacktPublishing/Cpp-in-Embedded-Systems/tree/main/Chapter08</span></span></a><span class="koboSpan" id="kobo.22.1">).</span></p>
<h1 class="heading-1" id="_idParaDest-124"><span class="koboSpan" id="kobo.23.1">Template basics</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.24.1">One definition of the word “template” is “a gauge, pattern, or mold (such as a thin plate or board) used as a guide to the form of a piece</span><a id="_idIndexMarker403"/><span class="koboSpan" id="kobo.25.1"> being made. </span><span class="koboSpan" id="kobo.25.2">“ This definition can be applied to templates in C++.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.26.1">In C++, templates serve as patterns or molds for functions and classes, allowing the creation of actual functions and classes. </span><span class="koboSpan" id="kobo.26.2">From this perspective, templates are not real functions or types themselves; rather, they act as guides for generating concrete functions and types. </span><span class="koboSpan" id="kobo.26.3">To better understand this definition, let us take a look at the following code sample:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.27.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.28.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.29.1">&lt;cstdio&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.30.1">template</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.31.1">&lt;</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.32.1">typename</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.33.1"> T&gt;</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.34.1">T </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.35.1">add</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.36.1">(T a, T b)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.37.1">{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.38.1">return</span></span><span class="koboSpan" id="kobo.39.1"> a + b;
}
</span><span class="hljs-type"><span class="koboSpan" id="kobo.40.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.41.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.42.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.43.1">{
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.44.1">int</span></span><span class="koboSpan" id="kobo.45.1"> result_int = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.46.1">add</span></span><span class="koboSpan" id="kobo.47.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.48.1">1</span></span><span class="koboSpan" id="kobo.49.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.50.1">4</span></span><span class="koboSpan" id="kobo.51.1">);
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.52.1">float</span></span><span class="koboSpan" id="kobo.53.1"> result_float = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.54.1">add</span></span><span class="koboSpan" id="kobo.55.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.56.1">1.11f</span></span><span class="koboSpan" id="kobo.57.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.58.1">1.91f</span></span><span class="koboSpan" id="kobo.59.1">);
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.60.1">printf</span></span><span class="koboSpan" id="kobo.61.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.62.1">"result_int = %d\r\n"</span></span><span class="koboSpan" id="kobo.63.1">, result_int);
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.64.1">printf</span></span><span class="koboSpan" id="kobo.65.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.66.1">"result_float = %.2f\r\n"</span></span><span class="koboSpan" id="kobo.67.1">, result_float);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.68.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.69.1">0</span></span><span class="koboSpan" id="kobo.70.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.71.1">In this example, we have a template function, </span><code class="inlineCode"><span class="koboSpan" id="kobo.72.1">add</span></code><span class="koboSpan" id="kobo.73.1">, with the template type parameter </span><code class="inlineCode"><span class="koboSpan" id="kobo.74.1">T</span></code><span class="koboSpan" id="kobo.75.1">. </span><span class="koboSpan" id="kobo.75.2">In the </span><code class="inlineCode"><span class="koboSpan" id="kobo.76.1">main</span></code><span class="koboSpan" id="kobo.77.1"> function, we see two calls to</span><a id="_idIndexMarker404"/><span class="koboSpan" id="kobo.78.1"> the </span><code class="inlineCode"><span class="koboSpan" id="kobo.79.1">add</span></code><span class="koboSpan" id="kobo.80.1"> function:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.81.1">The first one has integers as arguments and a return value stored in </span><code class="inlineCode"><span class="koboSpan" id="kobo.82.1">result_int</span></code></li>
<li class="bulletList"><span class="koboSpan" id="kobo.83.1">The second one has float arguments and a return value stored in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.84.1">result_float</span></code><span class="koboSpan" id="kobo.85.1"> float variable</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.86.1">Now, we previously said that template types and functions are not actual types and functions, so how can we make a call to the template function if it’s not a real function?</span></p>
<h2 class="heading-2" id="_idParaDest-125"><span class="koboSpan" id="kobo.87.1">Making a call to the template function</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.88.1">In this example, when the compiler sees a call to add a template function, it deduces the template argument and replaces the </span><a id="_idIndexMarker405"/><span class="koboSpan" id="kobo.89.1">template parameter, in this case, type </span><code class="inlineCode"><span class="koboSpan" id="kobo.90.1">T</span></code><span class="koboSpan" id="kobo.91.1">, with type </span><code class="inlineCode"><span class="koboSpan" id="kobo.92.1">int</span></code><span class="koboSpan" id="kobo.93.1"> in the first call and </span><code class="inlineCode"><span class="koboSpan" id="kobo.94.1">float</span></code><span class="koboSpan" id="kobo.95.1"> in the second call to </span><code class="inlineCode"><span class="koboSpan" id="kobo.96.1">add</span></code><span class="koboSpan" id="kobo.97.1">. </span><span class="koboSpan" id="kobo.97.2">After argument deduction, the template is instantiated; that is, the compiler creates two instances of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.98.1">add</span></code><span class="koboSpan" id="kobo.99.1"> function: one with integers as arguments and one with floats. </span><span class="koboSpan" id="kobo.99.2">We can see this in the assembly output of the preceding example shown here:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-symbol"><span class="koboSpan" id="kobo.100.1">_Z3addIiET_S0_S0_:</span></span>
        <span class="hljs-keyword"><span class="koboSpan" id="kobo.101.1">push</span></span>    <span class="hljs-built_in"><span class="koboSpan" id="kobo.102.1">rbp</span></span>
        <span class="hljs-keyword"><span class="koboSpan" id="kobo.103.1">mov</span></span>     <span class="hljs-built_in"><span class="koboSpan" id="kobo.104.1">rbp</span></span><span class="koboSpan" id="kobo.105.1">, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.106.1">rsp</span></span>
        <span class="hljs-keyword"><span class="koboSpan" id="kobo.107.1">mov</span></span>     <span class="hljs-built_in"><span class="koboSpan" id="kobo.108.1">DWORD</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.109.1">PTR</span></span><span class="koboSpan" id="kobo.110.1"> [</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.111.1">rbp</span></span><span class="koboSpan" id="kobo.112.1">-</span><span class="hljs-number"><span class="koboSpan" id="kobo.113.1">4</span></span><span class="koboSpan" id="kobo.114.1">], </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.115.1">edi</span></span>
        <span class="hljs-keyword"><span class="koboSpan" id="kobo.116.1">mov</span></span>     <span class="hljs-built_in"><span class="koboSpan" id="kobo.117.1">DWORD</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.118.1">PTR</span></span><span class="koboSpan" id="kobo.119.1"> [</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.120.1">rbp</span></span><span class="koboSpan" id="kobo.121.1">-</span><span class="hljs-number"><span class="koboSpan" id="kobo.122.1">8</span></span><span class="koboSpan" id="kobo.123.1">], </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.124.1">esi</span></span>
        <span class="hljs-keyword"><span class="koboSpan" id="kobo.125.1">mov</span></span>     <span class="hljs-built_in"><span class="koboSpan" id="kobo.126.1">edx</span></span><span class="koboSpan" id="kobo.127.1">, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.128.1">DWORD</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.129.1">PTR</span></span><span class="koboSpan" id="kobo.130.1"> [</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.131.1">rbp</span></span><span class="koboSpan" id="kobo.132.1">-</span><span class="hljs-number"><span class="koboSpan" id="kobo.133.1">4</span></span><span class="koboSpan" id="kobo.134.1">]
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.135.1">mov</span></span>     <span class="hljs-built_in"><span class="koboSpan" id="kobo.136.1">eax</span></span><span class="koboSpan" id="kobo.137.1">, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.138.1">DWORD</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.139.1">PTR</span></span><span class="koboSpan" id="kobo.140.1"> [</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.141.1">rbp</span></span><span class="koboSpan" id="kobo.142.1">-</span><span class="hljs-number"><span class="koboSpan" id="kobo.143.1">8</span></span><span class="koboSpan" id="kobo.144.1">]
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.145.1">add</span></span>     <span class="hljs-built_in"><span class="koboSpan" id="kobo.146.1">eax</span></span><span class="koboSpan" id="kobo.147.1">, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.148.1">edx</span></span>
        <span class="hljs-keyword"><span class="koboSpan" id="kobo.149.1">pop</span></span>     <span class="hljs-built_in"><span class="koboSpan" id="kobo.150.1">rbp</span></span>
        <span class="hljs-keyword"><span class="koboSpan" id="kobo.151.1">ret</span></span>
<span class="hljs-symbol"><span class="koboSpan" id="kobo.152.1">_Z3addIfET_S0_S0_:</span></span>
        <span class="hljs-keyword"><span class="koboSpan" id="kobo.153.1">push</span></span>    <span class="hljs-built_in"><span class="koboSpan" id="kobo.154.1">rbp</span></span>
        <span class="hljs-keyword"><span class="koboSpan" id="kobo.155.1">mov</span></span>     <span class="hljs-built_in"><span class="koboSpan" id="kobo.156.1">rbp</span></span><span class="koboSpan" id="kobo.157.1">, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.158.1">rsp</span></span>
        <span class="hljs-keyword"><span class="koboSpan" id="kobo.159.1">movss</span></span>   <span class="hljs-built_in"><span class="koboSpan" id="kobo.160.1">DWORD</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.161.1">PTR</span></span><span class="koboSpan" id="kobo.162.1"> s[</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.163.1">rbp</span></span><span class="koboSpan" id="kobo.164.1">-</span><span class="hljs-number"><span class="koboSpan" id="kobo.165.1">4</span></span><span class="koboSpan" id="kobo.166.1">], </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.167.1">xmm0</span></span>
        <span class="hljs-keyword"><span class="koboSpan" id="kobo.168.1">movss</span></span>   <span class="hljs-built_in"><span class="koboSpan" id="kobo.169.1">DWORD</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.170.1">PTR</span></span><span class="koboSpan" id="kobo.171.1"> [</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.172.1">rbp</span></span><span class="koboSpan" id="kobo.173.1">-</span><span class="hljs-number"><span class="koboSpan" id="kobo.174.1">8</span></span><span class="koboSpan" id="kobo.175.1">], </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.176.1">xmm1</span></span>
        <span class="hljs-keyword"><span class="koboSpan" id="kobo.177.1">movss</span></span>   <span class="hljs-built_in"><span class="koboSpan" id="kobo.178.1">xmm0</span></span><span class="koboSpan" id="kobo.179.1">, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.180.1">DWORD</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.181.1">PTR</span></span><span class="koboSpan" id="kobo.182.1"> [</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.183.1">rbp</span></span><span class="koboSpan" id="kobo.184.1">-</span><span class="hljs-number"><span class="koboSpan" id="kobo.185.1">4</span></span><span class="koboSpan" id="kobo.186.1">]
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.187.1">addss</span></span>   <span class="hljs-built_in"><span class="koboSpan" id="kobo.188.1">xmm0</span></span><span class="koboSpan" id="kobo.189.1">, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.190.1">DWORD</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.191.1">PTR</span></span><span class="koboSpan" id="kobo.192.1"> [</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.193.1">rbp</span></span><span class="koboSpan" id="kobo.194.1">-</span><span class="hljs-number"><span class="koboSpan" id="kobo.195.1">8</span></span><span class="koboSpan" id="kobo.196.1">]
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.197.1">pop</span></span>     <span class="hljs-built_in"><span class="koboSpan" id="kobo.198.1">rbp</span></span>
        <span class="hljs-keyword"><span class="koboSpan" id="kobo.199.1">ret</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.200.1">In the preceding assembly output, we see there are two instances of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.201.1">add</span></code><span class="koboSpan" id="kobo.202.1"> function: </span><code class="inlineCode"><span class="koboSpan" id="kobo.203.1">_Z3addIiET_S0_S0_</span></code><span class="koboSpan" id="kobo.204.1">, accepting integers, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.205.1">_Z3addIfET_S0_S0_</span></code><span class="koboSpan" id="kobo.206.1">, accepting floats. </span><span class="koboSpan" id="kobo.206.2">The compiler instantiated these two functions from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.207.1">add</span></code><span class="koboSpan" id="kobo.208.1"> template function, after it deduced template arguments on the call </span><a id="_idIndexMarker406"/><span class="koboSpan" id="kobo.209.1">site of this function. </span><span class="koboSpan" id="kobo.209.2">This is the basic working principle of templates in C++.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.210.1">In the example of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.211.1">add</span></code><span class="koboSpan" id="kobo.212.1"> template function, the compiler will instantiate a new function for every type for which there is a defined </span><code class="inlineCode"><span class="koboSpan" id="kobo.213.1">operator+</span></code><span class="koboSpan" id="kobo.214.1">. </span><span class="koboSpan" id="kobo.214.2">So, what would happen if we tried to call the </span><code class="inlineCode"><span class="koboSpan" id="kobo.215.1">add</span></code><span class="koboSpan" id="kobo.216.1"> template function on a type for which there is no defined </span><code class="inlineCode"><span class="koboSpan" id="kobo.217.1">operator+</span></code><span class="koboSpan" id="kobo.218.1">? </span><span class="koboSpan" id="kobo.218.2">Let’s take a look at the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.219.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.220.1">point</span></span><span class="koboSpan" id="kobo.221.1"> {
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.222.1">int</span></span><span class="koboSpan" id="kobo.223.1"> x;
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.224.1">int</span></span><span class="koboSpan" id="kobo.225.1"> y;
};
</span><span class="hljs-type"><span class="koboSpan" id="kobo.226.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.227.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.228.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.229.1">{
    point a{</span><span class="hljs-number"><span class="koboSpan" id="kobo.230.1">1</span></span><span class="koboSpan" id="kobo.231.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.232.1">2</span></span><span class="koboSpan" id="kobo.233.1">};
    point b{</span><span class="hljs-number"><span class="koboSpan" id="kobo.234.1">2</span></span><span class="koboSpan" id="kobo.235.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.236.1">1</span></span><span class="koboSpan" id="kobo.237.1">};
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.238.1">auto</span></span><span class="koboSpan" id="kobo.239.1"> c = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.240.1">add</span></span><span class="koboSpan" id="kobo.241.1">(a, b);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.242.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.243.1">0</span></span><span class="koboSpan" id="kobo.244.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.245.1">In the preceding example, we defined a </span><code class="inlineCode"><span class="koboSpan" id="kobo.246.1">point</span></code><span class="koboSpan" id="kobo.247.1"> struct, for which there is no defined </span><code class="inlineCode"><span class="koboSpan" id="kobo.248.1">operator+</span></code><span class="koboSpan" id="kobo.249.1">, and we made a call to the </span><code class="inlineCode"><span class="koboSpan" id="kobo.250.1">add</span></code><span class="koboSpan" id="kobo.251.1"> template function. </span><span class="koboSpan" id="kobo.251.2">This will result in a compiler error similar to the one shown here:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.252.1">&lt;source&gt;: In instantiation of 'T add(T, T) [with T = point]':
&lt;source&gt;:25:17:   required from here
   25 |     auto c = add(a, b);
      |              ~~~^~~~~~
&lt;source&gt;:6:13: error: no match for 'operator+' (operand types are 'point' and 'point')
    6 |    return a + b;
      |           ~~^~~
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.253.1">So, what happened? </span><span class="koboSpan" id="kobo.253.2">When the compiler tried to instantiate a function using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.254.1">add</span></code><span class="koboSpan" id="kobo.255.1"> template with </span><code class="inlineCode"><span class="koboSpan" id="kobo.256.1">point</span></code><span class="koboSpan" id="kobo.257.1"> as type </span><code class="inlineCode"><span class="koboSpan" id="kobo.258.1">T</span></code><span class="koboSpan" id="kobo.259.1">, the compilation</span><a id="_idIndexMarker407"/><span class="koboSpan" id="kobo.260.1"> failed due to </span><code class="inlineCode"><span class="koboSpan" id="kobo.261.1">no match for 'operator+' (operand types are 'point' and 'point')</span></code><span class="koboSpan" id="kobo.262.1">. </span><span class="koboSpan" id="kobo.262.2">We can solve this by defining </span><code class="inlineCode"><span class="koboSpan" id="kobo.263.1">operator+</span></code><span class="koboSpan" id="kobo.264.1"> for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.265.1">point</span></code><span class="koboSpan" id="kobo.266.1"> struct as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.267.1">struct</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.268.1">point</span></span><span class="koboSpan" id="kobo.269.1"> {
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.270.1">int</span></span><span class="koboSpan" id="kobo.271.1"> x;
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.272.1">int</span></span><span class="koboSpan" id="kobo.273.1"> y;
    point </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.274.1">operator</span></span><span class="koboSpan" id="kobo.275.1">+(</span><span class="hljs-type"><span class="koboSpan" id="kobo.276.1">const</span></span><span class="koboSpan" id="kobo.277.1"> point&amp; other) </span><span class="hljs-type"><span class="koboSpan" id="kobo.278.1">const</span></span><span class="koboSpan" id="kobo.279.1"> {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.280.1">return</span></span><span class="koboSpan" id="kobo.281.1"> point{x + other.x, y + other.y};
    }
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.282.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.283.1">print</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.284.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.285.1">{
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.286.1">printf</span></span><span class="koboSpan" id="kobo.287.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.288.1">"x = %d, y = %d\r\n"</span></span><span class="koboSpan" id="kobo.289.1">, x, y);
    }
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.290.1">In the preceding implementation, we defined </span><code class="inlineCode"><span class="koboSpan" id="kobo.291.1">operator+</span></code><span class="koboSpan" id="kobo.292.1"> for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.293.1">point</span></code><span class="koboSpan" id="kobo.294.1"> struct, and we also defined the </span><code class="inlineCode"><span class="koboSpan" id="kobo.295.1">print</span></code><span class="koboSpan" id="kobo.296.1"> function, which will help us to print the point. </span><span class="koboSpan" id="kobo.296.2">After this change, we can compile the example successfully.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.297.1">What if we wanted, for some reason, that </span><code class="inlineCode"><span class="koboSpan" id="kobo.298.1">add</span></code><span class="koboSpan" id="kobo.299.1"> function when used with type </span><code class="inlineCode"><span class="koboSpan" id="kobo.300.1">point</span></code><span class="koboSpan" id="kobo.301.1"> behaves differently than just applying the </span><code class="inlineCode"><span class="koboSpan" id="kobo.302.1">operator+</span></code><span class="koboSpan" id="kobo.303.1">? </span><span class="koboSpan" id="kobo.303.2">Let’s say we want to increment both </span><code class="inlineCode"><span class="koboSpan" id="kobo.304.1">x</span></code><span class="koboSpan" id="kobo.305.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.306.1">y</span></code><span class="koboSpan" id="kobo.307.1"> by 1 after summation. </span><span class="koboSpan" id="kobo.307.2">We can use template</span><a id="_idIndexMarker408"/><span class="koboSpan" id="kobo.308.1"> specialization for this.</span></p>
<h2 class="heading-2" id="_idParaDest-126"><span class="koboSpan" id="kobo.309.1">Template specialization</span></h2>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.310.1">Template specialization</span></strong><span class="koboSpan" id="kobo.311.1"> allows us </span><a id="_idIndexMarker409"/><span class="koboSpan" id="kobo.312.1">to provide the compiler with the implementation of a template function for a specific type, as in the following example of specializing the </span><code class="inlineCode"><span class="koboSpan" id="kobo.313.1">add</span></code><span class="koboSpan" id="kobo.314.1"> function for type </span><code class="inlineCode"><span class="koboSpan" id="kobo.315.1">point</span></code><span class="koboSpan" id="kobo.316.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.317.1">template</span></span><span class="koboSpan" id="kobo.318.1">&lt;&gt;
point </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.319.1">add</span></span><span class="koboSpan" id="kobo.320.1">&lt;point&gt;(point a, point b) {
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.321.1">return</span></span><span class="koboSpan" id="kobo.322.1"> point{a.x+b.x</span><span class="hljs-number"><span class="koboSpan" id="kobo.323.1">+1</span></span><span class="koboSpan" id="kobo.324.1">, a.y+b.y</span><span class="hljs-number"><span class="koboSpan" id="kobo.325.1">+1</span></span><span class="koboSpan" id="kobo.326.1">};
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.327.1">In this case, when the </span><code class="inlineCode"><span class="koboSpan" id="kobo.328.1">add</span></code><span class="koboSpan" id="kobo.329.1"> function is called with arguments of type </span><code class="inlineCode"><span class="koboSpan" id="kobo.330.1">point</span></code><span class="koboSpan" id="kobo.331.1">, the compiler skips the generic template instantiation and uses this specialized version instead. </span><span class="koboSpan" id="kobo.331.2">This allows us to customize the behavior of the function specifically for point objects, adding an extra 1 to each coordinate when two point instances are added together. </span><span class="koboSpan" id="kobo.331.3">Let us take a look at the full </span><code class="inlineCode"><span class="koboSpan" id="kobo.332.1">main</span></code><span class="koboSpan" id="kobo.333.1"> function now:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.334.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.335.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.336.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.337.1">{
    point a{</span><span class="hljs-number"><span class="koboSpan" id="kobo.338.1">1</span></span><span class="koboSpan" id="kobo.339.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.340.1">2</span></span><span class="koboSpan" id="kobo.341.1">};
    point b{</span><span class="hljs-number"><span class="koboSpan" id="kobo.342.1">2</span></span><span class="koboSpan" id="kobo.343.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.344.1">1</span></span><span class="koboSpan" id="kobo.345.1">};
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.346.1">auto</span></span><span class="koboSpan" id="kobo.347.1"> c = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.348.1">add</span></span><span class="koboSpan" id="kobo.349.1">(a, b);
    c.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.350.1">print</span></span><span class="koboSpan" id="kobo.351.1">();
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.352.1">static_assert</span></span><span class="koboSpan" id="kobo.353.1">(std::is_same_v&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.354.1">decltype</span></span><span class="koboSpan" id="kobo.355.1">(c), point&gt;);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.356.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.357.1">0</span></span><span class="koboSpan" id="kobo.358.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.359.1">If we run the example with template specialization from the previous step, we will get the following output:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attribute"><span class="koboSpan" id="kobo.360.1">x</span></span><span class="koboSpan" id="kobo.361.1"> = </span><span class="hljs-number"><span class="koboSpan" id="kobo.362.1">4</span></span><span class="koboSpan" id="kobo.363.1">, y = </span><span class="hljs-number"><span class="koboSpan" id="kobo.364.1">4</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.365.1">The compiler used function specialization for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.366.1">point</span></code><span class="koboSpan" id="kobo.367.1"> type. </span><span class="koboSpan" id="kobo.367.2">Template specialization makes templates a flexible tool, allowing us to provide compilers with custom implementations when needed.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.368.1">In the preceding example, we can see that for variable </span><code class="inlineCode"><span class="koboSpan" id="kobo.369.1">c</span></code><span class="koboSpan" id="kobo.370.1">, we used </span><code class="inlineCode"><span class="koboSpan" id="kobo.371.1">auto</span></code><span class="koboSpan" id="kobo.372.1"> as a type specifier. </span><span class="koboSpan" id="kobo.372.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.373.1">auto</span></code><span class="koboSpan" id="kobo.374.1"> keyword was introduced in C++11, and when used, the compiler deduces the actual type of a variable from the initialization </span><a id="_idIndexMarker410"/><span class="koboSpan" id="kobo.375.1">expression. </span><span class="koboSpan" id="kobo.375.2">In order to confirm that the deduced type of variable </span><code class="inlineCode"><span class="koboSpan" id="kobo.376.1">c</span></code><span class="koboSpan" id="kobo.377.1"> is </span><code class="inlineCode"><span class="koboSpan" id="kobo.378.1">point</span></code><span class="koboSpan" id="kobo.379.1">, we used </span><code class="inlineCode"><span class="koboSpan" id="kobo.380.1">static_assert</span></code><span class="koboSpan" id="kobo.381.1">, which performs compile-time assertion checking.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.382.1">As the argument of </span><code class="inlineCode"><span class="koboSpan" id="kobo.383.1">static_assert</span></code><span class="koboSpan" id="kobo.384.1">, we use a type trait from the metaprogramming library, </span><code class="inlineCode"><span class="koboSpan" id="kobo.385.1">std::is_same_v</span></code><span class="koboSpan" id="kobo.386.1">, which checks whether two types are identical and evaluates to </span><code class="inlineCode"><span class="koboSpan" id="kobo.387.1">true</span></code><span class="koboSpan" id="kobo.388.1"> if they are. </span><span class="koboSpan" id="kobo.388.2">We determine the type of </span><code class="inlineCode"><span class="koboSpan" id="kobo.389.1">c</span></code><span class="koboSpan" id="kobo.390.1"> using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.391.1">decltype</span></code><span class="koboSpan" id="kobo.392.1"> specifier, which retrieves the type of an expression at compile time. </span><span class="koboSpan" id="kobo.392.2">This allows us to verify that the type deduced for </span><code class="inlineCode"><span class="koboSpan" id="kobo.393.1">c</span></code><span class="koboSpan" id="kobo.394.1"> is indeed </span><code class="inlineCode"><span class="koboSpan" id="kobo.395.1">point</span></code><span class="koboSpan" id="kobo.396.1">. </span><span class="koboSpan" id="kobo.396.2">If this assertion fails, the compiler will generate an error.</span></p>
<h1 class="heading-1" id="_idParaDest-127"><span class="koboSpan" id="kobo.397.1">Template metaprogramming</span></h1>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.398.1">Template metaprogramming</span></strong><span class="koboSpan" id="kobo.399.1"> involves using templates to write code that generates different functions, types, and constants at compile time based on the types used in the template arguments. </span><span class="koboSpan" id="kobo.399.2">Template metaprogramming is an </span><a id="_idIndexMarker411"/><span class="koboSpan" id="kobo.400.1">advanced technique heavily utilized in modern C++ libraries. </span><span class="koboSpan" id="kobo.400.2">It may be overwhelming, so it is perfectly fine if it appears to be hard to understand. </span><span class="koboSpan" id="kobo.400.3">Take this as merely an introduction and an exploration of this interesting topic.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.401.1">Let us go back to the example of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.402.1">add</span></code><span class="koboSpan" id="kobo.403.1"> template function. </span><span class="koboSpan" id="kobo.403.2">Is there something we can do if we want to enforce that this template function is used only for arithmetic types such as integers and floats?</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.404.1">&lt;type_traits&gt;</span></code><span class="koboSpan" id="kobo.405.1"> header from metaprogramming library provides us with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.406.1">std::enable_if</span></code><span class="koboSpan" id="kobo.407.1"> template type, which accepts two parameters, a Boolean and a type. </span><span class="koboSpan" id="kobo.407.2">If a Boolean is true, the resulting type will have a public </span><code class="inlineCode"><span class="koboSpan" id="kobo.408.1">typedef</span></code><span class="koboSpan" id="kobo.409.1"> member, </span><code class="inlineCode"><span class="koboSpan" id="kobo.410.1">type</span></code><span class="koboSpan" id="kobo.411.1">. </span><span class="koboSpan" id="kobo.411.2">Let’s take a look at the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.412.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.413.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.414.1">&lt;type_traits&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.415.1">template</span></span><span class="koboSpan" id="kobo.416.1">&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.417.1">typename</span></span><span class="koboSpan" id="kobo.418.1"> T&gt;
std::enable_if&lt;</span><span class="hljs-literal"><span class="koboSpan" id="kobo.419.1">true</span></span><span class="koboSpan" id="kobo.420.1">, T&gt;::</span><span class="hljs-function"><span class="koboSpan" id="kobo.421.1">type</span></span>
<span class="hljs-title"><span class="koboSpan" id="kobo.422.1">add</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.423.1">(T a, T b)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.424.1">{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.425.1">return</span></span><span class="koboSpan" id="kobo.426.1"> a + b;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.427.1">In the preceding example, we used </span><code class="inlineCode"><span class="koboSpan" id="kobo.428.1">std::enable_if</span></code><span class="koboSpan" id="kobo.429.1"> in place of the return type of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.430.1">add</span></code><span class="koboSpan" id="kobo.431.1"> template function. </span><span class="koboSpan" id="kobo.431.2">As we set the Boolean argument to </span><code class="inlineCode"><span class="koboSpan" id="kobo.432.1">true</span></code><span class="koboSpan" id="kobo.433.1">, it will have a public </span><code class="inlineCode"><span class="koboSpan" id="kobo.434.1">typedef</span></code><span class="koboSpan" id="kobo.435.1"> type, </span><code class="inlineCode"><span class="koboSpan" id="kobo.436.1">T</span></code><span class="koboSpan" id="kobo.437.1">, meaning that the return type of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.438.1">add</span></code><span class="koboSpan" id="kobo.439.1"> function template will be </span><code class="inlineCode"><span class="koboSpan" id="kobo.440.1">T</span></code><span class="koboSpan" id="kobo.441.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.442.1">We will expand this example using </span><a id="_idIndexMarker412"/><span class="koboSpan" id="kobo.443.1">type trait class template </span><code class="inlineCode"><span class="koboSpan" id="kobo.444.1">std::is_arithmetic&lt;T&gt;</span></code><span class="koboSpan" id="kobo.445.1">, which will have a public Boolean named </span><code class="inlineCode"><span class="koboSpan" id="kobo.446.1">value</span></code><span class="koboSpan" id="kobo.447.1"> set to </span><code class="inlineCode"><span class="koboSpan" id="kobo.448.1">true</span></code><span class="koboSpan" id="kobo.449.1"> if </span><code class="inlineCode"><span class="koboSpan" id="kobo.450.1">T</span></code><span class="koboSpan" id="kobo.451.1"> is an arithmetic type. </span><span class="koboSpan" id="kobo.451.2">The preceding example will result in the following code:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.452.1">template</span></span><span class="koboSpan" id="kobo.453.1">&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.454.1">typename</span></span><span class="koboSpan" id="kobo.455.1"> T&gt;
std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value, T&gt;::</span><span class="hljs-function"><span class="koboSpan" id="kobo.456.1">type</span></span>
<span class="hljs-title"><span class="koboSpan" id="kobo.457.1">add</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.458.1">(T a, T b)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.459.1">{
   </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.460.1">return</span></span><span class="koboSpan" id="kobo.461.1"> a + b;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.462.1">In the preceding example, instead of hardcoding </span><code class="inlineCode"><span class="koboSpan" id="kobo.463.1">true</span></code><span class="koboSpan" id="kobo.464.1"> as the condition for </span><code class="inlineCode"><span class="koboSpan" id="kobo.465.1">std::enable_if</span></code><span class="koboSpan" id="kobo.466.1">, we use the </span><code class="inlineCode"><span class="koboSpan" id="kobo.467.1">std::is_arithmetic&lt;T&gt;::value</span></code><span class="koboSpan" id="kobo.468.1">. </span><span class="koboSpan" id="kobo.468.2">Let’s take a look at the </span><code class="inlineCode"><span class="koboSpan" id="kobo.469.1">main</span></code><span class="koboSpan" id="kobo.470.1"> function using this template function and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.471.1">point</span></code><span class="koboSpan" id="kobo.472.1"> type from the previous example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-type"><span class="koboSpan" id="kobo.473.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.474.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.475.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.476.1">{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.477.1">auto</span></span><span class="koboSpan" id="kobo.478.1"> a = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.479.1">add</span></span><span class="koboSpan" id="kobo.480.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.481.1">1</span></span><span class="koboSpan" id="kobo.482.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.483.1">2</span></span><span class="koboSpan" id="kobo.484.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.485.1">// OK</span></span>
    <span class="hljs-keyword"><span class="koboSpan" id="kobo.486.1">auto</span></span><span class="koboSpan" id="kobo.487.1"> b = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.488.1">add</span></span><span class="koboSpan" id="kobo.489.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.490.1">1.1</span></span><span class="koboSpan" id="kobo.491.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.492.1">2.1</span></span><span class="koboSpan" id="kobo.493.1">); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.494.1">// OK</span></span><span class="koboSpan" id="kobo.495.1">
    point p_a{</span><span class="hljs-number"><span class="koboSpan" id="kobo.496.1">1</span></span><span class="koboSpan" id="kobo.497.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.498.1">2</span></span><span class="koboSpan" id="kobo.499.1">};
    point p_b{</span><span class="hljs-number"><span class="koboSpan" id="kobo.500.1">2</span></span><span class="koboSpan" id="kobo.501.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.502.1">1</span></span><span class="koboSpan" id="kobo.503.1">}; 
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.504.1">auto</span></span><span class="koboSpan" id="kobo.505.1"> p_c = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.506.1">add</span></span><span class="koboSpan" id="kobo.507.1">(p_a, p_b); </span><span class="hljs-comment"><span class="koboSpan" id="kobo.508.1">// compile-error</span></span>
    <span class="hljs-keyword"><span class="koboSpan" id="kobo.509.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.510.1">0</span></span><span class="koboSpan" id="kobo.511.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.512.1">If we try to compile this code, the compilation will fail with a lengthy error message containing the following:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.513.1">&lt;source&gt;: In function 'int main()':
&lt;source&gt;:30:17: error: no matching function for call to 'add(point&amp;, point&amp;)'
  30 |     auto c = add(p_a, p_b); // compile-error
     |              ~~~^~~~~~~~~~
&lt;source&gt;:30:17: note: there is 1 candidate
&lt;source&gt;:19:1: note: candidate 1: 'template&lt;class T&gt; typename std::enable_if&lt;std::is_arithmetic&lt;_Tp&gt;::value, T&gt;::type add(T, T)'
  19 | add(T a, T b) {
     | ^~~
&lt;source&gt;:19:1: note: template argument deduction/substitution failed:
&lt;source&gt;: In substitution of 'template&lt;class T&gt; typename std::enable_if&lt;std::is_arithmetic&lt;_Tp&gt;::value, T&gt;::type add(T, T) [with T = point]':
&lt;source&gt;:30:17:   required from here
  30 |     auto c = add(p_a, p_b); // compile-error
     |              ~~~^~~~~~~~~~
&lt;source&gt;:19:1: error: no type named 'type' in 'struct std::enable_if&lt;false, point&gt;'
  19 | add(T a, T b) {
     | ^~~
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.514.1">The preceding compiler error looks intimidating, and it is hard to read. </span><span class="koboSpan" id="kobo.514.2">This is one of those things that templates are</span><a id="_idIndexMarker413"/><span class="koboSpan" id="kobo.515.1"> notorious for. </span><span class="koboSpan" id="kobo.515.2">Before we tackle this concern, let’s focus on analyzing what happened in this case.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.516.1">Template argument deduction/substitution failed as </span><code class="inlineCode"><span class="koboSpan" id="kobo.517.1">std::is_arithmetic&lt;point&gt;::value</span></code><span class="koboSpan" id="kobo.518.1"> results in </span><code class="inlineCode"><span class="koboSpan" id="kobo.519.1">false</span></code><span class="koboSpan" id="kobo.520.1">, meaning that the </span><code class="inlineCode"><span class="koboSpan" id="kobo.521.1">std::enable_if</span></code><span class="koboSpan" id="kobo.522.1"> template type will not have a public typedef </span><code class="inlineCode"><span class="koboSpan" id="kobo.523.1">type T</span></code><span class="koboSpan" id="kobo.524.1">. </span><span class="koboSpan" id="kobo.524.2">Effectively, any attempt at the usage of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.525.1">add</span></code><span class="koboSpan" id="kobo.526.1"> template function in this example with a type that’s not arithmetic will result in a compiler error, even if </span><code class="inlineCode"><span class="koboSpan" id="kobo.527.1">operator+</span></code><span class="koboSpan" id="kobo.528.1"> is defined for that type. </span><span class="koboSpan" id="kobo.528.2">We can think of </span><code class="inlineCode"><span class="koboSpan" id="kobo.529.1">std::enable_if</span></code><span class="koboSpan" id="kobo.530.1"> as an enabler or disabler of a template function in C++.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.531.1">Let’s modify the </span><code class="inlineCode"><span class="koboSpan" id="kobo.532.1">add</span></code><span class="koboSpan" id="kobo.533.1"> template function so that it prints the result of the sum operation. </span><span class="koboSpan" id="kobo.533.2">As both integers and floats are arithmetic types, we need to treat them differently. </span><span class="koboSpan" id="kobo.533.3">We could use </span><code class="inlineCode"><span class="koboSpan" id="kobo.534.1">std::enable_if</span></code><span class="koboSpan" id="kobo.535.1"> and create two template functions using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.536.1">std::is_integral</span></code><span class="koboSpan" id="kobo.537.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.538.1">std::is_floating_point</span></code><span class="koboSpan" id="kobo.539.1"> type traits as in the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.540.1">template</span></span><span class="koboSpan" id="kobo.541.1">&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.542.1">typename</span></span><span class="koboSpan" id="kobo.543.1"> T&gt;
std::enable_if&lt;std::is_integral&lt;T&gt;::value, T&gt;::</span><span class="hljs-function"><span class="koboSpan" id="kobo.544.1">type</span></span>
<span class="hljs-title"><span class="koboSpan" id="kobo.545.1">add</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.546.1">(T a, T b)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.547.1">{
    T result = a + b;
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.548.1">printf</span></span><span class="koboSpan" id="kobo.549.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.550.1">"%d + %d = %d\r\n"</span></span><span class="koboSpan" id="kobo.551.1">, a, b, result);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.552.1">return</span></span><span class="koboSpan" id="kobo.553.1"> result;
}
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.554.1">template</span></span><span class="koboSpan" id="kobo.555.1">&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.556.1">typename</span></span><span class="koboSpan" id="kobo.557.1"> T&gt;
std::enable_if&lt;std::is_floating_point&lt;T&gt;::value, T&gt;::</span><span class="hljs-function"><span class="koboSpan" id="kobo.558.1">type</span></span>
<span class="hljs-title"><span class="koboSpan" id="kobo.559.1">add</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.560.1">(T a, T b)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.561.1">{
    T result = a + b;
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.562.1">printf</span></span><span class="koboSpan" id="kobo.563.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.564.1">"%.2f + %.2f = %.2f\r\n"</span></span><span class="koboSpan" id="kobo.565.1">, a, b, result);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.566.1">return</span></span><span class="koboSpan" id="kobo.567.1"> result;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.568.1">As you remember, </span><code class="inlineCode"><span class="koboSpan" id="kobo.569.1">std::enable_if</span></code><span class="koboSpan" id="kobo.570.1"> is a template enabler or disabler, meaning it will enable the first template function for integer types and print them using </span><code class="inlineCode"><span class="koboSpan" id="kobo.571.1">printf</span></code><span class="koboSpan" id="kobo.572.1"> and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.573.1">%d</span></code><span class="koboSpan" id="kobo.574.1"> format specifier. </span><span class="koboSpan" id="kobo.574.2">Template substitution will fail for the second template function with integer types, but this will not be treated as </span><a id="_idIndexMarker414"/><span class="koboSpan" id="kobo.575.1">an error as there is a valid function candidate for integer arguments from the first template. </span><span class="koboSpan" id="kobo.575.2">This principle is called </span><strong class="keyWord"><span class="koboSpan" id="kobo.576.1">Subsitution Failure Is Not An Error</span></strong><span class="koboSpan" id="kobo.577.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.578.1">SFINAE</span></strong><span class="koboSpan" id="kobo.579.1">). </span><span class="koboSpan" id="kobo.579.2">For the</span><a id="_idIndexMarker415"/><span class="koboSpan" id="kobo.580.1"> floating-point types, the first template function will be disabled, but the second one will be enabled.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.581.1">Now, the example functions we used are very simple, but let’s for a moment pretend that the </span><code class="inlineCode"><span class="koboSpan" id="kobo.582.1">add</span></code><span class="koboSpan" id="kobo.583.1"> function template is doing a heavy-lifting task and that between integer and floating-point versions, the only difference is how we print the result. </span><span class="koboSpan" id="kobo.583.2">So, if we used two different function templates, we would copy a lot of the same code. </span><span class="koboSpan" id="kobo.583.3">We can avoid this by using </span><code class="inlineCode"><span class="koboSpan" id="kobo.584.1">constexpr if</span></code><span class="koboSpan" id="kobo.585.1">, which will enable or disable certain paths in code at compile time. </span><span class="koboSpan" id="kobo.585.2">Let us take a look at a modified example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.586.1">std::</span><span class="hljs-type"><span class="koboSpan" id="kobo.587.1">enable_if_t</span></span><span class="koboSpan" id="kobo.588.1">&lt;std::is_arithmetic_v&lt;T&gt;, T&gt;
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.589.1">add</span></span><span class="koboSpan" id="kobo.590.1">(T a, T b) {
    T result = a + b;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.591.1">if</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.592.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.593.1">(std::is_integral_v&lt;T&gt;)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.594.1">{
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.595.1">printf</span></span><span class="koboSpan" id="kobo.596.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.597.1">"%d + %d = %d\r\n"</span></span><span class="koboSpan" id="kobo.598.1">, a, b, result);
    } </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.599.1">else</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.600.1">if</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.601.1">constexpr</span></span><span class="koboSpan" id="kobo.602.1"> (std::is_floating_point_v&lt;T&gt;) {
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.603.1">printf</span></span><span class="koboSpan" id="kobo.604.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.605.1">"%.2f + %.2f = %.2f\r\n"</span></span><span class="koboSpan" id="kobo.606.1">, a, b, result);
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.607.1">return</span></span><span class="koboSpan" id="kobo.608.1"> a + b;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.609.1">In the preceding example, we used the </span><code class="inlineCode"><span class="koboSpan" id="kobo.610.1">constexpr if</span></code><span class="koboSpan" id="kobo.611.1"> statement to enable certain paths of the program based on the compile-time evaluation of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.612.1">std::is_integral_v&lt;T&gt;</span></code><span class="koboSpan" id="kobo.613.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.614.1">std::is_floating_point_v&lt;T&gt;</span></code><span class="koboSpan" id="kobo.615.1"> expressions. </span><code class="inlineCode"><span class="koboSpan" id="kobo.616.1">constexpr if</span></code><span class="koboSpan" id="kobo.617.1"> was introduced in C++17. </span><span class="koboSpan" id="kobo.617.2">You can also notice that we used </span><a id="_idIndexMarker416"/><span class="koboSpan" id="kobo.618.1">aliases for type traits as </span><code class="inlineCode"><span class="koboSpan" id="kobo.619.1">std::enable_if_t&lt;T&gt;</span></code><span class="koboSpan" id="kobo.620.1">, which is equivalent to </span><code class="inlineCode"><span class="koboSpan" id="kobo.621.1">std::enable_if&lt;T&gt;::type</span></code><span class="koboSpan" id="kobo.622.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.623.1">std::is_floating_point_v&lt;T&gt;</span></code><span class="koboSpan" id="kobo.624.1">, which is equivalent to </span><code class="inlineCode"><span class="koboSpan" id="kobo.625.1">std::is_floating_point&lt;T&gt;::value</span></code><span class="koboSpan" id="kobo.626.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.627.1">In this example, we used type traits and </span><code class="inlineCode"><span class="koboSpan" id="kobo.628.1">std::enable_if</span></code><span class="koboSpan" id="kobo.629.1"> to enable the </span><code class="inlineCode"><span class="koboSpan" id="kobo.630.1">add</span></code><span class="koboSpan" id="kobo.631.1"> function template only for arithmetic types. </span><span class="koboSpan" id="kobo.631.2">C++20 introduced concepts, which we can use to put restraints on template types.</span></p>
<h1 class="heading-1" id="_idParaDest-128"><span class="koboSpan" id="kobo.632.1">Concepts</span></h1>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.633.1">Concepts</span></strong><span class="koboSpan" id="kobo.634.1"> are named sets of template parameter requirements. </span><span class="koboSpan" id="kobo.634.2">They are evaluated at compile time and are used during overload</span><a id="_idIndexMarker417"/><span class="koboSpan" id="kobo.635.1"> resolution to select the most appropriate function overload; that is, they are used to determine which function template will be instantiated and compiled.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.636.1">We will create a concept for arithmetic types and use it in our </span><code class="inlineCode"><span class="koboSpan" id="kobo.637.1">add</span></code><span class="koboSpan" id="kobo.638.1"> template function, as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.639.1">template</span></span><span class="koboSpan" id="kobo.640.1">&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.641.1">typename</span></span><span class="koboSpan" id="kobo.642.1"> T&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.643.1">concept</span></span><span class="koboSpan" id="kobo.644.1"> Arithmetic = std::is_arithmetic_v&lt;T&gt;;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.645.1">template</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.646.1">&lt;Arithmetic T&gt;</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.647.1">T </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.648.1">add</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.649.1">(T a, T b)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.650.1">{
    T result = a + b;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.651.1">if</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.652.1">constexpr</span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="koboSpan" id="kobo.653.1">(std::is_integral_v&lt;T&gt;)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.654.1">{
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.655.1">printf</span></span><span class="koboSpan" id="kobo.656.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.657.1">"%d + %d = %d\r\n"</span></span><span class="koboSpan" id="kobo.658.1">, a, b, result);
    } </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.659.1">else</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.660.1">if</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.661.1">constexpr</span></span><span class="koboSpan" id="kobo.662.1"> (std::is_floating_point_v&lt;T&gt;) {
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.663.1">printf</span></span><span class="koboSpan" id="kobo.664.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.665.1">"%.2f + %.2f = %.2f\r\n"</span></span><span class="koboSpan" id="kobo.666.1">, a, b, result);
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.667.1">return</span></span><span class="koboSpan" id="kobo.668.1"> a + b;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.669.1">In the preceding code, we created the </span><code class="inlineCode"><span class="koboSpan" id="kobo.670.1">Arithmetic</span></code><span class="koboSpan" id="kobo.671.1"> concept and used it in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.672.1">add</span></code><span class="koboSpan" id="kobo.673.1"> function template to put requirements on the </span><code class="inlineCode"><span class="koboSpan" id="kobo.674.1">T</span></code><span class="koboSpan" id="kobo.675.1"> template type. </span><span class="koboSpan" id="kobo.675.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.676.1">add</span></code><span class="koboSpan" id="kobo.677.1"> template function is now easier to read. </span><span class="koboSpan" id="kobo.677.2">It is visible from the template declaration that type </span><code class="inlineCode"><span class="koboSpan" id="kobo.678.1">T</span></code><span class="koboSpan" id="kobo.679.1"> must meet the requirements of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.680.1">Arithmetic</span></code><span class="koboSpan" id="kobo.681.1"> concept, which makes the code easier to read and comprehend.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.682.1">Concepts not only make the</span><a id="_idIndexMarker418"/><span class="koboSpan" id="kobo.683.1"> code easier to read but also improve readability of compiler errors. </span><span class="koboSpan" id="kobo.683.2">If we tried to call the function template </span><code class="inlineCode"><span class="koboSpan" id="kobo.684.1">add</span></code><span class="koboSpan" id="kobo.685.1"> on type </span><code class="inlineCode"><span class="koboSpan" id="kobo.686.1">point</span></code><span class="koboSpan" id="kobo.687.1">, we would now get an error similar to the following one:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.688.1">&lt;source&gt;: In function 'int main()':
&lt;source&gt;:41:17: error: no matching function for call to 'add(point&amp;, point&amp;)'
  41 |     auto c = add(p_a, p_b); // compile-error
     |              ~~~^~~~~~~~~~
&lt;source&gt;:41:17: note: there is 1 candidate
&lt;source&gt;:22:3: note: candidate 1: 'template&lt;class T&gt;  requires  Arithmetic&lt;T&gt; T add(T, T)'
  22 | T add(T a, T b) {
     |   ^~~
&lt;source&gt;:22:3: note: template argument deduction/substitution failed:
&lt;source&gt;:22:3: note: constraints not satisfied
&lt;source&gt;: In substitution of 'template&lt;class T&gt;  requires  Arithmetic&lt;T&gt; T add(T, T) [with T = point]':
&lt;source&gt;:41:17:   required from here
  41 |     auto c = add(p_a, p_b); // compile-error
     |              ~~~^~~~~~~~~~
&lt;source&gt;:18:9:   required for the satisfaction of 'Arithmetic&lt;T&gt;' [with T = point]
&lt;source&gt;:18:27: note: the expression 'is_arithmetic_v&lt;T&gt; [with T = point]' evaluated to 'false'
  18 | concept Arithmetic = std::is_arithmetic_v&lt;T&gt;;
     |                      ~~~~~^~~~~~~~~~~~~~~~~~
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.689.1">The preceding compiler error is way easier to read and understand what happened than the one we had previously when we didn’t use concepts. </span><span class="koboSpan" id="kobo.689.2">We can easily trace the origin of the error to the fact that constraints</span><a id="_idIndexMarker419"/><span class="koboSpan" id="kobo.690.1"> imposed by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.691.1">Arithmetic</span></code><span class="koboSpan" id="kobo.692.1"> concept are not satisfied for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.693.1">point</span></code><span class="koboSpan" id="kobo.694.1"> type.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.695.1">Next, we will move on to discuss compile-time polymorphism and see how we can utilize concepts to help us enforce strong interfaces.</span></p>
<h1 class="heading-1" id="_idParaDest-129"><span class="koboSpan" id="kobo.696.1">Compile-time polymorphism</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.697.1">In </span><a href="Chapter_05.xhtml"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.698.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.699.1">, we discussed dynamic, or runtime, polymorphism. </span><span class="koboSpan" id="kobo.699.2">We used it to define an interface for </span><code class="inlineCode"><span class="koboSpan" id="kobo.700.1">uart</span></code><span class="koboSpan" id="kobo.701.1">, which was implemented by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.702.1">uart_stm32</span></code><span class="koboSpan" id="kobo.703.1"> class. </span><span class="koboSpan" id="kobo.703.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.704.1">gsm_lib</span></code><span class="koboSpan" id="kobo.705.1"> class has a dependency on the </span><code class="inlineCode"><span class="koboSpan" id="kobo.706.1">uart</span></code><span class="koboSpan" id="kobo.707.1"> interface only, not on</span><a id="_idIndexMarker420"/><span class="koboSpan" id="kobo.708.1"> the concrete implementation, which is </span><a id="_idIndexMarker421"/><span class="koboSpan" id="kobo.709.1">contained in </span><code class="inlineCode"><span class="koboSpan" id="kobo.710.1">uart_stm32</span></code><span class="koboSpan" id="kobo.711.1">. </span><span class="koboSpan" id="kobo.711.2">This is called </span><strong class="keyWord"><span class="koboSpan" id="kobo.712.1">loose coupling</span></strong><span class="koboSpan" id="kobo.713.1"> and allows us to have portable code for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.714.1">gsm_lib</span></code><span class="koboSpan" id="kobo.715.1"> class.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.716.1">We can easily supply </span><code class="inlineCode"><span class="koboSpan" id="kobo.717.1">gsm_lib</span></code><span class="koboSpan" id="kobo.718.1"> with another </span><code class="inlineCode"><span class="koboSpan" id="kobo.719.1">uart</span></code><span class="koboSpan" id="kobo.720.1"> interface implementation on a different hardware platform. </span><span class="koboSpan" id="kobo.720.2">This principle is </span><a id="_idIndexMarker422"/><span class="koboSpan" id="kobo.721.1">called </span><strong class="keyWord"><span class="koboSpan" id="kobo.722.1">dependency inversion</span></strong><span class="koboSpan" id="kobo.723.1">. </span><span class="koboSpan" id="kobo.723.2">It says that high-level modules (classes) shouldn’t depend on low-level modules and that both should depend on abstractions (interfaces). </span><span class="koboSpan" id="kobo.723.3">We can implement this principle by using inheritance and virtual functions in C++.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.724.1">Virtual functions result in indirection, causing the runtime overhead and increased binary size needed for their implementation. </span><span class="koboSpan" id="kobo.724.2">They allow runtime dispatching of function calls, but they come with a price. </span><span class="koboSpan" id="kobo.724.3">In embedded applications, we usually know all our types, meaning that we can use templates and overload</span><a id="_idIndexMarker423"/><span class="koboSpan" id="kobo.725.1"> resolution for the static or compile-time dispatch of function calls.</span></p>
<h3 class="heading-3" id="_idParaDest-130"><span class="koboSpan" id="kobo.726.1">Using Class Templates for Compile-Time Polymorphism</span></h3>
<p class="normal"><span class="koboSpan" id="kobo.727.1">We can make </span><code class="inlineCode"><span class="koboSpan" id="kobo.728.1">gsm_lib</span></code><span class="koboSpan" id="kobo.729.1"> a class template </span><a id="_idIndexMarker424"/><span class="koboSpan" id="kobo.730.1">that has one parameter that we will use for the </span><code class="inlineCode"><span class="koboSpan" id="kobo.731.1">uart</span></code><span class="koboSpan" id="kobo.732.1"> type, as shown in the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.733.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.734.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.735.1">&lt;span&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.736.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.737.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.738.1">&lt;cstdio&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.739.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.740.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.741.1">&lt;cstdint&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.742.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.743.1">uart_stm32</span></span><span class="koboSpan" id="kobo.744.1"> {
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.745.1">public</span></span><span class="koboSpan" id="kobo.746.1">:
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.747.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.748.1">init</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.749.1">(std::</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.750.1">uint32_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.751.1"> baudrate = </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.752.1">9600</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.753.1">)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.754.1">{
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.755.1">printf</span></span><span class="koboSpan" id="kobo.756.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.757.1">"uart_stm32::init: setting baudrate to %d\r\n"</span></span><span class="koboSpan" id="kobo.758.1">, baudrate);
    }
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.759.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.760.1">write</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.761.1">(std::span&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.762.1">const</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.763.1">char</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.764.1">&gt; data)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.765.1">{
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.766.1">printf</span></span><span class="koboSpan" id="kobo.767.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.768.1">"uart_stm32::write: "</span></span><span class="koboSpan" id="kobo.769.1">);
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.770.1">for</span></span><span class="koboSpan" id="kobo.771.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.772.1">auto</span></span><span class="koboSpan" id="kobo.773.1"> ch: data) {
            </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.774.1">putc</span></span><span class="koboSpan" id="kobo.775.1">(ch, stdout);
        }
    }
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.776.1">template</span></span><span class="koboSpan" id="kobo.777.1">&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.778.1">typename</span></span><span class="koboSpan" id="kobo.779.1"> T&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.780.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.781.1">gsm_lib</span></span><span class="koboSpan" id="kobo.782.1">{
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.783.1">public</span></span><span class="koboSpan" id="kobo.784.1">:
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.785.1">gsm_lib</span></span><span class="koboSpan" id="kobo.786.1">(T &amp;u) : </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.787.1">uart_</span></span><span class="koboSpan" id="kobo.788.1">(u) {}
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.789.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.790.1">init</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.791.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.792.1">{
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.793.1">printf</span></span><span class="koboSpan" id="kobo.794.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.795.1">"gsm_lib::init: sending AT command\r\n"</span></span><span class="koboSpan" id="kobo.796.1">);
        uart_.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.797.1">write</span></span><span class="koboSpan" id="kobo.798.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.799.1">"AT"</span></span><span class="koboSpan" id="kobo.800.1">);
    }
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.801.1">private</span></span><span class="koboSpan" id="kobo.802.1">:
    T &amp;uart_;
};
</span><span class="hljs-type"><span class="koboSpan" id="kobo.803.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.804.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.805.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.806.1">{
    uart_stm32 uart_stm32_obj;
    uart_stm32_obj.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.807.1">init</span></span><span class="koboSpan" id="kobo.808.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.809.1">115200</span></span><span class="koboSpan" id="kobo.810.1">);
    </span><span class="hljs-function"><span class="koboSpan" id="kobo.811.1">gsm_lib </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.812.1">gsm</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.813.1">(uart_stm32_obj)</span></span><span class="koboSpan" id="kobo.814.1">;
    gsm.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.815.1">init</span></span><span class="koboSpan" id="kobo.816.1">();
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.817.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.818.1">0</span></span><span class="koboSpan" id="kobo.819.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.820.1">In the preceding example, the compiler will instantiate the </span><code class="inlineCode"><span class="koboSpan" id="kobo.821.1">gsm_lib</span></code><span class="koboSpan" id="kobo.822.1"> template class using the </span><code class="inlineCode"><span class="koboSpan" id="kobo.823.1">uart_stm32</span></code><span class="koboSpan" id="kobo.824.1"> class as a template argument. </span><span class="koboSpan" id="kobo.824.2">This </span><a id="_idIndexMarker425"/><span class="koboSpan" id="kobo.825.1">will result in using a reference to an object of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.826.1">uart_stm32</span></code><span class="koboSpan" id="kobo.827.1"> class in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.828.1">gsm_lib</span></code><span class="koboSpan" id="kobo.829.1"> code. </span><span class="koboSpan" id="kobo.829.2">We can still easily reuse </span><code class="inlineCode"><span class="koboSpan" id="kobo.830.1">gsm_lib</span></code><span class="koboSpan" id="kobo.831.1"> by using it with a different type that provides all the methods needed to compile it. </span><span class="koboSpan" id="kobo.831.2">In this example, the type that used with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.832.1">gsm_lib</span></code><span class="koboSpan" id="kobo.833.1"> class template must provide a </span><code class="inlineCode"><span class="koboSpan" id="kobo.834.1">write</span></code><span class="koboSpan" id="kobo.835.1"> method accepting </span><code class="inlineCode"><span class="koboSpan" id="kobo.836.1">std::span&lt;char&gt; </span></code><span class="koboSpan" id="kobo.837.1">as its parameter. </span><span class="koboSpan" id="kobo.837.2">But this also means that any type that has such a method will allow us to compile the code.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.838.1">Dynamic polymorphism requires interface classes implemented in concrete classes and used in high-level code. </span><span class="koboSpan" id="kobo.838.2">It makes intended behavior of the code clear when reading it. </span><span class="koboSpan" id="kobo.838.3">Can we do something similar using templates? </span><span class="koboSpan" id="kobo.838.4">It turns out we can. </span><span class="koboSpan" id="kobo.838.5">We can use the </span><strong class="keyWord"><span class="koboSpan" id="kobo.839.1">curiously recurring template pattern</span></strong><span class="koboSpan" id="kobo.840.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.841.1">CRTP</span></strong><span class="koboSpan" id="kobo.842.1">) to implement compile-time subtype polymorphism.</span></p>
<h2 class="heading-2" id="_idParaDest-131"><span class="koboSpan" id="kobo.843.1">Curiously recurring template pattern (CRTP)</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.844.1">CRTP is a C++ idiom where the derived </span><a id="_idIndexMarker426"/><span class="koboSpan" id="kobo.845.1">class uses a template</span><a id="_idIndexMarker427"/><span class="koboSpan" id="kobo.846.1"> class instantiated with itself as a base class. </span><span class="koboSpan" id="kobo.846.2">Yes, it sounds confusing, so let’s jump into the code to better understand this:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.847.1">template</span></span><span class="koboSpan" id="kobo.848.1">&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.849.1">typename</span></span><span class="koboSpan" id="kobo.850.1"> U&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.851.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.852.1">uart_interface</span></span><span class="koboSpan" id="kobo.853.1"> {
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.854.1">public</span></span><span class="koboSpan" id="kobo.855.1">:
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.856.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.857.1">init</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.858.1">(std::</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.859.1">uint32_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.860.1"> baudrate = </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.861.1">9600</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.862.1">)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.863.1">{
       </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.864.1">static_cast</span></span><span class="koboSpan" id="kobo.865.1">&lt;U*&gt;(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.866.1">this</span></span><span class="koboSpan" id="kobo.867.1">)-&gt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.868.1">initImpl</span></span><span class="koboSpan" id="kobo.869.1">(baudrate);
    }
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.870.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.871.1">uart_stm32</span></span><span class="koboSpan" id="kobo.872.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.873.1">public</span></span><span class="koboSpan" id="kobo.874.1"> uart_interface&lt;uart_stm32&gt; {
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.875.1">public</span></span><span class="koboSpan" id="kobo.876.1">:
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.877.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.878.1">initImpl</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.879.1">(std::</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.880.1">uint32_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.881.1"> baudrate = </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.882.1">9600</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.883.1">)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.884.1">{
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.885.1">printf</span></span><span class="koboSpan" id="kobo.886.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.887.1">"uart_stm32::init: setting baudrate to %d\r\n"</span></span><span class="koboSpan" id="kobo.888.1">, baudrate);
    }
};
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.889.1">The preceding code implements CRTP. </span><span class="koboSpan" id="kobo.889.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.890.1">uart_stm32</span></code><span class="koboSpan" id="kobo.891.1"> derived class inherits from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.892.1">uart_interface</span></code><span class="koboSpan" id="kobo.893.1"> class template instantiated </span><a id="_idIndexMarker428"/><span class="koboSpan" id="kobo.894.1">with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.895.1">uart_stm32</span></code><span class="koboSpan" id="kobo.896.1"> class itself. </span><span class="koboSpan" id="kobo.896.2">The base class template exposes an interface</span><a id="_idIndexMarker429"/><span class="koboSpan" id="kobo.897.1"> from which it can access the derived class using </span><code class="inlineCode"><span class="koboSpan" id="kobo.898.1">static_cast</span></code><span class="koboSpan" id="kobo.899.1"> on </span><code class="inlineCode"><span class="koboSpan" id="kobo.900.1">this</span></code><span class="koboSpan" id="kobo.901.1"> (pointer to itself). </span><span class="koboSpan" id="kobo.901.2">It provides the </span><code class="inlineCode"><span class="koboSpan" id="kobo.902.1">init</span></code><span class="koboSpan" id="kobo.903.1"> method, which calls </span><code class="inlineCode"><span class="koboSpan" id="kobo.904.1">initImpl</span></code><span class="koboSpan" id="kobo.905.1"> on the object of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.906.1">uart_stm32</span></code><span class="koboSpan" id="kobo.907.1"> class.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.908.1">CRTP allows us to define our interface in the base class and implement it in a derived class, similar to the inheritance mechanism we are using for runtime polymorphism. </span><span class="koboSpan" id="kobo.908.2">The remaining part to ensure that this interface is used in </span><code class="inlineCode"><span class="koboSpan" id="kobo.909.1">gsm_lib</span></code><span class="koboSpan" id="kobo.910.1"> is to create type constraints using concepts, as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.911.1">template</span></span><span class="koboSpan" id="kobo.912.1">&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.913.1">typename</span></span><span class="koboSpan" id="kobo.914.1"> T&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.915.1">concept</span></span><span class="koboSpan" id="kobo.916.1"> TheUart = std::derived_from&lt;T, uart_interface&lt;T&gt;&gt;;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.917.1">The preceding code is a concept that we will use to restrain types accepted by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.918.1">gsm_lib</span></code><span class="koboSpan" id="kobo.919.1"> class template. </span><span class="koboSpan" id="kobo.919.2">It will accept only types that are derived from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.920.1">uart_interface</span></code><span class="koboSpan" id="kobo.921.1"> class template instantiated by that type itself. </span><span class="koboSpan" id="kobo.921.2">The following is the full code example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta"><span class="koboSpan" id="kobo.922.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.923.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.924.1">&lt;span&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.925.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.926.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.927.1">&lt;cstdio&gt;</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.928.1">#</span></span><span class="hljs-keyword"><span class="koboSpan" id="kobo.929.1">include</span></span><span class="hljs-meta"> </span><span class="hljs-string"><span class="koboSpan" id="kobo.930.1">&lt;cstdint&gt;</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.931.1">template</span></span><span class="koboSpan" id="kobo.932.1">&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.933.1">typename</span></span><span class="koboSpan" id="kobo.934.1"> U&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.935.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.936.1">uart_interface</span></span><span class="koboSpan" id="kobo.937.1"> {
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.938.1">public</span></span><span class="koboSpan" id="kobo.939.1">:
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.940.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.941.1">init</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.942.1">(std::</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.943.1">uint32_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.944.1"> baudrate = </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.945.1">9600</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.946.1">)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.947.1">{
       </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.948.1">static_cast</span></span><span class="koboSpan" id="kobo.949.1">&lt;U*&gt;(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.950.1">this</span></span><span class="koboSpan" id="kobo.951.1">)-&gt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.952.1">initImpl</span></span><span class="koboSpan" id="kobo.953.1">(baudrate);
    }
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.954.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.955.1">write</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.956.1">(std::span&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.957.1">const</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.958.1">char</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.959.1">&gt; data)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.960.1">{
       </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.961.1">static_cast</span></span><span class="koboSpan" id="kobo.962.1">&lt;U*&gt;(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.963.1">this</span></span><span class="koboSpan" id="kobo.964.1">)-&gt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.965.1">writeImpl</span></span><span class="koboSpan" id="kobo.966.1">(data);
    }
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.967.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.968.1">uart_stm32</span></span><span class="koboSpan" id="kobo.969.1"> : </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.970.1">public</span></span><span class="koboSpan" id="kobo.971.1"> uart_interface&lt;uart_stm32&gt; {
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.972.1">public</span></span><span class="koboSpan" id="kobo.973.1">:
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.974.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.975.1">initImpl</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.976.1">(std::</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.977.1">uint32_t</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.978.1"> baudrate = </span></span><span class="hljs-number"><span class="koboSpan" id="kobo.979.1">9600</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.980.1">)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.981.1">{
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.982.1">printf</span></span><span class="koboSpan" id="kobo.983.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.984.1">"uart_stm32::init: setting baudrate to %d\r\n"</span></span><span class="koboSpan" id="kobo.985.1">, baudrate);
    }
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.986.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.987.1">writeImpl</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.988.1">(std::span&lt;</span></span><span class="hljs-type"><span class="koboSpan" id="kobo.989.1">const</span></span><span class="hljs-params"> </span><span class="hljs-type"><span class="koboSpan" id="kobo.990.1">char</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.991.1">&gt; data)</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.992.1">{
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.993.1">printf</span></span><span class="koboSpan" id="kobo.994.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.995.1">"uart_stm32::write: "</span></span><span class="koboSpan" id="kobo.996.1">);
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.997.1">for</span></span><span class="koboSpan" id="kobo.998.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.999.1">auto</span></span><span class="koboSpan" id="kobo.1000.1"> ch: data) {
            </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1001.1">putc</span></span><span class="koboSpan" id="kobo.1002.1">(ch, stdout);
        }
    }
};
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1003.1">template</span></span><span class="koboSpan" id="kobo.1004.1">&lt;</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1005.1">typename</span></span><span class="koboSpan" id="kobo.1006.1"> T&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1007.1">concept</span></span><span class="koboSpan" id="kobo.1008.1"> TheUart = std::derived_from&lt;T, uart_interface&lt;T&gt;&gt;;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1009.1">template</span></span><span class="koboSpan" id="kobo.1010.1">&lt;TheUart T&gt;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1011.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1012.1">gsm_lib</span></span><span class="koboSpan" id="kobo.1013.1">{
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1014.1">public</span></span><span class="koboSpan" id="kobo.1015.1">:
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1016.1">gsm_lib</span></span><span class="koboSpan" id="kobo.1017.1">(T &amp;u) : </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1018.1">uart_</span></span><span class="koboSpan" id="kobo.1019.1">(u) {}
    </span><span class="hljs-type"><span class="koboSpan" id="kobo.1020.1">void</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1021.1">init</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1022.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1023.1">{
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1024.1">printf</span></span><span class="koboSpan" id="kobo.1025.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1026.1">"gsm_lib::init: sending AT command\r\n"</span></span><span class="koboSpan" id="kobo.1027.1">);
        uart_.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1028.1">write</span></span><span class="koboSpan" id="kobo.1029.1">(</span><span class="hljs-string"><span class="koboSpan" id="kobo.1030.1">"AT"</span></span><span class="koboSpan" id="kobo.1031.1">);
    }
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1032.1">private</span></span><span class="koboSpan" id="kobo.1033.1">:
    T &amp;uart_;
};
</span><span class="hljs-type"><span class="koboSpan" id="kobo.1034.1">int</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.1035.1">main</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1036.1">()</span></span><span class="hljs-function"> </span><span class="koboSpan" id="kobo.1037.1">{
    uart_stm32 uart_stm32_obj;
    uart_stm32_obj.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1038.1">init</span></span><span class="koboSpan" id="kobo.1039.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1040.1">115200</span></span><span class="koboSpan" id="kobo.1041.1">);
    </span><span class="hljs-function"><span class="koboSpan" id="kobo.1042.1">gsm_lib </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1043.1">gsm</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1044.1">(uart_stm32_obj)</span></span><span class="koboSpan" id="kobo.1045.1">;
    gsm.</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1046.1">init</span></span><span class="koboSpan" id="kobo.1047.1">();
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1048.1">return</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.1049.1">0</span></span><span class="koboSpan" id="kobo.1050.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1051.1">In the preceding code, we used CRTP to implement compile-time or static subtype polymorphism. </span><code class="inlineCode"><span class="koboSpan" id="kobo.1052.1">uart_stm32</span></code><span class="koboSpan" id="kobo.1053.1"> is a concrete class that depends on the interface defined by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1054.1">uart_interface</span></code><span class="koboSpan" id="kobo.1055.1"> class template. </span><span class="koboSpan" id="kobo.1055.2">We used</span><a id="_idIndexMarker430"/><span class="koboSpan" id="kobo.1056.1"> the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1057.1">TheUart</span></code><span class="koboSpan" id="kobo.1058.1"> concept to constrain high-level code in </span><code class="inlineCode"><span class="koboSpan" id="kobo.1059.1">gsm_lib</span></code><span class="koboSpan" id="kobo.1060.1"> on types derived</span><a id="_idIndexMarker431"/><span class="koboSpan" id="kobo.1061.1"> from </span><code class="inlineCode"><span class="koboSpan" id="kobo.1062.1">uart_interface</span></code><span class="koboSpan" id="kobo.1063.1">. </span><span class="koboSpan" id="kobo.1063.2">We achieved dependency inversion, and it is clearly defined thanks to CRTP and concepts.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1064.1">The major benefit of compile-time polymorphism over inheritance (runtime polymorphism) is static binding; that is, there are no virtual functions. </span><span class="koboSpan" id="kobo.1064.2">This comes at the price of template syntax, which may make the code harder to read and understand.</span></p>
<h1 class="heading-1" id="_idParaDest-132"><span class="koboSpan" id="kobo.1065.1">Summary</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1066.1">In this chapter, we covered template basics, template metaprogramming, concepts, and compile-time polymorphism. </span><span class="koboSpan" id="kobo.1066.2">While templates are an advanced topic that encompasses many deeper concepts, this chapter aims to serve as a solid starting point for new learners. </span><span class="koboSpan" id="kobo.1066.3">By understanding the fundamentals covered here, you should be well equipped to explore more complex aspects of templates and leverage their full potential in embedded systems programming.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1067.1">In the next chapter, we will discuss type safety in C++.</span></p>
</div>
</body></html>