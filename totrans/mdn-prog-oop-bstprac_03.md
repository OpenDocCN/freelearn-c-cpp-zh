# *第二章*

# 论文

## 对象是独立的程序

许多不同演示中贯穿的线索是对象是相互独立的计算机程序，它们通过发送和接收消息进行通信。通常，有一个“和”，但第二个子句差异很大。让我们忽略它，专注于第一个子句。

例如，在 Smalltalk-80 及其大多数后继者中，对象可以被描述为相互独立的计算机程序，它们通过发送和接收消息进行通信，并且是组织在树结构中的类的实例。这里第二部分，关于类的内容，通过减少隔离的范围削弱了第一部分。为什么要求消息的发送者和接收者都是类的实例，并且这两个类都是同一树结构的成员？这并不是必须的，所以让我们通过移除继承的约束来加强独立程序的概念。

一个具有这种隔离形式的面向对象编程环境的现有例子是 COM（是的，就是微软的**组件对象模型**，也就是**COM**）。当你收到一个对象时，你对其一无所知，只知道它响应在 **IUnknown**—[`docs.microsoft.com/en-us/windows/desktop/api/unknwn/nn-unknwn-iunknown`](https://docs.microsoft.com/en-us/windows/desktop/api/unknwn/nn-unknwn-iunknown) 接口中定义的消息，该接口允许你保持对对象的引用，放弃该引用，或找出它支持的其他接口。它没有告诉你该对象来自何处，是否从另一个对象继承，或者它是否对其每个方法都有新鲜、手工制作的、工匠般的实现。

你可以对 COM 对象和 Smalltalk 对象做出的一个推论是，它们存在于同一个进程中，也就是说，与发送消息的同一块内存和执行上下文。也许它们在内部通过某些 Smalltalk 对象将消息转发，其他对象则无法运行。

因此，虽然 Smalltalk 对象*近似*了独立计算机程序的概念，但这种近似并不精确。同时，在 Mach 上，发送者对对象唯一知道的是“端口”，这是一个内核可以使用它来确定正在被消息的对象的数字。对象可能位于不同的线程上，位于同一线程上，位于不同的进程中，或者（至少在理论上）位于不同的计算机上，向其发送消息的方式是相同的。接收者和发送者可能共享他们所有的代码，从共同的祖先继承，或者用不同的编程语言编写，在以不同方式存储数字的 CPU 上运行，但他们仍然可以向对方发送消息。

在`Smalltalk`（所有对象都是同一种对象，并且相互关联）和 Mach 之间，存在`MetaObject`的概念——[`wiki.c2.com/?MetaObjectProtocol`](http://wiki.c2.com/?MetaObjectProtocol)。由于软件系统中的对象定义了系统如何建模某些问题，元对象定义了软件系统如何表达其对象的行为。`MetaObject`协议暴露了改变系统内部*对象模型*含义的消息。

换句话说，一个`MetaObject`协议让程序员能够为程序的不同部分选择不同的编程环境规则。以方法查找为例：在第一部分，我们看到了原型继承、单继承和多继承各自的优点和缺点，以及它们对对象系统设计的不同约束。为什么不同时拥有所有这些继承工具——以及任何其他工具，以及其他形式的委托——呢？有了`MetaObject`协议，这是可能的。

## 独立对象的开放封闭特性

在他的书籍《面向对象软件构造》中，**伯特兰·迈耶**介绍了开放封闭原则。这个原则可能是所有计算中最容易混淆的观点之一，并导致了一个完整的子行业，包括文章和播客解释如何一个`ShapeRenderer`可以绘制`正方形`和`圆形`（当然，我也有参与其中，并将继续在这里讨论）。

开放封闭原则指出，一个模块（在我们的情况下是一个对象）应该对扩展开放——应该能够扩展其行为以适应新的目的——同时对其修改封闭——你不应该需要改变它。这个设计原则是有代价的，因为你需要设计你的对象以支持沿着尚未知的线路进行扩展（或者至少，要清楚地说明哪些线路是有益的，哪些不是），以换取维护者和对象使用者知道它们将是稳定的，并且不会通过意外的变化将破坏引入系统的好处。

上文探讨的对象特性，将它们视为完全独立的程序，通过保持每个对象与其他对象保持距离来支持开放封闭原则。它们唯一的接触点是它们的消息接口，甚至是对它们的父类（当然，记住它们可能没有任何父类）。

因此，为了保持开放和封闭，一个对象也需要无知：它应该尽可能少地了解其上下文。它知道在接收到消息时应该做什么，也知道何时发送消息，但应该在其他方面对周围发生的事情保持不知情。由于无法区分这些上下文，无知对象可以在多个上下文中使用——对其使用的扩展是开放的——这是因为它无法区分这些上下文。它不需要进行上下文更改，因此对修改是封闭的。

### 独立对象的正确性

当每个对象都是其自己的独立程序时，我们将“这个大系统是否工作”的问题转化为两个独立的问题：

+   这些独立的对象是否工作？

+   这些独立的对象是否正确地进行了通信？

这些问题在软件工程中，尤其是在面向对象编程（OOP）中，已经被反复解决。一个对象的消息接口在定义单元测试时，自然地构成了“这个单元”和“其他一切”之间的边界。Kent Beck 的测试驱动开发（TDD）方法通过询问自己希望向对象发送什么消息以及期望什么结果，从消息边界向内设计对象。这种方法通过将每个对象视为一个单独的系统来测试，回答了“这些独立的对象是否工作？”的问题。

以《通过测试引导的面向对象软件增长》一书为例的伦敦 TDD 学校，对消息边界作为系统边界的规则进行了极端解释，通过使用**模拟对象**——[`xunitpatterns.com/Mock%20Object.html`](http://xunitpatterns.com/Mock%20Object.html)作为被测试对象的全部协作者的替代品。*这个*对象（被测试的对象）需要向*那个*对象（某个协作者）发送消息，但没有理由了解关于那个对象的其他信息，除了它将响应这个消息。通过这种方式，伦敦学校推崇的上述无知被用来支持**开放-封闭原则**。

在 Eiffel 编程语言中，Bertrand Meyer 通过允许开发者将一个*契约*与每个类关联起来，也解决了每个对象是否工作的问题。这个契约基于 Edsger Dijkstra 和其他人使用数学归纳法来证明关于程序陈述的工作，使用对象的消息接口作为程序的自然外部边界。契约解释了在处理给定消息之前对象需要什么条件为真（前置条件），对象在其方法执行后将安排什么条件为真（后置条件），以及当对象不执行方法时始终为真的条件（不变性）。然后，当对象被使用时，这些契约作为检查运行，与仅使用测试作者最初考虑的输入和输出的单元测试不同。

契约在传统的软件开发方法中以有限的方式出现，形式为基于属性的测试——[`blog.jessitron.com/2013/04/property-based-testing-what-is-it.html`](http://blog.jessitron.com/2013/04/property-based-testing-what-is-it.html)，体现在 Haskell 的 **QuickCheck**、Scala 的 **ScalaCheck** 和其他工具中。在 Eiffel 中，契约是正在构建的系统的一部分，并描述了对象与其他对象结合时应该如何使用。基于属性的测试通过将契约作为测试占卜师，从而作为测试对象的外部验证器，使用契约来构建任何数量的自动化测试。一个契约可能说“如果你提供一个包含具有唯一标识符的电子邮件消息的列表，这个方法将返回一个包含相同消息的列表，按发送日期排序，如果日期相同，则按标识符排序”。一个基于属性的测试可能说“对于所有具有唯一标识符的电子邮件消息列表，调用此方法的输出结果...”。开发者可能生成一百或一千个这样的测试，作为他们发布流程的一部分，检查是否存在反例。

问题的第二部分——这些独立对象是否正确地进行了通信？——也可以用多种方式来处理。在像 Eiffel 这样的契约世界中，这是通过确保在每个对象向协作者发送消息的点，满足该协作者的先决条件来解决的。对于其他人，则有集成测试。

如果单元测试报告了一个单一对象的行为，那么集成测试就是任何包含多个对象的组件的测试。借用布拉德·科克斯的软件集成电路隐喻，单元测试告诉你芯片是否工作，集成测试告诉你电路是否工作。集成测试的一个特殊情况是系统测试，它集成了解决某些特定问题所需的所有对象：它告诉你整个板是否按预期工作。

## 独立对象的 设计

在这里讨论设计是合适的，因为测试和设计活动是紧密相关的。Eric Evans 的书籍**领域驱动设计**讨论了一种之前被称为面向对象分析的形式：通过解释问题的描述来找到解决问题所需的对象。这个过程很简单。取一个问题的描述，执行动作的“事物”是对象，它们执行的“动作”是方法，它们告诉或询问其他事物的“事物”是消息。Evans 建议在整个开发团队中有一个单一的“普遍”语言，这样拥有问题的**目标提供者**[`wiki.c2.com/?GoalDonor`](http://wiki.c2.com/?GoalDonor)所使用的词汇与构建解决方案的人所使用的词汇相同。借鉴 Christopher Alexander 的想法，这是问题域和解决方案域的普遍语言，在其中可以期望找到一种模式语言，因为问题的常见方面以类似的方式得到解决。

**行为驱动开发**将**测试驱动开发**的技术流程与普遍语言的构思设计相结合，通过鼓励开发者与其他团队成员协作，用普遍语言定义期望的行为陈述，并使用这些陈述来驱动解决方案领域中对象的开发和实现。这样，目标提供者所需的目标陈述也是充分性和正确性的陈述——也就是说，需要解决的问题的描述也是有效解决方案的描述。这种方式最终看起来足够自洽，以至于不会令人感到惊讶。

## 构建独立对象

这篇文章贯穿的主题是充分性足够。当一个对象被识别为解决问题的一部分，并且对解决方案的贡献达到所需程度（即使现在这个程度是“证明解决方案是可行的”），那么它就准备好使用了。没有必要将对象定位在继承类别的分类中，但如果这样做有助于解决问题，那么就尽一切可能去做。没有必要证明各种对象表现出严格的子类型关系并且可以互换使用，除非解决问题需要它们可以互换使用。没有必要让对象将其数据提供给程序的其他部分，除非这样做可以更好地解决问题（或者更便宜地解决问题，或者其他可取的性质）。

我之前对**开放封闭原则**做了很多讨论，它建议我们构建的对象应该是“开放于修改”。这难道不是意味着预测系统将如何变化，并使对象能够以这种方式灵活变化吗？

在某种程度上，是的，而且确实这种考虑是有价值的。如果你的问题是确定在你的当地台球馆中台球手在台上的时间应该如何收费，那么你的解决方案确实可能在同一个馆的台球桌上或在不同的台球馆中使用。但哪个会先发生？会很快发生吗？这些问题需要与目标捐赠者和**黄金所有者**（[`wiki.c2.com/?GoldOwner`](http://wiki.c2.com/?GoldOwner)，为解决方案付费的人）一起回答。现在解决这个相关问题值得付费吗？

无论答案如何，事实是，一旦它们解决了“你现在遇到的问题”，这些对象就可以随时开始工作。而且，无论如何，还有其他方法来解决相关的问题，这些方法不需要“未来证明”对象设计以预测它们可能被用于哪些用途。也许你的`SnookerTable`并不适用于扩展表示台球桌，但你的解决方案中的其他对象可以代替向`PoolPlayer`发送消息。正如开放-封闭原则的变体所显示的，这些其他对象可能对在桌面上进行的游戏一无所知。

无论计划是否最终实现，一定的规划总是有帮助的。在每个转折点，我们的目标应该是理解我们如何从“我们现在拥有的”达到“我们现在想要的”，而不是“已经拥有”我们可能将来想要的东西。也许最容易的事情就是从头开始：所以，就这样做。

## 与独立对象协同工作

传统的编写和更改软件的方式导致了持续部署，这是一种自动化从编写源代码到在实时环境中部署生产实体的管道的原则，目标是减少更改通过管道所需的时间，同时保持高质量。

**Pharo**（[`pharo.org/`](https://pharo.org/)）、**SqueakJS**（[`squeak.js.org/run/#url=https://freudenbergs.de/bert/squeakjs&zip=[Squeak5.0-15113.zip,SqueakV50.sources.zip`](https://squeak.js.org/run/#url=https://freudenbergs.de/bert/squeakjs&zip=[Squeak5.0-15113.zip,SqueakV50.sources.zip)）或甚至以它们有限的方式**Swift Playgrounds**（[`www.apple.com/swift/playgrounds/`](https://www.apple.com/swift/playgrounds/)）和**Project Jupyter**（[`jupyter.org/`](https://jupyter.org/)）都表明，这个管道可以是零长度的，并且软件可以直接在预期的环境中编写。测试失败的结果不需要是 Jenkins 提供的日志文件，必须仔细阅读以在“本地开发”中假设一个修复方案，它可以是纠正运行在实时环境中的程序的机会，并继续（或，在最坏的情况下，重新启动）失败的操作。

这种活跃性属性不仅限于类似 Smalltalk 的环境或 REPLs。考虑 Mach 微内核操作系统；任何注册到名称服务器（或者在 HURD 的情况下，作为文件系统上的翻译器）的服务器都是一个“活对象”，它可以接收来自系统其余部分的消息并参与其行为。它们也是可以检查、调试、更改、重新启动或替换的任务。

由微服务组成的服务器应用程序具有类似属性。“对象”（服务的运行实例）通过 URL 找到彼此：任何配置为在给定路由接收 HTTP 请求的服务“响应”消息。这些服务中的每一个都可以独立检查、调试、编辑或替换。

## 第二部分结论

当移除了额外的复杂性和试图采用传统的软件开发技术时，面向对象编程（Object-Oriented Programming）试图通过一组小型、独立的程序来表示复杂问题，每个程序都模拟问题的一个（更简单）方面。这些程序可以独立编写、验证、部署、更改和使用。理想情况下，它们应尽可能地对彼此一无所知，仅依赖于它们应该响应某些消息并且可以向其他对象发送其他消息的知识。
