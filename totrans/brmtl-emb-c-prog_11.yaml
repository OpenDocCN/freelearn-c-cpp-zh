- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Analog-to-Digital Converter (ADC)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn about the **analog-to-digital converter** (**ADC**),
    an important peripheral in embedded systems that enables the microcontroller to
    interface with the analog world. We will start by providing an overview of the
    analog-to-digital conversion process, the importance of the ADC, and its key specifications.
  prefs: []
  type: TYPE_NORMAL
- en: Following this, we will extract and analyze the relevant registers from the
    STM32F411 reference manual that are necessary for ADC operations. Finally, we
    will develop a bare-metal ADC driver to demonstrate the practical application
    of the theoretical concepts we’ve discussed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of analog-to-digital conversion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The STM32F4 ADC peripheral
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The key ADC registers and flags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing the ADC driver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a comprehensive understanding of the
    STM32 ADC peripheral and the skills necessary to develop efficient drivers for
    it, enabling you to effectively integrate analog-to-digital conversion capabilities
    into your embedded systems projects.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming](https://github.com/PacktPublishing/Bare-Metal-Embedded-C-Programming).
  prefs: []
  type: TYPE_NORMAL
- en: Overview of analog-to-digital conversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ADC is a critical process in embedded systems that allows our microcontrollers
    to interpret and process real-world analog signals. In this section, we will walk
    through this process, explaining each step involved in converting an analog signal
    into digital values.
  prefs: []
  type: TYPE_NORMAL
- en: What is analog-to-digital conversion?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Analog-to-digital conversion is the process of converting a continuous analog
    signal into a discrete digital representation. Analog signals, which can have
    any value within a certain range, are transformed into digital signals, which
    have specific, quantized levels. This conversion is essential because microcontrollers
    and digital systems can only process digital data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The conversion process typically involves several key steps: sampling, quantization,
    and encoding. Let’s break down these steps, starting with sampling.'
  prefs: []
  type: TYPE_NORMAL
- en: Sampling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Sampling** involves measuring the amplitude of an analog signal at regular
    intervals, called **sampling intervals**. The result is a series of discrete values
    that approximate the original analog signal. *Figure 11**.1* depicts this process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1: The sampling process](img/B21914_11_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.1: The sampling process'
  prefs: []
  type: TYPE_NORMAL
- en: The rate at which the analog signal is sampled is known as the **sampling rate**
    or **sampling frequency**. This is typically measured in samples per second (Hz).
    According to the **Nyquist Theorem**, the sampling rate must be at least twice
    the highest frequency present in the analog signal to accurately reconstruct the
    original signal.
  prefs: []
  type: TYPE_NORMAL
- en: The next step in the process is quantization.
  prefs: []
  type: TYPE_NORMAL
- en: Quantization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Quantization** is the process of mapping the sampled analog values to the
    nearest discrete levels available in the digital domain. Each discrete level corresponds
    to a unique digital code.'
  prefs: []
  type: TYPE_NORMAL
- en: The number of discrete levels available for quantization is determined by the
    resolution of the analog-to-digital converter. For example, an *8-bit ADC has
    256 levels (28)*, while a *12-bit ADC has 4096* *levels (212)*.
  prefs: []
  type: TYPE_NORMAL
- en: The quantization process inherently introduces an error, known as **quantization
    error** or **quantization noise**, because the exact analog value is approximated
    to the nearest digital level. We can minimize this error by increasing the resolution
    of the ADC. For example, if an analog signal ranges *from 0 to 3.3V* and an *8-bit
    ADC* is used, the quantization step size is approximately *12.9 mV (3.3V / 256)*.
    An analog input of *1.5V* might be quantized to the closest digital level, which
    could be slightly higher or lower than *1.5V*.
  prefs: []
  type: TYPE_NORMAL
- en: The final step in the process is encoding.
  prefs: []
  type: TYPE_NORMAL
- en: Encoding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Encoding** is the final step and is where the quantized levels are converted
    into a binary code that can be processed by the digital system. Each quantized
    level is represented by a unique binary value.'
  prefs: []
  type: TYPE_NORMAL
- en: The number of bits used in the ADC determines the binary code length. For example,
    a *10-bit* ADC will produce a *10-bit* binary number for each sampled value. Continuing
    with our previous example, if the quantized level for *1.5V* is determined to
    be level *116*, the binary representation would be *01110100* for an *8-bit* ADC.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 11**.2* shows the encoding process of a *6-bit ADC*. The columns in
    the table show the 6-bit binary representation of the quantization levels. For
    a 6-bit ADC, the digital output ranges from `000000` for the lowest quantization
    level to `111111` for the highest. Each binary value corresponds to a specific
    quantization level:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2: The encoding process](img/B21914_11_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.2: The encoding process'
  prefs: []
  type: TYPE_NORMAL
- en: In summary, the analog-to-digital conversion process begins with an analog input
    signal, which can vary continuously over time. This signal could be a voltage
    from a temperature sensor, an audio signal, or any other analog signal. The analog-to-digital
    converter typically includes a sample-and-hold circuit that captures and holds
    the analog signal at each sampling interval. This ensures that the signal remains
    constant during the conversion process. The core of the ADC performs quantization
    and encoding. It compares the held analog value to a set of reference voltages
    to determine the closest matching digital level. The resulting digital code is
    output from the ADC and can be read by our microcontroller or digital system for
    further processing.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explain some of the key terms that were used in
    this section, including resolution and **reference** **voltage** (**VREF**).
  prefs: []
  type: TYPE_NORMAL
- en: Key specifications of the ADC – resolution, step size, and VREF
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To effectively use ADCs, it’s important to understand their key specifications,
    which define their performance for various applications. Let’s start with resolution.
  prefs: []
  type: TYPE_NORMAL
- en: Resolution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The resolution of an ADC determines the number of distinct output levels it
    can produce, corresponding to the number of intervals the input voltage range
    is divided into. It is typically expressed in bits. Higher resolution allows us
    to have a more precise representation of the analog input signal, reducing quantization
    error and improving the accuracy of measurements.
  prefs: []
  type: TYPE_NORMAL
- en: For an *N-bit* ADC, the number of discrete output levels is *2N*. For example,
    an *8-bit* ADC has *256(28)* levels, while a *12-bit* ADC has *4,096* levels.
  prefs: []
  type: TYPE_NORMAL
- en: '*Table 11.1* shows common ADC resolutions and their corresponding number of
    discrete levels. The following table highlights how the number of discrete levels
    increases exponentially with the resolution, providing finer granularity in the
    digital representation of the analog input signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **ADC** **Resolution (bits)** | **Number of Discrete** **Levels (2^N)** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | 256 |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | 1,024 |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | 4,096 |'
  prefs: []
  type: TYPE_TB
- en: '| 14 | 16,384 |'
  prefs: []
  type: TYPE_TB
- en: '| 16 | 65,536 |'
  prefs: []
  type: TYPE_TB
- en: '| 18 | 262,144 |'
  prefs: []
  type: TYPE_TB
- en: '| 20 | 1,048,576 |'
  prefs: []
  type: TYPE_TB
- en: '| 24 | 16,777,216 |'
  prefs: []
  type: TYPE_TB
- en: 'Table 11.1: Common ADC resolutions'
  prefs: []
  type: TYPE_NORMAL
- en: The next key specification is the **VREF**.
  prefs: []
  type: TYPE_NORMAL
- en: VREF
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The VREF is the maximum voltage that our ADC can convert. The analog input voltage
    is compared to this VREF to produce a digital value. The stability and accuracy
    of the VREF directly impact the accuracy of the ADC as any fluctuations in the
    VREF can cause corresponding errors in the digital output.
  prefs: []
  type: TYPE_NORMAL
- en: We can choose to derive the VREF from the microcontroller or provide an external
    one for more precise applications. Internal references are convenient but might
    have higher variability, while external references can offer better stability
    and accuracy. The choice of VREF depends on our application’s accuracy requirements
    and the nature of the analog signal being measured.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if the VREF is 5V, the ADC can accurately convert any analog input
    signal within the range of 0V to 5V.
  prefs: []
  type: TYPE_NORMAL
- en: The last specification we’ll examine is the step size.
  prefs: []
  type: TYPE_NORMAL
- en: Step size
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The step size is the smallest change in analog input that can be distinguished
    by the ADC. It is determined by the VRED and the resolution and it determines
    the granularity of the ADC’s output. A smaller step size indicates finer resolution,
    allowing the ADC to detect smaller changes in the input signal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The step size is calculated by *dividing the VREF by 2 raised to the power
    of the ADC’s resolution* (number of bits):'
  prefs: []
  type: TYPE_NORMAL
- en: '![<math  display="block"><mrow><mrow><mi>S</mi><mi>t</mi><mi>e</mi><mi>p</mi><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo>=</mo><mfrac><mrow><mi>V</mi><mi>R</mi><mi>E</mi><mi>F</mi></mrow><msup><mn>2</mn><mi
    mathvariant="normal">N</mi></msup></mfrac></mrow></mrow></math>](img/4.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, *VREF* is the reference voltage and *N* is the resolution bits.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, for a 10-bit ADC with VREF = 3.3V:'
  prefs: []
  type: TYPE_NORMAL
- en: '![<math  display="block"><mrow><mrow><mi>S</mi><mi>t</mi><mi>e</mi><mi>p</mi><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo>=</mo><mfrac><mrow><mn>3.3</mn><mi>V</mi></mrow><msup><mn>2</mn><mn>10</mn></msup></mfrac><mo>=</mo><mfrac><mrow><mn>3.3</mn><mi>V</mi></mrow><mn>1024</mn></mfrac><mo>=</mo><mn>3.22</mn><mi>m</mi><mi>V</mi></mrow></mrow></math>](img/5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This means that each increment in the quantized digital output corresponds
    to a *3.22mV* change in the analog input. *Table 11.2* lists common ADC resolutions,
    the corresponding number of steps, and the step size using a VREF of 3.3V:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **ADC** **Resolution (Bits)** | **Number of** **Steps (2^N)** | **Step**
    **Size (mV)** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | 256 | 12.9 |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | 1,024 | 3.22 |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | 4,096 | 0.805 |'
  prefs: []
  type: TYPE_TB
- en: '| 14 | 16,384 | 0.201 |'
  prefs: []
  type: TYPE_TB
- en: '| 16 | 65,536 | 0.0504 |'
  prefs: []
  type: TYPE_TB
- en: '| 18 | 262,144 | 0.0126 |'
  prefs: []
  type: TYPE_TB
- en: '| 20 | 1,048,576 | 0.0032 |'
  prefs: []
  type: TYPE_TB
- en: '| 24 | 16,777,216 | 0.000197 |'
  prefs: []
  type: TYPE_TB
- en: 'Table 11.2: ADC resolutions and step sizes at 3.3V VREF'
  prefs: []
  type: TYPE_NORMAL
- en: This table provides a clear view of how the step size decreases with increasing
    resolution, allowing for finer granularity in the digital representation of the
    analog input.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our overview of the analog-to-digital conversion process. In
    the next section, we will examine the ADC peripheral of our STM32 microcontroller.
  prefs: []
  type: TYPE_NORMAL
- en: The STM32F4 ADC peripheral
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our STM32F411 microcontroller features a 12-bit ADC capable of measuring signals
    from up to *19 multiplexed channels*. The ADC can operate in various modes, such
    as single, continuous, scan, or discontinuous, with the results stored in *a 16-bit
    data register*. Additionally, the ADC has an analog watchdog feature that allows
    the system to detect when the input voltage exceeds predefined thresholds.
  prefs: []
  type: TYPE_NORMAL
- en: Before we explain the various ADC modes, let’s understand what we mean by ADC
    channels.
  prefs: []
  type: TYPE_NORMAL
- en: The ADC channels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An **ADC channel** is a dedicated pathway through which an analog signal is
    fed into the ADC so that it can be converted into a digital value. Each ADC channel
    corresponds to a specific GPIO pin configured to operate in analog mode.
  prefs: []
  type: TYPE_NORMAL
- en: Sensors, which produce analog signals representing physical phenomena (such
    as temperature, light, or pressure), are interfaced with our microcontroller through
    these GPIO pins. By configuring a GPIO pin as an analog input, the microcontroller
    can receive the sensor’s analog output signal on the corresponding ADC channel.
    The ADC then converts this continuous analog signal into a discrete digital representation
    that the microcontroller can process, analyze, and use for further decision-making
    tasks in our embedded systems applications.
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering, does having 19 channels mean we have 19 separate ADC
    modules? This is where multiplexing comes into play.
  prefs: []
  type: TYPE_NORMAL
- en: Multiplexing ADC channels
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Multiplexing** allows the ADC to switch between different input signals,
    sampling each one sequentially. This is achieved using an analog multiplexer (MUX)
    within the ADC peripheral. As we learned earlier, each of the ADC channels is
    connected to a specific GPIO pin configured for analog input. The analog MUX selects
    which analog input signal (from the GPIO pins or internal sources) is connected
    to the ADC’s sampling circuitry at any given time. This selection is controlled
    by the ADC’s configuration registers.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 11**.3* shows the ADC channels’ connection to the analog multiplexor
    within the ADC peripheral block:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3: ADC channel multiplexing](img/B21914_11_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.3: ADC channel multiplexing'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s examine the available ADC modes.
  prefs: []
  type: TYPE_NORMAL
- en: The ADC modes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ADC in our STM32F411 microcontroller can operate in several modes, each
    tailored to specific application requirements. The primary modes of operation
    include single conversion mode, continuous conversion mode, scan mode, discontinuous
    mode, and injected conversion mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s break them down:'
  prefs: []
  type: TYPE_NORMAL
- en: '`0` in the `ADC_CR2` register.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Example use case*: Reading the value from a temperature sensor at specific
    intervals.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`1` in the `ADC_CR2` register.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Example Use Case*: Continuously monitoring a potentiometer to track its position
    in real time.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ADC_CR1` register and then configuring the sequence of channels in the `ADC_SQRx`
    registers. If the `ADC_CR2`, the sequence restarts after the last channel is converted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Example use case*: Sampling multiple sensor inputs in a data acquisition system.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ADC_CR1` register and then defining the number of channels to convert in each
    group by setting the `ADC_CR1` register.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Example use case*: Reducing the sampling rate for a subset of channels in
    a multi-channel system.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ADC_JSQR` register, and then starting the conversion by setting the `ADC_CR2`
    register or via an external trigger.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Example use case*: Prioritizing critical cell voltage measurements in a **battery
    management system** (**BMS**) during rapid charging or discharging.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Before exploring the common ADC registers, let’s understand the two types of
    channels available in the STM32F411 microcontroller.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding regular channels versus injected channels in STM32F411 ADC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the STM32F411 microcontroller, the ADC offers a versatile approach to handling
    multiple analog inputs through two main types of channels: regular channels and
    injected channels. Regular channels are configured for routine, sequential conversions,
    ideal for periodic data acquisition from sensors where timing is not extremely
    critical. These channels follow a predefined sequence set by the `ADC_SQRx` registers
    and can be triggered by software or external events.'
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, injected channels, such as those configured in injected conversion
    mode, are designed for *high-priority*, *time-sensitive tasks*, interrupting the
    regular sequence to perform immediate conversions when specific conditions are
    met. This makes injected channels perfect for capturing critical measurements
    with precise timing, such as motor current sensing in control applications. Additionally,
    the ADC includes an *Analog Watchdog feature*, which can monitor both regular
    and injected channels for values that exceed predefined thresholds, generating
    interrupts to handle out-of-range conditions. This dual-channel capability, combined
    with the Analog Watchdog, provides a robust framework for diverse applications,
    from routine environmental monitoring to critical real-time data processing and
    safety monitoring.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will examine the key registers of the ADC peripheral
    and some of the flags associated with the ADC operations.
  prefs: []
  type: TYPE_NORMAL
- en: The key ADC registers and flags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will explore the characteristics and functions of some of
    the crucial registers within the ADC peripheral.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with ADC Control Register 1 (`ADC_CR1`).
  prefs: []
  type: TYPE_NORMAL
- en: ADC Control Register 1 (ADC_CR1)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is one of the main control registers that’s used to configure the ADC’s
    operational settings. It provides various configuration options, such as resolution,
    scan mode, discontinuous mode, and interrupt enable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the key bits in this register:'
  prefs: []
  type: TYPE_NORMAL
- en: '**RES[1:0]** (**resolution bits**): These bits set the resolution of the ADC
    (12-bit, 10-bit, 8-bit, or 6-bit)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SCAN** (**scan mode**): Setting this bit enables scan mode, allowing the
    ADC to convert multiple channels in sequence'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DISCEN** (**discontinuous mode**): When set, this bit enables discontinuous
    mode on regular channels'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AWDEN** (**Analog Watchdog enable**): This bit enables the Analog Watchdog
    on all regular channels'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EOCIE** (**end of conversion interrupt enable**): When set, this bit allows
    an interrupt to be generated when the EOC flag is set'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find detailed information about this register on page 229 of the STM32F411
    reference manual (RM0383).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have ADC Control Register 2 (`ADC_CR2`).
  prefs: []
  type: TYPE_NORMAL
- en: ADC Control Register 2 (ADC_CR2)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is another crucial control register that handles different aspects of ADC
    operation, including the start of conversion, data alignment, and external triggers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the key bits in this register:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ADON** (**ADC on**): This bit turns the ADC on or off'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CONT** (**continuous conversion**): Setting this bit enables continuous conversion
    mode'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SWSTART** (**start conversion of regular channels**): Setting this bit starts
    the conversion of regular channels'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ALIGN** (**data alignment**): This bit sets the alignment of the converted
    data (right or left)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EXTEN[1:0]**: This is an external trigger that enables polarity selection
    for regular channels'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further information about this register can be found on page 231 of the reference
    manual.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on to the ADC Regular Sequence Register (`ADC_SQRx`).
  prefs: []
  type: TYPE_NORMAL
- en: ADC Regular Sequence Register (ADC_SQRx)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ADC_SQRx` registers define the sequence in which the ADC converts the channels.
    There are multiple SQR registers to handle the sequence for up to 16 regular channels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the key bits in this register:'
  prefs: []
  type: TYPE_NORMAL
- en: '**L[3:0]**: Regular channel sequence length. These bits set the total number
    of conversions in the regular sequence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SQ1-SQ16**: Regular channel sequence. These bits specify the order of the
    channels to be converted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can read more about this register on page 235 of the reference. The next
    crucial register is the ADC Data Register (`ADC_DR`)
  prefs: []
  type: TYPE_NORMAL
- en: ADC Data Register (ADC_DR)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ADC_DR` register holds the result of the conversion. This is where the
    digital representation of the analog input is stored after the conversion is complete.
    The register is read-only and the data is stored in the lower 16 bits of the register.
  prefs: []
  type: TYPE_NORMAL
- en: The final register we will examine is the ADC Status Register (`ADC_SR`).
  prefs: []
  type: TYPE_NORMAL
- en: ADC Status Register (ADC_SR)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This register holds various status flags that indicate the state of the ADC.
    These flags are essential for monitoring the ADC’s operation and handling interrupts.
    We’ll examine these flags in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The key ADC flags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ADC flags are status indicators that inform the system about the state of the
    ADC operations. These flags are essential for monitoring the ADC’s progress, handling
    interrupts, and managing errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key ADC flags in the STM32F411 are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ADC_SR` register at bit position 1 (EOC) and is set by hardware when a regular
    conversion finishes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `ADC_CR1` register is set, the EOC flag can trigger an interrupt. In
    this case, an interrupt service routine can be triggered to process the converted
    data.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ADC_SR` register at bit position 2 (`ADC_CR1` register.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ADC_SR` register at bit position 0 (`ADC_CR1` register.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ADC_SR` register at bit position 5 (`ADC_CR1` register.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Start conversion (STRT) flag**: The **STRT** flag indicates that an ADC conversion
    has started. We can use this flag to verify that the ADC has initiated a conversion
    process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding and effectively using ADC flags is crucial for managing ADC operations
    in our STM32 microcontroller. Flags such as EOC, JEOC, AWD, OVR, and STRT provide
    essential information about the status of conversions, data integrity, and threshold
    monitoring. By leveraging these flags, we can enhance the reliability and functionality
    of our ADC implementations, ensuring accurate and timely data acquisition and
    processing in our embedded systems projects.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will apply the information we’ve learned to develop
    an ADC driver for reading analog sensor values.
  prefs: []
  type: TYPE_NORMAL
- en: Developing the ADC driver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will apply everything we have learned about the ADC peripheral
    to develop a driver for reading sensor values from a sensor connected to one of
    the ADC channels.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the GPIO pins for the ADC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s begin by identifying the GPIO pins connected to the ADC channels. To
    do this, refer to the table on *page 39* of the *STM32F411RE datasheet*. This
    table lists all the GPIO pins of the microcontroller, along with their descriptions
    and additional functionalities. As shown in *Figure 11**.4*, part of this table
    reveals that `ADC1_IN1`. This indicates that **PA1** is connected to ADC1, **channel
    1**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4: Pin definitions](img/B21914_11_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.4: Pin definitions'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s configure **PA1** so that it functions as an ADC pin.
  prefs: []
  type: TYPE_NORMAL
- en: First, create a copy of your previous project in your IDE, following the steps
    outlined in earlier chapters. Rename this copied project to `ADC`. Next, create
    a new file named `adc.c` in the `Src` folder and another file named `adc.h` in
    the `Inc` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Populate your `adc.c` file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break down the source code, starting with the macro definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break down the macros:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GPIOAEN`: This macro enables the clock for GPIOA by setting bit 0 in the `AHB1ENR`
    register'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ADC1EN`: This enables the clock for ADC1 by setting bit 8 in the `APB2ENR`
    register'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ADC_CH1`: This selects channel 1 for the ADC conversion in the `SQR3` register'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ADC_SEQ_LEN_1`: This sets the conversion sequence length to 1 in the `SQR1`
    register'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CR2_ADCON`: This enables the ADC module by setting bit 0 in the `CR2` register'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CR2_CONT`: This enables continuous conversion mode by setting bit 1 in the
    `CR2` register'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CR2_SWSTART`: This starts the ADC conversion by setting bit 30 in the `CR2`
    register'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SR_EOC`: This macro waits for the end of conversion by reading bit 1 in the
    **status** **register** (**SR**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, we must analyze the configuration sequence of the GPIO pin that’s used
    for ADC functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This line enables the clock for `GPIOA` by setting the appropriate bit in the
    `AHB1ENR` register using the **GPIOAEN** macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: These lines configure `GPIOA_MODER` register.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s move on to the part of the code that configures the ADC parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This line enables the clock for ADC1 by setting the appropriate bit in the `APB2ENR`
    register using the **ADC1EN** macro.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This line sets channel 1 as the start of the conversion sequence in the `ADC_SQR3`
    register using the **ADC_CH1** macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This line sets the sequence length to 1 in the `ADC_SQR1` register using the
    **ADC_SEQ_LEN_1** macro, meaning only one channel will be converted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This line enables the ADC module by setting the `ADC_CR2` register.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can start the conversion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This line enables continuous conversion mode by setting the `ADC_CR2` register
    using the **CR2_CONT** macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This line starts the ADC conversion by setting the `ADC_CR2` register using
    the **CR2_SWSTART** macro.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we must wait for the results to be ready:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This line waits until the conversion is complete by checking the `ADC_SR` register:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This line reads the converted digital value from the `ADC_DR` register.
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, our code performs the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Initializes the ADC** **GPIO pin**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enables the clock for GPIOA
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets PA1 to analog mode
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configures the** **ADC module**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enables the clock for ADC1
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets channel 1 as the start of the conversion sequence
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets the conversion sequence’s length to 1
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Enables the ADC module
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Starts the ADC** **conversion process**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enables continuous conversion mode
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Starts the ADC conversion process
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reads the** **ADC value**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Waits for the conversion to complete
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Reads the converted value from the ADC data register
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our next task is to populate the `adc.h` file. Here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '#include <stdio.h>'
  prefs: []
  type: TYPE_NORMAL
- en: '#include "adc.h"'
  prefs: []
  type: TYPE_NORMAL
- en: '#include "uart.h"'
  prefs: []
  type: TYPE_NORMAL
- en: int sensor_value;
  prefs: []
  type: TYPE_NORMAL
- en: int main(void)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: /*Initialize debug UART*/
  prefs: []
  type: TYPE_NORMAL
- en: uart_init();
  prefs: []
  type: TYPE_NORMAL
- en: /*Initialize ADC*/
  prefs: []
  type: TYPE_NORMAL
- en: pa1_adc_init();
  prefs: []
  type: TYPE_NORMAL
- en: /*Start conversion*/
  prefs: []
  type: TYPE_NORMAL
- en: start_conversion();
  prefs: []
  type: TYPE_NORMAL
- en: while(1)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: sensor_value = adc_read();
  prefs: []
  type: TYPE_NORMAL
- en: 'printf("Sensor Value: %d\r\n",sensor_value);'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '#include <stdio.h>'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '#include "adc.h"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '#include "uart.h"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: int sensor_value;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: /* Initialize debug UART */
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: uart_init();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: /* Initialize ADC */
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: pa1_adc_init();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: /* Start conversion */
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: start_conversion();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: sensor_value = adc_read();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'printf("Sensor Value: %d\r\n", sensor_value);'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
