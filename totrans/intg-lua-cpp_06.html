<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-133"><a id="_idTextAnchor135"/>6</h1>
<h1 id="_idParaDest-134"><a id="_idTextAnchor136"/>How to Call C++ from Lua</h1>
<p>In the previous three chapters, we focused on learning how to call Lua from C++. In this chapter, we will start to learn how to<a id="_idIndexMarker277"/> call C++ from Lua. This is important for your applications because although Lua scripts can extend your C++ applications, they can also benefit from the functions provided by your native C++ code.</p>
<p>This also means we will learn more concepts and piece different things together to make it work. Although the chapters are laid out in a way that they extend the previous chapter in a seamless flow, you may need a different pace to absorb the new concepts. Do read the sections more times if you need practice with coding.</p>
<p>We will cover the following topics:</p>
<ul>
<li>How to register C++ functions</li>
<li>How to override Lua library functions</li>
<li>How to register C++ modules</li>
</ul>
<h1 id="_idParaDest-135"><a id="_idTextAnchor137"/>Technical requirements</h1>
<p>Here are the technical requirements for this chapter:</p>
<ul>
<li>You can access the source code for this chapter at <a href="https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter06">https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter06</a><a href="https://github.com/PacktPublishing/Integrate-Lua-to-CPP/tree/main/Chapter06%0D"/></li>
<li>Based on the learnings from the last chapter, you should now be confident in adding code to our Lua executor</li>
</ul>
<p>This chapter will introduce many new concepts and Lua library APIs. You can cross-check the Lua reference manual online to reinforce the learning: <a href="https://www.lua.org/manual/5.4/">https://www.lua.org/manual/5.4/</a>.</p>
<h1 id="_idParaDest-136"><a id="_idTextAnchor138"/>How to register C++ functions</h1>
<p>Lua is <a id="_idIndexMarker278"/>written in C, so it cannot access your C++ classes directly. The only way to call C++ code from Lua is to make it call C++ functions – that is, plain C functions.</p>
<h2 id="_idParaDest-137"><a id="_idTextAnchor139"/>How to declare C++ functions for Lua</h2>
<p>To <a id="_idIndexMarker279"/>register a function to Lua, it must conform to the following prototype:</p>
<pre class="source-code">
typedef int (*lua_CFunction) (lua_State *L);</pre>
<p>The function receives only one argument, which is a Lua state. It needs to return an integer value indicating how many return values it produces. The Lua state is private to the function call, and its stack holds the arguments passed from the Lua code when calling the C++ function. The C++ function needs to push its return values onto the stack.</p>
<p>We will first implement a simple function and export it to Lua. Then, we’ll see more complex examples to understand more.</p>
<h2 id="_idParaDest-138"><a id="_idTextAnchor140"/>Implementing your first C++ function for Lua</h2>
<p>Let us add<a id="_idIndexMarker280"/> a simple but useful capability to our Lua executor. It will provide a function to check its version code so that the Lua code it executes can query it. In <code>LuaExecutor.cc</code>, right below the <code>#include</code> directives, add the following function implementation that conforms to <code>lua_CFunction</code>:</p>
<pre class="source-code">
namespace
{
    int luaGetExecutorVersionCode(lua_State *L)
    {
        lua_pushinteger(L, LuaExecutor::versionCode);
        return 1;
    }
}</pre>
<p>The function pushes a <code>LuaExecutor::versionCode</code> integer constant to its private stack and returns <code>1</code> to indicate that it returns one value. We can define this constant in <code>LuaExecutor.h</code> as follows:</p>
<pre class="source-code">
class LuaExecutor
{
public:
    static const int versionCode = 6;
};</pre>
<p>We will use the value <code>6</code> for <em class="italic">Chapter 6</em>.</p>
<p>You may <a id="_idIndexMarker281"/>have noticed that the function is inside an anonymous namespace. This is to make sure that it cannot be accessed outside the file of <code>LuaExecutor.cc</code>. This also helps with logical code grouping.</p>
<p>Next, let us make this function available to Lua.</p>
<h2 id="_idParaDest-139"><a id="_idTextAnchor141"/>How to register C++ functions to Lua</h2>
<p>There are a<a id="_idIndexMarker282"/> few ways to register C++ functions to Lua. We will look at the simplest way here to register a C++ function in the Lua global table. Later in this chapter when learning C++ modules, we will learn a more proper way to register C++ functions in their own table. You already know how to do this from <em class="italic">Chapter 3</em>. I only need to point it out with the following code, which you should add to the same anonymous namespace you have just written:</p>
<pre class="source-code">
namespace
{
    void registerHostFunctions(lua_State *L)
    {
        lua_pushcfunction(L, luaGetExecutorVersionCode);
        lua_setglobal(L, "host_version");
    }
}</pre>
<p>Yes—we simply need to set it as a Lua global variable! We use <code>lua_pushcfunction</code> to push the <code>lua_CFunction</code> type onto the stack. Then, we assign it to a global variable named <code>host_version</code>.</p>
<p>Using a <a id="_idIndexMarker283"/>global variable for the host executor version sounds very reasonable. But you should not abuse Lua global variables by using them too much. Now, let us try it out.</p>
<h2 id="_idParaDest-140"><a id="_idTextAnchor142"/>Testing it out</h2>
<p>We need <a id="_idIndexMarker284"/>to modify three places to test our progress so far. You can start your work with the <code>begin</code> folder from the source code of this chapter.</p>
<p>Call <code>registerHostFunctions</code> from the constructor of our Lua executor, as follows:</p>
<pre class="source-code">
LuaExecutor::LuaExecutor(...)
{
    ...
    registerHostFunctions(L);
}</pre>
<p>This registers our function to Lua.</p>
<p>Replace the content of <code>script.lua</code> as follows:</p>
<pre class="source-code">
print("Host version is " .. host_version())</pre>
<p>This calls our C++ function from Lua and prints out the result.</p>
<p>Replace the content of <code>main.cpp</code> with the following test code:</p>
<pre class="source-code">
#include "LuaExecutor.h"
#include "LoggingLuaExecutorListener.h"
int main()
{
    auto listener = std::make_unique&lt;
        LoggingLuaExecutorListener&gt;();
    auto lua = std::make_unique&lt;LuaExecutor&gt;(*listener);
    lua-&gt;executeFile("script.lua");
    return 0;
}</pre>
<p>This <a id="_idIndexMarker285"/>resets the test code to simply create a Lua executor and runs <code>scripts.lua</code>. Run the project, and if you have done everything correctly, you should see the following output:</p>
<pre class="source-code">
Host version is 6</pre>
<p>Congratulations! You have called your first C++ function from Lua code. Based on this learning, let us find out how to override Lua library functions.</p>
<h1 id="_idParaDest-141"><a id="_idTextAnchor143"/>How to override Lua library functions</h1>
<p>Why <a id="_idIndexMarker286"/>would you want to override Lua library functions? First, it helps to learn more about calling C++ functions from Lua in a progressive way, before moving on to C++ modules. Second, but more importantly, it is a frequent requirement for real-life projects.</p>
<p>Suppose you are working on a game where assets are packed inside a private archive and your Lua scripts need to access them. Overriding the Lua <code>io</code> and <code>file</code> libraries can provide a seamless experience for your fellow Lua developers and enforce security at the same time. You can make sure Lua scripts can only access assets you want them to, but nothing else on the host filesystem. This is even more important when your users can change the Lua scripts.</p>
<p>Let us implement a more trivial case. We use the Lua <code>print</code> function to output debug information. We want to merge the Lua debug output with C++ output so that we get all our logs in the same place ordered by the time they are printed.</p>
<h2 id="_idParaDest-142"><a id="_idTextAnchor144"/>Reimplementing the Lua print function</h2>
<p>Because the<a id="_idIndexMarker287"/> Lua <code>print</code> function takes a variable number of arguments, we need to take this into consideration in our implementation. In <code>LuaExecutor.cc</code>, below the namespace from the previous section, add <em class="italic">another</em> namespace as follows:</p>
<pre class="source-code">
namespace
{
    int luaPrintOverride(lua_State *L)
    {
        int nArgs = lua_gettop(L);
        std::cout &lt;&lt; "[Lua]";
        for (int i = 1; i &lt;= nArgs; i++)
        {
            std::cout &lt;&lt; " "
                      &lt;&lt; luaL_tolstring(L, i, NULL);
        }
        std::cout &lt;&lt; std::endl;
        return 0;
    }
}</pre>
<p>The <code>luaPrintOverride</code> C++ function <a id="_idIndexMarker288"/>would eventually get <a id="_idIndexMarker289"/>called when you invoke the <code>print</code> function in Lua. It takes <code>lua_State</code> as a single argument, whose associated Lua stack is used to pass the real arguments from the Lua call site. To understand what is happening, see the following diagram:</p>
<div><div><img alt="Figure 6.1 – Overriding the Lua print function" height="503" src="img/B20927_06_01.jpg" width="1112"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – Overriding the Lua print function</p>
<p>The<a id="_idIndexMarker290"/> Lua <code>print</code> function will push its arguments onto the private Lua stack for the call. The C++ function first checks the number of arguments the Lua call site has passed with <code>lua_gettop</code>. Then, it prints out <code>"[Lua]"</code>to indicate that the print comes from Lua instead of C++. Next, it loops through each argument and prints them out, separated by a space. Finally, it returns <code>0</code> to tell the Lua library that it has no value to return to the call site.</p>
<p class="callout-heading">To reinforce</p>
<p class="callout">The Lua state and the Lua stack for each <code>lua_CFunction</code> call are private to the call. So, everything in the stack is made up of the arguments passed from the Lua call site. You do not need to remove them from the stack before pushing your return values because you are already telling the Lua library how many values are pushed onto the stack as the C++ function return value.</p>
<p>Next, let us see how we can override the Lua <code>print</code> function with the C++ version we just implemented.</p>
<h2 id="_idParaDest-143"><a id="_idTextAnchor145"/>Overriding the Lua print function</h2>
<p>Here, we <a id="_idIndexMarker291"/>will first look at the code and then delve into our explanation of it. In the same anonymous namespace, add the following function:</p>
<pre class="source-code">
namespace
{
    void overrideLuaFunctions(lua_State *L)
    {
        const struct luaL_Reg overrides[] = {
            {"print", luaPrintOverride},
            {NULL, NULL}};
        lua_getglobal(L, "_G");
        luaL_setfuncs(L, overrides, 0);
        lua_pop(L, 1);
    }
}</pre>
<p>The process of <a id="_idIndexMarker292"/>overriding library functions includes the following:</p>
<ul>
<li>Getting the library table</li>
<li>Reassigning the functions of interest to your new implementations</li>
</ul>
<p>Each line of the code is doing the following:</p>
<ul>
<li>It defines an array of <code>luaL_Reg</code>, which is a structure representing a name and <code>lua_CFunction</code> pair. We set the name as <code>"print"</code>, the same as the function name we want to override. We set the function as our new implementation. The last entry in the array must be <code>{NULL, NULL}</code> to mark the end of the definition.</li>
<li>It gets the <code>_G</code> Lua table onto the stack, because the <code>print</code> function is a global variable and the <code>_G</code> table holds all global variables.</li>
<li>It sets our list of functions from <em class="italic">step 1</em> to the <code>_G</code> table with <code>luaL_setfuncs</code>. You can ignore the last parameter for now; we will learn about it in the next section.</li>
<li>It pops the <code>_G</code> table<a id="_idIndexMarker293"/> from the stack to maintain a balanced stack.</li>
<li>Additionally, <code>luaL_Reg</code> is defined in the Lua library as follows:</li>
</ul>
<pre class="source-code">
typedef struct luaL_Reg {
    const char *name;
    lua_CFunction func;
} luaL_Reg;</pre>
<p>Overriding the Lua library functions is really as simple as reassigning some table keys to different values! Now, let us see if it works.</p>
<h2 id="_idParaDest-144"><a id="_idTextAnchor146"/>Testing it out</h2>
<p>Similar to the <a id="_idIndexMarker294"/>previous section, call <code>overrideLuaFunctions</code> from the constructor of our Lua executor, as follows:</p>
<pre class="source-code">
LuaExecutor::LuaExecutor(...)
{
    ...
    overrideLuaFunctions(L);
}</pre>
<p>You do not need to change anything else. With the same <code>main.cpp</code> and <code>script.lua</code> files, run the project. If you have followed everything correctly, you should see the following output:</p>
<pre class="source-code">
[Lua] Host version is 6</pre>
<p>There is now a <code>[Lua]</code> prefix in the output, proving it is printed from our C++ override, not the Lua library function.</p>
<p>Next, let us learn about C++ modules, which is the preferred way to add your C++ functionalities to Lua.</p>
<h1 id="_idParaDest-145"><a id="_idTextAnchor147"/>How to register C++ modules</h1>
<p>In this<a id="_idIndexMarker295"/> section, we will export a C++ class instance to Lua. You probably have used or even implemented Lua modules before, the ones that the Lua interpreter can find and load automatically and return via Lua’s <code>require</code> function. Here, the focus is integrating Lua into C++, and in such use cases, things are initiated from a C++ executor to benefit from the rest of your C++ application. So, there is a difference if you have used standalone Lua modules before.</p>
<p>In the previous chapter, we implemented a Lua class called <code>Destinations</code> to keep track of places we want to go. Let us reimplement it in C++ so that we can export it to Lua.</p>
<h2 id="_idParaDest-146"><a id="_idTextAnchor148"/>Implementing a C++ class</h2>
<p>Create<a id="_idIndexMarker296"/> two source files, <code>Destinations.h</code> and <code>Destinations.cc</code>. Remember to add <code>Destinations.cc</code> to the <code>Makefile</code>. Write the header file as follows:</p>
<pre class="source-code">
#ifndef _DESTINATIONS_H
#define _DESTINATIONS_H
#include &lt;map&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
class Destinations
{
public:
    Destinations(const std::string &amp;name);
    void wish(const std::vector&lt;std::string&gt; &amp;places);
    void went(const std::vector&lt;std::string&gt; &amp;places);
    std::vector&lt;std::string&gt; listVisited() const;
    std::vector&lt;std::string&gt; listUnvisited() const;
private:
    std::string name;
    std::map&lt;std::string, bool&gt; wishlist;
};
#endif // _DESTINATIONS_H</pre>
<p>We<a id="_idIndexMarker297"/> use a <code>map</code> variable to keep a list of places and whether we have visited them and have a <code>name</code> member variable to identify the instance. The member functions are named and work the same as the Lua version, as follows:</p>
<ul>
<li><code>wish</code> adds a list of places to the wish list as <code>unvisited</code></li>
<li><code>went</code> marks a list of places as <code>visited</code></li>
<li><code>listVisited</code> returns visited places</li>
<li><code>listUnvisited</code> returns unvisited places</li>
</ul>
<p>Now, let us implement the member functions in <code>Destinations.cc</code>. They are plain C++ functions without using any Lua features. So, we will just list the code without much explanation. First, let us implement the constructor:</p>
<pre class="source-code">
#include "Destinations.h"
Destinations::Destinations(const std::string &amp;name)
    : name(name), wishlist({}) {}</pre>
<p>This initializes the <code>wishlist</code> as an empty map.</p>
<p>Then, write the <code>wish</code> function as follows:</p>
<pre class="source-code">
void Destinations::wish(
    const std::vector&lt;std::string&gt; &amp;places)
{
    for (const auto &amp;place : places)
    {
        wishlist[place] = false;
    }
}</pre>
<p>Then, implement<a id="_idIndexMarker298"/> the <code>went</code> function as follows:</p>
<pre class="source-code">
void Destinations::went(
    const std::vector&lt;std::string&gt; &amp;places)
{
    for (const auto &amp;place : places)
    {
        wishlist[place] = true;
    }
}</pre>
<p>The <code>wish</code> function and the <code>went</code> function are quite similar and mark places as visited or unvisited.</p>
<p>Finally, implement the query functions. Write the <code>listVisited</code> function as follows:</p>
<pre class="source-code">
std::vector&lt;std::string&gt;
Destinations::listVisited() const
{
    std::vector&lt;std::string&gt; results;
    for (const auto &amp;[place, visited] : wishlist)
    {
        if (visited)
        {
            results.push_back(place);
        }
    }
    return results;
}</pre>
<p>Then, write<a id="_idIndexMarker299"/> the <code>listUnvisited</code> function as follows:</p>
<pre class="source-code">
std::vector&lt;std::string&gt;
Destinations::listUnvisited() const
{
    std::vector&lt;std::string&gt; results;
    for (const auto &amp;[place, visited] : wishlist)
    {
        if (not visited)
        {
            results.push_back(place);
        }
    }
    return results;
}</pre>
<p>With a C++ class ready, our next task is to export it to Lua.</p>
<h2 id="_idParaDest-147"><a id="_idTextAnchor149"/>What to export to Lua</h2>
<p>Exporting <a id="_idIndexMarker300"/>a C++ class to Lua is really exporting its instances to Lua. Sometimes, only one instance is exported and the C++ class works as a utility library, similar to the Lua <code>string</code> library. Sometimes, many instances are exported and Lua extends C++’s <strong class="bold">object-oriented </strong><strong class="bold">programming</strong> (<strong class="bold">OOP</strong>).</p>
<p>It is important to note that no matter how many instances you want to export, the process is the same. When overriding Lua library functions, we retrieve an existing table and set some of its functions to our implementation. To export a C++ class instance, similarly, we need to do the following:</p>
<ul>
<li>Create a new table</li>
<li>Add the functions we want to export to the table</li>
</ul>
<p>If you recall that we can only export functions of the <code>lua_CFunction</code> prototype to Lua, you will clearly see that we cannot export our public member functions to Lua directly. We need some wrapper functions. Let us first write some stubs. Below the <code>#include</code> directives in <code>Destinations.cc</code>, add the following code:</p>
<pre class="source-code">
namespace
{
int luaWish(lua_State *L) { return 0; }
int luaWent(lua_State *L) { return 0; }
int luaListVisited(lua_State *L) { return 0; }
int luaListUnvisited(lua_State *L) { return 0; }
const std::vector&lt;luaL_Reg&gt; REGS = {
    {"wish", luaWish},
    {"went", luaWent},
    {"list_visited", luaListVisited},
    {"list_unvisited", luaListUnvisited},
    {NULL, NULL}};
}</pre>
<p>We defined four wrapper functions of the <code>lua_CFunction</code> prototype and a list of <code>luaL_Reg</code> instances. We<a id="_idIndexMarker301"/> are using <code>vector</code> instead of <code>array</code> because in C++ we prefer vectors unless we have to use an array.</p>
<p>Next, let us design a reusable mechanism to export our wrappers to Lua.</p>
<h2 id="_idParaDest-148"><a id="_idTextAnchor150"/>Designing a reusable exporting mechanism</h2>
<p>There <a id="_idIndexMarker302"/>are many ways to do this. We choose a way to work with our Lua executor and let it register our C++ modules. First, let us define an abstract class to represent C++ modules. Create a new file named <code>LuaModule.h</code> and write its content as follows:</p>
<pre class="source-code">
#ifndef _LUA_MODULE_H
#define _LUA_MODULE_H
#include &lt;lua.hpp&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
class LuaModule
{
public:
    virtual const std::string &amp;luaName()
        const override = 0;
    virtual const std::vector&lt;luaL_Reg&gt; &amp;luaRegs()
        const overrode = 0;
    virtual ~LuaModule() = default;
};
#endif // _LUA_MODULE_H</pre>
<p>The <code>LuaModule</code> abstract class defines two abstract methods to provide data needed to <a id="_idIndexMarker303"/>register a C++ module to Lua. <code>luaName</code> returns a name for the module instance; we will use it as the Lua table name. <code>luaRegs</code> returns a list of functions to be exported along with their names in Lua.</p>
<p>Let us extend our <code>Destinations</code> C++ class to conform to this protocol. Change its declaration as follows:</p>
<pre class="source-code">
class Destinations : public LuaModule
{
public:
    ...
    const std::string &amp;luaName() const;
    const std::vector&lt;luaL_Reg&gt; &amp;luaRegs() const;
    ...
};</pre>
<p>After this, add the following implementation to <code>Destinations.cc</code>:</p>
<pre class="source-code">
const std::string &amp;
Destinations::luaName() const
{
    return name;
}
const std::vector&lt;luaL_Reg&gt; &amp;
Destinations::luaRegs() const
{
    return REGS;
}</pre>
<p>The code simply returns the instance name as <code>luaName</code> and the <code>REGS</code> we just defined for our stubs as <code>luaRegs</code>.</p>
<p>Now<a id="_idIndexMarker304"/> comes the time to finally register our C++ class to Lua. In <code>LuaExecutor.h</code>, add a function declaration as follows:</p>
<pre class="source-code">
class LuaExecutor
{
public:
    void registerModule(LuaModule &amp;module);
};</pre>
<p>The <code>registerModule</code> function registers an instance of <code>LuaModule</code> to the Lua state that the executor holds.</p>
<p>Next, implement it in <code>LuaExecutor.cc</code>:</p>
<pre class="source-code">
void LuaExecutor::registerModule(LuaModule &amp;module)
{
    lua_createtable(L, 0, module.luaRegs().size() - 1);
    luaL_setfuncs(L, module.luaRegs().data(), 0);
    lua_setglobal(L, module.luaName().c_str());
}</pre>
<p>This needs some explanation. Let us explore what each line of the code here is doing in sequence:</p>
<ol>
<li>It creates a table with <code>lua_createtable</code>. This library function will push the table onto the stack. The second parameter hints at how many elements in the table will be used as a sequence. We have none, so we pass <code>0</code>. The third parameter hints at how many elements in the table will be used as a map. All our functions are used this way, so we pass the count of our vector minus the ending marker. The hints help with memory allocation in Lua, as Lua will be responsible for creating a properly sized table to avoid unnecessary reallocations to increase the capacity of the table later.</li>
<li>It sets<a id="_idIndexMarker305"/> our functions to the table with <code>luaL_setfuncs</code>. This works exactly the same as when we overrode Lua library functions. Ignore the third parameter for now as well. <code>module.luaRegs().data()</code> returns our function list as an array instead of a vector. <code>std::vector::data</code> is a C++ feature.</li>
<li>It assigns the table just created to a global variable using the name returned from <code>module.luaName()</code>. From now on, our C++ module can be accessed from this table.</li>
</ol>
<p>Exporting a C++ module to Lua may sound heavy and glorious. But there is actually not much gluing code involved. Compare what we have just done with overriding Lua library functions. Take a moment, then we will test our mechanism to see if it works.</p>
<h2 id="_idParaDest-149"><a id="_idTextAnchor151"/>Testing our mechanism</h2>
<p>Add a<a id="_idIndexMarker306"/> few lines of code to <code>main.cpp</code> so that it looks like this:</p>
<pre class="source-code">
#include "LuaExecutor.h"
#include "LoggingLuaExecutorListener.h"
#include "Destinations.h"
int main()
{
    auto listener = std::make_unique&lt;
       LoggingLuaExecutorListener&gt;();
    auto lua = std::make_unique&lt;LuaExecutor&gt;(*listener);
    auto wishlist = std::make_unique&lt;Destinations&gt;(
        "destinations");
    lua-&gt;registerModule(*wishlist.get());
    lua-&gt;executeFile("script.lua");
    return 0;
}</pre>
<p>We <a id="_idIndexMarker307"/>create an instance of the <code>Destinations</code> class and give it the name <code>"destinations"</code>. Then, we register it with our Lua executor.</p>
<p>Now, add the following code to <code>script.lua</code>:</p>
<pre class="source-code">
destinations.wish("London", "Paris", "Amsterdam")
destinations.went("Paris")
print("Visited:", destinations.list_visited())
print("Unvisited:", destinations.list_unvisited())</pre>
<p>This is doing the following:</p>
<ol>
<li>It adds London, Paris, and Amsterdam to the wish list.</li>
<li>It marks Paris as visited.</li>
<li>It prints the visited cities.</li>
<li>It prints the unvisited cities.</li>
</ol>
<p>Run the project, and if you have followed all the steps correctly, you should see the following output:</p>
<pre class="source-code">
[Lua] Visited:
[Lua] Unvisited:</pre>
<p>There should be no errors, and since our wrapper functions are only stubs, it will not return anything <a id="_idIndexMarker308"/>useful. Hence, this is how we laid out the architectural foundation. Next, we will focus our efforts on making it work at the ground level.</p>
<h2 id="_idParaDest-150"><a id="_idTextAnchor152"/>Accessing the C++ class instance</h2>
<p>Our <a id="_idIndexMarker309"/>wrapper functions are of type <code>lua_CFunction</code>. They <a id="_idIndexMarker310"/>are essentially C++ static methods not associated with any class. How can we access the correct class instance? We must do some bookkeeping.</p>
<p>Luckily, Lua provides a mechanism to keep data for the registered C++ functions. It is called an <strong class="bold">upvalue</strong>. Upvalues <a id="_idIndexMarker311"/>can only be accessed by the associated function in C/C++ code and are shared across different function calls. We can save the pointer to the class instance in an upvalue.</p>
<p>Why is it called an upvalue? At this stage, it is easier to understand when not explained, in the same spirit as why a variable is called a variable.</p>
<p class="callout-heading">Have you noticed?</p>
<p class="callout">From the previous description, an upvalue behaves like a C++ static variable in the function scope. Then, why do we use an upvalue instead of a static variable? Because an upvalue is associated with a C++ function in the Lua library. This way, we can use the same C++ function with different upvalues.</p>
<p>Which Lua data type can be used to save a C++ pointer? We can use <strong class="bold">userdata</strong>. This type is used to<a id="_idIndexMarker312"/> store arbitrary C/C++ data. Especially, for our case, we need to <a id="_idIndexMarker313"/>use <strong class="bold">light userdata</strong>, whose purpose is to store a C/C++ pointer. It is a perfect match for us.</p>
<p>In conclusion, we need to save the class instance’s <code>this</code> pointer as <em class="italic">light userdata</em> in an <em class="italic">upvalue</em> for the <code>lua_CFunction</code> implementation.</p>
<p>Here, we have involved two new Lua concepts. They are exclusively used to work with C/C++ code, so chances are that you are not very familiar with them from Lua programming. Let us see the code in action to help with the understanding.</p>
<h3>How to provide upvalues</h3>
<p>We <a id="_idIndexMarker314"/>will only look at the case for registering C++ modules. So far, we have ignored the third parameter to <code>luaL_setfuncs</code> and always passed <code>0</code>.</p>
<p>What does this third parameter mean? It is the count for the upvalues that will be available to all functions in the list provided in the second parameter.</p>
<p>How do you provide upvalues? Of course—you push them onto the stack!</p>
<p>Let us rewrite the function to register C++ modules as follows:</p>
<pre class="source-code">
void LuaExecutor::registerModule(LuaModule &amp;module)
{
    lua_createtable(L, 0, module.luaRegs().size() - 1);
    int nUpvalues = module.pushLuaUpvalues(L);
    luaL_setfuncs(L, module.luaRegs().data(), nUpvalues);
    lua_setglobal(L, module.luaName().c_str());
}</pre>
<p>There are only two changes. First, we want another function yet to be implemented in <code>LuaModule</code> to push upvalues onto the stack and return to us how many upvalues have been pushed. Then, we pass the upvalue count as the third parameter to <code>luaL_setfuncs</code>.</p>
<p>Remember to add <code>pushLuaUpvalues</code> to <code>LuaModule.h</code>, like so:</p>
<pre class="source-code">
class LuaModule
{
public:
    virtual int pushLuaUpvalues(lua_State *L)
    {
        lua_pushlightuserdata(L, this);
        return 1;
    }
};</pre>
<p>We have provided a default implementation that pushes <code>this</code> as an upvalue. In derived classes, they can override this function and<a id="_idIndexMarker315"/> push more upvalues.</p>
<p>Next, let us see how we can access this upvalue.</p>
<h3>How to access upvalues</h3>
<p>Lua upvalues <a id="_idIndexMarker316"/>are accessed as if they were in the stack, while they are not really in the stack. So, a magic stack index, <code>LUA_REGISTRYINDEX</code>, is used to mark the start of the upvalue pseudo-region. Lua provides a <code>lua_upvalueindex</code> macro to locate the indices of your upvalues, so you do not really need to deal with this magic number.</p>
<p>This is how we can access our C++ class instance stored as an upvalue. In <code>Destinations.cc</code>, add the following function to the anonymous namespace:</p>
<pre class="source-code">
namespace
{
    inline Destinations *getObj(lua_State *L)
    {
        return reinterpret_cast&lt;Destinations *&gt;(
            lua_touserdata(L, lua_upvalueindex(1)));
    }
}</pre>
<p>We can use this helper function to get a pointer to the instance. It uses <code>lua_touserdata</code> to get our light userdata from the stack with the pseudo-index. This helper will be called from the stubs we registered.</p>
<p class="callout-heading">To reinforce</p>
<p class="callout">The Lua state and stack passed to a <code>lua_CFunction</code> function are private to each call to that function.</p>
<p>Now that we <a id="_idIndexMarker317"/>have figured out how to access the class instance, we can complete our stubs.</p>
<h2 id="_idParaDest-151"><a id="_idTextAnchor153"/>Completing our stubs</h2>
<p>Write <code>luaWish</code> as <a id="_idIndexMarker318"/>follows:</p>
<pre class="source-code">
int luaWish(lua_State *L)
{
    Destinations *obj = getObj(L);
    std::vector&lt;std::string&gt; places;
    int nArgs = lua_gettop(L);
    for (int i = 1; i &lt;= nArgs; i++)
    {
        places.push_back(lua_tostring(L, i));
    }
    obj-&gt;wish(places);
    return 0;
}</pre>
<p>It first gets the class instance with the <code>getObj</code> helper function we just implemented. Then, it puts all arguments from the Lua call site into a vector. Finally, it calls the real object method, <code>obj-&gt;wish</code>. This is what a wrapper does – it routes the call to the real object.</p>
<p>The code for <code>luaWent</code> is similar, as we can see here:</p>
<pre class="source-code">
int luaWent(lua_State *L)
{
    Destinations *obj = getObj(L);
    std::vector&lt;std::string&gt; places;
    int nArgs = lua_gettop(L);
    for (int i = 1; i &lt;= nArgs; i++)
    {
        places.push_back(lua_tostring(L, i));
    }
    obj-&gt;went(places);
    return 0;
}</pre>
<p>The <a id="_idIndexMarker319"/>only difference is that it calls <code>obj-&gt;went</code> instead.</p>
<p>Finally, implement the query functions as follows:</p>
<pre class="source-code">
int luaListVisited(lua_State *L)
{
    Destinations *obj = getObj(L);
    auto places = obj-&gt;listVisited();
    for (const auto &amp;place : places)
    {
        lua_pushstring(L, place.c_str());
    }
    return places.size();
}
int luaListUnvisited(lua_State *L)
{
    Destinations *obj = getObj(L);
    auto places = obj-&gt;listUnvisited();
    for (const auto &amp;place : places)
    {
        lua_pushstring(L, place.c_str());
    }
    return places.size();
}</pre>
<p>These <a id="_idIndexMarker320"/>functions use the object functions to get a list of places and then push the list onto the stack to return the results to the Lua call site.</p>
<p>Now, we have implemented everything, and we can test it.</p>
<h2 id="_idParaDest-152"><a id="_idTextAnchor154"/>Testing it out</h2>
<p>We do not <a id="_idIndexMarker321"/>need to modify any test code because we have already used the functions to test our stubs. Now, recompile and run the project.</p>
<p>Recall that the Lua test code looks like this:</p>
<pre class="source-code">
destinations.wish("London", "Paris", "Amsterdam")
destinations.went("Paris")
print("Visited:", destinations.list_visited())
print("Unvisited:", destinations.list_unvisited())</pre>
<p>If you have done everything correctly, you should see the following output:</p>
<pre class="source-code">
[Lua] Visited: Paris
[Lua] Unvisited: Amsterdam London</pre>
<p>Congratulations on making it work!</p>
<p>This chapter is quite a change of mindset from the previous chapters. Take a moment to reflect if you need to.</p>
<h1 id="_idParaDest-153"><a id="_idTextAnchor155"/>Summary</h1>
<p>In this chapter, we learned how to call C++ code from Lua. We first learned how to register a simple C++ function to Lua. All registered functions must conform to <code>lua_CFunction</code>. Then, we found out how to override Lua library functions. Finally, we implemented a C++ class and exported it to Lua. We also came across the concepts of <em class="italic">upvalue</em> and <em class="italic">light userdata</em> along the way.</p>
<p>In the next chapter, we will continue our journey with more details on user-defined data in C++ and more data-exchanging mechanisms.</p>
<h1 id="_idParaDest-154"><a id="_idTextAnchor156"/>Exercises</h1>
<ol>
<li>In the <code>Destinations</code> class, we only used one upvalue. Add another upvalue and play around with it. Which upvalue is at which pseudo-index?</li>
<li>Try to modify the second upvalue in a function and see if the value is persisted the next time the function is called. How about when it is accessed in another function?</li>
<li>In <code>LuaType.hpp</code>, add <code>LuaType::lightuserdata</code> and implement a structure for it, named <code>LuaLightUserData</code>. Support this case in the executor and helper functions. You do not need to support this type when popping values from the Lua stack.</li>
</ol>
</div>
</div></body></html>