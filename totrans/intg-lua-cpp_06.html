<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer048">
<h1 class="chapter-number" id="_idParaDest-133"><a id="_idTextAnchor135"/>6</h1>
<h1 id="_idParaDest-134"><a id="_idTextAnchor136"/>How to Call C++ from Lua</h1>
<p>In the previous three chapters, we focused on learning how to call Lua from C++. In this chapter, we will start to learn how to<a id="_idIndexMarker277"/> call C++ from Lua. This is important for your applications because although Lua scripts can extend your C++ applications, they can also benefit from the functions provided by your native <span class="No-Break">C++ code.</span></p>
<p>This also means we will learn more concepts and piece different things together to make it work. Although the chapters are laid out in a way that they extend the previous chapter in a seamless flow, you may need a different pace to absorb the new concepts. Do read the sections more times if you need practice <span class="No-Break">with coding.</span></p>
<p>We will cover the <span class="No-Break">following topics:</span></p>
<ul>
<li>How to register <span class="No-Break">C++ functions</span></li>
<li>How to override Lua <span class="No-Break">library functions</span></li>
<li>How to register <span class="No-Break">C++ modules</span></li>
</ul>
<h1 id="_idParaDest-135"><a id="_idTextAnchor137"/>Technical requirements</h1>
<p>Here are the technical requirements for <span class="No-Break">this chapter:</span></p>
<ul>
<li>You can access the source code for this chapter <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter06"><span class="No-Break">https://github.com/PacktPublishing/Integrate-Lua-with-CPP/tree/main/Chapter06</span></a><a href="https://github.com/PacktPublishing/Integrate-Lua-to-CPP/tree/main/Chapter06%0D"/></li>
<li>Based on the learnings from the last chapter, you should now be confident in adding code to our <span class="No-Break">Lua executor</span></li>
</ul>
<p>This chapter will introduce many new concepts and Lua library APIs. You can cross-check the Lua reference manual online to reinforce the <span class="No-Break">learning: </span><a href="https://www.lua.org/manual/5.4/"><span class="No-Break">https://www.lua.org/manual/5.4/</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-136"><a id="_idTextAnchor138"/>How to register C++ functions</h1>
<p>Lua is <a id="_idIndexMarker278"/>written in C, so it cannot access your C++ classes directly. The only way to call C++ code from Lua is to make it call C++ functions – that is, plain <span class="No-Break">C functions.</span></p>
<h2 id="_idParaDest-137"><a id="_idTextAnchor139"/>How to declare C++ functions for Lua</h2>
<p>To <a id="_idIndexMarker279"/>register a function to Lua, it must conform to the <span class="No-Break">following prototype:</span></p>
<pre class="source-code">
typedef int (*lua_CFunction) (lua_State *L);</pre>
<p>The function receives only one argument, which is a Lua state. It needs to return an integer value indicating how many return values it produces. The Lua state is private to the function call, and its stack holds the arguments passed from the Lua code when calling the C++ function. The C++ function needs to push its return values onto <span class="No-Break">the stack.</span></p>
<p>We will first implement a simple function and export it to Lua. Then, we’ll see more complex examples to <span class="No-Break">understand more.</span></p>
<h2 id="_idParaDest-138"><a id="_idTextAnchor140"/>Implementing your first C++ function for Lua</h2>
<p>Let us add<a id="_idIndexMarker280"/> a simple but useful capability to our Lua executor. It will provide a function to check its version code so that the Lua code it executes can query it. In <strong class="source-inline">LuaExecutor.cc</strong>, right below the <strong class="source-inline">#include</strong> directives, add the following function implementation that conforms <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">lua_CFunction</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
namespace
{
    int luaGetExecutorVersionCode(lua_State *L)
    {
        lua_pushinteger(L, LuaExecutor::versionCode);
        return 1;
    }
}</pre>
<p>The function pushes a <strong class="source-inline">LuaExecutor::versionCode</strong> integer constant to its private stack and returns <strong class="source-inline">1</strong> to indicate that it returns one value. We can define this constant in <strong class="source-inline">LuaExecutor.h</strong> <span class="No-Break">as follows:</span></p>
<pre class="source-code">
class LuaExecutor
{
public:
    static const int versionCode = 6;
};</pre>
<p>We will use the value <strong class="source-inline">6</strong> for <span class="No-Break"><em class="italic">Chapter 6</em></span><span class="No-Break">.</span></p>
<p>You may <a id="_idIndexMarker281"/>have noticed that the function is inside an anonymous namespace. This is to make sure that it cannot be accessed outside the file of <strong class="source-inline">LuaExecutor.cc</strong>. This also helps with logical <span class="No-Break">code grouping.</span></p>
<p>Next, let us make this function available <span class="No-Break">to Lua.</span></p>
<h2 id="_idParaDest-139"><a id="_idTextAnchor141"/>How to register C++ functions to Lua</h2>
<p>There are a<a id="_idIndexMarker282"/> few ways to register C++ functions to Lua. We will look at the simplest way here to register a C++ function in the Lua global table. Later in this chapter when learning C++ modules, we will learn a more proper way to register C++ functions in their own table. You already know how to do this from <span class="No-Break"><em class="italic">Chapter 3</em></span>. I only need to point it out with the following code, which you should add to the same anonymous namespace you have <span class="No-Break">just written:</span></p>
<pre class="source-code">
namespace
{
    void registerHostFunctions(lua_State *L)
    {
        lua_pushcfunction(L, luaGetExecutorVersionCode);
        lua_setglobal(L, "host_version");
    }
}</pre>
<p>Yes—we simply need to set it as a Lua global variable! We use <strong class="source-inline">lua_pushcfunction</strong> to push the <strong class="source-inline">lua_CFunction</strong> type onto the stack. Then, we assign it to a global variable <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">host_version</strong></span><span class="No-Break">.</span></p>
<p>Using a <a id="_idIndexMarker283"/>global variable for the host executor version sounds very reasonable. But you should not abuse Lua global variables by using them too much. Now, let us try <span class="No-Break">it out.</span></p>
<h2 id="_idParaDest-140"><a id="_idTextAnchor142"/>Testing it out</h2>
<p>We need <a id="_idIndexMarker284"/>to modify three places to test our progress so far. You can start your work with the <strong class="source-inline">begin</strong> folder from the source code of <span class="No-Break">this chapter.</span></p>
<p>Call <strong class="source-inline">registerHostFunctions</strong> from the constructor of our Lua executor, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
LuaExecutor::LuaExecutor(...)
{
    ...
    registerHostFunctions(L);
}</pre>
<p>This registers our function <span class="No-Break">to Lua.</span></p>
<p>Replace the content of <strong class="source-inline">script.lua</strong> <span class="No-Break">as follows:</span></p>
<pre class="source-code">
print("Host version is " .. host_version())</pre>
<p>This calls our C++ function from Lua and prints out <span class="No-Break">the result.</span></p>
<p>Replace the content of <strong class="source-inline">main.cpp</strong> with the following <span class="No-Break">test code:</span></p>
<pre class="source-code">
#include "LuaExecutor.h"
#include "LoggingLuaExecutorListener.h"
int main()
{
    auto listener = std::make_unique&lt;
        LoggingLuaExecutorListener&gt;();
    auto lua = std::make_unique&lt;LuaExecutor&gt;(*listener);
    lua-&gt;executeFile("script.lua");
    return 0;
}</pre>
<p>This <a id="_idIndexMarker285"/>resets the test code to simply create a Lua executor and runs <strong class="source-inline">scripts.lua</strong>. Run the project, and if you have done everything correctly, you should see the <span class="No-Break">following output:</span></p>
<pre class="source-code">
Host version is 6</pre>
<p>Congratulations! You have called your first C++ function from Lua code. Based on this learning, let us find out how to override Lua <span class="No-Break">library functions.</span></p>
<h1 id="_idParaDest-141"><a id="_idTextAnchor143"/>How to override Lua library functions</h1>
<p>Why <a id="_idIndexMarker286"/>would you want to override Lua library functions? First, it helps to learn more about calling C++ functions from Lua in a progressive way, before moving on to C++ modules. Second, but more importantly, it is a frequent requirement for <span class="No-Break">real-life projects.</span></p>
<p>Suppose you are working on a game where assets are packed inside a private archive and your Lua scripts need to access them. Overriding the Lua <strong class="source-inline">io</strong> and <strong class="source-inline">file</strong> libraries can provide a seamless experience for your fellow Lua developers and enforce security at the same time. You can make sure Lua scripts can only access assets you want them to, but nothing else on the host filesystem. This is even more important when your users can change the <span class="No-Break">Lua scripts.</span></p>
<p>Let us implement a more trivial case. We use the Lua <strong class="source-inline">print</strong> function to output debug information. We want to merge the Lua debug output with C++ output so that we get all our logs in the same place ordered by the time they <span class="No-Break">are printed.</span></p>
<h2 id="_idParaDest-142"><a id="_idTextAnchor144"/>Reimplementing the Lua print function</h2>
<p>Because the<a id="_idIndexMarker287"/> Lua <strong class="source-inline">print</strong> function takes a variable number of arguments, we need to take this into consideration in our implementation. In <strong class="source-inline">LuaExecutor.cc</strong>, below the namespace from the previous section, add <em class="italic">another</em> namespace <span class="No-Break">as follows:</span></p>
<pre class="source-code">
namespace
{
    int luaPrintOverride(lua_State *L)
    {
        int nArgs = lua_gettop(L);
        std::cout &lt;&lt; "[Lua]";
        for (int i = 1; i &lt;= nArgs; i++)
        {
            std::cout &lt;&lt; " "
                      &lt;&lt; luaL_tolstring(L, i, NULL);
        }
        std::cout &lt;&lt; std::endl;
        return 0;
    }
}</pre>
<p>The <strong class="source-inline">luaPrintOverride</strong> C++ function <a id="_idIndexMarker288"/>would eventually get <a id="_idIndexMarker289"/>called when you invoke the <strong class="source-inline">print</strong> function in Lua. It takes <strong class="source-inline">lua_State</strong> as a single argument, whose associated Lua stack is used to pass the real arguments from the Lua call site. To understand what is happening, see the <span class="No-Break">following diagram:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer047">
<img alt="Figure 6.1 – Overriding the Lua print function" height="503" src="image/B20927_06_01.jpg" width="1112"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – Overriding the Lua print function</p>
<p>The<a id="_idIndexMarker290"/> Lua <strong class="source-inline">print</strong> function will push its arguments onto the private Lua stack for the call. The C++ function first checks the number of arguments the Lua call site has passed with <strong class="source-inline">lua_gettop</strong>. Then, it prints out <strong class="source-inline">"[Lua]"</strong>to indicate that the print comes from Lua instead of C++. Next, it loops through each argument and prints them out, separated by a space. Finally, it returns <strong class="source-inline">0</strong> to tell the Lua library that it has no value to return to the <span class="No-Break">call site.</span></p>
<p class="callout-heading">To reinforce</p>
<p class="callout">The Lua state and the Lua stack for each <strong class="source-inline">lua_CFunction</strong> call are private to the call. So, everything in the stack is made up of the arguments passed from the Lua call site. You do not need to remove them from the stack before pushing your return values because you are already telling the Lua library how many values are pushed onto the stack as the C++ function <span class="No-Break">return value.</span></p>
<p>Next, let us see how we can override the Lua <strong class="source-inline">print</strong> function with the C++ version we <span class="No-Break">just implemented.</span></p>
<h2 id="_idParaDest-143"><a id="_idTextAnchor145"/>Overriding the Lua print function</h2>
<p>Here, we <a id="_idIndexMarker291"/>will first look at the code and then delve into our explanation of it. In the same anonymous namespace, add the <span class="No-Break">following function:</span></p>
<pre class="source-code">
namespace
{
    void overrideLuaFunctions(lua_State *L)
    {
        const struct luaL_Reg overrides[] = {
            {"print", luaPrintOverride},
            {NULL, NULL}};
        lua_getglobal(L, "_G");
        luaL_setfuncs(L, overrides, 0);
        lua_pop(L, 1);
    }
}</pre>
<p>The process of <a id="_idIndexMarker292"/>overriding library functions includes <span class="No-Break">the following:</span></p>
<ul>
<li>Getting the <span class="No-Break">library table</span></li>
<li>Reassigning the functions of interest to your <span class="No-Break">new implementations</span></li>
</ul>
<p>Each line of the code is doing <span class="No-Break">the following:</span></p>
<ul>
<li>It defines an array of <strong class="source-inline">luaL_Reg</strong>, which is a structure representing a name and <strong class="source-inline">lua_CFunction</strong> pair. We set the name as <strong class="source-inline">"print"</strong>, the same as the function name we want to override. We set the function as our new implementation. The last entry in the array must be <strong class="source-inline">{NULL, NULL}</strong> to mark the end of <span class="No-Break">the definition.</span></li>
<li>It gets the <strong class="source-inline">_G</strong> Lua table onto the stack, because the <strong class="source-inline">print</strong> function is a global variable and the <strong class="source-inline">_G</strong> table holds all <span class="No-Break">global variables.</span></li>
<li>It sets our list of functions from <em class="italic">step 1</em> to the <strong class="source-inline">_G</strong> table with <strong class="source-inline">luaL_setfuncs</strong>. You can ignore the last parameter for now; we will learn about it in the <span class="No-Break">next section.</span></li>
<li>It pops the <strong class="source-inline">_G</strong> table<a id="_idIndexMarker293"/> from the stack to maintain a <span class="No-Break">balanced stack.</span></li>
<li>Additionally, <strong class="source-inline">luaL_Reg</strong> is defined in the Lua library <span class="No-Break">as follows:</span></li>
</ul>
<pre class="source-code">
typedef struct luaL_Reg {
    const char *name;
    lua_CFunction func;
} luaL_Reg;</pre>
<p>Overriding the Lua library functions is really as simple as reassigning some table keys to different values! Now, let us see if <span class="No-Break">it works.</span></p>
<h2 id="_idParaDest-144"><a id="_idTextAnchor146"/>Testing it out</h2>
<p>Similar to the <a id="_idIndexMarker294"/>previous section, call <strong class="source-inline">overrideLuaFunctions</strong> from the constructor of our Lua executor, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
LuaExecutor::LuaExecutor(...)
{
    ...
    overrideLuaFunctions(L);
}</pre>
<p>You do not need to change anything else. With the same <strong class="source-inline">main.cpp</strong> and <strong class="source-inline">script.lua</strong> files, run the project. If you have followed everything correctly, you should see the <span class="No-Break">following output:</span></p>
<pre class="source-code">
[Lua] Host version is 6</pre>
<p>There is now a <strong class="source-inline">[Lua]</strong> prefix in the output, proving it is printed from our C++ override, not the Lua <span class="No-Break">library function.</span></p>
<p>Next, let us learn about C++ modules, which is the preferred way to add your C++ functionalities <span class="No-Break">to Lua.</span></p>
<h1 id="_idParaDest-145"><a id="_idTextAnchor147"/>How to register C++ modules</h1>
<p>In this<a id="_idIndexMarker295"/> section, we will export a C++ class instance to Lua. You probably have used or even implemented Lua modules before, the ones that the Lua interpreter can find and load automatically and return via Lua’s <strong class="source-inline">require</strong> function. Here, the focus is integrating Lua into C++, and in such use cases, things are initiated from a C++ executor to benefit from the rest of your C++ application. So, there is a difference if you have used standalone Lua <span class="No-Break">modules before.</span></p>
<p>In the previous chapter, we implemented a Lua class called <strong class="source-inline">Destinations</strong> to keep track of places we want to go. Let us reimplement it in C++ so that we can export it <span class="No-Break">to Lua.</span></p>
<h2 id="_idParaDest-146"><a id="_idTextAnchor148"/>Implementing a C++ class</h2>
<p>Create<a id="_idIndexMarker296"/> two source files, <strong class="source-inline">Destinations.h</strong> and <strong class="source-inline">Destinations.cc</strong>. Remember to add <strong class="source-inline">Destinations.cc</strong> to the <strong class="source-inline">Makefile</strong>. Write the header file <span class="No-Break">as follows:</span></p>
<pre class="source-code">
#ifndef _DESTINATIONS_H
#define _DESTINATIONS_H
#include &lt;map&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
class Destinations
{
public:
    Destinations(const std::string &amp;name);
    void wish(const std::vector&lt;std::string&gt; &amp;places);
    void went(const std::vector&lt;std::string&gt; &amp;places);
    std::vector&lt;std::string&gt; listVisited() const;
    std::vector&lt;std::string&gt; listUnvisited() const;
private:
    std::string name;
    std::map&lt;std::string, bool&gt; wishlist;
};
#endif // _DESTINATIONS_H</pre>
<p>We<a id="_idIndexMarker297"/> use a <strong class="source-inline">map</strong> variable to keep a list of places and whether we have visited them and have a <strong class="source-inline">name</strong> member variable to identify the instance. The member functions are named and work the same as the Lua version, <span class="No-Break">as follows:</span></p>
<ul>
<li><strong class="source-inline">wish</strong> adds a list of places to the wish list <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">unvisited</strong></span></li>
<li><strong class="source-inline">went</strong> marks a list of places <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">visited</strong></span></li>
<li><strong class="source-inline">listVisited</strong> returns <span class="No-Break">visited places</span></li>
<li><strong class="source-inline">listUnvisited</strong> returns <span class="No-Break">unvisited places</span></li>
</ul>
<p>Now, let us implement the member functions in <strong class="source-inline">Destinations.cc</strong>. They are plain C++ functions without using any Lua features. So, we will just list the code without much explanation. First, let us implement <span class="No-Break">the constructor:</span></p>
<pre class="source-code">
#include "Destinations.h"
Destinations::Destinations(const std::string &amp;name)
    : name(name), wishlist({}) {}</pre>
<p>This initializes the <strong class="source-inline">wishlist</strong> as an <span class="No-Break">empty map.</span></p>
<p>Then, write the <strong class="source-inline">wish</strong> function <span class="No-Break">as follows:</span></p>
<pre class="source-code">
void Destinations::wish(
    const std::vector&lt;std::string&gt; &amp;places)
{
    for (const auto &amp;place : places)
    {
        wishlist[place] = false;
    }
}</pre>
<p>Then, implement<a id="_idIndexMarker298"/> the <strong class="source-inline">went</strong> function <span class="No-Break">as follows:</span></p>
<pre class="source-code">
void Destinations::went(
    const std::vector&lt;std::string&gt; &amp;places)
{
    for (const auto &amp;place : places)
    {
        wishlist[place] = true;
    }
}</pre>
<p>The <strong class="source-inline">wish</strong> function and the <strong class="source-inline">went</strong> function are quite similar and mark places as visited <span class="No-Break">or unvisited.</span></p>
<p>Finally, implement the query functions. Write the <strong class="source-inline">listVisited</strong> function <span class="No-Break">as follows:</span></p>
<pre class="source-code">
std::vector&lt;std::string&gt;
Destinations::listVisited() const
{
    std::vector&lt;std::string&gt; results;
    for (const auto &amp;[place, visited] : wishlist)
    {
        if (visited)
        {
            results.push_back(place);
        }
    }
    return results;
}</pre>
<p>Then, write<a id="_idIndexMarker299"/> the <strong class="source-inline">listUnvisited</strong> function <span class="No-Break">as follows:</span></p>
<pre class="source-code">
std::vector&lt;std::string&gt;
Destinations::listUnvisited() const
{
    std::vector&lt;std::string&gt; results;
    for (const auto &amp;[place, visited] : wishlist)
    {
        if (not visited)
        {
            results.push_back(place);
        }
    }
    return results;
}</pre>
<p>With a C++ class ready, our next task is to export it <span class="No-Break">to Lua.</span></p>
<h2 id="_idParaDest-147"><a id="_idTextAnchor149"/>What to export to Lua</h2>
<p>Exporting <a id="_idIndexMarker300"/>a C++ class to Lua is really exporting its instances to Lua. Sometimes, only one instance is exported and the C++ class works as a utility library, similar to the Lua <strong class="source-inline">string</strong> library. Sometimes, many instances are exported and Lua extends C++’s <strong class="bold">object-oriented </strong><span class="No-Break"><strong class="bold">programming</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">OOP</strong></span><span class="No-Break">).</span></p>
<p>It is important to note that no matter how many instances you want to export, the process is the same. When overriding Lua library functions, we retrieve an existing table and set some of its functions to our implementation. To export a C++ class instance, similarly, we need to do <span class="No-Break">the following:</span></p>
<ul>
<li>Create a <span class="No-Break">new table</span></li>
<li>Add the functions we want to export to <span class="No-Break">the table</span></li>
</ul>
<p>If you recall that we can only export functions of the <strong class="source-inline">lua_CFunction</strong> prototype to Lua, you will clearly see that we cannot export our public member functions to Lua directly. We need some wrapper functions. Let us first write some stubs. Below the <strong class="source-inline">#include</strong> directives in <strong class="source-inline">Destinations.cc</strong>, add the <span class="No-Break">following code:</span></p>
<pre class="source-code">
namespace
{
int luaWish(lua_State *L) { return 0; }
int luaWent(lua_State *L) { return 0; }
int luaListVisited(lua_State *L) { return 0; }
int luaListUnvisited(lua_State *L) { return 0; }
const std::vector&lt;luaL_Reg&gt; REGS = {
    {"wish", luaWish},
    {"went", luaWent},
    {"list_visited", luaListVisited},
    {"list_unvisited", luaListUnvisited},
    {NULL, NULL}};
}</pre>
<p>We defined four wrapper functions of the <strong class="source-inline">lua_CFunction</strong> prototype and a list of <strong class="source-inline">luaL_Reg</strong> instances. We<a id="_idIndexMarker301"/> are using <strong class="source-inline">vector</strong> instead of <strong class="source-inline">array</strong> because in C++ we prefer vectors unless we have to use <span class="No-Break">an array.</span></p>
<p>Next, let us design a reusable mechanism to export our wrappers <span class="No-Break">to Lua.</span></p>
<h2 id="_idParaDest-148"><a id="_idTextAnchor150"/>Designing a reusable exporting mechanism</h2>
<p>There <a id="_idIndexMarker302"/>are many ways to do this. We choose a way to work with our Lua executor and let it register our C++ modules. First, let us define an abstract class to represent C++ modules. Create a new file named <strong class="source-inline">LuaModule.h</strong> and write its content <span class="No-Break">as follows:</span></p>
<pre class="source-code">
#ifndef _LUA_MODULE_H
#define _LUA_MODULE_H
#include &lt;lua.hpp&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
class LuaModule
{
public:
    virtual const std::string &amp;luaName()
        const override = 0;
    virtual const std::vector&lt;luaL_Reg&gt; &amp;luaRegs()
        const overrode = 0;
    virtual ~LuaModule() = default;
};
#endif // _LUA_MODULE_H</pre>
<p>The <strong class="source-inline">LuaModule</strong> abstract class defines two abstract methods to provide data needed to <a id="_idIndexMarker303"/>register a C++ module to Lua. <strong class="source-inline">luaName</strong> returns a name for the module instance; we will use it as the Lua table name. <strong class="source-inline">luaRegs</strong> returns a list of functions to be exported along with their names <span class="No-Break">in Lua.</span></p>
<p>Let us extend our <strong class="source-inline">Destinations</strong> C++ class to conform to this protocol. Change its declaration <span class="No-Break">as follows:</span></p>
<pre class="source-code">
class Destinations : public LuaModule
{
public:
    ...
    const std::string &amp;luaName() const;
    const std::vector&lt;luaL_Reg&gt; &amp;luaRegs() const;
    ...
};</pre>
<p>After this, add the following implementation <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">Destinations.cc</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
const std::string &amp;
Destinations::luaName() const
{
    return name;
}
const std::vector&lt;luaL_Reg&gt; &amp;
Destinations::luaRegs() const
{
    return REGS;
}</pre>
<p>The code simply returns the instance name as <strong class="source-inline">luaName</strong> and the <strong class="source-inline">REGS</strong> we just defined for our stubs <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">luaRegs</strong></span><span class="No-Break">.</span></p>
<p>Now<a id="_idIndexMarker304"/> comes the time to finally register our C++ class to Lua. In <strong class="source-inline">LuaExecutor.h</strong>, add a function declaration <span class="No-Break">as follows:</span></p>
<pre class="source-code">
class LuaExecutor
{
public:
    void registerModule(LuaModule &amp;module);
};</pre>
<p>The <strong class="source-inline">registerModule</strong> function registers an instance of <strong class="source-inline">LuaModule</strong> to the Lua state that the <span class="No-Break">executor holds.</span></p>
<p>Next, implement it <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">LuaExecutor.cc</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
void LuaExecutor::registerModule(LuaModule &amp;module)
{
    lua_createtable(L, 0, module.luaRegs().size() - 1);
    luaL_setfuncs(L, module.luaRegs().data(), 0);
    lua_setglobal(L, module.luaName().c_str());
}</pre>
<p>This needs some explanation. Let us explore what each line of the code here is doing <span class="No-Break">in sequence:</span></p>
<ol>
<li>It creates a table with <strong class="source-inline">lua_createtable</strong>. This library function will push the table onto the stack. The second parameter hints at how many elements in the table will be used as a sequence. We have none, so we pass <strong class="source-inline">0</strong>. The third parameter hints at how many elements in the table will be used as a map. All our functions are used this way, so we pass the count of our vector minus the ending marker. The hints help with memory allocation in Lua, as Lua will be responsible for creating a properly sized table to avoid unnecessary reallocations to increase the capacity of the <span class="No-Break">table later.</span></li>
<li>It sets<a id="_idIndexMarker305"/> our functions to the table with <strong class="source-inline">luaL_setfuncs</strong>. This works exactly the same as when we overrode Lua library functions. Ignore the third parameter for now as well. <strong class="source-inline">module.luaRegs().data()</strong> returns our function list as an array instead of a vector. <strong class="source-inline">std::vector::data</strong> is a <span class="No-Break">C++ feature.</span></li>
<li>It assigns the table just created to a global variable using the name returned from <strong class="source-inline">module.luaName()</strong>. From now on, our C++ module can be accessed from <span class="No-Break">this table.</span></li>
</ol>
<p>Exporting a C++ module to Lua may sound heavy and glorious. But there is actually not much gluing code involved. Compare what we have just done with overriding Lua library functions. Take a moment, then we will test our mechanism to see if <span class="No-Break">it works.</span></p>
<h2 id="_idParaDest-149"><a id="_idTextAnchor151"/>Testing our mechanism</h2>
<p>Add a<a id="_idIndexMarker306"/> few lines of code to <strong class="source-inline">main.cpp</strong> so that it looks <span class="No-Break">like this:</span></p>
<pre class="source-code">
#include "LuaExecutor.h"
#include "LoggingLuaExecutorListener.h"
#include "Destinations.h"
int main()
{
    auto listener = std::make_unique&lt;
       LoggingLuaExecutorListener&gt;();
    auto lua = std::make_unique&lt;LuaExecutor&gt;(*listener);
    auto wishlist = std::make_unique&lt;Destinations&gt;(
        "destinations");
    lua-&gt;registerModule(*wishlist.get());
    lua-&gt;executeFile("script.lua");
    return 0;
}</pre>
<p>We <a id="_idIndexMarker307"/>create an instance of the <strong class="source-inline">Destinations</strong> class and give it the name <strong class="source-inline">"destinations"</strong>. Then, we register it with our <span class="No-Break">Lua executor.</span></p>
<p>Now, add the following code <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">script.lua</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
destinations.wish("London", "Paris", "Amsterdam")
destinations.went("Paris")
print("Visited:", destinations.list_visited())
print("Unvisited:", destinations.list_unvisited())</pre>
<p>This is doing <span class="No-Break">the following:</span></p>
<ol>
<li>It adds London, Paris, and Amsterdam to the <span class="No-Break">wish list.</span></li>
<li>It marks Paris <span class="No-Break">as visited.</span></li>
<li>It prints the <span class="No-Break">visited cities.</span></li>
<li>It prints the <span class="No-Break">unvisited cities.</span></li>
</ol>
<p>Run the project, and if you have followed all the steps correctly, you should see the <span class="No-Break">following output:</span></p>
<pre class="source-code">
[Lua] Visited:
[Lua] Unvisited:</pre>
<p>There should be no errors, and since our wrapper functions are only stubs, it will not return anything <a id="_idIndexMarker308"/>useful. Hence, this is how we laid out the architectural foundation. Next, we will focus our efforts on making it work at the <span class="No-Break">ground level.</span></p>
<h2 id="_idParaDest-150"><a id="_idTextAnchor152"/>Accessing the C++ class instance</h2>
<p>Our <a id="_idIndexMarker309"/>wrapper functions are of type <strong class="source-inline">lua_CFunction</strong>. They <a id="_idIndexMarker310"/>are essentially C++ static methods not associated with any class. How can we access the correct class instance? We must do <span class="No-Break">some bookkeeping.</span></p>
<p>Luckily, Lua provides a mechanism to keep data for the registered C++ functions. It is called an <strong class="bold">upvalue</strong>. Upvalues <a id="_idIndexMarker311"/>can only be accessed by the associated function in C/C++ code and are shared across different function calls. We can save the pointer to the class instance in <span class="No-Break">an upvalue.</span></p>
<p>Why is it called an upvalue? At this stage, it is easier to understand when not explained, in the same spirit as why a variable is called <span class="No-Break">a variable.</span></p>
<p class="callout-heading">Have you noticed?</p>
<p class="callout">From the previous description, an upvalue behaves like a C++ static variable in the function scope. Then, why do we use an upvalue instead of a static variable? Because an upvalue is associated with a C++ function in the Lua library. This way, we can use the same C++ function with <span class="No-Break">different upvalues.</span></p>
<p>Which Lua data type can be used to save a C++ pointer? We can use <strong class="bold">userdata</strong>. This type is used to<a id="_idIndexMarker312"/> store arbitrary C/C++ data. Especially, for our case, we need to <a id="_idIndexMarker313"/>use <strong class="bold">light userdata</strong>, whose purpose is to store a C/C++ pointer. It is a perfect match <span class="No-Break">for us.</span></p>
<p>In conclusion, we need to save the class instance’s <strong class="source-inline">this</strong> pointer as <em class="italic">light userdata</em> in an <em class="italic">upvalue</em> for the <span class="No-Break"><strong class="source-inline">lua_CFunction</strong></span><span class="No-Break"> implementation.</span></p>
<p>Here, we have involved two new Lua concepts. They are exclusively used to work with C/C++ code, so chances are that you are not very familiar with them from Lua programming. Let us see the code in action to help with <span class="No-Break">the understanding.</span></p>
<h3>How to provide upvalues</h3>
<p>We <a id="_idIndexMarker314"/>will only look at the case for registering C++ modules. So far, we have ignored the third parameter to <strong class="source-inline">luaL_setfuncs</strong> and always <span class="No-Break">passed </span><span class="No-Break"><strong class="source-inline">0</strong></span><span class="No-Break">.</span></p>
<p>What does this third parameter mean? It is the count for the upvalues that will be available to all functions in the list provided in the <span class="No-Break">second parameter.</span></p>
<p>How do you provide upvalues? Of course—you push them onto <span class="No-Break">the stack!</span></p>
<p>Let us rewrite the function to register C++ modules <span class="No-Break">as follows:</span></p>
<pre class="source-code">
void LuaExecutor::registerModule(LuaModule &amp;module)
{
    lua_createtable(L, 0, module.luaRegs().size() - 1);
    int nUpvalues = module.pushLuaUpvalues(L);
    luaL_setfuncs(L, module.luaRegs().data(), nUpvalues);
    lua_setglobal(L, module.luaName().c_str());
}</pre>
<p>There are only two changes. First, we want another function yet to be implemented in <strong class="source-inline">LuaModule</strong> to push upvalues onto the stack and return to us how many upvalues have been pushed. Then, we pass the upvalue count as the third parameter <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">luaL_setfuncs</strong></span><span class="No-Break">.</span></p>
<p>Remember to add <strong class="source-inline">pushLuaUpvalues</strong> to <strong class="source-inline">LuaModule.h</strong>, <span class="No-Break">like so:</span></p>
<pre class="source-code">
class LuaModule
{
public:
    virtual int pushLuaUpvalues(lua_State *L)
    {
        lua_pushlightuserdata(L, this);
        return 1;
    }
};</pre>
<p>We have provided a default implementation that pushes <strong class="source-inline">this</strong> as an upvalue. In derived classes, they can override this function and<a id="_idIndexMarker315"/> push <span class="No-Break">more upvalues.</span></p>
<p>Next, let us see how we can access <span class="No-Break">this upvalue.</span></p>
<h3>How to access upvalues</h3>
<p>Lua upvalues <a id="_idIndexMarker316"/>are accessed as if they were in the stack, while they are not really in the stack. So, a magic stack index, <strong class="source-inline">LUA_REGISTRYINDEX</strong>, is used to mark the start of the upvalue pseudo-region. Lua provides a <strong class="source-inline">lua_upvalueindex</strong> macro to locate the indices of your upvalues, so you do not really need to deal with this <span class="No-Break">magic number.</span></p>
<p>This is how we can access our C++ class instance stored as an upvalue. In <strong class="source-inline">Destinations.cc</strong>, add the following function to the <span class="No-Break">anonymous namespace:</span></p>
<pre class="source-code">
namespace
{
    inline Destinations *getObj(lua_State *L)
    {
        return reinterpret_cast&lt;Destinations *&gt;(
            lua_touserdata(L, lua_upvalueindex(1)));
    }
}</pre>
<p>We can use this helper function to get a pointer to the instance. It uses <strong class="source-inline">lua_touserdata</strong> to get our light userdata from the stack with the pseudo-index. This helper will be called from the stubs <span class="No-Break">we registered.</span></p>
<p class="callout-heading">To reinforce</p>
<p class="callout">The Lua state and stack passed to a <strong class="source-inline">lua_CFunction</strong> function are private to each call to <span class="No-Break">that function.</span></p>
<p>Now that we <a id="_idIndexMarker317"/>have figured out how to access the class instance, we can complete <span class="No-Break">our stubs.</span></p>
<h2 id="_idParaDest-151"><a id="_idTextAnchor153"/>Completing our stubs</h2>
<p>Write <strong class="source-inline">luaWish</strong> <span class="No-Break">as </span><span class="No-Break"><a id="_idIndexMarker318"/></span><span class="No-Break">follows:</span></p>
<pre class="source-code">
int luaWish(lua_State *L)
{
    Destinations *obj = getObj(L);
    std::vector&lt;std::string&gt; places;
    int nArgs = lua_gettop(L);
    for (int i = 1; i &lt;= nArgs; i++)
    {
        places.push_back(lua_tostring(L, i));
    }
    obj-&gt;wish(places);
    return 0;
}</pre>
<p>It first gets the class instance with the <strong class="source-inline">getObj</strong> helper function we just implemented. Then, it puts all arguments from the Lua call site into a vector. Finally, it calls the real object method, <strong class="source-inline">obj-&gt;wish</strong>. This is what a wrapper does – it routes the call to the <span class="No-Break">real object.</span></p>
<p>The code for <strong class="source-inline">luaWent</strong> is similar, as we can <span class="No-Break">see here:</span></p>
<pre class="source-code">
int luaWent(lua_State *L)
{
    Destinations *obj = getObj(L);
    std::vector&lt;std::string&gt; places;
    int nArgs = lua_gettop(L);
    for (int i = 1; i &lt;= nArgs; i++)
    {
        places.push_back(lua_tostring(L, i));
    }
    obj-&gt;went(places);
    return 0;
}</pre>
<p>The <a id="_idIndexMarker319"/>only difference is that it calls <span class="No-Break"><strong class="source-inline">obj-&gt;went</strong></span><span class="No-Break"> instead.</span></p>
<p>Finally, implement the query functions <span class="No-Break">as follows:</span></p>
<pre class="source-code">
int luaListVisited(lua_State *L)
{
    Destinations *obj = getObj(L);
    auto places = obj-&gt;listVisited();
    for (const auto &amp;place : places)
    {
        lua_pushstring(L, place.c_str());
    }
    return places.size();
}
int luaListUnvisited(lua_State *L)
{
    Destinations *obj = getObj(L);
    auto places = obj-&gt;listUnvisited();
    for (const auto &amp;place : places)
    {
        lua_pushstring(L, place.c_str());
    }
    return places.size();
}</pre>
<p>These <a id="_idIndexMarker320"/>functions use the object functions to get a list of places and then push the list onto the stack to return the results to the Lua <span class="No-Break">call site.</span></p>
<p>Now, we have implemented everything, and we can <span class="No-Break">test it.</span></p>
<h2 id="_idParaDest-152"><a id="_idTextAnchor154"/>Testing it out</h2>
<p>We do not <a id="_idIndexMarker321"/>need to modify any test code because we have already used the functions to test our stubs. Now, recompile and run <span class="No-Break">the project.</span></p>
<p>Recall that the Lua test code looks <span class="No-Break">like this:</span></p>
<pre class="source-code">
destinations.wish("London", "Paris", "Amsterdam")
destinations.went("Paris")
print("Visited:", destinations.list_visited())
print("Unvisited:", destinations.list_unvisited())</pre>
<p>If you have done everything correctly, you should see the <span class="No-Break">following output:</span></p>
<pre class="source-code">
[Lua] Visited: Paris
[Lua] Unvisited: Amsterdam London</pre>
<p>Congratulations on making <span class="No-Break">it work!</span></p>
<p>This chapter is quite a change of mindset from the previous chapters. Take a moment to reflect if you <span class="No-Break">need to.</span></p>
<h1 id="_idParaDest-153"><a id="_idTextAnchor155"/>Summary</h1>
<p>In this chapter, we learned how to call C++ code from Lua. We first learned how to register a simple C++ function to Lua. All registered functions must conform to <strong class="source-inline">lua_CFunction</strong>. Then, we found out how to override Lua library functions. Finally, we implemented a C++ class and exported it to Lua. We also came across the concepts of <em class="italic">upvalue</em> and <em class="italic">light userdata</em> along <span class="No-Break">the way.</span></p>
<p>In the next chapter, we will continue our journey with more details on user-defined data in C++ and more <span class="No-Break">data-exchanging mechanisms.</span></p>
<h1 id="_idParaDest-154"><a id="_idTextAnchor156"/>Exercises</h1>
<ol>
<li>In the <strong class="source-inline">Destinations</strong> class, we only used one upvalue. Add another upvalue and play around with it. Which upvalue is at <span class="No-Break">which pseudo-index?</span></li>
<li>Try to modify the second upvalue in a function and see if the value is persisted the next time the function is called. How about when it is accessed in <span class="No-Break">another function?</span></li>
<li>In <strong class="source-inline">LuaType.hpp</strong>, add <strong class="source-inline">LuaType::lightuserdata</strong> and implement a structure for it, named <strong class="source-inline">LuaLightUserData</strong>. Support this case in the executor and helper functions. You do not need to support this type when popping values from the <span class="No-Break">Lua stack.</span></li>
</ol>
</div>
</div></body></html>