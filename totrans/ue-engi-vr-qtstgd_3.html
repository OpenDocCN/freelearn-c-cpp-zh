<html><head></head><body><div><h1 class="header-title">Exploring Riveting Gameplay in Virtual Reality</h1>
                
            
            
                
<p class="mce-root">With our custom game files in place, it's time to start making some decisions about gameplay. In <em>Server 17</em>, the player takes on the role of a futuristic hacker trying to crack open a corporate server and plunder its secrets for personal gain. So, how might we present this in VR as an experience? Before we think about that, let's do a bit of research and discovery. The best way to learn which mechanics will challenge and entertain our players is to first look at the unique elements that VR brings to a game. After that, we can take a look at which titles are being played right now and why. Armed with that information, we can then make some decisions about how best to design our own gameplay for <em>Server 17</em>. We have a lot to discover, so let's get started!</p>
<p>In this chapter, we'll cover the following topics:</p>
<ul>
<li>What does VR bring to video games?</li>
<li>Popular gameplay mechanics</li>
<li>Designing the gameplay for <em>Server 17</em></li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">What does VR bring to video games?</h1>
                
            
            
                
<div><p class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr">VR is the new frontier in games and entertainment. It's able to put the player in the shoes of their favorite heroes, or in a front-row seat for some of their  favorite experiences. In most experiences, player movement is translated into near one-to-one movement inside the game—something that's usually impossible in traditional video games. VR also has the power to immerse our player in an alternate world and make them truly feel as if they're there. It's these special abilities that mark VR as the future of gaming.</p>
</div>
<p class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr">It's important to understand that the input and controls in VR can go beyond the locomotion methods that we discussed in the last chapter. Each controller for the Vive or Oculus brings at least six different buttons that can be mapped to different functions within a game. Each of these can then be combined with a location or specific player movement to create almost infinite variety. Let's take a look at some of the gunplay in Epic Game's <em>Robo Recall</em>.</p>
<div><p class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr">In this game, you destroy robots with a variety of weapons that are holstered on the player. The character has a pair of pistols holstered at their hips and a second pair of weapons holstered at their shoulders. This seems simple enough, right? Where the designers utilized the advantages of VR was in the hand placement needed to use your weapons. The player has to reach down to their waist to grab a pistol or reach behind their shoulder to grab a weapon. This simple addition of hand location to the input to equip a gun adds to the immersion and visceral quality of the gameplay.</p>
</div>


            

            
        
    </div>



  
<div><h1 class="header-title">Popular gameplay mechanics</h1>
                
            
            
                
<p>In the last few years, many developers have embraced VR technology as their chosen medium. This has lead to a variety of VR games spanning many different genres and ideas. Each game has approached the input and immersion that VR brings in their own way. Some, such as Bethesda and ID Software, chose to use the technology to bring their blockbuster games <em>Fallout 4</em> and <em>Doom</em> into the VR era (to mixed reviews). Others have found more success building their game specifically for the medium, such as Beat Games' <em>Beat Saber,</em> and Schell Games' <em>I Expect You To Die</em>. For our research into what might work for <em>Server 17</em>, we're going to look at seven different types of gameplay:</p>
<ul>
<li>Shooter experiences</li>
<li>Action/adventure experiences</li>
<li>Vehicle experiences</li>
<li>Physics-based experiences</li>
<li>Puzzle experiences</li>
<li>Rhythm experiences</li>
<li>Educational experiences</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Shooter experiences</h1>
                
            
            
                
<div><p class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr">In the last year, more than a dozen of the top 25 VR titles sold on Valve's Steam download service fell into the shooter category. A shooter is defined as any game that includes gunplay as a major part of experience. Many variations on the shooter experience in VR take advantage of unique mechanics. Still near the top of the charts is <em>Robo Recall</em>.</p>
</div>
<p class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr">Epic Games was able to combine the frantic action of a wave shooter with the immersive environment and mechanics that VR can bring. Much of the gameplay centers around using your hands. <em>Robo Recall</em> uses interesting mechanics when it comes to arming yourself. Players grab their chosen weapons from holsters located at their waist and shoulders. Each one is filled with a variety of customized weapons, all great for scrapping the game's robot enemies. The grab mechanism is also applied to a specific brand of melee combat from <em>Robo Recall</em>. Player's can grab many robot enemies by a handle that's conveniently located in the center of their chest. Once grabbed, enemies can be ripped apart by grabbing limbs, thrown into other enemies, or held up as shields to protect yourself.</p>
<p class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr"><em>Superhot VR</em> by Superhot Team is another game that takes gunplay to a whole new level. The game combines physics and shooting gameplay with their exclusive time mechanics to create a rare experience. Just about every object in its minimalist environments is a weapon in <em>Superhot VR</em>. These items can be thrown at an enemy to liberate their weapon, causing it to fly into the air so that it can be snatched up by the player. Combined with the fact that time only moves forward when you do, each level becomes a combat puzzle. Which enemy do you confront first? What weapon or object is available within arm's reach? Each decision and movement is important for discovering the level's solution, and progressing.</p>
<div><p class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr">The most important elements of a popular VR shooter are active gunplay combined with another unique mechanic. This can be grabbing, physics gameplay, or a particular locomotion mechanism. Other great examples in this category include <em>Sairento VR</em>, for its locomotion mechanic and combination of gun and swordplay, as well as <em>Damaged Core</em>, a game that has the player utilizing the ability to teleport from enemy to enemy, possessing them and using their weapons.</p>
</div>


            

            
        
    </div>



  
<div><h1 class="header-title">Action/adventure experiences</h1>
                
            
            
                
<div><p class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr">Action/adventure experiences combine combat experiences with exploration and story-based gameplay. These games feature impressive environments and visuals that take advantage of the fact that VR places the player directly into the game world. Yet, with such a large world in which to explore, designers must use artificial locomotion methods to allow the player to explore such a large space. For many players, the ability to experience the story firsthand outweighs any discomfort caused by using a thumbstick or snap turning for locomotion. In this category, the biggest contenders both come to us from <em>Bethesda Softworks : Fallout 4 VR and Skyrim VR</em>.</p>
</div>
<div><p class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr"><em>Fallout 4 VR</em> is a direct port of the popular 2015 title, redesigned to work with VR. Players travel the wasteland building settlements, crafting equipment, and experiencing the story from a first-person perspective. Combat is an in-your-face affair. The majority of the early enemies favor close combat, meaning there isn't much of a chance for the player to use a firearm before their opponent is right on top of them. Luckily, melee combat is as simple as equipping the right weapon, or none at all, and swinging away. Ranged combat also feels good, though not nearly as satisfying as in a VR shooter. Still, <em>Fallout 4</em> ticks all of the right boxes. It's an action/adventure experience that gives players a massive, awe-inspiring environment. In it, they may craft, build, and interact, as well as take part in a deep story with a variety of interesting characters.</p>
</div>


            

            
        
    </div>



  
<div><h1 class="header-title">Vehicle experiences</h1>
                
            
            
                
<div><p class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr">Vehicle experiences solve the locomotion problem by placing the player at the helm of a ship, mech, or other method of travel and destruction. The brain processes it much the same as when we go for a ride in the car. We don't question that we're moving because we're sitting down and controlling the vehicle. This gives the designers the opportunity to give players a vehicle-piloting experience. There are many great examples in this space. However, I want to give you one that represents some of the best gameplay in this category, Frontier Developments' <em>Elite Dangerous</em>.</p>
</div>
<p class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr">The most current entry in the <em>Elite</em> saga is a space adventure, combat, and trading sim that puts the player in the role of an elite commander. Players earn money, rank, and influence with the major factions of a one-to-one, open-world version of our Milky Way galaxy. The game can be played without VR hardware, but it truly shines when the player dons the headgear. When played in VR, the player is able to see the inside of the ship and see their own customized player character sitting at the helm.</p>
<p class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr">Navigating the systems and menus of the ship becomes easier as menus open with a glance. Combat and piloting become effortless, since the player can look through the canopy of their ship to help track their location. All of these VR-specific features add depth to an amazing experience as the players fight, trade, and explore their way to fortune and fame within the game world. </p>
<div><p class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr">The addition of an internal ship environment, customizable player character, and eye tracking-based menus are only possible thanks to the first-person perspective that VR provides. Being able to see themselves in the interior of their vehicle connects the player to their surroundings. This makes them feel as if they're a living part of the game. Whether it's racing in a tricked-out high-performance street car or fighting aliens in the depths of space, the player's vehicle-piloting experience is enhanced by the VR perspective.</p>
</div>


            

            
        
    </div>



  
<div><h1 class="header-title">Physics-based experiences</h1>
                
            
            
                
<div><p class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr">Not as well known in the gaming world, physics-based games take advantage of the player's ability to aim and throw objects using a standing or room-space experience. This goes beyond simply picking up and throwing everyday objects, such as the gameplay found in <em>Superhot VR</em>. It takes advantage of a game engine's ability to simulate real-world physics to create gameplay. In this genre, the games tend to take the form of phyiscs-based fighting games and physics puzzle games. Let's take a look at the physics-based combat game, <em>Gorn</em>.</p>
</div>
<p class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr"><em>Gorn</em>, from Devolver Digital, casts the player as a gladiator fighting for the amusement of several large-headed patrons. The game features cartoon-style art and violence, centered around comical physics-based brawling. Each round starts with the player entering the arena, sometimes with a selection of weapons and sometimes unarmed. The rules are simple: knock out the other guys before they do the same to you. The fun comes when the player picks a weapon to use. As the game translates their movement into the game world, it adds a bit of cartoon physics. Movements become exaggerated. Weapons feel as if they're made of foam or rubber, making combat a strange affair. Together, these features come together to create a brawling experience that feels visceral and absurd at the same time. <em>Gorn</em> is currently available for HTC Vive, Oculus Rift, and PlayStation VR.</p>
<p class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr">In contrast to the fighting gameplay of <em>Gorn</em> is the physics-based puzzler, <em>Bounce</em>. <em>Bounce</em>, developed by Steel Wool Studios, has the player helping a ball-shaped robot navigate the corridors of an intergalactic spaceship. Players are given an array of physics gadgets designed to propel their robot friend from one side of the level to the exit portal. To get there, the robot must navigate around laser walls, gravity wells, and other sci-fi obstructions. Beating the game unlocks style mode. This allows the player to play each of the game's 50 levels again and rewards them for the most creative solutions. </p>
<div><p class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr">In both games, we can again see the unique movement mechanic and first-person perspective often seen in VR, used to great effect. <em>Gorn</em> uses player arm movement with cartoon physics to create a gaming experience that feels fun and intense. In contrast, <em>Bounce</em> uses the first-person perspective to allow the player see what placing a particular physics gadget will do when the ball hits it. This gives the player the ability to see firsthand the effects of their actions and allows the player to feel more in control of the experience.</p>
</div>


            

            
        
    </div>



  
<div><h1 class="header-title">Puzzle experiences</h1>
                
            
            
                
<p>With their use of object manipulation as a major mechanism and often fantasy environments, puzzle experiences lend themselves very well to the VR treatment. Since the time of <em>Myst</em> and it's sequels, players have shown time and again that they love solving the mysteries of ancient ruins, dark dungeons, and castles in the sky. However, until now, players haven't been able to truly reach eye level with some of these puzzles and environments, which can make solving problems where you have to aim a laser or shoot a bow much harder. Take as an example the laser puzzles from the game <em>The</em> <em>Talos Principle VR</em> by Croteam, a port of the popular puzzle game from 2014. Players are required in several puzzles to use a device to bend a laser beam to hit a particular target. Some players have reported that this task is considerably easier in VR due to their ability to bend down and see where the laser will travel from eye level.</p>
<p>Another great example of VR principles applied to puzzle gameplay can be found in the standout title <em>I Expect You to Die</em> by Schell Games. In this game, the player takes on the role of a telekinetic super spy, charged with completing various missions to defeat the evil Zoraxis Organization. Each of the five locations in the game feels a bit like an escape room. The player is given the task of escaping the area and must use the tools they find to complete the mission. For instance, the first mission of the game has the player tasked with driving the evil Dr. Zor's weaponized car out of the back of a cargo plane while the plane is slowly filling with poison gas and using only the tools found in the car or dismantled  ones from the car's many attempts to kill you. The game gets around the locomotion issue by giving the player the choice of making it a sitting or room-scale experience and by giving the player telekinesis so they never have to move. Together, the game uses the uniqueness of VR and creativity to great effect to create an experience that has players singing its praises.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Rhythm experiences</h1>
                
            
            
                
<p>In many ways, VR mechanics are breathing new life into the game genres that we love. This is especially true of rhythm games whose basic gameplay mechanics of <em>press this button at this time</em> seem old by today's standards. However, the application of VR-specific gameplay mechanics such as one-to-one arm movement have revitalized the genre and given rise to several unique rhythm experiences. At the top of that list is certainly <em>Beat Saber</em>, developed and published by Beat Games. </p>
<p><em>Beat Saber</em> combines rhythm gameplay with VR saber combat to create a unique title that has players swinging virtual red and blue energy sabers to hit the corresponding color blocks in time with the music. Players must strike the blocks with the correct color saber at the correct angle while ducking and dodging wall obstacles  and mines that shouldn't be hit. All of this action is set to the tempo of the song. With a variety of tracks and difficulty settings, <em>Beat Saber</em> sets a new standard for rhythm experiences in the age of VR. In this game, we see two types of gameplay collide: VR combat (swinging at stuff and dodging) and rhythm mechanics. The combination creates an almost dancing experience that makes it easy to enjoy. Though be prepared for a workout even if you're playing this as a seated experience, as some of the songs get very energetic at times.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Educational experiences</h1>
                
            
            
                
<p>Since its inception, educators have been interested in VR as a way to instruct and train the next generation in a way that's engaging and allows the learner to see the material from a new perspective. New generations of students are looking for education institutions to embrace technology while providing a unique and experiential style of learning. To meet this demand, education software developers, college development teams, and even some game developers have begun creating VR experiences that allow students to experience history close up or to learn to use high-end equipment without fear of hurting themselves. Besides immersion and unique mechanics, VR can allow those who wish to learn something that takes expensive equipment or rare resources the opportunity to do so. Here are some of the titles currently available:</p>
<ul>
<li><em>The Body VR: Journey Inside a Cell</em>: This game uses the immersion of VR to allow the player to experience traveling in the bloodstream of a human being and enter a blood cell to see the inner workings at the cellular level.</li>
</ul>
<ul>
<li><em>Sharecare VR</em>: This application allows the player to explore the anatomy of the human body, simulate disease, and show how treatment interacts with the body. Players can also call up specific organs and enable the display of tags to show specific structures. This allows players to learn and study the human anatomy in ways that weren't possible previously.</li>
<li><em>Apollo 11 VR</em>: <em>Apollo 11</em> combines a passive viewing experience with occasional mini games to allow the player to live the Apollo 11 mission firsthand.</li>
</ul>
<p>I also want to mention <em>Tribe XR</em> here. Though the developers have chosen to teach users how to DJ using high-end equipment, the goal is to create a creative education platform that can be used to teach many skills and take advantage of what they refer to as exponential learning. As part of the plan for their platform, they're allowing vetted users, in this case other DJs, to teach those new to the platform both in recorded and live lessons. This mechanism has amazing potential for revolutionizing how schools and businesses teach and train their students. </p>
<p>VR has the ability to bring the user into the game worlds that we create and turn their movements into real in-game action. These two unique features have the potential to revolutionize how players enjoy video games and create new avenues for designers to express themselves creatively. However, we need to make sure that these new techniques for creating interaction within game worlds to become a crutch that props up poor design. Like the graphics advances of the early 20's, we mustn't let VR become a novelty and an excuse for bad games.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Designing the gameplay for Server 17</h1>
                
            
            
                
<p>Now that we've discovered some of the great VR games that our potential users are playing and dug deep into how VR helps to make them unique, let's look at how VR can really make the experience that lets <em>Server 17</em> shine. This is where we move from the Discovery and Empathy phases of our design process into the Ideate phase. Ideate is where the magic happens and where ideas are brainstormed and transformed into something more. For our user (first-time VR user, sci-fi fan, and nostalgic), we need to take into account that their status as first time users will mean that a basic locomotion scheme is important. We also want to make sure that the gameplay is intuitive and easy to learn. Current VR controllers are capable of several button-based functions, but we'll want to keep our control scheme simple to lower the learning curve and make our game accessible. Lastly, we want to make our environment simple yet really embrace the cyberpunk and future aesthetic.</p>
<p>With these things in mind, let's design. To keep locomotion easy and minimize VR sickness, we can use teleportation while keeping the gameplay area small. This will have the added benefit of playing into our cyberpunk background and the fact that the game level is meant to take place in a form of VR itself. We'll have the player press buttons and manipulate objects using some avatar hands. This allows us to make the gameplay as natural as possible, as well as making it easy to grasp quickly (pun intended). Gameplay will be centered around hacking a corporate server, reimagined as a techy-looking puzzle box in the center of the room that the player will have to solve by grasping parts to push and slide. We also want to provide the player with some special tools to speed the process up. These tools will be provided at different tool stations spread around the virtual room that represents the inside of the player's computer. Finally, to represent the danger of being discovered, the player will have to complete the puzzle box within a certain time frame. Here is a rough idea of the level:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/f1fa23a9-23b1-4cf5-8d42-23d01a5018ba.png" style="width:27.50em;height:35.33em;" width="1162" height="1492"/></p>
<p>Level map with design markings</p>
<p>Now, your instinct might be next to decide on the art style or to start making static meshes and shaders. Resist that urge! Despite the fact that the design sounds fun on paper, we don't know whether all of the features will work as intended or whether they're even as fun as we think they'll be. To test our assumptions, we need to move to the prototype stage of our design process and build a quick functional mock up and have our user test it to gain feedback. That way, we don't waste time or resources on game elements we might not use.</p>
<p>We'll start by implementing the hands.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Adding the hand functionality</h1>
                
            
            
                
<p>We want the player's experience with their in-game representation to be as smooth and as seamless as possible. To that end, the hand solution we implement needs to be able to do a few different things. First, the player needs to be able to see the hands. Second, the player needs to be able to know which objects can be interacted with and which ones might simply be there as scenery. Third, the player needs to be able to grab, pick up, and potentially throw objects that we want them to interact with. Fourth, we need the player to be able to press buttons inside the level to utilize the tools found at the different tool stations and to solve the puzzle cube.</p>
<p>The first step in following our design is to add the hand models to our <kbd>Server17PlayerPawn</kbd> to give our player a representation of themselves in the game. To do this, we'll add the standard hands provided for us by Epic Games to our pawn: </p>
<p class="CDPAlignCenter CDPAlign"><img src="img/03daea4b-be39-4c19-a297-23ace88d7d62.png" width="1950" height="1126"/></p>
<p>Hands added in the Class Blueprint screen</p>
<p>Here's how we add the hands:</p>
<ol>
<li>To have the hand meshes read the position of the player's motion controls, we'll start by adding a skeletal mesh component that's attached to the MotionController_L component in our pawn. Click on the MotionController_L component, and then click the Add Component button at the top of the Components panel. Select the Skeletal Mesh option and name the new component <kbd>SkeletalMesh_L</kbd>.</li>
<li>In the Details panel, find the Skeletal Mesh drop-down menu and select the MannequinHand_Right. This will add the hand to the end of the player's motion controller.</li>
<li>Since the hand is meant to be a right hand, we need to change a few settings to make it work correctly as a left hand. Find the Transform portion of the Details panel and change the X field of the Location property to -10. This will align the mesh more with where the player's physical hand is on the controller and will feel more natural.</li>
</ol>
<ol start="4">
<li>Move down to the Rotation property and change the X value to 90 degrees. This rotates the hand to a more natural position.</li>
<li>Move down one more property to the Scale property, and change the Z value to -1. This will flip the orientation of the hand to truly represent a left hand.</li>
<li>With the left hand complete, repeat steps one through four to create the right hand and name it <kbd>MotionController_R</kbd>.</li>
</ol>
<p>If we test now, we can see that the player pawn now has hands! Wave them in the air like you just don't care. However, they don't really do much other than look plastic, yet well manicured. Let's start to give them some functionality with the edition of some collision shapes so we can record when they overlap with an object. Let's start with the left hand:</p>
<ol>
<li>Select the MotionController_L component and navigate to the Add Component menu. Find the Sphere Collision component under the Collision section of the drop-down menu and select it. Name it <kbd>Sphere_L</kbd>.</li>
<li>In the Details panel, change the sphere radius to 10. This will define the area in which objects are considered overlapping with the player's hands.</li>
<li>Repeat steps one and two to create a collision sphere for the right hand and name it <kbd>Sphere_R</kbd>.</li>
</ol>
<p>Our hands are now set up to record overlap events so that we can manipulate objects in our game world. At this point, there are several actions we want these objects to perform. We want them to be able to detect when they're being looked at and when they're not. We also need them to know when we've performed some kind of action on them, an activated and a deactivated state. For this, we'll use something called a <strong>Blueprint Interface</strong>. A Blueprint Interface can be defined as a collection of one or more functions that can be assigned to objects that need to share data and functionality. It allows us to create a number of functions that each object that uses the interface can then define in a unique manner. In our game, we'll create an interface that contains all the functions that control how the hands manipulate gameplay objects.</p>
<div><em>Tribe XR</em> makes extensive use of Blueprint Interfaces to facilitate the creation and communication of its different user interfaces, since many of them share common elements. From the interface elements used to display music track information to the Options screen, they all have in common that they're 2D interfaces projected on to 3D planes. As we'll see from the following screenshot, creating a Blueprint Interface of common functions ahead of time can facilitate the creation of these menus:</div>
<div><img src="img/38d621c0-e383-461c-9d07-6511d4c23db1.png" style="width:24.83em;height:36.08em;" width="1347" height="1950"/></div>
<p>The Blueprint Interface option in the right-click menu</p>
<p>Start by creating a new Blueprint Interface:</p>
<ol>
<li>Make sure we're in our <kbd>Sever17\Blueprints</kbd> folder. Right-click in the Content Broswer and navigate to the Create Advanced Asset section of the menu. Find the Blueprints option and select Blueprint Interface. Name it <kbd>ObjectInteractionInterface</kbd>.</li>
<li>Double-click <kbd>ObjectInteractionInterface</kbd> to open it.</li>
<li>We'll need to create several functions here. Over on the right-hand side of the screen in the Functions section of the My Blueprints panel, click the plus (+) button to create a new function. Name it <kbd>TraceHitObject</kbd>. This will fire whenever our object is hit by a line trace from either the motion controller or the HMD, signifying that we're looking at it or interacting with it in some way.</li>
</ol>
<ol start="4">
<li>With our new function selected, look at the Details panel. This panel allows us to add input and output to our function to handle our data. Let's add an input named <kbd>Hit</kbd> and use the type Hit Result. Passing the hit data to the object allows us to access important information later.</li>
<li>To finish the function, we need to add a Boolean output named Return. Unreal Engine reads a function without an output as an Event, which isn't what we want. To avoid this, we use a dummy Boolean variable to complete the function.</li>
<li>The next function we need to create will be able to read when a trace leaves the object, giving us additional options for functionality. Head back to the Functions section of the <kbd>MyBlueprint</kbd> panel and create another function. Name it <kbd>TraceLeaveObject</kbd>. Create an input variable called <kbd>Hit</kbd> of the Hit Result type. Finish the function by creating a Boolean output and name it <kbd>Return</kbd>.</li>
<li>Now that the object can tell whether it's being looked at, let's take that functionality to the next level. It would be useful to have the object know what part of it's being looked at. We can do this by detecting the trace at the component level. Create a new function and name it <kbd>TraceHitComponent</kbd>. Just like our other functions, we need to create an input called <kbd>Hit</kbd> of the Hit Result type and an output called <kbd>Return</kbd> of the Boolean type.</li>
<li>To be able to read what component is being hit, we need to also add another input. Create a second input named <kbd>Component</kbd> and make it be of the type Primitive Component. This way, we can pass in what specific component is being hit.</li>
<li>Let's finish this functionality. Create another function and name it <kbd>TraceLeaveComponent</kbd>. This should have the same inputs and outputs as the <kbd>TraceHitComponent</kbd>.</li>
<li>Just a few more functions and we'll be finished! Let's create a function that can be called every frame to track the potential movement of an object. Create another function and name it <kbd>TraceMove</kbd>. This should have an input named <kbd>Hit</kbd> of the Hit Result type, and an output named <kbd>Return</kbd> of the Boolean type.</li>
<li><kbd>TraceMove</kbd> needs one more change to make it function correctly. Since this is a function designed to be called every frame, performance is definitely a concern. To optimize this function, we'll check two options. First, under the <kbd>Hit</kbd> input, click the little arrow next to the name of the variable and click the checkbox to make the function Pass-by-Reference. Passing by reference allows the <kbd>Hit</kbd> variable to be passed on by name without passing the value. Because we're selecting to pass the variable in this manner, we need to select the Const option in the Graph section of the Details panel. If you can't see the option, click the down arrow at the bottom of the section to expose the checkbox.</li>
</ol>
<ol start="12">
<li>Finally, let's create one more bit of functionality. We want to be able to activate and deactivate some kind of effect on an object. This covers a variety of potential scenarios, such as being able to turn a flashlight you picked up on and off. To create this effect, we need two more functions. First, create a new function and name it <kbd>TraceActivateDown</kbd>.</li>
<li><kbd>TraceActivateDown</kbd> will signify when a button has been pressed to activate the object. It needs two inputs. The first is named <kbd>Hit</kbd> and has a Hit Result type (so that a lot of great information is packed into a hit result). The second is named <kbd>Instigator</kbd> and is of the Pawn type. This way, we can pass in the Pawn that activated the object. Finish by creating an output named <kbd>Return</kbd> of the Boolean type.</li>
<li>If <kbd>TraceActivateDown</kbd> represents a button press, then we need our final function for our interface to represent the release of that button. Create one final function named <kbd>TraceActivateUp</kbd>. This should have the same inputs and outputs as <kbd>TraceActivateDown</kbd>.</li>
</ol>
<p style="padding-left: 60px">With everything completed, your interface should look something like this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/29a2c328-aeec-4a3b-ae12-3735ca8c44ce.png" style="width:19.83em;height:19.83em;" width="731" height="729"/></p>
<p>The My Blueprint section of ObjectInteractionInterface</p>
<p><kbd>ObjectInteractionInterface</kbd> now encapsulates many of the functions we would want an object to be able to perform. However, many of them depend on being the target of a line trace to be able to operate. A <strong>line trace</strong> is a function that can be called that will draw a line from one point to another and report anything that's hit by the line. Using that hit data, we can do all kinds of things! For instance, we can find the distance from the player to the object. We can act on the object to change color, emit sound, or other behaviors. We can even cause the object to delete itself if we wanted to. In shooter games, this is how direct-damage weapons, such as lasers, sniper rifles, or other weapons that don't really have a projectile, work. Since our line trace will be checking where our player is looking and will likely be used to figure out where they can teleport, we'll use a parabola, or curved line, rather than a straight line for our trace. To do this, we'll create a custom component that can be added to our HMD or motion controller that projects the line trace:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/5a5ca50d-8920-4c4f-9734-7d35dd30fc11.png" width="1862" height="1064"/></p>
<p>Created Interaction Component</p>
<p>We need to create a custom Scene Component that can be added to our custom pawn:</p>
<ol>
<li>In the Content Browser, right-click in the <kbd>Server17\Blueprints</kbd> folder and click the Blueprint Class option. In the bottom section of the Pick Parent Class window, search for Scene Component using the search box. Click it and then click the Select button. Name this new component <kbd>InteractionComponent</kbd>.</li>
<li>This new component is going to handle our line trace and any data that it collects. It'll then distribute the hit data through our interface to all of our interaction functions. Start by creating a new function by clicking the +Function button that's part of the My Blueprints panel. Name this new function <kbd>ParabolicLineTrace</kbd>.</li>
<li>We calculate the parabolic curve by taking the direction the interaction component is facing and calculate the projected curve based on a fixed point in time and a speed value. The formula is <em>z = (t * v<sub>z</sub>) - (0.5 * g * t<sup>2</sup>)</em>, where <em>z</em> is the projected end of the arc in the <em>z</em> axis, <em>v</em> is the velocity, <em>g</em> is gravity, and <em>t</em> is time. The distance the arc will cover is estimated by <em>y = t * v<sub>y</sub></em> where <em>y</em> is the end of the arc in the <em>y</em> axis. To have our function calculate our arc, it'll need three inputs. The first is named <kbd>Steps</kbd> and has a type of Integer. The second is named <kbd>TimeStep</kbd>, which is a Float value. Last, we have <kbd>Speed</kbd> of the Float type.</li>
</ol>
<p>If you don't understand the math, don't worry! The arc it creates is perfect for estimating the final location of our future teleport. Once complete, Unreal Engine 4 will be able to visually represent our line trace to us, and it'll make sense.</p>
<ol start="4">
<li>Double-click on our new function to open it. <kbd>ParabolicLineTrace</kbd> needs six local variables to work. Find the Local Variables section at the bottom of the My Blueprints panel. Click the +Local Variable button and create a new variable named Init Loc of the type Vector. Next, create one named Prev Loc, also of the type Vector. These will store the initial locations for our curve calculation.</li>
</ol>
<ol start="5">
<li>Create another local variable named <kbd>Velocity</kbd> of the type Vector. This is our speed value.</li>
<li>Now we need two local variables to handle our time calculation. Create two new local variables named <kbd>InTimeStep</kbd> of the type Float and In Steps of the type Integer.</li>
</ol>
<ol start="7">
<li>This is the last one! We need one more local variable to hold the hit data from the line trace. Create one final local variable named <kbd>TempHit</kbd> and make sure its type is set to Hit Result:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/38982226-4f8d-42f4-8b7d-a6e3469824ad.png" style="width:73.00em;height:41.25em;" width="1950" height="1101"/></p>
<p>Setting up the variables in the Parabolic Line Trace</p>
<p style="padding-left: 90px">With all of our variables finally set up, we can move on to creating our curve calculation.</p>
<ol start="8">
<li>The first step in our function is to store our location data. From your Local Variables section, drag in a copy of your <kbd>InitLoc</kbd> variable and choose Set. Do the same for your <kbd>PrevLoc</kbd> variable. Connect the execute output of the beginning of the function to the input on Init Loc. Connect the execute output on Init Loc to the input on Prev Loc.</li>
<li>Now we need to fill them with data. We need to start by knowing the location of the interaction component within the game world. Right-click in the blueprint window or use the Palette to grab a GetWorldLocation node. Connect the output of our new node into the Init Loc vector input, and then connect the vector output on Init Loc to the vector input on Prev Loc.</li>
</ol>
<ol start="10">
<li>Go back to the Local Variables section in My Blueprint and grab the In Steps and the <kbd>InTimeStep</kbd> variables, and choose Set for both of them. Connect the execute output of our Prev Loc node to the execute input on the In Steps node. Then, connect the execute output of In Steps to the input on In Time Step.</li>
</ol>
<ol start="11">
<li>To finish this section, we need to connect In Steps and In Time Step to their appropriate data input. Take the <kbd>Steps</kbd> input from our function and connect that to the integer input on In Steps. Finally, take the TimeStep input from the function and plug that into the float input on In Time Step.</li>
<li>There's one last bit of data to initialize before we calculate the curve. To get the velocity we'll use for the calculation, we'll need to determine the forward vector of our interaction component and multiply that by the <kbd>Speed</kbd> variable we take as an input into our function. Head back to the Local Variables portion of the screen and drag in a copy of the <kbd>Velocity</kbd> variable. Choose Set from the menu. Connect the execute output from our In Time Step node and plug it into our new Velocity node.</li>
</ol>
<ol start="13">
<li>Right-click in the blueprint and use the menu to find the Get Forward Vector node where the target is a Scene Component. Drag a line off the Return Value of the node and drop it to bring up the search menu and search for the <kbd>Vector * Float</kbd> node. The vector input will be the Return Value of the Get Forward Vector, and the float value will be the Speed input from the start of our function. The resulting value will become the input for the vector on the Set Velocity node:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/bf18caee-e945-4b91-aa93-299aae8065aa.png" width="1950" height="1259"/></p>
<p>Calculating a parabolic line trace in blueprints</p>
<ol start="14">
<li>With all of our variables straightened out, it's time for the fun part! Start the calculation by creating a ForLoopWithBreak node. Connect the execute output from our set Velocity to the execute input on ForLoopWithBreak. Drag in a copy of our local variable In Steps and plug that into the Last Index input on ForLoopWithBreak. Lastly, set the First Index integer to 1.</li>
</ol>
<ol start="15">
<li>Next, create a Line Trace By Channel node. This node will do all of the heavy lifting and create the actual line trace. Plug the Loop Body output from the ForLoopWithBreak into the execute input on our new line trace. On the line trace node, change the Draw Debug Type to For One Frame. This will help us to visualize the parabolic arc. We can always turn it off later. Now grab a copy of the <kbd>PrevLoc</kbd> variable and plug that into the <kbd>Start</kbd> input on the line trace.</li>
<li>Bring on the math! Let's start by getting a copy of the <kbd>Velocity</kbd> local variable. Right-click on the output of the variable and choose the Split Struct Pin option. This displays all the values that make up our velocity vector. </li>
<li>Now create three copies of the <kbd>Float * Float</kbd> node. We're going to plug the <em>X</em>, <em>Y</em>, and <em>Z</em> values we just exposed on the Velocity node into the top input on each of the multiplication nodes.</li>
<li>Create a copy of the <kbd>InTimeStep</kbd> local variable and an <kbd>Integer * Float</kbd> node. Plug the output of the variable into the float input on the multiplication node. The input for the integer section of the node comes from the <kbd>Index</kbd> output of the ForLoopWithBreak node. The output from this bit of math will be used by many nodes. </li>
<li>Take the output and plug it into the second float input on the multiplication nodes we created earlier in <em>step 17</em>. </li>
</ol>
<p>Don't forget, you can create reroute nodes to help clean your code! Right-click in the Blueprint as if you're creating a new node and find the Reroute node down toward the bottom of the menu.</p>
<ol start="20">
<li>It's time to compensate for gravity in our calculation. Create a <kbd>Float * Float</kbd> node and place it near the multiplication node created in <em>step 18</em>. On the newly created node, there's a button labeled + Add Pin. Let's click that twice to create two more input pins. Plug the output of the multiplication node from <em>step 18</em> into the first two input values of our new node (this represents time being squared in our equation). In the third input, change the value to 0.5. In the final input, change the value to 980.</li>
</ol>
<ol start="21">
<li>We've almost finished the math. Create a <kbd>Float - Float</kbd> node and plug the output of the multiplication node we use with the <em>Z</em> value from our <kbd>Velocity</kbd> variable into the first input and the output of the multiplication node we created in <em>step 20</em> into the second input.</li>
</ol>
<ol start="22">
<li>Finally, create one final math node, <kbd>Vector + Vector</kbd>, and right-click on the first <kbd>Vector</kbd> input pin. Select Split Struct Pin from the menu. The <em>X</em> value will be the output of the X Velocity multiplication node. The <em>Y</em> will be the output of the Y Velocity multiplication node. The <em>Z</em> value will be the output of the <kbd>Float - Float</kbd> we created in the last step. All of that will be added to the value of Init Loc. Create a copy of the variable and plug into the last input. The output of this node will become the End vector input on our line trace node.</li>
</ol>
<p style="padding-left: 60px">There's one last section regarding this function. With our Line Trace by Channel node getting all of the information it needs, we need to set up the output values to store the information that we receive from the trace. We'll do this by updating the location we've stored in our Prev Loc node and saving the hit result information into the TempHit node:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/80611f4e-3dcf-41e5-8d81-20a1bb0d0696.png" width="1933" height="1105"/></p>
<p>Completing the line trace</p>
<p style="padding-left: 90px">Let's wrap this thing up!</p>
<ol start="23">
<li>Create a SET node for our <kbd>PrevLoc</kbd> variable and connect the execute output from the line trace to its execute input. To update the vector input, drag a connection from the <kbd>Vector + Vector</kbd> node we created in <em>step 22</em> and plug it into the input.</li>
</ol>
<ol start="24">
<li>Next, create a Set node for the Temp Hit local variable and connect the execute output from our set Prev Loc node to the execute input. Connect the Out Hit output from the line trace into the input.</li>
<li>To make sure that we aren't making any unnecessary hit calculations when no hit is found, let's add a Branch node. Add a Branch node and connect the execute output from the set TempHit node to it. Pass the Return Value output from the line trace into the Condition input.</li>
<li>Bring the execute output from this node all of the way back to the ForLoopWithBreak node and plug it into the Break input.</li>
<li>Finish this by connecting the complete execute output to the input on the function's Return node. Create a copy of TempHit and pass that into the function's output.</li>
</ol>
<p>Now that the Parabolic Line Trace function is finally complete (wow! There's a lot going on there), it's time to do something with the hit information that it collects. The Interact With Hit function will take the hit data from the line trace and pass it to our functions we created in the Object Interaction Interface:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/d02b1a4b-07b4-47bb-ae1b-f2bf7f53a4e7.png" style="width:13.92em;height:18.75em;" width="698" height="939"/></p>
<p>The variables for the InteractWithHit function</p>
<p>Let's start by creating some variables:</p>
<ol>
<li>In the My Blueprints panel, find the Variables section and click the +Variable button. The first one we'll create will be named the <kbd>FocusComponent</kbd>. Set the Variable Type to Primitive Component. This will allow us to work with the individual components of an object as well as the object itself. Next, create a new variable named <kbd>FocusObject</kbd> and set the type to <kbd>Actor</kbd>. This will store the current object being hit. Finally, create a variable named <kbd>CurrentHit</kbd> and make its type <kbd>Hit Result</kbd> to store the hit information we collected from the line trace. Once we've created all three variables, click on each one and mark them Private in the Details panel.</li>
<li>It's time to create our second function. In the Functions section of My Blueprint, click the +Function button and name the new function <kbd>InteractWithHit</kbd>. The new function needs to have the ability to pass hit data into it. Click on the function, and in the Details panel create a new input named <kbd>Hit</kbd> of the type Hit Result.</li>
<li>Now we need to set up three Local Variables inside our new function. Double-click the <kbd>InteractWithHit</kbd> function and head to the Local Variables section. Click the +Local Variable button and name the new variable <kbd>InHitComponent</kbd> of the type Primitive Component. Create a second local variable and name it In Hit of the type Hit Result. Lastly, create a third local variable and name it In Hit Actor, and make it of the type Actor.</li>
<li>The initial setup is complete! With our variables created, we can now start initializing them with data. Starting at the function node, grab a copy of our In Hit local variable, and choose Set from the resulting menu. Connect the execute output from the function node to the input on the set In Hit node. We also want to pass the Hit data coming from outside of the function, so we'll connect the Hit pin on the function node to the input on the set In Hit node:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/1eb18fcf-bc24-4fd3-82f4-c47b62d9f77f.png" width="1927" height="1238"/></p>
<p>Taking in the hit data and storing it in our variables</p>
<ol start="5">
<li>Next, we're going to break the hit down and pass the Hit Actor and the Hit Component data to our local variables so that we can work with them. Right-click in the blueprint and create a Break Hit Result node. Connect the variable output of the Set In Hit node to the input on our new node. This will break the hit information down into its parts. Next, bring in a copy of our In Hit Actor and the <kbd>InHitComponent</kbd> variables, and choose Set from the menu. With the two setters created, connect them in the order you see in the previous screenshot. Then, connect the Hit Actor output from Break Hit Result to the input on the set In Hit Actor node. Be sure to do the same for Hit Component and the <kbd>InHitComponent</kbd> node.</li>
</ol>
<ol start="6">
<li>Much of what we're doing here is checking the data to see whether what we're looking at can be interacted with and then passing that information through the interface we created earlier. We also need to be able to clear our variables if we're no longer looking at something that has interaction. The first step in this process is to check to see whether the object we're looking at (stored in Focus Object) is equal to the one we're currently looking at, and for that we need a <kbd>Branch</kbd> node. Create a new <kbd>Branch</kbd> node and connect its execute input to the output from the Set <kbd>InHitComponent</kbd>. Now we need the two variables we want to compare. Get a copy of our Focus Object variable and our In Hit Actor local variable. Drag a connection off FocusObject and drop it to open the search menu. Look for the Equal (Object) node. This will compare two objects passed into it and return a Boolean showing whether they match. Connect the In Hit Actor to the second input and run the Boolean output into the input pin on the Branch:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/84cdf136-01e1-4a65-affb-22e455f437d2.png" width="1937" height="1053"/></p>
<p>Passing the data through our interface</p>
<ol start="7">
<li>With our Branch ready, it's time to pass the information. From the <kbd>True</kbd> output, drag a connection off and drop it to search for our Trace Move (message) function that we created earlier in the Object Interaction Interface. Get a copy of the Focus Object variable and pass that into the Target pin on Trace Move. Now get a copy of the In Hit variable and connect that to the <kbd>Hit</kbd> input on Trace Move.</li>
</ol>
<ol start="8">
<li>Create another Branch node and connect its execution input to the output from Trace Move. This time, we'll be checking to see whether the Focus Object is equal to the <kbd>InHitComponent</kbd> and passing the new information along if it's not. To do that, we need to get the Focus Object and the <kbd>InHitComponent</kbd> and use our Equal (object) node to compare them. Take the Boolean output of that comparison and plug it into the input on the new Branch.</li>
<li>The next node we need is another function from our interface. Right-click and search for Trace Leave Component (message). Create it and connect it to the False output on the last Branch. For input, we'll need to get a copy of the FocusObject and pass that into Target, In Hit, and pass that into Hit, and the FocusComponent and pass that into Component. </li>
<li>Now that we've called leave on the current focused component, we'll call the Trace Hit Component and have it pass the current component we're looking at. Create a copy of the Trace Hit Component (message) and connect it to the Trace Leave Component. Pass FocusObject into Target, In Hit into Hit, and <kbd>InHitComponent</kbd> into Component.</li>
<li>There is one final step in this branch of the process. We need to set the FocusComponent to our new the <kbd>InHitComponent</kbd>. Create a Set node for the FocusComponent, and get a copy of the <kbd>InHitComponent</kbd>. Connect the execute output from the Trace Hit Component to set the FocusComponent and pass the <kbd>InHitComponent</kbd> into the variable input pin. </li>
</ol>
<ol start="12">
<li>The branch we created was all about passing component data if the Focus Object and the In Hit object we're looking at are the same, but what if they're different? If they are, we need to clear the hit data and pass the new hit information through the interface. Go back to the Branch we created way back in <em>step 6</em>. Drag a connection from the <kbd>False</kbd> output and drop it. Search for the Trace Leave Object function and create the node. The Trace Leave Object has two input values. Into the Target input, we'll pass the object we're currently storing in the FocusObject. For the <kbd>Hit</kbd> input, get the current value of In Hit and connect it to the input pin:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/af012a2b-f0d3-4b15-b019-ecc85c8ca521.png" width="1931" height="1241"/></p>
<p>Clearing the variables</p>
<ol start="13">
<li>Since we're leaving the object and turning our focus elsewhere, we'll need to clear the values stored in the FocusObject and the FocusComponent. Create a Set version of each of the variables. Connect the new set FocusObject node to the execute output from Trace Leave Object. Connect the new set FocusComponent node to the set FocusObject node. We're leaving both of their input values empty to clear their values.</li>
</ol>
<ol start="14">
<li>Before we pass the new hit data forward, there's still one more check we need to do. We only want to pass on the hit information if the object we're looking at makes use of the Object Interaction Interface, since anything else wouldn't matter to us. It's our way as designers of creating objects that are interactable and others that are only meant to be scenery. To do this, we'll use another Branch node. Connect the input for the new branch to the execution output from the set FocusComponent. To check to see whether the object we're looking at uses the interface, we need to use the Does Implement Interface function. This function takes in an Actor and checks to see whether it has a specific interface attached to it, then returns a Boolean value—perfect for using with the Branch node. Create a copy of the Does Implement Interface. Pass in the value of the In Hit Actor as the Test Object and then click the drop-down menu under Interface. Use the search box at the top of the menu to find our Object Interaction Interface. With that set, plug the Return value from the node into the <kbd>Condition</kbd> input on our Branch. Our check is all set up:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/d57977ce-159a-491d-b73e-f71be8d77dac.png" width="1930" height="1240"/></p>
<p>Passing in the new hit data</p>
<ol start="15">
<li>Now all that's left is to pass on is the new hit data. Right-click in the blueprint and search for Trace Hit Object (message). Connect it to the True output from the Branch and pass the In Hit Actor into the Target input and the In Hit into the Hit input.</li>
<li>Next, create a copy of the Trace Hit Component (message) function. Pass the In Hit Actor into the Target input, In Hit into the Hit input, and the InHitComponent into the Component input.</li>
<li>In the final step for this branch, we'll need to update the values store in the FocusObject and the FocusComponent with the values from the In Hit Actor and the <kbd>InHitComponent</kbd>. Create a set FocusObject node and connect it to the execute output of the Trace Hit Component function. Pass the value of the In Hit Actor into the variable input. Lastly, connect the set FocusComponent execute input to the execute output from set the <kbd>FocusActor</kbd> and pass in the value from the <kbd>InHitComponent</kbd>. We've now completely finished using this function!</li>
</ol>
<p>It's taken quite a bit of programming to get here, hasn't it? However, we have made a huge amount of progress in building our hand interactions. Our Interaction Component now has the ability to do a parabolic line trace to find objects and safe locations to teleport. It can now pass information through the Object Interaction Interface we created to allow our interactable objects to work with the hands, to create gameplay. It's now time to bring that all together in the Event Graph to implement all of the functionality we've created. For this, we'll use the Event Tick node:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/dd5d5567-f1f3-4d9c-aa24-29b45998457e.png" style="width:64.75em;height:32.08em;" width="1929" height="956"/></p>
<p>Triggering the Parabolic Line Trace</p>
<p>Start by creating a couple of Custom Events:</p>
<ol>
<li>We'll need two custom events to represent the on and off states that we want the Interaction Component to have. The Custom Events will be called by elements outside this blueprint to trigger interaction using button presses on the player's motion controllers. Right-click near the Event Tick node and find the Add Event section of the menu. Open it and select the Add Custom Event option. Name this new event <kbd>Enable</kbd>. Repeat the process to create a second custom event and name it <kbd>Disable</kbd>.</li>
<li>Next, we'll use a Gate node to only allow the player to interact with objects when they've enabled the interaction component with a button. A Gate is a flow-control node that opens and shuts to allow data through only when the programmer allows it. Right-click in the blueprint and search for the Gate node. We'll connect the Event Tick output to the Enter input on the Gate. To control the flow of data, we'll connect the Execution output from our Enable custom event to the Open input and the execution output from the Disable custom event to the Close input.</li>
</ol>
<ol start="3">
<li>Now we'll add in our Parabolic Line Trace function. Grab a copy of it from the My Blueprints panel and drag it into the blueprint. Connect the execute output from the Gate to the execution input on the function. To make sure our parabola functions correctly, set the number of Steps to <kbd>10</kbd>, the Time Step to <kbd>0.1</kbd>, and the Speed to <kbd>500</kbd>. </li>
<li>The output from our line trace needs to be stored so that we can pass it to the Interact With Hit function. Luckily, we already created a variable to hold it. Create a copy of our <kbd>CurrentHit</kbd> hit variable by dragging it in from the My Blueprint panel and select Set from the menu. Connect it to the execute output from the line trace function and pass the Hit output from the line trace into it.</li>
<li>End the sequence by bringing in the Interact With Hit function and connecting the execute output from the set CurrentHit node to it. Connect the variable output from the set CurrentHit as the Hit input on the function.</li>
</ol>
<p>There's one final piece to this interaction puzzle. We need to add the interaction component to <kbd>Server17PlayerPawn</kbd> and map the functionality to buttons on the player's motion controllers. Let's start by adding two more custom events to the Interaction Component blueprint:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/e743e973-8b7f-4860-9a67-4ca3d1d3bdd2.png" style="width:41.42em;height:26.58em;" width="1929" height="1238"/></p>
<p>Activation section of the Interaction Blueprint</p>
<p>Every button has two states: an up and a down. We'll define these states by creating two Custom Events:</p>
<ol>
<li>Right-click in a new section of the blueprint, find the Add Event section of the menu, and open it and choose Add Custom Event. Name the first one <kbd>ActivateUp</kbd>. Create a second custom event and name it <kbd>ActivateDown</kbd>. Both events need to have a single input. Click on each of the custom events and click the + button in the Inputs section of the Details panel. Name the input <kbd>Instigator</kbd> and make its type Pawn.</li>
<li>Drag a connection off ActivateUp and search for Trace Activate Up (message). We created this function as part of our interface. Connect its execution to the ActivateUp event and connect the Instigator output from the event to the Instigator input on the function.</li>
<li>Trace Activate Up still needs two more input values to work correctly. Get a copy of the <kbd>FocusObject</kbd> variable and connect that to the Target input. Lastly, get a copy of the <kbd>CurrentHit</kbd> variable and connect that to the <kbd>Hit</kbd> input on the function.</li>
<li>We're going to repeat this process for <kbd>ActivateDown</kbd>—only, this time, we'll connect the Trace Activate Down (message) function from our interface.</li>
</ol>
<p>It's time to finish the setup in the player pawn:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/7886b243-86b5-4373-94a3-dbfad3fbc1ba.png" style="width:17.17em;height:22.00em;" width="721" height="924"/></p>
<p>Components setup in the player pawn</p>
<p>Start by adding a copy of the Interaction Component to each of the hands:</p>
<ol>
<li>In the Content Browser, find the <kbd>Server17PlayerPawn</kbd> and double-click to open it.</li>
<li>In the Viewport tab, head over to the Components panel and click the Add Component button. Use the search box to find our Interaction Component that we created. It'll be under the heading Custom. Click on it and name the new component <kbd>InteractionComponent_L</kbd>.</li>
<li>Drag and drop the new component on to the MotionController_L component. </li>
<li>Repeat <em>step 2</em> and <em>step 3</em> to create a second interaction component that's a child of the right motion controller. Name this one <kbd>InteractionComponent_R</kbd>.</li>
<li>Now we can tie our new interaction components to buttons on the controllers. This will give the player the power to finally interact with the world! Click on the Event Graph tab. In an empty section of the graph, right-click and search for the MotionController (L) Trigger event. Repeat the process to create a node for the MotionController (R) Trigger event:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/1dcf543a-67bd-4ed9-95ff-2fb87fcb877e.png" width="1931" height="1256"/></p>
<p>Mapping actions to our motion controllers in the player pawn</p>
<ol start="6">
<li>For each of our button events, we need to create two references to our custom events that we created back in the interaction component blueprint. Start by grabbing a reference to the left interaction component from the My Blueprints panel. Position it near the MotionController (L) Trigger event. Drag a line off it and drop it. Use the search box to find our Activate Down function. Connect it to the Pressed execute output on the left trigger event. Next, drag a connection off the Instigator input pin on the Activate Down function and drop it to bring up the search menu. Search for a reference to the <kbd>Self</kbd> variable. In this case, the player is the instigator of the activation.</li>
<li>Repeat the process for the MotionController (R) Trigger event by using a reference to the right interaction component.</li>
</ol>
<p>I chose to use the left and right triggers for interactions for a couple different reasons. First, it's a button that's natural for a first-time user to press to activate something or to make something happen. It's intuitive. Second, the button event exists with the Oculus Touch controllers and Vive motion controllers, so I wouldn't have to change anything to go between hardware. Later, we'll create a pickup interaction, and I will use the grip buttons for the same reasons.</p>
<p>In this first section of programming, we set up the hand static meshes and programmed the <kbd>ObjectInteractionInterface</kbd>, a collection of functions that can be utilized by the object we want the player to be able to interact with. This blueprint interface connects to our Interfaction Component, a custom Scene Component that has the ability to utilize a parabolic line trace function to find interactive objects. Finally, we mapped our Activate functionality to buttons on the Motion Controller as part of Player Pawn blueprint. In the next section, we'll build on to this new functionality to create a teleport mechanic. </p>


            

            
        
    </div>



  
<div><h1 class="header-title">Building the teleportation</h1>
                
            
            
                
<p>Now that the code for line tracing and interaction has been implemented, we can turn our attention to the teleport system itself. The goal of using teleportation in <em>Server 17</em> is to give our player an intuitive method of moving around our environment. Though teleportation is often seen as immersion breaking, I feel that the cyberspace environment in our game supports the idea of the player character being able to teleport around the space. To get started, let's first think about the parts of a VR teleport system:</p>
<ul>
<li><strong>Visuals</strong>: Players need to be able to visualize where they'll be moving to when they click the button. This can be done by projecting a line or an arc to where they'll land (we've done this through the debug option on our line trace that we set earlier). We should also have a visual on the surface they'll land on, to further highlight their landing point. Lastly, we might think about a particle effect and/or a sound effect to help enhance the player experience.</li>
<li><strong>Teleport code</strong>: This would be the actual functionality that's built within the blueprint. The code will need to handle the displaying of the visual elements, as well as the teleport itself. It would also be nice to build in some kinds of controls for us as designers to restrict the player to certain areas so that they can't teleport outside the area we've built for them or see things they aren't supposed to.</li>
</ul>
<p>Contrary to how we would normally start building a feature such as this (functionality, then art), here we'll start with a bit of the visual components. In this case, we need some visuals to be able to turn on and off to make sure our code is working. Building this system will also be an excellent test of how our interface and line trace code is working. Let's start with a visual on the ground for teleporting:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/c95d7262-db3f-4cf4-bdf2-c8327bd1c4aa.png" width="1874" height="1090"/></p>
<p>TeleportViz viewport</p>
<p>We start by creating a new actor blueprint:</p>
<ol>
<li>Right-click in the <kbd>Server17\Blueprints</kbd> folder of the Content Browser and select the Blueprint Class option from the Create Basic Asset section of the menu. Choose Actor from the Pick Parent Class menu and name this new blueprint TeleportViz. Double-click the blueprint to open it.</li>
<li>In the Viewport tab, head over to the Components panel and click the Add Component button. Choose Static Mesh from the menu. This should create a new static mesh component that's a child of the Default Scene Root.</li>
<li>Click on it and search for the Static Mesh section of the Details panel. There's an option called Static Mesh where we can set the shape we want to use. Click the drop-down menu and search for SM_FatCylinder, though you may use any shape you like. Name the piece <kbd>Visualizer</kbd>.</li>
</ol>
<ol start="4">
<li>The static mesh looks a bit plain. Let's spruce it up a bit with a custom Material to make it glow a bit and stand out. This will also serve as a great test for a potential art style for the overall environment of the game. In the Content Browser, navigate to the <kbd>Server17</kbd> folder, right-click in the Content Browser window, and create a New Folder. Name it <kbd>Materials</kbd>. Double-click the new folder and right-click in it to create a new Material. Name this material <kbd>M_TeleportViz</kbd>. Double-click the new material to open it:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/5df6e4d1-f23b-404d-85c5-59ebf3fede5f.png" width="1940" height="1126"/></p>
<p>TeleportViz Material</p>
<ol start="5">
<li>When we open the material, we're greeted with one large Result Node to get us started. Click on it, and let's tweak a few of the settings in the Details panel. Find the option labeled Blend Mode. We want our new material to feel high-tech, so let's change the mode to Translucent to give it a little bit of that feel. Next, find the Shading Model. Since we're going to give this element an emissive glow, let's change the model to Unlit. Lastly, check the box to make the material Two Sided.</li>
</ol>
<ol start="6">
<li>Now it's time to choose a color. Create a Constant 3 Vector by grabbing it from the Palette panel or holding the <em>3</em> key and clicking in the material blueprint. If you don't have the Palette open and would like it to be, click on the window button at the top right of your screen and choose Palette from the menu. Right-click on the new vector and select Convert to Parameter at the top of the resulting menu. Name the parameter Color. By making it a parameter, we're making it possible to use blueprints to change it if we needed to. This could be handy in the future.</li>
<li>Click on the Color node and click on the block of color in the Details panel to bring up the color picker. Choose any color you like and click the Ok button. If you would like to use the light blue color I have, set your RGB values to <em>R=0.84</em>, <em>G=0.74</em>, and <em>B=1.0</em>. Make sure you Alpha is set to <em>A=1.0</em>.</li>
<li>To give the material a bit of glow, let's create a Constant value and multiply that by our Color. Search for Constant in the Palette or right-click and use the search box. Right-click on the new node and select Convert to Parameter as we did for Color in <em>step 6</em>. Over in the Details panel, name this value Strength and set the default value to <kbd>10</kbd>. Finally, create a Multiply node and connect the output of the Color parameter as value <kbd>A</kbd> and the output of Strength as value <kbd>B</kbd>. Finish by connecting the output of the multiply to the Emissive slot on the Result node.</li>
<li>To give our new Color a bit of a gradient effect, we'll manipulate the texture coordinates a bit. Create a Texture Coordinate node by either using the Palette or holding the <em>U</em> key and clicking in the blueprint.</li>
<li>Next, we'll need a Component Mask. Create a copy of the node using the Palette or right-click in the blueprint and use the search box. In the Details panel, turn off the option to use the R channel. Connect the output from the Texture Coordinate to the input on the Component Mask.</li>
<li>Now create a Cosine node. A Cosine will ensure that the gradient starts from both ends of the material. This will connect to the output from the Component Mask.</li>
<li>Cosine outputs a value between -1 and 1. We need the resulting value to be positive only, so we'll use a One Minus node. This will give us values between 0 and 2. Create the One Minus node and connect it to the output of the Cosine node.</li>
<li>To bring the value back to between 0 and 1, we can divide the answer by 2. Using the Divide node, connect the output of the One Minus node as the <kbd>A</kbd> value. Click on the Divide node and find the value for <kbd>B</kbd> in the Details panel. Change this value to <kbd>2.0</kbd>.</li>
</ol>
<ol start="14">
<li>Now we're going to build in some control over the distance the gradient takes to go from opaque to clear. This is called <strong>Falloff</strong>. Create a new Power node and connect the output of our Divide node into the Base input on the new node. Next, create a Constant. This can be done using the Palette or the search menu, or by holding the one key and clicking in the blueprint. Right-click on it and Convert to Parameter. Name the parameter <kbd>GradientFalloff</kbd> and set the Default Value to <kbd>3</kbd>. Plug the output of this parameter into the Exponent, or Exp, input on the Power node.</li>
<li>To ensure the resulting value can never go above 1, we'll need to clamp the value. Create a new Clamp node and bring in the output from the Power node. Plug the output of the Clamp node into the Opacity slot on the result node.</li>
<li>Check that out! The result should be glowing and partially see-through. You can tweak the materials by adjusting the GradientFalloff, Strength, and Color parameters until it feels right to you. To complete the visual, head back to our TeleportViz class blueprint and click on the static mesh component. Using the Details panel, apply our new material and bask in the high-tech glow.</li>
</ol>
<p>With the visual component sorted, we can now build the functionality. To meet our needs of a system that can control where a player can teleport, we're going to create a volume that only allows players to teleport where we place it. It'll display our visual elements when it detects a line trace and will contain our teleport code. Start by right clicking in the <kbd>Server17\Blueprints</kbd> folder of the Content Browser and create a new Blueprint Class. Choose Actor from the Pick Parent Class menu and name it <kbd>TeleportVol</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/125c1126-9f18-4e83-a2a5-a064e534b8d8.png" style="width:41.42em;height:20.08em;" width="1902" height="920"/></p>
<p>The TeleportVol component</p>
<p>We'll start in the Viewport tab:</p>
<ol>
<li>TeleportVol has two components that make it work. The first is a box volume to detect collisions and line traces. The second is the visual elements we created earlier that we can turn on and off. Start by heading to the Components panel and creating a new Box Collision. Name the new component <kbd>TeleportVol</kbd>.</li>
<li>Click on TeleportVol in the Component panel. We want the collision box to cover a fair amount of space, but it really doesn't have to be that tall. In the Details Panel, find the Box Extents entry and change the values to <em>X=200</em>, <em>Y=200</em>, and <em>Z=1.0</em>.</li>
<li>Now we need to customize the collision a bit. In the Collision section of the Details panel, find the Collision section. Choose the Collision Presets drop-down menu and change it to Custom. Under Trace Responses, we want to set both options to Block. In the Object Responses section, change all of the options to Ignore. This will make the volume available for line traces, but nothing else.</li>
<li>With the volume customized, we can move on to the second component. In the Components panel, click the Add Component button and select Child Actor from the menu. This is a copy of a class blueprint that we can place inside this blueprint. We can essentially build a class blueprint out of class blueprints! Click the component and find the Child Actor Class option in the Details panel. Using the drop-down menu, set this option to TeleportViz. We also don't want it to be visible unless it's being hit by a line trace, so turn off the Visible option in the Rendering section of the Details.</li>
<li>Now we will move on to the code! We need this object to be able to react to line traces, right? Well, we wrote a whole interface for exactly that. This will be the first application of our Object Interaction Interface. To add the functions from the interface to this object, click on the Class Defaults that's just above the area where the Event Graph and Viewport tabs are located. This will open the default options for this class over in the Details panel. Find the Interfaces section and click the Add button. Search for the Object Interaction Interface in the menu and select it to add its functions to our teleport volume.</li>
<li>We now have access to every function we wrote in the interface. These can be found in the Interfaces section of the My Blueprint panel. Simply click the Arrow next to the word Interfaces to see them. We can even double-click on their names to open them. Open the following functions: <kbd>TraceMove</kbd>, <kbd>TraceHit</kbd>, <kbd>TraceLeaveObject</kbd>, and <kbd>TraceActivateUp</kbd>:</li>
</ol>
<p class="mce-root"/>
<p class="CDPAlignCenter CDPAlign"><img src="img/309921df-2090-4589-abc5-a451b0967525.png" width="1931" height="1255"/></p>
<p>The Trace Move function</p>
<ol start="7">
<li>For Trace Move, we need to program what happens as a line trace moves across our object. For the teleport volume, we want the visual element we created earlier (the glowing ring, TeleportViz) to move to wherever our line trace is hitting. To do this, we'll use a SetWorldLocation node. Right-click in the blueprint and search for Set World location. Choose SetWorldLocation (TeleportViz) from the list. Connect the execute output of the function node to its input and the execute output to the Return node.</li>
<li>SetWorldLocation needs a New Location input to know where to move TeleportViz to, and we can find that by breaking down the Hit result that comes as an input into the function. Create a Break Hit Result node and bring in the Hit from the function node as the input. We can take the Location output from the break and use that as the New Location input on the Set World Location.</li>
</ol>
<ol start="9">
<li>Next, choose the TraceHit function. In this function, we want to turn on the visibility of our TeleportViz mesh so that our player can see where they'll appear. Right-click in the blueprint and create a Set Visibility (TeleportViz) node. Connect it to the function node and to the Return node. On the node, turn on the New Visibility checkbox and the propagate to children checkbox.</li>
<li>Now, let's move on to the TraceLeaveObject function. This function will do something very similar to the TraceHit function, except we'll be turning the visibility back to off. Similar to the preceding, create a Set Visibility (TeleportViz) node and connect it to both the function node and the Return node. On the node itself, leave the box next to New Visibility unchecked, but do click the checkbox next to Propagate to Children:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/e6c7b19f-a084-49ef-afdc-24edcebd4f6b.png" width="1950" height="968"/></p>
<p>The Teleport function</p>
<ol start="11">
<li>Before we move on to the <kbd>TraceActivateUp</kbd>, we need to create a function that can handle the mechanics of the teleport. Over in the Functions section of the My Blueprint panel, click the + button and name the new function Teleport Player. Teleport Player needs to have a couple of input values to work. The first is named <kbd>Player</kbd> and will be of the type Actor. The second will be named <kbd>Loc</kbd> and this will be of the type Vector.</li>
</ol>
<ol start="12">
<li>The teleport itself will require a little bit of math and will need a bit of info from our Player Controller. Let's start the sequence by dragging an execute line from the function node and dropping it to open the search menu. Search for the Cast to PlayerController node and create it. Casting allows us to pretend to be another blueprint and is just one of many ways that allow us to communicate data between blueprints.</li>
<li>Casting requires an Object input, a reference to the specific object we're pretending to be to access its data. To get the exact PlayerController we need, click and drag a line off the Player input on the function node and drop it. Search for the Get Controller node and connect its output to the input on the Cast to PlayerController node.</li>
<li>Next, create a SetActorLocation node. This will do the actual teleporting by moving the player to the designated vector coordinates. Connect the execution output from the cast into the execution input on SetActorLocation. The target input should be set to the Player by dragging a connection from the Player input on the function node to the Target input on SetActorLocation.</li>
<li>It's now time to calculate the new location! To start, we'll need to get the location of two things: the player and the player camera. To get the player's location, drag a line off the Player input on the function node and drop it to open the search box. Search for the GetActorLocation node and create one. We'll need this data in a moment.</li>
<li>Drag a line off the as Player Controller output from our Cast to PlayerController node and use it to search for the Get Player Camera Manager node. Drag off the output of that and search for the Get Camera Location node.</li>
<li>Here is the math part: We need to subtract the location of the player's camera from the location of the player itself to find the true location of the HMD for our teleport. For that, we'll need a Vector - Vector node. The top input will be the vector output from our GetActorLocation node. The bottom input will be the vector from the GetCameraLocation node.</li>
<li>We're almost there! Right-click on the output pin of our <kbd>Vector - Vector</kbd> node and split the struct pin. We only need the X and Y value for the next part of the calculation. Create a new <kbd>Vector + Vector</kbd> node and split the struct pin on the top input. Connect the X and Y output values from <kbd>Vector - Vector</kbd> into the <em>X</em> and <em>Y</em> input values on the <kbd>Vector + Vector</kbd> node. The bottom vector input comes from the Loc input from the function node. Drag a connection from the Loc input on the function node and connect it to the bottom vector input on the <kbd>Vector + Vector</kbd>. </li>
</ol>
<p>Don't forget that you can use reroute nodes to clean up your code to make it organized and readable. Reroute nodes can be found in the search menu if you drag off a connection and drop it. They can also be created by double-clicking on the connection where you would like to create one.</p>
<ol start="19">
<li>With that, the calculation is complete! Plug the output from the <kbd>Vector + Vector</kbd> node into the New Location input on SetActorLocation to complete the sequence:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/30b5f54e-1ce3-42e8-8e02-6c0fdfae4215.png" width="1931" height="1101"/></p>
<p>Trace Activate Up</p>
<ol start="20">
<li>The last function to program is Trace Activate Up, or what happens when a player releases the button of their motion controller. Click the tab we opened earlier or double-click the function name in the Functions section of the My Blueprint panel. Using our new Teleport Player function, we're going to move the player to the new location. Grab a copy of our Teleport Player function and drag it into the blueprint. Connect the Instigator input from the function node to the Player input on Teleport Player.</li>
<li>Calculating the exact location to teleport to just a bit more math. Drag a line off the Hit input on the function node and drop it to open the search menu. Create a Break Hit Result node and right-click on the Location output to split the struct.</li>
</ol>
<ol start="22">
<li>Create a Get Actor Location node and position it near the Break Hit node. Right-click on the vector output and split that struct pin as well.</li>
<li>Next, right-click on the Loc input on the Teleport Player node and (you guessed it!) split the struct pin.</li>
<li>It's time to pass in the <em>XYZ</em> values! Connect the Location X and Location Y outputs from Break Hit to the Loc X and Loc Y inputs on Teleport Player. Also, connect the Z output from the Get Actor Location node to the Loc Z input on Teleport Player. </li>
<li>Finish the sequence by connecting the execute output from Teleport Player to the Function Return node.</li>
</ol>
<p>With the teleport volume complete, we can now test our ability to teleport, as well as all of the systems that support it (parabolic line tracing and the Object Interaction Interface). Throw a few of the TeleportVol blueprints down in your test level and go nuts trying it out! If everything works, we can move on to building a prototype puzzle box.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">The server – Building the puzzle box</h1>
                
            
            
                
<p>With the player now having the ability to touch things and teleport around our test level, it's now time tackle the puzzle box. In <em>Server 17</em>, the puzzle box is a graphical representation of the player hacking into a remote server and stealing data. The final version may contain several puzzles to solve and dozens of steps to complete. However, for this first prototype version, we're going to design and build a simple three-step box as shown as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/22b17ba4-639d-4bce-bb60-576804297a58.png" style="width:21.67em;height:17.67em;" width="1410" height="1150"/></p>
<p>This design requires the player to find and remove a panel on the box to reveal a button that unlocks the front of the box. This panel can then be removed by grabbing it and moving it to the side revealing another switch. The final step is to then press the switch and find the removable panel to steal the data.</p>
<p>Building this in Unreal Engine 4 will have us creating a few things:</p>
<ol>
<li>We'll need to create additional functionality for the hands that our interface currently doesn't cover, such as grabbing, dragging, and pressing.</li>
<li>We'll need an object that responds to the player's touch and can be grabbed, moved, and thrown.</li>
<li>We'll need interactive buttons that can trigger events.</li>
<li>We'll need to build the box itself using child actors and code to turn the interactive elements on and off.</li>
</ol>
<p>When complete, we'll have an amazing test platform that can be used to prove that <em>Server 17</em> is fun and that can be tested by our target demographic. The first step in moving forward is to build a second interface to hold our button interactions:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/a7325795-74eb-4ff8-973e-92780b0956bd.png" style="width:13.42em;height:16.42em;" width="692" height="844"/></p>
<p>Button Interaction Interface</p>
<p>It's time to create the Button Interaction Interface:</p>
<ol>
<li>Head to the Content Browser and navigate to our <kbd>Server17\Blueprints</kbd> folder. Right-click in the browser and navigate to the Create Advanced Asset section of the menu. Highlight the Blueprint Entry and choose the Blueprint Interface option. Name the new interface <kbd>ButtonInteractionInterface</kbd>. Double-click the new interface to open it.</li>
</ol>
<ol start="2">
<li>In this interface, we'll create nine different functions that represent the different states of the actions we're creating. The first is a function to determine what to do when we're hovering our hand over something. Find the Functions section of the My Blueprint panel and click the + button. Name the new function <kbd>OnHover</kbd>. <kbd>OnHover</kbd> will need one input named <kbd>Interactor</kbd> of the type Interaction Component. It'll also need an output named Return of the Boolean type to make it function properly.</li>
<li>The next function will be named <kbd>EndHover</kbd> and controls what happens when the player's hand leaves an object. It has the same input and output as the previous function.</li>
<li>Now we'll create the <kbd>OnPickup</kbd> function to cover what happens when we want to pick up an object, which is a very common interaction in VR. It has the same input and output as the last two functions.</li>
<li>Next is the  <kbd>OnDrop</kbd> function; this will give us the opportunity to create additional functions when the player drops an object. It also has the same input and output as the last few functions.</li>
<li>The next three functions control the dragging of objects and allow us the opportunity to create even more gameplay with these actions. Create functions named <kbd>OnDrag</kbd>, <kbd>OnDragStart</kbd>, and <kbd>OnDragEnd</kbd>. They have the same input and output as all of the other functions that we've created here so far.</li>
<li>Finally, here's one that's different! Create a new function and name it <kbd>CanPickUp</kbd>. This function controls a Boolean that determines whether something is allowed to be picked up. It only has one output: a Boolean with the name <kbd>PickUp</kbd>.</li>
<li>This is the last one. Create one more function. This one is named <kbd>OnUse</kbd> and allows us to create objects that can be used as power ups. <kbd>OnUse</kbd> has input and output identical to <kbd>OnHover</kbd>.</li>
</ol>
<p>We now have a second interface that allows us as designers as much freedom to create interactions as we have imagination. To test out our new player abilities, let's build a basic cube that can be interacted with in several different ways:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/2d15ebff-52b5-4770-b564-b8a5776b9cfd.png" width="1901" height="1269"/></p>
<p>InteractCube with interface</p>
<p>To test our systems (and have a little fun), we're going to create a cube that utilizes many of the new functions that we've created in this chapter:</p>
<ol>
<li>Make sure you're in the <kbd>Server17\Blueprints</kbd> folder and right-click in the Content Browser to create a new Blueprint Class. Choose Actor in the Pick Parent Class menu and name our new blueprint <kbd>InteractCube</kbd>.</li>
<li>Click the Add Component button in the Components panel and choose the Cube option from the Common section of the menu. In the Details panel, find the Scale values near the top and set the values so that X=0.3, Y=0.3, and Z=0.3.</li>
</ol>
<ol start="3">
<li>It's time to add the interfaces. Click the Class Defaults button at the top of the screen. In the Details panel, click the Add button in the Interfaces section. Search for and add both the Object Interaction Interface and the Button Interaction Interface.</li>
<li>Now we have a load of functions to play with! Let's start with a way to tell when the cube is being hit by a line trace. Open the Interfaces section of the My Blueprints panel and open the <kbd>TraceHitObject</kbd> function. Right-click in the blueprint and search for the set Vector Parameter Value (Cube) on the Materials node. This node allows us to access the Color parameter on the cube's default material. Connect it to the function node and the Return node. Next, set the value of Parameter Name to Color. Finally, let's turn the cube red by changing the Parameter Value X value to 1.0. Now the cube will turn red when hit by a line trace!</li>
<li>Let's set the color back to white when the line trace leaves the cube. Double-click the <kbd>TraceLeaveObject</kbd> function in the Interfaces menu. Grab the same set Vector Parameter Value (Cube) node we used before, only, this time, set the values of Parameter Value to X=1.0, Y=1.0, and Z=1.0.</li>
<li>Having fun yet? Let's open the <kbd>TraceActivateDown</kbd> function from the Interfaces menu. Using the same preceding technique, create the Set Vector Parameter Value (Cube) node, type in the Color for the Parameter Name, and set the values of Parameter Value to X=0, Y=1.0, and Z=0. Our cube now turns green when we click the button to interact with it!</li>
<li>If we use <kbd>TraceActivateDown</kbd>, we should probably use <kbd>TraceActivateUp</kbd>. Let's set it up to change the color back to red when we release the button. Open the function and create another set Vector Parameter Value (Cube) node. Wire it into the function, set the value of Parameter Name to Color, and change the values of Parameter Value to X=1.0, Y=0, and Z=0.</li>
</ol>
<p>Want to have a little more fun with our functions? Use the Add Impulse node where the target of the node is a Scene Component to create a sudden upward acceleration. Replace one of the set Vector Parameter Value nodes with Add Impulse and change the Z value of the Impulse parameter to 5000. Make sure to turn on the checkbox for Velocity Change. This will shoot the cube skyward when the button is pressed or released!</p>
<ol start="8">
<li>How about we try the cube able to be picked up and thrown? To create this mechanism, we'll have Unreal simulate physics on our cube and then toggle this feature off and on when we pick up and drop the cube. Open the <kbd>OnPickup</kbd> and <kbd>OnDrop</kbd> functions. In <kbd>OnPickup</kbd>, right-click in the blueprint and search for the node set Simulate Physics (Cube). Wire the execution input and output the the function node and the Return node, as it'll be the only node we use in this function. This will disable the physics when the cube is picked up so it won't fall out of the player's hands or exhibit other strange behavior. Now open <kbd>OnDrop</kbd> and create another copy of set Simulate Physics (Cube). This time, turn on the checkbox next to the option to Simulate Physics on the node. This will enable the physics when the cube is dropped so it behaves the way we intend. Finally, head back to the Viewport tab and click on the cube. Check the Details panel to make sure the Simulate Physics option is turned on. If it's not, enable it.</li>
<li>There's one more function to set up. Go back to the Interfaces section of the My Blueprints panel and open the <kbd>CanPickUp</kbd> function. To make it so we can toggle this feature on and off, we're going to need a Boolean that we can toggle. In the Variables section, click the + button and create a new Boolean variable named <kbd>PickUpActive</kbd>. Back in the <kbd>CanPickUp</kbd> function, drag in a copy of our new variable and choose get from the menu. Plug the output of <kbd>PickUpActive</kbd> into the <kbd>PickUp</kbd> input on the Return node.</li>
</ol>
<p>To make use of these new functions, we'll need to set up a way to call them in the Interaction Component, as well as map them to buttons in <kbd>Server17PlayerPawn</kbd>. This is exactly like what we did when we created the Object Interaction Interface earlier in this chapter. Head back to the Content Browser and open the Interaction Component:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/3aff3444-e764-42b6-bb2e-d0e8560ed210.png" width="1855" height="1086"/></p>
<p>The Hover interaction component code</p>
<ol start="1">
<li>Inside the Interaction Component, we need to add some of the new player functionality, but the current code doesn't allow for that kind of expansion. To change that, we're going to use a Sequence node. The Sequence node is a flow-control node that implements the code connected to each of its output pins in order. To implement our new functions, we'll want to add the Sequence node after the Gate. Right-click in the blueprint and search for the Sequence node. Once created, click the Add Pin button in the bottom-left portion of the node. This will add an additional execution output. Connect the Sequence right after the Gate and connect the Parabolic Line Trace node to the execution output labeled Then 0.</li>
</ol>
<ol start="2">
<li>Before we begin implementing the Hover, Drag, and Pickup features, we'll need a few more variables. Click the + button in Variables section of the My Blueprint panel and create a new Float variable named <kbd>InteractRadius</kbd>. Compile the blueprint and give it a default value of 10. Next, create two variables of the type Actor, one named <kbd>HoverObject</kbd> and the other named <kbd>HeldObject</kbd>. Finally, create one more Boolean variable and name it <kbd>Dragging</kbd>.</li>
</ol>
<ol start="3">
<li>Let's start by implementing the Hovering and Dragging behavior. Drag an execute line from the Then 1 output on our new Sequence node and drop it in a clear area of the blueprint. The node we're looking for is called SphereOverlapActors and is designed to return the objects that it detects within a specific radius. </li>
<li>SphereOverlapActors needs four different input values. The first is Sphere Position (or Pos). We want the sphere to detect from wherever the interaction component is located. Drag a line from the Sphere Pos input and drop it. Search for the GetWordlocation node. This will give us an input of where the interaction components are in world space.</li>
<li>For the next input, grab a copy of our InteractRadius variable and choose Get from the menu. This will give a 10 cm detection radius for our interactions and make that radius easily adjustable through the variable.</li>
<li>Now we want to filter what the player can interact with. Drag a line off the Object Types input and search for the Make Array node. Click the Add Pin button on the node and use the two drop-down menus to choose the WorldDynamic and PhysicsBody options.</li>
<li>Finally, we want the player to ignore anything classified as itself so one motion controller can't interact with the other motion controller, for example. Right-click in the blueprint and use the search box to find the Get Owner node. This will return a reference to the player as an Actor. Since SphereOverlapActors only accepts an array as an input for Actors To Ignore, we'll need to insert the output from Get Owner into an array. Drag off from the Return value on Get Owner and drop it. Find the Make Array node and plug the resulting array into the final input on SphereOverlapActors.</li>
</ol>
<ol start="8">
<li>SphereOverlapActors will now return an array of objects that match our criteria. With the output, we need to do a quick check to see whether the HoverObject we've stored in the variable is the same as the one we just took in. If they're the same, there's no reason to proceed; this will save us a bit of performance. Drag off the Out Actors output and search for the Get node. This will retrieve the item from the area at index 0 (the array should only contain one object). Next, get a reference to our HoverObject variable. Finally, to compare them, drag off the HoverObject variable and search for the NotEqual node. One input should be our HoverObject and the other should be the output of our Get node:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/f2bf60cc-79da-45c4-b2df-6ac9f309ee46.png" width="1932" height="1052"/></p>
<p>The second part of the Hover code</p>
<ol start="9">
<li>NotEqual will return a Boolean, so we'll need a Branch to continue. Connect the Branch to the execution output from the SphereOverlapActors node. The condition will be the result of the NotEqual node and we'll move forward only if it's <kbd>True</kbd>.</li>
<li>If our comparison is True and the two objects aren't the same, we're going to need to end the hovering behavior on the current object and set up the hovering or dragging behavior to work with the new object. Drag off from the True output on the Branch and search for our EndHover function from our Button Interaction Interface. Get a copy of our HoverObject variable and plug that into the Target input and use a Reference to Self as the Interactor input.</li>
</ol>
<ol start="11">
<li>Next, create a copy of our EndDrag function and connect it to the execution output from our EndHover node.</li>
<li>Now we need to update the HoverObject variable with the new object we're hovering over. Drag in a copy of HoverObject  and choose Set from the menu. The input will be the output from our Get node from earlier.</li>
<li>Lastly, we'll call the <kbd>OnHover</kbd> function to complete the sequence. Create a copy of our <kbd>OnHover</kbd> function and connect that to the execute output from the set HoverObject. The variable output from set the HoverObject can be used as the Target. Use a Reference to Self as as the Interactor input.</li>
</ol>
<p>Our hovering code allows us to detect what the player might be reaching out for or holding their hand over, such as a button or an other component. Next, we'll tackle Dragging:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/09a90731-f6c6-4f8d-b1c6-f9a9eab29e41.png" width="1907" height="656"/></p>
<p>Dragging code</p>
<p>For Dragging, we'll need to create two Custom Events that can be called from outside the blueprint. This is exactly the same technique we used to implement our ActivateUp and ActivateDown behavior earlier:</p>
<ol>
<li>To start, we'll create two Custom Events. Right-click in the blueprint and choose the Add Custom Event option. Name the first one <kbd>StartDrag</kbd> and the second one <kbd>EndDrag</kbd>.</li>
<li>For both of our new events, we basically want to turn our Dragging Boolean on and off while calling our OnDragStart and OnDragEnd functions. Let's start with StartDrag. Grab a copy of our Dragging variable and choose Set from the menu. Connect the execution output from our event to set Dragging and click the checkbox on the node to set it to True.</li>
</ol>
<p class="mce-root"/>
<ol start="3">
<li>Now we'll call our OnDragStart function. Drag a copy of OnDragStart into the blueprint from the Interfaces section of My Blueprint and connect an execution line from set Dragging. Plug in a copy of our HoverObject variable as the Target and use a Reference to Self as the Interactor.</li>
<li>Next, we can work with our EndDrag custom event. The first step is to check to see whether our Dragging Boolean is True; if it is, then we can end the current drag. Create a new Branch node and connect the execute output from our event to it. Get a copy of Dragging and connect this to the Condition input on the Branch.</li>
</ol>
<ol start="5">
<li>If Dragging is True, we need to update the variable and end the drag. Create another copy of Dragging, only this time choose Set from the menu and connect the True output from the Branch to it. Make sure the checkbox on Dragging is clear.</li>
<li>It's time to create a copy of our OnDragEnd function. Connect the execute output from set Dragging to the execute input on our new node. Just as we did for OnDragStart earlier, connect HoverObject as our Target and use a Reference to Self as the Interactor.</li>
<li>It's time to bring these two sequences together. We'll use a Gate to control whether or not something can be dragged with our custom events controlling whether the Gate is open or closed. Create a new Gate node and connect the output from OnDragStart to the Open input and bring in the output from OnDragEnd into the Close input. We'll connect the Enter input to the Then 2 input on our Sequence node from earlier.</li>
<li>The final step to completing the drag is calling the OnDrag function. Create a copy and connect it to the Exit output from our Gate node we created in the last step. Just as we did for our previous drag functions, we'll connect a copy of our HoverObject variable to the Target input and plug in a Reference to Self as the Interactor.</li>
</ol>
<p>We can now drag objects! Such a behavior might be useful in programming levers and other similar pieces that can be moved but not necessarily picked up. Speaking of picking up, the next feature we'll tackle is the ability to pick things up and throw them. Much like hovering or dragging, there's a similar trick to the pick-up-and drop behavior that happens behind the scenes. Most of the objects, but not all, will start with their Simulate Physics option enabled. The trick is this: when the object is picked up in VR, we'll attach the object to the player's hand so it can't get away from them. We will also disable the physics on the object (we set this up earlier in the OnPickup function of our InteractCube). When we put down the object, we detach it from the player and re-enable the physics. Since the player never sees any of the changes, it looks to them as if they just picked up the object and then put it down. Cool, huh?</p>
<p>Let's build it:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/c209bda3-9713-4d48-9023-2d7cd141b16f.png" width="1938" height="772"/></p>
<p>Pickup code</p>
<p>Just as we did for the dragging behavior, we'll start by creating two custom events: one for Pickup and one for Drop:</p>
<ol>
<li>Right-click in our blueprint and create two new custom events with the Add Custom Event option. Name the first <kbd>Pickup</kbd> and the second <kbd>Drop</kbd>.</li>
<li>We'll start by building the pickup behavior. We need to start by checking whether the object the player is hovering over is a valid object. Right-click in the blueprint and search for the IsValid node. The version we need is marked with a question mark as its icon. Connect it to our Pickup event and create a copy of our HoverObject variable, which will serve as the input for the Input object pin on the node.</li>
</ol>
<ol start="3">
<li>Now that we know whether the object is real (in a manner of speaking), we can check to see whether we can pick it up! Create a copy of our CanPickUp function and connect HoverObject as the Target. This will return a True or False, which will determine whether the player can pick up the object.</li>
</ol>
<ol start="4">
<li>Next, we need a Branch to process the Boolean from CanPickUp. We only want the player to pick things up if this is True. Create a new Branch node and connect it to the execute output from CanPickUp. The Condition input will be the PickUp output from CanPickUp.</li>
<li>We know now whether the object is real. We also know whether we're allowed to pickup it. Now it's the time to do the heavy lifting. Create a copy of our HeldObject variable and choose set from the menu. The input for Set HeldObject will be the current value of HoverObject.</li>
</ol>
<ol start="6">
<li>Next, create a copy of the AttachToComponent node, making sure we're using the Target is Actor version. Connect it to the output of  the set HeldObject. Also, pass the variable output of set HeldObject into the Target input on AttachToComponent. Now create a Reference to Self and plug that into the Parent input. Lastly, set the Location Rule, Rotation Rule, and Scale Rule settings in the node to the Keep World option. This will maintain the basic attributes of the object we pick up so that, when we drop it, everything will remain the same.</li>
<li>The next step is to call our OnPickup function to trigger any special behaviors we might want for that object. Create a copy of OnPickup and connect the output from AttachToComponent to it. Connect a copy of the HeldObject variable to the Target input and use a Reference to Self as the Interactor.</li>
</ol>
<ol start="8">
<li>Now that we have the ability to pick things up and drop them, we may want the player to be able to use something they're hovering over. To create this behavior, we'll need to create a custom event named UseHovered. Next, create a copy of our <kbd>OnUse</kbd> function and connect it to our custom event. Get a copy of our HoverObject variable to use as the Target. Finish the node with a Reference to Self to use as the Interactor:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/90ff10c8-2d12-499d-b05a-605af0ccfc64.png" width="1931" height="1250"/></p>
<p>Pickup/Drop and Hover/Drag code in player pawn</p>
<ol start="9">
<li>To be able to utilize our new behaviors (Hover, Drag, Pickup, and Drop), we'll need to map them to buttons on the player's motion controller. Let's add hover and drag to the triggers. Open <kbd>Server17PlayerPawn</kbd> and find where we mapped ActivateUp and ActivateDown to the motion controller triggers. We'll start with the left trigger. Extend an execute line from ActivateDown and drop it to search for our UseHovered function (referencing the left interaction component). Next, drag off the reference to InteractionComponent_L and search for the StartDrag function. Connect this to the execute output on the UseHovered function. Finish by dragging off the reference to InteractionComponent_L again and searching for EndDrag. We'll connect this to the execution output from ActivateUp. Now we can use hovered objects, as well as start and end drag sequences!</li>
<li>Repeat the same process for the right motion controller.</li>
</ol>
<ol start="11">
<li>Finally, it's time to map the pickup and drop behaviors. Many games map this type of behavior to the grip buttons as players seem to naturally gravitate toward using these buttons, for this interaction. Right-click in the blueprint and search for the MotionController L Grip1 event. Drag an execution line from the Pressed output and search for our Pickup function (referencing the left interaction component). Now drag off the reference to InteractionComponent_L and search for the Drop function. Connect this new function to the Released output on the event. As before, repeat this process for the right motion controller as well.</li>
</ol>
<p>Done! To test the behavior, let's drop a few of these wonderful cubes in our level and test their functionality. Pick them up, throw them, and watch them change color. Pretty cool, right? Just think about all of the possibilities for gameplay with the power you now hold within this cube. It gives you ideas, doesn't it? Before we get to implementing those ideas, why don't we add one more tool to our toolbox in the form of a button our players can press:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/8001be16-b35c-49bd-b788-a72c4621d8d2.png" width="1950" height="1099"/></p>
<p>Button press code</p>
<p>We can start building our button in the Viewport:</p>
<ol>
<li>Our button will be built from three different components. In the Viewport tab, click the Add Component button and create a new Scene Component. Name this <kbd>ButtonRoot</kbd> . Next, create a Cylinder component and name it <kbd>Button</kbd>. We'll need to scale the cylinder down a bit so change the X, Y, and Z values for the Scale property to 0.05. Also, change its Collision Preset to OverlapAllDynamic. Make sure the button is a child of the ButtonRoot. Lastly, create one more Cylinder component named <kbd>ButtonBase</kbd> and make sure that it's a child of the Default Scene Root. We'll need to change the Scale property here too. Change the scale values to X=0.15, Y=0.15, and Z=0.05. Finally, set its Collision Preset to NoCollision.</li>
<li>Now that the visual components have been created, we can move on to the blueprint. We want to create a button that animates a bit when the player hovers their hand on it, and, for that, we'll need a few variables. The first we'll create is named <kbd>InitOverlapLoc</kbd> of the type Vector. This will store the location where the player's hand started overlapping. The second is <kbd>MaxPressAmout</kbd> of the type Float. This will be an adjustable variable so that we can fine tune how much the player needs to press the button for it to fire. Compile the blueprint and set the default value of this variable to 4. The third variable we need is named <kbd>PressAmount</kbd> of the type Float. This will store the amount that the player has pressed the button. Lastly, we need to store the name of the component that over lapped the button. Create one more variable and name it <kbd>OverlapComponent</kbd>. Make sure its type is Primitive Component.</li>
<li>We're going to start our first code sequence with two events. Click on the Button component we created earlier and head to the Details panel. Near the very bottom of the list in the Events section of the menu is a collection of buttons that allows you to create almost every event compatible with our Button. We need to create two: OnComponentBeginOverlap and OnComponentEndOverlap. This will detect when the player's hand is pressing the button.</li>
<li>OnComponentBeginOverlap feels like a good place to start, since it's the event that kicks everything off. The first step is to check and see whether the component overlapping the button is valid. Create a copy of the IsValid node (remember the one with the question mark?). Connect it to the event and get a copy of our OverlapComponent variable to be pluged into the Input Object pin.</li>
<li>If our OverlapComponent isn't valid (meaning the variable is empty), we need to store whatever overlapped the button as our new value for OverlapComponent. Grab another copy of OverlapComponent, only, this time, choose Set from the menu. The input for the new node will be the Other Comp input from the event node.</li>
</ol>
<ol start="6">
<li>With the OverlapComponent set, we now also need to set its location in our InitOverlapLoc variable. Right-click in the blueprint and grab a copy of the GetWorldLocation node where the target of the node is a Scene Component. Connect the execute input to the execute output of set OverlapComponent. Have the variable input for GetWorldLocation by the variable output for the set OverlapComponent.</li>
<li>Now we need to store the new location in InitOverlapLoc. Create a new set InitOverlapLoc node. The variable input for this new node will be the output from GetWorldLocation. Don't forget to connect the execute connection!</li>
<li>It's time to tackle the OnComponentEndOverlap event. When we end the overlap, all we want to do is check to see whether the object that was removed from overlapping is the same that we've stored in the OverlapComponent variable and whether it's we want to clear that variable. Start the sequence by creating a Branch and connecting it to the execution output of the event. To compare our objects, create a copy of the Equals (object) node. The top input with be the OtherComp output from the event. The bottom will be a copy of our OverlapComponent variable. Finally, connect the Boolean output from the Equals node to the Condition input on the Branch.</li>
<li>For the final step in this sequence, create a copy of OverlapComponent and choose Set from the menu. Connect it to the True execution output on the Branch. We'll leave its variable input blank so that we can clear its value.</li>
</ol>
<ol start="10">
<li>The next step in our code is to build the nodes that will control the short animation. We begin with the Event Tick node. Next, right-click and create a Sequence node, since this will be a two-step process. Connect the Sequence to the execute output from Even Tick:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/33194035-ebcc-46c9-82e6-fedb35148c27.png" style="width:40.08em;height:15.67em;" width="1950" height="756"/></p>
<p>Button down code</p>
<ol start="11">
<li>Dragging off the Then 0 output, drop the connection and use the search box to find the IsValid node (remember to use the one marked with a ? in the menu). The Input Object we'll be checking this time will be a copy of our OverlapComponent. We'll use this setup to determine whether the player is still overlapping with the button. If they are, we'll animate the button going down. If they aren't, we'll animate the button, returning to the original position.</li>
<li>Next, drag in a copy of our PressAmount variable and choose the Set option from the menu. Connect this to the IsValid output. We'll leave its variable input blank for now.</li>
<li>To do the actual animating, we'll need to create a copy of a SetRelativeLocation node. Connect its execute input to the execute output from the set PressAmount and use a reference to the Button component as the Target.</li>
<li>With the basics of the code set up for the animation, it's time to do some quick math. Pressing a Button is a basic motion that involves moving the button component moving up and down in the <em>Z</em> axis when the player overlaps it. To figure out how far the button needs to travel, we'll take the distance the overlapping actor has traveled and subtract it from the initial position of that same actor. We'll compare that distance to our MaxPressAmount to determine whether the button has been truly pressed. This will all be calculated relative to the position of the button to ensure that it'll work in whatever situation you decide to use it. We'll start with converting our stored InitOverlapLoc value to be in relation to the button. Get a reference to the ButtonBase from the Components panel, drag a connection off of it, and drop it to open the search menu. Create a copy of GetWorldTransform.</li>
<li>Dragging a line from the return value of GetWorldTransform, drop the connection, and search for the InverseTransformLocation node. This node is designed to take in a location and convert it from World Space over into Local Space, based on the transform that we supply. In this case, we're converting the initial overlap location to be relative to the ButtonBase. Get a copy of our InitOverlapLoc variable and connect that to the Location input.</li>
<li>Now create a <kbd>Vector - Vector</kbd> node and take the Return value of the InverseTransformLocation and plug that into the top input. We'll calculate the second value in the following steps.</li>
</ol>
<ol start="17">
<li>Drag another connection off the reference to ButtonBase and create another copy of GetWorldTransform and another copy of InverseTransformLocation.</li>
</ol>
<ol start="18">
<li>This time, we'll need to get the location of the component we've stored in OverlapComponent. Get a copy of the OverlapComponent variable and drag a connection off it. Drop it and search for GetWorldLocation. The Return Value of this node will be the Location input on the copy of the InverseTransformLocation we created in <em>step 17</em>. The Return Value of this InverseTransformLocation can now be connected to the lower input on our <kbd>Vector - Vector</kbd>.</li>
<li>Since the button only travels in the <em>Z</em> axis, we're only interested in the <em>Z</em> output of the subtraction node. Right-click on the output of the <kbd>Vector - Vector</kbd> and split the struct pin.</li>
<li>To make sure the <em>Z</em> value doesn't go outside what we need, we're going to use a Clamp node to limit it. A Clamp node takes in a value and tells it that it can only be between a certain minimum and maximum. In this case, we're going to bring in the <em>Z</em> value and not let it go lower than zero or higher than our MaxPressAmount. Right-click and create a Clamp (float) node. Use the <em>Z</em> ouput from our <kbd>Vector - Vector</kbd> as the Value input and a copy of our MaxPressAmount variable as the Max. We should leave the minimum value at 0.</li>
<li>We're almost there! Our clamped float value is now ready to become the input for the set PressAmount node we created earlier. Connect the output of the Clamp to the set PressAmount input.</li>
<li>Since the button will always be moving down to show that it's being pressed, the value we need to pass into our SetRelativeLocation node should be negative. Take the variable output from set PressAmount, drag off from it, and create a <kbd>Float * Float</kbd> node. Set the second value to -1.0.</li>
</ol>
<ol start="23">
<li>To finish the animation, right-click on the New Location input on the SetRelativeLocation and split the struct. Connect the output from <kbd>Float * Float</kbd> and connect to the New Location Z input:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/f3d61845-a45e-40cc-b411-3694a8f33377.png" width="1919" height="831"/></p>
<p>Code that returns the button to the start position</p>
<ol start="24">
<li>Once the overlap is complete, we'll need to move the button back to its original location. Head back to the IsValid that we created back in <em>step 11</em> and drag a connection of the IsNotValid output, drop it, and search for a copy of the node SetRelativeLocation. Set a reference to our Button component as the Target.</li>
<li>Right-click in the blueprint and search for the VinterpTo. This will help the button achieve a smooth animation back to an unpressed state. To fill the Current input, grab a reference to the Button component and drag a connection off it. Drop and search for a GetRelativeLocation node. Plug the output from this node into the Current input.</li>
<li>To fill the Delta Time input, connect the Delta Time value from the Event Tick node.</li>
</ol>
<ol start="27">
<li>Finally, connect the Return Value from VinterpTo to the New Location input on SetRelativeLocation.</li>
</ol>
<p style="padding-left: 60px">The last thing needed to finish the button is a way to process what happens when the button is pressed. For that, we'll use an Event Dispatcher. By using an Event Dispatcher, we can bind different commands to the button, depending on what we need it for, leaving us with a flexible and reusable system:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/b4a8a587-cb18-463f-8a7d-dd48d28fcf97.png" width="1927" height="355"/></p>
<p>What happens when it's pressed?</p>
<p style="padding-left: 60px">To continue, drag off the Then 1 output on our Sequence node and create a new Branch:</p>
<ol start="28">
<li>It's now time to compare the amount we have pressed the button to the max press amount. Right-click and create a <kbd>Float &gt;= Float</kbd> node. Get a copy of PressAmount and connect that to the top input. Get a copy of MaxPressAmount and connect that to the bottom input. Lastly, plug the output of the node into the Condition input on the Branch.</li>
<li>Now create a DoOnce node. This node stops something from happening again until it has been reset. We'll plug the True output from the Branch into the execute input and the False output into the Reset input.</li>
<li>Finally, create an Event Dispatcher. Find the Event Dispatchers section of the My Blueprint panel and click the + button. Name the new dispatcher Pressed. Back in the blueprint, drag off the Completed output of DoOnce and search for the Call Pressed node.</li>
<li>The last step in implementing our button-press behavior is to add some code to the interaction component.  </li>
</ol>
<p>We now have a working button that the player can mash in VR. To test the feature, drop a copy of our button into the level where you can press it and open the Level Blueprint. We are going to build from the Event BeginPlay node that should be present in the blueprint by default. If it isn't there, go ahead and drop one in.</p>
<p>Right-click in the blueprint and create a reference to the InteractButton that's in the level. Drag off from the output and search for the AssignPressed node and connect the execute output from the event to its input. This will allow you to assign a custom event to Pressed. It can be anything you want! I created a simple way to end the level in the previous screenshot.</p>
<p>Wow! We've come a long way from where we began. The player now has hands. They can use them to interact with the world around them. They can touch, pick up, throw, press buttons, and anything else that we can dream up. They can also teleport around the level to explore whatever we decide to create—and all of this with controls in place so that they may only do these things with whatever we as the designers let them. It's time to put that power to good use.</p>
<p>Remember the puzzle box we designed at the beginning of the section? We now have all of the pieces we need to make this a reality. Since it's a prototype, we're going to build the box out of static mesh components and another type of component called a Child Actor. Child Actors are copies of class blueprints and allow us to build objects within a class blueprint out of other actors, meaning that we can piece together our simple puzzle box with Box components, copies of our InteractCube, and a couple copies of InteractButton:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/73d07a01-03ca-4880-b60c-6709f21bccdd.png" width="1935" height="1030"/></p>
<p>Building the PuzzleCubeTest</p>
<p>Start by creating a new Class Blueprint:</p>
<ol>
<li>Right-click in the <kbd>Server17\Blueprint</kbd> folder in the Content Browser and create a new Class Blueprint based on Actor. Name this new blueprint PuzzleCubeTest, since this puzzle cube represents our first prototype. Double-click it to open it.</li>
</ol>
<ol start="2">
<li>Let's create the visual components. The best place to start would be with the non-interactive components first. In the Components section of My Blueprints, click the Add Components button, and create a new Box component. Change the Scale properties X=1.0, Y=2.0, and Z=0.1. Name this component <kbd>Bottom</kbd>.</li>
<li>Create another Box component and name it <kbd>RightSide</kbd>. Change the Scale properties X=0.5, Y=2.0, and Z=0.1 and rotate it 90 degrees around the <em>Y</em> axis. Line it up along the right edge of the bottom component.</li>
<li>Select the Right component and press <em>Ctrl</em> <em>+ W</em>. This will create a copy that you can align with the left edge of the bottom piece. Name this new piece <kbd>LeftSide</kbd>. Change its Y Scale property to 1.5. This space will allow for the hidden compartment in the back.</li>
<li>Click on the bottom component and press <em>Ctrl+W</em> to create a copy. Name this new component Top. Move this component 60 cm up in the positive <em>Z</em> direction.</li>
<li>The box is slowly coming together, but now we need a back plate to finish the enclosure. Create a new Box component and change the Scale property to X=0.9, Y=0.5, and Z=0.1. Name it BackPlate. Finally, rotate it 90 degrees around the <em>X</em> axis.</li>
<li> Now we're going to create the non-interactive bottom and top supports. Create a new Box component and name it BottomSupport_1. Set the Scale property to X=0.5, Y=1.25, and Z=0.1. Move it below the Bottom Component and align it with the front and side edges.</li>
<li>With BottomSupport_1 selected, press <em>Ctrl + W</em> and name this new component <kbd>BottomSupport_2.</kbd> Rotate it 90 degrees around the <em>Z</em> axis and move it back to the center of the bottom of the box. The easy way to do this would be to set the <em>Y</em> value of its location property back to 0.</li>
<li>Create another copy of BottomSupport_1 and name it BottomSupport_3. Rotate it 90 around the <em>Z</em> axis and align this component with the back edge of the bottom component.</li>
</ol>
<ol start="10">
<li>Select all of the BottomSupport components in the Components list by clicking the first one and holding <em>Ctrl</em> while selecting the other two. If necessary, rotate the components 90 degrees so that they're back in the correct orientation. Then move them 80 cm up in the <em>Z</em> axis so that their bottom edges align with the top edge of the Top component. Name them <kbd>TopSupport_1</kbd>, <kbd>TopSupport_2</kbd>, and <kbd>TopSupport_3</kbd>.</li>
<li>To give one of our buttons inside the box a surface to sit on, we're going to create one more non-interactive component. Click on the BackPlate component and create a copy with <em>Ctrl + W</em>. Name this new component <kbd>MiddlePlate</kbd> and make the value of it's Location property X=0, Y=60, and Z=30.</li>
</ol>
<ol start="12">
<li>To create the interactive surfaces in our puzzle box, we're going utilize Child Actor components, which will be copies of our InteractCube object. This will allow us to have all of the functionality that we programmed into InteractCube and utilize them as components of our puzzle box without reprogramming them in a new component (though we may want to in the future). Create a new Child Actor component and name it <kbd>SideDecoy_R1</kbd>. In the Details panel, set the Child Actor class property to InteractCube. Se the Scale value to X=0.5, Y=0.13, and Z=0.7 and rotate it 90 degrees around the <em>Z</em> axis. Move this component into position in between the first set of the top and bottom supports on the right side, aligned to the front edge of the RightSide component.</li>
<li>Create a copy of SideDecoy_R1 using <em>Ctrl + W</em> and name the new Child Actor <kbd>SideDecoy_R2</kbd>. Move it between the rear set of the top and bottom supports on the right side, aligned with the back edge of the Right component.</li>
<li>Now for the left side, create a copy of <kbd>SideDecoy_R1</kbd> using <em>Ctrl + W</em> and name the new Child Actor  <kbd>SideDecoy_L1</kbd>. Move it to the left side of the box between the first set of top and bottom supports and align it with the front edge of the LeftSide component.</li>
<li>Make a copy of <kbd>SideDecoy_L1</kbd> and move it to the center set of the top and bottom supports.</li>
<li>The decoy components are there to divert the players attention while they look for the buttons to press to unlock the puzzle box. With them all in place, we can now add our interactive button components. On the right-hand side of our puzzle box, create a new Child Actor component and set the Child Actor class property to InteractButton. Name this new <kbd>Child Actor Button_Step1</kbd>. Lastly, move it to the center of the area between the middle top and bottom supports and align it with the surface of the RightSide component by rotating it -90 degrees around the <em>Y</em> axis. Players will need to uncover and find this button before they can open the front of the box.</li>
</ol>
<ol start="17">
<li>Create a copy of Button_Step1 with <em>Ctrl + W</em> and name the new component Button_Step2. Set the button's Rotation property to X=0, Y=90, and Z=90. Align this button with the center of our MiddlePlate component. This button will be found behind a plate that covers the front of the puzzle box that can only be removed after Button_Step1 has been pressed.</li>
<li>Now let's cover up those buttons! Create a copy of SideDecoy_R1 and name the new component <kbd>ButtonCover_Step1</kbd>. Move this new object to cover up Button_Step1 by aligning it between the center set of the top and bottom supports on the right side.</li>
</ol>
<ol start="19">
<li>To cover the front, we'll need a new Child Actor sized to fit that compartment. Create a new Child Actor, set the Child Actor class property to InteractCube, and name it <kbd>ButtonCover_Step2</kbd>. Set the value of the Scale property to X=0.8, Y=0.5, and Z=0.1. Rotate it around the <em>X</em> axis 90 degrees. Lastly, align it to cover Button_Step2 and fit it flush with the front of the puzzle box. This will unlock after the player presses the first button.</li>
<li>There's one more cover. This one will cover the compartment we have in the back. Click on SideDecoy_L2 and use <em>Ctrl + W</em> to create a copy of it. Name the new copy <kbd>CompartmentCover_Step3</kbd>. Align it between the back top and bottom supports to cover the compartment. This cover will unlock when the player presses the second button.</li>
<li>What good is a puzzle box if there's no prize at the end? Create one more Child Actor component and set the Child Actor class property to InteractCube. Name it StolenData. This will represent the prize the player is after. Set the value of the Scale property to X=0.1, Y=0.1, and Z=0.1. Place inside of rear compartment that we just covered with CompartmentCover_Step3.</li>
<li>There's one last detail. To make the InteractCube work as a stand-in for more detailed components that we'll create later, we need to open the InteractCube blueprint and turn off the Simulate Physics option. This will make it so the cubes won't have physics enabled by default, so the puzzle cube won't fall apart. Physics will still enable once the player has interacted with the cube.</li>
</ol>
<p>Based on our design, the code for the prototype puzzle box needs to be able to do the following things:</p>
<ul>
<li>Disable the ability to pick up the button covers when we start</li>
<li>Bind the correct button press events to our two buttons</li>
<li>Enable the front button cover after button 1 has been pressed</li>
<li>Enable the compartment cover after button 2 has been pressed</li>
</ul>
<p>Disabling the components that we don't want the player to be able to interact with what could be accomplished by toggling their individual PickUpActive Boolean variables. This will leave all of their other functions available but make it so the player can't remove them before we want them to have that ability. To give them that ability, we can bind a couple of custom events to our two buttons that re-enable them after the buttons have been found and pressed. Let's head to the Event Graph of PuzzleCubeTest and get to work:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/f317a5a2-c0b5-44cd-8c68-ba1fdb9f90e7.png" width="1932" height="1247"/></p>
<p>PuzzleBoxTest code</p>
<p>We'll build this code from the Event BeginPlay node:</p>
<ol>
<li>Right-click in the blueprint and search for a Sequence node. We are going to use this to fire off the steps that we mentioned previously in the correct order. Click the Add Pin button on the node until we have four output pins to work with.</li>
</ol>
<ol start="2">
<li>Start by dragging off the Then 0 output and search for the Cast To InteractCube node. For the Object input on the cast, we need to reference our Child Actor ButtonCover_Step2. However, if we try to plug in a simple reference to it, the cast won't work correctly. To make sure it references the correct object, we need to add a GetChildActor node. Create a reference to ButtonCover_Step2 and drag a connection from its output. Search for the GetChildActor node and connect its output to the Object input on the cast.</li>
<li>With the cast set up, we can now pretend to be the button cover and turn off its ability to be picked up. Drag a connection off the As InteractCube output and search for the set PickUpActive. On the set PickUpActive node, make sure the checkbox is turned off.</li>
<li>Let's repeat the process for CompartmentCover_Step3. Create the cast by dragging off the Then 1 output on the Sequence and connecting a reference to the Child Actor version of CompartmentCover_Step3 to the Object input through a GetChildActor node. As the child actor, set PickUpActive to false by turning off the checkbox on the Set node.</li>
<li>Next, we need to connect the button presses to a couple of custom events. Drag a connection off the Then 2 output on the Sequence node and search for the node Cast To InteractButton. Use the same method as the previous one to create a reference to the child actor, Button_Step1, and connect that to the Object input on the cast. We'll use our event dispatcher we created as part of the button to connect a custom event to the pressing of the button. Drag a connection off the As InteractButton output and search for Bind Event to Pressed.</li>
<li>Create a new custom event and name it UnlockStep2. Drag a connection off the little box next to the event node's name and plug it into the event input on the Bind Event to Pressed node. </li>
<li>Drag a connection from the As InteractCube output from <em>step 3</em> and create a set PickUpActive node. Connect it to the execution output from the UnlockStep2 event and make sure the checkbox on the Set node is turned on. We've now re-enabled ButtonCover_Step2.</li>
<li>Repeat the steps to set up the ability to re-enable CompartmentCover_Step3. Create a Cast To InteractButton node and pass in a reference to the child actor version of Button_Step2. As the button, create a Bind Event to Pressed node and connect it to a custom event named UnlockStep3. Drag off the As InteractCube output from <em>step 4</em> and create a set PickUpActive node. Make sure that the checkbox on this new node is set to on.</li>
</ol>
<p>And there we have it, a working puzzle cube that takes three steps to solve. Using our teleport volumes, create a space where you can teleport around the box and then drop a copy of the puzzle box in the center. Move around it. Test the steps and see whether they work. Once everything is working, I have a challenge for you. When we started this section, I provided a sketch of the plan for the puzzle box, as well as a prototype level for the player to test it. Build the level and test your puzzle box in it. Interested in a greater challenge? Design and build your own puzzle cube and test level!</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Building the first tool station</h1>
                
            
            
                
<p>An integral part of the gameplay for <em>Server 17</em> is the idea of the Tool Station, a location located near the puzzle box that contains some type of tool, device, or hint-generator that can be used by the player to help solve the puzzle at hand. The tools at each station would vary from brute-force hacking tools that could solve a step of the puzzle at the cost of a time penalty, to a simple hint tool that could highlight the next piece the player has to interact with. For the prototype, we're going to design a simple rotation tool that will highlight how easy it is to use the tools that we created. Let's take a look at the prototype visuals:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/d288f312-9d20-4f01-a0d1-dbef7d91d455.png" style="width:41.00em;height:19.50em;" width="1932" height="916"/></p>
<p>Prototype visuals</p>
<p>The build is relatively basic. Using the Content Browser, head to the <kbd>Shapes</kbd> folder of the Starter Content and grab yourself a cylinder. Use the Scale tool to shrink it by half. Then grab a Wedge shape and place that on top of the cylinder. Shrink this by half as well. I also used a Text Render to create the text you see in the image. The final piece to this tool station is a new class blueprint:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/469fd5e5-b079-40f5-a94e-100d5c560701.png" width="1931" height="1030"/></p>
<p>StationButton code</p>
<p>Create a new class Blueprint and select Actor from the menu:</p>
<ol>
<li>Create the new class Blueprint, select the Actor class from the Pick Parent Class menu, and name it <kbd>StationButton</kbd>.</li>
<li>Similar to our InteractCube, this blueprint contains only one component. I used a Cone component; however, feel free to use whatever you feel might be appropriate.</li>
<li>Now, let's code this thing! To utilize some of the functions that we've spent this chapter creating, click on the Class Defaults button and find the Interfaces section in the Details panel. Click the Add button and choose our Object Interaction Interface.</li>
</ol>
<ol start="4">
<li>With the interface added, head over to the My Blueprint panel and open the Interfaces section of the menu. Double-click and open the following functions: <kbd>TraceHitObject</kbd>, <kbd>TraceLeaveObject</kbd>, <kbd>TraceActivateUp</kbd>, and <kbd>TraceActivateDown</kbd>.</li>
</ol>
<ol start="5">
<li>Let's start with <kbd>TraceHitObject</kbd>. This covers what happens when our line trace touches the object. Drag a reference to the Cone into the blueprint from the Components panel and drag a connection from it. Create a copy of the SetVectorParameterValueOnMaterial and connect it to the function node and Return node. Set the value of the Parameter Name field to Color. Finally, set the <em>Y</em> value of the Parameter Value input to 1.0. This will highlight the button Green when we land a trace on it.</li>
<li>For <kbd>TraceLeaveObject</kbd>, we'll have to create a variable that can store whether or not our button is being used. Head over to the Variables section of My Blueprint and create a new Boolean variable. Name it <kbd>ButtonPressed</kbd> and set its default value to False. Along with changing the color of the button back to the default white, we want to make sure the button no longer registers as pressed if it's no longer being touched by a line trace. Repeat the preceding step to create the SetVectorParameterValueOnMaterial node and set the value of the Parameter Value input to X=1.0, Y=1.0, and Z=1.0. This will set the button color back to white. After SetVectorParameterValueOnMaterial, connect a set ButtonPressed node and make sure the checkbox is set to off. Connect that to the output of SetVectorParameterValueOnMaterial and the ReturnNode.</li>
<li>Now, let's move on to <kbd>TraceActivateDown</kbd>. When the player activates the button, all we want to do is set ButtonPressed to True. We'll handle the rotating in the level blueprint. Connect a copy of the set ButtonPressed to the function. Make sure the checkbox on the node is turned on. After the Set node, create another copy of SetVectorParameterValueOnMaterial using the Cone as the Target. Set it up the same way as we did in the previous steps in this section and set the <em>X</em> value of the Parameter Value input to 1.0. This will turn the button red when it's used.</li>
<li>Lastly, we have <kbd>TraceActivateUp</kbd>. When the player releases the trigger, we need to change the color back to green (the color it is when getting hit by a line trace) and change ButtonPressed back to false. Connect a copy of SetVectorParameterValueOnMaterial to the function node, set it up as we have in previous steps, and set the <em>Y</em> value of the Parameter Value input to 1.0. Connect a copy of set ButtonPressed to the output of the SetVectorParameterValueOnMaterial node and connect its output to the Return node, making sure the checkbox is set to off.</li>
</ol>
<ol start="9">
<li>Back in our level, add a copy of StationButton to the tools station that we've created and name it StationButton_Rotate.</li>
</ol>
<p>To make the puzzle box rotate when our station button is pressed, we're going to build a bit of functionality into the level blueprint, since this ability is limited to the prototype level. Open the Level Blueprint using the Blueprints button:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/48159940-23d4-4ef4-a513-5c01b5e86c7b.png" width="1929" height="746"/></p>
<p>The level blueprint code</p>
<p>We'll start to build this sequence with a custom event:</p>
<ol>
<li>Right-click in the blueprint and create a new custom event. We are going to name it ButtonCheck.</li>
<li>Next, right-click and create a new Branch node. This will read whether the button has been pressed. Create a reference to our StationButton_Rotate and drag a connection from it. Drop it and search for Get ButtonPressed. Connect the output from this node to the Condition node on the Branch.</li>
<li>Now, create an Event Tick node. We want the game to check every frame if the button is being pressed. Drag a connection from the event and search for our ButtonCheck function to create a copy of it.</li>
</ol>
<p class="mce-root"/>
<ol start="4">
<li>As we've done for previous buttons, we're going to use a Gate to control whether  the code executes, based on whether ButtonPressed is True or False. Create a Gate node and connect the Enter input to the output from the ButtonCheck function. Connect the True output from our Branch to the Open input and the False output from the Branch to the Close input.</li>
<li>It's time to create the rotation. Create a new <kbd>Float</kbd> variable over in the Variables section of My Blueprint and name it RotSpeed. This will control how fast the puzzle cube rotates.</li>
<li>Next, right-click and search for the Make Rotator node. Connect a copy of RotSpeed to the Z (Yaw) input. </li>
</ol>
<ol start="7">
<li>The last major node we need is AddActorLocalRotation. Connect it to the Exit output of our Gate node and use a reference to our puzzle cube in the level as the Target.</li>
<li>The Delta Rotation input needs a bit of math. Drag a connection from the output of Make Rotator and search for the ScaleRotator node. For the float input, use the Delta Seconds output from Event Tick. This will create a smooth rotation over time.</li>
<li>Finally, plug the output of our ScaleRotator node into the Delta Rotation input on the AddActorLocalRotation.</li>
</ol>
<p>We now have rotation! Obviously, there's quite a bit more that can be done with the idea of hacking tools in <em>Server 17</em>, but this will work fine for our prototype stage. It looks as though this is finally coming together. There is one last gameplay element we still haven't created  though: our level timer.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Building the Timer</h1>
                
            
            
                
<p>In the world of <em>Server 17</em>, players hack corporate servers looking for valuable company secrets. However, those corporations don't just lie down and take it! Powerful system administrators, corporate hackers, and AI countermeasures mobilize to stop the player, giving them limited time to crack each server. To represent this in the game, we'll implement a level timer in the game that will cause the player to lose when it reaches zero. Since this is a only a prototype, we'll have the game quit when the timer is complete.</p>
<p>Since this is a gameplay element independent of any level, we'll build this feature in our custom game state. Head to our <kbd>Sever17\Blueprints</kbd> server and double-click the <kbd>S17GameState</kbd> to open it:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/4555d7fd-b068-4804-bf13-c6eeea193c38.png" width="1921" height="1183"/></p>
<p>Game timer code setup in the Game State</p>
<p>Let's get started:</p>
<ol>
<li>This feature makes user of the Timer system built into the Blueprint system. Using the SetTimerByEvent node, we can call a custom event when a timer (in seconds) completes. Start by creating a copy of the Event BeginPlay node and dragging an execute connection off the output. Search for the SetTimerByEvent node and select it from the menu.</li>
<li>Next, create a Custom Event named <kbd>EndGame</kbd>. Connect this custom event to the Event input on SetTimerByEvent by dragging a connection from the square pin next to the custom event's name and connecting to the input pin.</li>
<li>Dragging off the EndGame event, search for the ExecuteConsoleCommand node. In the Command field, type in the command <kbd>quit</kbd>.</li>
</ol>
<ol start="4">
<li>To finish the sequence, we need to set a value for Time on SetTimerByEvent. To keep the system flexible, we'll create a variable for the game time that can easily be adjusted from outside the game state to take into account things such as level difficulty or story elements. Create a new <kbd>Float</kbd> variable and name it GameTime. Compile the blueprint and set the default value to 300. Get a copy of it and connect it to the Time input on SetTimerByEvent.</li>
</ol>
<p>Awesome! Our intrepid players now have five minutes to complete our puzzle cube or be kicked out of the game. Feel free to adjust the default value of GameTime to whatever feels appropriate for your players or to adjust the challenge for yourself.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Summary</h1>
                
            
            
                
<p>Wow! What a ride. We began this chapter with some interesting discussions about gameplay and ended it with creating a whole game prototype from scratch! In this chapter, we explored the many different types of gameplay that successfully implement the mechanics that VR is uniquely capable of. Using that knowledge, we designed our game elements to take advantage of the near one-to-one translation of player movement into the game and the ability to have the player interact with the world from a true first-person perspective. Through the rest of this chapter, we built all of our systems from scratch from hand interactions to VR buttons, and even a puzzle box  for the player to solve within a time limit.</p>
<p>In the next chapter, we're going to expand our gameplay by discussing the user experience we've created so far and how we can improve that experience through the use of user interfaces. We'll talk about the use and viability of 2D and 3D elements within our game world and what works best with VR. Using that knowledge, we'll design and build our own elements for use in <em>Server 17</em>.</p>


            

            
        
    </div>



  </body></html>