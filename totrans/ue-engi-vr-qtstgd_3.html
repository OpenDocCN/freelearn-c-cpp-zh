<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Exploring Riveting Gameplay in Virtual Reality</h1>
                </header>
            
            <article>
                
<p class="mce-root"><span>With our custom game files in place, it's time to start making some decisions about gameplay.</span> <span class="hardreadability"><span>In <em>Server 17</em>, the player takes on the role of a futuristic hacker trying to crack open a corporate server and plunder its secrets for personal gain</span></span><span>. So, how might we present this in VR as an experience? Before</span> <span class="qualifier"><span>we think</span></span> <span>about that, let's do a bit of research and discovery.</span> <span class="hardreadability"><span>The best way to learn which mechanics will challenge and entertain our players is to first look at the unique elements that VR brings to a game</span></span><span>. After that, we can take a look at which titles are being played right now and why.</span> <span class="hardreadability"><span>Armed with that information, we can then make some decisions about how best to design our own gameplay for <em>Server 17</em></span></span><span>. We have a lot to discover, so let's get started!</span></p>
<p>In this chapter, we'll cover the following topics:</p>
<ul>
<li>What does VR bring to video games?</li>
<li>Popular gameplay mechanics</li>
<li>Designing the gameplay for <em>Server 17</em></li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What does VR bring to video games?</h1>
                </header>
            
            <article>
                
<div class="">
<p class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr"><span>VR is the new frontier in games and entertainment.</span> <span class="hardreadability"><span>It's able to put the player in the shoes of their favorite heroes, or in a front-row seat for some of their  favorite experiences</span></span><span>.</span> <span class="hardreadability"><span>In most experiences, player movement</span></span> <span class="passivevoice"><span>is translated</span></span> <span class="hardreadability"><span>into near one-to-one movement inside the game—s</span></span><span>omething that's usually impossible in traditional video games. VR also has the power to immerse our player in an alternate world and make them</span> <span class="adverb"><span>truly</span></span> <span>feel as if they're there. It's these special abilities that mark VR as the future of gaming.</span></p>
</div>
<p class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr"><span class="hardreadability"><span>It's important to understand that the input and controls in VR can go beyond the locomotion methods that we discussed in the last chapter</span></span><span>.</span> <span class="hardreadability"><span>Each controller for the Vive or Oculus brings at least six different buttons that can</span></span> <span class="passivevoice"><span>be mapped</span></span> <span class="hardreadability"><span>to different functions within a game</span></span><span>.</span> <span class="hardreadability"><span>Each of these can then</span></span> <span class="passivevoice"><span>be combined</span></span> <span class="hardreadability"><span>with a location or specific player movement to create almost infinite variety</span></span><span>. Let's take a look at some of the gunplay in Epic Game's <em>Robo Recall</em>.</span></p>
<div class="">
<p class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr"><span>In this game, you destroy robots with a variety of weapons that</span> <span class="passivevoice"><span>are holstered</span></span> <span>on the player.</span> <span class="hardreadability"><span>The character has a pair of pistols holstered at their hips and a second pair of weapons holstered at their shoulders</span></span><span>. This seems simple enough, right?</span> <span class="hardreadability"><span>Where the designers utilized the advantages of VR was in the hand placement needed to use your weapons</span></span><span>. The player has to reach down to their waist to grab a pistol or reach behind their shoulder to grab a weapon.</span> <span class="hardreadability"><span>This simple addition of hand location to the input to equip a gun adds to the immersion and visceral quality of the gameplay</span></span><span>.</span></p>
</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Popular gameplay mechanics</h1>
                </header>
            
            <article>
                
<p><span class="hardreadability"><span>In the last few years, many developers have embraced VR technology as their chosen medium</span></span><span>. This has lead to a variety of VR games spanning many different genres and ideas. Each game has approached the input and immersion that VR brings in their own way.</span> <span class="hardreadability"><span>Some, such as Bethesda and ID Software, chose to use the technology to bring their blockbuster games</span> <em><span>Fallout 4</span></em> <span>and</span> <em><span>Doom</span></em> <span>into the VR era (to mixed reviews)</span></span><span>.</span> <span class="hardreadability"><span>Others have found more success building their game</span></span> <span class="adverb"><span>specifically</span></span> <span class="hardreadability"><span>for the medium, such as Beat Games'</span> <em><span>Beat Saber,</span></em> <span>and Schell Games'</span> <em><span>I Expect You To Die</span></em></span><span>. For our research into what might work for</span> <em><span>Se</span><span>rver 17</span></em><span>, we're going to look at seven different types of gameplay:</span></p>
<ul>
<li>Shooter experiences</li>
<li>Action/adventure experiences</li>
<li>Vehicle experiences</li>
<li>Physics-based experiences</li>
<li>Puzzle experiences</li>
<li>Rhythm experiences</li>
<li>Educational experiences</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Shooter experiences</h1>
                </header>
            
            <article>
                
<div class="">
<p class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr"><span class="hardreadability"><span>In the last year, more than a dozen of the top 25 VR titles sold on Valve's Steam download service fell into the shooter category</span></span><span>. A shooter</span> <span class="passivevoice"><span>is defined</span></span> <span>as any game that includes gunplay as a major part of experience.</span> <span class="hardreadability"><span>Many variations on the shooter experience in VR take advantage of unique mechanics</span></span><span>. Still near the top of the charts is <em>Robo Recall</em>.</span></p>
</div>
<p class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr"><span class="hardreadability"><span>Epic Games was able to combine the frantic action of a wave shooter with the immersive environment and mechanics that VR can bring</span></span><span>. Much of the gameplay centers around using your hands. <em>Robo Recall</em> uses interesting mechanics when it comes to arming yourself. Players grab their chosen weapons from holsters located at their waist and shoulders.</span> <span class="hardreadability"><span>Each one</span></span> <span class="passivevoice"><span>is filled</span></span> <span class="hardreadability"><span>with a variety of customized weapons, all great for scrapping the game's robot enemies</span></span><span>. The grab mechanism is also applied to a specific brand of melee combat from <em>Robo Recall</em>.</span> <span class="hardreadability"><span>Player's can grab many robot enemies by a handle that's</span></span> <span class="adverb"><span>conveniently</span></span> <span class="hardreadability"><span>located in the center of their chest</span></span><span>.</span> <span class="hardreadability"><span>Once grabbed, enemies can</span></span> <span class="passivevoice"><span>be ripped</span></span> <span class="hardreadability"><span>apart by grabbing limbs, thrown into other enemies, or held up as shields to protect yourself</span></span><span>.</span></p>
<p class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr"><span><em>Superhot VR</em> by Superhot Team is another game that takes gunplay to a whole new level.</span> <span class="hardreadability"><span>The game combines physics and shooting gameplay with their exclusive time mechanics to create a rare experience</span></span><span>.</span> <span class="qualifier"><span>Just</span></span> <span>about every object in its minimalist environments is a weapon in <em>Superhot VR</em>.</span> <span class="hardreadability"><span>These items <span class="fontstyle0">can be thrown at</span> an enemy to liberate their weapon, causing it to</span></span> <span class="adverb"><span>fly</span></span> <span class="hardreadability"><span>into the air so that it can</span></span> <span class="passivevoice"><span>be snatched</span></span> <span class="hardreadability"><span>up by the player</span></span><span>. Combined with the fact that time only moves forward when you do, each level becomes a combat puzzle. Which enemy do you confront first? What weapon or object is available within arm's reach? Each decision and movement is important for discovering the level's solution, and progressing.</span></p>
<div class="">
<p class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr"><span class="hardreadability"><span>The most important elements of a popular VR shooter are active gunplay combined with another unique mechanic</span></span><span>. This can be grabbing, physics gameplay, or a particular locomotion mechanism.</span> <span class="veryhardreadability"><span>Other great examples in this category include <em>Sairento VR</em>, for its locomotion mechanic and combination of gun and swordplay, a</span></span><span class="hardreadability"><span>s well as <em>Damaged Core</em>, a game that has the player utilizing the ability to teleport from enemy to enemy, possessing them and using their weapons</span></span><span>.</span></p>
</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Action/adventure experiences</h1>
                </header>
            
            <article>
                
<div class="">
<p class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr"><span>Action/adventure experiences combine combat experiences with exploration and story-based gameplay.</span> <span class="veryhardreadability"><span>These games feature impressive environments and visuals that take advantage of the fact that VR places the player</span></span> <span class="adverb"><span>directly</span></span> <span class="veryhardreadability"><span>into the game world</span></span><span>.</span> <span class="hardreadability"><span>Yet, with such a large world in which to explore, designers must use artificial locomotion methods to allow the player to explore such a large space</span></span><span>.</span> <span class="veryhardreadability"><span>For many players, the ability to experience the story firsthand outweighs any discomfort caused by using a thumbstick or snap turning for locomotion</span></span><span>.</span> <span class="hardreadability"><span>In this category, the biggest contenders both come to us from <em>Bethesda Softworks <span class="fontstyle0">:</span> <span class="fontstyle2">Fallout 4 VR</span> <span class="fontstyle0">and</span> <span class="fontstyle2">Skyrim VR</span></em></span></span><span>.</span></p>
</div>
<div class="">
<p class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr"><span><em>Fallout 4 VR</em> is a direct port of the popular 2015 title, redesigned to work with VR.</span> <span class="veryhardreadability"><span>Players travel the wasteland building settlements, crafting equipment, and experiencing the story from a first-person perspective</span></span><span>. Combat is an in-your-face affair.</span> <span class="hardreadability"><span>The majority of the early enemies <span class="fontstyle0">favor close combat</span>, meaning there isn't much of a chance for the player to use a firearm before their opponent is right on top of them</span></span><span>. Luckily, melee combat is as simple as equipping the right weapon, or none at all, and swinging away. Ranged combat also feels good, though not</span> <span class="adverb"><span>nearly</span></span> <span>as satisfying as in a VR shooter. Still, <em>Fallout 4</em> ticks all of the right boxes.</span> <span class="hardreadability"><span>It's an action/adventure experience that gives players a massive, awe-inspiring environment</span></span><span>.</span> <span class="hardreadability"><span>In it, they may craft, build, and interact, as well as take part in a deep story with a variety of interesting characters</span></span><span>.</span></p>
</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Vehicle experiences</h1>
                </header>
            
            <article>
                
<div class="">
<p class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr"><span class="hardreadability"><span>Vehicle experiences solve the locomotion problem by placing the player at the helm of a ship, mech, or other method of travel and destruction</span></span><span>. The brain processes it much the same as when we go for a ride in the car. We don't question that we're moving because we're sitting down and controlling the vehicle. This gives the designers the opportunity to give players a vehicle-piloting experience. There are many great examples in this space.</span> <span class="complexword"><span>However</span></span><span class="hardreadability"><span>, I want to give you one that represents some of the best gameplay in this category, Frontier Developments' <em>Elite Dangerous</em></span></span><span>.</span></p>
</div>
<p class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr"><span class="hardreadability"><span>The most current entry in the <em>Elite</em> saga is a space adventure, combat, and trading sim that puts the player in the role of an elite commander</span></span><span>.</span> <span class="hardreadability"><span>Players earn money, rank, and influence with the major factions of a one-to-one, open-world version of our Milky Way galaxy</span></span><span>.</span> <span class="hardreadability"><span>The game can</span></span> <span class="passivevoice"><span>be played</span></span> <span class="hardreadability"><span>without VR hardware, but it</span></span> <span class="adverb"><span>truly</span></span> <span class="hardreadability"><span>shines when the player dons the headgear</span></span><span>.</span> <span class="hardreadability"><span>When played in VR, the player is able to see the inside of the ship and see their own customized player character sitting at the helm</span></span><span>.</span></p>
<p class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr"><span>Navigating the systems and menus of the ship becomes easier as menus open with a glance.</span> <span class="hardreadability"><span>Combat and piloting become effortless, since the player can look through the canopy of their ship to help track their location</span></span><span>.</span> <span class="veryhardreadability"><span>All of these VR-specific features add depth to an amazing experience as the players fight, trade, and explore their way to fortune and fame within the game world</span></span><span>. </span></p>
<div class="">
<p class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr"><span class="veryhardreadability"><span>The addition of an internal ship environment, customizable player character, and eye tracking-based menus are only possible thanks to the first-person perspective that VR provides</span></span><span>.</span> <span class="hardreadability"><span>Being able to see themselves in the interior of their vehicle connects the player to their surroundings</span></span><span>. This makes them feel as if they're a living part of the game. </span><span class="veryhardreadability"><span>Whether it's racing in a tricked-out high-performance street car or fighting aliens in the depths of space, the player's vehicle-piloting experience</span></span> <span class="passivevoice"><span>is enhanced by</span></span> <span class="veryhardreadability"><span>the VR perspective</span></span><span>.</span></p>
</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Physics-based experiences</h1>
                </header>
            
            <article>
                
<div class="">
<p class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr"><span class="veryhardreadability"><span>Not as well known in the gaming world, physics-based games take advantage of the player's ability to aim and throw objects using a standing or room-space experience</span></span><span>.</span> <span class="hardreadability"><span>This goes beyond</span></span> <span class="adverb"><span>simply</span></span> <span class="hardreadability"><span>picking up and throwing everyday objects, such as the gameplay found in <em>Superhot VR</em></span></span><span>.</span> <span class="hardreadability"><span>It takes advantage of a game engine's ability to simulate real-world physics to create gameplay</span></span><span>.</span> <span class="hardreadability"><span>In this genre, the games tend to take the form of phyiscs-based fighting games and physics puzzle games</span></span><span>. Let's take a look at the physics-based combat game, <em>Gorn</em>.</span></p>
</div>
<p class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr"><span class="hardreadability"><span><em>Gorn</em>, from Devolver Digital, casts the player as a gladiator fighting for the amusement of several large-headed patrons</span></span><span>. The game features cartoon-style art and violence, centered around comical physics-based brawling.</span> <span class="hardreadability"><span>Each round starts with the player entering the arena, sometimes with a selection of weapons and sometimes unarmed</span></span><span>. The rules are simple: knock out the other guys before they do the same to you. The fun comes when the player picks a weapon to use. As the game translates their movement into the game world, it adds a bit of cartoon physics. Movements become exaggerated. Weapons feel as if they're</span> <span class="passivevoice"><span>made</span></span> <span>of foam or rubber, making combat a strange affair.</span> <span class="hardreadability"><span>Together, these features come together to create a brawling experience that feels visceral and absurd at the same time</span></span><span>. <em>Gorn</em> is currently available for HTC Vive, Oculus Rift, and PlayStation VR.</span></p>
<p class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr"><span>In contrast to the fighting gameplay of <em>Gorn</em> is the physics-based puzzler, <em>Bounce</em>.</span> <span class="veryhardreadability"><span><em>Bounce</em>, developed by Steel Wool Studios, has the player helping a ball-shaped robot navigate the corridors of an intergalactic spaceship</span></span><span>.</span> <span class="hardreadability"><span>Players</span></span> <span class="passivevoice"><span>are given</span></span> <span class="hardreadability"><span>an array of physics gadgets designed to propel their robot friend from one side of the level to the exit portal</span></span><span>.</span> <span class="hardreadability"><span>To get there, the robot must navigate around laser walls, gravity wells, and other sci-fi obstructions</span></span><span>. Beating the game unlocks style mode.</span> <span class="hardreadability"><span>This allows the player to play each of the game's 50 levels again and rewards them for the most creative solutions</span></span><span>. </span></p>
<div class="">
<p class="public-DraftStyleDefault-block public-DraftStyleDefault-ltr"><span class="hardreadability"><span>In both games, we can again see the unique movement mechanic and first-person perspective often seen in VR, used to great effect</span></span><span>.</span> <span class="hardreadability"><span><em>Gorn</em> uses player arm movement with cartoon physics to create a gaming experience that feels fun and intense</span></span><span>.</span> <span class="veryhardreadability"><span>In contrast, <em>Bounce</em> uses the first-person perspective to allow the player see what placing a particular physics gadget will do when the ball hits it</span></span><span>.</span> <span class="hardreadability"><span>This gives the player the ability to see firsthand the effects of their actions and allows the player to feel more in control of the experience</span></span><span>.</span></p>
</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Puzzle experiences</h1>
                </header>
            
            <article>
                
<p>With their use of object manipulation as a major mechanism and often fantasy environments, puzzle experiences lend themselves very well to the VR treatment. Since the time of <em>Myst</em> and it's sequels, players have shown time and again that they love solving the mysteries of ancient ruins, dark dungeons, and castles in the sky. However, until now, players haven't been able to truly reach eye level with some of these puzzles and environments, which can make solving problems where you have to aim a laser or shoot a bow much harder. Take as an example the laser puzzles from the game <em>The</em> <em>Talos Principle VR</em> by Croteam, a port of the popular puzzle game from 2014. Players are required in several puzzles to use a device to bend a laser beam to hit a particular target. Some players have reported that this task is considerably easier in VR due to their ability to bend down and see where the laser will travel from eye level.</p>
<p>Another great example of VR principles applied to puzzle gameplay can be found in the standout title <em>I Expect You to Die</em> by Schell Games. In this game, the player takes on the role of a telekinetic super spy, charged with completing various missions to defeat the evil Zoraxis Organization. Each of the five locations in the game feels a bit like an escape room. The player is given the task of escaping the area and must use the tools they find to complete the mission. For instance, the first mission of the game has the player tasked with driving the evil Dr. Zor's weaponized car out of the back of a cargo plane while the plane is slowly filling with poison gas and using only the tools found in the car or dismantled  ones from the car's many attempts to kill you. The game gets around the locomotion issue by giving the player the choice of making it a sitting or room-scale experience and by giving the player telekinesis so they never have to move. Together, the game uses the uniqueness of VR and creativity to great effect to create an experience that has players singing its praises.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Rhythm experiences</h1>
                </header>
            
            <article>
                
<p>In many ways, VR mechanics are breathing new life into the game genres that we love. This is especially true of rhythm games whose basic gameplay mechanics of <em>press this button at this time</em> seem old by today's standards. However, the application of VR-specific gameplay mechanics such as one-to-one arm movement have revitalized the genre and given rise to several unique rhythm experiences. At the top of that list is certainly <em>Beat Saber</em>, developed and published by Beat Games. </p>
<p><em>Beat Saber</em> combines rhythm gameplay with VR saber combat to create a unique title that has players swinging virtual red and blue energy sabers to hit the corresponding color blocks in time with the music. Players must strike the blocks with the correct color saber at the correct angle while ducking and dodging wall obstacles  and mines that shouldn't be hit. All of this action is set to the tempo of the song. With a variety of tracks and difficulty settings, <em>Beat Saber</em> sets a new standard for rhythm experiences in the age of VR. In this game, we see two types of gameplay collide: VR combat (swinging at stuff and dodging) and rhythm mechanics. The combination creates an almost dancing experience that makes it easy to enjoy. Though be prepared for a workout even if you're playing this as a seated experience, as some of the songs get very energetic at times.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Educational experiences</h1>
                </header>
            
            <article>
                
<p>Since its inception, educators have been interested in VR as a way to instruct and train the next generation in a way that's engaging and allows the learner to see the material from a new perspective. New generations of students are looking for education institutions to embrace technology while providing a unique and experiential style of learning. To meet this demand, education software developers, college development teams, and even some game developers have begun creating VR experiences that allow students to experience history close up or to learn to use high-end equipment without fear of hurting themselves. Besides immersion and unique mechanics, VR can allow those who wish to learn something that takes expensive equipment or rare resources the opportunity to do so. Here are some of the titles currently available:</p>
<ul>
<li><em>The Body VR: Journey Inside a Cell</em>: This game uses the immersion of VR to allow the player to experience traveling in the bloodstream of a human being and enter a blood cell to see the inner workings at the cellular level.</li>
</ul>
<ul>
<li><em>Sharecare VR</em>: This application allows the player to explore the anatomy of the human body, simulate disease, and show how treatment interacts with the body. Players can also call up specific organs and enable the display of tags to show specific structures. This allows players to learn and study the human anatomy in ways that weren't possible previously.</li>
<li><em>Apollo 11 VR</em>: <em>Apollo 11</em> combines a passive viewing experience with occasional mini games to allow the player to live the Apollo 11 mission firsthand.</li>
</ul>
<p>I also want to mention <em>Tribe XR</em> here. Though the developers have chosen to teach users how to DJ using high-end equipment, the goal is to create a creative education platform that can be used to teach many skills and take advantage of what they refer to as exponential learning. As part of the plan for their platform, they're allowing vetted users, in this case other DJs, to teach those new to the platform both in recorded and live lessons. This mechanism has amazing potential for revolutionizing how schools and businesses teach and train their students. </p>
<p>VR has the ability to bring the user into the game worlds that we create and turn their movements into real in-game action. These two unique features have the potential to revolutionize how players enjoy video games and create new avenues for designers to express themselves creatively. However, we need to make sure that these new techniques for creating interaction within game worlds to become a crutch that props up poor design. Like the graphics advances of the early 20's, we mustn't let VR become a novelty and an excuse for bad games.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Designing the gameplay for Server 17</h1>
                </header>
            
            <article>
                
<p>Now that we've discovered some of the great VR games that our potential users are playing and dug deep into how VR helps to make them unique, let's look at how VR can really make the experience that lets <em>Server 17</em> shine. This is where we move from the Discovery and Empathy phases of our design process into the Ideate phase. Ideate is where the magic happens and where ideas are brainstormed and transformed into something more. For our user (first-time VR user, sci-fi fan, and nostalgic), we need to take into account that their status as first time users will mean that a basic locomotion scheme is important. We also want to make sure that the gameplay is intuitive and easy to learn. Current VR controllers are capable of several button-based functions, but we'll want to keep our control scheme simple to lower the learning curve and make our game accessible. Lastly, we want to make our environment simple yet really embrace the cyberpunk and future aesthetic.</p>
<p>With these things in mind, let's design. To keep locomotion easy and minimize VR sickness, we can use teleportation while keeping the gameplay area small. This will have the added benefit of playing into our cyberpunk background and the fact that the game level is meant to take place in a form of VR itself. We'll have the player press buttons and manipulate objects using some avatar hands. This allows us to make the gameplay as natural as possible, as well as making it easy to grasp quickly <span>(pun intended)</span>. Gameplay will be centered around hacking a corporate server, reimagined as a techy-looking puzzle box in the center of the room that the player will have to solve by grasping parts to push and slide. We also want to provide the player with some special tools to speed the process up. These tools will be provided at different tool stations spread around the virtual room that represents the inside of the player's computer. Finally, to represent the danger of being discovered, the player will have to complete the puzzle box within a certain time frame. Here is a rough idea of the level:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/f1fa23a9-23b1-4cf5-8d42-23d01a5018ba.png" style="width:27.50em;height:35.33em;" width="1162" height="1492"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"> Level map with design markings</div>
<p>Now, your instinct might be next to decide on the art style or to start making static meshes and shaders. Resist that urge! Despite the fact that the design sounds fun on paper, we don't know whether all of the features will work as intended or whether they're even as fun as we think they'll be. To test our assumptions, we need to move to the prototype stage of our design process and build a quick functional mock up and have our user test it to gain feedback. That way, we don't waste time or resources on game elements we might not use.</p>
<p>We'll start by implementing the hands.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Adding the hand functionality</h1>
                </header>
            
            <article>
                
<p>We want the player's experience with their in-game representation to be as smooth and as seamless as possible. To that end, the hand solution we implement needs to be able to do a few different things. First, the player needs to be able to see the hands. Second, the player needs to be able to know which objects can be interacted with and which ones might simply be there as scenery. Third, the player needs to be able to grab, pick up, and potentially throw objects that we want them to interact with. Fourth, we need the player to be able to press buttons inside the level to utilize the tools found at the different tool stations and to solve the puzzle cube.</p>
<p><span>The first step in following our design is to add the hand models to our <kbd>Server17PlayerPawn</kbd> to give our player a representation of themselves in the game. To do this, we'll add the standard hands provided for us by Epic Games to our pawn: </span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/03daea4b-be39-4c19-a297-23ace88d7d62.png" width="1950" height="1126"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Hands added in the Class Blueprint screen</div>
<p>Here's how we add the hands:</p>
<ol>
<li>To have the hand meshes read the position of the player's motion controls, we'll start by adding a skeletal mesh component that's attached to the <span class="packt_screen">MotionController_L</span> component in our pawn. Click on the <span class="packt_screen">MotionController_L</span> component, and then click the <span class="packt_screen">Add Component</span> button at the top of the <span class="packt_screen">Components</span> panel. Select the <span class="packt_screen">Skeletal Mesh</span> option and name the new component <kbd>SkeletalMesh_L</kbd>.</li>
<li>In the <span class="packt_screen">Details</span> panel, find the <span class="packt_screen">Skeletal Mesh</span> drop-down menu and select the <span class="packt_screen">MannequinHand_Right</span>. This will add the hand to the end of the player's motion controller.</li>
<li>Since the hand is meant to be a right hand, we need to change a few settings to make it work correctly as a left hand. Find the <span class="packt_screen">Transform</span> portion of the <span class="packt_screen">Details</span> panel and change the <span class="packt_screen">X</span> field of the <span class="packt_screen">Location</span> property to <span class="packt_screen">-10</span>. This will align the mesh more with where the player's physical hand is on the controller and will feel more natural.</li>
</ol>
<ol start="4">
<li>Move down to the <span class="packt_screen">Rotation</span> property and change the <span class="packt_screen">X</span> value to <span class="packt_screen">90</span> degrees. This rotates the hand to a more natural position.</li>
<li>Move down one more property to the <span class="packt_screen">Scale</span> property, and change the <span class="packt_screen">Z</span> value to <span class="packt_screen">-1</span>. This will flip the orientation of the hand to truly represent a left hand.</li>
<li>With the left hand complete, repeat steps one through four to create the right hand and name it <kbd>MotionController_R</kbd>.</li>
</ol>
<p>If we test now, we can see that the player pawn now has hands! Wave them in the air like you just don't care. However, they don't really do much other than look plastic, yet well manicured. Let's start to give them some functionality with the edition of some collision shapes so we can record when they overlap with an object. Let's start with the left hand:</p>
<ol>
<li>Select the <span class="packt_screen">MotionController_L</span> component and navigate to the <span class="packt_screen">Add Component</span> menu. Find the <span class="packt_screen">Sphere Collision</span> component under the <span class="packt_screen">Collision</span> section of the drop-down menu and select it. Name it <kbd>Sphere_L</kbd>.</li>
<li>In the <span class="packt_screen">Details</span> panel, change the sphere radius to <span class="packt_screen">10</span>. This will define the area in which objects are considered overlapping with the player's hands.</li>
<li>Repeat steps one and two to create a collision sphere for the right hand and name it <kbd>Sphere_R</kbd>.</li>
</ol>
<p>Our hands are now set up to record overlap events so that we can manipulate objects in our game world. At this point, there are several actions we want these objects to perform. We want them to be able to detect when they're being looked at and when they're not. We also need them to know when we've performed some kind of action on them, an activated and a deactivated state. For this, we'll use something called a <strong>Blueprint Interface</strong>. A Blueprint Interface can be defined as a collection of one or more functions that can be assigned to objects that need to share data and functionality. It allows us to create a number of functions that each object that uses the interface can then define in a unique manner. In our game, we'll create an interface that contains all the functions that control how the hands manipulate gameplay objects.</p>
<div class="packt_infobox"><em>Tribe XR</em> makes extensive use of Blueprint Interfaces to facilitate the creation and communication of its <span class="fontstyle0">different</span> user interfaces, since many of them share common elements. From the interface elements used to display music track information to the <span class="packt_screen">Options</span> screen, they all have in common that they're 2D interfaces projected on to 3D planes. As we'll see from the following screenshot, creating a Blueprint Interface of common functions ahead of time can facilitate the creation of these menus:</div>
<div class="CDPAlignCenter CDPAlign"><img src="Images/38d621c0-e383-461c-9d07-6511d4c23db1.png" style="width:24.83em;height:36.08em;" width="1347" height="1950"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">The Blueprint Interface option in the right-click menu</div>
<p>Start by creating <span>a new <span class="packt_screen">Blueprint Interface</span>:</span></p>
<ol>
<li>Make sure we're in our <kbd>Sever17\Blueprints</kbd> folder. Right-click in the <span class="packt_screen">Content Broswer</span> and navigate to the <span class="packt_screen">Create Advanced Asset</span> section of the menu. Find the <span class="packt_screen">Blueprints</span> option and select <span class="packt_screen">Blueprint Interface</span>. Name it <kbd>ObjectInteractionInterface</kbd>.</li>
<li>Double-click <kbd>ObjectInteractionInterface</kbd> to open it.</li>
<li>We'll need to create several functions here. Over on the right-hand side of the screen in the <span class="packt_screen">Functions</span> section of the <span class="packt_screen">My Blueprints</span> panel, click the plus (<span class="packt_screen">+</span>) button to create a new function. Name it <kbd>TraceHitObject</kbd>. This will fire whenever our object is hit by a line trace from either the motion controller or the HMD, signifying that we're looking at it or interacting with it in some way.</li>
</ol>
<ol start="4">
<li>With our new function selected, look at the <span class="packt_screen">Details</span> panel. This panel allows us to add input and output to our function to handle our data. Let's add an input named <kbd>Hit</kbd> and use the type <span class="packt_screen">Hit Result</span>. Passing the hit data to the object allows us to access important information later.</li>
<li>To finish the function, we need to add a Boolean output named <span class="packt_screen">Return</span>. Unreal Engine reads a function without an output as an <span class="packt_screen">Event</span>, which isn't what we want. To avoid this, we use a dummy Boolean variable to complete the function.</li>
<li>The next function we need to create will be able to read when a trace leaves the object, giving us additional options for functionality. Head back to the <span class="packt_screen">Functions</span> section of the <kbd>MyBlueprint</kbd> panel and create another function. Name it <kbd>TraceLeaveObject</kbd>. Create an input variable called <kbd>Hit</kbd> of the <span class="packt_screen">Hit Result</span> <span>type</span>. Finish the function by creating a Boolean output and name it <kbd>Return</kbd>.</li>
<li>Now that the object can tell whether it's being looked at, let's take that functionality to the next level. It would be useful to have the object know what part of it's being looked at. We can do this by detecting the trace at the component level. Create a new function and name it <kbd>TraceHitComponent</kbd>. Just like our other functions, we need to create an input called <kbd>Hit</kbd> of the <span class="packt_screen">Hit Result</span> type and an output called <kbd>Return</kbd> of the <span class="packt_screen">Boolean</span> type.</li>
<li>To be able to read what component is being hit, we need to also add another input. Create a second input named <kbd>Component</kbd> and make it be of the type <span class="packt_screen">Primitive Component</span>. This way, we can pass in what specific component is being hit.</li>
<li>Let's finish this functionality. Create another function and name it <kbd>TraceLeaveComponent</kbd>. This should have the same inputs and outputs as the <kbd>TraceHitComponent</kbd>.</li>
<li>Just a few more functions and we'll be finished! Let's create a function that can be called every frame to track the potential movement of an object. Create another function and name it <kbd>TraceMove</kbd>. This should have an input named <kbd>Hit</kbd> of the <span class="packt_screen">Hit Result</span> type, and an output named <kbd>Return</kbd> of the <span class="packt_screen">Boolean</span> type.</li>
<li><kbd>TraceMove</kbd> needs one more change to make it function correctly. Since this is a function designed to be called every frame, performance is definitely a concern. To optimize this function, we'll check two options. First, under the <kbd>Hit</kbd> input, click the little arrow next to the name of the variable and click the checkbox to make the function <span class="packt_screen">Pass-by-Reference</span>. Passing by reference allows the <kbd>Hit</kbd> variable to be passed on by name without passing the value. Because we're selecting to pass the variable in this manner, we need to select the <span class="packt_screen">Const</span> option in the <span class="packt_screen">Graph</span> section of the <span class="packt_screen">Details</span> panel. If you can't see the option, click the down arrow at the bottom of the section to expose the checkbox.</li>
</ol>
<ol start="12">
<li>Finally, let's create one more bit of functionality. We want to be able to activate and deactivate some kind of effect on an object. This covers a variety of potential scenarios, such as being able to turn a flashlight you picked up on and off. To create this effect, we need two more functions. First, create a new function and name it <kbd>TraceActivateDown</kbd>.</li>
<li><kbd>TraceActivateDown</kbd> will signify when a button has been pressed to activate the object. It needs two inputs. The first is named <kbd>Hit</kbd> and has a <span class="packt_screen">Hit Result</span> type (so that a lot of great information is packed into a hit result). The second is named <kbd>Instigator</kbd> and is of the <span class="packt_screen">Pawn</span> type. This way, we can pass in the <span class="packt_screen">Pawn</span> that activated the object. Finish by creating an output named <kbd>Return</kbd> of the <span class="packt_screen">Boolean</span> type.</li>
<li>If <kbd>TraceActivateDown</kbd> represents a button press, then we need our final function for our interface to represent the release of that button. Create one final function named <kbd>TraceActivateUp</kbd>. This should have the same inputs and outputs as <kbd>TraceActivateDown</kbd>.</li>
</ol>
<p style="padding-left: 60px">With everything completed, your interface should look something like this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/29a2c328-aeec-4a3b-ae12-3735ca8c44ce.png" style="width:19.83em;height:19.83em;" width="731" height="729"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The My Blueprint section of ObjectInteractionInterface</div>
<p><kbd>ObjectInteractionInterface</kbd> now encapsulates many of the functions we would want an object to be able to perform. However, many of them depend on being the target of a line trace to be able to operate. A <strong>line trace</strong> is a function that can be called that will draw a line from one point to another and report anything that's hit by the line. Using that hit data, we can do all kinds of things! For instance, we can find the distance from the player to the object. We can act on the object to change color, emit sound, or other behaviors. We can even cause the object to delete itself if we wanted to. In shooter games, this is how direct-damage weapons, such as lasers, sniper rifles, or other weapons that don't really have a projectile, work. Since our line trace will be checking where our player is looking and will likely be used to figure out where they can teleport, we'll use a parabola, or curved line, rather than a straight line for our trace. To do this, we'll create a custom component that can be added to our HMD or motion controller that projects the line trace:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/5a5ca50d-8920-4c4f-9734-7d35dd30fc11.png" width="1862" height="1064"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Created Interaction Component</div>
<p>We need to create a custom <span class="packt_screen">Scene Component</span> that can be added to our custom pawn:</p>
<ol>
<li>In the <span class="packt_screen">Content Browser</span>, right-click in the <kbd>Server17\Blueprints</kbd> folder and click the <span class="packt_screen">Blueprint Class</span> option. In the bottom section of the <span class="packt_screen">Pick Parent Class</span> window, search for <span class="packt_screen">Scene Component</span> using the search box. Click it and then click the <span class="packt_screen">Select</span> button. Name this new component <kbd>InteractionComponent</kbd>.</li>
<li>This new component is going to handle our line trace and any data that it collects. It'll then distribute the hit data through our interface to all of our interaction functions. Start by creating a new function by clicking the +<span class="packt_screen">Function</span> button that's part of the <span class="packt_screen">My Blueprints</span> panel. Name this new function <kbd>ParabolicLineTrace</kbd>.</li>
<li>We calculate the parabolic curve by taking the direction the interaction component is facing and calculate the projected curve based on a fixed point in time and a speed value. The formula is <em>z = (t * v<sub>z</sub>) - (0.5 * g * t<sup>2</sup>)</em>, where <em>z</em> is the projected end of the arc in the <em>z</em> axis, <em>v</em> is the velocity, <em>g</em> is gravity, and <em>t</em> is time. The distance the arc will cover is estimated by <em>y = t * v<sub>y</sub></em> where <em>y</em> is the end of the arc in the <em>y</em> axis. To have our function calculate our arc, it'll need three inputs. The first is named <kbd>Steps</kbd> and has a type of <span class="packt_screen">Integer</span>. The second is named <kbd>TimeStep</kbd>, which is a <span class="packt_screen">Float</span> value. Last, we have <kbd>Speed</kbd> of the <span class="packt_screen">Float</span> type.</li>
</ol>
<div class="packt_tip">If you don't understand the math, don't worry! The arc it creates is perfect for estimating the final location of our future teleport. Once complete, Unreal Engine 4 will be able to visually represent our line trace to us, and it'll make sense.</div>
<ol start="4">
<li>Double-click on our new function to open it. <kbd>ParabolicLineTrace</kbd> needs six local variables to work. Find the <span class="packt_screen">Local Variables</span> section at the bottom of the <span class="packt_screen">My Blueprints</span> panel. Click the <span class="packt_screen">+Local Variable</span> button and create a new variable named <span class="packt_screen">Init Loc</span> of the type <span class="packt_screen">Vector</span>. Next, create one named <span class="packt_screen">Prev Loc</span>, also of the type <span class="packt_screen">Vector</span>. <span>These will store the initial locations for our curve calculation.</span></li>
</ol>
<ol start="5">
<li>Create another local variable named <kbd>Velocity</kbd> of the type <span class="packt_screen">Vector</span>. This is our speed value.</li>
<li>Now we need two local variables to handle our time calculation. Create two new local variables named <kbd>InTimeStep</kbd> of the type <span class="packt_screen">Float</span> and <span class="packt_screen">In Steps</span> of the type <span class="packt_screen">Integer</span>.</li>
</ol>
<ol start="7">
<li>This is the last one! We need one more local variable to hold the hit data from the line trace. Create one final local variable named <kbd>TempHit</kbd> and make sure its type is set to <span class="packt_screen">Hit Result</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/38982226-4f8d-42f4-8b7d-a6e3469824ad.png" style="width:73.00em;height:41.25em;" width="1950" height="1101"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Setting up the variables in the Parabolic Line Trace</div>
<p style="padding-left: 90px">With all of our variables finally set up, we can move on to creating our curve calculation.</p>
<ol start="8">
<li>The first step in our function is to store our location data. From your <span class="packt_screen">Local Variables</span> section, drag in a copy of your <kbd>InitLoc</kbd> variable and choose <span class="packt_screen">Set</span>. Do the same for your <kbd>PrevLoc</kbd> variable. Connect the execute output of the beginning of the function to the input on <span class="packt_screen">Init Loc</span>. Connect the execute output on <span class="packt_screen">Init Loc</span> to the input on <span class="packt_screen">Prev Loc</span>.</li>
<li>Now we need to fill them with data. We need to start by knowing the location of the interaction component within the game world. Right-click in the blueprint window or use the Palette to grab a <span class="packt_screen">GetWorldLocation</span> node. Connect the output of our new node into the <span class="packt_screen">Init Loc</span> vector input, and then connect the vector output on <span class="packt_screen">Init Loc</span> to the vector input on <span class="packt_screen">Prev Loc</span>.</li>
</ol>
<ol start="10">
<li>Go back to the <span class="packt_screen">Local Variables</span> section in <span class="packt_screen">My Blueprint</span> and grab the <span class="packt_screen">In Steps</span> and the <kbd>InTimeStep</kbd> variables, and choose <span class="packt_screen">Set</span> for both of them. Connect the execute output of our <span class="packt_screen">Prev Loc</span> node to the execute input on the <span class="packt_screen">In Steps</span> node. Then, connect the execute output of <span class="packt_screen">In Steps</span> to the input on <span class="packt_screen">In Time Step</span>.</li>
</ol>
<ol start="11">
<li>To finish this section, we need to connect <span class="packt_screen">In Steps</span> and <span class="packt_screen">In Time Step</span> to their appropriate data input. Take the <kbd>Steps</kbd> input from our function and connect that to the integer input on <span class="packt_screen">In Steps</span>. Finally, take the <span class="packt_screen">TimeStep</span> input from the function and plug that into the float input on <span class="packt_screen">In Time Step</span>.</li>
<li>There's one last bit of data to initialize before we calculate the curve. To get the velocity we'll use for the calculation, we'll need to determine the forward vector of our interaction component and multiply that by the <kbd>Speed</kbd> variable we take as an input into our function. Head back to the <span class="packt_screen">Local Variables</span> portion of the screen and drag in a copy of the <kbd>Velocity</kbd> variable. Choose <span class="packt_screen">Set</span> from the menu. Connect the execute output from our <span class="packt_screen">In Time Step</span> node and plug it into our new <span class="packt_screen">Velocity</span> node.</li>
</ol>
<ol start="13">
<li>Right-click in the blueprint and use the menu to find the <span class="packt_screen">Get Forward Vector</span> node where the target is a <span class="packt_screen">Scene Component</span>. Drag a line off the <span class="packt_screen">Return Value</span> of the node and drop it to bring up the search menu and search for the <kbd>Vector * Float</kbd> node. The vector input will be the <span class="packt_screen">Return Value</span> of the <span class="packt_screen">Get Forward Vector</span>, and the float value will be the <span class="packt_screen">Speed</span> input from the start of our function. The resulting value will become the input for the vector on the <span class="packt_screen">Set Velocity</span> node:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/bf18caee-e945-4b91-aa93-299aae8065aa.png" width="1950" height="1259"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Calculating a parabolic line trace in blueprints</div>
<ol start="14">
<li>With all of our variables straightened out, it's time for the fun part! Start the calculation by creating a <span class="packt_screen">ForLoopWithBreak</span> node. Connect the execute output from our set <span class="packt_screen">Velocity</span> to the execute input on <span class="packt_screen">ForLoopWithBreak</span>. Drag in a copy of our local variable <span class="packt_screen">In Steps</span> and plug that into the <span class="packt_screen">Last Index</span> input on <span class="packt_screen">ForLoopWithBreak</span>. Lastly, set the <span class="packt_screen">First Index</span> integer to <span class="packt_screen">1</span>.</li>
</ol>
<ol start="15">
<li>Next, create a <span class="packt_screen">Line Trace By Channel</span> node. This node will do all of the heavy lifting and create the actual line trace. Plug the <span class="packt_screen">Loop Body</span> output from the <span class="packt_screen">ForLoopWithBreak</span> into the execute input on our new line trace. On the line trace node, change the <span class="packt_screen">Draw Debug Type</span> to <span class="packt_screen">For One Frame</span>. This will help us to visualize the parabolic arc. We can always turn it off later. Now grab a copy of the <kbd>PrevLoc</kbd> variable and plug that into the <kbd>Start</kbd> input on the line trace.</li>
<li>Bring on the math! Let's start by getting a copy of the <kbd>Velocity</kbd> local variable. Right-click on the output of the variable and choose the <span class="packt_screen">Split Struct Pin</span> option. This displays all the values that make up our velocity vector. </li>
<li>Now create three copies of the <kbd>Float * Float</kbd> node. We're going to plug the <em>X</em>, <em>Y</em>, and <em>Z</em> values we just exposed on the <span class="packt_screen">Velocity</span> node into the top input on each of the multiplication nodes.</li>
<li>Create a copy of the <kbd>InTimeStep</kbd> local variable and an <kbd>Integer * Float</kbd> node. Plug the output of the variable into the float input on the multiplication node. The input for the integer section of the node comes from the <kbd>Index</kbd> output of the <span class="packt_screen">ForLoopWithBreak</span> node. The output from this bit of math will be used by many nodes. </li>
<li><span>Take the output and plug it into the second float input on the multiplication nodes we created earlier in <em>step 17</em>. </span></li>
</ol>
<div class="packt_tip">Don't forget, you can create reroute nodes to help clean your code! Right-click in the <span class="packt_screen">Blueprint</span> as if you're creating a new node and find the <span class="packt_screen">Reroute</span> node down toward the bottom of the menu.</div>
<ol start="20">
<li>It's time to compensate for gravity in our calculation. Create a <kbd>Float * Float</kbd> node and place it near the multiplication node created in <em>step 18</em>. On the newly created node, there's a button labeled <span class="packt_screen">+ Add Pin</span>. Let's click that twice to create two more input pins. Plug the output of the multiplication node from <em>step 18</em> into the first two input values of our new node (this represents time being squared in our equation). In the third input, change the value to 0.5. In the final input, change the value to 980.</li>
</ol>
<ol start="21">
<li>We've almost finished the math. Create a <kbd>Float - Float</kbd> node and plug the output of the multiplication node we use with the <em>Z</em> value from our <kbd>Velocity</kbd> variable into the first input and the output of the multiplication node we created in <em>step 20</em> into the second input.</li>
</ol>
<ol start="22">
<li>Finally, create one final math node, <kbd>Vector + Vector</kbd>, and right-click on the first <kbd>Vector</kbd> input pin. Select <span class="packt_screen">Split Struct Pin</span> from the menu. The <em>X</em> value will be the output of the <span class="packt_screen">X</span> <span class="packt_screen">Velocity</span> multiplication node. The <em>Y</em> will <span>be the output of the <span class="packt_screen">Y Velocity</span> multiplication node. The <em>Z</em> value will be the output of the <kbd>Float - Float</kbd> we created in the last step. All of that will be added to the value of</span> <span class="packt_screen">Init Loc</span><span>. Create a copy of the variable and plug into the last input. The output of this node will become the <span class="packt_screen">End</span> vector input on our line trace node.</span></li>
</ol>
<p style="padding-left: 60px">There's one last section regarding this function. With our <span class="packt_screen">Line Trace by Channel</span> <span>node getting all of the information it needs, we need to set up the output values to store the information that we receive from the trace. We'll do this by updating the location we've stored in our</span> <span class="packt_screen">Prev Loc</span> <span>node and saving the hit result information into the</span> <span class="packt_screen">TempHit</span> <span>node:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/80611f4e-3dcf-41e5-8d81-20a1bb0d0696.png" width="1933" height="1105"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Completing the line trace</div>
<p style="padding-left: 90px">Let's wrap this thing up!</p>
<ol start="23">
<li>Create a <span class="packt_screen">SET</span> node for our <kbd>PrevLoc</kbd> variable and connect the execute output from the line trace to its execute input. To update the vector input, drag a connection from the <kbd>Vector + Vector</kbd> node we created in <em>step 22</em> and plug it into the input.</li>
</ol>
<ol start="24">
<li>Next, create a <span class="packt_screen">Set</span> node for the <span class="packt_screen">Temp Hit</span> local variable and connect the execute output from our set <span class="packt_screen">Prev Loc</span> node to the execute input. Connect the <span class="packt_screen">Out</span> <span class="packt_screen">Hit</span> output from the line trace into the input.</li>
<li>To make sure that we aren't making any unnecessary hit calculations when no hit is found, let's add a <span class="packt_screen">Branch</span> node. Add a <span class="packt_screen">Branch</span> node and connect the execute output from the set <span class="packt_screen">TempHit</span> node to it. Pass the <span class="packt_screen">Return Value</span> output from the line trace into the <span class="packt_screen">Condition</span> input.</li>
<li>Bring the execute output from this node all of the way back to the <span class="packt_screen">ForLoopWithBreak</span> node and plug it into<span> the</span> <span class="packt_screen">Break</span> <span>input.</span></li>
<li>Finish this by connecting the complete execute output to the input on the function's <span class="packt_screen">Return</span> node. Create a copy of <span class="packt_screen">TempHit</span> and pass that into the function's output.</li>
</ol>
<p>Now that the <span class="packt_screen">Parabolic Line Trace</span> function is finally complete (wow! There's a lot going on there), it's time to do something with the hit information that it collects. The <span class="packt_screen">Interact With Hit</span> function will take the hit data from the line trace and pass it to our functions we created in the <span class="packt_screen">Object Interaction Interface</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/d02b1a4b-07b4-47bb-ae1b-f2bf7f53a4e7.png" style="width:13.92em;height:18.75em;" width="698" height="939"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The variables for the InteractWithHit function</div>
<p>Let's start by creating some variables:</p>
<ol>
<li>In the <span class="packt_screen">My Blueprints</span> panel, find the <span class="packt_screen">Variables</span> section and click the <span class="packt_screen">+Variable</span> button. The first one we'll create will be named the <kbd>FocusComponent</kbd>. Set the <span class="packt_screen">Variable Type</span> to <span class="packt_screen">Primitive Component</span>. This will allow us to work with the individual components of an object as well as the object itself. Next, create a new variable named <kbd>FocusObject</kbd> and set the type to <kbd>Actor</kbd>. This will store the current object being hit. Finally, create a variable named <kbd>CurrentHit</kbd> and make its type <kbd>Hit Result</kbd> to store the hit information we collected from the line trace. Once we've created all three variables, click on each one and mark them <span class="packt_screen">Private</span> in the <span class="packt_screen">Details</span> panel.</li>
<li>It's time to create our second function. In the <span class="packt_screen">Functions</span> section of <span class="packt_screen">My Blueprint</span>, click the <span class="packt_screen">+Function</span> button and name the new function <kbd>InteractWithHit</kbd>. The new function needs to have the ability to pass hit data into it. Click on the function, and in the <span class="packt_screen">Details</span> panel create a new input named <kbd>Hit</kbd> of the type <span class="packt_screen">Hit Result</span>.</li>
<li>Now we need to set up three <span class="packt_screen">Local Variables</span> inside our new function. Double-click the <kbd>InteractWithHit</kbd> function and head to the <span class="packt_screen">Local Variables</span> section. Click the <span class="packt_screen">+Local Variable</span> button and name the new variable <kbd>InHitComponent</kbd> of the type <span class="packt_screen">Primitive Component</span>. Create a second local variable and name it <span class="packt_screen">In Hit</span> of the type <span class="packt_screen">Hit Result</span>. Lastly, create a third local variable and name it <span class="packt_screen">In Hit Actor</span>, and make it of the type <span class="packt_screen">Actor</span>.</li>
<li>The initial setup is complete! With our variables created, we can now start initializing them with data. Starting at the function node, grab a copy of our <span class="packt_screen">In Hit</span> local variable, and choose <span class="packt_screen">Set</span> from the resulting menu. Connect the execute output from the function node to the input on the set <span class="packt_screen">In Hit</span> node. We also want to pass the <span class="packt_screen">Hit</span> data coming from outside of the function, so we'll connect the <span class="packt_screen">Hit</span> pin on the function node to the input on the set <span class="packt_screen">In Hit</span> node:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/1eb18fcf-bc24-4fd3-82f4-c47b62d9f77f.png" width="1927" height="1238"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"> Taking in the hit data and storing it in our variables</div>
<ol start="5">
<li>Next, we're going to break the hit down and pass the <span class="packt_screen">Hit Actor</span> and the <span class="packt_screen">Hit Component</span> data to our local variables so that we can work with them. Right-click in the blueprint and create a <span class="packt_screen">Break Hit Result</span> node. Connect the variable output of the <span class="packt_screen">Set</span> <span class="packt_screen">In Hit</span> node to the input on our new node. This will break the hit information down into its parts. Next, bring in a copy of our <span class="packt_screen">In Hit Actor</span> and the <kbd>InHitComponent</kbd> variables, and choose <span class="packt_screen">Set</span> from the menu. With the two setters created, connect them in the order you see in the previous screenshot. Then, connect the <span class="packt_screen">Hit Actor</span> output from <span class="packt_screen">Break Hit Result</span> to the input on the set <span class="packt_screen">In Hit Actor</span> node. Be sure to do the same for <span class="packt_screen">Hit Component</span> and the <kbd>InHitComponent</kbd> node.</li>
</ol>
<ol start="6">
<li>Much of what we're doing here is checking the data to see whether what we're looking at can be interacted with and then passing that information through the interface we created earlier. We also need to be able to clear our variables if we're no longer looking at something that has interaction. The first step in this process is to check to see whether the object we're looking at (stored in <span class="packt_screen">Focus Object</span>) is equal to the one we're currently looking at, and for that we need a <kbd>Branch</kbd> node. Create a new <kbd>Branch</kbd> node and connect its execute input to the output from the <span class="packt_screen">Set</span> <kbd>InHitComponent</kbd>. Now we need the two variables we want to compare. Get a copy of our <span class="packt_screen">Focus Object</span> variable and our <span class="packt_screen">In Hit Actor</span> local variable. Drag a connection off <span class="packt_screen">FocusObject</span> and drop it to open the search menu. Look for the <span class="packt_screen">Equal</span> (Object) node. This will compare two objects passed into it and return a Boolean showing whether they match. Connect the <span class="packt_screen">In Hit Actor</span> to the second input and run the Boolean output into the input pin on the <span class="packt_screen">Branch</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/84cdf136-01e1-4a65-affb-22e455f437d2.png" width="1937" height="1053"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Passing the data through our interface</span></div>
<ol start="7">
<li>With our <span class="packt_screen">Branch</span> ready, it's time to pass the information. From the <kbd>True</kbd> output, drag a connection off and drop it to search for our <span class="packt_screen">Trace Move</span> (message) function that we created earlier in the <span class="packt_screen">Object Interaction Interface</span>. Get a copy of the <span class="packt_screen">Focus Object</span> variable and pass that into the <span class="packt_screen">Target</span> pin on <span class="packt_screen">Trace Move</span>. Now get a copy of the <span class="packt_screen">In Hit</span> variable and connect that to the <kbd>Hit</kbd> input on <span class="packt_screen">Trace Move</span>.</li>
</ol>
<ol start="8">
<li>Create another <span class="packt_screen">Branch</span> node and connect its execution input to the output from <span class="packt_screen">Trace Move</span>. This time, we'll be checking to see whether the <span class="packt_screen">Focus Object</span> is equal to the <kbd>InHitComponent</kbd> and passing the new information along if it's not. To do that, we need to get the <span class="packt_screen">Focus Object</span> and the <span><kbd>InHitComponent</kbd> and use our <span class="packt_screen">Equal</span> (object) node to compare them. Take the Boolean output of that comparison and plug it into the input on the new <span class="packt_screen">Branch</span>.</span></li>
<li>The next node we need is another function from our interface. Right-click and search for <span class="packt_screen">Trace Leave Component</span> (message). Create it and connect it to the <span class="packt_screen">False</span> output on the last <span class="packt_screen">Branch</span>. For input, we'll need to get a copy of the <span class="packt_screen">FocusObject</span> and pass that into <span class="packt_screen">Target</span>, <span class="packt_screen">In Hit</span>, and pass that into <span class="packt_screen">Hit</span>, and the <span class="packt_screen">FocusComponent</span> and pass that into <span class="packt_screen">Component</span>. </li>
<li>Now that we've called leave on the current focused component, we'll call the <span class="packt_screen">Trace Hit Component</span> and have it pass the current component we're looking at. Create a copy of the <span class="packt_screen">Trace Hit Component</span> (message) and connect it to the <span class="packt_screen">Trace Leave Component</span>. Pass <span class="packt_screen">FocusObject</span> into <span class="packt_screen">Target</span>, <span class="packt_screen">In Hit</span> into <span class="packt_screen">Hit</span>, and <span><kbd>InHitComponent</kbd> into <span class="packt_screen">Component</span>.</span></li>
<li>There is one final step in this branch of the process. We need to set the <span class="packt_screen">FocusComponent</span> to our new the <kbd>InHitComponent</kbd>. Create a <span class="packt_screen">Set</span> node for the <span class="packt_screen">FocusComponent</span>, and get a copy of the <kbd>InHitComponent</kbd>. Connect the execute output from the <span class="packt_screen">Trace Hit Component</span> to set the <span class="packt_screen">FocusComponent</span><span> and pass the <kbd>InHitComponent</kbd> into the variable input pin. </span></li>
</ol>
<ol start="12">
<li>The branch we created was all about passing component data if the <span class="packt_screen">Focus Object</span> and the <span class="packt_screen">In Hit</span> object we're looking at are the same, but what if they're different? If they are, we need to clear the hit data and pass the new hit information through the interface. Go back to the <span class="packt_screen">Branch</span> we created way back in <em>step 6</em>. Drag a connection from the <kbd>False</kbd> output and drop it. Search for the <span class="packt_screen">Trace Leave Object</span> function and create the node. The <span class="packt_screen">Trace Leave Object</span> has two input values. Into the <span class="packt_screen">Target</span> input, we'll pass the object we're currently storing in the <span class="packt_screen">FocusObject</span>. For the <kbd>Hit</kbd> input, get the current value of <span class="packt_screen">In Hit</span> and connect it to the input pin:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/af012a2b-f0d3-4b15-b019-ecc85c8ca521.png" width="1931" height="1241"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span> Clearing the variables</span></div>
<ol start="13">
<li>Since we're leaving the object and turning our focus elsewhere, we'll need to clear the values stored in the <span class="packt_screen">FocusObject</span> and the <span class="packt_screen">FocusComponent</span>. Create a <span class="packt_screen">Set</span> version of each of the variables. Connect the new set <span class="packt_screen">FocusObject</span> node to the execute output from <span class="packt_screen">Trace Leave Object</span>. Connect the new set <span class="packt_screen">FocusComponent</span> node to the set <span class="packt_screen">FocusObject</span> node. We're leaving both of their input values empty to clear their values.</li>
</ol>
<ol start="14">
<li>Before we pass the new hit data forward, there's still one more check we need to do. We only want to pass on the hit information if the object we're looking at makes use of the Object Interaction Interface, since anything else wouldn't matter to us. It's our way as designers of creating objects that are interactable and others that are only meant to be scenery. To do this, we'll use another <span class="packt_screen">Branch</span> node. Connect the input for the new branch to the execution output from the set <span class="packt_screen">FocusComponent</span>. To check to see whether the object we're looking at uses the interface, we need to use the <span class="packt_screen">Does Implement Interface</span> function. This function takes in an <span class="packt_screen">Actor</span> and checks to see whether it has a specific interface attached to it, then returns a Boolean value—perfect for using with the <span class="packt_screen">Branch</span> node. Create a copy of the <span class="packt_screen">D<span>oes Implement Interface</span></span><span>. Pass in the value of the</span> <span class="packt_screen">In Hit Actor</span> <span>as the <span class="packt_screen">Test Object</span> and then click the drop-down menu under <span class="packt_screen">Interface</span>. Use the search box at the top of the menu to find our <span class="packt_screen">Object Interaction Interface</span>. With that set, plug the <span class="packt_screen">Return</span> value from the node into the <kbd>Condition</kbd> input on our <span class="packt_screen">Branch</span>. Our check is all set up:</span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/d57977ce-159a-491d-b73e-f71be8d77dac.png" width="1930" height="1240"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Passing in the new hit data</span></div>
<ol start="15">
<li>Now all that's left is to pass on is the new hit data. Right-click in the blueprint and search for <span class="packt_screen">Trace Hit Object</span> (message). Connect it to the <span class="packt_screen">True</span> output from the <span class="packt_screen">Branch</span> and pass the <span class="packt_screen">In Hit Actor</span> into the <span class="packt_screen">Target</span> input and the <span class="packt_screen">In Hit</span> into the <span class="packt_screen">Hit</span> input.</li>
<li>Next, create a copy of the <span class="packt_screen">Trace Hit Component</span> (message) function. Pass the <span class="packt_screen">In Hit Actor</span> into the <span class="packt_screen">Target</span> input, <span class="packt_screen">In Hit</span> into the <span class="packt_screen">Hit</span> input, and the <span class="packt_screen">InHitComponent</span> into the <span class="packt_screen">Component</span> input.</li>
<li>In the final step for this branch, we'll need to update the values store in the <span class="packt_screen">FocusObject</span> and the <span class="packt_screen">FocusComponent</span> with the values from the <span class="packt_screen">In Hit Actor</span> and the <kbd>InHitComponent</kbd>. Create a set <span class="packt_screen">FocusObject</span> node and connect it to the execute output of the <span class="packt_screen">Trace Hit Component</span> function. Pass the value of the <span class="packt_screen">In Hit Actor</span> into the variable input. Lastly, connect the set <span class="packt_screen">FocusComponent</span> execute input to the execute output from set the <kbd>FocusActor</kbd> and pass in the value from the <kbd>InHitComponent</kbd>. We've now completely finished using this function!</li>
</ol>
<p>It's taken quite a bit of programming to get here, hasn't it? However, we have made a huge amount of progress in building our hand interactions. Our <span class="packt_screen">Interaction Component</span> now has the ability to do a parabolic line trace to find objects and safe locations to teleport. It can now pass information through the Object Interaction Interface we created to allow our interactable objects to work with the hands, to create gameplay. It's now time to bring that all together in the Event Graph to implement all of the functionality we've created. For this, we'll use the <span class="packt_screen">Event Tick</span> node:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/dd5d5567-f1f3-4d9c-aa24-29b45998457e.png" style="width:64.75em;height:32.08em;" width="1929" height="956"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Triggering the Parabolic Line Trace</div>
<p>Start by creating a couple of <span class="packt_screen">Custom Events</span>:</p>
<ol>
<li>We'll need two custom events to represent the on and off states that we want the <span class="packt_screen">Interaction Component</span> to have. The <span class="packt_screen">Custom Events</span> will be called by elements outside this blueprint to trigger interaction using button presses on the player's motion controllers. Right-click near the <span class="packt_screen">Event Tick</span> node and find the <span class="packt_screen">Add Event</span> section of the menu. Open it and select the <span class="packt_screen">Add Custom Event</span> option. Name this new event <kbd>Enable</kbd>. Repeat the process to create a second custom event and name it <kbd>Disable</kbd>.</li>
<li>Next, we'll use a <span class="packt_screen">Gate</span> node to only allow the player to interact with objects when they've enabled the interaction component with a button. A <span class="packt_screen">Gate</span> is a flow-control node that opens and shuts to allow data through only when the programmer allows it. Right-click in the blueprint and search for the <span class="packt_screen">Gate</span> node. We'll connect the <span class="packt_screen">Event Tick</span> output to the <span class="packt_screen">Enter</span> input on the <span class="packt_screen">Gate</span>. To control the flow of data, we'll connect the <span class="packt_screen">Execution</span> output from our <span class="packt_screen">Enable</span> custom event to the <span class="packt_screen">Open</span> input and the execution output from the <span class="packt_screen">Disable</span> custom event to the <span class="packt_screen">Close</span> input.</li>
</ol>
<ol start="3">
<li>Now we'll add in our <span class="packt_screen">Parabolic Line Trace</span> function. Grab a copy of it from the <span class="packt_screen">My Blueprints</span> panel and drag it into the blueprint. Connect the execute output from the <span class="packt_screen">Gate</span> to the execution input on the function. To make sure our parabola functions correctly, set the number of <span class="packt_screen">Steps</span> to <kbd>10</kbd>, the <span class="packt_screen">Time Step</span> to <kbd>0.1</kbd>, and the <span class="packt_screen">Speed</span> to <kbd>500</kbd>. </li>
<li>The output from our line trace needs to be stored so that we can pass it to the <span class="packt_screen">Interact With Hit</span> function. Luckily, we already created a variable to hold it. Create a copy of our <kbd>CurrentHit</kbd> hit variable by dragging it in from the <span class="packt_screen">My Blueprint</span> panel and select <span class="packt_screen">Set</span> from the menu. Connect it to the execute output from the line trace function and pass the <span class="packt_screen">Hit</span> output from the line trace into it.</li>
<li>End the sequence by bringing in the <span class="packt_screen">Interact With Hit</span> function and connecting the execute output from the set <span class="packt_screen">CurrentHit</span> node to it. Connect the variable output from the set <span class="packt_screen">CurrentHit</span> as the <span class="packt_screen">Hit</span> input on the function.</li>
</ol>
<p>There's one final piece to this interaction puzzle. We need to add the interaction component to <kbd>Server17PlayerPawn</kbd> and map the functionality to buttons on the player's motion controllers. Let's start by adding two more custom events to the <span class="packt_screen">Interaction Component</span> blueprint:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/e743e973-8b7f-4860-9a67-4ca3d1d3bdd2.png" style="width:41.42em;height:26.58em;" width="1929" height="1238"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Activation section of the Interaction Blueprint</div>
<p>Every button has two states: an up and a down. We'll define these states by creating two Custom Events:</p>
<ol>
<li>Right-click in a new section of the blueprint, find the <span class="packt_screen">Add Event</span> section of the menu, and open it and choose <span class="packt_screen">Add Custom Event</span>. Name the first one <kbd>ActivateUp</kbd>. Create a second custom event and name it <kbd>ActivateDown</kbd>. Both events need to have a single input. Click on each of the custom events and click the <span class="packt_screen">+</span> button in the <span class="packt_screen">Inputs</span> section of the <span class="packt_screen">Details</span> panel. Name the input <kbd>Instigator</kbd> and make its type <span class="packt_screen">Pawn</span>.</li>
<li>Drag a connection off <span class="packt_screen">ActivateUp</span> and search for <span class="packt_screen">Trace Activate Up</span> (message). We created this function as part of our interface. Connect its execution to the <span class="packt_screen">ActivateUp</span> event and connect the <span class="packt_screen">Instigator</span> output from the event to the <span class="packt_screen">Instigator</span> input on the function.</li>
<li><span class="packt_screen">Trace Activate Up</span> still needs two more input values to work correctly. Get a copy of the <kbd>FocusObject</kbd> variable and connect that to the <span class="packt_screen">Target</span> input. Lastly, get a copy of the <kbd>CurrentHit</kbd> variable and connect that to the <kbd>Hit</kbd> input on the function.</li>
<li>We're going to repeat this process for <kbd>ActivateDown</kbd>—only, this time, we'll connect the <span class="packt_screen">Trace Activate Down</span> (message) function from our interface.</li>
</ol>
<p>It's time to finish the setup in the player pawn:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/7886b243-86b5-4373-94a3-dbfad3fbc1ba.png" style="width:17.17em;height:22.00em;" width="721" height="924"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Components setup in the player pawn</div>
<p>Start by adding a copy of the <span class="packt_screen">Interaction Component</span> to each of the hands:</p>
<ol>
<li>In the <span class="packt_screen">Content Browser</span>, find the <kbd>Server17PlayerPawn</kbd> and double-click to open it.</li>
<li>In the <span class="packt_screen">Viewport</span> tab, head over to the <span class="packt_screen">Components</span> panel and click the <span class="packt_screen">Add Component</span> button. Use the search box to find our <span class="packt_screen">Interaction Component</span> that we created. It'll be under the heading <span class="packt_screen">Custom</span>. Click on it and name the new component <kbd>InteractionComponent_L</kbd>.</li>
<li>Drag and drop the new component on to the <span class="packt_screen">MotionController_L</span> component. </li>
<li>Repeat <em>step 2</em> and <em>step 3</em> to create a second interaction component that's a child of the right motion controller. Name this one <kbd>InteractionComponent_R</kbd>.</li>
<li>Now we can tie our new interaction components to buttons on the controllers. This will give the player the power to finally interact with the world! Click on the <span class="packt_screen">Event Graph</span> tab. In an empty section of the graph, right-click and search for the <span class="packt_screen">MotionController (L)</span> <span class="packt_screen">Trigger</span> event. Repeat the process to create a node for the <span><span class="packt_screen">MotionController (R) Trigger</span> event:</span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/1dcf543a-67bd-4ed9-95ff-2fb87fcb877e.png" width="1931" height="1256"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Mapping actions to our motion controllers in the player pawn</div>
<ol start="6">
<li>For each of our button events, we need to create two references to our custom events that we created back in the interaction component blueprint. Start by grabbing a reference to the left interaction component from the <span class="packt_screen">My Blueprints</span> panel. Position it near the <span><span class="packt_screen">MotionController (L) Trigger</span> event. Drag a line off it and drop it. Use the search box to find our <span class="packt_screen">Activate Down</span> function. Connect it to the <span class="packt_screen">Pressed execute</span> output on the left trigger event. Next, drag a connection off the <span class="packt_screen">Instigator</span> input pin on the <span class="packt_screen">Activate Down</span> function and drop it to bring up the search menu. Search for a reference to the <kbd>Self</kbd> variable. In this case, the player is the instigator of the activation.</span></li>
<li><span>Repeat the process for the <span class="packt_screen">MotionController (R) Trigger</span> event by using a reference to the right interaction component.</span></li>
</ol>
<div class="packt_infobox">I chose to use the left and right triggers for interactions for a couple different reasons. First, it's a button that's natural for a first-time user to press to activate something or to make something happen. It's intuitive. Second, the button event exists with the Oculus Touch controllers and Vive motion controllers, so I wouldn't have to change anything to go between hardware. Later, we'll create a pickup interaction, and I will use the grip buttons for the same reasons.</div>
<p>In this first section of programming, we set up the hand static meshes and programmed the <kbd>ObjectInteractionInterface</kbd>, a collection of functions that can be utilized by the object we want the player to be able to interact with. This blueprint interface connects to our <span class="packt_screen">Interfaction Component</span>, a custom <span class="packt_screen">Scene Component</span> that has the ability to utilize a parabolic line trace function to find interactive objects. Finally, we mapped our <span class="packt_screen">Activate</span> functionality to buttons on the <span class="packt_screen">Motion Controller</span> as part of <span class="packt_screen">Player Pawn</span> blueprint. In the next section, we'll build on to this new functionality to create a teleport mechanic. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Building the teleportation</h1>
                </header>
            
            <article>
                
<p>Now that the code for line tracing and interaction has been implemented, we can turn our attention to the teleport system itself. The goal of using teleportation in <em>Server 17</em> is to give our player an intuitive method of moving around our environment. Though teleportation is often seen as immersion breaking, I feel that the cyberspace environment in our game supports the idea of the player character being able to teleport around the space. To get started, let's first think about the parts of a VR teleport system:</p>
<ul>
<li><strong>Visuals</strong>: Players need to be able to visualize where they'll be moving to when they click the button. This can be done by projecting a line or an arc to where they'll land (we've done this through the debug option on our line trace that we set earlier). We should also have a visual on the surface they'll land on, to further highlight their landing point. Lastly, we might think about a particle effect and/or a sound effect to help enhance the player experience.</li>
<li><strong>Teleport code</strong>: This would be the actual functionality that's built within the blueprint. The code will need to handle the displaying of the visual elements, as well as the teleport itself. It would also be nice to build in some kinds of controls for us as designers to restrict the player to certain areas so that they can't teleport outside the area we've built for them or see things they aren't supposed to.</li>
</ul>
<p>Contrary to how we would normally start building a feature such as this (functionality, then art), here we'll start with a bit of the visual components. In this case, we need some visuals to be able to turn on and off to make sure our code is working. Building this system will also be an excellent test of how our interface and line trace code is working. Let's start with a visual on the ground for teleporting:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/c95d7262-db3f-4cf4-bdf2-c8327bd1c4aa.png" width="1874" height="1090"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">TeleportViz viewport</div>
<p>We start by creating a new actor blueprint:</p>
<ol>
<li>Right-click in the <kbd>Server17\Blueprints</kbd> folder of the <span class="packt_screen">Content Browser</span> and select the <span class="packt_screen">Blueprint Class</span> option from the <span class="packt_screen">Create Basic Asset</span> section of the menu. Choose <span class="packt_screen">Actor</span> from the <span class="packt_screen">Pick Parent Class</span> menu and name this new blueprint <span class="packt_screen">TeleportViz</span>. Double-click the blueprint to open it.</li>
<li>In the <span class="packt_screen">Viewport</span> tab, head over to the <span class="packt_screen">Components</span> panel and click the <span class="packt_screen">Add Component</span> button. Choose <span class="packt_screen">Static Mesh</span> from the menu. This should create a new static mesh component that's a child of the <span class="packt_screen">Default Scene Root</span>.</li>
<li>Click on it and search for the <span class="packt_screen">Static Mesh</span> section of the <span class="packt_screen">Details</span> panel. There's an option called <span class="packt_screen">Static Mesh</span> where we can set the shape we want to use. Click the drop-down menu and search for <span class="packt_screen">SM_FatCylinder</span>, though you may use any shape you like. Name the piece <kbd>Visualizer</kbd>.</li>
</ol>
<ol start="4">
<li>The static mesh looks a bit plain. Let's spruce it up a bit with a custom <span class="packt_screen">Material</span> to make it glow a bit and stand out. This will also serve as a great test for a potential art style for the overall environment of the game. In the <span class="packt_screen">Content Browser</span>, navigate to the <kbd>Server17</kbd> folder, right-click in the <span class="packt_screen">Content Browser</span> window, and create a <span class="packt_screen">New Folder</span>. Name it <kbd>Materials</kbd>. Double-click the new folder and right-click in it to create a new <span class="packt_screen">Material</span>. Name this material <kbd>M_TeleportViz</kbd>. Double-click the new material to open it:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/5df6e4d1-f23b-404d-85c5-59ebf3fede5f.png" width="1940" height="1126"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">TeleportViz Material</div>
<ol start="5">
<li>When we open the material, we're greeted with one large <span class="packt_screen">Result Node</span> to get us started. Click on it, and let's tweak a few of the settings in the <span class="packt_screen">Details</span> panel. Find the option labeled <span class="packt_screen">Blend Mode</span>. We want our new material to feel high-tech, so let's change the mode to <span class="packt_screen">Translucent</span> to give it a little bit of that feel. Next, find the <span class="packt_screen">Shading Model</span>. Since we're going to give this element an emissive glow, let's change the model to <span class="packt_screen">Unlit</span>. Lastly, check the box to make the material <span class="packt_screen">Two Sided</span>.</li>
</ol>
<ol start="6">
<li>Now it's time to choose a color. Create a <span class="packt_screen">Constant 3 Vector</span> by grabbing it from the <span class="packt_screen">Palette</span> panel or holding the <em>3</em> key and clicking in the material blueprint. If you don't have the <span class="packt_screen">Palette</span> open and would like it to be, click on the window button at the top right of your screen and choose <span class="packt_screen">Palette</span> from the menu. Right-click on the new vector and select <span class="packt_screen">Convert to Parameter</span> at the top of the resulting menu. Name the parameter <span class="packt_screen">Color</span>. By making it a parameter, we're making it possible to use blueprints to change it if we needed to. This could be handy in the future.</li>
<li>Click on the <span class="packt_screen">Color</span> node and click on the block of color in the <span class="packt_screen">Details</span> panel to bring up the color picker. Choose any color you like and click the <span class="packt_screen">Ok</span> button. If you would like to use the light blue color I have, set your RGB values to <em>R=0.84</em>, <em>G=0.74</em>, and <em>B=1.0</em>. Make sure you <span class="packt_screen">Alpha</span> is set to <em>A=1.0</em>.</li>
<li><span>To give the material a bit of glow, let's create a <span class="packt_screen">Constant</span> value and multiply that by our <span class="packt_screen">Color</span>. Search for <span class="packt_screen">Constant</span> in the <span class="packt_screen">Palette</span> or right-click and use the search box. Right-click on the new node and select <span class="packt_screen">Convert to Parameter</span> as we did for <span class="packt_screen">Color</span> in <em>step 6</em>. Over in the <span class="packt_screen">Details</span> panel, name this value</span> <span class="packt_screen">Strength</span> <span>and set the default value to <kbd>10</kbd>. Finally, create a <span class="packt_screen">Multiply</span> node and connect the output of the <span class="packt_screen">Color</span> parameter as value</span> <kbd>A</kbd> <span>and the output of</span> <span class="packt_screen">Strength</span> <span>as value <kbd>B</kbd>. Finish by connecting the output of the multiply to the <span class="packt_screen">Emissive</span> slot on the <span class="packt_screen">Result</span> node.</span></li>
<li>To give our new <span class="packt_screen">Color</span> a bit of a gradient effect, we'll manipulate the texture coordinates a bit. Create a <span class="packt_screen">Texture Coordinate</span> node by either using the <span class="packt_screen">Palette</span> or holding the <em>U</em> key and clicking in the blueprint.</li>
<li>Next, we'll need a <span class="packt_screen">Component Mask</span>. Create a copy of the node using the <span class="packt_screen">Palette</span> or right-click in the blueprint and use the search box. In the <span class="packt_screen">Details</span> panel, turn off the option to use the <span class="packt_screen">R</span> channel. Connect the output from the <span class="packt_screen">Texture Coordinate</span> to the input on the <span class="packt_screen">Component Mask</span>.</li>
<li>Now create a <span class="packt_screen">Cosine</span> node. A <span class="packt_screen">Cosine</span> will ensure that the gradient starts from both ends of the material. This will connect to the output from the <span class="packt_screen">Component Mask</span>.</li>
<li><span class="packt_screen">Cosine</span> outputs a value between -1 and 1. We need the resulting value to be positive only, so we'll use a <span class="packt_screen">One Minus</span> node. This will give us values between 0 and 2. Create the <span class="packt_screen">One Minus</span><span> node and connect it to the output of the</span> <span class="packt_screen">Cosine</span> <span>node.</span></li>
<li>To bring the value back to between 0 and 1, we can divide the answer by 2. Using the <span class="packt_screen">Divide</span> node, connect the output of the <span class="packt_screen">One Minus</span> node as the <kbd>A</kbd> value. Click on the <span class="packt_screen">Divide</span> node and find the value for <kbd>B</kbd> in the <span class="packt_screen">Details</span> panel. Change this value to <kbd>2.0</kbd>.</li>
</ol>
<ol start="14">
<li>Now we're going to build in some control over the distance the gradient takes to go from opaque to clear. This is called <strong>Falloff</strong>. Create a new <span class="packt_screen">Power</span> node and connect the output of our <span class="packt_screen">Divide</span> node into the <span class="packt_screen">Base</span> input on the new node. Next, create a <span class="packt_screen">Constant</span>. This can be done using the <span class="packt_screen">Palette</span> or the search menu, or by holding the one key and clicking in the blueprint. Right-click on it and <span class="packt_screen">Convert to Parameter</span>. Name the parameter <kbd>GradientFalloff</kbd> and set the <span class="packt_screen">Default Value</span> to <kbd>3</kbd>. Plug the output of this parameter into the <span class="packt_screen">Exponent</span>, or <span class="packt_screen">Exp</span>, input on the <span class="packt_screen">Power</span> node.</li>
<li>To ensure the resulting value can never go above 1, we'll need to clamp the value. Create a new <span class="packt_screen">Clamp</span> node and bring in the output from the <span class="packt_screen">Power</span> node. Plug the output of the <span class="packt_screen">Clamp</span> node into the <span class="packt_screen">Opacity</span> slot on the result node.</li>
<li>Check that out! The result should be glowing and partially see-through. You can tweak the materials by adjusting the <span class="packt_screen">GradientFalloff</span>, <span class="packt_screen">Strength</span>, and <span class="packt_screen">Color</span> parameters until it feels right to you. To complete the visual, head back to our <span class="packt_screen">TeleportViz</span> class blueprint and click on the static mesh component. Using the <span class="packt_screen">Details</span> panel, apply our new material and bask in the high-tech glow.</li>
</ol>
<p>With the visual component sorted, we can now build the functionality. To meet our needs of a system that can control where a player can teleport, we're going to create a volume that only allows p<span>layers to teleport where we place it</span>. It'll display our visual elements when it detects a line trace and will contain our teleport code. Start by right clicking in the <span><kbd>Server17\Blueprints</kbd> folder of the <span class="packt_screen">Content Browser</span> and create a new</span> <span class="packt_screen">Blueprint Class</span><span>. Choose <span class="packt_screen">Actor</span> from the <span class="packt_screen">Pick Parent Class</span> menu and name it <kbd>TeleportVol</kbd>:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/125c1126-9f18-4e83-a2a5-a064e534b8d8.png" style="width:41.42em;height:20.08em;" width="1902" height="920"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The TeleportVol component</div>
<p>We'll start in the <span class="packt_screen">Viewport</span> tab:</p>
<ol>
<li><span class="packt_screen">TeleportVol</span> has two components that make it work. The first is a box volume to detect collisions and line traces. The second is the visual elements we created earlier that we can turn on and off. Start by heading to the <span class="packt_screen">Components</span> panel and creating a new <span class="packt_screen">Box Collision</span>. Name the new component <kbd>TeleportVol</kbd>.</li>
<li>Click on <span class="packt_screen">TeleportVol</span> in the <span class="packt_screen">Component</span> panel. We want the collision box to cover a fair amount of space, but it really doesn't have to be that tall. In the <span class="packt_screen">Details Panel</span>, find the <span class="packt_screen">Box Extents</span> entry and change the values to <em>X=200</em>, <em>Y=200</em>, and <em>Z=1.0</em>.</li>
<li>Now we need to customize the collision a bit. In the <span class="packt_screen">Collision</span> section of the <span class="packt_screen">Details</span> panel, find the <span class="packt_screen">Collision</span> section. Choose the <span class="packt_screen">Collision</span> <span class="packt_screen">Presets</span> drop-down menu and change it to <span class="packt_screen">Custom</span>. Under <span class="packt_screen">Trace Responses</span>, we want to set both options to <span class="packt_screen">Block</span>. In the <span class="packt_screen">Object Responses</span> section, change all of the options to <span class="packt_screen">Ignore</span>. This will make the volume available for line traces, but nothing else.</li>
<li>With the volume customized, we can move on to the second component. In the <span class="packt_screen">Components</span> panel, click the <span class="packt_screen">Add Component</span> button and select <span class="packt_screen">Child Actor</span> from the menu. This is a copy of a class blueprint that we can place inside this blueprint. We can essentially build a class blueprint out of class blueprints! Click the component and find the <span class="packt_screen">Child Actor</span> Class option in the <span class="packt_screen">Details</span> panel. Using the drop-down menu, set this option to <span class="packt_screen">TeleportViz</span>. We also don't want it to be visible unless it's being hit by a line trace, so turn off the <span class="packt_screen">Visible</span> option in the <span class="packt_screen">Rendering</span> section of the <span class="packt_screen">Details</span>.</li>
<li>Now we will move on to the code! We need this object to be able to react to line traces, right? Well, we wrote a whole interface for exactly that. This will be the first application of our Object Interaction Interface. To add the functions from the interface to this object, click on the <span class="packt_screen">Class Defaults</span> that's just above the area where the <span class="packt_screen">Event Graph</span> and <span class="packt_screen">Viewport</span> tabs are located. This will open the default options for this class over in the <span class="packt_screen">Details</span> panel. Find the <span class="packt_screen">Interfaces</span> section and click the <span class="packt_screen">Add</span> button. Search for the <span class="packt_screen">Object Interaction Interface</span> in the menu and select it to add its functions to our teleport volume.</li>
<li>We now have access to every function we wrote in the interface. These can be found in the <span class="packt_screen">Interfaces</span> section of the <span class="packt_screen">My Blueprint</span> panel. Simply click the <span class="packt_screen">Arrow</span> next to the word <span class="packt_screen">Interfaces</span> to see them. We can even double-click on their names to open them. Open the following functions: <kbd>TraceMove</kbd>, <kbd>TraceHit</kbd>, <kbd>TraceLeaveObject</kbd>, and <kbd>TraceActivateUp</kbd>:</li>
</ol>
<p class="mce-root"/>
<p class="CDPAlignCenter CDPAlign"><img src="Images/309921df-2090-4589-abc5-a451b0967525.png" width="1931" height="1255"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The Trace Move function</div>
<ol start="7">
<li>For <span class="packt_screen">Trace Move</span>, we need to program what happens as a line trace moves across our object. For the teleport volume, we want the visual element we created earlier (the glowing ring, <span class="packt_screen">TeleportViz</span>) to move to wherever our line trace is hitting. To do this, we'll use a <span class="packt_screen">Set</span><span class="packt_screen">WorldLocation</span> node. Right-click in the blueprint and search for <span class="packt_screen">Set World location</span>. Choose <span class="packt_screen">Set</span><span class="packt_screen">WorldLocation</span> (<span class="packt_screen">TeleportViz</span>) from the list. Connect the execute output of the function node to its input and the execute output to the <span class="packt_screen">Return</span> node.</li>
<li><span class="packt_screen">SetWorldLocation</span> needs a <span class="packt_screen">New Location</span> input to know where to move <span class="packt_screen">TeleportViz</span> to, and we can find that by breaking down the <span class="packt_screen">Hit</span> result that comes as an input into the function. Create a <span class="packt_screen">Break Hit Result</span> node and bring in the <span class="packt_screen">Hit</span> from the function node as the input. We can take the <span class="packt_screen">Location</span> output from the break and use that as the <span class="packt_screen">New Location</span> input on the <span class="packt_screen">Set World Location</span>.</li>
</ol>
<ol start="9">
<li>Next, choose the <span class="packt_screen">TraceHit</span> function. In this function, we want to turn on the visibility of our <span class="packt_screen">TeleportViz</span> mesh so that our player can see where they'll appear. Right-click in the blueprint and create a <span class="packt_screen">Set Visibility</span> (<span class="packt_screen">TeleportViz</span>) node. Connect it to the function node and to the <span class="packt_screen">Return</span> node. On the node, turn on the <span class="packt_screen">New Visibility</span> checkbox and the <span class="packt_screen">propagate to children</span> checkbox.</li>
<li>Now, let's move on to the <span class="packt_screen">TraceLeaveObject</span> function. This function will do something very similar to the <span class="packt_screen">TraceHit</span> function, except we'll be turning the visibility back to off. Similar to the preceding, create a <span><span class="packt_screen">Set Visibility</span> (<span class="packt_screen">TeleportViz</span>) node and connect it to both the function node and the <span class="packt_screen">Return</span> node. On the node itself, leave the box next to <span class="packt_screen">New Visibility</span> unchecked, but do click the checkbox next to <span class="packt_screen">Propagate</span> to <span class="packt_screen">Children</span>:</span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/e6c7b19f-a084-49ef-afdc-24edcebd4f6b.png" width="1950" height="968"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The Teleport function</div>
<ol start="11">
<li>Before we move on to the <kbd>TraceActivateUp</kbd>, we need to create a function that can handle the mechanics of the teleport. Over in the <span class="packt_screen">Functions</span> section of the <span class="packt_screen">My Blueprint</span> panel, click the <span class="packt_screen">+</span> button and name the new function <span class="packt_screen">Teleport Player</span>. <span class="packt_screen">Teleport Player</span> needs to have a couple of input values to work. The first is named <kbd>Player</kbd> and will be of the type <span class="packt_screen">Actor</span>. The second will be named <kbd>Loc</kbd> and this will be of the type <span class="packt_screen">Vector</span>.</li>
</ol>
<ol start="12">
<li>The teleport itself will require a little bit of math and will need a bit of info from our <span class="packt_screen">Player Controller</span>. Let's start the sequence by dragging an execute line from the function node and dropping it to open the search menu. Search for the <span class="packt_screen">Cast to PlayerController</span> node and create it. Casting allows us to pretend to be another blueprint and is just one of many ways that allow us to communicate data between blueprints.</li>
<li>Casting requires an <span class="packt_screen">Object</span> input, a reference to the specific object we're pretending to be to access its data. To get the exact <span class="packt_screen">PlayerController</span> we need, click and drag a line off the <span class="packt_screen">Player</span> input on the function node and drop it. Search for the <span class="packt_screen">Get Controller</span> node and connect its output to the input on the <span class="packt_screen">Cast</span> to <span class="packt_screen">PlayerController</span> node.</li>
<li>Next, create a <span class="packt_screen">SetActorLocation</span> node. This will do the actual teleporting by moving the player to the designated vector coordinates. Connect the execution output from the cast into the execution input on <span class="packt_screen">SetActorLocation</span><span>. The target input should be set to the <span class="packt_screen">Player</span> by dragging a connection from the <span class="packt_screen">Player</span> input on the function node to the <span class="packt_screen">Target</span> input on </span><span class="packt_screen">SetActorLocation</span><span>.</span></li>
<li>It's now time to calculate the new location! To start, we'll need to get the location of two things: the player and the player camera. To get the player's location, drag a line off the <span class="packt_screen">Player</span> input on the function node and drop it to open the search box. Search for the <span class="packt_screen">GetActorLocation</span> node and create one. We'll need this data in a moment.</li>
<li>Drag a line off the as <span class="packt_screen">Player Controller</span> output from our <span class="packt_screen">Cast</span> to <span class="packt_screen">PlayerController</span> node and use it to search for the <span class="packt_screen">Get Player Camera Manager</span> node. Drag off the output of that and search for the <span class="packt_screen">Get Camera Location</span> node.</li>
<li>Here is the math part: We need to subtract the location of the player's camera from the location of the player itself to find the true location of the HMD for our teleport. For that, we'll need a <span class="packt_screen">Vector - Vector</span> node. The top input will be the vector output from our <span class="packt_screen">GetActorLocation</span> node. The bottom input will be the vector from the <span class="packt_screen">GetCameraLocation</span> node.</li>
<li>We're almost there! Right-click on the output pin of our <kbd>Vector - Vector</kbd> node and split the struct pin. We only need the <span class="packt_screen">X</span> and <span class="packt_screen">Y</span> value for the next part of the calculation. Create a new <kbd>Vector + Vector</kbd> node and split the struct pin on the top input. Connect the <span class="packt_screen">X</span> and <span class="packt_screen">Y</span> <span>output </span>values from <kbd>Vector - Vector</kbd> into the <em>X</em> and <em>Y</em> input values on the <kbd>Vector + Vector</kbd> node. The bottom vector input comes from the <span class="packt_screen">Loc</span> input from the function node. Drag a connection from the <span class="packt_screen">Loc</span> input on the function node and connect it to the bottom vector input on the <kbd>Vector + Vector</kbd>. </li>
</ol>
<div class="packt_tip">Don't forget that you can use reroute nodes to clean up your code to make it organized and readable. Reroute nodes can be found in the search menu if you drag off a connection and drop it. They can also be created by double-clicking on the connection where you would like to create one.</div>
<ol start="19">
<li>With that, the calculation is complete! Plug the output from the <kbd>Vector + Vector</kbd> node into the <span class="packt_screen">New Location</span> input on <span class="packt_screen">SetActorLocation</span> to complete the sequence:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/30b5f54e-1ce3-42e8-8e02-6c0fdfae4215.png" width="1931" height="1101"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Trace Activate Up</div>
<ol start="20">
<li>The last function to program is <span class="packt_screen">Trace Activate Up</span>, or what happens when a player releases the button of their motion controller. Click the tab we opened earlier or double-click the function name in the <span class="packt_screen">Functions</span> section of the <span class="packt_screen">My Blueprint</span> panel. Using our new <span class="packt_screen">Teleport Player</span> function, we're going to move the player to the new location. Grab a copy of our <span class="packt_screen">Teleport Player</span> function and drag it into the blueprint. Connect the <span class="packt_screen">Instigator</span> input from the function node to the <span class="packt_screen">Player</span> input on <span class="packt_screen">Teleport Player</span>.</li>
<li>Calculating the exact location to teleport to just a bit more math. Drag a line off the <span class="packt_screen">Hit</span> input on the function node and drop it to open the search menu. Create a <span class="packt_screen">Break Hit Result</span> node and right-click on the <span class="packt_screen">Location</span> output to split the struct.</li>
</ol>
<ol start="22">
<li>Create a <span class="packt_screen">Get</span> <span class="packt_screen">Actor Location</span> node and position it near the <span class="packt_screen">Break Hit</span> node. Right-click on the vector output and split that struct pin as well.</li>
<li>Next, right-click on the <span class="packt_screen">Loc</span> input on the <span class="packt_screen">Teleport Player</span> node and (you guessed it!) split the struct pin.</li>
<li>It's time to pass in the <em>XYZ</em> values! Connect the <span class="packt_screen">Location X</span> and <span class="packt_screen">Location Y</span> outputs from <span class="packt_screen">Break Hit</span> to the <span class="packt_screen">Loc X</span> and <span class="packt_screen">Loc Y</span> inputs on <span class="packt_screen">Teleport Player</span>. Also, connect the <span class="packt_screen">Z</span> output from the <span class="packt_screen">Get Actor Location</span> node to the <span class="packt_screen">Loc Z</span> input on <span><span class="packt_screen">Teleport Player</span>. </span></li>
<li>Finish the sequence by connecting the execute output from <span><span class="packt_screen">Teleport Player</span> to the <span class="packt_screen">Function Return</span> node.</span></li>
</ol>
<p>With the teleport volume complete, we can now test our ability to teleport, as well as all of the systems that support it (parabolic line tracing and the Object Interaction Interface). Throw a few of the <span class="packt_screen">TeleportVol</span> blueprints down in your test level and go nuts trying it out! If everything works, we can move on to building a prototype puzzle box.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The server – Building the puzzle box</h1>
                </header>
            
            <article>
                
<p>With the player now having the ability to touch things and teleport around our test level, it's now time tackle the puzzle box. In <em>Server 17</em>, the puzzle box is a graphical representation of the player hacking into a remote server and stealing data. The final version may contain several puzzles to solve and dozens of steps to complete. However, for this first prototype version, we're going to design and build a simple three-step box as shown as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/22b17ba4-639d-4bce-bb60-576804297a58.png" style="width:21.67em;height:17.67em;" width="1410" height="1150"/></p>
<div class="mce-root packt_figref CDPAlignCenter CDPAlign">This design requires the player to find and remove a panel on the box to reveal a button that unlocks the front of the box. This panel can then be removed by grabbing it and moving it to the side revealing another switch. The final step is to then press the switch and find the removable panel to steal the data.</div>
<p>Building this in Unreal Engine 4 will have us creating a few things:</p>
<ol>
<li>We'll need to create additional functionality for the hands that our interface currently doesn't cover, such as grabbing, dragging, and pressing.</li>
<li><span>We'll need an object that responds to the player's touch and can be grabbed, moved, and thrown.</span></li>
<li>We'll need interactive buttons that can trigger events.</li>
<li>We'll need to build the box itself using child actors and code to turn the interactive elements on and off.</li>
</ol>
<p>When complete, we'll have an amazing test platform that can be used to prove that <em>Server 17</em> is fun and that can be tested by our target demographic. The first step in moving forward is to build a second interface to hold our button interactions:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/a7325795-74eb-4ff8-973e-92780b0956bd.png" style="width:13.42em;height:16.42em;" width="692" height="844"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Button Interaction Interface</div>
<p>It's time to create the Button Interaction Interface:</p>
<ol>
<li>Head to the <span class="packt_screen">Content</span> <span class="packt_screen">Browser</span> and navigate to our <kbd>Server17\Blueprints</kbd> folder. Right-click in the browser and navigate to the <span class="packt_screen">Create Advanced Asset</span> section of the menu. Highlight the <span class="packt_screen">Blueprint Entry</span> and choose the <span class="packt_screen">Blueprint Interface</span> option. Name the new interface <kbd>ButtonInteractionInterface</kbd>. Double-click the new interface to open it.</li>
</ol>
<ol start="2">
<li>In this interface, we'll create nine different functions that represent the different states of the actions we're creating. The first is a function to determine what to do when we're hovering our hand over something. Find the <span class="packt_screen">Functions</span> section of the <span class="packt_screen">My Blueprint</span> panel and click the + button. Name the new function <kbd>OnHover</kbd>. <kbd>OnHover</kbd> will need one input named <kbd>Interactor</kbd> of the type <span class="packt_screen">Interaction Component</span>. It'll also need an output named <span class="packt_screen">Return</span> of the Boolean <span>type </span>to make it function properly.</li>
<li>The next function will be named <kbd>EndHover</kbd> and controls what happens when the player's hand leaves an object. It has the same input and output as the previous function.</li>
<li>Now we'll create the <kbd>OnPickup</kbd> <span>function </span>to cover what happens when we want to pick up an object, which is a very common interaction in VR. It has the same input and output as the last two functions.</li>
<li>Next is the  <kbd>OnDrop</kbd> <span>function;</span> this will give us the opportunity to create additional functions when the player drops an object. It also has the same input and output as the last few functions.</li>
<li>The next three functions control the dragging of objects and allow us the opportunity to create even more gameplay with these actions. Create functions named <kbd>OnDrag</kbd>, <kbd>OnDragStart</kbd>, and <kbd>OnDragEnd</kbd>. They have the same input and output as all of the other functions that we've created here so far.</li>
<li>Finally, here's one that's different! Create a new function and name it <kbd>CanPickUp</kbd>. This function controls a Boolean that determines whether something is allowed to be picked up. It only has one output: a Boolean with the name <kbd>PickUp</kbd>.</li>
<li>This is the last one. Create one more function. This one is named <kbd>OnUse</kbd> and allows us to create objects that can be used as power ups. <kbd>OnUse</kbd> has input and output identical to <kbd>OnHover</kbd>.</li>
</ol>
<p>We now <span>have </span>a second interface that allows us as designers as much freedom to create interactions as we have imagination. To test out our new player abilities, let's build a basic cube that can be interacted with in several different ways:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/2d15ebff-52b5-4770-b564-b8a5776b9cfd.png" width="1901" height="1269"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">InteractCube with interface</div>
<p>To test our systems (and have a little fun), we're going to create a cube that utilizes many of the new functions that we've created in this chapter:</p>
<ol>
<li>Make sure you're in the <kbd>Server17\Blueprints</kbd> folder and right-click in the <span><span class="packt_screen">Content</span> <span class="packt_screen">Browser</span> to create a new <span class="packt_screen">Blueprint Class</span>. Choose <span class="packt_screen">Actor</span> in the <span class="packt_screen">Pick Parent Class</span> menu and name our new blueprint <kbd>InteractCube</kbd>.</span></li>
<li>Click the <span class="packt_screen">Add Component</span> button in the <span class="packt_screen">Components</span> panel and choose the <span class="packt_screen">Cube</span> option from the <span class="packt_screen">Common</span> section of the menu. In the <span class="packt_screen">Details</span> panel, find the <span class="packt_screen">Scale</span> values near the top and set the values so that <span class="packt_screen">X=0.3, Y=0.3, and Z=0.3</span>.</li>
</ol>
<ol start="3">
<li>It's time to add the interfaces. Click the <span class="packt_screen">Class Defaults</span> button at the top of the screen. In the <span class="packt_screen">Details</span> panel, click the <span class="packt_screen">Add</span> button in the <span class="packt_screen">Interfaces</span> section. Search for and add both the <span class="packt_screen">Object Interaction Interface</span> and the <span class="packt_screen">Button Interaction Interface</span>.</li>
<li>Now we have a load of functions to play with! Let's start with a way to tell when the cube is being hit by a line trace. Open the <span class="packt_screen">Interfaces</span> section of the <span class="packt_screen">My Blueprints</span> panel and open the <kbd>TraceHitObject</kbd> function. Right-click in the blueprint and search for the set <span class="packt_screen">Vector Parameter Value</span> <span class="packt_screen">(Cube)</span> on the <span class="packt_screen">Materials</span> node. This node allows us to access the <span class="packt_screen">Color</span> parameter on the cube's default material. Connect it to the function node and the <span class="packt_screen">Return</span> node. Next, set the value of <span class="packt_screen">Parameter Name</span> to <span class="packt_screen">Color</span>. Finally, let's turn the cube red by changing the <span class="packt_screen">Parameter Value X</span> value to 1.0. Now the cube will turn red when hit by a line trace!</li>
<li>Let's set the color back to white when the line trace leaves the cube. Double-click the <kbd>TraceLeaveObject</kbd> function in the <span class="packt_screen">Interfaces</span> menu. Grab the same <span>set <span class="packt_screen">Vector Parameter Value</span> <span class="packt_screen">(Cube)</span> node we used before, only, this time, set the values of <span class="packt_screen">Parameter Value</span> to</span> <span class="packt_screen">X=1.0</span>, <span class="packt_screen">Y=1.0</span>, and <span class="packt_screen">Z=1.0</span>.</li>
<li>Having fun yet? Let's open the <kbd>TraceActivateDown</kbd> function from the <span class="packt_screen">Interfaces</span> menu. Using the same preceding technique, create the <span><span class="packt_screen">Set Vector Parameter Value (Cube)</span> node, type in the <span class="packt_screen">Color</span> for the <span class="packt_screen">Parameter Name</span>, and set the values of <span class="packt_screen">Parameter Value</span> to <span class="packt_screen">X</span></span>=<span><span class="packt_screen">0</span>, <span class="packt_screen">Y</span></span>=<span><span class="packt_screen">1.0</span>, and <span class="packt_screen">Z</span></span>=<span><span class="packt_screen">0</span>. Our cube now turns green when we click the button to interact with it!</span></li>
<li>If we use <kbd>TraceActivateDown</kbd>, we should probably use <kbd>TraceActivateUp</kbd>. <span>Let's set it up to change the color back to red when we release the button. Open the function and create another set <span class="packt_screen">Vector Parameter Value</span> <span class="packt_screen">(Cube)</span> node. Wire it into the function, set the value of <span class="packt_screen">Parameter Name</span> to <span class="packt_screen">Color</span>, and change the values of <span class="packt_screen">Parameter Value</span> to <span class="packt_screen">X</span></span>=<span><span class="packt_screen">1.0</span>,</span> <span class="packt_screen">Y=0</span><span>, and <span class="packt_screen">Z</span></span>=<span><span class="packt_screen">0</span>.</span></li>
</ol>
<div class="packt_tip">Want to have a little more fun with our functions? Use the <span class="packt_screen">Add Impulse</span> <span>node </span>where the target of the node is a <span class="packt_screen">Scene Component</span> to create a sudden upward acceleration. Replace one of the s<span>et <span class="packt_screen">Vector Parameter Value</span> nodes with <span class="packt_screen">Add Impulse</span> and change the <span class="packt_screen">Z</span> value of the <span class="packt_screen">Impulse parameter</span> to <span class="packt_screen">5000</span>. Make sure to turn on the checkbox for <span class="packt_screen">Velocity Change</span>. This will shoot the cube skyward when the button is pressed or released!</span></div>
<ol start="8">
<li>How about we try the cube able to be picked up and thrown? To create this mechanism, we'll have Unreal simulate physics on our cube and then toggle this feature off and on when we pick up and drop the cube. <span>Open the <kbd>OnPickup</kbd> and <kbd>OnDrop</kbd></span> functions.<span> In <kbd>OnPickup</kbd>, right-click in the blueprint and search for the node set <span class="packt_screen">Simulate Physics</span> <span class="packt_screen">(Cube)</span>. Wire the execution input and output the the function node and the <span class="packt_screen">Return</span> node, as it'll be the only node we use in this function. This will disable the physics when the cube is picked up so it won't fall out of the player's hands or exhibit other strange behavior. Now open <kbd>OnDrop</kbd> and create another copy of set <span class="packt_screen">Simulate Physics</span> <span class="packt_screen">(Cube)</span>. This time, turn on the checkbox next to the option to <span class="packt_screen">Simulate Physics</span> on the node. This will enable the physics when the cube is dropped so it behaves the way we intend. Finally, head back to the <span class="packt_screen">Viewport</span> tab and click on the cube. Check the <span class="packt_screen">Details</span> panel to make sure the <span class="packt_screen">Simulate Physics</span> option is turned on. If it's not, enable it.</span></li>
<li>There's one more function to set up. Go back to the <span class="packt_screen">Interfaces</span> section of the <span class="packt_screen">My Blueprints</span> panel and open the <kbd>CanPickUp</kbd> function. To make it so we can toggle this feature on and off, we're going to need a Boolean that we can toggle. In the <span class="packt_screen">Variables</span> section, click the <span class="packt_screen">+</span> button and create a new Boolean variable named <kbd>PickUpActive</kbd>. Back in the <kbd>CanPickUp</kbd> function, drag in a copy of our new variable and choose get from the menu. Plug the output of <span><kbd>PickUpActive</kbd> into the <kbd>PickUp</kbd> input on the <span class="packt_screen">Return</span> node.</span></li>
</ol>
<p>To make use of these new functions, we'll need to set up a way to call them in the <span class="packt_screen">Interaction Component</span>, as well as map them to buttons in <span><kbd>Server17PlayerPawn</kbd>. This is exactly like what we did when we created the Object Interaction Interface earlier in this chapter. Head back to the <span class="packt_screen">Content</span> <span class="packt_screen">Browser</span> and open the <span class="packt_screen">Interaction Component</span>:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/3aff3444-e764-42b6-bb2e-d0e8560ed210.png" width="1855" height="1086"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The Hover interaction component code</div>
<ol start="1">
<li>Inside the <span class="packt_screen">Interaction Component</span>, we need to add some of the new player functionality, but the current code doesn't allow for that kind of expansion. To change that, we're going to use a <span class="packt_screen">Sequence</span> node. The <span class="packt_screen">Sequence</span> node is a flow-control node that implements the code connected to each of its output pins in order. To implement our new functions, we'll want to add the <span class="packt_screen">Sequence</span> node after the <span class="packt_screen">Gate</span>. Right-click in the blueprint and search for the <span class="packt_screen">Sequence</span> node. Once created, click the <span class="packt_screen">Add Pin</span> button in the bottom-left portion of the node. This will add an additional execution output. Connect the <span class="packt_screen">Sequence</span> right after the <span class="packt_screen">Gate</span> and connect the <span class="packt_screen">Parabolic Line Trace</span> node to the execution output labeled <span class="packt_screen">Then 0</span>.</li>
</ol>
<ol start="2">
<li>Before we begin implementing the <span class="packt_screen">Hover</span>, <span class="packt_screen">Drag</span>, and <span class="packt_screen">Pickup</span> features, we'll need a few more variables. <span>Click the <span class="packt_screen">+</span> button in <span class="packt_screen">Variables</span> section of the <span class="packt_screen">My Blueprint</span> panel and create a new <span class="packt_screen">Float</span> variable named</span> <kbd>InteractRadius</kbd><span>. Compile the blueprint and give it a default value of <span class="packt_screen">10</span>. Next, create two variables of the type <span class="packt_screen">Actor</span>, one named</span> <kbd>HoverObject</kbd> <span>and the other named</span> <kbd>HeldObject</kbd><span>. Finally, create one more Boolean variable and name it <kbd>Dragging</kbd>.</span></li>
</ol>
<ol start="3">
<li>Let's start by implementing the <span class="packt_screen">Hovering</span> and <span class="packt_screen">Dragging</span> behavior. Drag an execute line from the <span class="packt_screen">Then 1</span> output on our new <span class="packt_screen">Sequence</span> node and drop it in a clear area of the blueprint. The node we're looking for is called <span class="packt_screen">SphereOverlapActors</span> and is designed to return the objects that it detects within a specific radius. </li>
<li><span><span class="packt_screen">SphereOverlapActors</span> needs four different input values. The first is <span class="packt_screen">Sphere Position</span> (or <span class="packt_screen">Pos</span>). We want the sphere to detect from wherever the interaction component is located. Drag a line from the <span class="packt_screen">Sphere Pos</span> input and drop it. Search for the <span class="packt_screen">GetWordlocation </span></span>node<span>. This will give us an input of where the interaction components are in world space.</span></li>
<li>For the next input, grab a copy of our <span class="packt_screen">InteractRadius</span> variable and choose <span class="packt_screen">Get</span> from the menu. This will give a 10 cm detection radius for our interactions and make that radius easily adjustable through the variable.</li>
<li>Now we want to filter what the player can interact with. Drag a line off the <span class="packt_screen">Object Types</span> input and search for the <span class="packt_screen">Make Array</span> node. Click the <span class="packt_screen">Add Pin</span> button on the node and use the two drop-down menus to choose the <span class="packt_screen">WorldDynamic</span> and <span class="packt_screen">PhysicsBody</span> options.</li>
<li>Finally, we want the player to ignore anything classified as itself so one motion controller can't interact with the other motion controller, for example. Right-click in the blueprint and use the search box to find the <span class="packt_screen">Get Owner</span> node. This will return a reference to the player as an <span class="packt_screen">Actor</span>. Since <span><span class="packt_screen">SphereOverlapActors</span> only accepts an array as an input for <span class="packt_screen">Actors To Ignore</span>, we'll need to insert the output from <span class="packt_screen">Get Owner</span> into an array. Drag off from the <span class="packt_screen">Return</span> value on <span class="packt_screen">Get Owner</span> and drop it. Find the <span class="packt_screen">Make Array</span> node and plug the resulting array into the final input on <span class="packt_screen">SphereOverlapActors</span>.</span></li>
</ol>
<ol start="8">
<li><span class="packt_screen"><span>SphereOverlapActors</span><span> </span></span><span>will now return an array of objects that match our criteria. With the output, we need to do a quick check to see whether the <span class="packt_screen">HoverObject</span> we've stored in the variable is the same as the one we just took in. If they're the same, there's no reason to proceed; this will save us a bit of performance. Drag off the <span class="packt_screen">Out Actors</span> output and search for the <span class="packt_screen">Get</span> node. This will retrieve the item from the area at index 0 (the array should only contain one object). Next, get a reference to our <span class="packt_screen">HoverObject</span> variable. Finally, to compare them, drag off the <span class="packt_screen">HoverObject</span> variable and search for the <span class="packt_screen">NotEqual</span> node. One input should be our <span class="packt_screen">HoverObject</span> and the other should be the output of our <span class="packt_screen">Get</span> node:</span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/f2bf60cc-79da-45c4-b2df-6ac9f309ee46.png" width="1932" height="1052"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The second part of the Hover code</div>
<ol start="9">
<li><span class="packt_screen">NotEqual</span> will return a Boolean, so we'll need a <span class="packt_screen">Branch</span> to continue. Connect the <span class="packt_screen">Branch</span> to the execution output from the <span><span class="packt_screen">SphereOverlapActors</span> node. The condition will be the result of the <span class="packt_screen">NotEqual</span> node and we'll move forward only if it's <kbd><span class="packt_screen">True</span></kbd>.</span></li>
<li>If our comparison is <span class="packt_screen">True</span> and the two objects aren't the same, we're going to need to end the hovering behavior on the current object and set up the hovering or dragging behavior to work with the new object. Drag off from the <span class="packt_screen">True</span> output on the <span class="packt_screen">Branch</span> and search for our <span class="packt_screen">EndHover</span> function from our Button Interaction Interface. Get a copy of our <span class="packt_screen">HoverObject</span> variable and plug that into the <span class="packt_screen">Target</span> input and use a <span class="packt_screen">Reference to Self</span> as the <span class="packt_screen">Interactor</span> input.</li>
</ol>
<ol start="11">
<li>Next, create a copy of our <span class="packt_screen">EndDrag</span> function and connect it to the execution output from our <span class="packt_screen">EndHover</span> node.</li>
<li>Now we need to update the <span class="packt_screen">HoverObject</span> variable with the new object we're hovering over. Drag in a copy of <span><span class="packt_screen">HoverObject</span>  and choose <span class="packt_screen">Set</span> from the menu. The input will be the output from our <span class="packt_screen">Get</span> node from earlier.</span></li>
<li>Lastly, we'll call the <kbd>OnHover</kbd> function to complete the sequence. Create a copy of our <kbd>OnHover</kbd> function and connect that to the execute output from the set <span><span class="packt_screen">HoverObject</span>. The variable output from set the <span class="packt_screen">HoverObject</span> can be used as the Target. Use a <span class="packt_screen">Reference</span> to <span class="packt_screen">Self</span> as as the <span class="packt_screen">Interactor</span> input.</span></li>
</ol>
<p>Our hovering code allows us to detect what the player might be reaching out for or holding their hand over, such as a button or an other component. Next, we'll tackle <span class="packt_screen">Dragging</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/09a90731-f6c6-4f8d-b1c6-f9a9eab29e41.png" width="1907" height="656"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Dragging code</div>
<p>For <span class="packt_screen">Dragging</span>, we'll need to create two <span class="packt_screen">Custom Events</span> that can be called from outside the blueprint. This is exactly the same technique we used to implement our <span class="packt_screen">ActivateUp</span> and <span class="packt_screen">ActivateDown</span> behavior earlier:</p>
<ol>
<li>To start, we'll create two <span class="packt_screen">Custom Events</span>. Right-click in the blueprint and choose the <span class="packt_screen">Add Custom Event</span> option. Name the first one <kbd>StartDrag</kbd> and the second one <kbd>EndDrag</kbd>.</li>
<li>For both of our new events, we basically want to turn our <span class="packt_screen">Dragging</span> Boolean on and off while calling our <span class="packt_screen">OnDragStart</span> and <span class="packt_screen">OnDragEnd</span> functions. Let's start with <span class="packt_screen">StartDrag</span>. Grab a copy of our <span class="packt_screen">Dragging</span> variable and choose <span class="packt_screen">Set</span> from the menu. Connect the execution output from our event to set <span class="packt_screen">Dragging</span> and click the checkbox on the node to set it to <span class="packt_screen">True</span>.</li>
</ol>
<p class="mce-root"/>
<ol start="3">
<li>Now we'll call our <span class="packt_screen">OnDragStar</span>t function. Drag a copy of <span class="packt_screen">OnDragStart</span> into the blueprint from the <span class="packt_screen">Interfaces</span> section of <span class="packt_screen">My Blueprint</span> and connect an execution line from s<span>et <span class="packt_screen">Dragging</span>. Plug in a copy of our <span class="packt_screen">HoverObject</span> variable as the <span class="packt_screen">Target</span> and use a <span class="packt_screen">Reference</span> to <span class="packt_screen">Self</span> as the <span class="packt_screen">Interactor</span>.</span></li>
<li>Next, we can work with our <span class="packt_screen">EndDrag</span> custom event. The first step is to check to see whether our <span class="packt_screen">Dragging</span> Boolean is <span class="packt_screen">True</span>; if it is, then we can end the current drag. Create a new <span class="packt_screen">Branch</span> node and connect the execute output from our event to it. Get a copy of <span class="packt_screen">Dragging</span> and connect this to the <span class="packt_screen">Condition</span> input on the <span class="packt_screen">Branch</span>.</li>
</ol>
<ol start="5">
<li>If <span class="packt_screen">Dragging</span> is <span class="packt_screen">True</span>, we need to update the variable and end the drag. Create another copy of <span class="packt_screen">Dragging</span>, only this time choose <span class="packt_screen">Set</span> from the menu and connect the <span class="packt_screen">True</span> output from the <span class="packt_screen">Branch</span> to it. Make sure the checkbox on <span class="packt_screen">Dragging</span> is clear.</li>
<li>It's time to create a copy of our <span class="packt_screen">OnDragEnd</span> function. Connect the execute output from set <span class="packt_screen">Dragging</span> to the execute input on our new node. Just as we did for <span><span class="packt_screen">OnDragStart</span> earlier, connect <span class="packt_screen">HoverObject</span> as our <span class="packt_screen">Target</span> and use a <span class="packt_screen">Reference</span> to <span class="packt_screen">Self</span> as the <span class="packt_screen">Interactor</span>.</span></li>
<li>It's time to bring these two sequences together. We'll use a <span class="packt_screen">Gate</span> to control whether or not something can be dragged with our custom events controlling whether the <span class="packt_screen">Gate</span> is open or closed. Create a new <span class="packt_screen">Gate</span> node and connect the output from <span><span class="packt_screen">OnDragStart</span></span><span> to the <span class="packt_screen">Open</span> input and bring in the output from <span class="packt_screen">OnDragEnd</span> into the <span class="packt_screen">Close</span> input. We'll connect the <span class="packt_screen">Enter</span> input to the <span class="packt_screen">Then 2</span> input on our <span class="packt_screen">Sequence</span> node from earlier.</span></li>
<li>The final step to completing the drag is calling the <span class="packt_screen">OnDrag</span> function. Create a copy and connect it to the <span class="packt_screen">Exit</span> output from our <span class="packt_screen">Gate</span> node we created in the last step. Just as we did for our previous drag functions, we'll connect a copy of our <span class="packt_screen">HoverObject</span> variable to the <span class="packt_screen">Target</span> input and plug in <span>a <span class="packt_screen">Reference</span> to <span class="packt_screen">Self</span> as the <span class="packt_screen">Interactor</span>.</span></li>
</ol>
<p>We can now drag objects! Such a behavior might be useful in programming levers and other similar pieces that can be moved but not necessarily picked up. Speaking of picking up, the next feature we'll tackle is the ability to pick things up and throw them. Much like hovering or dragging, there's a similar trick to the pick-up-and drop behavior that happens behind the scenes. Most of the objects, but not all, will start with their <span class="packt_screen">Simulate Physics</span> option enabled. The trick is this: when the object is picked up in VR, we'll attach the object to the player's hand so it can't get away from them. We will also disable the physics on the object (we set this up earlier in the <span class="packt_screen">OnPickup</span> function of our <span class="packt_screen">InteractCube</span>). When we put down the object, we detach it from the player and re-enable the physics. Since the player never sees any of the changes, it looks to them as if they just picked up the object and then put it down. Cool, huh?</p>
<p>Let's build it:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/c209bda3-9713-4d48-9023-2d7cd141b16f.png" width="1938" height="772"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Pickup code</div>
<p>Just as we did for the dragging behavior, we'll start by creating two custom events: one for <span class="packt_screen">Pickup</span> and one for <span class="packt_screen">Drop</span>:</p>
<ol>
<li>Right-click in our blueprint and create two new custom events with the <span class="packt_screen">Add Custom Event</span> option. Name the first <kbd>Pickup</kbd> and the second <kbd>Drop</kbd>.</li>
<li>We'll start by building the pickup behavior. We need to start by checking whether the object the player is hovering over is a valid object. Right-click in the blueprint and search for the <span class="packt_screen">IsValid</span> node. The version we need is marked with a question mark as its icon. Connect it to our <span class="packt_screen">Pickup</span> event and create a copy of our <span class="packt_screen">HoverObject</span> variable, which will serve as the input for the <span class="packt_screen">Input</span> object pin on the node.</li>
</ol>
<ol start="3">
<li>Now that we know whether the object is real (in a manner of speaking), we can check to see whether we can pick it up! Create a copy of our <span class="packt_screen">CanPickUp</span> function and connect <span class="packt_screen">HoverObject</span> as the <span class="packt_screen">Target</span>. This will return a <span class="packt_screen">True</span> or <span class="packt_screen">False</span>, which will determine whether the player can pick up the object.</li>
</ol>
<ol start="4">
<li>Next, we need a <span class="packt_screen">Branch</span> to process the Boolean from <span><span class="packt_screen">CanPickUp</span>. We only want the player to pick things up if this is <span class="packt_screen">True</span>. Create a new <span class="packt_screen">Branch</span> node and connect it to the execute output from <span class="packt_screen">CanPickUp</span>. The <span class="packt_screen">Condition</span> input will be the <span class="packt_screen">PickUp</span> output from <span class="packt_screen">CanPickUp</span>.</span></li>
<li>We know now whether the object is real. We also know whether we're allowed to pickup it. Now it's the time to do the heavy lifting. Create a copy of our <span class="packt_screen">HeldObject</span> variable and choose set from the menu. The input for <span class="packt_screen">Set HeldObject</span> will be the current value of <span class="packt_screen">HoverObject</span>.</li>
</ol>
<ol start="6">
<li>Next, create a copy of the <span class="packt_screen">AttachToComponent<span> </span></span>node, making sure we're using the <span class="packt_screen">Target</span> <span class="packt_screen">is </span><span class="packt_screen">Actor</span> version. Connect it to the output of  the s<span>et <span class="packt_screen">HeldObject</span>. Also, pass the variable output of set <span class="packt_screen">HeldObject</span> into the <span class="packt_screen">Target</span> input on <span class="packt_screen">AttachToComponent</span>. Now create a <span class="packt_screen">Reference</span> to <span class="packt_screen">Self</span> and plug that into the <span class="packt_screen">Parent</span> input. Lastly, set the <span class="packt_screen">Location Rule</span>, <span class="packt_screen">Rotation Rule</span>, and <span class="packt_screen">Scale Rule</span> settings in the node to the <span class="packt_screen">Keep World</span> option. This will maintain the basic attributes of the object we pick up so that, when we drop it, everything will remain the same.</span></li>
<li>The next step is to call our <span class="packt_screen">OnPickup</span> function to trigger any special behaviors we might want for that object. Create a copy of <span class="packt_screen">OnPickup</span> and connect the output from <span><span class="packt_screen">AttachToComponent</span> to it. Connect a copy of the <span class="packt_screen">HeldObject</span> variable to the Target input and use a <span class="packt_screen">Reference</span> to <span class="packt_screen">Self</span> as the <span class="packt_screen">Interactor</span>.</span></li>
</ol>
<ol start="8">
<li>Now that we have the ability to pick things up and drop them, we may want the player to be able to use something they're hovering over. To create this behavior, we'll need to create a custom event named <span class="packt_screen">UseHovered</span>. Next, create a copy of our <kbd>OnUse</kbd> function and connect it to our custom event. Get a copy of our <span class="packt_screen">HoverObject</span> variable to use as the <span class="packt_screen">Target</span>. Finish the node with a <span class="packt_screen">Reference</span> to <span class="packt_screen">Self</span> to use as the <span class="packt_screen">Interactor</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/90ff10c8-2d12-499d-b05a-605af0ccfc64.png" width="1931" height="1250"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Pickup/Drop and Hover/Drag code in player pawn</div>
<ol start="9">
<li>To be able to utilize our new behaviors (<span class="packt_screen">Hover</span>, <span class="packt_screen">Drag</span>, <span class="packt_screen">Pickup</span>, and <span class="packt_screen">Drop</span>), we'll need to map them to buttons on the player's motion controller. Let's add hover and drag to the triggers. Open <kbd>Server17PlayerPawn</kbd> and find where we mapped <span class="packt_screen">ActivateUp</span> and <span class="packt_screen">ActivateDown</span> to the motion controller triggers. We'll start with the left trigger. Extend an execute line from <span class="packt_screen">ActivateDown</span> and drop it to search for our <span class="packt_screen">UseHovered</span> function (referencing the left interaction component). Next, drag off the reference to <span class="packt_screen">InteractionComponent_L</span> and search for the <span class="packt_screen">StartDrag</span> function. Connect this to the execute output on the <span><span class="packt_screen">UseHovered</span> function. </span>Finish by dragging off the <span>reference to <span class="packt_screen">InteractionComponent_L</span> again and searching for <span class="packt_screen">EndDrag</span>. We'll connect this to the execution output from <span class="packt_screen">ActivateUp</span>. Now we can use hovered objects, as well as start and end drag sequences!</span></li>
<li>Repeat the same process for the right motion controller.</li>
</ol>
<ol start="11">
<li>Finally, it's time to map the pickup and drop behaviors. Many games map this type of behavior to the grip buttons as players seem to naturally gravitate toward using these buttons, for this interaction. Right-click in the blueprint and search for the <span class="packt_screen">MotionController L Grip1</span> event. Drag an execution line from the Pressed output and search for our <span class="packt_screen">Pickup</span> function <span>(referencing the left interaction component). Now drag off the reference to <span class="packt_screen">InteractionComponent_L</span> and search for the <span class="packt_screen">Drop</span> function. Connect this new function to the <span class="packt_screen">Released</span> output on the event. As before, repeat this process for the right motion controller as well.</span></li>
</ol>
<p>Done! To test the behavior, let's drop a few of these wonderful cubes in our level and test their functionality. Pick them up, throw them, and watch them change color. Pretty cool, right? Just think about all of the possibilities for gameplay with the power you now hold within this cube. It gives you ideas, doesn't it? Before we get to implementing those ideas, why don't we add one more tool to our toolbox in the form of a button our players can press:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/8001be16-b35c-49bd-b788-a72c4621d8d2.png" width="1950" height="1099"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Button press code</div>
<p>We can start building our button in the <span class="packt_screen">Viewport</span>:</p>
<ol>
<li>Our button will be built from three different components. In the <span class="packt_screen">Viewport</span> tab, click the <span class="packt_screen">Add Component</span> button and create a new <span class="packt_screen">Scene</span> <span class="packt_screen">Component</span>. Name this <kbd>ButtonRoot</kbd> . Next, create a <span class="packt_screen">Cylinder</span> component and name it <kbd>Button</kbd>. We'll need to scale the cylinder down a bit so change the <span class="packt_screen">X</span>, <span class="packt_screen">Y</span>, and <span class="packt_screen">Z</span> values for the <span class="packt_screen">Scale</span> property to 0.05. <span>Also, change its <span class="packt_screen">Collision Preset</span> to <span class="packt_screen">OverlapAllDynamic</span></span>. Make sure the button is a child of the <span class="packt_screen">ButtonRoot</span>. Lastly, create one more <span class="packt_screen">Cylinder</span> component named <kbd>ButtonBase</kbd> and make sure that it's a child of the <span class="packt_screen">Default Scene Root</span>. We'll need to change the <span class="packt_screen">Scale</span> property here too. Change the scale values to <span class="packt_screen">X</span>=<span class="packt_screen">0.15</span>, <span class="packt_screen">Y</span>=<span class="packt_screen">0.15</span>, and <span class="packt_screen">Z</span>=<span class="packt_screen">0.05</span>. Finally, set its <span><span class="packt_screen">Collision Preset</span> to <span class="packt_screen">NoCollision</span>.</span></li>
<li>Now that the visual components have been created, we can move on to the blueprint. We want to create a button that animates a bit when the player hovers their hand on it, and, for that, we'll need a few variables. The first we'll create is named <kbd>InitOverlapLoc</kbd> of the type <span class="packt_screen">Vector</span>. This will store the location where the player's hand started overlapping. The second is <kbd>MaxPressAmout</kbd> of the type <span class="packt_screen">Float</span>. This will be an adjustable variable so that we can fine tune how much the player needs to press the button for it to fire. Compile the blueprint and set the default value of this variable to <span class="packt_screen">4</span>. The third variable we need is named <kbd>PressAmount</kbd> of the type <span class="packt_screen">Float</span>. This will store the amount that the player has pressed the button. Lastly, we need to store the name of the component that over lapped the button. Create one more variable and name it <kbd>OverlapComponent</kbd>. Make sure its type is <span class="packt_screen">Primitive Component</span>.</li>
<li>We're going to start our first code sequence with two events. Click on the <span class="packt_screen">Button</span> component we created earlier and head to the <span class="packt_screen">Details</span> panel. Near the very bottom of the list in the <span class="packt_screen">Events</span> section of the menu is a collection of buttons that allows you to create almost every event compatible with our <span class="packt_screen">Button</span>. We need to create two: <span class="packt_screen">OnComponentBeginOverlap</span> and <span><span class="packt_screen">OnComponentEndOverlap</span>. This will detect when the player's hand is pressing the button.</span></li>
<li><span><span class="packt_screen">OnComponentBeginOverlap</span> feels like a good place to start, since it's the event that kicks everything off. The first step is to check and see whether the component overlapping the button is valid. Create a copy of the <span class="packt_screen">IsValid</span> node (remember the one with the question mark?). Connect it to the event and get a copy of our <span class="packt_screen">OverlapComponent</span> variable to be pluged into the <span class="packt_screen">Input Object</span> pin.</span></li>
<li>If our <span><span class="packt_screen">OverlapComponent</span> </span>isn't valid (meaning the variable is empty), we need to store whatever overlapped the button as our new value for <span><span class="packt_screen">OverlapComponent</span></span><span>. Grab another copy of <span class="packt_screen">OverlapComponent</span></span>,<span> only, this time, choose <span class="packt_screen">Set</span> from the menu. The input for the new node will be the <span class="packt_screen">Other Comp</span> input from the event node.</span></li>
</ol>
<ol start="6">
<li>With the <span><span class="packt_screen">OverlapComponent </span>set, we now also need to set its location in our <span class="packt_screen">InitOverlapLoc</span> variable. Right-click in the blueprint and grab a copy of the <span class="packt_screen">GetWorldLocation</span> node where the target of the node is a <span class="packt_screen">Scene Component</span>. Connect the execute input to the execute output of set <span class="packt_screen">OverlapComponent</span>. Have the variable input for <span class="packt_screen">GetWorldLocation</span> by the variable output for the set <span class="packt_screen">OverlapComponent</span>.</span></li>
<li>Now we need to store the new location in <span><span class="packt_screen">InitOverlapLoc</span>. Create a new set <span class="packt_screen">InitOverlapLoc </span>node. The variable input for this new node will be the output from <span class="packt_screen">GetWorldLocation</span>. Don't forget to connect the execute connection!</span></li>
<li>It's time to tackle the <span><span class="packt_screen">OnComponentEndOverlap</span> event. When we end the overlap, all we want to do is check to see whether the object that was removed from overlapping is the same that we've stored in the </span><span class="packt_screen">OverlapComponent </span><span>variable and whether it's we want to clear that variable. Start the sequence by creating a <span class="packt_screen">Branch</span> and connecting it to the execution output of the event. To compare our objects, create a copy of the <span class="packt_screen">Equals</span> (object) node. The top input with be the <span class="packt_screen">OtherComp</span> output from the event. The bottom will be a copy of our <span class="packt_screen">OverlapComponent</span> variable. Finally, connect the Boolean output from the <span class="packt_screen">Equals</span> node to the <span class="packt_screen">Condition</span> input on the <span class="packt_screen">Branch</span>.</span></li>
<li>For the final step in this sequence, create a copy of <span><span class="packt_screen">OverlapComponent </span>and choose <span class="packt_screen">Set</span> from the menu. Connect it to the <span class="packt_screen">True</span> execution output on the <span class="packt_screen">Branch</span>. We'll leave its variable input blank so that we can clear its value.</span></li>
</ol>
<ol start="10">
<li>The next step in our code is to build the nodes that will control the short animation. We begin with the <span class="packt_screen">Event Tick</span> node. Next, right-click and create a <span class="packt_screen">Sequence</span> node, since this will be a two-step process. Connect the <span class="packt_screen">Sequence</span> to the execute output from <span class="packt_screen">Even Tick</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/33194035-ebcc-46c9-82e6-fedb35148c27.png" style="width:40.08em;height:15.67em;" width="1950" height="756"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Button down code</div>
<ol start="11">
<li>Dragging off the <span class="packt_screen">Then 0</span> output, drop the connection and use the search box to find the <span class="packt_screen">IsValid</span> node (remember to use the one marked with a <span class="packt_screen">?</span> in the menu). The <span class="packt_screen">Input Object</span> we'll be checking this time will be a copy of our <span><span class="packt_screen">OverlapComponent</span>. </span>We'll use this setup to determine whether the player is still overlapping with the button. If they are, we'll animate the button going down. If they aren't, we'll animate the button, returning to the original position.</li>
<li>Next, drag in a copy of our <span class="packt_screen">PressAmount</span> variable and choose the <span class="packt_screen">Set</span> option from the menu. Connect this to the <span class="packt_screen">IsValid</span> output. We'll leave its variable input blank for now.</li>
<li>To do the actual animating, we'll need to create a copy of a <span class="packt_screen">SetRelativeLocation</span> node. Connect its execute input to the execute output from the set <span><span class="packt_screen">PressAmount</span> and use a reference to the <span class="packt_screen">Button</span> component as the <span class="packt_screen">Target</span>.</span></li>
<li>With the basics of the code set up for the animation, it's time to do some quick math. Pressing a <span class="packt_screen">Button</span> is a basic motion that involves moving the button component moving up and down in the <em>Z</em> axis when the player overlaps it. To figure out how far the button needs to travel, we'll take the distance the overlapping actor has traveled and subtract it from the initial position of that same actor. We'll compare that distance to our <span class="packt_screen">MaxPressAmount</span> to determine whether the button has been truly pressed. This will all be calculated relative to the position of the button to ensure that it'll work in whatever situation you decide to use it. We'll start with converting our stored <span class="packt_screen">InitOverlapLoc</span> value to be in relation to the button. Get a reference to the <span class="packt_screen">ButtonBase</span> from the <span class="packt_screen">Components</span> panel, drag a connection off of it, and drop it to open the search menu. Create a copy of <span class="packt_screen">GetWorldTransform</span>.</li>
<li>Dragging a line from the return value of <span><span class="packt_screen">GetWorldTransform</span>, drop the connection, and search for the <span class="packt_screen">InverseTransformLocation</span> node. This node is designed to take in a location and convert it from <span class="packt_screen">World Space</span> over into <span class="packt_screen">Local Space</span>, based on the transform that we supply. In this case, we're converting the initial overlap location to be relative to the <span class="packt_screen">ButtonBase</span>. Get a copy of our <span class="packt_screen">InitOverlapLoc </span>variable and connect that to the <span class="packt_screen">Location</span> input.</span></li>
<li>Now create a <kbd>Vector - Vector</kbd> node and take the <span class="packt_screen">Return</span> value of the <span><span class="packt_screen">InverseTransformLocation </span>and plug that into the top input. We'll calculate the second value in the following steps.</span></li>
</ol>
<ol start="17">
<li>Drag another connection off the reference to <span class="packt_screen">ButtonBase</span> and create another copy of <span><span class="packt_screen">GetWorldTransform</span> and another copy of <span class="packt_screen">InverseTransformLocation</span>.</span></li>
</ol>
<ol start="18">
<li>This time, we'll need to get the location of the component we've stored in <span><span class="packt_screen">OverlapComponent</span>. Get a copy of the <span class="packt_screen">OverlapComponent</span> variable and drag a connection off it. Drop it and search for <span class="packt_screen">GetWorldLocation</span>. The <span class="packt_screen">Return Value</span> of this node will be the <span class="packt_screen">Location</span> input on the copy of the <span class="packt_screen">InverseTransformLocation</span> we created in <em>step 17</em>. The <span class="packt_screen">Return Value</span> of this <span class="packt_screen">InverseTransformLocation</span> can now be connected to the lower input on our <kbd>Vector - Vector</kbd>.</span></li>
<li>Since the button only travels in the <em>Z</em> axis, we're only interested in the <em>Z</em> output of the subtraction node. Right-click on the output of the <span><kbd>Vector - Vector</kbd> and split the struct pin.</span></li>
<li>To make sure the <em>Z</em> value doesn't go outside what we need, we're going to use a <span class="packt_screen">Clamp</span> node to limit it. A <span class="packt_screen">Clamp</span> node takes in a value and tells it that it can only be between a certain minimum and maximum. In this case, we're going to bring in the <em>Z</em> value and not let it go lower than zero or higher than our <span class="packt_screen">MaxPressAmount</span>. Right-click and create a <span class="packt_screen">Clamp</span> (float) node. Use the <em>Z</em> ouput from <span>our <kbd>Vector - Vector</kbd> as the <span class="packt_screen">Value</span> input and a copy of our <span class="packt_screen">MaxPressAmount</span> variable as the <span class="packt_screen">Max</span>. We should leave the minimum value at <span class="packt_screen">0</span>.</span></li>
<li>We're almost there! Our clamped float value is now ready to become the input for the set <span class="packt_screen">PressAmount</span> node we created earlier. Connect the output of the <span class="packt_screen">Clamp</span> to the <span>set <span class="packt_screen">PressAmount </span>input.</span></li>
<li><span>Since the button will always be moving down to show that it's being pressed, the value we need to pass into our <span class="packt_screen">SetRelativeLocation </span>node should be negative. Take the variable output from set <span class="packt_screen">PressAmount</span>, drag off from it, and create a <kbd>Float * Float</kbd> node. Set the second value to <span class="packt_screen">-1.0</span>.</span></li>
</ol>
<ol start="23">
<li>To finish the animation, right-click on the <span class="packt_screen">New Location</span> input on the <span><span class="packt_screen">SetRelativeLocation</span> and split the struct. Connect the output from <kbd>Float * Float</kbd> and connect to the <span class="packt_screen">New Location</span> Z input:</span></li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/f3d61845-a45e-40cc-b411-3694a8f33377.png" width="1919" height="831"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Code that returns the button to the start position</div>
<ol start="24">
<li>Once the overlap is complete, we'll need to move the button back to its original location. Head back to the <span class="packt_screen">IsValid</span> that we created back in <em>step 11</em> and drag a connection of the <span class="packt_screen">IsNotValid</span> output, drop it, and search for a copy of the node <span class="packt_screen">SetRelativeLocation</span>. Set a reference to our <span class="packt_screen">Button</span> component as the Target.</li>
<li>Right-click in the blueprint and search for the <span class="packt_screen">VinterpTo</span>. This will help the button achieve a smooth animation back to an unpressed state. To fill the <span class="packt_screen">Current</span> input, grab a reference to the <span class="packt_screen">Button</span> component and drag a connection off it. Drop and search for a <span class="packt_screen">GetRelativeLocation</span> node. Plug the output from this node into the <span class="packt_screen">Current</span> input.</li>
<li>To fill the <span class="packt_screen">Delta Time</span> input, connect the <span class="packt_screen">Delta Time</span> value from the <span class="packt_screen">Event Tick</span> node.</li>
</ol>
<ol start="27">
<li>Finally, connect the <span class="packt_screen">Return Value</span> from <span><span class="packt_screen">VinterpTo</span> to the <span class="packt_screen">New Location</span> input on <span class="packt_screen">SetRelativeLocation</span>.</span></li>
</ol>
<p style="padding-left: 60px">The last thing needed to finish the button is a way to process what happens when the button is pressed. For that, we'll use an <span class="packt_screen">Event Dispatcher</span>. By using an <span class="packt_screen">Event Dispatcher</span>, we can bind different commands to the button, depending on what we need it for, leaving us with a flexible and reusable system:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/b4a8a587-cb18-463f-8a7d-dd48d28fcf97.png" width="1927" height="355"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">What happens when it's pressed?</div>
<p style="padding-left: 60px">To continue, drag off the <span class="packt_screen">Then 1</span> output on our <span class="packt_screen">Sequence</span> node and create a new <span class="packt_screen">Branch</span>:</p>
<ol start="28">
<li>It's now time to compare the amount we have pressed the button to the max press amount. Right-click and create a <kbd>Float &gt;= Float</kbd> node. Get a copy of <span class="packt_screen">PressAmount</span> and connect that to the top input. Get a copy of <span class="packt_screen">MaxPressAmount</span> and connect that to the bottom input. Lastly, plug the output of the node into the <span class="packt_screen">Condition</span> input on the <span class="packt_screen">Branch</span>.</li>
<li>Now create a <span class="packt_screen">DoOnce</span> node. This node stops something from happening again until it has been reset. We'll plug the <span class="packt_screen">True</span> output from the <span class="packt_screen">Branch</span> into the execute input and the <span class="packt_screen">False</span> output into the <span class="packt_screen">Reset</span> input.</li>
<li>Finally, create an <span class="packt_screen">Event Dispatcher</span>. Find the <span class="packt_screen">Event Dispatchers</span> section of the My Blueprint panel and click the <span class="packt_screen">+</span> button. Name the new dispatcher Pressed. Back in the blueprint, drag off the <span class="packt_screen">Completed</span> output of <span class="packt_screen">DoOnce</span> and search for the <span class="packt_screen">Call Pressed</span> node.</li>
<li>The last step in implementing our button-press behavior is to add some code to the interaction component.  </li>
</ol>
<p>We now have a working button that the player can mash in VR. To test the feature, drop a copy of our button into the level where you can press it and open the <span class="packt_screen">Level</span> <span class="packt_screen">Blueprint</span>. We are going to build from the <span class="packt_screen">Event BeginPlay</span> node that should be present in the blueprint by default. If it isn't there, go ahead and drop one in.</p>
<p>Right-click in the blueprint and create a reference to the <span class="packt_screen">InteractButton</span> that's in the level. Drag off from the output and search for the <span class="packt_screen">AssignPressed</span> node and connect the execute output from the event to its input. This will allow you to assign a custom event to <span class="packt_screen">Pressed</span>. It can be anything you want! I created a simple way to end the level in the previous screenshot.</p>
<p>Wow! We've come a long way from where we began. The player now has hands. They can use them to interact with the world around them. They can touch, pick up, throw, press buttons, and anything else that we can dream up. They can also teleport around the level to explore whatever we decide to create—and all of this with controls in place so that they may only do these things with whatever we as the designers let them. It's time to put that power to good use.</p>
<p>Remember the puzzle box we designed at the beginning of the section? We now have all of the pieces we need to make this a reality. Since it's a prototype, we're going to build the box out of static mesh components and another type of component called a <span class="packt_screen">Child Actor</span>. <span class="packt_screen">Child Actors</span> are copies of class blueprints and allow us to build objects within a class blueprint out of other actors, meaning that we can piece together our simple puzzle box with <span class="packt_screen">Box</span> components, copies of our <span class="packt_screen">InteractCube</span>, and a couple copies of <span class="packt_screen">InteractButton</span>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/73d07a01-03ca-4880-b60c-6709f21bccdd.png" width="1935" height="1030"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Building the PuzzleCubeTest</div>
<p>Start by creating a new <span class="packt_screen">Class Blueprint</span>:</p>
<ol>
<li>Right-click in the <kbd>Server17\Blueprint</kbd> folder in the <span class="packt_screen">Content</span> <span class="packt_screen">Browser</span> and create a new <span class="packt_screen">Class Blueprint</span> based on <span class="packt_screen">Actor</span>. Name this new blueprint <span class="packt_screen">PuzzleCubeTest</span>, since this puzzle cube represents our first prototype. Double-click it to open it.</li>
</ol>
<ol start="2">
<li>Let's create the visual components. The best place to start would be with the non-interactive components first. In the <span class="packt_screen">Components</span> section of <span class="packt_screen">My Blueprints</span>, click the <span class="packt_screen">Add Components</span> button, and create a new <span class="packt_screen">Box</span> component. Change the <span class="packt_screen">Scale</span> properties <span class="packt_screen">X=1.0</span>, <span class="packt_screen">Y=2.0</span>, and <span class="packt_screen">Z=0.1</span>. Name this component <kbd>Bottom</kbd>.</li>
<li>Create another <span class="packt_screen">Box</span> component and name it <kbd>RightSide</kbd>. C<span>hange the <span class="packt_screen">Scale</span> properties <span class="packt_screen">X=0.5</span>, <span class="packt_screen">Y=2.0</span>, and <span class="packt_screen">Z=0.1</span> and rotate it 90 degrees around the <em>Y</em> axis. Line it up along the right edge of the bottom component.</span></li>
<li>Select the <span class="packt_screen">Right</span> component and press <em>Ctrl</em> <em>+ W</em>. This will create a copy that you can align with the left edge of the bottom piece. Name this new piece <kbd>LeftSide</kbd>. Change its Y <span class="packt_screen">Scale</span> property to 1.5. This space will allow for the hidden compartment in the back.</li>
<li>Click on the bottom component <span>and press <em>Ctrl+W</em></span> to create a copy. Name this new component <span class="packt_screen">Top</span>. Move this component 60 cm up in the positive <em>Z</em> direction.</li>
<li>The box is slowly coming together, but now we need a back plate to finish the enclosure. Create a new <span class="packt_screen">Box</span> component and change the <span class="packt_screen">Scale</span> property to <span class="packt_screen">X=0.9</span>, <span class="packt_screen">Y=0.5</span>, and <span class="packt_screen">Z=0.1</span>. Name it <span class="packt_screen">BackPlate</span>. Finally, rotate it 90 degrees around the <em>X</em> axis.</li>
<li> Now we're going to create the non-interactive bottom and top supports. <span>Create a new <span class="packt_screen">Box</span> component and name it <span class="packt_screen">BottomSupport_1</span>. Set the <span class="packt_screen">Scale</span> property to <span class="packt_screen">X=0.5</span>, <span class="packt_screen">Y=1.25</span>, and <span class="packt_screen">Z=0.1</span>. Move it below the <span class="packt_screen">Bottom</span> <span class="packt_screen">Component</span> and align it with the front and side edges.</span></li>
<li>With <span><span class="packt_screen">BottomSupport_1</span> selected, press <em>Ctrl + W</em> and name this new component </span><kbd>BottomSupport_2.</kbd> <span>Rotate it 90 degrees around the <em>Z</em> axis and move it back to the center of the bottom of the box. The easy way to do this would be to set the <em>Y</em> value of its location property back to 0.</span></li>
<li>Create another copy of <span><span class="packt_screen">BottomSupport_1</span> and name it <span class="packt_screen">BottomSupport_3</span>. Rotate it 90 around the <em>Z</em> axis and align this component with the back edge of the bottom component.</span></li>
</ol>
<ol start="10">
<li>Select all of the <span class="packt_screen">BottomSupport</span> components in the <span class="packt_screen">Components</span> list by clicking the first one and holding <em>Ctrl</em> while selecting the other two. If necessary, rotate the components 90 degrees so that they're back in the correct orientation. Then move them 80 cm up in the <em>Z</em> axis so that their bottom edges align with the top edge of the <span class="packt_screen">Top</span> component. Name them <kbd>TopSupport_1</kbd>, <span><kbd>TopSupport_2</kbd>, and <kbd>TopSupport_3</kbd>.</span></li>
<li>To give one of our buttons inside the box a surface to sit on, we're going to create one more non-interactive component. Click on the <span class="packt_screen">BackPlate</span> component and create a copy with <em>Ctrl + W</em>. Name this new component <kbd>MiddlePlate</kbd> and make the value of it's <span class="packt_screen">Location</span> property <span class="packt_screen">X=0</span>, <span class="packt_screen">Y=60</span>, and <span class="packt_screen">Z=30</span>.</li>
</ol>
<ol start="12">
<li>To create the interactive surfaces in our puzzle box, we're going utilize <span class="packt_screen">Child Actor</span> components, which will be copies of our <span class="packt_screen">InteractCube</span> object. This will allow us to have all of the functionality that we programmed into <span class="packt_screen">InteractCube</span> and utilize them as components of our puzzle box without reprogramming them in a new component (though we may want to in the future). Create a new <span class="packt_screen">Child Actor</span> component and name it <kbd>SideDecoy_R1</kbd>. In the <span class="packt_screen">Details</span> panel, set the <span class="packt_screen">Child Actor</span> class property to <span class="packt_screen">InteractCube</span>. Se the <span class="packt_screen">Scale</span> value to <span class="packt_screen">X=0.5</span>, <span class="packt_screen">Y=0.13</span>, and <span class="packt_screen">Z=0.7</span> and rotate it 90 degrees around the <em>Z</em> axis. Move this component into position in between the first set of the top and bottom supports on the right side, aligned to the front edge of the <span class="packt_screen">RightSide</span> component.</li>
<li>Create a copy of <span><span class="packt_screen">SideDecoy_R1</span> using <em>Ctrl + W</em> and name the new <span class="packt_screen">Child Actor </span><kbd>SideDecoy_R2</kbd>. Move it between the rear set of the top and bottom supports on the right side, aligned with the back edge of the <span class="packt_screen">Right</span> component.</span></li>
<li>Now for the left side, create a copy of <span><kbd>SideDecoy_R1</kbd> using <em>Ctrl + W</em> and name the new <span class="packt_screen">Child Actor</span>  </span><span><kbd>SideDecoy_L1</kbd>. Move it to the left side of the box between the first set of top and bottom supports and align it with the front edge of the <span class="packt_screen">LeftSide</span> component.</span></li>
<li>Make a copy of <span><kbd>SideDecoy_L1</kbd> and move it to the center set of the top and bottom supports.</span></li>
<li>The decoy components are there to divert the players attention while they look for the buttons to press to unlock the puzzle box. With them all in place, we can now add our interactive button components. On the right-hand side of our puzzle box, create a new <span class="packt_screen">Child Actor</span> component and set the <span><span class="packt_screen">Child Actor</span> class property to <span class="packt_screen">InteractButton</span>. Name this new <kbd>Child Actor Button_Step1</kbd>. Lastly, move it to the center of the area between the middle top and bottom supports and align it with the surface of the <span class="packt_screen">RightSide</span> component by rotating it -90 degrees around the <em>Y</em> axis. Players will need to uncover and find this button before they can open the front of the box.</span></li>
</ol>
<ol start="17">
<li>Create a copy of <span><span class="packt_screen">Button_Step1</span> with <em>Ctrl + W</em> and name the new component <span class="packt_screen">Button_Step2</span>. Set the button's <span class="packt_screen">Rotation</span> property to <span class="packt_screen">X=0</span>, <span class="packt_screen">Y=90</span>, and <span class="packt_screen">Z=90</span>. Align this button with the center of our <span class="packt_screen">MiddlePlate</span> component. This button will be found behind a plate that covers the front of the puzzle box that can only be removed after <span class="packt_screen">Button_Step1</span> has been pressed.</span></li>
<li>Now let's cover up those buttons! Create a copy of <span><span class="packt_screen">SideDecoy_R1</span> and name the new component <kbd>ButtonCover_Step1</kbd>. Move this new object to cover up <span class="packt_screen">Button_Step1</span> by aligning it between the center set of the top and bottom supports on the right side.</span></li>
</ol>
<ol start="19">
<li>To cover the front, we'll need a new <span class="packt_screen">Child Actor</span> sized to fit that compartment. Create a new <span class="packt_screen">Child Actor</span>, <span>set the </span><span><span class="packt_screen">Child Actor</span> class property to <span class="packt_screen">InteractCube</span>, and name it</span> <kbd>ButtonCover_Step2</kbd><span>. Set the value of the <span class="packt_screen">Scale</span> property to <span class="packt_screen">X=0.8</span>, <span class="packt_screen">Y=0.5</span>, and <span class="packt_screen">Z=0.1</span>. Rotate it around the <em>X</em> axis 90 degrees. Lastly, align it to cover <span class="packt_screen">Button_Step2</span> and fit it flush with the front of the puzzle box. This will unlock after the player presses the first button.</span></li>
<li>There's one more cover. This one will cover the compartment we have in the back. Click on <span class="packt_screen">SideDecoy_L2</span> and use <em>Ctrl + W</em> to create a copy of it. Name the new copy <kbd>CompartmentCover_Step3</kbd>. Align it between the back top and bottom supports to cover the compartment. This cover will unlock when the player presses the second button.</li>
<li>What good is a puzzle box if there's no prize at the end? Create one more <span class="packt_screen">Child Actor</span> component and <span>set the </span><span><span class="packt_screen">Child Actor</span> class property to <span class="packt_screen">InteractCube</span>. Name it <span class="packt_screen">StolenData</span>. This will represent the prize the player is after. Set the value of the <span class="packt_screen">Scale</span> property to <span class="packt_screen">X=0.1</span>, <span class="packt_screen">Y=0.1</span>, and <span class="packt_screen">Z=0.1</span>. Place inside of rear compartment that we just covered with <span class="packt_screen">CompartmentCover_Step3</span>.</span></li>
<li>There's one last detail. To make the <span><span class="packt_screen">InteractCube</span> work as a stand-in for more detailed components that we'll create later, we need to open the <span class="packt_screen">InteractCube</span> blueprint and turn off the <span class="packt_screen">Simulate Physics</span> option. This will make it so the cubes won't have physics enabled by default, so the puzzle cube won't fall apart. Physics will still enable once the player has interacted with the cube.</span></li>
</ol>
<p>Based on our design, the code for the prototype puzzle box needs to be able to do the following things:</p>
<ul>
<li>Disable the ability to pick up the button covers when we start</li>
<li>Bind the correct button press events to our two buttons</li>
<li>Enable the front button cover after button 1 has been pressed</li>
<li>Enable the compartment cover after button 2 has been pressed</li>
</ul>
<p>Disabling the components that we don't want the player to be able to interact with what could be accomplished by toggling their individual <span class="packt_screen">PickUpActive</span> Boolean variables. This will leave all of their other functions available but make it so the player can't remove them before we want them to have that ability. To give them that ability, we can bind a couple of custom events to our two buttons that re-enable them after the buttons have been found and pressed. Let's head to the <span class="packt_screen">Event Graph</span> of <span class="packt_screen">PuzzleCubeTest</span> and get to work:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/f317a5a2-c0b5-44cd-8c68-ba1fdb9f90e7.png" width="1932" height="1247"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">PuzzleBoxTest code</div>
<p>We'll build this code from the <span class="packt_screen">Event BeginPlay</span> node:</p>
<ol>
<li>Right-click in the blueprint and search for a <span class="packt_screen">Sequence</span> node. We are going to use this to fire off the steps that we mentioned previously in the correct order. Click the <span class="packt_screen">Add Pin</span> button on the node until we have four output pins to work with.</li>
</ol>
<ol start="2">
<li>Start by dragging off the <span class="packt_screen">Then 0</span> output and search for the <span class="packt_screen">Cast To InteractCube</span> node. For the <span class="packt_screen">Object</span> input on the cast, we need to reference our <span class="packt_screen">Child Actor</span> <span class="packt_screen">ButtonCover_Step2</span>. However, if we try to plug in a simple reference to it, the cast won't work correctly. To make sure it references the correct object, we need to add a <span class="packt_screen">GetChildActor</span> node. Create a reference to <span><span class="packt_screen">ButtonCover_Step2</span> and drag a connection from its output. Search for the <span class="packt_screen">GetChildActor</span> node and connect its output to the <span class="packt_screen">Object</span> input on the cast.</span></li>
<li>With the cast set up, we can now pretend to be the button cover and turn off its ability to be picked up. Drag a connection off the <span class="packt_screen">As</span> <span class="packt_screen">InteractCube</span> output and search for the set <span class="packt_screen">PickUpActive</span>. On the set <span><span class="packt_screen">PickUpActive</span> node, make sure the checkbox is turned off.</span></li>
<li>Let's repeat the process for <span class="packt_screen">CompartmentCover_Step3</span>. Create the cast by dragging off the <span class="packt_screen">Then 1</span> output on the <span class="packt_screen">Sequence</span> and connecting a reference to the <span class="packt_screen">Child Actor</span> version of <span><span class="packt_screen">CompartmentCover_Step3</span> to the <span class="packt_screen">Object</span> input through a <span class="packt_screen">GetChildActor</span> node. As the child actor, set <span class="packt_screen">PickUpActive </span>to false by turning off the checkbox on the <span class="packt_screen">Set</span> node.</span></li>
<li>Next, we need to connect the button presses to a couple of custom events. Drag a connection off the <span class="packt_screen">Then 2</span> output on the <span class="packt_screen">Sequence</span> node and search for the node <span class="packt_screen">Cast To InteractButton</span>. Use the same method as the previous one to create a reference to the child actor, <span class="packt_screen">Button_Step1</span>, and connect that to the <span class="packt_screen">Object</span> input on the cast. We'll use our event dispatcher we created as part of the button to connect a custom event to the pressing of the button. Drag a connection off the <span class="packt_screen">As</span> <span class="packt_screen">InteractButton</span> output and search for <span class="packt_screen">Bind Event</span> to <span class="packt_screen">Pressed</span>.</li>
<li>Create a new custom event and name it <span class="packt_screen">UnlockStep2</span>. Drag a connection off the little box next to the event node's name and plug it into the event input on the <span>Bind <span class="packt_screen">Event to Pressed</span> node. </span></li>
<li>Drag a connection from the <span>As <span class="packt_screen">InteractCube</span> output from <em>step 3</em> and create a set <span class="packt_screen">PickUpActive</span> node. Connect it to the execution output from the <span class="packt_screen">UnlockStep2</span> event and make sure the checkbox on the <span class="packt_screen">Set</span> node is turned on. We've now re-enabled <span class="packt_screen">ButtonCover_Step2</span>.</span></li>
<li>Repeat the steps to set up the ability to re-enable <span><span class="packt_screen">CompartmentCover_Step3</span>. Create a <span class="packt_screen">Cast To InteractButton</span> node and pass in a reference to the child actor version of <span class="packt_screen">Button_Step2</span>. As the button, create a <span class="packt_screen">Bind Event</span> to <span class="packt_screen">Pressed</span> node and connect it to a custom event named <span class="packt_screen">UnlockStep3</span>. Drag off the <span class="packt_screen">As</span> <span class="packt_screen">InteractCube</span> output from <em>step 4</em> and create a set <span class="packt_screen">PickUpActive</span> node. Make sure that the checkbox on this new node is set to on.</span></li>
</ol>
<p>And there we have it, a working puzzle cube that takes three steps to solve. Using our teleport volumes, create a space where you can teleport around the box and then drop a copy of the puzzle box in the center. Move around it. Test the steps and see whether they work. Once everything is working, I have a challenge for you. When we started this section, I provided a sketch of the plan for the puzzle box, as well as a prototype level for the player to test it. Build the level and test your puzzle box in it. Interested in a greater challenge? Design and build your own puzzle cube and test level!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Building the first tool station</h1>
                </header>
            
            <article>
                
<p>An integral part of the gameplay for <em>Server 17</em> is the idea of the Tool Station, a location located near the puzzle box that contains some type of tool, device, or hint-generator that can be used by the player to help solve the puzzle at hand. The tools at each station would vary from brute-force hacking tools that could solve a step of the puzzle at the cost of a time penalty, to a simple hint tool that could highlight the next piece the player has to interact with. For the prototype, we're going to design a simple rotation tool that will highlight how easy it is to use the tools that we created. Let's take a look at the prototype visuals:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/d288f312-9d20-4f01-a0d1-dbef7d91d455.png" style="width:41.00em;height:19.50em;" width="1932" height="916"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Prototype visuals</div>
<p>The build is relatively basic. Using the <span class="packt_screen">Content</span> <span class="packt_screen">Browser</span>, head to the <kbd>Shapes</kbd> folder of the <span class="packt_screen">Starter Content</span> and grab yourself a cylinder. Use the <span class="packt_screen">Scale</span> tool to shrink it by half. Then grab a <span class="packt_screen">Wedge</span> shape and place that on top of the cylinder. Shrink this by half as well. I also used a <span class="packt_screen">Text Render</span> to create the text you see in the image. The final piece to this tool station is a new class blueprint:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/469fd5e5-b079-40f5-a94e-100d5c560701.png" width="1931" height="1030"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">StationButton code</div>
<p>Create a new class <span class="packt_screen">Blueprint</span> and select <span class="packt_screen">Actor</span> from the menu:</p>
<ol>
<li>Create the new class <span class="packt_screen">Blueprint</span>, select the <span class="packt_screen">Actor</span> class from the <span class="packt_screen">Pick Parent Class</span> menu, and name it <kbd>StationButton</kbd>.</li>
<li>Similar to our <span class="packt_screen">InteractCube</span>, this blueprint contains only one component. I used a <span class="packt_screen">Cone</span> component; however, feel free to use whatever you feel might be appropriate.</li>
<li>Now, let's code this thing! To utilize some of the functions that we've spent this chapter creating, click on the <span class="packt_screen">Class Defaults</span> button and find the <span class="packt_screen">Interfaces</span> section in the <span class="packt_screen">Details</span> panel. Click the <span class="packt_screen">Add</span> button and choose our <span class="packt_screen">Object Interaction</span> Interface.</li>
</ol>
<ol start="4">
<li>With the interface added, head over to the <span class="packt_screen">My Blueprint</span> panel and open the <span class="packt_screen">Interfaces</span> section of the menu. Double-click and open the following functions: <kbd>TraceHitObject</kbd>, <kbd>TraceLeaveObject</kbd>, <kbd>TraceActivateUp</kbd>, and <kbd>TraceActivateDown</kbd>.</li>
</ol>
<ol start="5">
<li>Let's start with <kbd>TraceHitObject</kbd>. This covers what happens when our line trace touches the object. Drag a reference to the <span class="packt_screen">Cone</span> into the blueprint from the <span class="packt_screen">Components</span> panel and drag a connection from it. Create a copy of the <span class="packt_screen">SetVectorParameterValueOnMaterial</span> and connect it to the function node and <span class="packt_screen">Return</span> node. Set the value of the <span class="packt_screen">Parameter Name</span> field to <span class="packt_screen">Color</span>. Finally, set the <em>Y</em> value of the <span class="packt_screen">Parameter Value</span> input to <span class="packt_screen">1.0</span>. This will highlight the button <span class="packt_screen">Green</span> when we land a trace on it.</li>
<li>For <kbd>TraceLeaveObject</kbd>, we'll have to create a variable that can store whether or not our button is being used. Head over to the <span class="packt_screen">Variables</span> section of <span class="packt_screen">My Blueprint</span> and create a new Boolean variable. Name it <kbd>ButtonPressed</kbd> and set its default value to <span class="packt_screen">False</span>. Along with changing the color of the button back to the default white, we want to make sure the button no longer registers as pressed if it's no longer being touched by a line trace. Repeat the preceding step to create the <span><span class="packt_screen">SetVectorParameterValueOnMaterial</span> node and set the value of the <span class="packt_screen">Parameter Value</span> input to <span class="packt_screen">X=1.0</span>, <span class="packt_screen">Y=1.0</span>, and <span class="packt_screen">Z=1.0</span>. This will set the button color back to white. After <span class="packt_screen">SetVectorParameterValueOnMaterial</span>, connect a set <span class="packt_screen">ButtonPressed</span> node and make sure the checkbox is set to off. Connect that to the output of <span class="packt_screen">SetVectorParameterValueOnMaterial</span> and the <span class="packt_screen">ReturnNode</span>.</span></li>
<li>Now, let's move on to <kbd>TraceActivateDown</kbd>. When the player activates the button, all we want to do is set <span class="packt_screen">ButtonPressed</span> to <span class="packt_screen">True</span>. We'll handle the rotating in the level blueprint. Connect a copy of the s<span>et <span class="packt_screen">ButtonPressed</span> to the function. Make sure the checkbox on the node is turned on. After the <span class="packt_screen">Set</span> node, create another copy of <span class="packt_screen">SetVectorParameterValueOnMaterial</span> using the <span class="packt_screen">Cone</span> as the <span class="packt_screen">Target</span>. Set it up the same way as we did in the previous steps in this section and set the <em>X</em> value of the <span class="packt_screen">Parameter Value</span> input to <span class="packt_screen">1.0</span>. This will turn the button red when it's used.</span></li>
<li>Lastly, we have <kbd>TraceActivateUp</kbd>. When the player releases the trigger, we need to change the color back to green (the color it is when getting hit by a line trace) and change <span><span class="packt_screen">ButtonPressed</span> back to false. Connect a copy of <span class="packt_screen">SetVectorParameterValueOnMaterial</span> to the function node, set it up as we have in previous steps, and set the <em>Y</em> value of the <span class="packt_screen">Parameter Value</span> input to <span class="packt_screen">1.0</span>. Connect a copy of set <span class="packt_screen">ButtonPressed</span> to the output of the <span class="packt_screen">SetVectorParameterValueOnMaterial</span> node and connect its output to the <span class="packt_screen">Return</span> node, making sure the checkbox is set to off.</span></li>
</ol>
<ol start="9">
<li>Back in our level, add a copy of <span class="packt_screen">StationButton</span> to the tools station that we've created and name it <span class="packt_screen">StationButton_Rotate</span>.</li>
</ol>
<p>To make the puzzle box rotate when our station button is pressed, we're going to build a bit of functionality into the level blueprint, since this ability is limited to the prototype level. Open the <span class="packt_screen">Level Blueprint</span> using the <span class="packt_screen">Blueprints</span> button:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/48159940-23d4-4ef4-a513-5c01b5e86c7b.png" width="1929" height="746"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">The level blueprint code</div>
<p>We'll start to build this sequence with a custom event:</p>
<ol>
<li>Right-click in the blueprint and create a new custom event. We are going to name it <span class="packt_screen">ButtonCheck</span>.</li>
<li>Next, right-click and create a new <span class="packt_screen">Branch</span> node. This will read whether the button has been pressed. Create a reference to our <span><span class="packt_screen">StationButton_Rotate</span> and drag a connection from it. Drop it and search for <span class="packt_screen">Get <span class="packt_screen">B</span></span><span class="packt_screen">uttonPressed</span>. Connect the output from this node to the <span class="packt_screen">Condition</span> node on the <span class="packt_screen">Branch</span>.</span></li>
<li>Now, create an <span class="packt_screen">Event Tick</span> node. We want the game to check every frame if the button is being pressed. Drag a connection from the event and search for our <span class="packt_screen">ButtonCheck</span> function to create a copy of it.</li>
</ol>
<p class="mce-root"/>
<ol start="4">
<li>As we've done for previous buttons, we're going to use a <span class="packt_screen">Gate</span> to control whether  the code executes, based on whether <span class="packt_screen">ButtonPressed</span> is <span class="packt_screen">True</span> or <span class="packt_screen">False</span>. Create a <span class="packt_screen">Gate</span> node and connect the Enter input to the output from the <span class="packt_screen">ButtonCheck</span> function. Connect the True output from our <span class="packt_screen">Branch</span> to the <span class="packt_screen">Open</span> input and the <span class="packt_screen">False</span> output from the <span class="packt_screen">Branch</span> to the <span class="packt_screen">Close</span> input.</li>
<li>It's time to create the rotation. Create a new <kbd>Float</kbd> variable over in the <span class="packt_screen">Variables</span> section of <span class="packt_screen">My Blueprint</span> and name it <span class="packt_screen">RotSpeed</span>. This will control how fast the puzzle cube rotates.</li>
<li>Next, right-click and search for the <span class="packt_screen">Make Rotator</span> node. Connect a copy of <span class="packt_screen">RotSpeed</span> to the <span class="packt_screen">Z</span> (<span class="packt_screen">Yaw</span>) input. </li>
</ol>
<ol start="7">
<li>The last major node we need is <span class="packt_screen">AddActorLocalRotation</span>. Connect it to the <span class="packt_screen">Exit</span> output of our <span class="packt_screen">Gate</span> node and use a reference to our puzzle cube in the level as the <span class="packt_screen">Target</span>.</li>
<li>The <span class="packt_screen">Delta Rotation</span> input needs a bit of math. Drag a connection from the output of <span class="packt_screen">Make Rotator</span> and search for the <span class="packt_screen">ScaleRotator</span> node. For the float input, use the <span class="packt_screen">Delta Seconds</span> output from <span class="packt_screen">Event Tick</span>. This will create a smooth rotation over time.</li>
<li>Finally, plug the output of our <span class="packt_screen">ScaleRotator</span> node into the <span class="packt_screen">Delta Rotation</span> input on the <span><span class="packt_screen">AddActorLocalRotation</span>.</span></li>
</ol>
<p>We now have rotation! Obviously, there's quite a bit more that can be done with the idea of hacking tools in <em>Server 17</em>, but this will work fine for our prototype stage. It looks as though this is finally coming together. There is one last gameplay element we still haven't created  though: our level timer.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Building the Timer</h1>
                </header>
            
            <article>
                
<p>In the world of <em>Server 17</em>, players hack corporate servers looking for valuable company secrets. However, those corporations don't just lie down and take it! Powerful system administrators, corporate hackers, and AI countermeasures mobilize to stop the player, giving them limited time to crack each server. To represent this in the game, we'll implement a level timer in the game that will cause the player to lose when it reaches zero. Since this is a only a prototype, we'll have the game quit when the timer is complete.</p>
<p>Since this is a gameplay element independent of any level, we'll build this feature in our custom game state. Head to our <kbd>Sever17\Blueprints</kbd> server and double-click the <kbd>S17GameState</kbd> to open it:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/4555d7fd-b068-4804-bf13-c6eeea193c38.png" width="1921" height="1183"/></p>
<div class="packt_figref CDPAlignCenter CDPAlign">Game timer code setup in the Game State</div>
<p>Let's get started:</p>
<ol>
<li>This feature makes user of the <span class="packt_screen">Timer</span> system built into the <span class="packt_screen">Blueprint</span> system. Using the <span class="packt_screen">SetTimerByEvent</span> node, we can call a custom event when a timer (in seconds) completes. Start by creating a copy of the <span class="packt_screen">Event</span> <span class="packt_screen">BeginPlay</span> node and dragging an execute connection off the output. Search for the <span><span class="packt_screen">SetTimerByEvent </span>node and select it from the menu.</span></li>
<li>Next, create a <span class="packt_screen">Custom Event</span> named <kbd>EndGame</kbd>. Connect this custom event to the <span class="packt_screen">Event</span> input on <span class="packt_screen">SetTimerByEvent </span><span>by dragging a connection from the square pin next to the custom event's name and connecting to the input pin.</span></li>
<li>Dragging off the <span class="packt_screen">EndGame</span> event, search for the <span class="packt_screen">ExecuteConsoleCommand</span> node. In the <span class="packt_screen">Command</span> field, type in the command <kbd>quit</kbd>.</li>
</ol>
<ol start="4">
<li>To finish the sequence, we need to set a value for <span class="packt_screen">Time</span> on <span><span class="packt_screen">SetTimerByEvent</span>. To keep the system flexible, we'll create a variable for the game time that can easily be adjusted from outside the game state to take into account things such as level difficulty or story elements. Create a new <kbd>Float</kbd> variable and name it <span class="packt_screen">GameTime</span>. Compile the blueprint and set the default value to 300. Get a copy of it and connect it to the <span class="packt_screen">Time</span> input on <span class="packt_screen">SetTimerByEvent</span>.</span></li>
</ol>
<p>Awesome! Our intrepid players now have five minutes to complete our puzzle cube or be kicked out of the game. Feel free to adjust the default value of <span class="packt_screen">GameTime</span> to whatever feels appropriate for your players or to adjust the challenge for yourself.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Wow! What a ride. We began this chapter with some interesting discussions about gameplay and ended it with creating a whole game prototype from scratch! In this chapter, we explored the many different types of gameplay that successfully implement the <span>mechanics that VR is uniquely capable of. Using that knowledge, we designed our game elements to take advantage of the near one-to-one translation of player movement into the game and the ability to have the player interact with the world from a true first-person perspective. Through the rest of this chapter, we built all of our systems from scratch from hand interactions to VR buttons, and even a puzzle box  for the player to solve within a time limit.</span></p>
<p>In the next chapter, we're going to expand our gameplay by discussing the user experience we've created so far and how we can improve that experience through the use of user interfaces. We'll talk about the use and viability of 2D and 3D elements within our game world and what works best with VR. Using that knowledge, we'll design and build our own elements for use in <em>Server 17</em>.</p>


            </article>

            
        </section>
    </div>



  </body></html>