# 微服务架构模式

微服务架构（**MSA**）正被宣称为设计、开发、部署和交付下一代软件应用的最强大的架构模式。微服务显然正在成为构建企业级和关键任务应用的主要构建块。微服务是细粒度的、通常是单功能的、松散耦合的服务，便于独立部署和水平扩展。微服务是自我定义的、干净隔离的、自主的，并且本质上支持流行的多语言模型。多语言范式代表多种编程语言、数据传输协议和持久化机制。目标是构建和运行高度可靠、可扩展、可用、弹性、消息驱动和安全的微服务。微服务是互操作性的、技术无关的，并且可组合以产生以流程为中心的应用。微服务和Docker容器化在敏捷软件开发和快速IT服务交付中相辅相成。许多有成就的专业人士正在发现各种最佳实践、关键指南、设计和评估指标以及促进模式，以加快从单体工作负载到基于微服务的工作负载的迁移过程。此外，还有API网关、服务集成和编排的集成平台、如Docker容器等部署和交付环境，以提高MSA的采用率。产品供应商、系统集成商、云服务提供商、DevOps工程师和其他IT专业人士正在合作，以加速服务在实现高度灵活、可扩展、弹性、可持续的应用中的使用。本章致力于向读者展示这个新领域中所有现有和新兴的模式。

# 微服务模式

几位IT专业人士，基于他们丰富的经验，提出了一系列促进基于微服务应用生产的模式。更进一步，还有一些模式专门用于从头开始构建新的服务。不仅限于开发，还包括测试、部署和交付，精致的分解模式正在被发现并普及。MSA的一个战略影响是将遗留应用程序无风险地转换为基于MSA的现代应用程序。有促进将大型和单体应用程序分解为多个微服务的模式。在接下来的章节中，我们将详细讨论突出的模式。主要有两种模式：架构模式和设计模式。

# 分解模式

模式对于任何新范式的发展至关重要。微服务范式也需要通过许多新颖且具有增值的图案来相应地启用，以便维持并简化其漫长而艰巨的旅程。无论是设计、开发、部署和交付新的微服务，还是将遗留和单体应用程序分解成无数个交互式微服务，架构和设计模式的作用和相关性极高。毫无疑问，世界各地的IT团队都背负着许多不灵活、封闭、维护成本高且规模庞大的软件应用程序。在理解了通过MSA提议所预期的显著好处后，全球企业都热衷于探索利用它来清晰、自信地现代化当前应用程序的可能性。这种技术驱动的转型和变革使每个企业都准备好迎接数字经济和时代。微服务被吹捧为实现数字企业梦想的前进之路，并且有一个响亮的号召去发掘强大且变革性的模式来加速构建和维持以微服务为中心的应用程序。让我们从一些有趣的分解模式开始。

微服务架构模式对应于扩展立方体的*y* 轴缩放，这是一个如图所示的三维扩展模型：

![扩展立方体图](img/02be04cb-f1e5-439e-a74b-17b44e617beb.png)

*x* 轴缩放是为了在负载均衡器后面运行多个应用程序的克隆副本。这是实现横向扩展最常见的方式。*y* 轴缩放表示一个由功能、服务或资源分割的应用程序。每个服务负责一个或多个紧密相关的功能。*z* 轴缩放通常用于扩展数据库，因为数据被分割到一组服务器上。每个服务器运行相同的代码副本，每个服务请求都被路由到相应的服务器。*z* 轴缩放，就像*x* 轴缩放一样，可以提高应用程序的容量和可用性。然而，为了解决日益增长的开发和应用复杂性问题，建议使用*y* 轴缩放。*y* 轴缩放将应用程序分割成多个服务。

# 通过用例模式进行分解

将大型应用程序分割成动态的小型且协作的组件集合有许多基础和原因。众所周知，软件包和库正在被构建，目的是自动化和加速多个用例。因此，这种模式明确地指定了如何专业地将大型应用程序分割成许多小模块的方法；每个模块至少完成一个用例。我们知道，任何技术要生存下来，都必须在日益知识化的市场中击败各种竞争，这需要突破性的商业和技术案例。然而，用例通常是在使用任何技术支持的应用和服务时，用户（人类）、用户代理/服务（软件）或物联网和I/O设备所获得的好处。在这个模式中，关键是开始、识别和优先考虑用例。用例无疑是开发新应用程序以及现代化现有应用程序的关键因素和转折点。这种模式通过产生新的服务和提取大应用程序内部封装的隐藏微服务，有助于产生下一代应用程序。

# 基于资源的分解模式

在这种模式中，它是根据它们访问或控制的资源（服务器机器、存储设备、网络组件、软件基础设施、数据库等）来定义微服务的。这允许创建一组微服务，它们作为访问单个资源的通道。我们展望着应用程序感知基础设施和基础设施感知应用程序的时代。为了微服务展现其特殊能力，底层资源发挥着重要作用，这一点不容忽视。

# 基于业务能力的分解模式

功能性是另一种将单体应用程序分解成许多可互操作的微服务的选项。这些功能或责任通常是业务特定的或非特定的。也就是说，这些垂直以及水平功能可以很容易地被应用程序的多个部分使用。从粗粒度角度来看，许多细粒度服务可以由这些更大的功能/责任产生。这是MSA时代的一个有趣模式。

越来越多的业务应用正变得复杂和复杂。大量的第三方应用正在集成。单体和大规模应用是目前最普遍和突出的。**面向服务的架构**（**SOA**）模式主要用于通过特定的包装和面向服务的接口在不同和分布式应用程序之间建立和维持无缝和自发的集成。也就是说，企业级和云应用集成是通过SOA技术和技巧实现的。在理解了MSA模式战略意义之后，商业巨头正在制定战略，以平稳地进入MSA之路，以正确和适当地服务于他们的客户和客户。除了将大规模应用分解为易于管理、松散耦合且相对简单的服务集合之外，MSA范式通过实现持续交付/部署来加速软件开发。

为了实现上述好处，必须非常小心地将应用程序分解为微服务。面向对象设计（**OOD**）世界的一个有用指南是**单一职责原则**（**SRP**），它将类的职责定义为改变的原因，并指出类应该只有一个改变的原因。面向对象设计中的另一个有用原则是**共同封闭原则**（**CCP**）；一起改变的事物应该打包在一起，以确保每次改变只影响一个服务。

有前景的解决方案方法如下。定义与业务能力相对应的服务。业务能力是指企业为了创造价值所做的事情。业务能力通常对应于业务对象，例如：

+   订单管理负责订单

+   客户管理负责客户

这种基于业务能力的单体应用分解是为了长期造福企业。此外，通过业务能力服务的编排，可以实现更大、更好的业务能力。为了在运行时根据需要生成过程感知的复合应用程序，有API网关、分区最佳实践、用于托管微服务的Docker容器、编排工具和治理引擎。

# 子域模式分解

为了构建模块化软件应用程序，应用程序组件和服务需要松散耦合（每个服务都有一个封装其实施的API，其实施可以更改而不影响其客户端）和内聚（一个服务应实现一组强相关的功能）。通过基于组件的软件组装和**面向服务架构**（**SOA**）方法，设置和维护模块化应用程序已经成为常态。这些组件和服务通常是粗粒度的。随着服务架构的日益普及和深入，创建细粒度服务正在积聚势头。MSA的主要目标是通过对持续集成、部署和交付的支持，快速将软件解决方案推向市场。因此，对应用程序和粗粒度服务的系统化和明智的分解正在获得特别的关注。在上述模式中，我们讨论了业务能力是分解应用程序的基础。

此模式建议按子域进行分解。建议定义与**领域驱动设计**（**DDD**）子域相对应的服务。DDD指的是应用程序的问题空间（业务）作为领域。一个领域由多个子域组成。每个子域对应业务的不同部分。在线商店应用的子域包括：

+   产品目录

+   库存管理

+   订单管理

+   配送管理

由于子域相对稳定，因此结果服务架构相当稳定。挑战在于精确识别子域。分解遵循**分而治之**范式。随着数字时代的到来，软件复杂性将上升，因此将分解技术纳入视野。大型和打包的应用程序需要分解，以便获得决定性和深入的理解。

# 微服务部署模式

微服务的部署方式和手段多种多样。包括一些运行时和执行环境，如**裸机**（**BM**）服务器、**虚拟机**（**VMs**）和容器。因此，部署选项也增多了。然后，一个服务器需要容纳一个或多个相同的微服务实例。部署模式的选取并不简单，而是取决于各种参数。

# 每个主机上的多个服务实例模式

微服务通常规模较小，因此可以快速构建、调整、组合和部署。微服务的可用性和吞吐量很重要。冗余是保证高可用性和吞吐量的一个广泛使用的方法。也就是说，每个服务都作为一组服务实例进行部署。

微服务的美丽之处在于服务可以使用不同的编程语言和框架来实现。正如一开始所阐述的，微服务可以独立部署和水平扩展。为了确保服务的安全和安全，服务实例必须彼此明确隔离。服务实例消耗的资源（处理器/核心/线程、内存、存储等）需要被细致地监控、测量和管理，以确保不同IT资源的优化利用。

在物理或虚拟服务器上运行不同服务的多个实例是可能的。可以将每个服务实例作为JVM进程部署，也可以在同一JVM中部署多个实例。随着密度的提高，资源以及服务的利用率必然会增加。与此模式相关的问题包括资源竞争、资源依赖和资源监控。

# 每个主机一个服务实例模式

这是另一种服务部署模式。存在一些需求和场景，其中服务的多个实例部署在单个服务器上。另一方面，也有只部署一个实例并在主机机器上运行的需求。这种方法的优点包括：

+   服务实例之间是完全隔离的

+   没有资源竞争，与依赖相关的问题也不再存在

+   服务实例最多只能消耗单个主机的资源

+   监控、管理和重新部署每个服务实例都很简单

缺点是资源利用率可能会降低。

# 每个虚拟机一个服务实例模式

服务实例部署有几种选择。BM服务器、虚拟机（VMs）以及最近，Docker容器是主流的部署和运行环境。此模式指定了在虚拟机中部署服务。云环境正日益虚拟化，因此托管在虚拟机上的服务正在蓬勃发展。由**云服务提供商**（**CSPs**）提供的自动扩展功能有助于快速且并发地提供新的虚拟机，以水平扩展服务实例的数量。此机制确保了所需的性能水平和服务的可用性。服务隔离发生在虚拟机级别。这里典型的难题是虚拟机配置需要几分钟。

# 每个容器一个服务实例模式

每个软件模块都通过Docker打包格式和开源平台进行容器化，该特定应用或服务的Docker镜像被存储在公开可发现和可访问的枢纽中。当Docker镜像被提交时，它自动成为一个可以立即部署和运行的Docker容器。容器开始向外界提供实现的服务，以便订阅和消费。原始的开源Docker平台正在通过一系列开创性的工具、引擎和框架迅速加强，以实现全方位的自动化。有Docker机器、容器集群管理平台、编排和网络工具、容器监控工具等等，以宣布Docker支持的容器化成为生产级技术。微服务和Docker范式的关键融合是为了为生产更大、更好的软件应用奠定坚实的基础。

与虚拟机不同，容器的创建和运行速度相当快。这意味着，通过利用容器，可以实现实时可伸缩性。作为最佳实践，每个容器都应该托管一个服务实例。通过多个容器，可以拥有多个服务实例。通常，由于容器的轻量级特性，可以在物理主机上舒适地运行数十个甚至数百个应用容器。

# 无服务器部署模式

无服务器计算，也被称为**函数即服务**（**FaaS**），正吸引着众多关注和市场份额。应用服务的开发、调试、部署、交付和退役是任何**应用生命周期管理**（**ALM**）过程中的主要部分。也就是说，需要运维人员建立并维护优化的基础设施来部署和运行软件应用。

这种无服务器部署模式推荐一种隐藏服务器概念（无论是物理的还是虚拟的）的部署基础设施。该基础设施运行应用服务的代码。用户必须根据消耗的资源为他的每个请求付费。性能、可伸缩性和可用性要求将自动满足。几乎所有的主流云服务提供商都在提供这种新的部署模式。这是一种新的云服务，确保每个功能都作为服务提供。

例如，从一个 AWS Lambda 函数开始，这是一个无状态的组件，用于处理事件。要创建 AWS Lambda 函数，用户必须将他的 NodeJS、Java 或 Python 代码打包成 ZIP 文件，并上传到 AWS Lambda。当发生事件时，AWS Lambda 会找到一个空闲的函数实例，如果没有可用实例，则会启动一个实例并调用处理函数。AWS Lambda 可以根据需要自动运行更多实例，以处理额外的用户和负载。

调用 lambda 函数有四种方式。一种选项是将 lambda 函数配置为在 AWS 服务生成的事件响应中调用。以下是一些事件的示例：

+   一个对象被存放在 S3 桶中

+   在 DynamoDB 表中创建、更新或删除一个条目

+   可以从 Kinesis 流中读取一条消息

另一种调用 lambda 函数的方式是配置 AWS Lambda 网关将 HTTP 请求路由到 lambda 函数。AWS 网关将 HTTP 请求转换为事件对象，调用 lambda 函数，并从 lambda 函数的结果生成 HTTP 响应。

还可以使用 AWS Lambda Web 服务 API 调用 lambda 函数。调用 lambda 函数的应用程序提供一个 JSON 对象，该对象传递给 lambda 函数。Web 服务调用返回 lambda 返回的值。调用 lambda 函数的第四种和最后一种方式是定期使用类似于 cron 的机制。可以告诉 AWS 每五分钟调用一次 lambda 函数。

优点很多；基础设施的配置、设置和管理时间，以及财力和人才都得到了显著减少。软件工程师可以冷静地专注于他们的核心优势，而无需为准备基础设施来运行他们的应用程序而烦恼。然而，也有一些限制。目前 AWS Lambda 支持的语言有限。它仅适用于部署快速响应请求的无状态应用程序。在无服务器模式下运行长时间运行的状态应用程序，如数据库或消息代理是不可能的。如果一个应用程序启动时间很长，那么这个应用程序不适合无服务器部署。同样，遗留的单一和大型应用程序也不适合无服务器计算。无服务器部署通常是反应性的，而不是主动性的，因此可能会出现高延迟的问题。

# 服务部署平台模式

市场上有一些自动化的软件部署工具。IBM UrbanCode Deploy 是一个应用程序发布自动化解决方案。该软件允许按需或按计划无缝部署到分布式数据中心和云环境。它可以扩展到企业级部署，处理数千台服务器。其他流行的软件部署自动化解决方案包括：

+   Docker编排框架，包括 Docker Swarm 和 Kubernetes ([http://kubernetes.io/](http://kubernetes.io/))

+   无服务器平台，例如 AWS Lambda

+   PaaS 包括 Cloud Foundry

部署、发布和交付活动正越来越多地通过一系列工具实现自动化。为了更快地将软件推向市场，工具支持的持续集成、部署和交付是必不可少的，上述模式对于软件架构师和设计师来说非常有用。

# 微服务设计模式

设计能够与其他服务无缝且自发地工作的微服务对于 MSA 的预期成功至关重要。同样，通过微服务的力量优雅且高效地设计云、企业、移动、物联网、分析、运营和事务性应用程序的架构也必须如此。正如之前所述，微服务可以通过多种技术和工具实现。此外，辉煌的 MSA 架构范式在未来的意义上是，任何新技术都可以轻松用于生产下一代微服务，这些微服务易于发现、访问、评估、操作、替换、替代等。接下来的部分将列出所有主导的设计模式，以逐步迈向预期的 MSA 时代。

设计模式通常是细粒度的，并且对构建单个以及复合微服务做出了巨大贡献。不仅业务逻辑，设计模式也有助于附加数据连接性和持久性逻辑。因此，设计模式对于提供 MSA 架构预期的成功至关重要。以下部分将列举并解释关键的设计模式。

# 聚合器微服务设计模式

服务和数据聚合对于 MSA 模式的预期成功至关重要。由于服务相对较小，并且通常一个微服务实现单个任务，因此需要识别和聚合多个分布式和去中心化的服务，以提供全面的企业功能特性。因此，聚合器模式对于 MSA 时代至关重要。由于每个服务都是通过轻量级的 RESTful 接口暴露的，一个由许多微服务组成的应用程序可以通过使用此聚合器模式从不同的服务中检索数据，并相应地处理/显示它。

如果在数据显示之前需要对检索到的数据进行某种处理，存在可行的选项来引入所需业务逻辑：

![](img/573665ab-e497-4e19-a63e-c6216eb6f084.png)

如果聚合必须在服务级别发生以创建组合服务，那么聚合器将仅从每个参与的服务中收集数据，对其应用规定的业务逻辑，然后使用组合REST端点进行聚合和发布。这个以过程为中心的组合服务然后可以被需要它的其他服务消费。所有微服务可能都有自己的缓存和数据库。组合服务也可以拥有自己的缓存和数据库层。聚合器可以在*x*轴和*z*轴上独立扩展。

# 代理微服务设计模式

这种模式是聚合器的一种轻微变化。在这种情况下，客户端不参与聚合活动。根据业务需求，可以调用不同的微服务。代理模式也可以在*x*轴和*z*轴上独立扩展。其想法是每个微服务不需要暴露给消费者。代理可能是一个哑代理，在这种情况下，它只是将请求委派给其中一个服务。或者，它可能是一个智能代理，在向客户端提供响应之前，对某些数据进行转换。随着不同物联网和I/O设备的爆炸式增长，这种代理模式是有益的。

# 链式微服务设计模式

这是为了对一个请求产生一个单一的汇总响应。在这种情况下，客户端的请求由服务A接收，然后与服务B通信，服务B反过来可能与服务C通信。所有服务都可能使用同步的HTTP请求/响应消息。这里的关键问题是客户端在链中的所有服务完成处理之前被阻塞。也就是说，服务A到服务B再到服务B到服务C的链必须短且小，否则，同步通信可能会导致延迟。

# 微服务底盘模式

横切关注点众多，并且在任何应用程序的源代码中也是重复出现的。以独特的方式解决这些在企业级应用程序中普遍存在的横切关注点的面向方面编程模型是第一个。众所周知的例子包括身份和访问、数据库和网络位置、消息平台、日志记录、数据加密、评估指标等等。众所周知，微服务在规模上较小，在开发、测试、调试、部署和交付方面都很快。也就是说，一个小团队的开发者可以在一天或两天内构建一个服务。根据MSA模式，这些来自多个开发团队的小规模服务被有目的地挑选出来，并即时融合形成关键任务应用程序。生成基于微服务的流程感知应用程序的整个过程在短时间内完成。在这里，花费大量额外时间来附加各种横切关注点并不是一个逻辑上合理的论点。因此，微服务底盘框架被制定并推荐用于从应用程序的角度构建微服务。当开发者利用MSA模式时，还必须结合MSA特定的横切关注点，例如服务注册和发现以及断路器，以可靠地处理部分故障。因此，最佳解决方案是在创建微服务时，至关重要的是添加处理上述横切关注点的精简和清晰代码。这种嵌入横切关注点的方式是MSA世界中最明智的前进方式。

# 外部化配置模式

任何企业级应用程序通常使用一个或多个基础设施和第三方服务。例如，应用程序必须使用一些常见的基础设施服务，如服务注册、身份验证、授权和审计服务、消息代理和队列、文件系统、数据库、知识可视化平台、安全等。进一步来说，还有几个第三方应用程序和服务，如支付网关、电子邮件服务器等。因此，任何生产级应用程序都必须直接或间接地连接到本地和远程服务，以展示高度集成的功能。另一个相关的问题是，我们如何使服务能够在多个环境中运行而无需任何修改？

通常，一个服务必须提供配置数据，以告知它如何连接到其他服务。例如，为了连接到数据库，数据库的网络位置和凭证必须附加到配置数据中。此外，还有诸如QA数据库与生产环境数据库之类的变体。突出的解决方案方法是将所有以应用为中心的配置信息外部化，以便服务从外部源读取配置细节以完美地完成其功能。这种模式的优点是应用服务可以在多个环境中运行而无需修改和/或重新编译。

# 微服务数据库模式

数据持久性是任何微服务的重要因素。近期，为了存储原始和加工后的数据，出现了新的数据库管理系统。有大型、快速、流式、物联网数据，以及各种数据处理类型，如批量、实时、交互式和迭代处理。为了支持数据驱动的洞察和洞察驱动的决策，新鲜数据捕获、摄取、存储、处理、挖掘、分析和可视化技术和工具正在涌现并不断发展。在MSA（微服务架构）世界中存在几个与数据相关的模式，本节专门准备来讨论这些模式。

# 每个服务一个数据库模式

MSA（微服务架构）模式正在被关键任务应用所采用，并且这些符合MSA规范的应用必然提供了各种业务、技术和用户优势。意识到MSA理念的战略意义后，全球的企业、组织和机构都热衷于制定可行的和获胜的策略和计划，以利用MSA范式独特的功能。正如我们所知，微服务可以使用多种语言进行编码，微服务的数据持久化需求可以由包括**数据库管理系统**（**DBMS**）、文件系统等在内的多个系统来满足。进一步来说，还有SQL、NoSQL、NewSQL、内存中、数据库内数据库管理系统。因此，微服务支持多语言能力。此模式建议利用每个服务的一个数据库。

随着数据密集型应用（如电子商务、商业、供应链管理等）的日益增多，这些应用被分割成一组相互作用的服务的集合。在此，每个服务都需要持久化自己的数据。因此，每个微服务必须通过其自身的数据持久化机制相应地启用。当每个微服务使用自己的数据库时，会存在一些挑战。复杂的业务交易需要在多个服务、多个数据库之间工作。进一步来说，某些业务操作必须更新多个服务拥有的数据。有时，需要查询多个服务拥有的数据。为了扩展，数据库有时需要复制和共享。

为了确保所需的最大数据安全隔离，正在坚持API驱动的访问。服务的数据库实际上是该服务实现的一部分。数据库不能被其他服务直接访问。API是数据库访问的前进方向。有一些不同的方法可以保持服务持久数据的隐私。首先，可以为每个微服务构建一个单独的表并分配给它。其次，可以为每个微服务生成一个单独的模式。最后，可以为每个服务分配一个单独的数据库服务器。每个服务都有一个数据库确保微服务是松散耦合的，并且可以根据每个服务的任务选择最佳的数据库解决方案。例如，执行文本搜索的微服务可以分配一个文本挖掘和搜索引擎。同样，执行社交媒体分析的微服务可以配备一个图数据库，如Neo4j。

然而，众所周知，NoSQL数据库不支持ACID属性，因此分布式和嵌套事务不适合涉及NoSQL后端系统的微服务。这里的选项是使用最终一致性和**事件驱动架构**（**EDA**）。服务生产者将他们的消息以主题的形式发布到消息队列中，而服务消费者订阅这些主题并使用它们。一些查询需要从多个数据库中联合数据。前进的方式是赋予应用程序执行联合操作的能力，而不是在数据库中完成。例如，API网关或一种组合服务可以检索客户及其订单，来自客户和订单微服务。然后，*联合*操作可以由API网关或组合服务完成。另一种选择是利用**命令查询责任分离**（**CQRS**）模式。

# 共享数据设计模式

微服务是自我定义和自治的。也就是说，微服务拥有所有模块（表示逻辑、业务逻辑、集成逻辑、数据连接性和持久性逻辑），可以独立运行。进一步来说，服务可以轻松地利用经过验证的技术和工具，实现完全的多语言。也就是说，如今，有几种数据库管理系统，如SQL、NoSQL、NewSQL等，微服务可以选择其中任何一个来满足它们所需的数据持久性，以极其优雅地贡献于最初表达和设想的企业目标。

组织将遗留应用程序现代化，使其成为具有微服务功能的现代应用程序。这里的突出挑战之一是数据库规范化。也就是说，每个微服务都必须拥有正确数量的数据。在这个设计模式中，一些服务，可能是一个链中的服务，可能会共享缓存和数据库存储。如果这两个服务之间存在强烈的耦合，这是合理的。这种模式可能被归类为反模式，因为微服务假设并提出了无共享现象。对于以微服务为中心的绿色田野应用，这种模式无疑是反模式。这种模式可以在从单体到微服务的过渡阶段作为临时方面得到利用。

# 共享数据库模式

微服务架构的成功逃逸有几个独特的因素。我们熟悉共享数据库。现在，在大数据和Web规模应用时代，各种新的、功能不同的数据库已经出现，并为许多新一代应用做出了贡献。因此，之前讨论的模式建议为不同的服务使用专用数据库。然而，存在某些要求，如以ACID为中心的事务和事务型应用。解决方案是使用由多个微服务共享的单个数据库。每个微服务都能舒适且方便地访问其他微服务拥有的数据。共享数据库确保了数据的一致性达到极致。单个共享数据库的管理和运营复杂性较低。

如常，共享数据库模式存在一些缺点。首先也是最重要的是服务与数据库之间的紧密耦合。其次是与数据共享相关的问题。传统的SQL数据库不支持水平扩展，因此，数据量的激增无法由跨多个服务的共享SQL数据库处理。

# 命令查询责任分离（CQRS）模式

在微服务世界中，实现连接来自多个服务和它们自己的数据库的查询是一个真正的挑战。解决方案是将应用程序分成两部分；命令端和查询端。命令端处理创建、更新和删除请求，并在数据更改时发出事件。查询端通过执行一个或多个由订阅数据更改时发出的事件流来保持更新的物化视图来处理查询。这种模式有很多优点。这种模式对于**事件驱动架构（EDA**）环境尤其必要。这提供了更好的关注点分离，并支持多个非规范化视图。

# 微服务集成模式

微服务是自治和自定义的。然而，分布式和去中心化的服务应该相互交谈，以产生强大的以流程为中心和业务关键的应用。本节专门分配给您了解MSA环境中正在酝酿的集成模式。

# 远程过程调用（RPI）模式

微服务必须与多个微服务交互才能完成任何复杂的功能。为此，服务使用进程间通信协议。解决方案是利用RPI进行任何服务间的通信和协作。客户端使用基于请求/回复的协议向服务发送请求。知名的RPI技术包括REST、gRPC和Apache Thrift。这种模式易于实现，无需任何中间代理来促进预期的通信。然而，这种模式有几个关键的缺点。那就是，服务之间紧密耦合，必须在线才能找到、绑定和交互。其他突出的交互类型，如通知、请求/异步响应、发布/订阅和发布/异步响应，这里不支持。

# 消息设计模式

消息通常是异步的，在服务间通信中被广泛使用。服务通过在消息通道上交换标准化的消息来相互交谈。市场上存在消息代理、中心节点和队列（如Apache Kafka、RabbitMQ等）。这种模式有以下优点：

+   消息使得参与和贡献服务之间松散且轻量级的耦合成为可能。依赖地狱在这里被消除。

+   消息代理通常将消息缓冲，直到订阅者/消费者能够接收和处理它们。这种基于中间代理的消息存储增强了消息的可用性。这种模式支持多种通信模式，如“发送即忘”，轮询、发布和订阅。

通过消息中间件解决方案实现的异步通信最终成为分布式计算时代的救世主。

# 异步消息设计模式

强调基于消息的异步通信，以建立和维护可靠的弹性微服务。微服务之间松散且轻量级的耦合以及通过传递标准化消息发生的交互被视为 MSA 模式的成功公式。高度流行的 REST 设计模式通常是同步的，因此会阻塞客户端服务。通过 RESTful 协议，仍然可以实现所需的异步交互，但这必须在应用层面实现。因此，在 MSA 世界中，消息代理和队列的使用显著增加。进一步来说，存在同步和异步通信的混合。例如，服务 A 可能同步调用服务 C，然后通过共享的消息队列异步与服务 B 和 D 通信。通过使用 WebSockets，服务 A 可以以异步方式与服务 C 通信，以实现规定的可伸缩性。精确地说，可以使用请求/响应（REST）和发布/订阅消息的组合来完成任何独特的业务需求。

# 领域特定协议模式

存在着更多种类的进程间通信协议。对于某些场景，推荐使用领域特定协议进行进程间通信。对于电子邮件服务，SMTP 和 IMAP 是首选的协议。对于媒体流需求，RTMP、HLS 和 HDS 正在得到应用。

# API 网关模式

在 MSA 世界中存在一些挑战。微服务通常是细粒度的，并且每个微服务都拥有粒度化的 API。其他特点包括不同的服务使用不同的语言编写，以及许多数据传输协议和数据持久化方法。简而言之，服务支持多语言架构。进一步来说，存在多种客户端选项，如桌面、移动、可穿戴、便携式和固定设备。有明确的情况是，从不同的和分布式的微服务和数据服务中消耗数据和应用程序逻辑。精确地说，我们正走向分布式计算的时代。微服务需要找到适当的交互服务，并在规定的时间和 SLA 合规的范围内完成所需的业务功能目标。

网络拓扑和技术在塑造 MSA 应用中也发挥着至关重要的作用。WAN、MAN、LAN、CAN、PAN 和 BAN 等不同方法的延迟不同。也就是说，个人区域网络的延迟较低，而广域网络的延迟较高。微服务可以快速多次访问附近的微服务，而在远程服务的情况下，服务访问次数较低且耗时较长。

可行且增值的解决方案方法是将API网关作为所有类型服务的**单一接触点**（SPOC）以与本地和远程服务进行交互。所有类型的连接性、调解、经纪、聚合、消息丰富、协议和数据格式转换等均由这种标准化的API网关解决方案负责。通过此API网关服务，可以整洁地找到和组合多种服务和数据源，该服务还可以为每个客户端暴露独特的API。通过网络通道传输的数据和消息的安全要求也由该产品完成。

# 前端后端模式

此模式建议并为每种类型的客户端定义一个独立的API。通常，除了传统的Web界面外，移动和管理界面在当今也很常见。API网关具有为不同客户端类型提供不同API的能力。API网关能够隔离客户端与应用程序，应用程序可以被划分为多个协作的微服务。这样，任何类型的应用程序重构、重新平台化和改造都不会对接近客户端产生任何恶意影响。可以根据适当的客户端选择和使用的最佳API。API网关使客户端能够通过单次往返操作从多个服务和来源检索数据。更少的请求也意味着更少的开销，并改善了用户体验。可以根据需要编排多个后端微服务和数据源，以产生更大更好的应用程序。这种转型为用户代理提供了独特的体验。API网关本质上负责所有类型的数据和协议转换。

# 微服务注册、发现和使用模式

为了在运行时找到并相应地利用服务，服务需要在公开可用的服务注册表中注册。在动态和分布式环境中，服务会移动，因此运行时服务发现的任务必须通过此类网络可访问的注册表和存储库来简化。不仅服务，它们的实例也必须注册，以简化服务高可用性的目标。

# 服务发现模式

微服务必须找到一个或多个适当的微服务，以启动一种对话，以满足已识别的业务功能。众所周知，有几种服务发现机制、服务注册表和存储库。在传统的Web服务世界中，我们曾经围绕WSDL和UDDI进行服务接口、发现和启动的实验。在早期时代，我们也曾尝试RPC、RMI、CORBA、EJB、Jini等。在最近过去，RESTful服务交互是建立服务连接和服务实现的最常见方式。

然而，微服务在动态性、多样性和灵活性方面非常独特，数量众多。进一步来说，服务主要是为了在虚拟机和容器中运行而设计的。虚拟化和容器化环境具有动态性，固有地能够提供虚拟化资源和工作负载的实时迁移能力。API网关是一种解决方案，可以适当地使服务能够发现服务以对应并完成业务功能。服务注册包含所有参与和贡献服务的必要信息，如位置、主机、端口等。这种机制有助于显著减少尝试涉及其他服务的服务的网络跳数。

对于企业级服务，连接通常通过集群负载均衡器来实现。负载均衡器的位置是预定义和确定的。服务将请求发送到负载均衡器，负载均衡器随后查询服务注册，该注册可能集成在负载均衡器中。然后负载均衡器将服务请求和查询转发到特定服务的可用实例。

流行的集群解决方案，如Kubernetes ([https://github.com/GoogleCloudPlatform/kubernetes/blob/master/docs/services.md](https://github.com/GoogleCloudPlatform/kubernetes/blob/master/docs/services.md)) 和Marathon ([https://mesosphere.github.io/marathon/docs/service-discovery-load-balancing.html](https://mesosphere.github.io/marathon/docs/service-discovery-load-balancing.html)) 在每个主机上运行一个代理。代理实际上充当服务器端发现路由器/负载均衡器。为了访问一个服务，客户端服务通过分配给该服务的端口连接到本地代理。然后代理将请求转发到集群中某处运行的服务实例。路由器、**应用交付控制器**（**ADCs**）、负载均衡器和其他网络解决方案模块在大规模IT环境中（如云）可用。

# 服务注册模式

服务注册和存储库对于任何软件开发组织都至关重要。随着微服务成为下一代应用构建块，服务和它们一站式注册的相关性正在上升。服务注册为环境中的每个服务提供所有正确的引用。也就是说，每个服务一旦开发完成，就必须在服务注册中注册，以便被发现、绑定并做出巨大贡献。因此，任何想要与其他服务连接的服务都必须首先连接到服务注册，以收集所有服务的发现、访问和利用细节。服务注册可能会调用服务实例的健康检查API来验证它是否能够处理请求。知名的服务注册技术包括：

+   Apache Zookeeper

+   Consul

+   Etcd

在服务世界中，服务注册表非常重要，它必须高度可用。如果它连短时间内都无法可用，那么业务连续性就处于危险之中。

# 服务注册模式

我们已经讨论了服务注册的重要性。由于微服务的动态性，服务注册表的作用变得特别重要。每个服务都必须在服务注册表中注册，以便对业务极为有益。也就是说，每个实例的详细信息必须在每个实例开始其漫长而艰巨的旅程时注册到服务注册表中。另一方面，当服务实例被退役或关闭时，服务实例将被注销。

微服务可以自行注册，或者可以指定第三方解决方案来注册每个服务实例。在第一种情况下，微服务完全负责将自己注册到服务注册表中。在启动时，服务会将自己（主机和IP地址）注册到服务注册表中，并使其可被发现和连接。不仅服务本身，而且这些服务的每个实例都必须有系统地注册到服务注册表中。如果一个服务实例失败，其他服务实例可以方便地维持业务运营、提供和输出。在第二种情况下，可以与第三方解决方案和服务提供商签订合同，以设置服务注册表来注册每个服务实例。

# 事件驱动架构（EDA）模式

随着大量数字化物品/智能对象/感知材料的出现，以及我们日常环境中成百上千的连接设备，每个人在决策、行为和交易方面都将变得更加明智。在预期的物联网世界中，许多决定性和更深入的自动化必将发生。我们周围的所有有形事物都将内外部获得权力，以便在适当的时候主动和预防性地对各种值得注意的事件采取行动。也就是说，我们周围和周围的每一个实体都将被事件驱动。在预期的事件驱动世界中，IT的作用至关重要，具有突破性。IT系统和业务应用程序/服务必须捕获、缓冲、处理、挖掘和分析所有传入的事件，以产生见解。未来的日子肯定是数字化的，我们的日常系统应该足够聪明和熟练，以便能够*感知*和*反应*。在这里，EDA在使我们的IT和业务系统具有创新性、颠覆性和变革性方面发挥的作用和责任必将进一步增长。

在MSA（微服务架构）世界中，每个服务使用数据库是主要的解决方案。但是，有一些特定要求，其中ACID事务对于保证数据一致性目标是强制性的。前进的道路是使用经过验证和潜在的事件驱动架构来实现数据一致性。也就是说，每个服务在更新其数据时都会发布一个事件。其他服务订阅这些发布的事件，并相应地更新它们自己的数据库。这保证了多个微服务之间的数据一致性，而无需通过传统的分布式事务。

为了实现更快交付周期的承诺，团队需要自主权。团队间的依赖是缓慢进步的配方。这就是为什么单体架构进步缓慢的原因。服务之间的隔离是团队保持自主权的方式——维持这种隔离至关重要。

每个团队都必须有权做出独立决策，甚至关于他们的数据层，而不会影响或依赖任何其他团队。甚至数据存储类型的选择也应该是独立的——这个概念被称为多语言持久性。数据如何建模也应该是一个自主决策，本地化到每个服务。团队应该完全控制对模式进行更改，即添加或删除表和实体，或列和属性。那么修改、添加或删除类和对象呢？在自主团队中，这些需要是对其他团队非破坏性的更改，以保护每个团队的自主权。确保每个团队都有权做出自己的数据层选择的最佳方式是不在微服务之间共享数据存储。

服务之间的隔离为每个微服务设定了边界，而事件驱动机制解决了服务如何通信的问题。事件驱动系统在架构的整体运行中起着至关重要的作用。

# 事件源模式

事件溯源是一种架构模式，其中应用程序的状态由一系列事件确定。序列中的每个事件都记录在只追加的事件存储库或流中。传统上，大多数软件应用与数据交互，并且应用必须通过在用户操作数据时更新数据来维护数据的当前状态。典型的数据处理过程是从存储中读取数据，对其进行一些修改，并使用新值更新数据的当前状态。事务是改变数据值的过程。然而，这种数据更新和数据一致性维护的方式有许多固有的局限性。在完成分布式事务时，需要**两阶段提交**（**2PC**）。任何2PC提交都会大幅度降低事务吞吐量。当有多个并发用户时，由于更新操作发生在单个数据项上，可能会出现数据更新冲突的可能性。进一步来说，还需要一个额外的审计机制，该机制记录每个操作的详细信息到一个单独的日志中，否则历史记录就会丢失。

事件溯源通过使用以事件为中心的方法，实现了所需的原子性，而不需要复杂的2PC过程。而不是存储实体的当前状态，应用程序存储一系列状态改变的事件。也就是说，每当业务实体的状态发生变化时，就会创建一个新的事件并将其附加到已捕获和存储的事件列表中。由于保存事件是一个单一操作，因此它是原子的。然后，软件应用可以通过回放事件轻松地重建实体的当前状态。

软件应用和服务通常将事件持久化存储在事件存储库（事件数据库）中，事件存储库公开了一个API，用于添加和检索业务实体的事件。事件存储库还像是一个*发布和订阅*消息代理。订阅者可以订阅特定的事件。每当有新事件发生时，事件存储库将其发送给所有合法的订阅者。进一步来说，应用程序可以定期保存实体的当前状态快照。为了重建当前状态，应用程序将最近的快照和自该快照以来发生的事件进行回放。因此，在事件驱动世界中，事件溯源和存储变得尤为重要。

# 事务日志尾部模式

这是实现分布式事务的另一种选择。其思路是跟踪数据库事务日志，并将每个更改发布为一个事件。这种模式的优点是无需在应用层进行任何更改；所有操作都在数据库层完成。避免重复发布有点困难。这种模式确保了低级别的数据库更改，但确定业务级别的事件相当困难。

# 使用数据库触发器模式发布事件

这是解决多个微服务之间分布式事务挑战和关注点的另一种解决方案方法。一个或多个数据库触发器将事件插入到`EVENTS`表中，该表由一个独立的过程轮询，该过程将事件发布到消息代理，并且所需的微服务和它们的数据库消费它们并相应地更新。

# 应用程序发布事件模式

应用程序将事件插入到作为本地事务一部分的`EVENTS`表中。一个独立的过程轮询`EVENTS`表并将事件发布到消息代理。与这种模式相关的主要关注点是必须在应用程序上实施适当的更改。

将成为一个事件驱动的世界。形式化和标准化的事件将成为未来系统敏感、响应和弹性行动和反应的真实区分器。随着物联网时代的迅速到来，将有数万亿的事件和必须相应定义和设计的IT系统以及业务应用程序。在此，微服务在建立和维持此类适应性、以人为本、流程优化、面向服务和事件驱动的应用程序中的作用显著增长。EDA模式正成为物联网世界的极其合适的实体。微服务能够捕获和处理事件消息以产生正确的输出。基于消息的异步通信模型也由微服务支持。

# 测试和故障排除模式

执行服务验证和验证以了解其提供分配功能的能力，以及**非功能性需求**（**NFRs**），是微服务宣称成功的重要参数和因素。本节将简要介绍服务测试、调试和故障排除。

# 访问令牌模式

我们讨论了API网关在实现微服务架构模式预期成功方面的贡献。API网关是客户端服务的第一个入口点，它代表客户端服务工作。然而，挑战是如何进行用户识别、认证和授权。也就是说，如何将用户代理/请求服务的身份与请求的服务通信，以启动按表达意图执行的任务。

API网关验证请求并传递一个访问令牌（例如，JSON Web Token，[https://jwt.io/](https://jwt.io/)），该令牌在每个请求中安全地识别请求者。一个服务可以在它对其他服务的请求中包含访问令牌。

# 服务组件测试模式

测试微服务和它们的实例对于服务验证和验证非常重要。编写示例测试用例并利用自动化测试工具有助于检查服务是否按预期运行。对涉及许多分布式和去中心化微服务的应用程序进行端到端测试确实不是一件容易的事情。解决方案是使用经过验证的测试套件。微服务可以独立通过测试，但基于微服务的应用程序的测试带来了一些挑战。

# 日志聚合模式

任何微服务的每个实例都会以标准化的格式将其正在执行的操作信息写入日志文件。日志文件通常包含错误、警告、信息和调试消息。挑战在于理解应用程序行为，并使用单个日志来排除应用程序的故障。前进的方式是使用一个集中的日志服务，该服务本质上会聚合每个服务实例产生的所有日志。有日志分析自动化工具。一般来说，日志分析会在软件和硬件组件的功能出现任何重大偏差时发出预警。管理员和用户分别访问日志存储并从日志中搜索任何有用的信息，以便思考下一步的行动。

# 应用指标模式

这是理解并阐述应用程序行为的另一种方法。一直以来，我们都被大量的软件设计和评估指标所包围。为微服务最终确定所有正确和相关的指标是一个好的起点，以便达到了解应用程序行为的目标。推荐的解决方案是拥有一个集中的指标服务，该服务收集并存储每个服务操作的决策支持统计数据。微服务可以将它们的指标信息推送到指标服务。另一方面，指标服务可以从微服务中拉取指标。指标服务正在成为MSA世界中的一个重要组成部分。

# 审计日志模式

服务的可审计性非常关键。这有助于理解用户以及应用程序的行为。对所有用户交互进行审计将有助于设置和维持微服务环境。审计代码必须与业务逻辑交织在一起。

# 分布式跟踪模式

目前可用的软件测试和故障排除技术和工具被发现已经过时和无力，尤其是对于基于微服务的应用程序。随着我们从单体时代迈向有希望的微服务时代，我们需要一系列多功能的工具来检查独立的服务以及整体微服务应用程序。由于单个服务不能提供整体图景，新一代的测试和调试工具必须具有在应用层面做到同样事情的独特能力。也就是说，工具必须展示应用程序性能的完整图景，以及应用程序如何交付其功能。

因此，此模式建议利用分布式跟踪工具，该工具可以跟踪每个请求并在扫描多个微服务时捕获相关数据。然后，该工具将收集的详细信息汇总，以提供对应用程序行为和性能的全面和360度视图。解决方案方法是使用代码对每个微服务进行配置，为每个外部请求分配一个唯一的ID。该代码使能够将ID传递给所有参与处理请求的服务，将ID包含在所有日志消息中，并最终记录如开始和结束时间等增值信息。此模式使开发者能够通过搜索汇总日志来查看单个请求的处理方式。

# 异常跟踪模式

微服务和它们的各个实例被部署在多个BM服务器、虚拟机（VM）甚至Docker容器中。当服务处理来自其他服务的请求时可能会发生错误。通常，服务会抛出一个包含错误信息和堆栈跟踪的异常。这里的需要是对异常进行去重、记录并自觉地调查它们，以理解和解决这些问题。方法是向集中式异常跟踪服务报告所有异常。开发者和调试专业人员可以查看异常并确保及时解决。

# 健康检查API模式

健康检查一直是IT行业的重要组成部分。各种软件和硬件系统都在定期进行健康检查。对于微服务也是如此。服务在运行，但有时由于各种原因，它们无法处理服务请求。在这种情况下，服务监控系统必须生成警报并将其实时发送给运维团队进行处理。负载均衡器也理解任何失败的服务实例，并相应地将请求路由到实时服务，以确保业务连续性。服务注册表也必须注意失败实例，以便任何客户端服务都能获得功能服务的访问详情。解决方案机制是为每个服务提供一个健康检查API端点以执行各种健康检查。

# 微服务组合模式

组合活动是通过两种方式实现的：编排和协奏。组合任务超出了服务组合的范围。也就是说，流程、UI和数据组合对于服务工程也非常重要。服务网格是行业中的新术语，有平台、实践和模式用于创建服务网格，以设想以前未知且业务和流程感知的服务组合。

# 服务器端页面片段组合模式

有面向客户的软件应用，如B2C电子商务网络应用和公司门户网站。这些应用是通过使用多个服务（专用和非专用）设计和开发的。有经过验证的机制，如业务能力、技术优势、横切关注点、领域中心性、**服务质量**（**QoS**）等，可以将原始应用程序分割成许多微服务，或者从头开始构建微服务。这里的一个方面是一些UI屏幕/页面服务必须显示来自多个服务的数据。UI设计师绘制整体外观，而网络应用开发者专注于实现网页特定区域的HTML片段。UI团队负责开发页面模板，通过在服务器端聚合特定于服务的HTML片段来构建页面。

# 客户端UI组合模式

如前所述的挑战是实现一个显示从多个服务聚合数据的UI屏幕或页面。网络开发者构建客户端UI组件，最终实现网页的区域。UI团队负责实现页面骨架，通过组合多个特定于服务的UI组件来构建页面/屏幕。

# 基于消息的微服务组合模式

即使服务是隔离的，服务之间的某些通信也是必需的。由于应用程序由多个微服务组成，微服务需要以某种方式协同工作作为应用程序的一部分。给定服务的状态变化可能对其他微服务感兴趣。一个微服务的数据可能需要另一个微服务。服务之间通信的原因有很多。好的架构通过使微服务API成为访问其服务的唯一入口点来管理通信。

微服务API可以是同步的或异步的。由于网络延迟和间歇性连接，同步模式可能会出现问题。因此，异步、非阻塞的消息正在兴起，因为它允许微服务在等待彼此之前继续处理。这些消息构成了微服务之间松散耦合的基础。异步消息需要在一致性上做出一些妥协——它是一个最终一致性的模型。因此，获得的松散耦合和性能使得这是一个很好的权衡。

一个异步的、基于消息的事件驱动系统通过使它们之间的必要通信非侵入性，满足了微服务之间隔离的需求。微服务可以产生事件，而无需知道哪些服务正在消费这些事件以及事件是如何被处理的。对于微服务开发团队来说，事件驱动架构允许每个团队专注于自己的问题域。

微服务通常包括完整的科技栈，包括用户界面、中间层应用程序和最后一级数据持久化。根据业务需求，每个层级和层都分别使用组合模式。集成视图是一个这样的需求。同样，数据存储需要逻辑上集成，以便检索数据以提供综合视图。最后，在某些情况和场景中，需要将多个离散和原子服务集成和编排，以创建强大的复合体。因此，组合模式在塑造和支撑微服务时代方面发挥着越来越重要的作用。

# 弹性和可靠的微服务模式

与复制整个应用程序不同，应用程序的一部分或多个服务可以独立扩展。这就是微服务的力量。可扩展性功能被强调用于处理额外的用户和数据负载。微服务实例可以轻松地适应Docker容器。创建额外的容器既容易又快，因此，为了实现实时可扩展性，容器内嵌入的微服务正成为适当的方法。在本节中，我们将讨论准备可靠、弹性、可用和以微服务为中心的应用程序的多种模式。

# 电路断路器模式

基于微服务的应用程序设计在软件应用程序的设计、部署和交付方式上带来了微妙而智能的改变。现在，应用程序变成了一个动态的服务集合，这些服务相互依赖以执行各种任务。高度复杂和精细的应用程序必然涉及大量相互依赖的微服务。更多的依赖意味着更多的复杂性和复杂性。这种模式之所以突出，是因为它极大地有助于避免级联服务故障。这种模式的理念是持续监控应用程序的微服务和它们之间的流量，以防止故障。当故障发生时，这种模式有助于最小化这些故障对应用程序的影响。这种模式还试图从一开始就防止故障。对于某些类型的错误条件，例如内存耗尽，有可能认识到故障即将发生，并采取适当的措施来预防它。

这通常是通过服务发出它正在变得不健康的信号来实现的，然后断路器给服务一个机会通过减少请求数量或完全重新路由它们来恢复。一旦服务恢复，断路器会缓慢地增加对服务的请求数量，以免立即压倒它并使其再次变得不健康。

对于微服务，断路器模式保证了自下而上的弹性。如果这种模式被正确实现，它可以通过确保即使在服务不可用的情况下服务的连续性来帮助避免级联故障。确切地说，可以构建使用此模式的应用程序来优雅地降低功能，当方法调用失败时。

# 共享缓存层模式

在任何时间点，任何微服务的所有实例都有相同的数据需求，因此在这些实例之间拥有和共享一个缓存层是非常有意义的。当每个实例在其内存中都有自己的内部*缓存*来存储会话状态时，这种做法通常不会被遵循。这种安排将数据分散到不同的实例中，而这些实例应该被视为一个整体。共享缓存层消除了由这种其他情况下分散的数据层产生的运营复杂性，但它对共享缓存层提出了要求。

应用层对用户数据有一个统一的视图，并且可以通过任何实例访问。当使用共享缓存时，数据的更新对所有微服务实例都是可用的。如果数据层不是共享的，那么每个服务都会对数据有一个狭隘的视角，并且架构必须设置得使得任何给定的用户总是被路由到同一个实例。因此，拥有一个共享缓存层提供了对数据的一个集成和统一的视图。共享缓存层为后端存储提供了隔离层。对后端存储的更改只需在一个地方进行，并且这些更改将惠及所有微服务实例。

如前所述，添加额外的实例立即为云原生应用程序提供了一种有效且高效的方式来扩展应用程序逻辑并提高性能。为了使整个系统从中受益，数据层也必须具备这种能力。如果数据层成为瓶颈，应用程序的性能和可扩展性可能会受到严重影响。引入共享缓存及其实时可扩展性对于确保应用程序性能非常有用。数据延迟也非常低。缓存层的可扩展性可以通过数据分布和复制来实现。

# 高可用性微服务模式

通过添加微服务的实例来扩展其规模，确保了服务的可用性和弹性。如果一个微服务实例出现故障，那么同一微服务的另一个实例可以简单地站出来替换失败的实例，从而通过这类技术解决方案确保业务连续性。根据不断变化的容量需求，可以随意添加或删除微服务实例。通过在每个不同的容器/虚拟机/裸机服务器上运行每个实例，可以确保更高的可用性。容错性是云时代另一个属性，这可以通过在云中心内的不同服务器或地理上分布的云服务器上运行每个实例来实现。共享数据缓存应该提供类似的容错性，以应对服务器故障或站点中断。

高可用性和容错性要求对于服务有益于企业级业务应用至关重要。与Docker容器结合的微服务可以通过在紧急和紧迫的情况下自动添加微服务的额外实例来满足水平扩展的需求。也就是说，服务集群和网格的形成是数字世界的关键区别。谷歌每天调整数百万个容器，以保持其对消费者、客户和客户的业务承诺。服务器故障被积极识别和解决，以确保业务连续性。微服务的可靠性和弹性在其采用和适应中起着重要作用。

如果运行微服务的服务器出现故障，系统会自动将工作重定向到微服务的备用实例，启动一个新的实例以恢复容量，并从新实例提供相同的数据访问。这种恢复场景对如何为适应各种类型的故障设置数据层有多个影响。

# 数据模式并发请求

运行多个应用程序实例将对共享缓存层产生重大影响，因为将会有更多并发请求来获取数据。因此，根据需要添加实例来加强共享缓存层也是必要的。也就是说，缓存层也必须具备弹性能力，以满足额外的请求。

# 事件存储模式

解决方案的关键组件是一个事件存储库。事件存储系统是不可变的、顺序的，并且是每个服务事件流的目的地。这些事件的消费者可以订阅并读取感兴趣的事件。事件存储本质上为每个消费者提供了事件源。消费者维护自己的逻辑，以确定事件是否感兴趣。每个消费者还维护自己的指针/偏移量，以顺序处理事件存储库中的事件。

事件可以从应用层或直接从数据层生成。从应用层生成事件可以提供对事件流的可见性和控制，但这也意味着必须管理和维护所有生产者和消费者之间的事件流。如果事件来自数据层，则可以解放应用层和开发者，使他们不必在应用中构建事件驱动系统的关键部分。

# 事件流和统一事件日志模式

统一事件日志是所有参与微服务中发生的所有事件（状态变化、阈值突破或任何值得注意的偏差、不足、干扰等）的收集点/仓库。每个参与服务也可以选择保留其自身状态变化的本地日志。然而，将所有类型的事件日志收集和存储在单个统一的事件存储库中，可以开辟一系列新的可能性和机会。统一事件日志中呈现的所有事件的完整和360度视图可以用于回放选定的事件，并以任何期望的方式创建信息投影。可以在实时事件数据上执行各种数据分析，以提取可操作的见解。可以从事件存储库中轻松推断出微服务的性能/吞吐量、可扩展性、可用性、可审计性、安全性、运营状态等。通过这种集中和整合的事件日志数据，还可以实现微服务的预测性和预防性维护。

在大量可能提供事件流的微服务存在的情况下，一个统一的日志可能对性能和可扩展性有较高的要求。Apache Kafka的设计旨在追求速度、可扩展性、持久性和大规模并发，加上其只允许写入不可变记录的模式，使其成为统一日志的越来越受欢迎的选择。Kafka通过分布式和复制的分区来维护消息流。

由于多方面、网络化和嵌入式设备的持续爆炸性增长，生成和捕获的事件数量正在迅速增加。无疑需要有一个高度可扩展的消息平台，能够接收来自不同和分布式源的大量事件。我们都知道，Apache Kafka消息平台具有接收每秒数百万事件的内禀能力。然后，事件被分区，以满足批处理和实时处理的需求。由于服务架构模式要求智能端点和愚笨管道，Kafka将满足大多数应用程序和系统集成用例的需求。

# 异步命令调用模式

将服务原子调用组合成复杂流程通常需要对异步操作进行适当的编排。这些通常是本地集成用例，连接必须交换消息并保证交付的关联微服务。在这个用例中，消息层的需求与事件流火管有显著不同，因为其消息是点对点的（队列而不是主题）。这通常需要保证交付，尽管仍然是异步的，并且是会话式的。这是一个传统的以代理为中心的用例，通过异步通信可靠地连接端点。通信流程通过各方之间交换的原子消息进行，而不是由多个进程处理的事件的持续流。

总结来说，基于微服务的应用的高度分布式特性引发了对如何处理数据层的几个悬而未决的问题。微服务促进了完全隔离和自主性。依赖相关的问题在这里简单地消失了。但在真正分布式环境中，如何找到、连接和聚合多个微服务以产生复合服务是一个挑战。在分布式环境中，性能和安全问题浮现出来，利用强大的和开创性的设计实践、模式和流程来产生下一代现代化应用。内存缓存层为读取和写入数据需求提供快速响应时间：

+   异步更新和事件驱动架构保护团队之间的自主性，并允许高速软件开发

+   服务的架构弹性和可扩展性与数据层的弹性和可扩展性密不可分

+   通过缓存隔离层，可以将遗留系统现代化并带入微服务世界

这是我们数字转型的时代。我们周围的一切都在系统地数字化，以使各种物理、机械、电气和电子系统能够加入主流计算。数字经济和时代正迎面而来。我们需要有竞争力的信息技术、敏捷的开发平台、实践和模式。微服务架构（MSA）是成熟稳定的服务导向架构（SOA）范式的衍生品，正成为开发、部署和交付数字服务和应用程序的前进方向。本章专门编写和制定，旨在讨论风险无忧采用和加速有前景的MSA范式的突出和主导模式。模式被认为是任何范式方便和自信使用的一个不可或缺的组成部分。读者将受到启发，制定新的模式，使MSA具有渗透力、参与性和普遍性。

# 摘要

在本章中，我们简要介绍了微服务架构模式，并学习了快速涌现和演变的微服务架构（MSA）的独特性以及相关的架构模式。我们还涵盖了与狂热发展的MSA相关的架构和设计模式。

本章节的参考文献和额外资源：

+   [http://microservices.io/patterns/microservices.html](http://microservices.io/patterns/microservices.html)

+   [https://dzone.com/articles/microservice-design-patterns](https://dzone.com/articles/microservice-design-patterns)

+   [https://azure.microsoft.com/en-us/blog/design-patterns-for-microservices/](https://azure.microsoft.com/en-us/blog/design-patterns-for-microservices/)

+   [https://www.sumologic.com/blog/devops/top-patterns-building-successful-microservices-architecture/](https://www.sumologic.com/blog/devops/top-patterns-building-successful-microservices-architecture/)

+   [https://mapr.com/blog/event-driven-microservices-patterns/](https://mapr.com/blog/event-driven-microservices-patterns/)

+   [https://content.pivotal.io/blog/messaging-patterns-for-event-driven-microservices](https://content.pivotal.io/blog/messaging-patterns-for-event-driven-microservices)

+   [http://soapatterns.org/design_patterns/microservice_deployment](http://soapatterns.org/design_patterns/microservice_deployment)

+   [http://blog.christianposta.com/](http://blog.christianposta.com/)

+   [https://blogs.oracle.com/developers/getting-started-with-microservices-part-three](https://blogs.oracle.com/developers/getting-started-with-microservices-part-three)
