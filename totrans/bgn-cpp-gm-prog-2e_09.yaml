- en: '*Chapter 8*: SFML Views – Starting the Zombie Shooter Game'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*：SFML视图 – 启动僵尸射击器游戏'
- en: In this project, we will be making even more use of `View` class. This versatile
    class will allow us to easily divide our game up into layers for different aspects
    of the game. In the Zombie Shooter project, we will have a layer for the HUD and
    a layer for the main game. This is necessary because as the game world expands
    each time the player clears a wave of zombies and, eventually, the game world
    will be bigger than the screen and will need to scroll. The use of the `View`
    class will prevent the text of the HUD from scrolling with the background. In
    the next project, we will take things even further and create a co-op split screen
    game with the SFML `View` class doing most of the hard work.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将更多地使用`View`类。这个多才多艺的类将使我们能够轻松地将游戏划分为不同方面的层。在僵尸射击器项目中，我们将有一个用于HUD的层和一个用于主游戏的层。这是必要的，因为随着玩家每次清除一波僵尸时游戏世界都会扩大，最终游戏世界将比屏幕大，需要滚动。使用`View`类将防止HUD的文本与背景一起滚动。在下一个项目中，我们将更进一步，使用SFML的`View`类创建一个合作分屏游戏，`View`类将完成大部分繁重的工作。
- en: 'This is what we will do in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们将在本章中要做的事情：
- en: Planning and starting the Zombie Arena game
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规划并启动僵尸竞技场游戏
- en: Coding the `Player` class
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码`Player`类
- en: Learning about the SFML `View` class
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解SFML的`View`类
- en: Building the Zombie Arena game engine
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建僵尸竞技场游戏引擎
- en: Putting the `Player` class to work
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Player`类
- en: Planning and starting the Zombie Arena game
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规划并启动僵尸竞技场游戏
- en: 'At this point, if you haven''t already, I suggest you go and watch a video
    of *Over 9000 Zombies* ([http://store.steampowered.com/app/273500/](http://store.steampowered.com/app/273500/))
    and *Crimson Land* ([http://store.steampowered.com/app/262830/](http://store.steampowered.com/app/262830/)).
    Our game will obviously not be as in-depth or advanced as either of these examples,
    but we will also have the same basic set of features and game mechanics, such
    as the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，如果你还没有看过，我建议你去看一下*Over 9000 Zombies* ([http://store.steampowered.com/app/273500/](http://store.steampowered.com/app/273500/))
    和 *Crimson Land* ([http://store.steampowered.com/app/262830/](http://store.steampowered.com/app/262830/))
    的视频。显然，我们的游戏不会像这两个例子那样深入或高级，但我们将拥有相同的基本功能集和游戏机制，如下所示：
- en: A Heads Up Display (HUD) that shows details such as the score, high score, and
    bullets in clip, the number of bullets left, player health, and the number of
    zombies left to kill.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个显示详细信息如分数、最高分、弹夹中的子弹数量、剩余子弹数量、玩家生命值和剩余待杀僵尸数量的抬头显示（HUD）。
- en: The player will shoot zombies while frantically running away from them.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家将在疯狂地逃离僵尸的同时射击它们。
- en: Move around a scrolling world using the *WASD* keyboard keys while aiming the
    gun using the mouse.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用*WASD*键盘键在移动的同时，用鼠标瞄准枪支。
- en: In-between each level, the player will choose a "level-up" that will affect
    the way the game needs to be played for the player to win.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个关卡之间，玩家将选择一个“升级”，这将影响玩家为了获胜而需要玩游戏的方式。
- en: The player will need to collect "pick-ups" to restore health and ammunition.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家需要收集“拾取物”来恢复生命值和弹药。
- en: Each wave brings more zombies and a bigger arena to make it more challenging.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每一波都会带来更多的僵尸和更大的竞技场，使其更具挑战性。
- en: 'There will be three types of zombies to splatter. They will have different
    attributes, such as appearance, health, and speed. We will call them chasers,
    bloaters, and crawlers. Take a look at the following annotated screenshot of the
    game to see some of the features in action and the components and assets that
    make up the game:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 将有三种类型的僵尸可供击杀。它们将具有不同的属性，如外观、生命值和速度。我们将它们称为追逐者、膨胀者和爬行者。查看以下带有注释的游戏截图，以了解一些功能在实际操作中的表现以及构成游戏的组件和资产：
- en: '![](img/B14278_08_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14278_08_01.jpg)'
- en: 'Here is some more information about each of the numbered points:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是关于每个编号点的更多信息：
- en: The score and hi-score. These, along with the other parts of the HUD, will be
    drawn in a separate layer, known as a view, and represented by an instance of
    the `View` class. The hi-score will be saved and loaded to a file.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分数和最高分。这些，连同HUD的其他部分，将绘制在一个单独的层上，称为视图，并由`View`类的实例表示。最高分将被保存并加载到文件中。
- en: A texture that will build a wall around the arena. This texture is contained
    in a single graphic called a **sprite sheet**, along with the other background
    textures (points **3**, **5**, and **6**).
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个纹理，将在竞技场周围建造墙壁。这个纹理包含在一个名为**精灵图集**的单个图形中，以及其他背景纹理（编号**3**、**5**和**6**）。
- en: The first of two mud textures from the sprite sheet.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 来自精灵图的第一个泥地纹理。
- en: This is an "ammo pick-up." When the player gets this, they will be given more
    ammunition. There is a "health pick-up" as well, from which the player will receive
    more health. These pick-ups can be chosen by the player to be upgraded in-between
    waves of zombies.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个“弹药拾取”。当玩家获得这个时，他们将会获得更多的弹药。还有一个“健康拾取”，玩家将从中获得更多的生命。这些拾取可以在僵尸波之间由玩家选择升级。
- en: A grass texture, also from the sprite sheet.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 来自精灵图的草地纹理。
- en: The second mud texture from the sprite sheet.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 来自精灵图的第二个泥地纹理。
- en: A blood splat where there used to be a zombie.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 僵尸曾经所在的地方的血溅。
- en: The bottom part of the HUD. From left to right, there is an icon to represent
    ammo, the number of bullets in the clip, the number of spare bullets, a health
    bar, the current wave of zombies, and the number of zombies remaining for the
    current wave.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HUD的底部部分。从左到右，有一个代表弹药、弹夹中的子弹数量、备用子弹数量、生命条、当前僵尸波和当前波剩余僵尸数量的图标。
- en: The player's character.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩家的角色。
- en: A crosshair, which the player aims with the mouse.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准星，玩家用鼠标瞄准。
- en: A slow-moving, but strong, "bloater" zombie.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个缓慢移动但强大的“浮肿僵尸”。
- en: A slightly faster-moving, but weaker, "crawler" zombie. There is also a "chaser
    zombie" that is very fast and weak. Unfortunately, I couldn't manage to get one
    in the screenshot before they were all killed.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个稍微快一点的移动但较弱的“爬行僵尸”。还有一个非常快且弱的“追逐僵尸”。不幸的是，在他们都被杀死之前，我无法在截图中获得一个。
- en: So, we have a lot to do and new C++ skills to learn. Let's start by creating
    a new project.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有很多事情要做，还有很多新的C++技能要学习。让我们从创建一个新项目开始。
- en: Creating a new project
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建新项目
- en: As creating a project is a relatively involved process, I will detail all the
    steps again. For even more detail and images, please refer to the *Setting up
    the Timber project* section in [*Chapter 1*](B14278_01_Final_AG_ePub.xhtml#_idTextAnchor017),
    *C++, SFML, Visual Studio, and Starting the First Game*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于创建项目是一个相对复杂的过程，我将再次详细说明所有步骤。对于更多细节和图片，请参阅[*第1章*](B14278_01_Final_AG_ePub.xhtml#_idTextAnchor017)，*C++、SFML、Visual
    Studio和开始第一个游戏*中的*设置Timber项目*部分。
- en: 'As setting up a project is a fiddly process, we will go through it step by
    step, like we did for the Timber project. I won''t show you the same images as
    I did for the Timber project, but the process is the same, so flip back to [*Chapter
    1*](B14278_01_Final_AG_ePub.xhtml#_idTextAnchor017), *C++, SFML, Visual Studio,
    and Starting the First Game* if you want a reminder of the locations of the various
    project properties. Let''s look at the following steps:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于设置项目是一个繁琐的过程，我们将一步一步地进行，就像我们在Timber项目中做的那样。我不会展示与Timber项目相同的图片，但过程是相同的，所以如果你想提醒各种项目属性的位置，请翻回[*第1章*](B14278_01_Final_AG_ePub.xhtml#_idTextAnchor017)，*C++、SFML、Visual
    Studio和开始第一个游戏*。让我们看看以下步骤：
- en: Start Visual Studio and click on the **Create New Project** button. If you have
    another project open, you can select **File** | **New project**.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio并点击**创建新项目**按钮。如果你有其他项目打开，你可以选择**文件** | **新建项目**。
- en: In the window shown next, choose **Console app** and click on the **Next** button.
    You will then see the **Configure your new project** window.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个显示的窗口中，选择**控制台应用程序**并点击**下一步**按钮。然后你会看到**配置你的新项目**窗口。
- en: In the `Zombie Arena` in the **Project** **name** field.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目** **名称**字段中的`Zombie Arena`。
- en: In the `VS Projects` folder.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`VS Projects`文件夹中。
- en: Check the option to **Place solution and project in the same directory**.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**将解决方案和项目放在同一目录下**的选项。
- en: When you have completed the preceding steps, click on **Create**.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你完成前面的步骤后，点击**创建**。
- en: We will now configure the project to use the SFML files that we put in the `SFML`
    folder. From the main menu, select **Project** | **Zombie Arena properties…**.
    At this stage, you should have the **Zombie Arena Property Pages** window open.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将配置项目以使用我们放在`SFML`文件夹中的SFML文件。从主菜单中选择**项目** | **僵尸竞技场属性…**。在这个阶段，你应该已经打开了**僵尸竞技场属性页**窗口。
- en: In the **Zombie Arena Property Pages** window, take the following steps. Select
    **All Configurations** from the **Configuration:** dropdown menu.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**僵尸竞技场属性页**窗口中，执行以下步骤。从**配置：**下拉菜单中选择**所有配置**。
- en: Now, select **C/C++** and then **General** from the left-hand menu.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从左侧菜单中选择**C/C++**然后选择**常规**。
- en: Next, locate the `\SFML\include`. The full path to type, if you located your
    `SFML` folder on your D drive, will be `D:\SFML\include`. Vary your path if you
    installed SFML on a different drive.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，定位到 `\SFML\include`。如果你将 `SFML` 文件夹位于你的 D 驱动器上，要输入的完整路径将是 `D:\SFML\include`。如果你将
    SFML 安装在不同的驱动器上，请更改你的路径。
- en: Click on **Apply** to save your configurations so far.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **应用** 以保存到目前为止的配置。
- en: Now, still in the same window, perform these next steps. From the left-hand
    menu, select **Linker** and then **General**.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，仍然在同一窗口中，执行以下下一步。从左侧菜单中选择 **链接器** 然后选择 **常规**。
- en: Now, find the `SFML` folder is, followed by `\SFML\lib`. So, the full path to
    type, if you located your `SFML` folder on your D drive, will be `D:\SFML\lib`.
    Change your path if you installed SFML to a different drive.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，找到 `SFML` 文件夹，然后是 `\SFML\lib`。所以，如果你将 `SFML` 文件夹位于你的 D 驱动器上，要输入的完整路径将是 `D:\SFML\lib`。如果你将
    SFML 安装在不同的驱动器上，请更改你的路径。
- en: Click on **Apply** to save your configurations so far.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **应用** 以保存到目前为止的配置。
- en: Next, still in the same window, perform these steps. Switch the **Configuration:**
    dropdown menu to **Debug** as we will be running and testing Pong in debug mode.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，仍然在同一窗口中，执行以下步骤。将 **配置** 下拉菜单切换到 **调试**，因为我们将在调试模式下运行和测试 Pong。
- en: Select **Linker** and then **Input**.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **链接器** 然后选择 **输入**。
- en: Find the `sfml-graphics-d.lib;sfml-window-d.lib;sfml-system-d.lib;sfml-network-d.lib;sfml-audio-d.lib;`.
    Be extra careful to place the cursor exactly at the start of the edit box's current
    content so as not to overwrite any of the text that is already there.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到 `sfml-graphics-d.lib;sfml-window-d.lib;sfml-system-d.lib;sfml-network-d.lib;sfml-audio-d.lib;`。请格外小心地将光标放在编辑框当前内容的起始位置，以免覆盖任何已存在的文本。
- en: Click on **OK**.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **确定**。
- en: Click on **Apply** and then **OK**.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **应用** 然后点击 **确定**。
- en: 'Now, you have configured the project properties and you are nearly ready to
    go. Next, we need to copy the SFML `.dll` files into the main project directory
    by following these steps:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经配置了项目属性，你几乎准备就绪了。接下来，我们需要按照以下步骤将 SFML `.dll` 文件复制到主项目目录中：
- en: My main project directory is `D:\VS Projects\Zombie Arena`. This folder was
    created by Visual Studio in the previous steps. If you put your `Projects` folder
    somewhere else, then perform this step in your directory. The files we need to
    copy into the project folder are in your `SFML\bin` folder. Open a window for
    each of the two locations and highlight all the `.dll` files.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我的主要项目目录是 `D:\VS Projects\Zombie Arena`。这个文件夹是在之前的步骤中由 Visual Studio 创建的。如果你将你的
    `Projects` 文件夹放在其他地方，那么在你的目录中执行此步骤。我们需要复制到项目文件夹中的文件位于你的 `SFML\bin` 文件夹中。为这两个位置打开一个窗口，并突出显示所有的
    `.dll` 文件。
- en: Now, copy and paste the highlighted files into the project.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将高亮显示的文件复制到项目中。
- en: The project is now set up and ready to go. Next, we will explore and add the
    project assets.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 项目现在已经设置好并准备就绪。接下来，我们将探索并添加项目资源。
- en: The project assets
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目资源
- en: 'The assets in this project are more numerous and more diverse than the previous
    games. The assets include the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前游戏相比，这个项目中的资源更多样化和丰富。资源包括以下内容：
- en: A font for the text on the screen
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 屏幕上文本所需的字体
- en: Sound effects for different actions such as shooting, reloading, or getting
    hit by a zombie
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同动作的音效，如射击、装弹或被僵尸击中
- en: Graphics for the character, zombies, and a sprite sheet for the various background
    textures
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色图形、僵尸图形以及各种背景纹理的精灵图
- en: All the graphics and sound effects that are required for the game are included
    in the download bundle. They can be found in the `Chapter 8/graphics` and `Chapter
    8/sound` folders, respectively.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏所需的所有图形和音效都包含在下载包中。它们分别位于 `第 8 章/graphics` 和 `第 8 章/sound` 文件夹中。
- en: The font that is required has not been supplied. This is done to avoid any possible
    ambiguity regarding the license. This will not cause a problem because the links
    for downloading the fonts and how and where to choose the font will be provided.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的字体尚未提供。这是为了避免任何关于许可的歧义。这不会造成问题，因为将提供下载字体以及如何和在哪里选择字体的链接。
- en: Exploring the assets
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索资源
- en: 'The graphical assets make up the parts of the scene of our Zombie Arena game.
    Look at the following graphical assets; it should be clear to you where the assets
    in the game will be used:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图形资源构成了我们僵尸竞技场游戏的场景部分。看看以下图形资源；你应该能清楚地知道游戏中的资源将如何使用：
- en: '![](img/B14278_08_03.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_08_03.jpg)'
- en: What might be less obvious, however, is the `background_sheet.png` file, which
    contains four different images. This is the sprite sheet we mentioned previously.
    We will see how we can save memory and increase the speed of our game using the
    sprite sheet in [*Chapter 9*](B14278_09_Final_AG_ePub.xhtml#_idTextAnchor200),
    *C++ References, Sprite Sheets, and Vertex Arrays*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，可能不那么明显的是 `background_sheet.png` 文件，它包含四幅不同的图像。这是我们之前提到的精灵图集。我们将在 [*第9章*](B14278_09_Final_AG_ePub.xhtml#_idTextAnchor200)，*C++
    参考，精灵图集和顶点数组* 中看到如何使用精灵图集来节省内存并提高游戏速度。
- en: 'The sound files are all in `.wav` format. These are files that contain the
    sound effects that will be played when certain events are triggered. They are
    as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 所有声音文件都采用 `.wav` 格式。这些文件包含在触发某些事件时将播放的声音效果。具体如下：
- en: '`hit.wav`: A sound that plays when a zombie comes into contact with the player.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hit.wav`：僵尸与玩家接触时播放的声音。'
- en: '`pickup.wav`: A sound that plays when the player collides or steps on (collects)
    a health boost (pick-up).'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pickup.wav`：当玩家碰撞或踩到（收集）健康提升（拾取）时播放的声音。'
- en: '`powerup.wav`: A sound for when the player chooses an attribute to increase
    their strength (power-up) in-between each wave of zombies.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`powerup.wav`：当玩家在每一波僵尸之间选择一个属性来增强他们的力量（升级）时播放的声音。'
- en: '`reload.wav`: A satisfying click to let the player know they have loaded a
    fresh clip of ammunition.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reload.wav`：一个令人满意的点击声，让玩家知道他们已经装上了新的弹药。'
- en: '`reload_failed.wav`: A less satisfying sound that indicates failing to load
    new bullets.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reload_failed.wav`：一个不那么令人满意的音效，表示未能装上新子弹。'
- en: '`shoot.wav`: A shooting sound.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shoot.wav`：射击声音。'
- en: '`splat.wav`: A sound like a zombie being hit by a bullet.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`splat.wav`：僵尸被子弹击中的声音。'
- en: Once you have decided which assets you will use, it is time to add them to the
    project.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您决定使用哪些资产，就是时候将它们添加到项目中。
- en: Adding the assets to the project
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将资产添加到项目中
- en: 'The following instructions will assume you are using all the assets that were
    supplied is the book''s download bundle. Where you are using your own assets,
    simply replace the appropriate sound or graphic file with your own, using the
    same filename. Let''s take a look at the steps:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下说明将假设您正在使用书中提供的下载包中的所有资产。如果您使用自己的资产，只需用您自己的相应声音或图形文件替换，使用相同的文件名。让我们看看步骤：
- en: Browse to `D:\VS Projects\ZombieArena`.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览到 `D:\VS Projects\ZombieArena`。
- en: Create three new folders within this folder and name them `graphics`, `sound`,
    and `fonts`.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此文件夹内创建三个新文件夹，分别命名为 `graphics`、`sound` 和 `fonts`。
- en: From the download bundle, copy the entire contents of `Chapter 8/graphics` into
    the `D:\VS Projects\ZombieArena\graphics` folder.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下载包中，将 `Chapter 8/graphics` 的全部内容复制到 `D:\VS Projects\ZombieArena\graphics`
    文件夹。
- en: From the download bundle, copy the entire contents of `Chapter 6/sound` into
    the `D:\VS Projects\ZombieArena\sound` folder.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下载包中，将 `Chapter 6/sound` 的全部内容复制到 `D:\VS Projects\ZombieArena\sound` 文件夹。
- en: Now, visit [http://www.1001freefonts.com/zombie_control.font](http://www.1001freefonts.com/zombie_control.font)
    in your web browser and download the **Zombie Control** font.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在您的网络浏览器中访问 [http://www.1001freefonts.com/zombie_control.font](http://www.1001freefonts.com/zombie_control.font)
    并下载 **Zombie Control** 字体。
- en: Extract the contents of the zipped download and add the `zombiecontrol.ttf`
    file to the `D:\VS Projects\ZombieArena\fonts` folder.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解压下载内容，并将 `zombiecontrol.ttf` 文件添加到 `D:\VS Projects\ZombieArena\fonts` 文件夹。
- en: Now, it's time to consider how OOP will help us with this project and then we
    can start writing the code for Zombie Arena.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候考虑面向对象编程如何帮助我们完成这个项目了，然后我们可以开始编写僵尸竞技场的代码。
- en: OOP and the Zombie Arena project
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象编程和僵尸竞技场项目
- en: 'The initial problem we are faced with is the complexity of the current project.
    Let''s consider that there is just a single zombie; here is what we need to make
    it function in the game:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们面临的首要问题是当前项目的复杂性。让我们考虑只有一个僵尸的情况；以下是使其在游戏中运行所需的内容：
- en: Its horizontal and vertical position
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的水平和垂直位置
- en: Its size
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的大小
- en: The direction it is facing
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它面对的方向
- en: A different texture for each zombie type
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每种僵尸类型不同的纹理
- en: A Sprite
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个精灵
- en: A different speed for each zombie type
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每种僵尸类型不同的速度
- en: A different health for each zombie type
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每种僵尸类型不同的健康值
- en: Keeping track of the type of each zombie
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪每种僵尸的类型
- en: Collision detection data
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碰撞检测数据
- en: Its intelligence (to chase the player), which is slightly different for each
    type of zombie
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的智能（追逐玩家），对于每种僵尸类型略有不同
- en: An indication of whether the zombie is alive or dead
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指示僵尸是活着还是死了的标志
- en: This suggests perhaps a dozen variables for just one zombie, and entire arrays
    of each of these variables will be required for managing a zombie horde. But what
    about all the bullets from the machine gun, the pick-ups, and the different level-ups?
    The simple Timber!!! and Pong games also started to get a bit unmanageable, and
    it is easy to speculate that this more complicated shooter will be many times
    worse!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能意味着对于一个僵尸就需要十几个变量，而管理一群僵尸则需要每个变量的整个数组。但是，对于机枪的所有子弹、拾取物品以及不同等级的提升呢？简单的Timber!!!和Pong游戏也开始变得难以管理，很容易推测这个更复杂的射击游戏将会更加难以控制！
- en: Fortunately, we will put all the OOP skills we learned in the previous two chapters
    into action, as well as learn some new C++ techniques.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们将把在前两个章节中学到的所有面向对象编程技能付诸实践，并学习一些新的C++技术。
- en: We will start our coding for this project with a class to represent the player.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个项目开始编写代表玩家的类。
- en: Building the player – the first class
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建玩家类——第一个类
- en: Let's think about what our `Player` class will need to do and what we require
    for it. The class will need to *know* how fast it can move, where in the game
    world it currently is, and how much health it has. As the `Player` class, in the
    player's eyes, is represented as a 2D graphical character, the class will need
    both a `Sprite` object and a `Texture` object.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们思考一下`Player`类需要做什么，以及我们对其的要求。这个类需要知道它能以多快的速度移动，它在游戏世界中的当前位置，以及它有多少健康值。由于`Player`类在玩家眼中被表示为一个二维图形角色，这个类将需要一个`Sprite`对象和一个`Texture`对象。
- en: Furthermore, although the reasons might not be obvious at this point, our `Player`
    class will also benefit from knowing a few details about the overall environment
    the game is running in. These details are screen resolution, the size of the tiles
    that make up an arena, and the overall size of the current arena.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，尽管现在可能不明显，但我们的`Player`类也将从了解游戏运行的整体环境的一些细节中受益。这些细节包括屏幕分辨率、组成竞技场的瓦片大小以及当前竞技场的整体大小。
- en: As the `Player` class will be taking full responsibility for updating itself
    in each frame (like the bat and ball did), it will need to know the player's intentions
    at any given moment. For example, is the player currently holding down a keyboard
    direction key? Or is the player currently holding down multiple keyboard direction
    keys? Boolean variables are used to determine the status of the *W*, *A*, *S*,
    and *D* keys and will be essential.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Player`类将负责在每一帧中更新自己（就像蝙蝠和球一样），它需要知道玩家在任何给定时刻的意图。例如，玩家当前是否按下了键盘方向键？或者玩家当前是否按下了多个键盘方向键？布尔变量用于确定*W*、*A*、*S*和*D*键的状态，并将是必不可少的。
- en: It is clear that we are going to need quite a selection of variables in our
    new class. Having learned all we have about OOP, we will, of course, be making
    all of these variables private. This means that we must provide access, where
    appropriate, from the `main` function.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，我们将在新类中需要相当多的变量。在学到了所有关于面向对象编程的知识后，我们当然会把这些变量都设置为私有。这意味着在适当的地方，我们必须提供从`main`函数访问的权限。
- en: We will use a whole bunch of getter functions as well as some functions to set
    up our object. These functions are quite numerous. There are 21 functions in this
    class. At first, this might seem a little daunting, but we will go through them
    all and see that most of them simply set or get one of the private variables.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用大量的getter函数以及一些设置对象状态的函数。这些函数数量相当多。这个类中有21个函数。一开始，这可能会显得有些令人畏惧，但我们将逐一过目，并会发现它们中的大多数只是设置或获取一个私有变量。
- en: 'There are just a few in-depth functions: `update`, which will be called once
    each frame from the `main` function, and `spawn`, which will handle initializing
    some of the private variables each time the player is spawned. As we will see,
    however, there is nothing complicated and they will all be described in detail.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 其中只有几个深入的功能：`update`，它将从`main`函数中每帧被调用一次，以及`spawn`，它将处理每次玩家被创建时初始化一些私有变量。然而，正如我们将看到的，它们并没有什么复杂的地方，并且它们都将被详细描述。
- en: The best way to proceed is to code the header file. This will give us the opportunity
    to see all the private variables and examine all the function signatures.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 进行编码的最佳方式是编写头文件。这将给我们机会看到所有的私有变量并检查所有的函数签名。
- en: Tip
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Pay close attention to the return values and argument types, as this will make
    understanding the code in the function definitions much easier.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 请密切注意返回值和参数类型，因为这会使理解函数定义中的代码变得容易得多。
- en: Coding the Player class header file
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写玩家类头文件
- en: Start by right-clicking on `Player.h`. Finally, click on the **Add** button.
    We are now ready to code the header file for our first class.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 首先右键单击 `Player.h`。最后，点击 **添加** 按钮。我们现在可以开始编写我们第一个类的头文件了。
- en: 'Start coding the `Player` class by adding the declaration, including the opening
    and closing curly braces, followed by a semicolon:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加声明，包括开闭花括号，然后加上分号来开始编写 `Player` 类：
- en: '[PRE0]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, let''s add all our private member variables in the file. Based on what
    we have already discussed, see whether you can work out what each of them will
    do. We will go through them individually in a moment:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将所有我们的私有成员变量添加到文件中。根据我们之前讨论的内容，看看你是否能弄清楚每个变量将做什么。我们稍后会逐一介绍：
- en: '[PRE1]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The previous code declares all our member variables. Some are regular variables,
    while some of them are objects. Notice that they are all under the `private:`
    section of the class and, therefore, are not directly accessible from outside
    the class.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码声明了所有我们的成员变量。其中一些是常规变量，而另一些是对象。请注意，它们都在类的 `private:` 部分下，因此不能从类外部直接访问。
- en: Also, notice that we are using the naming convention of prefixing `m_` to all
    the names of the non-constant variables. The `m_` prefix will remind us, while
    coding the function definitions, that they are member variables, are distinct
    from the local variables we will create in some of the functions, and are also
    distinct from the function parameters.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意我们正在使用命名约定，即给所有非常量变量的名称前缀为 `m_`。这个 `m_` 前缀将在编写函数定义时提醒我们，它们是成员变量，与我们在某些函数中创建的局部变量不同，也与函数参数不同。
- en: All the variables that are used are straightforward, such as `m_Position`, `m_Texture`,
    and `m_Sprite`, which are for the current location, texture, and sprite of the
    player, respectively. In addition to this, each variable (or group of variables)
    is commented to make its usage plain.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 所使用的所有变量都非常直接，例如 `m_Position`、`m_Texture` 和 `m_Sprite`，分别代表玩家的当前位置、纹理和精灵。除此之外，每个变量（或变量组）都有注释，以便清楚地说明其用法。
- en: However, why exactly they are needed, and the context they will be used in,
    might not be so obvious. For example, `m_LastHit`, which is an object of the `Time`
    type, is for recording the time that the player last received a hit from a zombie.
    It is not obvious *why* we might need this information, but we will go over this
    soon.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为什么它们是必需的，以及它们将用于什么上下文，可能并不那么明显。例如，`m_LastHit` 是 `Time` 类型的对象，用于记录玩家最后一次被僵尸击中的时间。我们可能需要这个信息的
    `why` 并不明显，但我们会很快讨论这个问题。
- en: As we piece the rest of the game together, the context for each of the variables
    will become clearer. The important thing, for now, is to familiarize yourself
    with the names and data types to make following along with the rest of the project
    trouble-free.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将游戏的其余部分拼凑起来时，每个变量的上下文将变得更加清晰。现在的重要事情是熟悉名称和数据类型，以便轻松地跟随整个项目的其余部分。
- en: Tip
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: You don't need to memorize the variable names and types as we will discuss all
    the code when they are used. You do, however, need to take your time to look over
    them and get more familiar with them. Furthermore, as we proceed, it might be
    worth referring to this header file if anything seems unclear.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要记住变量名称和类型，因为当它们被使用时我们会讨论所有代码。然而，你需要花时间仔细查看它们，并更多地熟悉它们。此外，随着我们的进展，如果任何内容似乎不清楚，参考这个头文件可能是有价值的。
- en: 'Now, we can add a complete long list of functions. Add the following highlighted
    code and see whether you can work out what it all does. Pay close attention to
    the return types, parameters, and the name of each function. This is key to understanding
    the code we will write throughout the rest of this project. What do they tell
    us about each function? Add the following highlighted code and then we will examine
    it:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以添加一个完整的函数列表。添加以下突出显示的代码，看看你是否能弄清楚它都做了什么。请密切注意返回类型、参数和每个函数的名称。这是理解我们将在这个项目的其余部分编写的代码的关键。它们告诉我们关于每个函数的什么？添加以下突出显示的代码，然后我们将检查它：
- en: '[PRE2]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Firstly, note that all the functions are public. This means we can call all
    of these functions using an instance of the class from the `main` function with
    code like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请注意，所有这些函数都是公开的。这意味着我们可以使用`main`函数中的类实例调用所有这些函数，代码如下：
- en: '[PRE3]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Assuming `player` is a fully set up instance of the `Player` class, the previous
    code will return a copy of `m_Sprite`. Putting this code into a real context,
    we could, in the `main` function, write code like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`player`是`Player`类的完整配置实例，之前的代码将返回`m_Sprite`的副本。将此代码放入实际上下文中，我们可以在`main`函数中编写如下代码：
- en: '[PRE4]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The previous code would draw the player graphic in its correct location, just
    as if the sprite was declared in the `main` function itself. This is what we did
    with the `Bat` class in the Pong project.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码会在正确的位置绘制玩家图形，就像在`main`函数中直接声明精灵一样。这就是我们在Pong项目中使用`Bat`类所做的那样。
- en: 'Before we move on to implement (that is, write the definitions) of these functions
    in a corresponding `.cpp` file, let''s take a closer look at each of them in turn:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将要实现（即编写相应的`.cpp`文件中的定义）这些函数之前，让我们逐一仔细看看它们：
- en: '`void spawn(IntRect arena, Vector2f resolution, int tileSize)`: This function
    does what its name suggests. It will prepare the object ready for use, which includes
    putting it in its starting location (that is, spawning it). Notice that it doesn''t
    return any data, but it does have three arguments. It receives an `IntRect` instance
    called `arena`, which will be the size and location of the current level; a `Vector2f`
    instance, which will contain the screen resolution; and an `int`, which will hold
    the size of a background tile.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void spawn(IntRect arena, Vector2f resolution, int tileSize)`: 这个函数做它名字暗示的事情。它将准备对象以便使用，包括将其放置在起始位置（即生成）。请注意，它不返回任何数据，但它有三个参数。它接收一个名为`arena`的`IntRect`实例，这将表示当前级别的尺寸和位置；一个包含屏幕分辨率的`Vector2f`实例；以及一个整数，它将包含背景瓷砖的大小。'
- en: '`void resetPlayerStats`: Once we give the player the ability to level up between
    waves, we will need to be able to take away/reset those abilities at the start
    of a new game.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void resetPlayerStats`: 一旦我们赋予玩家在波次之间升级的能力，我们将在新游戏开始时需要能够取消/重置这些能力。'
- en: '`Time getLastHitTime()`: This function does just one thing – it returns the
    time when the player was last hit by a zombie. We will use this function when
    detecting collisions, and it will allow us to make sure the player isn''t punished
    *too* frequently for making contact with a zombie.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Time getLastHitTime()`: 这个函数只做一件事——它返回玩家最后一次被僵尸击中的时间。当检测碰撞时，我们将使用这个函数，并且它将确保玩家不会因为与僵尸接触而频繁受到惩罚。'
- en: '`FloatRect getPosition()`: This function returns a `FloatRect` instance that
    describes the horizontal and vertical floating-point coordinates of the rectangle,
    which contains the player graphic. This is also useful for collision detection.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FloatRect getPosition()`: 这个函数返回一个`FloatRect`实例，描述了包含玩家图形的矩形的水平和垂直浮点坐标。这对于碰撞检测也很有用。'
- en: '`Vector2f getCenter()`: This is slightly different to `getPosition` because
    it is a `Vector2f` type and contains just the *x* and *y* locations of the very
    center of the player graphic.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Vector2f getCenter()`: 这与`getPosition`略有不同，因为它是一个`Vector2f`类型，只包含玩家图形中心的*x*和*y*位置。'
- en: '`float getRotation()`: The code in the `main` function will sometimes need
    to know, in degrees, which way the player is currently facing. 3 o''clock is 0
    degrees and increases clockwise.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float getRotation()`: `main`函数中的代码有时需要知道，以度为单位，玩家当前面向的方向。3点钟是0度，顺时针增加。'
- en: '`Sprite getSprite()`: As we discussed previously, this function returns a copy
    of the sprite that represents the player.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sprite getSprite()`: 正如我们之前讨论的，这个函数返回代表玩家的精灵的副本。'
- en: '`void moveLeft()`, `..Right()`, `..Up()`, `..Down()`: These four functions
    have no return type or parameters. They will be called from the `main` function
    and the `Player` class will then be able to act when one or more of the *WASD*
    keys have been pressed.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void moveLeft()`, `..Right()`, `..Up()`, `..Down()`: 这四个函数没有返回类型或参数。它们将从`main`函数中调用，然后`Player`类将能够在按下一个或多个*WASD*键时采取行动。'
- en: '`void stopLeft()`, `..Right()`, `..Up()`, `..Down()`: These four functions
    have no return type or parameters. They will be called from the `main` function,
    and the `Player` class will then be able to act when one or more of the *WASD*
    keys have been released.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void stopLeft()`, `..Right()`, `..Up()`, `..Down()`: 这四个函数没有返回类型或参数。它们将从`main`函数中调用，然后`Player`类将能够在释放一个或多个*WASD*键时采取行动。'
- en: '`void update(float elapsedTime, Vector2i mousePosition)`: This will be the
    only long function of the entire class. It will be called once per frame from
    `main`. It will do everything necessary to make sure the `player` object''s data
    is updated so that it''s ready for collision detection and drawing. Notice that
    it returns no data but receives the amount of elapsed time since the last frame,
    along with a `Vector2i` instance, which will hold the horizontal and vertical
    screen location of the mouse pointer/crosshair.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void update(float elapsedTime, Vector2i mousePosition)`: 这将是整个类中唯一的长函数。它将每帧从
    `main` 中调用一次。它将执行所有必要的操作，以确保 `player` 对象的数据被更新，以便进行碰撞检测和绘制。注意，它不返回任何数据，但接收自上一帧以来经过的时间量，以及一个
    `Vector2i` 实例，它将包含鼠标指针/十字准线的水平和垂直屏幕位置。'
- en: Important note
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示
- en: Note that these are integer screen coordinates and are distinct from the floating-point
    world coordinates.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，这些是整数屏幕坐标，与浮点世界坐标不同。
- en: '`void upgradeSpeed()`: A function that can be called from the leveling up screen
    when the player chooses to make the player faster.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void upgradeSpeed()`: 一个可以在升级屏幕上调用，当玩家选择让玩家跑得更快时的函数。'
- en: '`void upgradeHealth()`: Another function that can be called from the leveling
    up screen when the player chooses to make the player stronger (that is, have more
    health).'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void upgradeHealth()`: 另一个可以在升级屏幕上调用，当玩家选择让玩家更强（即拥有更多健康）时的函数。'
- en: '`void increaseHealthLevel(int amount)`: A subtle but important difference regarding
    the previous function in that this one will increase the amount of health the
    player has, up to the maximum that''s currently set. This function will be used
    when the player picks up a health pick-up.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void increaseHealthLevel(int amount)`: 与之前的函数相比，这个函数会增加玩家拥有的健康量，直到达到当前设定的最大值。这个函数将在玩家拾取健康物品时使用。'
- en: '`int getHealth()`: With the level of health being as dynamic as it is, we need
    to be able to determine how much health the player has at any given moment. This
    function returns an `int`, which holds that value.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int getHealth()`: 由于健康水平是如此动态，我们需要能够确定玩家在任何给定时刻的健康量。这个函数返回一个 `int`，它包含这个值。'
- en: Like the variables, it should now be plain what each of the functions is for.
    Also the *why* and the precise context of using some of these functions will only
    reveal themselves as we progress with the project.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 就像变量一样，现在应该很清楚每个函数的作用。同时，使用这些函数的 *原因* 和精确的上下文也只有在项目进展过程中才会逐渐显现。
- en: Tip
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: You don't need to memorize the function names, return types, or parameters as
    we will discuss the code when they are used. You do, however, need to take your
    time to look over them, along with the previous explanations, and get more familiar
    with them. Furthermore, as we proceed, it might be worth referring to this header
    file if anything seems unclear.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要记住函数名、返回类型或参数，因为当它们被使用时我们会讨论代码。然而，你需要花时间仔细查看它们，结合之前的解释，并熟悉它们。此外，随着项目的进行，如果任何内容似乎不清楚，参考这个头文件可能会有所帮助。
- en: 'Now, we can move on to the meat of our functions: the definitions.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续到函数的核心部分：定义。
- en: Coding the Player class function definitions
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 Player 类函数定义
- en: Finally, we can begin writing the code that does the work of our class.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以开始编写执行我们类工作的代码。
- en: '*Right-click* on `Player.cpp`. Finally, click on the **Add** button.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Player.cpp` 上 *右键点击*。最后，点击 **添加** 按钮。
- en: Tip
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: From now on, I will simply ask you to create a new class or header file. So,
    commit the preceding step to memory or refer back here if you need a reminder.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在起，我将简单地要求你创建一个新的类或头文件。所以，记住前面的步骤，或者如果需要提醒，请参考这里。
- en: We are now ready to code the `.cpp` file for our first class in this project.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始为这个项目中第一个类的 `.cpp` 文件编写代码了。
- en: 'Here are the necessary include directives, followed by the definition of the
    constructor. Remember, the constructor will be called when we first instantiate
    an object of the `Player` type. Add the following code to the `Player.cpp` file
    and then we can take a closer look at it:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是必要的包含指令，接着是构造函数的定义。记住，构造函数将在我们首次实例化 `Player` 类型的对象时被调用。将以下代码添加到 `Player.cpp`
    文件中，然后我们可以更仔细地查看它：
- en: '[PRE5]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the constructor function, which, of course, has the same name as the class
    and no return type, we write code that begins to set up the `Player` object, ready
    for use.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，它当然与类名相同且没有返回类型，我们编写代码来开始设置 `Player` 对象，使其准备好使用。
- en: 'To be clear; this code will run when we write the following code from the `main`
    function:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要清晰明了；此代码将在我们从`main`函数中编写以下代码时运行：
- en: '[PRE6]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Don't add the previous line of code just yet.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 不要立即添加上一行的代码。
- en: All we do in the constructor is initialize `m_Speed`, `m_Health`, and `m_MaxHealth`
    from their related constants. Then, we load the player graphic into `m_Texture`,
    associate `m_Texture` with `m_Sprite`, and set the origin of `m_Sprite` to the
    center, `(25, 25)`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们只是从相关常量初始化`m_Speed`、`m_Health`和`m_MaxHealth`。然后，我们将玩家图形加载到`m_Texture`中，将`m_Texture`与`m_Sprite`关联，并将`m_Sprite`的原点设置为中心，`(25,
    25)`。
- en: Tip
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note the cryptic comment, `// !!Watch this space!!`, indicating that we will
    return to the loading of our texture and some important issues regarding it. We
    will eventually change how we deal with this texture once we have discovered a
    problem and learned a bit more C++. We will do so in [*Chapter 10*](B14278_10_Final_AG_ePub.xhtml#_idTextAnchor214)*,
    Pointers, the Standard Template Library, and Texture Management*.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到这个神秘的注释`// !!Watch this space!!`，它表明我们将返回到加载我们的纹理以及与之相关的一些重要问题。一旦我们发现问题并学习更多C++，我们最终将改变我们处理这个纹理的方式。我们将在[*第10章*](B14278_10_Final_AG_ePub.xhtml#_idTextAnchor214)*，指针、标准模板库和纹理管理*中这样做。
- en: 'Next, we will code the `spawn` function. We will only ever create one instance
    of the `Player` class. We will, however, need to spawn it into the current level
    for each wave. This is what the `spawn` function will handle for us. Add the following
    code to the `Player.cpp` file and be sure to examine the details and read the
    comments:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编写`spawn`函数。我们只会创建一个`Player`类的实例。然而，我们需要在每一波中将其生成到当前关卡中。这就是`spawn`函数为我们处理的事情。将以下代码添加到`Player.cpp`文件中，并确保检查细节并阅读注释：
- en: '[PRE7]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding code starts off by initializing the `m_Position.x` and `m_Position.y`
    values to half the height and width of the passed in `arena`. This has the effect
    of moving the player to the center of the level, regardless of its size.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码首先将`m_Position.x`和`m_Position.y`的值初始化为传入的`arena`高度和宽度的一半。这会将玩家移动到关卡的中心，无论其大小如何。
- en: Next, we copy all the coordinates and dimensions of the passed in `arena` to
    the member object of the same type, `m_Arena`. The details of the size and coordinates
    of the current arena are used so frequently that it makes sense to do this. We
    can now use `m_Arena` for tasks such as making sure the player can't walk through
    walls. In addition to this, we copy the passed in `tileSize` instance to the member
    variable, `m_TileSize`, for the same purpose. We will see `m_Arena` and `m_TileSize`
    in action in the `update` function.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将传入的`arena`的所有坐标和尺寸复制到相同类型的成员对象`m_Arena`中。当前竞技场的尺寸和坐标被频繁使用，因此这样做是有意义的。现在我们可以使用`m_Arena`来执行诸如确保玩家不能穿过墙壁等任务。此外，我们将传入的`tileSize`实例复制到成员变量`m_TileSize`中，出于相同的目的。我们将在`update`函数中看到`m_Arena`和`m_TileSize`的实际应用。
- en: The final two lines from the preceding code copy the screen resolution from
    the `Vector2f`, `resolution`, which is a parameter of `spawn`, into `m_Resolution`,
    which is a member variable of `Player`. We now have access to these values inside
    the `Player` class.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码的最后两行将屏幕分辨率从`Vector2f`的`resolution`（`spawn`的参数）复制到`m_Resolution`（`Player`的成员变量）。现在我们可以在`Player`类内部访问这些值。
- en: 'Now, add the very straightforward code of the `resetPlayerStats` function:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加`resetPlayerStats`函数的非常直接的代码：
- en: '[PRE8]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When the player dies, we will use this to reset any upgrades they might have
    used.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家死亡时，我们将使用此代码来重置他们可能使用的任何升级。
- en: We will not write the code that calls the `resetPlayerStats` function until
    nearly completing the project, but it is there ready for when we need it.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在接近完成项目之前编写调用`resetPlayerStats`函数的代码，但它已经准备好了，以备我们使用。
- en: In the next part of the code, we will add two more functions. They will handle
    what happens when the player is hit by a zombie. We will be able to call `player.hit()`
    and pass in the current game time. We will also be able to query the last time
    that the player was hit by calling `player.getLastHitTime()`. Exactly how these
    functions are useful will become apparent when we have some zombies.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的下一部分，我们将添加两个额外的函数。它们将处理玩家被僵尸击中的情况。我们将能够调用`player.hit()`并传入当前游戏时间。我们还可以通过调用`player.getLastHitTime()`来查询玩家最后一次被击中的时间。这些函数的确切用途将在我们有僵尸时变得明显。
- en: 'Add the two new definitions to the `Player.cpp` file and then examine the C++
    code a little more closely:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 将两个新的定义添加到`Player.cpp`文件中，然后更仔细地检查C++代码：
- en: '[PRE9]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The code for `getLastHitTime()` is very straightforward; it will return whatever
    value is stored in `m_LastHit`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`getLastHitTime()`的代码非常直接；它将返回存储在`m_LastHit`中的任何值。'
- en: The `hit` function is a bit more in-depth and nuanced. First, the `if` statement
    checks to see whether the time that's passed in as a parameter is 200 milliseconds
    further ahead than the time stored in `m_LastHit`. If it is, `m_LastHit` is updated
    with the time passed in and `m_Health` has 10 deducted from its current value.
    The last line of code in this `if` statement is `return true`. Notice that the
    `else` clause simply returns `false` to the calling code.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`hit`函数稍微复杂一些，并且更加微妙。首先，`if`语句检查传入的参数时间是否比存储在`m_LastHit`中的时间晚200毫秒。如果是这样，`m_LastHit`将更新为传入的时间，`m_Health`的当前值将扣除10点。`if`语句中的最后一行代码是`return
    true`。注意，`else`子句只是简单地返回`false`给调用代码。'
- en: The overall effect of this function is that health points will only be deducted
    from the player up to five times per second. Remember that our game loop might
    be running at thousands of iterations per second. In this scenario, without the
    restriction this function provides, a zombie would only need to be in contact
    with the player for one second and tens of thousands of health points would be
    deducted. The `hit` function controls and restricts this phenomenon. It also lets
    the calling code know whether a new hit has been registered (or not) by returning
    `true` or `false`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的整体效果是，玩家的健康点数每秒最多只能扣除五次。记住，我们的游戏循环可能每秒运行数千次迭代。在这种情况下，如果没有这个函数提供的限制，僵尸只需要与玩家接触一秒钟，就会扣除数万健康点数。`hit`函数控制并限制这种现象。它还通过返回`true`或`false`来让调用代码知道是否已注册新的打击（或没有）。
- en: This code implies that we will detect collisions between a zombie and the player
    in the `main` function. We will then call `player.hit()` to determine whether
    to deduct any health points.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码暗示我们将在`main`函数中检测僵尸与玩家之间的碰撞。然后我们将调用`player.hit()`来确定是否扣除任何健康点数。
- en: Next, for the `Player` class, we will implement a bunch of getter functions.
    They allow us to keep the data neatly encapsulated in the `Player` class, at the
    same time as making their values available to the `main` function.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，对于`Player`类，我们将实现一系列的getter函数。这些函数允许我们保持数据在`Player`类中整洁地封装，同时使它们的值对`main`函数可用。
- en: 'Add the following code, right after the previous block:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码块之后添加以下代码：
- en: '[PRE10]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The previous code is very straightforward. Each one of the previous five functions
    returns the value of one of our member variables. Look carefully at each of them
    and familiarize yourself with which function returns which value.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码非常直接。之前的五个函数中的每一个都返回我们成员变量中的一个值。仔细观察每一个，熟悉哪个函数返回哪个值。
- en: 'The next eight short functions enable the keyboard controls (which we will
    use from the `main` function) so that we can change the data contained in our
    object of the `Player` type. Add the following code to the `Player.cpp` file and
    then we will summarize how it all works:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的八个简短函数启用了键盘控制（我们将在`main`函数中使用），以便我们可以更改我们的`Player`类型对象的包含数据。将以下代码添加到`Player.cpp`文件中，然后我们将总结它是如何工作的：
- en: '[PRE11]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The previous code has four functions (`moveLeft`, `moveRight`, `moveUp`, and
    `moveDown`), which set the related Boolean variables (`m_LeftPressed`, `m_RightPressed`,
    `m_UpPressed`, and `m_DownPressed`) to `true`. The other four functions (`stopLeft`,
    `stopRight`, `stopUp`, and `stopDown`) do the opposite and set the same Boolean
    variables to `false`. The instance of the `Player` class can now be kept informed
    of which of the *WASD* keys were pressed and which were not.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码包含四个函数（`moveLeft`、`moveRight`、`moveUp`和`moveDown`），这些函数将相关的布尔变量（`m_LeftPressed`、`m_RightPressed`、`m_UpPressed`和`m_DownPressed`）设置为`true`。另外四个函数（`stopLeft`、`stopRight`、`stopUp`和`stopDown`）执行相反的操作，并将相同的布尔变量设置为`false`。现在，`Player`类的实例可以知道哪些*WASD*键被按下，哪些没有被按下。
- en: 'The following function is the one that does all the hard work. The `update`
    function will be called once in every single frame of our game loop. Add the following
    code, and then we will examine it in detail. If we followed along with the previous
    eight functions and we remember how we animated the clouds and bees for the Timber!!!
    project and the bat and ball for Pong, we will probably understand most of the
    following code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数是完成所有繁重工作的函数。`update` 函数将在游戏循环的每一帧中调用一次。添加以下代码，然后我们将详细检查它。如果我们跟随着之前的八个函数，并且记得我们是如何为
    Timber!!! 项目动画云和蜜蜂，以及为 Pong 项目动画蝙蝠和球的，我们可能会理解以下代码的大部分内容：
- en: '[PRE12]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The first portion of the previous code moves the player sprite. The four `if`
    statements check which of the movement-related Boolean variables (`m_LeftPressed`,
    `m_RightPressed`, `m_UpPressed`, or `m_DownPressed`) are true and changes `m_Position.x`
    and `m_Position.y` accordingly. The same formula, from the previous two projects,
    to calculate the amount to move is also used:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的前一部分移动玩家精灵。四个 `if` 语句检查哪些与移动相关的布尔变量（`m_LeftPressed`、`m_RightPressed`、`m_UpPressed`
    或 `m_DownPressed`）为真，并相应地更改 `m_Position.x` 和 `m_Position.y`。同样，从之前的两个项目中使用的公式来计算移动量也被使用：
- en: '**position (+ or -) speed * elapsed time.**'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**位置（+ 或 -）速度 * 经过的时间**。'
- en: After these four `if` statements, `m_Sprite.setPosition` is called and `m_Position`
    is passed in. The sprite has now been adjusted by exactly the right amount for
    that one frame.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这四个 `if` 语句之后，调用 `m_Sprite.setPosition` 并传入 `m_Position`。精灵现在已经调整得恰到好处，以适应那一帧。
- en: 'The next four `if` statements check whether `m_Position.x` or `m_Position.y`
    is beyond any of the edges of the current arena. Remember that the confines of
    the current arena were stored in `m_Arena`, in the `spawn` function. Let''s look
    at the first one of these four `if` statements in order to understand them all:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的四个 `if` 语句检查 `m_Position.x` 或 `m_Position.y` 是否超出了当前竞技场的任何边缘。记住，当前竞技场的范围存储在
    `m_Arena` 的 `spawn` 函数中。让我们看看这四个 `if` 语句中的第一个，以便理解它们：
- en: '[PRE13]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The previous code tests to see whether `m_position.x` is greater than `m_Arena.width`,
    minus the size of a tile (`m_TileSize`). As we will see when we create the background
    graphics, this calculation will detect the player straying into the wall.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码测试 `m_position.x` 是否大于 `m_Arena.width` 减去瓦片的大小（`m_TileSize`）。当我们创建背景图形时，这个计算将检测玩家是否越界到墙壁。
- en: When the `if` statement is true, the `m_Arena.width - m_TileSize` calculation
    is used to initialize `m_Position.x`. This means that the center of the player
    graphic will never be able to stray past the left-hand edge of the right-hand
    wall.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `if` 语句为真时，使用 `m_Arena.width - m_TileSize` 的计算来初始化 `m_Position.x`。这意味着玩家图形的中心永远不会超出右侧墙壁的左侧边缘。
- en: The next three `if` statements, which follow the one we have just discussed,
    do the same thing but for the other three walls.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的三个 `if` 语句，紧随我们刚刚讨论的那个语句之后，做的是同样的事情，但针对其他三面墙壁。
- en: The last two lines in the preceding code calculate and set the angle that the
    player sprite is rotated to (that is, facing). This line of code might look a
    little complex, but it is simply using the position of the crosshair (`mousePosition.x`
    and `mousePosition.y`) and the center of the screen (`m_Resolution.x` and `m_Resolution.y`)
    in a tried-and-tested trigonometric function.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的最后两行计算并设置玩家精灵旋转到的角度（即面向）。这一行代码可能看起来有点复杂，但它只是使用准星的位置（`mousePosition.x` 和
    `mousePosition.y`）以及屏幕中心（`m_Resolution.x` 和 `m_Resolution.y`）在一个经过验证的三角函数中。
- en: How `atan` uses these coordinates along with Pi (3.141) is quite complicated,
    and that is why it is wrapped up in a handy function for us.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`atan` 如何使用这些坐标以及 Pi（3.141）相当复杂，这就是为什么它被封装在一个方便的函数中供我们使用。'
- en: Important note
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'If you want to explore trigonometric functions in more detail, you can do so
    here: [http://www.cplusplus.com/reference/cmath/](http://www.cplusplus.com/reference/cmath/).'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想更详细地探索三角函数，可以在这里进行：[http://www.cplusplus.com/reference/cmath/](http://www.cplusplus.com/reference/cmath/)。
- en: The last three functions we will add for the `Player` class make the player
    20% faster, increase the player's health by 20%, and increase the player's health
    by the amount passed in, respectively.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为 `Player` 类添加的最后三个函数使玩家速度提高 20%，增加玩家生命值 20%，以及分别增加传入的生命值。
- en: 'Add the following code at the end of the `Player.cpp` file, and then we will
    take a closer look at it:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Player.cpp` 文件的末尾添加以下代码，然后我们将更仔细地查看它：
- en: '[PRE14]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code, the `upgradeSpeed()` and `upgradeHealth()` functions
    increase the value stored in `m_Speed` and `m_MaxHealth`, respectively. These
    values are increased by 20% by multiplying the starting values by .2 and adding
    them to the current values. These functions will be called from the `main` function
    when the player is choosing what attributes of their character they wish to improve
    (that is, level up) between levels.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: The `increaseHealthLevel()` function takes an `int` value from `main` in the
    `amount` parameter. This `int` value will be provided by a class called `Pickup`,
    which we will write in [*Chapter 11*](B14278_11_Final_AG_ePub.xhtml#_idTextAnchor249)*,
    Collision Detection, Pickups, and Bullets*. The `m_Health` member variable is
    increased by the passed-in value. However, there is a catch for the player. The
    `if` statement checks whether `m_Health` has exceeded `m_MaxHealth` and, if it
    has, sets it to `m_MaxHealth`. This means the player cannot simply gain infinite
    health from pick-ups. Instead, they must carefully balance the upgrades they choose
    between levels.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Of course, our `Player` class can't do anything until we instantiate it and
    put it to work in our game loop. Before we do that, let's look at the concept
    of a game camera.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the game camera with SFML View
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In my opinion, the SFML `View` class is one of the neatest classes. After finishing
    this book, when we make games without using a media/gaming library, we will really
    notice the absence of `View`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: The `View` class allows us to consider our game as taking place in its own world,
    with its own properties. What do I mean? Well, when we create a game, we are usually
    trying to create a virtual world. That virtual world rarely, if ever, is measured
    in pixels, and rarely, if ever, will that world be the same number of pixels as
    the player's monitor. We need a way to abstract the virtual world we are building
    so that it can be of whatever size or shape we like.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Another way to think of SFML `View` is as a camera through which the player
    views a part of our virtual world. Most games will have more than one camera/view
    of the world.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider a split screen game where two players can be in different
    parts of the world at the same time.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Or, consider a game where there is a small area of the screen that represents
    the entire game world, but at a very high level/zoomed out, like a mini map.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Even if our games are much simpler than the previous two examples and don't
    need split screens or mini maps, we will likely want to create a world that is
    bigger than the screen it is being played on. This is, of course, the case with
    Zombie Arena.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, if we are constantly moving the game camera around to show different
    parts of the virtual world (usually to track the player), what happens to the
    HUD? If we draw the score and other onscreen HUD information and then we scroll
    the world around to follow the player, the score would move relative to that camera.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: The SFML `View` class easily enables all these of features and solves this problem
    with very straightforward code. The trick is to create an instance of `View` for
    every camera – perhaps a `View` instance for the mini map, a `View` instance for
    the scrolling game world, and then a `View` instance for the HUD.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: SFML的`View`类很容易实现所有这些功能，并用非常直接的代码解决了这个问题。诀窍是为每个相机创建一个`View`实例——可能是一个用于迷你地图的`View`实例，一个用于滚动游戏世界的`View`实例，然后是一个用于HUD的`View`实例。
- en: The instances of `View` can be moved around, sized, and positioned as required.
    So, the main `View` instance following the game can track the player, the mini-map
    view can remain in a fixed, zoomed-out small corner of the screen, and the HUD
    can overlay the entire screen and never move, despite the fact the main `View`
    instance could go wherever the player goes.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`View`实例可以根据需要移动、调整大小和定位。因此，跟随游戏的`main`视图可以跟踪玩家，迷你地图视图可以保持在屏幕的一个固定、缩小的角落，而HUD可以覆盖整个屏幕且不会移动，尽管主`View`实例可以跟随玩家移动。'
- en: Let's look at some code using a few instances of `View`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用几个`View`实例的一些代码。
- en: Tip
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: This code is being used to introduce the `View` class. Don't add this code to
    the Zombie Arena project.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码被用来介绍`View`类。不要将此代码添加到僵尸竞技场项目中。
- en: 'Create and initialize a few instances of `View`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 创建并初始化几个`View`实例：
- en: '[PRE15]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The previous code creates two `View` objects that fill a 1920 x 1080 monitor.
    Now, we can do some magic with `mainView` while leaving `hudView` completely alone:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码创建了两个填充1920 x 1080监视器的`View`对象。现在，我们可以用`mainView`做一些魔法，同时完全不动`hudView`：
- en: '[PRE16]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When we manipulate the properties of a `View` instance, we do so like this.
    When we draw sprites, text, or other objects to a view, we must specifically **set**
    the view as the current view for the window:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们操作`View`实例的属性时，我们这样做。当我们向视图中绘制精灵、文本或其他对象时，我们必须明确地将视图**设置为**当前窗口的视图：
- en: '[PRE17]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, we can draw everything we want into that view:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将我们想要绘制的一切都绘制到这个视图中：
- en: '[PRE18]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The player might be at any coordinate whatsoever; it doesn't matter because
    `mainView` is centered around the graphic.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家的坐标可能是什么都行；这无关紧要，因为`mainView`是围绕图形居中的。
- en: 'Now, we can draw the HUD into `hudView`. Note that just like we draw individual
    elements (background, game objects, text, and so on) in layers from back to front,
    we also draw views from back to front as well. Hence, a HUD is drawn after the
    main game scene:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将HUD绘制到`hudView`中。注意，就像我们从后往前在层中绘制单个元素（背景、游戏对象、文本等）一样，我们也会从后往前绘制视图。因此，HUD是在主游戏场景之后绘制的：
- en: '[PRE19]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, we can draw/show the window and all its views for the current frame
    in the usual way:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以以通常的方式绘制/显示窗口及其当前帧的所有视图：
- en: '[PRE20]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Tip
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'If you want to take your understanding of SFML `View` further than is necessary
    for this project, including how to achieve split screens and mini maps, then the
    best guide on the web is on the official SFML website: [https://www.sfml-dev.org/tutorials/2.5/graphics-view.php](https://www.sfml-dev.org/tutorials/2.5/graphics-view.php).'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将你对SFML `View`的理解进一步扩展到这个项目所必需的范围之外，包括如何实现分屏和迷你地图，那么网上最好的指南是官方SFML网站：[https://www.sfml-dev.org/tutorials/2.5/graphics-view.php](https://www.sfml-dev.org/tutorials/2.5/graphics-view.php)。
- en: Now that we have learned about `View`, we can start coding the Zombie Arena
    `main` function and use our first `View` instance for real. In [*Chapter 12*](B14278_12_Final_AG_ePub.xhtml#_idTextAnchor272),
    *Layering Views and Implementing the HUD*, we will introduce a second instance
    of `View` for the HUD and layer it over the top of the main `View` instance.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了`View`，我们可以开始编写僵尸竞技场`main`函数，并真正使用我们的第一个`View`实例。在[*第12章*](B14278_12_Final_AG_ePub.xhtml#_idTextAnchor272)，*分层视图和实现HUD*，我们将介绍`View`的第二个实例用于HUD，并将其叠加在主`View`实例之上。
- en: Starting the Zombie Arena game engine
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动僵尸竞技场游戏引擎
- en: In this game, we will need a slightly upgraded game engine in `main`. We will
    have an enumeration called `state`, which will track what the current state of
    the game is. Then, throughout `main`, we can wrap parts of our code so that different
    things happen in different states.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个游戏中，我们在`main`中需要一个稍微升级的游戏引擎。我们将有一个名为`state`的枚举，它将跟踪游戏当前的状态。然后，在`main`的整个过程中，我们可以将我们的代码部分包裹起来，以便在不同的状态下发生不同的事情。
- en: When we created the project, Visual Studio created a file for us called `ZombieArena.cpp`.
    This will be the file that contains our `main` function and the code that instantiates
    and controls all our classes.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建项目时，Visual Studio为我们创建了一个名为`ZombieArena.cpp`的文件。这个文件将包含我们的`main`函数以及实例化和控制所有类的代码。
- en: We begin with the now-familiar `main` function and some include directives.
    Note the addition of an include directive for the `Player` class.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从现在熟悉的`main`函数和一些包含指令开始。注意添加了`Player`类的包含指令。
- en: 'Add the following code to the `ZombieArena.cpp` file:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`ZombieArena.cpp`文件中：
- en: '[PRE21]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The previous code has nothing new in it except that the `#include "Player.h"`
    line means we can now use the `Player` class within our code.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码中没有新内容，除了`#include "Player.h"`这一行意味着我们现在可以在代码中使用`Player`类。
- en: Let's flesh out some more of our game engine. The following code does quite
    a lot. Be sure to read the comments when you add the code to get an idea of what
    is going on. We will then go through it in more detail.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步完善我们的游戏引擎。以下代码做了很多事情。当你添加代码时，务必阅读注释，以了解正在发生的事情。然后我们将更详细地讨论它。
- en: 'Add the following highlighted code at the start of the `main` function:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数的开始处添加以下高亮代码：
- en: '[PRE22]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s run through each section of all the code that we entered. Just inside
    the `main` function, we have the following code:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个检查我们输入的所有代码的每个部分。在`main`函数内部，我们有以下代码：
- en: '[PRE23]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The previous code creates a new enumeration class called `State`. Then, the
    code creates an instance of the `State` class called `state`. The `state` enumeration
    can now be one of four values, as defined in the declaration. Those values are
    `PAUSED`, `LEVELING_UP`, `GAME_OVER`, and `PLAYING`. These four values will be
    just what we need for keeping track and responding to the different states that
    the game can be in at any given time. Note that it is not possible for `state`
    to hold more than one value at a time.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码创建了一个名为`State`的新枚举类。然后，代码创建了一个名为`state`的`State`类实例。现在，`state`枚举可以是以下四个值之一，如声明中定义的那样。这些值是`PAUSED`、`LEVELING_UP`、`GAME_OVER`和`PLAYING`。这四个值正是我们跟踪和响应游戏在任何给定时间可能处于的不同状态所需要的。请注意，`state`一次不可能持有多个值。
- en: 'Immediately after, we added the following code:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 紧接着，我们添加了以下代码：
- en: '[PRE24]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The previous code declares a `Vector2f` instance called `resolution`. We initialize
    the two member variables of `resolution` (`x` and `y`) by calling the `VideoMode::getDesktopMode`
    function for both `width` and `height`. The `resolution` object now holds the
    resolution of the monitor on which the game is running. The final line of code
    creates a new `RenderWindow` instance called `window` using the appropriate resolution.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码声明了一个名为`resolution`的`Vector2f`实例。我们通过调用`VideoMode::getDesktopMode`函数来初始化`resolution`的两个成员变量（`x`和`y`），用于`width`和`height`。现在，`resolution`对象持有游戏运行在的监视器的分辨率。最后一行代码使用适当的分辨率创建了一个名为`window`的新`RenderWindow`实例。
- en: 'The following code creates an SFML `View` object. The view is positioned (initially)
    at the exact coordinates of the pixels of the monitor. If we were to use this
    `View` to do some drawing in this current position, it would be the same as drawing
    to a window without a view. However, we will eventually start to move this view
    to focus on the parts of our game world that the player needs to see. Then, when
    we start to use a second `View` instance, which remains fixed (for the HUD), we
    will see how this `View` instance can track the action while the other remains
    static to display the HUD:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码创建了一个SFML `View`对象。视图最初位于监视器像素的精确坐标。如果我们使用这个`View`在这个当前位置进行绘图，它将等同于在没有视图的窗口中绘图。然而，我们最终将开始移动这个视图，以聚焦于玩家需要看到的游戏世界的部分。然后，当我们开始使用第二个`View`实例（用于HUD并保持固定）时，我们将看到这个`View`实例如何跟踪动作，而另一个保持静态以显示HUD：
- en: '[PRE25]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, we created a `Clock` instance to do our timing and a `Time` object called
    `gameTimeTotal` that will keep a running total of the game time that has elapsed.
    As the project progresses, we will also introduce more variables and objects to
    handle timing:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建了一个`Clock`实例来进行计时，并创建了一个名为`gameTimeTotal`的`Time`对象，它将记录已经过去的时间。随着项目的进展，我们还将引入更多的变量和对象来处理计时：
- en: '[PRE26]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following code declares two vectors: one holding two `float` variables,
    called `mouseWorldPosition`, and one holding two integers, called `mouseScreenPosition`.
    The mouse pointer is something of an anomaly because it exists in two different
    coordinate spaces. We could think of these as parallel universes if we like. Firstly,
    as the player moves around the world, we will need to keep track of where the
    crosshair is in that world. These will be floating-point coordinates and will
    be stored in `mouseWorldCoordinates`. Of course, the actual pixel coordinates
    of the monitor itself never change. They will always be 0,0 to horizontal resolution
    -1, vertical resolution -1\. We will track the mouse pointer position that is
    relative to this coordinate space using the integers stored in `mouseScreenPosition`:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码声明了两个向量：一个包含两个`float`变量，称为`mouseWorldPosition`，另一个包含两个整数，称为`mouseScreenPosition`。鼠标指针有点特殊，因为它存在于两个不同的坐标空间中。如果我们愿意，可以将其视为平行宇宙。首先，当玩家在世界中移动时，我们需要跟踪准星在那个世界中的位置。这些将是浮点坐标，并将存储在`mouseWorldCoordinates`中。当然，显示器本身的实际像素坐标永远不会改变。它们始终是0,0到水平分辨率-1，垂直分辨率-1。我们将使用存储在`mouseScreenPosition`中的整数来跟踪相对于此坐标空间的鼠标指针位置：
- en: '[PRE27]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, we get to use our `Player` class. This line of code will cause the
    constructor function (`Player::Player`) to execute. Refer to `Player.cpp` if you
    want to refresh your memory about this function:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们开始使用我们的`Player`类。这一行代码将导致构造函数（`Player::Player`）执行。如果您想刷新对这个函数的记忆，请参考`Player.cpp`：
- en: '[PRE28]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This `IntRect` object will hold starting horizontal and vertical coordinates,
    as well as a width and a height. Once initialized, we will be able to access the
    size and location details of the current arena with code such as `arena.left`,
    `arena.top`, `arena.width`, and `arena.height`:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`IntRect`对象将包含起始水平和垂直坐标，以及宽度和高度。一旦初始化，我们将能够通过代码如`arena.left`、`arena.top`、`arena.width`和`arena.height`来访问当前竞技场的尺寸和位置详情：
- en: '[PRE29]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The last part of the code that we added previously is, of course, our game
    loop:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前添加的代码的最后部分当然是我们的游戏循环：
- en: '[PRE30]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We have probably noticed that the code is getting quite long. We'll talk about
    this inconvenience in the following section.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能已经注意到代码变得相当长。我们将在下一节讨论这个不便之处。
- en: Managing the code files
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理代码文件
- en: One of the advantages of abstraction using classes and functions is that the
    length (number of lines) of our code files can be reduced. Even though we will
    be using more than a dozen code files for this project, the length of the code
    in `ZombieArena.cpp` will still get a little unwieldy toward the end. In the final
    project, Space Invaders++, we will look at even more ways to abstract and manage
    our code.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类和函数进行抽象的一个优点是，我们的代码文件长度（行数）可以减少。尽管我们将为这个项目使用十几个代码文件，但`ZombieArena.cpp`中的代码长度在项目结束时仍会变得有点难以管理。在最终项目Space
    Invaders++中，我们将探讨更多抽象和管理代码的方法。
- en: 'For now, use this tip to keep things manageable. Notice that on the left-hand
    side of the code editor in Visual Studio, there are several **+** and **-** signs,
    one of which is shown in this diagram:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，使用这个技巧来保持事情的可管理性。注意，在Visual Studio代码编辑器的左侧，有几个**+**和**-**符号，其中一个在本图中显示：
- en: '![](img/B14278_08_04.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_08_04.jpg)'
- en: There will be one sign for each block (`if`, `while`, `for`, and so on) of the
    code. You can expand and collapse these blocks by clicking on the **+** and **-**
    signs. I recommend keeping all the code not currently under discussion collapsed.
    This will make things much clearer.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 每个代码块（例如`if`、`while`、`for`等）将有一个对应的标记。您可以通过点击**+**和**-**符号来展开和折叠这些块。我建议将所有当前未讨论的代码块都折叠起来。这将使事情更加清晰。
- en: 'Furthermore, we can create our own collapsible blocks. I suggest making a collapsible
    block out of all the code before the start of the main game loop. To do so, highlight
    the code and then *right-click* and choose **Outlining** | **Hide Selection**,
    as shown in the following screenshot:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以创建自己的可折叠块。我建议将主游戏循环开始之前的所有代码制作成一个可折叠块。要做到这一点，请突出显示代码，然后*右键单击*并选择**大纲**|**隐藏选择**，如图所示：
- en: '![](img/B14278_08_05.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14278_08_05.jpg)'
- en: 'Now, you can click the **-** and **+** signs to expand and collapse the block.
    Each time we add code before the main game loop (and that will be quite often),
    you can expand the code, add the new lines, and then collapse it again. The following
    screenshot shows what the code looks like when it is collapsed:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以点击 **-** 和 **+** 符号来展开和折叠块。每次我们在主游戏循环之前添加代码（这将会很频繁），您都可以展开代码，添加新行，然后再将其折叠。以下截图显示了代码折叠时的样子：
- en: '![](img/B14278_08_06.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14278_08_06.jpg)'
- en: This is much more manageable than it was before. Now, we can make a start with
    the main game loop.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这比之前要容易管理得多。现在，我们可以开始编写主游戏循环。
- en: Starting to code the main game loop
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始编写主游戏循环
- en: As you can see, the last part of the preceding code is the game loop (`while
    (window.isOpen()){}`). We will turn our attention to this now. Specifically, we
    will be coding the input handling section of the game loop.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，前面代码的最后部分是游戏循环（`while (window.isOpen()){}`）。我们现在将关注这个部分。具体来说，我们将编写游戏循环的输入处理部分。
- en: The code that we will be adding is quite long. There is nothing complicated
    about it, though, and we will examine it all in a moment.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要添加的代码相当长。尽管如此，它并没有什么复杂的地方，我们稍后将会详细检查它。
- en: 'Add the following highlighted code to the game loop:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下高亮显示的代码添加到游戏循环中：
- en: '[PRE31]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the preceding code, we instantiate an object of the `Event` type. We will
    use `event`, like we did in the previous projects, to poll for system events.
    To do so, we wrap the rest of the code from the previous block in a `while` loop
    with the `window.pollEvent(event)` condition. This will keep looping each frame
    until there are no more events to process.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们实例化了一个 `Event` 类型的对象。我们将像在之前的项目中一样使用 `event` 来轮询系统事件。为此，我们将上一个代码块中的其余代码包裹在一个带有
    `window.pollEvent(event)` 条件的 `while` 循环中。这将保持循环，直到没有更多事件需要处理。
- en: Inside this `while` loop, we handle the events we are interested in. First,
    we test for `Event::KeyPressed` events. If the *Return* key is pressed while the
    game is in the `PLAYING` state, then we switch `state` to `PAUSED`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 `while` 循环内部，我们处理我们感兴趣的的事件。首先，我们测试 `Event::KeyPressed` 事件。如果游戏处于 `PLAYING`
    状态时按下了 `Return` 键，那么我们将 `state` 切换到 `PAUSED`。
- en: If the *Return* key is pressed while the game is in the `PAUSED` state, then
    we switch `state` to `PLAYING` and restart the `clock` object. The reason we restart
    `clock` after switching from `PAUSED` to `PLAYING` is because, while the game
    is paused, the elapsed time still accumulates. If we didn't restart the clock,
    all our objects would update their locations as if the frame had just taken a
    very long time. This will become more apparent as we flesh out the rest of the
    code in this file.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在游戏处于 `PAUSED` 状态时按下了 `Return` 键，那么我们将 `state` 切换到 `PLAYING` 并重新启动 `clock`
    对象。我们在从 `PAUSED` 切换到 `PLAYING` 后重新启动 `clock` 的原因是，当游戏暂停时，经过的时间仍然会累积。如果我们不重新启动时钟，所有对象都会更新它们的位置，就像帧刚刚花费了很长时间一样。随着我们在文件中完善其余的代码，这一点将变得更加明显。
- en: We then have an `else if` block to test whether the `Return` key was pressed
    while the game was in the `GAME_OVER` state. If it was, then `state` is changed
    to `LEVELING_UP`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有一个 `else if` 块来测试在游戏处于 `GAME_OVER` 状态时是否按下了 `Return` 键。如果是的话，那么 `state`
    将被更改为 `LEVELING_UP`。
- en: Important note
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Note that the `GAME_OVER` state is the state where the home screen is displayed.
    So, the `GAME_OVER` state is the state after the player has just died and when
    the player first runs the game. The first thing that the player gets to do each
    game is pick an attribute to improve (that is, level up).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`GAME_OVER` 状态是显示主页面的状态。因此，`GAME_OVER` 状态是在玩家刚刚死亡以及玩家第一次运行游戏后的状态。玩家在每一局游戏中首先要做的事情就是选择一个属性来提升（即升级）。
- en: In the previous code, there is a final `if` condition to test whether the state
    is equal to `PLAYING`. This `if` block is empty and we will add code to it throughout
    the project.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，有一个最终的 `if` 条件来测试状态是否等于 `PLAYING`。这个 `if` 块是空的，我们将在整个项目中向其中添加代码。
- en: Tip
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: We will add code to lots of different parts of this file throughout the project.
    Therefore, it is worthwhile taking the time to understand the different states
    our game can be in and where we handle them. It will also be very beneficial to
    collapse and expand the different `if`, `else`, and `while` blocks as and when
    appropriate.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在整个项目过程中向这个文件的许多不同部分添加代码。因此，花时间了解我们的游戏可能处于的不同状态以及我们如何处理这些状态是非常有价值的。在适当的时候折叠和展开不同的
    `if`、`else` 和 `while` 块也将非常有好处。
- en: Spend some time thoroughly familiarizing yourself with the `while`, `if`, and
    `else if` blocks we have just coded. We will be referring to them regularly.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 花些时间彻底熟悉我们刚刚编写的`while`、`if`和`else if`块。我们将会经常引用它们。
- en: 'Next, immediately after the previous code and still inside the game loop, which
    is still dealing with handling input, add the following highlighted code. Note
    the existing code (not highlighted) that shows exactly where the new (highlighted)
    code goes:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在之前的代码之后，仍然在游戏循环内，仍然在处理输入，添加以下突出显示的代码。注意现有的代码（未突出显示），它显示了新（突出显示）代码的确切位置：
- en: '[PRE32]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding code, we first test to see whether the player has pressed the
    *Escape* key. If it is pressed, the game window will be closed.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们首先测试玩家是否按下了*Escape*键。如果按下，游戏窗口将被关闭。
- en: Next, within one big `if(state == State::PLAYING)` block, we check each of the
    *WASD* keys in turn. If a key is pressed, we call the appropriate `player.move...`
    function. If it is not, we call the related `player.stop...` function.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在一个大的`if(state == State::PLAYING)`块内，我们依次检查每个*WASD*键。如果按键被按下，我们调用相应的`player.move...`函数。如果没有，我们调用相关的`player.stop...`函数。
- en: This code ensures that, in each frame, the player object will be updated with
    the *WASD* keys that are pressed and those that are not. The `player.move...`
    and `player.stop...` functions store the information in the member Boolean variables
    (`m_LeftPressed`, `m_RightPressed`, `m_UpPressed`, and `m_DownPressed`). The `Player`
    class then responds to the value of these Booleans, in each frame, in the `player.update`
    function, which we will call in the update section of the game loop.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码确保在每个帧中，玩家对象都会根据按下的*WASD*键和未按下的键进行更新。`player.move...`和`player.stop...`函数将信息存储在成员布尔变量中（`m_LeftPressed`、`m_RightPressed`、`m_UpPressed`和`m_DownPressed`）。`Player`类然后在每个帧的`player.update`函数中响应这些布尔值，我们将在游戏循环的更新部分调用它。
- en: 'Now, we can handle the keyboard input to allow the player to level up at the
    start of each game and in-between each wave. Add and study the following highlighted
    code and then we will discuss it:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以处理键盘输入，允许玩家在每场游戏的开始和每波之间升级。添加并学习以下突出显示的代码，然后我们将讨论它：
- en: '[PRE33]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the preceding code, which is all wrapped in a test to see whether the current
    value of `state` is equal to `LEVELING_UP`, we handle the keyboard keys *1*, *2*,
    *3*, *4*, *5*, and *6*. In the `if` block for each, we simply set `state` to `State::PLAYING`.
    We will add some code to deal with each level up option later in [*Chapter 13*](B14278_13_Final_AG_ePub.xhtml#_idTextAnchor279)*,
    Sound Effects, File I/O, and Finishing the Game*.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，它全部包含在一个测试中，以查看当前`state`的值是否等于`LEVELING_UP`，我们处理键盘键*1*、*2*、*3*、*4*、*5*和*6*。在每一个`if`块中，我们只是将`state`设置为`State::PLAYING`。我们将在[*第13章*](B14278_13_Final_AG_ePub.xhtml#_idTextAnchor279)*，声音效果、文件I/O和完成游戏*中稍后添加一些代码来处理每个升级选项。
- en: 'This code does the following things:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码执行以下操作：
- en: If the `state` is equal to `LEVELING_UP`, wait for either the *1*, *2*, *3*,
    *4*, *5*, or *6* keys to be pressed.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`state`等于`LEVELING_UP`，等待按下*1*、*2*、*3*、*4*、*5*或*6*键。
- en: When pressed, change `state` to `PLAYING`.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下时，将`state`更改为`PLAYING`。
- en: When the state changes, still within the `if (state == State::LEVELING_UP)`
    block, the nested `if(state == State::PLAYING)` block will run.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当状态改变时，仍然在`if (state == State::LEVELING_UP)`块内，嵌套的`if(state == State::PLAYING)`块将会执行。
- en: Within this block, we set the location and size of `arena`, set the `tileSize`
    to `50`, pass all the information to `player.spawn`, and call `clock.restart`.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此块中，我们设置`arena`的位置和大小，将`tileSize`设置为`50`，将所有信息传递给`player.spawn`，并调用`clock.restart`。
- en: Now, we have an actual spawned player object that is aware of its environment
    and can respond to key presses. We can now update the scene on each pass through
    the loop.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个实际生成的玩家对象，它了解其环境并能对按键做出响应。我们现在可以在循环的每次传递中更新场景。
- en: 'Be sure to neatly collapse the code from the input handling part of the game
    loop since we are done with that for now. The following code is in the updating
    part of the game loop. Add and study the following highlighted code and then we
    can discuss it:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要将游戏循环中输入处理部分的代码整洁地折叠起来，因为我们现在已经完成了这部分。以下代码是游戏循环的更新部分。添加并学习以下突出显示的代码，然后我们可以讨论它：
- en: '[PRE34]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: First, note that the previous code is wrapped in a test to make sure the game
    is in the `PLAYING` state. We don't want this code to run if the game has been
    paused, it has ended, or if the player is choosing what to level up.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请注意，上一段代码被包裹在一个测试中，以确保游戏处于`PLAYING`状态。我们不希望在这段代码在游戏暂停、结束或玩家选择升级时运行。
- en: 'First, we restart the clock and store the time that the previous frame took
    in the `dt` variable:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们重新启动时钟并将上一帧所花费的时间存储在`dt`变量中：
- en: '[PRE35]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, we add the time that the previous frame took to the accumulated time
    the game has been running for, as held by `gameTimeTotal`:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将上一帧所花费的时间添加到游戏运行的总累积时间`gameTimeTotal`中：
- en: '[PRE36]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now, we initialize a `float` variable called `dtAsSeconds` with the value returned
    by the `dt.AsSeconds` function. For most frames, this will be a fraction of one.
    This is perfect for passing into the `player.update` function to be used to calculate
    how much to move the player sprite.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们使用`dt.AsSeconds`函数返回的值初始化一个名为`dtAsSeconds`的`float`变量。对于大多数帧，这将是一个分数。这对于传递给`player.update`函数以计算移动玩家精灵的量是完美的。
- en: Now, we can initialize `mouseScreenPosition` using the `MOUSE::getPosition`
    function.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`MOUSE::getPosition`函数初始化`mouseScreenPosition`。
- en: Important note
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You might be wondering about the slightly unusual syntax for getting the position
    of the mouse. This is called a **static function**. If we define a function in
    a class with the static keyword, we can call that function using the class name
    and without an instance of the class. C++ OOP has lots of quirks and rules like
    this. We will see more as we progress.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道获取鼠标位置略微不寻常的语法。这被称为**静态函数**。如果我们使用`static`关键字在类中定义一个函数，我们可以使用类名调用该函数，而不需要类的实例。C++面向对象编程有很多这样的怪癖和规则。随着我们的进展，我们将看到更多。
- en: We then initialize `mouseWorldPosition` using the SFML `mapPixelToCoords` function
    on `window`. We discussed this function when talking about the `View` class earlier
    in this chapter.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`window`上的SFML `mapPixelToCoords`函数初始化`mouseWorldPosition`。我们在本章前面讨论了该函数。
- en: At this point, we are now able to call `player.update` and pass in `dtAsSeconds`
    and the position of the mouse, as is required.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们现在能够调用`player.update`并传入`dtAsSeconds`和鼠标的位置，正如所需的那样。
- en: We store the player's new center in a `Vector2f` instance called `playerPosition`.
    At the moment, this is unused, but we will have a use for this later in the project.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将玩家的新中心存储在一个名为`playerPosition`的`Vector2f`实例中。目前，这个变量尚未使用，但我们在项目后期将会有所用途。
- en: We can then center the view around the center of the player's up-to-date position
    with `mainView.setCenter(player.getCenter())`.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用`mainView.setCenter(player.getCenter())`将视图中心定位在玩家最新位置的中央。
- en: 'We are now able to draw the player to the screen. Add the following highlighted
    code, which splits the draw section of the main game loop into different states:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在能够将玩家绘制到屏幕上。添加以下突出显示的代码，将主游戏循环的绘制部分拆分为不同的状态：
- en: '[PRE37]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Within the `if(state == State::PLAYING)` section of the previous code, we clear
    the screen, set the view of the window to `mainView`, and then draw the player
    sprite with `window.draw(player.getSprite())`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一段代码的`if(state == State::PLAYING)`部分中，我们清除屏幕，将窗口的视图设置为`mainView`，然后使用`window.draw(player.getSprite())`绘制玩家精灵。
- en: After all the different states have been handled, the code shows the scene in
    the usual manner with `window.display();`.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完所有不同的状态后，代码以通常的方式使用`window.display();`显示场景。
- en: You can run the game and see our player character spin around in response to
    moving the mouse.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以运行游戏，并看到我们的玩家角色在鼠标移动时旋转。
- en: Tip
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: When you run the game, you need to press *Enter* to start the game, and then
    select a number from *1* to *6* to simulate choosing an upgrade option. Then,
    the game will start.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行游戏时，你需要按*Enter*键开始游戏，然后从*1*到*6*选择一个数字来模拟选择升级选项。然后，游戏将开始。
- en: 'You can also move the player around within the (empty) 500 x 500 pixel arena.
    You can see our lonely player in the center of the screen, as shown here:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在（空白的）500 x 500像素的竞技场内移动玩家。你可以看到屏幕中央的孤独玩家，如图所示：
- en: '![](img/B14278_08_07.jpg)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B14278_08_07.jpg)'
- en: You can't, however, get any sense of movement because we haven't implemented
    the background. We will do so in the next chapter.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你无法感受到任何移动的感觉，因为我们还没有实现背景。我们将在下一章这样做。
- en: Summary
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Phew! That was a long one. We have done a lot in this chapter: we built our
    first class for the Zombie Arena project, `Player`, and put it to use in the game
    loop. We also learned about and used an instance of the `View` class, although
    we haven''t explored the benefits this gives us just yet.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 呼！这一章内容很长。我们在本章做了很多工作：我们为Zombie Arena项目构建了第一个类`Player`，并在游戏循环中使用了它。我们还学习了并使用了`View`类的一个实例，尽管我们还没有探索这给我们带来的好处。
- en: In the next chapter, we will build our arena background by exploring what sprite
    sheets are. We will also learn about C++ **references**, which allow us to manipulate
    variables, even when they are out of scope (that is, in another function).
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过探索精灵图集（sprite sheets）来构建我们的竞技场背景。我们还将学习关于C++ **引用**的知识，这些引用允许我们在变量超出作用域（即在另一个函数中）时对其进行操作。
- en: FAQ
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见问题解答
- en: Q) I noticed we have coded quite a few functions of the `Player` class that
    we don't use. Why is this?
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: Q) 我注意到我们为`Player`类编写了很多我们没有使用的函数。为什么会有这种情况？
- en: A) Rather than keep coming back to the `Player` class, we have added all the
    code that we will need throughout the project. By the end of [*Chapter 13*](B14278_13_Final_AG_ePub.xhtml#_idTextAnchor279),
    *Sound Effects, File I/O, and Finishing the Game*, we will have made full use
    of all of these functions.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: A) 我们不是反复回到`Player`类，而是将整个项目所需的所有代码都添加进来了。到[*第13章*](B14278_13_Final_AG_ePub.xhtml#_idTextAnchor279)“音效、文件输入/输出和完成游戏”结束时，我们将充分利用所有这些功能。
