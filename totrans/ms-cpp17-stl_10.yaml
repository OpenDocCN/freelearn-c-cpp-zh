- en: Regular Expressions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正则表达式
- en: In the previous chapter, we learned all about formatted input and output in
    C++. We saw that there are good solutions for formatted output--as long as you
    make sure you're in the `C` locale--but that despite the many approaches to input
    parsing, even the simple task of parsing an `int` out of a string can be quite
    difficult. (Recall that of the two most foolproof methods, `std::stoi(x)` requires
    converting `x` to a heap-allocated `std::string`, and the verbose `std::from_chars(x.begin(),
    x.end(), &value, 10)` is lagging the rest of C++17 in vendor adoption.) The fiddliest
    part of parsing numbers is figuring out what to do with the part of the input
    that *isn't* numeric!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了 C++ 中的格式化输入和输出。我们了解到，只要确保你处于 `C` 位置，格式化输出就有很好的解决方案，但尽管有众多输入解析方法，即使是解析字符串中的
    `int` 这样的简单任务也可能相当困难。（回想一下，在两种最保险的方法中，`std::stoi(x)` 需要将 `x` 转换为堆分配的 `std::string`，而冗长的
    `std::from_chars(x.begin(), x.end(), &value, 10)` 在 C++17 的供应商采用方面落后于其他部分。）解析数字中最棘手的部分是确定如何处理输入中
    *不是* 数字的部分！
- en: 'Parsing gets easier if you can split it into two subtasks: First, figure out
    exactly how many bytes of the input correspond to one "input item" (this is called
    *lexing*); and second, parse the value of that item, with some error recovery
    in the case that the item''s value is out of range or otherwise nonsensical. If
    we apply this approach to integer input, *lexing* corresponds to finding the longest
    initial sequence of digits in the input, and *parsing* corresponds to computing
    the numeric value of that sequence in base 10.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可以将解析任务分解为两个子任务，解析会变得更容易：首先，确定输入中对应于一个“输入项”的确切字节数（这被称为 *词法分析*）；其次，解析该项的值，如果该项的值超出范围或无意义，则进行一些错误恢复。如果我们将这种方法应用于整数输入，*词法分析*
    对应于找到输入中最长的初始数字序列，而 *解析* 对应于计算该序列的十进制数值。
- en: '*Regular expressions* (or *regexes*) is a tool provided by many programming
    languages that solve the lexing problem, not just for sequences of digits but
    for arbitrarily complicated input formats. Regular expressions have been part
    of the C++ standard library since 2011, in the `<regex>` header. In this chapter
    we''ll show you how to use regexes to simplify some common parsing tasks.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*正则表达式*（或 *regexes*）是许多编程语言提供的一种工具，用于解决词法分析问题，不仅适用于数字序列，还适用于任意复杂的输入格式。自 2011
    年以来，正则表达式一直是 C++ 标准库的一部分，位于 `<regex>` 头文件中。在本章中，我们将向您展示如何使用正则表达式简化一些常见的解析任务。'
- en: Bear in mind that regexes are likely to be overkill for *most* parsing tasks
    that you'll face in your daily work. They can be slow and bloated, and unavoidably
    require heap allocation (that is, the regex data types are not *allocator-aware*
    as described in [Chapter 8](part0129.html#3R0OI0-2fdac365b8984feebddfbb9250eaf20d),
    *Allocators*). Where regexes really shines is for complicated tasks where hand-written
    parsing code would be just as slow anyway; and for extremely simple tasks where
    the readability and robustness of regular expressions outweigh their performance
    costs. In short, regex support has taken C++ one step closer to the everyday usability
    of scripting languages such as Python and Perl.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，正则表达式对于你日常工作中遇到的 *大多数* 解析任务来说可能是过度杀鸡用牛刀。它们可能很慢、体积庞大，并且不可避免地需要堆分配（即，正则表达式数据类型不是如
    [第 8 章](part0129.html#3R0OI0-2fdac365b8984feebddfbb9250eaf20d) 中描述的 *分配器感知*）。正则表达式真正发光的地方是对于即使手写的解析代码也会很慢的复杂任务；以及对于极其简单的任务，正则表达式的可读性和健壮性超过了它们的性能成本。简而言之，正则表达式支持使
    C++ 向日常可使用脚本语言（如 Python 和 Perl）迈进了一步。
- en: 'In this chapter we''ll learn:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习：
- en: '"Modified ECMAScript", the dialect used by C++ regexes'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “修改后的 ECMAScript”，C++ 正则表达式使用的方言
- en: How to match, search, and even replace substrings using regexes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用正则表达式匹配、搜索甚至替换子串
- en: Further dangers of dangling iterators
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 悬挂迭代器的进一步危险
- en: Regex features to avoid
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免的正则表达式功能
- en: What are regular expressions?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正则表达式是什么？
- en: A *regular expression* is a way of writing down the rules for recognizing a
    string of bytes or characters as belonging (or not belonging) to a certain "language."
    In this context, a "language" can be anything from "the set of all digit-sequences"
    to "the set of all sequences of valid C++ tokens." Essentially, a "language" is
    just a rule for dividing the world of all strings into two sets--the set of strings
    matching the rules of the language, and the set of strings that *don't* match.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式是一种记录识别字符串字节或字符是否属于（或不属于）某种“语言”规则的方法。在这个语境中，“语言”可以是“所有数字序列的集合”到“所有有效C++标记序列的集合”的任何东西。本质上，“语言”只是将所有字符串的世界划分为两个集合——匹配语言规则的字符串集合，以及不匹配的字符串集合。
- en: Some kinds of languages follow simple enough rules that they can be recognized
    by a *finite state machine*, a computer program with no memory at all--just a
    program counter and a pointer that scans over the input in a single pass. The
    language of "digit-sequences" is certainly in the category of languages that can
    be recognized by a finite state machine. We call these languages *regular languages*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一些类型的语言遵循足够简单的规则，以至于可以通过一个“有限状态机”来识别，这是一个完全没有记忆的计算机程序——只是一个程序计数器和扫描输入的单个指针。数字序列的语言当然属于可以通过有限状态机识别的语言类别。我们称这些语言为“正则语言”。
- en: There also exist non-regular languages. One very common non-regular language
    is "valid arithmetic expressions," or, to boil it down to its essence, "properly
    matched parentheses." Any program that can distinguish the properly matched string
    `(((())))` from the improperly matched strings `(((()))` and `(((()))))` must
    essentially be able to "count"--to distinguish the case of *four* parentheses
    from the cases of *three* or *five*. Counting in this way cannot be done without
    a modifiable variable or a push-down stack; so parenthesis-matching is *not* a
    regular language.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 还存在非正则语言。一个非常常见的非正则语言是“有效的算术表达式”，或者简化其本质，就是“正确匹配的括号”。任何能够区分正确匹配的字符串`(((())))`与不正确匹配的字符串`(((()))`和`(((()))))`的程序，本质上必须能够“计数”——区分四个括号的情况与三个或五个括号的情况。这种计数方式不能没有可修改的变量或下推栈；因此，括号匹配不是正则语言。
- en: It turns out that, given any regular language, there is a nice straightforward
    way to write a representation of the finite state machine that recognizes it,
    which of course is also a representation of the rules of the language itself.
    We call this representation a *regular expression*, or *regex*. The standard notation
    for regexes was developed in the 1950s, and was really set in stone by the late
    1970s in Unix programs such as `grep` and `sed`--programs which are still very
    much worth learning today, but which are of course outside the scope of this book.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，对于任何正则语言，都存在一种简单直接的方法来编写识别它的有限状态机的表示，这当然也是语言规则的表示。我们称这种表示为“正则表达式”，或“regex”。正则表达式的标准符号是在20世纪50年代开发的，并在20世纪70年代末的Unix程序（如`grep`和`sed`）中得到确立——这些程序至今仍非常值得学习，但当然超出了本书的范围。
- en: The C++ standard library offers several different "flavors" of regex syntax,
    but the default flavor (and the one you should always use) was borrowed wholesale
    from the standard for ECMAScript--the language better known as JavaScript--with
    only minor modifications in the vicinity of square-bracket constructs. I've included
    a primer on ECMAScript regex syntax near the end of this chapter; but if you've
    ever used `grep`, you'll be able to follow the rest of this chapter easily without
    consulting that section.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准库提供了几种不同的正则表达式语法“风味”，但默认风味（以及你应该始终使用的风味）是从ECMAScript标准（更广为人知的JavaScript语言）全面借鉴的，只是在方括号结构附近进行了少量修改。我在本章末尾包含了一个关于ECMAScript正则表达式语法的入门介绍；但如果你曾经使用过`grep`，你将能够轻松地跟随本章的其余部分，而无需查阅该部分。
- en: A note on backslash-escaping
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于反斜杠转义说明
- en: 'In this chapter, we''ll be referring frequently to strings and regular expressions
    that contain literal backslashes. As you know, to write a string containing a
    literal backslash in C++, you have to *escape* the backslash with another backslash:
    thus `"\n"` represents a newline character but `"\\n"` represents the two-character
    string of "backslash" followed by "n". This kind of thing is usually easy to keep
    track of, but in this chapter we''re going to have to take special pains. Regexes
    are implemented purely as a library feature; so when you write `std::regex("\n")`
    the regex library will see a "regex" containing only a single whitespace character,
    and if you write `std::regex("\\n")` the library will see a two-character string
    starting with a backslash, which *the library will interpret* as a two-character
    escape sequence meaning "newline." If you want to communicate the idea of a *literal*
    backslash-n to the regex library, you''ll have to get the regex library to see
    the three-character string `\\\\n`, which means writing the five-character string
    `"\\\\n"` in your C++ source code.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将频繁地提到包含字面反斜杠的字符串和正则表达式。正如你所知，要在 C++ 中写入包含字面反斜杠的字符串，你必须用另一个反斜杠来 *转义*
    反斜杠：因此 `"\n"` 表示一个换行符，但 `"\\n"` 表示由“反斜杠”和“n”组成的两个字符字符串。这类事情通常很容易跟踪，但在这个章节中，我们不得不特别小心。正则表达式完全作为库特性实现；所以当你写
    `std::regex("\n")` 时，正则表达式库会看到一个只包含单个空白字符的“正则表达式”，如果你写 `std::regex("\\n")`，库会看到一个以反斜杠开头的两个字符字符串，库会
    *解释* 它为一个表示“换行”的两个字符转义序列。如果你想将 *字面* 反斜杠-n 的概念传达给正则表达式库，你必须让正则表达式库看到三个字符字符串 `\\\\n`，这意味着在
    C++ 源代码中写入五个字符字符串 `"\\\\n"`。
- en: 'You might have noticed in the preceding paragraph the solution I''m going to
    be using in this chapter. When I talk about a *C++ string literal* or string value,
    I will put it in double quotes, like this: `"cat"`, `"a\\.b"`. When I talk about
    a *regular expression* as you would type it in an email or a text editor, or hand
    it to the library for evaluation, I will express it without quotes: `cat`, `a\.b`.
    Just remember that when you see an unquoted string, that''s a literal sequence
    of characters, and if you want to put it into a C++ string literal, you''ll need
    to double up all the backslashes, thus: `a\.b` goes into your source code as `std::regex("a\\.b")`.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在前一段落注意到了我将在本章中使用的解决方案。当我提到一个 *C++ 字符串字面量* 或字符串值时，我会用双引号将其括起来，就像这样："cat"，"a\.b"。当我提到一个
    *正则表达式*，就像你在电子邮件或文本编辑器中输入的那样，或者将其传递给库进行评估时，我将不使用引号来表示：`cat`，`a\.b`。只需记住，当你看到未加引号的字符串时，那是一个字符序列的字面表示，如果你想要将其放入
    C++ 字符串字面量中，你需要将所有的反斜杠都加倍，因此：`a\.b` 将在源代码中以 `std::regex("a\\.b")` 的形式出现。
- en: 'I hear some of you asking: What about *raw string literals*? Raw string literals
    are a C++11 feature that allows you to write the character sequence `a\.b` by
    "escaping" the entire string with an `R` and some parentheses, like this--`R"(a\.b)"`--instead
    of escaping each backslash in the string. If your string contains parentheses
    itself, then you can get fancier by writing any arbitrary string before the first
    parenthesis and after the last, like this: `R"fancy(a\.b)fancy"`. A raw string
    literal like this one is allowed to contain any characters--backslashes, quotation
    marks, even newlines--as long as it doesn''t contain the consecutive sequence
    `)fancy"` (and if you think there''s a chance it might contain that sequence,
    then you just pick a new arbitrary string, such as `)supercalifragilisticexpialidocious"`).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我听到一些人在问：那么 *原始字符串字面量* 呢？原始字符串字面量是 C++11 中的一个特性，它允许你通过使用 `R` 和一些括号来“转义”整个字符串来写出
    `a\.b` 这样的字符序列，就像这样--`R"(a\.b)"`--而不是转义字符串中的每个反斜杠。如果你的字符串本身包含括号，那么你可以在第一个括号之前和最后一个括号之后写任何任意字符串，就像这样：`R"fancy(a\.b)fancy"`。这样的原始字符串字面量可以包含任何字符--反斜杠、引号，甚至是换行符--只要它不包含连续的序列
    `)fancy"`（如果你认为它可能包含这个序列，那么你只需选择一个新的任意字符串，例如 `)supercalifragilisticexpialidocious"`）。
- en: The syntax of C++ raw string literals, with its leading `R`, is reminiscent
    of the raw string literal syntax in Python (with its leading `r`). In Python,
    `r"a\.b"` similarly represents the literal string `a\.b`; and it is both common
    and idiomatic to represent regular expressions in code by strings such as `r"abc"`
    even if they don't contain any special characters. But notice the all-important
    difference between `r"a\.b"` and `R"(a\.b)"`--the C++ version has an extra set
    of parentheses! And parentheses are *significant special characters* in the regex
    grammar. The C++ string literals `"(cat)"` and `R"(cat)"` are as different as
    night and day--the former represents the five-character regex `(cat)`, and the
    latter represents the three-character regex `cat`. If you trip up and write `R"(cat)"`
    when you meant `"(cat)"` (or equivalently, `R"((cat))"`), your program will have
    a very subtle bug. Even more sadistically, `R"a*(b*)a*"` is a valid regex with
    a surprising meaning! Therefore, I recommend that you use raw string literals
    for regexes with great caution; generally it is safer and clearer to double *all*
    your backslashes than to worry about doubling only the *outermost* of your parentheses.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: C++原始字符串字面量的语法，其前缀为`R`，让人联想到Python中原始字符串字面量的语法（其前缀为`r`）。在Python中，`r"a\.b"`同样表示字面量字符串`a\.b`；在代码中，用如`r"abc"`这样的字符串表示正则表达式是既常见又符合习惯的，即使它们不包含任何特殊字符。但请注意`r"a\.b"`和`R"(a\.b)"`之间至关重要的区别——C++版本有一个额外的括号组！并且括号是正则表达式语法中的*重要特殊字符*。C++字符串字面量`"(cat)"`和`R"(cat)"`与白天和黑夜一样不同——前者表示五个字符的正则表达式`(cat)`，而后者表示三个字符的字符串`cat`。如果你不小心写了`R"(cat)"`而本意是`"(cat)"`（或者等价地，`R"((cat))"`），你的程序将会有一个非常微妙的错误。甚至更糟糕的是，`R"a*(b*)a*"`是一个具有惊人含义的有效正则表达式！因此，我建议你在使用原始字符串字面量表示正则表达式时要非常小心；通常，双重*所有*反斜杠比只担心双重*最外层*的括号更安全、更清晰。
- en: 'Where raw string literals *are* useful is for what other languages call "heredocs":'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 原始字符串字面量*适用于*其他语言所说的“heredocs”：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: That is, raw string literals are the only kind of string literal in C++ that
    can encode newline characters without any kind of escaping. This is useful for
    printing long messages to the user, or maybe for things such as HTTP headers;
    but raw strings' behavior with parentheses makes them mildly dangerous for use
    with regular expressions--I will not be using them in this book.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，原始字符串字面量是C++中唯一可以不进行任何转义就编码换行符的字符串字面量。这对于向用户打印长消息或可能用于HTTP头等用途非常有用；但是原始字符串与括号的行为使得它们在使用正则表达式时稍微有些危险——我不会在这本书中使用它们。
- en: Reifying regular expressions into std::regex objects
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将正则表达式实体化为`std::regex`对象
- en: 'To use regular expressions in C++, you can''t use a string such as `"c[a-z]*t"`
    directly. Instead, you have to use that string to construct a *regular expression
    object* of type `std::regex`, and then pass the `regex` object as one of the arguments
    to a *matching function* such as `std::regex_match`, `std::regex_search`, or `std::regex_replace`.
    Each object of type `std::regex` encodes a complete finite state machine for the
    given expression, and constructing this finite state machine requires a lot of
    computation and memory allocation; so if we are going to match a lot of input
    text against the same regex, it is convenient that the library gives us a way
    to pay for that expensive construction just once. On the other hand, this means
    that the `std::regex` objects are relatively slow to construct and expensive to
    copy; constructing a regex inside a tight inner loop is a good way to kill your
    program''s performance:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要在C++中使用正则表达式，你不能直接使用如`"c[a-z]*t"`这样的字符串。相反，你必须使用这个字符串来构建一个*正则表达式对象*，类型为`std::regex`，然后将`regex`对象作为参数之一传递给*匹配函数*，例如`std::regex_match`、`std::regex_search`或`std::regex_replace`。每个`std::regex`类型的对象都编码了给定表达式的完整有限状态机，构建这个有限状态机需要大量的计算和内存分配；因此，如果我们需要将大量的输入文本与相同的正则表达式进行匹配，那么库提供一种只需支付一次这种昂贵构建的方法是非常方便的。另一方面，这也意味着`std::regex`对象构建相对较慢，复制成本较高；在紧缩的内循环中构建正则表达式是降低程序性能的好方法：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Keep in mind that this `regex` object has value semantics; when we "match" an
    input string against a regex, we aren't mutating the `regex` object itself. A
    regex has no memory of what it's been matched against. Therefore, when we want
    to pull information out of a regex-matching operation--such as "did the command
    say to move left or right? what was the number we saw?"--we'll have to introduce
    a new entity that we can mutate.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这个 `regex` 对象具有值语义；当我们“匹配”一个输入字符串与正则表达式时，我们并没有修改 `regex` 对象本身。正则表达式没有记忆它匹配过什么。因此，当我们想要从正则表达式匹配操作中提取信息——例如，“命令是否说要向左或向右移动？我们看到了什么数字？”——我们将不得不引入一个新的实体，我们可以对其进行修改。
- en: 'A `regex` object offers the following methods:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`regex` 对象提供了以下方法：'
- en: '`std::regex(str, flags)` constructs a new `std::regex` object by translating
    (or "compiling") the given `str` into a finite state machine. Options affecting
    the compilation process itself can be specified via the bitmask argument `flags`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::regex(str, flags)` 通过将给定的 `str` 转换（或“编译”）成有限状态机来构建一个新的 `std::regex` 对象。可以通过位掩码参数
    `flags` 指定影响编译过程本身的选项：'
- en: '`std::regex::icase`: Treat all alphabetic characters as case-insensitive'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::regex::icase`：将所有字母字符视为不区分大小写'
- en: '`std::regex::nosubs`: Treat all parenthesized groups as non-capturing'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::regex::nosubs`：将所有括号组视为非捕获组'
- en: '`std::regex::multiline`: Make the non-consuming assertion `^` (and `$`) match
    immediately after (and before) a `"\n"` character in the input, rather than only
    at the beginning (and end) of the input'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std::regex::multiline`：使非消耗性断言 `^`（和 `$`）在输入中的 `"\n"` 字符之后（和之前）立即匹配，而不是仅在输入的开始（和结束）处匹配'
- en: There are several other options that you could bitwise-OR into flags; but the
    others either change the "flavor" of regex syntax away from ECMAScript towards
    less well-documented and less well-tested flavors (`basic`, `extended`, `awk`,
    `grep`, `egrep`), introduce locale dependencies (`collate`), or simply don't do
    anything at all (`optimize`). Therefore, you should avoid all of them in production
    code.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将其他几个选项按位或到标志中；但其他选项要么将正则表达式语法“风味”从 ECMAScript 转向文档较少且测试较少的风味（`basic`、`extended`、`awk`、`grep`、`egrep`），引入区域设置依赖性（`collate`），或者根本不执行任何操作（`optimize`）。因此，你应该在生产代码中避免使用所有这些选项。
- en: Notice that even though the process of turning a string into a `regex` object
    is often called "compiling the regex," it is still a dynamic process that happens
    at runtime when the `regex` constructor is called, not during the compilation
    of your C++ program. If you make a syntax error in your regular expression, it
    will be caught not at compile time, but at runtime--the `regex` constructor will
    throw an exception of type `std::regex_error`, which is a subclass of `std::runtime_error`.
    Properly robust code should also be prepared for the `regex` constructor to throw
    `std::bad_alloc`; recall that `std::regex` is not allocator-aware.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管将字符串转换为 `regex` 对象的过程通常被称为“编译正则表达式”，但它仍然是一个动态过程，在调用 `regex` 构造函数时发生，而不是在编译你的
    C++ 程序期间。如果你在正则表达式中犯了语法错误，它将在运行时被捕获，而不是在编译时——`regex` 构造函数将抛出一个类型为 `std::regex_error`
    的异常，它是 `std::runtime_error` 的子类。健壮的代码还应该准备好 `regex` 构造函数抛出 `std::bad_alloc`；回想一下，`std::regex`
    不是分配器感知的。
- en: '`rx.mark_count()` returns the number of parenthesized capturing groups in the
    regex. The name of this method comes from the phrase "marked subexpression," an
    older synonym for "capturing group."'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`rx.mark_count()` 返回正则表达式中的括号捕获组的数量。这个方法的名字来源于短语“标记子表达式”，这是“捕获组”的一个较老的别名。'
- en: '`rx.flags()` returns the bit-mask that was passed to the constructor originally.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`rx.flags()` 返回最初传递给构造函数的位掩码。'
- en: Matching and searching
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匹配和搜索
- en: 'To ask whether a given input string `haystack` conforms to a given regex `rneedle`,
    you can use `std::regex_match(haystack, rneedle)`. The regex always comes last,
    which is reminiscent of JavaScript''s syntax `haystack.match(rneedle)` and Perl''s
    `haystack =~ rneedle` even as it''s opposed to Python''s `re.match(rneedle, haystack)`.
    The `regex_match` function returns `true` if the regex matches the entire input
    string, and `false` otherwise:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要询问给定的输入字符串 `haystack` 是否符合给定的正则表达式 `rneedle`，你可以使用 `std::regex_match(haystack,
    rneedle)`。正则表达式始终放在最后，这与 JavaScript 的语法 `haystack.match(rneedle)` 和 Perl 的 `haystack
    =~ rneedle` 相似，尽管它与 Python 的 `re.match(rneedle, haystack)` 相反。如果正则表达式匹配整个输入字符串，则
    `regex_match` 函数返回 `true`，否则返回 `false`：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `regex_search` function returns `true` if the regex matches any portion
    of the input string. Essentially, it just puts `.*` on both sides of the regex
    you provided and then runs the `regex_match` algorithm; but implementations can
    generally perform a `regex_search` faster than they could recompile a whole new
    regex.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`regex_search` 函数在正则表达式与输入字符串的任何部分匹配时返回 `true`。本质上，它只是在提供的正则表达式两边加上 `.*`，然后运行
    `regex_match` 算法；但实现通常可以比重新编译整个新的正则表达式更快地执行 `regex_search`。'
- en: 'To match within just part of a character buffer (such as you might do when
    pulling data in bulk over a network connection or from a file), you can pass an
    iterator pair to `regex_match` or `regex_search`, very similarly to what we saw
    in [Chapter 3](part0036.html#12AK80-2fdac365b8984feebddfbb9250eaf20d), *The Iterator-Pair
    Algorithms*. In the following example, bytes outside the range `[p, end)` are
    never considered, and the "string" `p` doesn''t need to be null-terminated:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要在字符缓冲区的一部分（例如，当你从网络连接或文件中批量拉取数据时）进行匹配，你可以将迭代器对传递给 `regex_match` 或 `regex_search`，这与我们在
    [第 3 章](part0036.html#12AK80-2fdac365b8984feebddfbb9250eaf20d) 中看到的非常相似，*The Iterator-Pair
    Algorithms*。在下面的例子中，范围 `[p, end)` 之外的字节永远不会被考虑，并且 "string" `p` 不需要以空字符终止：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This interface is similar to what we saw with `std::from_chars` in [Chapter
    9](part0144.html#49AH00-2fdac365b8984feebddfbb9250eaf20d), *Iostreams*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此接口与我们之前在 [第 9 章](part0144.html#49AH00-2fdac365b8984feebddfbb9250eaf20d) 中看到的
    `std::from_chars` 类似，*Iostreams*。
- en: Pulling submatches out of a match
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从匹配中提取子匹配
- en: 'To use regexes for the *lexing* stage of input, you''ll need a way to pull
    out the input substrings that matched each capturing group. The way you do this
    in C++ is by creating a *match object* of type `std::smatch`. No, that''s not
    a typo! The name of the match-object type really is `smatch`, which stands for
    `std::string` match; there is also `cmatch` for `const char *` match. The difference
    between `smatch` or `cmatch` is the *type of iterator* they store internally:
    `smatch` stores `string::const_iterator`, while `cmatch` stores `const char *`.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用正则表达式进行输入的 *lexing* 阶段，你需要一种方法来提取匹配每个捕获组的输入子字符串。在 C++ 中，你通过创建一个类型为 `std::smatch`
    的 *match 对象* 来这样做。不，这不是一个打字错误！match 对象类型的名称确实是 `smatch`，代表 `std::string` match；还有一个
    `cmatch` 用于 `const char *` 匹配。`smatch` 或 `cmatch` 之间的区别是它们内部存储的 *迭代器类型*：`smatch`
    存储 `string::const_iterator`，而 `cmatch` 存储 `const char *`。
- en: Having constructed an empty `std::smatch` object, you'll pass it by reference
    as the middle parameter to `regex_match` or `regex_search`. Those functions will
    "fill in" the `smatch` object with information about the substrings that matched,
    *if* the regex match actually succeeded. If the match failed, then the `smatch`
    object will become (or remain) empty.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建了一个空的 `std::smatch` 对象后，你将通过引用将其作为 `regex_match` 或 `regex_search` 的中间参数传递。这些函数将
    "填充" `smatch` 对象，包含有关匹配的子字符串的信息，*如果* 正则表达式匹配实际上成功了。如果匹配失败，那么 `smatch` 对象将变为（或保持）空。
- en: 'Here''s an example of using `std::smatch` to pull out the substrings matching
    the direction and the integer distance from our "robot command":'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用 `std::smatch` 从我们的 "robot command" 中提取匹配方向和整数距离的子字符串的例子：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Notice that we use a `static` regex object to avoid constructing ("compiling")
    a new regex object every time the function is entered. Here''s the same code using
    `const char *` and `std::cmatch` just for comparison:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用一个 `static` 正则表达式对象来避免每次函数进入时都构造（"编译"）一个新的正则表达式对象。以下代码使用 `const char
    *` 和 `std::cmatch` 仅用于比较：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In both cases, something interesting happens on the line with the `return`.
    Having successfully matched the input string against our regex, we can query the
    match object `m` to find out which pieces of the input string correspond to the
    individual capturing groups in our regex. The first capturing group (`(left|right)`
    in our example) corresponds to `m[1]`, the second group (`([0-9]+)` in our example)
    corresponds to `m[2]`, and so on. If you try to refer to a group that doesn't
    exist in the regex, such as `m[3]` in our example, you'll get an empty string;
    accessing a match object will never throw an exception.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，在带有 `return` 的行上都会发生一些有趣的事情。在成功将输入字符串与我们的正则表达式匹配后，我们可以查询匹配对象 `m` 来找出输入字符串中哪些部分对应于正则表达式中的各个捕获组。在我们的例子中，第一个捕获组
    (`(left|right)`) 对应于 `m[1]`，第二个组 (`([0-9]+)`) 对应于 `m[2]`，依此类推。如果你尝试引用正则表达式中不存在的组，例如我们的例子中的
    `m[3]`，你将得到一个空字符串；访问匹配对象永远不会抛出异常。
- en: 'The group `m[0]` is a special case: it refers to the entire matched sequence.
    If the match was filled in by `std::regex_match`, this will always be the entire
    input string; if the match was filled in by `std::regex_search`, then this will
    be just the part of the string that matched the regex.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 组 `m[0]` 是一个特殊情况：它指的是整个匹配序列。如果匹配是由 `std::regex_match` 填充的，这将始终是整个输入字符串；如果匹配是由
    `std::regex_search` 填充的，那么这将只是与正则表达式匹配的字符串部分。
- en: 'There are also two named groups: `m.prefix()` and `m.suffix()`. These refer
    to the sequences that were *not* part of the match--before the matched substring
    and after it, respectively. It is an invariant that if the match succeeded at
    all, then `m.prefix() + m[0] + m.suffix()` represents the entire input string.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有两个命名组：`m.prefix()` 和 `m.suffix()`。这些指的是不是匹配部分的序列——分别在匹配子串之前和之后。如果匹配成功，则
    `m.prefix() + m[0] + m.suffix()` 表示整个输入字符串。
- en: 'All of these "group" objects are represented not by `std::string` objects--that
    would be too expensive--but by lightweight objects of type `std::sub_match<It>`
    (where `It` is either `std::string::const_iterator` or `const char *` as noted
    previously). Every `sub_match` object is implicitly convertible to `std::string`,
    and otherwise behaves a lot like a `std::string_view`: you can compare submatches
    against string literals, ask them for their lengths, and even output them to a
    C++ stream with `operator<<`, without ever converting them to `std::string`. The
    downside of this lightweight efficiency is the same downside we get every time
    we deal with iterators pointing into a container we may not own: we run the risk
    of *dangling iterators*:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些“组”对象都不是由 `std::string` 对象表示的——那会太昂贵了——而是由轻量级的 `std::sub_match<It>` 类型对象表示（其中
    `It` 是 `std::string::const_iterator` 或 `const char *`，如前所述）。每个 `sub_match` 对象都可以隐式转换为
    `std::string`，并且其行为在很大程度上类似于 `std::string_view`：你可以比较子匹配与字符串字面量，询问它们的长度，甚至可以使用
    `operator<<` 将它们输出到 C++ 流中，而无需将它们转换为 `std::string`。这种轻量级效率的缺点是，每次我们处理指向可能不属于我们的容器的迭代器时都会遇到的同样缺点：我们面临
    *悬垂迭代器* 的风险：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Fortunately, the standard library foresaw this lurking horror and evaded it
    by providing a special-case overload `regex_match(std::string&&, std::smatch&,
    const std::regex&)`, which is *explicitly deleted* (using the same `=delete` syntax
    you'd use to delete an unwanted special member function). This ensures that the
    preceding innocent-looking code will fail to compile, rather than being a source
    of iterator-invalidation bugs. Still, iterator invalidation bugs can happen, as
    in the previous example; to prevent them, you should treat `smatch` objects as
    extremely temporary, kind of like a `[&]` lambda that captures the world by reference.
    Once a `smatch` object has been filled in, don't touch anything else in the environment
    until you've extracted the parts of the `smatch` that you care about!
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，标准库预见到这种潜伏的恐怖，并通过提供特殊案例重载 `regex_match(std::string&&, std::smatch&, const
    std::regex&)` 来避免它，该重载是 *显式删除的*（使用与删除不想要的特殊成员函数相同的 `=delete` 语法）。这确保了前面的看似无辜的代码将无法编译，而不是成为迭代器无效化错误的来源。尽管如此，迭代器无效化错误仍然可能发生，就像前面的例子中那样；为了防止这些错误，你应该将
    `smatch` 对象视为极其临时的，有点像捕获整个世界的 `[&]` lambda。一旦 `smatch` 对象被填充，在提取你关心的 `smatch`
    部分之前，不要触摸环境中的任何其他内容！
- en: 'To summarize, a `smatch` or `cmatch` object offers the following methods:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`smatch` 或 `cmatch` 对象提供了以下方法：
- en: '`m.ready()`: True if `m` has been filled in at all, in the time since its construction.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m.ready()`: 如果 `m` 自构造以来已被填充，则为真。'
- en: '`m.empty()`: True if `m` represents a failed match (that is, if it was most
    recently filled in by a failed `regex_match` or `regex_search`); false if `m`
    represents a successful match.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m.empty()`: 如果 `m` 代表一个失败的匹配（即，如果它是最近由失败的 `regex_match` 或 `regex_search` 填充的），则为真；如果
    `m` 代表一个成功的匹配，则为假。'
- en: '`m.prefix()`, `m[0]`, `m.suffix()`: `sub_match` objects representing the unmatched
    prefix, matched, and unmatched suffix parts of the input string. (If `m` represents
    a failed match, then none of these are meaningful.)'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m.prefix()`、`m[0]`、`m.suffix()`：代表输入字符串中未匹配的前缀、匹配和未匹配后缀部分的 `sub_match` 对象。（如果
    `m` 代表一个失败的匹配，那么这些都没有意义。）'
- en: '`m[k]`: A `sub_match` object representing the part of the input string matched
    by the *k*th capturing group. `m.str(k)` is a convenient shorthand for `m[k].str()`.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m[k]`: 代表输入字符串中由第 *k* 个捕获组匹配的部分的 `sub_match` 对象。`m.str(k)` 是 `m[k].str()`
    的便捷简写。'
- en: '`m.size()`: Zero if `m` represents a failed match; otherwise, one more than
    the number of capturing groups in the regex whose successful match is represented
    by `m`. Notice that `m.size()` always agrees with `operator[]`; the range of meaningful
    submatch objects is always `m[0]` through `m[m.size()-1]`.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m.size()`: 如果 `m` 表示一个失败的匹配，则为零；否则，比表示 `m` 的正则表达式中捕获组的数量多一个。请注意，`m.size()`
    总是与 `operator[]` 一致；有意义的子匹配对象的范围始终是 `m[0]` 到 `m[m.size()-1]`。'
- en: '`m.begin()`, `m.end()`: Iterators enabling ranged for-loop syntax over a match
    object.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m.begin()`、`m.end()`：使能够对匹配对象进行范围 for 循环语法的迭代器。'
- en: 'And a `sub_match` object offers the following methods:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `sub_match` 对象提供了以下方法：
- en: '`sm.first`: The iterator to the beginning of the matched input substring.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sm.first`: 匹配输入子字符串开头的迭代器。'
- en: '`sm.second`: The iterator to the end of the matched input substring.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sm.second`: 匹配输入子字符串末尾的迭代器。'
- en: '`sm.matched`: True if `sm` was involved in the successful match; false if `sm`
    was part of an optional branch that got bypassed. For example, if the regex was
    `(a)|(b)` and the input was `"a"`, we would have `m[1].matched && !m[2].matched`;
    whereas if the input were `"b"`, we would have `m[2].matched && !m[1].matched`.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sm.matched`: 如果 `sm` 参与了成功的匹配，则为真；如果 `sm` 是一个可选分支的一部分，该分支被绕过，则为假。例如，如果正则表达式是
    `(a)|(b)` 并且输入是 `"a"`，则会有 `m[1].matched && !m[2].matched`；而如果输入是 `"b"`，则会有 `m[2].matched
    && !m[1].matched`。'
- en: '`sm.str()`: The matched input substring, pulled out and converted to `std::string`.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sm.str()`: 匹配的输入子字符串，提取并转换为 `std::string`。'
- en: '`sm.length()`: The length of the matched input substring (`second - first`).
    Equivalent to `sm.str().length()`, but much faster.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sm.length()`: 匹配输入子字符串的长度（`second - first`）。相当于 `sm.str().length()`，但速度更快。'
- en: '`sm == "foo"`: Comparison against `std::string`, `const char *`, or a single
    `char`. Equivalent to `sm.str() == "foo"`, but much faster. Unfortunately, the
    C++17 standard library does not provide any overload of `operator==` taking `std::string_view`.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sm == "foo"`: 与 `std::string`、`const char *` 或单个 `char` 进行比较。相当于 `sm.str()
    == "foo"`，但速度更快。不幸的是，C++17 标准库没有提供任何重载的 `operator==` 操作符，用于接受 `std::string_view`。'
- en: Although you will likely never have a use for this in real code, it is possible
    to create a match or submatch object storing iterators into containers other than
    `std::string` or buffers of `char`. For example, here's our same function, but
    matching our regex against a `std::list<char>`--silly, but it works!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可能在实际代码中永远不会用到这个，但有可能创建一个存储到容器中迭代器（除了 `std::string` 或 `char` 缓冲区）的匹配或子匹配对象。例如，这里是我们相同的函数，但将正则表达式与
    `std::list<char>` 匹配——愚蠢，但它有效！
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Converting submatches to data values
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将子匹配转换为数据值
- en: 'Just to close the loop on parsing, here''s an example of how we could parse
    string and integer values out of our submatches to actually move our robot:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 只为了完成解析的闭环，这里有一个例子，说明我们如何从子匹配中解析字符串和整数值，以实际移动我们的机器人：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Any unrecognized or invalid string input is diagnosed either by our custom`"Failed
    to lex"` exception or by the `std::out_of_range` exception thrown by `std::stoi()`.
    If we were to add a check for integer overflow before modifying `pos`, we'd have
    a rock-solid input parser.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 任何未识别或无效的字符串输入将通过我们自定义的 `"Failed to lex"` 异常或由 `std::stoi()` 抛出的 `std::out_of_range`
    异常来诊断。如果我们修改 `pos` 之前添加一个整数溢出的检查，我们将有一个坚不可摧的输入解析器。
- en: 'If we wanted to handle negative integers and case-insensitive directions, the
    following modifications would do the trick:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要处理负整数和大小写不敏感的方向，以下修改将有效：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Iterating over multiple matches
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遍历多个匹配项
- en: Consider the regex `(?!\d)\w+`, which matches a single C++ identifier. We already
    know how to use `std::regex_match` to tell whether an input string *is* a C++
    identifier, and how to use `std::regex_search` to find the *first* C++ identifier
    in a given input line. But what if we want to find *all* the C++ identifiers in
    a given input line?
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑正则表达式 `(?!\d)\w+`，它匹配单个 C++ 标识符。我们已经知道如何使用 `std::regex_match` 来判断输入字符串是否是
    C++ 标识符，以及如何使用 `std::regex_search` 来找到给定输入行中的第一个 C++ 标识符。但如果我们想要找到给定输入行中的所有 C++
    标识符呢？
- en: 'The fundamental idea here is to call `std::regex_search` in a loop. This gets
    complicated, though, because of the non-consuming "lookbehind" anchors such as
    `^` and `\b`. To implement a loop over `std::regex_search` correctly from scratch,
    we''d have to preserve the state of these anchors. `std::regex_search` (and `std::regex_match`
    for that matter) supports this use-case by providing flags of its own--flags which
    determine the *starting state* of the finite state machine for this particular
    matching operation. For our purposes, the only important flag is `std::regex::match_prev_avail`,
    which tells the library that the iterator `begin`, representing the start of the
    input, is not actually at the "beginning" of the input (that is, it might not
    match `^`) and that if you want to know the previous character of the input for
    purposes of `\b`, it is safe to inspect `begin[-1]`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的基本思想是在循环中调用 `std::regex_search`。然而，由于非消耗性的“向后看”锚点，如 `^` 和 `\b`，这会变得复杂。要从头开始正确实现
    `std::regex_search` 的循环，我们必须保留这些锚点的状态。`std::regex_search`（以及 `std::regex_match`）通过提供自己的标志来支持这种用例——这些标志决定了这个特定匹配操作的有限状态机的
    *起始状态*。对我们来说，唯一重要的标志是 `std::regex::match_prev_avail`，它告诉库迭代器 `begin`（表示输入的开始）实际上不在输入的“开始”处（即它可能不匹配
    `^`），并且如果你想要知道输入的上一字符用于 `\b`，检查 `begin[-1]` 是安全的：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding example, when `!be_correct`, each `regex_search` invocation
    is treated independently, so there is no difference between searching for `\bb.`
    from the first letter of the word `"by"` or from the third letter of the word
    `"baby"`. But when we pass `match_prev_avail` to the later invocations of `regex_search`,
    it takes a step back--literally--to see whether the letter before `"by"` was a
    "word" letter or not. Since the preceding `"a"` is a word letter, the second `regex_search`
    correctly refuses to treat `"by"` as a match.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，当 `!be_correct` 时，每次 `regex_search` 调用都是独立处理的，所以从单词 `"by"` 的第一个字母搜索
    `\bb.` 和从单词 `"baby"` 的第三个字母搜索 `\bb.` 之间没有区别。但是当我们把 `match_prev_avail` 传递给 `regex_search`
    的后续调用时，它会实际退后一步——看看 `"by"` 前面的字母是否是一个“单词”字母。由于前面的 `"a"` 是一个单词字母，第二个 `regex_search`
    正确地拒绝将 `"by"` 作为匹配项。
- en: 'Using `regex_search` in a loop like this is easy... unless the given regex
    might match an empty string! If the regex ever returns a successful match `m`
    where `m[0].length() == 0`, then we''ll have an infinite loop. So the inner loop
    of our `get_all_matches()` should really look more like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环中使用 `regex_search` 很简单... 除非给定的正则表达式可能会匹配一个空字符串！如果正则表达式返回一个成功的匹配 `m`，其中 `m[0].length()
    == 0`，那么我们就会有一个无限循环。所以我们的 `get_all_matches()` 的内部循环实际上应该看起来更像是这样：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The standard library provides a "convenience" type called `std::regex_iterator`
    that will encapsulate the preceding code snippets'' logic; using `regex_iterator`
    might conceivably save you some subtle bugs related to zero-length matches. Sadly,
    it won''t save you any typing, and it slightly increases the chances of dangling-iterator
    pitfalls. `regex_iterator` is templated on its underlying iterator type in the
    same way as `match_results`, so if you''re matching `std::string` input you want
    `std::sregex_iterator` and if you''re matching on `const char *` input you want
    `std::cregex_iterator`. Here''s the preceding example, recoded in terms of `sregex_iterator`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库提供了一个名为 `std::regex_iterator` 的“便利”类型，它将封装前面代码片段的逻辑；使用 `regex_iterator` 可能会节省你一些与零长度匹配相关的微妙错误。遗憾的是，它不会节省你的任何打字，而且它略微增加了悬挂迭代器陷阱的可能性。`regex_iterator`
    与 `match_results` 一样，在底层迭代器类型上进行了模板化，所以如果你正在匹配 `std::string` 输入，你想要 `std::sregex_iterator`，如果你正在匹配
    `const char *` 输入，你想要 `std::cregex_iterator`。以下是将前面的示例重新编码为 `sregex_iterator`
    的代码：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Consider how this awkward for-loop might benefit from a helper class, along
    the lines
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下这个笨拙的 for 循环如何从辅助类中受益
- en: of `streamer<T>` from the example near the end of [Chapter 9](part0144.html#49AH00-2fdac365b8984feebddfbb9250eaf20d),
    *Iostreams*.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 [第9章末尾的示例](part0144.html#49AH00-2fdac365b8984feebddfbb9250eaf20d) 的 `streamer<T>`，*Iostreams*。
- en: 'You can also iterate over the submatches within each match, either manually
    or using a "convenience" library type. Manually, it would look something like
    this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以手动遍历每个匹配中的子匹配，或者使用一个“便利”库类型。手动的话，看起来可能像这样：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Recall that `regex_iterator` is just a wrapper around `regex_search`, so `m.prefix()`
    in this case is guaranteed to hold an entire non-matching portion, all the way
    back to the end of the previous match. By alternately pushing back non-matching
    prefixes and matches, and finishing with a special case for the non-matching suffix,
    we split the input string into a vector of "words" alternating with "word separators."
    It's easy to modify this code to save only the "words" or only the "separators"
    if that's all you need; or even to save `m[1]` instead of `m[0]`, and so forth.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，`regex_iterator` 只是 `regex_search` 的包装，所以在这种情况下，`m.prefix()` 保证包含整个非匹配部分，一直回溯到上一个匹配的末尾。通过交替推送非匹配前缀和匹配项，并以非匹配后缀的特殊情况结束，我们将输入字符串分割成一个交替出现
    "单词" 和 "单词分隔符" 的向量。如果要保存的只是 "单词" 或 "分隔符"，或者甚至要保存 `m[1]` 而不是 `m[0]`，则很容易修改此代码；或者甚至保存
    `m[1]` 而不是 `m[0]`，等等。
- en: The library type `std::sregex_token_iterator` encapsulates all of this logic
    very directly, although its constructor interface is fairly confusing if you aren't
    already familiar with the preceding manual code. `sregex_token_iterator`'s constructor
    takes an input iterator-pair, a regex, and then a *vector of submatch indices*,
    where the index `-1` is a special case meaning "prefixes (and also, suffix)."
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 库类型 `std::sregex_token_iterator` 非常直接地封装了所有这些逻辑，尽管如果你不熟悉前面的手动代码，其构造函数接口相当复杂。`sregex_token_iterator`
    的构造函数接受一个输入迭代器对、一个正则表达式，然后是一个 *子匹配索引的向量*，其中索引 `-1` 是一个特殊情况，表示 "前缀（以及后缀）。"
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If we change the array `{-1, 0}` to just `{0}`, then our resulting vector will
    contain
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将数组 `{-1, 0}` 改为仅 `{0}`，那么我们的结果向量将只包含
- en: only the pieces of the input string matching `rx`. If we change it to `{1, 2,
    3}`, our
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 仅匹配 `rx` 的输入字符串的片段。如果我们将其更改为 `{1, 2, 3}`，我们的
- en: 'loop will see only those submatches (`m[1]`, `m[2]`, and `m[3]`) in each match
    `m` of `rx`. Recall that because of the `|` operator, submatches can be bypassed,
    leaving `m[k].matched` false. `regex_token_iterator` does not skip those matches.
    For example:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 循环将只看到每个 `rx` 匹配 `m` 中的那些子匹配（`m[1]`、`m[2]` 和 `m[3]`）。回想一下，由于 `|` 操作符，子匹配可以被跳过，使得
    `m[k].matched` 为假。`regex_token_iterator` 不会跳过这些匹配。例如：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The most attractive use of `regex_token_iterator` might be to split a string
    into "words" at whitespace boundaries. Unfortunately it is not significantly easier
    to use--or to debug--than old-school approaches such as `istream_iterator<string>`
    (see [Chapter 9](part0144.html#49AH00-2fdac365b8984feebddfbb9250eaf20d), *Iostreams*)
    or `strtok_r`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`regex_token_iterator` 最吸引人的用途可能是将字符串在空白边界处分割成 "单词"。不幸的是，它并不比老式方法（如 `istream_iterator<string>`
    （见第 9 章 [part0144.html#49AH00-2fdac365b8984feebddfbb9250eaf20d]，*Iostreams*）或
    `strtok_r`）更容易使用——或者更容易调试。'
- en: Using regular expressions for string replacement
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用正则表达式进行字符串替换
- en: If you're coming from Perl, or if you often use the command-line utility `sed`,
    you probably think of regexes primarily as a way to *modify* strings--for example,
    "remove all substrings matching this regex," or "replace all instances of this
    word with another word." The C++ standard library does provide a sort of replace-by-regex
    functionality, under the name `std::regex_replace`. It's based on the JavaScript
    `String.prototype.replace` method, which means that it comes with its own idiosyncratic
    formatting mini-language.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自 Perl，或者你经常使用命令行工具 `sed`，你可能会主要将正则表达式视为修改字符串的一种方式——例如，"删除所有匹配此正则表达式的子串"，或者"将所有此单词的实例替换为另一个单词"。C++
    标准库确实提供了一种名为 `std::regex_replace` 的正则表达式替换功能。它是基于 JavaScript 的 `String.prototype.replace`
    方法，这意味着它自带了一种独特的格式化迷你语言。
- en: '`std::regex_replace(str, rx, "replacement")` returns a `std::string` constructed
    by searching through `str` for every substring matching the regex `rx` and replacing
    each such substring with the literal string `"replacement"`. For example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::regex_replace(str, rx, "replacement")` 返回一个由 `std::string` 构造的字符串，该字符串通过在
    `str` 中搜索每个匹配正则表达式 `rx` 的子串，并将每个这样的子串替换为字面字符串 `"replacement"`。例如：'
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: However, if `"replacement"` contains any `'$'` characters, special things will
    happen!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果 `"replacement"` 包含任何 `'$'` 字符，会发生特殊的事情！
- en: '`"$&"` is replaced with the entire matching substring, `m[0]`. Both libstdc++
    and libc++ support `"$0"` as a non-standard synonym for `"$&"`.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"$&"` 被替换为整个匹配子串，`m[0]`。libstdc++ 和 libc++ 都支持 `"$0"` 作为 `"$&"` 的非标准同义词。'
- en: '`"$1"` is replaced with the first submatch, `m[1]`; `"$2"` is replaced with
    `m[2]`; and so on, all the way up to `"$99"`. There is no way to refer to the
    100th submatch. `"$100"` represents "`m[10]` followed by a literal `''0''`." To
    express "`m[1]` followed by a literal `''0''`," write `"$010"`.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"$1"`被替换为第一个子匹配`m[1]`；`"$2"`被替换为`m[2]`；以此类推，直到`"$99"`。无法引用第100个子匹配。`"$100"`表示"`m[10]`"后面跟着一个字面字符`''0''`。要表示"`m[1]`"后面跟着一个字面字符`''0''`，请写`"$010"`。'
- en: '``"$`"`` (that''s a backtick) is replaced with `m.prefix()`.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"$`"`（这是一个反引号）被替换为`m.prefix()`。'
- en: '`"$''"` (that''s a single-quote) is replaced with `m.suffix()`.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"$''"`（这是一个单引号）被替换为`m.suffix()`。'
- en: '`"$$"` is replaced with a literal dollar sign.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"$$"`被替换为一个字面美元符号。'
- en: Notice that ``"$`"`` and `"$'"` are far from symmetrical, because `m.prefix()`
    always refers to the part of the string between the end of the last match and
    the start of the current one, but `m.suffix()` always refers to the part of the
    string between the end of the current match and the *end of the string*! You'll
    never use either ``"$`"`` or `"$'"` in real code.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`"$`"`和`"$'"`远非对称，因为`m.prefix()`始终指向最后一个匹配的末尾和当前匹配的开始之间的字符串部分，而`m.suffix()`始终指向当前匹配的末尾和字符串末尾之间的字符串部分！你永远不会在实际代码中使用`"$`"`或`"$'"`。
- en: 'Here''s an example of using `regex_replace` to remove all the instances of
    `std::` from a piece of code, or to change them all to `my::`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用`regex_replace`从代码片段中删除所有`std::`实例或将它们全部更改为`my::`的示例：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'JavaScript''s `String.prototype.replace` allows you to pass in an arbitrary
    function instead of a dollar-sign-studded format string. C++''s `regex_replace`
    doesn''t support arbitrary functions yet, but it''s easy to write your own version
    that does:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的`String.prototype.replace`允许你传入一个任意函数而不是带美元符号的格式字符串。C++的`regex_replace`目前还不支持任意函数，但可以轻松编写自己的版本来实现这一点：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: With this improved `regex_replace` in hand, you can perform complicated operations
    such as "convert every identifier from `snake_case` to `CamelCase`" with ease.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个改进的`regex_replace`，你可以轻松执行复杂的操作，例如“将每个标识符从`snake_case`转换为`CamelCase`”。
- en: This concludes our whirlwind tour of the facilities provided in C++'s `<regex>`
    header. The remainder of this chapter consists of a detailed introduction to the
    ECMAScript dialect of regex notation. I hope it will be useful to readers who
    haven't worked with regexes before, and that it will serve as a refresher and
    reference for those who have.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对C++ `<regex>`头文件中提供的功能的快速浏览。本章的其余部分是对ECMAScript方言的正则表达式符号的详细介绍。我希望它对之前没有使用过正则表达式的读者有所帮助，并且对那些已经使用过正则表达式的人来说，它将作为一个复习和参考。
- en: A primer on the ECMAScript regex grammar
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ECMAScript正则表达式语法的入门指南
- en: 'The rules for reading and writing regexes in the ECMAScript dialect are simple.
    A regex is just a string of characters (such as `a[bc].d*e`), and you read it
    from left to right. Most characters represent only themselves, so that `cat` is
    a valid regex and matches only the literal string `"cat"`. The only characters
    that don''t represent themselves--and thus the only way to build regexes that
    represent languages more interesting than `"cat"`--are the following punctuation
    characters:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在ECMAScript方言中读取和编写正则表达式的规则很简单。正则表达式只是一系列字符（例如`a[bc].d*e`），并且你应该从左到右读取它。大多数字符仅代表自身，因此`cat`是一个有效的正则表达式，仅匹配字面字符串`"cat"`。唯一不表示自身的字符——也是构建表示比`"cat"`更有趣的语言的正则表达式的唯一方式——是以下标点符号：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`\`--if you''re using a regex to describe a set of strings involving punctuation
    characters, you can use a backslash to escape those special characters. For example,
    `\$42\.00` is a regex for the singleton language whose only member is the string
    `"$42.00"`. Perhaps confusingly, backslash is *also* used to turn some normal
    characters into special characters! `n` is a regex for the letter "n", but `\n`
    is a regex for the newline character. `d` is a regex for the letter "d", but `\d`
    is a regex equivalent to `[0-9]`.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`\`——如果你使用正则表达式来描述涉及标点符号的字符串集合，你可以使用反斜杠来转义这些特殊字符。例如，`\$42\.00`是一个正则表达式，表示只包含字符串`"$42.00"`的单例语言。也许有些令人困惑的是，反斜杠还被用来将一些普通字符转换为特殊字符！`n`是一个表示字母“n”的正则表达式，但`\n`是一个表示换行符的正则表达式。`d`是一个表示字母“d”的正则表达式，但`\d`是一个等同于`[0-9]`的正则表达式。'
- en: 'The complete list of backslash characters recognized by C++''s regex grammar
    is:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: C++的正则表达式语法所识别的反斜杠字符的完整列表是：
- en: '`\1`, `\2`, ... `\10`, ... for backreferences (to be avoided)'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\1`、`\2`、... `\10`、... 用于后向引用（应避免使用）'
- en: '`\b` for a word boundary and `\B` for `(?!\b)`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\b`用于单词边界和`\B`用于`(?!\b)`'
- en: '`\d` for `[[:digit:]]` and `\D` for `[^[:digit:]]`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\d` 用于 `[[:digit:]]` 和 `\D` 用于 `[^[:digit:]]`'
- en: '`\s` for `[[:space:]]` and `\S` for `[^[:space:]]`'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\s` 用于 `[[:space:]]` 和 `\S` 用于 `[^[:space:]]`'
- en: '`\w` for `[0-9A-Za-z_]` and `\W` for `[^0-9A-Za-z_]`'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\w` 用于 `[0-9A-Za-z_]` 和 `\W` 用于 `[^0-9A-Za-z_]`'
- en: '`\cX` for various "control characters" (to be avoided)'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\cX` 用于各种“控制字符”（应避免使用）'
- en: '`\xXX` for hexadecimal, with the usual meaning'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\xXX` 用于十六进制，具有通常的含义'
- en: '`\u00XX` for Unicode, with the usual meaning'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\u00XX` 用于 Unicode，具有通常的含义'
- en: '`\0`, `\f`, `\n`, `\r`, `\t`, `\v` with their usual meanings'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\0`、`\f`、`\n`、`\r`、`\t`、`\v` 具有它们通常的含义'
- en: '`.`--This special character represents "exactly one character," with almost
    no other requirements. For example, `a.c` is a valid regex and matches inputs
    such as `"aac"`, `"a!c"`, and `"a\0c"`. However, `.` will *never* match a newline
    or carriage-return character; and because C++ regexes work at the byte level,
    not the Unicode level, `.` will match any single byte (other than `''\\n''` and
    `''\\r''`) but will never match a sequence of multiple bytes even if they happen
    to make up a valid UTF-8 codepoint.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`.`——这个特殊字符表示“正好一个字符”，几乎没有其他要求。例如，`a.c` 是一个有效的正则表达式，并匹配如 `"aac"`、`"a!c"` 和
    `"a\0c"` 这样的输入。然而，`.` 永远不会匹配换行符或回车符；并且由于 C++ 正则表达式在字节级别工作，而不是在 Unicode 级别，`.`
    会匹配任何单个字节（除了 `''\\n''` 和 `''\\r''`），但即使它们偶然组成一个有效的 UTF-8 代码点，也不会匹配多个字节的序列。'
- en: '`[]`--A group of characters enclosed in square brackets represents "exactly
    one of this set," so that `c[aou]t` is a valid regex and matches the strings `"cat"`,
    `"cot"`, and `"cut"`. You can use square-bracket syntax to "escape" most characters;
    for example, `[$][.][*][+][?][(][)][[][{][}][|]` is a regex for the singleton
    language whose only member is the string `"$.*+?()[{}|"`. However, you cannot
    use brackets to escape `]`, `\`, or `^`.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`[]`——一个包含在方括号内的字符组表示“正好是这个集合中的一个”，因此 `c[aou]t` 是一个有效的正则表达式，并匹配字符串 `"cat"`、`"cot"`
    和 `"cut"`。你可以使用方括号语法来“转义”大多数字符；例如，`[$][.][*][+][?][(][)][[][{][}][|]` 是一个单成员语言的正则表达式，其唯一成员是字符串
    `"$.*+?()[{}|"`。然而，你不能使用方括号来转义 `]`、`\` 或 `^`。'
- en: '`[^]`--A group of characters enclosed in square brackets with a leading `^`
    represents "exactly one, *not* of this set," so that `c[^aou]t` will match `"cbt"`
    or `"c^t"` but not `"cat"`. The ECMAScript dialect does not treat the trivial
    cases `[]` or `[^]` specially; `[]` means "exactly one character from the empty
    set" (which is to say, it never matches anything), and `[^]` means "exactly one
    character *not* from the empty set" (which is to say, it matches any single character--just
    like `.` but better, because it *will* match newline and carriage-return characters).'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`[^]`——一个以 `^` 开头并包含在方括号内的字符组表示“正好一个，不是这个集合中的”，因此 `c[^aou]t` 将匹配 `"cbt"` 或
    `"c^t"` 但不会匹配 `"cat"`。ECMAScript 方言不特别处理 `[]` 或 `[^]` 的平凡情况；`[]` 表示“来自空集的正好一个字符”（也就是说，它永远不会匹配任何内容），而
    `[^]` 表示“不是来自空集的正好一个字符”（也就是说，它匹配任何单个字符——就像 `.` 但更好，因为它会匹配换行符和回车符）。'
- en: 'The `[]` syntax treats a couple more characters specially: If `-` appears inside
    square brackets anywhere except as the first or last character, it denotes a "range"
    with its left and right neighbors. So `ro[s-v]e` is a regex for the language whose
    members are the four strings `"rose"`, `"rote"`, `"roue"`, and `"rove"`. A few
    commonly useful ranges--the same ranges exposed via the `<ctype.h>` header--are
    built in using the syntax `[:foo:]` inside square brackets: `[[:digit:]]` is the
    same as `[0-9]`, `[[:upper:][:lower:]]` is the same as `[[:alpha:]]` is the same
    as `[A-Za-z]`, and so on.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`[]` 语法对一些字符有特殊处理：如果 `-` 出现在方括号内，除了作为第一个或最后一个字符外，它表示一个“范围”，其左右邻居为范围。因此，`ro[s-v]e`
    是一个正则表达式，用于匹配语言成员为四个字符串：“rose”、“rote”、“roue”和“rove”。一些常用范围——与 `<ctype.h>` 头文件中暴露的范围相同——使用方括号内的
    `[:foo:]` 语法内置：`[[:digit:]]` 与 `[0-9]` 相同，`[[:upper:][:lower:]]` 与 `[[:alpha:]]`
    相同，即 `[A-Za-z]`，等等。'
- en: 'There are also built-in syntaxes that look like `[[.x.]]` and `[[=x=]]`; they
    deal with locale-dependent comparisons and you will never have to use them. Merely
    be aware that if you ever need to include the character `[` inside a square-bracketed
    character class, it will be in your best interest to backslash-escape it: both
    `foo[=([;]` and `foo[(\[=;]` match the strings `"foo="`, `"foo("`, `"foo["`, and
    `"foo;"`, but `foo[([=;]` is an invalid regex and will throw an exception at runtime
    when you try to construct a `std::regex` object from it.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些内置语法看起来像 `[[.x.]]` 和 `[[=x=]]`；它们处理与区域设置相关的比较，你永远不会需要使用它们。只需知道，如果你需要在方括号字符类中包含字符
    `[`，最好使用反斜杠转义：`foo[=([;]` 和 `foo[(\[=;]` 匹配字符串 `"foo="`、`"foo("`、`"foo["` 和 `"foo;"`，但
    `foo[([=;]` 是一个无效的正则表达式，在尝试从它构造 `std::regex` 对象时会在运行时抛出异常。
- en: '`+`--An expression or single character followed immediately by `+` matches
    the previous expression or character any positive number of times. For example,
    the regex `ba+` matches the strings `"ba"`, `"baa"`, `"baaa"`, and so on.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`+`--一个表达式或单个字符后面紧跟 `+` 可以匹配前面的表达式或字符任意正次数。例如，正则表达式 `ba+` 匹配字符串 `"ba"`、`"baa"`、`"baaa"`
    等等。'
- en: '`*`--An expression or single character followed immediately by `*` matches
    the previous expression or character any number of times--even no times at all!
    So the regex `ba*` matches the strings `"ba"`, `"baa"`, and `"baaa"`, and also
    matches `"b"` alone.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`*`--一个表达式或单个字符后面紧跟 `*` 可以匹配前面的表达式或字符任意次数，包括零次。所以正则表达式 `ba*` 匹配字符串 `"ba"`、`"baa"`
    和 `"baaa"`，甚至单独的 `"b"`。'
- en: '`?`--An expression or single character followed immediately by `?` matches
    the previous expression or character exactly zero or one times. For example, `coo?t`
    is a regex matching only `"cot"` and `"coot"`.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`?`--一个表达式或单个字符后面紧跟 `?` 可以匹配前面的表达式或字符正好零次或一次。例如，正则表达式 `coo?t` 只匹配 `"cot"` 和
    `"coot"`。'
- en: '`{n}`--An expression or single character followed immediately by a curly-braced
    integer matches the previous expression or character exactly the number of times
    indicated. For example, `b(an){2}a` is a regex matching `"banana"`; `b(an){3}a`
    is a regex matching `"bananana"`.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`{n}`--一个表达式或单个字符后面紧跟一个花括号中的整数，会精确匹配前面的表达式或字符指定次数。例如，`b(an){2}a` 是一个匹配 `"banana"`
    的正则表达式；`b(an){3}a` 是一个匹配 `"bananana"` 的正则表达式。'
- en: '`{m,n}`--When the curly-braced construct has the form of two integers *m* and
    *n* separated by a comma, the construct matches the previous expression or character
    anywhere from *m* to *n* times (inclusive). So `b(an){2,3}a` is a regex matching
    only the strings `"banana"` and `"bananana"`.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`{m,n}`--当花括号结构由两个用逗号分隔的整数 *m* 和 *n* 组成时，该结构匹配前面的表达式或字符从 *m* 到 *n* 次数（包括）。所以
    `b(an){2,3}a` 是一个只匹配字符串 `"banana"` 和 `"bananana"` 的正则表达式。'
- en: '`{m,}`--Leaving *n* blank effectively makes it infinite; so `x{42,}` means
    "match `x` 42 or more times," and is equivalent to `x{42}x*`. The ECMAScript dialect
    does not allow leaving *m* blank.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`{m,}`--留空 *n* 实际上使其无限；所以 `x{42,}` 表示“匹配 `x` 42 次或更多”，相当于 `x{42}x*`。ECMAScript
    语法不允许留空 *m*。'
- en: '`|`--Two regular expressions can be "glued together" with `|` to express the
    idea of *either-or*. For example, `cat|dog` is a regex matching only the strings
    `"cat"` and `"dog"`; and `(tor|shark)nado` matches either `"tornado"` or `"sharknado"`.
    The `|` operator has very low precedence in regexes, just as it does in C++ expressions.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`|`--两个正则表达式可以用 `|` 连接起来，表示“或”的概念。例如，`cat|dog` 是一个只匹配字符串 `"cat"` 和 `"dog"`
    的正则表达式；而 `(tor|shark)nado` 匹配 `"tornado"` 或 `"sharknado"`。在正则表达式中，`|` 运算符的优先级非常低，就像它在
    C++ 表达式中的优先级一样。'
- en: '`()`--Parentheses work just as in mathematics, to enclose a sub-expression
    that you want to bind tightly together and treat as a unit. For example, `ba*`
    means "the character `b`, and then zero or more instances of `a`; but `(ba)*`
    means "zero or more instances of `ba`." So the former matches `"b"`, `"ba"`, `"baa"`,
    and so on; but the version with parentheses matches `""`, `"ba"`, `"baba"`, and
    so on.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`()`--括号的作用就像在数学中一样，用于括住一个子表达式，将其紧密绑定并作为一个单元处理。例如，`ba*` 表示“字符 `b`，然后是零个或多个
    `a` 的实例；但 `(ba)*` 表示“零个或多个 `ba` 的实例。”所以前者匹配 `"b"`、`"ba"`、`"baa"` 等等；但带括号的那个版本匹配
    `""`、`"ba"`、`"baba"` 等等。'
- en: Parentheses also have a second purpose--they are used not just for *grouping*
    but also for *capturing* parts of a match for further processing. Each opening
    `(` in the regex generates another submatch in the resulting `std::smatch` object.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 括号也有第二个用途--它们不仅用于 *分组*，还用于 *捕获* 匹配的部分以进行进一步处理。正则表达式中的每个开括号 `(` 都会在结果 `std::smatch`
    对象中生成另一个子匹配。
- en: 'If you want to group some subexpression tightly together without generating
    a submatch, you can use a *non-capturing* group with the syntax `(?:foo)`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将某些子表达式紧密地组合在一起而不生成子匹配，你可以使用语法 `(?:foo)` 的非捕获组：
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Non-capturing might be useful in some obscure context; but generally, it will
    be clearer to the reader if you just use regular capturing `()` and ignore the
    submatches you don't care about, as opposed to scattering `(?:)` around your codebase
    in an attempt to squelch all unused submatches. Unused submatches are very cheap,
    performance-wise.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 非捕获性可能在某些隐藏的上下文中很有用；但通常，如果你只是使用常规捕获 `()` 并忽略你不在乎的子匹配，而不是在你的代码库中散布 `(?:)` 以尝试压制所有未使用的子匹配，这将使读者更清楚。未使用的子匹配在性能上非常便宜。
- en: Non-consuming constructs
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非消耗性结构
- en: '`(?=foo)` matches the pattern `foo` against the input, and then "rewinds" so
    that none of the input is actually consumed. This is called "lookahead." So for
    example `c(?=a)(?=a)(?=a)at` matches `"cat"`; and `(?=.*[A-Za-z])(?=.*[0-9]).*`
    matches any string containing at least one alphabetic character and at least one
    digit.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`(?=foo)` 匹配输入中的模式 `foo`，然后“回滚”以使输入实际上没有消耗。这被称为“向前查看”。所以例如 `c(?=a)(?=a)(?=a)at`
    匹配 `"cat"`；而 `(?=.*[A-Za-z])(?=.*[0-9]).*` 匹配包含至少一个字母字符和至少一个数字的任何字符串。'
- en: '`(?!foo)` is a "negative lookahead"; it looks ahead to match `foo` against
    the input, but then *rejects* the match if `foo` would have accepted, and *accepts*
    the match if `foo` would have rejected. So, for example, `(?!\d)\w+` matches any
    C++ identifier or keyword--that is, any sequence of alphanumeric characters that
    does *not* start with a digit. Notice that the first character must not match
    `\d` but is not consumed by the `(?!\d)` construct; it must still be accepted
    by `\w`. The similar-looking regex `[^0-9]\w+` would "erroneously" accept strings
    such as `"#xyzzy"` which are not valid identifiers.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`(?!foo)` 是一个“负向前查看”；它向前查看以匹配输入中的 `foo`，但如果 `foo` 被接受，则*拒绝*匹配，如果 `foo` 被拒绝，则*接受*匹配。所以，例如，`(?!\d)\w+`
    匹配任何 C++ 标识符或关键字--也就是说，任何不以数字开头的字母数字字符序列。请注意，第一个字符必须不匹配 `\d` 但不被 `(?!\d)` 结构消耗；它仍然必须被
    `\w` 接受。类似外观的正则表达式 `[^0-9]\w+` 会“错误地”接受像 `"#xyzzy"` 这样的字符串，这些字符串不是有效的标识符。'
- en: Both `(?=)` and `(?!)` are not only non-consuming but also *non-capturing*,
    just like `(?:)`. But it is perfectly fine to write `(?=(foo))` to capture all
    or part of the "looked-ahead" portion.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`(?=)` 和 `(?!)` 不仅是非消耗性的，而且是*非捕获性的*，就像 `(?:)` 一样。但是，写 `(?=(foo))` 来捕获“向前查看”的部分的全部或部分是完全可行的。'
- en: '`^` and `$`--A caret `^` on its own, outside any square brackets, matches only
    at the beginning of the string to be matched; and `$` matches only at the end.
    This is useful to "anchor" the regex to the beginning or end of the input string,
    in the context of `std::regex_search`. In `std::regex::multiline` regexes, `^`
    and `$` act as "lookbehind" and "lookahead" assertions respectively:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`^` 和 `$`--一个单独的、不在任何方括号内的撇号 `^` 仅匹配要匹配的字符串的开始；而 `$` 仅匹配字符串的末尾。这在 `std::regex_search`
    的上下文中非常有用，可以“锚定”正则表达式到输入字符串的开始或结束。在 `std::regex::multiline` 正则表达式中，`^` 和 `$` 分别作为“向后查看”和“向前查看”断言：'
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Putting it all together, we might write the regex `foo[a-z_]+(\d|$)` to match
    "the letters `foo`, followed by one or more other letters and/or underscore; followed
    by either a digit or the end of the line."
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些放在一起，我们可能会写出正则表达式 `foo[a-z_]+(\d|$)` 来匹配“字母 `foo` 后跟一个或多个其他字母和/或下划线；然后跟一个数字或行尾。”
- en: If you need a deeper dive into regex syntax, consult [cppreference.com](https://cppreference.com).
    And if that's not enough--the best thing about C++'s copying the ECMAScript flavor
    of regexes is that any tutorial on JavaScript regexes will also be applicable
    to C++! You can even test out regular expressions in your browser's console. The
    only difference between C++ regexes and JavaScript regexes is that C++ supports
    the double-square-bracket syntax for character classes such as `[[:digit:]]`,
    `[[.x.]]`, and `[[=x=]]`, whereas JavaScript doesn't. JavaScript treats those
    regexes as equivalent to `[\[:digt]\]`, `[\[.x]\]`, and `[\[=x]\]` respectively.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要深入了解正则表达式语法，请参阅 [cppreference.com](https://cppreference.com)。如果还不够--C++
    从 ECMAScript 风格的正则表达式复制来的最好之处在于，任何关于 JavaScript 正则表达式的教程也适用于 C++！你甚至可以在浏览器控制台中测试正则表达式。C++
    正则表达式和 JavaScript 正则表达式之间的唯一区别是，C++ 支持字符类如 `[[:digit:]]`、`[[.x.]]` 和 `[[=x=]]`
    的双方括号语法，而 JavaScript 不支持。JavaScript 将这些正则表达式视为与 `[\[:digit:]]`、`[\[.x\]]` 和 `[\[=x\]]`
    分别等价。
- en: Obscure ECMAScript features and pitfalls
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐藏的 ECMAScript 功能和陷阱
- en: Earlier in this chapter I mentioned a few features of `std::regex` that you
    would be better off to avoid, such as `std::regex::collate`, `std::regex::optimize`,
    and flags that change the dialect away from ECMAScript. The ECMAScript regex grammar
    itself contains a few obscure and avoid worthy features as well.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期，我提到了一些 `std::regex` 的特性，你最好避免使用，例如 `std::regex::collate`、`std::regex::optimize`
    以及改变方言远离 ECMAScript 的标志。ECMAScript 正则表达式语法本身也包含一些晦涩且应避免的特性。
- en: A backslash followed by one or more digits (other than `\0`) creates a *backreference*.
    The backreference `\1` matches "the same sequence of characters that was matched
    by my first capturing group"; so for example the regex `(cat|dog)\1` will match
    the strings `"catcat"` and `"dogdog"` but not `"catdog"`, and `(a*)(b*)c\2\1`
    will match `"aabbbcbbbaa"` but not `"aabbbcbbba"`. Backreferences can have subtly
    weird semantics, especially when combined with non-consuming constructs such as
    `(?=foo)`, and I recommend avoiding them when possible.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一个反斜杠后跟一个或多个数字（除了 `\0`）会创建一个**回溯引用**。回溯引用 `\1` 匹配“与我第一个捕获组匹配的相同字符序列”；例如，正则表达式
    `(cat|dog)\1` 会匹配字符串 `"catcat"` 和 `"dogdog"`，但不会匹配 `"catdog"`，而 `(a*)(b*)c\2\1`
    会匹配 `"aabbbcbbbaa"`，但不会匹配 `"aabbbcbbba"`。回溯引用可以具有微妙而奇怪的语义，特别是当与 `(?=foo)` 这样的非消耗性构造结合使用时，我建议在可能的情况下避免使用它们。
- en: If you're having trouble with backreferences, the first thing to check is your
    backslash-escaping. Remember that `std::regex("\1")` is a regex matching ASCII
    control character number 1\. What you meant to type was `std::regex("\\1")`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到回溯引用的问题，首先检查的是你的反斜杠转义。记住，`std::regex("\1")` 是匹配 ASCII 控制字符编号 1 的正则表达式。你本想输入的是
    `std::regex("\\1")`。
- en: Using backreferences takes you out of the world of *regular languages* and into
    the wider world of *context-sensitive languages*, which means that the library
    must trade in its extremely efficient finite-state-machine-based matching algorithm
    for more powerful but expensive and slow "backtracking" algorithms. This seems
    like another good reason to avoid backreferences unless they're absolutely necessary.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用回溯引用将你带出了**正则语言**的世界，进入了更广泛的**上下文相关语言**的世界，这意味着库必须放弃其基于有限状态机的高效匹配算法，转而使用更强大但昂贵且缓慢的“回溯”算法。这似乎是避免回溯引用的另一个很好的理由，除非它们绝对必要。
- en: However, as of 2017, most vendors do not actually switch algorithms based on
    the *presence* of backreferences in a regex; they'll use the slower backtracking
    algorithm based on the *mere possibility* of backreferences in the ECMAScript
    regex dialect. And then, because no vendor wants to implement a whole second algorithm
    just for the backreference-less dialects `std::regex::awk` and `std::regex::extended`,
    they end up using the backtracking algorithm even for those dialects! Similarly,
    most vendors will implement `regex_match(s, rx)` in terms of `regex_match(s, m,
    rx)` and then throw out the expensively computed `m`, rather than using a potentially
    faster algorithm for `regex_match(s, rx)`. Optimizations like this might come
    to a library near you sometime in the next 10 years, but I wouldn't hold your
    breath waiting for them.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，截至 2017 年，大多数供应商实际上并不会根据正则表达式中的**回溯引用的存在**来切换算法；他们会在 ECMAScript 正则表达式方言中基于回溯引用的**可能性**使用较慢的回溯算法。然后，因为没有任何供应商愿意为没有回溯引用的方言
    `std::regex::awk` 和 `std::regex::extended` 实现整个第二个算法，他们最终甚至为这些方言使用回溯算法！同样，大多数供应商将
    `regex_match(s, rx)` 实现为 `regex_match(s, m, rx)`，然后丢弃昂贵的计算结果 `m`，而不是使用可能更快的 `regex_match(s,
    rx)` 算法。这样的优化可能在未来的 10 年内出现在某个库中，但我不会为此而等待。
- en: 'Another obscure quirk is that the `*`, `+`, and `?` quantifiers are all *greedy*
    by default, meaning that, for example, `(a*)` will prefer to match as many `a`
    characters as it can. You can turn a greedy quantifier *non-greedy* by suffixing
    an extra `?`; so for example `(a*?)` matches the *smallest* number of `a` characters
    it can. This makes no difference at all unless you''re using capturing groups.
    Here''s an example:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个鲜为人知的特性是，`*`、`+` 和 `?` 量词默认都是**贪婪的**，这意味着例如 `(a*)` 会尽可能多地匹配 `a` 字符。你可以通过在量词后附加一个额外的
    `?` 来将贪婪量词转换为**非贪婪的**；例如 `(a*?)` 会匹配尽可能少的 `a` 字符。除非你使用捕获组，否则这不会产生任何区别。以下是一个例子：
- en: '[PRE23]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the first case, `.*` greedily matches `abc`, leaving only `d` to be matched
    by the capturing group. In the second case, `.*?` non-greedily matches only `a`,
    leaving `bcd` for the capturing group. (In fact, `.*?` would have preferred to
    match the empty string; but it couldn't do that without the overall match being
    rejected.)
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，`.*` 贪婪地匹配 `abc`，只留下 `d` 由捕获组进行匹配。在第二种情况下，`.*?` 非贪婪地只匹配 `a`，留下 `bcd`
    给捕获组。实际上，`.*?` 更愿意匹配空字符串；但是，如果没有整体匹配被拒绝，它就不能这样做。
- en: Notice that the syntax for non-greediness doesn't follow the "normal" rules
    of operator composition. From what we know of C++'s operator syntax, we'd expect
    that `a+*` would mean `(a+)*` (which it does) and `a+?` would mean `(a+)?` (which
    it doesn't). So, if you see consecutive punctuation characters in a regular expression,
    watch out--it may mean something different from what your intuition tells you!
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，非贪婪性的语法并不遵循“正常”的运算符组合规则。根据我们对 C++ 运算符语法的了解，我们预计 `a+*` 应该意味着 `(a+)*`（它确实如此），而
    `a+?` 应该意味着 `(a+)?`（但它并不这样）。因此，如果你在正则表达式中看到连续的标点符号字符，要小心——它可能意味着与你的直觉告诉你的不同！
- en: Summary
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Regular expressions (regexes) are a good way to *lex* out the pieces of an input
    string before parsing them. The default regex dialect in C++ is the same as in
    JavaScript. Use this to your advantage.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式（regexes）是在解析之前从输入字符串中提取片段的好方法。C++ 中的默认正则表达式方言与 JavaScript 相同。利用这一点。
- en: Prefer to avoid raw string literals in situations where an extra pair of parentheses
    could be confusing. When possible, limit the number of escaped backslashes in
    your regexes by using square brackets to escape special characters instead.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，避免使用原始字符串字面量，因为额外的括号可能会造成混淆。在正则表达式中，尽可能限制转义反斜杠的数量，通过使用方括号来转义特殊字符。
- en: '`std::regex rx` is basically immutable and represents a finite state machine.
    `std::smatch m` is mutable and holds information about a particular match within
    the haystack string. Submatch `m[0]` represents the whole matched substring; `m[k]`
    represents the *k*th capturing group.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::regex rx` 基本上是不可变的，代表一个有限状态机。`std::smatch m` 是可变的，并包含关于草堆字符串中特定匹配的信息。子匹配
    `m[0]` 代表整个匹配的子字符串；`m[k]` 代表第 *k* 个捕获组。'
- en: '`std::regex_match(s, m, rx)` matches the needle against the *entire* haystack
    string; `std::regex_search(s, m, rx)` looks for the needle *in* the haystack.
    Remember that the haystack goes first and the needle goes last, just like in JavaScript
    and Perl.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::regex_match(s, m, rx)` 将针针对整个草堆字符串进行匹配；`std::regex_search(s, m, rx)`
    在草堆中寻找针。记住，草堆在前，针在后，就像在 JavaScript 和 Perl 中一样。'
- en: '`std::regex_iterator`, `std::regex_token_iterator`, and `std::regex_replace`
    are relatively inconvenient "convenience" functions built on top of `regex_search`.
    Get comfortable with `regex_search` before worrying about these wrappers.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`std::regex_iterator`, `std::regex_token_iterator`, 和 `std::regex_replace`
    是在 `regex_search` 基础上构建的相对不便的“便利”函数。在使用这些包装器之前，先熟悉 `regex_search`。'
- en: Beware of dangling-iterator bugs! Never modify or destroy a `regex` that is
    still referenced by `regex_iterator`; and never modify or destroy a `string` that
    is still referenced by `smatch`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 警惕悬挂迭代器错误！永远不要修改或销毁一个仍被 `regex_iterator` 引用的 `regex`；永远不要修改或销毁一个仍被 `smatch`
    引用的 `string`。
