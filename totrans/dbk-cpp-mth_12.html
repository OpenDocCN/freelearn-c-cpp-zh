<html><head></head><body>
  <div id="_idContainer038">
   <h1 class="chapter-number" id="_idParaDest-121">
    <a id="_idTextAnchor120">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     12
    </span>
   </h1>
   <h1 id="_idParaDest-122">
    <a id="_idTextAnchor121">
    </a>
    <span class="koboSpan" id="kobo.2.1">
     Rust Will Replace C++
    </span>
   </h1>
   <p class="italic-heading">
    <em class="italic">
     <span class="koboSpan" id="kobo.3.1">
      If 4 things
     </span>
    </em>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.4.1">
       happen concomitantly
      </span>
     </em>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.5.1">
     Rust rose as a contender for systems programming and C++ in the past years.
    </span>
    <span class="koboSpan" id="kobo.5.2">
     There are good reasons for this: Rust is a modern language, providing a good toolset, simple syntax, and innovations that help reason about the code.
    </span>
    <span class="koboSpan" id="kobo.5.3">
     The question of whether Rust will replace C++ is therefore on the minds of many programmers who would like to know where to invest their efforts for the future of their careers.
    </span>
    <span class="koboSpan" id="kobo.5.4">
     We will look next at what makes Rust interesting and at what would need to happen for it to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.6.1">
      replace C++.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.7.1">
     In this chapter, we’re going to cover the following
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.8.1">
      main topics:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.9.1">
      Why
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.10.1">
       the competition?
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.11.1">
      Core features
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.12.1">
       of Rust
      </span>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.13.1">
       Rust’s advantages
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.14.1">
      Where C++
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.15.1">
       is better
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.16.1">
      What C++
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.17.1">
       still needs
      </span>
     </span>
    </li>
   </ul>
   <h1 id="_idParaDest-123">
    <a id="_idTextAnchor122">
    </a>
    <span class="koboSpan" id="kobo.18.1">
     Technical requirements
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.19.1">
     The code for this chapter is available in the GitHub repository (
    </span>
    <a href="https://github.com/PacktPublishing/Debunking-C-Myths">
     <span class="koboSpan" id="kobo.20.1">
      https://github.com/PacktPublishing/Debunking-C-Myths
     </span>
    </a>
    <span class="koboSpan" id="kobo.21.1">
     ), in the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.22.1">
      ch12
     </span>
    </strong>
    <span class="koboSpan" id="kobo.23.1">
     folder.
    </span>
    <span class="koboSpan" id="kobo.23.2">
     To run the code, you will need Rust, using the instructions from
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.24.1">
      their website:
     </span>
    </span>
   </p>
   <p>
    <a href="https://www.rust-lang.org/tools/install">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.25.1">
       https://www.rust-lang.org/tools/install
      </span>
     </span>
    </a>
   </p>
   <h1 id="_idParaDest-124">
    <a id="_idTextAnchor123">
    </a>
    <span class="koboSpan" id="kobo.26.1">
     Why the competition?
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.27.1">
     As a junior C++ programmer working abroad in Paris around 2001, my biggest challenge was to make my code do what it needed to do.
    </span>
    <span class="koboSpan" id="kobo.27.2">
     The project was a knowledge base for industrial printing presses, allowing operators to identify the source of printing errors.
    </span>
    <span class="koboSpan" id="kobo.27.3">
     Back then, the main option for such desktop applications was C++ under Windows, developed with Visual C++,
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.28.1">
      Microsoft Foundation Class
     </span>
    </strong>
    <span class="koboSpan" id="kobo.29.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.30.1">
      MFC
     </span>
    </strong>
    <span class="koboSpan" id="kobo.31.1">
     ), and Windows APIs, designed with the Document-View model, a
    </span>
    <a id="_idIndexMarker405">
    </a>
    <span class="koboSpan" id="kobo.32.1">
     weaker cousin of Model-View-Controller promoted by Microsoft.
    </span>
    <span class="koboSpan" id="kobo.32.2">
     The project challenged me to the maximum: not only was I struggling with C++ memory management but I also had to deal with the quirks of MFC and Windows APIs.
    </span>
    <span class="koboSpan" id="kobo.32.3">
     My support back then was the official documentation, the
    </span>
    <a href="https://codeproject.com">
     <span class="koboSpan" id="kobo.33.1">
      https://codeproject.com
     </span>
    </a>
    <span class="koboSpan" id="kobo.34.1">
     website, and one more experienced colleague who was rarely available.
    </span>
    <span class="koboSpan" id="kobo.34.2">
     Basically, I had to deal with a complex technology, as a sole developer, without a lot of support.
    </span>
    <span class="koboSpan" id="kobo.34.3">
     Welcome to software development in the 2000s!
    </span>
    <span class="koboSpan" id="kobo.34.4">
     Don’t get me wrong, I’m not complaining: because of its challenges, the experience was deeply helpful
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.35.1">
      and educational.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.36.1">
     My sole focus at that point was the technology I was using.
    </span>
    <span class="koboSpan" id="kobo.36.2">
     I had heard of things such as PHP, and I had used Java before for applets and web applications, but C++, MFC, and Windows APIs were filling my bandwidth.
    </span>
    <span class="koboSpan" id="kobo.36.3">
     It didn’t help that the commute took around 90 minutes, enough time to read the whole
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.37.1">
      Lord of the Rings
     </span>
    </em>
    <span class="koboSpan" id="kobo.38.1">
     book on public transport over the course of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.39.1">
      a year.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.40.1">
     A second important project in my career was completely different: still C++, but a very structured and mentored approach to building a NoSQL database engine before such a thing was named.
    </span>
    <span class="koboSpan" id="kobo.40.2">
     At that time, I learned how to write tests, and we wrote our own testing engine since there was none for C++.
    </span>
    <span class="koboSpan" id="kobo.40.3">
     I learned a lot about software design by writing design documents and reviewing them with colleagues.
    </span>
    <span class="koboSpan" id="kobo.40.4">
     I learned about code reviews.
    </span>
    <span class="koboSpan" id="kobo.40.5">
     I learned C++ ins and outs through a deep dive into seminal books that included Scott Meyers’
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.41.1">
      Effective C++
     </span>
    </em>
    <span class="koboSpan" id="kobo.42.1">
     and
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.43.1">
      More Effective C++
     </span>
    </em>
    <span class="koboSpan" id="kobo.44.1">
     , and Andrei Alexandrescu’s
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.45.1">
      Modern C++ Design
     </span>
    </em>
    <span class="koboSpan" id="kobo.46.1">
     .
    </span>
    <span class="koboSpan" id="kobo.46.2">
     So, I went even deeper into the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.47.1">
      same technology.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.48.1">
     Then C# appeared, and I decided to switch technologies.
    </span>
    <span class="koboSpan" id="kobo.48.2">
     After doing some Java, having a deep knowledge of C++, and going in a structured manner into C#, I realized two things: changing technologies is easier the more you do it, and each technology has its own advantages and disadvantages.
    </span>
    <span class="koboSpan" id="kobo.48.3">
     Desktop applications were much easier to build in C# since we had to pay less attention to memory management and its potential issues.
    </span>
    <span class="koboSpan" id="kobo.48.4">
     Programming was more fun, and more importantly, we were developing faster.
    </span>
    <span class="koboSpan" id="kobo.48.5">
     We traded these two benefits for two downsides: less control and a less rigorous approach
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.49.1">
      to programming.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.50.1">
     Later in my career, I started wondering about the plethora of programming languages available in the marketplace.
    </span>
    <span class="koboSpan" id="kobo.50.2">
     In my estimation, we would need about 5-7 programming languages for purely technical reasons: one for web, one for systems programming, one for scripting, and the rest for various niches like AI, workflows, solving equations, and so on.
    </span>
    <span class="koboSpan" id="kobo.50.3">
     Let’s say I’m wrong and we would need 20.
    </span>
    <span class="koboSpan" id="kobo.50.4">
     However, the reality is that we can use hundreds of programming languages today, including mainstream, niche, and esoteric languages such as Brainfuck or Whitespace.
    </span>
    <span class="koboSpan" id="kobo.50.5">
     We can see many of them in the TIOBE Programming Community index that monitors the popularity of programming languages.
    </span>
    <span class="koboSpan" id="kobo.50.6">
     Why are there
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.51.1">
      so many?
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.52.1">
     My best guess is that it’s not a matter of technical needs, but one of culture.
    </span>
    <span class="koboSpan" id="kobo.52.2">
     Sure, the technical aspects are important.
    </span>
    <span class="koboSpan" id="kobo.52.3">
     Object-oriented and later functional programming features were introduced in all mainstream languages.
    </span>
    <span class="koboSpan" id="kobo.52.4">
     Security, parallelism and concurrency, ease of programming, the community, and the ecosystem are all important aspects of a programming language.
    </span>
    <span class="koboSpan" id="kobo.52.5">
     However, the decision to make a new programming language comes from people, and the decisions they make when designing the language come from their personal preferences.
    </span>
    <span class="koboSpan" id="kobo.52.6">
     Trends in literature and philosophy follow the same pattern: current and counter-current or reactionary.
    </span>
    <span class="koboSpan" id="kobo.52.7">
     In literature, Romanticism was a reaction to Classicism, and realism was a reaction to Romanticism.
    </span>
    <span class="koboSpan" id="kobo.52.8">
     Something similar happens with programming languages: Java was a reaction to C++, and Ruby on Rails was a reaction to Java.
    </span>
    <span class="koboSpan" id="kobo.52.9">
     While in literature, currents are partially determined by societal changes, in technology, the currents are determined both by the movements in the landscape and the preferences of younger generations of programmers, added at a very high pace.
    </span>
    <span class="koboSpan" id="kobo.52.10">
     An example of the technological landscape change is the rise of the internet, which has favored the rise of Java as a reaction to C++ for web applications.
    </span>
    <span class="koboSpan" id="kobo.52.11">
     Interestingly, the movement of computation from server to client nowadays seems to favor the apparition of Web Assembly applications that currently require low-level programming in C++ or Rust.
    </span>
    <span class="koboSpan" id="kobo.52.12">
     As for the new generations of programmers, Ruby on Rails was very much a reaction to the perceived old-style Java language.
    </span>
    <span class="koboSpan" id="kobo.52.13">
     Rails offered freedoms of expression that Java didn’t, along with a feeling of satisfaction with the progress.
    </span>
    <span class="koboSpan" id="kobo.52.14">
     This feeling had little technical basis, but technical aspects aren’t everything for people, not even for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.53.1">
      software developers.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.54.1">
     You should see now where this is going: Rust is a reaction to C++.
    </span>
    <span class="koboSpan" id="kobo.54.2">
     It is a reaction both to current technical annoyances of C++ and to the ways C++ does things.
    </span>
    <span class="koboSpan" id="kobo.54.3">
     Let’s therefore look at what Rust brings to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.55.1">
      the table.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-125">
    <a id="_idTextAnchor124">
    </a>
    <span class="koboSpan" id="kobo.56.1">
     Core features of Rust
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.57.1">
     The first place we can use for understanding
    </span>
    <a id="_idIndexMarker406">
    </a>
    <span class="koboSpan" id="kobo.58.1">
     Rust’s core features is the official website,
    </span>
    <a href="https://www.rust-lang.org/">
     <span class="koboSpan" id="kobo.59.1">
      https://www.rust-lang.org/
     </span>
    </a>
    <span class="koboSpan" id="kobo.60.1">
     .
    </span>
    <span class="koboSpan" id="kobo.60.2">
     The site does a very good job of emphasizing the most important features
    </span>
    <a id="_idIndexMarker407">
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.61.1">
      of Rust:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.62.1">
      Fast
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.63.1">
       and memory-efficient
      </span>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.64.1">
       No runtime
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.65.1">
      No
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.66.1">
       garbage collector
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.67.1">
      Integrates with
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.68.1">
       other languages
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.69.1">
      Memory safety and thread safety through a rich type system and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.70.1">
       ownership model
      </span>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.71.1">
       Great documentation
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.72.1">
      Friendly compiler with useful
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.73.1">
       error messages
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.74.1">
      Integrated package manager and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.75.1">
       build tool
      </span>
     </span>
    </li>
    <li>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.76.1">
       Auto formatter
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.77.1">
      Smart multi-editor support with auto-completion and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.78.1">
       type inspections
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.79.1">
     From this description only, we can already see a few similarities with C++, along with improvements on the current state of C++.
    </span>
    <span class="koboSpan" id="kobo.79.2">
     The similarities are in the level of control: native compilation, no garbage collector, speed, and memory efficiency are qualities that C++ touts as well.
    </span>
    <span class="koboSpan" id="kobo.79.3">
     The differences point to things that we discussed at length in this book: standard package manager, standard tooling, and friendly compiler.
    </span>
    <span class="koboSpan" id="kobo.79.4">
     This last quality is music to the ears of any C++ programmer who got huge error messages; I remember back in the 2000s, I got an error in Visual C++ that said something along the lines of “error messages are too long and we can’t display them”.
    </span>
    <span class="koboSpan" id="kobo.79.5">
     While today’s C++ is friendlier, figuring out what didn’t work while using templates is still
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.80.1">
      a pain.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.81.1">
     However, let’s look beyond what’s written on the front page of the website.
    </span>
    <span class="koboSpan" id="kobo.81.2">
     We’ll look next at a few features that I selected because I found them very useful and interesting compared
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.82.1">
      to C++.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-126">
    <a id="_idTextAnchor125">
    </a>
    <span class="koboSpan" id="kobo.83.1">
     Project templates and package management
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.84.1">
     As an avid
    </span>
    <a id="_idIndexMarker408">
    </a>
    <span class="koboSpan" id="kobo.85.1">
     user of the command line and neovim code editor, I love technologies that allow me to create projects directly from the command line.
    </span>
    <span class="koboSpan" id="kobo.85.2">
     Rust comes with the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.86.1">
      cargo
     </span>
    </strong>
    <span class="koboSpan" id="kobo.87.1">
     tool that allows creating projects, building, running, packaging, and
    </span>
    <a id="_idIndexMarker409">
    </a>
    <span class="koboSpan" id="kobo.88.1">
     publishing.
    </span>
    <span class="koboSpan" id="kobo.88.2">
     To create a new project, just call
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.89.1">
      cargo new project-name
     </span>
    </strong>
    <span class="koboSpan" id="kobo.90.1">
     .
    </span>
    <span class="koboSpan" id="kobo.90.2">
     You run it with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.91.1">
      cargo run
     </span>
    </strong>
    <span class="koboSpan" id="kobo.92.1">
     , check that it doesn’t have compile errors with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.93.1">
      cargo check
     </span>
    </strong>
    <span class="koboSpan" id="kobo.94.1">
     , compile it with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.95.1">
      cargo build
     </span>
    </strong>
    <span class="koboSpan" id="kobo.96.1">
     , package it with – you guessed it!
    </span>
    <span class="koboSpan" id="kobo.96.2">
     –
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.97.1">
      cargo package
     </span>
    </strong>
    <span class="koboSpan" id="kobo.98.1">
     , and publish it with (drum rolls) ...
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.99.1">
       cargo publish
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.100.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.101.1">
     We can, of course, create
    </span>
    <a id="_idIndexMarker410">
    </a>
    <span class="koboSpan" id="kobo.102.1">
     libraries and executables with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.103.1">
      cargo
     </span>
    </strong>
    <span class="koboSpan" id="kobo.104.1">
     .
    </span>
    <span class="koboSpan" id="kobo.104.2">
     More than that, we can use the cargo generate tool found at
    </span>
    <a href="https://cargo-generate.github.io/cargo-generate/">
     <span class="koboSpan" id="kobo.105.1">
      https://cargo-generate.github.io/cargo-generate/
     </span>
    </a>
    <span class="koboSpan" id="kobo.106.1">
     to start from a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.107.1">
      project template.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.108.1">
     I know this might not look like much to most of the C++ developers out there because you rarely create a new project.
    </span>
    <span class="koboSpan" id="kobo.108.2">
     This has been one of my surprises when teaching unit testing or test-driven development to C++ programmers: we had to work together to set up a test project with a production project and the corresponding references, something I took for granted.
    </span>
    <span class="koboSpan" id="kobo.108.3">
     Believe me when I say that this is very nice to have not only at the beginning of a project but also for small experiments, personal or practice code bases, and reducing compilation times.
    </span>
    <span class="koboSpan" id="kobo.108.4">
     A simple thing C++ offers you if your project compiles too slowly is to create a new compilation unit formed out of the few files you are modifying and refer to the rest as a binary.
    </span>
    <span class="koboSpan" id="kobo.108.5">
     I used this technique extensively before SSD hard drives sped up
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.109.1">
      compilation considerably.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.110.1">
     Enough on new projects.
    </span>
    <span class="koboSpan" id="kobo.110.2">
     Let’s write some code.
    </span>
    <span class="koboSpan" id="kobo.110.3">
     Let’s modify some variables...
    </span>
    <span class="koboSpan" id="kobo.110.4">
     or
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.111.1">
      maybe not.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-127">
    <a id="_idTextAnchor126">
    </a>
    <span class="koboSpan" id="kobo.112.1">
     Immutability
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.113.1">
     Rust features
    </span>
    <a id="_idIndexMarker411">
    </a>
    <span class="koboSpan" id="kobo.114.1">
     immutability by default.
    </span>
    <span class="koboSpan" id="kobo.114.2">
     The way the documentation puts it is
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.115.1">
      “once a value is bound to a name, you can’t change that value.”
     </span>
    </em>
    <span class="koboSpan" id="kobo.116.1">
     Let’s look at a simple example where I assign a string value to a variable, display it, and then try to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.117.1">
      modify it:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.118.1">
fn main() {
    let the_message = "Hello, world!";
    println!("{the_message}");
    the_message = "A new hello!";
    println!("{the_message}");
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.119.1">
     Trying to compile this program results in a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.120.1">
      cannot assign twice to immutable variable `the_message`
     </span>
    </strong>
    <span class="koboSpan" id="kobo.121.1">
     compilation error.
    </span>
    <span class="koboSpan" id="kobo.121.2">
     Helpfully, the error message includes the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.122.1">
      For more information about this error, try `rustc –explain E0384`
     </span>
    </strong>
    <span class="koboSpan" id="kobo.123.1">
     notice.
    </span>
    <span class="koboSpan" id="kobo.123.2">
     The explanation for the error message contains an example for the error, and a very helpful notice on how to make
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.124.1">
      variables mutable:
     </span>
    </span>
   </p>
   <p>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.125.1">
      "By default, variables in Rust are immutable.
     </span>
     <span class="koboSpan" id="kobo.125.2">
      To fix this error, add the keyword must after the keyword let when declaring
     </span>
    </strong>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.126.1">
       the variable"
      </span>
     </strong>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.127.1">
     Following is a code
    </span>
    <a id="_idIndexMarker412">
    </a>
    <span class="koboSpan" id="kobo.128.1">
     example that, when adapted, makes the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.129.1">
      program compile:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.130.1">
    let mut the_message = "Hello, world!";
    println!("{the_message}");
    the_message = "A new hello!";
    println!("{the_message}");</span></pre>
   <p>
    <span class="koboSpan" id="kobo.131.1">
     As you can see, mutable variables must be specified as
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.132.1">
      mut
     </span>
    </strong>
    <span class="koboSpan" id="kobo.133.1">
     , so the default is immutability.
    </span>
    <span class="koboSpan" id="kobo.133.2">
     As we’ve seen in previous chapters, this helps with a lot of problems such as parallelism and concurrency, automated testing, and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.134.1">
      code simplicity.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-128">
    <a id="_idTextAnchor127">
    </a>
    <span class="koboSpan" id="kobo.135.1">
     Simple syntax for compound types
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.136.1">
     Rust borrows from
    </span>
    <a id="_idIndexMarker413">
    </a>
    <span class="koboSpan" id="kobo.137.1">
     languages such as Python or Ruby the syntax for arrays and tuples.
    </span>
    <span class="koboSpan" id="kobo.137.2">
     Here’s what that
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.138.1">
      looks like:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.139.1">
let months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
println!("{:?}", months);
let (one, two) = (1, 1+1);
println!("{one} and {two}");</span></pre>
   <p>
    <span class="koboSpan" id="kobo.140.1">
     This might not look like much, but it helps
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.141.1">
      simplify code.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.142.1">
     It’s worth mentioning here that C++ has introduced a similar syntax in C++ 11 and has improved it in consequent versions, through the list initializer, using
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.143.1">
      curly braces:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.144.1">
std::vector&lt;string&gt; months = {"January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"};</span></pre>
   <p>
    <span class="koboSpan" id="kobo.145.1">
     I would love to see
    </span>
    <a id="_idIndexMarker414">
    </a>
    <span class="koboSpan" id="kobo.146.1">
     further improvements on this front, but the C++ syntax is already complex, so I don’t
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.147.1">
      expect it.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-129">
    <a id="_idTextAnchor128">
    </a>
    <span class="koboSpan" id="kobo.148.1">
     Optional return keyword
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.149.1">
     Functions in
    </span>
    <a id="_idIndexMarker415">
    </a>
    <span class="koboSpan" id="kobo.150.1">
     Rust allow the return of the last value in the function.
    </span>
    <span class="koboSpan" id="kobo.150.2">
     The next example uses this construct to increment
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.151.1">
      a number:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.152.1">
fn main() {
    let two = increment(1);
    println!("{two}");
}
fn increment(x:i32) -&gt; i32{
    x+1
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.153.1">
     I usually avoid this in functions such as the preceding, but avoiding the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.154.1">
      return
     </span>
    </strong>
    <span class="koboSpan" id="kobo.155.1">
     keyword simplifies closures, as we’ll
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.156.1">
      see next.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-130">
    <a id="_idTextAnchor129">
    </a>
    <span class="koboSpan" id="kobo.157.1">
     Closures
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.158.1">
     Let’s
    </span>
    <a id="_idIndexMarker416">
    </a>
    <span class="koboSpan" id="kobo.159.1">
     increment all elements of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.160.1">
      a vector:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.161.1">
fn increment_all() -&gt; Vec&lt;i32&gt;{
    let values : Vec&lt;i32&gt; = vec![1, 2, 3];
    return values.iter().map(|x| x+1).collect();
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.162.1">
     As usual for functional programming constructs, and similarly to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.163.1">
      ranges
     </span>
    </strong>
    <span class="koboSpan" id="kobo.164.1">
     library in C++, we need to get an iterator, call the map function – equivalent to the transform algorithm in C++ – with a closure, and call
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.165.1">
      collect
     </span>
    </strong>
    <span class="koboSpan" id="kobo.166.1">
     to obtain the results.
    </span>
    <span class="koboSpan" id="kobo.166.2">
     The closure has a very simple syntax, made possible by the optional
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.167.1">
      return statement.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-131">
    <a id="_idTextAnchor130">
    </a>
    <span class="koboSpan" id="kobo.168.1">
     Unit tests in Standard Library
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.169.1">
     Unit testing
    </span>
    <a id="_idIndexMarker417">
    </a>
    <span class="koboSpan" id="kobo.170.1">
     is a very important practice in software development, and it’s surprising that only a few languages offer support for it in the standard library.
    </span>
    <span class="koboSpan" id="kobo.170.2">
     Rust does it by default, and it’s quite easy to use.
    </span>
    <span class="koboSpan" id="kobo.170.3">
     Let’s add a unit test to verify that our
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.171.1">
      increment_all
     </span>
    </strong>
    <span class="koboSpan" id="kobo.172.1">
     function works
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.173.1">
      as expected:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.174.1">
#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn it_works() {
        assert_eq!(vec![2, 3, 4], increment_all());
    }
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.175.1">
     As a plus, I like that it’s very easy to write unit tests in the same compilation unit (called a
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.176.1">
      crate
     </span>
    </strong>
    <span class="koboSpan" id="kobo.177.1">
     in
    </span>
    <a id="_idIndexMarker418">
    </a>
    <span class="koboSpan" id="kobo.178.1">
     Rust) as the production code.
    </span>
    <span class="koboSpan" id="kobo.178.2">
     This might not seem like much if you see unit tests as an
    </span>
    <a id="_idIndexMarker419">
    </a>
    <span class="koboSpan" id="kobo.179.1">
     obligation, but I often use unit tests to experiment and to design so I love this facility
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.180.1">
      a lot.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-132">
    <a id="_idTextAnchor131">
    </a>
    <span class="koboSpan" id="kobo.181.1">
     Traits
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.182.1">
     A big difference
    </span>
    <a id="_idIndexMarker420">
    </a>
    <span class="koboSpan" id="kobo.183.1">
     between Rust (or Go) and the other mainstream languages is that Rust does not support inheritance, instead favoring composition.
    </span>
    <span class="koboSpan" id="kobo.183.2">
     To allow for polymorphic behavior without inheritance, Rust
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.184.1">
      offers traits.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.185.1">
     Rust traits are similar to interfaces in object-oriented languages in that they define a set of methods that need to be implemented for every object that derives from them.
    </span>
    <span class="koboSpan" id="kobo.185.2">
     However, Rust traits have a specific feature: you can add a trait to a type you don’t own.
    </span>
    <span class="koboSpan" id="kobo.185.3">
     This is similar to extension methods in C#, although not
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.186.1">
      the same.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.187.1">
     The Rust documentation provides an example of traits by using two structures, one representing a tweet and the other a news article, and adding the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.188.1">
      Summary
     </span>
    </strong>
    <span class="koboSpan" id="kobo.189.1">
     trait to both is meant to create a summary of the corresponding message.
    </span>
    <span class="koboSpan" id="kobo.189.2">
     As you can see in the example that follows, the trait implementation is separate from both the structure implementation and the trait definition, which makes it
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.190.1">
      very flexible.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.191.1">
     Let’s start by looking at the two structures.
    </span>
    <span class="koboSpan" id="kobo.191.2">
     First, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.192.1">
      NewsArticle
     </span>
    </strong>
    <span class="koboSpan" id="kobo.193.1">
     contains a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.194.1">
      few fields:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.195.1">
pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.196.1">
     Then, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.197.1">
      Tweet
     </span>
    </strong>
    <span class="koboSpan" id="kobo.198.1">
     structure contains its
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.199.1">
      own fields:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.200.1">
pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.201.1">
     Separately, we define the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.202.1">
      Summary
     </span>
    </strong>
    <span class="koboSpan" id="kobo.203.1">
     trait with a single method summarize returning
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.204.1">
      a string:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.205.1">
pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.206.1">
     Let’s now
    </span>
    <a id="_idIndexMarker421">
    </a>
    <span class="koboSpan" id="kobo.207.1">
     implement the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.208.1">
      Summary
     </span>
    </strong>
    <span class="koboSpan" id="kobo.209.1">
     trait for the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.210.1">
      Tweet
     </span>
    </strong>
    <span class="koboSpan" id="kobo.211.1">
     structure.
    </span>
    <span class="koboSpan" id="kobo.211.2">
     This is done by specifying that the implementation of this trait applies to the structure,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.212.1">
      as follows:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.213.1">
impl Summary for Tweet {
    fn summarize(&amp;self) -&gt; String {
        format!("{}: {}", self.username, self.content)
    }
}</span></pre>
   <p>
    <span class="koboSpan" id="kobo.214.1">
     The test
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.215.1">
      works perfectly:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.216.1">
    #[test]
    fn summarize_tweet() {
        let tweet = Tweet {
            username: String::from("me"),
            content: String::from("a message"),
            reply: false,
            retweet: false,
        };
        assert_eq!("me: a message", tweet.summarize());
    }</span></pre>
   <p>
    <span class="koboSpan" id="kobo.217.1">
     Finally, let’s
    </span>
    <a id="_idIndexMarker422">
    </a>
    <span class="koboSpan" id="kobo.218.1">
     implement the trait for the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.219.1">
      news article:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.220.1">
impl Summary for NewsArticle {
    fn summarize(&amp;self) -&gt; String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}
#[test]
    fn summarize_news_article() {
        let news_article = NewsArticle {
            headline: String::from("Big News"),
            location: String::from("Undisclosed"),
            author: String::from("Me"),
            content: String::from("Big News here, must follow"),
        };
        assert_eq!("Big News, by Me (Undisclosed)", news_article.summarize());
    }</span></pre>
   <p>
    <span class="koboSpan" id="kobo.221.1">
     Traits in Rust have much more capabilities.
    </span>
    <span class="koboSpan" id="kobo.221.2">
     We can implement a default behavior, specify that the type of a parameter needs to be of one or multiple trait types,  implement traits generically on multiple types, and so on.
    </span>
    <span class="koboSpan" id="kobo.221.3">
     In fact, Rust traits are a combination of OO interfaces, C# extension methods, and C++ concepts.
    </span>
    <span class="koboSpan" id="kobo.221.4">
     However, this is outside the scope of this chapter.
    </span>
    <span class="koboSpan" id="kobo.221.5">
     What’s worth remembering is that Rust treats inheritance very differently
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.222.1">
      from C++.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-133">
    <a id="_idTextAnchor132">
    </a>
    <span class="koboSpan" id="kobo.223.1">
     Ownership model
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.224.1">
     An interesting
    </span>
    <a id="_idIndexMarker423">
    </a>
    <span class="koboSpan" id="kobo.225.1">
     characteristic of Rust, and perhaps its most advertised feature, is the ownership model.
    </span>
    <span class="koboSpan" id="kobo.225.2">
     This is Rust’s reaction to memory safety issues in C++, only instead of going into garbage collectors like Java or C# do, the designers have solved the problem with a more explicit ownership of memory.
    </span>
    <span class="koboSpan" id="kobo.225.3">
     We’ll look at a quote from the Rust
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.226.1">
      book (
     </span>
    </span>
    <a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html):">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.227.1">
       https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html
      </span>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.228.1">
       ):
      </span>
     </span>
    </a>
   </p>
   <p>
    <span class="koboSpan" id="kobo.229.1">
     “
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.230.1">
      Memory is managed through a system of ownership with a set of rules that the compiler checks.
     </span>
     <span class="koboSpan" id="kobo.230.2">
      If any of the rules are violated, the program won’t compile.
     </span>
     <span class="koboSpan" id="kobo.230.3">
      None of the features of ownership will slow down your program while
     </span>
    </em>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.231.1">
       it’s running.
      </span>
     </em>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.232.1">
      ”
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.233.1">
     There are three rules of ownership
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.234.1">
      in Rust:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.235.1">
      Each value in Rust has
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.236.1">
       an
      </span>
     </span>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.237.1">
        owner
       </span>
      </em>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.238.1">
      There can only be one owner at
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.239.1">
       a time
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.240.1">
      When the owner goes out of scope, the value will
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.241.1">
       be dropped
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.242.1">
     Let’s first look at an example that works the same as in C++.
    </span>
    <span class="koboSpan" id="kobo.242.2">
     If we have a variable allocated on the stack, such as an integer, then copying the variable works in a very
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.243.1">
      familiar way:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.244.1">
    #[test]
    fn copy_on_stack() {
        let stack_value = 1;
        let copied_stack_value = stack_value;
        assert_eq!(1, stack_value);
        assert_eq!(1, copied_stack_value);
    }</span></pre>
   <p>
    <span class="koboSpan" id="kobo.245.1">
     Both variables have the same value, as expected.
    </span>
    <span class="koboSpan" id="kobo.245.2">
     However, if we try the same code with a variable allocated on the heap, we get
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.246.1">
      an error:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.247.1">
    #[test]
    fn copy_on_heap() {
        let heap_value = String::from("A string");
        let copied_heap_value = heap_value;
        assert_eq!(String::from("A string"), heap_value);
        assert_eq!(String::from("A string"), copied_heap_value);
    }</span></pre>
   <p>
    <span class="koboSpan" id="kobo.248.1">
     When running this, we get the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.249.1">
      error[E0382]: borrow of moved value: `heap_value`
     </span>
    </strong>
    <span class="koboSpan" id="kobo.250.1">
     error.
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.251.1">
      What happens?
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.252.1">
     Well, when we assign the value of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.253.1">
      heap_value
     </span>
    </strong>
    <span class="koboSpan" id="kobo.254.1">
     to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.255.1">
      copied_heap_value
     </span>
    </strong>
    <span class="koboSpan" id="kobo.256.1">
     , the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.257.1">
      heap_value
     </span>
    </strong>
    <span class="koboSpan" id="kobo.258.1">
     variable is invalidated.
    </span>
    <span class="koboSpan" id="kobo.258.2">
     This behaves the same as the move semantics in C++, only without any additional work from the programmer.
    </span>
    <span class="koboSpan" id="kobo.258.3">
     Behind the scenes, this works through the use of two traits:
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.259.1">
      Copy
     </span>
    </strong>
    <span class="koboSpan" id="kobo.260.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.261.1">
      Drop
     </span>
    </strong>
    <span class="koboSpan" id="kobo.262.1">
     .
    </span>
    <span class="koboSpan" id="kobo.262.2">
     If a type implements the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.263.1">
      Copy
     </span>
    </strong>
    <span class="koboSpan" id="kobo.264.1">
     trait then it works as in the first example, while if it implements the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.265.1">
      Drop
     </span>
    </strong>
    <span class="koboSpan" id="kobo.266.1">
     trait then it works as in the second.
    </span>
    <span class="koboSpan" id="kobo.266.2">
     No type can implement
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.267.1">
      both traits.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.268.1">
     To make the
    </span>
    <a id="_idIndexMarker424">
    </a>
    <span class="koboSpan" id="kobo.269.1">
     above example work, we need to clone the value instead of using the default
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.270.1">
      move mechanism:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.271.1">
    #[test]
    fn clone_on_heap() {
        let heap_value = String::from("A string");
        let copied_heap_value = heap_value.clone();
        assert_eq!(String::from("A string"), heap_value);
        assert_eq!(String::from("A string"), copied_heap_value);
    }</span></pre>
   <p>
    <span class="koboSpan" id="kobo.272.1">
     This example works fine, so the value is cloned.
    </span>
    <span class="koboSpan" id="kobo.272.2">
     This indicates, however, a new allocation on the heap, not a reference to the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.273.1">
      same value.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.274.1">
     The move
    </span>
    <a id="_idIndexMarker425">
    </a>
    <span class="koboSpan" id="kobo.275.1">
     semantics work the same for function calls.
    </span>
    <span class="koboSpan" id="kobo.275.2">
     Let’s initialize a value and pass it to a function that returns it unchanged to see
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.276.1">
      what happens:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.277.1">
    fn call_me(value: String) -&gt; String {
        return value;
    }
    #[test]
    fn move_semantics_method_call() {
        let heap_value = String::from("A string");
        let result = call_me(heap_value);
        assert_eq!(String::from("A string"), heap_value);
        assert_eq!(String::from("A string"), result);
    }</span></pre>
   <p>
    <span class="koboSpan" id="kobo.278.1">
     When trying to compile this code, we get the same error as before:
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.279.1">
      error[E0382]: borrow of moved value: `heap_value`
     </span>
    </strong>
    <span class="koboSpan" id="kobo.280.1">
     .
    </span>
    <span class="koboSpan" id="kobo.280.2">
     The value is created on the heap, moved into the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.281.1">
      call_me
     </span>
    </strong>
    <span class="koboSpan" id="kobo.282.1">
     function, and therefore dropped from the current scope.
    </span>
    <span class="koboSpan" id="kobo.282.2">
     We can make this code work by specifying that the function called should only borrow the ownership instead of taking it over.
    </span>
    <span class="koboSpan" id="kobo.282.3">
     This is done through the use of reference and dereference operators, which are the same as
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.283.1">
      in C++:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.284.1">
    fn i_borrow(value: &amp;String) -&gt; &amp;String {
        return value;
    }
    #[test]
    fn borrow_method_call() {
        let heap_value = String::from("A string");
        let result = i_borrow(&amp;heap_value);
        assert_eq!(String::from("A string"), heap_value);
        assert_eq!(String::from("A string"), *result);
    }</span></pre>
   <p>
    <span class="koboSpan" id="kobo.285.1">
     The important difference between C++ references and Rust references is that Rust references are immutable
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.286.1">
      by default.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.287.1">
     There is, of course, a lot more to learn about the ownership model in Rust, but I believe this is enough to give you a taste of how it works and how it’s meant to prevent memory
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.288.1">
      safety issues.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-134">
    <a id="_idTextAnchor133">
    </a>
    <span class="koboSpan" id="kobo.289.1">
     Rust’s advantages
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.290.1">
     To summarize, Rust has a few advantages over C++.
    </span>
    <span class="koboSpan" id="kobo.290.2">
     By being a newer language, it has the advantage of learning from
    </span>
    <a id="_idIndexMarker426">
    </a>
    <span class="koboSpan" id="kobo.291.1">
     its predecessors and using the best patterns available.
    </span>
    <span class="koboSpan" id="kobo.291.2">
     I find the combination of immutability with the ownership model to be very good at code that works well by default.
    </span>
    <span class="koboSpan" id="kobo.291.3">
     It might take a bit to learn since it’s not the typical memory management style, but once you understand how to use it, it allows you to write code that works without
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.292.1">
      much challenge.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.293.1">
     The unit testing support in the standard library, the package manager, and the multi-editor support should be part of any modern programming language.
    </span>
    <span class="koboSpan" id="kobo.293.2">
     The syntax is nicer when it comes to closures and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.294.1">
      compound types.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.295.1">
     We might wonder at this point: does C++ stand a chance?
    </span>
    <span class="koboSpan" id="kobo.295.2">
     Why
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.296.1">
      and where?
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-135">
    <a id="_idTextAnchor134">
    </a>
    <span class="koboSpan" id="kobo.297.1">
     Where C++ is better
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.298.1">
     C++ is a very capable, advanced
    </span>
    <a id="_idIndexMarker427">
    </a>
    <span class="koboSpan" id="kobo.299.1">
     programming language, under continuous improvement.
    </span>
    <span class="koboSpan" id="kobo.299.2">
     The language is progressing quite fast.
    </span>
    <span class="koboSpan" id="kobo.299.3">
     It’s very difficult to equal the C++ ecosystem: its community, the staggering number of libraries and frameworks available, and the articles, blogs, and books that teach you how to use C++ in various ways for any possible problem you might have.
    </span>
    <span class="koboSpan" id="kobo.299.4">
     For all its benefits, Rust is a young language compared to C++, which should give you pause when considering the choice of technology for systems programming.
    </span>
    <span class="koboSpan" id="kobo.299.5">
     However, Rust has been adopted for subsystems of Linux and Android, so it proves itself a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.300.1">
      worthy competitor.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.301.1">
     The C++ standardization committee has shown a continuous focus on simplifying syntax and reducing the mental burden of programmers for various code constructs.
    </span>
    <span class="koboSpan" id="kobo.301.2">
     Part of the effort comes from the competition, with many of the features introduced in C++17 and later being an answer to the Rust design choices.
    </span>
    <span class="koboSpan" id="kobo.301.3">
     While I don’t expect C++’s syntax to evolve to be as simple as Rust, the other factors mentioned here must contribute to the choice just as much, if
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.302.1">
      not more.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-136">
    <a id="_idTextAnchor135">
    </a>
    <span class="koboSpan" id="kobo.303.1">
     What C++ still needs
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.304.1">
     In this book, we have seen some of the challenges
    </span>
    <a id="_idIndexMarker428">
    </a>
    <span class="koboSpan" id="kobo.305.1">
     of C++.
    </span>
    <span class="koboSpan" id="kobo.305.2">
     A standard package manager would be very helpful, even if the community follows in the footsteps of Java and C# and picks an open source de-facto standard.
    </span>
    <span class="koboSpan" id="kobo.305.3">
     A standard unit testing library would be very beneficial, even if the existing code might take a long while to migrate if it
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.306.1">
      ever does.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.307.1">
     Unicode and utf-8 support still need improvement.
    </span>
    <span class="koboSpan" id="kobo.307.2">
     Standard support for multithreading is at the beginning.
    </span>
    <span class="koboSpan" id="kobo.307.3">
     Safety profiles would be extremely useful for minimizing memory
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.308.1">
      safety issues.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.309.1">
     It’s clear from this list that C++ has a lot of things to improve.
    </span>
    <span class="koboSpan" id="kobo.309.2">
     The good news is that the standardization committee is hard at work on some of these issues.
    </span>
    <span class="koboSpan" id="kobo.309.3">
     The less good news is that it takes time to define these improvements, more time to adapt compilers, and even more time to adapt existing code.
    </span>
    <span class="koboSpan" id="kobo.309.4">
     Hopefully, Gen AI will be capable enough to speed up these improvements while maintaining
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.310.1">
      code integrity.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-137">
    <a id="_idTextAnchor136">
    </a>
    <span class="koboSpan" id="kobo.311.1">
     Summary
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.312.1">
     We saw, in this chapter, that Rust is a very interesting language, whose designers knew to take advantage of the knowledge gathered by their predecessors and to innovate in the right places.
    </span>
    <span class="koboSpan" id="kobo.312.2">
     The result is a nice syntax, a more natural way to deal with memory without using a garbage collector, and an overall modern development experience.
    </span>
    <span class="koboSpan" id="kobo.312.3">
     We explored this in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.313.1">
      this chapter.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.314.1">
     However, C++ is hard to compete with.
    </span>
    <span class="koboSpan" id="kobo.314.2">
     The sheer number of libraries, frameworks, blogs, articles, code examples, books, and experience available in the world on C++ is impossible to equal in a short time.
    </span>
    <span class="koboSpan" id="kobo.314.3">
     Rust has found its niches in Web Assembly applications and various tools, but it’s far from
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.315.1">
      replacing C++.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.316.1">
     Still, we have to remember that languages are not necessarily picked based on technical reasons and that cultural reasons matter as well.
    </span>
    <span class="koboSpan" id="kobo.316.2">
     Newer generations of programmers might enjoy Rust much more than C++, and with the NSA and the White House leading the focus on memory-safe languages, Rust might gain ground for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.317.1">
      newer projects.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.318.1">
     The conclusion?
    </span>
    <span class="koboSpan" id="kobo.318.2">
     It’s hard to predict the future, but we can imagine how Rust could take over.
    </span>
    <span class="koboSpan" id="kobo.318.3">
     The way I see it, it would require four factors: Rust is preferred by more and more programmers, it is required by regulation, C++ fails to evolve on memory safety fast enough, and generative AI gets good enough at translating from C++
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.319.1">
      to Rust.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.320.1">
     So, there’s a chance, but I think it’s safe to say that it’s over 50% that C++ is here to stay at least for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.321.1">
      another decade.
     </span>
    </span>
   </p>
  </div>
 </body></html>