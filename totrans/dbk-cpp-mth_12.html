<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-121">
    <a id="_idTextAnchor120">
    </a>
    
     12
    
   </h1>
   <h1 id="_idParaDest-122">
    <a id="_idTextAnchor121">
    </a>
    
     Rust Will Replace C++
    
   </h1>
   <p class="italic-heading">
    <em class="italic">
     
      If 4 things
     
    </em>
    
     <em class="italic">
      
       happen concomitantly
      
     </em>
    
   </p>
   <p>
    
     Rust rose as a contender for systems programming and C++ in the past years.
    
    
     There are good reasons for this: Rust is a modern language, providing a good toolset, simple syntax, and innovations that help reason about the code.
    
    
     The question of whether Rust will replace C++ is therefore on the minds of many programmers who would like to know where to invest their efforts for the future of their careers.
    
    
     We will look next at what makes Rust interesting and at what would need to happen for it to
    
    
     
      replace C++.
     
    
   </p>
   <p>
    
     In this chapter, we’re going to cover the following
    
    
     
      main topics:
     
    
   </p>
   <ul>
    <li>
     
      Why
     
     
      
       the competition?
      
     
    </li>
    <li>
     
      Core features
     
     
      
       of Rust
      
     
    </li>
    <li>
     
      
       Rust’s advantages
      
     
    </li>
    <li>
     
      Where C++
     
     
      
       is better
      
     
    </li>
    <li>
     
      What C++
     
     
      
       still needs
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-123">
    <a id="_idTextAnchor122">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     The code for this chapter is available in the GitHub repository (
    
    <a href="https://github.com/PacktPublishing/Debunking-C-Myths">
     
      https://github.com/PacktPublishing/Debunking-C-Myths
     
    </a>
    
     ), in the
    
    <strong class="source-inline">
     
      ch12
     
    </strong>
    
     folder.
    
    
     To run the code, you will need Rust, using the instructions from
    
    
     
      their website:
     
    
   </p>
   <p>
    <a href="https://www.rust-lang.org/tools/install">
     
      
       https://www.rust-lang.org/tools/install
      
     
    </a>
   </p>
   <h1 id="_idParaDest-124">
    <a id="_idTextAnchor123">
    </a>
    
     Why the competition?
    
   </h1>
   <p>
    
     As a junior C++ programmer working abroad in Paris around 2001, my biggest challenge was to make my code do what it needed to do.
    
    
     The project was a knowledge base for industrial printing presses, allowing operators to identify the source of printing errors.
    
    
     Back then, the main option for such desktop applications was C++ under Windows, developed with Visual C++,
    
    <strong class="bold">
     
      Microsoft Foundation Class
     
    </strong>
    
     (
    
    <strong class="bold">
     
      MFC
     
    </strong>
    
     ), and Windows APIs, designed with the Document-View model, a
    
    <a id="_idIndexMarker405">
    </a>
    
     weaker cousin of Model-View-Controller promoted by Microsoft.
    
    
     The project challenged me to the maximum: not only was I struggling with C++ memory management but I also had to deal with the quirks of MFC and Windows APIs.
    
    
     My support back then was the official documentation, the
    
    <a href="https://codeproject.com">
     
      https://codeproject.com
     
    </a>
    
     website, and one more experienced colleague who was rarely available.
    
    
     Basically, I had to deal with a complex technology, as a sole developer, without a lot of support.
    
    
     Welcome to software development in the 2000s!
    
    
     Don’t get me wrong, I’m not complaining: because of its challenges, the experience was deeply helpful
    
    
     
      and educational.
     
    
   </p>
   <p>
    
     My sole focus at that point was the technology I was using.
    
    
     I had heard of things such as PHP, and I had used Java before for applets and web applications, but C++, MFC, and Windows APIs were filling my bandwidth.
    
    
     It didn’t help that the commute took around 90 minutes, enough time to read the whole
    
    <em class="italic">
     
      Lord of the Rings
     
    </em>
    
     book on public transport over the course of
    
    
     
      a year.
     
    
   </p>
   <p>
    
     A second important project in my career was completely different: still C++, but a very structured and mentored approach to building a NoSQL database engine before such a thing was named.
    
    
     At that time, I learned how to write tests, and we wrote our own testing engine since there was none for C++.
    
    
     I learned a lot about software design by writing design documents and reviewing them with colleagues.
    
    
     I learned about code reviews.
    
    
     I learned C++ ins and outs through a deep dive into seminal books that included Scott Meyers’
    
    <em class="italic">
     
      Effective C++
     
    </em>
    
     and
    
    <em class="italic">
     
      More Effective C++
     
    </em>
    
     , and Andrei Alexandrescu’s
    
    <em class="italic">
     
      Modern C++ Design
     
    </em>
    
     .
    
    
     So, I went even deeper into the
    
    
     
      same technology.
     
    
   </p>
   <p>
    
     Then C# appeared, and I decided to switch technologies.
    
    
     After doing some Java, having a deep knowledge of C++, and going in a structured manner into C#, I realized two things: changing technologies is easier the more you do it, and each technology has its own advantages and disadvantages.
    
    
     Desktop applications were much easier to build in C# since we had to pay less attention to memory management and its potential issues.
    
    
     Programming was more fun, and more importantly, we were developing faster.
    
    
     We traded these two benefits for two downsides: less control and a less rigorous approach
    
    
     
      to programming.
     
    
   </p>
   <p>
    
     Later in my career, I started wondering about the plethora of programming languages available in the marketplace.
    
    
     In my estimation, we would need about 5-7 programming languages for purely technical reasons: one for web, one for systems programming, one for scripting, and the rest for various niches like AI, workflows, solving equations, and so on.
    
    
     Let’s say I’m wrong and we would need 20.
    
    
     However, the reality is that we can use hundreds of programming languages today, including mainstream, niche, and esoteric languages such as Brainfuck or Whitespace.
    
    
     We can see many of them in the TIOBE Programming Community index that monitors the popularity of programming languages.
    
    
     Why are there
    
    
     
      so many?
     
    
   </p>
   <p>
    
     My best guess is that it’s not a matter of technical needs, but one of culture.
    
    
     Sure, the technical aspects are important.
    
    
     Object-oriented and later functional programming features were introduced in all mainstream languages.
    
    
     Security, parallelism and concurrency, ease of programming, the community, and the ecosystem are all important aspects of a programming language.
    
    
     However, the decision to make a new programming language comes from people, and the decisions they make when designing the language come from their personal preferences.
    
    
     Trends in literature and philosophy follow the same pattern: current and counter-current or reactionary.
    
    
     In literature, Romanticism was a reaction to Classicism, and realism was a reaction to Romanticism.
    
    
     Something similar happens with programming languages: Java was a reaction to C++, and Ruby on Rails was a reaction to Java.
    
    
     While in literature, currents are partially determined by societal changes, in technology, the currents are determined both by the movements in the landscape and the preferences of younger generations of programmers, added at a very high pace.
    
    
     An example of the technological landscape change is the rise of the internet, which has favored the rise of Java as a reaction to C++ for web applications.
    
    
     Interestingly, the movement of computation from server to client nowadays seems to favor the apparition of Web Assembly applications that currently require low-level programming in C++ or Rust.
    
    
     As for the new generations of programmers, Ruby on Rails was very much a reaction to the perceived old-style Java language.
    
    
     Rails offered freedoms of expression that Java didn’t, along with a feeling of satisfaction with the progress.
    
    
     This feeling had little technical basis, but technical aspects aren’t everything for people, not even for
    
    
     
      software developers.
     
    
   </p>
   <p>
    
     You should see now where this is going: Rust is a reaction to C++.
    
    
     It is a reaction both to current technical annoyances of C++ and to the ways C++ does things.
    
    
     Let’s therefore look at what Rust brings to
    
    
     
      the table.
     
    
   </p>
   <h1 id="_idParaDest-125">
    <a id="_idTextAnchor124">
    </a>
    
     Core features of Rust
    
   </h1>
   <p>
    
     The first place we can use for understanding
    
    <a id="_idIndexMarker406">
    </a>
    
     Rust’s core features is the official website,
    
    <a href="https://www.rust-lang.org/">
     
      https://www.rust-lang.org/
     
    </a>
    
     .
    
    
     The site does a very good job of emphasizing the most important features
    
    <a id="_idIndexMarker407">
    </a>
    
     
      of Rust:
     
    
   </p>
   <ul>
    <li>
     
      Fast
     
     
      
       and memory-efficient
      
     
    </li>
    <li>
     
      
       No runtime
      
     
    </li>
    <li>
     
      No
     
     
      
       garbage collector
      
     
    </li>
    <li>
     
      Integrates with
     
     
      
       other languages
      
     
    </li>
    <li>
     
      Memory safety and thread safety through a rich type system and
     
     
      
       ownership model
      
     
    </li>
    <li>
     
      
       Great documentation
      
     
    </li>
    <li>
     
      Friendly compiler with useful
     
     
      
       error messages
      
     
    </li>
    <li>
     
      Integrated package manager and
     
     
      
       build tool
      
     
    </li>
    <li>
     
      
       Auto formatter
      
     
    </li>
    <li>
     
      Smart multi-editor support with auto-completion and
     
     
      
       type inspections
      
     
    </li>
   </ul>
   <p>
    
     From this description only, we can already see a few similarities with C++, along with improvements on the current state of C++.
    
    
     The similarities are in the level of control: native compilation, no garbage collector, speed, and memory efficiency are qualities that C++ touts as well.
    
    
     The differences point to things that we discussed at length in this book: standard package manager, standard tooling, and friendly compiler.
    
    
     This last quality is music to the ears of any C++ programmer who got huge error messages; I remember back in the 2000s, I got an error in Visual C++ that said something along the lines of “error messages are too long and we can’t display them”.
    
    
     While today’s C++ is friendlier, figuring out what didn’t work while using templates is still
    
    
     
      a pain.
     
    
   </p>
   <p>
    
     However, let’s look beyond what’s written on the front page of the website.
    
    
     We’ll look next at a few features that I selected because I found them very useful and interesting compared
    
    
     
      to C++.
     
    
   </p>
   <h2 id="_idParaDest-126">
    <a id="_idTextAnchor125">
    </a>
    
     Project templates and package management
    
   </h2>
   <p>
    
     As an avid
    
    <a id="_idIndexMarker408">
    </a>
    
     user of the command line and neovim code editor, I love technologies that allow me to create projects directly from the command line.
    
    
     Rust comes with the
    
    <strong class="source-inline">
     
      cargo
     
    </strong>
    
     tool that allows creating projects, building, running, packaging, and
    
    <a id="_idIndexMarker409">
    </a>
    
     publishing.
    
    
     To create a new project, just call
    
    <strong class="source-inline">
     
      cargo new project-name
     
    </strong>
    
     .
    
    
     You run it with
    
    <strong class="source-inline">
     
      cargo run
     
    </strong>
    
     , check that it doesn’t have compile errors with
    
    <strong class="source-inline">
     
      cargo check
     
    </strong>
    
     , compile it with
    
    <strong class="source-inline">
     
      cargo build
     
    </strong>
    
     , package it with – you guessed it!
    
    
     –
    
    <strong class="source-inline">
     
      cargo package
     
    </strong>
    
     , and publish it with (drum rolls) ...
    
    
     <strong class="source-inline">
      
       cargo publish
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     We can, of course, create
    
    <a id="_idIndexMarker410">
    </a>
    
     libraries and executables with
    
    <strong class="source-inline">
     
      cargo
     
    </strong>
    
     .
    
    
     More than that, we can use the cargo generate tool found at
    
    <a href="https://cargo-generate.github.io/cargo-generate/">
     
      https://cargo-generate.github.io/cargo-generate/
     
    </a>
    
     to start from a
    
    
     
      project template.
     
    
   </p>
   <p>
    
     I know this might not look like much to most of the C++ developers out there because you rarely create a new project.
    
    
     This has been one of my surprises when teaching unit testing or test-driven development to C++ programmers: we had to work together to set up a test project with a production project and the corresponding references, something I took for granted.
    
    
     Believe me when I say that this is very nice to have not only at the beginning of a project but also for small experiments, personal or practice code bases, and reducing compilation times.
    
    
     A simple thing C++ offers you if your project compiles too slowly is to create a new compilation unit formed out of the few files you are modifying and refer to the rest as a binary.
    
    
     I used this technique extensively before SSD hard drives sped up
    
    
     
      compilation considerably.
     
    
   </p>
   <p>
    
     Enough on new projects.
    
    
     Let’s write some code.
    
    
     Let’s modify some variables...
    
    
     or
    
    
     
      maybe not.
     
    
   </p>
   <h2 id="_idParaDest-127">
    <a id="_idTextAnchor126">
    </a>
    
     Immutability
    
   </h2>
   <p>
    
     Rust features
    
    <a id="_idIndexMarker411">
    </a>
    
     immutability by default.
    
    
     The way the documentation puts it is
    
    <em class="italic">
     
      “once a value is bound to a name, you can’t change that value.”
     
    </em>
    
     Let’s look at a simple example where I assign a string value to a variable, display it, and then try to
    
    
     
      modify it:
     
    
   </p>
   <pre class="source-code">
fn main() {
    let the_message = "Hello, world!";
    println!("{the_message}");
    the_message = "A new hello!";
    println!("{the_message}");
}</pre>
   <p>
    
     Trying to compile this program results in a
    
    <strong class="source-inline">
     
      cannot assign twice to immutable variable `the_message`
     
    </strong>
    
     compilation error.
    
    
     Helpfully, the error message includes the
    
    <strong class="source-inline">
     
      For more information about this error, try `rustc –explain E0384`
     
    </strong>
    
     notice.
    
    
     The explanation for the error message contains an example for the error, and a very helpful notice on how to make
    
    
     
      variables mutable:
     
    
   </p>
   <p>
    <strong class="source-inline">
     
      "By default, variables in Rust are immutable.
     
     
      To fix this error, add the keyword must after the keyword let when declaring
     
    </strong>
    
     <strong class="source-inline">
      
       the variable"
      
     </strong>
    
   </p>
   <p>
    
     Following is a code
    
    <a id="_idIndexMarker412">
    </a>
    
     example that, when adapted, makes the
    
    
     
      program compile:
     
    
   </p>
   <pre class="source-code">
    let mut the_message = "Hello, world!";
    println!("{the_message}");
    the_message = "A new hello!";
    println!("{the_message}");</pre>
   <p>
    
     As you can see, mutable variables must be specified as
    
    <strong class="source-inline">
     
      mut
     
    </strong>
    
     , so the default is immutability.
    
    
     As we’ve seen in previous chapters, this helps with a lot of problems such as parallelism and concurrency, automated testing, and
    
    
     
      code simplicity.
     
    
   </p>
   <h2 id="_idParaDest-128">
    <a id="_idTextAnchor127">
    </a>
    
     Simple syntax for compound types
    
   </h2>
   <p>
    
     Rust borrows from
    
    <a id="_idIndexMarker413">
    </a>
    
     languages such as Python or Ruby the syntax for arrays and tuples.
    
    
     Here’s what that
    
    
     
      looks like:
     
    
   </p>
   <pre class="source-code">
let months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
println!("{:?}", months);
let (one, two) = (1, 1+1);
println!("{one} and {two}");</pre>
   <p>
    
     This might not look like much, but it helps
    
    
     
      simplify code.
     
    
   </p>
   <p>
    
     It’s worth mentioning here that C++ has introduced a similar syntax in C++ 11 and has improved it in consequent versions, through the list initializer, using
    
    
     
      curly braces:
     
    
   </p>
   <pre class="source-code">
std::vector&lt;string&gt; months = {"January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"};</pre>
   <p>
    
     I would love to see
    
    <a id="_idIndexMarker414">
    </a>
    
     further improvements on this front, but the C++ syntax is already complex, so I don’t
    
    
     
      expect it.
     
    
   </p>
   <h2 id="_idParaDest-129">
    <a id="_idTextAnchor128">
    </a>
    
     Optional return keyword
    
   </h2>
   <p>
    
     Functions in
    
    <a id="_idIndexMarker415">
    </a>
    
     Rust allow the return of the last value in the function.
    
    
     The next example uses this construct to increment
    
    
     
      a number:
     
    
   </p>
   <pre class="source-code">
fn main() {
    let two = increment(1);
    println!("{two}");
}
fn increment(x:i32) -&gt; i32{
    x+1
}</pre>
   <p>
    
     I usually avoid this in functions such as the preceding, but avoiding the
    
    <strong class="source-inline">
     
      return
     
    </strong>
    
     keyword simplifies closures, as we’ll
    
    
     
      see next.
     
    
   </p>
   <h2 id="_idParaDest-130">
    <a id="_idTextAnchor129">
    </a>
    
     Closures
    
   </h2>
   <p>
    
     Let’s
    
    <a id="_idIndexMarker416">
    </a>
    
     increment all elements of
    
    
     
      a vector:
     
    
   </p>
   <pre class="source-code">
fn increment_all() -&gt; Vec&lt;i32&gt;{
    let values : Vec&lt;i32&gt; = vec![1, 2, 3];
    return values.iter().map(|x| x+1).collect();
}</pre>
   <p>
    
     As usual for functional programming constructs, and similarly to the
    
    <strong class="source-inline">
     
      ranges
     
    </strong>
    
     library in C++, we need to get an iterator, call the map function – equivalent to the transform algorithm in C++ – with a closure, and call
    
    <strong class="source-inline">
     
      collect
     
    </strong>
    
     to obtain the results.
    
    
     The closure has a very simple syntax, made possible by the optional
    
    
     
      return statement.
     
    
   </p>
   <h2 id="_idParaDest-131">
    <a id="_idTextAnchor130">
    </a>
    
     Unit tests in Standard Library
    
   </h2>
   <p>
    
     Unit testing
    
    <a id="_idIndexMarker417">
    </a>
    
     is a very important practice in software development, and it’s surprising that only a few languages offer support for it in the standard library.
    
    
     Rust does it by default, and it’s quite easy to use.
    
    
     Let’s add a unit test to verify that our
    
    <strong class="source-inline">
     
      increment_all
     
    </strong>
    
     function works
    
    
     
      as expected:
     
    
   </p>
   <pre class="source-code">
#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn it_works() {
        assert_eq!(vec![2, 3, 4], increment_all());
    }
}</pre>
   <p>
    
     As a plus, I like that it’s very easy to write unit tests in the same compilation unit (called a
    
    <strong class="bold">
     
      crate
     
    </strong>
    
     in
    
    <a id="_idIndexMarker418">
    </a>
    
     Rust) as the production code.
    
    
     This might not seem like much if you see unit tests as an
    
    <a id="_idIndexMarker419">
    </a>
    
     obligation, but I often use unit tests to experiment and to design so I love this facility
    
    
     
      a lot.
     
    
   </p>
   <h2 id="_idParaDest-132">
    <a id="_idTextAnchor131">
    </a>
    
     Traits
    
   </h2>
   <p>
    
     A big difference
    
    <a id="_idIndexMarker420">
    </a>
    
     between Rust (or Go) and the other mainstream languages is that Rust does not support inheritance, instead favoring composition.
    
    
     To allow for polymorphic behavior without inheritance, Rust
    
    
     
      offers traits.
     
    
   </p>
   <p>
    
     Rust traits are similar to interfaces in object-oriented languages in that they define a set of methods that need to be implemented for every object that derives from them.
    
    
     However, Rust traits have a specific feature: you can add a trait to a type you don’t own.
    
    
     This is similar to extension methods in C#, although not
    
    
     
      the same.
     
    
   </p>
   <p>
    
     The Rust documentation provides an example of traits by using two structures, one representing a tweet and the other a news article, and adding the
    
    <strong class="source-inline">
     
      Summary
     
    </strong>
    
     trait to both is meant to create a summary of the corresponding message.
    
    
     As you can see in the example that follows, the trait implementation is separate from both the structure implementation and the trait definition, which makes it
    
    
     
      very flexible.
     
    
   </p>
   <p>
    
     Let’s start by looking at the two structures.
    
    
     First, the
    
    <strong class="source-inline">
     
      NewsArticle
     
    </strong>
    
     contains a
    
    
     
      few fields:
     
    
   </p>
   <pre class="source-code">
pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}</pre>
   <p>
    
     Then, the
    
    <strong class="source-inline">
     
      Tweet
     
    </strong>
    
     structure contains its
    
    
     
      own fields:
     
    
   </p>
   <pre class="source-code">
pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}</pre>
   <p>
    
     Separately, we define the
    
    <strong class="source-inline">
     
      Summary
     
    </strong>
    
     trait with a single method summarize returning
    
    
     
      a string:
     
    
   </p>
   <pre class="source-code">
pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}</pre>
   <p>
    
     Let’s now
    
    <a id="_idIndexMarker421">
    </a>
    
     implement the
    
    <strong class="source-inline">
     
      Summary
     
    </strong>
    
     trait for the
    
    <strong class="source-inline">
     
      Tweet
     
    </strong>
    
     structure.
    
    
     This is done by specifying that the implementation of this trait applies to the structure,
    
    
     
      as follows:
     
    
   </p>
   <pre class="source-code">
impl Summary for Tweet {
    fn summarize(&amp;self) -&gt; String {
        format!("{}: {}", self.username, self.content)
    }
}</pre>
   <p>
    
     The test
    
    
     
      works perfectly:
     
    
   </p>
   <pre class="source-code">
    #[test]
    fn summarize_tweet() {
        let tweet = Tweet {
            username: String::from("me"),
            content: String::from("a message"),
            reply: false,
            retweet: false,
        };
        assert_eq!("me: a message", tweet.summarize());
    }</pre>
   <p>
    
     Finally, let’s
    
    <a id="_idIndexMarker422">
    </a>
    
     implement the trait for the
    
    
     
      news article:
     
    
   </p>
   <pre class="source-code">
impl Summary for NewsArticle {
    fn summarize(&amp;self) -&gt; String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}
#[test]
    fn summarize_news_article() {
        let news_article = NewsArticle {
            headline: String::from("Big News"),
            location: String::from("Undisclosed"),
            author: String::from("Me"),
            content: String::from("Big News here, must follow"),
        };
        assert_eq!("Big News, by Me (Undisclosed)", news_article.summarize());
    }</pre>
   <p>
    
     Traits in Rust have much more capabilities.
    
    
     We can implement a default behavior, specify that the type of a parameter needs to be of one or multiple trait types,  implement traits generically on multiple types, and so on.
    
    
     In fact, Rust traits are a combination of OO interfaces, C# extension methods, and C++ concepts.
    
    
     However, this is outside the scope of this chapter.
    
    
     What’s worth remembering is that Rust treats inheritance very differently
    
    
     
      from C++.
     
    
   </p>
   <h2 id="_idParaDest-133">
    <a id="_idTextAnchor132">
    </a>
    
     Ownership model
    
   </h2>
   <p>
    
     An interesting
    
    <a id="_idIndexMarker423">
    </a>
    
     characteristic of Rust, and perhaps its most advertised feature, is the ownership model.
    
    
     This is Rust’s reaction to memory safety issues in C++, only instead of going into garbage collectors like Java or C# do, the designers have solved the problem with a more explicit ownership of memory.
    
    
     We’ll look at a quote from the Rust
    
    
     
      book (
     
    
    <a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html):">
     
      
       https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html
      
     
     
      
       ):
      
     
    </a>
   </p>
   <p>
    
     “
    
    <em class="italic">
     
      Memory is managed through a system of ownership with a set of rules that the compiler checks.
     
     
      If any of the rules are violated, the program won’t compile.
     
     
      None of the features of ownership will slow down your program while
     
    </em>
    
     <em class="italic">
      
       it’s running.
      
     </em>
    
    
     
      ”
     
    
   </p>
   <p>
    
     There are three rules of ownership
    
    
     
      in Rust:
     
    
   </p>
   <ul>
    <li>
     
      Each value in Rust has
     
     
      
       an
      
     
     
      <em class="italic">
       
        owner
       
      </em>
     
    </li>
    <li>
     
      There can only be one owner at
     
     
      
       a time
      
     
    </li>
    <li>
     
      When the owner goes out of scope, the value will
     
     
      
       be dropped
      
     
    </li>
   </ul>
   <p>
    
     Let’s first look at an example that works the same as in C++.
    
    
     If we have a variable allocated on the stack, such as an integer, then copying the variable works in a very
    
    
     
      familiar way:
     
    
   </p>
   <pre class="source-code">
    #[test]
    fn copy_on_stack() {
        let stack_value = 1;
        let copied_stack_value = stack_value;
        assert_eq!(1, stack_value);
        assert_eq!(1, copied_stack_value);
    }</pre>
   <p>
    
     Both variables have the same value, as expected.
    
    
     However, if we try the same code with a variable allocated on the heap, we get
    
    
     
      an error:
     
    
   </p>
   <pre class="source-code">
    #[test]
    fn copy_on_heap() {
        let heap_value = String::from("A string");
        let copied_heap_value = heap_value;
        assert_eq!(String::from("A string"), heap_value);
        assert_eq!(String::from("A string"), copied_heap_value);
    }</pre>
   <p>
    
     When running this, we get the
    
    <strong class="source-inline">
     
      error[E0382]: borrow of moved value: `heap_value`
     
    </strong>
    
     error.
    
    
     
      What happens?
     
    
   </p>
   <p>
    
     Well, when we assign the value of
    
    <strong class="source-inline">
     
      heap_value
     
    </strong>
    
     to
    
    <strong class="source-inline">
     
      copied_heap_value
     
    </strong>
    
     , the
    
    <strong class="source-inline">
     
      heap_value
     
    </strong>
    
     variable is invalidated.
    
    
     This behaves the same as the move semantics in C++, only without any additional work from the programmer.
    
    
     Behind the scenes, this works through the use of two traits:
    
    <strong class="source-inline">
     
      Copy
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      Drop
     
    </strong>
    
     .
    
    
     If a type implements the
    
    <strong class="source-inline">
     
      Copy
     
    </strong>
    
     trait then it works as in the first example, while if it implements the
    
    <strong class="source-inline">
     
      Drop
     
    </strong>
    
     trait then it works as in the second.
    
    
     No type can implement
    
    
     
      both traits.
     
    
   </p>
   <p>
    
     To make the
    
    <a id="_idIndexMarker424">
    </a>
    
     above example work, we need to clone the value instead of using the default
    
    
     
      move mechanism:
     
    
   </p>
   <pre class="console">
    #[test]
    fn clone_on_heap() {
        let heap_value = String::from("A string");
        let copied_heap_value = heap_value.clone();
        assert_eq!(String::from("A string"), heap_value);
        assert_eq!(String::from("A string"), copied_heap_value);
    }</pre>
   <p>
    
     This example works fine, so the value is cloned.
    
    
     This indicates, however, a new allocation on the heap, not a reference to the
    
    
     
      same value.
     
    
   </p>
   <p>
    
     The move
    
    <a id="_idIndexMarker425">
    </a>
    
     semantics work the same for function calls.
    
    
     Let’s initialize a value and pass it to a function that returns it unchanged to see
    
    
     
      what happens:
     
    
   </p>
   <pre class="source-code">
    fn call_me(value: String) -&gt; String {
        return value;
    }
    #[test]
    fn move_semantics_method_call() {
        let heap_value = String::from("A string");
        let result = call_me(heap_value);
        assert_eq!(String::from("A string"), heap_value);
        assert_eq!(String::from("A string"), result);
    }</pre>
   <p>
    
     When trying to compile this code, we get the same error as before:
    
    <strong class="source-inline">
     
      error[E0382]: borrow of moved value: `heap_value`
     
    </strong>
    
     .
    
    
     The value is created on the heap, moved into the
    
    <strong class="source-inline">
     
      call_me
     
    </strong>
    
     function, and therefore dropped from the current scope.
    
    
     We can make this code work by specifying that the function called should only borrow the ownership instead of taking it over.
    
    
     This is done through the use of reference and dereference operators, which are the same as
    
    
     
      in C++:
     
    
   </p>
   <pre class="console">
    fn i_borrow(value: &amp;String) -&gt; &amp;String {
        return value;
    }
    #[test]
    fn borrow_method_call() {
        let heap_value = String::from("A string");
        let result = i_borrow(&amp;heap_value);
        assert_eq!(String::from("A string"), heap_value);
        assert_eq!(String::from("A string"), *result);
    }</pre>
   <p>
    
     The important difference between C++ references and Rust references is that Rust references are immutable
    
    
     
      by default.
     
    
   </p>
   <p>
    
     There is, of course, a lot more to learn about the ownership model in Rust, but I believe this is enough to give you a taste of how it works and how it’s meant to prevent memory
    
    
     
      safety issues.
     
    
   </p>
   <h1 id="_idParaDest-134">
    <a id="_idTextAnchor133">
    </a>
    
     Rust’s advantages
    
   </h1>
   <p>
    
     To summarize, Rust has a few advantages over C++.
    
    
     By being a newer language, it has the advantage of learning from
    
    <a id="_idIndexMarker426">
    </a>
    
     its predecessors and using the best patterns available.
    
    
     I find the combination of immutability with the ownership model to be very good at code that works well by default.
    
    
     It might take a bit to learn since it’s not the typical memory management style, but once you understand how to use it, it allows you to write code that works without
    
    
     
      much challenge.
     
    
   </p>
   <p>
    
     The unit testing support in the standard library, the package manager, and the multi-editor support should be part of any modern programming language.
    
    
     The syntax is nicer when it comes to closures and
    
    
     
      compound types.
     
    
   </p>
   <p>
    
     We might wonder at this point: does C++ stand a chance?
    
    
     Why
    
    
     
      and where?
     
    
   </p>
   <h1 id="_idParaDest-135">
    <a id="_idTextAnchor134">
    </a>
    
     Where C++ is better
    
   </h1>
   <p>
    
     C++ is a very capable, advanced
    
    <a id="_idIndexMarker427">
    </a>
    
     programming language, under continuous improvement.
    
    
     The language is progressing quite fast.
    
    
     It’s very difficult to equal the C++ ecosystem: its community, the staggering number of libraries and frameworks available, and the articles, blogs, and books that teach you how to use C++ in various ways for any possible problem you might have.
    
    
     For all its benefits, Rust is a young language compared to C++, which should give you pause when considering the choice of technology for systems programming.
    
    
     However, Rust has been adopted for subsystems of Linux and Android, so it proves itself a
    
    
     
      worthy competitor.
     
    
   </p>
   <p>
    
     The C++ standardization committee has shown a continuous focus on simplifying syntax and reducing the mental burden of programmers for various code constructs.
    
    
     Part of the effort comes from the competition, with many of the features introduced in C++17 and later being an answer to the Rust design choices.
    
    
     While I don’t expect C++’s syntax to evolve to be as simple as Rust, the other factors mentioned here must contribute to the choice just as much, if
    
    
     
      not more.
     
    
   </p>
   <h1 id="_idParaDest-136">
    <a id="_idTextAnchor135">
    </a>
    
     What C++ still needs
    
   </h1>
   <p>
    
     In this book, we have seen some of the challenges
    
    <a id="_idIndexMarker428">
    </a>
    
     of C++.
    
    
     A standard package manager would be very helpful, even if the community follows in the footsteps of Java and C# and picks an open source de-facto standard.
    
    
     A standard unit testing library would be very beneficial, even if the existing code might take a long while to migrate if it
    
    
     
      ever does.
     
    
   </p>
   <p>
    
     Unicode and utf-8 support still need improvement.
    
    
     Standard support for multithreading is at the beginning.
    
    
     Safety profiles would be extremely useful for minimizing memory
    
    
     
      safety issues.
     
    
   </p>
   <p>
    
     It’s clear from this list that C++ has a lot of things to improve.
    
    
     The good news is that the standardization committee is hard at work on some of these issues.
    
    
     The less good news is that it takes time to define these improvements, more time to adapt compilers, and even more time to adapt existing code.
    
    
     Hopefully, Gen AI will be capable enough to speed up these improvements while maintaining
    
    
     
      code integrity.
     
    
   </p>
   <h1 id="_idParaDest-137">
    <a id="_idTextAnchor136">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     We saw, in this chapter, that Rust is a very interesting language, whose designers knew to take advantage of the knowledge gathered by their predecessors and to innovate in the right places.
    
    
     The result is a nice syntax, a more natural way to deal with memory without using a garbage collector, and an overall modern development experience.
    
    
     We explored this in
    
    
     
      this chapter.
     
    
   </p>
   <p>
    
     However, C++ is hard to compete with.
    
    
     The sheer number of libraries, frameworks, blogs, articles, code examples, books, and experience available in the world on C++ is impossible to equal in a short time.
    
    
     Rust has found its niches in Web Assembly applications and various tools, but it’s far from
    
    
     
      replacing C++.
     
    
   </p>
   <p>
    
     Still, we have to remember that languages are not necessarily picked based on technical reasons and that cultural reasons matter as well.
    
    
     Newer generations of programmers might enjoy Rust much more than C++, and with the NSA and the White House leading the focus on memory-safe languages, Rust might gain ground for
    
    
     
      newer projects.
     
    
   </p>
   <p>
    
     The conclusion?
    
    
     It’s hard to predict the future, but we can imagine how Rust could take over.
    
    
     The way I see it, it would require four factors: Rust is preferred by more and more programmers, it is required by regulation, C++ fails to evolve on memory safety fast enough, and generative AI gets good enough at translating from C++
    
    
     
      to Rust.
     
    
   </p>
   <p>
    
     So, there’s a chance, but I think it’s safe to say that it’s over 50% that C++ is here to stay at least for
    
    
     
      another decade.
     
    
   </p>
  </div>
 </body></html>