<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer053">
<h1 class="chapter-number" id="_idParaDest-213"><a id="_idTextAnchor561"/>13</h1>
<h1 id="_idParaDest-214"><a id="_idTextAnchor562"/>Working with Templates</h1>
<p>This chapter will continue our pursuit of increasing your C++ programming repertoire beyond OOP concepts, with the continued goal of writing more extensible code. We will next explore creating generic code using C++ templates – both <strong class="bold">template functions</strong> and <strong class="bold">template classes</strong>. We will learn how template code, when written correctly, is the pinnacle in code reuse. In addition to exploring how to create both template functions and template classes, we will also understand how the appropriate use of operator overloading can make a template function reusable for nearly any type of data. </p>
<p>In this chapter, we will cover the following main topics:</p>
<ul>
<li>Exploring template basics to genericize code</li>
<li>Understanding how to create and use template functions and template classes</li>
<li>Understanding how operator overloading can make templates more extensible</li>
</ul>
<p>Many object-oriented languages include the concept of programming with generics, allowing the types of classes and interfaces to be parameterized themselves. In some languages, generics are merely wrappers for casting objects to the desired type. In C++, the idea of generics is more comprehensive and is implemented using templates. </p>
<p>By the end of this chapter, you will be able to design more generic code by building both template functions and template classes. You will understand how operator overloading can ensure that a template function can become highly extensible for any data type. By pairing together well-designed template member functions with operator overloading, you will be able to create highly reusable and extensible template classes in C++.</p>
<p>Let’s increase our understanding of C++ by expanding your programming repertoire by exploring templates. </p>
<h1 id="_idParaDest-215"><a id="_idTextAnchor563"/>Technical requirements</h1>
<p>Online code for full program examples can be found in the following GitHub URL: <a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter13">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter13</a>. Each full program example can be found in the GitHub repository under the appropriate chapter heading (subdirectory) in a file that corresponds to the chapter number, followed by a dash, followed by the example number in the chapter at hand. For example, the first full program in this chapter can be found in the subdirectory <strong class="source-inline">Chapter13</strong> in a file named <strong class="source-inline">Chp13-Ex1.cpp</strong> under the aforementioned GitHub directory.</p>
<p>The CiA video for this chapter can be viewed at: <a href="https://bit.ly/3A7lx0U">https://bit.ly/3A7lx0U</a>.</p>
<h1 id="_idParaDest-216"><a id="_idTextAnchor564"/><a id="_idTextAnchor565"/><a id="_idTextAnchor566"/>Exploring template basics to genericize code</h1>
<p>Templates allow code to be generically specified in a manner that is abstracted from the data types <a id="_idIndexMarker854"/>primarily used within relevant functions or classes. The motivation for creating templates is to generically specify the definition of functions and classes that we repeatedly want to utilize, but with varying data types. The individualized versions of these components would otherwise differ only in the core data type utilized; these key data types can then be extracted and written generically. </p>
<p>When we then opt to utilize such a class or function with a specific type, rather than copying and pasting existing code from a similar class or function (with preset data types) and changing it slightly, the preprocessor instead would take the template code and <em class="italic">expand</em> it for our requested, bonafide type. This template <em class="italic">expansion</em> capability allows the programmer to write and maintain only one version of the genericized code, versus the many type-specific versions of code that would otherwise need to be written. The benefit is also that the preprocessor will do a more accurate expansion of the template code to a bonafide type than we might have done using a copy, paste, and slight modification method.</p>
<p>Let’s take a moment to further investigate the motivation for using templates in our code.</p>
<h2 id="_idParaDest-217"><a id="_idTextAnchor567"/>Examining the motivation for templates</h2>
<p>Imagine that <a id="_idIndexMarker855"/>we wish to create a class to safely handle dynamically allocated arrays for data type <strong class="source-inline">int</strong>, such as we have created in a solution for <em class="italic">Question 3</em> of <a href="B19087_12.xhtml#_idTextAnchor526"><em class="italic">Chapter 12</em></a>, <em class="italic">Friends and Operator Overloading</em>. Our motivation may be to have an array type that can grow or shrink to any size (unlike native, fixed-sized arrays), yet have bounds checking for safe usage (unlike the raw manipulation of a dynamic array implemented using <strong class="source-inline">int *</strong>, which would unscrupulously allow us to access elements well beyond the length of our dynamic array allocation). </p>
<p>We may <a id="_idIndexMarker856"/>decide to create an <strong class="source-inline">ArrayInt</strong> class with the following beginning framework:</p>
<pre class="source-code">
class ArrayInt
{
private: 
    int numElements = 0;     // in-class initialization
    int *contents = nullptr; // dynamically allocated array
public:
    ArrayInt(int size): numElements(size) 
    { 
        contents = new int [size];
    }
    ~ArrayInt() { delete [] contents; }       
    int &amp;operator[](int index) // returns a referenceable
    {                // memory location or throws exception
        if (index &lt; numElements) 
            return contents[index];
        else         // index selected is out of bounds
            throw std::out_of_range(std::to_string(index));
    }                                
};
int main()
{
    ArrayInt a1(5); // Create an ArrayInt of 5 elements
    try    // operator[] could throw an exception
    {
        a1[4] = 7;      // a1.operator[](4) = 7;
    }
    catch (const std::out_of_range &amp;e)
    {
        cout &lt;&lt; "Out of range: element " &lt;&lt; e.what();
        cout &lt;&lt; endl;
    }
}   </pre>
<p>In the previous code segment, notice that our <strong class="source-inline">ArrayInt</strong> class implements the data structure comprising the array using <strong class="source-inline">int *contents</strong>, which is dynamically allocated to the desired <a id="_idIndexMarker857"/>size in the constructor. We have overloaded <strong class="source-inline">operator[]</strong> to safely return only indexed values in the array that are within the proper range, and throw a <strong class="source-inline">std::out_of_range</strong> exception otherwise. We can add methods to <strong class="source-inline">Resize()</strong> an <strong class="source-inline">ArrayInt</strong> and so on. Overall, we love the safety and flexibility of this class. </p>
<p>Now, we may want to have an <strong class="source-inline">ArrayFloat</strong> class (or later, an <strong class="source-inline">ArrayStudent</strong> class). Rather than copying our baseline <strong class="source-inline">ArrayInt</strong> class and modifying it slightly to create an <strong class="source-inline">ArrayFloat</strong> class, for example, we may ask whether there is a more automated way to make this substitution. After all, what would we change in creating an <strong class="source-inline">ArrayFloat</strong> class using an <strong class="source-inline">ArrayInt</strong> class as a starting point? We would change the <em class="italic">type</em> of the data member <strong class="source-inline">contents</strong> – from an <strong class="source-inline">int *</strong> to a <strong class="source-inline">float *</strong>. We would change the <em class="italic">type</em> in the memory allocation in the constructor from <strong class="source-inline">contents = new int [size];</strong> to utilize <strong class="source-inline">float</strong> instead of <strong class="source-inline">int</strong> (and similarly so in any reallocation, such as in a <strong class="source-inline">Resize()</strong> method). </p>
<p>Rather than copying, pasting, and slightly modifying an <strong class="source-inline">ArrayInt</strong> class to create an <strong class="source-inline">ArrayFloat</strong> class, we can <a id="_idIndexMarker858"/>simply use a <strong class="bold">template class</strong> to genericize the <em class="italic">type</em> associated with the data manipulated within this class. Similarly, any functions relying on the <a id="_idIndexMarker859"/>specific data type will become <strong class="bold">template functions</strong>. We will examine the syntax for creating and utilizing templates shortly.</p>
<p>Using templates, we can instead create just one template class called <strong class="source-inline">Array</strong> where the type is genericized. At compile time, should the preprocessor detect we have utilized this class for type <strong class="source-inline">int</strong> or <strong class="source-inline">float</strong> in our code, the preprocessor will then provide the necessary template <em class="italic">expansions</em> for us. That is, by copying and pasting (behind the scenes) each template class (and its methods) and substituting in the data types that the preprocessor identifies we are using. </p>
<p>The resulting code, once expanded under the hood, is no smaller than if we had written the code for <a id="_idIndexMarker860"/>each individual class ourselves. But the point is that we did not have to tediously create, modify, test, and later maintain each minorly different class ourselves. This is done on our behalf by C++. This is the noteworthy purpose of template classes and template functions. </p>
<p>Templates are not restricted for use with primitive data types. For example, we may wish to create an <strong class="source-inline">Array</strong> of a user defined type, such as <strong class="source-inline">Student</strong>. We will need to ensure that all of our template member functions are meaningful for the data types that we actually expand the template class to utilize. We may need to overload selected operators so that our template member functions can work seamlessly with user defined types, just as they do with primitive types.</p>
<p>We will later see in this chapter an example illustrating how we may need to overload selected operators if we choose to expand a template class for user defined types so that the member functions of a class can work fluidly with any data type. Fortunately, we know how to overload operators!</p>
<p>Let’s move forward to explore the mechanics of specifying and utilizing template functions and template classes.</p>
<h1 id="_idParaDest-218"><a id="_idTextAnchor568"/>Understanding template functions and classes</h1>
<p><strong class="bold">Templates</strong> provide the <a id="_idIndexMarker861"/>ability to create generic functions and classes by abstracting the data types associated with those functions and classes. Template functions and classes can both be carefully written in such a way as to genericize the relevant data types that underlie these functions and classes. </p>
<p>Let’s begin by examining how to create and utilize template fun<a id="_idTextAnchor569"/><a id="_idTextAnchor570"/>ctions.</p>
<h2 id="_idParaDest-219"><a id="_idTextAnchor571"/>Creating and using template functions</h2>
<p><strong class="bold">Template functions</strong> parameterize <a id="_idIndexMarker862"/>the types of arguments in a function in addition to the arguments themselves. Template functions require the body of the function to be applicable to almost any data type. Template functions can be member or non-member functions. Operator overloading can help ensure that the bodies of template functions are applicable to user defined types – we’ll see more of that s<a id="_idTextAnchor572"/>hortly. </p>
<p>The keyword <strong class="source-inline">template</strong>, along with angle brackets, <strong class="source-inline">&lt;</strong> <strong class="source-inline">&gt;</strong>, and placeholders for the <em class="italic">type</em> names are used to specify a template function and its prototype.</p>
<p>Let’s take a <a id="_idIndexMarker863"/>look at a template function that is not a member of a class (we will see examples of template member functions <a id="_idTextAnchor573"/>shortly). This example can be found, as a full working program, in our GitHub repository as follows:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter13/Chp13-Ex1.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter13/Chp13-Ex1.cpp</a></p>
<pre class="source-code">
// template function prototype
<strong class="bold">template &lt;class Type1, class Type2&gt;</strong>   // template preamble
<strong class="bold">Type2</strong> ChooseFirst(<strong class="bold">Type1</strong>, <strong class="bold">Type2</strong>);
// template function definition
<strong class="bold">template &lt;class Type1, class Type2&gt;</strong>  // template preamble
<strong class="bold">Type2</strong> ChooseFirst(<strong class="bold">Type1</strong> x, <strong class="bold">Type2</strong> y)
{
    if (x &lt; y) 
        return static_cast&lt;<strong class="bold">Type2</strong>&gt;(x);
    else 
        return y; 
}   
int main()
{
    int value1 = 4, value2 = 7;
    float value3 = 5.67f;
    cout &lt;&lt; "First: " &lt;&lt; <strong class="bold">ChooseFirst(value1, value3)</strong>; 
    cout &lt;&lt; endl;
    cout &lt;&lt; "First: " &lt;&lt; <strong class="bold">ChooseFirst(value2, value1)</strong>; 
    cout &lt;&lt; endl;
}</pre>
<p>Looking at <a id="_idIndexMarker864"/>the previous function example, we first see a template function prototype. The p<a id="_idTextAnchor574"/>reamble of <strong class="source-inline">template &lt;class Type1, class Type 2&gt;</strong> indicates that the prototype will be a template prototype and that placeholders <strong class="source-inline">Type1</strong> and <strong class="source-inline">Type2</strong> will be used instead of actual data types. The placeholders <strong class="source-inline">Type1</strong> and <strong class="source-inline">Type2</strong> may be (nearly) any name, following the rules of creating identifiers. </p>
<p>Then, to <a id="_idIndexMarker865"/>complete the prototype, we see <strong class="source-inline">Type2 ChooseFirst(Type1, Type2);</strong>, which indicates that the return type from this function will be of <strong class="source-inline">Type2</strong> and that the arguments of the <strong class="source-inline">ChooseFirst()</strong> function will be of <strong class="source-inline">Type1</strong> and <strong class="source-inline">Type2</strong> (which may certainly be expanded to be the same type).</p>
<p>Next, we see the function definition. It, too, begins with a preamble of <strong class="source-inline">template &lt;class Type1, class Type 2&gt;</strong>. Similar to the prototype, the function header <strong class="source-inline">Type2 ChooseFirst(Type1 x, Type2 y)</strong> indicates that formal parameters <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong> are of types <strong class="source-inline">Type1</strong> and <strong class="source-inline">Type2</strong>, respectively. The body of this function is rather straightforward. We simply determine which of the two parameters should be ranked first in an ordering of the two values by using a simple comparison with the <strong class="source-inline">&lt;</strong> operator.</p>
<p>Now, in <strong class="source-inline">main()</strong>, when the preprocessor portion of the compiler sees a call to <strong class="source-inline">ChooseFirst()</strong> with actual parameters, <strong class="source-inline">int value1</strong> and <strong class="source-inline">float value3</strong>, the preprocessor notices that <strong class="source-inline">ChooseFirst()</strong> is a template function. If no such version of <strong class="source-inline">ChooseFirst()</strong> yet exists to handle an <strong class="source-inline">int</strong> and a <strong class="source-inline">float</strong>, the preprocessor copies this template function and replaces <strong class="source-inline">Type1</strong> with <strong class="source-inline">int</strong> and <strong class="source-inline">Type2</strong> with <strong class="source-inline">float</strong> – creating on our behalf the appropriate version of this function to fit our needs. Notice that when <strong class="source-inline">ChooseFirst(value2, value1)</strong> is called and the types are both integers, the placeholder types of <strong class="source-inline">Type1</strong> and <strong class="source-inline">Type2</strong> will both be replaced with <strong class="source-inline">int</strong> when the template function is again expanded (under the hood) in our code by the preprocessor.</p>
<p>Though <strong class="source-inline">ChooseFirst()</strong> is a simple function, with it we can see the straightforward mechanics of creating a template function that genericizes key data types. We can also see how <a id="_idIndexMarker866"/>the preprocessor notices how the template function is <a id="_idIndexMarker867"/>used and takes on the effort on our behalf to expand this function, as needed, for our specific type usage.</p>
<p>Let’s take a look at the output for this program:</p>
<p class="source-code">First: 4</p>
<p class="source-code">First: 4</p>
<p>Now that we have seen the basic mechanics of template functions, let us move forward to understand how we can expand this process to include template classes.</p>
<h2 id="_idParaDest-220"><a id="_idTextAnchor575"/>Creating and using template classes</h2>
<p><strong class="bold">Template classes</strong> parameterize the ultimate type of a class definition, and will additionally <a id="_idIndexMarker868"/>require template member functions for any methods <a id="_idIndexMarker869"/>that need to know the core data type being manipulated.</p>
<p>The keywords <strong class="source-inline">template</strong> and <strong class="source-inline">class</strong>, along with angle brackets, <strong class="source-inline">&lt;</strong> <strong class="source-inline">&gt;</strong>, and place<a id="_idTextAnchor576"/>holders for the <em class="italic">type</em> names are used to specify a template class definition.</p>
<p>Let’s take a look at a template class definition and its supporting template member functions. This example can be found as a complete program (with the necessary <strong class="source-inline">#include</strong> and <strong class="source-inline">using</strong> statements) in our GitHub repository as follows:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter13/Chp13-Ex2.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter13/Chp13-Ex2.cpp</a></p>
<pre class="source-code">
<strong class="bold">template &lt;class Type&gt;   </strong>// template class preamble
<a id="_idTextAnchor577"/>class Array
{
private:
    int numElements = 0;   // in-class initialization
    <strong class="bold">Type</strong> *contents = nullptr;// dynamically allocated array
public:
    // Constructor and destructor will allocate, deallocate
    // heap memory to allow Array to be fluid in its size.
    // Later, you can use a smart pointer – or use the STL
    // vector class (we're building a similar class here!)
    Array(int size): numElements(size), 
                     contents(new <strong class="bold">Type</strong> [size])
    { // note: allocation is handled in member init. list
    }
    ~Array() { delete [] contents; }  
    void Print() const;     
    <strong class="bold">Type</strong> &amp;operator[](int index) // returns a referenceable
    {               // memory location or throws exception
        if (index &lt; numElements) 
            return contents[index];
        else   // index is out of bounds
            throw std::out_of_range
                             (std::to_string (index));    
    }                                
    void operator+(<strong class="bold">Type</strong>);   // pro<a id="_idTextAnchor578"/>totype only
};
<strong class="bold">template &lt;class Type&gt;</strong>
void <strong class="bold">Array&lt;Type&gt;</strong>::operator+(<strong class="bold">Type</strong> item)  
{
    // resize array as necessary, add new data element and
    // increment numElements
}
<strong class="bold">template &lt;class Type&gt;</strong>
void <strong class="bold">Array&lt;Type&gt;</strong>::Print() const
{
    for (int i = 0; i &lt; numElements; i++)
        cout &lt;&lt; contents[i] &lt;&lt; " ";
    cout &lt;&lt; endl;
}
int main()
{                    
    // Creation of int Array will trigger template
    // expansion by the preprocessor.
    <strong class="bold">Array&lt;int&gt;</strong> a1(3); // Create an int Array of 3 elements
    try    // operator[] could throw an exception
    {
        a1[2] = 12;      
        a1[1] = 70;       // a1.operator[](1) = 70;
        a1[0] = 2;
        a1[100] = 10;// this assignment throws an exception
    }
    catch (const std::out_of_range &amp;e)
    {
        cout &lt;&lt; "Out of range: index " &lt;&lt; e.what() &lt;&lt; endl;
    } 
    a1.Print();
}   </pre>
<p>In the preceding class definition, let’s first notice the template class preamble of <strong class="source-inline">template &lt;class Type&gt;</strong>. This preamble specifies that the impending class definition will be that of a template class and that the placeholder <strong class="source-inline">Type</strong> will be used to genericize the data types primarily used within this class. </p>
<p>We then <a id="_idIndexMarker870"/>see the class definition for <strong class="source-inline">Array</strong>. Data member <strong class="source-inline">contents</strong> will be of the placeholder type of <strong class="source-inline">Type</strong>. Of course, not all data types will need to <a id="_idIndexMarker871"/>be genericized. Data member <strong class="source-inline">int numElements</strong> is perfectly reasonable as an integer. Next, we see an assortment of member functions prototyped and some defined inline, including overloaded <strong class="source-inline">operator[]</strong>. For the member functions defined inline, a template preamble is not necessary in front of the function definition. The only thing we need to do for inline functions is to genericize the data type using our placeholder, <strong class="source-inline">Type</strong>.</p>
<p>Let’s now take a look at selected member functions. In the constructor, we now notice that the memory allocation of <strong class="source-inline">contents = new Type [size];</strong> merely uses the placeholder <strong class="source-inline">Type</strong> in lieu of an actual data type. Similarly, for overloaded <strong class="source-inline">operator[]</strong>, the return type of this method is <strong class="source-inline">Type</strong>.</p>
<p>However, looking at a member function that is not inline, we notice that the template preamble of <strong class="source-inline">template &lt;class Type&gt;</strong> must precede the member function definition. For example, let’s consider the member function definition for <strong class="source-inline">void Array&lt;Type&gt;::operator+(Type item);</strong>. In addition to the preamble, the class name (preceding the member function name and scope resolution operator, <strong class="source-inline">::</strong>) in the function definition must be augmented to include the placeholder type <strong class="source-inline">&lt;Type&gt;</strong> in angle brackets. Also, any generic function parameters must use the pl<a id="_idTextAnchor579"/>aceholder type of <strong class="source-inline">Type</strong>. </p>
<p>Now, in our <strong class="source-inline">main()</strong> function, we merely use the data type of <strong class="source-inline">Array&lt;int&gt;</strong> to instantiate a safe, easily resizable array of integers. We could have alternatively used <strong class="source-inline">Array&lt;float&gt;</strong> had we instead wanted to instantiate an array of floating-point numbers. Under the hood, when we create an instance of a specific array type, the preprocessor notices whether we have previously expanded this class for that <em class="italic">type</em>. If not, the class definition and applicable template member functions are copied for us and the <a id="_idIndexMarker872"/>placeholder types are replaced with the type that we need. This is no fewer lines of code than if we had copied, pasted, and slightly modified the <a id="_idIndexMarker873"/>code ourselves; however, the point is that we only have one version to specify and maintain ourselves. This is less error-prone and easier for lon<a id="_idTextAnchor580"/>g-term maintenance. </p>
<p>Let’s take a look at the output for this program:</p>
<p class="source-code">2 70 12</p>
<p class="callout-heading">An interesting tangent – std::optional</p>
<p class="callout">In the previous example, <strong class="source-inline">Array&lt;Type&gt;::operator[]</strong> throws an <strong class="source-inline">out_of_range</strong> exception when the selected index is out of bounds. Sometimes, exception handling can be programmatically expensive. In such cases, using an optional return type may be a useful alternative. Remember, a valid return value for <strong class="source-inline">operator[]</strong> is a reference to the memory location for the array element in question. For the out-of-bounds index scenario, knowing we simply cannot return the corresponding memory location for an array element from this method (it would not make sense), an alternative to exception handling may be to use <strong class="source-inline">std::optional&lt;Type&gt;</strong> in the return value of the function.</p>
<p>Let’s next take a look at a different full program example to pull together template functions and template classes.</p>
<h2 id="_idParaDest-221"><a id="_idTextAnchor581"/>Examining a full program example</h2>
<p>It is <a id="_idIndexMarker874"/>useful to see an additional example that <a id="_idIndexMarker875"/>illustrates template functions and template classes. Let us expand on a <strong class="source-inline">LinkList</strong> program we reviewed most recently in <a href="B19087_12.xhtml#_idTextAnchor526"><em class="italic">Chapter 12</em></a>, <em class="italic">Friends and Operator Overloading</em>; we will upgrade this program to utilize templates. </p>
<p>This <a id="_idIndexMarker876"/>complete program can be found <a id="_idIndexMarker877"/>in our GitHu<a id="_idTextAnchor582"/>b repository as follows:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter13/Chp13-Ex3.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter13/Chp13-Ex3.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
using std::cout;   // preferred to: using namespace std;
using std::endl;
// forward declaration with template preamble
<strong class="bold">template &lt;class Type&gt; class LinkList;</strong>  
<strong class="bold">template &lt;class Type&gt;</strong>   // template preamble for class def.
class LinkListElement
{
private:
    <strong class="bold">Type</strong> *data = nullptr;
    LinkListElement *next = nullptr;
    // private access methods to be used in scope of friend<strong class="bold"> </strong>
    <strong class="bold">Type</strong> *GetData() const { return data; } 
    LinkListElement *GetNext() const { return next; }
    void SetNext(LinkListElement *e) { next = e; }
public:
    friend class<strong class="bold"> LinkList&lt;Type&gt;;</strong>   
    LinkListElement() = default;
    LinkListElement(<strong class="bold">Type</strong> *i): data(i), next(nullptr) { }
    ~LinkListElement(){ delete data; next = nullptr; }
};
// LinkList should only be extended as a protected/private
// base class; it does not contain a virtual destructor. It
// can be used as-is, or as implementation for another ADT.
<strong class="bold">template &lt;class Type&gt;</strong>
class LinkList
{
private:
    <strong class="bold">LinkListElement&lt;Type&gt;</strong> *head = nullptr, *tail = nullptr,
                                 *current = nullptr;
public:
    LinkList() = default;
    LinkList(<strong class="bold">LinkListElement&lt;Type&gt;</strong> *e) 
        { head = tail = current = e; }
    void InsertAtFront(<strong class="bold">Type</strong> *);
    <strong class="bold">LinkListElement&lt;Type&gt;</strong> *RemoveAtFront();  
    void DeleteAtFront()  { delete RemoveAtFront(); }
    bool IsEmpty() const { return head == nullptr; } 
    void Print() const;    
    ~LinkList(){ while (!IsEmpty()) DeleteAtFront(); }
};</pre>
<p>Let’s examine the preceding template class definitions for <strong class="source-inline">LinkListElement</strong> and <strong class="source-inline">LinkList</strong>. Initially, we notice that the forward declaration of the <strong class="source-inline">LinkList</strong> class contains the necessary template preamble of <strong class="source-inline">template class &lt;Type&gt;</strong>. We also should notice that each class definition itself contains the same template preamble to dually specify that the class will be a template class and that the placeholder for the data type will be the identifier <strong class="source-inline">Type</strong>. </p>
<p>In the <strong class="source-inline">LinkListElement</strong> class, notice that the data type will be <strong class="source-inline">Type</strong> (the placeholder type). Also notice that the placeholder for the type will be necessary in the friend class specification of <strong class="source-inline">LinkList</strong>, that is, <strong class="source-inline">friend class LinkList&lt;Type&gt;;</strong>.</p>
<p>In the <strong class="source-inline">LinkList</strong> class, notice that any reference to the associated class of <strong class="source-inline">LinkListElement</strong> will include the type placeholder of <strong class="source-inline">&lt;Type&gt;</strong>. Notice, for example, this placeholder usage in the data member declaration of <strong class="source-inline">LinkListElement&lt;Type&gt; *head;</strong> or the return type of <strong class="source-inline">RemoveAtFront()</strong>, which is <strong class="source-inline">LinkListElement&lt;Type&gt;</strong>. Additionally, notice that the inline function definitions <a id="_idIndexMarker878"/>do not require a template <a id="_idIndexMarker879"/>preamble before each method; we are still covered by the preamble occurring before the class definition itself.</p>
<p>Now, let’s move forward to take a look at the three non-inline member functio<a id="_idTextAnchor583"/>ns of the <strong class="source-inline">LinkList</strong> class:</p>
<pre class="source-code">
<strong class="bold">template &lt;class Type&gt;     </strong>// template preamble
void <strong class="bold">LinkList&lt;Type&gt;</strong>::InsertAtFront(<strong class="bold">Type</strong> *theItem)
{
    <strong class="bold">LinkListElement&lt;Type&gt;</strong> *newHead = nullptr;
    newHead = new <strong class="bold">LinkListElement&lt;Type&gt;</strong>(theItem);
    newHead-&gt;SetNext(head);  // newHead-&gt;next = head;
    head = newHead;
}
<strong class="bold">template &lt;class Type&gt;    </strong>// template preamble
<strong class="bold">LinkListElement&lt;Type&gt;</strong> *<strong class="bold">LinkList&lt;Type&gt;</strong>::RemoveAtFront()
{
    <strong class="bold">LinkListElement&lt;Type&gt;</strong> *remove = head;
    head = head-&gt;GetNext();  // head = head-&gt;next;
    current = head;    // reset current for usage elsewhere
    return remove;
}
 
<strong class="bold">template &lt;class Type&gt;</strong>    // template preamble
void <strong class="bold">LinkList&lt;Type&gt;</strong>::Print() const
{
    if (!head)
        cout &lt;&lt; "&lt;EMPTY&gt;" &lt;&lt; endl;
    LinkListElement&lt;Type&gt; *traverse = head;
    while (traverse)
    {
        <strong class="bold">Type</strong> output = *(traverse-&gt;GetData());
        cout &lt;&lt; output &lt;&lt; ' ';
        traverse = traverse-&gt;GetNext();
    }
    cout &lt;&lt; endl;
}</pre>
<p>As we <a id="_idIndexMarker880"/>examine the preceding code, we <a id="_idIndexMarker881"/>can see that in the non-inline methods of <strong class="source-inline">LinkList</strong>, the template preamble of <strong class="source-inline">template &lt;class Type&gt;</strong> appears before each member function definition. We also see that the class name tied with the scope resolution operator to the member function name is augmented with <strong class="source-inline">&lt;Type&gt;</strong>, for example, <strong class="source-inline">void LinkList&lt;Type&gt;::Print()</strong>.</p>
<p>We notice that the aforementioned template member functions require some part of their method to utilize the placeholder type, <strong class="source-inline">Type</strong>. For example, the <strong class="source-inline">InsertAtFront(Type *theItem)</strong> method uses both the placeholder <strong class="source-inline">Type</strong> as the data type of the formal parameter <strong class="source-inline">theItem</strong>, and to specify the associated class <strong class="source-inline">LinkListElement&lt;Type&gt;</strong> when declaring a local pointer variable <strong class="source-inline">temp</strong>. The <strong class="source-inline">RemoveAtFront()</strong> method similarly utilizes a local variable of type <strong class="source-inline">LinkListElement&lt;Type&gt;</strong>, hence necessitating its use as a template function. Similarly, <strong class="source-inline">Print()</strong> introduces a local variable of type <strong class="source-inline">Type</strong> to assist with output.</p>
<p>Let’s now <a id="_idIndexMarker882"/>take a look at our <strong class="source-inline">main()</strong> function to <a id="_idIndexMarker883"/>see how we can utilize our template classes:</p>
<pre class="source-code">
int main()
{
    <strong class="bold">LinkList&lt;int&gt; list1;</strong>  // create a LinkList of integers
    list1.InsertAtFront(new int (3000));
    list1.InsertAtFront(new int (600));
    list1.InsertAtFront(new int (475));
    cout &lt;&lt; "List 1: ";
    list1.Print();
    // delete elements from list, one by one
    while (!(list1.IsEmpty()))
    {
       list1.DeleteAtFront();
       cout &lt;&lt; "List 1 after removing an item: ";
       list1.Print();
    }
    <strong class="bold">LinkList&lt;float&gt; list2;</strong>  // create a LinkList of floats
    list2.InsertAtFront(new float(30.50));
    list2.InsertAtFront(new float (60.89));
    list2.InsertAtFront(new float (45.93));
    cout &lt;&lt; "List 2: ";
    list2.Print();
}</pre>
<p>In our <a id="_idIndexMarker884"/>preceding <strong class="source-inline">main()</strong> function, we utilize <a id="_idIndexMarker885"/>our template classes to create two types of linked lists, that is, a <strong class="source-inline">LinkList</strong> of integers with the declaration <strong class="source-inline">LinkList&lt;int&gt; list1;</strong> and a <strong class="source-inline">LinkList</strong> of floating-point numbers with the declaration <strong class="source-inline">LinkList&lt;float&gt; list2;</strong>.</p>
<p>In each case, we instantiate the various link lists, then add elements and print the respective lists. In the case of the first <strong class="source-inline">LinkList</strong> instance, we also demonstrate how elements can be succ<a id="_idTextAnchor584"/>essively removed from the list.</p>
<p>Let’s take a look at the output for this program:</p>
<p class="source-code">List 1: 475 600 3000</p>
<p class="source-code">List 1 after removing an item: 600 3000</p>
<p class="source-code">List 1 after removing an item: 3000</p>
<p class="source-code">List 1 after removing an item: &lt;EMPTY&gt;</p>
<p class="source-code">List 2: 45.93 60.89 30.5</p>
<p>Overall, we see that creating a <strong class="source-inline">LinkList&lt;int&gt;</strong> and a <strong class="source-inline">LinkList&lt;float&gt;</strong> is very easy. The template code is simply expanded behind the scenes to accommodate each data type we desire. We may then ask ourselves, how easy is it to create a linked list of <strong class="source-inline">Student</strong> instances? Very easy! We could simply instantiate <strong class="source-inline">LinkList&lt;Student&gt; list3;</strong> and call the appropriate <strong class="source-inline">LinkList</strong> methods, such as <strong class="source-inline">list3.InsertAtFront(new Student("George", "Katz", 'C', "Mr.", 3.2, "C++", "123GWU"));</strong>.</p>
<p>Perhaps we would like to include a means to order our elements in the template <strong class="source-inline">LinkList</strong> class, such as by adding an <strong class="source-inline">OrderedInsert()</strong> method (which typically relies on <strong class="source-inline">operator&lt;</strong> or <strong class="source-inline">operator&gt;</strong> for the comparison of elements). Would that work for all data types? That’s a good question. It could, provided the code written in the method is generic to work for all data types. Can operator overloading help with this endeavor? Yes!</p>
<p>Now that <a id="_idIndexMarker886"/>we have seen the mechanics of <a id="_idIndexMarker887"/>template classes and functions in action, let’s consider how we can ensure that our template classes and functions are fully extensible to work for any data type. To do this, let’s consider how operator overloading can be of value.</p>
<h1 id="_idParaDest-222"><a id="_idTextAnchor585"/>Making templates more flexible and extensible </h1>
<p>The addition of templates in C++ gives us the ability to make certain types of classes and functions <a id="_idIndexMarker888"/>generically specified a single time by the programmer, while behind the scenes, the preprocessor generates many versions of that code on our behalf. However, in order for a class to truly be extensible to expand for many different user defined types, code written within member functions must be universally applicable to any type of data. To help with this endeavor, operator overloading can be used to extend operations that may easily exist for standard types to include definitions for user defined types. </p>
<p>To recap, we know <a id="_idIndexMarker889"/>operator overloading can allow simple operators to work not only with standard types but also with user defined types. By overloading operators in our template code, we can ensure that our template code is highly reusable and extensible. </p>
<p>Let’s consider how we can strengthen templates wit<a id="_idTextAnchor586"/>h the use of operator overloading. </p>
<h2 id="_idParaDest-223">Adding operator overloading <a id="_idTextAnchor587"/><a id="_idTextAnchor588"/><a id="_idTextAnchor589"/>to further genericize template code</h2>
<p>Recall <a id="_idIndexMarker890"/>that when overloading an operator, it is important to promote the same meaning that the operator has for standard types. Imagine that we would like to add an <strong class="source-inline">OrderedInsert()</strong> method to our <strong class="source-inline">LinkList</strong> class. The body of this member function might rely on comparing two elements to see which one should go before the other. The easiest way to do this is using <strong class="source-inline">operator&lt;</strong>. This operator is easily defined to work with standard types, but will it work with user defined types? It can, provided we overload the operator to work with the desired types.</p>
<p>Let’s take a look at an example where we will need to overload an operator to make the member f<a id="_idTextAnchor590"/>unction code universally applicable:</p>
<pre class="source-code">
template &lt;class Type&gt;
void LinkList&lt;Type&gt;::OrderedInsert(Type *theItem)
{
    current = head;    
    if (*theItem <strong class="bold">&lt;</strong> *(head-&gt;GetData()))  
        InsertAtFront(theItem);  // add theItem before head
    else
        // Traverse list, add theItem in proper location
}</pre>
<p>In the <a id="_idIndexMarker891"/>preceding template member function, we rely on <strong class="source-inline">operator&lt;</strong> to be able to work with any data type in which we would like to utilize this template class. That is, when the preprocessor expands this code for a specific, user defined type, the <strong class="source-inline">&lt;</strong> operator must work for whatever data type this method has been specifically expanded for.</p>
<p>Should we wish to create a <strong class="source-inline">LinkList</strong> of <strong class="source-inline">Student</strong> instances and apply an <strong class="source-inline">OrderedInsert()</strong> of one <strong class="source-inline">Student</strong> versus another, we then need to ensure that the comparison with <strong class="source-inline">operator&lt;</strong> is defined for two <strong class="source-inline">Student</strong> instances. Of course, by default, <strong class="source-inline">operator&lt;</strong> is only defined for standard types. But, if we simply overload <strong class="source-inline">operator&lt;</strong> for <strong class="source-inline">Student</strong>, we can ensure that the <strong class="source-inline">LinkList&lt;Type&gt;::OrderedInsert()</strong> method will work for <strong class="source-inline">Student</strong> data types as well. </p>
<p>Let’s take a look at how we can overload <strong class="source-inline">operator&lt;</strong> for <strong class="source-inline">Student</strong> instances, both as a member function or as a non-member function:</p>
<pre class="source-code">
<strong class="bold">// overload operator &lt; As a member function of Student</strong>
bool Student::operator&lt;(const Student &amp;s)
{   // if this-&gt;gpa &lt; s.gpa return true, else return false
    return this-&gt;gpa &lt; s.gpa;
}
<strong class="bold">// OR, overload operator &lt; as a non-member function</strong>
bool operator&lt;(const Student &amp;s1, const Student &amp;s2)
{   // if s1.gpa &lt; s2.gpa return true, else return false
    return s1.gpa &lt; s2.gpa;
}</pre>
<p>In the preceding code, we can recognize <strong class="source-inline">operator&lt;</strong> implemented as either a member function of <strong class="source-inline">Student</strong> or as a non-member function. If you have access to the class definition for <strong class="source-inline">Student</strong>, the preferred approach would be to utilize the member function <a id="_idIndexMarker892"/>definition for this operator function. However, sometimes, we do not have access to modify a class. In such cases, we must utilize the non-member function approach. Nonetheless, in either implementation, we simply compare the <strong class="source-inline">gpa</strong> of the two <strong class="source-inline">Student</strong> instances, and return <strong class="source-inline">true</strong> if the first instance has a lower <strong class="source-inline">gpa</strong> than the second <strong class="source-inline">Student</strong> instance, and <strong class="source-inline">false</strong> otherwise.</p>
<p>Now that <strong class="source-inline">operator&lt;</strong> has been defined for two <strong class="source-inline">Student</strong> instances, we can return to our prior template function of <strong class="source-inline">LinkList&lt;Type&gt;::OrderedInsert(Type *)</strong>, which utilizes operator <strong class="source-inline">&lt;</strong> for comparison of two objects of type <strong class="source-inline">Type</strong> in the <strong class="source-inline">LinkList</strong>. When a <strong class="source-inline">LinkList&lt;Student&gt;</strong> is made somewhere in our code, the template code for <strong class="source-inline">LinkList</strong> and <strong class="source-inline">LinkListElement</strong> will be expanded by the preprocessor for <strong class="source-inline">Student</strong>; <strong class="source-inline">Type</strong> will be replaced with <strong class="source-inline">Student</strong>. When the expanded code is then compiled, the code in the expanded <strong class="source-inline">LinkList&lt;Student&gt;::OrderedInsert()</strong> will compile without error, as <strong class="source-inline">operator&lt;</strong> has been defined for two <strong class="source-inline">Student</strong> objects. </p>
<p>What happens if we neglect to overload <strong class="source-inline">operator&lt;</strong> for a given type, however, <strong class="source-inline">OrderedInsert()</strong> (or another method relying on <strong class="source-inline">operator&lt;</strong>) is never called in our code on an object of that same expanded template type? Believe it or not, the code will compile and work without issue. In this case, we are not actually calling a function (that is, <strong class="source-inline">OrderedInsert()</strong>) that would require <strong class="source-inline">operator&lt;</strong> to be implemented for that type. Because the function is never called, the template expansion for that member function is skipped. The compiler has no reason to discover that <strong class="source-inline">operator&lt;</strong> should have been overloaded for the type in question (in order for the method to compile successfully). The uncalled method has simply not been expanded for the compiler to verify.</p>
<p>By using <a id="_idIndexMarker893"/>operator overloading to complement template classes and functions, we can make template code even further extensible by ensuring that typical operators used within method bodies can be made applicable to any type we would want to utilize in the template expansion. Our code becomes more widely applicable.</p>
<p>We have now seen how to utilize template functions and classes, and how operator overloading can enhance templates to create even more extensible code. Let us now briefly recap these concepts before moving forward to our next chapter.</p>
<h1 id="_idParaDest-224"><a id="_idTextAnchor591"/>Summary</h1>
<p>In this chapter, we have furthered our C++ programming knowledge beyond OOP language features to include additional language features that will enable us to write more extensible code. We have learned how to utilize template functions and template classes, and how operator overloading nicely supports these endeavors.</p>
<p>We have seen that templates can allow us to generically specify a class or function with respect to the data type primarily used within that class or function. We have seen that template classes inevitably utilize template functions because those methods generally need to generically use the data upon which the class is built. We have seen that by taking advantage of operator overloading for user defined types, we can take advantage of method bodies written using simple operators to accommodate usage by more complex data types, making the template code much more useful and extensible. </p>
<p>The power of templates coupled with operator overloading (to make a method usable for nearly any type) makes C++’s implementation of generics much more powerful than simple type replacement. </p>
<p>We now understand that using templates can allow us to specify a class or function just one time more abstractly, and allow the preprocessor to generate many versions of that class or function for us, based upon specific data types that may be needed within the application. </p>
<p>By allowing the preprocessor to expand many versions of a template class or set of template functions for us based on types needed in an application, the work of creating many similar classes or functions (and maintaining those versions) is passed to C++, rather than the programmer. In addition to having less code for the user to maintain, changes made in the template classes or functions need only be made in one place – the preprocessor will re-expand the code without errors when needed.</p>
<p>We have added additional, useful features to our C++ reperto<a id="_idTextAnchor592"/>ire through examining templates, which, combined with operator overloading, will ensure we can write highly extensible and reusable code for nearly any data type. We are now ready to continue forward with <a href="B19087_14.xhtml#_idTextAnchor595"><em class="italic">Chapter 14</em></a>, <em class="italic">Understanding STL Basics</em>, so that we can continue extending our C++ programming skills with useful C++ library features that will make us better pr<a id="_idTextAnchor593"/>ogrammers. Let’s move forward!</p>
<h1 id="_idParaDest-225"><a id="_idTextAnchor594"/>Questions</h1>
<ol>
<li>Convert your <strong class="source-inline">ArrayInt</strong> class from <a href="B19087_12.xhtml#_idTextAnchor526"><em class="italic">Chapter 12</em></a>, <em class="italic">Friends and Operator Overloading</em>, to a template <strong class="source-inline">Array</strong> class to support a dynamically allocated array of any data type that can be easily resized and has built-in bounds checking. </li>
</ol>
<p>a. Consider what operators, if any, you will need to overload to allow generic code within each method to support any user defined types you may wish to store in the template <strong class="source-inline">Array</strong> type.</p>
<p>b. Using your template <strong class="source-inline">Array</strong> class, create an array of <strong class="source-inline">Student</strong> instances. Utilize various member functions to demonstrate that various template functions operate correctly.</p>
<ol>
<li value="2">Using the template <strong class="source-inline">LinkList</strong> class, complete the implementation for <strong class="source-inline">LinkList&lt;Type&gt;::OrderedInsert()</strong>. Create a <strong class="source-inline">LinkList</strong> of <strong class="source-inline">Student</strong> instances in <strong class="source-inline">main()</strong>. After several <strong class="source-inline">Student</strong> instances have been inserted in the list using <strong class="source-inline">OrderedInsert()</strong>, verify that this method works correctly by displaying each <strong class="source-inline">Student</strong> and their <strong class="source-inline">gpa</strong>. The <strong class="source-inline">Student</strong> instances should be ordered from lowest to highest <strong class="source-inline">gpa</strong>. You may wish to use the online code as a starting point. </li>
</ol>
</div>
</div></body></html>