<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-213"><a id="_idTextAnchor561"/>13</h1>
<h1 id="_idParaDest-214"><a id="_idTextAnchor562"/>Working with Templates</h1>
<p>This chapter will continue our pursuit of increasing your C++ programming repertoire beyond OOP concepts, with the continued goal of writing more extensible code. We will next explore creating generic code using C++ templates – both <strong class="bold">template functions</strong> and <strong class="bold">template classes</strong>. We will learn how template code, when written correctly, is the pinnacle in code reuse. In addition to exploring how to create both template functions and template classes, we will also understand how the appropriate use of operator overloading can make a template function reusable for nearly any type of data. </p>
<p>In this chapter, we will cover the following main topics:</p>
<ul>
<li>Exploring template basics to genericize code</li>
<li>Understanding how to create and use template functions and template classes</li>
<li>Understanding how operator overloading can make templates more extensible</li>
</ul>
<p>Many object-oriented languages include the concept of programming with generics, allowing the types of classes and interfaces to be parameterized themselves. In some languages, generics are merely wrappers for casting objects to the desired type. In C++, the idea of generics is more comprehensive and is implemented using templates. </p>
<p>By the end of this chapter, you will be able to design more generic code by building both template functions and template classes. You will understand how operator overloading can ensure that a template function can become highly extensible for any data type. By pairing together well-designed template member functions with operator overloading, you will be able to create highly reusable and extensible template classes in C++.</p>
<p>Let’s increase our understanding of C++ by expanding your programming repertoire by exploring templates. </p>
<h1 id="_idParaDest-215"><a id="_idTextAnchor563"/>Technical requirements</h1>
<p>Online code for full program examples can be found in the following GitHub URL: <a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter13">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter13</a>. Each full program example can be found in the GitHub repository under the appropriate chapter heading (subdirectory) in a file that corresponds to the chapter number, followed by a dash, followed by the example number in the chapter at hand. For example, the first full program in this chapter can be found in the subdirectory <code>Chapter13</code> in a file named <code>Chp13-Ex1.cpp</code> under the aforementioned GitHub directory.</p>
<p>The CiA video for this chapter can be viewed at: <a href="https://bit.ly/3A7lx0U">https://bit.ly/3A7lx0U</a>.</p>
<h1 id="_idParaDest-216"><a id="_idTextAnchor564"/><a id="_idTextAnchor565"/><a id="_idTextAnchor566"/>Exploring template basics to genericize code</h1>
<p>Templates allow code to be generically specified in a manner that is abstracted from the data types <a id="_idIndexMarker854"/>primarily used within relevant functions or classes. The motivation for creating templates is to generically specify the definition of functions and classes that we repeatedly want to utilize, but with varying data types. The individualized versions of these components would otherwise differ only in the core data type utilized; these key data types can then be extracted and written generically. </p>
<p>When we then opt to utilize such a class or function with a specific type, rather than copying and pasting existing code from a similar class or function (with preset data types) and changing it slightly, the preprocessor instead would take the template code and <em class="italic">expand</em> it for our requested, bonafide type. This template <em class="italic">expansion</em> capability allows the programmer to write and maintain only one version of the genericized code, versus the many type-specific versions of code that would otherwise need to be written. The benefit is also that the preprocessor will do a more accurate expansion of the template code to a bonafide type than we might have done using a copy, paste, and slight modification method.</p>
<p>Let’s take a moment to further investigate the motivation for using templates in our code.</p>
<h2 id="_idParaDest-217"><a id="_idTextAnchor567"/>Examining the motivation for templates</h2>
<p>Imagine that <a id="_idIndexMarker855"/>we wish to create a class to safely handle dynamically allocated arrays for data type <code>int</code>, such as we have created in a solution for <em class="italic">Question 3</em> of <a href="B19087_12.xhtml#_idTextAnchor526"><em class="italic">Chapter 12</em></a>, <em class="italic">Friends and Operator Overloading</em>. Our motivation may be to have an array type that can grow or shrink to any size (unlike native, fixed-sized arrays), yet have bounds checking for safe usage (unlike the raw manipulation of a dynamic array implemented using <code>int *</code>, which would unscrupulously allow us to access elements well beyond the length of our dynamic array allocation). </p>
<p>We may <a id="_idIndexMarker856"/>decide to create an <code>ArrayInt</code> class with the following beginning framework:</p>
<pre class="source-code">
class ArrayInt
{
private: 
    int numElements = 0;     // in-class initialization
    int *contents = nullptr; // dynamically allocated array
public:
    ArrayInt(int size): numElements(size) 
    { 
        contents = new int [size];
    }
    ~ArrayInt() { delete [] contents; }       
    int &amp;operator[](int index) // returns a referenceable
    {                // memory location or throws exception
        if (index &lt; numElements) 
            return contents[index];
        else         // index selected is out of bounds
            throw std::out_of_range(std::to_string(index));
    }                                
};
int main()
{
    ArrayInt a1(5); // Create an ArrayInt of 5 elements
    try    // operator[] could throw an exception
    {
        a1[4] = 7;      // a1.operator[](4) = 7;
    }
    catch (const std::out_of_range &amp;e)
    {
        cout &lt;&lt; "Out of range: element " &lt;&lt; e.what();
        cout &lt;&lt; endl;
    }
}   </pre>
<p>In the previous code segment, notice that our <code>ArrayInt</code> class implements the data structure comprising the array using <code>int *contents</code>, which is dynamically allocated to the desired <a id="_idIndexMarker857"/>size in the constructor. We have overloaded <code>operator[]</code> to safely return only indexed values in the array that are within the proper range, and throw a <code>std::out_of_range</code> exception otherwise. We can add methods to <code>Resize()</code> an <code>ArrayInt</code> and so on. Overall, we love the safety and flexibility of this class. </p>
<p>Now, we may want to have an <code>ArrayFloat</code> class (or later, an <code>ArrayStudent</code> class). Rather than copying our baseline <code>ArrayInt</code> class and modifying it slightly to create an <code>ArrayFloat</code> class, for example, we may ask whether there is a more automated way to make this substitution. After all, what would we change in creating an <code>ArrayFloat</code> class using an <code>ArrayInt</code> class as a starting point? We would change the <em class="italic">type</em> of the data member <code>contents</code> – from an <code>int *</code> to a <code>float *</code>. We would change the <em class="italic">type</em> in the memory allocation in the constructor from <code>contents = new int [size];</code> to utilize <code>float</code> instead of <code>int</code> (and similarly so in any reallocation, such as in a <code>Resize()</code> method). </p>
<p>Rather than copying, pasting, and slightly modifying an <code>ArrayInt</code> class to create an <code>ArrayFloat</code> class, we can <a id="_idIndexMarker858"/>simply use a <strong class="bold">template class</strong> to genericize the <em class="italic">type</em> associated with the data manipulated within this class. Similarly, any functions relying on the <a id="_idIndexMarker859"/>specific data type will become <strong class="bold">template functions</strong>. We will examine the syntax for creating and utilizing templates shortly.</p>
<p>Using templates, we can instead create just one template class called <code>Array</code> where the type is genericized. At compile time, should the preprocessor detect we have utilized this class for type <code>int</code> or <code>float</code> in our code, the preprocessor will then provide the necessary template <em class="italic">expansions</em> for us. That is, by copying and pasting (behind the scenes) each template class (and its methods) and substituting in the data types that the preprocessor identifies we are using. </p>
<p>The resulting code, once expanded under the hood, is no smaller than if we had written the code for <a id="_idIndexMarker860"/>each individual class ourselves. But the point is that we did not have to tediously create, modify, test, and later maintain each minorly different class ourselves. This is done on our behalf by C++. This is the noteworthy purpose of template classes and template functions. </p>
<p>Templates are not restricted for use with primitive data types. For example, we may wish to create an <code>Array</code> of a user defined type, such as <code>Student</code>. We will need to ensure that all of our template member functions are meaningful for the data types that we actually expand the template class to utilize. We may need to overload selected operators so that our template member functions can work seamlessly with user defined types, just as they do with primitive types.</p>
<p>We will later see in this chapter an example illustrating how we may need to overload selected operators if we choose to expand a template class for user defined types so that the member functions of a class can work fluidly with any data type. Fortunately, we know how to overload operators!</p>
<p>Let’s move forward to explore the mechanics of specifying and utilizing template functions and template classes.</p>
<h1 id="_idParaDest-218"><a id="_idTextAnchor568"/>Understanding template functions and classes</h1>
<p><strong class="bold">Templates</strong> provide the <a id="_idIndexMarker861"/>ability to create generic functions and classes by abstracting the data types associated with those functions and classes. Template functions and classes can both be carefully written in such a way as to genericize the relevant data types that underlie these functions and classes. </p>
<p>Let’s begin by examining how to create and utilize template fun<a id="_idTextAnchor569"/><a id="_idTextAnchor570"/>ctions.</p>
<h2 id="_idParaDest-219"><a id="_idTextAnchor571"/>Creating and using template functions</h2>
<p><strong class="bold">Template functions</strong> parameterize <a id="_idIndexMarker862"/>the types of arguments in a function in addition to the arguments themselves. Template functions require the body of the function to be applicable to almost any data type. Template functions can be member or non-member functions. Operator overloading can help ensure that the bodies of template functions are applicable to user defined types – we’ll see more of that s<a id="_idTextAnchor572"/>hortly. </p>
<p>The keyword <code>template</code>, along with angle brackets, <code>&lt;</code> <code>&gt;</code>, and placeholders for the <em class="italic">type</em> names are used to specify a template function and its prototype.</p>
<p>Let’s take a <a id="_idIndexMarker863"/>look at a template function that is not a member of a class (we will see examples of template member functions <a id="_idTextAnchor573"/>shortly). This example can be found, as a full working program, in our GitHub repository as follows:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter13/Chp13-Ex1.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter13/Chp13-Ex1.cpp</a></p>
<pre class="source-code">
// template function prototype
<strong class="bold">template &lt;class Type1, class Type2&gt;</strong>   // template preamble
<strong class="bold">Type2</strong> ChooseFirst(<strong class="bold">Type1</strong>, <strong class="bold">Type2</strong>);
// template function definition
<strong class="bold">template &lt;class Type1, class Type2&gt;</strong>  // template preamble
<strong class="bold">Type2</strong> ChooseFirst(<strong class="bold">Type1</strong> x, <strong class="bold">Type2</strong> y)
{
    if (x &lt; y) 
        return static_cast&lt;<strong class="bold">Type2</strong>&gt;(x);
    else 
        return y; 
}   
int main()
{
    int value1 = 4, value2 = 7;
    float value3 = 5.67f;
    cout &lt;&lt; "First: " &lt;&lt; <strong class="bold">ChooseFirst(value1, value3)</strong>; 
    cout &lt;&lt; endl;
    cout &lt;&lt; "First: " &lt;&lt; <strong class="bold">ChooseFirst(value2, value1)</strong>; 
    cout &lt;&lt; endl;
}</pre>
<p>Looking at <a id="_idIndexMarker864"/>the previous function example, we first see a template function prototype. The p<a id="_idTextAnchor574"/>reamble of <code>template &lt;class Type1, class Type 2&gt;</code> indicates that the prototype will be a template prototype and that placeholders <code>Type1</code> and <code>Type2</code> will be used instead of actual data types. The placeholders <code>Type1</code> and <code>Type2</code> may be (nearly) any name, following the rules of creating identifiers. </p>
<p>Then, to <a id="_idIndexMarker865"/>complete the prototype, we see <code>Type2 ChooseFirst(Type1, Type2);</code>, which indicates that the return type from this function will be of <code>Type2</code> and that the arguments of the <code>ChooseFirst()</code> function will be of <code>Type1</code> and <code>Type2</code> (which may certainly be expanded to be the same type).</p>
<p>Next, we see the function definition. It, too, begins with a preamble of <code>template &lt;class Type1, class Type 2&gt;</code>. Similar to the prototype, the function header <code>Type2 ChooseFirst(Type1 x, Type2 y)</code> indicates that formal parameters <code>x</code> and <code>y</code> are of types <code>Type1</code> and <code>Type2</code>, respectively. The body of this function is rather straightforward. We simply determine which of the two parameters should be ranked first in an ordering of the two values by using a simple comparison with the <code>&lt;</code> operator.</p>
<p>Now, in <code>main()</code>, when the preprocessor portion of the compiler sees a call to <code>ChooseFirst()</code> with actual parameters, <code>int value1</code> and <code>float value3</code>, the preprocessor notices that <code>ChooseFirst()</code> is a template function. If no such version of <code>ChooseFirst()</code> yet exists to handle an <code>int</code> and a <code>float</code>, the preprocessor copies this template function and replaces <code>Type1</code> with <code>int</code> and <code>Type2</code> with <code>float</code> – creating on our behalf the appropriate version of this function to fit our needs. Notice that when <code>ChooseFirst(value2, value1)</code> is called and the types are both integers, the placeholder types of <code>Type1</code> and <code>Type2</code> will both be replaced with <code>int</code> when the template function is again expanded (under the hood) in our code by the preprocessor.</p>
<p>Though <code>ChooseFirst()</code> is a simple function, with it we can see the straightforward mechanics of creating a template function that genericizes key data types. We can also see how <a id="_idIndexMarker866"/>the preprocessor notices how the template function is <a id="_idIndexMarker867"/>used and takes on the effort on our behalf to expand this function, as needed, for our specific type usage.</p>
<p>Let’s take a look at the output for this program:</p>
<pre>First: 4
First: 4</pre>
<p>Now that we have seen the basic mechanics of template functions, let us move forward to understand how we can expand this process to include template classes.</p>
<h2 id="_idParaDest-220"><a id="_idTextAnchor575"/>Creating and using template classes</h2>
<p><strong class="bold">Template classes</strong> parameterize the ultimate type of a class definition, and will additionally <a id="_idIndexMarker868"/>require template member functions for any methods <a id="_idIndexMarker869"/>that need to know the core data type being manipulated.</p>
<p>The keywords <code>template</code> and <code>class</code>, along with angle brackets, <code>&lt;</code> <code>&gt;</code>, and place<a id="_idTextAnchor576"/>holders for the <em class="italic">type</em> names are used to specify a template class definition.</p>
<p>Let’s take a look at a template class definition and its supporting template member functions. This example can be found as a complete program (with the necessary <code>#include</code> and <code>using</code> statements) in our GitHub repository as follows:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter13/Chp13-Ex2.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter13/Chp13-Ex2.cpp</a></p>
<pre class="source-code">
<strong class="bold">template &lt;class Type&gt;   </strong>// template class preamble
<a id="_idTextAnchor577"/>class Array
{
private:
    int numElements = 0;   // in-class initialization
    <strong class="bold">Type</strong> *contents = nullptr;// dynamically allocated array
public:
    // Constructor and destructor will allocate, deallocate
    // heap memory to allow Array to be fluid in its size.
    // Later, you can use a smart pointer – or use the STL
    // vector class (we're building a similar class here!)
    Array(int size): numElements(size), 
                     contents(new <strong class="bold">Type</strong> [size])
    { // note: allocation is handled in member init. list
    }
    ~Array() { delete [] contents; }  
    void Print() const;     
    <strong class="bold">Type</strong> &amp;operator[](int index) // returns a referenceable
    {               // memory location or throws exception
        if (index &lt; numElements) 
            return contents[index];
        else   // index is out of bounds
            throw std::out_of_range
                             (std::to_string (index));    
    }                                
    void operator+(<strong class="bold">Type</strong>);   // pro<a id="_idTextAnchor578"/>totype only
};
<strong class="bold">template &lt;class Type&gt;</strong>
void <strong class="bold">Array&lt;Type&gt;</strong>::operator+(<strong class="bold">Type</strong> item)  
{
    // resize array as necessary, add new data element and
    // increment numElements
}
<strong class="bold">template &lt;class Type&gt;</strong>
void <strong class="bold">Array&lt;Type&gt;</strong>::Print() const
{
    for (int i = 0; i &lt; numElements; i++)
        cout &lt;&lt; contents[i] &lt;&lt; " ";
    cout &lt;&lt; endl;
}
int main()
{                    
    // Creation of int Array will trigger template
    // expansion by the preprocessor.
    <strong class="bold">Array&lt;int&gt;</strong> a1(3); // Create an int Array of 3 elements
    try    // operator[] could throw an exception
    {
        a1[2] = 12;      
        a1[1] = 70;       // a1.operator[](1) = 70;
        a1[0] = 2;
        a1[100] = 10;// this assignment throws an exception
    }
    catch (const std::out_of_range &amp;e)
    {
        cout &lt;&lt; "Out of range: index " &lt;&lt; e.what() &lt;&lt; endl;
    } 
    a1.Print();
}   </pre>
<p>In the preceding class definition, let’s first notice the template class preamble of <code>template &lt;class Type&gt;</code>. This preamble specifies that the impending class definition will be that of a template class and that the placeholder <code>Type</code> will be used to genericize the data types primarily used within this class. </p>
<p>We then <a id="_idIndexMarker870"/>see the class definition for <code>Array</code>. Data member <code>contents</code> will be of the placeholder type of <code>Type</code>. Of course, not all data types will need to <a id="_idIndexMarker871"/>be genericized. Data member <code>int numElements</code> is perfectly reasonable as an integer. Next, we see an assortment of member functions prototyped and some defined inline, including overloaded <code>operator[]</code>. For the member functions defined inline, a template preamble is not necessary in front of the function definition. The only thing we need to do for inline functions is to genericize the data type using our placeholder, <code>Type</code>.</p>
<p>Let’s now take a look at selected member functions. In the constructor, we now notice that the memory allocation of <code>contents = new Type [size];</code> merely uses the placeholder <code>Type</code> in lieu of an actual data type. Similarly, for overloaded <code>operator[]</code>, the return type of this method is <code>Type</code>.</p>
<p>However, looking at a member function that is not inline, we notice that the template preamble of <code>template &lt;class Type&gt;</code> must precede the member function definition. For example, let’s consider the member function definition for <code>void Array&lt;Type&gt;::operator+(Type item);</code>. In addition to the preamble, the class name (preceding the member function name and scope resolution operator, <code>::</code>) in the function definition must be augmented to include the placeholder type <code>&lt;Type&gt;</code> in angle brackets. Also, any generic function parameters must use the pl<a id="_idTextAnchor579"/>aceholder type of <code>Type</code>. </p>
<p>Now, in our <code>main()</code> function, we merely use the data type of <code>Array&lt;int&gt;</code> to instantiate a safe, easily resizable array of integers. We could have alternatively used <code>Array&lt;float&gt;</code> had we instead wanted to instantiate an array of floating-point numbers. Under the hood, when we create an instance of a specific array type, the preprocessor notices whether we have previously expanded this class for that <em class="italic">type</em>. If not, the class definition and applicable template member functions are copied for us and the <a id="_idIndexMarker872"/>placeholder types are replaced with the type that we need. This is no fewer lines of code than if we had copied, pasted, and slightly modified the <a id="_idIndexMarker873"/>code ourselves; however, the point is that we only have one version to specify and maintain ourselves. This is less error-prone and easier for lon<a id="_idTextAnchor580"/>g-term maintenance. </p>
<p>Let’s take a look at the output for this program:</p>
<pre>2 70 12</pre>
<p class="callout-heading">An interesting tangent – std::optional</p>
<p class="callout">In the previous example, <code>Array&lt;Type&gt;::operator[]</code> throws an <code>out_of_range</code> exception when the selected index is out of bounds. Sometimes, exception handling can be programmatically expensive. In such cases, using an optional return type may be a useful alternative. Remember, a valid return value for <code>operator[]</code> is a reference to the memory location for the array element in question. For the out-of-bounds index scenario, knowing we simply cannot return the corresponding memory location for an array element from this method (it would not make sense), an alternative to exception handling may be to use <code>std::optional&lt;Type&gt;</code> in the return value of the function.</p>
<p>Let’s next take a look at a different full program example to pull together template functions and template classes.</p>
<h2 id="_idParaDest-221"><a id="_idTextAnchor581"/>Examining a full program example</h2>
<p>It is <a id="_idIndexMarker874"/>useful to see an additional example that <a id="_idIndexMarker875"/>illustrates template functions and template classes. Let us expand on a <code>LinkList</code> program we reviewed most recently in <a href="B19087_12.xhtml#_idTextAnchor526"><em class="italic">Chapter 12</em></a>, <em class="italic">Friends and Operator Overloading</em>; we will upgrade this program to utilize templates. </p>
<p>This <a id="_idIndexMarker876"/>complete program can be found <a id="_idIndexMarker877"/>in our GitHu<a id="_idTextAnchor582"/>b repository as follows:</p>
<p class="SC---Link" lang="en-US" xml:lang="en-US"><a href="https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter13/Chp13-Ex3.cpp">https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter13/Chp13-Ex3.cpp</a></p>
<pre class="source-code">
#include &lt;iostream&gt;
using std::cout;   // preferred to: using namespace std;
using std::endl;
// forward declaration with template preamble
<strong class="bold">template &lt;class Type&gt; class LinkList;</strong>  
<strong class="bold">template &lt;class Type&gt;</strong>   // template preamble for class def.
class LinkListElement
{
private:
    <strong class="bold">Type</strong> *data = nullptr;
    LinkListElement *next = nullptr;
    // private access methods to be used in scope of friend<strong class="bold"> </strong>
    <strong class="bold">Type</strong> *GetData() const { return data; } 
    LinkListElement *GetNext() const { return next; }
    void SetNext(LinkListElement *e) { next = e; }
public:
    friend class<strong class="bold"> LinkList&lt;Type&gt;;</strong>   
    LinkListElement() = default;
    LinkListElement(<strong class="bold">Type</strong> *i): data(i), next(nullptr) { }
    ~LinkListElement(){ delete data; next = nullptr; }
};
// LinkList should only be extended as a protected/private
// base class; it does not contain a virtual destructor. It
// can be used as-is, or as implementation for another ADT.
<strong class="bold">template &lt;class Type&gt;</strong>
class LinkList
{
private:
    <strong class="bold">LinkListElement&lt;Type&gt;</strong> *head = nullptr, *tail = nullptr,
                                 *current = nullptr;
public:
    LinkList() = default;
    LinkList(<strong class="bold">LinkListElement&lt;Type&gt;</strong> *e) 
        { head = tail = current = e; }
    void InsertAtFront(<strong class="bold">Type</strong> *);
    <strong class="bold">LinkListElement&lt;Type&gt;</strong> *RemoveAtFront();  
    void DeleteAtFront()  { delete RemoveAtFront(); }
    bool IsEmpty() const { return head == nullptr; } 
    void Print() const;    
    ~LinkList(){ while (!IsEmpty()) DeleteAtFront(); }
};</pre>
<p>Let’s examine the preceding template class definitions for <code>LinkListElement</code> and <code>LinkList</code>. Initially, we notice that the forward declaration of the <code>LinkList</code> class contains the necessary template preamble of <code>template class &lt;Type&gt;</code>. We also should notice that each class definition itself contains the same template preamble to dually specify that the class will be a template class and that the placeholder for the data type will be the identifier <code>Type</code>. </p>
<p>In the <code>LinkListElement</code> class, notice that the data type will be <code>Type</code> (the placeholder type). Also notice that the placeholder for the type will be necessary in the friend class specification of <code>LinkList</code>, that is, <code>friend class LinkList&lt;Type&gt;;</code>.</p>
<p>In the <code>LinkList</code> class, notice that any reference to the associated class of <code>LinkListElement</code> will include the type placeholder of <code>&lt;Type&gt;</code>. Notice, for example, this placeholder usage in the data member declaration of <code>LinkListElement&lt;Type&gt; *head;</code> or the return type of <code>RemoveAtFront()</code>, which is <code>LinkListElement&lt;Type&gt;</code>. Additionally, notice that the inline function definitions <a id="_idIndexMarker878"/>do not require a template <a id="_idIndexMarker879"/>preamble before each method; we are still covered by the preamble occurring before the class definition itself.</p>
<p>Now, let’s move forward to take a look at the three non-inline member functio<a id="_idTextAnchor583"/>ns of the <code>LinkList</code> class:</p>
<pre class="source-code">
<strong class="bold">template &lt;class Type&gt;     </strong>// template preamble
void <strong class="bold">LinkList&lt;Type&gt;</strong>::InsertAtFront(<strong class="bold">Type</strong> *theItem)
{
    <strong class="bold">LinkListElement&lt;Type&gt;</strong> *newHead = nullptr;
    newHead = new <strong class="bold">LinkListElement&lt;Type&gt;</strong>(theItem);
    newHead-&gt;SetNext(head);  // newHead-&gt;next = head;
    head = newHead;
}
<strong class="bold">template &lt;class Type&gt;    </strong>// template preamble
<strong class="bold">LinkListElement&lt;Type&gt;</strong> *<strong class="bold">LinkList&lt;Type&gt;</strong>::RemoveAtFront()
{
    <strong class="bold">LinkListElement&lt;Type&gt;</strong> *remove = head;
    head = head-&gt;GetNext();  // head = head-&gt;next;
    current = head;    // reset current for usage elsewhere
    return remove;
}
 
<strong class="bold">template &lt;class Type&gt;</strong>    // template preamble
void <strong class="bold">LinkList&lt;Type&gt;</strong>::Print() const
{
    if (!head)
        cout &lt;&lt; "&lt;EMPTY&gt;" &lt;&lt; endl;
    LinkListElement&lt;Type&gt; *traverse = head;
    while (traverse)
    {
        <strong class="bold">Type</strong> output = *(traverse-&gt;GetData());
        cout &lt;&lt; output &lt;&lt; ' ';
        traverse = traverse-&gt;GetNext();
    }
    cout &lt;&lt; endl;
}</pre>
<p>As we <a id="_idIndexMarker880"/>examine the preceding code, we <a id="_idIndexMarker881"/>can see that in the non-inline methods of <code>LinkList</code>, the template preamble of <code>template &lt;class Type&gt;</code> appears before each member function definition. We also see that the class name tied with the scope resolution operator to the member function name is augmented with <code>&lt;Type&gt;</code>, for example, <code>void LinkList&lt;Type&gt;::Print()</code>.</p>
<p>We notice that the aforementioned template member functions require some part of their method to utilize the placeholder type, <code>Type</code>. For example, the <code>InsertAtFront(Type *theItem)</code> method uses both the placeholder <code>Type</code> as the data type of the formal parameter <code>theItem</code>, and to specify the associated class <code>LinkListElement&lt;Type&gt;</code> when declaring a local pointer variable <code>temp</code>. The <code>RemoveAtFront()</code> method similarly utilizes a local variable of type <code>LinkListElement&lt;Type&gt;</code>, hence necessitating its use as a template function. Similarly, <code>Print()</code> introduces a local variable of type <code>Type</code> to assist with output.</p>
<p>Let’s now <a id="_idIndexMarker882"/>take a look at our <code>main()</code> function to <a id="_idIndexMarker883"/>see how we can utilize our template classes:</p>
<pre class="source-code">
int main()
{
    <strong class="bold">LinkList&lt;int&gt; list1;</strong>  // create a LinkList of integers
    list1.InsertAtFront(new int (3000));
    list1.InsertAtFront(new int (600));
    list1.InsertAtFront(new int (475));
    cout &lt;&lt; "List 1: ";
    list1.Print();
    // delete elements from list, one by one
    while (!(list1.IsEmpty()))
    {
       list1.DeleteAtFront();
       cout &lt;&lt; "List 1 after removing an item: ";
       list1.Print();
    }
    <strong class="bold">LinkList&lt;float&gt; list2;</strong>  // create a LinkList of floats
    list2.InsertAtFront(new float(30.50));
    list2.InsertAtFront(new float (60.89));
    list2.InsertAtFront(new float (45.93));
    cout &lt;&lt; "List 2: ";
    list2.Print();
}</pre>
<p>In our <a id="_idIndexMarker884"/>preceding <code>main()</code> function, we utilize <a id="_idIndexMarker885"/>our template classes to create two types of linked lists, that is, a <code>LinkList</code> of integers with the declaration <code>LinkList&lt;int&gt; list1;</code> and a <code>LinkList</code> of floating-point numbers with the declaration <code>LinkList&lt;float&gt; list2;</code>.</p>
<p>In each case, we instantiate the various link lists, then add elements and print the respective lists. In the case of the first <code>LinkList</code> instance, we also demonstrate how elements can be succ<a id="_idTextAnchor584"/>essively removed from the list.</p>
<p>Let’s take a look at the output for this program:</p>
<pre>List 1: 475 600 3000
List 1 after removing an item: 600 3000
List 1 after removing an item: 3000
List 1 after removing an item: &lt;EMPTY&gt;
List 2: 45.93 60.89 30.5</pre>
<p>Overall, we see that creating a <code>LinkList&lt;int&gt;</code> and a <code>LinkList&lt;float&gt;</code> is very easy. The template code is simply expanded behind the scenes to accommodate each data type we desire. We may then ask ourselves, how easy is it to create a linked list of <code>Student</code> instances? Very easy! We could simply instantiate <code>LinkList&lt;Student&gt; list3;</code> and call the appropriate <code>LinkList</code> methods, such as <code>list3.InsertAtFront(new Student("George", "Katz", 'C', "Mr.", 3.2, "C++", "123GWU"));</code>.</p>
<p>Perhaps we would like to include a means to order our elements in the template <code>LinkList</code> class, such as by adding an <code>OrderedInsert()</code> method (which typically relies on <code>operator&lt;</code> or <code>operator&gt;</code> for the comparison of elements). Would that work for all data types? That’s a good question. It could, provided the code written in the method is generic to work for all data types. Can operator overloading help with this endeavor? Yes!</p>
<p>Now that <a id="_idIndexMarker886"/>we have seen the mechanics of <a id="_idIndexMarker887"/>template classes and functions in action, let’s consider how we can ensure that our template classes and functions are fully extensible to work for any data type. To do this, let’s consider how operator overloading can be of value.</p>
<h1 id="_idParaDest-222"><a id="_idTextAnchor585"/>Making templates more flexible and extensible </h1>
<p>The addition of templates in C++ gives us the ability to make certain types of classes and functions <a id="_idIndexMarker888"/>generically specified a single time by the programmer, while behind the scenes, the preprocessor generates many versions of that code on our behalf. However, in order for a class to truly be extensible to expand for many different user defined types, code written within member functions must be universally applicable to any type of data. To help with this endeavor, operator overloading can be used to extend operations that may easily exist for standard types to include definitions for user defined types. </p>
<p>To recap, we know <a id="_idIndexMarker889"/>operator overloading can allow simple operators to work not only with standard types but also with user defined types. By overloading operators in our template code, we can ensure that our template code is highly reusable and extensible. </p>
<p>Let’s consider how we can strengthen templates wit<a id="_idTextAnchor586"/>h the use of operator overloading. </p>
<h2 id="_idParaDest-223">Adding operator overloading <a id="_idTextAnchor587"/><a id="_idTextAnchor588"/><a id="_idTextAnchor589"/>to further genericize template code</h2>
<p>Recall <a id="_idIndexMarker890"/>that when overloading an operator, it is important to promote the same meaning that the operator has for standard types. Imagine that we would like to add an <code>OrderedInsert()</code> method to our <code>LinkList</code> class. The body of this member function might rely on comparing two elements to see which one should go before the other. The easiest way to do this is using <code>operator&lt;</code>. This operator is easily defined to work with standard types, but will it work with user defined types? It can, provided we overload the operator to work with the desired types.</p>
<p>Let’s take a look at an example where we will need to overload an operator to make the member f<a id="_idTextAnchor590"/>unction code universally applicable:</p>
<pre class="source-code">
template &lt;class Type&gt;
void LinkList&lt;Type&gt;::OrderedInsert(Type *theItem)
{
    current = head;    
    if (*theItem <strong class="bold">&lt;</strong> *(head-&gt;GetData()))  
        InsertAtFront(theItem);  // add theItem before head
    else
        // Traverse list, add theItem in proper location
}</pre>
<p>In the <a id="_idIndexMarker891"/>preceding template member function, we rely on <code>operator&lt;</code> to be able to work with any data type in which we would like to utilize this template class. That is, when the preprocessor expands this code for a specific, user defined type, the <code>&lt;</code> operator must work for whatever data type this method has been specifically expanded for.</p>
<p>Should we wish to create a <code>LinkList</code> of <code>Student</code> instances and apply an <code>OrderedInsert()</code> of one <code>Student</code> versus another, we then need to ensure that the comparison with <code>operator&lt;</code> is defined for two <code>Student</code> instances. Of course, by default, <code>operator&lt;</code> is only defined for standard types. But, if we simply overload <code>operator&lt;</code> for <code>Student</code>, we can ensure that the <code>LinkList&lt;Type&gt;::OrderedInsert()</code> method will work for <code>Student</code> data types as well. </p>
<p>Let’s take a look at how we can overload <code>operator&lt;</code> for <code>Student</code> instances, both as a member function or as a non-member function:</p>
<pre class="source-code">
<strong class="bold">// overload operator &lt; As a member function of Student</strong>
bool Student::operator&lt;(const Student &amp;s)
{   // if this-&gt;gpa &lt; s.gpa return true, else return false
    return this-&gt;gpa &lt; s.gpa;
}
<strong class="bold">// OR, overload operator &lt; as a non-member function</strong>
bool operator&lt;(const Student &amp;s1, const Student &amp;s2)
{   // if s1.gpa &lt; s2.gpa return true, else return false
    return s1.gpa &lt; s2.gpa;
}</pre>
<p>In the preceding code, we can recognize <code>operator&lt;</code> implemented as either a member function of <code>Student</code> or as a non-member function. If you have access to the class definition for <code>Student</code>, the preferred approach would be to utilize the member function <a id="_idIndexMarker892"/>definition for this operator function. However, sometimes, we do not have access to modify a class. In such cases, we must utilize the non-member function approach. Nonetheless, in either implementation, we simply compare the <code>gpa</code> of the two <code>Student</code> instances, and return <code>true</code> if the first instance has a lower <code>gpa</code> than the second <code>Student</code> instance, and <code>false</code> otherwise.</p>
<p>Now that <code>operator&lt;</code> has been defined for two <code>Student</code> instances, we can return to our prior template function of <code>LinkList&lt;Type&gt;::OrderedInsert(Type *)</code>, which utilizes operator <code>&lt;</code> for comparison of two objects of type <code>Type</code> in the <code>LinkList</code>. When a <code>LinkList&lt;Student&gt;</code> is made somewhere in our code, the template code for <code>LinkList</code> and <code>LinkListElement</code> will be expanded by the preprocessor for <code>Student</code>; <code>Type</code> will be replaced with <code>Student</code>. When the expanded code is then compiled, the code in the expanded <code>LinkList&lt;Student&gt;::OrderedInsert()</code> will compile without error, as <code>operator&lt;</code> has been defined for two <code>Student</code> objects. </p>
<p>What happens if we neglect to overload <code>operator&lt;</code> for a given type, however, <code>OrderedInsert()</code> (or another method relying on <code>operator&lt;</code>) is never called in our code on an object of that same expanded template type? Believe it or not, the code will compile and work without issue. In this case, we are not actually calling a function (that is, <code>OrderedInsert()</code>) that would require <code>operator&lt;</code> to be implemented for that type. Because the function is never called, the template expansion for that member function is skipped. The compiler has no reason to discover that <code>operator&lt;</code> should have been overloaded for the type in question (in order for the method to compile successfully). The uncalled method has simply not been expanded for the compiler to verify.</p>
<p>By using <a id="_idIndexMarker893"/>operator overloading to complement template classes and functions, we can make template code even further extensible by ensuring that typical operators used within method bodies can be made applicable to any type we would want to utilize in the template expansion. Our code becomes more widely applicable.</p>
<p>We have now seen how to utilize template functions and classes, and how operator overloading can enhance templates to create even more extensible code. Let us now briefly recap these concepts before moving forward to our next chapter.</p>
<h1 id="_idParaDest-224"><a id="_idTextAnchor591"/>Summary</h1>
<p>In this chapter, we have furthered our C++ programming knowledge beyond OOP language features to include additional language features that will enable us to write more extensible code. We have learned how to utilize template functions and template classes, and how operator overloading nicely supports these endeavors.</p>
<p>We have seen that templates can allow us to generically specify a class or function with respect to the data type primarily used within that class or function. We have seen that template classes inevitably utilize template functions because those methods generally need to generically use the data upon which the class is built. We have seen that by taking advantage of operator overloading for user defined types, we can take advantage of method bodies written using simple operators to accommodate usage by more complex data types, making the template code much more useful and extensible. </p>
<p>The power of templates coupled with operator overloading (to make a method usable for nearly any type) makes C++’s implementation of generics much more powerful than simple type replacement. </p>
<p>We now understand that using templates can allow us to specify a class or function just one time more abstractly, and allow the preprocessor to generate many versions of that class or function for us, based upon specific data types that may be needed within the application. </p>
<p>By allowing the preprocessor to expand many versions of a template class or set of template functions for us based on types needed in an application, the work of creating many similar classes or functions (and maintaining those versions) is passed to C++, rather than the programmer. In addition to having less code for the user to maintain, changes made in the template classes or functions need only be made in one place – the preprocessor will re-expand the code without errors when needed.</p>
<p>We have added additional, useful features to our C++ reperto<a id="_idTextAnchor592"/>ire through examining templates, which, combined with operator overloading, will ensure we can write highly extensible and reusable code for nearly any data type. We are now ready to continue forward with <a href="B19087_14.xhtml#_idTextAnchor595"><em class="italic">Chapter 14</em></a>, <em class="italic">Understanding STL Basics</em>, so that we can continue extending our C++ programming skills with useful C++ library features that will make us better pr<a id="_idTextAnchor593"/>ogrammers. Let’s move forward!</p>
<h1 id="_idParaDest-225"><a id="_idTextAnchor594"/>Questions</h1>
<ol>
<li>Convert your <code>ArrayInt</code> class from <a href="B19087_12.xhtml#_idTextAnchor526"><em class="italic">Chapter 12</em></a>, <em class="italic">Friends and Operator Overloading</em>, to a template <code>Array</code> class to support a dynamically allocated array of any data type that can be easily resized and has built-in bounds checking. </li>
</ol>
<p>a. Consider what operators, if any, you will need to overload to allow generic code within each method to support any user defined types you may wish to store in the template <code>Array</code> type.</p>
<p>b. Using your template <code>Array</code> class, create an array of <code>Student</code> instances. Utilize various member functions to demonstrate that various template functions operate correctly.</p>
<ol>
<li value="2">Using the template <code>LinkList</code> class, complete the implementation for <code>LinkList&lt;Type&gt;::OrderedInsert()</code>. Create a <code>LinkList</code> of <code>Student</code> instances in <code>main()</code>. After several <code>Student</code> instances have been inserted in the list using <code>OrderedInsert()</code>, verify that this method works correctly by displaying each <code>Student</code> and their <code>gpa</code>. The <code>Student</code> instances should be ordered from lowest to highest <code>gpa</code>. You may wish to use the online code as a starting point. </li>
</ol>
</div>
</div></body></html>