- en: Using Geometry and Tessellation Shaders
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用几何和镶嵌着色器
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖：
- en: Point sprites with the geometry shader
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用几何着色器的点精灵
- en: Drawing a wireframe on top of a shaded mesh
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在着色网格上绘制线框
- en: Drawing silhouette lines using the geometry shader
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用几何着色器绘制轮廓线
- en: Tessellating a curve
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 镶嵌曲线
- en: Tessellating a 2D quad
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 镶嵌二维四边形
- en: Tessellating a 3D surface
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 镶嵌三维表面
- en: Tessellating based on depth
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据深度进行镶嵌
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Tessellation and geometry shaders provide programmers with additional ways to
    modify geometry as it progresses through the shader pipeline. Geometry shaders
    can be used to add, modify, or delete geometry in a very precise and user-controlled
    manner. Tessellation shaders can also be configured to automatically subdivide
    geometry to various degrees (levels of detail), potentially creating immensely
    dense geometry via the GPU.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 镶嵌和几何着色器为程序员提供了在着色器管道中修改几何形状的额外方式。几何着色器可以以非常精确和用户可控的方式添加、修改或删除几何形状。镶嵌着色器也可以配置为自动以不同程度（细节级别）细分几何形状，通过GPU可能创建出极其密集的几何形状。
- en: In this chapter, we'll look at several examples of geometry and tessellation
    shaders in various contexts. However, before we get into the recipes, let's investigate
    how all of this fits together.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨在不同情境下几何和镶嵌着色器的几个示例。然而，在我们深入到食谱之前，让我们先研究一下所有这些是如何相互关联的。
- en: The shader pipeline extended
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 着色器管道扩展
- en: 'The following diagram shows a simplified view of the shader pipeline, when
    the shader program includes geometry and tessellation shaders:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图展示了当着色器程序包含几何和镶嵌着色器时的着色器管道的简化视图：
- en: '![](img/c5e7bd33-7a4f-4522-b079-7e5feb07d9ee.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c5e7bd33-7a4f-4522-b079-7e5feb07d9ee.png)'
- en: 'The tessellation portion of the shader pipeline includes two stages: the **Tessellation
    Control Shader** (**TCS**) and the **Tessellation Evaluation Shader** (**TES**).
    The geometry shader follows the tessellation stages and precedes the fragment
    shader. The tessellation shader and geometry shader are optional; however, when
    a shader program includes a tessellation or geometry shader, a vertex shader must
    be included.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器管道的镶嵌部分包括两个阶段：**镶嵌控制着色器**（**TCS**）和**镶嵌评估着色器**（**TES**）。几何着色器位于镶嵌阶段之后，片段着色器之前。镶嵌着色器和几何着色器是可选的；然而，当着色器程序包含镶嵌或几何着色器时，必须包括顶点着色器。
- en: All shaders except the vertex shader are optional. When using a geometry shader,
    there is no requirement that you also include a tessellation shader and vice versa.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 除了顶点着色器之外的所有着色器都是可选的。当使用几何着色器时，没有要求你必须包括镶嵌着色器，反之亦然。
- en: The geometry shader
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 几何着色器
- en: The **geometry shader** (**GS**) is designed to execute once for each primitive.
    It has access to all of the vertices of the primitive, as well as the values of
    any input variables associated with each vertex. In other words, if a previous
    stage (such as the vertex shader) provides an output variable, the geometry shader
    has access to the value of that variable for all vertices in the primitive. As
    a result, the input variables within the geometry shader are always arrays.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**几何着色器**（**GS**）设计为对每个原语执行一次。它能够访问原语的所有顶点，以及与每个顶点相关联的任何输入变量的值。换句话说，如果前一个阶段（如顶点着色器）提供了一个输出变量，几何着色器可以访问原语中所有顶点的该变量的值。因此，几何着色器内的输入变量始终是数组。'
- en: The geometry shader can output zero, one, or more primitives. Those primitives
    need not be of the same kind that were received by the geometry shader.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 几何着色器可以输出零个、一个或多个原语。这些原语不必与几何着色器接收到的原语种类相同。
- en: However, the GS can only output one primitive type. For example, a GS could
    receive a triangle, and output several line segments as a line strip, or a GS
    could receive a triangle and output zero or many triangles as a triangle strip.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，GS只能输出一种原语类型。例如，一个GS可以接收一个三角形，并输出多个线段作为线带，或者GS可以接收一个三角形，并输出零个或多个三角形作为三角形带。
- en: This enables the GS to act in many different ways. A GS could be responsible
    for culling (removing) geometry based on some criteria, such as visibility based
    on occlusions. It could generate additional geometry to augment the shape of the
    object being rendered. The GS could simply compute additional information about
    the primitive and pass the primitive along unchanged, or the GS could produce
    primitives that are entirely different from the input geometry.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得GS能够以许多不同的方式行动。GS可能负责基于某些标准（如基于遮挡的可见性）裁剪（移除）几何形状。它可能生成额外的几何形状以增强正在渲染的对象的形状。GS可以简单地计算有关原语的一些额外信息并将原语传递不变，或者GS可以生成与输入几何形状完全不同的原语。
- en: The functionality of the GS is centered around the two built-in functions: `EmitVertex`
    and `EndPrimitive`. These two functions allow the GS to send multiple vertices
    and primitives down the pipeline. The GS defines the output variables for a particular
    vertex, and then calls `EmitVertex`. After that, the GS can proceed to redefine
    the output variables for the next vertex, call `EmitVertex` again, and so on.
    After emitting all of the vertices for the primitive, the GS can call `EndPrimitive`
    to let the OpenGL system know that all the vertices of the primitive have been
    emitted. The `EndPrimitive` function is implicitly called when the GS finishes
    execution. If GS does not call `EmitVertex` at all, the input primitive is effectively
    dropped (it is not rendered).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: GS的功能集中在两个内置函数上：`EmitVertex` 和 `EndPrimitive`。这两个函数允许GS将多个顶点和原语发送到管道。GS定义特定顶点的输出变量，然后调用`EmitVertex`。之后，GS可以继续重新定义下一个顶点的输出变量，再次调用`EmitVertex`，依此类推。在发出原语的所有顶点后，GS可以调用`EndPrimitive`来让OpenGL系统知道原语的所有顶点都已发出。当GS完成执行时，`EndPrimitive`函数会隐式调用。如果GS根本不调用`EmitVertex`，则输入原语实际上被丢弃（它不会被渲染）。
- en: In the following recipes, we'll examine a few examples of the geometry shader.
    In the *Point sprites with the geometry shader* recipe, we'll see an example where
    the input primitive type is entirely different from the output type. In the *Drawing
    a wireframe on top of a shaded mesh* recipe, we'll pass the geometry along unchanged,
    but also produce some additional information about the primitive to help in drawing
    wireframe lines. In the *Drawing silhouette lines using the geometry shader* recipe,
    we'll see an example where the GS passes along the input primitive, but generates
    additional primitives as well.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下食谱中，我们将检查几个几何着色器的示例。在*使用几何着色器的点精灵*食谱中，我们将看到一个输入原语类型与输出类型完全不同的例子。在*在着色网格上绘制线框*食谱中，我们将传递未改变的几何形状，但也会产生一些有关原语的信息，以帮助绘制线框线。在*使用几何着色器绘制轮廓线*食谱中，我们将看到一个GS传递输入原语，但同时也生成额外的原语。
- en: The tessellation shaders
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纹理填充着色器
- en: 'When the tessellation shaders are active, we can only render one kind of primitive:
    the patch (`GL_PATCHES`). Rendering any other kind of primitive (such as triangles,
    or lines) while a tessellation shader is active is an error. The **patch primitive**
    is an arbitrary *chunk* of geometry (or any information) that is completely defined
    by the programmer. It has no geometric interpretation beyond how it is interpreted
    within the TCS and TES. The number of vertices within the patch primitive is also
    configurable. The maximum number of vertices per patch is implementation-dependent,
    and can be queried via the following command:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当纹理填充着色器处于活动状态时，我们只能渲染一种原语：补丁 (`GL_PATCHES`)。在纹理填充着色器活动时渲染任何其他类型的原语（如三角形或线条）是错误的。**补丁原语**是一个任意**块**的几何形状（或任何信息），它完全由程序员定义。它除了在TCS和TES中的解释之外，没有其他几何解释。补丁原语内的顶点数也是可配置的。每个补丁的最大顶点数取决于实现，可以通过以下命令查询：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can define the number of vertices per patch with the following function:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下函数定义每个补丁的顶点数：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A very common application of this is when the patch primitive consists of a
    set of control points that define an interpolated surface or curve (such as a
    Bezier curve or surface). However, there is no reason why the information within
    the patch primitive couldn't be used for other purposes.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这种应用非常常见的情况是，当补丁原语由一组控制点组成，这些控制点定义了一个插值表面或曲线（如贝塞尔曲线或表面）。然而，没有理由说明补丁原语内的信息不能用于其他目的。
- en: 'The patch primitive is never actually rendered; instead, it is used as additional
    information for the TCS and TES. The primitives that actually make their way further
    down the pipeline are created by the **tessellation primitive generator** (**TPG**),
    which lies between the TCS and TES. Think of the tessellation-primitive generator
    as a configurable engine that produces primitives based on a set of standard tessellation
    algorithms. The TCS and TES have access to the entire input patch, but have fundamentally
    different responsibilities. The TCS is responsible for:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 补丁原语实际上永远不会被渲染；相反，它被用作TCS和TES的附加信息。真正进入管道进一步处理的原语是由**镶嵌原语生成器**（**TPG**）创建的，它位于TCS和TES之间。将镶嵌原语生成器想象为一个可配置的引擎，它根据一组标准镶嵌算法生成原语。TCS和TES可以访问整个输入补丁，但它们有根本不同的职责。TCS负责：
- en: setting up the TPG
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置TPG
- en: defining how the primitives should be generated by the TPG (how many and what
    algorithm to use)
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义TPG如何生成原语（生成多少以及使用什么算法）
- en: producing per-vertex output attributes.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成每个顶点的输出属性。
- en: The TES has the job of determining the position (and any other information)
    of each vertex of the primitives that are produced by the TPG. For example, the
    TCS might tell the TPG to generate a line strip consisting of 100 line segments,
    and the TES is responsible for determining the position of each vertex of those
    100 line segments. The TES would likely make use of the information within the
    entire patch primitive in order to do so.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: TES负责确定由TPG生成的原语中每个顶点的位置（以及任何其他信息）。例如，TCS可能会告诉TPG生成由100个线段组成的线段条，TES负责确定这100个线段中每个顶点的位置。TES可能会利用整个补丁原语中的信息来完成这项工作。
- en: The TCS is executed once for each vertex in a patch, but has access to all vertices
    of its associated patch. It can compute additional information about the patch
    and pass it along to the TES using output variables. However, the most important
    task of the TCS is to tell the TPG how many primitives it should produce. It does
    this by defining tessellation levels via the `gl_TessLevelInner` and `gl_TessLevelOuter`
    arrays. These arrays define the granularity of the tessellation produced by the
    TPG.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: TCS在每个补丁的每个顶点处执行一次，但可以访问其相关补丁的所有顶点。它可以计算有关补丁的附加信息，并通过输出变量将其传递给TES。然而，TCS最重要的任务是告诉TPG应该生成多少原语。它通过定义通过`gl_TessLevelInner`和`gl_TessLevelOuter`数组进行镶嵌级别的设置来完成此操作。这些数组定义了TPG生成的镶嵌的粒度。
- en: The TPG generates primitives based on a particular algorithm (quads, isolines,
    or triangles). Each algorithm produces primitives in a slightly different fashion,
    and we will see examples of isolines and quads in the recipes in this chapter.
    Each vertex of the generated primitives is associated with a position in parameter
    space (u, v, w). Each coordinate of this position is a number that can range from
    zero to one. This coordinate can be used to evaluate the location of the vertex,
    often by interpolation of the patch primitive's vertices.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: TPG根据特定的算法（四边形、等值线或三角形）生成原语。每种算法以略微不同的方式生成原语，我们将在本章的食谱中看到等值线和四边形的示例。生成的原语每个顶点都与参数空间中的一个位置（u,
    v, w）相关联。这个位置的这个坐标是一个可以从零到一的数字。这个坐标可以用来评估顶点的位置，通常是通过插值补丁原语顶点来完成。
- en: 'The primitive-generation algorithms produce vertices (and the associated parametric
    coordinates) in a slightly different fashion. The tessellation algorithms for
    quads and isolines make use of only the first two parametric coordinates: *u*
    and *v*. The following diagram illustrates the process for an input and output
    patch consisting of four vertices. In the diagram, the TPG uses the quad tessellation
    algorithm with the inner and outer tessellation levels set at four:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 原语生成算法以略微不同的方式生成顶点（以及相关的参数坐标）。四边形和等值线的镶嵌算法仅使用前两个参数坐标：*u*和*v*。以下图示说明了由四个顶点组成的输入和输出补丁的过程。在图中，TPG使用四边形镶嵌算法，内嵌和外嵌镶嵌级别设置为四：
- en: '![](img/0f134320-c9fe-44e2-b161-e538b96aed54.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0f134320-c9fe-44e2-b161-e538b96aed54.png)'
- en: The number of vertices in the input patch need not be the same as the number
    of vertices in the output patch, although that will be the case in all of the
    examples in this chapter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 输入补丁中的顶点数不必与输出补丁中的顶点数相同，尽管在本章的所有示例中情况都是如此。
- en: The TES is executed once for each parameter-space vertex that is generated by
    the TPG. Somewhat strangely, the TES is actually the shader that defines the algorithm
    used by the TPG. It does so via its input layout qualifier. As stated earlier,
    its main responsibility is to determine the position of the vertex (possibly along
    with other information, such as normal vector and texture coordinate). Typically,
    the TES uses the parametric coordinate (u,v) provided by the TPG along with the
    positions of all of the input patch vertices to do so. For example, when drawing
    a curve, the patch might consists of four vertices, which are the control points
    for the curve. The TPG would then generate 101 vertices to create a line strip
    (if the tessellation level was set to 100), and each vertex might have a *u* coordinate
    that ranged appropriately between zero and one. The TES would then use that *u*
    coordinate along with the positions of the four patch vertices to determine the
    position of the vertex associated with the shader's execution.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: TES（镶嵌着色器）对于TPG生成的每个参数空间顶点执行一次。有些奇怪的是，TES实际上是定义TPG使用的算法的着色器。它是通过其输入布局限定符来做到这一点的。如前所述，其主要责任是确定顶点的位置（可能还有其他信息，如法向量纹理坐标）。通常，TES使用TPG提供的参数坐标（u,v）以及所有输入补丁顶点的位置来完成这一任务。例如，当绘制曲线时，补丁可能由四个顶点组成，这些顶点是曲线的控制点。然后TPG会生成101个顶点来创建一个线带（如果镶嵌级别设置为100），每个顶点可能有一个在零和一之间适当范围的
    *u* 坐标。然后TES将使用那个 *u* 坐标以及四个补丁顶点的位置来确定与着色器执行相关的顶点的位置。
- en: If all of this seems confusing, start with the *Tessellating a curve* recipe,
    and work your way through the following recipes.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这一切看起来很复杂，可以从 *曲线镶嵌* 菜单开始，然后逐步学习以下菜单。
- en: In the *Tessellating a curve* recipe, we'll go through a basic example where
    we use tessellation shaders to draw a Bezier curve with four control points. In
    the *Tessellating a 2D quad* recipe, we'll try to understand how the quad tessellation
    algorithm works by rendering a simple quad and visualizing the triangles produced
    by the TPG. In the *Tessellating a 3D surface* recipe, we'll use quad tessellation
    to render a 3D Bezier surface. Finally, in the *Tessellating based on depth* recipe,
    we'll see how the tessellation shaders make it easy to implement **level-of-detail**
    (**LOD**) algorithms.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *曲线镶嵌* 菜单中，我们将通过一个基本示例来了解如何使用镶嵌着色器绘制具有四个控制点的贝塞尔曲线。在 *2D 四边形镶嵌* 菜单中，我们将通过渲染一个简单的四边形并可视化由TPG产生的三角形来理解四边形镶嵌算法的工作原理。在
    *3D 表面镶嵌* 菜单中，我们将使用四边形镶嵌来渲染3D贝塞尔表面。最后，在 *基于深度的镶嵌* 菜单中，我们将看到镶嵌着色器如何使实现**细节级别**（**LOD**）算法变得容易。
- en: Point sprites with the geometry shader
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用几何着色器的点精灵
- en: '**Point sprites** are simple quads (usually texture mapped) that are aligned
    such that they are always facing the camera. They are very useful for particle
    systems in 3D (refer to [Chapter 9](36422579-2eed-46ff-95b7-755859c387eb.xhtml),
    *Using Noise in Shaders*) or 2D games. The point sprites are specified by the
    OpenGL application as single-point primitives, via the `GL_POINTS` rendering mode.
    This simplifies the process, because the quad itself and the texture coordinates
    for the quad are determined automatically. The OpenGL side of the application
    can effectively treat them as point primitives, avoiding the need to compute the
    positions of the quad vertices.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**点精灵**是简单的四边形（通常是纹理映射的），它们被对齐，使得它们始终面向相机。它们在3D（参考第9章，*在着色器中使用噪声*）或2D游戏中对粒子系统非常有用。点精灵由OpenGL应用程序指定为单点原语，通过`GL_POINTS`渲染模式。这简化了过程，因为四边形本身及其纹理坐标是自动确定的。应用程序的OpenGL端可以有效地将它们视为点原语，避免计算四边形顶点的位置。'
- en: 'The following image shows a group of point sprites. Each sprite is rendered
    as a point primitive. The quad and texture coordinates are generated automatically
    (within the geometry shader) and aligned to face the camera:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了一组点精灵。每个精灵都被渲染为一个点原语。四边形和纹理坐标在几何着色器中自动生成并面向相机：
- en: '![](img/6358f541-9692-4abf-92cd-ba82a0a22076.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6358f541-9692-4abf-92cd-ba82a0a22076.png)'
- en: OpenGL already has built-in support for point sprites in the `GL_POINTS` rendering
    mode. When rendering point primitives using this mode, the points are rendered
    as screen-space squares that have a diameter (side length) as defined by the `glPointSize`
    function. In addition, OpenGL will automatically generate texture coordinates
    for the fragments of the square. These coordinates run from zero to one in each
    direction (horizontal and vertical), and are accessible in the fragment shader
    via the `gl_PointCoord` built-in variable.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL已经在其`GL_POINTS`渲染模式中内置了对点精灵的支持。当使用此模式渲染点原语时，点被渲染为屏幕空间正方形，其直径（边长）由`glPointSize`函数定义。此外，OpenGL将为正方形的片段自动生成纹理坐标。这些坐标在每个方向（水平和垂直）上从零到一，可以通过片段着色器中的`gl_PointCoord`内置变量访问。
- en: There are various ways to fine-tune the rendering of point sprites within OpenGL.
    One can define the origin of the automatically-generated texture coordinates using
    the `glPointParameter` functions. The same set of functions also can be used to
    tweak the way that OpenGL defines the alpha value for points when multi-sampling
    is enabled.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以微调OpenGL中点精灵的渲染。可以使用`glPointParameter`函数定义自动生成的纹理坐标的原点。同一组函数也可以用来调整OpenGL在启用多采样时定义点alpha值的方式。
- en: The built-in support for point sprites does not allow the programmer to rotate
    the screen-space squares, or define them as different shapes, such as rectangles
    or triangles. However, one can achieve similar effects with the creative use of
    textures and transformations of the texture coordinates. For example, we could
    transform the texture coordinates using a rotation matrix to create the look of
    a rotating object even though the geometry itself is not actually rotating. In
    addition, the size of the point sprite is a screen-space size. In other words,
    the point size must be adjusted with the depth of the point sprite if we want
    to get a perspective effect (sprites get smaller with distance).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的点精灵支持不允许程序员旋转屏幕空间正方形，或定义它们为不同的形状，例如矩形或三角形。然而，可以通过创造性地使用纹理和纹理坐标的变换来实现类似的效果。例如，我们可以使用旋转矩阵变换纹理坐标，以创建旋转物体的外观，尽管几何形状本身并没有实际旋转。此外，点精灵的大小是屏幕空间大小。换句话说，如果我们要获得透视效果（精灵随着距离的增加而变小），点的大小必须与点精灵的深度调整一致。
- en: If these (and possibly other) issues make the default support for point sprites
    too limiting, we can use the geometry shader to generate our point sprites. In
    fact, this technique is a good example of using the geometry shader to generate
    different kinds of primitives than it receives. The basic idea here is that the
    geometry shader will receive point primitives (in camera coordinates) and will
    output a quad centered at the point and aligned so that it is facing the camera.
    The geometry shader will also automatically generate texture coordinates for the
    quad.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些（以及可能的其他）问题使得默认的点精灵支持过于受限，我们可以使用几何着色器来生成我们的点精灵。实际上，这种技术是使用几何着色器生成不同于接收到的不同类型原语的一个很好的例子。这里的基本思想是，几何着色器将接收点原语（在相机坐标系中）并将输出一个以点为中心且面向相机的四边形。几何着色器还将自动为四边形生成纹理坐标。
- en: If desired, we could generate other shapes, such as hexagons, or we could rotate
    the quads before they are output from the geometry shader. The possibilities are
    endless.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，我们可以生成其他形状，例如六边形，或者我们可以在它们从几何着色器输出之前旋转四边形。可能性是无限的。
- en: Before jumping directly into the code, let's take a look at some of the mathematics.
    In the geometry shader, we'll need to generate the vertices of a quad that is
    centered at a point and aligned with the camera's coordinate system (eye coordinates).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在直接进入代码之前，让我们先看看一些数学知识。在几何着色器中，我们需要生成一个以点为中心且与相机坐标系（眼睛坐标系）对齐的四边形的顶点。
- en: 'Given the point location (**P**) in camera coordinates, we can generate the
    vertices of the corners of the quad by simply translating **P** in a plane parallel
    to the x-y plane of the camera''s coordinate system, as shown in the following
    figure:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 给定相机坐标系中的点位置（**P**），我们可以通过简单地沿与相机坐标系x-y平面平行的平面平移**P**来生成四边形的顶点，如图所示：
- en: '![](img/99afbe00-d819-4ce4-b58d-ed568411d828.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/99afbe00-d819-4ce4-b58d-ed568411d828.png)'
- en: The geometry shader will receive the point location in camera coordinates, and
    output the quad as a triangle strip with texture coordinates. The fragment shader
    will then just apply the texture to the quad.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 几何着色器将接收点位置（相机坐标），并以带有纹理坐标的三角形带形式输出四边形。然后片段着色器将仅将纹理应用到四边形上。
- en: Getting ready
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this example, we'll need to render a number of point primitives. The positions
    can be sent via attribute location `0`. There's no need to provide normal vectors
    or texture coordinates for this one.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们需要渲染多个点原语。位置可以通过属性位置`0`发送。对于这个例子，不需要提供法线向量或纹理坐标。
- en: 'The following uniform variables are defined within the shaders, and need to
    be set within the OpenGL program:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在着色器中定义了以下统一变量，并在OpenGL程序中需要设置：
- en: '`Size2`: This should be half the width of the sprite''s square'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Size2`：这应该是精灵正方形宽度的一半'
- en: '`SpriteTex`: This is the texture unit containing the point sprite texture'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SpriteTex`：这是包含点精灵纹理的纹理单元'
- en: As usual, uniforms for the standard transformation matrices are also defined
    within the shaders, and need to be set within the OpenGL program.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，标准变换矩阵的统一变量也在着色器中定义，并在OpenGL程序中需要设置。
- en: How to do it...
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'To create a shader program that can be used to render point primitives as quads,
    use the following steps:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个可以用来将点原语渲染为四边形的着色器程序，请按照以下步骤操作：
- en: 'The vertex shader will convert the position to camera coordinates and assign
    to the `gl_Position` output variable. Note that we''re not converting to clip
    coordinates just yet:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 顶点着色器将位置转换为相机坐标并分配给输出变量`gl_Position`。请注意，我们还没有将其转换为裁剪坐标：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The geometry shader emits two triangles as a triangle strip. We use the `gl_in`
    variable to access the position from the vertex shader (camera coordinates):'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几何着色器以三角形带的形式发出两个三角形。我们使用`gl_in`变量从顶点着色器（相机坐标）访问位置：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The fragment shader applies the texture:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 片段着色器应用纹理：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Within the OpenGL render function, render a set of point primitives.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在OpenGL渲染函数中，渲染一组点原语。
- en: How it works...
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The vertex shader is almost as simple as it can get. It converts the point's
    position to camera coordinates by multiplying by the model-view matrix, and assigns
    the result to the built-in output variable, `gl_Position`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色器几乎是最简单的。它通过乘以模型视图矩阵将点的位置转换为相机坐标，并将结果分配给内置输出变量`gl_Position`。
- en: 'In the geometry shader, we start by defining the kind of primitive that this
    geometry shader expects to receive. The first layout statement indicates that
    this geometry shader will receive point primitives:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在几何着色器中，我们首先定义这个几何着色器期望接收的原语类型。第一个布局语句指示这个几何着色器将接收点原语：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The next layout statement indicates the kind of primitives produced by this
    geometry shader, and the maximum number of vertices that will be output:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个布局语句指示了由这个几何着色器产生的原语类型，以及将输出的最大顶点数：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this case, we want to produce a single quad for each point received, so we
    indicate that the output will be a triangle strip with a maximum of four vertices.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们希望为每个接收到的点生成一个四边形，因此我们指出输出将是一个最多包含四个顶点的三角形带。
- en: The input primitive is available to the geometry shader via the built-in input
    variable, `gl_in`. Note that it is an array of structures. You might be wondering
    why this is an array since a point primitive is only defined by a single position.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 输入原语通过内置输入变量`gl_in`可用给几何着色器。请注意，它是一个结构体的数组。你可能想知道为什么这是一个数组，因为点原语仅由一个位置定义。
- en: Well, in general, the geometry shader can receive triangles, lines, or points
    (and possibly adjacency information). So, the number of values available may be
    more than one. If the input were triangles, the geometry shader would have access
    to three input values (associated with each vertex). In fact, it could have access
    to as many as six values when `triangles_adjacency` is used (more on that in a
    later recipe).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，一般来说，几何着色器可以接收三角形、线或点（以及可能的相邻信息）。因此，可用的值数量可能不止一个。如果输入是三角形，几何着色器将能够访问三个输入值（与每个顶点相关联）。实际上，当使用`triangles_adjacency`时，它可以访问多达六个值（关于这一点将在后面的菜谱中详细介绍）。
- en: The `gl_in` variable is an array of structs. Each struct contains the following
    fields: `gl_Position`, `gl_PointSize`, and `gl_ClipDistance[]`. In this example,
    we are only interested in `gl_Position`. However, the others can be set in the
    vertex shader to provide additional information to the geometry shader.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`gl_in`变量是一个结构体数组。每个结构体包含以下字段：`gl_Position`、`gl_PointSize`和`gl_ClipDistance[]`。在这个例子中，我们只对`gl_Position`感兴趣。然而，其他字段可以在顶点着色器中设置，以向几何着色器提供额外信息。'
- en: 'Within the `main` function of the geometry shader, we produce the quad (as
    a triangle strip) in the following way. For each vertex of the triangle strip,
    we execute the following steps:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在几何着色器的`main`函数中，我们以下这种方式生成四边形（作为一个三角形带）。对于三角形带的每个顶点，我们执行以下步骤：
- en: Compute the attributes for the vertex (in this case the position and texture
    coordinate), and assign their values to the appropriate output variables (`gl_Position`
    and `TexCoord`). Note that the position is also transformed by the projection
    matrix. We do this because the `gl_Position` variable must be provided in clip
    coordinates to later stages of the pipeline.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算顶点的属性（在这种情况下是位置和纹理坐标），并将它们的值分配给适当的输出变量（`gl_Position`和`TexCoord`）。请注意，位置也由投影矩阵变换。我们这样做是因为`gl_Position`变量必须以裁剪坐标的形式提供给管道的后续阶段。
- en: Emit the vertex (send it down the pipeline) by calling the built-in `EmitVertex()` function.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用内置的`EmitVertex()`函数来发射顶点（将其发送到管道）。
- en: Once we have emitted all vertices for the output primitive, we call `EndPrimitive()`
    to finalize the primitive and send it along.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们为输出原语发射了所有顶点，我们就调用`EndPrimitive()`来最终化原语并将其发送出去。
- en: It is not strictly necessary to call `EndPrimitive()` in this case because it
    is implicitly called when the geometry shader finishes. However, like closing
    files, it is a good practice.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，严格来说没有必要调用`EndPrimitive()`，因为当几何着色器完成后会隐式调用它。然而，就像关闭文件一样，这是一个好的实践。
- en: The fragment shader is also very simple. It just applies the texture to the
    fragment using the (interpolated) texture coordinate provided by the geometry
    shader.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 片段着色器也非常简单。它只是使用几何着色器提供的（插值）纹理坐标将纹理应用到片段上。
- en: There's more...
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This example is fairly straightforward and is intended as a gentle introduction
    to geometry shaders. We could expand on this by allowing the quad to rotate or
    to be oriented in different directions. We could also use the texture to discard
    fragments (in the fragment shader) in order to create point sprites of arbitrary
    shapes. The power of the geometry shader opens up plenty of possibilities!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子相当直接，旨在作为几何着色器的一个温和的介绍。我们可以通过允许四边形旋转或以不同的方向定位来扩展这个例子。我们还可以使用纹理在片段着色器中丢弃片段，以创建任意形状的点精灵。几何着色器的力量为提供了大量的可能性！
- en: See also
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter07/scenepointsprite.cpp` file in the example code
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的`chapter07/scenepointsprite.cpp`文件
- en: Drawing a wireframe on top of a shaded mesh
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在着色网格上绘制线框
- en: The preceding recipe demonstrated the use of a geometry shader to produce a
    different variety of primitives than it received. Geometry shaders can also be
    used to provide additional information to later stages. They are quite well-suited
    to doing so because they have access to all of the vertices of the primitive at
    once, and can do computations based on the entire primitive rather than a single
    vertex.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的方法展示了如何使用几何着色器产生与接收到的原语不同的原语种类。几何着色器也可以用来向后续阶段提供额外信息。它们非常适合这样做，因为它们可以一次性访问原语的所有顶点，并且可以根据整个原语而不是单个顶点进行计算。
- en: This example involves a geometry shader that does not modify the triangle at
    all. It essentially passes the primitive along unchanged. However, it computes
    additional information about the triangle that will be used by the fragment shader
    to highlight the edges of the polygon. The basic idea here is to draw the edges
    of each polygon directly on top of the shaded mesh.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子涉及一个不修改三角形的几何着色器。它基本上以不变的方式传递原语。然而，它计算了三角形的一些额外信息，这些信息将被片段着色器用来突出显示多边形的边缘。这里的基想法是直接在着色网格上绘制每个多边形的边缘。
- en: 'The following image shows an example of this technique. The mesh edges are
    drawn on top of the shaded surface by using information computed within the geometry
    shader:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像展示了这种技术的示例。通过在几何着色器内部计算的信息，网格边在着色表面之上被绘制出来：
- en: '![](img/85998f4d-e8b2-413b-ae0d-248d1d8ffd20.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/85998f4d-e8b2-413b-ae0d-248d1d8ffd20.png)'
- en: There are many techniques for producing wireframe structures on top of shaded
    surfaces. This technique comes from an NVIDIA whitepaper published in 2007\. We
    make use of the geometry shader to produce the wireframe and shaded surface in
    a single pass. We also provide some simple anti-aliasing of the mesh lines that
    are produced, and the results are quite nice (refer to the preceding image).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在阴影表面之上生成线框结构有许多技术。这项技术源自于2007年NVIDIA发布的一篇白皮书。我们利用几何着色器在一次遍历中生成线框和阴影表面。我们还对生成的网格线提供了一些简单的抗锯齿处理，效果相当不错（参考前面的图像）。
- en: To render the wireframe on top of the shaded mesh, we'll compute the distance
    from each fragment to the nearest triangle edge. When the fragment is within a
    certain distance from the edge, it will be shaded and mixed with the edge color.
    Otherwise, the fragment will be shaded normally.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要在阴影网格上渲染线框，我们将计算每个片段到最近三角形边缘的距离。当片段距离边缘一定距离内时，它将被着色并与边缘颜色混合。否则，片段将正常着色。
- en: 'To compute the distance from a fragment to the edge, we use the following technique.
    In the geometry shader, we compute the minimum distance from each vertex to the
    opposite edge (also called the **triangle altitude**). In the following diagram,
    the desired distances are **ha**, **hb**, and **hc**:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算片段到边缘的距离，我们使用以下技术。在几何着色器中，我们计算每个顶点到对边（也称为 **三角形高度**）的最小距离。在以下图中，所需的距离是 **ha**、**hb**
    和 **hc**：
- en: '![](img/e9d927f2-7b3f-4bce-acd6-c80b8c0f1f33.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e9d927f2-7b3f-4bce-acd6-c80b8c0f1f33.png)'
- en: 'We can compute these altitudes using the interior angles of the triangle, which
    can be determined using the law of cosines. For example, to find **ha**, we use
    the interior angle at vertex **C** (**β**):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用三角形的内角来计算这些高度，这些内角可以通过余弦定理确定。例如，要找到 **ha**，我们使用顶点 **C** 处的内角（**β**）：
- en: '![](img/ff8aa61a-661c-44d8-8886-7aa2243ec2f7.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ff8aa61a-661c-44d8-8886-7aa2243ec2f7.png)'
- en: The other altitudes can be computed in a similar way. (Note that **β** could
    be greater than 90 degrees, in which case, we would want the sine of 180-β. However,
    the sine of 180-β is the same as the sine of β.) Once we have computed these triangle
    altitudes, we can create an output vector (an *edge-distance* vector) within the
    geometry shader for interpolation across the triangle. The components of this
    vector represent the distances from the fragment to each edge of the triangle.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 其他高度可以以类似的方式计算。（注意，**β** 可能大于90度，在这种情况下，我们希望得到180-**β**的正弦值。然而，180-**β**的正弦值与**β**的正弦值相同。）一旦我们计算了这些三角形高度，我们就可以在几何着色器中创建一个输出向量（一个
    *边距* 向量）以在三角形上插值。这个向量的分量代表从片段到三角形每个边缘的距离。
- en: The *x* component represents the distance from edge **a**, the *y* component
    is the distance from edge **b**, and the *z* component is the distance from edge
    **c**. If we assign the correct values to these components at the vertices, the
    hardware will automatically interpolate them for us to provide the appropriate
    distances at each fragment. At vertex **A**, the value of this vector should be
    (**ha**, 0, 0) because vertex **A** is at a distance of ha from edge **a** and
    directly on edges **b** and **c**. Similarly, the value for vertex **B** is (0,
    **hb**, 0) and for vertex **C** is (0, 0, **hc**). When these three values are
    interpolated across the triangle, we should have the distance from the fragment
    to each of the three edges. We will calculate all of this in screen space. That
    is, we'll transform the vertices to screen space within the geometry shader before
    computing the altitudes.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*x* 分量表示从边缘 **a** 的距离，*y* 分量是距离边缘 **b** 的距离，而 *z* 分量是距离边缘 **c** 的距离。如果我们在这三个顶点处为这些分量分配正确的值，硬件将自动为我们插值它们，以在每个片段处提供适当的距离。在顶点
    **A** 处，这个向量的值应该是（**ha**，0，0），因为顶点 **A** 距离边缘 **a** 为 **ha**，并且直接位于边缘 **b** 和
    **c** 上。同样，顶点 **B** 的值是（0，**hb**，0），顶点 **C** 的值是（0，0，**hc**）。当这三个值在三角形上插值时，我们应该得到从片段到三个边缘的距离。我们将在屏幕空间中计算所有这些。也就是说，在计算高度之前，我们将在几何着色器中将顶点转换到屏幕空间。'
- en: Since we are working in screen space, there's no need (and it would be incorrect)
    to interpolate the values in a perspective-correct manner. So we need to be careful
    to tell the hardware to interpolate linearly. Within the fragment shader, all
    we need to do is find the minimum of the three distances, and if that distance
    is less than the line width, we mix the fragment color with the line color. However,
    we'd also like to apply a bit of anti-aliasing while we're at it. To do so, we'll
    fade the edge of the line using the GLSL `smoothstep` function. We'll scale the
    intensity of the line in a two-pixel range around the edge of the line. Pixels
    that are at a distance of one or less from the true edge of the line get 100%
    of the line color, and pixels that are at a distance of one or more from the edge
    of the line get 0% of the line color. In between, we'll use the `smoothstep` function
    to create a smooth transition. Of course, the edge of the line itself is a configurable
    distance (we'll call it `Line.Width`) from the edge of the polygon.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在屏幕空间中工作，没有必要（并且这是不正确的）以透视正确的方式插值值。因此，我们需要小心地告诉硬件以线性方式插值。在片段着色器中，我们只需要找到三个距离中的最小值，如果这个距离小于线宽，我们就将片段颜色与线条颜色混合。然而，我们还想在这个过程中应用一点抗锯齿。为此，我们将使用GLSL的`smoothstep`函数来淡出线条的边缘。我们将在线条边缘的两像素范围内缩放线条的强度。距离真实边缘一像素或更近的像素将获得100%的线条颜色，而距离边缘一像素或更远的像素将获得0%的线条颜色。在两者之间，我们将使用`smoothstep`函数创建平滑过渡。当然，线条的边缘本身是一个可配置的距离（我们将称之为`Line.Width`），从多边形的边缘开始。
- en: Getting ready
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The typical setup is needed for this example. The vertex position and normal
    should be provided in attributes zero and one, respectively, and you need to provide
    the appropriate parameters for your shading model. As usual, the standard matrices
    are defined as uniform variables and should be set within the OpenGL application.
    However, note that this time we also need the viewport matrix (the `ViewportMatrix` uniform
    variable) in order to transform into screen space. There are a few uniforms related
    to the mesh lines that need to be set:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此示例，需要典型的设置。顶点位置和法线应分别提供在属性零和一，你需要为你的着色模型提供适当的参数。像往常一样，标准矩阵被定义为统一变量，应在OpenGL应用程序中设置。然而，请注意，这次我们还需要视口矩阵（`ViewportMatrix`统一变量）以便将其转换为屏幕空间。有一些与网格线相关的统一变量需要设置：
- en: '`Line.Width`: This should be half the width of the mesh lines'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Line.Width`: 这应该是网格线的宽度的一半'
- en: '`Line.Color`: This is the color of the mesh lines'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Line.Color`: 这是网格线的颜色'
- en: How to do it...
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create a shader program that utilizes the geometry shader to produce a wireframe
    on top of a shaded surface, use the following steps:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个利用几何着色器在着色表面之上生成线框的着色器程序，请按照以下步骤操作：
- en: 'Use the following code for the vertex shader:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码作为顶点着色器：
- en: '[PRE7]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Use the following code for the geometry shader:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码作为几何着色器：
- en: '[PRE8]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Use the following code for the fragment shader:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码作为片段着色器：
- en: '[PRE9]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The vertex shader is pretty simple. It passes the normal and position along
    to the geometry shader after converting them into camera coordinates. The built-in `gl_Position` variable
    gets the position in clip coordinates. We''ll use this value in the geometry shader
    to determine the screen space coordinates. In the geometry shader, we begin by
    defining the input and output primitive types for this shader:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色器相当简单。它将法线和位置转换为相机坐标后，传递给几何着色器。内置的`gl_Position`变量获取剪辑坐标中的位置。我们将在几何着色器中使用这个值来确定屏幕空间坐标。在几何着色器中，我们首先定义此着色器的输入和输出原语类型：
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We don''t actually change anything about the geometry of the triangle, so the
    input and output types are essentially the same. We will output exactly the same
    triangle that was received as input. The output variables for the geometry shader
    are `GNormal`, `GPosition`, and `GEdgeDistance`. The first two are simply the
    values of the normal and position in camera coordinates, passed through unchanged.
    The third is the vector that will store the distance to each edge of the triangle
    (described previously). Note that it is defined with the `noperspective` qualifier:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上并没有改变三角形的几何形状，因此输入和输出类型基本上是相同的。我们将输出与输入接收到的完全相同的三角形。几何着色器的输出变量是`GNormal`、`GPosition`和`GEdgeDistance`。前两个只是通过不变传递的正常值和位置值。第三个是存储到三角形每条边的距离的向量（如前所述）。注意，它使用`noperspective`修饰符定义：
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `noperspective` qualifier indicates that the values are to be interpolated
    linearly, instead of the default perspective correct interpolation. As mentioned
    previously, these distances are in screen space, so it would be incorrect to interpolate
    them in a non-linear fashion. Within the `main` function, we start by transforming
    the position of each of the three vertices of the triangle from clip coordinates
    to screen space coordinates by multiplying with the viewport matrix. (Note that
    it is also necessary to divide by the *w* coordinate as the clip coordinates are
    homogeneous and may need to be converted back to true Cartesian coordinates.)
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`noperspective`修饰符表示这些值将进行线性插值，而不是默认的透视正确插值。如前所述，这些距离是在屏幕空间中，因此以非线性方式插值是不正确的。在`main`函数中，我们首先通过乘以视口矩阵将三角形的三个顶点的位置从裁剪坐标转换为屏幕空间坐标。（注意，由于裁剪坐标是齐次的，可能需要除以*w*坐标，以便将其转换回真正的笛卡尔坐标。）'
- en: 'Next, we compute the three altitudes—`ha`, `hb`, and `hc`—using the law of
    cosines. Once we have the three altitudes, we set `GEdgeDistance` appropriately
    for the first vertex, pass along `GNormal`, `GPosition`, and `gl_Position` unchanged,
    and emit the first vertex by calling `EmitVertex()`. This finishes the vertex
    and emits the vertex position and all of the per-vertex output variables. We then
    proceed similarly for the other two vertices of the triangle, finishing the polygon
    by calling `EndPrimitive()`. In the fragment shader, we start by evaluating the
    basic shading model and storing the resulting color in `color`. At this stage
    in the pipeline, the three components of the `GEdgeDistance` variable should contain
    the distance from this fragment to each of the three edges of the triangle. We
    are interested in the minimum distance, so we find the minimum of the three components
    and store that in the `d` variable. The `smoothstep` function is then used to
    determine how much to mix the line color with the shaded color (`mixVal`):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用余弦定理计算三个高度——`ha`、`hb`和`hc`。一旦我们得到了这三个高度，我们就为第一个顶点适当地设置`GEdgeDistance`，保持`GNormal`、`GPosition`和`gl_Position`不变，并通过调用`EmitVertex()`来发射第一个顶点。这完成了顶点的处理，并发射了顶点位置以及所有每个顶点的输出变量。然后我们以类似的方式处理三角形的另外两个顶点，通过调用`EndPrimitive()`来完成多边形的处理。在片段着色器中，我们首先评估基本的着色模型，并将结果颜色存储在`color`中。在这个管道阶段，`GEdgeDistance`变量的三个分量应该包含从该片段到三角形三个边的距离。我们感兴趣的是最小距离，因此我们找到这三个分量的最小值，并将其存储在`d`变量中。然后使用`smoothstep`函数来确定混合线颜色与着色颜色的比例（`mixVal`）：
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If the distance is less than `Line.Width - 1`, then `smoothstep` will return
    a value of `0`, and if it is greater than `Line.Width + 1`, it will return `1`.
    For values of `d` that are in between the two, we'll get a smooth transition.
    This gives us a value of `0` when inside the line, a value of `1` when outside
    the line, and in a two-pixel area around the edge, we'll get a smooth variation
    between 0 and 1\. Therefore, we can use the result to mix the color directly with
    the line color. Finally, the fragment color is determined by mixing the shaded
    color with the line color using `mixVal` as the interpolation parameter.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果距离小于`Line.Width - 1`，则`smoothstep`将返回`0`的值，如果大于`Line.Width + 1`，则返回`1`。对于`d`值在两者之间的情况，我们将得到平滑的过渡。这给我们一个当在内部时为`0`的值，当在外部时为`1`的值，并且在边缘周围的两个像素区域内，我们将得到0到1之间的平滑变化。因此，我们可以使用这个结果直接与线颜色混合。最后，通过使用`mixVal`作为插值参数，通过混合着色颜色与线颜色来确定片段颜色。
- en: There's more...
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This technique produces very nice-looking results and has relatively few drawbacks.
    However, it does have some issues with triangles that are large in screen space
    (extend outside the view volume). If the *w* coordinate is small or zero, the
    position in viewport space can approach infinity, producing some ugly artifacts. 
    This happens when the vertex is at or near the *x*-*y* plane in camera space.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术产生的结果非常漂亮，并且相对较少的缺点。然而，它确实有一些与屏幕空间中大的三角形（延伸到视图体积之外）相关的问题。如果*w*坐标很小或为零，视口空间中的位置可以接近无穷大，产生一些难看的伪影。这发生在顶点在或接近相机空间的*x*-*y*平面时。
- en: However, it is a good example of how geometry shaders can be useful for tasks
    other than the modification of the actual geometry. In this case, we used the
    geometry shader simply to compute additional information about the primitive as
    it was being sent down the pipeline. This shader can be dropped in and applied
    to any mesh without any modification to the OpenGL side of the application. It
    can be useful when debugging mesh issues or when implementing a mesh modeling
    program. Other common techniques for accomplishing this effect typically involve
    rendering the shaded object and wireframe in two passes with a polygon offset
    (via the `glPolygonOffset` function) applied to avoid **z-fighting**, which takes
    place between the wireframe and the shaded surface beneath. This technique is
    not always effective because the modified depth values might not always be correct,
    or as desired, and it can be difficult to find the sweet spot for the polygon
    offset value. For a good survey of techniques, refer to *Section 11.4.2* in *Real
    Time Rendering*, *third edition*, by T Akenine-Moller, E Haines, and N Hoffman,
    AK Peters, 2008.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这是一个很好的例子，说明了几何着色器可以用于除了修改实际几何以外的任务。在这种情况下，我们只是使用几何着色器来计算在管道中发送原始数据时的额外信息。这个着色器可以插入并应用于任何网格，而无需对应用程序的OpenGL部分进行任何修改。它在调试网格问题或实现网格建模程序时非常有用。实现此效果的其他常见技术通常涉及通过应用多边形偏移（通过`glPolygonOffset`函数）以避免**z-fighting**，在轮廓线和下面的着色表面之间发生。这种技术并不总是有效的，因为修改后的深度值可能并不总是正确，或者如期望的那样，并且可能很难找到多边形偏移值的最佳点。有关技术的良好概述，请参阅T
    Akenine-Moller、E Haines和N Hoffman所著的《实时渲染》第三版中的*第11.4.2节*。
- en: See also...
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见...
- en: The `chapter07/sceneshadewire.cpp` file in the example code.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的`chapter07/sceneshadewire.cpp`文件。
- en: This technique was originally published in an NVIDIA whitepaper in 2007 (*Solid
    Wireframe*, *NVIDIA Whitepaper WP-03014-001_v01* available at [developer.nvidia.com](http://developer.nvidia.com)).
    The white paper was listed as a Direct3D example, but of course our implementation
    here is provided in OpenGL.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种技术最初发表在2007年NVIDIA的一份白皮书中（*Solid Wireframe*，*NVIDIA Whitepaper WP-03014-001_v01*，可在[developer.nvidia.com](http://developer.nvidia.com)找到）。该白皮书被列为Direct3D的示例，但当然，我们在这里提供的是OpenGL的实现。
- en: The *Creating shadows using shadow volumes and the geometry shader* recipe in
    [Chapter 8](43239816-a842-483f-9eca-284f919d0bd6.xhtml), *Shadows*.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*第8章*中，*阴影*的*使用阴影体积和几何着色器创建阴影*菜谱[43239816-a842-483f-9eca-284f919d0bd6.xhtml]。
- en: Drawing silhouette lines using the geometry shader
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用几何着色器绘制轮廓线
- en: When a cartoon or hand-drawn effect is desired, we often want to draw black
    outlines around the edges of a model and along ridges or creases (silhouette lines).
    In this recipe, we'll discuss one technique for doing this using the geometry
    shader, to produce the additional geometry for the silhouette lines. The geometry
    shader will approximate these lines by generating small, skinny quads aligned
    with the edges that make up the silhouette of the object. The following image
    shows the ogre mesh with black silhouette lines generated by the geometry shader.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要卡通或手绘效果时，我们通常想在模型的边缘以及脊或褶皱（轮廓线）周围绘制黑色轮廓。在这个菜谱中，我们将讨论一种使用几何着色器来实现这一点的技术，以生成轮廓线的额外几何形状。几何着色器将通过生成与构成对象轮廓的边缘对齐的小而瘦的四边形来近似这些线条。以下图像显示了由几何着色器生成的黑色轮廓线的ogre网格。
- en: 'The lines are made up of small quads that are aligned with certain mesh edges:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这些线由与某些网格边缘对齐的小四边形组成：
- en: '![](img/39d7443c-089e-49d6-bcf2-26602ed1ddb7.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/39d7443c-089e-49d6-bcf2-26602ed1ddb7.png)'
- en: 'The technique shown in this recipe is based on a technique published in a blog
    post by Philip Rideout: [prideout.net/blog/?p=54](http://prideout.net/blog/?p=54).
    His implementation uses two passes (base geometry and silhouette), and includes
    many optimizations, such as anti-aliasing and custom depth testing (with g-buffers).
    To keep things simple, as our main goal is to demonstrate the features of the
    geometry shader, we''ll implement the technique using a single pass without anti-aliasing
    or custom depth testing. If you are interested in adding these additional features,
    refer to Philip''s excellent blog post. One of the most important features of
    the geometry shader is that it allows us to provide additional vertex information
    beyond just the primitive being rendered. When geometry shaders were introduced
    in OpenGL, several additional primitive rendering modes were also introduced.
    These **adjacency modes** allow additional vertex data to be associated with each
    primitive. Typically, this additional information is related to the nearby primitives
    within a mesh, but there is no requirement that this be the case (we could actually
    use the additional information for other purposes if desired). The following list
    includes the adjacency modes along with a short description:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱中展示的技术基于Philip Rideout在博客文章中发布的技术：[prideout.net/blog/?p=54](http://prideout.net/blog/?p=54)。他的实现使用两个遍历（基础几何和轮廓），并包括许多优化，如抗锯齿和自定义深度测试（使用g缓冲区）。为了保持简单，因为我们的主要目标是展示几何着色器的功能，我们将使用单遍历实现该技术，不使用抗锯齿或自定义深度测试。如果您有兴趣添加这些附加功能，请参阅Philip出色的博客文章。几何着色器最重要的特性之一是它允许我们提供除正在渲染的基本形状之外的其他顶点信息。当OpenGL中引入几何着色器时，还引入了几个额外的原始形状渲染模式。这些**相邻模式**允许将额外的顶点数据与每个原始形状关联。通常，这些附加信息与网格中附近的原始形状相关，但这不是必需的（如果需要，我们可以实际上将附加信息用于其他目的）。以下列表包括相邻模式及其简要描述：
- en: '`GL_LINES_ADJACENCY`: This mode defines lines with adjacent vertices (four
    vertices per line segment)'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GL_LINES_ADJACENCY`：此模式定义了带有相邻顶点的线条（每条线段四个顶点）'
- en: '`GL_LINE_STRIP_ADJACENCY`: This mode defines a line strip with adjacent vertices
    (for *n* lines, there are *n+3* vertices)'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GL_LINE_STRIP_ADJACENCY`：此模式定义了一个带有相邻顶点的线带（对于*n*条线，提供了*n+3*个顶点）'
- en: '`GL_TRIANGLES_ADJACENCY`: This mode defines triangles along with vertices of
    adjacent triangles (six vertices per primitive)'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GL_TRIANGLES_ADJACENCY`：此模式定义了三角形以及相邻三角形的顶点（每个基本形状六个顶点）'
- en: '`GL_TRIANGLE_STRIP_ADJACENCY`: This mode defines a triangle strip along with
    vertices of adjacent triangles (for *n* triangles, there are *2(n+2)* vertices
    provided)'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GL_TRIANGLE_STRIP_ADJACENCY`：此模式定义了一个三角形带以及相邻三角形的顶点（对于*n*个三角形，提供了*2(n+2)*个顶点）'
- en: 'For full details on each of these modes, check out the official OpenGL documentation.
    In this recipe, we''ll use the `GL_TRIANGLES_ADJACENCY` mode to provide information
    about adjacent triangles in our mesh. With this mode, we provide six vertices
    per primitive. The following diagram illustrates the locations of these vertices:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这些模式的详细信息，请查看官方OpenGL文档。在本食谱中，我们将使用`GL_TRIANGLES_ADJACENCY`模式来提供关于我们的网格中相邻三角形的详细信息。使用此模式，我们为每个基本形状提供六个顶点。以下图示说明了这些顶点的位置：
- en: '![](img/66d81906-1fe1-4b06-99ef-59f9a8992c80.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](img/66d81906-1fe1-4b06-99ef-59f9a8992c80.png)'
- en: In the preceding diagram, the solid line represents the triangle itself, and
    the dotted lines represent adjacent triangles. The first, third, and fifth vertices
    (**0**, **2**, and **4**) make up the triangle itself. The second, fourth, and
    sixth are vertices that make up the adjacent triangles.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，实线代表三角形本身，虚线代表相邻的三角形。第一个、第三个和第五个顶点（**0**、**2**和**4**）构成了三角形本身。第二个、第四个和第六个是构成相邻三角形的顶点。
- en: Mesh data is not usually provided in this form, so we need to preprocess our
    mesh to include the additional vertex information. Typically, this only means
    expanding the element index array by a factor of two. The position, normal, and
    texture coordinate arrays can remain unchanged.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 网格数据通常不以这种形式提供，因此我们需要预处理我们的网格以包含额外的顶点信息。通常，这仅意味着将元素索引数组扩展两倍。位置、法线和纹理坐标数组可以保持不变。
- en: When a mesh is rendered with adjacency information, the geometry shader has
    access to all six vertices associated with a particular triangle. We can then
    use the adjacent triangles to determine whether a triangle edge is part of the
    silhouette of the object. The basic assumption is that an edge is a silhouette
    edge if the triangle is front-facing and the corresponding adjacent triangle is
    not front-facing.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个网格带有相邻信息渲染时，几何着色器可以访问与特定三角形相关联的所有六个顶点。然后我们可以使用相邻三角形来确定三角形边是否是物体轮廓的一部分。基本假设是，如果一个三角形面向前方且相应的相邻三角形不面向前方，则边是轮廓边缘。
- en: 'We can determine whether a triangle is front-facing within the geometry shader
    by computing the triangle''s normal vector (using a cross product). If we are
    working within eye coordinates (or clip coordinates), the *z* coordinate of the
    normal vector will be positive for front-facing triangles. Therefore, we only
    need to compute the *z* coordinate of the normal vector, which should save a few
    cycles. For a triangle with vertices *A*, *B*, and *C*, the *z* coordinate of
    the normal vector is given by the following equation:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在几何着色器中通过计算三角形法向量（使用叉积）来确定三角形是否面向前方。如果我们正在眼坐标（或裁剪坐标）内工作，法向量的*Z*坐标对于面向前方的三角形将是正的。因此，我们只需要计算法向量的*Z*坐标，这应该可以节省几个周期。对于一个顶点为*A*、*B*和*C*的三角形，法向量的*Z*坐标由以下方程给出：
- en: '![](img/18f15f0e-3e95-4434-b8f9-f27ccfbf3c51.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/18f15f0e-3e95-4434-b8f9-f27ccfbf3c51.png)'
- en: Once we determine which edges are silhouette edges, the geometry shader will
    produce additional skinny quads aligned with the silhouette edge. These quads,
    taken together, will make up the desired dark lines (refer to the previous figure).
    After generating all the silhouette quads, the geometry shader will output the
    original triangle.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定哪些是轮廓边缘，几何着色器将生成与轮廓边缘对齐的额外瘦四边形。这些四边形合在一起将构成所需的暗线（参考前面的图）。在生成所有轮廓四边形后，几何着色器将输出原始三角形。
- en: In order to render the mesh in a single pass with appropriate shading for the
    base mesh, and no shading for the silhouette lines, we'll use an additional output
    variable. This variable will let the fragment shader know when we are rendering
    the base mesh and when we are rendering the silhouette edge.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在单次遍历中渲染网格，并对基础网格进行适当的着色，而对轮廓线不进行着色，我们将使用一个额外的输出变量。这个变量将让片段着色器知道我们是在渲染基础网格还是在渲染轮廓边缘。
- en: Getting ready
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Set up your mesh data so that adjacency information is included. As just mentioned,
    this probably requires expanding the element index array to include the additional
    information. This can be done by passing through your mesh and looking for shared
    edges. Due to space limitations, we won''t go through the details here, but the
    blog post mentioned some time back has some information about how this might be
    done. Also, the source code for this example contains a simple (albeit not very
    efficient) technique. The important uniform variables for this example are as
    follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 设置你的网格数据，以便包含相邻信息。正如刚才提到的，这可能需要扩展元素索引数组以包含附加信息。这可以通过遍历你的网格并寻找共享边缘来实现。由于空间限制，我们不会在这里详细介绍，但之前提到的博客文章中提供了一些关于如何实现这一点的信息。此外，本例的源代码包含了一种简单（尽管效率不高）的技术。本例中重要的统一变量如下：
- en: '`EdgeWidth`: This is the width of the silhouette edge in clip (normalized device)
    coordinates'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EdgeWidth`：这是轮廓边缘在裁剪（归一化设备）坐标中的宽度'
- en: '`PctExtend`: This is a percentage to extend the quads beyond the edge'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PctExtend`：这是扩展四边形超出边缘的百分比'
- en: '`LineColor`: This is the color of the silhouette edge lines'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LineColor`：这是轮廓边缘线的颜色'
- en: As usual, there are also the appropriate uniforms for the shading model, and
    the standard matrices.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，还有适当的着色模型统一变量和标准矩阵。
- en: How to do it...
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To create a shader program that utilizes the geometry shader to render silhouette
    edges, use the following steps:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个利用几何着色器渲染轮廓边缘的着色器程序，请按照以下步骤操作：
- en: 'Use the following code for the vertex shader:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码进行顶点着色器：
- en: '[PRE13]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Use the following code for the geometry shader:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码进行几何着色器：
- en: '[PRE14]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Use the following code for the fragment shader:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码进行片段着色器：
- en: '[PRE15]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The vertex shader is a simple *passthrough* shader. It converts the vertex position
    and normal to camera coordinates and sends them along, via `VPosition` and `VNormal`.
    These will be used for shading within the fragment shader and will be passed along
    (or ignored) by the geometry shader. The position is also converted to clip coordinates
    (or normalized device coordinates) by transforming with the model-view projection
    matrix, and it is then assigned to the built-in `gl_Position`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色器是一个简单的 *passthrough* 着色器。它将顶点位置和法线转换为相机坐标，并通过 `VPosition` 和 `VNormal` 将它们发送出去。这些将在片段着色器中进行着色，并将由几何着色器传递（或忽略）。位置也通过模型视图投影矩阵转换成裁剪坐标（或归一化设备坐标），然后分配给内置的
    `gl_Position`。
- en: 'The geometry shader begins by defining the input and output primitive types
    using the layout directive:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 几何着色器首先使用布局指令定义输入和输出原语类型：
- en: '[PRE16]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This indicates that the input primitive type is triangles with adjacency information,
    and the output type is triangle strips. This geometry shader will produce a single
    triangle (the original triangle) and at most one quad for each edge. This corresponds
    to a maximum of 15 vertices that could be produced, and we indicate that maximum
    within the output layout directive.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示输入原语类型是具有相邻信息的三角形，输出类型是三角形带。此几何着色器将生成一个三角形（原始三角形）和最多一个与每条边对应的四边形。这对应于最多可以生成的
    15 个顶点，我们在输出布局指令中指示了最大值。
- en: The `GIsEdge` output variable is used to indicate to the fragment shader whether
    or not the polygon is an edge quad. The fragment shader will use this value to
    determine whether to shade the polygon. There is no need to interpolate the value
    and since it is a Boolean, interpolation doesn't quite make sense, so we use the
    `flat` qualifier.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`GIsEdge` 输出变量用于指示片段着色器该多边形是否为边四边形。片段着色器将使用此值来确定是否着色该多边形。无需插值此值，因为它是一个布尔值，插值并不完全有意义，所以我们使用
    `flat` 限定符。'
- en: The first few lines within the `main` function take the position for each of
    the six vertices (in clip coordinates) and divide it by the fourth coordinate
    in order to convert it from its homogeneous representation to the true Cartesian
    value. This is necessary if we are using a perspective projection, but is not
    necessary for orthographic projections.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 函数中的前几行取六个顶点（在裁剪坐标中）的位置，并将其除以第四个坐标，以便将其从齐次表示转换为真正的笛卡尔值。如果我们使用透视投影，这是必要的，但对于正交投影则不是必要的。'
- en: Next, we determine whether the main triangle (defined by points `0`, `2`, and
    `4`) is front-facing. The `isFrontFacing` function returns whether the triangle
    defined by its three parameters is front-facing using the equation described previously.
    If the main triangle is front-facing, we will emit a silhouette edge quad only
    if the adjacent triangle is not front-facing.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们确定由点 `0`、`2` 和 `4` 定义的三角形是否为正面三角形。`isFrontFacing` 函数返回由其三个参数定义的三角形是否为正面三角形，使用之前描述的方程。如果主三角形是正面三角形，则只有在相邻三角形不是正面三角形时，我们才会发出轮廓边四边形。
- en: The `emitEdgeQuad` function produces a quad that is aligned with an edge defined
    by the `e0` and `e1` points. It begins by computing `ext`, which is the vector
    from `e0` to `e1`, scaled by `PctExtend` (in order to slightly lengthen the edge
    quad). We lengthen the edge quad in order to cover gaps that may appear between
    quads (we'll discuss this further in *There's more...*).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`emitEdgeQuad` 函数生成一个与由 `e0` 和 `e1` 点定义的边对齐的四边形。它首先计算 `ext`，这是从 `e0` 到 `e1`
    的向量，并按 `PctExtend` 缩放（为了稍微延长边四边形）。我们延长边四边形是为了覆盖四边形之间可能出现的间隙（我们将在 *还有更多...* 中进一步讨论）。'
- en: Note also that we drop the *z* coordinate here. As the points are defined in
    clip coordinates, and we are going to produce a quad that is aligned with the
    x-y plane (facing the camera), we want to compute the positions of the vertices
    by translating within the x-y plane. Therefore we can ignore the *z* coordinate
    for now. We'll use its value unchanged in the final position of each vertex.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在这里省略了 *z* 坐标。因为点是在裁剪坐标中定义的，我们打算生成一个与 x-y 平面（面向相机）对齐的四边形，所以我们想通过在 x-y 平面内平移来计算顶点的位置。因此，我们现在可以忽略
    *z* 坐标。我们将在每个顶点的最终位置中使用其值不变。
- en: 'Next, the `v` variable is assigned to the normalized vector from `e0` to `e1`.
    The `n` variable gets a vector that is perpendicular to `v` (in 2D, this can be
    achieved by swapping the *x* and *y* coordinates and negating the new *x* coordinate).
    This is just a counter-clockwise 90-degree rotation in 2D. We scale the `n` vector
    by `EdgeWidth` because we want the length of the vector to be the same as the
    width of the quad. The `ext` and `n` vectors will be used to determine the vertices
    of the quad, as shown in the following diagram:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，变量 `v` 被赋值为从 `e0` 到 `e1` 的归一化向量。变量 `n` 获得一个垂直于 `v` 的向量（在二维中，这可以通过交换 *x*
    和 *y* 坐标并取新 *x* 坐标的相反数来实现）。这只是在二维中的逆时针90度旋转。我们通过 `EdgeWidth` 缩放 `n` 向量，因为我们希望向量的长度与四边形的宽度相同。`ext`
    和 `n` 向量将用于确定四边形的顶点，如下面的图所示：
- en: '![](img/c7c319c1-d834-485f-ae6a-5cccc4cfd2dd.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c7c319c1-d834-485f-ae6a-5cccc4cfd2dd.png)'
- en: The four corners of the quad are given by **e0 - ext**, **e0 - n - ext**, **e1
    + ext**, and **e1 - n + ext**. The *z* coordinate for the lower two vertices is
    the same as the *z* coordinate for **e0**, and the *z* coordinate for the upper
    two vertices is the *z* coordinate for **e1**.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 四边形的四个角由 **e0 - ext**、**e0 - n - ext**、**e1 + ext** 和 **e1 - n + ext** 给出。下两个顶点的
    *z* 坐标与 **e0** 的 *z* 坐标相同，上两个顶点的 *z* 坐标与 **e1** 的 *z* 坐标相同。
- en: We then finish up the `emitEdgeQuad` function by setting `GIsEdge` to `true`
    in order to let the fragment shader know that we are rendering a silhouette edge,
    and then emitting the four vertices of the quad. The function ends with a call
    to `EndPrimitive` to terminate the processing of the triangle strip for the quad.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们通过将 `GIsEdge` 设置为 `true` 来完成 `emitEdgeQuad` 函数，以便让片段着色器知道我们正在渲染轮廓边缘，然后发出四边形的四个顶点。函数通过调用
    `EndPrimitive` 来终止四边形三角形带的处理。
- en: Back within the `main` function, after producing the silhouette edges, we proceed
    by emitting the original triangle unchanged. `VNormal`, `VPosition`, and `gl_Position`
    for vertices `0`, `2`, and `4` are passed along without any modification to the
    fragment shader. Each vertex is emitted with a call to `EmitVertex`, and the primitive
    is completed with `EndPrimitive`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 函数中，在生成轮廓边缘之后，我们继续发出原始三角形，保持不变。顶点 `0`、`2` 和 `4` 的 `VNormal`、`VPosition`
    和 `gl_Position` 传递给片段着色器时没有任何修改。每个顶点通过调用 `EmitVertex` 发出，并通过 `EndPrimitive` 完成原语。
- en: Within the fragment shader, we either shade the fragment (using the toon shading
    algorithm), or simply give the fragment a constant color. The `GIsEdge` input
    variable will indicate which option to choose. If `GIsEdge` is `true`, then we
    are rendering a silhouette edge so the fragment is given the line color. Otherwise,
    we are rendering a mesh polygon, so we shade the fragment using the toon shading
    technique from [Chapter 4](343fbd70-0012-4449-afe6-a724b330b441.xhtml), *Lighting
    and Shading*.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在片段着色器中，我们要么着色片段（使用卡通着色算法），要么简单地给片段一个恒定颜色。`GIsEdge` 输入变量将指示选择哪个选项。如果 `GIsEdge`
    是 `true`，那么我们正在渲染轮廓边缘，因此片段被赋予线条颜色。否则，我们正在渲染网格多边形，因此我们使用第4章中描述的卡通着色技术来着色片段，即 *光照和着色*。
- en: There's more...
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'One of the problems with the preceding technique is that **feathering** can
    occur due to the gaps between consecutive edge quads:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 前述技术的一个问题是，由于连续边缘四边形之间的间隙，可能会出现 **羽化** 现象：
- en: '![](img/b429c478-28a1-4a3a-8d84-953af16a5857.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b429c478-28a1-4a3a-8d84-953af16a5857.png)'
- en: The preceding diagram shows the feathering of a silhouette edge. The gaps between
    the polygons can be filled with triangles, but in our example, we simply extend
    the length of each quad to fill in the gap. This can, of course, cause artifacts
    if the quads are extended too far, but in practice they haven't been very distracting
    in my experience.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图显示了轮廓边缘的羽化。多边形之间的间隙可以用三角形填充，但在我们的例子中，我们只是简单地扩展每个四边形的长度来填充间隙。当然，如果四边形扩展得太远，这可能会引起伪影，但在实践中，我的经验是它们并没有非常分散注意力。
- en: 'A second issue is related to depth testing. If an edge polygon extends into
    another area of the mesh, it can be clipped due to the depth test. The following
    is an example:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题与深度测试有关。如果一个边缘多边形扩展到网格的另一个区域，它可能会因为深度测试而被裁剪。以下是一个例子：
- en: '![](img/122f9288-2a45-42f8-9d84-4766a7737c9f.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/122f9288-2a45-42f8-9d84-4766a7737c9f.png)'
- en: The edge polygon should extend vertically throughout the middle of the preceding
    image, but is clipped because it falls behind the part of the mesh that is nearby.
    This issue can be solved by using custom depth testing when rendering the silhouette
    edges. Refer to Philip Rideout's blog post mentioned earlier for details on this
    technique. It may also be possible to turn depth testing off when rendering the
    edges, being careful not to render any edges from the opposite side of the model.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 边缘多边形应垂直延伸到前一个图像的中间，但由于它位于附近的网格部分之后而被裁剪。可以通过在渲染轮廓边缘时使用自定义深度测试来解决此问题。有关此技术的详细信息，请参阅前面提到的Philip
    Rideout的博客文章。在渲染边缘时关闭深度测试也可能可行，但要小心不要渲染模型另一侧的任何边缘。
- en: See also
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter07/scenesilhouette.cpp` file in the example code
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的`chapter07/scenesilhouette.cpp`文件
- en: 'A whitepaper on using the geometry shader for fur and fins: [http://developer.download.nvidia.com/whitepapers/2007/SDK10/FurShellsAndFins.pdf](http://developer.download.nvidia.com/whitepapers/2007/SDK10/FurShellsAndFins.pdf)'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于使用几何着色器进行毛皮和鳍的白皮书：[http://developer.download.nvidia.com/whitepapers/2007/SDK10/FurShellsAndFins.pdf](http://developer.download.nvidia.com/whitepapers/2007/SDK10/FurShellsAndFins.pdf)
- en: The *Creating shadows using shadow volumes and the geometry shader* recipe in
    [Chapter 8](43239816-a842-483f-9eca-284f919d0bd6.xhtml), *Shadows*
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第8章中创建阴影体积和几何着色器阴影的配方，*阴影*，[第8章](43239816-a842-483f-9eca-284f919d0bd6.xhtml)
- en: The *Creating a cartoon shading effect* recipe in [Chapter 4](343fbd70-0012-4449-afe6-a724b330b441.xhtml),
    *Lighting and Shading*
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第4章中创建卡通阴影效果的配方，*光照与阴影*，[第4章](343fbd70-0012-4449-afe6-a724b330b441.xhtml)
- en: Tessellating a curve
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 曲线镶嵌
- en: 'In this recipe, we''ll take a look at the basics of tessellation shaders by
    drawing a **cubic Bezier curve**. A Bezier curve is a parametric curve defined
    by four control points. The control points define the overall shape of the curve.
    The first and last of the four points define the start and end of the curve, and
    the middle points guide the shape of the curve, but do not necessarily lie directly
    on the curve itself. The curve is defined by interpolating the four control points
    using a set of **blending functions**. The blending functions define how much
    each control point contributes to the curve for a given position along the curve.
    For Bezier curves, the blending functions are known as the **Bernstein polynomials**:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将通过绘制**立方贝塞尔曲线**来查看镶嵌着色器的基础。贝塞尔曲线是由四个控制点定义的参数曲线。控制点定义了曲线的整体形状。四个点中的第一个和最后一个定义了曲线的开始和结束，中间的点引导曲线的形状，但不必直接位于曲线本身上。曲线是通过使用一组**混合函数**插值四个控制点来定义的。混合函数定义了每个控制点对曲线给定位置的贡献程度。对于贝塞尔曲线，混合函数被称为**伯恩斯坦多项式**：
- en: '![](img/d3216e61-ff68-42d1-b1da-bd7b83d8b158.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d3216e61-ff68-42d1-b1da-bd7b83d8b158.png)'
- en: 'In the preceding equation, the first term is the binomial coefficient function
    (shown in the following equation), **n** is the degree of the polynomial, **i**
    is the polynomial number, and **t** is the parametric parameter:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个方程中，第一项是二项式系数函数（如下所示），**n** 是多项式的次数，**i** 是多项式的编号，**t** 是参数参数：
- en: '![](img/3af2d66d-2378-40b9-b401-cabd3ffef959.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3af2d66d-2378-40b9-b401-cabd3ffef959.png)'
- en: 'The general parametric form for the Bezier curve is then given as a sum of
    the products of the Bernstein polynomials with the control points (**P[i]**):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 贝塞尔曲线的一般参数形式是伯恩斯坦多项式与控制点（**P[i]**）的乘积之和：
- en: '![](img/29024019-198d-4c49-9596-f9cfb163f289.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/29024019-198d-4c49-9596-f9cfb163f289.png)'
- en: 'In this example, we will draw a cubic Bezier curve, which involves four control
    points (*n = 3*):'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将绘制一个立方贝塞尔曲线，这涉及到四个控制点（*n = 3*）：
- en: '![](img/64cbe72d-f2f3-460f-9cc9-1704887d79c2.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/64cbe72d-f2f3-460f-9cc9-1704887d79c2.png)'
- en: 'And the cubic Bernstein polynomials are:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 立方贝塞尔多项式如下：
- en: '![](img/be67b6ba-69c0-4acc-b75b-34ab38eccbc8.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/be67b6ba-69c0-4acc-b75b-34ab38eccbc8.png)'
- en: 'As stated in the introduction to this chapter, the tessellation functionality
    within OpenGL involves two shader stages. They are the tessellation control shader
    (TCS) and the tessellation evaluation shader (TES). In this example, we''ll define
    the number of line segments for our Bezier curve within the TCS (by defining the
    outer tessellation levels), and evaluate the Bezier curve at each particular vertex
    location within the TES. The following image shows the output of this example
    for three different tessellation levels. The left figure uses three line segments
    (level 3), the middle uses level 5, and the right-hand figure is created with
    tessellation level 30\. The small squares are the control points:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章引言所述，OpenGL 中的镶嵌功能涉及两个着色器阶段。它们是镶嵌控制着色器（TCS）和镶嵌评估着色器（TES）。在这个例子中，我们将在 TCS
    中定义我们的贝塞尔曲线的线段数量（通过定义外镶嵌级别），并在 TES 中评估每个特定顶点位置处的贝塞尔曲线。以下图像显示了本例三个不同镶嵌级别的输出。左图使用三个线段（级别3），中间使用级别5，右图使用镶嵌级别30。小方块是控制点：
- en: '![](img/020120fe-cf25-457f-9d36-caf299c6efe7.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/020120fe-cf25-457f-9d36-caf299c6efe7.png)'
- en: The control points for the Bezier curve are sent down the pipeline as a patch
    primitive consisting of four vertices. A patch primitive is a programmer-defined
    primitive type. Basically, it is a set of vertices that can be used for anything
    that the programmer chooses. The TCS is executed once for each vertex within the
    patch, and the TES is executed, a variable number of times, depending on the number
    of vertices produced by the TPG. The final output of the tessellation stages is
    a set of primitives. In our case, it will be a line strip.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 贝塞尔曲线的控制点作为由四个顶点组成的补丁原语发送到管线中。补丁原语是程序员定义的原语类型。基本上，它是一组可以用于程序员选择的任何事物的顶点集。TCS
    对补丁内的每个顶点执行一次，TES 根据TPG 生成的顶点数量，以变量次数执行。镶嵌阶段的最终输出是一组原语。在我们的例子中，它将是一条线段。
- en: Part of the job of the TCS is to define the tessellation level. In very rough
    terms, the tessellation level is related to the number of vertices that will be
    generated. In our case, the TCS will be generating a line strip, so the tessellation
    level is the number of line segments in the line strip. Each vertex that is generated
    for this line strip will be associated with a tessellation coordinate that will
    vary between zero and one. We'll refer to this as the *u* coordinate, and it will
    correspond to the parametric *t* parameter in the preceding Bezier curve equation.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: TCS 的一部分工作是定义镶嵌级别。非常粗略地说，镶嵌级别与将要生成的顶点数量相关。在我们的例子中，TCS 将生成一条线段，所以镶嵌级别是线段中的线段数量。为这条线段生成的每个顶点都将与一个在零到一之间变化的镶嵌坐标相关联。我们将称之为
    *u* 坐标，它将对应于前面贝塞尔曲线方程中的参数 *t*。
- en: What we've looked at so far is not, in fact, the whole story. Actually, the
    TCS will trigger the generation of a set of line strips called isolines. Each
    vertex in this set of isolines will have a *u* and a *v* coordinate. The *u* coordinate
    will vary from zero to one along a given isoline, and *v* will be constant for
    each isoline. The number of distinct values of *u* and *v* is associated with
    two separate tessellation levels, the so-called *outer* levels. For this example,
    however, we'll only generate a single line strip, so the second tessellation level
    (for *v*) will always be one.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止所看到的内容并不是整个故事。实际上，TCS 将触发生成一组称为等值线的线段。这个等值线集中的每个顶点都将有一个 *u* 和一个 *v* 坐标。*u*
    坐标将在给定的等值线上从零变到一，而 *v* 对于每个等值线将是常数。*u* 和 *v* 的不同值与两个单独的镶嵌级别相关联，所谓的 *外* 级别。然而，对于这个例子，我们只会生成一条线段，所以第二个镶嵌级别（对于
    *v*）将始终为1。
- en: Within the TES, the main task is to determine the position of the vertex associated
    with this execution of the shader. We have access to the *u* and *v* coordinates
    associated with the vertex, and we also have (read-only) access to all of the
    vertices of the patch. We can then determine the appropriate position for the
    vertex by using the parametric equation, with *u* as the parametric coordinate
    (*t* in the preceding equation).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TES 中，主要任务是确定与此次着色器执行相关的顶点的位置。我们可以访问与顶点相关的 *u* 和 *v* 坐标，我们还可以（只读）访问补丁中所有顶点。然后我们可以通过使用参数方程，以
    *u* 作为参数坐标（前面方程中的 *t*），来确定顶点的适当位置。
- en: Getting ready
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The following are the important uniform variables for this example:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为本例重要的统一变量：
- en: '`NumSegments`: This is the number of line segments to be produced.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NumSegments`：这是要生成的线段数量。'
- en: '`NumStrips`: This is the number of isolines to be produced. For this example,
    this should be set to `1`.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NumStrips`：这是要生成的等值线的数量。对于这个例子，这个值应该设置为`1`。'
- en: '`LineColor`: This is the color for the resulting line strip.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LineColor`：这是结果线条的颜色。'
- en: Set the uniform variables within the main OpenGL application. There are a total
    of four shaders to be compiled and linked. They are the vertex, fragment, tessellation
    control, and tessellation evaluation shaders.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在主OpenGL应用程序中设置统一变量。总共有四个着色器需要编译和链接。它们是顶点、片段、细分控制以及细分评估着色器。
- en: How to do it...
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To create a shader program that will generate a Bezier curve from a patch of
    four control points, use the following steps:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个从四个控制点组成的补丁生成贝塞尔曲线的着色器程序，请按照以下步骤操作：
- en: 'Use the following code for the vertex shader. Note that we send the vertex
    position along to the TCS unmodified:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码作为顶点着色器。请注意，我们将顶点位置原封不动地发送到TCS：
- en: '[PRE17]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Use the following code as the tessellation control shader:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码作为细分控制着色器：
- en: '[PRE18]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Use the following code as the tessellation evaluation shader:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码作为细分评估着色器：
- en: '[PRE19]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Use the following code for the fragment shader:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码作为片段着色器：
- en: '[PRE20]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'It is important to define the number of vertices per patch within the OpenGL
    application. You can do so using the `glPatchParameter` function:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在OpenGL应用程序中定义每个补丁的顶点数是很重要的。您可以使用`glPatchParameter`函数来完成此操作：
- en: '[PRE21]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Render the four control points as a patch primitive within the OpenGL application''s
    `render` function:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在OpenGL应用程序的`render`函数中将四个控制点作为补丁原语渲染：
- en: '[PRE22]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works...
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The vertex shader is just a passthrough shader. It sends the vertex position
    along to the next stage without any modification.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色器只是一个传递着色器。它将顶点位置原封不动地传递到下一个阶段。
- en: 'The tessellation control shader begins by defining the number of vertices in
    the output patch:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 细分控制着色器首先定义输出补丁中的顶点数：
- en: '[PRE23]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note that this is not the same as the number of vertices that will be produced
    by the tessellation process. In this case, the patch is our four control points,
    so we use a value of four.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这不同于由细分过程产生的顶点数量。在这种情况下，补丁是我们的四个控制点，所以我们使用`4`这个值。
- en: The main method within the TCS passes the input position (of the patch vertex)
    to the output position without modification. The `gl_out` and `gl_in` arrays contain
    the input and output information associated with each vertex in the patch. Note
    that we assign and read from `gl_InvocationID` in these arrays. The `gl_InvocationID`
    variable defines the output patch vertex for which this invocation of the TCS
    is responsible. The TCS can access all of the `gl_in` array, but should only write
    to the location in `gl_out` corresponding to `gl_InvocationID`. The other indices
    will be written by other invocations of the TCS.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: TCS中的主方法将输入位置（补丁顶点的位置）原封不动地传递到输出位置。`gl_out`和`gl_in`数组包含与补丁中每个顶点相关的输入和输出信息。请注意，我们在这些数组中分配和读取`gl_InvocationID`。`gl_InvocationID`变量定义了TCS负责的输出补丁顶点。TCS可以访问`gl_in`数组中的所有内容，但应该只写入对应于`gl_InvocationID`的`gl_out`中的位置。其他索引将由TCS的其他调用写入。
- en: Next, the TCS sets the tessellation levels by assigning to the `gl_TessLevelOuter`
    array. Note that the values for `gl_TessLevelOuter` are floating point numbers
    rather than integers. They will be rounded up to the nearest integer and clamped
    automatically by the OpenGL system.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，TCS通过将值分配给`gl_TessLevelOuter`数组来设置细分级别。请注意，`gl_TessLevelOuter`的值是浮点数而不是整数。它们将被四舍五入到最接近的整数，并由OpenGL系统自动夹断。
- en: The first element in the array defines the number of isolines that will be generated.
    Each isoline will have a constant value for `v`. In this example, the value of
    `gl_TessLevelOuter[0]` should be one since we only want to create a single curve.
    The second one defines the number of line segments that will be produced in the
    line strip. Each vertex in the strip will have a value for the parametric `u`
    coordinate that will vary from zero to one.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的第一个元素定义了将生成的等值线的数量。每条等值线对于`v`的值都是恒定的。在这个例子中，`gl_TessLevelOuter[0]`的值应该为`1`，因为我们只想创建一条曲线。第二个定义了将在线条中产生的线段数量。条纹中的每个顶点都将有一个从零到一的参数`u`坐标的值。
- en: 'In the TES, we start by defining the input primitive type using a `layout`
    declaration:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在TES中，我们首先使用`layout`声明来定义输入原语类型：
- en: '[PRE24]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This indicates the type of subdivision that is performed by the tessellation
    primitive generator. Other possibilities here include `quads` and `triangles`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示细分原语生成器执行的细分类型。其他可能性包括 `quads` 和 `triangles`。
- en: Within the `main` function of the TES, the `gl_TessCoord` variable contains
    the tessellation's `u` and `v` coordinates for this invocation. As we are only
    tessellating in one dimension, we only need the `u` coordinate, which corresponds
    to the *x* coordinate of `gl_TessCoord`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TES 的 `main` 函数中，`gl_TessCoord` 变量包含此调用中细分图的 `u` 和 `v` 坐标。由于我们只在一维上进行细分，我们只需要
    `u` 坐标，它对应于 `gl_TessCoord` 的 *x* 坐标。
- en: The next step accesses the positions of the four control points (all the points
    in our patch primitive). These are available in the `gl_in` array.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是访问四个控制点的位置（我们补丁原语中的所有点）。这些位置在 `gl_in` 数组中可用。
- en: The cubic Bernstein polynomials are then evaluated at `u` and stored in `b0`,
    `b1`, `b2`, and `b3`. Next, we compute the interpolated position using the Bezier
    curve equation. The final position is converted to clip coordinates and assigned
    to the `gl_Position` output variable.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 立方贝塞尔多项式在 `u` 处评估，并存储在 `b0`、`b1`、`b2` 和 `b3` 中。接下来，我们使用贝塞尔曲线方程计算插值位置。最终位置转换为裁剪坐标，并分配给
    `gl_Position` 输出变量。
- en: The fragment shader simply applies `LineColor` to the fragment.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 片段着色器简单地应用 `LineColor` 到片段上。
- en: There's more...
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There's a lot more to be said about tessellation shaders, but this example is
    intended to be a simple introduction so we'll leave that for the following recipes.
    Next, we'll look at tessellation across surfaces in two dimensions.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 关于细分着色器还有很多可以说的，但这个例子旨在提供一个简单的介绍，所以我们将留到后面的食谱中。接下来，我们将探讨二维表面上的细分。
- en: See also
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter07/scenebezcurve.cpp` file in the example code
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的 `chapter07/scenebezcurve.cpp` 文件
- en: Tessellating a 2D quad
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 细分 2D 四边形
- en: One of the best ways to understand OpenGL's hardware tessellation is to visualize
    the tessellation of a 2D quad. When linear interpolation is used, the triangles
    that are produced are directly related to the tessellation coordinates (u,v) that
    are produced by the tessellation primitive generator. It can be extremely helpful
    to draw a few quads with different inner and outer tessellation levels, and study
    the triangles produced. We will do exactly that in this recipe.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 OpenGL 的硬件细分的一个最好的方法是通过可视化 2D 四边形的细分。当使用线性插值时，产生的三角形与细分原语生成的细分坐标（u,v）直接相关。绘制几个具有不同内部和外部细分级别的四边形，并研究产生的三角形，这可以非常有帮助。我们将在本食谱中做
    exactly that。
- en: 'When using quad tessellation, the tessellation primitive generator subdivides
    (u,v) parameter space into a number of subdivisions based on six parameters. These
    are the inner tessellation levels for `u` and `v` (inner level 0 and inner level
    1), and the outer tessellation levels for `u` and `v` along both edges (outer
    levels 0 to 3). These determine the number of subdivisions along the edges of
    the parameter space and internally. Let''s look at each of these individually:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用四边形细分时，细分原语生成器根据六个参数将 (u,v) 参数空间细分为多个细分。这些是 `u` 和 `v` 的内部细分级别（内部级别 0 和内部级别
    1），以及沿着两个边的外部细分级别（外部级别 0 到 3）。这些决定了参数空间边沿和内部的细分数量。让我们分别看看这些：
- en: '**Outer level 0 (OL0)**: This is the number of subdivisions along the *v* direction
    where *u = 0*'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外层级别 0 (OL0)**: 这是沿着 *v* 方向的细分数量，其中 *u = 0*'
- en: '**Outer level 1 (OL1)**: This is the number of subdivisions along the *u* direction
    where *v = 0*'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外层级别 1 (OL1)**: 这是沿着 *u* 方向的细分数量，其中 *v = 0*'
- en: '**Outer level 2 (OL2)**: This is the number of subdivisions along the *v* direction
    where *u = 1*'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外层级别 2 (OL2)**: 这是沿着 *v* 方向的细分数量，其中 *u = 1*'
- en: '**Outer level 3 (OL3)**: This is the number of subdivisions along the *u* direction
    where **v = 1**'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外层级别 3 (OL3)**: 这是沿着 *u* 方向的细分数量，其中 **v = 1**'
- en: '**Inner level 0 (IL0)**: This is the number of subdivisions along the *u* direction
    for all internal values of *v*'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内部级别 0 (IL0)**: 这是对于所有内部 *v* 值沿着 *u* 方向的细分数量'
- en: '**Inner level 1 (IL1)**: This is the number of subdivisions along the *v* direction
    for all internal values of *u*'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内部级别 1 (IL1)**: 这是对于所有内部 *u* 值沿着 *v* 方向的细分数量'
- en: 'The following diagram represents the relationship between the tessellation
    levels and the areas of parameter space that are affected by each. The outer levels
    define the number of subdivisions along the edges, and the inner levels define
    the number of subdivisions internally:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表表示细分级别与受影响的参数空间区域之间的关系。外层级别定义了边缘上的细分次数，内层级别定义了内部的细分次数：
- en: '![](img/b7bdb2e0-832e-4cca-a02f-853ccb66980b.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b7bdb2e0-832e-4cca-a02f-853ccb66980b.png)'
- en: The six tessellation levels described some time back can be configured via the `gl_TessLevelOuter`
    and `gl_TessLevelInner` arrays. For example, `gl_TessLevelInner[0]` corresponds
    to **IL0**, `gl_TessLevelOuter[2]` corresponds to **OL2**, and so on.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 之前描述的六个细分级别可以通过`gl_TessLevelOuter`和`gl_TessLevelInner`数组进行配置。例如，`gl_TessLevelInner[0]`对应于**IL0**，`gl_TessLevelOuter[2]`对应于**OL2**，依此类推。
- en: 'If we draw a patch primitive that consists of a single quad (four vertices),
    and use linear interpolation, the triangles that result can help us to understand
    how OpenGL does quad tessellation. The following diagram shows the results for
    various tessellation levels:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们绘制一个由单个四边形（四个顶点）组成的补丁原语，并使用线性插值，生成的三角形可以帮助我们理解OpenGL如何进行四边形细分。以下图表显示了不同细分级别的结果：
- en: '[![](img/3585c185-39d1-44ae-a026-6116257fcbc3.png)]'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](img/3585c185-39d1-44ae-a026-6116257fcbc3.png)]'
- en: When we use linear interpolation, the triangles that are produced represent
    a visual representation of parameter (u, v) space. The *x* axis corresponds to
    the *u* coordinate and the *y* axis corresponds to the *v* coordinate. The vertices
    of the triangles are the (u,v) coordinates generated by the tessellation primitive
    generator. The number of subdivisions can be clearly seen in the mesh of triangles.
    For example, when the outer levels are set to **2** and the inner levels are set
    to **8**, you can see that the outer edges have two subdivisions, but within the
    quad, u and v are subdivided into eight intervals.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用线性插值时，产生的三角形代表参数（u, v）空间的视觉表示。*x*轴对应于*u*坐标，*y*轴对应于*v*坐标。三角形的顶点是细分原语生成的(u,v)坐标。细分次数可以在三角形的网格中清楚地看到。例如，当外层级别设置为**2**，内层级别设置为**8**时，可以看到外边缘有两个细分，但在四边形内部，u和v被细分为八个区间。
- en: 'Before jumping into the code, let''s discuss linear interpolation. If the four
    corners of the quad are as shown in the following figure, then any point within
    the quad can be determined by linearly interpolating the four corners with respect
    to the **u** and **v** parameters:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入代码之前，让我们讨论线性插值。如果四边形的四个角如图所示，那么四边形内的任何点都可以通过相对于**u**和**v**参数进行线性插值来确定：
- en: '![](img/cf0b2180-2719-49b1-bc0f-01f2153c7645.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cf0b2180-2719-49b1-bc0f-01f2153c7645.png)'
- en: We'll let the tessellation-primitive generator create a set of vertices with
    appropriate parametric coordinates, and we'll determine the corresponding positions
    by interpolating the corners of the quad using the preceding equation.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将让细分原语生成具有适当参数坐标的一组顶点，我们将通过使用前面的方程式插值四边形的角来确定相应的位置。
- en: Getting ready
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The outer and inner tessellation levels will be determined by the `Inner` and
    `Outer` uniform variables. In order to display the triangles, we will use the
    geometry shader.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 外部和内部细分级别将由`Inner`和`Outer`统一变量确定。为了显示三角形，我们将使用几何着色器。
- en: Set up your OpenGL application to render a patch primitive consisting of four
    vertices in counterclockwise order, as shown in the previous figure.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 设置你的OpenGL应用程序以渲染一个由四个顶点组成的补丁原语，顺时针方向，如图中所示。
- en: How to do it...
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To create a shader program that will generate a set of triangles using quad
    tessellation from a patch of four vertices, use the following steps:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个着色器程序，该程序将使用四个顶点的补丁进行四边形细分来生成一组三角形，请按照以下步骤操作：
- en: 'Use the following code for the vertex shader:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码作为顶点着色器：
- en: '[PRE25]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Use the following code as the tessellation control shader:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码作为细分控制着色器：
- en: '[PRE26]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Use the following code as the tessellation evaluation shader:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码作为细分评估着色器：
- en: '[PRE27]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Use the geometry shader from the *Drawing a wireframe on top of a shaded mesh* recipe
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用来自*在着色网格上绘制线框*菜谱的几何着色器
- en: 'Use the following code as the fragment shader:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码作为片段着色器：
- en: '[PRE28]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Within the `render` function of your main OpenGL program, define the number
    of vertices within a patch:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的主OpenGL程序的`render`函数中，定义补丁内的顶点数：
- en: '[PRE29]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Render the patch as four 2D vertices in counterclockwise order
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以逆时针顺序渲染补丁为四个2D顶点
- en: How it works...
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The vertex shader passes the position along to the TCS unchanged.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色器将位置原封不动地传递给TCS。
- en: 'The TCS defines the number of vertices in the patch using the layout directive:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: TCS使用布局指令定义了补丁中的顶点数：
- en: '[PRE30]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the `main` function, it passes along the position of the vertex without modification,
    and sets the inner and outer tessellation levels. All four of the outer tessellation
    levels are set to the value of `Outer`, and both of the inner tessellation levels
    are set to `Inner`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，它将顶点的位置原封不动地传递下去，并设置内部和外部素片化级别。所有四个外部素片化级别都设置为`Outer`的值，两个内部素片化级别都设置为`Inner`。
- en: 'In the tessellation evaluation shader, we define the tessellation mode and
    other tessellation parameters with the input layout directive:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在素片评估着色器中，我们使用输入布局指令定义素片化模式和其它素片化参数：
- en: '[PRE31]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `quads` parameter indicates that the tessellation-primitive generator should
    tessellate the parameter space using quad tessellation. The `equal_spacing` parameter
    says that the tessellation should be performed such that all subdivisions have
    equal length. The last parameter, `ccw`, indicates that the primitives should
    be generated with counterclockwise winding.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`quads`参数指示着素片生成器应该使用四边形素片化来对参数空间进行素片化。`equal_spacing`参数表示素片化应该执行，使得所有细分部分具有相等的长度。最后一个参数`ccw`表示素片应该以逆时针方向生成。'
- en: The `main` function in the TES starts by retrieving the parametric coordinates
    for this vertex by accessing the `gl_TessCoord` variable. Then we move on to read
    the positions of the four vertices in the patch from the `gl_in` array. We store
    them in temporary variables to be used in the interpolation calculation.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: TES中的`main`函数首先通过访问`gl_TessCoord`变量来检索此顶点的参数坐标。然后我们继续从`gl_in`数组中读取补丁中的四个顶点的位置。我们将它们存储在临时变量中，以便在插值计算中使用。
- en: The built-in `gl_Position` output variable then gets the value of the interpolated
    point using the preceding equation. Finally, we convert the position into clip
    coordinates by multiplying by the model-view projection matrix.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的`gl_Position`输出变量随后使用前面的方程式获取插值点的值。最后，我们通过乘以模型视图投影矩阵将位置转换为裁剪坐标。
- en: Within the fragment shader, we give all fragments a color that is possibly mixed
    with a line color in order to highlight the edges.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在片段着色器中，我们给所有片段一个颜色，这个颜色可能混合了线条颜色，以便突出边缘。
- en: See also
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter07/scenequadtess.cpp` file in the example code
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的`chapter07/scenequadtess.cpp`文件
- en: The *Drawing a wireframe on top of a shaded mesh* recipe
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在着色网格上绘制线框图*的配方'
- en: Tessellating a 3D surface
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 素片化3D表面
- en: As an example of tessellating a 3D surface, let's render (yet again) the *teapotahedron.*
    It turns out that the teapot's dataset is actually defined as a set of 4 x 4 patches
    of control points, suitable for cubic Bezier interpolation. Therefore, drawing
    the teapot really boils down to drawing a set of cubic Bezier surfaces.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 作为素片化3D表面的一个例子，让我们再次渲染（是的，又是）*茶壶多面体*。结果证明，茶壶的数据集实际上被定义为4 x 4个控制点的集合，适合进行三次贝塞尔插值。因此，绘制茶壶实际上归结为绘制一组三次贝塞尔曲面。
- en: Of course, this sounds like a perfect job for tessellation shaders! We'll render
    each patch of 16 vertices as a patch primitive, use quad tessellation to subdivide
    the parameter space, and implement the Bezier interpolation within the tessellation
    evaluation shader.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这听起来像是素片着色器的完美工作！我们将渲染每个16个顶点的补丁作为补丁原语，使用四边形素片化来细分参数空间，并在素片评估着色器中实现贝塞尔插值。
- en: 'The following image shows an example of the desired output. The left teapot
    is rendered with inner and outer tessellation level 2, the middle uses level 4,
    and the teapot on the right uses tessellation level 16\. The tessellation evaluation
    shader computes the Bezier surface interpolation:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了所需输出的一个示例。左边的茶壶使用了内部和外部素片化级别2，中间的使用了级别4，右边的茶壶使用了素片化级别16。素片评估着色器计算贝塞尔曲面插值：
- en: '![](img/932ce989-229a-448c-9787-af4343d398d6.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/932ce989-229a-448c-9787-af4343d398d6.png)'
- en: 'First, let''s take a look at how cubic Bezier surface-interpolation works.
    If our surface is defined by a set of 16 control points (laid out in a 4 x 4 grid)
    *P[ij]*, with *i* and *j* ranging from 0 to 3, the parametric Bezier surface is
    given by the following equation:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看立方贝塞尔曲面插值是如何工作的。如果我们的曲面由一组16个控制点（以4 x 4网格排列）*P[ij]*定义，其中*i*和*j*的范围从0到3，则参数化贝塞尔曲面由以下方程给出：
- en: '![](img/af432160-f4c7-4a39-bb20-2bfec138a669.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![](img/af432160-f4c7-4a39-bb20-2bfec138a669.png)'
- en: The instances of *B* in the preceding equation are the cubic Bernstein polynomials
    (refer to the previous recipe, *Tessellating a 2D quad*).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 前述方程中的*B*实例是立方伯恩斯坦多项式（参考先前的配方，*Tessellating a 2D quad*）。
- en: 'We also need to compute the normal vector at each interpolated location. To
    do so, we have to compute the cross product of the partial derivatives of the
    preceding equation:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要计算每个插值位置的法向量。为此，我们必须计算前述方程的偏导数的叉积：
- en: '![](img/f6dd88cc-82cd-410e-a09b-d993113c2833.png)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f6dd88cc-82cd-410e-a09b-d993113c2833.png)'
- en: 'The partial derivatives of the Bezier surface boil down to the partial derivatives
    of the Bernstein polynomials:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 贝塞尔曲面的偏导数简化为伯恩斯坦多项式的偏导数：
- en: '![](img/e786e253-d99d-4092-9707-7eb73ce7cb73.png)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e786e253-d99d-4092-9707-7eb73ce7cb73.png)'
- en: We'll compute the partials within the TES and compute the cross product to determine
    the normal to the surface at each tessellated vertex.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在TES内计算偏导数并计算叉积以确定每个细分顶点的曲面法线。
- en: Getting ready
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Set up your shaders with a vertex shader that simply passes the vertex position
    along without any modification (you can use the same vertex shader as was used
    in the *Tessellating a 2D quad* recipe). Create a fragment shader that implements
    whatever shading model you choose. The fragment shader should receive the `TENormal`
    and `TEPosition` input variables, which will be the normal and position in camera
    coordinates.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 设置你的着色器，使用一个顶点着色器，它简单地传递顶点位置而不进行任何修改（你可以使用与*Tessellating a 2D quad*配方中使用的相同的顶点着色器）。创建一个片段着色器，实现你选择的着色模型。片段着色器应该接收`TENormal`和`TEPosition`输入变量，它们将是相机坐标中的法线和位置。
- en: The `TessLevel` uniform variable should be given the value of the desired tessellation
    level. All of the inner and outer levels will be set to this value.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`TessLevel`统一变量应赋予所需细分级别的值。所有内部和外部级别都将设置为该值。'
- en: How to do it...
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create a shader program that creates Bezier patches from input patches of
    16 control points, use the following steps:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个从16个控制点输入的贝塞尔补丁的程序，请按照以下步骤操作：
- en: Use the vertex shader from the *Tessellating a 2D quad* recipe.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*Tessellating a 2D quad*配方中的顶点着色器。
- en: 'Use the following code for the tessellation control shader:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码进行细分控制着色器：
- en: '[PRE32]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Use the following code for the tessellation evaluation shader:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码进行细分评估着色器：
- en: '[PRE33]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Implement your favorite shading model within the fragment shader utilizing the
    output variables from the TES.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在片段着色器中实现你喜欢的着色模型，利用TES的输出变量。
- en: 'Render the Bezier control points as a 16-vertex patch primitive. Don''t forget
    to set the number of vertices per patch within the OpenGL application:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将贝塞尔控制点渲染为16顶点的补丁原语。别忘了在OpenGL应用程序中设置每个补丁的顶点数：
- en: '[PRE34]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How it works...
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The tessellation control shader starts by defining the number of vertices in
    the patch using the layout directive:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 细分控制着色器首先使用布局指令定义补丁中的顶点数：
- en: '[PRE35]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: It then simply sets the tessellation levels to the value of `TessLevel`. It
    passes the vertex position along, without any modification.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它简单地设置细分级别为`TessLevel`的值。它传递顶点位置，不进行任何修改。
- en: The tessellation evaluation shader starts by using a layout directive to indicate
    the type of tessellation to be used. As we are tessellating a 4 x 4 Bezier surface
    patch, quad tessellation makes the most sense.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 细分评估着色器首先使用布局指令来指示要使用的细分类型。由于我们正在细分一个4 x 4的贝塞尔曲面补丁，四边形细分最为合理。
- en: The `basisFunctions` function evaluates the Bernstein polynomials and their
    derivatives for a given value of the `t` parameter. The results are returned in
    the `b` and `db` output parameters.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '`basisFunctions`函数评估给定`t`参数值的伯恩斯坦多项式及其导数。结果返回在`b`和`db`输出参数中。'
- en: Within the `main` function, we start by assigning the tessellation coordinates
    to the `u` and `v` variables, and reassigning all 16 of the patch vertices to
    variables with shorter names (to shorten the code that appears later).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，我们首先将镶嵌坐标分配给`u`和`v`变量，并将所有16个补丁顶点重新分配给具有较短名称的变量（以缩短稍后出现的代码）。
- en: We then call `basisFunctions` to compute the Bernstein polynomials and their
    derivatives at `u` and `v`, storing the results in `bu`, `dbu`, `bv`, and `dbv`.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们调用`basisFunctions`来计算伯恩斯坦多项式及其在`u`和`v`处的导数，并将结果存储在`bu`、`dbu`、`bv`和`dbv`中。
- en: The next step is the evaluation of the sums from the preceding equations for
    the position (`TEPosition`), the partial derivative with respect to `u` (`du`),
    and the partial derivative with respect to `v` (`dv`). We compute the normal vector
    as the cross product of `du` and `dv`.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是评估前面方程中关于位置（`TEPosition`）、关于`u`的偏导数（`du`）和关于`v`的偏导数（`dv`）的总和。我们通过计算`du`和`dv`的叉积来计算法向量。
- en: Finally, we convert the position (`TEPosition`) to clip coordinates and assign
    the result to
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将位置（`TEPosition`）转换为裁剪坐标，并将结果分配给
- en: '`gl_Position`. We also convert it to camera coordinates before it is passed
    along to the fragment shader.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`gl_Position`。我们还在将其传递到片段着色器之前将其转换为摄像机坐标。'
- en: The normal vector is converted to camera coordinates by multiplying it with `NormalMatrix`,
    and the result is normalized and passed along to the fragment shader via `TENormal`.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 通过乘以`NormalMatrix`，将法向量转换为摄像机坐标，并将结果归一化，通过`TENormal`传递到片段着色器。
- en: See also
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter07/scenetessteapot.cpp` file in the example code
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的`chapter07/scenetessteapot.cpp`文件
- en: The *Tessellating a 2D quad* recipe
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*2D四边形的镶嵌*配方'
- en: Tessellating based on depth
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于深度的镶嵌
- en: One of the greatest things about tessellation shaders is how easy it is to implement **level-of-detail**
    (**LOD**) algorithms. LOD is a general term in computer graphics that refers to
    the process of increasing/decreasing the complexity of an object's geometry with
    respect to the distance from the viewer (or other factors). As an object moves
    farther away from the camera, less geometric detail is needed to represent the
    shape because the overall size of the object becomes smaller. However, as the
    object moves closer to the camera, the object fills more and more of the screen,
    and more geometric detail is needed to maintain the desired appearance (smoothness
    or lack of other geometric artifacts).
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 镶嵌着色器最伟大的事情之一就是实现**细节级别**（**LOD**）算法的简单性。LOD是计算机图形学中的一个通用术语，指的是根据观察者（或其他因素）与对象之间的距离增加/减少对象几何复杂性的过程。当对象远离摄像机时，需要更少的几何细节来表示形状，因为对象的总体尺寸变得更小。然而，当对象靠近摄像机时，对象在屏幕上占据的面积越来越大，需要更多的几何细节来保持所需的外观（平滑度或其他几何失真）。
- en: 'The following image shows a few teapots rendered with tessellation levels that
    depend on distance from the camera. Each teapot is rendered using exactly the
    same code on the OpenGL side. The TCS automatically varies the tessellation levels
    based on depth:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了使用基于摄像机距离的镶嵌级别渲染的几个茶壶。每个茶壶在OpenGL端使用完全相同的代码进行渲染。TCS自动根据深度变化镶嵌级别：
- en: '![](img/406640f8-eae1-4876-911c-43b073ea62ba.png)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![](img/406640f8-eae1-4876-911c-43b073ea62ba.png)'
- en: When tessellation shaders are used, the tessellation level is what determines
    the geometric complexity of the object. As the tessellation levels can be set
    within the tessellation control shader, it is a simple matter to vary the tessellation
    levels with respect to the distance from the camera.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用镶嵌着色器时，镶嵌级别决定了对象的几何复杂性。由于镶嵌级别可以在镶嵌控制着色器中设置，因此根据与摄像机的距离变化镶嵌级别是一件简单的事情。
- en: In this example, we'll vary the tessellation levels linearly (with respect to
    distance) between a minimum level and a maximum level. We'll compute the *distance
    from the camera* as the absolute value of the *z* coordinate in camera coordinates,
    (of course, this is not the true distance, but should work fine for the purposes
    of this example). The tessellation level will then be computed based on that value.
    We'll also define two additional values (as uniform variables): `MinDepth` and
    `MaxDepth`. Objects that are closer to the camera than `MinDepth` get the maximum
    tessellation level, and any objects that are further from the camera than `MaxDepth`
    will get the minimum tessellation level. The tessellation level for objects in
    between will be linearly interpolated.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将线性地（相对于距离）在最小级别和最大级别之间变化细分级别。我们将计算**相机到距离**作为相机坐标中**z**坐标的绝对值（当然，这并不是真正的距离，但应该适用于本例的目的）。然后根据该值计算细分级别。我们还将定义两个额外的值（作为统一变量）：`MinDepth`和`MaxDepth`。距离相机比`MinDepth`更近的对象将获得最大的细分级别，而距离相机比`MaxDepth`更远的所有对象将获得最小的细分级别。介于两者之间的对象的细分级别将进行线性插值。
- en: Getting ready
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'This program is nearly identical to the one in the *Tessellating a 3D surface*
    recipe. The only difference lies within the TCS. We''ll remove the `TessLevel` uniform
    variable, and add a few new ones that are described as follows:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序几乎与“**对3D表面进行细分**”菜谱中的程序相同。唯一的区别在于TCS。我们将移除`TessLevel`统一变量，并添加一些新的变量，如下所述：
- en: '`MinTessLevel`: This is the lowest desired tessellation level'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MinTessLevel`：这是期望的最低细分级别'
- en: '`MaxTessLevel`: This is the highest desired tessellation level'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MaxTessLevel`：这是期望的最高细分级别'
- en: '`MinDepth`: This is the minimum *distance* from the camera, where the tessellation
    level is maximal'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MinDepth`：这是从相机到最小**距离**，此时细分级别最大'
- en: '`MaxDepth`: This is the maximum *distance* from the camera, where the tessellation
    level is at a minimum'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MaxDepth`：这是从相机到最大**距离**，此时细分级别最小'
- en: Render your objects as 16-vertex patch primitives as indicated in the *Tessellating
    a 3D surface* recipe.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 按照在“**对3D表面进行细分**”菜谱中指示的，将您的对象渲染为16顶点补丁原语。
- en: How to do it...
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create a shader program that varies the tessellation level based on the
    depth, use the following steps:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个根据深度变化细分级别的着色器程序，请按照以下步骤操作：
- en: Use the vertex shader and tessellation evaluation shader from the *Tessellating
    a 3D surface* recipe.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用来自“**对3D表面进行细分**”菜谱的顶点着色器和细分评估着色器。
- en: 'Use the following code for the tessellation control shader:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码进行细分控制着色器：
- en: '[PRE36]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As with the previous recipe, implement your favorite shading model within the
    fragment shader.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与先前的菜谱一样，在片段着色器中实现您喜欢的着色模型。
- en: How it works...
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The TCS takes the position and converts it to camera coordinates and stores
    the result in the `p` variable. The absolute value of the *z* coordinate is then
    scaled and clamped so that the result is between zero and one. If the *z* coordinate
    is equal to `MaxDepth`, the value of the depth will be `1.0`, if it is equal to
    `MinDepth`, the depth will be `0.0`. If *z* is between `MinDepth` and `MaxDepth`,
    the depth will get a value between zero and one. If *z* is outside that range,
    it will be clamped to `0.0` or `1.0` by the `clamp` function.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: TCS将位置转换为相机坐标，并将结果存储在`p`变量中。然后**z**坐标的绝对值被缩放并夹紧，以确保结果在零和一之间。如果**z**坐标等于`MaxDepth`，则深度值将为`1.0`；如果等于`MinDepth`，则深度将为`0.0`。如果**z**在`MinDepth`和`MaxDepth`之间，则深度将获得介于零和一之间的值。如果**z**超出该范围，它将被`clamp`函数夹紧到`0.0`或`1.0`。
- en: The value of `depth` is then used to linearly interpolate between `MaxTessLevel`
    and `MinTessLevel` using the `mix` function. The result (`tessLevel`) is used
    to set the inner and outer tessellation levels.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用`mix`函数根据`depth`值在`MaxTessLevel`和`MinTessLevel`之间进行线性插值。结果（`tessLevel`）用于设置内部和外部细分级别。
- en: There's more...
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There is a somewhat subtle aspect to this example. Recall that the TCS is executed
    once for each output vertex in the patch. Therefore, assuming that we are rendering
    cubic Bezier surfaces, this TCS will be executed 16 times for each patch. Each
    time it is executed, the value of `depth` will be slightly different because it
    is evaluated based on the *z* coordinate of the vertex. You might be wondering,
    which of the 16 possible different tessellation levels will be the one that is
    used? It doesn't make sense for the tessellation level to be interpolated across
    the parameter space. What's going on?
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子有一个稍微微妙的地方。回想一下，TCS（三角形细分计算）在补丁中的每个输出顶点处执行一次。因此，如果我们正在渲染三次贝塞尔曲面，这个TCS将为每个补丁执行16次。每次执行时，`depth`的值都会略有不同，因为它基于顶点的*z*坐标进行评估。你可能想知道，16种可能的不同细分级别中哪一种会被使用？在参数空间中插值细分级别是没有意义的。这是怎么回事？
- en: The `gl_TessLevelInner` and `gl_TessLevelOuter` output arrays are per-patch
    output variables. This means that only a single value will be used per patch,
    similar to the way that the flat qualifier works for fragment shader input variables.
    The OpenGL specification seems to indicate that any of the values from each of
    the invocations of the TCS could be the value that ends up being used.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`gl_TessLevelInner`和`gl_TessLevelOuter`输出数组是每个补丁的输出变量。这意味着每个补丁只使用一个值，类似于平面限定符对片段着色器输入变量的作用。OpenGL规范似乎表明，TCS的每次调用中的任何值都可能最终被使用。'
- en: We should also note that if the tessellation level is different for patches
    that share an edge, then there is the potential for cracks to appear or other
    visual artifacts. Therefore we should take care to make sure that neighboring
    patches use the same tessellation level.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该注意，如果共享边的补丁的细分级别不同，那么可能会出现裂缝或其他视觉伪影。因此，我们应该确保相邻的补丁使用相同的细分级别。
- en: See also
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The `chapter07/scenetessteapotdepth.cpp` file in the example code
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码中的`chapter07/scenetessteapotdepth.cpp`文件
- en: 'DirectX 11 Terrain Tessellation at: [http://developer.download.nvidia.com/assets/gamedev/files/sdk/11/TerrainTessellation_WhitePaper.pdf](http://developer.download.nvidia.com/assets/gamedev/files/sdk/11/TerrainTessellation_WhitePaper.pdf)'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DirectX 11地形细分：[http://developer.download.nvidia.com/assets/gamedev/files/sdk/11/TerrainTessellation_WhitePaper.pdf](http://developer.download.nvidia.com/assets/gamedev/files/sdk/11/TerrainTessellation_WhitePaper.pdf)
- en: The *Tessellating a 3D surface* recipe
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*细分3D曲面*菜谱'
