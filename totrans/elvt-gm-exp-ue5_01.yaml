- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Introduction to Unreal Engine
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚幻引擎简介
- en: Welcome to *Game Development Projects with Unreal Engine Second Edition*. If
    this is the first time you’re using **Unreal Engine 5** (**UE5**), this book will
    support you in getting started with one of the most in-demand game engines on
    the market. You will discover how to build up your game development skills and
    how to express yourself by creating video games. If you’ve already tried using
    UE5, this book will help you develop your knowledge and skills further so that
    you can build games more easily and effectively.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎使用*虚幻引擎游戏开发项目第二版*。如果你是第一次使用**虚幻引擎5**（**UE5**），这本书将帮助你开始使用市场上最受欢迎的游戏引擎之一。你将发现如何提升你的游戏开发技能，以及如何通过创建视频游戏来表达自己。如果你已经尝试过使用UE5，这本书将帮助你进一步发展你的知识和技能，以便你能够更轻松、更有效地构建游戏。
- en: A game engine is a software application that allows you to produce video games
    from the ground up. Their feature sets vary significantly but usually allow you
    to import multimedia files, such as 3D models, images, audio, and video, and manipulate
    those files through the use of programming, where you can use programming languages
    such as C++, Python, and Lua, among others.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏引擎是一种软件应用程序，它允许你从头开始制作视频游戏。它们的特性集差异很大，但通常允许你导入多媒体文件，如3D模型、图像、音频和视频，并通过编程方式操作这些文件，其中你可以使用C++、Python和Lua等编程语言。
- en: UE5 uses two main programming languages, C++ and Blueprint, with the latter
    being a visual scripting language that allows you to do most of what C++ also
    allows. Although we will be teaching a bit of Blueprint in this book, we will
    mostly focus on C++, and hence expect you to have a basic understanding of the
    language, including topics such as **variables**, **functions**, **classes**,
    **inheritance**, and **polymorphism**. We will remind you about these topics throughout
    this book where appropriate.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: UE5使用两种主要的编程语言，C++和蓝图，后者是一种可视化脚本语言，允许你完成C++所能完成的大部分工作。尽管我们将在本书中教授一些蓝图知识，但我们主要会关注C++，因此我们期望你对这种语言有基本的了解，包括诸如**变量**、**函数**、**类**、**继承**和**多态**等主题。我们会在这本书中适当提醒你这些主题。
- en: 'Examples of popular video games made with Unreal Engine 4, the previous Unreal
    Engine version that UE5 is heavily based on, include *Fortnite*, *Final Fantasy
    VII Remake*, *Borderlands 3*, *Star Wars: Jedi Fallen Order*, *Gears 5*, and *Sea
    of Thieves*, among many others. All of these have a very high level of visual
    fidelity, are well-known, and have (or had) millions of players.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 使用虚幻引擎4（UE4）制作的流行视频游戏的例子，这是UE5主要基于的前一个版本，包括*堡垒之夜*、*最终幻想VII重制版*、*边境之地3*、*星球大战：绝地武士落魄者*、*
    gears 5*和*海贼王*等。所有这些游戏都具有非常高的视觉保真度，广为人知，并且（或曾经）拥有数百万玩家。
- en: 'The following link specifies some of the great games that have been made with
    Unreal Engine 5: [https://youtu.be/kT4iWCxu5hA](https://youtu.be/kT4iWCxu5hA).
    This showcase will show you the variety of games that UE5 allows you to make,
    both in terms of visuals and gameplay style.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 以下链接列出了使用虚幻引擎5制作的一些优秀游戏：[https://youtu.be/kT4iWCxu5hA](https://youtu.be/kT4iWCxu5hA)。这个展示将向您展示UE5允许你制作的各类游戏，无论是视觉效果还是游戏玩法风格。
- en: If you’d like to make games such as the ones shown in the video one day or contribute
    to them in any way, then you’ve taken your first step in that direction.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一天想制作像视频中展示的游戏，或者以任何方式为它们做出贡献，那么你已经迈出了第一步。
- en: This chapter will be an introduction to the Unreal Engine editor. You will learn
    about the editor’s interface; how to add, remove, and manipulate objects in a
    level; how to use Unreal Engine’s Blueprint visual scripting language; and how
    to use materials in combination with meshes.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍虚幻引擎编辑器。你将了解编辑器的界面；如何在关卡中添加、删除和操作对象；如何使用虚幻引擎的蓝图可视化脚本语言；以及如何结合网格使用材质。
- en: By the end of this chapter, you will be able to navigate the Unreal Engine editor,
    create Actors, manipulate them inside the level, and create materials. Let’s start
    this chapter by learning how to create a new UE5 project in this first exercise.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够导航虚幻引擎编辑器，创建演员，在关卡内操作它们，并创建材质。让我们通过学习如何在这个第一个练习中创建一个新的UE5项目来开始本章。
- en: Note
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Before you continue this chapter, make sure you have installed all the necessary
    software mentioned in the *Preface*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在你继续本章之前，请确保你已经安装了*前言*中提到的所有必要软件。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code files for this chapter can be found here: [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在以下位置找到：[https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition)
- en: Exercise 1.01 – creating an Unreal Engine 5 project
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习1.01 – 创建Unreal Engine 5项目
- en: In this first exercise, we will learn how to create a new UE5 project. UE5 has
    predefined project templates that allow you to implement a basic setup for your
    project. We’ll be using the **Third Person** template project in this exercise.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一个练习中，我们将学习如何创建一个新的UE5项目。UE5有预定义的项目模板，允许你为项目实现基本设置。在这个练习中，我们将使用**第三人称**模板项目。
- en: 'Follow these steps to complete this exercise:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成这个练习：
- en: After installing Unreal Engine version 5.0, launch the editor by clicking the
    **Launch** button next to the version icon.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Unreal Engine 5.0版本后，通过点击版本图标旁边的**启动**按钮来启动编辑器。
- en: After you’ve done that, you’ll be greeted with the engine’s **Projects** window,
    which will show you the existing projects that you can open and work on. It will
    also give you the option to create a new project. Because we have no projects
    yet, the **Recent Projects** section will be empty. To create a new project, choose
    a **Project Category** option, which in our case will be **Games**. Then, click
    **Next**.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这些操作后，你会看到引擎的**项目**窗口，它将显示你可以打开和工作的现有项目。它还将提供创建新项目的选项。因为我们还没有项目，所以**最近的项目**部分将是空的。要创建新项目，选择一个**项目类别**选项，在我们的情况下将是**游戏**。然后点击**下一步**。
- en: After that, you’ll see the **Project Templates** window. This window will show
    all the available project templates in Unreal Engine. When creating a new project,
    instead of having that project start empty, you have the option to add some assets
    and code out of the box, which you can then modify to your liking. There are several
    project templates available for different types of games, but we’ll want to go
    with the **Third Person** project template in this case.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，你会看到**项目模板**窗口。这个窗口将显示Unreal Engine中所有可用的项目模板。在创建新项目时，你将有一个选项，可以选择一些资产和代码直接使用，然后你可以根据喜好进行修改。有几种项目模板适用于不同类型的游戏，但在这个情况下，我们将选择**第三人称**项目模板。
- en: Select that template and click the **Next** button, which should take you to
    the **Project Settings** window.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择该模板并点击**下一步**按钮，这将带你到**项目设置**窗口。
- en: 'In this window, you can choose a few options related to your project:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个窗口中，你可以选择一些与你的项目相关的选项：
- en: '**Blueprint or C++**: Here, you can choose whether you want to be able to add
    C++ classes. The default option is **Blueprint**, but in our case, we’ll want
    to select the **C++** option.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**蓝图或C++**：在这里，你可以选择是否想要能够添加C++类。默认选项是**蓝图**，但在这个情况下，我们将想要选择**C++**选项。'
- en: '**Quality**: Here, you can choose whether you want your project to have high-quality
    graphics or high performance. Set this option to **Maximum Quality**.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**质量**：在这里，你可以选择你的项目是否需要高质量的图形或高性能。将此选项设置为**最高质量**。'
- en: '**Raytracing**: Here, you can choose whether you want raytracing enabled or
    disabled. Raytracing is a novel graphics rendering technique that allows you to
    render objects by simulating the path of light (using light rays) over a digital
    environment. Although this technique is rather costly in terms of performance,
    it also provides much more realistic graphics, especially when it comes to lighting.
    Set it to **disabled**.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**光线追踪**：在这里，你可以选择是否启用或禁用光线追踪。光线追踪是一种新颖的图形渲染技术，它允许你通过模拟光线（使用光线）在数字环境中的路径来渲染对象。尽管这项技术在性能方面相当昂贵，但它也提供了更加逼真的图形，尤其是在照明方面。将其设置为**禁用**。'
- en: '**Target Platforms**: Here, you can choose the main platforms you’ll want this
    project to run on. Set this option to **Desktop/Console**.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标平台**：在这里，你可以选择你希望此项目运行的主要平台。将此选项设置为**桌面/控制台**。'
- en: '**Starter Content**: Here, you can choose whether you want this project to
    come with an additional set of basic assets. Set this option to **With Starter
    Content**.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**起始内容**：在这里，你可以选择是否希望此项目附带一组额外的基本资产。将此选项设置为**包含起始内容**。'
- en: '**Location and Name**: At the bottom of the window, you’ll be able to choose
    the location where your project will be stored on your computer and its name.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位置和名称**：在窗口底部，你可以选择你的项目将在你的计算机上存储的位置及其名称。'
- en: Once you’ve made sure that all the options have been set to their intended values,
    click the **Create Project** button. This will cause your project to be created
    according to the parameters you set. It may take a few minutes for it to be ready.
    With that, you have created your first UE5 project!
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保所有选项都已设置为预期值后，点击**创建项目**按钮。这将根据您设置的参数创建您的项目。这可能需要几分钟才能准备就绪。这样，您就创建了您的第一个 UE5
    项目！
- en: Now, let’s learn about some of the basics of UE5.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习 UE5 的一些基础知识。
- en: Getting to know Unreal Engine
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解虚幻引擎
- en: In this section, you will be introduced to the Unreal Engine editor, which is
    a fundamental topic for becoming familiar with UE5.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将了解虚幻引擎编辑器，这是熟悉 UE5 的基本主题。
- en: Once your project has been generated, you should see the Unreal Engine editor
    open automatically. This screen is likely the one that you will see the most when
    working with Unreal Engine, so you must get accustomed to it.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的项目生成，您应该会看到虚幻引擎编辑器自动打开。这个屏幕可能是您在使用虚幻引擎时看到最多的屏幕，因此您必须习惯它。
- en: 'Let’s break down what we can see in the editor window:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下编辑器窗口中可以看到的内容：
- en: '![Figure 1.1 – The Unreal Engine editor divided into its main windows ](img/Figure_1.01_B18531.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1 – 虚幻引擎编辑器分为主要窗口](img/Figure_1.01_B18531.jpg)'
- en: Figure 1.1 – The Unreal Engine editor divided into its main windows
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – 虚幻引擎编辑器分为主要窗口
- en: 'Let’s look at these windows in more detail:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这些窗口：
- en: '**Viewport**: At the very center of the screen, you can see the **Viewport**
    window. This will show you the content of the current level and will allow you
    to navigate through your level as well as add, move, remove, and edit objects
    inside it. It also contains several different parameters regarding visual filters,
    object filters (which objects you can see), and the lighting on your level.'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**视口**：在屏幕的正中心，您可以看到**视口**窗口。这将显示当前级别的内容，并允许您在级别中导航以及添加、移动、删除和编辑其中的对象。它还包含有关视觉过滤器、对象过滤器（您可以看到哪些对象）以及级别上的光照的几个不同参数。'
- en: '**Outliner**: At the top-right corner of the screen, you’ll see the **Outliner**
    window. This allows you to quickly list and manipulate the objects that are on
    your level. The **Viewport** and **Outliner** windows work hand in hand in allowing
    you to manage your level, where the former will show you what it looks like and
    the latter will help you manage and organize it. The **Outliner** window allows
    you to organize the objects in your level in directories by showing you the *objects*
    in your level.'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**大纲**：在屏幕的右上角，您将看到**大纲**窗口。这允许您快速列出和管理级别上的对象。**视口**和**大纲**窗口协同工作，允许您管理级别，其中前者将向您显示其外观，而后者将帮助您管理和组织它。**大纲**窗口允许您通过向您显示级别中的**对象**来按目录组织级别中的对象。'
- en: '**Details**: At the far right of the screen, below **Outliner**, you’ll be
    able to see the **Details** panel, which allows you to edit the properties of
    an object that you have selected in your level. Since no objects have been selected
    in the preceding screenshot, it is empty. However, if you select any object in
    your level by *left-clicking* on it, its properties should appear in this window,
    as shown in the following screenshot:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**详细信息**：在屏幕的右侧，在**大纲**下方，您将能够看到**详细信息**面板，它允许您编辑您在级别中选定的对象的属性。由于前一个屏幕截图中没有选择任何对象，因此它是空的。然而，如果您通过**左键单击**选择级别中的任何对象，其属性应该会显示在这个窗口中，如下面的屏幕截图所示：'
- en: '![Figure 1.2 – The Details tab ](img/Figure_1.02_B18531.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2 – 详细信息选项卡](img/Figure_1.02_B18531.jpg)'
- en: Figure 1.2 – The Details tab
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – 详细信息选项卡
- en: '**Toolbar**: At the top of the screen, you’ll see the **Toolbar** area, where
    you’ll be able to save your current level, add objects to your level, and play
    your level, among other things.'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**工具栏**：在屏幕的顶部，您将看到**工具栏**区域，您将能够保存当前级别，向级别添加对象，并播放级别，等等。'
- en: Note
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We will only be using some of the buttons from these toolbars, namely, the **Save
    Current**, **Settings**, **Add**, and **Play** buttons.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将只使用这些工具栏中的某些按钮，即**保存当前**、**设置**、**添加**和**播放**按钮。
- en: '**Content Drawer**: One of the windows that you’ll be using very frequently
    is the **Content Drawer** window. This window lets you quickly access the **Context
    Browser** window. You can also open it by using *Ctrl* + *Space*. The **Content
    Browser** window will let you browse and manipulate all the files and assets located
    inside your project’s folder. As mentioned at the start of this chapter, Unreal
    Engine allows you to import several types of multimedia files, and **Content Browser**
    is the window that will allow you to browse and edit them in their respective
    sub-editors. Whenever you create an Unreal Engine project, it will always generate
    a **Content** folder. This folder will be the **root directory** of the **Content
    Browser** window, meaning you can only browse files inside that folder. You can
    see the directory you’re currently browsing inside the **Content Browser** window
    by looking at the top of it, which, in our case, is **Content** | **ThirdPersonCPP**.'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**内容抽屉**：你将非常频繁地使用的一个窗口是**内容抽屉**窗口。这个窗口让你能够快速访问**上下文浏览器**窗口。你也可以通过按下*Ctrl*
    + *Space*来打开它。**内容浏览器**窗口将允许你浏览和操作位于项目文件夹内的所有文件和资源。正如本章开头所述，虚幻引擎允许你导入多种类型的多媒体文件，而**内容浏览器**就是让你能够在各自的子编辑器中浏览和编辑它们的窗口。每次你创建一个虚幻引擎项目时，它都会始终生成一个**内容**文件夹。这个文件夹将是**内容浏览器**窗口的**根目录**，这意味着你只能浏览该文件夹内的文件。你可以在**内容浏览器**窗口的顶部看到你当前正在浏览的目录，在我们的例子中是**内容**
    | **ThirdPersonCPP**。'
- en: '![Figure 1.3 – The Content Browser window shown in Unreal Editor interface](img/Figure_1.03_B18531.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图1.3 – 在虚幻引擎界面中显示的内容浏览器窗口](img/Figure_1.03_B18531.jpg)'
- en: Figure 1.3 – The Content Browser window shown in Unreal Editor interface
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 – 在虚幻引擎界面中显示的内容浏览器窗口
- en: 'If you click the icon to the left of the **Filters** button, at the very left
    of the **Content Browser** window, you will be able to see the directory hierarchy
    of the **Content** folder. This directory view allows you to select, expand, and
    collapse individual directories in the **Content** folder of your project:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击位于**内容浏览器**窗口最左侧的**过滤器**按钮左侧的图标，你将能够看到**内容**文件夹的目录层次结构。这种目录视图允许你在项目的**内容**文件夹中选中、展开和折叠单个目录：
- en: '![Figure 1.4 – The Content Browser window’s directory view ](img/Figure_1.04_B18531.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图1.4 – 内容浏览器窗口的目录视图](img/Figure_1.04_B18531.jpg)'
- en: Figure 1.4 – The Content Browser window’s directory view
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 – 内容浏览器窗口的目录视图
- en: Note
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The terms **Content Drawer** and **Content Browser** are interchangeable.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**内容抽屉**和**内容浏览器**这两个术语可以互换使用。'
- en: Now that we have learned about the main windows of the Unreal Engine editor,
    let’s look at how to manage those windows (hiding and showing their tabs).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了虚幻引擎编辑器的主要窗口，让我们看看如何管理这些窗口（隐藏和显示它们的标签）。
- en: Exploring editor windows
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索编辑器窗口
- en: 'As we’ve seen, the Unreal Engine editor is comprised of many windows, all of
    which are resizable, movable, and have a corresponding tab on top of them. You
    can *click and hold* a window’s tab and drag it to move it somewhere else. You
    can hide tab labels by *right-clicking* them and selecting the **Hide Tabs** option:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，虚幻引擎编辑器由许多窗口组成，所有这些窗口都是可调整大小、可移动的，并且它们上面都有一个相应的标签。你可以*点击并拖动*一个窗口的标签来将其移动到其他位置。你可以通过*右键单击*标签并选择**隐藏标签**选项来隐藏标签标签：
- en: '![Figure 1.5 – How to hide a tab](img/Figure_1.05_B18531.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图1.5 – 如何隐藏标签](img/Figure_1.05_B18531.jpg)'
- en: Figure 1.5 – How to hide a tab
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5 – 如何隐藏标签
- en: 'If the tab labels have been hidden, you can get them to reappear by clicking
    the *blue triangle* in the top-left corner of that window, as shown in the following
    screenshot:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果标签标签已被隐藏，你可以通过点击该窗口左上角的*蓝色三角形*来使它们重新出现，如下面的截图所示：
- en: '![Figure 1.6 – The blue triangle that allows you to show a window’s tab](img/Figure_1.06_B18531.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图1.6 – 显示窗口标签的蓝色三角形](img/Figure_1.06_B18531.jpg)'
- en: Figure 1.6 – The blue triangle that allows you to show a window’s tab
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6 – 显示窗口标签的蓝色三角形
- en: 'You can also dock the windows to the sidebar to hide them while also having
    them easily available:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将窗口停靠到侧边栏以隐藏它们，同时使它们易于访问：
- en: '![Figure 1.7 – Docking a window to the sidebar ](img/Figure_1.07_B18531.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图1.7 – 将窗口停靠到侧边栏](img/Figure_1.07_B18531.jpg)'
- en: Figure 1.7 – Docking a window to the sidebar
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7 – 将窗口停靠到侧边栏
- en: 'After that, to show or hide them, you simply have to click them:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，要显示或隐藏它们，你只需点击它们：
- en: '![Figure 1.8 – Showing a window docked to the sidebar ](img/Figure_1.08_B18531.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图1.8 – 显示停靠在侧边栏的窗口](img/Figure_1.08_B18531.jpg)'
- en: Figure 1.8 – Showing a window docked to the sidebar
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.8 – 显示停靠在侧边栏的窗口
- en: 'When it comes to the windows that are docked to the lower bar, such as the
    **Content Drawer** window, you can undock them from the lower bar into the editor
    by clicking **Dock in Layout** in the top-right corner:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到停靠在底部工具栏的窗口，例如**内容抽屉**窗口时，你可以通过点击右上角的**Dock in Layout**来将它们从底部工具栏取消停靠到编辑器中：
- en: '![Figure 1.9 – Undocking a window from the lower bar in the editor ](img/Figure_1.09_B18531.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图1.9 – 在编辑器底部的工具栏中取消停靠窗口](img/Figure_1.09_B18531.jpg)'
- en: Figure 1.9 – Undocking a window from the lower bar in the editor
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.9 – 在编辑器底部的工具栏中取消停靠窗口
- en: Keep in mind that you can browse and open all the windows available in the editor,
    including the ones that were just mentioned, by clicking the **Window** button
    in the top-left corner of the editor.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，你可以通过点击编辑器左上角的**窗口**按钮来浏览和打开编辑器中所有可用的窗口，包括刚才提到的那些。
- en: 'Another very important thing you should know is how to play your level from
    inside the editor (also known as **PIE**). At the right edge of the **Toolbar**
    window, you’ll see the green **Play** button. If you click it, you’ll start playing
    the currently open level inside the editor:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个你应该知道的重要事情是如何在编辑器内播放你的层级（也称为**PIE**）。在**工具栏**窗口的右侧边缘，你会看到一个绿色的**播放**按钮。如果你点击它，你将开始在编辑器内播放当前打开的层级：
- en: '![Figure 1.10 – The green play button, alongside other game playback buttons
    ](img/Figure_1.10_B18531.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图1.10 – 绿色的播放按钮，以及其他游戏播放按钮](img/Figure_1.10_B18531.jpg)'
- en: Figure 1.10 – The green play button, alongside other game playback buttons
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.10 – 绿色的播放按钮，以及其他游戏播放按钮
- en: 'Once you hit **Play**, you’ll be able to control the player character in the
    level by using the *W*, *A*, *S*, and *D* keys to move the player character, the
    *Spacebar* to jump, and moving your mouse to rotate the camera:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你按下**播放**，你将能够通过使用*W*、*A*、*S*和*D*键来移动玩家角色，使用*空格键*来跳跃，以及移动鼠标来旋转相机来控制层级中的玩家角色：
- en: '![Figure 1.11 – The level being played inside the editor](img/Figure_1.11_B18531.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图1.11 – 在编辑器内播放的层级](img/Figure_1.11_B18531.jpg)'
- en: Figure 1.11 – The level being played inside the editor
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.11 – 在编辑器内播放的层级
- en: Then, you can press the *Shift* + *Esc* keys to stop playing the level.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以按下*Shift* + *Esc*键来停止播放层级。
- en: Now that we’ve gotten accustomed to some of the editor’s windows, let’s take
    a deeper look at the **Viewport** window’s navigation.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经习惯了编辑器的一些窗口，让我们更深入地看看**视口**窗口的导航。
- en: Viewport navigation
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视口导航
- en: In the previous section, we mentioned that the **Viewport** window allows you
    to visualize your level, as well as manipulate the objects inside it. Because
    this is a very important window for you to use and has a lot of functionality,
    we’re going to learn more about it in this section.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们提到**视口**窗口允许你可视化你的层级，以及操作其中的对象。因为这个窗口对你来说非常重要，并且具有很多功能，所以我们将在本节中更深入地了解它。
- en: Before we start learning about the **Viewport** window, let’s quickly get to
    know **levels**. In UE5, levels represent a **collection of objects**, as well
    as their locations and properties. The **Viewport** window will always show you
    the contents of the currently selected level, which in this case was already made
    and generated alongside the **Third Person** template project. In this level,
    you can see four wall objects, one ground object, a set of stairs, and some other
    elevated objects, as well as the player character, which is represented by the
    UE5 mannequin. You can create multiple levels and switch between them by opening
    them via the **Content Browser** window.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始学习**视口**窗口之前，让我们快速了解一下**层级**。在UE5中，层级代表一组**对象**，以及它们的**位置和属性**。**视口**窗口将始终显示当前选中层级的**内容**，在这个例子中，它已经与**第三人称**模板项目一起创建和生成。在这个层级中，你可以看到四个墙面对象，一个地面对象，一组楼梯，以及一些其他高处的对象，还有玩家角色，它由UE5的模特表示。你可以创建多个层级并通过在**内容浏览器**窗口中打开它们来在它们之间切换。
- en: To manipulate and navigate the currently selected level, you must use the **Viewport**
    window. If you press and hold the *left mouse button* inside the window, you’ll
    be able to rotate the camera horizontally by moving the mouse *left* and *right*,
    and move the camera forward and backward by moving the mouse *forward* and *backward*.
    You can achieve similar results by holding the *right mouse button*, except the
    camera will rotate vertically when you move the mouse *forward* and *backward*,
    which allows you to rotate the camera both horizontally and vertically.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要操作和导航当前选定的水平面，你必须使用**视口**窗口。如果你在窗口内按下并按住**左鼠标按钮**，你可以通过移动鼠标**左**和**右**来水平旋转相机，并通过移动鼠标**前**和**后**来前后移动相机。你也可以通过按住**右鼠标按钮**达到类似的效果，但当你移动鼠标**前**和**后**时，相机将垂直旋转，这允许你水平和垂直旋转相机。
- en: Additionally, you can move around the level by clicking and holding the **Viewport**
    window with the *right mouse button* (the *left mouse button* works too, but using
    it for movement is not as useful due to there not being as much freedom when rotating
    the camera) and using the *W* and *S* keys to move forward and backward, the *A*
    and *D* keys to move sideways, and the *E* and *Q* keys to move up and down.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以通过点击并按住**视口**窗口的**右鼠标按钮**（**左鼠标按钮**也可以，但使用它进行移动并不那么有用，因为旋转相机时没有那么多自由度）并使用**W**和**S**键向前和向后移动，**A**和**D**键向左右移动，**E**和**Q**键向上和向下移动来在水平面上移动。
- en: If you look at the top-right corner of the **Viewport** window, you will see
    a small camera icon with a number next to it, which will allow you to change the
    speed at which the camera moves in the **Viewport** window.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看**视口**窗口的右上角，你会看到一个带有数字的小相机图标，这将允许你更改**视口**窗口中相机移动的速度。
- en: Another thing you can do in the **Viewport** window is change its visualization
    settings. You can change the type of visualization in the **Viewport** window
    by clicking the button that currently says **Lit**, which will show you all the
    options available for different lighting and other types of visualization filters.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在**视口**窗口中，你还可以更改其可视化设置。你可以通过点击当前显示为**光照**的按钮来更改**视口**窗口中的可视化类型，这将显示所有可用于不同光照和其他类型可视化过滤器的选项。
- en: If you click on the **Perspective** button, you’ll have the option to switch
    between seeing your level from a perspective view, as well as from an orthographic
    view, the latter of which may help you build your levels faster.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击**透视**按钮，你将可以选择在透视视图和正交视图之间切换，后者可能有助于你更快地构建水平面。
- en: Now that we’ve learned how to navigate the viewport, let’s learn how to manipulate
    objects, also known as Actors, in your level.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何导航视口，让我们学习如何操作对象，也称为Actor，在你的水平面上。
- en: Manipulating Actors
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作Actor
- en: In Unreal Engine, all the objects that can be placed in a level are referred
    to as Actors. In a movie, an actor would be a human playing a character, but in
    UE5, every single object you see in your level, including walls, floors, weapons,
    and characters, is an Actor.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unreal Engine中，所有可以放置在水平面上的对象都被称为Actor。在电影中，演员是一个扮演角色的演员，但在UE5中，你水平面上看到的每个对象，包括墙壁、地板、武器和角色，都是一个Actor。
- en: 'Every Actor must have what’s called a **Transform** property, which is a collection
    of three things:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Actor都必须有一个称为**变换**属性的东西，它是一组三件事：
- en: '`Vector` property signifying the position of that Actor in the level in the
    *X*, *Y,* and *Z*-axis. A vector is simply a tuple with three floating-point numbers
    – one for the location of the point on each axis.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Vector`属性表示该Actor在水平、垂直和**Z**轴上的位置。一个向量简单地说是一个包含三个浮点数的元组——每个轴上的点位置各一个。'
- en: '`Rotator` property signifying the rotation of that Actor along the *X*, *Y,*
    and *Z*-axis. A rotator is also a tuple with three floating-point numbers – one
    for the angle of rotation on each axis.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Rotator`属性表示该Actor沿**X**、**Y**和**Z**轴的旋转。旋转器也是一个包含三个浮点数的元组——每个轴上的旋转角度各一个。'
- en: '`Vector` property signifying the scale (that is, the size) of that Actor in
    the level in the *X*, *Y,* and *Z*-axis. This is also a collection of three floating-point
    numbers – one for the scale value on each axis.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Vector`属性表示该Actor在水平、垂直和**Z**轴上的缩放（即大小）。这也是一个包含三个浮点数的集合——每个轴上的缩放值各一个。'
- en: 'Actors can be moved, rotated, and scaled in a level, which will modify their
    **Transform** property accordingly. To do this, select any object in your level
    by *left-clicking* on it. You should see the **Move** tool appear:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 演员可以在级别中移动、旋转和缩放，这将相应地修改其**变换**属性。要这样做，通过在它上*左键单击*来选择您级别中的任何对象。您应该会看到**移动**工具出现：
- en: '![Figure 1.12 – The Move tool, which allows you to move an Actor in the level  ](img/Figure_1.12_B18531.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图1.12 – 允许您在级别中移动演员的移动工具](img/Figure_1.12_B18531.jpg)'
- en: Figure 1.12 – The Move tool, which allows you to move an Actor in the level
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.12 – 允许您在级别中移动演员的移动工具
- en: 'The **Move** tool is a three-axis gizmo that allows you to move an object in
    any of the axes simultaneously. The red arrow of the **Move** tool (pointing to
    the left in the preceding screenshot) represents the *X*-axis, the green arrow
    (pointing to the right in the preceding screenshot) represents the *Y*-axis, and
    the blue arrow (pointing up in the preceding screenshot) represents the *Z*-axis.
    If you *click and hold* any of these arrows and then drag them around the level,
    you will move your Actor along that axis in the level. If you click the handles
    that connect two arrows, you will move the Actor along both those axes simultaneously,
    and if you click the white sphere at the intersection of all the arrows, you will
    move the Actor freely along all three axes:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**移动**工具是一个三轴操纵杆，允许您在任何轴上同时移动对象。**移动**工具的红色箭头（在前一个屏幕截图中指向左侧）代表*X*轴，绿色箭头（在前一个屏幕截图中指向右侧）代表*Y*轴，蓝色箭头（在前一个屏幕截图中向上）代表*Z*轴。如果您*单击并按住*这些箭头中的任何一个，然后将其拖动到级别中，您将在级别中沿着该轴移动您的演员。如果您单击连接两个箭头的手柄，您将同时沿着这两个轴移动演员，如果您单击所有箭头交点的白色球体，您将可以自由地在所有三个轴上移动演员：'
- en: '![Figure 1.13 – An Actor being moved on the Z-axis using the Move tool ](img/Figure_1.13_B18531.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图1.13 – 使用移动工具在Z轴上移动演员](img/Figure_1.13_B18531.jpg)'
- en: Figure 1.13 – An Actor being moved on the Z-axis using the Move tool
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.13 – 使用移动工具在Z轴上移动演员
- en: 'The **Move** tool allows you to move an Actor around the level, but if you
    want to rotate or scale an Actor, you’ll need to use the **Rotate** and **Scale**
    tools, respectively. You can switch between the **Move**, **Rotate**, and **Scale**
    tools by pressing the *W*, *E*, and *R* keys, respectively. Press *E* to switch
    to the **Rotate** tool:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**移动**工具允许您在级别中移动演员，但如果您想旋转或缩放演员，您将需要分别使用**旋转**和**缩放**工具。您可以通过分别按*W*、*E*和*R*键在**移动**、**旋转**和**缩放**工具之间切换。按*E*键切换到**旋转**工具：'
- en: '![Figure 1.14 – The Rotate tool, which allows you to rotate an Actor ](img/Figure_1.14_B18531.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图1.14 – 旋转工具，允许您旋转一个演员](img/Figure_1.14_B18531.jpg)'
- en: Figure 1.14 – The Rotate tool, which allows you to rotate an Actor
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.14 – 旋转工具，允许您旋转一个演员
- en: 'The **Rotate** tool, as expected, allows you to rotate an Actor in your level.
    You can *click and hold* any of the arcs to rotate the Actor around its associated
    axis. The red arc (top left in the preceding screenshot) will rotate the Actor
    around the *X*-axis, the green arc (top right in the preceding screenshot) will
    rotate the Actor around the *Y*-axis, and the blue arc (lower center in the preceding
    screenshot) will rotate the Actor around the *Z*-axis:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，**旋转**工具允许您在级别中旋转一个演员。您可以*单击并按住*任何弧线来围绕相关的轴旋转演员。红色弧线（前一个屏幕截图的左上角）将围绕*X*轴旋转演员，绿色弧线（前一个屏幕截图的右上角）将围绕*Y*轴旋转演员，而蓝色弧线（前一个屏幕截图的左下角）将围绕*Z*轴旋转演员：
- en: '![Figure 1.15 – A cube before and after being rotated 30 degrees around the
    Y-axis  ](img/Figure_1.15_B18531.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图1.15 – 绕Y轴旋转30度前后的立方体](img/Figure_1.15_B18531.jpg)'
- en: Figure 1.15 – A cube before and after being rotated 30 degrees around the Y-axis
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.15 – 绕Y轴旋转30度前后的立方体
- en: Keep in mind that an object’s rotation around the *X*-axis is usually designated
    as **Roll**, its rotation around the *Y*-axis is usually designated as **Pitch**,
    and its rotation around the *Z*-axis is usually designated as **Yaw**.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，一个对象绕*X*轴的旋转通常被指定为**翻滚**，其绕*Y*轴的旋转通常被指定为**俯仰**，其绕*Z*轴的旋转通常被指定为**偏航**。
- en: 'Lastly, we have the **Scale** tool. Press *R* to switch to it:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有**缩放**工具。按*R*键切换到它：
- en: '![Figure 1.16 – The Scale tool ](img/Figure_1.16_B18531.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图1.16 – 缩放工具](img/Figure_1.16_B18531.jpg)'
- en: Figure 1.16 – The Scale tool
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.16 – 缩放工具
- en: 'The **Scale** tool allows you to increase and decrease the scale (size) of
    an Actor in the *X*, *Y*, and *Z* axes, where the red handle (left in the preceding
    screenshot) will scale the Actor on the *X*-axis, the green handle (right in the
    preceding screenshot) will scale the Actor on the *Y*-axis, and the blue handle
    (top in the preceding screenshot) will scale the Actor on the *Z*-axis:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**缩放**工具允许你在**X**、**Y**和**Z**轴上增加和减少演员的缩放（大小），其中红色手柄（在先前的屏幕截图中的左侧）将沿**X**轴缩放演员，绿色手柄（在先前的屏幕截图中的右侧）将沿**Y**轴缩放演员，蓝色手柄（在先前的屏幕截图中的顶部）将沿**Z**轴缩放演员：'
- en: '![Figure 1.17 – A Cube Actor before and after being scaled on all three axes  ](img/Figure_1.17_B18531.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.17 – 在所有三个轴向上缩放之前和之后的立方体演员](img/Figure_1.17_B18531.jpg)'
- en: Figure 1.17 – A Cube Actor before and after being scaled on all three axes
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.17 – 在所有三个轴向上缩放之前和之后的立方体演员
- en: 'You can also toggle between the **Move**, **Rotate**, and **Scale** tools by
    clicking the following icons at the top of the **Viewport** window:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过点击**视口**窗口顶部的以下图标在**移动**、**旋转**和**缩放**工具之间切换：
- en: '![Figure 1.18 – The Move, Rotate, and Scale tool icons ](img/Figure_1.18_B18531.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.18 – 移动、旋转和缩放工具图标](img/Figure_1.18_B18531.jpg)'
- en: Figure 1.18 – The Move, Rotate, and Scale tool icons
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.18 – 移动、旋转和缩放工具图标
- en: 'Additionally, you can change the increments with which you move, rotate, and
    scale your objects through the grid snapping options to the right of the **Move**,
    **Rotate**, and **Scale** tool icons. By clicking the buttons highlighted in blue,
    you’ll be able to disable snapping altogether, and by pressing the buttons showing
    the current snapping increments, you’ll be able to change those increments:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还可以通过**移动**、**旋转**和**缩放**工具图标右侧的网格吸附选项更改你移动、旋转和缩放对象的增量。通过点击高亮显示的蓝色按钮，你可以完全禁用吸附，通过按下显示当前吸附增量的按钮，你可以更改这些增量：
- en: '![Figure 1.19 – The grid-snapping icons for moving, rotating, and scaling ](img/Figure_1.19_B18531.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.19 – 移动、旋转和缩放的网格吸附图标](img/Figure_1.19_B18531.jpg)'
- en: Figure 1.19 – The grid-snapping icons for moving, rotating, and scaling
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.19 – 移动、旋转和缩放的网格吸附图标
- en: Now that you know how to manipulate Actors already present in your level, let’s
    learn how to add and remove Actors to and from our level.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何操作你层级中已有的演员，让我们学习如何添加和移除演员到我们的层级。
- en: Exercise 1.02 – adding and removing Actors
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.02 – 添加和移除演员
- en: In this exercise, we will be adding and removing Actors from our level.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将添加和移除演员从我们的层级。
- en: 'When it comes to adding Actors to your level, there are two main ways in which
    you can do so: by dragging assets from the **Content Browser** window or by dragging
    the default assets from the **Modes** window’s **Place Mode**.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到将演员添加到你的层级时，有两种主要方式可以实现：通过从**内容浏览器**窗口拖动资产或通过从**模式**窗口的**放置模式**拖动默认资产。
- en: 'Follow these steps to complete this exercise:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此练习：
- en: 'Go to the `ThirdPersonCharacter` Actor. If you drag that asset to your level
    using the *left mouse button*, you will be able to add an instance of that Actor
    to it. It will be placed wherever you let go of the *left mouse button*:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 `ThirdPersonCharacter` 演员处。如果你使用**左鼠标按钮**将此资产拖动到你的层级，你将能够将此演员的一个实例添加到其中。它将放置在你释放**左鼠标按钮**的地方：
- en: '![Figure 1.20 – Dragging an instance of the ThirdPersonCharacter Actor to our
    level ](img/Figure_1.20_B18531.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.20 – 将 ThirdPersonCharacter 演员的实例拖动到我们的层级](img/Figure_1.20_B18531.jpg)'
- en: Figure 1.20 – Dragging an instance of the ThirdPersonCharacter Actor to our
    level
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.20 – 将 ThirdPersonCharacter 演员的实例拖动到我们的层级
- en: 'Similarly, drag an Actor to your level by using the **Add** button in the **Toolbar**
    window (the cube with the green *+*):'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，通过使用**工具栏**窗口中的**添加**按钮（带有绿色 *+* 的立方体）将一个**演员**拖动到你的层级：
- en: '![Figure 1.21 – Dragging a Cylinder Actor to our level ](img/Figure_1.21_B18531.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.21 – 将圆柱形演员拖动到我们的层级](img/Figure_1.21_B18531.jpg)'
- en: Figure 1.21 – Dragging a Cylinder Actor to our level
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.21 – 将圆柱形演员拖动到我们的层级
- en: To delete an Actor, simply select the Actor and press the *Delete* key. You
    can also *right-click* on an Actor to look at the many other options available
    to you regarding that Actor.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要删除一个演员，只需选择该演员并按**删除**键。你还可以**右键单击**一个演员，查看有关该演员的许多其他选项。
- en: Note
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Although we won’t be covering this topic in this book, one of the ways developers
    can populate their levels with simple boxes and geometry, for prototyping purposes,
    is BSP Brushes. These can be quickly molded into the desired shape as you build
    your levels. To find out more about BSP Brushes, go to [https://docs.unrealengine.com/en-US/Engine/Actors/Brushes](https://docs.unrealengine.com/en-US/Engine/Actors/Brushes).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们不会在本书中涵盖这个主题，但开发者可以用BSP刷子来填充他们的关卡，以简单盒子和几何体进行原型设计，这是其中一种方法。当你构建关卡时，这些刷子可以快速塑造成所需的形状。要了解更多关于BSP刷子的信息，请访问[https://docs.unrealengine.com/en-US/Engine/Actors/Brushes](https://docs.unrealengine.com/en-US/Engine/Actors/Brushes)。
- en: And with this, we have concluded this exercise and learned how to add and remove
    Actors to and from our level.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们就完成了这个练习，并学习了如何将Actors添加到我们的关卡中或从关卡中移除。
- en: Now that we know how to navigate the **Viewport** window, let’s learn about
    Blueprint Actors.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何导航**视口**窗口，让我们来了解一下蓝图Actors。
- en: Understanding Blueprint Actors
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解蓝图Actors
- en: 'In UE5, the word Blueprint can be used to refer to two different things: UE5’s
    visual scripting language or a specific type of asset, also referred to as a Blueprint
    class or Blueprint asset.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在UE5中，"蓝图"这个词可以指代两件事：UE5的可视化脚本语言或一种特定的资产类型，也称为蓝图类或蓝图资产。
- en: 'As we’ve mentioned previously, an Actor is an object that can be placed in
    a level. This object can either be an instance of a C++ class or an instance of
    a Blueprint class, both of which must inherit from the Actor class (either directly
    or indirectly). So, what is the difference between a C++ class and a Blueprint
    class, you may ask? There are a few:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，一个Actor是一个可以放置在关卡中的对象。这个对象可以是C++类的实例或蓝图类的实例，这两个都必须继承自Actor类（无论是直接还是间接）。那么，C++类和蓝图类之间有什么区别呢？有几个：
- en: If you add programming logic to your C++ class, you’ll have access to more advanced
    engine functionality than you would if you were to create a Blueprint class.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你向你的C++类添加编程逻辑，你将能够访问比创建蓝图类时更多的先进引擎功能。
- en: In a Blueprint class, you can easily view and edit visual components of that
    class, such as a 3D mesh or a Trigger Box Collision, as well as modify properties
    defined in the C++ class that are exposed to the editor, which makes managing
    those properties much easier.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在蓝图类中，你可以轻松地查看和编辑该类的可视化组件，例如3D网格或触发盒碰撞，以及修改在C++类中定义并暴露给编辑器的属性，这使得管理这些属性变得容易得多。
- en: In a Blueprint class, you can easily reference other assets in your project,
    whereas in C++, you can also do so but less simply and less flexibly.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在蓝图类中，你可以轻松地引用项目中其他资产，而在C++中，你也可以这样做，但不如前者简单和灵活。
- en: Programming logic that runs on Blueprint visual scripting is slower in terms
    of performance than that of a C++ class.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在蓝图可视化脚本上运行的编程逻辑在性能方面比C++类的慢。
- en: It’s simple to have more than one person work on a C++ class simultaneously
    without conflicts in a source version platform, whereas with a Blueprint class,
    which is interpreted as a binary file instead of a text file, conflicts will occur
    in your source version platform if two different people edit the same Blueprint
    class.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在源版本平台上，同时让多个人在没有冲突的情况下工作于一个C++类是非常简单的，而蓝图类，作为二进制文件而不是文本文件，如果两个人编辑同一个蓝图类，则会在源版本平台上发生冲突。
- en: Note
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you don’t know what a source version platform is, this is how several developers
    can work on the same project and have it updated with the work done by other developers.
    In these platforms, different people can usually edit the same file simultaneously,
    so long as they edit different parts of that file, and still receive updates that
    other programmers made without them affecting your work on that same file. One
    of the most popular source version platforms is GitHub.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道源版本平台是什么，这就是几个开发者如何可以在同一个项目中工作，并且通过其他开发者的工作来更新项目。在这些平台上，不同的人通常可以同时编辑同一个文件，只要他们编辑的是该文件的不同部分，并且仍然可以接收到其他程序员所做的更新，而不会影响你在同一文件上的工作。最受欢迎的源版本平台之一是GitHub。
- en: Keep in mind that Blueprint classes can inherit either from a C++ class or from
    another Blueprint class.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，蓝图类可以继承自C++类或另一个蓝图类。
- en: Lastly, before we create our first Blueprint class, another important thing
    you should know is that you can write programming logic in a C++ class and then
    create a Blueprint class that inherits from that class, but can also access its
    properties and methods if you specify that in the C++ class. You can have a Blueprint
    class edit properties defined in the C++ class, as well as call and override functions
    using the Blueprint scripting language. We will be doing some of these things
    in this book.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们创建第一个蓝图类之前，还有另一件重要的事情你应该知道，你可以在 C++ 类中编写编程逻辑，然后创建一个继承自该类的蓝图类，同时也可以访问其属性和方法，如果你在
    C++ 类中指定了这些。你可以让蓝图类编辑在 C++ 类中定义的属性，以及使用蓝图脚本语言调用和覆盖函数。我们将在本书中做一些这些事情。
- en: Now that you know a bit more about Blueprint classes, let’s create our own.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对蓝图类有了更多了解，让我们创建自己的蓝图。
- en: Exercise 1.03 – creating Blueprint Actors
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.03 – 创建蓝图演员
- en: In this short exercise, we will learn how to create a new Blueprint Actor.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简短的练习中，我们将学习如何创建一个新的蓝图演员。
- en: 'Follow these steps to complete this exercise:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成这个练习：
- en: 'Go to the **ThirdPersonCPP** | **Blueprints** directory inside the **Content
    Browser** window and *right-click* inside it. The following window should pop
    up:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入 **Content Browser** 窗口内的 **ThirdPersonCPP** | **Blueprints** 目录，并在其中 *右键单击*。应该会弹出以下窗口：
- en: '![Figure 1.22 – The options window inside the Content Browser window ](img/Figure_1.22_B18531.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.22 – 内容浏览器窗口内的选项窗口](img/Figure_1.22_B18531.jpg)'
- en: Figure 1.22 – The options window inside the Content Browser window
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.22 – 内容浏览器窗口内的选项窗口
- en: This options menu contains the types of assets that you can create in UE5 (Blueprints
    are simply a type of asset, along with other types of assets, such as **Level**,
    **Material**, and **Sound**).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项菜单包含在 UE5 中可以创建的资产类型（蓝图只是资产类型之一，还有其他类型的资产，如 **Level**、**Material** 和 **Sound**）。
- en: 'Click on the **Blueprint Class** icon to create a new Blueprint class. When
    you do, you will be given the option to choose the C++ or Blueprint class that
    you want to inherit from:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **Blueprint Class** 图标以创建一个新的蓝图类。当你这样做时，你将可以选择从 C++ 或蓝图类继承：
- en: '![Figure 1.23 – The Pick Parent Class window that pops up when you create a
    new Blueprint class ](img/Figure_1.23_B18531.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.23 – 创建新蓝图类时弹出的选择父类窗口](img/Figure_1.23_B18531.jpg)'
- en: Figure 1.23 – The Pick Parent Class window that pops up when you create a new
    Blueprint class
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.23 – 创建新蓝图类时弹出的选择父类窗口
- en: Select the first class from this window – that is, the `Actor` class. After
    this, the text of the new Blueprint class will be automatically selected so that
    you can easily name it what you want. Name this Blueprint class `TestActor` and
    press the *Enter* key to accept this name.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这个窗口中选择第一个类 – 即，`Actor` 类。之后，新蓝图类的文本将自动选中，以便你可以轻松地给它命名。将这个蓝图类命名为 `TestActor`
    并按 *Enter* 键接受这个名称。
- en: After following these steps, you will have created your Blueprint class and
    completed this exercise. Once you’ve created this asset, double-click on it with
    the *left mouse button* to open the Blueprint editor. We will learn more about
    this in the next section.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在遵循这些步骤之后，你将创建你的蓝图类并完成这个练习。一旦你创建了此资产，用 *左鼠标键* 双击它以打开蓝图编辑器。我们将在下一节中了解更多关于这个内容。
- en: Exploring the Blueprint editor
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索蓝图编辑器
- en: The Blueprint editor is a sub-editor within the Unreal Engine editor specifically
    for Blueprint classes. Here, you can edit the properties and logic for your Blueprint
    classes, or those of their parent classes, as well as their visual appearance.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝图编辑器是 Unreal Engine 编辑器中专门用于蓝图类的子编辑器。在这里，你可以编辑你的蓝图类及其父类的属性和逻辑，以及它们的视觉外观。
- en: 'When you open an Actor Blueprint class, you should see the Blueprint editor.
    This window will allow you to edit your Blueprint classes in UE5\. Let’s learn
    about the windows that you’re currently seeing:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打开一个演员蓝图类时，你应该看到蓝图编辑器。这个窗口将允许你在 UE5 中编辑你的蓝图类。让我们了解你现在看到的窗口：
- en: '![Figure 1.24 – The Blueprint editor window is broken down into five parts
    ](img/Figure_1.24_B18531.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.24 – 蓝图编辑器窗口分为五个部分](img/Figure_1.24_B18531.jpg)'
- en: Figure 1.24 – The Blueprint editor window is broken down into five parts
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.24 – 蓝图编辑器窗口分为五个部分
- en: 'Let’s look at these windows in more detail:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这些窗口：
- en: '**Viewport**: Front and center in the editor, you have the **Viewport** window.
    This window, similar to the **Level Viewport** window that we already learned
    about, will allow you to visualize your Actor and edit its components. Every Actor
    can have several Actor Components, some of which have a visual representation,
    such as Mesh Components and Collision Components. We’ll talk about Actor Components
    in more depth later in this book.'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**视口**：在编辑器的正中央，您有**视口**窗口。这个窗口类似于我们之前已经了解过的**级别视口**窗口，它将允许您可视化您的演员并编辑其组件。每个演员都可以有多个演员组件，其中一些具有视觉表示，例如网格组件和碰撞组件。我们将在本书的后面更深入地讨论演员组件。'
- en: Technically, this center window contains three tabs, only one of which is the
    **Viewport** window, but we’ll be talking about the other important tab, **Event
    Graph**, after we tackle this editor’s interface. The third tab is the **Construction
    Script** window, which will not be covered in this book.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，这个中心窗口包含三个选项卡，其中只有一个选项卡是**视口**窗口，但我们在处理这个编辑器的界面之后，将讨论其他重要的选项卡**事件图**。第三个选项卡是**构造脚本**窗口，本书将不会涉及。
- en: '**Components**: At the top left of the editor, you have the **Components**
    window. As mentioned previously, Actors can have several Actor Components, and
    this window is the one that will allow you to add and remove those Actor Components
    in your Blueprint class, as well as access the Actor Components defined in the
    C++ classes it inherits from.'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**组件**：在编辑器的左上角，您有**组件**窗口。如前所述，演员可以有多个演员组件，这个窗口将允许您在蓝图类中添加和删除这些演员组件，以及访问它从C++类继承的演员组件。'
- en: '**My Blueprint**: At the bottom left of the editor, you have the **My Blueprint**
    window. This will allow you to browse, add, and remove variables and functions
    defined in both this Blueprint class and the C++ class it inherits from. Keep
    in mind that Blueprints have a special kind of function, called an **event**,
    which is used to represent an event that happened in the game. You should see
    three of them in this window: **BeginPlay**, **ActorBeginOverlap**, and **Tick**.
    We’ll be talking about these shortly.'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**我的蓝图**：在编辑器的左下角，您可以看到**我的蓝图**窗口。这个窗口将允许您浏览、添加和删除在这个蓝图类及其继承的C++类中定义的变量和函数。请记住，蓝图有一种特殊类型的函数，称为**事件**，用于表示游戏中发生的事件。您应该在这个窗口中看到三个事件：**BeginPlay**、**ActorBeginOverlap**和**Tick**。我们很快就会讨论这些。'
- en: '**Details**: At the right of the editor, you have the **Details** window. Similar
    to the editor’s **Details** window, this window will show you the properties of
    the currently selected Actor Component, function, variable, event, or any other
    individual element of this Blueprint class. If you currently have no elements
    selected, this window will be empty.'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**详细信息**：在编辑器的右侧，您有**详细信息**窗口。类似于编辑器的**详细信息**窗口，这个窗口将显示当前所选演员组件、函数、变量、事件或任何其他蓝图类的单个元素的属性。如果您当前没有选择任何元素，这个窗口将是空的。'
- en: '**Toolbar**: At the top center of the editor, you have the **Toolbar** window.
    This window will allow you to compile the code you wrote in this Blueprint class,
    save it, locate it in the **Content Browser** window, and access this class’s
    settings, among other things.'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**工具栏**：在编辑器的顶部中央，您有**工具栏**窗口。这个窗口将允许您编译您在这个蓝图类中编写的代码，保存它，在**内容浏览器**窗口中定位它，以及访问这个类的设置等。'
- en: You can see the parent class of a Blueprint class by looking at the top-right
    corner of the Blueprint editor. If you click the name of the parent class, you’ll
    be taken to either the corresponding Blueprint class, through the Unreal Engine
    editor, or the C++ class, through Visual Studio.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过查看蓝图编辑器的右上角来查看蓝图类的父类。如果您点击父类的名称，您将被带到通过虚幻引擎编辑器对应的蓝图类，或者通过Visual Studio对应的C++类。
- en: Additionally, you can change a Blueprint class’s parent class by clicking on
    the **File** tab at the top left of the Blueprint editor and selecting the **Reparent
    Blueprint** option, which will allow you to specify the new parent class of this
    Blueprint class.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以通过点击蓝图编辑器左上角的**文件**选项卡并选择**重新父化蓝图**选项来更改蓝图类的父类，这将允许您指定这个蓝图类的新父类。
- en: Now that we’ve learned about the basics of the Blueprint editor, let’s look
    at its **Event Graph**.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了蓝图编辑器的基础知识，让我们来看看它的**事件图**。
- en: Exploring the Event Graph window
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索事件图窗口
- en: The **Event Graph** window is where you’ll be writing all of your Blueprint
    visual scripting code, creating your variables and functions, and accessing other
    variables and functions declared in this class’s parent class.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件图** 窗口是你在其中编写所有蓝图可视化脚本代码、创建你的变量和函数，以及访问在此类父类中声明的其他变量和函数的地方。'
- en: 'If you select the **Event Graph** tab, which you should be able to see to the
    right of the **Viewport** tab, you will be shown the **Event Graph** window instead
    of the **Viewport** window. On clicking the **Event Graph** tab, you will see
    the following window:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择 **事件图** 选项卡，你应该能在 **视口** 选项卡的右侧看到它，你将看到 **事件图** 窗口而不是 **视口** 窗口。点击 **事件图**
    选项卡时，你会看到以下窗口：
- en: '![Figure 1.25 – The Event Graph window, showing three disabled events ](img/Figure_1.25_B18531.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.25 – 显示三个禁用事件的“事件图”窗口](img/Figure_1.25_B18531.jpg)'
- en: Figure 1.25 – The Event Graph window, showing three disabled events
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.25 – 显示三个禁用事件的“事件图”窗口
- en: You can navigate the **Event Graph** window by holding the *right mouse button*
    and dragging inside the graph, you can zoom in and out by scrolling the *mouse
    wheel*, and you can select nodes from the graph by either clicking the *left mouse
    button* or by clicking and holding to select an area of nodes.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过按住 **右鼠标按钮** 并在图中拖动来导航 **事件图** 窗口，你可以通过滚动 **鼠标滚轮** 来放大和缩小，你可以通过点击 **左鼠标按钮**
    或点击并按住来选择节点区域。
- en: You can also *right-click* inside the **Event Graph** window to access the Blueprint’s
    **Actions** menu, which allows you to access the actions you can perform in the
    **Event Graph** window, including getting and setting variables, calling functions
    or events, and many others.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在 **事件图** 窗口中 **右键单击** 来访问蓝图（Blueprint）的 **动作** 菜单，这允许你访问在 **事件图** 窗口中可以执行的操作，包括获取和设置变量、调用函数或事件，以及其他许多操作。
- en: 'The way scripting works in Blueprint is by connecting nodes using pins. There
    are several types of nodes, such as variables, functions, and events. You can
    connect these nodes through pins, of which there are two types:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在蓝图（Blueprint）中脚本的工作方式是通过使用引脚连接节点。有几种类型的节点，例如变量、函数和事件。你可以通过引脚连接这些节点，其中有两种类型的引脚：
- en: '**Execution pins**: These will dictate the order in which the nodes will be
    executed. If you want node 1 to be executed first and then node 2, you can link
    the output execution pin of node 1 to the input execution pin of node 2, as shown
    in the following screenshot:'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行引脚**：这些将决定节点执行的顺序。如果你想先执行节点 1，然后是节点 2，你可以将节点 1 的输出执行引脚链接到节点 2 的输入执行引脚，如下面的截图所示：'
- en: '![Figure 1.26 – Blueprint execution pins ](img/Figure_1.26_B18531.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.26 – 蓝图执行引脚](img/Figure_1.26_B18531.jpg)'
- en: Figure 1.26 – Blueprint execution pins
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.26 – 蓝图执行引脚
- en: '**Variable pins**: These work as parameters (also known as input pins), at
    the left of the node, and return values (also known as output pins), at the right
    of the node, representing a value of a certain type (integer, float, Boolean,
    and others):'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变量引脚**：这些作为参数（也称为输入引脚），位于节点的左侧，并返回值（也称为输出引脚），位于节点的右侧，代表某种类型的值（整数、浮点数、布尔值等）：'
- en: '![Figure 1.27 – The Get Scalar Parameter Value node ](img/Figure_1.27_B18531.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.27 – 获取标量参数值节点](img/Figure_1.27_B18531.jpg)'
- en: Figure 1.27 – The Get Scalar Parameter Value node
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.27 – 获取标量参数值节点
- en: Let’s understand this better by completing an exercise.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成一个练习来更好地理解这一点。
- en: Exercise 1.04 – creating Blueprint variables
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.04 – 创建蓝图变量
- en: In this exercise, we will learn how to create Blueprint variables by creating
    a new variable of the **Boolean** type.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将通过创建一个 **布尔型** 的新变量来学习如何创建蓝图变量。
- en: In Blueprint, variables work similarly to the ones you would use in C++. You
    can create them, get their value, and set them.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在蓝图（Blueprint）中，变量与你在 C++ 中使用的变量工作方式类似。你可以创建它们，获取它们的值，并设置它们。
- en: 'Follow these steps to complete this exercise:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成这个练习：
- en: 'To create a new Blueprint variable, head to the **My Blueprint** window and
    click the **+** button in the **Variables** category:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个新的蓝图变量，前往 **My Blueprint** 窗口，并在 **变量** 类别中点击 **+** 按钮：
- en: '![Figure 1.28 – The + button in the Variables category ](img/Figure_1.28_B18531.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.28 – 变量类别中的 + 按钮](img/Figure_1.28_B18531.jpg)'
- en: Figure 1.28 – The + button in the Variables category
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.28 – 变量类别中的 + 按钮
- en: 'After that, you’ll automatically be allowed to name your new variable. Name
    this new variable `MyVar`:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，你将自动被允许命名你的新变量。将这个新变量命名为 `MyVar`：
- en: '![Figure 1.29 – Naming the new variable MyVar ](img/Figure_1.29_B18531.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图1.29 – 命名新变量MyVar](img/Figure_1.29_B18531.jpg)'
- en: Figure 1.29 – Naming the new variable MyVar
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.29 – 命名新变量MyVar
- en: 'Compile your Blueprint by clicking the **Compile** button on the left-hand
    side of the **Toolbar** window:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**工具栏**窗口左侧的**编译**按钮来编译您的蓝图：
- en: '![Figure 1.30 – The Compile button ](img/Figure_1.30_B18531.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图1.30 – 编译按钮](img/Figure_1.30_B18531.jpg)'
- en: Figure 1.30 – The Compile button
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.30 – 编译按钮
- en: 'Now, if you look at the **Details** window, you should see the following:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果您查看**详细**窗口，您应该会看到以下内容：
- en: '![Figure 1.31 – The MyVar variable settings in the Details window ](img/Figure_1.31_B18531.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图1.31 – 详细窗口中的MyVar变量设置](img/Figure_1.31_B18531.jpg)'
- en: Figure 1.31 – The MyVar variable settings in the Details window
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.31 – 详细窗口中的MyVar变量设置
- en: 'Here, you’ll be able to edit all the settings related to this variable, with
    the most important ones being **Variable Name**, **Variable Type**, and **Default
    Value** at the end of the settings. You can change the values of Boolean variables
    by clicking the gray box to their right:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，您将能够编辑与该变量相关的所有设置，其中最重要的设置包括设置末尾的**变量名称**、**变量类型**和**默认值**。您可以通过点击右侧的灰色框来更改布尔变量的值：
- en: '![Figure 1.32 – The variable types available from the Variable Type drop-down
    menu](img/Figure_1.32_B18531.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图1.32 – 变量类型下拉菜单中可用的变量类型](img/Figure_1.32_B18531.jpg)'
- en: Figure 1.32 – The variable types available from the Variable Type drop-down
    menu
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.32 – 变量类型下拉菜单中可用的变量类型
- en: 'You can also drag a getter or setter for a variable inside the **My Blueprint**
    tab into the **Event Graph** window:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以将**My Blueprint**选项卡中的变量获取器或设置器拖动到**事件图**窗口中：
- en: '![Figure 1.33 – Dragging the MyVar variable into the Event Graph window ](img/Figure_1.33_B18531.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图1.33 – 将MyVar变量拖动到事件图窗口中](img/Figure_1.33_B18531.jpg)'
- en: Figure 1.33 – Dragging the MyVar variable into the Event Graph window
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.33 – 将MyVar变量拖动到事件图窗口中
- en: Getters are nodes that contain the current value of a variable, while setters
    are nodes that allow you to change the value of a variable.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 获取器是包含变量当前值的节点，而设置器是允许您更改变量值的节点。
- en: 'To allow a variable to be editable in each of the instances of this Blueprint
    class, you can click the eye icon to the right of that variable inside the **My
    Blueprint** window:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要允许变量在蓝图类每个实例中可编辑，您可以点击**My Blueprint**窗口中该变量的右侧的眼睛图标：
- en: '![Figure 1.34 – Clicking the eye icon to expose a variable and allow it to
    be instance-editable ](img/Figure_1.34_B18531.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图1.34 – 点击眼睛图标以显示变量并允许实例编辑](img/Figure_1.34_B18531.jpg)'
- en: Figure 1.34 – Clicking the eye icon to expose a variable and allow it to be
    instance-editable
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.34 – 点击眼睛图标以显示变量并允许实例编辑
- en: 'Then, you can drag an instance of this class to your level, select that instance,
    and see the option to change that variable’s value in the **Details** window of
    the editor:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您可以将此类的一个实例拖动到您的级别，选择该实例，并在编辑器的**详细**窗口中看到更改该变量值的选项：
- en: '![Figure 1.35 – The exposed MyVar variable that can be edited through the Details
    panel of that object ](img/Figure_1.35_B18531.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图1.35 – 可以通过该对象的详细面板编辑的公开MyVar变量](img/Figure_1.35_B18531.jpg)'
- en: Figure 1.35 – The exposed MyVar variable that can be edited through the Details
    panel of that object
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.35 – 可以通过该对象的详细面板编辑的公开MyVar变量
- en: And with that, you know how to create Blueprint variables. Now, let’s learn
    how to create Blueprint functions.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，您就知道了如何创建蓝图变量。现在，让我们学习如何创建蓝图函数。
- en: Exercise 1.05 – creating Blueprint functions
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.05 – 创建蓝图函数
- en: 'In this exercise, we will create our first Blueprint function. In Blueprint,
    functions and events are relatively similar, with the only difference being that
    an event will only have an output pin, usually because it gets called from outside
    of the Blueprint class:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建我们的第一个蓝图函数。在蓝图里，函数和事件相对相似，唯一的区别是事件通常只有一个输出引脚，通常是因为它从蓝图类外部被调用：
- en: '![Figure 1.36 – An event (left), a pure function call that doesn’t need execution
    pins (middle), and a normal function call (right) ](img/Figure_1.36_B18531.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图1.36 – 事件（左）、纯函数调用（中间）和普通函数调用（右）](img/Figure_1.36_B18531.jpg)'
- en: Figure 1.36 – An event (left), a pure function call that doesn’t need execution
    pins (middle), and a normal function call (right)
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.36 – 事件（左）、纯函数调用（中间）和普通函数调用（右）
- en: 'Follow these steps to complete this exercise:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此练习：
- en: 'Click the **+** button inside the **Functions** category of the **My Blueprint**
    window:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**My Blueprint**窗口的**函数**类别中点击**+**按钮：
- en: '![Figure 1.37 – The + Function button being hovered over, which will create
    a new function ](img/Figure_1.37_B18531.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图1.37 – 悬停在+函数按钮上，这将创建一个新函数](img/Figure_1.37_B18531.jpg)'
- en: Figure 1.37 – The + Function button being hovered over, which will create a
    new function
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.37 – 悬停在+函数按钮上，这将创建一个新函数
- en: Name the new function `MyFunc`.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新函数命名为`MyFunc`。
- en: Compile your Blueprint by clicking the **Compile** button in the **Toolbar**
    window.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击**工具栏**窗口中的**编译**按钮来编译你的蓝图。
- en: 'Now, if you look at the **Details** window, you should see the following:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果你查看**详细信息**窗口，你应该会看到以下内容：
- en: '![Figure 1.38 – The Details panel for the MyFunc function ](img/Figure_1.38_B18531.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图1.38 – MyFunc函数的详细信息面板](img/Figure_1.38_B18531.jpg)'
- en: Figure 1.38 – The Details panel for the MyFunc function
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.38 – MyFunc函数的详细信息面板
- en: Here, you can edit all the settings related to this function, with the most
    important ones being **Inputs** and **Outputs**. These will allow you to specify
    the variables that this function must receive and will return.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以编辑与此函数相关的所有设置，其中最重要的设置是**输入**和**输出**。这将允许你指定此函数必须接收的变量以及它将返回的变量。
- en: 'Lastly, you can edit what this function does by *clicking* it inside the `false`
    every time it is called:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以通过每次调用时在`false`内部**点击**它来编辑此函数的功能：
- en: '![Figure 1.39 – The MyFunc function ](img/Figure_1.39_B18531.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图1.39 – MyFunc函数](img/Figure_1.39_B18531.jpg)'
- en: Figure 1.39 – The MyFunc function
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.39 – MyFunc函数
- en: To save the modifications we made to this Blueprint class, click the **Save**
    button next to the **Compile** button on the toolbar. Alternatively, you can have
    it so that the Blueprint automatically saves every time you compile it successfully
    by selecting that option.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要保存我们对这个蓝图类所做的修改，请点击工具栏上**编译**按钮旁边的**保存**按钮。或者，你可以选择在每次成功编译时自动保存蓝图，通过选择该选项来实现。
- en: Now, you know how to create Blueprint functions. Next, we will look at the **Multiply**
    Blueprint node we’ll be making use of in this chapter’s remaining exercises and
    activities.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经知道如何创建蓝图函数。接下来，我们将查看本章剩余练习和活动中将使用的**乘法**蓝图节点。
- en: Understanding the Multiply node
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解乘法节点
- en: 'Blueprints contain many more nodes that are not related to variables or functions.
    One such example is arithmetic nodes (that is, adding, subtracting, multiplying,
    and so on). If you search for `Multiply` in the Blueprint **Actions** menu, you’ll
    find the **Multiply** node:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝图包含许多与变量或函数无关的节点。其中一个例子是算术节点（即，加法、减法、乘法等）。如果你在蓝图**动作**菜单中搜索“**乘法**”，你会找到**乘法**节点：
- en: '![Figure 1.40 – The multiply node ](img/Figure_1.40_B18531.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图1.40 – 乘法节点](img/Figure_1.40_B18531.jpg)'
- en: Figure 1.40 – The multiply node
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.40 – 乘法节点
- en: This node allows you to input two or more parameters, which can be of many types
    (for example, integer, float, vector, and so on; you can add more by clicking
    the **+** icon to the right of the **Add pin** text) and output the result of
    multiplying all of them. We will be using this node later, in this chapter’s activity.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 此节点允许你输入两个或更多参数，这些参数可以是多种类型（例如，整数、浮点数、向量等；你可以通过点击“**添加引脚**”文本右侧的**+**图标来添加更多；），并且输出所有这些参数相乘的结果。我们将在本章的活动中使用此节点。
- en: Exploring the BeginPlay and Tick events
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索BeginPlay和Tick事件
- en: 'Now, let’s look at two of the most important events in UE5: **BeginPlay** and
    **Tick**.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看UE5中最重要的事件中的两个：**BeginPlay**和**Tick**。
- en: As mentioned previously, events will usually be called from outside the Blueprint
    class. In the case of the **BeginPlay** event, this event gets called either when
    an instance of this Blueprint class is placed in the level and the level starts
    being played, or when an instance of this Blueprint class is spawned dynamically
    while the game is being played. You can think of the **BeginPlay** event as the
    first event that will be called on an instance of this Blueprint, which you can
    use for initialization.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，事件通常会在蓝图类外部被调用。在**BeginPlay**事件的例子中，此事件在将此蓝图类的实例放置在级别中并且级别开始播放时被调用，或者当在游戏进行时动态生成此蓝图类的实例时被调用。你可以将**BeginPlay**事件视为将在蓝图实例上首先被调用的第一个事件，你可以用它来进行初始化。
- en: The other important event to know about in UE5 is the **Tick** event. As you
    may know, games run at a certain frame rate, with the most frequent being either
    30 **frames per second** (**FPS**) or 60 FPS. This means that the game will render
    an updated image of the game 30 or 60 times every second. The **Tick** event will
    get called every time the game does this, which means that if the game is running
    at 30 FPS, the **Tick** event will get called 30 times every second.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在 UE5 中，另一个需要了解的重要事件是 **Tick** 事件。正如你可能知道的，游戏以一定的帧率运行，最常见的帧率是每秒 30 **帧**（**FPS**）或
    60 FPS。这意味着游戏每秒将渲染游戏更新的图像 30 或 60 次。每当游戏这样做时，**Tick** 事件都会被调用，这意味着如果游戏以 30 FPS
    运行，**Tick** 事件每秒将被调用 30 次。
- en: 'Go to your Blueprint class’s **Event Graph** window and delete the three grayed-out
    events by selecting all of them and clicking the *Delete* key, which should cause
    the **Event Graph** window to become empty. After that, *right-click* inside the
    **Event Graph** window, type in **BeginPlay**, and select the **Event BeginPlay**
    node by either clicking the *Enter* key or by clicking on that option in the Blueprint
    **Actions** menu. This should cause that event to be added to the **Event Graph**
    window:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 前往你的蓝图类的事件图窗口，通过选择所有三个灰色事件并点击 *Delete* 键来删除它们，这将导致事件图窗口变为空。之后，在事件图窗口内 *右键单击*，输入
    **BeginPlay**，然后通过按 *Enter* 键或在蓝图 **操作** 菜单中选择该选项来选择 **Event BeginPlay** 节点。这应该会导致该事件被添加到事件图窗口中：
- en: '![Figure 1.41 – The BeginPlay event being added to the Event Graph window through
    the Blueprint Actions menu](img/Figure_1.41_B18531.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.41 – 通过蓝图操作菜单将 BeginPlay 事件添加到事件图窗口](img/Figure_1.41_B18531.jpg)'
- en: Figure 1.41 – The BeginPlay event being added to the Event Graph window through
    the Blueprint Actions menu
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.41 – 通过蓝图操作菜单将 BeginPlay 事件添加到事件图窗口
- en: '*Right-click* inside the **Event Graph** window, type **Tick**, and select
    the **Event Tick** node. This should cause that event to be added to the **Event
    Graph** window:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件图窗口内 *右键单击*，输入 **Tick**，然后选择 **Event Tick** 节点。这应该会导致该事件被添加到事件图窗口中：
- en: '![Figure 1.42 – The Tick event ](img/Figure_1.42_B18531.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.42 – Tick 事件](img/Figure_1.42_B18531.jpg)'
- en: Figure 1.42 – The Tick event
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.42 – Tick 事件
- en: Unlike the **BeginPlay** event, the **Tick** event will be called with a parameter,
    **DeltaTime**. This parameter is a float that indicates the amount of time that
    has passed since the last frame was rendered. If your game is running at 30 FPS,
    this means that the interval between each of the frames being rendered (the delta
    time) is going to be, on average, 1/30 seconds, which is around 0.033 seconds
    (33.33 milliseconds). If frame 1 is rendered and then frame 2 is rendered 0.2
    seconds after that, then frame 2’s delta time will be 0.2 seconds. If frame 3
    gets rendered 0.1 seconds after frame 2, frame 3’s delta time will be 0.1 seconds,
    and so forth.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 与 **BeginPlay** 事件不同，**Tick** 事件将以一个参数 **DeltaTime** 被调用。这个参数是一个浮点数，表示自上一帧渲染以来经过的时间。如果你的游戏以
    30 FPS 运行，这意味着渲染每一帧之间的间隔（即时间差）平均将是 1/30 秒，大约是 0.033 秒（33.33 毫秒）。如果帧 1 被渲染，然后帧
    2 在 0.2 秒后渲染，那么帧 2 的时间差将是 0.2 秒。如果帧 3 在帧 2 后 0.1 秒被渲染，那么帧 3 的时间差将是 0.1 秒，以此类推。
- en: 'But why is the **DeltaTime** parameter so important? Let’s take a look at the
    following scenario: you have a Blueprint class that increases its position on
    the *Z*-axis by 1 unit every time a frame is rendered using the **Tick** event.
    However, you are faced with a problem: there’s the possibility that players will
    run your game at different frame rates, such as 30 FPS and 60 FPS. The players
    that are running the game at 60 FPS will cause the **Tick** event to be called
    twice as much as the players that are running the game at 30 FPS, and the Blueprint
    class will end up moving twice as fast because of that. This is where the delta
    time comes into play: because the game that’s running at 60 FPS will have the
    **Tick** event called with a lower delta time value (the interval between the
    frames being rendered is much smaller), you can use that value to change the position
    on the *Z*-axis. Although the **Tick** event is being called twice as much on
    the game running at 60 FPS, its delta time is half the value, so it all balances
    out. This will cause two players playing the game with different frame rates to
    have the same result.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么**DeltaTime**参数如此重要？让我们看看以下场景：你有一个蓝图类，每次使用**Tick**事件渲染帧时，都会在其*Z*-轴上增加1个单位。然而，你面临一个问题：玩家可能会以不同的帧率运行你的游戏，例如30
    FPS和60 FPS。以60 FPS运行游戏的玩家将导致**Tick**事件被调用两次，而以30 FPS运行游戏的玩家，蓝图类将因为这一点而移动得更快。这就是delta
    time发挥作用的地方：因为以60 FPS运行的游戏的**Tick**事件将以较低的delta time值被调用（渲染帧之间的间隔要小得多），你可以使用这个值来改变*Z*-轴上的位置。尽管在以60
    FPS运行的游戏中**Tick**事件被调用得更多，但其delta time值是后者的一半，所以一切都会平衡。这将导致以不同帧率玩游戏的两个玩家得到相同的结果。
- en: Note
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In this book, the **Tick** event is used a few times for demonstration purposes.
    However, because of its performance hit, you should be mindful when using it.
    If you use the **Tick** event for something that doesn’t need to be done every
    single frame, there’s probably a better or more efficient way of doing it.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，为了演示目的，**Tick**事件被使用了几次。然而，由于其性能影响，使用时应谨慎。如果你将**Tick**事件用于不需要每帧都执行的操作，可能存在更好的或更高效的方法来完成它。
- en: Note
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you want a Blueprint that is using the delta time to move, you can make it
    move faster or slower by multiplying the delta time by the number of units you
    want it to move per second (for example, if you want a Blueprint to move 3 units
    per second on the *Z*-axis, you can tell it to move `3 * DeltaTime` units every
    frame).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要一个使用delta time移动的蓝图，你可以通过将delta time乘以你想要它每秒移动的单位数（例如，如果你想要蓝图在*Z*-轴上每秒移动3个单位，你可以告诉它在每一帧移动`3
    * DeltaTime`个单位）来加快或减慢它的移动速度。
- en: Now, let’s complete an exercise where we will work with Blueprint nodes and
    pins.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们完成一个练习，我们将在这个练习中与蓝图节点和引脚一起工作。
- en: Exercise 1.06 – offsetting the TestActor class on the Z-axis
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.06 – 在Z轴上偏移TestActor类
- en: In this exercise, you’ll be using the `BeginPlay` event to offset (move) the
    `TestActor` class on the *Z*-axis when the game starts being played.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将使用`BeginPlay`事件在游戏开始播放时在*Z*-轴上偏移（移动）`TestActor`类。
- en: 'Follow these steps to complete this exercise:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此练习：
- en: Open the `TestActor` Blueprint class.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`TestActor`蓝图类。
- en: Using the `Event BeginPlay` node to the graph, if it’s not already there.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用图中的`Event BeginPlay`节点，如果它还没有在那里的话。
- en: 'Add the `AddActorWorldOffset` function and connect the `BeginPlay` event’s
    output execution pin to this function’s input execution pin. This function is
    responsible for moving an Actor in the intended axes (*X*, *Y*, and *Z*) and it
    receives the following parameters:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`AddActorWorldOffset`函数，并将`BeginPlay`事件的输出执行引脚连接到该函数的输入执行引脚。此函数负责在预期的轴（*X*、*Y*和*Z*）上移动Actor，并接收以下参数：
- en: '`Target`: The Actor that this function should be called on, which will be the
    Actor calling this function. The default behavior is to call this function on
    the Actor calling this function, which is exactly what we want and is shown using
    the `self` property.'
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`目标`: 这个函数应该被调用的Actor，这将是被调用此函数的Actor。默认行为是在调用此函数的Actor上调用此函数，这正是我们想要的，并且使用`self`属性展示了这一点。'
- en: '`DeltaLocation`: The amount that we want to offset this Actor by in each of
    the three axes: *X*, *Y*, and *Z*.'
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DeltaLocation`: 我们想要在每个三个轴（*X*、*Y*和*Z*）上偏移此Actor的量。'
- en: 'We won’t be getting into the other two parameters, `Sweep` and `Teleport`,
    so you can leave them as-is. They are both Boolean types and should be left set
    to `false`:'
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不会深入探讨其他两个参数，`Sweep` 和 `Teleport`，因此您可以保持它们不变。它们都是布尔类型，应设置为 `false`：
- en: '![Figure 1.43 – The BeginPlay event calling the AddActorWorldOffset function
    ](img/Figure_1.43_B18531.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.43 – BeginPlay 事件调用 AddActorWorldOffset 函数](img/Figure_1.43_B18531.jpg)'
- en: Figure 1.43 – The BeginPlay event calling the AddActorWorldOffset function
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.43 – BeginPlay 事件调用 AddActorWorldOffset 函数
- en: 'Split the `Delta Location` input pin, which will cause this `Vector` property
    to be split into three float properties. You can do this to any variable type
    that is comprised of one or more subtypes (you wouldn’t be able to do this to
    the float type because it’s not comprised of any variable subtypes) by *right-clicking*
    on them and selecting **Split Struct Pin**:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Delta Location` 输入引脚分割，这将导致此 `Vector` 属性被分割成三个浮点属性。您可以通过在它们上 *右键单击* 并选择 **分割结构引脚**
    来对此进行操作，任何由一个或多个子类型组成的变量类型都可以这样做（您无法对浮点类型这样做，因为它不包含任何变量子类型）：
- en: '![Figure 1.44 – The Delta Location parameter being split from a vector into
    three floats ](img/Figure_1.44_B18531.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.44 – Delta 位置参数从矢量分割成三个浮点数](img/Figure_1.44_B18531.jpg)'
- en: Figure 1.44 – The Delta Location parameter being split from a vector into three
    floats
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.44 – Delta 位置参数从矢量分割成三个浮点数
- en: Set the *Z* property of `100` units by using the *left mouse button*, typing
    that number, and then pressing the *Enter* key. This will cause our `100` units
    when the game starts.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 *左鼠标按钮* 设置 `100` 单位的 *Z* 属性，输入该数字，然后按 *Enter* 键。这将使游戏开始时我们的 `100` 单位。
- en: 'Add a cube shape to your **TestActor** using the **Components** window so that
    we can see our Actor. You can do this by clicking the **+ Add** button, typing
    **Cube**, and then selecting the first option under the **Basic Shapes** section:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **组件** 窗口为您的 **TestActor** 添加一个立方体形状，以便我们可以看到我们的 Actor。您可以通过单击 **+ 添加** 按钮，输入
    **Cube**，然后在 **基本形状** 部分下选择第一个选项来完成此操作：
- en: '![Figure 1.45 – Adding a cube shape ](img/Figure_1.45_B18531.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.45 – 添加立方体形状](img/Figure_1.45_B18531.jpg)'
- en: Figure 1.45 – Adding a cube shape
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.45 – 添加立方体形状
- en: Compile and save your Blueprint class by clicking the **Compile** button.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过单击 **编译** 按钮编译并保存您的蓝图类。
- en: 'Go back to the level’s **Viewport** window and place an instance of your **TestActor**
    Blueprint class inside the level, if you haven’t done so already:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回级别的 **视口** 窗口，并将您的 **TestActor** 蓝图类的一个实例放置在级别中，如果您还没有这样做的话：
- en: '![Figure 1.46 – Adding an instance of TestActor to the level ](img/Figure_1.46_B18531.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.46 – 将 TestActor 实例添加到级别中](img/Figure_1.46_B18531.jpg)'
- en: Figure 1.46 – Adding an instance of TestActor to the level
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.46 – 将 TestActor 实例添加到级别中
- en: 'When you play the level, you should notice that the **TestActor** class we
    added to the level is in a more elevated position:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您播放级别时，您应该会注意到我们添加到级别中的 **TestActor** 类位于更高的位置：
- en: '![Figure 1.47 – TestActor increasing its position on the Z-axis when the game
    starts ](img/Figure_1.47_B18531.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.47 – TestActor 在游戏开始时增加其在 Z 轴上的位置](img/Figure_1.47_B18531.jpg)'
- en: Figure 1.47 – TestActor increasing its position on the Z-axis when the game
    starts
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.47 – 游戏开始时 TestActor 在 Z 轴上增加其位置
- en: After making these modifications, save the changes that you’ve made to our level
    by either pressing *Ctrl* + *S* or clicking the **Save Current** button in the
    **Toolbar** window.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在进行这些修改后，通过按 *Ctrl* + *S* 或在 **工具栏** 窗口中单击 **保存当前** 按钮来保存您对我们级别的更改。
- en: In this exercise, you learned how to create your first Actor Blueprint class
    with Blueprint scripting logic.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您学习了如何使用蓝图脚本逻辑创建您的第一个 Actor 蓝图类。
- en: Note
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Both the `TestActor` Blueprint asset and the `Map` asset, along with the final
    result of this exercise, can be found here: [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition).'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestActor` 蓝图资产、`Map` 资产以及此练习的最终结果都可以在这里找到：[https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition)。'
- en: Now, let’s learn a bit more about the `ThirdPersonCharacter` Blueprint class.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更深入地了解 `ThirdPersonCharacter` 蓝图类。
- en: The ThirdPersonCharacter Blueprint class
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三人称角色蓝图类
- en: Let’s take a look at the `ThirdPersonCharacter` Blueprint class, which is the
    Blueprint that represents the character that the player controls, and look at
    the Actor Components that it contains.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`ThirdPersonCharacter`蓝图类，这是代表玩家控制的角色的蓝图，并查看它包含的演员组件。
- en: 'Go to the **ThirdPersonCPP** | **Blueprints** directory inside the **Content
    Browser** window and open the **ThirdPersonCharacter** asset:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 前往**内容浏览器（Content Browser**）窗口中的**ThirdPersonCPP** | **Blueprints**目录，并打开**ThirdPersonCharacter**资产：
- en: '![Figure 1.48 – The ThirdPersonCharacter Blueprint class ](img/Figure_1.48_B18531.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![图1.48 – ThirdPersonCharacter蓝图类](img/Figure_1.48_B18531.jpg)'
- en: Figure 1.48 – The ThirdPersonCharacter Blueprint class
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.48 – ThirdPersonCharacter蓝图类
- en: Previously, when we introduced the **Components** window inside the Blueprint
    editor, we mentioned **Actor Components**.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前在蓝图编辑器中介绍**组件（Components**）窗口时，我们提到了**演员组件（Actor Components**）。
- en: 'Actor Components are entities that must live inside an Actor and allow you
    to spread the logic of your Actor into several different Actor Components. In
    this Blueprint, we can see that there are four visually represented Actor Components:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 演员（Actor）组件是必须存在于演员（Actor）内部并允许您将演员的逻辑分散到几个不同的演员组件中的实体。在这个蓝图（Blueprint）中，我们可以看到有四个以视觉形式表示的演员组件：
- en: A Skeletal Mesh Component, which shows the UE5 mannequin
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个骨骼网格组件，它显示UE5的模特
- en: A Camera Component, which shows where the player will be able to see the game
    from
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个相机组件，它显示玩家将能够从哪里看到游戏
- en: An Arrow Component, which allows us to see where the character is facing (this
    is mainly used for development purposes, not while the game is being played)
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个箭头组件，它允许我们看到角色面向的方向（这主要用于开发目的，而不是在游戏进行时）
- en: A Capsule Component, which specifies the collision range of this character
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个胶囊组件，它指定了这个角色的碰撞范围
- en: If you look at the **Components** window, you’ll see a few more Actor Components
    than the ones we can see in the **Viewport** window. This is because some Actor
    Components don’t have a visual representation and are purely made up of C++ or
    Blueprint code. We’ll look at Actor Components in more depth in the next chapter
    and [*Chapter 7*](B18531_07.xhtml#_idTextAnchor154)*, Working with UE5 Utilities*.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看**组件（Components**）窗口，您会看到比我们在**视口（Viewport**）窗口中看到的更多演员组件。这是因为一些演员组件没有视觉表示，完全由C++或蓝图代码组成。我们将在下一章和[*第7章*](B18531_07.xhtml#_idTextAnchor154)*，使用UE5工具*中更深入地探讨演员组件。
- en: If you take a look at this Blueprint class’s **Event Graph** window, you’ll
    see that it’s essentially empty, similar to the one we saw with our **TestActor**
    Blueprint class, despite it having a bit of logic associated with it. This is
    because that logic is defined in the C++ class, not in this Blueprint class. We’ll
    look at how to do this in the next chapter.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看这个蓝图类的事件图（**Event Graph**）窗口，您会发现它基本上是空的，类似于我们之前看到的**测试演员（TestActor**）蓝图类，尽管它与它关联了一些逻辑。这是因为这些逻辑是在C++类中定义的，而不是在这个蓝图类中。我们将在下一章中探讨如何做到这一点。
- en: To explain this Blueprint class’s Skeletal Mesh Component, we should first talk
    about meshes and materials.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释这个蓝图类的骨骼网格组件（Skeletal Mesh Component），我们首先应该谈谈网格和材质。
- en: Exploring the usage of meshes and materials
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索网格和材质的使用
- en: 'For a computer to visually represent a 3D object, it needs two things: a 3D
    mesh and a material. 3D meshes allow us to specify the shape of an object and
    its size, while a material allows us to specify its color and visual tones, among
    other things. We’ll dive deeper into both of these in the following sections and
    see how UE5 allows us to work with them.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让计算机以视觉形式表示一个3D对象，它需要两样东西：一个3D网格和一个材质。3D网格允许我们指定物体的形状和大小，而材质允许我们指定其颜色和视觉色调等。我们将在接下来的几节中深入了解这两者，并看看UE5如何允许我们与之交互。
- en: Meshes
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网格
- en: '3D meshes allow you to specify the size and shape of an object, like this mesh
    representing a monkey’s head:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 3D网格允许您指定物体的尺寸和形状，就像这个代表猴子头部的网格：
- en: '![Figure 1.49 – A 3D mesh of a monkey’s head ](img/Figure_1.49_B18531.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![图1.49 – 一只猴子的3D网格](img/Figure_1.49_B18531.jpg)'
- en: Figure 1.49 – A 3D mesh of a monkey’s head
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.49 – 一只猴子的3D网格
- en: Meshes are comprised of several vertices, edges, and faces. Vertices are simply
    3D coordinates with *X*, *Y,* and *Z* positions; an edge is a connection (that
    is, a line) between two vertices; and a face is a connection of three or more
    edges. The preceding screenshot shows the individual vertices, edges, and faces
    of the mesh, where each face is colored between white and black, depending on
    how much light is reflecting off the face. Nowadays, video games can render meshes
    with thousands of vertices in such a way that you can’t tell the individual vertices
    apart because there are so many of them so close together.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 网格由多个顶点、边和面组成。顶点仅仅是具有 *X*、*Y* 和 *Z* 位置的 3D 坐标；边是两个顶点之间的连接（即，一条线）；面是三个或更多边的连接。前面的截图显示了网格的各个顶点、边和面，其中每个面的颜色在白色和黑色之间，这取决于从面上反射的光量。如今，视频游戏可以以这种方式渲染具有数千个顶点的网格，以至于你无法分辨出单独的顶点，因为它们如此靠近且数量众多。
- en: Materials
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 材料
- en: Materials, on the other hand, allow you to specify how a mesh is going to be
    represented. They allow you to specify a mesh’s color, draw a texture on its surface,
    or even manipulate its vertices.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 材料另一方面允许你指定网格如何被表示。它们允许你指定网格的颜色，在其表面绘制纹理，甚至操纵其顶点。
- en: Creating meshes is something that, at the time of writing this book, is not
    properly supported in UE5 and should be done in another piece of software, such
    as Blender or Autodesk Maya, so we won’t be going into this in great detail here.
    We will, however, learn how to create materials for existing meshes.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，创建网格在 UE5 中没有得到适当的支持，应该在其他软件中完成，例如 Blender 或 Autodesk Maya，因此我们在这里不会详细介绍这一点。然而，我们将学习如何为现有网格创建材料。
- en: In UE5, you can add meshes through Mesh Components, which inherit from the Actor
    Component class. There are several types of Mesh Components, but the two most
    important ones are Static Mesh Components, for meshes that don’t have animations
    (for example, cubes, static level geometry), and Skeletal Mesh Components, for
    meshes that have animations (for example, character meshes that play movement
    animations). As we saw earlier, the **ThirdPersonCharacter** Blueprint class contains
    a Skeletal Mesh Component because it’s used to represent a character mesh that
    plays movement animations. In the next chapter, we’ll learn how to import assets
    such as meshes into our UE5 project.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在 UE5 中，你可以通过网格组件添加网格，这些组件继承自 Actor Component 类。有几种类型的网格组件，但最重要的两种是静态网格组件，用于没有动画的网格（例如，立方体、静态关卡几何体），和骨骼网格组件，用于具有动画的网格（例如，播放运动动画的角色网格）。如我们之前所见，**ThirdPersonCharacter**
    蓝图类包含一个骨骼网格组件，因为它用于表示播放运动动画的角色网格。在下一章中，我们将学习如何将网格等资产导入我们的 UE5 项目。
- en: Now, let’s learn how to manipulate materials in UE5.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何在 UE5 中操作材料。
- en: Manipulating materials in UE5
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 UE5 中操作材料
- en: 'In this section, we’ll learn how materials work in UE5\. As mentioned previously,
    materials are what specify the visual aspects of a certain object, including its
    color and how it reacts to light. To learn more about them, follow these steps:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习材料在 UE5 中的工作方式。如前所述，材料是用于指定某个对象的视觉方面，包括其颜色以及它对光的反应。要了解更多关于它们的信息，请按照以下步骤操作：
- en: 'Go back to your **Level Viewport** window and select the **Cube** object shown
    in the following screenshot:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回你的**级别视口**窗口，并选择以下截图所示的**立方体**对象：
- en: '![Figure 1.50 – The Cube object, next to the text that says Third Person on
    the floor ](img/Figure_1.50_B18531.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.50 – 立方体对象，位于地板上写着第三人称的文字旁边](img/Figure_1.50_B18531.jpg)'
- en: Figure 1.50 – The Cube object, next to the text that says Third Person on the
    floor
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.50 – 立方体对象，位于地板上写着第三人称的文字旁边
- en: 'Take a look at the **Details** window, where you’ll be able to see both the
    mesh and material associated with this object’s **Static Mesh** Component:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看**详细信息**窗口，在那里你可以看到与该对象的**静态网格组件**关联的网格和材料：
- en: '![Figure 1.51 – The Static Mesh and Materials (Element 0) properties of the
    Cube object’s Static Mesh Component ](img/Figure_1.51_B18531.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.51 – 立方体对象的静态网格组件的静态网格和材料属性（元素 0）](img/Figure_1.51_B18531.jpg)'
- en: Figure 1.51 – The Static Mesh and Materials (Element 0) properties of the Cube
    object’s Static Mesh Component
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.51 – 立方体对象的静态网格组件的静态网格和材料属性（元素 0）
- en: Note
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Keep in mind that meshes can have more than one material, but must have at least
    one.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，网格可以具有多个材料，但至少必须有一个。
- en: 'Click the *looking glass* icon next to the **Materials** property to be taken
    to that material’s location in the **Content Browser** window. This icon works
    with any reference to any asset inside the editor, so you can do the same thing
    with the asset referenced as the cube object’s **Static Mesh**:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **材料** 属性旁边的 **放大镜** 图标，可以跳转到 **内容浏览器** 窗口中该材质的位置。此图标与编辑器内任何资产的引用都兼容，因此你可以用相同的方式处理作为立方体对象
    **静态网格** 的引用的资产：
- en: '![Figure 1.52 – The looking glass icon (left), which takes you to that asset’s
    location in the Content Browser (right) ](img/Figure_1.52_B18531.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.52 – **放大镜** 图标（左），它带你到内容浏览器中该资产的位置（右）](img/Figure_1.52_B18531.jpg)'
- en: Figure 1.52 – The looking glass icon (left), which takes you to that asset’s
    location in the Content Browser (right)
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.52 – **放大镜** 图标（左），它带你到内容浏览器中该资产的位置（右）
- en: '*Double-click* the asset with the *left mouse button* to open its properties.
    Because this material is a child of another material, we must select its parent
    material. In this material’s **Details panel**, you’ll find the **Parent** property.
    Click the *looking glass* icon to select it in the **Context Browser** window:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**双击** 使用 **左鼠标按钮** 的资产以打开其属性。因为这种材质是另一个材质的子项，我们必须选择其父材质。在这个材质的 **详细信息面板**
    中，你会找到 **父** 属性。点击 **放大镜** 图标以在 **上下文浏览器** 窗口中选择它：'
- en: '![Figure 1.53 – The Parent property ](img/Figure_1.53_B18531.jpg)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.53 – 父属性](img/Figure_1.53_B18531.jpg)'
- en: Figure 1.53 – The Parent property
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.53 – 父属性
- en: 'After selecting that asset, double-click it with the *left mouse button* to
    open it in the **Material** Editor. Let’s break down the windows present in the
    **Material** Editor:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择该资产后，使用 **左鼠标按钮** 双击它以在 **材质** 编辑器中打开它。让我们分解一下 **材质** 编辑器中现有的窗口：
- en: '![Figure 1.54 – The Material Editor window broken down into five parts ](img/Figure_1.54_B18531.jpg)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.54 – 材质编辑器窗口分为五个部分](img/Figure_1.54_B18531.jpg)'
- en: Figure 1.54 – The Material Editor window broken down into five parts
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.54 – 材质编辑器窗口分为五个部分
- en: 'Let’s look at these windows in more detail:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这些窗口：
- en: '**Graph**: Front and center in the editor, you have the **Graph** window. Similar
    to the Blueprint editor’s **Event Graph** window, the **Material** Editor’s graph
    is also node-based, where you’ll also find nodes connected by pins, although here,
    you won’t find execution pins, only input and output pins.'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**图**：在编辑器的最前方和中心位置，你有 **图** 窗口。类似于蓝图编辑器的 **事件图** 窗口，材质编辑器的图也是基于节点的，你也会找到通过引脚连接的节点，尽管在这里，你不会找到执行引脚，只有输入和输出引脚。'
- en: '**Palette**: At the right edge of the screen, you’ll see the **Palette** window,
    where you can search for all the nodes that you can add to the **Graph** window.
    You can also do this the same way as in the Blueprint editor’s **Event Graph**
    window by *right-clicking* inside the **Graph** window and typing in the node
    you wish to add.'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**调色板**：在屏幕的右侧边缘，你会看到 **调色板** 窗口，在这里你可以搜索所有可以添加到 **图** 窗口的节点。你也可以通过在 **图**
    窗口中 **右键单击** 并输入你想要添加的节点的方式，以相同的方式在蓝图编辑器的 **事件图** 窗口中这样做。'
- en: '**Viewport**: At the top-left corner of the screen, you’ll see the **Viewport**
    window. Here, you can preview the result of your material and how it will appear
    on some basic shapes such as spheres, cubes, and planes.'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**视口**：在屏幕的左上角，你会看到 **视口** 窗口。在这里，你可以预览材质的结果以及它将如何出现在一些基本形状上，如球体、立方体和平面。'
- en: '**Details**: At the bottom-left corner of the screen, you’ll see the **Details**
    window where, similar to the Blueprint editor, you’ll see the details of either
    this **Material** asset or those of the currently selected node in the **Graph**
    window.'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**详细信息**：在屏幕的左下角，你会看到 **详细信息** 窗口，类似于蓝图编辑器，你会在其中看到此 **材质** 资产或当前在 **图** 窗口中选定的节点的详细信息。'
- en: '**Toolbar**: At the top edge of the screen, you’ll see the **Toolbar** window,
    where you’ll be able to apply and save the changes you’ve made to your material,
    as well as perform several actions related to the **Graph** window.'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**工具栏**：在屏幕的顶部边缘，你会看到 **工具栏** 窗口，在这里你可以应用和保存你对材质所做的更改，以及执行与 **图** 窗口相关的多个操作。'
- en: In every single Material Editor inside UE5, you’ll find a node with the name
    of that **Material** asset, where you’ll be able to specify several parameters
    related to it by plugging that node’s pins into other nodes.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在 UE5 中的每一个材质编辑器中，你都会找到一个名为该 **材质** 资产的节点，通过将此节点的引脚连接到其他节点，你可以指定与它相关的几个参数。
- en: In this case, you can see that there’s a node called `0.7` being plugged into
    the `0.7`. You can create constant nodes of a single number, a 2 vector (for example,
    `(1,` `0.5)`), a 3 vector (for example, `(1,` `0.5,` `4)`), and a 4 vector (for
    example, `(1,0.5,` `4,` `0)`). To create these nodes, you can click the **Graph**
    window with the *left mouse button* while holding the *1*, *2*, *3*, or *4* number
    keys, respectively.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你可以看到有一个名为 `0.7` 的节点被连接到 `0.7`。你可以创建单个数字、2 向量（例如，`(1,` `0.5)`）、3 向量（例如，`(1,`
    `0.5,` `4)`）和 4 向量（例如，`(1,0.5,` `4,` `0)`）的常量节点。要创建这些节点，你可以分别按住 *1*、*2*、*3* 或
    *4* 数字键，并用 *左鼠标按钮* 点击 **图形** 窗口。
- en: 'Materials have several input parameters, so let’s go through some of the most
    important ones:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 材料有多个输入参数，所以让我们来看看其中一些最重要的参数：
- en: '`BaseColor`: This parameter is simply the color of the material. Generally,
    constants or texture samples are used to connect to this pin, to either have an
    object be a certain color or to map to a certain texture.'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`基础颜色`：此参数仅仅是材料本身的颜色。通常，常量或纹理样本用于连接到此引脚，以便使物体具有某种颜色或映射到某种纹理。'
- en: '`Metallic`: This parameter will dictate how much your object will look like
    a metal surface. You can do this by connecting a constant single number node that
    ranges from 0 (not metallic) to 1 (very metallic).'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`金属度`：此参数将决定你的物体看起来有多像金属表面。你可以通过连接一个从 0（非金属）到 1（非常金属）的单个数字常量节点来实现这一点。'
- en: '`Specular`: This parameter will dictate how much your object will reflect light.
    You can do this by connecting a constant single number node that ranges from 0
    (doesn’t reflect any light) to 1 (reflects all the light). If your object is already
    very metallic, you will see little to no difference.'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`镜面反射`：此参数将决定你的物体反射多少光。你可以通过连接一个从 0（不反射任何光）到 1（反射所有光）的单个数字常量节点来实现这一点。如果你的物体已经非常金属，你将看到几乎没有区别。'
- en: '`Roughness`: This parameter will dictate how much the light that your object
    reflects will be scattered (the more the light scatters, the less clear this object
    will reflect what’s around it). You can do this by connecting a constant single
    number node that ranges from 0 (the object essentially becomes a mirror) to 1
    (the reflection on this object is blurry and unclear).'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`粗糙度`：此参数将决定你的物体反射的光会被散射多少（光散射越多，物体反射周围物体的清晰度越低）。你可以通过连接一个从 0（物体本质上变成镜子）到 1（此物体的反射模糊且不清晰）的单个数字常量节点来实现这一点。'
- en: Note
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To learn more about `material` inputs like the ones shown previously, go to
    [https://docs.unrealengine.com/en-US/Engine/Rendering/Materials/MaterialInputs](https://docs.unrealengine.com/en-US/Engine/Rendering/Materials/MaterialInputs).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于前面显示的 `material` 输入的信息，请访问 [https://docs.unrealengine.com/en-US/Engine/Rendering/Materials/MaterialInputs](https://docs.unrealengine.com/en-US/Engine/Rendering/Materials/MaterialInputs)。
- en: 'UE5 also allows you to import images (`.jpeg`, `.png`) as `Texture` assets,
    which can then be referenced in a material using `Texture Sample` nodes:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: UE5 还允许你将图像（`.jpeg`、`.png`）作为 `Texture` 资产导入，然后可以使用 `Texture Sample` 节点在材料中引用：
- en: '![Figure 1.55 – The Texture Sample node, which allows you to specify a texture
    and use it or its color channels as pins ](img/Figure_1.55_B18531.jpg)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.55 – 文本样本节点，允许你指定一个纹理并使用它或其颜色通道作为引脚](img/Figure_1.55_B18531.jpg)'
- en: Figure 1.55 – The Texture Sample node, which allows you to specify a texture
    and use it or its color channels as pins
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.55 – 文本样本节点，允许你指定一个纹理并使用它或其颜色通道作为引脚
- en: Note
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We will learn how to import files into UE5 in the next chapter.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章学习如何将文件导入 UE5。
- en: To create a new **Material** asset, *right-click* on the directory inside the
    **Content Browser** window where you want to create the new asset, which will
    allow you to choose which asset to create, and then select **Material**.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的 **材料** 资产，在 **内容浏览器** 窗口中你想要创建新资产的目录内 *右键单击*，这将允许你选择要创建哪种资产，然后选择 **材料**。
- en: With that, you know how to create and manipulate materials in UE5.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，你就知道了如何在 UE5 中创建和操作材料。
- en: Now, let’s jump into this chapter’s activity, which is the first activity in
    this book.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们进入本章的活动，这是本书的第一个活动。
- en: Activity 1.01 – propelling TestActor on the Z-axis indefinitely
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动一.01 – 在 Z 轴上无限期地推动 TestActor
- en: In this activity, you will use the `TestActor` to move it on the *Z*-axis indefinitely,
    instead of doing this only once when the game starts.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在此活动中，你将使用 `TestActor` 在 *Z* 轴上无限期地移动它，而不是在游戏开始时只做一次。
- en: 'Follow these steps to complete this activity:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此活动：
- en: Open the `TestActor` Blueprint class.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`TestActor`蓝图类。
- en: Add the **Event Tick** node to the Blueprint’s **Event Graph** window.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**事件Tick**节点添加到蓝图的**事件图**窗口中。
- en: Add the **AddActorWorldOffset** function, split its **DeltaLocation** pin, and
    connect the **Tick** event’s output execution pin to this function’s input execution
    pin, similar to what we did in *Exercise 1.01 – creating an Unreal Engine 5 project*.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加**AddActorWorldOffset**函数，分割其**DeltaLocation**引脚，并将**Tick**事件的输出执行引脚连接到这个函数的输入执行引脚，类似于我们在*练习1.01
    – 创建Unreal Engine 5项目*中所做的。
- en: Add a `Float Multiplication` node to the **Event Graph** window.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个`Float Multiplication`节点添加到**事件图**窗口中。
- en: Connect the **Tick** event’s **Delta Seconds** output pin to the first input
    pin of the **Float Multiplication** node.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Tick**事件的**Delta Seconds**输出引脚连接到**Float Multiplication**节点的第一个输入引脚。
- en: Create a new variable of the `float` type, call it `VerticalSpeed`, and set
    its default value to `25`.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`float`类型的新的变量，命名为`VerticalSpeed`，并将其默认值设置为`25`。
- en: Add a getter to the `VerticalSpeed` variable in the `Float Multiplication` node.
    After that, connect the `Float Multiplication` node’s output pin to the **Delta
    Location Z** pin of the **AddActorWorldOffset** function.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Float Multiplication`节点中添加一个getter到`VerticalSpeed`变量。之后，将`Float Multiplication`节点的输出引脚连接到**AddActorWorldOffset**函数的**Delta
    Location Z**引脚。
- en: Delete the **BeginPlay** event and the **AddActorWorldOffset** function connected
    to it, both of which we created in *Exercise 1.01 – creating an Unreal Engine
    5 project*.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除与它连接的**BeginPlay**事件和**AddActorWorldOffset**函数，这两个都是在*练习1.01 – 创建Unreal Engine
    5项目*中创建的。
- en: Delete the existing instance of our actor in the level and drag in a new one.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在关卡中删除我们现有的actor实例，并拖入一个新的实例。
- en: 'Play the level. You will notice our `TestActor` rising from the ground and
    up into the air over time:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放关卡。你会注意到我们的`TestActor`随着时间的推移从地面升起并进入空中：
- en: '![Figure 1.56 – TestActor propelling itself vertically ](img/Figure_1.56_B18531.jpg)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![图1.56 – TestActor垂直推进](img/Figure_1.56_B18531.jpg)'
- en: Figure 1.56 – TestActor propelling itself vertically
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.56 – TestActor垂直推进
- en: And with those steps completed, we have concluded this activity – the first
    of many in this book. We’ve consolidated adding and removing nodes to and from
    the Blueprint editor’s **Event Graph** window, as well as using the **Tick** event
    and its **DeltaSeconds** property to create game logic that maintains consistency
    across different frame rates.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些步骤后，我们结束了这个活动——本书中的第一个活动。我们已将添加和删除节点到和从蓝图编辑器的**事件图**窗口中，以及使用**Tick**事件及其**DeltaSeconds**属性来创建游戏逻辑，以保持不同帧率的一致性。
- en: Note
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: 'The solution to this activity can be found on GitHub here: [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions).'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在GitHub上找到：[https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition/tree/main/Activity%20solutions)。
- en: 'The `TestActor` Blueprint asset can be found here: [https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition).'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestActor`蓝图资产可以在以下位置找到：[https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition](https://github.com/PacktPublishing/Elevating-Game-Experiences-with-Unreal-Engine-5-Second-Edition)。'
- en: Summary
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: By completing this chapter, you have taken the first step in your game development
    journey by learning about UE5\. You now know how to navigate the Unreal Engine
    editor, manipulate the Actors inside a level, create Actors, use the Blueprint
    scripting language, and how 3D objects are represented in UE5.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成本章，你已经在游戏开发之旅中迈出了第一步，通过学习UE5。你现在知道如何导航Unreal Engine编辑器，操作关卡内的Actors，创建Actors，使用蓝图脚本语言，以及3D对象在UE5中的表示。
- en: Hopefully, you realize that there’s a whole world of possibilities ahead of
    you and that the sky is the limit in terms of the things you can create using
    this game development tool.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你能意识到前方有一个广阔的世界等待你去探索，而且在这个游戏开发工具的帮助下，你能创造的事物没有极限。
- en: In the next chapter, you will recreate the project template that was automatically
    generated in this chapter from scratch. You will learn how to create C++ classes
    and then create Blueprint classes that can manipulate properties declared in their
    parent class. You will also learn how to import character meshes and animations
    into Unreal Engine 5, as well as become familiar with other animation-related
    assets such as *Animation Blueprints*.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将从零开始重新创建本章中自动生成的项目模板。您将学习如何创建 C++ 类，然后创建可以操作其父类中声明的属性的蓝图类。您还将学习如何将角色网格和动画导入到
    Unreal Engine 5 中，以及熟悉其他与动画相关的资产，例如 *动画蓝图*。
