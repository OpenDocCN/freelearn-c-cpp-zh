["```cpp\n    git clone --recursive https://github.com/pfalcon/esp-open-sdk.git\n    cd esp-open-sdk\n    make VENDOR_SDK=1.5.4 STANDALONE=y  \n```", "```cpp\n    git clone https://github.com/SmingHub/Sming.git\n    cd Sming\n    make  \n```", "```cpp\n    wget https://github.com/themadinventor/esptool/archive/master.zip\n    unzip master.zip\n    mv esptool-master esp-open-sdk/esptool  \n```", "```cpp\n    cd  $ESP_HOME\n    git clone https://github.com/raburton/esptool2\n    cd esptool2\n    make  \n```", "```cpp\n    export ESP_HOME=/opt/esp-open-sdk\n    export SMING_HOME=/opt/Sming/Sming\n    export PATH=$PATH:$ESP_HOME/esptool2\n    export PATH=$PATH:$ESP_HOME/xtensa-lx106-elf/bin  \n```", "```cpp\n#include \"ota_core.h\"\nvoid onInit() {\n    // \n}\nvoid init() {\n         OtaCore::init(onInit);\n }\n```", "```cpp\n#include <user_config.h>\n#include <SmingCore/SmingCore.h>\n```", "```cpp\nenum {\n          LOG_ERROR = 0,\n          LOG_WARNING,\n          LOG_INFO,\n          LOG_DEBUG,\n          LOG_TRACE,\n          LOG_XTRACE\n };\n\n enum ESP8266_pins {\n          ESP8266_gpio00 = 0x00001,     // Flash\n          ESP8266_gpio01 = 0x00002,     // TXD 0\n          ESP8266_gpio02 = 0x00004,     // TXD 1\n          ESP8266_gpio03 = 0x00008,     // RXD 0\n          ESP8266_gpio04 = 0x00010,     // \n          ESP8266_gpio05 = 0x00020,     // \n          ESP8266_gpio09 = 0x00040,     // SDD2 (QDIO Flash)\n          ESP8266_gpio10 = 0x00080,     // SDD3 (QDIO Flash)\n          ESP8266_gpio12 = 0x00100,     // HMISO (SDO)\n          ESP8266_gpio13 = 0x00200,     // HMOSI (SDI)\n          ESP8266_gpio14 = 0x00400,     // SCK\n          ESP8266_gpio15 = 0x00800,     // HCS\n          ESP8266_gpio16 = 0x01000,     // User, Wake\n          ESP8266_mosi = 0x02000,\n          ESP8266_miso = 0x04000,\n          ESP8266_sclk = 0x08000,\n          ESP8266_cs = 0x10000\n };\n```", "```cpp\n#define SCL_PIN 5\n#define SDA_PIN 4\n```", "```cpp\ntypedef void (*topicCallback)(String);\ntypedef void (*onInitCallback)();\n```", "```cpp\n\nclass OtaCore {\n         static Timer procTimer;\n         static rBootHttpUpdate* otaUpdater;\n         static MqttClient* mqtt;\n         static String MAC;\n         static HashMap<String, topicCallback>* topicCallbacks;\n         static HardwareSerial Serial1;\n         static String location;\n         static String version;\n         static int sclPin;\n         static int sdaPin;\n         static bool i2c_active;\n         static bool spi_active;\n         static uint32 esp8266_pins;\n\n         static void otaUpdate();\n         static void otaUpdate_CallBack(rBootHttpUpdate& update, bool result);\n         static void startMqttClient();\n         static void checkMQTTDisconnect(TcpClient& client, bool flag);\n         static void connectOk(IPAddress ip, IPAddress mask, IPAddress gateway);\n         static void connectFail(String ssid, uint8_t ssidLength, uint8_t *bssid,    uint8_t reason);\n         static void onMqttReceived(String topic, String message);\n         static void updateModules(uint32 input);\n         static bool mapGpioToBit(int pin, ESP8266_pins &addr);\n\npublic:\n         static bool init(onInitCallback cb);\n         static bool registerTopic(String topic, topicCallback cb);\n         static bool deregisterTopic(String topic);\n         static bool publish(String topic, String message, int qos = 1);\n         static void log(int level, String msg);\n         static String getMAC() { return OtaCore::MAC; }\n         static String getLocation() { return OtaCore::location; }\n         static bool starti2c();\n         static bool startSPI();\n         static bool claimPin(ESP8266_pins pin);\n         static bool claimPin(int pin);\n         static bool releasePin(ESP8266_pins pin);\n         static bool releasePin(int pin);\n};\n```", "```cpp\n#include <ota_core.h>\n\n#include \"base_module.h\"\n\n#define SPI_SCLK 14\n#define SPI_MOSI 13\n#define SPI_MISO 12\n#define SPI_CS 15\n\nTimer OtaCore::procTimer;\nrBootHttpUpdate* OtaCore::otaUpdater = 0;\nMqttClient* OtaCore::mqtt = 0;\nString OtaCore::MAC;\nHashMap<String, topicCallback>* OtaCore::topicCallbacks = new HashMap<String, topicCallback>();\nHardwareSerial OtaCore::Serial1(UART_ID_1); // UART 0 is 'Serial'.\nString OtaCore::location;\nString OtaCore::version = VERSION;\nint OtaCore::sclPin = SCL_PIN; // default.\nint OtaCore::sdaPin = SDA_PIN; // default.\nbool OtaCore::i2c_active = false;\nbool OtaCore::spi_active = false;\nuint32 OtaCore::esp8266_pins = 0x0;\n```", "```cpp\nString getFileContent(const String fileName) {\n         file_t file = fileOpen(fileName.c_str(), eFO_ReadOnly);\n\n         fileSeek(file, 0, eSO_FileEnd);\n         int size = fileTell(file);\n         if (size <= 0)    {\n                fileClose(file);\n                return \"\";\n         }\n\n         fileSeek(file, 0, eSO_FileStart);\n         char* buffer = new char[size + 1];\n         buffer[size] = 0;\n         fileRead(file, buffer, size);\n         fileClose(file);\n         String res(buffer, size);\n         delete[] buffer;\n         return res;\n}\n```", "```cpp\nvoid setFileContent(const String &fileName, const String &content) {\n          file_t file = fileOpen(fileName.c_str(),                                                   eFO_CreateNewAlways | eFO_WriteOnly);\n          fileWrite(file, content.c_str(), content.length());\n          fileClose(file);\n }\n```", "```cpp\nbool readIntoFileBuffer(const String filename, char* &buffer, unsigned int &size) {\n         file_t file = fileOpen(filename.c_str(), eFO_ReadOnly);\n\n         fileSeek(file, 0, eSO_FileEnd);\n         size = fileTell(file);\n         if (size == 0)    {\n                fileClose(file);\n                return true;\n         }\n\n         fileSeek(file, 0, eSO_FileStart);\n         buffer = new char[size + 1];\n         buffer[size] = 0;\n         fileRead(file, buffer, size);\n         fileClose(file);\n         return true;\n}\n```", "```cpp\nbool OtaCore::init(onInitCallback cb) {\n         Serial.begin(9600);\n\n         Serial1.begin(SERIAL_BAUD_RATE); \n         Serial1.systemDebugOutput(true);\n```", "```cpp\n         BaseModule::init(); \n```", "```cpp\n         int slot = rboot_get_current_rom();\n         u32_t offset;\n         if (slot == 0) { offset = 0x100000; }\n         else { offset = 0x300000; }\n         spiffs_mount_manual(offset, 65536);\n```", "```cpp\n\n          Serial1.printf(\"\\r\\nSDK: v%s\\r\\n\", system_get_sdk_version());\n     Serial1.printf(\"Free Heap: %d\\r\\n\", system_get_free_heap_size());\n     Serial1.printf(\"CPU Frequency: %d MHz\\r\\n\", system_get_cpu_freq());\n     Serial1.printf(\"System Chip ID: %x\\r\\n\", system_get_chip_id());\n     Serial1.printf(\"SPI Flash ID: %x\\r\\n\", spi_flash_get_id());\n```", "```cpp\n         mqtt = new MqttClient(MQTT_HOST, MQTT_PORT, onMqttReceived);\n```", "```cpp\n\n         Serial1.printf(\"\\r\\nCurrently running rom %d.\\r\\n\", slot);\n\n         WifiStation.enable(true);\n         WifiStation.config(WIFI_SSID, WIFI_PWD);\n         WifiStation.connect();\n         WifiAccessPoint.enable(false);\n\n        WifiEvents.onStationGotIP(OtaCore::connectOk);\n        WifiEvents.onStationDisconnect(OtaCore::connectFail);\n\n          (*cb)();\n}\n```", "```cpp\n\nvoid OtaCore::otaUpdate_CallBack(rBootHttpUpdate& update, bool result) {\n         OtaCore::log(LOG_INFO, \"In OTA callback...\");\n         if (result == true) { // success\n               uint8 slot = rboot_get_current_rom();\n               if (slot == 0) { slot = 1; } else { slot = 0; }\n\n               Serial1.printf(\"Firmware updated, rebooting to ROM slot %d...\\r\\n\",                                                                                                                        slot);\n               OtaCore::log(LOG_INFO, \"Firmware updated, restarting...\");\n               rboot_set_current_rom(slot);\n               System.restart();\n         } \n         else {\n               OtaCore::log(LOG_ERROR, \"Firmware update failed.\");\n         }\n}\n```", "```cpp\nbool OtaCore::registerTopic(String topic, topicCallback cb) {\n         OtaCore::mqtt->subscribe(topic);\n         (*topicCallbacks)[topic] = cb;\n         return true;\n}\n\nbool OtaCore::deregisterTopic(String topic) {\n         OtaCore::mqtt->unsubscribe(topic);\n         if (topicCallbacks->contains(topic)) {\n               topicCallbacks->remove(topic);\n         }\n\n         return true;\n}\n```", "```cpp\nbool OtaCore::publish(String topic, String message, int qos /* = 1 */) {\n         OtaCore::mqtt->publishWithQoS(topic, message, qos);\n         return true;\n}\n```", "```cpp\nvoid OtaCore::otaUpdate() {\n         OtaCore::log(LOG_INFO, \"Updating firmware from URL: \" + String(OTA_URL));\n\n         if (otaUpdater) { delete otaUpdater; }\n         otaUpdater = new rBootHttpUpdate();\n\n         rboot_config bootconf = rboot_get_config();\n         uint8 slot = bootconf.current_rom;\n         if (slot == 0) { slot = 1; } else { slot = 0; }\n\n         otaUpdater->addItem(bootconf.roms[slot], OTA_URL + MAC);\n\n         otaUpdater->setCallback(OtaCore::otaUpdate_CallBack);\n         otaUpdater->start();\n}\n```", "```cpp\nvoid OtaCore::checkMQTTDisconnect(TcpClient& client, bool flag) {\n         if (flag == true) { Serial1.println(\"MQTT Broker disconnected.\"); }\n         else { \n               String tHost = MQTT_HOST;\n               Serial1.println(\"MQTT Broker \" + tHost + \" unreachable.\"); }\n\n         procTimer.initializeMs(2 * 1000, OtaCore::startMqttClient).start();\n}\n```", "```cpp\nvoid OtaCore::startMqttClient() {\n         procTimer.stop();\n         if (!mqtt->setWill(\"last/will\",                                 \"The connection from this device is lost:(\",    1, true)) {\n               debugf(\"Unable to set the last will and testament. Most probably there is not enough memory on the device.\");\n         }\n```", "```cpp\n#ifdef ENABLE_SSL\n         mqtt->connect(MAC, MQTT_USERNAME, MQTT_PWD, true);\n         mqtt->addSslOptions(SSL_SERVER_VERIFY_LATER);\n\n       Serial1.printf(\"Free Heap: %d\\r\\n\", system_get_free_heap_size());\n\n         if (!fileExist(\"esp8266.client.crt.binary\")) {\n               Serial1.println(\"SSL CRT file is missing: esp8266.client.crt.binary.\");\n               return;\n         }\n         else if (!fileExist(\"esp8266.client.key.binary\")) {\n               Serial1.println(\"SSL key file is missing: esp8266.client.key.binary.\");\n               return;\n         }\n\n         unsigned int crtLength, keyLength;\n         char* crtFile;\n         char* keyFile;\n         readIntoFileBuffer(\"esp8266.client.crt.binary\", crtFile, crtLength);\n         readIntoFileBuffer(\"esp8266.client.key.binary\", keyFile, keyLength);\n\n         Serial1.printf(\"keyLength: %d, crtLength: %d.\\n\", keyLength, crtLength);\n         Serial1.printf(\"Free Heap: %d\\r\\n\", system_get_free_heap_size());\n\n         if (crtLength < 1 || keyLength < 1) {\n               Serial1.println(\"Failed to open certificate and/or key file.\");\n               return;\n         }\n\n         mqtt->setSslClientKeyCert((const uint8_t*) keyFile, keyLength,\n                                                (const uint8_t*) crtFile, crtLength, 0, true);\n         delete[] keyFile;\n         delete[] crtFile;\n\n    Serial1.printf(\"Free Heap: %d\\r\\n\", system_get_free_heap_size());\n```", "```cpp\n#elif defined USE_MQTT_PASSWORD\n          mqtt->connect(MAC, MQTT_USERNAME, MQTT_PWD);\n```", "```cpp\n#else\n         mqtt->connect(MAC);\n#endif\n```", "```cpp\n         mqtt->setCompleteDelegate(checkMQTTDisconnect);\n\n         mqtt->subscribe(MQTT_PREFIX\"upgrade\");\n         mqtt->subscribe(MQTT_PREFIX\"presence/tell\");\n         mqtt->subscribe(MQTT_PREFIX\"presence/ping\");\n         mqtt->subscribe(MQTT_PREFIX\"presence/restart/#\");\n         mqtt->subscribe(MQTT_PREFIX\"cc/\" + MAC);\n\n         delay(100);\n\n         mqtt->publish(MQTT_PREFIX\"cc/config\", MAC);\n}\n```", "```cpp\nvoid OtaCore::connectOk(IPAddress ip, IPAddress mask, IPAddress gateway) {\n          Serial1.println(\"I'm CONNECTED. IP: \" + ip.toString());\n\n          MAC = WifiStation.getMAC();\n          Serial1.printf(\"MAC: %s.\\n\", MAC.c_str());\n\n          if (fileExist(\"location.txt\")) {\n                location = getFileContent(\"location.txt\");\n          }\n          else {\n                location = MAC;\n          }\n\n          if (fileExist(\"config.txt\")) {\n                String configStr = getFileContent(\"config.txt\");\n                uint32 config;\n                configStr.getBytes((unsigned char*) &config, sizeof(uint32), 0);\n                updateModules(config);\n          }\n\n          startMqttClient();\n }\n```", "```cpp\nvoid OtaCore::connectFail(String ssid, uint8_t ssidLength, \n                                                   uint8_t* bssid, uint8_t reason) {\n          Serial1.println(\"I'm NOT CONNECTED. Need help :(\");\n          debugf(\"Disconnected from %s. Reason: %d\", ssid.c_str(), reason);\n\n          WDT.alive();\n\n          WifiEvents.onStationGotIP(OtaCore::connectOk);\n          WifiEvents.onStationDisconnect(OtaCore::connectFail);\n }\n```", "```cpp\nvoid OtaCore::onMqttReceived(String topic, String message) {\n         Serial1.print(topic);\n         Serial1.print(\":\\n\");\n         Serial1.println(message);\n\n         log(LOG_DEBUG, topic + \" - \" + message);\n\n         if (topic == MQTT_PREFIX\"upgrade\" && message == MAC) {\n                otaUpdate();\n         }\n         else if (topic == MQTT_PREFIX\"presence/tell\") {\n                mqtt->publish(MQTT_PREFIX\"presence/response\", MAC);\n         }\n         else if (topic == MQTT_PREFIX\"presence/ping\") {\n               mqtt->publish(MQTT_PREFIX\"presence/pong\", MAC);\n         }\n         else if (topic == MQTT_PREFIX\"presence/restart\" && message == MAC) {\n               System.restart();\n         }\n         else if (topic == MQTT_PREFIX\"presence/restart/all\") {\n               System.restart();\n         }\n```", "```cpp\n   else if (topic == MQTT_PREFIX\"cc/\" + MAC) {\n          int chAt = message.indexOf(';');\n          String cmd = message.substring(0, chAt);\n          ++chAt;\n\n          String msg(((char*) &message[chAt]), (message.length() - chAt));\n\n          log(LOG_DEBUG, msg);\n\n          Serial1.printf(\"Command: %s, Message: \", cmd.c_str());\n          Serial1.println(msg);\n```", "```cpp\n\n         if (cmd == \"mod\") {\n               if (msg.length() != 4) {\n                     Serial1.printf(\"Payload size wasn't 4 bytes: %d\\n\", msg.length());\n                     return; \n               }\n\n               uint32 input;\n               msg.getBytes((unsigned char*) &input, sizeof(uint32), 0);\n               String byteStr;\n               byteStr = \"Received new configuration: \";\n               byteStr += input;\n               log(LOG_DEBUG, byteStr);\n               updateModules(input);               \n          }\n```", "```cpp\n        else if (cmd == \"loc\") {\n               if (msg.length() < 1) { return; }\n               if (location != msg) {\n                     location = msg;\n                     fileSetContent(\"location.txt\", location);\n               }\n         }\n```", "```cpp\n         else if (cmd == \"mod_active\") {\n               uint32 active_mods = BaseModule::activeMods();\n               if (active_mods == 0) {\n                     mqtt->publish(MQTT_PREFIX\"cc/response\", MAC + \";0\");\n                     return;\n               }\n\n               mqtt->publish(MQTT_PREFIX\"cc/response\", MAC + \";\"                                                         + String((const char*) &active_mods, 4));\n         }\n         else if (cmd == \"version\") {\n               mqtt->publish(MQTT_PREFIX\"cc/response\", MAC + \";\" + version);\n         }\n         else if (cmd == \"upgrade\") {\n               otaUpdate();\n         }\n   }\n```", "```cpp\n         else {\n               if (topicCallbacks->contains(topic)) {\n                     (*((*topicCallbacks)[topic]))(message);\n                }\n         }\n}\n```", "```cpp\nvoid OtaCore::updateModules(uint32 input) {\n         Serial1.printf(\"Input: %x, Active: %x.\\n\", input, BaseModule::activeMods());\n\n         BaseModule::newConfig(input);\n\n         if (BaseModule::activeMods() != input) {\n               String content(((char*) &input), 4);\n               setFileContent(\"config.txt\", content);\n         }\n}\n```", "```cpp\nbool OtaCore::mapGpioToBit(int pin, ESP8266_pins &addr) {\n          switch (pin) {\n                case 0:\n                      addr = ESP8266_gpio00;\n                      break;\n                case 1:\n                      addr = ESP8266_gpio01;\n                      break;\n                case 2:\n                      addr = ESP8266_gpio02;\n                      break;\n                case 3:\n                      addr = ESP8266_gpio03;\n                      break;\n                case 4:\n                      addr = ESP8266_gpio04;\n                      break;\n                case 5:\n                      addr = ESP8266_gpio05;\n                      break;\n                case 9:\n                      addr = ESP8266_gpio09;\n                      break;\n                case 10:\n                      addr = ESP8266_gpio10;\n                      break;\n                case 12:\n                      addr = ESP8266_gpio12;\n                      break;\n                case 13:\n                      addr = ESP8266_gpio13;\n                      break;\n                case 14:\n                      addr = ESP8266_gpio14;\n                      break;\n                case 15:\n                      addr = ESP8266_gpio15;\n                      break;\n                case 16:\n                      addr = ESP8266_gpio16;\n                      break;\n                default:\n                      log(LOG_ERROR, \"Invalid pin number specified: \" + String(pin));\n                      return false;\n          };\n\n          return true;\n }\n```", "```cpp\nvoid OtaCore::log(int level, String msg) {\n         String out(lvl);\n         out += \" - \" + msg;\n\n         Serial1.println(out);\n         mqtt->publish(MQTT_PREFIX\"log/all\", OtaCore::MAC + \";\" + out);\n}\n```", "```cpp\nbool OtaCore::starti2c() {\n         if (i2c_active) { return true; }\n\n         if (!claimPin(sdaPin)) { return false; }\n         if (!claimPin(sclPin)) { return false; }\n\n         Wire.pins(sdaPin, sclPin);\n         pinMode(sclPin, OUTPUT);\n         for (int i = 0; i < 8; ++i) {\n               digitalWrite(sclPin, HIGH);\n               delayMicroseconds(3);\n               digitalWrite(sclPin, LOW);\n               delayMicroseconds(3);\n         }\n\n         pinMode(sclPin, INPUT);\n\n         Wire.begin();\n         i2c_active = true;\n}\n```", "```cpp\nbool OtaCore::startSPI() {\n    if (spi_active) { return true; }\n\n    if (!claimPin(SPI_SCLK)) { return false; }\n    if (!claimPin(SPI_MOSI)) { return false; }\n    if (!claimPin(SPI_MISO)) { return false; }\n    if (!claimPin(SPI_CS)) { return false; }\n\n    SPI.begin();\n    spi_active = true;\n }\n```", "```cpp\nbool OtaCore::claimPin(int pin) {\n          ESP8266_pins addr;\n          if (!mapGpioToBit(pin, addr)) { return false; }\n\n          return claimPin(addr);\n    }\n\n    bool OtaCore::claimPin(ESP8266_pins pin) {\n          if (esp8266_pins & pin) {\n                log(LOG_ERROR, \"Attempting to claim an already claimed pin: \"                                                                                                      + String(pin));\n                log(LOG_DEBUG, String(\"Current claimed pins: \") + String(esp8266_pins));\n                return false;\n          }\n\n          log(LOG_INFO, \"Claiming pin position: \" + String(pin));\n\n          esp8266_pins |= pin;\n\n          log(LOG_DEBUG, String(\"Claimed pin configuration: \") + String(esp8266_pins));\n\n          return true;\n }\n```", "```cpp\nbool OtaCore::releasePin(int pin) {\n          ESP8266_pins addr;\n          if (!mapGpioToBit(pin, addr)) { return false; }\n\n          return releasePin(addr);\n    }\n\n    bool OtaCore::releasePin(ESP8266_pins pin) {\n          if (!(esp8266_pins & pin)) {\n                log(LOG_ERROR, \"Attempting to release a pin which has not been set: \"                                                                                                      + String(pin));\n                return false;\n          }\n\n          esp8266_pins &= ~pin;\n\n          log(LOG_INFO, \"Released pin position: \" + String(pin));\n          log(LOG_DEBUG, String(\"Claimed pin configuration: \") + String(esp8266_pins));\n\n          return true;\n }\n```", "```cpp\n#include \"ota_core.h\"\n\nenum ModuleIndex {\n   MOD_IDX_TEMPERATURE_HUMIDITY = 0,\n   MOD_IDX_CO2,\n   MOD_IDX_JURA,\n   MOD_IDX_JURATERM,\n   MOD_IDX_MOTION,\n   MOD_IDX_PWM,\n   MOD_IDX_IO,\n   MOD_IDX_SWITCH,\n   MOD_IDX_PLANT\n};\n\ntypedef bool (*modStart)();\ntypedef bool (*modShutdown)();\n```", "```cpp\n#include \"thp_module.h\"\n#include \"jura_module.h\"\n#include \"juraterm_module.h\"\n#include \"co2_module.h\"\n#include \"motion_module.h\"\n#include \"pwm_module.h\"\n#include \"io_module.h\"\n#include \"switch_module.h\"\n#include \"plant_module.h\"\n```", "```cpp\nclass BaseModule {   \n         struct SubModule {\n               modStart start;\n               modShutdown shutdown;\n               ModuleIndex index;\n               uint32 bitmask;\n               bool started;\n         };\n\n         static SubModule modules[32];\n         static uint32 active_mods;\n         static bool initialized;\n         static uint8 modcount;\n\npublic:\n         static void init();\n         static bool registerModule(ModuleIndex index, modStart start,                                                                                    modShutdown shutdown);\n```", "```cpp\n\n         static bool newConfig(uint32 config);\n         static uint32 activeMods() { return active_mods; }\n};\n```", "```cpp\n#include \"base_module.h\"\n\nBaseModule::SubModule BaseModule::modules[32];\nuint32 BaseModule::active_mods = 0x0;\nbool BaseModule::initialized = false;\nuint8 BaseModule::modcount = 0;\n```", "```cpp\nvoid BaseModule::init() {\n    CO2Module::initialize();\n    IOModule::initialize();\n    JuraModule::initialize();\n    JuraTermModule::initialize();\n    MotionModule::initialize();\n    PlantModule::initialize();\n    PwmModule::initialize();\n    SwitchModule::initialize();\n    THPModule::initialize();\n}\n```", "```cpp\nbool BaseModule::registerModule(ModuleIndex index, modStart start, modShutdown shutdown) {\n         if (!initialized) {\n               for (uint8 i = 0; i < 32; i++) {\n                     modules[i].start = 0;\n                     modules[i].shutdown = 0;\n                     modules[i].index = index;\n                     modules[i].bitmask = (1 << i);\n                     modules[i].started = false;\n               }\n\n               initialized = true;\n         }\n\n         if (modules[index].start) {\n               return false;\n         }\n\n         modules[index].start = start;\n         modules[index].shutdown = shutdown;\n         ++modcount;\n\n         return true;\n}\n```", "```cpp\nbool BaseModule::newConfig(uint32 config) {\n    OtaCore::log(LOG_DEBUG, String(\"Mod count: \") + String(modcount));\n    uint32 new_config = config ^ active_mods;\n    if (new_config == 0x0) {\n        OtaCore::log(LOG_INFO, \"New configuration was 0x0\\. No \n        change.\");\n        return true; \n    }\n    OtaCore::log(LOG_INFO, \"New configuration: \" + new_config);\n    for (uint8 i = 0; i < 32; ++i) {\n        if (new_config & (1 << i)) {\n            OtaCore::log(LOG_DEBUG, String(\"Toggling module: \") + \n            String(i));\n            if (modules[i].started) { \n                if ((modules[i]).shutdown()) { \n                    modules[i].started = false; \n                    active_mods ^= modules[i].bitmask;\n                }\n                else { \n                    OtaCore::log(LOG_ERROR, \"Failed to shutdown \n                    module.\");\n                    return false; \n                }\n            }\n            else { \n                if ((modules[i].start) && (modules[i]).start()) { \n                    modules[i].started = true;\n                    active_mods |= modules[i].bitmask;\n                }\n                else { \n                    OtaCore::log(LOG_ERROR, \"Failed to start module.\");\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n }\n```", "```cpp\n#include \"base_module.h\"\n#include <Libraries/APA102/apa102.h>\n\n#define PLANT_GPIO_PIN 5\n#define NUM_APA102 1\n\nclass PlantModule {\n         static int pin;\n         static Timer timer;\n         static uint16 humidityTrigger;\n         static String publishTopic;\n         static HttpServer server;\n         static APA102* LED;\n\n         static void onRequest(HttpRequest& request, HttpResponse& response);\n\npublic:\n         static bool initialize();\n         static bool start();\n         static bool shutdown();\n         static void readSensor();\n         static void commandCallback(String message);\n};\n```", "```cpp\n#include \"plant_module.h\"\n\nint PlantModule::pin = PLANT_GPIO_PIN;\nTimer PlantModule::timer;\nuint16 PlantModule::humidityTrigger = 530;\nString PlantModule::publishTopic;\nHttpServer PlantModule::server;\nAPA102* PlantModule::LED = 0;\n\nenum {\n         PLANT_SOIL_MOISTURE = 0x01,\n         PLANT_SET_TRIGGER = 0x02,\n         PLANT_TRIGGER = 0x04\n};\n```", "```cpp\nbool PlantModule::initialize() {\n          BaseModule::registerModule(MOD_IDX_PLANT, PlantModule::start,                                                                                                                 PlantModule::shutdown);\n}\n```", "```cpp\nbool PlantModule::start() {\n         OtaCore::log(LOG_INFO, \"Plant Module starting...\");\n\n         if (!OtaCore::claimPin(pin)) { return false; }\n\n         publishTopic = MQTT_PREFIX + \"plant/response/\" + OtaCore::getLocation();\n         OtaCore::registerTopic(MQTT_PREFIX + String(\"plants/\") +                                                             OtaCore::getLocation(), PlantModule::commandCallback);\n\n         pinMode(pin, OUTPUT);\n\n         server.listen(80);\n         server.setDefaultHandler(PlantModule::onRequest);\n\n         LED = new APA102(NUM_APA102);\n         LED->setBrightness(15);\n         LED->clear();\n         LED->setAllPixel(0, 255, 0);\n         LED->show();\n\n         timer.initializeMs(60000, PlantModule::readSensor).start();\n         return true;\n}\n```", "```cpp\nbool PlantModule::shutdown() {\n         if (!OtaCore::releasePin(pin)) { return false; }\n\n         server.shutdown();\n\n         if (LED) {\n               delete LED;\n               LED = 0;\n         }\n\n         OtaCore::deregisterTopic(MQTT_PREFIX + String(\"plants/\") +                                                                                            OtaCore::getLocation());\n\n         timer.stop();\n         return true;\n}\n```", "```cpp\n\nvoid PlantModule::commandCallback(String message) {\n         OtaCore::log(LOG_DEBUG, \"Plant command: \" + message);\n\n         if (message.length() < 1) { return; }\n         int index = 0;\n         uint8 cmd = *((uint8*) &message[index++]);\n\n         if (cmd == PLANT_SOIL_MOISTURE) {\n               readSensor();\n         }\n         else if (cmd == PLANT_SET_TRIGGER) {               \n                if (message.length() != 3) { return; }\n               uint16 payload = *((uint16*) &message[index]);\n               index += 2;\n\n               humidityTrigger = payload;\n         }\n         else if (cmd == PLANT_TRIGGER) {\n               OtaCore::publish(publishTopic, OtaCore::getLocation() + \";\" \n                                                                + String(((char*) &humidityTrigger), 2));\n         }\n}\n```", "```cpp\nvoid PlantModule::readSensor() {\n    int16_t val = 0;\n    val = analogRead(A0); // calls system_adc_read().\n\n    String response = OtaCore::getLocation() + \";\" + val;\n    OtaCore::publish(MQTT_PREFIX\"nsa/plant/moisture_raw\", response);\n```", "```cpp\n        if (val >= humidityTrigger) {\n               digitalWrite(pin, HIGH);\n\n               LED->setBrightness(31);\n               LED->setAllPixel(0, 0, 255);\n               LED->show();\n\n               for (int i = 0; i < 10; ++i) {\n                     LED->directWrite(0, 0, 255, 25);\n                     delay(200);\n                     LED->directWrite(0, 0, 255, 18);\n                     delay(200);\n                     LED->directWrite(0, 0, 255, 12);\n                     delay(200);\n                     LED->directWrite(0, 0, 255, 5);\n                     delay(200);\n                     LED->directWrite(0, 0, 255, 31);\n                     delay(200);\n               }\n\n               digitalWrite(pin, LOW);\n         }\n}\n```", "```cpp\nvoid PlantModule::onRequest(HttpRequest& request, HttpResponse& response) {\n         TemplateFileStream* tmpl = new TemplateFileStream(\"index.html\");\n         TemplateVariables& vars = tmpl->variables();\n         int16_t val = analogRead(A0);\n         int8_t perc = 100 - ((val - 379) / 3.87);\n         vars[\"raw_value\"] = String(val);\n         vars[\"percentage\"] = String(perc);\n\n         response.sendTemplate(tmpl);\n}\n```", "```cpp\n<!DOCTYPE html>\n<html>\n<head>\n         <title>Plant soil moisture readings</title>\n   </head>\n   <body>\n         Current value: {raw_value}<br>\n         Percentage: {percentage}%\n</body>\n</html>\n```", "```cpp\nmake  \n```", "```cpp\n    make flash COM_PORT=/dev/ttyUSB0  \n```", "```cpp\n    log;plant001  \n```", "```cpp\nmod;\\x00\\x01\\x00\\x00  \n```"]