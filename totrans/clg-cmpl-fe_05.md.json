["```cpp\nstatic bool unionHasUniqueObjectRepresentations(const ASTContext &Context, \n\n                                                const RecordDecl *RD, \n\n                                                bool CheckIfTriviallyCopyable) { \n\n  assert(RD->isUnion() && \"Must be union type\"); \n\n  CharUnits UnionSize = Context.getTypeSizeInChars(RD->getTypeForDecl());\n\n```", "```cpp\n46 void testAnimal() { \n\n47   auto AnimalPtr = std::make_unique<clangbook::Horse>(10); \n\n48   if (llvm::isa<clangbook::Horse>(AnimalPtr)) { \n\n49     llvm::outs() \n\n50         << \"Animal is a Horse and the horse speed is: \" \n\n51         << llvm::dyn_cast<clangbook::Horse>(AnimalPtr.get())->getSpeed() \n\n52         << \"mph \\n\"; \n\n53   } else { \n\n54     llvm::outs() << \"Animal is not a Horse\\n\"; \n\n55   } \n\n56 }\n```", "```cpp\nAnimal is a Horse and the horse speed is: 10mph\n```", "```cpp\n9 class Animal { \n\n10 public: \n\n11   enum AnimalKind { AK_Horse, AK_Sheep }; \n\n12  \n\n13 public: \n\n14   Animal(AnimalKind K) : Kind(K){}; \n\n15   AnimalKind getKind() const { return Kind; } \n\n16  \n\n17 private: \n\n18   const AnimalKind Kind; \n\n19 };\n```", "```cpp\n21 class Horse : public Animal { \n\n22 public: \n\n23   Horse(int S) : Animal(AK_Horse), Speed(S){}; \n\n24  \n\n25   static bool classof(const Animal *A) { return A->getKind() == AK_Horse; } \n\n26  \n\n27   int getSpeed() { return Speed; } \n\n28  \n\n29 private: \n\n30   int Speed; \n\n31 }; \n\n32  \n\n33 class Sheep : public Animal { \n\n34 public: \n\n35   Sheep(int WM) : Animal(AK_Sheep), WoolMass(WM){}; \n\n36  \n\n37   static bool classof(const Animal *A) { return A->getKind() == AK_Sheep; } \n\n38  \n\n39   int getWoolMass() { return WoolMass; } \n\n40  \n\n41 private: \n\n42   int WoolMass; \n\n43 };\n```", "```cpp\n1template <typename To, typename From> \n\n2 bool isa(const From *Val) { \n\n3   return To::classof(Val); \n\n4 }\n```", "```cpp\n1  #include \"llvm/ADT/StringRef.h\" \n\n2   ... \n\n3   llvm::StringRef StrRef(\"Hello, LLVM!\"); \n\n4   // Efficient substring, no allocations \n\n5   llvm::StringRef SubStr = StrRef.substr(0, 5); \n\n6  \n\n7   llvm::outs() << \"Original StringRef: \" << StrRef.str() << \"\\n\"; \n\n8   llvm::outs() << \"Substring: \" << SubStr.str() << \"\\n\";\n```", "```cpp\nOriginal StringRef: Hello, LLVM!\nSubstring: Hello\n```", "```cpp\n1   #include \"llvm/ADT/Twine.h\" \n\n2    ... \n\n3    llvm::StringRef Part1(\"Hello, \"); \n\n4    llvm::StringRef Part2(\"Twine!\"); \n\n5    llvm::Twine Twine = Part1 + Part2;  // Efficient concatenation \n\n6  \n\n7    // Convert twine to a string (actual allocation happens here) \n\n8    std::string TwineStr = Twine.str(); \n\n9    llvm::outs() << \"Twine result: \" << TwineStr << \"\\n\";\n```", "```cpp\nTwine result: Hello, Twine!\n```", "```cpp\n1   #include \"llvm/ADT/SmallString.h\" \n\n2    ... \n\n3    // Stack allocate space for up to 20 characters. \n\n4    llvm::SmallString<20> SmallStr; \n\n5  \n\n6    // No heap allocation happens here. \n\n7    SmallStr = \"Hello, \"; \n\n8    SmallStr += \"LLVM!\"; \n\n9  \n\n10    llvm::outs() << \"SmallString result: \" << SmallStr << \"\\n\";\n```", "```cpp\n1    llvm::SmallVector<int, 10> SmallVector; \n\n2     for (int i = 0; i < 10; i++) { \n\n3       SmallVector.push_back(i); \n\n4     } \n\n5     SmallVector.push_back(10);\n```", "```cpp\n1  class MyClass : public llvm::RefCountedBase<MyClass> { \n\n2   // ... \n\n3   }; \n\n4  \n\n5   llvm::IntrusiveRefCntPtr<MyClass> Ptr = new MyClass();\n```", "```cpp\n1template <class Derived> class RefCountedBase { \n\n2   // ... \n\n3   void Release() const { \n\n4    assert(RefCount > 0 && \"Reference count is already zero.\"); \n\n5    if (--RefCount == 0) \n\n6      delete static_cast<const Derived *>(this); \n\n7   } \n\n8 }\n```", "```cpp\n$ <...>/llvm-project/install/bin/clang -fsyntax-only maxerr.cpp\nmaxerr.cpp:3:12: error: use of undeclared identifier ’ab’\n    return ab;\n           ^\n1  error generated.\n```", "```cpp\n$ lldb <...>/llvm-project/install/clang\n...\n(lldb) p sizeof(clang::SourceLocation)\n(unsigned long) 4\n(lldb)\n```", "```cpp\n1 #define BAR void bar() \n\n2 int foo(int x); \n\n3 BAR;\n```", "```cpp\n10   CreateASTConsumer(clang::CompilerInstance &CI, llvm::StringRef File) { \n\n11     return std::make_unique<Consumer>(&CI.getASTContext());\n```", "```cpp\n8   Consumer(clang::ASTContext *Context) \n\n9       : V(std::make_unique<Visitor>(Context)) {}\n```", "```cpp\n5 class Visitor : public clang::RecursiveASTVisitor<Visitor> { \n\n6 public: \n\n7   explicit Visitor(clang::ASTContext *C) : Context(C) {}\n```", "```cpp\n25 private: \n\n26   clang::ASTContext *Context;\n```", "```cpp\n9   bool VisitFunctionDecl(const clang::FunctionDecl *FD) { \n\n10     clang::SourceManager &SM = Context->getSourceManager(); \n\n11     clang::SourceLocation Loc = FD->getLocation(); \n\n12     clang::SourceLocation ExpLoc = SM.getExpansionLoc(Loc); \n\n13     clang::SourceLocation SpellLoc = SM.getSpellingLoc(Loc); \n\n14     llvm::StringRef ExpFileName = SM.getFilename(ExpLoc); \n\n15     llvm::StringRef SpellFileName = SM.getFilename(SpellLoc); \n\n16     unsigned SpellLine = SM.getSpellingLineNumber(SpellLoc); \n\n17     unsigned ExpLine = SM.getExpansionLineNumber(ExpLoc); \n\n18     llvm::outs() << \"Spelling : \" << FD->getName() << \" at \" << SpellFileName \n\n19                  << \":\" << SpellLine << \"\\n\"; \n\n20     llvm::outs() << \"Expansion : \" << FD->getName() << \" at \" << ExpFileName \n\n21                  << \":\" << ExpLine << \"\\n\"; \n\n22     return true; \n\n23   }\n```", "```cpp\nSpelling : foo at functions.hpp:2\nExpansion : foo at functions.hpp:2\nSpelling : bar at functions.hpp:1\nExpansion : bar at functions.hpp:3\n```", "```cpp\n18   // Emit a warning \n\n19   DiagnosticsEngine.Report(DiagnosticsEngine.getCustomDiagID( \n\n20       clang::DiagnosticsEngine::Warning, \"This is a custom warning.\"));\n```", "```cpp\n7 int main() { \n\n8   llvm::IntrusiveRefCntPtr<clang::DiagnosticOptions> DiagnosticOptions = \n\n9       new clang::DiagnosticOptions(); \n\n10   clang::TextDiagnosticPrinter TextDiagnosticPrinter( \n\n11       llvm::errs(), DiagnosticOptions.get(), false); \n\n12  \n\n13   llvm::IntrusiveRefCntPtr<clang::DiagnosticIDs> DiagIDs = \n\n14       new clang::DiagnosticIDs(); \n\n15   clang::DiagnosticsEngine DiagnosticsEngine(DiagIDs, DiagnosticOptions, \n\n16                                              &TextDiagnosticPrinter, false); \n\n17  \n\n18   // Emit a warning \n\n19   DiagnosticsEngine.Report(DiagnosticsEngine.getCustomDiagID( \n\n20       clang::DiagnosticsEngine::Warning, \"This is a custom warning.\")); \n\n21  \n\n22   return 0; \n\n23 }\n```", "```cpp\nwarning: This is a custom warning.\n```", "```cpp\n16 // Define the diagnostic severities. \n\n17 class Severity<string N> { \n\n18   string Name = N; \n\n19 }\n```", "```cpp\n20 def SEV_Ignored : Severity<\"Ignored\">; \n\n21 def SEV_Remark  : Severity<\"Remark\">; \n\n22 def SEV_Warning : Severity<\"Warning\">; \n\n23 def SEV_Error   : Severity<\"Error\">; \n\n24 def SEV_Fatal   : Severity<\"Fatal\">;\n```", "```cpp\n// All diagnostics emitted by the compiler are an indirect subclass of this. \n\nclass Diagnostic<string summary, DiagClass DC, Severity defaultmapping> { \n\n  ... \n\n} \n\n... \n\nclass Warning<string str>   : Diagnostic<str, CLASS_WARNING, SEV_Warning>;\n```", "```cpp\ndef warn_unused_parameter : Warning<\"unused parameter %0\">, \n\n  InGroup<UnusedParameter>, DefaultIgnore;\n```", "```cpp\nDIAG(warn_unused_parameter, CLASS_WARNING, (unsigned)diag::Severity::Ignored, \"unused parameter %0\", 985, SFINAE_Suppress, false, false, true, false, 2)\n```", "```cpp\n  const StaticDiagInfoDescriptionStringTable StaticDiagInfoDescriptions = { \n\n#define DIAG(ENUM, CLASS, DEFAULT_SEVERITY, DESC, GROUP, SFINAE, NOWERROR,\\ \n\n            SHOWINSYSHEADER, SHOWINSYSMACRO, DEFERRABLE, CATEGORY)    \\ \n\n  DESC, \n\n... \n\n#include \"clang/Basic/DiagnosticSemaKinds.inc\" \n\n... \n\n#undef DIAG \n\n};\n```", "```cpp\n  const StaticDiagInfoDescriptionStringTable StaticDiagInfoDescriptions = { \n\n   ... \n\n   \"unused parameter %0\", \n\n   ... \n\n  };\n```", "```cpp\n1 // RUN: %clang_cc1 -fsyntax-only -verify -Wattributes %s \n\n2  \n\n3 int x __attribute__((foobar)); // expected-warning {{unknown attribute ’foobar’ ignored}} \n\n4 void z(void) __attribute__((bogusattr)); // expected-warning {{unknown attribute ’bogusattr’ ignored}}\n```", "```cpp\n$ ./build/bin/llvm-lit ./clang/test/Sema/attr-unknown.c\n...\n-- Testing: 1 tests, 1 workers --\nPASS: Clang :: Sema/attr-unknown.c (1 of 1)\n\nTesting Time: 0.06s\n  Passed: 1\n```", "```cpp\ncmake -G Ninja -DCMAKE_BUILD_TYPE=Debug -DCMAKE_INSTALL_PREFIX=../install -DLLVM_TARGETS_TO_BUILD=\"X86\" -DLLVM_ENABLE_PROJECTS=\"clang\" -DLLVM_USE_SPLIT_DWARF=ON -DBUILD_SHARED_LIBS=ON ../llvm\n```", "```cpp\n$ ninja install\n```", "```cpp\n8   message(STATUS \"$LLVM_HOME found: $ENV{LLVM_HOME}\") \n\n9   set(LLVM_HOME $ENV{LLVM_HOME} CACHE PATH \"Root of LLVM installation\") \n\n10   set(LLVM_LIB ${LLVM_HOME}/lib) \n\n11   set(LLVM_DIR ${LLVM_LIB}/cmake/llvm) \n\n12   set(LLVM_BUILD $ENV{LLVM_BUILD} CACHE PATH \"Root of LLVM build\") \n\n13   find_package(LLVM REQUIRED CONFIG) \n\n14   include_directories(${LLVM_INCLUDE_DIRS}) \n\n15   link_directories(${LLVM_LIBRARY_DIRS}) \n\n16  \n\n17   # Add the plugin’s shared library target \n\n18   add_library(classchecker MODULE \n\n19     ClassChecker.cpp \n\n20   ) \n\n21   set_target_properties(classchecker PROPERTIES COMPILE_FLAGS \"-fno-rtti\") \n\n22   target_link_libraries(classchecker \n\n23     LLVMSupport \n\n24     clangAST \n\n25     clangBasic \n\n26     clangFrontend \n\n27     clangTooling \n\n28   )\n```", "```cpp\n1 #include \"clang/AST/ASTContext.h\" \n\n2 #include \"clang/AST/RecursiveASTVisitor.h\" \n\n3  \n\n4 namespace clangbook { \n\n5 namespace classchecker { \n\n6 class ClassVisitor : public clang::RecursiveASTVisitor<ClassVisitor> { \n\n7 public: \n\n8   explicit ClassVisitor(clang::ASTContext *C, int T) \n\n9       : Context(C), Threshold(T) {} \n\n10  \n\n11   bool VisitCXXRecordDecl(clang::CXXRecordDecl *Declaration) { \n\n12     if (Declaration->isThisDeclarationADefinition()) { \n\n13       int MethodCount = 0; \n\n14       for (const auto *M : Declaration->methods()) { \n\n15         MethodCount++; \n\n16       } \n\n17  \n\n18       if (MethodCount > Threshold) { \n\n19         clang::DiagnosticsEngine &D = Context->getDiagnostics(); \n\n20         unsigned DiagID = \n\n21             D.getCustomDiagID(clang::DiagnosticsEngine::Warning, \n\n22                               \"class %0 is too complex: method count = %1\"); \n\n23         clang::DiagnosticBuilder DiagBuilder = \n\n24             D.Report(Declaration->getLocation(), DiagID); \n\n25         DiagBuilder << Declaration->getName() << MethodCount; \n\n26       } \n\n27     } \n\n28     return true; \n\n29   }\n```", "```cpp\n30 \n\n31 private: \n\n32   clang::ASTContext *Context; \n\n33   int Threshold; \n\n34 }; \n\n35 } // namespace classchecker \n\n36 } // namespace clangbook\n```", "```cpp\n1 namespace clangbook { \n\n2 namespace classchecker { \n\n3 class ClassConsumer : public clang::ASTConsumer { \n\n4 public: \n\n5   explicit ClassConsumer(clang::ASTContext *Context, int Threshold) \n\n6       : Visitor(Context, Threshold) {} \n\n7  \n\n8   virtual void HandleTranslationUnit(clang::ASTContext &Context) { \n\n9     Visitor.TraverseDecl(Context.getTranslationUnitDecl()); \n\n10   } \n\n11  \n\n12 private: \n\n13   ClassVisitor Visitor; \n\n14 }; \n\n15 } // namespace classchecker \n\n16 } // namespace clangbook\n```", "```cpp\n1 namespace clangbook { \n\n2 namespace classchecker { \n\n3 class ClassAction : public clang::PluginASTAction { \n\n4 protected: \n\n5   std::unique_ptr<clang::ASTConsumer> \n\n6   CreateASTConsumer(clang::CompilerInstance &CI, llvm::StringRef) { \n\n7     return std::make_unique<ClassConsumer>(&CI.getASTContext(), \n\n8                                            MethodCountThreshold); \n\n9   } \n\n10  \n\n11   bool ParseArgs(const clang::CompilerInstance &CI, \n\n12                  const std::vector<std::string> &args) { \n\n13     for (const auto &arg : args) { \n\n14       if (arg.substr(0, 9) == \"threshold\") { \n\n15         auto valueStr = arg.substr(10); // Get the substring after \"threshold=\" \n\n16         MethodCountThreshold = std::stoi(valueStr); \n\n17         return true; \n\n18       } \n\n19     } \n\n20     return true; \n\n21   } \n\n22   ActionType getActionType() { return AddAfterMainAction; } \n\n23  \n\n24 private: \n\n25   int MethodCountThreshold = 5; // default value \n\n26 }; \n\n27 } // namespace classchecker \n\n28 } // namespace clangbook\n```", "```cpp\n1 #include \"clang/Frontend/FrontendPluginRegistry.h\" \n\n2  \n\n3 #include \"ClassAction.hpp\" \n\n4  \n\n5 static clang::FrontendPluginRegistry::Add<clangbook::classchecker::ClassAction> \n\n6     X(\"classchecker\", \"Checks the complexity of C++ classes\");\n```", "```cpp\nexport LLVM_HOME=<...>/llvm-project/install\nmkdir build\ncd build\ncmake -G Ninja -DCMAKE_BUILD_TYPE=Debug ..\nninja classchecker\n```", "```cpp\n$ <...>/llvm-project/install/bin/clang -fsyntax-only\\\n                 -fplugin=./build/libclasschecker.so\\\n                 <filepath>\n```", "```cpp\n1 class Simple { \n\n2 public: \n\n3   void func1() {} \n\n4   void func2() {} \n\n5   void func3() {} \n\n6 };\n```", "```cpp\n$ <...>/llvm-project/install/bin/clang -fsyntax-only \\\n                 -fplugin-arg-classchecker-threshold=2 \\\n                 -fplugin=./build/libclasschecker.so \\\n                 test.cpp\ntest.cpp:1:7: warning: class Simple is too complex: method count = 3\n    1 | class Simple {\n      |       ^\n1  warning generated.\n```", "```cpp\n1 config.ClassComplexityChecker_obj_root = \"@CMAKE_CURRENT_BINARY_DIR@\" \n\n2 config.ClassComplexityChecker_src_root = \"@CMAKE_CURRENT_SOURCE_DIR@\" \n\n3 config.ClangBinary = \"@LLVM_HOME@/bin/clang\" \n\n4 config.FileCheck = \"@FILECHECK_COMMAND@\" \n\n5  \n\n6 lit_config.load_config( \n\n7         config, os.path.join(config.ClassComplexityChecker_src_root, \"test/lit.cfg.py\"))\n```", "```cpp\n1 # lit.cfg.py \n\n2 import lit.formats \n\n3  \n\n4 config.name = ’classchecker’ \n\n5 config.test_format = lit.formats.ShTest(True) \n\n6 config.suffixes = [’.cpp’] \n\n7 config.test_source_root = os.path.dirname(__file__) \n\n8  \n\n9 config.substitutions.append((’%clang-binary’, config.ClangBinary)) \n\n10 config.substitutions.append((’%path-to-plugin’, os.path.join(config.ClassComplexityChecker_obj_root, ’libclasschecker.so’))) \n\n11 config.substitutions.append((’%file-check-binary’, config.FileCheck))\n```", "```cpp\n1 // RUN: %clang-binary -fplugin=%path-to-plugin -fsyntax-only %s 2>&1 | %file-check-binary %s \n\n2  \n\n3 class Simple { \n\n4 public: \n\n5   void func1() {} \n\n6   void func2() {} \n\n7 }; \n\n8  \n\n9 // CHECK: :[[@LINE+1]]:{{[0-9]+}}: warning: class Complex is too complex: method count = 6 \n\n10 class Complex { \n\n11 public: \n\n12   void func1() {} \n\n13   void func2() {} \n\n14   void func3() {} \n\n15   void func4() {} \n\n16   void func5() {} \n\n17   void func6() {} \n\n18 };\n```", "```cpp\n31   find_program(LIT_COMMAND llvm-lit PATH ${LLVM_BUILD}/bin) \n\n32   find_program(FILECHECK_COMMAND FileCheck ${LLVM_BUILD}/bin) \n\n33   if(LIT_COMMAND AND FILECHECK_COMMAND) \n\n34     message(STATUS \"$LIT_COMMAND found: ${LIT_COMMAND}\") \n\n35     message(STATUS \"$FILECHECK_COMMAND found: ${FILECHECK_COMMAND}\") \n\n36  \n\n37     # Point to our custom lit.cfg.py \n\n38     set(LIT_CONFIG_FILE \"${CMAKE_CURRENT_SOURCE_DIR}/test/lit.cfg.py\") \n\n39  \n\n40     # Configure lit.site.cfg.py using current settings \n\n41     configure_file(\"${CMAKE_CURRENT_SOURCE_DIR}/test/lit.site.cfg.py.in\" \n\n42                    \"${CMAKE_CURRENT_BINARY_DIR}/test/lit.site.cfg.py\" \n\n43                    @ONLY) \n\n44  \n\n45     # Add a custom target to run tests with lit \n\n46     add_custom_target(check-classchecker \n\n47                       COMMAND ${LIT_COMMAND} -v ${CMAKE_CURRENT_BINARY_DIR}/test \n\n48                       COMMENT \"Running lit tests for classchecker clang plugin\" \n\n49                       USES_TERMINAL) \n\n50   else() \n\n51     message(FATAL_ERROR \"It was not possible to find the LIT executables at ${LLVM_BUILD}/bin\") \n\n52   endif()\n```", "```cpp\nexport LLVM_BUILD=<...>/llvm-project/build\nexport LLVM_HOME=<...>/llvm-project/install\nrm -rf build; mkdir build; cd build\ncmake -G Ninja -DCMAKE_BUILD_TYPE=Debug ..\nninja classchecker\nninja check-classchecker\n```", "```cpp\n...\n[2/2] Linking CXX shared module libclasschecker.so\n[0/1] Running lit tests for classchecker clang plugin\n-- Testing: 1 tests, 1 workers --\nPASS: classchecker :: simple_test.cpp (1 of 1)\n\nTesting Time: 0.12s\nPassed: 1\n```"]