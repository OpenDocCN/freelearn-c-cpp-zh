<html><head></head><body>
        

                            
                    <h1 class="header-title">Building a Library Management System</h1>
                
            
            
                
<p class="mce-root">In this chapter, we study a system for the management of a library. We continue to develop C++ classes, as in the previous chapters. However, in this chapter, we develop a more real-world system. The library system of this chapter can be used by a real library.</p>
<p>The library is made up of sets of books and customers. The books keep track of which customers have borrowed or reserved them. The customers keep track of which books they have borrowed and reserved.</p>
<p>The main idea is that the library holds a set of books and a set of customers. Each book is marked as borrowed or unborrowed. If it is borrowed, the identity number of the customer that borrowed the book is stored. Moreover, a book can also be reserved by one or several customers. Therefore, each book also holds a list of identity numbers for the customers that have reserved the book. It must be a list rather than a set, since the book shall be loaned to the customers in the order that they reserved the book.</p>
<p>Each customer holds two sets with the identity numbers of the book they have borrowed and reserved. In both cases, we use sets rather than lists since the order they have borrowed or reserved the books does not matter.</p>
<p class="mce-root">In this chapter, we will cover the following topics:</p>
<ul>
<li>Working with classes for books and customers that constitute a small database with integer numbers as keys.</li>
<li class="mce-root">Working with standard input and output streams, where we write information about the books and customers, and prompt the user for input.</li>
<li class="mce-root">Working with file handling and streams. The books and customers are written and read with standard C++ file streams.</li>
<li class="mce-root">Finally, we work with the generic classes <kbd>set</kbd> and <kbd>list</kbd> from the C++ standard library.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">The Book class</h1>
                
            
            
                
<p>We have three classes: <kbd>Book</kbd>, <kbd>Customer</kbd>, and <kbd>Library</kbd>:</p>
<ul>
<li>The <kbd>Book</kbd> class keeps track of a book. Each book has an author and a title, and a unique identity number.</li>
<li>The <kbd>Customer</kbd> class keeps track of a customer. Each customer has a name and an address, and a unique identity number.</li>
<li>The <kbd>Library</kbd> class keeps track of the library operations, such as adding and removing books and customers, borrowing, returning, and reserving books, as well as listing books and customers.</li>
<li>The <kbd>main</kbd> function simply creates an object of the <kbd>Library</kbd> class.</li>
</ul>
<p>Moreover, each book holds information on whether it is borrowed at the moment. If it is borrowed, the identity number of the customer who has borrowed the book is also stored. Each book also holds a list of reservations. In the same way, each customer holds sets of books currently borrowed and reserved.</p>
<p>The <kbd>Book</kbd> class holds two constructors. The first constructor is a default constructor and is used when reading books from a file. The second constructor is used when adding a new book to the library. It takes the name of the author and the title of the book as parameters.</p>
<p><strong>Book.h</strong></p>
<pre style="padding-left: 60px">class Book { 
  public: 
    Book(void); 
    Book(const string&amp; author, const string&amp; title); </pre>
<p>The <kbd>author</kbd> and <kbd>title</kbd> methods simply return the author and title of the book:</p>
<pre>    const string&amp; author(void) const { return m_author; } 
    const string&amp; title(void) const { return m_title; } </pre>
<p>The books of the library can be read from and written to a file:</p>
<pre>    void read(ifstream&amp; inStream); 
    void write(ofstream&amp; outStream) const; </pre>
<p>A book can be borrowed, reserved, or returned. A reservation can also be removed. Note that when a book is borrowed or reserved, we need to provide the identity number of the customer. However, that is not necessary when returning a book, since the <kbd>Book</kbd> class keeps track of the customer that has currently borrowed the book:</p>
<pre>    void borrowBook(int customerId); 
    int reserveBook(int customerId); 
    void unreserveBookation(int customerId); <br/>    void returnBook(); </pre>
<p>When the book is borrowed, the customer's identity number is stored, which is returned by <kbd>bookId</kbd>:</p>
<pre>    int bookId(void) const { return m_bookId; } </pre>
<p>The <kbd>borrowed</kbd> method returns true if the book is borrowed at the moment. In that case, <kbd>customerId</kbd> returns the identity number of the customer who has borrowed the book:</p>
<pre>    bool borrowed(void) const { return m_borrowed; } 
    int customerId(void) const { return m_customerId; } </pre>
<p>A book can be reserved by a list of customers, and <kbd>reservationList</kbd> returns that list:</p>
<pre>    list&lt;int&gt;&amp; reservationList(void) { return m_reservationList; } </pre>
<p>The <kbd>MaxBookId</kbd> field is static, which means that it is common to all objects of the class:</p>
<pre>    static int MaxBookId; </pre>
<p>The output stream operator writes the information of the book:</p>
<pre>    friend ostream&amp; operator&lt;&lt;(ostream&amp; outStream, 
                               const Book&amp; book); </pre>
<p>The <kbd>m_borrowed</kbd> field is true when the book is borrowed. The identity of the book and potential borrower are stored in <kbd>m_bookId</kbd> and <kbd>m_customerId</kbd>:</p>
<pre>    private: 
      bool m_borrowed = false; 
      int m_bookId, m_customerId; </pre>
<p>The name of the author and the title of the book are stored in <kbd>m_author</kbd> and <kbd>m_title</kbd>:</p>
<pre>      string m_author, m_title; </pre>
<p>More than one customer can reserve a book. When they do, their identities are stored in <kbd>m_reservationList</kbd>. It is a list rather than a set because the reservations are stored in order. When a book is returned, the next customer, in reservation order, borrows the book:</p>
<pre>      list&lt;int&gt; m_reservationList; 
      }; </pre>
<p>In this chapter, we use the generic <kbd>set</kbd>, <kbd>map</kbd>, and <kbd>list</kbd> classes from the C++ standard library. Their specifications are stored in the <kbd>Set</kbd>, <kbd>Map</kbd>, and <kbd>List</kbd> header files. The <kbd>set</kbd> and <kbd>list</kbd> classes hold a set and a list similar to our set and list classes in the previous chapter. A map is a structure where each value is identified by a unique key in order to provide fast access.</p>
<p><strong>Book.cpp</strong></p>
<pre>    #include &lt;Set&gt; 
    #include &lt;Map&gt; 
    #include &lt;List&gt; 
    #include &lt;String&gt; 
    #include &lt;FStream&gt; 
    using namespace std; 
 
    #include "Book.h" 
    #include "Customer.h" 
    #include "Library.h" </pre>
<p>Since <kbd>MaxBookId</kbd> is static, we initialize it with the double colon (<kbd>::</kbd>) notation. Every static field needs to be initialized outside the class definition:</p>
<pre>    int Book::MaxBookId = 0; </pre>
<p>The default constructor does nothing. It is used when reading from a file. Nevertheless, we still must have a default constructor to create objects of the <kbd>Book</kbd> class:</p>
<pre>    Book::Book(void) { 
      // Empty. 
    } </pre>
<p>When a new book is created, it is assigned a unique identity number. The identity number is stored in <kbd>MaxBookId</kbd>, which is increased for each new <kbd>Book</kbd> object:</p>
<pre>    Book::Book(const string&amp; author, const string&amp; title) 
     :m_bookId(++MaxBookId), 
      m_author(author), 
      m_title(title) { 
      // Empty. 
    } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Writing the book</h1>
                
            
            
                
<p>A book is written to a stream in a similar manner. However, instead of <kbd>read</kbd> we use <kbd>write</kbd>. They work in a similar manner:</p>
<pre>    void Book::write(ofstream&amp; outStream) const { 
      outStream.write((char*) &amp;m_bookId, sizeof m_bookId); </pre>
<p>When reading a string we use <kbd>getline</kbd> instead of the stream operator, since the stream operator reads one word only, while <kbd>getline</kbd> reads several words. When writing to a stream, however, we can use the stream operator. It does not matter whether the name and title are made up of one or several words:</p>
<pre>    outStream &lt;&lt; m_author &lt;&lt; endl; 
    outStream &lt;&lt; m_title &lt;&lt; endl; 
 
    outStream.write((char*) &amp;m_borrowed, sizeof m_borrowed); 
    outStream.write((char*) &amp;m_customerId, sizeof m_customerId); </pre>
<p>Similar to the reading case here, we first write the number of reservations in the list. Then we write the reservation identities themselves:</p>
<pre>    { int reservationListSize = m_reservationList.size(); 
      outStream.write((char*) &amp;reservationListSize, 
                    sizeof reservationListSize); 
 
      for (int customerId : m_reservationList) { 
        outStream.write((char*) &amp;customerId, sizeof customerId); 
      } 
    } 
    } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Reading the book</h1>
                
            
            
                
<p class="mce-root">When reading any kind of value (except strings) from a file, we use the <kbd>read</kbd> method, which reads a fixed number of bytes. The <kbd>sizeof</kbd> operator gives us the size, in bytes, of the <kbd>m_bookId</kbd> field. The <kbd>sizeof</kbd> operator can also be used to find the size of a type. For instance, <kbd>sizeof (int)</kbd> gives us the size in bytes of a value of the type <kbd>int</kbd>. The type must be enclosed in parentheses:</p>
<pre class="mce-root">    void Book::read(ifstream&amp; inStream) { <br/>      inStream.read((char*) &amp;m_bookId, sizeof m_bookId); </pre>
<p class="mce-root">When reading string values from a file, we use the C++ standard function <kbd>getline</kbd> to read the name of the author and the title of the book. It would not work to use the input stream operator if the name is made up of more than one word. If the author or title is made up of more than one word, only the first word would be read. The remaining words would not be read:</p>
<pre class="mce-root">    getline(inStream, m_author);<br/>    getline(inStream, m_title);</pre>
<p class="mce-root">Note that we use the <kbd>read</kbd> method to read the value of the <kbd>m_borrowed</kbd> field, too, even though it holds the <kbd>bool</kbd> type rather than <kbd>int</kbd>:</p>
<pre class="mce-root">    inStream.read((char*) &amp;m_borrowed, sizeof m_borrowed);<br/>    inStream.read((char*) &amp;m_customerId, sizeof m_customerId);</pre>
<p class="mce-root">When reading the reservation list, we first read the number of reservations in the list. Then we read the reservation identity numbers themselves:</p>
<pre class="mce-root">    { int reservationListSize;<br/>      inStream.read((char*) &amp;reservationListSize,<br/>                  sizeof reservationListSize);<br/>      for (int count = 0; count &lt; reservationListSize; ++count) {<br/>        int customerId;<br/>        inStream.read((char*) &amp;customerId, sizeof customerId);<br/>        m_reservationList.push_back(customerId);<br/>      }<br/>    }<br/>  } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Borrowing and reserving the book</h1>
                
            
            
                
<p>When the book is borrowed, <kbd>m_borrowed</kbd> becomes <kbd>true</kbd> and <kbd>m_customerId</kbd> is set to the identity number of the customer that borrowed the book:</p>
<pre style="padding-left: 60px">void Book::borrowBook(int customerId) { 
  m_borrowed = true; 
  m_customerId = customerId; 
} </pre>
<p>It is a little bit different when the book is reserved. While a book can be borrowed by one customer only, it can be reserved by more than one customer. The identity number of the customer is added to <kbd>m_reservationList</kbd>. The size of the list is returned for the caller to know their position in the reservation list:</p>
<pre>    int Book::reserveBook(int customerId) { 
      m_reservationList.push_back(customerId); 
      return m_reservationList.size(); 
    } </pre>
<p>When the book is returned, we just set <kbd>m_borrowed</kbd> to false. We do not need to set <kbd>m_customerId</kbd> to anything specific. It is not relevant as long as the book is not borrowed:</p>
<pre>    void Book::returnBook() { 
      m_borrowed = false; 
    } </pre>
<p>A customer can remove themselves from the reservation list. In that case, we call <kbd>remove</kbd> on <kbd>m_reservationList</kbd>:</p>
<pre>    void Book::unreserveBookation(int customerId) { 
      m_reservationList.remove(customerId); 
    } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Displaying the book</h1>
                
            
            
                
<p>The output stream operator writes the title and author of the book. If the book is borrowed, the customer's name is written, and if the reservation list is full, the reservation customers' names are written:</p>
<pre>    ostream&amp; operator&lt;&lt;(ostream&amp; outStream, const Book&amp; book) { 
      outStream &lt;&lt; """ &lt;&lt; book.m_title &lt;&lt; "" by " &lt;&lt; book.m_author; </pre>
<p>We use the double-colon notation (<kbd>::</kbd>) when accessing a static field, such as <kbd>s_customerMap</kbd> in <kbd>Library</kbd>:</p>
<pre>  if (book.m_borrowed) { 
    outStream &lt;&lt; endl &lt;&lt; "  Borrowed by: " 
              &lt;&lt; Library::s_customerMap[book.m_customerId].name() 
              &lt;&lt; "."; 
  } 
 
  if (!book.m_reservationList.empty()) { 
    outStream &lt;&lt; endl &lt;&lt; "  Reserved by: "; 
     
    bool first = true; 
    for (int customerId : book.m_reservationList) { 
      outStream &lt;&lt; (first ? "" : ",") 
                &lt;&lt; Library::s_customerMap[customerId].name(); 
      first = false; 
    } 
 
    outStream &lt;&lt; "."; 
  } 
 
  return outStream; 
} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The Customer class</h1>
                
            
            
                
<p>The <kbd>Customer</kbd> class keeps track of a customer. It holds sets of the books the customer currently has borrowed and reserved.</p>
<p><strong>Customer.h</strong></p>
<pre style="padding-left: 60px">class Customer { 
  public: 
    Customer(void); 
    Customer(const string&amp; name, const string&amp; address); 
 
    void read(ifstream&amp; inStream); 
    void write(ofstream&amp; outStream) const; 
 
    void borrowBook(int bookId); 
    void reserveBook(int bookId); 
    void returnBook(int bookId); 
    void unreserveBook(int bookId); </pre>
<p>The <kbd>hasBorrowed</kbd> method returns true if the customer has at least one book borrowed at the moment. In the <kbd>Library</kbd> class in the next section, it is not possible to remove a customer who currently has borrowed books:</p>
<pre>    bool hasBorrowed(void) const { return !m_loanSet.empty(); } 
 
    const string&amp; name(void) const {return m_name;} 
    const string&amp; address(void) const {return m_address;} 
    int id(void) const {return m_customerId;} </pre>
<p>In the same way, as in the <kbd>Book</kbd> class, which was used previously, we use the static field <kbd>MaxCustomerId</kbd> to count the identity number of the customers. We also use the output stream operator to write information about the customer:</p>
<pre>    static int MaxCustomerId; 
    friend ostream&amp; operator&lt;&lt;(ostream&amp; outStream, 
                               const Customer&amp; customer); </pre>
<p>Each customer has a name, address, and unique identity number. The sets <kbd>m_loanSet</kbd> and <kbd>m_reservationSet</kbd> hold the identity numbers of the books currently borrowed and reserved by the customer. Note that we use sets instead of lists, since the order of the books borrowed and reserved does not matter:</p>
<pre>    private: 
      int m_customerId; 
      string m_name, m_address; 
      set&lt;int&gt; m_loanSet, m_reservationSet; 
  }; </pre>
<p><strong>Customer.cpp</strong></p>
<pre>    #include &lt;Set&gt; 
    #include &lt;Map&gt; 
    #include &lt;List&gt; 
    #include &lt;String&gt; 
    #include &lt;FStream&gt; 
    using namespace std; 
 
    #include "Book.h" 
    #include "Customer.h" 
    #include "Library.h" </pre>
<p>Since <kbd>MaxCustomerId</kbd> is a static field, it needs to be defined outside the class:</p>
<pre>    int Customer::MaxCustomerId; </pre>
<p>The default constructor is used when loading objects from a file only. Therefore, there is no need to initialize the fields:</p>
<pre>    Customer::Customer(void) { 
      // Empty. 
    } </pre>
<p>The second constructor is used when creating new book objects. We use the <kbd>MaxCustomerId</kbd> field to initialize the identity number of the customer; we also initialize their <kbd>name</kbd> and <kbd>address</kbd>:</p>
<pre>    Customer::Customer(const string&amp; name, const string&amp; address) 
     :m_customerId(++MaxCustomerId), 
      m_name(name), 
      m_address(address) { 
      // Empty. 
    } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Reading the customer from a file</h1>
                
            
            
                
<p>The <kbd>read</kbd> method reads the information on a customer from the file stream:</p>
<pre>    void Customer::read(ifstream&amp; inStream) { 
     inStream.read((char*) &amp;m_customerId, sizeof m_customerId); </pre>
<p>In the same way, as in the <kbd>read</kbd> method of the <kbd>Book</kbd> class, we have to use the <kbd>getline</kbd> function instead of the input stream operator, since the input stream operator would read one word only:</p>
<pre>    getline(inStream, m_name); 
    getline(inStream, m_address); 
 
    { int loanSetSize; 
      inStream.read((char*) &amp;loanSetSize, sizeof loanSetSize); 
 
      for (int count = 0; count &lt; loanSetSize; ++count) { 
        int bookId; 
        inStream.read((char*) &amp;bookId, sizeof bookId); 
        m_loanSet.insert(bookId); 
      } 
    } 
 
    { int reservationListSize; 
      inStream.read((char*) &amp;reservationListSize, 
                  sizeof reservationListSize); 
 
      for (int count = 0; count &lt; reservationListSize; ++count) { 
        int bookId; 
        inStream.read((char*) &amp;bookId, sizeof bookId); 
        m_loanSet.insert(bookId); 
      } 
    } 
  } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Writing the customer to a file</h1>
                
            
            
                
<p>The <kbd>write</kbd> method writes information on the customer to the stream in the same way as in the <kbd>Book</kbd> class previously:</p>
<pre>    void Customer::write(ofstream&amp; outStream) const { 
      outStream.write((char*) &amp;m_customerId, sizeof m_customerId); 
      outStream &lt;&lt; m_name &lt;&lt; endl; 
      outStream &lt;&lt; m_address &lt;&lt; endl; </pre>
<p>When writing a set, we first write the size of the set, and then the individual values of the set:</p>
<pre>    { int loanSetSize = m_loanSet.size(); 
      outStream.write((char*) &amp;loanSetSize, sizeof loanSetSize); 
 
      for (int bookId : m_loanSet) { 
        outStream.write((char*) &amp;bookId, sizeof bookId); 
      } 
    } 
 
    { int reservationListSize = m_reservationSet.size(); 
      outStream.write((char*) &amp;reservationListSize, 
                    sizeof reservationListSize); 
 
      for (int bookId : m_reservationSet) { 
        outStream.write((char*) &amp;bookId, sizeof bookId); 
      } 
    } 
  } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Borrowing and reserving a book</h1>
                
            
            
                
<p>When a customer borrows a book, it is inserted into the loan set of the customer:</p>
<pre>    void Customer::borrowBook(int bookId) { 
      m_loanSet.insert(bookId); 
    } </pre>
<p>In the same way, when a customer reserves a book, it is inserted into the reservation set of the customer:</p>
<pre>    void Customer::reserveBook(int bookId) { 
      m_reservationSet.insert(bookId); 
    } </pre>
<p>When a customer returns or unreserves a book, it is removed from the loan set or reservation set:</p>
<pre>    void Customer::returnBook(int bookId) { 
      m_loanSet.erase(bookId); 
    } 
 
    void Customer::unreserveBook(int bookId) { 
      m_reservationSet.erase(bookId); 
    } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Displaying the customer</h1>
                
            
            
                
<p>The output stream operator writes the name and address of the customer. If the customer has borrowed or reserved books, they are written too:</p>
<pre>    ostream&amp; operator&lt;&lt;(ostream&amp; outStream, const Customer&amp; customer){ 
      outStream &lt;&lt; customer.m_customerId &lt;&lt; ". " &lt;&lt; customer.m_name 
                &lt;&lt; ", " &lt;&lt; customer.m_address &lt;&lt; "."; 
 
      if (!customer.m_loanSet.empty()) { 
        outStream &lt;&lt; endl &lt;&lt; "  Borrowed books: "; 
 
        bool first = true; 
        for (int bookId : customer.m_loanSet) { 
          outStream &lt;&lt; (first ? "" : ",") 
                    &lt;&lt; Library::s_bookMap[bookId].author(); 
          first = false; 
        } 
     } 
 
      if (!customer.m_reservationSet.empty()) { 
        outStream &lt;&lt; endl &lt;&lt; "  Reserved books: "; 
     
        bool first = true; 
        for (int bookId : customer.m_reservationSet) { 
          outStream &lt;&lt; (first ? "" : ",") 
                    &lt;&lt; Library::s_bookMap[bookId].title(); 
          first = false; 
        } 
      } 
 
      return outStream; 
    }   </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The Library class</h1>
                
            
            
                
<p>Finally, the <kbd>Library</kbd> class handles the library itself. It performs a set of tasks regarding borrowing and returning books.</p>
<p><strong>Library.h</strong></p>
<pre style="padding-left: 60px">class Library { 
  public: 
    Library(); 
 
  private: 
    static string s_binaryPath; </pre>
<p>The <kbd>lookupBook</kbd> method looks up a book by the author and title. It returns true if the book is found. If it is found, its information (an object of the <kbd>Book</kbd> class) is copied into the object pointed at by <kbd>bookPtr</kbd>:</p>
<pre>    bool lookupBook(const string&amp; author, const string&amp; title, 
                    Book* bookPtr = nullptr); </pre>
<p>In the same way, <kbd>lookupCustomer</kbd> looks up a customer by the name and address. If the customer is found, true is returned, and the information is copied into the object pointed at by <kbd>customerPtr</kbd>:</p>
<pre>    bool lookupCustomer(const string&amp; name, const string&amp; address, 
                        Customer* customerPtr = nullptr); </pre>
<p>The application of this chapter revolves around the following methods. They perform the tasks of the library system. Each of the methods will prompt the user for input and then perform a task, such as borrowing or returning a book.</p>
<p>The following methods perform one task each, which are looking up the information about a book or a customer, adding or deleting a book, listing the books, adding and deleting books from the library, and borrowing, reserving, and returning books:</p>
<pre>    void addBook(void); 
    void deleteBook(void); 
    void listBooks(void); 
    void addCustomer(void); 
    void deleteCustomer(void); 
    void listCustomers(void); 
    void borrowBook(void); 
    void reserveBook(void); 
    void returnBook(void); </pre>
<p>The <kbd>load</kbd> and <kbd>save</kbd> methods are called at the beginning and the end of the execution:</p>
<pre>    void load();  
    void save(); </pre>
<p>There are two maps holding the books and the customers of the library. As mentioned previously, a map is a structure where each value is identified by a unique key in order to provide fast access. The unique identity numbers of the books and customers are the keys:</p>
<pre>  public: 
    static map&lt;int,Book&gt; s_bookMap; 
    static map&lt;int,Customer&gt; s_customerMap; 
}; </pre>
<p><strong>Library.cpp</strong></p>
<pre style="padding-left: 60px">#include &lt;Set&gt; 
#include &lt;Map&gt; 
#include &lt;List&gt; 
#include &lt;String&gt; 
#include &lt;FStream&gt; 
#include &lt;IOStream&gt; 
#include &lt;Algorithm&gt; 
using namespace std; 
 
#include "Book.h" 
#include "Customer.h" 
#include "Library.h" 
 
map&lt;int,Book&gt; Library::s_bookMap; 
map&lt;int,Customer&gt; Library::s_customerMap; </pre>
<p>Between executions, the library information is stored in the <kbd>Library.bin</kbd> file on the hard drive. Note that we use two backslashes to represent one backslash in the <kbd>string</kbd>. The first backslash indicates that the character is a special character, and the second backslash states that it is a backslash:</p>
<pre style="padding-left: 60px">string Library::s_binaryPath("Library.bin"); </pre>
<p>The constructor ­loads the library, presents a menu, and iterates until the user quits. Before the execution is finished, the library is saved:</p>
<pre style="padding-left: 60px">Library::Library(void) { </pre>
<p>Before the menu is presented, the library information (books, customers, loans, and reservations) is loaded from the file:</p>
<pre style="padding-left: 60px">  load(); </pre>
<p>The while statement continues as long as <kbd>quit</kbd> is true. It remains false until the user chooses the Quit option from the menu:</p>
<pre>  bool quit = false; 
  while (!quit) { 
    cout &lt;&lt; "1. Add Book" &lt;&lt; endl 
         &lt;&lt; "2. Delete Book" &lt;&lt; endl 
         &lt;&lt; "3. List Books" &lt;&lt; endl 
         &lt;&lt; "4. Add Customer" &lt;&lt; endl 
         &lt;&lt; "5. Delete Customer" &lt;&lt; endl 
         &lt;&lt; "6. List Customers" &lt;&lt; endl 
         &lt;&lt; "7. Borrow Book" &lt;&lt; endl 
         &lt;&lt; "8. Reserve Book" &lt;&lt; endl 
         &lt;&lt; "9. Return Book" &lt;&lt; endl 
         &lt;&lt; "0. Quit" &lt;&lt; endl 
         &lt;&lt; ": "; </pre>
<p>The user inputs an integer value from the console input stream (<kbd>cin</kbd>), which is stored in <kbd>choice</kbd>:</p>
<pre>    int choice; 
    cin &gt;&gt; choice; </pre>
<p>We use a <kbd>switch</kbd> statement to perform the requested task:</p>
<pre>    switch (choice) { 
      case 1: 
        addBook(); 
        break; 
 
      case 2: 
        deleteBook(); 
        break; 
 
      case 3: 
        listBooks(); 
        break; 
 
      case 4: 
        addCustomer(); 
        break; 
 
      case 5: 
        deleteCustomer(); 
        break; 
 
      case 6: 
        listCustomers(); 
        break; 
 
      case 7: 
        borrowBook(); 
        break; 
 
      case 8: 
        reserveBook(); 
        break; 
 
      case 9: 
        returnBook(); 
        break; 
 
      case 0: 
        quit = true; 
        break; 
    } 
 
    cout &lt;&lt; endl; 
  } </pre>
<p>Before the program is finished, the library information is saved:</p>
<pre>      save(); 
    } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Looking up books and customers</h1>
                
            
            
                
<p>The <kbd>lookupBook</kbd> method iterates through the book map. It returns true if a book with the author and title exists. If the book exists, its information is copied to the object pointed at by the <kbd>bookPtr</kbd> parameter and true is returned, as long as the pointer is not null. If the book does not exist, false is returned, and no information is copied into the object:</p>
<pre>    bool Library::lookupBook(const string&amp; author, 
        const string&amp; title, Book* bookPtr /* = nullptr*/) { 
      for (const pair&lt;int,Book&gt;&amp; entry : s_bookMap) { 
        const Book&amp; book = entry.second; </pre>
<p>Note that <kbd>bookPtr</kbd> may be <kbd>nullptr</kbd>. In that case, only true is returned, and no information is written to the object pointed at by <kbd>bookPtr</kbd>:</p>
<pre style="padding-left: 60px">    if ((book.author() == author) &amp;&amp; (book.title() == title)) { 
      if (bookPtr != nullptr) { 
        *bookPtr = book; 
      } 
 
      return true; 
    } 
  } 
 
  return false; 
} </pre>
<p>In the same way, <kbd>lookupCustomer</kbd> iterates through the customer map and returns true, as well as copies the customer information to a <kbd>Customer</kbd> object if a customer with the name exists:</p>
<pre>    bool Library::lookupCustomer(const string&amp; name, 
       const string&amp; address, Customer* customerPtr /*=nullptr*/){ 
      for (const pair&lt;int,Customer&gt;&amp; entry : s_customerMap) { 
        const Customer&amp; customer = entry.second; </pre>
<p>Also, in this case, <kbd>customerPtr</kbd> may be <kbd>nullptr</kbd>. In that case, only true is returned. When adding a new customer, we would like to know if there already is a customer with the same name and address:</p>
<pre style="padding-left: 60px">    if ((customer.name() == name) &amp;&amp; 
        (customer.address() == address)) { 
      if (customerPtr != nullptr) { 
        *customerPtr = customer; 
      } 
 
      return true; 
    } 
  } 
 
  return false; 
} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding a book</h1>
                
            
            
                
<p>The <kbd>addBook</kbd> method prompts the user for the name and title of the new book:</p>
<pre>    void Library::addBook(void) { 
      string author; 
      cout &lt;&lt; "Author: "; 
      cin &gt;&gt; author; 
 
      string title; 
      cout &lt;&lt; "Title: "; 
      cin &gt;&gt; title; </pre>
<p>If a book with the <kbd>author</kbd> and <kbd>title</kbd> already exists, an error message is displayed:</p>
<pre style="padding-left: 60px">  if (lookupBook(author, title)) { 
    cout &lt;&lt; endl &lt;&lt; "The book "" &lt;&lt;  title &lt;&lt; "" by " 
         &lt;&lt; author &lt;&lt; " already exists." &lt;&lt; endl; 
    return; 
  } </pre>
<p>If the book does not already exist, we create a new <kbd>Book</kbd> object that we add to the book map:</p>
<pre style="padding-left: 60px">  Book book(author, title); 
  s_bookMap[book.bookId()] = book; 
  cout &lt;&lt; endl &lt;&lt; "Added: " &lt;&lt; book &lt;&lt; endl; 
} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Deleting a book</h1>
                
            
            
                
<p>The <kbd>deleteBook</kbd> method prompts the user for the author and title of the book, and deletes it if it exists:</p>
<pre>    void Library::deleteBook() { 
      string author; 
      cout &lt;&lt; "Author: "; 
      cin &gt;&gt; author; 
 
      string title; 
      cout &lt;&lt; "Title: "; 
      cin &gt;&gt; title; </pre>
<p>If the book does not exist, an error message is displayed:</p>
<pre style="padding-left: 60px">  Book book; 
  if (!lookupBook(author, title, &amp;book)) { 
    cout &lt;&lt; endl &lt;&lt; "There is no book "" &lt;&lt; title &lt;&lt; "" by " 
         &lt;&lt; "author " &lt;&lt; author &lt;&lt; "." &lt;&lt; endl; 
    return; 
  } </pre>
<p>When a book is being deleted, we iterate through all customers and, for each customer, return, and unreserve the book. We do that for every book just in case the book has been borrowed or reserved by customers. In the next chapter, we will work with pointers, which allow us to return and unreserve books in a more effective manner.</p>
<p>Note that when we iterate through a map and obtain each <kbd>Customer</kbd> object, we need to put it back in the map after we have modified the values of its fields:</p>
<pre>    for (pair&lt;int,Customer&gt; entry : s_customerMap) { 
      Customer&amp; customer = entry.second; 
      customer.returnBook(book.bookId()); 
      customer.unreserveBook(book.bookId()); 
      s_customerMap[customer.id()] = customer; 
    } </pre>
<p>Finally, when we have made sure the book exists, and when we have returned and unreserved it, we remove it from the book map:</p>
<pre>    s_bookMap.erase(book.bookId()); 
    cout &lt;&lt; endl &lt;&lt; "Deleted." &lt;&lt; endl; 
  } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Listing the books</h1>
                
            
            
                
<p>The <kbd>listBook</kbd> method is quite simple. First, we check if the book map is empty. If it is empty, we write <kbd>"No books."</kbd> If the book map is not empty, we iterate through it, and for each book, we write its information to the console output stream (<kbd>cout</kbd>):</p>
<pre>    void Library::listBooks(void) { 
      if (s_bookMap.empty()) { 
        cout &lt;&lt; "No books." &lt;&lt; endl; 
        return; 
      } 
 
      for (const pair&lt;int,Book&gt;&amp; entry : s_bookMap) { 
        const Book&amp; book = entry.second; 
        cout &lt;&lt; book &lt;&lt; endl; 
      } 
    } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding a customer</h1>
                
            
            
                
<p>The <kbd>addCustomer</kbd> method prompts the user for the <kbd>name</kbd> and <kbd>address</kbd> of the new customer:</p>
<pre>    void Library::addCustomer(void) { 
      string name; 
      cout &lt;&lt; "Name: "; 
      cin &gt;&gt; name; 
 
      string address; 
      cout &lt;&lt; "Address: "; 
      cin &gt;&gt; address; </pre>
<p>If a customer with the same <kbd>name</kbd> and <kbd>address</kbd> already exists, an error message is displayed:</p>
<pre>    if (lookupCustomer(name, address)) { 
      cout &lt;&lt; endl &lt;&lt; "A customer with name " &lt;&lt; name 
           &lt;&lt; " and address " &lt;&lt; address &lt;&lt; " already exists." 
           &lt;&lt; endl; 
      return; 
    } </pre>
<p>Finally, we create a new <kbd>Customer</kbd> object that we add to the customer map:</p>
<pre>    Customer customer(name, address); 
    s_customerMap[customer.id()] = customer; 
    cout &lt;&lt; endl &lt;&lt; "Added." &lt;&lt; endl; 
  } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Deleting a customer</h1>
                
            
            
                
<p>The <kbd>deleteCustomer</kbd> method deletes the customer if they exist:</p>
<pre>    void Library::deleteCustomer(void) { 
      string name; 
      cout &lt;&lt; "Name: "; 
      cin &gt;&gt; name; 
 
      string address; 
      cout &lt;&lt; "Address: "; 
      cin &gt;&gt; address; 
     
      Customer customer; 
      if (!lookupCustomer(name, address, &amp;customer)) { 
        cout &lt;&lt; endl &lt;&lt; "There is no customer with name " &lt;&lt; name 
             &lt;&lt; " and address " &lt;&lt; address &lt;&lt; "." &lt;&lt; endl; 
        return; 
      } </pre>
<p>If the customer has borrowed at least one book, it must be returned before the customer can be removed:</p>
<pre style="padding-left: 60px">  if (customer.hasBorrowed()) { 
    cout &lt;&lt; "Customer " &lt;&lt; name &lt;&lt; " has borrowed at least " 
         &lt;&lt; "one book and cannot be deleted." &lt;&lt; endl; 
    return; 
  } </pre>
<p>However, if the customer has reserved books, we just unreserve them before removing the customer:</p>
<pre style="padding-left: 60px">  for (pair&lt;int,Book&gt; entry : s_bookMap) { 
    Book&amp; book = entry.second; 
    book.unreserveBookation(customer.id()); 
    s_bookMap[book.bookId()] = book; 
  } 
 
  cout &lt;&lt; endl &lt;&lt; "Deleted." &lt;&lt; endl; 
  s_customerMap.erase(customer.id()); 
} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Listing the customers</h1>
                
            
            
                
<p>The <kbd>listCustomer</kbd> method works in a way similar to <kbd>listBooks</kbd>. If there are no customers, we write <kbd>"No Customers."</kbd> If there are customers, we write them to the console output stream (<kbd>cout</kbd>):</p>
<pre>    void Library::listCustomers(void) { 
      if (s_customerMap.empty()) { 
        cout &lt;&lt; "No customers." &lt;&lt; endl; 
        return; 
      } 
       
      for (const pair&lt;int,Customer&gt;&amp; entry : s_customerMap) { 
        const Customer&amp; customer = entry.second; 
        cout &lt;&lt; customer &lt;&lt; endl; 
      } 
    } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Borrowing a book</h1>
                
            
            
                
<p>The <kbd>borrowBook</kbd> method prompts the user for the <kbd>author</kbd> and <kbd>title</kbd> of the book:</p>
<pre>    void Library::borrowBook(void) { 
      string author; 
      cout &lt;&lt; "Author: "; 
      cin &gt;&gt; author; 
 
      string title; 
      cout &lt;&lt; "Title: "; 
      cin &gt;&gt; title; </pre>
<p>If a book with the <kbd>author</kbd> and <kbd>title</kbd> does not exist, an error message is displayed:</p>
<pre>    Book book; 
    if (!lookupBook(author, title, &amp;book)) { 
      cout &lt;&lt; endl &lt;&lt; "There is no book "" &lt;&lt; title &lt;&lt; "" by " 
           &lt;&lt; "author " &lt;&lt; author &lt;&lt; "." &lt;&lt; endl; 
      return; 
    } </pre>
<p>Also, if the <kbd>book</kbd> is already borrowed, an error message is displayed:</p>
<pre>    if (book.borrowed()) { 
      cout &lt;&lt; endl &lt;&lt; "The book "" &lt;&lt; title &lt;&lt; "" by " &lt;&lt; author 
           &lt;&lt; " has already been borrowed." &lt;&lt; endl; 
      return; 
    } </pre>
<p>Then we prompt the user for the customer's <kbd>name</kbd> and <kbd>address</kbd>:</p>
<pre style="padding-left: 60px">  string name; 
  cout &lt;&lt; "Customer name: "; 
  cin &gt;&gt; name; 
 
  string address; 
  cout &lt;&lt; "Adddress: "; 
  cin &gt;&gt; address; </pre>
<p>If there is no <kbd>customer</kbd> with the <kbd>name</kbd> and <kbd>address</kbd>, an error message is displayed:</p>
<pre>    Customer customer; 
    if (!lookupCustomer(name, address, &amp;customer)) { 
      cout &lt;&lt; endl &lt;&lt; "There is no customer with name " &lt;&lt; name 
           &lt;&lt; " and address " &lt;&lt; address &lt;&lt; "." &lt;&lt; endl; 
      return; 
    } </pre>
<p>However, if the book exists and is not already borrowed, and the customer exists, we add the book to the loan set of the customer and mark the book as to be borrowed by the customer:</p>
<pre>    book.borrowBook(customer.id()); 
    customer.borrowBook(book.bookId()); </pre>
<p>Note that we have to put the <kbd>Book</kbd> and <kbd>Customer</kbd> objects back into their maps after we have altered them. In the next chapter, we will work with a more direct approach to pointers:</p>
<pre>    s_bookMap[book.bookId()] = book; 
    s_customerMap[customer.id()] = customer; 
    cout &lt;&lt; endl &lt;&lt; "Borrowed." &lt;&lt; endl; 
  } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Reserving a book</h1>
                
            
            
                
<p>The <kbd>reserveBook</kbd> method works in the same way as <kbd>borrowBook</kbd>. It prompts the user for the <kbd>author</kbd> and <kbd>title</kbd> of the book:</p>
<pre>    void Library::reserveBook(void) { 
      string author; 
      cout &lt;&lt; "Author: "; 
      cin &gt;&gt; author; 
 
      string title; 
      cout &lt;&lt; "Title: "; 
      cin &gt;&gt; title; </pre>
<p>Similar to the <kbd>borrowBook</kbd> case, we check that the book with the <kbd>author</kbd> and <kbd>title</kbd> exists:</p>
<pre style="padding-left: 60px">  Book book; 
  if (!lookupBook(author, title, &amp;book)) { 
    cout &lt;&lt; endl &lt;&lt; "There is no book "" &lt;&lt; title &lt;&lt; "" by " 
         &lt;&lt; "author " &lt;&lt; author &lt;&lt; "." &lt;&lt; endl; 
    return; 
  } </pre>
<p>However, one difference compared to <kbd>borrowBook</kbd> is that the book must have been borrowed in order to be reserved. If it has not been borrowed, there is no point reserving it. In that case, the user should borrow the book instead:</p>
<pre style="padding-left: 60px">  if (!book.borrowed()) { 
    cout &lt;&lt; endl &lt;&lt; "The book with author " &lt;&lt; author 
         &lt;&lt; " and title "" &lt;&lt; title &lt;&lt; "" has not been " 
         &lt;&lt; "borrowed. Please borrow the book instead." &lt;&lt; endl; 
    return; 
  } </pre>
<p>If the book exists and has not been borrowed, we prompt the user for the <kbd>name</kbd> and <kbd>address</kbd> of the customer:</p>
<pre style="padding-left: 60px">  string name; 
  cout &lt;&lt; "Customer name: "; 
  cin &gt;&gt; name; 
 
  string address; 
  cout &lt;&lt; "Address: "; 
  cin &gt;&gt; address; </pre>
<p>If the customer does not exist, an error message is displayed:</p>
<pre style="padding-left: 60px">  Customer customer; 
  if (!lookupCustomer(name, address, &amp;customer)) { 
    cout &lt;&lt; endl &lt;&lt; "No customer with name " &lt;&lt; name 
         &lt;&lt; " and address " &lt;&lt; address &lt;&lt; " exists." &lt;&lt; endl; 
    return; 
  } </pre>
<p>Moreover, if a book has already been borrowed by the customer, we display an error message:</p>
<pre>    if (book.customerId() == customer.id()) { 
      cout &lt;&lt; endl &lt;&lt; "The book has already been borrowed by " 
           &lt;&lt; name &lt;&lt; "." &lt;&lt; endl; 
      return; 
    } </pre>
<p>If the book exists and has been borrowed, but not by the customer, we add the customer to the reservation list for the book and the book to the reservation set of the customer:</p>
<pre>    customer.reserveBook(book.bookId()); 
    int position = book.reserveBook(customer.id()); </pre>
<p>Also, in this case, we have to put the <kbd>Book</kbd> and <kbd>Customer</kbd> objects back into their maps:</p>
<pre>    s_bookMap[book.bookId()] = book; 
    s_customerMap[customer.id()] = customer; </pre>
<p>Finally, we write the position of the customer in the reservation list:</p>
<pre>    cout &lt;&lt; endl &lt;&lt; position &lt;&lt; "nd reserve." &lt;&lt; endl; 
  } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Returning a Book</h1>
                
            
            
                
<p>The <kbd>returnBook</kbd> method prompts the user for the author and title of the book:</p>
<pre>    void Library::returnBook(void) { 
      string author; 
      cout &lt;&lt; "Author: "; 
      cin &gt;&gt; author; 
 
      string title; 
      cout &lt;&lt; "Title: "; 
      cin &gt;&gt; title; </pre>
<p>If the book does not exist, an error message is displayed:</p>
<pre>    Book book; 
    if (!lookupBook(author, title, &amp;book)) { 
      cout &lt;&lt; endl &lt;&lt; "No book "" &lt;&lt; title 
           &lt;&lt; "" by " &lt;&lt; author &lt;&lt; " exists." &lt;&lt; endl; 
      return; 
    } </pre>
<p>If the book has not been borrowed, an error message is displayed:</p>
<pre>    if (!book.borrowed()) { 
      cout &lt;&lt; endl &lt;&lt; "The book "" &lt;&lt; title 
           &lt;&lt; "" by " &lt;&lt; author 
           &lt;&lt; "" has not been borrowed." &lt;&lt; endl; 
      return; 
    } </pre>
<p>Unlike the methods described previously, in this case, we do not ask for the customer. Instead, we return the book and look up the book in the reservation list of each customer:</p>
<pre>    book.returnBook(); 
    cout &lt;&lt; endl &lt;&lt; "Returned." &lt;&lt; endl; 
 
    Customer customer = s_customerMap[book.customerId()]; 
    customer.returnBook(book.bookId()); 
    s_customerMap[customer.id()] = customer; </pre>
<p>If the book has been reserved, we look up the first customer in the reservation list, remove them from the reservation list, and let them borrow the book:</p>
<pre>    list&lt;int&gt;&amp; reservationList = book.reservationList(); 
 
    if (!reservationList.empty()) { 
      int newCustomerId = reservationList.front(); 
      reservationList.erase(reservationList.begin()); 
      book.borrowBook(newCustomerId); 
 
      Customer newCustomer = s_customerMap[newCustomerId]; 
      newCustomer.borrowBook(book.bookId()); 
 
      s_customerMap[newCustomerId] = newCustomer; 
      cout &lt;&lt; endl &lt;&lt; "Borrowed by " &lt;&lt; newCustomer.name() &lt;&lt; endl; 
    } 
 
    s_bookMap[book.bookId()] = book; 
  } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Saving the library information to a file</h1>
                
            
            
                
<p>When saving the library information, we first open the file:</p>
<pre style="padding-left: 60px">void Library::save() { 
  ofstream outStream(s_binaryPath); </pre>
<p>If the file was correctly opened, first we write the number of books, and then we write the information for each book by calling <kbd>write</kbd> on the <kbd>Book</kbd> objects:</p>
<pre>  if (outStream) { 
    int numberOfBooks = s_bookMap.size(); 
    outStream.write((char*) &amp;numberOfBooks, sizeof numberOfBooks); 
 
    for (const pair&lt;int,Book&gt;&amp; entry : s_bookMap) { 
      const Book&amp; book = entry.second; 
      book.write(outStream); 
    } </pre>
<p>In the same way, we write the number of customers, and then the information of each customer, by calling <kbd>write</kbd>:</p>
<pre style="padding-left: 60px">    int numberOfCustomers = s_customerMap.size(); 
    outStream.write((char*) &amp;numberOfCustomers, 
                    sizeof numberOfCustomers); 
 
    for (const pair&lt;int,Customer&gt;&amp; entry : s_customerMap) { 
      const Customer&amp; customer = entry.second; 
      customer.write(outStream); 
    } 
  } 
} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Loading the library information from a file</h1>
                
            
            
                
<p>When loading the library information from a file, we use the same method we would for <kbd>read</kbd>. We start by opening the file:</p>
<pre style="padding-left: 60px">void Library::load() { 
  ifstream inStream(s_binaryPath); </pre>
<p>We read the number of books and then the information of each book:</p>
<pre style="padding-left: 60px">  if (inStream) { 
    int numberOfBooks; 
    inStream.read((char*) &amp;numberOfBooks, sizeof numberOfBooks); </pre>
<p>For each book, we create a new <kbd>Book</kbd> object, read its information by calling <kbd>read</kbd>, and add it to the book map. We also calculate the new value of the <kbd>MaxBookId</kbd> static field by assigning it the maximum value of itself and the identity number of the book:</p>
<pre>    for (int count = 0; count &lt; numberOfBooks; ++count) { 
      Book book; 
      book.read(inStream); 
      s_bookMap[book.bookId()] = book; 
      Book::MaxBookId = max(Book::MaxBookId, book.bookId()); 
    } </pre>
<p>In the same way, we read the number of customers and then the information of each customer by calling <kbd>read</kbd>:</p>
<pre>    int numberOfCustomers; 
    inStream.read((char*) &amp;numberOfCustomers, 
                  sizeof numberOfCustomers); </pre>
<p>For each customer, we create a <kbd>Customer</kbd> object, read its information from the file, add it to the customer map, and calculate a new value for the <kbd>MaxCustomerId</kbd> static field:</p>
<pre style="padding-left: 60px">    for (int count = 0; count &lt; numberOfCustomers; ++count) { 
      Customer customer; 
      customer.read(inStream); 
      s_customerMap[customer.id()] = customer; 
      Customer::MaxCustomerId = 
        max(Customer::MaxCustomerId, customer.id()); 
    } 
  } 
} </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The main function</h1>
                
            
            
                
<p>Finally, we write the <kbd>main</kbd> function, which executes the library. It is quite easy; the only thing to do is to instantiate an object of the <kbd>Library</kbd> class. Then the constructor displays the main menu:</p>
<p><strong>Main.cpp</strong></p>
<pre>    #include &lt;Set&gt; 
    #include &lt;Map&gt; 
    #include &lt;List&gt; 
    #include &lt;String&gt; 
    #include &lt;FStream&gt; 
    #include &lt;IOStream&gt; 
    using namespace std; 
 
    #include "Book.h" 
    #include "Customer.h" 
    #include "Library.h" 
 
    void main(void) { 
      Library(); 
    } </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we built a library management system made up of the classes <kbd>Book</kbd>, <kbd>Customer</kbd>, and <kbd>Library</kbd>.</p>
<p>The <kbd>Book</kbd> class holds information about a book. Each <kbd>Book</kbd> object holds a unique identity number. It also keeps track of the borrower (if the book is borrowed) and a list of reservations. In the same way, the <kbd>Customer</kbd> class holds information about a customer. Similar to the book, each customer holds a unique identity number. Each <kbd>Customer</kbd> object also holds a set of borrowed and reserved books. Finally, the <kbd>Library</kbd> class provides a set of services, such as adding and removing books and customers, borrowing, returning, and reserving books, as well as displaying lists of books and customers.</p>
<p>In this chapter, each book and customer have a unique identity number. In the next chapter, we will look into to the library system again. However, we will omit the identity numbers and work with pointers instead.</p>


            

            
        
    </body></html>