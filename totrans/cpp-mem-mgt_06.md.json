["```cpp\nnamespace managing_memory_book {\n   // basic deleter types\n   template <class T>\n   struct deleter_pointer_wrapper {\n      void (*pf)(T*);\n      deleter_pointer_wrapper(void (*pf)(T*)) : pf{ pf } {\n      }\n      void operator()(T* p) const { pf(p); }\n   };\n   template <class T>\n   struct default_deleter {\n      void operator()(T* p) const { delete p; }\n   };\n   template <class T>\n   struct default_deleter<T[]> {\n      void operator()(T* p) const { delete[] p; }\n   };\n   // ...\n}\n```", "```cpp\n#include <type_traits>\nnamespace managing_memory_book {\n   // ...\n   template <class T>\n   struct is_deleter_function_candidate\n      : std::false_type {};\n   template <class T>\n   struct is_deleter_function_candidate<void (*)(T*)>\n      : std::true_type {};\n   template <class T>\n   constexpr auto is_deleter_function_candidate_v =\n      is_deleter_function_candidate<T>::value;\n   // ...\n}\n```", "```cpp\nnamespace managing_memory_book {\n   // ...\n   // unique_ptr general template\n   template <class T, class D = default_deleter<T>>\n   class unique_ptr : std::conditional_t <\n      is_deleter_function_candidate_v<D>,\n      deleter_pointer_wrapper<T>, D\n   > {\n      using deleter_type = std::conditional_t <\n         is_deleter_function_candidate_v<D>,\n         deleter_pointer_wrapper<T>,\n         D\n      >;\n      T* p = nullptr;\n   public:\n      unique_ptr() = default;\n      unique_ptr(T* p) : p{ p } {\n      }\n      unique_ptr(T* p, void (*pf)(T*))\n         : deleter_type{ pf }, p{ p } {\n      }\n      ~unique_ptr() {\n         (*static_cast<deleter_type*>(this))(p);\n      }\n   };\n   // ...\n}\n```", "```cpp\nnamespace managing_memory_book {\n   // ...\n   // unique_ptr specialization for arrays\n   template <class T, class D>\n   class unique_ptr<T[], D> : std::conditional_t <\n      is_deleter_function_candidate_v<D>,\n      deleter_pointer_wrapper<T>,\n      D\n   > {\n      using deleter_type = std::conditional_t <\n         is_deleter_function_candidate_v<D>,\n         deleter_pointer_wrapper<T>,\n         D\n      >;\n      T* p = nullptr;\n   public:\n      unique_ptr() = default;\n      unique_ptr(T* p) : p{ p } {\n      }\n      unique_ptr(T* p, void (*pf)(T*))\n         : deleter_type{ pf }, p{ p } {\n      }\n      ~unique_ptr() {\n         (*static_cast<deleter_type*>(this))(p);\n      }\n   };\n}\n```", "```cpp\n// ...\n      unique_ptr(const unique_ptr&) = delete;\n      unique_ptr& operator=(const unique_ptr&) = delete;\n      void swap(unique_ptr &other) noexcept {\n         using std::swap;\n         swap(p, other.p);\n      }\n      unique_ptr(unique_ptr &&other) noexcept\n         : p{ std::exchange(other.p, nullptr) } {\n      }\n      unique_ptr& operator=(unique_ptr &&other) noexcept {\n         unique_ptr{ std::move(other) }.swap(*this);\n         return *this;\n      }\n// ...\n```", "```cpp\n// ...\n      bool empty() const noexcept { return !p; }\n      operator bool() const noexcept { return !empty(); }\n      bool operator==(const unique_ptr &other)\n         const noexcept {\n         return p == other.p;\n      }\n      // inferred from operator==() since C++20\n      bool operator!=(const unique_ptr &other)\n         const noexcept {\n         return !(*this == other);\n      }\n      T *get() noexcept { return p; }\n      const T *get() const noexcept { return p; }\n// ...\n```", "```cpp\n// ...\n      T& operator*() noexcept { return *p; }\n      const T& operator*() const noexcept { return *p; }\n      T* operator->() noexcept { return p; }\n      const T* operator->() const noexcept { return p; }\n// ...\n```", "```cpp\n// ...\n      T& operator[](std::size_t n) noexcept {\n         return p[n];\n      }\n      const T& operator[](std::size_t n) const noexcept {\n         return p[n];\n      }\n// ...\n```", "```cpp\n// the following is for both the array and non-array cases\ntemplate <class U>\n   decltype(auto) get(this U && self) noexcept {\n      return self.p;\n   }\n// the following two are only for the non-array case\ntemplate <class U>\n   decltype(auto) operator*(this U && self) noexcept {\n      return *(self.p);\n   }\ntemplate <class U>\n   decltype(auto) operator->(this U && self) noexcept {\n      return self.p;\n   }\n// the following is only for the array case\ntemplate <class U>\n   decltype(auto) operator[](this U && self,\n                             std::size_t n) noexcept {\n   return self.p[n];\n}\n```", "```cpp\n// ... (our own unique_ptr<T> goes here...)\nstruct X {};\nint main() {\n   unique_ptr<X> p{ new X };\n} // X::~X() called here\n```", "```cpp\n// ... (our own unique_ptr<T> goes here...)\nclass X {\n   ~X(){}\npublic:\n   static void destroy(X *p) { delete p; }\n};\nint main() {\n   unique_ptr<X, &X::destroy> p{ new X };\n} // X::destroy(p.get()) called here\n```", "```cpp\n#include <atomic>\n#include <utility>\nnamespace managing_memory_book {\n   // naïve shared_ptr\n   template <class T>\n   class shared_ptr {\n      T* p = nullptr;\n      std::atomic<long long> *ctr = nullptr;\n      // ...\n```", "```cpp\n      // ...\n   public:\n      shared_ptr() = default;\n      shared_ptr(T* p) : p{ p } {\n         if(p) try {\n            ctr = new std::atomic<long long>{ 1LL };\n         } catch(...) {\n            delete p;\n            throw;\n         }\n      }\n      shared_ptr(const shared_ptr &other)\n         : p{ other.p }, ctr{ other.ctr } {\n         if(ctr) ++(*ctr);\n      }\n      shared_ptr(shared_ptr &&other) noexcept\n         : p{ std::exchange(other.p, nullptr) },\n           ctr{ std::exchange(other.ctr, nullptr) } {\n      }\n      bool empty() const noexcept { return !p; }\n      operator bool() const noexcept { return !empty(); }\n// ...\n```", "```cpp\n      // ...\n      void swap(shared_ptr &other) noexcept {\n         using std::swap;\n         swap(p, other.p);\n         swap(ctr, other.ctr);\n      }\n      shared_ptr& operator=(const shared_ptr &other) {\n         shared_ptr{ other }.swap(*this);\n         return *this;\n      }\n      shared_ptr& operator=(shared_ptr &&other) noexcept {\n         shared_ptr{ std::move(other) }.swap(*this);\n         return *this;\n      }\n      // ...\n```", "```cpp\n      // ...\n      ~shared_ptr() {\n         if(ctr) {\n            auto expected = ctr->load();\n            auto desired = expected - 1;\n            while(ctr->compare_exchange_weak(expected,\n                                             desired))\n                desired = expected - 1;\n            if(desired == 0) { // I was the last user of *p\n               delete p;\n               delete ctr;\n            }\n         }\n      }\n      // ...\n```", "```cpp\n      // ...\n      bool operator==(const shared_ptr &other)\n         const noexcept { return p == other.p; }\n      // inferred from operator==() since C++20\n      bool operator!=(const shared_ptr &other)\n         const noexcept { return !(*this == other); }\n      T *get() noexcept { return p; }\n      const T *get() const noexcept { return p; }\n      T& operator*() noexcept { return *p; }\n      const T& operator*() const noexcept { return *p; }\n      T* operator->() noexcept { return p; }\n      const T* operator->() const noexcept { return p; }\n   };\n}\n```", "```cpp\n#include <thread>\n#include <chrono>\n#include <random>\n#include <iostream>\nusing namespace std::literals;\nstruct X {\n   int n;\n   X(int n) : n{ n } {}\n   ~X() { std::cout << \"X::~X()\\n\"; }\n};\nint main() {\n   using managing_memory_book::shared_ptr;\n   std::mt19937 prng{ std::random_device{}() };\n   std::uniform_int_distribution<int> die{ 200, 300 };\n   shared_ptr<X> p{ new X{ 3 } };\n   using std::chrono::milliseconds; // shortcut\n   std::thread th0{ [p, dt = die(prng)] {\n      std::this_thread::sleep_for(milliseconds{dt});\n      std::cout << \"end of th0, p->n : \" << p->n << '\\n';\n   } };\n   std::thread th1{ [p, dt = die(prng)] {\n      std::this_thread::sleep_for(milliseconds{dt});\n      std::cout << \"end of th1, p->n : \" << p->n << '\\n';\n   } };\n   th1.detach();\n   th0.detach();\n   std::this_thread::sleep_for(350ms);\n   std::cout << \"end main()\\n\";\n}\n```", "```cpp\nstd::shared_ptr<X> p{ new X { /* ... args ... */ };\n```", "```cpp\nauto p= std::make_shared<X>( /* ... args ... */ );\n```", "```cpp\nstruct X { int n; };\nstruct B {\n   int n;\n   B(int n) : n{ n } {}\n   virtual ~B() = default;\n};\nstruct D0 : B {\n   D0(int n) : B{ n } { /* ... */ }\n   // ...\n};\nstruct D1 : B {\n   D1(int n) : B{ n } { /* ... */ }\n   // ...\n};\n// precondition: p != nullptr (to keep things simple)\nX* duplicate(X *p) {\n   return new X{ *p }; // Ok\n}\n// precondition: p != nullptr (to keep things simple)\nB* duplicate(B *p) {\n   return new B{ *p }; // Bad idea!\n}\n#include <memory>\nint main() {\n   using std::unique_ptr;\n   X x{ 3 };\n   unique_ptr<X> px { duplicate(&x) };\n   D0 d0{ 4 };\n   unique_ptr<B> pb{ duplicate(&d0) }; // trouble ahead\n}\n```", "```cpp\nstruct cloneable {\n   virtual cloneable * clone() const = 0;\n   virtual ~cloneable() = default;\n};\n```", "```cpp\n// ... type cloneable\nstruct X { int n; };\nstruct B : cloneable { // every B is cloneable\n   int n;\n   B(int n) : n{ n } {}\n   virtual ~B() = default;\n   B * clone()\nprotected: // cloneable types are meaningfully copied\n           // in a subjective manner\n   B(const B&) = default;\n};\nstruct D0 : B {\n   D0(int n) : B{ n } { /* ... */ }\n   D0* clone() const override { return new D0{ *this }; }\n   // ...\n};\nstruct D1 : B {\n   D1(int n) : B{ n } { /* ... */ }\n   D1* clone() const override { return new D1{ *this }; }\n   // ...\n};\n```", "```cpp\n// ... type cloneable\nstruct Copier {\n   template <class T> T* operator()(const T *p) const {\n      return new T{ *p };\n   }\n};\nstruct Cloner {\n   template <class T> T* operator()(const T *p) const {\n      return p->clone();\n   }\n};\n#include <type_traits>\ntemplate <class T,\n          class Dup = std::conditional_t<\n             std::is_base_of_v<cloneable, T>,\n             Cloner, Copier\n          >>\nclass dup_ptr {\n   T *p{};\n   // use an object of type Dup when duplication is\n   // required: copy constructor and copy assignment\n   // ...\npublic:\n   dup_ptr(const dup_ptr &other)\n      : p{ other.empty()? nullptr : Dup{}(other.p) } {\n   }\n   // ...\n};\n```", "```cpp\n// types Cloner and Copier (see above)\ntemplate <class, class = void>\n   struct has_clone : std::false_type { };\ntemplate <class T>\n   struct has_clone <T, std::void_t<\n      decltype(std::declval<const T*>()->clone())\n   >> : std::true_type { };\ntemplate <class T>\n   constexpr bool has_clone_v = has_clone<T>::value;\ntemplate <class T, class Dup = std::conditional_t<\n             has_clone_v<T>, Cloner, Copier\n>> class dup_ptr {\n   T *p{};\npublic:\n   // ...\n   dup_ptr(const dup_ptr &other)\n      : p{ other.empty()? nullptr : Dup{}(other.p) } {\n   }\n   // ...\n};\n```", "```cpp\ntemplate <class T>\n   concept cloneable = requires(const T *p) {\n      { p->clone() } -> std::convertible_to<T*>;\n   };\ntemplate <class T, class Dup = std::conditional_t<\n            cloneable<T>, Cloner, Copier\n>> class dup_ptr {\n   T *p{};\npublic:\n   // ...\n   dup_ptr(const dup_ptr &other)\n      : p{ other.empty()? nullptr : Dup{}(other.p) } {\n   }\n   // ...\n};\n```", "```cpp\n// ...\n// precondition: p != nullptr (to keep things simple)\nX* duplicate(X *p) {\n   return new X{ *p }; // Ok\n}\n// ...\n```", "```cpp\nclass invalid_pointer {};\ntemplate <class T>\n   class non_null_ptr {\n      T *p;\n   public:\n      non_null_ptr(T *p) : p{ p } {\n         if (!p) throw invalid_pointer{};\n      }\n      T* get() const { return p; }\n      constexpr operator bool() const noexcept {\n         return true;\n      }\n   // ...\n```", "```cpp\nstruct X { int n; };\nclass invalid {};\nint extract_value(const X *p) {\n   if(!p) throw invalid{};\n   return p->n;\n}\n#include <iostream>\nint main() try {\n   X x{ 3 };\n   std::cout << extract_value(&x) << '\\n'\n             << extract_value(nullptr) << '\\n';\n} catch(invalid) {\n   std::cerr << \"oops\\n\";\n}\n```", "```cpp\n// definition of the non_null_ptr type (omitted)\nstruct X { int n; };\nint extract_value(const non_null_ptr<X> &p) {\n   return p->n; // no need for validation as it stems\n                // from the type system itself\n}\n#include <iostream>\nint main() try {\n   X x{ 3 };\n   std::cout << extract_value(&x) << '\\n'\n             << extract_value(nullptr) << '\\n';\n} catch(...) {\n   std::cerr << \"oops\\n\";\n}\n```", "```cpp\nclass X { /* ... */ };\nvoid f(X *p) {\n   // use *p\n   // we passed a raw pointer to f(), so f() should\n   // observe it, not own it\ndelete p; // wait! You're not supposed to do that!\n}\n```", "```cpp\nclass X { /* ... */ };\nvoid f(observer_ptr<X> p) {\n   // use *p\n   // delete p; // nope, does not compile\n}\n```"]