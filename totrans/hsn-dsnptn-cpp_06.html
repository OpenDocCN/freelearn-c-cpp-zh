<html><head></head><body>
<div id="_idContainer019">
<h1 class="chapter-number" id="_idParaDest-98"><a id="_idTextAnchor266"/><a id="_idTextAnchor267"/><a id="_idTextAnchor268"/><a id="_idTextAnchor269"/><a id="_idTextAnchor270"/><span class="koboSpan" id="kobo.1.1">6</span></h1>
<h1 id="_idParaDest-99"><a id="_idTextAnchor271"/><span class="koboSpan" id="kobo.2.1">Understanding Type Erasure</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Type erasure is often seen as a mysterious, enigmatic programming technique. </span><span class="koboSpan" id="kobo.3.2">It is not exclusive to C++ (most tutorials on type erasure use Java for their examples). </span><span class="koboSpan" id="kobo.3.3">The goal of this chapter is to </span><a id="_idIndexMarker259"/><span class="koboSpan" id="kobo.4.1">lift the shroud of mystery and teach you what type erasure is and how to use it </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">in C++.</span></span></p>
<p><span class="koboSpan" id="kobo.6.1">The following topics will be covered in </span><span class="No-Break"><span class="koboSpan" id="kobo.7.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.8.1">What is </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">type erasure?</span></span></li>
<li><span class="koboSpan" id="kobo.10.1">Is type erasure a design pattern, or an </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">implementation technique?</span></span></li>
<li><span class="koboSpan" id="kobo.12.1">How can we implement </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">type erasure?</span></span><a id="_idTextAnchor272"/></li>
<li><span class="koboSpan" id="kobo.14.1">What design and performance considerations must be taken into account when deciding to use type erasure? </span><span class="koboSpan" id="kobo.14.2">What other guidelines can be offered for the use of </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">type erasure?</span></span></li>
</ul>
<h1 id="_idParaDest-100"><a id="_idTextAnchor273"/><span class="koboSpan" id="kobo.16.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.17.1">Example code can be found at the following </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">link: </span></span><a href="https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/main/Chapter06"><span class="No-Break"><span class="koboSpan" id="kobo.19.1">https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/main/Chapter06</span></span></a></p>
<p><span class="koboSpan" id="kobo.20.1">You will need the Google Benchmark library installed and configured, details for which can be found here: </span><a href="https://github.com/google/benchmark"><span class="koboSpan" id="kobo.21.1">https://github.com/google/benchmark</span></a><span class="koboSpan" id="kobo.22.1"> (see </span><a href="B19262_04.xhtml#_idTextAnchor152"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.23.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.24.1">, </span><em class="italic"><span class="koboSpan" id="kobo.25.1">Swap - From Simple </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.26.1">to Subtle</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">)</span></span><a id="_idTextAnchor274"/><a id="_idTextAnchor275"/></p>
<h1 id="_idParaDest-101"><a id="_idTextAnchor276"/><span class="koboSpan" id="kobo.28.1">What is type erasure?</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.29.1">Type erasure</span></strong><span class="koboSpan" id="kobo.30.1">, in general, is a programming technique by which the explicit type information is removed </span><a id="_idIndexMarker260"/><span class="koboSpan" id="kobo.31.1">from the program. </span><span class="koboSpan" id="kobo.31.2">It is a type of abstraction that ensures that the program does not explicitly depend on some of the </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">data types</span><a id="_idTextAnchor277"/><span class="koboSpan" id="kobo.33.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.34.1">This definition, while perfectly correct, also serves perfectly to surround type erasure in mystery. </span><span class="koboSpan" id="kobo.34.2">It does so by employing a sort of circular reasoning—it dangles before you the hope for something that, at first glance, appears impossible—a program written in a strongly typed language that does not use the actual types. </span><span class="koboSpan" id="kobo.34.3">How can this be? </span><span class="koboSpan" id="kobo.34.4">Why, by abstracting away the type, of course! </span><span class="koboSpan" id="kobo.34.5">And so, the hope and the mystery </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">lives on.</span></span></p>
<p><span class="koboSpan" id="kobo.36.1">It is hard to imagine a program that uses types without explicitly mentioning them (at least a C++ program; there are certainly languages where all types are not final </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">until runtime).</span></span></p>
<p><span class="koboSpan" id="kobo.38.1">So, we begin by demonstrating what is meant by type erasure using an example. </span><span class="koboSpan" id="kobo.38.2">This should allow us to gain </span><a id="_idIndexMarker261"/><span class="koboSpan" id="kobo.39.1">an intuitive understanding of type erasure, which, in the later sections of this chapter, we will develop and make more rigorous. </span><span class="koboSpan" id="kobo.39.2">The aim here is to increase the level of abstraction—instead of writing some type-specific code, perhaps several versions of it for different types, we can write just one version that is more abstract, and expresses the concept—for example, instead of writing a function whose interface express</span><a id="_idTextAnchor278"/><span class="koboSpan" id="kobo.40.1">es the concept </span><em class="italic"><span class="koboSpan" id="kobo.41.1">sort an array of integers</span></em><span class="koboSpan" id="kobo.42.1">, we want to write a more abstract function, </span><em class="italic"><span class="koboSpan" id="kobo.43.1">sort </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.44.1">any arra</span><a id="_idTextAnchor279"/><span class="koboSpan" id="kobo.45.1">y</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">.</span></span></p>
<h2 id="_idParaDest-102"><a id="_idTextAnchor280"/><span class="koboSpan" id="kobo.47.1">Type erasure by example</span></h2>
<p><span class="koboSpan" id="kobo.48.1">We will go </span><a id="_idIndexMarker262"/><span class="koboSpan" id="kobo.49.1">through a detailed explanation of what type erasure is and how it is accomplished in C++. </span><span class="koboSpan" id="kobo.49.2">But first, let’s see what a program that has had the explicit type information removed from it </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">looks like.</span></span></p>
<p><span class="koboSpan" id="kobo.51.1">We start with a very simple example of using a unique </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">pointer, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.53.1">std::unique_ptr</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.55.1">
std::unique_ptr&lt;int&gt; p(new int(0));</span></pre>
<p><span class="koboSpan" id="kobo.56.1">This is an owning pointer (see </span><a href="B19262_03.xhtml#_idTextAnchor110"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.57.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.58.1">, </span><em class="italic"><span class="koboSpan" id="kobo.59.1">Memory and Ownership</span></em><span class="koboSpan" id="kobo.60.1">)—the entity containing this pointer, such as an object or a functional scope, also controls the lifetime of the integer we allocated, and is responsible for its deletion. </span><span class="koboSpan" id="kobo.60.2">The deletion is not explicitly visible in the code and will happen when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.61.1">p</span></strong><span class="koboSpan" id="kobo.62.1"> pointer is deleted (for example, when it goes out of scope). </span><span class="koboSpan" id="kobo.62.2">The way this deletion will be accomplished is also not explicitly visible—by default, </span><strong class="source-inline"><span class="koboSpan" id="kobo.63.1">std::unique_ptr</span></strong><span class="koboSpan" id="kobo.64.1"> deletes the object it owns using </span><strong class="source-inline"><span class="koboSpan" id="kobo.65.1">operator delete</span></strong><span class="koboSpan" id="kobo.66.1">, or, more precisely, by invoking </span><strong class="source-inline"><span class="koboSpan" id="kobo.67.1">std::default_delete</span></strong><span class="koboSpan" id="kobo.68.1">, which, in turn, calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">operator delete</span></strong><span class="koboSpan" id="kobo.70.1">. </span><span class="koboSpan" id="kobo.70.2">What if we do not want to use the regular standard </span><strong class="source-inline"><span class="koboSpan" id="kobo.71.1">delete</span></strong><span class="koboSpan" id="kobo.72.1">? </span><span class="koboSpan" id="kobo.72.2">For example, we may have objects that are allocated on our </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">own heap:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.74.1">
class MyHeap {
  public:
  ...
</span><span class="koboSpan" id="kobo.74.2">  void* allocate(size_t size);
  void deallocate(void* p);
  </span><a id="_idTextAnchor281"/><span class="koboSpan" id="kobo.75.1">...
</span><span class="koboSpan" id="kobo.75.2">};
void* operator new(size_t size, MyHeap* heap) {
  return heap-&gt;allocate(size);
}</span></pre>
<p><span class="koboSpan" id="kobo.76.1">Allocation is no problem, with the help of the overloaded </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">operator new</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.79.1">
MyHeap heap;
std::unique_ptr&lt;int&gt; p(new(&amp;heap) int(0));</span></pre>
<p><span class="koboSpan" id="kobo.80.1">This syntax invokes the two-argument </span><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">operator new</span></strong><span class="koboSpan" id="kobo.82.1"> function; the first argument is always the size and is added by the compiler, and the second argument is the heap pointer. </span><span class="koboSpan" id="kobo.82.2">Since we have such an overload declared, it will be invoked and will return the memory allocated from the heap. </span><span class="koboSpan" id="kobo.82.3">But we have not done anything to change the way the object is deleted. </span><span class="koboSpan" id="kobo.82.4">The regular </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">operator delete</span></strong><span class="koboSpan" id="kobo.84.1"> function will be called and will attempt to return to </span><a id="_idIndexMarker263"/><span class="koboSpan" id="kobo.85.1">the global heap some memory that wasn’t allocated from there. </span><span class="koboSpan" id="kobo.85.2">The result is likely to be memory corruption, and probably a crash. </span><span class="koboSpan" id="kobo.85.3">We could define an </span><strong class="source-inline"><span class="koboSpan" id="kobo.86.1">operator delete</span></strong><span class="koboSpan" id="kobo.87.1"> function with the same additional argument, but it does us no good here—unlike </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">operator new</span></strong><span class="koboSpan" id="kobo.89.1">, there is no place to pass arguments to </span><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">delete</span></strong><span class="koboSpan" id="kobo.91.1"> (you will often see such an </span><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">operator delete</span></strong><span class="koboSpan" id="kobo.93.1"> function defined anyway, and it should behave as such, but it has nothing to do with any </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">delete</span></strong><span class="koboSpan" id="kobo.95.1"> you see in the program; it is used in the stack unwinding if the constructor throws </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">an exception).</span></span></p>
<p><span class="koboSpan" id="kobo.97.1">Somehow, we need to tell the unique pointer that this particular object is to be deleted differently. </span><span class="koboSpan" id="kobo.97.2">It turns out that </span><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">std::unique_ptr</span></strong><span class="koboSpan" id="kobo.99.1"> has a second </span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">template</span></strong><span class="koboSpan" id="kobo.101.1"> argument. </span><span class="koboSpan" id="kobo.101.2">You usually don’t see it because it defaults to </span><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">std::default_delete</span></strong><span class="koboSpan" id="kobo.103.1">, but that can be changed and a custom </span><strong class="source-inline"><span class="koboSpan" id="kobo.104.1">deleter</span></strong><span class="koboSpan" id="kobo.105.1"> object can be defined to match the allocation mechanism. </span><span class="koboSpan" id="kobo.105.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">deleter</span></strong><span class="koboSpan" id="kobo.107.1"> has a very simple interface—it needs to </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">be callable:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.109.1">
template &lt;typename T&gt; struct MyDeleter {
  void operator()(T* p);
};</span></pre>
<p><span class="koboSpan" id="kobo.110.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.111.1">std::default_delete</span></strong><span class="koboSpan" id="kobo.112.1"> policy is implemented pretty much like that and simply calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">delete</span></strong><span class="koboSpan" id="kobo.114.1"> on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">p</span></strong><span class="koboSpan" id="kobo.116.1"> pointer. </span><span class="koboSpan" id="kobo.116.2">Our custom </span><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">deleter</span></strong><span class="koboSpan" id="kobo.118.1"> will need a non-trivial constructor to store the pointer to the heap. </span><span class="koboSpan" id="kobo.118.2">Note that, while the </span><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">deleter</span></strong><span class="koboSpan" id="kobo.120.1"> needs, in general, to be able to delete an object of any type that can be allocated, it does not have to be a template class. </span><span class="koboSpan" id="kobo.120.2">A non-template class with a template member function will do just as well, as long as the data members of the class do not depend on the deleted type. </span><span class="koboSpan" id="kobo.120.3">In our case, the data members depend only on the type of the heap, but not on what is </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">being deleted:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.122.1">
class MyDeleter {
  MyHeap* heap_;
  pub</span><a id="_idTextAnchor282"/><span class="koboSpan" id="kobo.123.1">lic:
  MyDeleter(MyHeap* heap) : heap_(heap) {}
  template &lt;typename T&gt; void operator()(T* p) {
    p-&gt;~T();
    heap_-&gt;deallocate(p);
  }
};</span></pre>
<p><span class="koboSpan" id="kobo.124.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">deleter</span></strong><span class="koboSpan" id="kobo.126.1"> has to perform the equivalent of both functions of the standard </span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">operator</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.128.1">delete</span></strong><span class="koboSpan" id="kobo.129.1"> function—it has to invoke the destructor of the object being deleted, then it must deallocate the memory that was allocated for </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">this object.</span></span></p>
<p><span class="koboSpan" id="kobo.131.1">Now that we have the appropriate </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">deleter</span></strong><span class="koboSpan" id="kobo.133.1">, we can finally use </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">std::unique_ptr</span></strong><span class="koboSpan" id="kobo.135.1"> with our </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">own heap:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.137.1">
// Example 01
MyHeap heap;
MyDeleter deleter(&amp;heap);
std::unique_ptr&lt;int, MyDeleter&gt; p(
  new(&amp;heap) int(0), deleter);</span></pre>
<p><span class="koboSpan" id="kobo.138.1">Note that </span><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">deleter</span></strong><span class="koboSpan" id="kobo.140.1"> objects are often created on demand, at the point </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">of allocation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.142.1">
MyHeap heap;
std::unique_ptr&lt;int, MyDeleter&gt; p(
  new(&amp;heap) int(0), MyDeleter(&amp;heap));</span></pre>
<p><span class="koboSpan" id="kobo.143.1">Either way, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">deleter</span></strong><span class="koboSpan" id="kobo.145.1"> must be no-throw-copyable or no-throw-movable; that is, it must have a copy constructor or a move constructor, and the constructor must be declared </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">noexcept</span></strong><span class="koboSpan" id="kobo.147.1">. </span><span class="koboSpan" id="kobo.147.2">The built-in types, such as raw pointers, are, of course, copyable, and the default compiler-generated constructor does not throw. </span><span class="koboSpan" id="kobo.147.3">Any aggregate type combining one or more of these types as data members, such as our </span><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">deleter</span></strong><span class="koboSpan" id="kobo.149.1">, has a default constructor that also does not throw (unless it has been redefined, </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">of course).</span></span></p>
<p><span class="koboSpan" id="kobo.151.1">Note that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">deleter</span></strong><span class="koboSpan" id="kobo.153.1"> is a part of the unique pointer’s type. </span><span class="koboSpan" id="kobo.153.2">Two unique pointers </span><a id="_idIndexMarker264"/><span class="koboSpan" id="kobo.154.1">that own objects of the same type, but have different deleters, are </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">different types:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.156.1">
// Example 02
MyHeap heap;
std::unique_ptr&lt;int, MyDeleter&gt; p(
  new(&amp;heap) int(0), MyDeleter(&amp;heap));
std::unique_ptr&lt;int&gt; q(new int(0));
p = std::move(q);    // Error: p and q are different types</span></pre>
<p><span class="koboSpan" id="kobo.157.1">Similarly, the unique pointer must be constructed with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">deleter</span></strong><span class="koboSpan" id="kobo.159.1"> of the </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">right type:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.161.1">
std::unique_ptr&lt;int&gt; p(new(&amp;heap) int(0),
  MyDeleter(&amp;heap));    // Does not co</span><a id="_idTextAnchor283"/><span class="koboSpan" id="kobo.162.1">mpile</span></pre>
<p><span class="koboSpan" id="kobo.163.1">As an aside, while experimenting with unique pointers of different types, you might notice that the two pointers in the preceding code, </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">p</span></strong><span class="koboSpan" id="kobo.165.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">q</span></strong><span class="koboSpan" id="kobo.167.1">, while not assignable, are comparable: </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">p == q</span></strong><span class="koboSpan" id="kobo.169.1"> compiles. </span><span class="koboSpan" id="kobo.169.2">This happens because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">comparison</span></strong><span class="koboSpan" id="kobo.171.1"> operator is actually a template—it accepts two unique pointers of different types and compares the underlying raw pointers (if that type differs as well, the compilation error is likely to not mention the unique pointer at all, but instead, to say something about comparing pointers to distinct types without </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">a cast).</span></span></p>
<p><span class="koboSpan" id="kobo.173.1">Now let’s do the same example, but with the shared pointer, </span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">std::shared_ptr</span></strong><span class="koboSpan" id="kobo.175.1">. </span><span class="koboSpan" id="kobo.175.2">First, we point the shared pointer to an object constructed with the regular </span><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">operator new</span></strong><span class="koboSpan" id="kobo.177.1"> function </span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.179.1">
std::unique_ptr&lt;int&gt; p(new int(0));
std::shared_ptr&lt;int&gt; q(new int(0));</span></pre>
<p><span class="koboSpan" id="kobo.180.1">For comparison, we left the unique pointer declaration there as well. </span><span class="koboSpan" id="kobo.180.2">The two smart pointers are </span><a id="_idIndexMarker265"/><span class="koboSpan" id="kobo.181.1">declared and constructed in exactly the same way. </span><span class="koboSpan" id="kobo.181.2">And now, in the following code block, the shared pointer to an object allocated on </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">our </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">heap</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.185.1">
MyHeap heap;
std::unique_ptr&lt;int, MyDeleter&gt; p(
  new(&amp;heap) int(0), MyDeleter(&amp;heap));
std::shared_ptr&lt;int&gt; q(
  new(&amp;heap) int(0), MyDeleter(&amp;heap));</span></pre>
<p><span class="koboSpan" id="kobo.186.1">Now you see a difference—the shared pointer that was created with a custom </span><strong class="source-inline"><span class="koboSpan" id="kobo.187.1">deleter</span></strong><span class="koboSpan" id="kobo.188.1"> is, nonetheless, of the same type as the one that uses the default </span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">deleter</span></strong><span class="koboSpan" id="kobo.190.1">! </span><span class="koboSpan" id="kobo.190.2">In fact, all shared pointers to </span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">int</span></strong><span class="koboSpan" id="kobo.192.1"> have the same type, </span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">std::shared_ptr&lt;int&gt;</span></strong><span class="koboSpan" id="kobo.194.1">—the template does not have another argument. </span><span class="koboSpan" id="kobo.194.2">Think this through—the </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">deleter</span></strong><span class="koboSpan" id="kobo.196.1"> is specified in the constructor but is used only in the destructor, therefore it must be stored inside the smart pointer object until needed. </span><span class="koboSpan" id="kobo.196.2">There is no way to recover it later if we lose the object that was given to us during construction. </span><span class="koboSpan" id="kobo.196.3">Both </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">std::shared_ptr</span></strong><span class="koboSpan" id="kobo.198.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">std::unique_ptr</span></strong><span class="koboSpan" id="kobo.200.1"> must store the </span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">deleter</span></strong><span class="koboSpan" id="kobo.202.1"> object of an arbitrary type inside the pointer object itself. </span><span class="koboSpan" id="kobo.202.2">But only the </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">std::unique_ptr</span></strong><span class="koboSpan" id="kobo.204.1"> class has the deleter information in its type. </span><span class="koboSpan" id="kobo.204.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">std::shared_ptr</span></strong><span class="koboSpan" id="kobo.206.1"> class is the same for all deleter types. </span><span class="koboSpan" id="kobo.206.2">Going back to the very beginning of this section, the program that uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">std::shared_ptr&lt;int&gt;</span></strong><span class="koboSpan" id="kobo.208.1"> does not have any explicit information about the </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">deleter type.</span></span></p>
<p><span class="koboSpan" id="kobo.210.1">This type has been erased from the program. </span><span class="koboSpan" id="kobo.210.2">This, then, is what a type-erased program </span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">looks like:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.212.1">
// Example 03
void some_function(std::shared_ptr&lt;int&gt;);     // no deleter
MyHeap heap;
{
  std::shared_ptr&lt;int&gt; p(    // No deleter in the type
    new(&amp;heap) int(0),
    MyDeleter(&amp;heap));    // Deleter in constructor only
  std::shared_ptr&lt;int&gt; q(p);    // No deleter type a</span><a id="_idTextAnchor284"/><span class="koboSpan" id="kobo.213.1">nywhere
  some_function(p);    // uses p, no deleter
}    // Deletion happens, MyDeleter is invoked</span></pre>
<p><span class="koboSpan" id="kobo.214.1">We spent so much time dissecting </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">std::shared_ptr</span></strong><span class="koboSpan" id="kobo.216.1"> because it provides a very simple example </span><a id="_idIndexMarker266"/><span class="koboSpan" id="kobo.217.1">of type erasure, especially since we can contrast it with </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">std::unique_ptr</span></strong><span class="koboSpan" id="kobo.219.1"> which has to solve exactly the same problem but chooses the opposite approach. </span><span class="koboSpan" id="kobo.219.2">This simple example, however, does not highlight the design implications of choosing type erasure and does not illustrate what design problems this pattern solves. </span><span class="koboSpan" id="kobo.219.3">For that, we should look at the quintessential type-erased object in </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">C++: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">std::function</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">.</span></span></p>
<h2 id="_idParaDest-103"><a id="_idTextAnchor285"/><span class="koboSpan" id="kobo.223.1">From example to generalization</span></h2>
<p><span class="koboSpan" id="kobo.224.1">In C++, </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">std::function</span></strong><span class="koboSpan" id="kobo.226.1"> is a general-purpose polymorphic function wrapper, or a general callable object. </span><span class="koboSpan" id="kobo.226.2">It is </span><a id="_idIndexMarker267"/><span class="koboSpan" id="kobo.227.1">used to store any callable entity such as a function, a lambda expression, a functor (an object with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">operator()</span></strong><span class="koboSpan" id="kobo.229.1">), or a member function pointer. </span><span class="koboSpan" id="kobo.229.2">The only requirement for these different callable entities is that they must have the same call signature, i.e., accept the same arguments and return the result of the same type. </span><span class="koboSpan" id="kobo.229.3">The signature is specified when a particular </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">std::function</span></strong><span class="koboSpan" id="kobo.231.1"> object </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">is declared:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.233.1">
std::function&lt;int(long, double)&gt; f;</span></pre>
<p><span class="koboSpan" id="kobo.234.1">We have just declared a callable that can be invoked with two arguments, </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">long</span></strong><span class="koboSpan" id="kobo.236.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">double</span></strong><span class="koboSpan" id="kobo.238.1"> (or, to be more precise, with any two arguments convertible to </span><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">long</span></strong><span class="koboSpan" id="kobo.240.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.241.1">double</span></strong><span class="koboSpan" id="kobo.242.1">), and returns a result that can be converted to </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">int</span></strong><span class="koboSpan" id="kobo.244.1">. </span><span class="koboSpan" id="kobo.244.2">What does it do with the arguments and what is the result? </span><span class="koboSpan" id="kobo.244.3">That is determined by the concrete callable entity that is assigned </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">f</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.248.1">
// Example 04
std::function&lt;size_t(const std::string&amp;)&gt; f;
size_t f1(const std::string&amp; s) { return s.capacity(); }
f = f1;
std::cout &lt;&lt; f("abcde");    // 15
char c = 'b';
f = [=](const std::string&amp; s) { return s.find(c); };
std::cout &lt;&lt; f("abcde");    // 1
f = &amp;std::string::size;
std::cout &lt;&lt; f("abcde");    // 5</span></pre>
<p><span class="koboSpan" id="kobo.249.1">In this example, we first assign a non-member function </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">f1</span></strong><span class="koboSpan" id="kobo.251.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.252.1">f</span></strong><span class="koboSpan" id="kobo.253.1">; now calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">f(s)</span></strong><span class="koboSpan" id="kobo.255.1"> returns the capacity of the string </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">s</span></strong><span class="koboSpan" id="kobo.257.1"> since that’s what </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">f1</span></strong><span class="koboSpan" id="kobo.259.1"> does. </span><span class="koboSpan" id="kobo.259.2">Next, we change </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">f</span></strong><span class="koboSpan" id="kobo.261.1"> to contain a lambda expression; calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">f(s)</span></strong><span class="koboSpan" id="kobo.263.1"> now invokes that expression. </span><span class="koboSpan" id="kobo.263.2">The only thing these two functions </span><a id="_idIndexMarker268"/><span class="koboSpan" id="kobo.264.1">have in common is the interface: they accept the same arguments and have the same result types. </span><span class="koboSpan" id="kobo.264.2">Finally, we assign a member function pointer to </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">f</span></strong><span class="koboSpan" id="kobo.266.1">; while the function </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">std::string::size()</span></strong><span class="koboSpan" id="kobo.268.1"> takes no arguments, all member functions have an implicit first argument which is a reference to the object itself, so it fits the requirement on </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">the interface.</span></span></p>
<p><span class="koboSpan" id="kobo.270.1">We can now see type erasure in its more general form: it is an abstraction for many different implementations that all provide the same behavior. </span><span class="koboSpan" id="kobo.270.2">Let us consider what design capabilities </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">it opens.</span></span></p>
<h1 id="_idParaDest-104"><a id="_idTextAnchor286"/><span class="koboSpan" id="kobo.272.1">Type erasure as a design pattern</span></h1>
<p><span class="koboSpan" id="kobo.273.1">We have already seen how type erasure manifests itself in a program: the code expects certain </span><a id="_idIndexMarker269"/><span class="koboSpan" id="kobo.274.1">semantics behavior, but, instead of dealing with specific types that provide it, we use an abstraction and “erase” the properties of those types that are not relevant to the task at hand (starting with the name of </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">the type).</span></span></p>
<p><span class="koboSpan" id="kobo.276.1">In this way, type erasure has attributes of several other design patterns, but it’s not equivalent to any of them. </span><span class="koboSpan" id="kobo.276.2">It could reasonably be considered a design pattern in its own right. </span><span class="koboSpan" id="kobo.276.3">So, what does type erasure offer as a </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">design pattern?</span></span></p>
<p><span class="koboSpan" id="kobo.278.1">In type erasure, we find an abstract expression of certain behavior, such as a function call, that can be used to separate the interface from the implementation. </span><span class="koboSpan" id="kobo.278.2">So far, this sounds very similar to inheritance. </span><span class="koboSpan" id="kobo.278.3">Recall now how, at the end of the last section, we made a </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">std::function</span></strong><span class="koboSpan" id="kobo.280.1"> object invoke several completely different callables: a function, a lambda expression, and a member function. </span><span class="koboSpan" id="kobo.280.2">This illustrates the fundamental difference between type erasure and inheritance: with inheritance, the base class determines the abstract behavior (the interface), and any class that needs to implement that interface must be derived from the same base. </span><span class="koboSpan" id="kobo.280.3">With type erasure, there is no such requirement: the types that provide the common behavior do not have to form any particular hierarchy; in fact, they need not be classes </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">at all.</span></span></p>
<p><span class="koboSpan" id="kobo.282.1">It can be said that type erasure offers a non-intrusive way to separate the interface from the implementation. </span><span class="koboSpan" id="kobo.282.2">By “intrusive” we mean the fact that we must change a type in order to use the abstraction: for example, we may have a class that has the desired behavior, but, in order to be used polymorphically, it must also inherit from the common base class. </span><span class="koboSpan" id="kobo.282.3">This is the “intrusion” – the enforced change we must make to the otherwise perfectly good class in order to make it usable as a concrete implementation of a certain abstract interface. </span><span class="koboSpan" id="kobo.282.4">As we have just seen, type erasure has no such need. </span><span class="koboSpan" id="kobo.282.5">As long as the class (or any other type) has the desired behavior – usually, a way to invoke it in a function call-like manner with certain arguments – it can be used to implement this behavior. </span><span class="koboSpan" id="kobo.282.6">The other properties of the type are not relevant for supporting the interface we are focusing on and </span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">are “erased.”</span></span></p>
<p><span class="koboSpan" id="kobo.284.1">We can also say that type erasure provides “external polymorphism:” there is no unifying hierarchy required, and the set of types that can be used to implement a particular abstraction is extensible, not limited to just classes derived from a </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">common base.</span></span></p>
<p><span class="koboSpan" id="kobo.286.1">So, why doesn’t type erasure completely replace inheritance in C++? </span><span class="koboSpan" id="kobo.286.2">To some extent, it is tradition; don’t be too fast to kick tradition, though – the other name for tradition is “convention,” and conventional code is also familiar, easy-to-understand code. </span><span class="koboSpan" id="kobo.286.3">But there are two “real” reasons as well. </span><span class="koboSpan" id="kobo.286.4">The first one is performance. </span><span class="koboSpan" id="kobo.286.5">We will study the implementations of type erasure and their respective performance later in this chapter; however, without spoiling anything, we can say that high-performance implementations of type erasure became available only recently. </span><span class="koboSpan" id="kobo.286.6">The second one is convenience, and we can see that already. </span><span class="koboSpan" id="kobo.286.7">If we need to declare an abstraction for a whole set of related operations, we can declare a base class with the necessary virtual member functions. </span><span class="koboSpan" id="kobo.286.8">If we use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">std::function</span></strong><span class="koboSpan" id="kobo.288.1"> approach, a type-erased implementation would have to handle each of these operations separately. </span><span class="koboSpan" id="kobo.288.2">As we will see soon, this is not a requirement – we can implement a type-erased abstraction for a whole set of operations at once. </span><span class="koboSpan" id="kobo.288.3">However, doing it with inheritance is easier. </span><span class="koboSpan" id="kobo.288.4">Also, remember that all concrete types hiding behind the type erasure must provide the required behavior; if we require that all these types support several different member functions, it is more likely that they are going to be coming from the same hierarchy for </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">other reasons.</span></span></p>
<h2 id="_idParaDest-105"><a id="_idTextAnchor287"/><span class="koboSpan" id="kobo.290.1">Type erasure as an implementation technique</span></h2>
<p><span class="koboSpan" id="kobo.291.1">Not every use of type erasure has a grand design idea behind it. </span><span class="koboSpan" id="kobo.291.2">Often, type erasure is used purely </span><a id="_idIndexMarker270"/><span class="koboSpan" id="kobo.292.1">as an implementation technique (the same is true for inheritance, and we are about to see one such use). </span><span class="koboSpan" id="kobo.292.2">In particular, type erasure is a great tool for breaking dependencies between components of a </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">large system.</span></span></p>
<p><span class="koboSpan" id="kobo.294.1">Here is a simple example. </span><span class="koboSpan" id="kobo.294.2">We are building a large distributed software system, so one of our core components is the network </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">communication layer:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.296.1">
class Network {
  …
  void send(const char* data);
  void receive(const char* buffer);
  …
};</span></pre>
<p><span class="koboSpan" id="kobo.297.1">This is, of course, a very simplified and abstract view of a component that is, at best, non-trivial, but sending data across the network is not what we want to focus on now. </span><span class="koboSpan" id="kobo.297.2">The important point is that this is one of our foundational components, the rest of the system depends on it. </span><span class="koboSpan" id="kobo.297.3">We may have several different programs built as a part of our software solution; all of them include this </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">communication library.</span></span></p>
<p><span class="koboSpan" id="kobo.299.1">Now, in one specific application, we have a need to process the data packets before and after they are sent across the network; it could be a high-security system that requires advanced encryption, or it could be the only tool in our system that is designed to work over unreliable </span><a id="_idIndexMarker271"/><span class="koboSpan" id="kobo.300.1">networks and needs to insert error correction codes. </span><span class="koboSpan" id="kobo.300.2">The point is, the designer of the network layer is now asked to introduce a dependency on some external code that comes from a higher-level </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">application-specific component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.302.1">
class Network {
  …
  bool needs_processing;
  void send(const char* data) {
    if (needs_processing) apply_processing(buffer);
    …
  }
  …
};</span></pre>
<p><span class="koboSpan" id="kobo.303.1">While this code looks simple, it is a dependency nightmare: the low-level library now has to be built with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">apply_processing()</span></strong><span class="koboSpan" id="kobo.305.1"> function from the specific application. </span><span class="koboSpan" id="kobo.305.2">Even worse, all other programs that do not require this functionality must still be compiled and linked with this code, even if they never </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">set </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">needs_processing</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.309.1">While this problem can be handled the “old school” way – with some function pointers or (worse) global variables, type erasure offers an </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">elegant solution:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.311.1">
// Example 05
class Network {
  static const char* default_processor(const char* data) {
    std::cout &lt;&lt; "Default processing" &lt;&lt; std::endl;
    return data;
  }
  std::function&lt;const char*(const char*)&gt; processor =
    default_processor;
  void send(const char* data) {
    data = processor(data);
    …
  }
  public:
  template &lt;typename F&gt;
  void set_processor(F&amp;&amp; f) { processor = f; }
};</span></pre>
<p><span class="koboSpan" id="kobo.312.1">This is an example of the strategy design pattern, where the implementation of a particular behavior can be chosen at run-time. </span><span class="koboSpan" id="kobo.312.2">Now, any higher-level component of the system can specify its own processor function (or a lambda expression, or a callable object) without forcing the rest of the software to link with </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">their code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.314.1">
Network N;
N.set_processor([](const char* s){ char* c; …; return c; };</span></pre>
<p><span class="koboSpan" id="kobo.315.1">Now that we </span><a id="_idIndexMarker272"/><span class="koboSpan" id="kobo.316.1">know what type erasure looks like and how it can help decouple components, both as a design pattern and as a convenient implementation technique, there is only one more question left - how </span><a id="_idTextAnchor288"/><a id="_idTextAnchor289"/><span class="koboSpan" id="kobo.317.1">does </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">it work?</span></span></p>
<h1 id="_idParaDest-106"><a id="_idTextAnchor290"/><span class="koboSpan" id="kobo.319.1">How is type erasure implemented in C++?</span></h1>
<p><span class="koboSpan" id="kobo.320.1">We have seen </span><a id="_idIndexMarker273"/><span class="koboSpan" id="kobo.321.1">what type erasure looks like in C++. </span><span class="koboSpan" id="kobo.321.2">Now we </span><a id="_idIndexMarker274"/><span class="koboSpan" id="kobo.322.1">understand what it means for a program to not explicitly depend on a type. </span><span class="koboSpan" id="kobo.322.2">But the mystery remains—the program makes no mention </span><a id="_idIndexMarker275"/><span class="koboSpan" id="kobo.323.1">of the type, and yet, at the right time, invokes an </span><a id="_idIndexMarker276"/><span class="koboSpan" id="kobo.324.1">operation on </span><a id="_idTextAnchor291"/><span class="koboSpan" id="kobo.325.1">the type it knows nothing about. </span><span class="koboSpan" id="kobo.325.2">How? </span><span class="koboSpan" id="kobo.325.3">That is what we </span><a id="_idTextAnchor292"/><span class="koboSpan" id="kobo.326.1">are about </span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">to see.</span></span></p>
<h2 id="_idParaDest-107"><a id="_idTextAnchor293"/><span class="koboSpan" id="kobo.328.1">Very old type erasure</span></h2>
<p><span class="koboSpan" id="kobo.329.1">The idea of writing a </span><a id="_idIndexMarker277"/><span class="koboSpan" id="kobo.330.1">program without explicit type information is certainly not new. </span><span class="koboSpan" id="kobo.330.2">In fact, it predates object-oriented programming and the notion of objects by a long time. </span><span class="koboSpan" id="kobo.330.3">Consider this C program (no C++ here) as </span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.332.1">
// Example 06
int less(const void* a, const int* b) {
  return *(const int*)a - *(const int*)b;
}
int main() {
  int a[10] = { 1, 10, 2, 9, 3, 8, 4, 7, 5, 0 };
  qsort(a, 10, sizeof(int), less);
}</span></pre>
<p><span class="koboSpan" id="kobo.333.1">Now remember the function declaration for </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">qsort</span></strong><span class="koboSpan" id="kobo.335.1"> from the standard </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">C</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.337.1"> library:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.338.1">
void qsort(void *base, size_t nmemb, size_t size,
  int (*compare)(const void *, const void *));</span></pre>
<p><span class="koboSpan" id="kobo.339.1">Note that, while we are using it to sort an array of integers, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">qsort</span></strong><span class="koboSpan" id="kobo.341.1"> function itself does not have any explicit types—it uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">void*</span></strong><span class="koboSpan" id="kobo.343.1"> to pass in the array to be sorted. </span><span class="koboSpan" id="kobo.343.2">Similarly, the comparison function takes two </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">void*</span></strong><span class="koboSpan" id="kobo.345.1"> pointers and has no explicit type information in its declaration. </span><span class="koboSpan" id="kobo.345.2">Of course, at some point, we need to know how to compare the real types. </span><span class="koboSpan" id="kobo.345.3">In our C program, the pointers that could, in theory, point to anything, are </span><a id="_idIndexMarker278"/><span class="koboSpan" id="kobo.346.1">reinterpreted as pointers to integers. </span><span class="koboSpan" id="kobo.346.2">This action, which reverses the abstraction, is kn</span><a id="_idTextAnchor294"/><span class="koboSpan" id="kobo.347.1">own </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">as </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.349.1">reification</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.351.1">In C, restoring concrete types is entirely the responsibility of the programmer—our </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">less()</span></strong><span class="koboSpan" id="kobo.353.1"> comparison function does, in fact, only compare integers, but it is impossible to deduce so from the interface. </span><span class="koboSpan" id="kobo.353.2">Neither is it possible to validate, at runtime, that the correct types are used throughout the program, and it is certainly not possible for the program to automatically select the right comparison operation for the actual type </span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">at runtime.</span></span></p>
<p><span class="koboSpan" id="kobo.355.1">Nonetheless, this simple example lets us penetrate the magic of type erasure: the general code indeed does not depend on the concrete type that was erased, but that type is hidden in the code of a function called through the type-erased interface. </span><span class="koboSpan" id="kobo.355.2">In our example, it was the </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">comparison function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.357.1">
int less(const void* a, const int* b) {
  return *(const int*)a - *(const int*)b;
}</span></pre>
<p><span class="koboSpan" id="kobo.358.1">The calling code knows nothing about the type </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">int</span></strong><span class="koboSpan" id="kobo.360.1">, but the implementation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">less()</span></strong><span class="koboSpan" id="kobo.362.1"> operates on this type. </span><span class="koboSpan" id="kobo.362.2">The type is “hidden” in the code of a function invoked through the </span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">type-agnostic interface.</span></span></p>
<p><span class="koboSpan" id="kobo.364.1">The major downside of this C approach is that the programmer is wholly responsible for ensuring that all the pieces of the type-erased code are consistent; in our example, it is the sorted data and the comparison function that must refer to the </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">same type.</span></span></p>
<p><span class="koboSpan" id="kobo.366.1">In C++, we can do </span><a id="_idIndexMarker279"/><span class="koboSpan" id="kobo.367.1">a lot better, but the idea is still the same: the erased type is reified by the implementation of some type-specific code that is invoked through the type-agnostic interface. </span><span class="koboSpan" id="kobo.367.2">The key difference is that we are going to force the compiler to generate this code for us. </span><span class="koboSpan" id="kobo.367.3">There are, fundamentally, two techniques that can be used. </span><span class="koboSpan" id="kobo.367.4">The first one relies on run-time polymorphism (inheritance), and the second one uses template magic. </span><span class="koboSpan" id="kobo.367.5">Let us start with the </span><span class="No-Break"><span class="koboSpan" id="kobo.368.1">polymorphic implementation.</span></span></p>
<h2 id="_idParaDest-108"><a id="_idTextAnchor295"/><span class="koboSpan" id="kobo.369.1">Type erasure using inheritance</span></h2>
<p><span class="koboSpan" id="kobo.370.1">We’re now </span><a id="_idIndexMarker280"/><span class="koboSpan" id="kobo.371.1">going to see how </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">std::shared_ptr</span></strong><span class="koboSpan" id="kobo.373.1"> does its magic. </span><span class="koboSpan" id="kobo.373.2">We will do it with a simplified example of a smart pointer that focuses specifically on the type erasure aspect. </span><span class="koboSpan" id="kobo.373.3">It should not surprise you to learn that this is done with a combination of generic and </span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">object-oriented programming:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.375.1">
// Example 07
template &lt;typename T&gt; class smartptr {
  </span><a id="_idTextAnchor296"/><span class="koboSpan" id="kobo.376.1">struct destroy_base {
    virtual void operator()(void*) = 0;
    virtual ~deleter_base() {}
  };
  template &lt;typename Deleter&gt;
  struct destroy : public destroy _base {
    destroy (Deleter d) : d_(d) {}
    void operator()(void* p) override {
      d_(static_cast&lt;T*&gt;(p));
    }
    Deleter d_;
  };
  public:
  template &lt;typename Deleter&gt; smartptr(T* p, Deleter d) :
    p_(p), d_(new destroy&lt;Deleter&gt;(d)) {}
  ~smartptr() { (*d_)(p_); delete d_; }
  T* operator-&gt;() { return p_; }
  const T* operator-&gt;() const { return p_; }
  private:
  T* p_;
  destroy _base* d_;
};</span></pre>
<p><span class="koboSpan" id="kobo.377.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">smartptr</span></strong><span class="koboSpan" id="kobo.379.1"> template has only one type parameter. </span><span class="koboSpan" id="kobo.379.2">Since the erased type is not part of the smart </span><a id="_idIndexMarker281"/><span class="koboSpan" id="kobo.380.1">pointer’s type, it has to be captured in some other object. </span><span class="koboSpan" id="kobo.380.2">In our case, this object is an instantiation of the nested </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">smartptr&lt;T&gt;::destroy</span></strong><span class="koboSpan" id="kobo.382.1"> template. </span><span class="koboSpan" id="kobo.382.2">This object is created by the constructor, which is the last point in the code where the deleter type is explicitly present. </span><span class="koboSpan" id="kobo.382.3">But </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">smartptr</span></strong><span class="koboSpan" id="kobo.384.1"> must refer to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">destroy</span></strong><span class="koboSpan" id="kobo.386.1"> instance through a pointer whose type does not depend on </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">destroy</span></strong><span class="koboSpan" id="kobo.388.1"> (since the </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">smartptr</span></strong><span class="koboSpan" id="kobo.390.1"> object has the same type for all deleters). </span><span class="koboSpan" id="kobo.390.2">Therefore, all instances of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">destroy</span></strong><span class="koboSpan" id="kobo.392.1"> template inherit from the same base class, </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">destroy_base</span></strong><span class="koboSpan" id="kobo.394.1">, and the actual deleter is invoked through a virtual function. </span><span class="koboSpan" id="kobo.394.2">The constructor is a template that deduces the type of deleter, but the type is only hidden, as it’s part of the actual declaration of the specific instantiation of this template. </span><span class="koboSpan" id="kobo.394.3">The smart pointer class itself, and, in particular, its destructor, where the deleter is actually used, really have the deleter type erased. </span><span class="koboSpan" id="kobo.394.4">The compile-time type detection is used to create a correct-by-construction polymorphic object that will rediscover the deleter type at runtime and perform the correct action. </span><span class="koboSpan" id="kobo.394.5">For that reason, we do not need a dynamic cast, and can use the static cast instead, which only works if we know the real derived type (and </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">we do).</span></span></p>
<p><span class="koboSpan" id="kobo.396.1">The same technique can be used to implement </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">std::function</span></strong><span class="koboSpan" id="kobo.398.1"> and other type</span><a id="_idTextAnchor297"/><span class="koboSpan" id="kobo.399.1">-erased types, such as the ultimate type-erased class, </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">std::any</span></strong><span class="koboSpan" id="kobo.401.1"> (in C++17 and above). </span><span class="koboSpan" id="kobo.401.2">This is a class, not a template, but it can hold a value of </span><span class="No-Break"><span class="koboSpan" id="kobo.402.1">any type:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.403.1">
// Example 08
std::any a(5);
int i = std::any_cast&lt;int&gt;(a);    // i == 5
std::any_cast&lt;long&gt;(a);        // throws bad_any_cast</span></pre>
<p><span class="koboSpan" id="kobo.404.1">Of course, without knowing the type, </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">std::any</span></strong><span class="koboSpan" id="kobo.406.1"> cannot provide any interfaces. </span><span class="koboSpan" id="kobo.406.2">You can store any value in it, and get it back if you know the right type (or you can ask for the type and get back a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">std::type_info</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.408.1"> object).</span></span></p>
<p><span class="koboSpan" id="kobo.409.1">Before we learn the other (usually more efficient) way to implement type erasure, we have to address one glaringly obvious inefficiency in our design: every time we create or delete a shared pointer or a </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">std::function</span></strong><span class="koboSpan" id="kobo.411.1"> object that is implemented as described above, we must allocate and deallocate memory for the derived object that conceals the </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">erased type.</span></span></p>
<h2 id="_idParaDest-109"><a id="_idTextAnchor298"/><span class="koboSpan" id="kobo.413.1">Type erasure without memory allocation</span></h2>
<p><span class="koboSpan" id="kobo.414.1">There are, however, </span><a id="_idIndexMarker282"/><span class="koboSpan" id="kobo.415.1">ways to optimize the type-erased pointers (as well as any other type-erased data structures) and avoid the additional memory allocation that happens when we construct the polymorphic </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">smartptr::destroy</span></strong><span class="koboSpan" id="kobo.417.1"> object. </span><span class="koboSpan" id="kobo.417.2">We can avoid this allocation, at least sometimes, by pre-allocating a memory buffer for these objects. </span><span class="koboSpan" id="kobo.417.3">The details of this optimization, as well as its limitations, are discussed in </span><a href="B19262_10.xhtml#_idTextAnchor453"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.418.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.419.1">, </span><em class="italic"><span class="koboSpan" id="kobo.420.1">Local Buffer Optimization</span></em><span class="koboSpan" id="kobo.421.1">. </span><span class="koboSpan" id="kobo.421.2">Here is the gist of </span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">the optimization:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.423.1">
// Example 07
template &lt;typename T&gt; class smartptr {
  …
  public:
  template &lt;typename Deleter&gt; smartptr(T* p, Deleter d) :
    p_(p) {
    static_assert(sizeof(Deleter) &lt;= sizeof(buf_));
    ::new (static_cast&lt;void*&gt;(buf_)) destroy&lt;Deleter&gt;(d));
  }
  ~smartptr() {
    destroy_base* d = (destroy_base*)buf_;
    (*d)(p_);
    d-&gt;~destroy_base();
  }
  private:
  T* p_;
  alignas(8) char buf_[16];
};</span></pre>
<p><span class="koboSpan" id="kobo.424.1">The local buffer optimization does make type-erased pointers and functions a lot more efficient, as </span><a id="_idIndexMarker283"/><span class="koboSpan" id="kobo.425.1">we will see later in this chapter. </span><span class="koboSpan" id="kobo.425.2">Of course, it imposes restrictions on the size of the deleter; for this reason, most real-life implementations use a local buffer for small enough erased types and dynamic memory for types that don’t fit into the buffer. </span><span class="koboSpan" id="kobo.425.3">The alternative solution - to assert as shown above and force the programmer to increase the buffer – is often embraced in very </span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">high-performance applications.</span></span></p>
<p><span class="koboSpan" id="kobo.427.1">There are some subtler consequences of the use of this optimization: the deleter (or another erased object) is now stored as a part of the class and must be copied with the rest of the class. </span><span class="koboSpan" id="kobo.427.2">How do we copy an object whose type we no longer know? </span><span class="koboSpan" id="kobo.427.3">This and other details will have to wait until </span><a href="B19262_10.xhtml#_idTextAnchor453"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.428.1">Chapter 10</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.429.1">, Local Buffer Optimization</span></em><span class="koboSpan" id="kobo.430.1">. </span><span class="koboSpan" id="kobo.430.2">For now, we will use the local buffer optimization in the rest of the examples, both to show its use and to simplify </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">the code.</span></span></p>
<h2 id="_idParaDest-110"><a id="_idTextAnchor299"/><span class="koboSpan" id="kobo.432.1">Type erasure without inheritance</span></h2>
<p><span class="koboSpan" id="kobo.433.1">There is an </span><a id="_idIndexMarker284"/><span class="koboSpan" id="kobo.434.1">alternative implementation of type erasure that does not use an internal hierarchy of classes to store the erased type. </span><span class="koboSpan" id="kobo.434.2">Instead, the type is captured in the implementation of a function, just like it was done </span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">in C:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.436.1">
void erased_func(void* p) {
  TE* q = static_cast&lt;T*&gt;(p);
  … do work on type TE …
}</span></pre>
<p><span class="koboSpan" id="kobo.437.1">In C++, we make the function a template so the compiler generates instantiations for every type </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">TE</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.439.1">we need:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.440.1">
template &lt;typename TE&gt; void erased_func(void* p) {
  TE* q = static_cast&lt;T*&gt;(p);
  … do work on type TE …
}</span></pre>
<p><span class="koboSpan" id="kobo.441.1">This is a somewhat unusual template function: the type parameter cannot be deduced from the arguments and must be explicitly specified. </span><span class="koboSpan" id="kobo.441.2">We already know that this will be done in the constructor of a type-erased class, such as our smart pointer: there, we still know the type that is about to be erased. </span><span class="koboSpan" id="kobo.441.3">The other very important point is that any function generated by the preceding template can be invoked through the same </span><span class="No-Break"><span class="koboSpan" id="kobo.442.1">function pointer:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.443.1">
void(*)(void*) fp = erased_func&lt;int&gt;; // or any other type</span></pre>
<p><span class="koboSpan" id="kobo.444.1">Now we can see how the type erasure magic works: we have a function pointer whose type does not depend on the type </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">TE</span></strong><span class="koboSpan" id="kobo.446.1"> we are erasing. </span><span class="koboSpan" id="kobo.446.2">We are going to generate a function with an implementation that uses this type and assign it to this pointer. </span><span class="koboSpan" id="kobo.446.3">When we need to </span><a id="_idIndexMarker285"/><span class="koboSpan" id="kobo.447.1">use the erased type </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">TE</span></strong><span class="koboSpan" id="kobo.449.1">, such as deleting the object with the specified deleter, we are going to call a function through this pointer; we can do that without knowing what </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">TE</span></strong><span class="koboSpan" id="kobo.451.1"> is. </span><span class="koboSpan" id="kobo.451.2">We just have to put this all together into a correct-by-construction implementation, and here is our type-erased </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">smart pointer:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.453.1">
// Example 07
template &lt;typename T&gt;
class smartptr_te_static {
  T* p_;
  using destroy_t = void(*)(T*, void*);
  destroy_t destroy_;
  alignas(8) char buf_[8];
  template&lt;typename Deleter&gt;
  static void invoke_destroy(T* p, void* d) {
    (*static_cast&lt;Deleter*&gt;(d))(p);
  }
  public:
  template &lt;typename Deleter&gt;
  smartptr_te_static(T* p, Deleter d)
    : p_(p), destroy_(invoke_destroy&lt;Deleter&gt;)
  {
    static_assert(sizeof(Deleter) &lt;= sizeof(buf_));
    ::new (static_cast&lt;void*&gt;(buf_)) Deleter(d);
  }
  ~smartptr_te_static() {
    this-&gt;destroy_(p_, buf_);
  }
  T* operator-&gt;() { return p_; }
  const T* operator-&gt;() const { return p_; }
};</span></pre>
<p><span class="koboSpan" id="kobo.454.1">We store the user-given deleter in a small local buffer; in this example, we do not show the alternative implementation for a larger deleter that would require dynamic memory allocation. </span><span class="koboSpan" id="kobo.454.2">The function template that retains the information about the erased type is </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">invoke_destroy()</span></strong><span class="koboSpan" id="kobo.456.1">. </span><span class="koboSpan" id="kobo.456.2">Note that it is a static function; static functions can be invoked through a regular function pointer instead of a more cumbersome member </span><span class="No-Break"><span class="koboSpan" id="kobo.457.1">function pointer.</span></span></p>
<p><span class="koboSpan" id="kobo.458.1">In the constructor of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">smartptr</span></strong><span class="koboSpan" id="kobo.460.1"> class, we instantiate </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">invoke_destroy&lt;Deleter&gt;</span></strong><span class="koboSpan" id="kobo.462.1"> and assign it to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">destroy_</span></strong><span class="koboSpan" id="kobo.464.1"> function pointer. </span><span class="koboSpan" id="kobo.464.2">We also need a copy of the deleter object, since the deleter may contain a state (for example, a pointer to the allocator that provided the memory for the object owned by the smart pointer). </span><span class="koboSpan" id="kobo.464.3">We construct this deleter in the space provided by the local buffer </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">buf_</span></strong><span class="koboSpan" id="kobo.466.1">. </span><span class="koboSpan" id="kobo.466.2">At this point, the original </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">Deleter</span></strong><span class="koboSpan" id="kobo.468.1"> type is erased: all we have is a function pointer that does not depend on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">Deleter</span></strong><span class="koboSpan" id="kobo.470.1"> type and a </span><span class="No-Break"><span class="koboSpan" id="kobo.471.1">character array.</span></span></p>
<p><span class="koboSpan" id="kobo.472.1">When the time comes to destroy the object owned by the shared pointer, we need to invoke the </span><a id="_idIndexMarker286"/><span class="koboSpan" id="kobo.473.1">deleter. </span><span class="koboSpan" id="kobo.473.2">Instead, we invoke the function through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.474.1">destroy_</span></strong><span class="koboSpan" id="kobo.475.1"> pointer and pass to it the object to be destroyed and the buffer where the deleter resides. </span><span class="koboSpan" id="kobo.475.2">The erased </span><strong class="source-inline"><span class="koboSpan" id="kobo.476.1">Deleter</span></strong><span class="koboSpan" id="kobo.477.1"> type is nowhere to be seen, but it is hiding inside the specific implementation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">invoke_destroy()</span></strong><span class="koboSpan" id="kobo.479.1">. </span><span class="koboSpan" id="kobo.479.2">There, the pointer to the buffer is cast back to the type that is actually stored in the buffer (</span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">Deleter</span></strong><span class="koboSpan" id="kobo.481.1">) and the deleter </span><span class="No-Break"><span class="koboSpan" id="kobo.482.1">is invoked.</span></span></p>
<p><span class="koboSpan" id="kobo.483.1">This example is, perhaps, the most concise demonstration of type erasure machinery in C++. </span><span class="koboSpan" id="kobo.483.2">But it is not quite equivalent to the example in the previous section where we used inheritance. </span><span class="koboSpan" id="kobo.483.3">While we invoke the deleter on the object of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">T</span></strong><span class="koboSpan" id="kobo.485.1"> owned by the smart pointer, we do nothing to destroy the deleter object itself, specifically, the copy we stored inside the local buffer. </span><span class="koboSpan" id="kobo.485.2">The local buffer is not the problem here: if we dynamically allocated the memory instead, it would still be accessed through a generic pointer such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">char*</span></strong><span class="koboSpan" id="kobo.487.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">void*</span></strong><span class="koboSpan" id="kobo.489.1">, and we would now know how to properly delete it. </span><span class="koboSpan" id="kobo.489.2">For that, we need another function that can reify the original type. </span><span class="koboSpan" id="kobo.489.3">Well, maybe: trivially destructible deleters (and, in general, trivially destructible callable objects) are very common. </span><span class="koboSpan" id="kobo.489.4">All function pointers, member function pointers, stateless objects, and lambdas that do not capture any non-trivial objects by value are all trivially destructible. </span><span class="koboSpan" id="kobo.489.5">So we could simply add a static assert to our constructor and restrict our smart pointer to trivially destructible deleters, and, in reality, it would serve us fine in most cases. </span><span class="koboSpan" id="kobo.489.6">But I also want to show you a more </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">general solution.</span></span></p>
<p><span class="koboSpan" id="kobo.491.1">We can, of course, use another pointer to a static function that destroys the deleter and is instantiated with the right type in the constructor. </span><span class="koboSpan" id="kobo.491.2">But the destructor is not the end of what we need: in general, we also need to copy and move deleters, and maybe even compare them. </span><span class="koboSpan" id="kobo.491.3">That’s a lot </span><a id="_idIndexMarker287"/><span class="koboSpan" id="kobo.492.1">of function pointers making our </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">smartptr</span></strong><span class="koboSpan" id="kobo.494.1"> class bloated. </span><span class="koboSpan" id="kobo.494.2">By comparison, the inheritance-based implementation did everything with just the pointer to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">destroy</span></strong><span class="koboSpan" id="kobo.496.1"> object (stored as a pointer to the base class </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">destroy_base</span></strong><span class="koboSpan" id="kobo.498.1">). </span><span class="koboSpan" id="kobo.498.2">There is a way we can do the same. </span><span class="koboSpan" id="kobo.498.3">For this example, there is no good way to gradually reveal the magic, so we have to jump right in and follow up with a </span><span class="No-Break"><span class="koboSpan" id="kobo.499.1">line-by-line explanation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.500.1">
// Example 07
template &lt;typename T&gt;
class smartptr_te_vtable {
  T* p_;
  struct vtable_t {
    using destroy_t = void(*)(T*, void*);
    using destructor_t = void(*)(void*);
    destroy_t destroy_;
    destructor_t destructor_;
  };
  const vtable_t* vtable_ = nullptr;
  template &lt;typename Deleter&gt;
  constexpr static vtable_t vtable = {
    smartptr_te_vtable::template destroy&lt;Deleter&gt;,
    smartptr_te_vtable::template destructor&lt;Deleter&gt;
  };
  template &lt;typename Deleter&gt;
  static void destroy(T* p, void* d) {
    (*static_cast&lt;Deleter*&gt;(d))(p);
  }
  template &lt;typename Deleter&gt;
  static void destructor(void* d) {
    static_cast&lt;Deleter*&gt;(d)-&gt;~Deleter();
  }
  alignas(8) char buf_[8];
  public:
  template &lt;typename Deleter&gt;
  smartptr_te_vtable(T* p, Deleter d)
    : p_(p), vtable_(&amp;vtable&lt;Deleter&gt;)
  {
    static_assert(sizeof(Deleter) &lt;= sizeof(buf_));
    ::new (static_cast&lt;void*&gt;(buf_)) Deleter(d);
  }
  ~smartptr_te_vtable() {
    this-&gt;vtable_-&gt;destroy_(p_, buf_);
    this-&gt;vtable_-&gt;destructor_(buf_);
  }
  T* operator-&gt;() { return p_; }
  const T* operator-&gt;() const { return p_; }
};</span></pre>
<p><span class="koboSpan" id="kobo.501.1">Let us explain how this code works. </span><span class="koboSpan" id="kobo.501.2">First of all, we declare a </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">struct vtable_t</span></strong><span class="koboSpan" id="kobo.503.1"> that contains function pointers to every operation we need to implement on the erased </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">Deleter</span></strong><span class="koboSpan" id="kobo.505.1"> type. </span><span class="koboSpan" id="kobo.505.2">In our case, there are just two: invoke the deleter on an object to be destroyed and destroy the deleter itself. </span><span class="koboSpan" id="kobo.505.3">In general, we would have at least copy and move operations there as well (you will find such implementation in </span><a href="B19262_10.xhtml#_idTextAnchor453"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.506.1">Chapter 10</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.507.1">, Local Buffer Optimization</span></em><span class="koboSpan" id="kobo.508.1">). </span><span class="koboSpan" id="kobo.508.2">Next, we have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">vtable_</span></strong><span class="koboSpan" id="kobo.510.1"> pointer. </span><span class="koboSpan" id="kobo.510.2">After the object is constructed, it will point to an object of the type </span><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">vtable_t</span></strong><span class="koboSpan" id="kobo.512.1">. </span><span class="koboSpan" id="kobo.512.2">While this may suggest dynamic memory allocation ahead, we are going to do much better than that. </span><span class="koboSpan" id="kobo.512.3">Next is a variable template </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">vtable</span></strong><span class="koboSpan" id="kobo.514.1">; instantiating it on a concrete </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">Deleter</span></strong><span class="koboSpan" id="kobo.516.1"> type will create a static instance of a variable of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">vtable_t</span></strong><span class="koboSpan" id="kobo.518.1">. </span><span class="koboSpan" id="kobo.518.2">This is, perhaps, the most tricky part: usually, when we have a static data member of a class, it’s just a variable, and we can access it by name. </span><span class="koboSpan" id="kobo.518.3">But here is something different: the name </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">vtable</span></strong><span class="koboSpan" id="kobo.520.1"> can refer to many objects, all of the same type, </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">vtable_t</span></strong><span class="koboSpan" id="kobo.522.1">. </span><span class="koboSpan" id="kobo.522.2">None of them are explicitly created by us: we do not allocate memory for them, do not call </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">operator new</span></strong><span class="koboSpan" id="kobo.524.1"> to construct them. </span><span class="koboSpan" id="kobo.524.2">The compiler creates one of these objects </span><a id="_idIndexMarker288"/><span class="koboSpan" id="kobo.525.1">for every </span><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">Deleter</span></strong><span class="koboSpan" id="kobo.527.1"> type we use. </span><span class="koboSpan" id="kobo.527.2">For every smartptr object, the address of the specific </span><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">vtable</span></strong><span class="koboSpan" id="kobo.529.1"> object we want it to use is stored in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">vtable_</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.531.1"> pointer.</span></span></p>
<p><span class="koboSpan" id="kobo.532.1">An object of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">vtable_t</span></strong><span class="koboSpan" id="kobo.534.1"> contains pointers to static functions. </span><span class="koboSpan" id="kobo.534.2">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">vtable</span></strong><span class="koboSpan" id="kobo.536.1"> must do so as well: as you can see, we initialized the function pointers in </span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">vtable</span></strong><span class="koboSpan" id="kobo.538.1"> to point to instantiations of static member functions of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">smartptr</span></strong><span class="koboSpan" id="kobo.540.1"> class. </span><span class="koboSpan" id="kobo.540.2">These instantiations are for the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">Deleter</span></strong><span class="koboSpan" id="kobo.542.1"> type that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">vtable</span></strong><span class="koboSpan" id="kobo.544.1"> itself is </span><span class="No-Break"><span class="koboSpan" id="kobo.545.1">instantiated with.</span></span></p>
<p><span class="koboSpan" id="kobo.546.1">The name </span><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">vtable</span></strong><span class="koboSpan" id="kobo.548.1"> was not chosen lightly: we have indeed implemented a virtual table; the compiler builds a very similar structure with function pointers for every polymorphic hierarchy, and every virtual class has a virtual pointer that points to the table for its original type (the one it was </span><span class="No-Break"><span class="koboSpan" id="kobo.549.1">constructed with).</span></span></p>
<p><span class="koboSpan" id="kobo.550.1">After the </span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">vtable</span></strong><span class="koboSpan" id="kobo.552.1">, we have two static function templates. </span><span class="koboSpan" id="kobo.552.2">That is where the erased type is really hidden and later reified. </span><span class="koboSpan" id="kobo.552.3">As we have seen before, the function signatures do not depend on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.553.1">Deleter</span></strong><span class="koboSpan" id="kobo.554.1"> type, but their implementations do. </span><span class="koboSpan" id="kobo.554.2">Finally, we have the same buffer for storing deleter </span><span class="No-Break"><span class="koboSpan" id="kobo.555.1">objects locally.</span></span></p>
<p><span class="koboSpan" id="kobo.556.1">As before, the constructor ties everything together; this must be so since the constructor is the only place in this code where the </span><strong class="source-inline"><span class="koboSpan" id="kobo.557.1">Deleter</span></strong><span class="koboSpan" id="kobo.558.1"> type is explicitly known. </span><span class="koboSpan" id="kobo.558.2">Our constructor does three things: first, it stores the pointer to the object, as any other smart pointer does. </span><span class="koboSpan" id="kobo.558.3">Second, it points the </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">vtable_</span></strong><span class="koboSpan" id="kobo.560.1"> pointer to an instance of the static </span><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">vtable</span></strong><span class="koboSpan" id="kobo.562.1"> variable for the right </span><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">Deleter</span></strong><span class="koboSpan" id="kobo.564.1"> type. </span><span class="koboSpan" id="kobo.564.2">Finally, it constructs a copy of the deleter in the local buffer. </span><span class="koboSpan" id="kobo.564.3">At this point, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">Deleter</span></strong><span class="koboSpan" id="kobo.566.1"> type is erased: nothing in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">smartptr</span></strong><span class="koboSpan" id="kobo.568.1"> object explicitly depends </span><span class="No-Break"><span class="koboSpan" id="kobo.569.1">on it.</span></span></p>
<p><span class="koboSpan" id="kobo.570.1">The deleter, and its true type, come into play again when the destructor of the smart pointer is called and we need to destroy the owned object and the deleter itself. </span><span class="koboSpan" id="kobo.570.2">Each of these actions is done by means of an indirect function call. </span><span class="koboSpan" id="kobo.570.3">The functions to call are stored in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">*vtable_</span></strong><span class="koboSpan" id="kobo.572.1"> object (just like for polymorphic classes, the correct virtual function overrides are found in the virtual table of function pointers). </span><span class="koboSpan" id="kobo.572.2">The deleter is passed into these functions using the address of the buffer – no type information there. </span><span class="koboSpan" id="kobo.572.3">But the functions were generated for the specific </span><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">Deleter</span></strong><span class="koboSpan" id="kobo.574.1"> type, so they cast the </span><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">void*</span></strong><span class="koboSpan" id="kobo.576.1"> buffer address to the right type and use the deleter that was stored in </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">the buffer.</span></span></p>
<p><span class="koboSpan" id="kobo.578.1">This implementation allows us to have multiple type-erased operations while storing just one </span><strong class="source-inline"><span class="koboSpan" id="kobo.579.1">vtable_</span></strong><span class="koboSpan" id="kobo.580.1"> pointer in the </span><span class="No-Break"><span class="koboSpan" id="kobo.581.1">object itself.</span></span></p>
<p><span class="koboSpan" id="kobo.582.1">We can also combine the two approaches: invoke some operations through a virtual table and have </span><a id="_idIndexMarker289"/><span class="koboSpan" id="kobo.583.1">dedicated function pointers for others. </span><span class="koboSpan" id="kobo.583.2">Why? </span><span class="koboSpan" id="kobo.583.3">Performance, possibly: invoking a function through a virtual table may be a little slower. </span><span class="koboSpan" id="kobo.583.4">This needs to be measured for any </span><span class="No-Break"><span class="koboSpan" id="kobo.584.1">specific application.</span></span></p>
<p><span class="koboSpan" id="kobo.585.1">So far, we used type erasure to provide abstract interfaces for very specific behaviors. </span><span class="koboSpan" id="kobo.585.2">We already know that type erasure does not need to be so restricted – we have seen the example of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.586.1">std::function</span></strong><span class="koboSpan" id="kobo.587.1">. </span><span class="koboSpan" id="kobo.587.2">The last example in this section will be our own generic </span><span class="No-Break"><span class="koboSpan" id="kobo.588.1">type-erased function.</span></span></p>
<h2 id="_idParaDest-111"><a id="_idTextAnchor300"/><span class="koboSpan" id="kobo.589.1">Efficient type erasure</span></h2>
<p><span class="koboSpan" id="kobo.590.1">After the examples </span><a id="_idIndexMarker290"/><span class="koboSpan" id="kobo.591.1">and explanations of the last section, a type-erased function is not going to be much of a challenge. </span><span class="koboSpan" id="kobo.591.2">Nonetheless, there is value in showing it here. </span><span class="koboSpan" id="kobo.591.3">We are going to demonstrate a very efficient implementation of type erasure (the implementation you find in this book was inspired by the works of Arthur O’Dwyer and </span><span class="No-Break"><span class="koboSpan" id="kobo.592.1">Eduardo Magrid).</span></span></p>
<p><span class="koboSpan" id="kobo.593.1">The template for a generic function looks </span><span class="No-Break"><span class="koboSpan" id="kobo.594.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.595.1">
template&lt;typename Signature&gt; class Function;</span></pre>
<p><span class="koboSpan" id="kobo.596.1">Here </span><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">Signature</span></strong><span class="koboSpan" id="kobo.598.1"> is something like </span><strong class="source-inline"><span class="koboSpan" id="kobo.599.1">int(std::string)</span></strong><span class="koboSpan" id="kobo.600.1"> for a function that takes a string and returns an integer. </span><span class="koboSpan" id="kobo.600.2">This function can be constructed to invoke any </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">Callable</span></strong><span class="koboSpan" id="kobo.602.1"> type as long as an object of this type can be invoked like a function with the </span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">specified signature.</span></span></p>
<p><span class="koboSpan" id="kobo.604.1">We are going to use a local buffer again, but instead of hard-coding it into the class, we will add template parameters to control buffer size </span><span class="No-Break"><span class="koboSpan" id="kobo.605.1">and alignment:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.606.1">
template&lt;typename Signature, size_t Size = 16,
         size_t Alignment = 8&gt; struct Function;</span></pre>
<p><span class="koboSpan" id="kobo.607.1">For ease of coding, it is convenient to unpack the function signature into the argument types </span><strong class="source-inline"><span class="koboSpan" id="kobo.608.1">Args…</span></strong><span class="koboSpan" id="kobo.609.1"> and the return type </span><strong class="source-inline"><span class="koboSpan" id="kobo.610.1">Res</span></strong><span class="koboSpan" id="kobo.611.1">. </span><span class="koboSpan" id="kobo.611.2">The easiest way to do so is with a class </span><span class="No-Break"><span class="koboSpan" id="kobo.612.1">template specialization:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.613.1">
// Example 09
template&lt;typename Signature, size_t Size = 16,
         size_t Alignment = 8&gt; struct Function;
template&lt;size_t Size, size_t Alignment,
         typename Res, typename... </span><span class="koboSpan" id="kobo.613.2">Args&gt;
struct Function&lt;Res(Args...), Size, Alignment&gt; {…};</span></pre>
<p><span class="koboSpan" id="kobo.614.1">Now all that is left is the small matter of the implementation. </span><span class="koboSpan" id="kobo.614.2">First, we need the buffer to store the </span><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">Callable</span></strong><span class="koboSpan" id="kobo.616.1"> object </span><span class="No-Break"><span class="koboSpan" id="kobo.617.1">in it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.618.1">
// Example 09
alignas(Alignment) char space_[Size];</span></pre>
<p><span class="koboSpan" id="kobo.619.1">Second, we need </span><a id="_idIndexMarker291"/><span class="koboSpan" id="kobo.620.1">a function pointer </span><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">executor_</span></strong><span class="koboSpan" id="kobo.622.1"> to store the address of the static function </span><strong class="source-inline"><span class="koboSpan" id="kobo.623.1">executor</span></strong><span class="koboSpan" id="kobo.624.1"> generated from a template with the type of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">Callable</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.626.1"> object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.627.1">
// Example 09
using executor_t = Res(*)(Args..., void*);
executor_t executor_;
template&lt;typename Callable&gt;
static Res executor(Args... </span><span class="koboSpan" id="kobo.627.2">args, void* this_function) {
  return (*reinterpret_cast&lt;Callable*&gt;(
    static_cast&lt;Function*&gt;(this_function)-&gt;space_))
  (std::forward&lt;Args&gt;(args)...);
}</span></pre>
<p><span class="koboSpan" id="kobo.628.1">Next, in the constructor we must initialize the executor and store the callable in </span><span class="No-Break"><span class="koboSpan" id="kobo.629.1">the buffer:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.630.1">
// Example 09
template &lt;typename CallableArg,
          typename Callable = std::decay_t&lt;CallableArg&gt;&gt;
  requires(!std::same_as&lt;Function, Callable&gt;)
Function(CallableArg&amp;&amp; callable) :
  executor_(executor&lt;Callable&gt;)
{
  ::new (static_cast&lt;void*&gt;(space_))
    Callable(std::forward&lt;CallableArg&gt;(callable));
}</span></pre>
<p><span class="koboSpan" id="kobo.631.1">The constructor has two subtle details. </span><span class="koboSpan" id="kobo.631.2">The first is the treatment of the type of the callable: we deduce it as </span><strong class="source-inline"><span class="koboSpan" id="kobo.632.1">CallableArg</span></strong><span class="koboSpan" id="kobo.633.1"> but then use it as </span><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">Callable</span></strong><span class="koboSpan" id="kobo.635.1">. </span><span class="koboSpan" id="kobo.635.2">This is because </span><strong class="source-inline"><span class="koboSpan" id="kobo.636.1">CallableArg</span></strong><span class="koboSpan" id="kobo.637.1"> may be a reference to the type of the callable, such as the function pointer, and we don’t want to construct a copy of a reference. </span><span class="koboSpan" id="kobo.637.2">The second is the concept restriction: the </span><strong class="source-inline"><span class="koboSpan" id="kobo.638.1">Function</span></strong><span class="koboSpan" id="kobo.639.1"> itself is a callable object with the same signature, but we do not </span><a id="_idIndexMarker292"/><span class="koboSpan" id="kobo.640.1">want this constructor to apply in such a case – that is the job of the copy constructor. </span><span class="koboSpan" id="kobo.640.2">If you don’t use C++20, you have to use SFINAE to achieve the same effect (see </span><a href="B19262_07.xhtml#_idTextAnchor314"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.641.1">Chapter 7</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.642.1">, SFINAE, Concepts, and Overload Resolution Management,</span></em><span class="koboSpan" id="kobo.643.1"> for details). </span><span class="koboSpan" id="kobo.643.2">If you like the concept style, you can emulate it to </span><span class="No-Break"><span class="koboSpan" id="kobo.644.1">some degree:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.645.1">
#define REQUIRES(...) \
  std::enable_if_t&lt;__VA_ARGS__, int&gt; = 0
template &lt;typename CallableArg,
          typename Callable = std::decay_t&lt;CallableArg&gt;,
          REQUIRES(!std::is_same_v&lt;Function, Callable&gt;)&gt;)
Function(CallableArg&amp;&amp; callable) …</span></pre>
<p><span class="koboSpan" id="kobo.646.1">Speaking of copying, our </span><strong class="source-inline"><span class="koboSpan" id="kobo.647.1">Function</span></strong><span class="koboSpan" id="kobo.648.1"> is correct only for trivially copyable and trivially destructible </span><strong class="source-inline"><span class="koboSpan" id="kobo.649.1">Callable</span></strong><span class="koboSpan" id="kobo.650.1"> types since we did not provide any means to destroy or copy the callable objects stored in the buffer. </span><span class="koboSpan" id="kobo.650.2">This still covers a lot of ground, but we can handle non-trivial callables as well using the vtable approach (you will find an example in </span><a href="B19262_10.xhtml#_idTextAnchor453"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.651.1">Chapter 10</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.652.1">, Local </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.653.1">Buffer Optimization</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.654.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.655.1">There is one more detail we need to take care of right now: </span><strong class="source-inline"><span class="koboSpan" id="kobo.656.1">std::function</span></strong><span class="koboSpan" id="kobo.657.1"> can be default-constructed without any callable; calling such a “null” function throws a </span><strong class="source-inline"><span class="koboSpan" id="kobo.658.1">std::bad_function_call</span></strong><span class="koboSpan" id="kobo.659.1"> exception. </span><span class="koboSpan" id="kobo.659.2">We can do this too if we initialize the executor to a pre-defined function that does nothing except throw </span><span class="No-Break"><span class="koboSpan" id="kobo.660.1">this exception:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.661.1">
// Example 09
static constexpr Res default_executor(Args..., void*) {
  throw std::bad_function_call();
}
constexpr static executor_t default_executor_ =
  default_executor;
executor_t executor_ = default_executor_;</span></pre>
<p><span class="koboSpan" id="kobo.662.1">Now we have a generic function that is very similar to </span><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">std::function</span></strong><span class="koboSpan" id="kobo.664.1"> (or would have been if we </span><a id="_idIndexMarker293"/><span class="koboSpan" id="kobo.665.1">added support for calling member functions, copy and move semantics, and the few missing member functions). </span><span class="koboSpan" id="kobo.665.2">It does work the </span><span class="No-Break"><span class="koboSpan" id="kobo.666.1">same way:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.667.1">
Function&lt;int(int, int, int, int)&gt; f =
  [](int a, int b, int c, int d) { return a + b + c + d; };
int res = f(1, 2, 3, 4);</span></pre>
<p><span class="koboSpan" id="kobo.668.1">And just what did that convenience cost us? </span><span class="koboSpan" id="kobo.668.2">All performance should be measured, but we can also get some idea by examining the machine code generated by the compiler when it has to call a type-erased function. </span><span class="koboSpan" id="kobo.668.3">Here is what it takes to invoke </span><strong class="source-inline"><span class="koboSpan" id="kobo.669.1">std::function</span></strong><span class="koboSpan" id="kobo.670.1"> with </span><a id="_idIndexMarker294"/><span class="koboSpan" id="kobo.671.1">the same signature as we </span><span class="No-Break"><span class="koboSpan" id="kobo.672.1">just used:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.673.1">
// Example 09
using Signature = int(int, int, int, int);
using SF = std::function&lt;Signature&gt;;
auto invoke_sf(int a, int b, int c, int d, const SF&amp; f) {
  return f(a, b, c, d);
}</span></pre>
<p><span class="koboSpan" id="kobo.674.1">The compiler (GCC-11 with O3) turns this code </span><span class="No-Break"><span class="koboSpan" id="kobo.675.1">into this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.676.1">
endbr64
sub    $0x28,%rsp
mov    %r8,%rax
mov    %fs:0x28,%r8
mov    %r8,0x18(%rsp)
xor    %r8d,%r8d
cmpq   $0x0,0x10(%rax)
mov    %edi,0x8(%rsp)
mov    %esi,0xc(%rsp)
mov    %edx,0x10(%rsp)
mov    %ecx,0x14(%rsp)
je     62 &lt;_Z9invoke_sfiiiiRKSt8functionIFiiiiiEE+0x62&gt;
lea    0xc(%rsp),%rdx
lea    0x10(%rsp),%rcx
mov    %rax,%rdi
lea    0x8(%rsp),%rsi
lea    0x14(%rsp),%r8
callq  *0x18(%rax)
mov    0x18(%rsp),%rdx
sub    %fs:0x28,%rdx
jne    67 &lt;_Z9invoke_sfiiiiRKSt8functionIFiiiiiEE+0x67&gt;
add    $0x28,%rsp
retq
callq  67 &lt;_Z9invoke_sfiiiiRKSt8functionIFiiiiiEE+0x67&gt;
callq  6c &lt;_Z9invoke_sfiiiiRKSt8functionIFiiiiiEE+0x6c&gt;</span></pre>
<p><span class="koboSpan" id="kobo.677.1">Now </span><span class="No-Break"><span class="koboSpan" id="kobo.678.1">our function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.679.1">
// Example 09
using F = Function&lt;Signature&gt;;
auto invoke_f(int a, int b, int c, int d, const F&amp; f) {
  return f(a, b, c, d);
}</span></pre>
<p><span class="koboSpan" id="kobo.680.1">This time, the compiler can do </span><span class="No-Break"><span class="koboSpan" id="kobo.681.1">much better:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.682.1">
endbr64
jmpq   *0x10(%r8)</span></pre>
<p><span class="koboSpan" id="kobo.683.1">What we see here is the so-called tail call: the compiler simply redirects the execution to the actual callable that needs to be invoked. </span><span class="koboSpan" id="kobo.683.2">You might ask, doesn’t it always? </span><span class="koboSpan" id="kobo.683.3">Not usually: most </span><a id="_idIndexMarker295"/><span class="koboSpan" id="kobo.684.1">function calls are implemented with </span><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">call</span></strong><span class="koboSpan" id="kobo.686.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">ret</span></strong><span class="koboSpan" id="kobo.688.1"> instructions. </span><span class="koboSpan" id="kobo.688.2">To call a function, its arguments must be stored in a predefined location, then the return address is pushed onto the stack and the execution is transferred to the function entry point by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.689.1">call</span></strong><span class="koboSpan" id="kobo.690.1"> instruction. </span><span class="koboSpan" id="kobo.690.2">The return instruction </span><strong class="source-inline"><span class="koboSpan" id="kobo.691.1">ret</span></strong><span class="koboSpan" id="kobo.692.1"> takes the address off the stack and transfers execution to it. </span><span class="koboSpan" id="kobo.692.2">The beauty of the tail call is this: while we want the call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">Function</span></strong><span class="koboSpan" id="kobo.694.1"> to call the original callable in the end, we don’t need the execution to return to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">Function</span></strong><span class="koboSpan" id="kobo.696.1"> object. </span><span class="koboSpan" id="kobo.696.2">If there is nothing to do in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">Function</span></strong><span class="koboSpan" id="kobo.698.1"> executor except to return the control to the caller, we might as well simply leave the original return address as-is and have the callable return the control to the right place without an additional indirection. </span><span class="koboSpan" id="kobo.698.2">Of course, this assumes that the executor has nothing to do after </span><span class="No-Break"><span class="koboSpan" id="kobo.699.1">the call.</span></span></p>
<p><span class="koboSpan" id="kobo.700.1">There are two key optimizations in our code that enable this compact implementation. </span><span class="koboSpan" id="kobo.700.2">The first one is the way we handle the null function: most implementations of </span><strong class="source-inline"><span class="koboSpan" id="kobo.701.1">std::function</span></strong><span class="koboSpan" id="kobo.702.1"> initialize the executor to </span><strong class="source-inline"><span class="koboSpan" id="kobo.703.1">nullptr</span></strong><span class="koboSpan" id="kobo.704.1"> and do a pointer comparison on every call. </span><span class="koboSpan" id="kobo.704.2">We did no such comparison; we always invoke the executor. </span><span class="koboSpan" id="kobo.704.3">But then, our executor is never null: unless otherwise initialized, it points to the </span><span class="No-Break"><span class="koboSpan" id="kobo.705.1">default executor.</span></span></p>
<p><span class="koboSpan" id="kobo.706.1">The second optimization is more subtle. </span><span class="koboSpan" id="kobo.706.2">You might have noticed that the executor has one more argument than the callable: to call a function with the signature </span><strong class="source-inline"><span class="koboSpan" id="kobo.707.1">int(int, int)</span></strong><span class="koboSpan" id="kobo.708.1"> our executor needs the two original function arguments (of course) and the pointer to the callable object (stored in the local buffer in our case). </span><span class="koboSpan" id="kobo.708.2">So our executor’s signature is </span><strong class="source-inline"><span class="koboSpan" id="kobo.709.1">int(int, int, void*)</span></strong><span class="koboSpan" id="kobo.710.1">. </span><span class="koboSpan" id="kobo.710.2">Why not pass the object first? </span><span class="koboSpan" id="kobo.710.3">That’s what the </span><strong class="source-inline"><span class="koboSpan" id="kobo.711.1">std::function</span></strong><span class="koboSpan" id="kobo.712.1"> does (at least the one whose assembly we have just seen). </span><span class="koboSpan" id="kobo.712.2">The problem is that the original function arguments are also sitting on the stack. </span><span class="koboSpan" id="kobo.712.3">Adding one more argument at the end of the stack is easy. </span><span class="koboSpan" id="kobo.712.4">But to insert the new first argument, we have to shift all the existing </span><a id="_idIndexMarker296"/><span class="koboSpan" id="kobo.713.1">arguments by one (this is why the code generated for </span><strong class="source-inline"><span class="koboSpan" id="kobo.714.1">std::function</span></strong><span class="koboSpan" id="kobo.715.1"> becomes longer the more arguments </span><span class="No-Break"><span class="koboSpan" id="kobo.716.1">you have).</span></span></p>
<p><span class="koboSpan" id="kobo.717.1">As convincing as it sounds, any speculations about performance are hardly worth the electrons expanded to have them written down. </span><span class="koboSpan" id="kobo.717.2">Performance must always be measured, and this is the last task left for us to do in </span><span class="No-Break"><span class="koboSpan" id="kobo.718.1">this chapter.</span></span></p>
<h1 id="_idParaDest-112"><a id="_idTextAnchor301"/><span class="koboSpan" id="kobo.719.1">Performance of type erasure</span></h1>
<p><span class="koboSpan" id="kobo.720.1">We are going to measure the performance of a type-erased generic function and a type-erased smart pointer deleter. </span><span class="koboSpan" id="kobo.720.2">First, we need the right tools; in thi</span><a id="_idTextAnchor302"/><span class="koboSpan" id="kobo.721.1">s case, a </span><span class="No-Break"><span class="koboSpan" id="kobo.722.1">micro-benchmarking library.</span></span></p>
<h2 id="_idParaDest-113"><a id="_idTextAnchor303"/><span class="koboSpan" id="kobo.723.1">Installing the micro-benchmark library</span></h2>
<p><span class="koboSpan" id="kobo.724.1">In our case, we are interested in the efficiency of very small fragments of code that construct and </span><a id="_idIndexMarker297"/><span class="koboSpan" id="kobo.725.1">delete objects </span><a id="_idIndexMarker298"/><span class="koboSpan" id="kobo.726.1">using different kinds of smart pointers. </span><span class="koboSpan" id="kobo.726.2">The appropriate tool for measuring the performance of small fragments of code is a micro-benchmark. </span><span class="koboSpan" id="kobo.726.3">There are many micro-benchmark libraries and tools out there; in this book, we will use the Google Benchmark library. </span><span class="koboSpan" id="kobo.726.4">To follow along with the examples in this section, you must first download and install the library (to do this, follow the instructions in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.727.1">Readme.md</span></strong><span class="koboSpan" id="kobo.728.1"> file). </span><span class="koboSpan" id="kobo.728.2">Then you can compile and run the examples. </span><span class="koboSpan" id="kobo.728.3">You can build the sample files included with the library to see how to build a benchmark on your particular system. </span><span class="koboSpan" id="kobo.728.4">For example, on a Linux machine, the command to build and run a </span><strong class="source-inline"><span class="koboSpan" id="kobo.729.1">smartptr.C</span></strong><span class="koboSpan" id="kobo.730.1"> benchmark program might look something </span><span class="No-Break"><span class="koboSpan" id="kobo.731.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.732.1">
$CXX smartptr.C smartptr_ext.C -o smartptr -g –O3 \
  -I. </span><span class="koboSpan" id="kobo.732.2">-I$GBENCH_DIR/include \
  -Wall -Wextra -Werror -pedantic --std=c++20 \
  $GBENCH_DIR/lib/libbenchmark.a -lpthread -lrt -lm &amp;&amp; \
./smartptr</span></pre>
<p><span class="koboSpan" id="kobo.733.1">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.734.1">$CXX</span></strong><span class="koboSpan" id="kobo.735.1"> is </span><a id="_idIndexMarker299"/><span class="koboSpan" id="kobo.736.1">your C++ compiler, such </span><a id="_idIndexMarker300"/><span class="koboSpan" id="kobo.737.1">as </span><strong class="source-inline"><span class="koboSpan" id="kobo.738.1">clang++</span></strong><span class="koboSpan" id="kobo.739.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.740.1">g++-11</span></strong><span class="koboSpan" id="kobo.741.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.742.1">$GBENCH_DIR</span></strong><span class="koboSpan" id="kobo.743.1"> is the di</span><a id="_idTextAnchor304"/><a id="_idTextAnchor305"/><a id="_idTextAnchor306"/><span class="koboSpan" id="kobo.744.1">rectory where the benchmark </span><span class="No-Break"><span class="koboSpan" id="kobo.745.1">is installed.</span></span></p>
<h2 id="_idParaDest-114"><a id="_idTextAnchor307"/><span class="koboSpan" id="kobo.746.1">The overhead of type erasure</span></h2>
<p><span class="koboSpan" id="kobo.747.1">Every benchmark needs a baseline. </span><span class="koboSpan" id="kobo.747.2">In our case, the baseline is a raw pointer. </span><span class="koboSpan" id="kobo.747.3">We can reasonably </span><a id="_idIndexMarker301"/><span class="koboSpan" id="kobo.748.1">assume that no smart pointer will be able to outperform a raw pointer, and the best smart pointer will have zero overhead. </span><span class="koboSpan" id="kobo.748.2">Thus, we begin by measuring how long it takes to construct and destroy a small object using a </span><span class="No-Break"><span class="koboSpan" id="kobo.749.1">raw pointer:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.750.1">
// Example 07
struct deleter {
  template &lt;typename T&gt; void operator()(T* p) { delete p; }
};
deleter d;
void BM_rawptr(benchmark::State&amp; state) {
  for (auto _ : state) {
    int* p = new int(0);
    d(p);
  }
  state.SetItemsProcessed(state.iterations());
}</span></pre>
<p><span class="koboSpan" id="kobo.751.1">A good optimizing compiler can do a great deal of damage to a microbenchmark like this by optimizing the “unnecessary” work (which is, really, all the work done by this program). </span><span class="koboSpan" id="kobo.751.2">We can prevent such optimizations by moving the allocation into a different </span><span class="No-Break"><span class="koboSpan" id="kobo.752.1">compilation unit:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.753.1">
// 07_smartptr.C:
void BM_rawptr(benchmark::State&amp; state) {
  for (auto _ : state) {
    int* p = get_raw_ptr()
    d(p);
  }
  state.SetItemsProcessed(state.iterations());
}
// 07_smartptr_ext.C:
int* get_raw_ptr() { return new int(0); }</span></pre>
<p><span class="koboSpan" id="kobo.754.1">If you have a compiler that can do whole program optimizations, turn them off for this benchmark. </span><span class="koboSpan" id="kobo.754.2">But don’t turn off the optimization of each file: we want to profile the optimized </span><a id="_idIndexMarker302"/><span class="koboSpan" id="kobo.755.1">code since that’s what the real program </span><span class="No-Break"><span class="koboSpan" id="kobo.756.1">will use.</span></span></p>
<p><span class="koboSpan" id="kobo.757.1">The actual numbers reported by the benchmark depend, of course, on the machine that it runs on. </span><span class="koboSpan" id="kobo.757.2">But we are interested in the relative changes, so any machine will do, as long as we stay with it for </span><span class="No-Break"><span class="koboSpan" id="kobo.758.1">all measurements:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.759.1">
Benchmark                      Time
BM_rawptr                   8.72 ns</span></pre>
<p><span class="koboSpan" id="kobo.760.1">We can now verify that </span><strong class="source-inline"><span class="koboSpan" id="kobo.761.1">std::unique_ptr</span></strong><span class="koboSpan" id="kobo.762.1"> indeed has zero overhead (as long as we construct and delete objects the same way, </span><span class="No-Break"><span class="koboSpan" id="kobo.763.1">of course):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.764.1">
// smartptr.C
void BM_uniqueptr(benchmark::State&amp; state) {
  for (auto _ : state) {
    auto p(get_unique_ptr());
  }
  state.SetItemsProcessed(state.iterations());
}
// smartptr_ext.C
auto get_unique_ptr() {
  return std::unique_ptr&lt;int, deleter&gt;(new int(0), d);
}</span></pre>
<p><span class="koboSpan" id="kobo.765.1">The result is within the measurement noise from the raw pointer, as can be </span><span class="No-Break"><span class="koboSpan" id="kobo.766.1">seen here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.767.1">
Benchmark                    </span><a id="_idTextAnchor308"/><span class="koboSpan" id="kobo.768.1">  Time
BM_uniqueptr                8.82 ns</span></pre>
<p><span class="koboSpan" id="kobo.769.1">We can similarly measure the performance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.770.1">std::shared_ptr</span></strong><span class="koboSpan" id="kobo.771.1"> as well as different versions of our own </span><span class="No-Break"><span class="koboSpan" id="kobo.772.1">smart pointer:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.773.1">
Benchmark                      Time
BM_sharedptr                22.9 ns
BM_make_sharedptr           17.5 ns
BM_smartptr_te              19.5 ns</span></pre>
<p><span class="koboSpan" id="kobo.774.1">The first line, </span><strong class="source-inline"><span class="koboSpan" id="kobo.775.1">BM_sharedptr</span></strong><span class="koboSpan" id="kobo.776.1">, constructs and deletes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.777.1">std::shared_ptr&lt;int&gt;</span></strong><span class="koboSpan" id="kobo.778.1"> with our </span><a id="_idIndexMarker303"/><span class="koboSpan" id="kobo.779.1">custom deleter. </span><span class="koboSpan" id="kobo.779.2">The shared pointer is much more expensive than the unique pointer. </span><span class="koboSpan" id="kobo.779.3">Of course, there is more than one reason for that—</span><strong class="source-inline"><span class="koboSpan" id="kobo.780.1">std::shared_ptr</span></strong><span class="koboSpan" id="kobo.781.1"> is a reference-counting smart pointer, and maintaining a reference count has its own overhead. </span><span class="koboSpan" id="kobo.781.2">Using </span><strong class="source-inline"><span class="koboSpan" id="kobo.782.1">std::make_shared</span></strong><span class="koboSpan" id="kobo.783.1"> to allocate shared pointers makes its creation and deletion considerably faster, as we can see in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.784.1">BM_make_sharedptr</span></strong><span class="koboSpan" id="kobo.785.1"> benchmark, but, to make sure that we measure only the overhead of type erasure, we should implement a type-erased unique pointer. </span><span class="koboSpan" id="kobo.785.2">But we already did—it’s our </span><strong class="source-inline"><span class="koboSpan" id="kobo.786.1">smartptr</span></strong><span class="koboSpan" id="kobo.787.1"> that we saw in the </span><em class="italic"><span class="koboSpan" id="kobo.788.1">How is type erasure implemented in C++?</span></em><span class="koboSpan" id="kobo.789.1"> section of this chapter. </span><span class="koboSpan" id="kobo.789.2">It has just enough functionality to measure the performance of the same benchmark that we used for all </span><span class="No-Break"><span class="koboSpan" id="kobo.790.1">other pointers:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.791.1">
void BM_smartptr_te(benchmark::State&amp; state) {
  for (auto _ : state) {
    auto get_smartptr_te();
  }
  state.SetItemsProcessed(state.iterations());
}</span></pre>
<p><span class="koboSpan" id="kobo.792.1">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.793.1">smartptr_te</span></strong><span class="koboSpan" id="kobo.794.1"> stands for the type-erased version of the smart pointer implemented using inheritance. </span><span class="koboSpan" id="kobo.794.2">It is slightly faster than </span><strong class="source-inline"><span class="koboSpan" id="kobo.795.1">std::shared_ptr</span></strong><span class="koboSpan" id="kobo.796.1">, proving our suspicion that the latter has more than one source of overhead. </span><span class="koboSpan" id="kobo.796.2">Just like </span><strong class="source-inline"><span class="koboSpan" id="kobo.797.1">std::shared_ptr</span></strong><span class="koboSpan" id="kobo.798.1">, deleting </span><strong class="source-inline"><span class="koboSpan" id="kobo.799.1">smartptr_te</span></strong><span class="koboSpan" id="kobo.800.1"> touches two memory locations: in our case, it is the object that is being deleted and the deleter (embedded in a polymorphic object). </span><span class="koboSpan" id="kobo.800.2">This is exactly what </span><strong class="source-inline"><span class="koboSpan" id="kobo.801.1">std::make_shared</span></strong><span class="koboSpan" id="kobo.802.1"> avoids by consolidating both memory locations for </span><strong class="source-inline"><span class="koboSpan" id="kobo.803.1">std::shared_ptr</span></strong><span class="koboSpan" id="kobo.804.1">, and it definitely pays off. </span><span class="koboSpan" id="kobo.804.2">We can reasonably assume that the second memory allocation is also the reason for the poor performance of our type-erased smart pointer (approximately twice as slow as the raw or unique pointers). </span><span class="koboSpan" id="kobo.804.3">We can avoid this allocation if we use an internal buffer reserved inside the </span><a id="_idIndexMarker304"/><span class="koboSpan" id="kobo.805.1">smart pointer object. </span><span class="koboSpan" id="kobo.805.2">We have already seen a local buffer implementation of the smart pointer in the section </span><em class="italic"><span class="koboSpan" id="kobo.806.1">Type erasure without memory allocation</span></em><span class="koboSpan" id="kobo.807.1"> (in this benchmark, it is renamed as </span><strong class="source-inline"><span class="koboSpan" id="kobo.808.1">smartptr_te_lb0</span></strong><span class="koboSpan" id="kobo.809.1">). </span><span class="koboSpan" id="kobo.809.2">Here it is benchmarked under the name </span><strong class="source-inline"><span class="koboSpan" id="kobo.810.1">BM_smartptr_te_lb0</span></strong><span class="koboSpan" id="kobo.811.1">. </span><span class="koboSpan" id="kobo.811.2">The version that uses the local buffer when possible but switches to dynamic allocation for larger deleters is named </span><strong class="source-inline"><span class="koboSpan" id="kobo.812.1">smartptr_te_lb</span></strong><span class="koboSpan" id="kobo.813.1"> and is slightly </span><span class="No-Break"><span class="koboSpan" id="kobo.814.1">slower (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.815.1">BM_smartptr_te_lb</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.816.1">):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.817.1">
Benchmark                      Time
BM_smartptr_te_lb           11.3 ns
BM_smartptr_te_lb0          10.5 ns
BM_smartptr_te_static       9.58 ns
BM_smartptr_te_vtable       10.4 ns</span></pre>
<p><span class="koboSpan" id="kobo.818.1">We have also benchmarked the two type-erased smart pointers implemented without inheritance. </span><span class="koboSpan" id="kobo.818.2">The static function version </span><strong class="source-inline"><span class="koboSpan" id="kobo.819.1">BM_smartptr_te_static</span></strong><span class="koboSpan" id="kobo.820.1"> is slightly faster than the version that uses the vtable (</span><strong class="source-inline"><span class="koboSpan" id="kobo.821.1">BM_smartptr_te_vtable</span></strong><span class="koboSpan" id="kobo.822.1">). </span><span class="koboSpan" id="kobo.822.2">Both of these use local buffers; it should not come as a surprise that the compiler-generated vtable performs exactly as well as the equivalent structure we crafted using static </span><span class="No-Break"><span class="koboSpan" id="kobo.823.1">variable templates.</span></span></p>
<p><span class="koboSpan" id="kobo.824.1">Overall, there is some overhead even for the best type erasure implementation, just under 10 percent in our case. </span><span class="koboSpan" id="kobo.824.2">Whether or not this is acceptable, depends on </span><span class="No-Break"><span class="koboSpan" id="kobo.825.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.826.1">We should </span><a id="_idIndexMarker305"/><span class="koboSpan" id="kobo.827.1">also measure the performance of the generic type-erased function. </span><span class="koboSpan" id="kobo.827.2">We can measure its performance with any callable entity, for example, a </span><span class="No-Break"><span class="koboSpan" id="kobo.828.1">lambda expression:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.829.1">
// Example 09
void BM_fast_lambda(benchmark::State&amp; state) {
  int a = rand(), b = rand(), c = rand(), d = rand();
  int x = rand();
  Function&lt;int(int, int, int, int)&gt; f {
    [=](int a, int b, int c, int d) {
      return x + a + b + c + d; }
  };
  for (auto _ : state) {
    benchmark::DoNotOptimize(f(a, b, c, d));
    benchmark::ClobberMemory();
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.830.1">We can do the same measurement for </span><strong class="source-inline"><span class="koboSpan" id="kobo.831.1">std::function</span></strong><span class="koboSpan" id="kobo.832.1"> as well, and compare </span><span class="No-Break"><span class="koboSpan" id="kobo.833.1">the results:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.834.1">
Benchmark                      Time
BM_fast_lambda                 0.884 ns
BM_std_lambda                   1.33 ns</span></pre>
<p><span class="koboSpan" id="kobo.835.1">While it may seem like a great success, this benchmark also hides the warning against going overboard with type erasure. </span><span class="koboSpan" id="kobo.835.2">All we have to do to reveal this warning is to measure the performance of the direct call to the </span><span class="No-Break"><span class="koboSpan" id="kobo.836.1">same lambda:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.837.1">
Benchmark                      Time
BM_lambda                      0.219 ns</span></pre>
<p><span class="koboSpan" id="kobo.838.1">How do we reconcile this major slowdown with the minor cost of type erasure we have seen earlier when we were comparing smart and </span><span class="No-Break"><span class="koboSpan" id="kobo.839.1">raw pointers?</span></span></p>
<p><span class="koboSpan" id="kobo.840.1">It is important to pay attention to what is being erased. </span><span class="koboSpan" id="kobo.840.2">A well-implemented type-erased interface </span><a id="_idIndexMarker306"/><span class="koboSpan" id="kobo.841.1">can deliver performance very similar to that of a virtual function call. </span><span class="koboSpan" id="kobo.841.2">A non-inlined non-virtual function call is going to be slightly faster (in our case, a call that took just under 9 nanoseconds incurred about 10 percent overhead). </span><span class="koboSpan" id="kobo.841.3">But a type-erased invocation is always indirect. </span><span class="koboSpan" id="kobo.841.4">The one competition it can’t come close to is an inlined function call. </span><span class="koboSpan" id="kobo.841.5">This is exactly what we observed when we compared the performance of type-erased and direct invocations </span><span class="No-Break"><span class="koboSpan" id="kobo.842.1">of lambdas.</span></span></p>
<p><span class="koboSpan" id="kobo.843.1">With what we learned about the performance of type erasure, when can we </span><span class="No-Break"><span class="koboSpan" id="kobo.844.1">recommend it?</span></span></p>
<h1 id="_idParaDest-115"><a id="_idTextAnchor309"/><span class="koboSpan" id="kobo.845.1">Guidelines for using type erasure</span></h1>
<p><span class="koboSpan" id="kobo.846.1">What problems does type erasure solve, and when is the cost of the solution acceptable? </span><span class="koboSpan" id="kobo.846.2">First of all, it is important to not lose sight of the original goal: type erasure is a design </span><a id="_idIndexMarker307"/><span class="koboSpan" id="kobo.847.1">pattern that helps with the separation of concerns, a very powerful design technique. </span><span class="koboSpan" id="kobo.847.2">It is used to create an abstraction for a certain behavior when the implementation of said behavior can be provided by an open set of possibly </span><span class="No-Break"><span class="koboSpan" id="kobo.848.1">unrelated types.</span></span></p>
<p><span class="koboSpan" id="kobo.849.1">It is also used as an implementation technique, mostly to aid in breaking dependencies between compilation units and other </span><span class="No-Break"><span class="koboSpan" id="kobo.850.1">program components.</span></span></p>
<p><span class="koboSpan" id="kobo.851.1">Before we can answer the question “</span><em class="italic"><span class="koboSpan" id="kobo.852.1">Is type erasure worth the cost?</span></em><span class="koboSpan" id="kobo.853.1">”, we need to consider the alternatives. </span><span class="koboSpan" id="kobo.853.2">In many cases, the alternative is another way to implement the same abstraction: polymorphic class hierarchies or function pointers. </span><span class="koboSpan" id="kobo.853.3">The performance of either option is similar to that of the type erasure (in its optimal implementation), so it comes down to convenience and code quality. </span><span class="koboSpan" id="kobo.853.4">For a single function, using a type-erased function is easier than developing a new class hierarchy, and more flexible than using a function pointer. </span><span class="koboSpan" id="kobo.853.5">For a class with many member functions, it is usually easier and less error-prone to maintain a </span><span class="No-Break"><span class="koboSpan" id="kobo.854.1">class hierarchy.</span></span></p>
<p><span class="koboSpan" id="kobo.855.1">The other possible alternative is to do nothing and allow tighter coupling between parts of the design. </span><span class="koboSpan" id="kobo.855.2">The downsides of such a decision are often inversely proportional to its performance benefit: closely coupled parts of the system often need to coordinate implementation to achieve good performance, but they are closely coupled for a reason. </span><span class="koboSpan" id="kobo.855.3">Components that are logically well separated should not interact extensively, therefore, the performance of such interaction should not </span><span class="No-Break"><span class="koboSpan" id="kobo.856.1">be critical.</span></span></p>
<p><span class="koboSpan" id="kobo.857.1">What do we do when performance is important but we still need an abstraction? </span><span class="koboSpan" id="kobo.857.2">Often, the direct opposite of type erasure: we make everything </span><span class="No-Break"><span class="koboSpan" id="kobo.858.1">into templates.</span></span></p>
<p><span class="koboSpan" id="kobo.859.1">Consider C++20 ranges. </span><span class="koboSpan" id="kobo.859.2">On one hand, they are abstract sequences. </span><span class="koboSpan" id="kobo.859.3">We can write a function that operates on a range and invoke it with a vector, a deque, a range created from one of these </span><a id="_idIndexMarker308"/><span class="koboSpan" id="kobo.860.1">containers, a subrange of that range, or a filtered view. </span><span class="koboSpan" id="kobo.860.2">Anything is a range as long as it can be iterated from </span><strong class="source-inline"><span class="koboSpan" id="kobo.861.1">begin()</span></strong><span class="koboSpan" id="kobo.862.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.863.1">end()</span></strong><span class="koboSpan" id="kobo.864.1">. </span><span class="koboSpan" id="kobo.864.2">But ranges created from a vector and a deque are different types, even though they are abstractions for sequences, interface-wise. </span><span class="koboSpan" id="kobo.864.3">The standard library provides multiple range adapters and range views, and they are all templates. </span><span class="koboSpan" id="kobo.864.4">So are the functions operating on </span><span class="No-Break"><span class="koboSpan" id="kobo.865.1">the ranges.</span></span></p>
<p><span class="koboSpan" id="kobo.866.1">Could we implement a type-erased range? </span><span class="koboSpan" id="kobo.866.2">Yes, it is not even that hard. </span><span class="koboSpan" id="kobo.866.3">We end up with a single type, </span><strong class="source-inline"><span class="koboSpan" id="kobo.867.1">GenericRange</span></strong><span class="koboSpan" id="kobo.868.1">, that can be constructed from a vector, a deque, a list, or anything else that has </span><strong class="source-inline"><span class="koboSpan" id="kobo.869.1">begin()</span></strong><span class="koboSpan" id="kobo.870.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.871.1">end()</span></strong><span class="koboSpan" id="kobo.872.1">, and a forward iterator. </span><span class="koboSpan" id="kobo.872.2">We also get something that is about twice as slow as most container iterators, except for vectors: their iterators are really just pointers, and vectorizing compilers can do optimizations that speed up the code by at least an order of magnitude. </span><span class="koboSpan" id="kobo.872.3">The possibility of such optimizations is lost when we erase the type of the </span><span class="No-Break"><span class="koboSpan" id="kobo.873.1">original container.</span></span></p>
<p><span class="koboSpan" id="kobo.874.1">The C++ designers made the decision that, on the one hand, ranges provide an abstraction for certain behavior and let us separate the interface from the implementation. </span><span class="koboSpan" id="kobo.874.2">On the other hand, they were unwilling to sacrifice performance. </span><span class="koboSpan" id="kobo.874.3">So they chose to make ranges and all code that operates on them </span><span class="No-Break"><span class="koboSpan" id="kobo.875.1">into templates.</span></span></p>
<p><span class="koboSpan" id="kobo.876.1">As a designer of a software system, you may have to make similar decisions. </span><span class="koboSpan" id="kobo.876.2">The general guideline is to prefer tighter coupling for closely related components where such coupling is essential for performance. </span><span class="koboSpan" id="kobo.876.3">Conversely, prefer better separation for loosely coupled components whose interaction does not require high efficiency. </span><span class="koboSpan" id="kobo.876.4">When in that domain, type erasure should </span><a id="_idIndexMarker309"/><span class="koboSpan" id="kobo.877.1">be considered at least equall</span><a id="_idTextAnchor310"/><span class="koboSpan" id="kobo.878.1">y to polymorphism and other </span><span class="No-Break"><span class="koboSpan" id="kobo.879.1">decoupling techniques.</span></span></p>
<h1 id="_idParaDest-116"><a id="_idTextAnchor311"/><span class="koboSpan" id="kobo.880.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.881.1">In this chapter, we have, hopefully, demystified the programming technique known as type erasure. </span><span class="koboSpan" id="kobo.881.2">We have shown how a program can be written without all of the type information being explicitly visible, and some of the reasons why this may be a desirable implementation. </span><span class="koboSpan" id="kobo.881.3">We have also demonstrated that, when implemented efficiently and used wisely, it is a powerful technique that may lead to much simpler and more flexible interfaces and clearly </span><span class="No-Break"><span class="koboSpan" id="kobo.882.1">separated components.</span></span></p>
<p><span class="koboSpan" id="kobo.883.1">The next chapter is a change of direction—we are done with the abstraction idioms for some time and now move on to C++ idioms that facilitate the binding of template components into complex in</span><a id="_idTextAnchor312"/><span class="koboSpan" id="kobo.884.1">teracting systems. </span><span class="koboSpan" id="kobo.884.2">We start with the </span><span class="No-Break"><span class="koboSpan" id="kobo.885.1">SFINAE idiom.</span></span></p>
<h1 id="_idParaDest-117"><a id="_idTextAnchor313"/><span class="koboSpan" id="kobo.886.1">Questions</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.887.1">What is type </span><span class="No-Break"><span class="koboSpan" id="kobo.888.1">erasure, really?</span></span></li>
<li><span class="koboSpan" id="kobo.889.1">How is type erasure implemented </span><span class="No-Break"><span class="koboSpan" id="kobo.890.1">in C++?</span></span></li>
<li><span class="koboSpan" id="kobo.891.1">What is the difference between hiding a type behind </span><strong class="source-inline"><span class="koboSpan" id="kobo.892.1">auto</span></strong><span class="koboSpan" id="kobo.893.1"> and </span><span class="No-Break"><span class="koboSpan" id="kobo.894.1">erasing it?</span></span></li>
<li><span class="koboSpan" id="kobo.895.1">How is the concrete type reified when the program needs to </span><span class="No-Break"><span class="koboSpan" id="kobo.896.1">use it?</span></span></li>
<li><span class="koboSpan" id="kobo.897.1">What is the performance overhead of </span><span class="No-Break"><span class="koboSpan" id="kobo.898.1">type erasure?</span></span></li>
</ol>
</div>
</body></html>