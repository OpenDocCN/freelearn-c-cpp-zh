<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-98"><a id="_idTextAnchor266"/><a id="_idTextAnchor267"/><a id="_idTextAnchor268"/><a id="_idTextAnchor269"/><a id="_idTextAnchor270"/>6</h1>
<h1 id="_idParaDest-99"><a id="_idTextAnchor271"/>Understanding Type Erasure</h1>
<p>Type erasure is often seen as a mysterious, enigmatic programming technique. It is not exclusive to C++ (most tutorials on type erasure use Java for their examples). The goal of this chapter is to <a id="_idIndexMarker259"/>lift the shroud of mystery and teach you what type erasure is and how to use it in C++.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>What is type erasure?</li>
<li>Is type erasure a design pattern, or an implementation technique?</li>
<li>How can we implement type erasure?<a id="_idTextAnchor272"/></li>
<li>What design and performance considerations must be taken into account when deciding to use type erasure? What other guidelines can be offered for the use of type erasure?</li>
</ul>
<h1 id="_idParaDest-100"><a id="_idTextAnchor273"/>Technical requirements</h1>
<p>Example code can be found at the following link: <a href="https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/main/Chapter06">https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/main/Chapter06</a></p>
<p>You will need the Google Benchmark library installed and configured, details for which can be found here: <a href="https://github.com/google/benchmark">https://github.com/google/benchmark</a> (see <a href="B19262_04.xhtml#_idTextAnchor152"><em class="italic">Chapter 4</em></a>, <em class="italic">Swap - From Simple </em><em class="italic">to Subtle</em>)<a id="_idTextAnchor274"/><a id="_idTextAnchor275"/></p>
<h1 id="_idParaDest-101"><a id="_idTextAnchor276"/>What is type erasure?</h1>
<p><strong class="bold">Type erasure</strong>, in general, is a programming technique by which the explicit type information is removed <a id="_idIndexMarker260"/>from the program. It is a type of abstraction that ensures that the program does not explicitly depend on some of the data types<a id="_idTextAnchor277"/>.</p>
<p>This definition, while perfectly correct, also serves perfectly to surround type erasure in mystery. It does so by employing a sort of circular reasoning—it dangles before you the hope for something that, at first glance, appears impossible—a program written in a strongly typed language that does not use the actual types. How can this be? Why, by abstracting away the type, of course! And so, the hope and the mystery lives on.</p>
<p>It is hard to imagine a program that uses types without explicitly mentioning them (at least a C++ program; there are certainly languages where all types are not final until runtime).</p>
<p>So, we begin by demonstrating what is meant by type erasure using an example. This should allow us to gain <a id="_idIndexMarker261"/>an intuitive understanding of type erasure, which, in the later sections of this chapter, we will develop and make more rigorous. The aim here is to increase the level of abstraction—instead of writing some type-specific code, perhaps several versions of it for different types, we can write just one version that is more abstract, and expresses the concept—for example, instead of writing a function whose interface express<a id="_idTextAnchor278"/>es the concept <em class="italic">sort an array of integers</em>, we want to write a more abstract function, <em class="italic">sort </em><em class="italic">any arra<a id="_idTextAnchor279"/>y</em>.</p>
<h2 id="_idParaDest-102"><a id="_idTextAnchor280"/>Type erasure by example</h2>
<p>We will go <a id="_idIndexMarker262"/>through a detailed explanation of what type erasure is and how it is accomplished in C++. But first, let’s see what a program that has had the explicit type information removed from it looks like.</p>
<p>We start with a very simple example of using a unique pointer, <code>std::unique_ptr</code>:</p>
<pre class="source-code">
std::unique_ptr&lt;int&gt; p(new int(0));</pre>
<p>This is an owning pointer (see <a href="B19262_03.xhtml#_idTextAnchor110"><em class="italic">Chapter 3</em></a>, <em class="italic">Memory and Ownership</em>)—the entity containing this pointer, such as an object or a functional scope, also controls the lifetime of the integer we allocated, and is responsible for its deletion. The deletion is not explicitly visible in the code and will happen when the <code>p</code> pointer is deleted (for example, when it goes out of scope). The way this deletion will be accomplished is also not explicitly visible—by default, <code>std::unique_ptr</code> deletes the object it owns using <code>operator delete</code>, or, more precisely, by invoking <code>std::default_delete</code>, which, in turn, calls <code>operator delete</code>. What if we do not want to use the regular standard <code>delete</code>? For example, we may have objects that are allocated on our own heap:</p>
<pre class="source-code">
class MyHeap {
  public:
  ...
  void* allocate(size_t size);
  void deallocate(void* p);
  <a id="_idTextAnchor281"/>...
};
void* operator new(size_t size, MyHeap* heap) {
  return heap-&gt;allocate(size);
}</pre>
<p>Allocation is no problem, with the help of the overloaded <code>operator new</code>:</p>
<pre class="source-code">
MyHeap heap;
std::unique_ptr&lt;int&gt; p(new(&amp;heap) int(0));</pre>
<p>This syntax invokes the two-argument <code>operator new</code> function; the first argument is always the size and is added by the compiler, and the second argument is the heap pointer. Since we have such an overload declared, it will be invoked and will return the memory allocated from the heap. But we have not done anything to change the way the object is deleted. The regular <code>operator delete</code> function will be called and will attempt to return to <a id="_idIndexMarker263"/>the global heap some memory that wasn’t allocated from there. The result is likely to be memory corruption, and probably a crash. We could define an <code>operator delete</code> function with the same additional argument, but it does us no good here—unlike <code>operator new</code>, there is no place to pass arguments to <code>delete</code> (you will often see such an <code>operator delete</code> function defined anyway, and it should behave as such, but it has nothing to do with any <code>delete</code> you see in the program; it is used in the stack unwinding if the constructor throws an exception).</p>
<p>Somehow, we need to tell the unique pointer that this particular object is to be deleted differently. It turns out that <code>std::unique_ptr</code> has a second <code>template</code> argument. You usually don’t see it because it defaults to <code>std::default_delete</code>, but that can be changed and a custom <code>deleter</code> object can be defined to match the allocation mechanism. The <code>deleter</code> has a very simple interface—it needs to be callable:</p>
<pre class="source-code">
template &lt;typename T&gt; struct MyDeleter {
  void operator()(T* p);
};</pre>
<p>The <code>std::default_delete</code> policy is implemented pretty much like that and simply calls <code>delete</code> on the <code>p</code> pointer. Our custom <code>deleter</code> will need a non-trivial constructor to store the pointer to the heap. Note that, while the <code>deleter</code> needs, in general, to be able to delete an object of any type that can be allocated, it does not have to be a template class. A non-template class with a template member function will do just as well, as long as the data members of the class do not depend on the deleted type. In our case, the data members depend only on the type of the heap, but not on what is being deleted:</p>
<pre class="source-code">
class MyDeleter {
  MyHeap* heap_;
  pub<a id="_idTextAnchor282"/>lic:
  MyDeleter(MyHeap* heap) : heap_(heap) {}
  template &lt;typename T&gt; void operator()(T* p) {
    p-&gt;~T();
    heap_-&gt;deallocate(p);
  }
};</pre>
<p>The <code>deleter</code> has to perform the equivalent of both functions of the standard <code>operator</code> <code>delete</code> function—it has to invoke the destructor of the object being deleted, then it must deallocate the memory that was allocated for this object.</p>
<p>Now that we have the appropriate <code>deleter</code>, we can finally use <code>std::unique_ptr</code> with our own heap:</p>
<pre class="source-code">
// Example 01
MyHeap heap;
MyDeleter deleter(&amp;heap);
std::unique_ptr&lt;int, MyDeleter&gt; p(
  new(&amp;heap) int(0), deleter);</pre>
<p>Note that <code>deleter</code> objects are often created on demand, at the point of allocation:</p>
<pre class="source-code">
MyHeap heap;
std::unique_ptr&lt;int, MyDeleter&gt; p(
  new(&amp;heap) int(0), MyDeleter(&amp;heap));</pre>
<p>Either way, the <code>deleter</code> must be no-throw-copyable or no-throw-movable; that is, it must have a copy constructor or a move constructor, and the constructor must be declared <code>noexcept</code>. The built-in types, such as raw pointers, are, of course, copyable, and the default compiler-generated constructor does not throw. Any aggregate type combining one or more of these types as data members, such as our <code>deleter</code>, has a default constructor that also does not throw (unless it has been redefined, of course).</p>
<p>Note that the <code>deleter</code> is a part of the unique pointer’s type. Two unique pointers <a id="_idIndexMarker264"/>that own objects of the same type, but have different deleters, are different types:</p>
<pre class="source-code">
// Example 02
MyHeap heap;
std::unique_ptr&lt;int, MyDeleter&gt; p(
  new(&amp;heap) int(0), MyDeleter(&amp;heap));
std::unique_ptr&lt;int&gt; q(new int(0));
p = std::move(q);    // Error: p and q are different types</pre>
<p>Similarly, the unique pointer must be constructed with the <code>deleter</code> of the right type:</p>
<pre class="source-code">
std::unique_ptr&lt;int&gt; p(new(&amp;heap) int(0),
  MyDeleter(&amp;heap));    // Does not co<a id="_idTextAnchor283"/>mpile</pre>
<p>As an aside, while experimenting with unique pointers of different types, you might notice that the two pointers in the preceding code, <code>p</code> and <code>q</code>, while not assignable, are comparable: <code>p == q</code> compiles. This happens because the <code>comparison</code> operator is actually a template—it accepts two unique pointers of different types and compares the underlying raw pointers (if that type differs as well, the compilation error is likely to not mention the unique pointer at all, but instead, to say something about comparing pointers to distinct types without a cast).</p>
<p>Now let’s do the same example, but with the shared pointer, <code>std::shared_ptr</code>. First, we point the shared pointer to an object constructed with the regular <code>operator new</code> function as follows:</p>
<pre class="source-code">
std::unique_ptr&lt;int&gt; p(new int(0));
std::shared_ptr&lt;int&gt; q(new int(0));</pre>
<p>For comparison, we left the unique pointer declaration there as well. The two smart pointers are <a id="_idIndexMarker265"/>declared and constructed in exactly the same way. And now, in the following code block, the shared pointer to an object allocated on our <code>heap</code>:</p>
<pre class="source-code">
MyHeap heap;
std::unique_ptr&lt;int, MyDeleter&gt; p(
  new(&amp;heap) int(0), MyDeleter(&amp;heap));
std::shared_ptr&lt;int&gt; q(
  new(&amp;heap) int(0), MyDeleter(&amp;heap));</pre>
<p>Now you see a difference—the shared pointer that was created with a custom <code>deleter</code> is, nonetheless, of the same type as the one that uses the default <code>deleter</code>! In fact, all shared pointers to <code>int</code> have the same type, <code>std::shared_ptr&lt;int&gt;</code>—the template does not have another argument. Think this through—the <code>deleter</code> is specified in the constructor but is used only in the destructor, therefore it must be stored inside the smart pointer object until needed. There is no way to recover it later if we lose the object that was given to us during construction. Both <code>std::shared_ptr</code> and <code>std::unique_ptr</code> must store the <code>deleter</code> object of an arbitrary type inside the pointer object itself. But only the <code>std::unique_ptr</code> class has the deleter information in its type. The <code>std::shared_ptr</code> class is the same for all deleter types. Going back to the very beginning of this section, the program that uses <code>std::shared_ptr&lt;int&gt;</code> does not have any explicit information about the deleter type.</p>
<p>This type has been erased from the program. This, then, is what a type-erased program looks like:</p>
<pre class="source-code">
// Example 03
void some_function(std::shared_ptr&lt;int&gt;);     // no deleter
MyHeap heap;
{
  std::shared_ptr&lt;int&gt; p(    // No deleter in the type
    new(&amp;heap) int(0),
    MyDeleter(&amp;heap));    // Deleter in constructor only
  std::shared_ptr&lt;int&gt; q(p);    // No deleter type a<a id="_idTextAnchor284"/>nywhere
  some_function(p);    // uses p, no deleter
}    // Deletion happens, MyDeleter is invoked</pre>
<p>We spent so much time dissecting <code>std::shared_ptr</code> because it provides a very simple example <a id="_idIndexMarker266"/>of type erasure, especially since we can contrast it with <code>std::unique_ptr</code> which has to solve exactly the same problem but chooses the opposite approach. This simple example, however, does not highlight the design implications of choosing type erasure and does not illustrate what design problems this pattern solves. For that, we should look at the quintessential type-erased object in C++: <code>std::function</code>.</p>
<h2 id="_idParaDest-103"><a id="_idTextAnchor285"/>From example to generalization</h2>
<p>In C++, <code>std::function</code> is a general-purpose polymorphic function wrapper, or a general callable object. It is <a id="_idIndexMarker267"/>used to store any callable entity such as a function, a lambda expression, a functor (an object with the <code>operator()</code>), or a member function pointer. The only requirement for these different callable entities is that they must have the same call signature, i.e., accept the same arguments and return the result of the same type. The signature is specified when a particular <code>std::function</code> object is declared:</p>
<pre class="source-code">
std::function&lt;int(long, double)&gt; f;</pre>
<p>We have just declared a callable that can be invoked with two arguments, <code>long</code> and <code>double</code> (or, to be more precise, with any two arguments convertible to <code>long</code> and <code>double</code>), and returns a result that can be converted to <code>int</code>. What does it do with the arguments and what is the result? That is determined by the concrete callable entity that is assigned to <code>f</code>:</p>
<pre class="source-code">
// Example 04
std::function&lt;size_t(const std::string&amp;)&gt; f;
size_t f1(const std::string&amp; s) { return s.capacity(); }
f = f1;
std::cout &lt;&lt; f("abcde");    // 15
char c = 'b';
f = [=](const std::string&amp; s) { return s.find(c); };
std::cout &lt;&lt; f("abcde");    // 1
f = &amp;std::string::size;
std::cout &lt;&lt; f("abcde");    // 5</pre>
<p>In this example, we first assign a non-member function <code>f1</code> to <code>f</code>; now calling <code>f(s)</code> returns the capacity of the string <code>s</code> since that’s what <code>f1</code> does. Next, we change <code>f</code> to contain a lambda expression; calling <code>f(s)</code> now invokes that expression. The only thing these two functions <a id="_idIndexMarker268"/>have in common is the interface: they accept the same arguments and have the same result types. Finally, we assign a member function pointer to <code>f</code>; while the function <code>std::string::size()</code> takes no arguments, all member functions have an implicit first argument which is a reference to the object itself, so it fits the requirement on the interface.</p>
<p>We can now see type erasure in its more general form: it is an abstraction for many different implementations that all provide the same behavior. Let us consider what design capabilities it opens.</p>
<h1 id="_idParaDest-104"><a id="_idTextAnchor286"/>Type erasure as a design pattern</h1>
<p>We have already seen how type erasure manifests itself in a program: the code expects certain <a id="_idIndexMarker269"/>semantics behavior, but, instead of dealing with specific types that provide it, we use an abstraction and “erase” the properties of those types that are not relevant to the task at hand (starting with the name of the type).</p>
<p>In this way, type erasure has attributes of several other design patterns, but it’s not equivalent to any of them. It could reasonably be considered a design pattern in its own right. So, what does type erasure offer as a design pattern?</p>
<p>In type erasure, we find an abstract expression of certain behavior, such as a function call, that can be used to separate the interface from the implementation. So far, this sounds very similar to inheritance. Recall now how, at the end of the last section, we made a <code>std::function</code> object invoke several completely different callables: a function, a lambda expression, and a member function. This illustrates the fundamental difference between type erasure and inheritance: with inheritance, the base class determines the abstract behavior (the interface), and any class that needs to implement that interface must be derived from the same base. With type erasure, there is no such requirement: the types that provide the common behavior do not have to form any particular hierarchy; in fact, they need not be classes at all.</p>
<p>It can be said that type erasure offers a non-intrusive way to separate the interface from the implementation. By “intrusive” we mean the fact that we must change a type in order to use the abstraction: for example, we may have a class that has the desired behavior, but, in order to be used polymorphically, it must also inherit from the common base class. This is the “intrusion” – the enforced change we must make to the otherwise perfectly good class in order to make it usable as a concrete implementation of a certain abstract interface. As we have just seen, type erasure has no such need. As long as the class (or any other type) has the desired behavior – usually, a way to invoke it in a function call-like manner with certain arguments – it can be used to implement this behavior. The other properties of the type are not relevant for supporting the interface we are focusing on and are “erased.”</p>
<p>We can also say that type erasure provides “external polymorphism:” there is no unifying hierarchy required, and the set of types that can be used to implement a particular abstraction is extensible, not limited to just classes derived from a common base.</p>
<p>So, why doesn’t type erasure completely replace inheritance in C++? To some extent, it is tradition; don’t be too fast to kick tradition, though – the other name for tradition is “convention,” and conventional code is also familiar, easy-to-understand code. But there are two “real” reasons as well. The first one is performance. We will study the implementations of type erasure and their respective performance later in this chapter; however, without spoiling anything, we can say that high-performance implementations of type erasure became available only recently. The second one is convenience, and we can see that already. If we need to declare an abstraction for a whole set of related operations, we can declare a base class with the necessary virtual member functions. If we use a <code>std::function</code> approach, a type-erased implementation would have to handle each of these operations separately. As we will see soon, this is not a requirement – we can implement a type-erased abstraction for a whole set of operations at once. However, doing it with inheritance is easier. Also, remember that all concrete types hiding behind the type erasure must provide the required behavior; if we require that all these types support several different member functions, it is more likely that they are going to be coming from the same hierarchy for other reasons.</p>
<h2 id="_idParaDest-105"><a id="_idTextAnchor287"/>Type erasure as an implementation technique</h2>
<p>Not every use of type erasure has a grand design idea behind it. Often, type erasure is used purely <a id="_idIndexMarker270"/>as an implementation technique (the same is true for inheritance, and we are about to see one such use). In particular, type erasure is a great tool for breaking dependencies between components of a large system.</p>
<p>Here is a simple example. We are building a large distributed software system, so one of our core components is the network communication layer:</p>
<pre class="source-code">
class Network {
  …
  void send(const char* data);
  void receive(const char* buffer);
  …
};</pre>
<p>This is, of course, a very simplified and abstract view of a component that is, at best, non-trivial, but sending data across the network is not what we want to focus on now. The important point is that this is one of our foundational components, the rest of the system depends on it. We may have several different programs built as a part of our software solution; all of them include this communication library.</p>
<p>Now, in one specific application, we have a need to process the data packets before and after they are sent across the network; it could be a high-security system that requires advanced encryption, or it could be the only tool in our system that is designed to work over unreliable <a id="_idIndexMarker271"/>networks and needs to insert error correction codes. The point is, the designer of the network layer is now asked to introduce a dependency on some external code that comes from a higher-level application-specific component:</p>
<pre class="source-code">
class Network {
  …
  bool needs_processing;
  void send(const char* data) {
    if (needs_processing) apply_processing(buffer);
    …
  }
  …
};</pre>
<p>While this code looks simple, it is a dependency nightmare: the low-level library now has to be built with the <code>apply_processing()</code> function from the specific application. Even worse, all other programs that do not require this functionality must still be compiled and linked with this code, even if they never set <code>needs_processing</code>.</p>
<p>While this problem can be handled the “old school” way – with some function pointers or (worse) global variables, type erasure offers an elegant solution:</p>
<pre class="source-code">
// Example 05
class Network {
  static const char* default_processor(const char* data) {
    std::cout &lt;&lt; "Default processing" &lt;&lt; std::endl;
    return data;
  }
  std::function&lt;const char*(const char*)&gt; processor =
    default_processor;
  void send(const char* data) {
    data = processor(data);
    …
  }
  public:
  template &lt;typename F&gt;
  void set_processor(F&amp;&amp; f) { processor = f; }
};</pre>
<p>This is an example of the strategy design pattern, where the implementation of a particular behavior can be chosen at run-time. Now, any higher-level component of the system can specify its own processor function (or a lambda expression, or a callable object) without forcing the rest of the software to link with their code:</p>
<pre class="source-code">
Network N;
N.set_processor([](const char* s){ char* c; …; return c; };</pre>
<p>Now that we <a id="_idIndexMarker272"/>know what type erasure looks like and how it can help decouple components, both as a design pattern and as a convenient implementation technique, there is only one more question left - how <a id="_idTextAnchor288"/><a id="_idTextAnchor289"/>does it work?</p>
<h1 id="_idParaDest-106"><a id="_idTextAnchor290"/>How is type erasure implemented in C++?</h1>
<p>We have seen <a id="_idIndexMarker273"/>what type erasure looks like in C++. Now we <a id="_idIndexMarker274"/>understand what it means for a program to not explicitly depend on a type. But the mystery remains—the program makes no mention <a id="_idIndexMarker275"/>of the type, and yet, at the right time, invokes an <a id="_idIndexMarker276"/>operation on <a id="_idTextAnchor291"/>the type it knows nothing about. How? That is what we <a id="_idTextAnchor292"/>are about to see.</p>
<h2 id="_idParaDest-107"><a id="_idTextAnchor293"/>Very old type erasure</h2>
<p>The idea of writing a <a id="_idIndexMarker277"/>program without explicit type information is certainly not new. In fact, it predates object-oriented programming and the notion of objects by a long time. Consider this C program (no C++ here) as an example:</p>
<pre class="source-code">
// Example 06
int less(const void* a, const int* b) {
  return *(const int*)a - *(const int*)b;
}
int main() {
  int a[10] = { 1, 10, 2, 9, 3, 8, 4, 7, 5, 0 };
  qsort(a, 10, sizeof(int), less);
}</pre>
<p>Now remember the function declaration for <code>qsort</code> from the standard <code>C</code> library:</p>
<pre class="source-code">
void qsort(void *base, size_t nmemb, size_t size,
  int (*compare)(const void *, const void *));</pre>
<p>Note that, while we are using it to sort an array of integers, the <code>qsort</code> function itself does not have any explicit types—it uses <code>void*</code> to pass in the array to be sorted. Similarly, the comparison function takes two <code>void*</code> pointers and has no explicit type information in its declaration. Of course, at some point, we need to know how to compare the real types. In our C program, the pointers that could, in theory, point to anything, are <a id="_idIndexMarker278"/>reinterpreted as pointers to integers. This action, which reverses the abstraction, is kn<a id="_idTextAnchor294"/>own as <strong class="bold">reification</strong>.</p>
<p>In C, restoring concrete types is entirely the responsibility of the programmer—our <code>less()</code> comparison function does, in fact, only compare integers, but it is impossible to deduce so from the interface. Neither is it possible to validate, at runtime, that the correct types are used throughout the program, and it is certainly not possible for the program to automatically select the right comparison operation for the actual type at runtime.</p>
<p>Nonetheless, this simple example lets us penetrate the magic of type erasure: the general code indeed does not depend on the concrete type that was erased, but that type is hidden in the code of a function called through the type-erased interface. In our example, it was the comparison function:</p>
<pre class="source-code">
int less(const void* a, const int* b) {
  return *(const int*)a - *(const int*)b;
}</pre>
<p>The calling code knows nothing about the type <code>int</code>, but the implementation of <code>less()</code> operates on this type. The type is “hidden” in the code of a function invoked through the type-agnostic interface.</p>
<p>The major downside of this C approach is that the programmer is wholly responsible for ensuring that all the pieces of the type-erased code are consistent; in our example, it is the sorted data and the comparison function that must refer to the same type.</p>
<p>In C++, we can do <a id="_idIndexMarker279"/>a lot better, but the idea is still the same: the erased type is reified by the implementation of some type-specific code that is invoked through the type-agnostic interface. The key difference is that we are going to force the compiler to generate this code for us. There are, fundamentally, two techniques that can be used. The first one relies on run-time polymorphism (inheritance), and the second one uses template magic. Let us start with the polymorphic implementation.</p>
<h2 id="_idParaDest-108"><a id="_idTextAnchor295"/>Type erasure using inheritance</h2>
<p>We’re now <a id="_idIndexMarker280"/>going to see how <code>std::shared_ptr</code> does its magic. We will do it with a simplified example of a smart pointer that focuses specifically on the type erasure aspect. It should not surprise you to learn that this is done with a combination of generic and object-oriented programming:</p>
<pre class="source-code">
// Example 07
template &lt;typename T&gt; class smartptr {
  <a id="_idTextAnchor296"/>struct destroy_base {
    virtual void operator()(void*) = 0;
    virtual ~deleter_base() {}
  };
  template &lt;typename Deleter&gt;
  struct destroy : public destroy _base {
    destroy (Deleter d) : d_(d) {}
    void operator()(void* p) override {
      d_(static_cast&lt;T*&gt;(p));
    }
    Deleter d_;
  };
  public:
  template &lt;typename Deleter&gt; smartptr(T* p, Deleter d) :
    p_(p), d_(new destroy&lt;Deleter&gt;(d)) {}
  ~smartptr() { (*d_)(p_); delete d_; }
  T* operator-&gt;() { return p_; }
  const T* operator-&gt;() const { return p_; }
  private:
  T* p_;
  destroy _base* d_;
};</pre>
<p>The <code>smartptr</code> template has only one type parameter. Since the erased type is not part of the smart <a id="_idIndexMarker281"/>pointer’s type, it has to be captured in some other object. In our case, this object is an instantiation of the nested <code>smartptr&lt;T&gt;::destroy</code> template. This object is created by the constructor, which is the last point in the code where the deleter type is explicitly present. But <code>smartptr</code> must refer to the <code>destroy</code> instance through a pointer whose type does not depend on <code>destroy</code> (since the <code>smartptr</code> object has the same type for all deleters). Therefore, all instances of the <code>destroy</code> template inherit from the same base class, <code>destroy_base</code>, and the actual deleter is invoked through a virtual function. The constructor is a template that deduces the type of deleter, but the type is only hidden, as it’s part of the actual declaration of the specific instantiation of this template. The smart pointer class itself, and, in particular, its destructor, where the deleter is actually used, really have the deleter type erased. The compile-time type detection is used to create a correct-by-construction polymorphic object that will rediscover the deleter type at runtime and perform the correct action. For that reason, we do not need a dynamic cast, and can use the static cast instead, which only works if we know the real derived type (and we do).</p>
<p>The same technique can be used to implement <code>std::function</code> and other type<a id="_idTextAnchor297"/>-erased types, such as the ultimate type-erased class, <code>std::any</code> (in C++17 and above). This is a class, not a template, but it can hold a value of any type:</p>
<pre class="source-code">
// Example 08
std::any a(5);
int i = std::any_cast&lt;int&gt;(a);    // i == 5
std::any_cast&lt;long&gt;(a);        // throws bad_any_cast</pre>
<p>Of course, without knowing the type, <code>std::any</code> cannot provide any interfaces. You can store any value in it, and get it back if you know the right type (or you can ask for the type and get back a <code>std::type_info</code> object).</p>
<p>Before we learn the other (usually more efficient) way to implement type erasure, we have to address one glaringly obvious inefficiency in our design: every time we create or delete a shared pointer or a <code>std::function</code> object that is implemented as described above, we must allocate and deallocate memory for the derived object that conceals the erased type.</p>
<h2 id="_idParaDest-109"><a id="_idTextAnchor298"/>Type erasure without memory allocation</h2>
<p>There are, however, <a id="_idIndexMarker282"/>ways to optimize the type-erased pointers (as well as any other type-erased data structures) and avoid the additional memory allocation that happens when we construct the polymorphic <code>smartptr::destroy</code> object. We can avoid this allocation, at least sometimes, by pre-allocating a memory buffer for these objects. The details of this optimization, as well as its limitations, are discussed in <a href="B19262_10.xhtml#_idTextAnchor453"><em class="italic">Chapter 10</em></a>, <em class="italic">Local Buffer Optimization</em>. Here is the gist of the optimization:</p>
<pre class="source-code">
// Example 07
template &lt;typename T&gt; class smartptr {
  …
  public:
  template &lt;typename Deleter&gt; smartptr(T* p, Deleter d) :
    p_(p) {
    static_assert(sizeof(Deleter) &lt;= sizeof(buf_));
    ::new (static_cast&lt;void*&gt;(buf_)) destroy&lt;Deleter&gt;(d));
  }
  ~smartptr() {
    destroy_base* d = (destroy_base*)buf_;
    (*d)(p_);
    d-&gt;~destroy_base();
  }
  private:
  T* p_;
  alignas(8) char buf_[16];
};</pre>
<p>The local buffer optimization does make type-erased pointers and functions a lot more efficient, as <a id="_idIndexMarker283"/>we will see later in this chapter. Of course, it imposes restrictions on the size of the deleter; for this reason, most real-life implementations use a local buffer for small enough erased types and dynamic memory for types that don’t fit into the buffer. The alternative solution - to assert as shown above and force the programmer to increase the buffer – is often embraced in very high-performance applications.</p>
<p>There are some subtler consequences of the use of this optimization: the deleter (or another erased object) is now stored as a part of the class and must be copied with the rest of the class. How do we copy an object whose type we no longer know? This and other details will have to wait until <a href="B19262_10.xhtml#_idTextAnchor453"><em class="italic">Chapter 10</em></a><em class="italic">, Local Buffer Optimization</em>. For now, we will use the local buffer optimization in the rest of the examples, both to show its use and to simplify the code.</p>
<h2 id="_idParaDest-110"><a id="_idTextAnchor299"/>Type erasure without inheritance</h2>
<p>There is an <a id="_idIndexMarker284"/>alternative implementation of type erasure that does not use an internal hierarchy of classes to store the erased type. Instead, the type is captured in the implementation of a function, just like it was done in C:</p>
<pre class="source-code">
void erased_func(void* p) {
  TE* q = static_cast&lt;T*&gt;(p);
  … do work on type TE …
}</pre>
<p>In C++, we make the function a template so the compiler generates instantiations for every type <code>TE</code> we need:</p>
<pre class="source-code">
template &lt;typename TE&gt; void erased_func(void* p) {
  TE* q = static_cast&lt;T*&gt;(p);
  … do work on type TE …
}</pre>
<p>This is a somewhat unusual template function: the type parameter cannot be deduced from the arguments and must be explicitly specified. We already know that this will be done in the constructor of a type-erased class, such as our smart pointer: there, we still know the type that is about to be erased. The other very important point is that any function generated by the preceding template can be invoked through the same function pointer:</p>
<pre class="source-code">
void(*)(void*) fp = erased_func&lt;int&gt;; // or any other type</pre>
<p>Now we can see how the type erasure magic works: we have a function pointer whose type does not depend on the type <code>TE</code> we are erasing. We are going to generate a function with an implementation that uses this type and assign it to this pointer. When we need to <a id="_idIndexMarker285"/>use the erased type <code>TE</code>, such as deleting the object with the specified deleter, we are going to call a function through this pointer; we can do that without knowing what <code>TE</code> is. We just have to put this all together into a correct-by-construction implementation, and here is our type-erased smart pointer:</p>
<pre class="source-code">
// Example 07
template &lt;typename T&gt;
class smartptr_te_static {
  T* p_;
  using destroy_t = void(*)(T*, void*);
  destroy_t destroy_;
  alignas(8) char buf_[8];
  template&lt;typename Deleter&gt;
  static void invoke_destroy(T* p, void* d) {
    (*static_cast&lt;Deleter*&gt;(d))(p);
  }
  public:
  template &lt;typename Deleter&gt;
  smartptr_te_static(T* p, Deleter d)
    : p_(p), destroy_(invoke_destroy&lt;Deleter&gt;)
  {
    static_assert(sizeof(Deleter) &lt;= sizeof(buf_));
    ::new (static_cast&lt;void*&gt;(buf_)) Deleter(d);
  }
  ~smartptr_te_static() {
    this-&gt;destroy_(p_, buf_);
  }
  T* operator-&gt;() { return p_; }
  const T* operator-&gt;() const { return p_; }
};</pre>
<p>We store the user-given deleter in a small local buffer; in this example, we do not show the alternative implementation for a larger deleter that would require dynamic memory allocation. The function template that retains the information about the erased type is <code>invoke_destroy()</code>. Note that it is a static function; static functions can be invoked through a regular function pointer instead of a more cumbersome member function pointer.</p>
<p>In the constructor of the <code>smartptr</code> class, we instantiate <code>invoke_destroy&lt;Deleter&gt;</code> and assign it to the <code>destroy_</code> function pointer. We also need a copy of the deleter object, since the deleter may contain a state (for example, a pointer to the allocator that provided the memory for the object owned by the smart pointer). We construct this deleter in the space provided by the local buffer <code>buf_</code>. At this point, the original <code>Deleter</code> type is erased: all we have is a function pointer that does not depend on the <code>Deleter</code> type and a character array.</p>
<p>When the time comes to destroy the object owned by the shared pointer, we need to invoke the <a id="_idIndexMarker286"/>deleter. Instead, we invoke the function through the <code>destroy_</code> pointer and pass to it the object to be destroyed and the buffer where the deleter resides. The erased <code>Deleter</code> type is nowhere to be seen, but it is hiding inside the specific implementation of <code>invoke_destroy()</code>. There, the pointer to the buffer is cast back to the type that is actually stored in the buffer (<code>Deleter</code>) and the deleter is invoked.</p>
<p>This example is, perhaps, the most concise demonstration of type erasure machinery in C++. But it is not quite equivalent to the example in the previous section where we used inheritance. While we invoke the deleter on the object of type <code>T</code> owned by the smart pointer, we do nothing to destroy the deleter object itself, specifically, the copy we stored inside the local buffer. The local buffer is not the problem here: if we dynamically allocated the memory instead, it would still be accessed through a generic pointer such as <code>char*</code> or <code>void*</code>, and we would now know how to properly delete it. For that, we need another function that can reify the original type. Well, maybe: trivially destructible deleters (and, in general, trivially destructible callable objects) are very common. All function pointers, member function pointers, stateless objects, and lambdas that do not capture any non-trivial objects by value are all trivially destructible. So we could simply add a static assert to our constructor and restrict our smart pointer to trivially destructible deleters, and, in reality, it would serve us fine in most cases. But I also want to show you a more general solution.</p>
<p>We can, of course, use another pointer to a static function that destroys the deleter and is instantiated with the right type in the constructor. But the destructor is not the end of what we need: in general, we also need to copy and move deleters, and maybe even compare them. That’s a lot <a id="_idIndexMarker287"/>of function pointers making our <code>smartptr</code> class bloated. By comparison, the inheritance-based implementation did everything with just the pointer to the <code>destroy</code> object (stored as a pointer to the base class <code>destroy_base</code>). There is a way we can do the same. For this example, there is no good way to gradually reveal the magic, so we have to jump right in and follow up with a line-by-line explanation:</p>
<pre class="source-code">
// Example 07
template &lt;typename T&gt;
class smartptr_te_vtable {
  T* p_;
  struct vtable_t {
    using destroy_t = void(*)(T*, void*);
    using destructor_t = void(*)(void*);
    destroy_t destroy_;
    destructor_t destructor_;
  };
  const vtable_t* vtable_ = nullptr;
  template &lt;typename Deleter&gt;
  constexpr static vtable_t vtable = {
    smartptr_te_vtable::template destroy&lt;Deleter&gt;,
    smartptr_te_vtable::template destructor&lt;Deleter&gt;
  };
  template &lt;typename Deleter&gt;
  static void destroy(T* p, void* d) {
    (*static_cast&lt;Deleter*&gt;(d))(p);
  }
  template &lt;typename Deleter&gt;
  static void destructor(void* d) {
    static_cast&lt;Deleter*&gt;(d)-&gt;~Deleter();
  }
  alignas(8) char buf_[8];
  public:
  template &lt;typename Deleter&gt;
  smartptr_te_vtable(T* p, Deleter d)
    : p_(p), vtable_(&amp;vtable&lt;Deleter&gt;)
  {
    static_assert(sizeof(Deleter) &lt;= sizeof(buf_));
    ::new (static_cast&lt;void*&gt;(buf_)) Deleter(d);
  }
  ~smartptr_te_vtable() {
    this-&gt;vtable_-&gt;destroy_(p_, buf_);
    this-&gt;vtable_-&gt;destructor_(buf_);
  }
  T* operator-&gt;() { return p_; }
  const T* operator-&gt;() const { return p_; }
};</pre>
<p>Let us explain how this code works. First of all, we declare a <code>struct vtable_t</code> that contains function pointers to every operation we need to implement on the erased <code>Deleter</code> type. In our case, there are just two: invoke the deleter on an object to be destroyed and destroy the deleter itself. In general, we would have at least copy and move operations there as well (you will find such implementation in <a href="B19262_10.xhtml#_idTextAnchor453"><em class="italic">Chapter 10</em></a><em class="italic">, Local Buffer Optimization</em>). Next, we have the <code>vtable_</code> pointer. After the object is constructed, it will point to an object of the type <code>vtable_t</code>. While this may suggest dynamic memory allocation ahead, we are going to do much better than that. Next is a variable template <code>vtable</code>; instantiating it on a concrete <code>Deleter</code> type will create a static instance of a variable of type <code>vtable_t</code>. This is, perhaps, the most tricky part: usually, when we have a static data member of a class, it’s just a variable, and we can access it by name. But here is something different: the name <code>vtable</code> can refer to many objects, all of the same type, <code>vtable_t</code>. None of them are explicitly created by us: we do not allocate memory for them, do not call <code>operator new</code> to construct them. The compiler creates one of these objects <a id="_idIndexMarker288"/>for every <code>Deleter</code> type we use. For every smartptr object, the address of the specific <code>vtable</code> object we want it to use is stored in the <code>vtable_</code> pointer.</p>
<p>An object of type <code>vtable_t</code> contains pointers to static functions. Our <code>vtable</code> must do so as well: as you can see, we initialized the function pointers in <code>vtable</code> to point to instantiations of static member functions of the <code>smartptr</code> class. These instantiations are for the same <code>Deleter</code> type that the <code>vtable</code> itself is instantiated with.</p>
<p>The name <code>vtable</code> was not chosen lightly: we have indeed implemented a virtual table; the compiler builds a very similar structure with function pointers for every polymorphic hierarchy, and every virtual class has a virtual pointer that points to the table for its original type (the one it was constructed with).</p>
<p>After the <code>vtable</code>, we have two static function templates. That is where the erased type is really hidden and later reified. As we have seen before, the function signatures do not depend on the <code>Deleter</code> type, but their implementations do. Finally, we have the same buffer for storing deleter objects locally.</p>
<p>As before, the constructor ties everything together; this must be so since the constructor is the only place in this code where the <code>Deleter</code> type is explicitly known. Our constructor does three things: first, it stores the pointer to the object, as any other smart pointer does. Second, it points the <code>vtable_</code> pointer to an instance of the static <code>vtable</code> variable for the right <code>Deleter</code> type. Finally, it constructs a copy of the deleter in the local buffer. At this point, the <code>Deleter</code> type is erased: nothing in the <code>smartptr</code> object explicitly depends on it.</p>
<p>The deleter, and its true type, come into play again when the destructor of the smart pointer is called and we need to destroy the owned object and the deleter itself. Each of these actions is done by means of an indirect function call. The functions to call are stored in the <code>*vtable_</code> object (just like for polymorphic classes, the correct virtual function overrides are found in the virtual table of function pointers). The deleter is passed into these functions using the address of the buffer – no type information there. But the functions were generated for the specific <code>Deleter</code> type, so they cast the <code>void*</code> buffer address to the right type and use the deleter that was stored in the buffer.</p>
<p>This implementation allows us to have multiple type-erased operations while storing just one <code>vtable_</code> pointer in the object itself.</p>
<p>We can also combine the two approaches: invoke some operations through a virtual table and have <a id="_idIndexMarker289"/>dedicated function pointers for others. Why? Performance, possibly: invoking a function through a virtual table may be a little slower. This needs to be measured for any specific application.</p>
<p>So far, we used type erasure to provide abstract interfaces for very specific behaviors. We already know that type erasure does not need to be so restricted – we have seen the example of the <code>std::function</code>. The last example in this section will be our own generic type-erased function.</p>
<h2 id="_idParaDest-111"><a id="_idTextAnchor300"/>Efficient type erasure</h2>
<p>After the examples <a id="_idIndexMarker290"/>and explanations of the last section, a type-erased function is not going to be much of a challenge. Nonetheless, there is value in showing it here. We are going to demonstrate a very efficient implementation of type erasure (the implementation you find in this book was inspired by the works of Arthur O’Dwyer and Eduardo Magrid).</p>
<p>The template for a generic function looks like this:</p>
<pre class="source-code">
template&lt;typename Signature&gt; class Function;</pre>
<p>Here <code>Signature</code> is something like <code>int(std::string)</code> for a function that takes a string and returns an integer. This function can be constructed to invoke any <code>Callable</code> type as long as an object of this type can be invoked like a function with the specified signature.</p>
<p>We are going to use a local buffer again, but instead of hard-coding it into the class, we will add template parameters to control buffer size and alignment:</p>
<pre class="source-code">
template&lt;typename Signature, size_t Size = 16,
         size_t Alignment = 8&gt; struct Function;</pre>
<p>For ease of coding, it is convenient to unpack the function signature into the argument types <code>Args…</code> and the return type <code>Res</code>. The easiest way to do so is with a class template specialization:</p>
<pre class="source-code">
// Example 09
template&lt;typename Signature, size_t Size = 16,
         size_t Alignment = 8&gt; struct Function;
template&lt;size_t Size, size_t Alignment,
         typename Res, typename... Args&gt;
struct Function&lt;Res(Args...), Size, Alignment&gt; {…};</pre>
<p>Now all that is left is the small matter of the implementation. First, we need the buffer to store the <code>Callable</code> object in it:</p>
<pre class="source-code">
// Example 09
alignas(Alignment) char space_[Size];</pre>
<p>Second, we need <a id="_idIndexMarker291"/>a function pointer <code>executor_</code> to store the address of the static function <code>executor</code> generated from a template with the type of the <code>Callable</code> object:</p>
<pre class="source-code">
// Example 09
using executor_t = Res(*)(Args..., void*);
executor_t executor_;
template&lt;typename Callable&gt;
static Res executor(Args... args, void* this_function) {
  return (*reinterpret_cast&lt;Callable*&gt;(
    static_cast&lt;Function*&gt;(this_function)-&gt;space_))
  (std::forward&lt;Args&gt;(args)...);
}</pre>
<p>Next, in the constructor we must initialize the executor and store the callable in the buffer:</p>
<pre class="source-code">
// Example 09
template &lt;typename CallableArg,
          typename Callable = std::decay_t&lt;CallableArg&gt;&gt;
  requires(!std::same_as&lt;Function, Callable&gt;)
Function(CallableArg&amp;&amp; callable) :
  executor_(executor&lt;Callable&gt;)
{
  ::new (static_cast&lt;void*&gt;(space_))
    Callable(std::forward&lt;CallableArg&gt;(callable));
}</pre>
<p>The constructor has two subtle details. The first is the treatment of the type of the callable: we deduce it as <code>CallableArg</code> but then use it as <code>Callable</code>. This is because <code>CallableArg</code> may be a reference to the type of the callable, such as the function pointer, and we don’t want to construct a copy of a reference. The second is the concept restriction: the <code>Function</code> itself is a callable object with the same signature, but we do not <a id="_idIndexMarker292"/>want this constructor to apply in such a case – that is the job of the copy constructor. If you don’t use C++20, you have to use SFINAE to achieve the same effect (see <a href="B19262_07.xhtml#_idTextAnchor314"><em class="italic">Chapter 7</em></a><em class="italic">, SFINAE, Concepts, and Overload Resolution Management,</em> for details). If you like the concept style, you can emulate it to some degree:</p>
<pre class="source-code">
#define REQUIRES(...) \
  std::enable_if_t&lt;__VA_ARGS__, int&gt; = 0
template &lt;typename CallableArg,
          typename Callable = std::decay_t&lt;CallableArg&gt;,
          REQUIRES(!std::is_same_v&lt;Function, Callable&gt;)&gt;)
Function(CallableArg&amp;&amp; callable) …</pre>
<p>Speaking of copying, our <code>Function</code> is correct only for trivially copyable and trivially destructible <code>Callable</code> types since we did not provide any means to destroy or copy the callable objects stored in the buffer. This still covers a lot of ground, but we can handle non-trivial callables as well using the vtable approach (you will find an example in <a href="B19262_10.xhtml#_idTextAnchor453"><em class="italic">Chapter 10</em></a><em class="italic">, Local </em><em class="italic">Buffer Optimization</em>).</p>
<p>There is one more detail we need to take care of right now: <code>std::function</code> can be default-constructed without any callable; calling such a “null” function throws a <code>std::bad_function_call</code> exception. We can do this too if we initialize the executor to a pre-defined function that does nothing except throw this exception:</p>
<pre class="source-code">
// Example 09
static constexpr Res default_executor(Args..., void*) {
  throw std::bad_function_call();
}
constexpr static executor_t default_executor_ =
  default_executor;
executor_t executor_ = default_executor_;</pre>
<p>Now we have a generic function that is very similar to <code>std::function</code> (or would have been if we <a id="_idIndexMarker293"/>added support for calling member functions, copy and move semantics, and the few missing member functions). It does work the same way:</p>
<pre class="source-code">
Function&lt;int(int, int, int, int)&gt; f =
  [](int a, int b, int c, int d) { return a + b + c + d; };
int res = f(1, 2, 3, 4);</pre>
<p>And just what did that convenience cost us? All performance should be measured, but we can also get some idea by examining the machine code generated by the compiler when it has to call a type-erased function. Here is what it takes to invoke <code>std::function</code> with <a id="_idIndexMarker294"/>the same signature as we just used:</p>
<pre class="source-code">
// Example 09
using Signature = int(int, int, int, int);
using SF = std::function&lt;Signature&gt;;
auto invoke_sf(int a, int b, int c, int d, const SF&amp; f) {
  return f(a, b, c, d);
}</pre>
<p>The compiler (GCC-11 with O3) turns this code into this:</p>
<pre class="source-code">
endbr64
sub    $0x28,%rsp
mov    %r8,%rax
mov    %fs:0x28,%r8
mov    %r8,0x18(%rsp)
xor    %r8d,%r8d
cmpq   $0x0,0x10(%rax)
mov    %edi,0x8(%rsp)
mov    %esi,0xc(%rsp)
mov    %edx,0x10(%rsp)
mov    %ecx,0x14(%rsp)
je     62 &lt;_Z9invoke_sfiiiiRKSt8functionIFiiiiiEE+0x62&gt;
lea    0xc(%rsp),%rdx
lea    0x10(%rsp),%rcx
mov    %rax,%rdi
lea    0x8(%rsp),%rsi
lea    0x14(%rsp),%r8
callq  *0x18(%rax)
mov    0x18(%rsp),%rdx
sub    %fs:0x28,%rdx
jne    67 &lt;_Z9invoke_sfiiiiRKSt8functionIFiiiiiEE+0x67&gt;
add    $0x28,%rsp
retq
callq  67 &lt;_Z9invoke_sfiiiiRKSt8functionIFiiiiiEE+0x67&gt;
callq  6c &lt;_Z9invoke_sfiiiiRKSt8functionIFiiiiiEE+0x6c&gt;</pre>
<p>Now our function:</p>
<pre class="source-code">
// Example 09
using F = Function&lt;Signature&gt;;
auto invoke_f(int a, int b, int c, int d, const F&amp; f) {
  return f(a, b, c, d);
}</pre>
<p>This time, the compiler can do much better:</p>
<pre class="source-code">
endbr64
jmpq   *0x10(%r8)</pre>
<p>What we see here is the so-called tail call: the compiler simply redirects the execution to the actual callable that needs to be invoked. You might ask, doesn’t it always? Not usually: most <a id="_idIndexMarker295"/>function calls are implemented with <code>call</code> and <code>ret</code> instructions. To call a function, its arguments must be stored in a predefined location, then the return address is pushed onto the stack and the execution is transferred to the function entry point by the <code>call</code> instruction. The return instruction <code>ret</code> takes the address off the stack and transfers execution to it. The beauty of the tail call is this: while we want the call to <code>Function</code> to call the original callable in the end, we don’t need the execution to return to the <code>Function</code> object. If there is nothing to do in the <code>Function</code> executor except to return the control to the caller, we might as well simply leave the original return address as-is and have the callable return the control to the right place without an additional indirection. Of course, this assumes that the executor has nothing to do after the call.</p>
<p>There are two key optimizations in our code that enable this compact implementation. The first one is the way we handle the null function: most implementations of <code>std::function</code> initialize the executor to <code>nullptr</code> and do a pointer comparison on every call. We did no such comparison; we always invoke the executor. But then, our executor is never null: unless otherwise initialized, it points to the default executor.</p>
<p>The second optimization is more subtle. You might have noticed that the executor has one more argument than the callable: to call a function with the signature <code>int(int, int)</code> our executor needs the two original function arguments (of course) and the pointer to the callable object (stored in the local buffer in our case). So our executor’s signature is <code>int(int, int, void*)</code>. Why not pass the object first? That’s what the <code>std::function</code> does (at least the one whose assembly we have just seen). The problem is that the original function arguments are also sitting on the stack. Adding one more argument at the end of the stack is easy. But to insert the new first argument, we have to shift all the existing <a id="_idIndexMarker296"/>arguments by one (this is why the code generated for <code>std::function</code> becomes longer the more arguments you have).</p>
<p>As convincing as it sounds, any speculations about performance are hardly worth the electrons expanded to have them written down. Performance must always be measured, and this is the last task left for us to do in this chapter.</p>
<h1 id="_idParaDest-112"><a id="_idTextAnchor301"/>Performance of type erasure</h1>
<p>We are going to measure the performance of a type-erased generic function and a type-erased smart pointer deleter. First, we need the right tools; in thi<a id="_idTextAnchor302"/>s case, a micro-benchmarking library.</p>
<h2 id="_idParaDest-113"><a id="_idTextAnchor303"/>Installing the micro-benchmark library</h2>
<p>In our case, we are interested in the efficiency of very small fragments of code that construct and <a id="_idIndexMarker297"/>delete objects <a id="_idIndexMarker298"/>using different kinds of smart pointers. The appropriate tool for measuring the performance of small fragments of code is a micro-benchmark. There are many micro-benchmark libraries and tools out there; in this book, we will use the Google Benchmark library. To follow along with the examples in this section, you must first download and install the library (to do this, follow the instructions in the <code>Readme.md</code> file). Then you can compile and run the examples. You can build the sample files included with the library to see how to build a benchmark on your particular system. For example, on a Linux machine, the command to build and run a <code>smartptr.C</code> benchmark program might look something like this:</p>
<pre class="source-code">
$CXX smartptr.C smartptr_ext.C -o smartptr -g –O3 \
  -I. -I$GBENCH_DIR/include \
  -Wall -Wextra -Werror -pedantic --std=c++20 \
  $GBENCH_DIR/lib/libbenchmark.a -lpthread -lrt -lm &amp;&amp; \
./smartptr</pre>
<p>Here, <code>$CXX</code> is <a id="_idIndexMarker299"/>your C++ compiler, such <a id="_idIndexMarker300"/>as <code>clang++</code> or <code>g++-11</code>, and <code>$GBENCH_DIR</code> is the di<a id="_idTextAnchor304"/><a id="_idTextAnchor305"/><a id="_idTextAnchor306"/>rectory where the benchmark is installed.</p>
<h2 id="_idParaDest-114"><a id="_idTextAnchor307"/>The overhead of type erasure</h2>
<p>Every benchmark needs a baseline. In our case, the baseline is a raw pointer. We can reasonably <a id="_idIndexMarker301"/>assume that no smart pointer will be able to outperform a raw pointer, and the best smart pointer will have zero overhead. Thus, we begin by measuring how long it takes to construct and destroy a small object using a raw pointer:</p>
<pre class="source-code">
// Example 07
struct deleter {
  template &lt;typename T&gt; void operator()(T* p) { delete p; }
};
deleter d;
void BM_rawptr(benchmark::State&amp; state) {
  for (auto _ : state) {
    int* p = new int(0);
    d(p);
  }
  state.SetItemsProcessed(state.iterations());
}</pre>
<p>A good optimizing compiler can do a great deal of damage to a microbenchmark like this by optimizing the “unnecessary” work (which is, really, all the work done by this program). We can prevent such optimizations by moving the allocation into a different compilation unit:</p>
<pre class="source-code">
// 07_smartptr.C:
void BM_rawptr(benchmark::State&amp; state) {
  for (auto _ : state) {
    int* p = get_raw_ptr()
    d(p);
  }
  state.SetItemsProcessed(state.iterations());
}
// 07_smartptr_ext.C:
int* get_raw_ptr() { return new int(0); }</pre>
<p>If you have a compiler that can do whole program optimizations, turn them off for this benchmark. But don’t turn off the optimization of each file: we want to profile the optimized <a id="_idIndexMarker302"/>code since that’s what the real program will use.</p>
<p>The actual numbers reported by the benchmark depend, of course, on the machine that it runs on. But we are interested in the relative changes, so any machine will do, as long as we stay with it for all measurements:</p>
<pre class="source-code">
Benchmark                      Time
BM_rawptr                   8.72 ns</pre>
<p>We can now verify that <code>std::unique_ptr</code> indeed has zero overhead (as long as we construct and delete objects the same way, of course):</p>
<pre class="source-code">
// smartptr.C
void BM_uniqueptr(benchmark::State&amp; state) {
  for (auto _ : state) {
    auto p(get_unique_ptr());
  }
  state.SetItemsProcessed(state.iterations());
}
// smartptr_ext.C
auto get_unique_ptr() {
  return std::unique_ptr&lt;int, deleter&gt;(new int(0), d);
}</pre>
<p>The result is within the measurement noise from the raw pointer, as can be seen here:</p>
<pre class="source-code">
Benchmark                    <a id="_idTextAnchor308"/>  Time
BM_uniqueptr                8.82 ns</pre>
<p>We can similarly measure the performance of <code>std::shared_ptr</code> as well as different versions of our own smart pointer:</p>
<pre class="source-code">
Benchmark                      Time
BM_sharedptr                22.9 ns
BM_make_sharedptr           17.5 ns
BM_smartptr_te              19.5 ns</pre>
<p>The first line, <code>BM_sharedptr</code>, constructs and deletes a <code>std::shared_ptr&lt;int&gt;</code> with our <a id="_idIndexMarker303"/>custom deleter. The shared pointer is much more expensive than the unique pointer. Of course, there is more than one reason for that—<code>std::shared_ptr</code> is a reference-counting smart pointer, and maintaining a reference count has its own overhead. Using <code>std::make_shared</code> to allocate shared pointers makes its creation and deletion considerably faster, as we can see in the <code>BM_make_sharedptr</code> benchmark, but, to make sure that we measure only the overhead of type erasure, we should implement a type-erased unique pointer. But we already did—it’s our <code>smartptr</code> that we saw in the <em class="italic">How is type erasure implemented in C++?</em> section of this chapter. It has just enough functionality to measure the performance of the same benchmark that we used for all other pointers:</p>
<pre class="source-code">
void BM_smartptr_te(benchmark::State&amp; state) {
  for (auto _ : state) {
    auto get_smartptr_te();
  }
  state.SetItemsProcessed(state.iterations());
}</pre>
<p>Here, <code>smartptr_te</code> stands for the type-erased version of the smart pointer implemented using inheritance. It is slightly faster than <code>std::shared_ptr</code>, proving our suspicion that the latter has more than one source of overhead. Just like <code>std::shared_ptr</code>, deleting <code>smartptr_te</code> touches two memory locations: in our case, it is the object that is being deleted and the deleter (embedded in a polymorphic object). This is exactly what <code>std::make_shared</code> avoids by consolidating both memory locations for <code>std::shared_ptr</code>, and it definitely pays off. We can reasonably assume that the second memory allocation is also the reason for the poor performance of our type-erased smart pointer (approximately twice as slow as the raw or unique pointers). We can avoid this allocation if we use an internal buffer reserved inside the <a id="_idIndexMarker304"/>smart pointer object. We have already seen a local buffer implementation of the smart pointer in the section <em class="italic">Type erasure without memory allocation</em> (in this benchmark, it is renamed as <code>smartptr_te_lb0</code>). Here it is benchmarked under the name <code>BM_smartptr_te_lb0</code>. The version that uses the local buffer when possible but switches to dynamic allocation for larger deleters is named <code>smartptr_te_lb</code> and is slightly slower (<code>BM_smartptr_te_lb</code>):</p>
<pre class="source-code">
Benchmark                      Time
BM_smartptr_te_lb           11.3 ns
BM_smartptr_te_lb0          10.5 ns
BM_smartptr_te_static       9.58 ns
BM_smartptr_te_vtable       10.4 ns</pre>
<p>We have also benchmarked the two type-erased smart pointers implemented without inheritance. The static function version <code>BM_smartptr_te_static</code> is slightly faster than the version that uses the vtable (<code>BM_smartptr_te_vtable</code>). Both of these use local buffers; it should not come as a surprise that the compiler-generated vtable performs exactly as well as the equivalent structure we crafted using static variable templates.</p>
<p>Overall, there is some overhead even for the best type erasure implementation, just under 10 percent in our case. Whether or not this is acceptable, depends on the application.</p>
<p>We should <a id="_idIndexMarker305"/>also measure the performance of the generic type-erased function. We can measure its performance with any callable entity, for example, a lambda expression:</p>
<pre class="source-code">
// Example 09
void BM_fast_lambda(benchmark::State&amp; state) {
  int a = rand(), b = rand(), c = rand(), d = rand();
  int x = rand();
  Function&lt;int(int, int, int, int)&gt; f {
    [=](int a, int b, int c, int d) {
      return x + a + b + c + d; }
  };
  for (auto _ : state) {
    benchmark::DoNotOptimize(f(a, b, c, d));
    benchmark::ClobberMemory();
  }
}</pre>
<p>We can do the same measurement for <code>std::function</code> as well, and compare the results:</p>
<pre class="source-code">
Benchmark                      Time
BM_fast_lambda                 0.884 ns
BM_std_lambda                   1.33 ns</pre>
<p>While it may seem like a great success, this benchmark also hides the warning against going overboard with type erasure. All we have to do to reveal this warning is to measure the performance of the direct call to the same lambda:</p>
<pre class="source-code">
Benchmark                      Time
BM_lambda                      0.219 ns</pre>
<p>How do we reconcile this major slowdown with the minor cost of type erasure we have seen earlier when we were comparing smart and raw pointers?</p>
<p>It is important to pay attention to what is being erased. A well-implemented type-erased interface <a id="_idIndexMarker306"/>can deliver performance very similar to that of a virtual function call. A non-inlined non-virtual function call is going to be slightly faster (in our case, a call that took just under 9 nanoseconds incurred about 10 percent overhead). But a type-erased invocation is always indirect. The one competition it can’t come close to is an inlined function call. This is exactly what we observed when we compared the performance of type-erased and direct invocations of lambdas.</p>
<p>With what we learned about the performance of type erasure, when can we recommend it?</p>
<h1 id="_idParaDest-115"><a id="_idTextAnchor309"/>Guidelines for using type erasure</h1>
<p>What problems does type erasure solve, and when is the cost of the solution acceptable? First of all, it is important to not lose sight of the original goal: type erasure is a design <a id="_idIndexMarker307"/>pattern that helps with the separation of concerns, a very powerful design technique. It is used to create an abstraction for a certain behavior when the implementation of said behavior can be provided by an open set of possibly unrelated types.</p>
<p>It is also used as an implementation technique, mostly to aid in breaking dependencies between compilation units and other program components.</p>
<p>Before we can answer the question “<em class="italic">Is type erasure worth the cost?</em>”, we need to consider the alternatives. In many cases, the alternative is another way to implement the same abstraction: polymorphic class hierarchies or function pointers. The performance of either option is similar to that of the type erasure (in its optimal implementation), so it comes down to convenience and code quality. For a single function, using a type-erased function is easier than developing a new class hierarchy, and more flexible than using a function pointer. For a class with many member functions, it is usually easier and less error-prone to maintain a class hierarchy.</p>
<p>The other possible alternative is to do nothing and allow tighter coupling between parts of the design. The downsides of such a decision are often inversely proportional to its performance benefit: closely coupled parts of the system often need to coordinate implementation to achieve good performance, but they are closely coupled for a reason. Components that are logically well separated should not interact extensively, therefore, the performance of such interaction should not be critical.</p>
<p>What do we do when performance is important but we still need an abstraction? Often, the direct opposite of type erasure: we make everything into templates.</p>
<p>Consider C++20 ranges. On one hand, they are abstract sequences. We can write a function that operates on a range and invoke it with a vector, a deque, a range created from one of these <a id="_idIndexMarker308"/>containers, a subrange of that range, or a filtered view. Anything is a range as long as it can be iterated from <code>begin()</code> to <code>end()</code>. But ranges created from a vector and a deque are different types, even though they are abstractions for sequences, interface-wise. The standard library provides multiple range adapters and range views, and they are all templates. So are the functions operating on the ranges.</p>
<p>Could we implement a type-erased range? Yes, it is not even that hard. We end up with a single type, <code>GenericRange</code>, that can be constructed from a vector, a deque, a list, or anything else that has <code>begin()</code>, <code>end()</code>, and a forward iterator. We also get something that is about twice as slow as most container iterators, except for vectors: their iterators are really just pointers, and vectorizing compilers can do optimizations that speed up the code by at least an order of magnitude. The possibility of such optimizations is lost when we erase the type of the original container.</p>
<p>The C++ designers made the decision that, on the one hand, ranges provide an abstraction for certain behavior and let us separate the interface from the implementation. On the other hand, they were unwilling to sacrifice performance. So they chose to make ranges and all code that operates on them into templates.</p>
<p>As a designer of a software system, you may have to make similar decisions. The general guideline is to prefer tighter coupling for closely related components where such coupling is essential for performance. Conversely, prefer better separation for loosely coupled components whose interaction does not require high efficiency. When in that domain, type erasure should <a id="_idIndexMarker309"/>be considered at least equall<a id="_idTextAnchor310"/>y to polymorphism and other decoupling techniques.</p>
<h1 id="_idParaDest-116"><a id="_idTextAnchor311"/>Summary</h1>
<p>In this chapter, we have, hopefully, demystified the programming technique known as type erasure. We have shown how a program can be written without all of the type information being explicitly visible, and some of the reasons why this may be a desirable implementation. We have also demonstrated that, when implemented efficiently and used wisely, it is a powerful technique that may lead to much simpler and more flexible interfaces and clearly separated components.</p>
<p>The next chapter is a change of direction—we are done with the abstraction idioms for some time and now move on to C++ idioms that facilitate the binding of template components into complex in<a id="_idTextAnchor312"/>teracting systems. We start with the SFINAE idiom.</p>
<h1 id="_idParaDest-117"><a id="_idTextAnchor313"/>Questions</h1>
<ol>
<li value="1">What is type erasure, really?</li>
<li>How is type erasure implemented in C++?</li>
<li>What is the difference between hiding a type behind <code>auto</code> and erasing it?</li>
<li>How is the concrete type reified when the program needs to use it?</li>
<li>What is the performance overhead of type erasure?</li>
</ol>
</div>
</body></html>