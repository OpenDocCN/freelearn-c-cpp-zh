- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Understanding Basic C++ Assumptions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解基本的 C++ 假设
- en: This chapter will briefly identify the basic language syntax, constructs, and
    features of C++, which you are assumed to have from familiarity either with the
    basic syntax of C++, C, Java, or similar languages. These core language features
    will be reviewed concisely. If these basic syntax skills are not familiar to you
    after completing this chapter, please first take the time to explore a more basic
    syntax-driven C++ text before continuing with this book. The goal of this chapter
    is not to teach each of the assumed skills in detail but to briefly provide a
    synopsis of each basic language feature to allow you to quickly recall a skill
    that should already be in your programming repertoire.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将简要介绍 C++ 的基本语言语法、结构和功能，这些您可能通过熟悉 C++、C、Java 或类似语言的基本语法而获得。这些核心语言特性将简要回顾。如果在完成本章后，这些基本语法技能对您来说仍然不熟悉，请在继续阅读本书之前，先花时间探索更基础的语法驱动的
    C++ 文本。本章的目标不是详细教授每个假设的技能，而是简要概述每个基本语言特性，以便您能够快速回忆起您编程库中应该已经掌握的技能。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Basic language syntax
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本语言语法
- en: Basic I/O
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本输入/输出
- en: Control structures, statements, and looping
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制结构、语句和循环
- en: Operators
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运算符
- en: Function basics
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数基础
- en: User defined type basics
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户定义类型基础
- en: Namespace basics
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间基础
- en: By the end of this chapter, you’ll have a succinct review of the very basic
    C++ language skills in which you’re assumed to be proficient. These skills will
    be necessary in order to move forward with the next chapter successfully. Because
    most of these features do not utilize OO features of C++, I will refrain from
    using OO terminology (as much as possible) and will instead introduce appropriate
    OO terminology when we move into the OO sections of this book.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将对您假设熟练掌握的非常基本的 C++ 语言技能有一个简洁的回顾。这些技能对于成功进入下一章是必要的。因为大多数这些特性不使用 C++
    的面向对象特性，所以我会尽量避免使用面向对象的术语（尽可能），当我们进入本书的面向对象部分时，我会引入适当的面向对象术语。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Please ensure that you have a current C++ compiler available; you’ll want to
    try many of the online code examples. Minimally, please download g++ from [https://gcc.gnu.org](https://gcc.gnu.org).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保您有可用的当前 C++ 编译器；您将想要尝试许多在线代码示例。至少，请从 [https://gcc.gnu.org](https://gcc.gnu.org)
    下载 g++。
- en: 'Online code for full program examples can be found in the following GitHub
    URL: [https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter01](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter01).
    Each full program example can be found in the GitHub under the appropriate chapter
    heading (subdirectory) in a file that corresponds to the chapter number, followed
    by a dash, followed by the example number in the chapter at hand. For example,
    the first full program in [*Chapter 1*](B19087_01.xhtml#_idTextAnchor016), *Understanding
    Basic C++ Assumptions*, can be found in the subdirectory `Chapter01` in a file
    named `Chp1-Ex1.cpp` under the aforementioned GitHub directory.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 完整程序示例的在线代码可以在以下 GitHub 网址找到：[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter01](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/tree/main/Chapter01)。每个完整程序示例都可以在
    GitHub 的相应章节标题（子目录）下的文件中找到，该文件以章节编号开头，后面跟着一个连字符，然后是本章中的示例编号。例如，第一完整的程序在 [*第 1
    章*](B19087_01.xhtml#_idTextAnchor016)，*理解基本的 C++ 假设*，可以在上述 GitHub 目录下的 `Chapter01`
    子目录中找到，文件名为 `Chp1-Ex1.cpp`。
- en: 'The **Code in Action** (**CiA**) video for this chapter can be viewed at: [https://bit.ly/3PtOYjf](https://bit.ly/3PtOYjf)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的 **Code in Action** (**CiA**) 视频可以在以下网址查看：[https://bit.ly/3PtOYjf](https://bit.ly/3PtOYjf)
- en: Reviewing basic C++ language syntax
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾基本的 C++ 语言语法
- en: In this section, we will briefly review basic C++ syntax. We’ll assume that
    you are either a C++ programmer with non-OO programming skills, or that you’ve
    programmed in C, Java, or a similar strongly typed checked language with related
    syntax. You may also be a long-standing professional programmer who is able to
    pick up another language’s basics quickly. Let’s begin our brief review.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将简要回顾基本的 C++ 语法。我们假设你是一个具有非面向对象编程技能的 C++ 程序员，或者你已经使用过 C、Java 或类似的有相关语法的强类型检查语言进行编程。你也可能是一位经验丰富的专业程序员，能够快速掌握另一种语言的基础。让我们开始我们的简要回顾。
- en: Comment styles
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注释风格
- en: 'Two styles of comments are available in C++:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 中有可用的两种注释风格：
- en: The `/*   */` style provides for comments spanning multiple lines of code. This
    style may not be nested with other comments of this same style.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/*   */`风格的注释允许跨越多行代码的注释。这种风格不能与相同风格的其它注释嵌套。'
- en: The `//` style of comment provides for a simple comment to the end of the current
    line.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`//`风格的注释允许对当前行的末尾进行简单注释。'
- en: Using the two comment styles together can allow for nested comments, which can
    be useful when debugging code.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用两种注释风格一起可以允许嵌套注释，这在调试代码时可能很有用。
- en: Variable declarations and standard data types
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量声明和标准数据类型
- en: 'Variables may be of any length, and may consist of letters, digits, and underscores.
    Variables are case sensitive and must begin with a letter or an underscore. Standard
    data types in C++ include the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的长度可以是任意的，并且可以由字母、数字和下划线组成。变量是区分大小写的，并且必须以字母或下划线开头。C++中的标准数据类型包括以下内容：
- en: '`int`: To store whole numbers'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`：用于存储整数'
- en: '`float`: To store floating point values'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float`：用于存储浮点值'
- en: '`double`: To store double precision floating point values'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double`：用于存储双精度浮点值'
- en: '`char`: To store a single character'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`char`：用于存储单个字符'
- en: '`bool`: For boolean values of `true` or `false`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool`：用于存储布尔值`true`或`false`'
- en: 'Here are a few straightforward examples using the aforementioned standard data
    types:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些使用上述标准数据类型的简单示例：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Reviewing the previous fragment of code, note that a variable can be assigned
    a literal value, such as `int x = 5;` or that a variable may be assigned the value
    or contents of another variable, such as `int a = x;`. These examples illustrate
    this ability with various standard data types. Note that for the `bool` type,
    the value can be set to `true` or `false`, or to the opposite of one of those
    values using `!` (not).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾之前的代码片段，注意一个变量可以被赋予一个字面量值，例如`int x = 5;`，或者一个变量可以被赋予另一个变量的值或内容，例如`int a =
    x;`。这些示例用各种标准数据类型说明了这种能力。注意，对于`bool`类型，值可以设置为`true`或`false`，或者使用`!`（非）来设置这些值的相反。
- en: Variables and array basics
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量和数组基础
- en: Arrays can be declared of any data type. The array name represents the starting
    address of the contiguous memory associated with the array’s contents. Arrays
    are zero-based in C++, meaning they are indexed starting with array `element[0]`
    rather than array `element[1]`. Most importantly, range checking is not performed
    on arrays in C++; if you access an element outside the size of an array, you are
    accessing memory belonging to another variable, and your code will likely fault
    very soon.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 数组可以声明为任何数据类型。数组名称代表与数组内容关联的连续内存的起始地址。在C++中，数组是零基的，这意味着它们从数组`element[0]`开始索引，而不是从`element[1]`开始。最重要的是，C++中的数组不执行范围检查；如果你访问数组之外的元素，你将访问属于另一个变量的内存，并且你的代码可能会很快出现故障。
- en: 'Let’s review some simple array declarations (some with initialization), and
    an assignment:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一些简单的数组声明（一些带有初始化），以及一个赋值操作：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice that the first array, `name`, contains 10 `char` elements, which are
    initialized to the seven characters in the string literal `"Dorothy"`, followed
    by the null character (`'``\0'`). The array currently has two unused elements
    at the end. The elements in the array can be accessed individually using `name[0]`
    through `name[9]`, as arrays in C++ are zero-based. Similarly, the array above,
    which is identified by the variable `grades`, has 20 elements, none of which are
    initialized. Any array value accessed prior to initialization or assignment can
    contain any value; this is true for any uninitialized variable. Notice that just
    after the array `grades` is declared, its 0th element is assigned a value of `4.0`.
    Finally, notice that the array of `float`, `scores`, is declared and initialized
    with values. Though we could have specified an array size within the `[]` pair,
    we did not – the compiler is able to calculate the size based upon the number
    of elements in our initialization. Initializing an array when possible (even using
    zeros), is always the safest style to utilize.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，第一个数组 `name` 包含 10 个 `char` 元素，这些元素被初始化为字符串字面量 `"Dorothy"` 中的七个字符，后面跟着空字符
    (`'\0'`)。数组目前有两个未使用的元素在末尾。可以使用 `name[0]` 到 `name[9]` 访问数组中的元素，因为在 C++ 中数组是从零开始的。同样，上面由变量
    `grades` 标识的数组有 20 个元素，其中没有任何一个被初始化。在初始化或赋值之前访问的任何数组值都可能包含任何值；这是任何未初始化变量的特性。注意，在声明数组
    `grades` 之后，它的第 0 个元素被赋值为 `4.0`。最后，注意 `float` 类型的数组 `scores` 被声明并初始化了值。尽管我们可以在
    `[]` 对中指定数组大小，但我们没有这样做——编译器能够根据我们初始化中的元素数量来计算大小。尽可能初始化数组（即使使用零），始终是利用最安全的风格。
- en: Arrays of characters are often conceptualized as strings. Many standard string
    functions exist in libraries such as `<cstring>`. Arrays of characters should
    be null-terminated if they are to be treated as strings. When arrays of characters
    are initialized with a string of characters, the null character is added automatically.
    However, if characters are added one by one to the array via assignment, it would
    then be the programmer’s job to add the null character (`'\0'`) as the final element
    in the array.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 字符数组通常被概念化为字符串。在 `<cstring>` 等库中存在许多标准的字符串函数。如果字符数组要被当作字符串处理，它们应该是以空字符终止的。当字符数组被初始化为一个字符串时，空字符会自动添加。然而，如果字符逐个添加到数组中通过赋值，那么添加空字符
    (`'\0'`) 作为数组的最后一个元素就是程序员的职责了。
- en: In addition to strings implemented using arrays of characters (or a pointer
    to characters), there is a safer data type from the C++ Standard Library, `std::string`.
    We will understand the details of this type once we master classes in [*Chapter
    5*](B19087_05.xhtml#_idTextAnchor222), *Exploring Classes in Detail*; however,
    let us introduce `string` now as an easier and less error-prone way to create
    strings of characters. You will need to understand both representations; the array
    of `char` (and pointer to `char`) implementations will inevitably appear in C++
    library and other existing code. Yet you may prefer `string` in new code for its
    ease and safety.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用字符数组（或字符指针）实现的字符串之外，C++ 标准库中还有一个更安全的数据类型，即 `std::string`。一旦我们掌握了类的内容，我们就会了解这个类型的细节；在
    [*第5章*](B19087_05.xhtml#_idTextAnchor222) *详细探索类*；然而，现在让我们先介绍 `string`，作为一种更容易且更不容易出错的方式来创建字符字符串。你需要理解这两种表示；`char`
    数组（和 `char` 指针）的实现不可避免地会出现在 C++ 库和其他现有代码中。然而，你可能会在新代码中更喜欢 `string`，因为它更简单且更安全。
- en: 'Let’s see some basic examples:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些基本的例子：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, the first variable `book1` is declared and initialized to a string literal
    of `"C++ Programming"`; the size of the array will be calculated by the length
    of the quoted string value plus one for the null character (`'\0'`). Next, variable
    `book2` is declared to be an array of `25` characters in length, but is not initialized
    with a value. Next, the function `strcpy()` from `<cstring>` is used to copy the
    string literal `"OO Programming with C++"` into the variable `book2`. Note that
    `strcpy()` will automatically add the null-terminating character to the destination
    string. On the next line, `strcmp()`, also from `<cstring>`, is used to lexicographically
    compare the contents of variables `book1` and `book2`. This function returns an
    integer value, which can be captured in another variable or used in a comparison.
    Lastly, the function `strlen()` is used to count the number of characters in `book2`
    (excluding the null character).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，第一个变量`book1`被声明并初始化为一个字符串字面量`"C++ Programming"`；数组的大小将由引号字符串值的长度加上一个空字符(`'\0'`)来计算。接下来，变量`book2`被声明为一个长度为`25`字符的数组，但没有初始化任何值。接下来，使用来自`<cstring>`的函数`strcpy()`将字符串字面量`"OO
    Programming with C++"`复制到变量`book2`中。注意，`strcpy()`会自动将空终止字符添加到目标字符串中。在下一行，使用来自`<cstring>`的`strcmp()`函数来对变量`book1`和`book2`的内容进行字典序比较。这个函数返回一个整数值，可以被捕获到另一个变量中或用于比较。最后，使用`strlen()`函数来计算`book2`中的字符数（不包括空字符）。
- en: Lastly, notice that `book3` and `book4` are each of type `string`, illustrating
    two different manners to initialize a string. Also notice that `book5` is initialized
    using `book4` as a basis. As we will soon discover, there are many safety features
    built into the `string` class to promote safe string usage. Though we have reviewed
    examples featuring two of several manners to represent strings (a native array
    of characters versus the string class), we will most often utilize `std::string`
    for its safety. Nonetheless, we have now seen various functions, such as `strcpy()`
    and `strlen()`, that operate on native C++ strings (as we will inevitably come
    across them in existing code). It is important to note that the C++ community
    is moving away from native C++ strings – that is, those implemented using an array
    of (or pointer to) characters.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意`book3`和`book4`都是`string`类型，展示了两种不同的初始化字符串的方法。同时请注意`book5`是使用`book4`作为基础进行初始化的。正如我们很快就会发现的，`string`类中内置了许多安全特性，以促进安全的字符串使用。尽管我们已经回顾了几个表示字符串的方法的示例（一个本地的字符数组与字符串类），但我们通常将使用`std::string`，因为它更安全。尽管如此，我们现在已经看到了各种函数，如`strcpy()`和`strlen()`，它们在原生C++字符串上操作（我们不可避免地会在现有代码中遇到它们）。重要的是要注意，C++社区正在远离原生C++字符串——即使用字符数组（或指针）实现的字符串。
- en: 'Now that we have successfully reviewed basic C++ language features such as
    comment styles, variable declarations, standard data types, and array basics,
    let’s move forward to recap another fundamental language feature of C++: basic
    keyboard input and output using the `<iostream>` library.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功回顾了基本的C++语言特性，如注释风格、变量声明、标准数据类型和数组基础，让我们继续回顾C++的另一个基本语言特性：使用`<iostream>`库的基本键盘输入和输出。
- en: Recapping basic I/O
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾基本I/O
- en: In this section, we’ll briefly review simple character-based input and output
    with the keyboard and monitor. Simple manipulators will also be reviewed to both
    explain the underlying mechanics of I/O buffers and to provide basic enhancements
    and formatting.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将简要回顾基于键盘和监视器的简单字符输入和输出。还将回顾简单的操纵器，以解释I/O缓冲区的底层机制，并提供基本的增强和格式化。
- en: The iostream library
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: iostream库
- en: 'One of the easiest mechanisms for input and output in C++ is the use of the
    `<iostream>` library. The header file `<iostream>` contains definitions of data
    types `cin`, `cout`, `cerr`, and `clog`, are incorporated by including the `std`
    namespace. The `<iostream>` library facilitates simple I/O and can be used as
    follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，最容易的输入和输出机制之一是使用`<iostream>`库。头文件`<iostream>`包含了数据类型`cin`、`cout`、`cerr`和`clog`的定义，通过包含`std`命名空间来整合。`<iostream>`库简化了I/O操作，可以使用如下方式：
- en: '`cin` can be used in conjunction with the extraction operator `>>` for buffered
    input'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cin`可以与提取操作符`>>`一起用于缓冲输入'
- en: '`cout` can be used in conjunction with the insertion operator `<<` for buffered
    output'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cout`可以与插入操作符`<<`一起用于缓冲输出'
- en: '`cerr` (unbuffered) and `clog` (buffered) can also be used in conjunction with
    the insertion operator, but for errors'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cerr`（无缓冲）和`clog`（缓冲）也可以与插入操作符一起使用，但用于错误'
- en: 'Let’s review an example showcasing simple I/O:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一个展示简单I/O的示例：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex1.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex1.cpp)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex1.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex1.cpp)'
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'First, we include the `<iostream>` library and indicate that we’re using the
    `std` namespace to gain usage of `cin` and `cout` (more on namespaces later in
    this chapter). Next, we introduce the `main()` function, which is the entry point
    in our application. Here, we declare two variables, `name` and `age`, neither
    of which is initialized. Next, we prompt the user for input by placing the string
    `"Please enter a name and an age: "` in the buffer associated with `cout`. When
    the buffer associated with `cout` is flushed, the user will see this prompt on
    the screen.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '首先，我们包含 `<iostream>` 库并指示我们正在使用 `std` 命名空间以使用 `cin` 和 `cout`（关于命名空间将在本章后面进行更多介绍）。接下来，我们介绍
    `main()` 函数，它是我们应用程序的入口点。在这里，我们声明了两个变量，`name` 和 `age`，它们都没有初始化。接下来，我们通过将字符串 `"Please
    enter a name and an age: "` 放入与 `cout` 相关的缓冲区来提示用户输入。当与 `cout` 相关的缓冲区被刷新时，用户将在屏幕上看到这个提示。'
- en: The keyboard input string is then placed in the buffer associated with `cout`
    using the extraction operator `<<`. Conveniently, one mechanism that automatically
    flushes the buffer associated with `cout` is the use of `cin` to read keyboard
    input into variables, such as seen on the next line, where we read the user input
    into the variables `name` and `age`, respectively.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用提取操作符 `<<` 将键盘输入字符串放入与 `cout` 相关的缓冲区。方便的是，一个自动刷新与 `cout` 相关的缓冲区的机制是使用 `cin`
    将键盘输入读取到变量中，如下一行所示，我们将用户输入读取到变量 `name` 和 `age` 中，分别。
- en: Next, we print out a greeting of `"Hello"` to the user, followed by the name
    entered, followed by an indication of their age, gathered from the second piece
    of user input. The `endl` at the end of this line both places a newline character
    `'\n'` into the output buffer and ensures that the output buffer is flushed –
    more of that next. The `return 0;` declaration simply returns a program exit status
    to the programming shell, in this case, the value `0`. Notice that the `main()`
    function indicates an `int` for a return value to ensure this is possible.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们向用户打印出 `"Hello"` 的问候语，然后是输入的名字，然后是用户年龄的指示，这些是从用户输入的第二部分收集的。此行末尾的 `endl`
    不仅可以向输出缓冲区中放置一个换行符 `'\n'`，而且确保输出缓冲区被刷新——关于这一点将在下一节中详细介绍。`return 0;` 声明只是将程序退出状态返回给编程外壳，在这种情况下，值为
    `0`。请注意，`main()` 函数表明返回值是 `int` 类型，以确保这是可能的。
- en: Basic iostream manipulators
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本iostream操作符
- en: 'Often, it is desirable to be able to manipulate the contents of the buffers
    associated with `cin`, `cout`, and `cerr`. Manipulators allow the internal state
    of these objects to be modified, which affects how their associated buffers are
    formatted and manipulated. Manipulators are defined in the `<iomanip>` header
    file. Common manipulator examples include the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们希望能够操作与 `cin`、`cout` 和 `cerr` 相关的缓冲区的内容。操作符允许修改这些对象的内部状态，从而影响它们相关缓冲区的格式化和操作。操作符在
    `<iomanip>` 头文件中定义。常见的操作符示例包括以下内容：
- en: '`endl`: Places a newline character (`''\n''`) in the buffer associated with
    `cout` then flushes the buffer'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`endl`: 在与 `cout` 相关的缓冲区中放置一个换行符 (`''\n''`) 然后刷新缓冲区'
- en: '`flush`: Clears the contents of the output stream'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flush`: 清除输出流的全部内容'
- en: '`setprecision(int)`: Defines the precision (number of digits) used to output
    floating point numbers'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setprecision(int)`: 定义用于输出浮点数的精度（数字位数）'
- en: '`setw(int)`: Sets the width for input and output'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setw(int)`: 设置输入和输出的宽度'
- en: '`ws`: Removes whitespace characters from the buffer'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ws`: 从缓冲区中移除空白字符'
- en: 'Let’s see a simple example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的示例：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex2.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex2.cpp)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex2.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex2.cpp)'
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, first, notice the inclusion of the `<iomanip>` header file.
    Also, notice that `setw(20)` is used to ensure that we do not overflow the name
    variable, which is only 20 characters long; `setw()` will automatically deduct
    one from the size provided to ensure there is room for the null character. Notice
    that `flush` is used on the second output line – it’s not necessary here to flush
    the output buffer; this manipulator merely demonstrates how a `flush` may be applied.
    On the last output line with `cout`, notice that `setprecision(3)` is used to
    print the floating point `gpa`. Three points of precision account for the decimal
    point plus two places to the right of the decimal. Finally, notice that we add
    the `endl` manipulator to the buffer associated with `cout`. The `endl` manipulator
    will first insert a newline character (`'\n'`) into the buffer and then flush
    the buffer. For performance, if you don’t need a buffer flush to immediately see
    the output, using a newline character alone is more efficient.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，首先，注意 `<iomanip>` 头文件的包含。另外，注意 `setw(20)` 的使用是为了确保我们不会溢出只有 20 个字符长的名称变量；`setw()`
    会自动从提供的大小中减去一个，以确保有空间放置空字符。注意在第二行输出中使用 `flush` – 在这里不需要刷新输出缓冲区；这个转换器仅仅演示了如何应用
    `flush`。在最后一行输出 `cout` 中，注意使用了 `setprecision(3)` 来打印浮点数 `gpa`。三个小数点精度包括小数点及其右边的两个位置。最后，注意我们向与
    `cout` 关联的缓冲区添加了 `endl` 转换器。`endl` 转换器首先在缓冲区中插入一个换行符 (`'\n'`)，然后刷新缓冲区。为了性能，如果你不需要立即看到输出，只使用换行符会更高效。
- en: Now that we have reviewed simple input and output using the `<iostream>` library,
    let’s move forward by briefly reviewing control structures, statements, and looping
    constructs.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经回顾了使用 `<iostream>` 库的简单输入和输出，让我们通过简要回顾控制结构、语句和循环结构来继续前进。
- en: Revisiting control structures, statements, and looping
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾控制结构、语句和循环
- en: C++ has a variety of control structures and looping constructs that allow for
    non-sequential program flow. Each can be coupled with simple or compound statements.
    Simple statements end with a semicolon; more compound statements are enclosed
    in a block of code using a pair of brackets `{}`. In this section, we will be
    revisiting various types of control structures (`if`, `else if`, and `else`),
    and looping constructs (`while`, `do while`, and `for`) to recap simple methods
    for non-sequential program flow within our code.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 具有多种控制结构和循环结构，允许程序流程非顺序执行。每个结构都可以与简单或复合语句结合使用。简单语句以分号结束；更复杂的复合语句则用一对花括号
    `{}` 包围。在本节中，我们将回顾各种控制结构（`if`、`else if` 和 `else`）以及循环结构（`while`、`do while` 和 `for`），以总结代码中非顺序程序流程的简单方法。
- en: Control structures – if, else if, and else
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制结构 – if、else if 和 else
- en: 'Conditional statements using `if`, `else if`, and `else` can be used with simple
    statements or a block of statements. Note that an `if` clause can be used without
    a following `else if` or `else` clause. Actually, `else if` is really a condensed
    version of an `else` clause with a nested `if` clause inside of it. Practically
    speaking, developers flatten the nested use into `else if` format for readability
    and to save excess indenting. Let’s see an example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `if`、`else if` 和 `else` 的条件语句可以与简单语句或语句块一起使用。注意，`if` 子句可以不跟 `else if` 或 `else`
    子句。实际上，`else if` 是一个嵌套了 `if` 子句的 `else` 子句的压缩版本。实际上，开发者将嵌套使用简化为 `else if` 格式以提高可读性和节省多余的缩进。让我们看一个例子：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex3.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex3.cpp)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex3.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex3.cpp)'
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice that in the preceding `else` clause, multiple statements are bundled
    into a block of code, whereas in the `if` and `else if` conditions, only a single
    statement follows each condition. As a side note, in C++, any non-zero value is
    considered to be true. So, for example, testing `if (x)` would imply that `x`
    is not equal to zero – it would not be necessary to write `if (x !=0)`, except
    possibly for readability.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在前面的 `else` 子句中，多个语句被组合成一个代码块，而在 `if` 和 `else if` 条件中，每个条件后只跟一个语句。作为旁注，在
    C++ 中，任何非零值都被视为真。例如，测试 `if (x)` 就意味着 `x` 不等于零 – 不必写 `if (x !=0)`，除非为了可读性。
- en: It is worth mentioning that in C++, it is wise to adopt a set of consistent
    coding conventions and practices (as do many teams and organizations). As a straightforward
    example, the placement of brackets may be specified in a coding standard (such
    as starting the `{` on the same line as the keyword `else`, or on the line below
    the keyword `else` with the number of spaces it should be indented). Another convention
    may be that even a single statement following an `else` keyword be included in
    a block using brackets. Following a consistent set of coding conventions will
    allow your code to be more easily read and maintained by others.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在C++中，采用一套一致的编码约定和实践是明智的（正如许多团队和组织所做的那样）。作为一个简单的例子，括号的放置可能被指定在编码标准中（例如，将`{`与关键字`else`放在同一行，或者放在`else`关键字下面的行上，并指定缩进的空格数）。另一个约定可能是，即使是一个跟随在`else`关键字之后的单条语句，也应该用括号包含在一个块中。遵循一套一致的编码约定将使你的代码更容易被他人阅读和维护。
- en: Looping constructs – while, do while, and for loops
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环结构——while、do while和for循环
- en: 'C++ has several looping constructs. Let’s take a moment to review a brief example
    for each style, starting with the `while` and `do while` loop constructs:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: C++有几种循环结构。让我们花点时间简要回顾每种风格的示例，从`while`和`do while`循环结构开始：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex4.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex4.cpp)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex4.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex4.cpp)'
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With the `while` loop, the condition to enter the loop must evaluate to true
    prior to each entry of the loop body. However, with the `do while` loop, the first
    entry to the loop body is guaranteed – the condition is then evaluated before
    another iteration through the loop body. In the preceding example, both the `while`
    and `do while` loops are executed 10 times, each printing values `0`-`9` for variable
    `i`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`while`循环时，循环体进入之前，条件必须评估为真。然而，使用`do while`循环时，循环体的第一次进入是有保证的——条件是在循环体再次迭代之前评估的。在先前的例子中，`while`和`do
    while`循环都执行了10次，每次为变量`i`打印值`0`到`9`。
- en: 'Next, let’s review a typical `for` loop. The `for` loop has three parts within
    the `()`. First, there is a statement that is executed exactly once and is often
    used to initialize a loop control variable. Next, separated on both sides by semicolons
    in the center of the `()` is an expression. This expression is evaluated each
    time before entering the body of the loop. The body of the loop is only entered
    if this expression evaluates to `true`. Lastly, the third part within the `()`
    is a second statement. This statement is executed immediately after executing
    the body of the loop and is often used to modify a loop control variable. Following
    this second statement, the center expression is re-evaluated. Here is an example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们回顾一下典型的`for`循环。`for`循环在括号内有三个部分。首先，有一个语句只执行一次，通常用于初始化循环控制变量。接下来，在括号中间由分号分隔的表达式。这个表达式在每次进入循环体之前都会被评估。只有当这个表达式评估为`true`时，才会进入循环体。最后，括号内的第三部分是第二个语句。这个语句在执行循环体之后立即执行，通常用于修改循环控制变量。在第二个语句之后，中心表达式会被重新评估。以下是一个例子：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex5.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex5.cpp)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex5.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex5.cpp)'
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we have two `for` loops. Prior to the first loop, variable `i` is declared.
    Variable `i` is then initialized with a value of `0` in statement 1 between the
    loop parentheses `()`. The loop condition is tested, and if `true`, the loop body
    is then entered and executed, followed by statement 2 being executed prior to
    the loop condition being retested. This loop is executed 10 times for `i` values
    `0` through `9`. The second `for` loop is similar, with the only difference being
    variable `j` is both declared and initialized within statement 1 of the loop construct.
    Note that variable `j` only has scope for the `for` loop itself, whereas variable
    `i` has scope of the entire block in which it is declared, from its declaration
    point forward.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有两个 `for` 循环。在第一个循环之前，变量 `i` 被声明。然后，变量 `i` 在循环括号 `()` 中的语句 1 中初始化为 `0`
    的值。测试循环条件，如果为 `true`，则进入并执行循环体，然后执行语句 2，在重新测试循环条件之前。这个循环对于 `i` 的值 `0` 到 `9` 执行
    10 次。第二个 `for` 循环类似，唯一的区别是变量 `j` 在循环结构的语句 1 中被声明和初始化。请注意，变量 `j` 只在 `for` 循环本身的作用域内，而变量
    `i` 的作用域是从其声明点开始到整个声明它的代码块。
- en: 'Let’s quickly see an example using nested loops. The looping constructs can
    be of any type, but in the following, we’ll review nested `for` loops:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看看一个使用嵌套循环的示例。循环结构可以是任何类型，但在以下内容中，我们将回顾嵌套 `for` 循环：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex6.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex6.cpp)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex6.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex6.cpp)'
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, the outer loop will execute ten times with `i` values of `0` through `9`.
    For each value of `i`, the inner loop will execute ten times, with `j` values
    of `0` through `9`. Remember, with `for` loops, the loop control variable is automatically
    incremented with the `i++` or `j++` within the loop construct. Had a `while` loop
    been used, the programmer would need to remember to increment the loop control
    variable in the last line of the body of each such loop.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，外层循环将执行十次，`i` 的值为 `0` 到 `9`。对于每个 `i` 的值，内层循环将执行十次，`j` 的值为 `0` 到 `9`。记住，在使用
    `for` 循环时，循环控制变量会自动在循环结构内部通过 `i++` 或 `j++` 进行递增。如果使用 `while` 循环，程序员需要在每个此类循环体的最后一行记住递增循环控制变量。
- en: Now that we have reviewed control structures, statements, and looping constructs
    in C++, we can move onward by briefly recalling C++’s operators.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经回顾了 C++ 中的控制结构、语句和循环结构，我们可以通过简要回顾 C++ 的运算符继续前进。
- en: Reviewing C++ operators
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾 C++ 运算符
- en: 'Unary, binary, and ternary operators exist in C++. C++ allows operators to
    have different meanings based on the context of usage. C++ also allows programmers
    to redefine the meaning of selected operators when used in the context of at least
    one user defined type. The operators are listed in the following concise list.
    We’ll see examples of these operators throughout the remainder of this section
    and throughout the course. Here is a synopsis of the binary, unary, and ternary
    operators in C++:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 中存在一元、二元和三元运算符。C++ 允许运算符根据使用上下文具有不同的含义。C++ 还允许程序员在至少一个用户定义类型的上下文中重新定义所选运算符的含义。运算符列在以下简洁列表中。我们将在本节剩余部分和整个课程中看到这些运算符的示例。以下是
    C++ 中二元、一元和三元运算符的概述：
- en: '![Figure 1.1 – C++ operators](img/Figure_1.01_B19087.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1 – C++ 运算符](img/Figure_1.01_B19087.jpg)'
- en: Figure 1.1 – C++ operators
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – C++ 运算符
- en: 'In the aforementioned binary operator list, notice how many of the operators
    have “*shortcut*” versions when paired with the assignment operator `=`. For example,
    `a = a * b` can be written equivalently using a shortcut operator `a *= b`. Let’s
    take a look at an example that incorporates an assortment of operators, including
    the usage of a shortcut operator:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述二元运算符列表中，请注意有多少运算符在与赋值运算符 `=` 配对时具有“*快捷*”版本。例如，`a = a * b` 可以使用快捷运算符 `a *=
    b` 等价地编写。让我们看看一个包含各种运算符的示例，包括快捷运算符的使用：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the previous code fragment, notice the use of the shortcut operator `+=`.
    Here, the statement `score += 5;` is equivalent to `score = score + 5;`. Next,
    the unary increment operator `++` is used to increment `score` by 1\. Then we
    see the equality operator `==` to compare `score` with a value of `100`. Finally,
    we see an example of the ternary operator `?:` to replace a simple `if` - `else`
    statement. It is instructive to note that `?:` is not preferred by some programmers,
    yet it is always interesting to review an example of its use.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，注意到了快捷操作符 `+=` 的使用。这里，语句 `score += 5;` 等同于 `score = score + 5;`。接下来，使用一元增量操作符
    `++` 将 `score` 增加 1。然后我们看到等号操作符 `==` 用于比较 `score` 与值 `100`。最后，我们看到三元操作符 `?:` 的一个示例，用于替换简单的
    `if` - `else` 语句。值得注意的是，`?:` 并不是所有程序员的首选，但回顾其使用示例总是很有趣。
- en: Now that we have very briefly recapped the operators in C++, let’s revisit function
    basics.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经简要回顾了 C++ 中的运算符，让我们重新审视函数基础。
- en: Revisiting function basics
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾函数基础
- en: 'A function identifier must begin with a letter or underscore and may also contain
    digits. The function’s return type, argument list, and return value are optional.
    The basic form of a C++ function is as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 函数标识符必须以字母或下划线开头，并且还可以包含数字。函数的返回类型、参数列表和返回值是可选的。C++ 函数的基本形式如下：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let’s review a simple function:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一个简单的函数：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex7.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex7.cpp)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex7.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex7.cpp)'
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the preceding simple example, first, a function `Minimum()` is defined.
    It has a return type of `int` and it takes two integer arguments: formal parameters
    `a` and `b`. In the `main()` function, `Minimum()` is called with actual parameters
    `x` and `y`. The call to `Minimum()` is permitted within the `cout` statement
    because `Minimum()` returns an integer value; this value is passed along to the
    extraction operator (`<<`) in conjunction with printing. In fact, the string `"The
    minimum is: "` is first placed into the buffer associated with `cout`, followed
    by the return value from calling function `Minimum()`. The output buffer is then
    flushed by `endl` (which first places a newline character in the buffer before
    flushing).'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的简单示例中，首先定义了一个函数 `Minimum()`。它返回 `int` 类型，并接受两个整数参数：形式参数 `a` 和 `b`。在 `main()`
    函数中，使用实际参数 `x` 和 `y` 调用了 `Minimum()` 函数。由于 `Minimum()` 返回一个整数值，因此可以在 `cout` 语句中调用它；这个值与打印操作一起传递给提取操作符
    (`<<`)。实际上，字符串 `"The minimum is: "` 首先被放置在 `cout` 相关的缓冲区中，然后是调用函数 `Minimum()`
    返回的值。然后通过 `endl`（在刷新之前先在缓冲区中放置一个换行符）刷新输出缓冲区。'
- en: Notice that the function is first defined in the file and then called later
    in the file in the `main()` function. Strong type checking is performed on the
    call to the function by comparing the parameter types and their usage in the call
    to the function’s definition. What happens, however, when the function call precedes
    its definition? Or if the call to the function is in a separate file from its
    definition?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，函数首先在文件中定义，然后在文件中的 `main()` 函数中稍后调用。在调用函数时，会执行强类型检查，比较参数类型及其在函数定义中的使用。然而，当函数调用在其定义之前发生时会发生什么？或者如果函数的调用与其定义在不同的文件中？
- en: In these cases, the default action is for the compiler to assume a certain *signature*
    to the function, such as an integer return type, and that the formal parameters
    will match the types of arguments in the function call. Often, the default assumptions
    are incorrect; when the compiler then encounters the function definition later
    in the file (or when another file is linked in), an error will be raised indicating
    that the function call and definition do not match.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，编译器默认假设函数具有某种 *签名*，例如整数返回类型，并且形式参数将与函数调用中的参数类型匹配。通常，默认假设是不正确的；当编译器随后在文件中遇到函数定义（或在链接另一个文件时），将引发错误，指示函数调用和定义不匹配。
- en: These issues have historically been solved with a forward declaration of a function
    included at the top of a file where the function will be called. Forward declarations
    consist of the function return type, function name and types, and the number of
    parameters. In C++, a forward declaration has been improved upon and is instead
    known as a function prototype. Since there are many interesting details surrounding
    function prototyping, this topic will be covered in reasonable detail in the next
    chapter.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题在历史上通常通过在文件顶部包含一个函数的前向声明来解决，该声明位于将要调用该函数的位置。前向声明包括函数的返回类型、函数名和类型以及参数数量。在C++中，前向声明得到了改进，现在被称为函数原型。由于函数原型周围有许多有趣的细节，这个主题将在下一章中详细讨论。
- en: Important note
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The specifier `[[nodiscard]]` can optionally be added to precede the return
    type of a function. This specifier is used to indicate that the return value from
    a function must not be ignored – that is, it must be captured in a variable or
    utilized in an expression. Should the function’s return value consequently be
    ignored, a compiler warning will be issued. Note that the `nodiscard` qualifier
    can be added to the function prototype and optionally to the definition (or required
    in a definition if there is no prototype). Ideally, `nodiscard` should appear
    in both locations.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 可以选择性地将`[[nodiscard]]`指定符添加到函数返回类型之前。此指定符用于指示函数的返回值不得被忽略——也就是说，它必须被捕获在变量中或在表达式中使用。如果函数的返回值因此被忽略，编译器将发出警告。请注意，`nodiscard`限定符可以添加到函数原型中，也可以选择性地添加到定义中（如果没有原型，则定义中必须要求）。理想情况下，`nodiscard`应出现在两个位置。
- en: As we move to the object-oriented sections in this book ([*Chapter 5*](B19087_05.xhtml#_idTextAnchor222),
    *Exploring Classes in Detail*, and beyond), we will learn that there are many
    more details and quite interesting features relating to functions. Nonetheless,
    we have sufficiently recalled the basics needed to move forward. Next, let’s continue
    our C++ language review with user defined types.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们转向本书中的面向对象部分（[*第5章*](B19087_05.xhtml#_idTextAnchor222)，*详细探索类*，以及更多），我们将了解到与函数相关的更多细节和非常有趣的功能。尽管如此，我们已经充分回忆了前进所需的基本知识。接下来，让我们继续用用户定义类型来回顾C++语言。
- en: Reviewing user defined type basics
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾用户定义类型的基本知识
- en: C++ offers several mechanisms to create user defined types. Bundling together
    like characteristics into one data type (later, we’ll also add relevant behaviors)
    will form the basis for an object-oriented concept known as encapsulation explored
    in a later section of this text. For now, let’s review the basic mechanisms to
    bundle together only data in `struct`, `class`, and `typedef` (to a lesser extent).
    We will also review enumerated types to represent lists of integers more meaningfully.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: C++提供了几种机制来创建用户定义的类型。将类似特性捆绑成一个数据类型（稍后我们还将添加相关行为）将形成面向对象概念“封装”的基础，该概念将在本文的后续部分探讨。现在，让我们回顾一下将数据捆绑在一起的基本机制，这些机制包括`struct`、`class`和`typedef`（在某种程度上）。我们还将回顾枚举类型，以更有意义地表示整数列表。
- en: struct
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: struct
- en: 'A C++ structure in its simplest form can be used to collect common data elements
    together in a single unit. Variables may then be declared of the composite data
    type. The dot operator is used to access specific members of each structure variable.
    Here is a structure used in its most simple fashion:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: C++结构在其最简单形式下可以用来将常见的数据元素收集到一个单元中。然后可以声明复合数据类型的变量。点操作符用于访问每个结构变量的特定成员。以下是一个以最简单方式使用的结构示例：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex8.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex8.cpp)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex8.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex8.cpp)'
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Stylistically, type names are typically in lowercase when using structs. In
    the preceding example, we declare the user defined type `student` using a `struct`.
    Type `student` has three fields or data members: `name`, `semesterGrades`, and
    `gpa`. In the `main()` function, a variable `s1` of type `student` is declared;
    the dot operator is used to access each of the variable’s data members. Since
    structs are typically not used for OO programming in C++, we’re not going to yet
    introduce significant OO terminology relating to their use. It’s worthy to note
    that in C++, the tag `student` also becomes the type name (unlike in C, where
    a variable declaration would need the word `struct` to precede the type).'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在风格上，当使用 `struct` 时，类型名称通常是小写的。在先前的例子中，我们使用 `struct` 声明用户定义类型 `student`。类型 `student`
    有三个字段或数据成员：`name`、`semesterGrades` 和 `gpa`。在 `main()` 函数中，声明了一个类型为 `student` 的变量
    `s1`；使用点操作符来访问变量的每个数据成员。由于在 C++ 中通常不使用 `struct` 进行面向对象编程，所以我们现在不会介绍与它们使用相关的重大面向对象术语。值得注意的是，在
    C++ 中，标签 `student` 也成为类型名称（与 C 中的不同，在变量声明中需要用 `struct` 来先于类型）。
- en: typedef and “using” alias declaration
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`typedef` 和 “using” 别名声明'
- en: A `typedef` declaration can be used to provide a more mnemonic representation
    for data types. In C++, the relative need for a `typedef` has been eliminated
    in usage with a `struct`. Historically, a `typedef` in C allowed the bundling
    together of the keyword `struct` and the structure tag to create a user defined
    type. However, in C++, as the structure tag automatically becomes the type, a
    `typedef` then becomes wholly unnecessary for a `struct`. Typedefs can still be
    used with standard types for enhanced readability in code, but in this fashion,
    the `typedef` is not being used to bundle together like data elements, such as
    with a `struct`. As a related historical note, `#define` (a preprocessor directive
    and macro replacement) was once used to create more mnemonic types, but `typedef`
    (and `using`) are certainly preferred. It’s worthy to note when viewing older
    code.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`typedef` 声明可以用来为数据类型提供更易记的表示。在 C++ 中，与 `struct` 一起使用时，`typedef` 的相对需求已经被消除。历史上，C
    中的 `typedef` 允许将关键字 `struct` 和结构标签捆绑在一起，以创建用户定义的类型。然而，在 C++ 中，由于结构标签自动成为类型，因此
    `typedef` 对于 `struct` 来说就完全不必要的了。`typedef` 仍然可以与标准类型一起使用，以增强代码的可读性，但以这种方式，`typedef`
    并不是用来捆绑数据元素，例如与 `struct` 一起使用。作为一个相关的历史注释，`#define`（一个预处理器指令和宏替换）曾经被用来创建更易记的类型，但
    `typedef`（和 `using`）无疑是首选。在查看旧代码时，这一点值得注意。'
- en: A `using` statement can be used as an alternative to a simple `typedef` to create
    an alias for a type, known as an `using` statement can also be used to simplify
    more complex types (such as providing an alias for complex declarations when using
    the Standard Template Library or declaring function pointers). The current trend
    is to favor a `using` alias-declaration to a `typedef`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`using` 语句可以用作简单 `typedef` 的替代，以创建类型的别名，称为 `using` 语句也可以用来简化更复杂类型（例如，在使用标准模板库或声明函数指针时提供复杂声明的别名）。当前的趋势是更倾向于使用
    `using` 别名声明而不是 `typedef`。'
- en: 'Let’s take a look at a simple `typedef` compared to a simple `using` alias-declaration:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较一下简单的 `typedef` 与简单的 `using` 别名声明：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the previous declaration, the new type `dollars` can be used interchangeably
    with the type `float`. Likewise, the new alias `money` can also be used interchangeably
    with type `float`. It is not productive to demonstrate the archaic use of `typedef`
    with a structure, so let’s move on to the most used user defined type in C++,
    the `class`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的声明中，新类型 `dollars` 可以与类型 `float` 互换使用。同样，新别名 `money` 也可以与类型 `float` 互换使用。使用
    `typedef` 与结构体进行陈旧的使用并不具有生产力，所以让我们继续到 C++ 中最常用的用户定义类型 `class`。
- en: class
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: class
- en: 'A `class` in its simplest form can be used nearly like a `struct` to bundle
    together related data into a single data type. In [*Chapter 5*](B19087_05.xhtml#_idTextAnchor222),
    *Exploring Classes in Detail*, we’ll see that a `class` is typically also used
    to bundle related functions together with the new data type. Grouping together
    data and behaviors relevant to that data is the basis of encapsulation. For now,
    let’s see a `class` in its simplest form, much like a `struct`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最简单的形式中，`class` 可以几乎像 `struct` 一样用来将相关数据捆绑成一个单一的数据类型。在 [*第5章*](B19087_05.xhtml#_idTextAnchor222)，*详细探索类*，我们将看到
    `class` 通常也用来将相关函数与新数据类型捆绑在一起。将相关数据和与该数据相关的行为组合在一起是封装的基础。现在，让我们看看 `class` 的最简单形式，就像
    `struct` 一样：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex9.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex9.cpp)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex9.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex9.cpp)'
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Notice that the previous code is very similar to that used in the `struct`
    example. The main difference is the keyword `class` instead of the keyword `struct`
    and the addition of the access label `public:` at the beginning of the class definition
    (more on that in [*Chapter 5*](B19087_05.xhtml#_idTextAnchor222)*, Exploring Classes
    in Detail*). Stylistically, the capitalization of the first letter in the data
    type, such as `Student`, is typical for classes. We’ll see that classes have a
    wealth more features and are the building blocks for OO programming. We’ll introduce
    new terminology such as *instance*, to be used rather than *variable*. However,
    this section is only a review of skills assumed, so we’ll need to wait to get
    to the exciting OO features of the language. Spoiler alert: all the wonderful
    things classes will be able to do also applies to structs; however, we’ll see
    that structs stylistically won’t be used to exemplify OO programming.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面的代码与 `struct` 示例中使用的代码非常相似。主要区别在于使用了关键字 `class` 而不是 `struct`，以及在类定义开头添加了访问标签
    `public:`（更多内容请参阅[*第5章*](B19087_05.xhtml#_idTextAnchor222)*，详细探索类*）。从风格上讲，数据类型名称首字母大写，如
    `Student`，是类的典型特征。我们将看到类具有更多功能，是面向对象编程的构建块。我们将介绍新的术语，如 *实例*，而不是 *变量* 来使用。然而，本节仅是对假设技能的回顾，因此我们需要等待了解语言中令人兴奋的面向对象特性。剧透一下：类能够做到的所有奇妙事情也适用于结构体；然而，我们将看到在风格上结构体不会用来举例说明面向对象编程。
- en: enum and strongly-typed enum
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举和强类型枚举
- en: Traditional enumerated types may be used to mnemonically represent lists of
    integers. Unless otherwise initialized, integer values in the enumeration begin
    with zero and increase by one throughout the list. Two enumerated types may not
    utilize the same enumerator names.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 传统枚举类型可以用来记忆性地表示整数列表。除非另有初始化，枚举中的整数值从零开始，并在整个列表中递增。两个枚举类型不能使用相同的枚举值名称。
- en: Strongly-typed enumerated types improve upon traditional enumerated types. Strongly-typed
    enums default to represent lists of integers, but may be used to represent any
    integral type, such as `int`, `short` `int`, `long` `int`, `char`, or `bool`.
    The enumerators are not exported to the surrounding scope, so enumerators may
    be reused between types. Strongly-typed enums allow forward declarations of their
    type (allowing such uses as these types as arguments to functions before the enumerator
    declaration).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 强类型枚举类型在传统枚举类型的基础上进行了改进。强类型枚举默认表示整数列表，但也可以用来表示任何整型，例如 `int`、`short` `int`、`long`
    `int`、`char` 或 `bool`。枚举值不会被导出到周围作用域，因此枚举值可以在不同类型之间重用。强类型枚举允许对其类型的提前声明（允许在枚举声明之前将这些类型用作函数的参数）。
- en: 'Let’s now see an example of traditional enums and strongly-typed enums:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看传统枚举和强类型枚举的例子：
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex10.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex10.cpp)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex10.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex10.cpp)'
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the previous example, the traditional enumerated type `day` has values of
    `0` through `6`, starting with `Sunday`. The traditional enumerated type `workDay`
    has values of `1` through `5`, starting with `Mon`. Notice the explicit use of
    `Mon = 1` as the first item in the enumerated type has been used to override the
    default starting value of `0`. Interestingly, we may not repeat enumerators between
    two enumerated types. For that reason, you will notice that `Mon` is used as an
    enumerator in `workDay` because `Monday` has already been used in the enumerated
    type `day`. Now, when we create variables such as `birthday` or `payday`, we can
    use meaningful enumerated types to initialize or assign values, such as `Monday`
    or `Fri`. As meaningful as the enumerators may be within the code, please note
    that the values when manipulated or printed will be their corresponding integer
    values.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个示例中，传统的枚举类型 `day` 的值从 `0` 到 `6`，以 `Sunday` 开始。传统的枚举类型 `workDay` 的值从 `1`
    到 `5`，以 `Mon` 开始。请注意，枚举类型中显式使用 `Mon = 1` 作为第一个项目已用于覆盖默认的起始值 `0`。有趣的是，我们可以在两个枚举类型之间不重复枚举器。因此，您会注意到
    `Mon` 在 `workDay` 中用作枚举器，因为 `Monday` 已经在枚举类型 `day` 中使用。现在，当我们创建如 `birthday` 或
    `payday` 这样的变量时，我们可以使用有意义的枚举类型来初始化或分配值，如 `Monday` 或 `Fri`。尽管枚举器在代码中可能很有意义，但请注意，当操作或打印时，它们的值将是相应的整数值。
- en: Moving forward to consider the strongly-typed enumerated types in the previous
    example, the `enum` for `WinterHoliday` is defined using a struct. Default values
    for the enumerators are integers, starting with the value of `0` (as with the
    traditional enums). However, notice that the `enum` for `Holiday` specifies the
    enumerators to be of type `short int`. Additionally, we choose to start the first
    item in the enumerated type with value `1`, rather than `0`. Notice when we print
    out the strongly-typed enumerators that we must cast the type using a `static_cast`
    to the type of the enumerator. This is because the insertion operator knows how
    to handle selected types, but these types do not include strongly-typed enums;
    therefore, we cast our enumerated type to a type understood by the insertion operator.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑前一个示例中的强类型枚举类型之后，`WinterHoliday` 的 `enum` 是使用 `struct` 定义的。枚举器的默认值是整数，从值
    `0` 开始（就像传统枚举一样）。然而，请注意，`Holiday` 的 `enum` 指定枚举器为 `short int` 类型。此外，我们选择从值 `1`
    开始枚举类型中的第一个项目，而不是 `0`。请注意，当我们打印强类型枚举器时，我们必须使用 `static_cast` 将类型转换为枚举器的类型。这是因为插入操作符知道如何处理选定的类型，但这些类型不包括强类型枚举；因此，我们将枚举类型转换为插入操作符可以理解的类型。
- en: Now that we have revisited simple user defined types in C++, including `struct`,
    `typedef` (and `using` an alias), `class`, and `enum`, we are ready to move onward
    to reviewing our next language necessity, the `namespace`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经回顾了 C++ 中的简单用户定义类型，包括 `struct`、`typedef`（以及使用别名`using`）、`class` 和 `enum`，我们准备继续前进，复习我们下一个语言必需品，即
    `namespace`。
- en: Recapping namespace basics
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾命名空间基础知识
- en: 'The `namespace` utility was added to C++ to add a scoping level beyond global
    scope to applications. This feature can be used to allow two or more libraries
    to be utilized without concern that they may contain duplicative data types, functions,
    or identifiers. The programmer needs to activate the desired namespace in each
    relevant portion of their application with the keyword `using`. Programmers can
    also create their own namespaces (usually for creating reusable library code)
    and activate each namespace as applicable. In the previous examples, we’ve seen
    the simple use of the `std` namespace to include `cin` and `cout`, which are instances
    of `istream` and `ostream` (whose definitions are found in `<iostream>`). Let’s
    review how we can create namespaces ourselves:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`namespace` 实用工具被添加到 C++ 中，以在全局作用域之外为应用程序添加一个作用域级别。此功能可用于允许使用两个或多个库，而无需担心它们可能包含重复的数据类型、函数或标识符。程序员需要在应用程序的相关部分中使用关键字
    `using` 激活所需的命名空间。程序员还可以创建自己的命名空间（通常用于创建可重用的库代码）并按适用情况激活每个命名空间。在前面的示例中，我们已经看到了
    `std` 命名空间的简单使用，以包含 `cin` 和 `cout`，它们是 `istream` 和 `ostream` 的实例（其定义在 `<iostream>`
    中）。让我们回顾一下我们如何自己创建命名空间：'
- en: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex11.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex11.cpp)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex11.cpp](https://github.com/PacktPublishing/Deciphering-Object-Oriented-Programming-with-CPP/blob/main/Chapter01/Chp1-Ex11.cpp)'
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the second line of the preceding code (which is commented out), we notice
    the keyword `using` applied to indicate that we’d like to use or activate the
    entire `std` namespace. Preferably, on the following two lines of code, we can
    instead activate only the elements in the standard namespace that we will be needing,
    such as `std::cout` or `std::endl`. We can utilize `using` to open existing libraries
    (or individual elements within those libraries) that may contain useful classes;
    the keyword `using` activates the namespace to which a given library may belong.
    Next in the code, a user specified namespace is created called `DataTypes`, using
    the `namespace` keyword. Within this namespace exists a variable `total`, and
    two class definitions: `LinkList` and `Stack`. Following this namespace, a second
    namespace, `AbstractDataTypes`, is created and includes two class definitions:
    `Stack` and `Queue`. Additionally, the namespace `AbstractDataTypes` is augmented
    by a second occurrence of the *namespace* definition in which a variable `total`
    and a class definition for `Tree` are added.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一段代码的第二行（该行已被注释），我们注意到使用了关键字`using`来表示我们希望使用或激活整个`std`命名空间。最好是在接下来的两行代码中，我们只激活我们将需要的标准命名空间中的元素，例如`std::cout`或`std::endl`。我们可以使用`using`来打开可能包含有用类的现有库（或这些库中的单个元素）；关键字`using`激活了可能属于给定库的命名空间。接下来在代码中，创建了一个名为`DataTypes`的用户指定命名空间，使用`namespace`关键字。在这个命名空间中存在一个变量`total`和两个类定义：`LinkList`和`Stack`。在此命名空间之后，创建了一个名为`AbstractDataTypes`的第二个命名空间，并包含两个类定义：`Stack`和`Queue`。此外，通过第二个`namespace`定义的出现，`AbstractDataTypes`命名空间被扩展，添加了一个变量`total`和一个`Tree`类的定义。
- en: In the `main()` function, first, the `AbstractDataTypes` namespace is opened
    with the `using` keyword. This activates all names in this namespace. Next, the
    keyword `using` is combined with the scope resolution operator (`::`) to only
    activate the `LinkList` class definition from the `DataTypes` namespace. Had there
    also been a `LinkList` class within the `AbstractDataType` namespace, the initial
    visible `LinkList` would now be hidden by the activation of `DataTypes::LinkList`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`函数中，首先，使用`using`关键字打开`AbstractDataTypes`命名空间。这激活了该命名空间中的所有名称。接下来，将`using`关键字与作用域解析运算符（`::`）结合使用，仅激活来自`DataTypes`命名空间的`LinkList`类定义。如果`AbstractDataType`命名空间中也有一个`LinkList`类，那么最初可见的`LinkList`现在将被激活`DataTypes::LinkList`所隐藏。
- en: 'Next, a variable of type `LinkList` is declared, whose definition comes from
    the `DataTypes` namespace. A variable of type `Stack` is next declared; though
    both namespaces have a `Stack` class definition, there is no ambiguity since only
    one `Stack` has been activated. Next, we use `cin` to read into `total`, which
    is active from the `AbstractDataTypes` namespace. Lastly, we use the scope resolution
    operator to explicitly read into `DataTypes::total`, a variable that would otherwise
    be hidden. One caveat to note: should two or more namespaces contain the same
    identifier, the one last opened will preside, hiding all previous occurrences.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，声明了一个类型为`LinkList`的变量，其定义来自`DataTypes`命名空间。接下来声明了一个类型为`Stack`的变量；尽管两个命名空间都有一个`Stack`类的定义，但由于只有一个`Stack`被激活，因此没有歧义。接下来，我们使用`cin`将数据读入`total`，该变量来自`AbstractDataTypes`命名空间。最后，我们使用作用域解析运算符显式地将数据读入`DataTypes::total`，否则这个变量将被隐藏。需要注意的是：如果有两个或多个命名空间包含相同的标识符，则最后打开的命名空间将占主导地位，隐藏所有之前的出现。
- en: It is considered good practice to activate only the elements of a namespace
    we wish to utilize. From the aforementioned example, we can see potential ambiguity
    that can otherwise arise.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 被认为是一种良好的实践，只激活我们希望使用的命名空间元素。从上述示例中，我们可以看到可能出现的潜在歧义。
- en: Summary
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we reviewed core C++ syntax and non-OO language features to
    refresh your existing skill set. These features include basic language syntax,
    basic I/O with `<iostream>`, control structures/statements/looping, operator basics,
    function basics, simple user defined types, and namespaces. Most importantly,
    you are now ready to move to the next chapter, in which we will expand on some
    of these ideas with additional language necessities such as `const` qualified
    variables, understanding and using prototypes (including with default values),
    and function overloading.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了核心C++语法和非面向对象语言特性，以更新你的现有技能集。这些特性包括基本语言语法、基本I/O操作与`<iostream>`、控制结构/语句/循环、运算符基础、函数基础、简单的用户定义类型和命名空间。最重要的是，你现在可以进入下一章，我们将通过添加一些额外的语言必要性来扩展这些想法，例如`const`限定变量、理解和使用原型（包括默认值）和函数重载。
- en: The ideas in the next chapter begin to move us closer to our goal for OO programming,
    as many of these aggregate skills are used often and matter of factly as we move
    deeper into the language. It is important to remember that in C++, you can do
    anything, whether you mean to do so or not. There is great power in the language,
    and having a solid base for its many nuances and features is crucial. Over the
    next couple of chapters, the solid groundwork will be laid with an arsenal of
    non-OO C++ skills, so that we may realistically engage OO programming in C++ with
    a high level of understanding and success.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章中的思想开始让我们更接近面向对象编程的目标，因为随着我们深入语言，许多这些聚合技能经常被使用，并且变得自然而然。重要的是要记住，在C++中，无论你是否有意为之，你都可以做任何事情。这个语言拥有巨大的力量，对其众多细微差别和特性的坚实基础至关重要。在接下来的几章中，我们将通过一系列非面向对象的C++技能打下坚实的基础，以便我们能够以高水平和成功率在C++中现实地参与面向对象编程。
- en: Questions
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Describe a situation in which `flush`, rather than `endl`, may be useful for
    clearing the contents of the buffer associated with `cout`.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述一个场景，其中`flush`而不是`endl`可能对清除与`cout`关联的缓冲区内容更有用。
- en: The unary operator `++` can be used as a pre- or post-increment operator, such
    as `i++` or `++i`. Can you describe a situation in which choosing a pre- versus
    post-increment for `++` would have different consequences in the code?
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一元运算符`++`可以用作前增量或后增量运算符，例如`i++`或`++i`。你能描述一个选择前增量或后增量`++`会有不同后果的代码场景吗？
- en: Create a simple program using a `struct` or `class` to make a user defined type
    for `Book`. Add data members for title, author, and number of pages. Create two
    variables of type `Book` and use the dot operator `.` to fill in the data members
    for each such instance. Use `iostreams` to both prompt the user for input values,
    and to print each `Book` instance when complete. Use only features covered in
    this chapter.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`struct`或`class`创建一个简单的程序，定义一个用户自定义类型`Book`。为标题、作者和页数添加数据成员。创建两个`Book`类型的变量，并使用点操作符`.`为每个实例填充数据成员。使用`iostreams`来提示用户输入值，并在完成后打印每个`Book`实例。只使用本章中介绍的功能。
