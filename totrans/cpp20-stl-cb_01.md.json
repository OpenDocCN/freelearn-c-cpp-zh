["```cpp\nprintf(\"Hello, %s\\n\", c_string);\n```", "```cpp\ncout << \"Hello, \" << str << endl;\n```", "```cpp\n    template<typename... Args>\n    string format(string_view fmt, const Args&... args);\n    ```", "```cpp\n    string who{ \"everyone\" };\n    int ival{ 42 };\n    double pi{ std::numbers::pi };\n    format(\"Hello, {}!\\n \", who);   // Hello, everyone!\n    format(\"Integer: {}\\n \", ival); // Integer: 42\n    format(\"π: {}\\n\", pi);          // π: 3.141592653589793\n    ```", "```cpp\n    format(\"Hello {} {}\", ival, who);  // Hello 42 \n                                       // everyone\n    ```", "```cpp\n    format(\"Hello {1} {0}\", ival, who); // Hello everyone 42\n    format(\"Hola {0} {1}\", ival, who);  // Hola 42 everyone\n    ```", "```cpp\n    format(\"{:.<10}\", ival);  // 42........\n    format(\"{:.>10}\", ival);  // ........42\n    format(\"{:.^10}\", ival);  // ....42....\n    ```", "```cpp\n    format(\"π: {:.5}\", pi);  // π: 3.1416\n    ```", "```cpp\ncout << format(\"Hello, {}\", who) << \"\\n\";\n```", "```cpp\nputs(format(\"Hello, {}\", who).c_str());\n```", "```cpp\n#include <format>\n#include <string_view>\n#include <cstdio>\ntemplate<typename... Args>\nvoid print(const string_view fmt_str, Args&&... args) {\n    auto fmt_args{ make_format_args(args...) };\n    string outstr{ vformat(fmt_str, fmt_args) };\n    fputs(outstr.c_str(), stdout);\n} \n```", "```cpp\nprint(\"Hello, {}!\\n\", who);\nprint(\"π: {}\\n\", pi);\nprint(\"Hello {1} {0}\\n\", ival, who);\nprint(\"{:.^10}\\n\", ival);\nprint(\"{:.5}\\n\", pi);\n```", "```cpp\nHello, everyone!\nπ: 3.141592653589793\nHello everyone 42\n....42....\n3.1416\n```", "```cpp\nstruct Frac {\n    long n;\n    long d;\n};\nint main() {\n    Frac f{ 5, 3 };\n    print(\"Frac: {}\\n\", f);    \n}\n```", "```cpp\ntemplate<>\nstruct std::formatter<Frac>\n{\n    template<typename ParseContext>\n    constexpr auto parse(ParseContext& ctx) {\n        return ctx.begin();\n    }\n    template<typename FormatContext>\n    auto format(const Frac& f, FormatContext& ctx) {\n        return format_to(ctx.out(), \"{0:d}/{1:d}\", \n            f.n, f.d);\n    }\n};\n```", "```cpp\nint main() {\n    Frac f{ 5, 3 };\n    print(\"Frac: {}\\n\", f);    \n}\n```", "```cpp\nFrac: 5/3\n```", "```cpp\nconstexpr auto use_string() {\n    string str{\"string\"};\n    return str.size();\n}\n```", "```cpp\nconstexpr auto use_vector() {\n    vector<int> vec{ 1, 2, 3, 4, 5};\n    return accumulate(begin(vec), end(vec), 0);\n}\n```", "```cpp\nconstexpr auto use_vector() {\n    vector<int> vec{ 1, 2, 3, 4, 5};\n    return vec;\n}\n```", "```cpp\nint main() {\n    constexpr auto vec = use_vector();\n    return vec[0];\n}\n```", "```cpp\nint main() {\n    constexpr auto value = use_vector().size();\n    return value;\n}\n```", "```cpp\nint x{ -3 };\nunsigned y{ 7 };\nif(x < y) puts(\"true\");\nelse puts(\"false\");\n```", "```cpp\n#include <utility>\nint main() {\n    int x{ -3 };\n    unsigned y{ 7 };\n    if(cmp_less(x, y)) puts(\"true\");\n    else puts(\"false\");\n}\n```", "```cpp\ncmp_equal(x, y)          // x == y is false\ncmp_not_equal(x, y)      // x != y is true\ncmp_less(x, y)           // x < y is true\ncmp_less_equal(x, y)     // x <= y is true\ncmp_greater(x, y)        // x > y is false\ncmp_greater_equal(x, y)  // x >= y is false\n```", "```cpp\ntemplate< class T, class U >\nconstexpr bool cmp_less( T t, U u ) noexcept\n{\n    using UT = make_unsigned_t<T>;\n    using UU = make_unsigned_t<U>;\n    if constexpr (is_signed_v<T> == is_signed_v<U>)\n        return t < u;\n    else if constexpr (is_signed_v<T>)\n        return t < 0 ? true : UT(t) < u;\n    else\n        return u < 0 ? false : t < UU(u);\n}\n```", "```cpp\nconst int a = 7;\nconst int b = 42;\nstatic_assert(a < b);\n```", "```cpp\nconst int a = 7;\nconst int b = 42;\nstatic_assert((a <=> b) < 0);\n```", "```cpp\nstrong_ordering::equal    // operands are equal\nstrong_ordering::less     // lhs is less than rhs\nstrong_ordering::greater  // lhs is greater than rhs\n```", "```cpp\npartial_ordering::equivalent  // operands are equivelant\npartial_ordering::less        // lhs is less than rhs\npartial_ordering::greater     // lhs is greater than rhs\npartial_ordering::unordered   // if an operand is unordered\n```", "```cpp\nstruct Num {\n    int a;\n    constexpr bool operator==(const Num& rhs) const \n        { return a == rhs.a; }\n    constexpr bool operator!=(const Num& rhs) const\n        { return !(a == rhs.a); }\n    constexpr bool operator<(const Num& rhs) const\n        { return a < rhs.a; }\n    constexpr bool operator>(const Num& rhs) const\n        { return rhs.a < a; }\n    constexpr bool operator<=(const Num& rhs) const\n        { return !(rhs.a < a); }\n    constexpr bool operator>=(const Num& rhs) const\n        { return !(a < rhs.a); }\n};\n```", "```cpp\n#include <compare>\nstruct Num {\n    int a;\n    constexpr Num(int a) : a{a} {}\n    auto operator<=>(const Num&) const = default;\n};\n```", "```cpp\nconstexpr Num a{ 7 };\nconstexpr Num b{ 7 };\nconstexpr Num c{ 42 };\nint main() {\n    static_assert(a < c);\n    static_assert(c > a);\n    static_assert(a == b);\n    static_assert(a <= b);\n    static_assert(a <= c);\n    static_assert(c >= a);\n    static_assert(a != c);\n    puts(\"done.\");\n}\n```", "```cpp\nstruct Nums {\n  int i;\n  char c;\n  float f;\n  double d;\n  auto operator<=>(const Nums&) const = default;\n};\n```", "```cpp\nstruct Frac {\n    long n;\n    long d;\n    constexpr Frac(int a, int b) : n{a}, d{b} {}\n    constexpr double dbl() const {\n        return static_cast<double>(n) / \n          static_cast<double>(d);\n    }\n    constexpr auto operator<=>(const Frac& rhs) const {\n        return dbl() <=> rhs.dbl();\n    };\n    constexpr auto operator==(const Frac& rhs) const {\n        return dbl() <=> rhs.dbl() == 0;\n    };\n};\n```", "```cpp\nconstexpr Frac a(10,15);  // compares equal with 2/3\nconstexpr Frac b(2,3);\nconstexpr Frac c(5,3);\n```", "```cpp\nint main() {\n    static_assert(a < c);\n    static_assert(c > a);\n    static_assert(a == b);\n    static_assert(a <= b);\n    static_assert(a <= c);\n    static_assert(c >= a);\n    static_assert(a != c);\n}\n```", "```cpp\n#include <version>\n#ifdef __cpp_lib_three_way_comparison\n#   include <compare>\n#else\n#   error Spaceship has not yet landed\n#endif\n```", "```cpp\n#if __has_include(<compare>)\n#   include <compare>\n#else\n#   error Spaceship has not yet landed\n#endif\n```", "```cpp\n#include <version>\n#ifdef __cpp_lib_three_way_comparison\n    cout << \"value is \" << __cpp_lib_three_way_comparison \n        << \"\\n\"\n#endif\n```", "```cpp\n$ ./working\nvalue is 201907\n```", "```cpp\ntemplate <typename T>\nT arg42(const T & arg) {\n    return arg + 42;\n}\n```", "```cpp\nconst char * n = \"7\";\ncout << \"result is \" << arg42(n) << \"\\n\";\n```", "```cpp\nResult is ion\n```", "```cpp\ntemplate <typename T>\nrequires Numeric<T>\nT arg42(const T & arg) {\n    return arg + 42;\n}\n```", "```cpp\nerror: 'arg42': no matching overloaded function found\nerror: 'arg42': the associated constraints are not satisfied\n```", "```cpp\n#include <concepts>\ntemplate <typename T>\nconcept Numeric = integral<T> || floating_point<T>;\n```", "```cpp\ntemplate<typename T>\nrequires Numeric<T>\nstruct Num {\n    T n;\n    Num(T n) : n{n} {}\n};\n```", "```cpp\ntemplate<typename T>\nrequires floating_point<T>\nT pi{3.1415926535897932385L};\n```", "```cpp\ntemplate<typename T>\nrequires is_integral<T>::value  // value is bool\nconstexpr double avg(vector<T> const& vec) {\n    double sum{ accumulate(vec.begin(), vec.end(), \n      0.0)\n    };\n    return sum / vec.size();\n}\n```", "```cpp\n    template<typename T>\n    constexpr bool is_gt_byte{ sizeof(T) > 1 };\n    ```", "```cpp\n    template<typename T>\n    concept Numeric = is_gt_byte<T> &&\n        (integral<T> || floating_point<T>);\n    ```", "```cpp\ntemplate<Numeric T>\nT arg42(const T & arg) {\n    return arg + 42;\n}\n```", "```cpp\n    template<typename T>\n    requires Numeric<T>\n    T arg42(const T & arg) {\n        return arg + 42;\n    }\n    ```", "```cpp\n    template<Numeric T>\n    T arg42(const T & arg) {\n        return arg + 42;\n    }\n    ```", "```cpp\n    template<typename T>\n    T arg42(const T & arg) requires Numeric<T> {\n        return arg + 42;\n    }\n    ```", "```cpp\n    auto arg42(Numeric auto & arg) {\n        return arg + 42;\n    }\n    ```", "```cpp\nTemplate <typename T>\nconcept Integral_s = Integral<T> && is_signed<T>::value;\n```", "```cpp\nTemplate <typename T>\nconcept Numeric = integral<T> || floating_point<T>;\n```", "```cpp\ntemplate<typename T>\nconcept is_gt_byte = sizeof(T) > 1;\n```", "```cpp\ntemplate<typename T>\nconcept is_byte = !is_gt_byte<T>;\n```", "```cpp\ntemplate<typename T>\nconcept Numeric = is_gt_byte<T> && \n    (integral<T> || floating_point<T>);\n```", "```cpp\n#ifndef BW_MATH\n#define BW_MATH\nnamespace bw {\n    template<typename T>\n    T add(T lhs, T rhs) {\n        return lhs + rhs;\n    }\n}\n#endif // BW_MATH\n```", "```cpp\n#include \"bw-math.h\"\n#include <format>\n#include <string>\n#include <iostream>\n```", "```cpp\ntemplate<typename T>\nT add(T lhs, T rhs) {\n    return lhs + rhs;\n}\n```", "```cpp\nexport module bw_math;\nexport template<typename T>\nT add(T lhs, T rhs) {\n    return lhs + rhs;\n}\n```", "```cpp\nimport bw_math;\nimport std.core;\nint main() {\n    double f = add(1.23, 4.56);\n    int i = add(7, 42);\n    string s = add<string>(\"one \", \"two\");\n    cout << \n        \"double: \" << f << \"\\n\" <<\n        \"int: \" << i << \"\\n\" <<\n        \"string: \" << s << \"\\n\";\n}\n```", "```cpp\n$ ./module-test\ndouble: 5.79\nint: 49\nstring: one two\n```", "```cpp\nexport module bw_math;\nexport template<typename T>\nT add(T lhs, T rhs) {\n    return lhs + rhs;\n}\n```", "```cpp\nmodule;\n#define SOME_MACRO 42\n#include <stdlib.h>\nexport module bw_math;\n...\n```", "```cpp\n    export int a{7};  // visible to consumer\n    int b{42};        // not visible\n    ```", "```cpp\n    export {\n        int a() { return 7; };     // visible \n        int b() { return 42; };    // also visible\n    }\n    ```", "```cpp\n    export namespace bw {  // all of the bw namespace is visible\n        template<typename T>\n        T add(T lhs, T rhs) {  // visible as bw::add()\n            return lhs + rhs;\n        }\n    }\n    ```", "```cpp\n    namespace bw {  // all of the bw namespace is visible\n        export template<typename T>\n        T add(T lhs, T rhs) {  // visible as bw::add()\n            return lhs + rhs;\n        }\n    }\n    ```", "```cpp\n    import bw_math;\n    int main() {\n        double f = bw::add(1.23, 4.56);\n        int i = bw::add(7, 42);\n        string s = bw::add<string>(\"one \", \"two\");\n    }\n    ```", "```cpp\n    export module bw_math;\n    export import std.core;\n    ```", "```cpp\nimport bw_math;\nusing std::cout, std::string, std::format;\nint main() {\n    double f = bw::add(1.23, 4.56);\n    int i = bw::add(7, 42);\n    string s = bw::add<string>(\"one \", \"two\");\n    cout << \n        format(\"double {} \\n\", f) <<\n        format(\"int {} \\n\", i) <<\n        format(\"string {} \\n\", s);\n}\n```", "```cpp\n    const vector<int> nums{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n    auto result = ranges::take_view(nums, 5);\n    for (auto v: result) cout << v << \" \";\n    ```", "```cpp\n1 2 3 4 5 \n```", "```cpp\nauto result = nums | views::take(5);\nfor (auto v: result) cout << v << \" \";\n```", "```cpp\n1 2 3 4 5 \n```", "```cpp\n    const vector<int> nums{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n    auto result = nums | views::take(5) | \n       views::reverse;\n    ```", "```cpp\n5 4 3 2 1\n```", "```cpp\n    auto result = nums | \n        views::filter([](int i){ return 0 == i % 2; });\n    ```", "```cpp\n2 4 6 8 10\n```", "```cpp\n    auto result = nums | \n        views::transform([](int i){ return i * i; });\n    ```", "```cpp\n1 4 9 16 25 36 49 64 81 100\n```", "```cpp\n    cosnt vector<string>\n    words{ \"one\", \"two\", \"three\", \"four\", \"five\" };\n    auto result = words | views::reverse;\n    ```", "```cpp\nfive four three two one\n```", "```cpp\n    auto rnums = views::iota(1, 10);\n    ```", "```cpp\n1 2 3 4 5 6 7 8 9\n```", "```cpp\nauto rnums = views::iota(1) | views::take(200);\n```", "```cpp\n1 2 3 4 5 6 7 8 9 10 11 12 […] 196 197 198 199 200\n```", "```cpp\nvector<int> vi { 0, 1, 2, 3, 4, 5 };\nranges::take_view tv{vi, 2};\nfor(int i : tv) {\n    cout << i << \" \";\n}\ncout << \"\\n\";\n```", "```cpp\n0 1\n```", "```cpp\nvector<int> vi { 0, 1, 2, 3, 4, 5 };\nauto tview = vi | views::take(2);\nfor(int i : tview) {\n    cout << i << \" \";\n}\ncout << \"\\n\";\n```", "```cpp\n0 1\n```", "```cpp\nvector<int> vi { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\nauto tview = vi | views::reverse | views::take(5);\nfor(int i : tview) {\n    cout << i << \" \";\n}\ncout << \"\\n\";\n```", "```cpp\n9 8 7 6 5\n```", "```cpp\nvector<int> vi { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\nauto even = [](long i) { return 0 == i % 2; };\nauto tview = vi | views::filter(even);\n```", "```cpp\n0 2 4 6 8\n```", "```cpp\nvector<int> vi { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\nauto even = [](int i) { return 0 == i % 2; };\nauto x2 = [](auto i) { return i * 2; };\nauto tview = vi | views::filter(even) | views::transform(x2);\n```", "```cpp\n0 4 8 12 16\n```", "```cpp\nsort(v.begin(), v.end());\n```", "```cpp\nranges::sort(v);\n```", "```cpp\nsort(v.begin() + 5, v.end());\n```", "```cpp\nranges::sort(views::drop(v, 5));\n```", "```cpp\nranges::sort(views::drop(views::reverse(v), 5));\n```", "```cpp\nranges::sort(v | views::reverse | views::drop(5));\n```", "```cpp\nsort(v.rbegin() + 5, v.rend());\n```"]