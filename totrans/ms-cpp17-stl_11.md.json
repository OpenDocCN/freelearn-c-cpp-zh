["```cpp\n    template<class T>\n    class SimplePRNG {\n      uint32_t state = 1;\n    public:\n      static constexpr T min() { return 0; }\n      static constexpr T max() { return 0x7FFF; }\n\n      T operator()() {\n        state = state * 1103515245 + 12345;\n        return (state >> 16) & 0x7FFF;\n      }\n    };\n```", "```cpp\n    #include <stdlib.h>\n\n    int randint0(int x) {\n      return rand() % x;\n    }\n```", "```cpp\n    int heads(int n) {\n      DEBUG_LOG(\"heads\");\n      int result = 0;\n      for (int i = 0; i < n; ++i) {\n        result += (rand() % 2);\n      }\n      return result;\n    }\n\n    void test_heads() {\n      srand(17); // nail down the seed\n      int result = heads(42);\n      assert(result == 27);\n    }\n```", "```cpp\n    std::random_device rd;\n    unsigned int seed = rd();\n    assert(rd.min() <= seed && seed <= rd.max());\n```", "```cpp\n    std::mt19937 g;\n    assert(g.min() == 0 && g.max() == 4294967295);\n\n    assert(g() == 3499211612);\n    assert(g() == 581869302);\n    assert(g() == 3890346734);\n```", "```cpp\n    std::random_device rd;\n\n    uint32_t numbers[624];\n    std::generate(numbers, std::end(numbers), std::ref(rd));\n      // Generate initial state.\n\n    SeedSeq sseq(numbers, std::end(numbers));\n      // Copy our state into a heap-allocated \"seed sequence\".\n\n    std::mt19937 g(sseq);\n      // Initialize a mt19937 generator with our state.\n```", "```cpp\n    template<class It>\n    struct SeedSeq {\n      It begin_;\n      It end_;\n    public:\n      SeedSeq(It begin, It end) : begin_(begin), end_(end) {}\n\n      template<class It2>\n      void generate(It2 b, It2 e) {\n        assert((e - b) <= (end_ - begin_));\n        std::copy(begin_, begin_ + (e - b), b);\n      }\n    };\n```", "```cpp\n    std::random_device rd;\n\n    std::mt19937 g(rd());\n      // 32 bits of randomness ought to be enough for anyone!\n      // ...Right?\n```", "```cpp\n    std::vector<uint32_t> raw(10), filtered(10);\n\n    std::discard_block_engine<std::mt19937, 3, 2> g2;\n    std::mt19937 g1 = g2.base();\n\n    std::generate(raw.begin(), raw.end(), g1);\n    std::generate(filtered.begin(), filtered.end(), g2);\n\n    assert(raw[0] == filtered[0]);\n    assert(raw[1] == filtered[1]);\n      // raw[2] doesn't appear in filtered[]\n    assert(raw[3] == filtered[2]);\n    assert(raw[4] == filtered[3]);\n      // raw[5] doesn't appear in filtered[]\n```", "```cpp\n    using knuth_b = std::shuffle_order_engine<\n      std::linear_congruential_engine<\n        uint_fast32_t, 16807, 0, 2147483647\n      >,\n      256\n    >;\n```", "```cpp\n    std::independent_bits_engine<std::mt19937, 40, uint64_t> g2;\n    std::mt19937 g1 = g2.base();\n\n    assert(g1() == 0xd09'1bb5c); // Take \"1bb5c\"...\n    assert(g1() == 0x22a'e9ef6); // and \"e9ef6\"...\n    assert(g2() == 0x1bb5c'e9ef6); // Paste and serve!\n```", "```cpp\n    using coinflipper = std::independent_bits_engine<\n      std::mt19937, 1, uint8_t>;\n\n    coinflipper onecoin;\n    std::array<int, 64> results;\n    std::generate(results.begin(), results.end(), onecoin);\n    assert((results == std::array<int, 64>{{\n      0,0,0,1, 0,1,1,1, 0,1,1,1, 0,0,1,0,\n      1,0,1,0, 1,1,1,1, 0,0,0,1, 0,1,0,1,\n      1,0,0,1, 1,1,1,0, 0,0,1,0, 1,0,1,0,\n      1,0,0,1, 0,0,0,0, 0,1,0,0, 1,1,0,0,\n    }}));\n\n    std::independent_bits_engine<coinflipper, 32, uint32_t> manycoins;\n    assert(manycoins() == 0x1772af15);\n    assert(manycoins() == 0x9e2a904c);\n```", "```cpp\n    template<class Int>\n    class uniform_int_distribution {\n      using UInt = std::make_unsigned_t<Int>;\n      UInt m_min, m_max;\n    public:\n      uniform_int_distribution(Int a, Int b) :\n        m_min(a), m_max(b) {}\n\n      template<class Gen>\n      Int operator()(Gen& g) {\n        UInt range = (m_max - m_min);\n        assert(g.max() - g.min() >= range);\n        while (true) {\n          UInt r = g() - g.min();\n          if (r <= range) {\n            return Int(m_min + r);\n          }\n        }\n      }\n    };\n```", "```cpp\n    int randint0(int x) {\n      static std::mt19937 g;\n      return std::uniform_int_distribution<int>(0, x-1)(g);\n    }\n```", "```cpp\n    double mean = 161.8;\n    double stddev = 6.8;\n    std::normal_distribution<double> dist(mean, stddev);\n\n      // Initialize our generator.\n    std::mt19937 g(std::random_device{}());\n\n      // Fill a vector with 10,000 samples.\n    std::vector<double> v;\n    for (int i=0; i < 10000; ++i) {\n      v.push_back( dist(g) );\n    }\n    std::sort(v.begin(), v.end());\n\n      // Compare expectations with reality.\n    auto square = [](auto x) { return x*x; };\n    double mean_of_values = std::accumulate(\n      v.begin(), v.end(), 0.0) / v.size();\n    double mean_of_squares = std::inner_product(\n      v.begin(), v.end(), v.begin(), 0.0) / v.size();\n    double actual_stddev =\n      std::sqrt(mean_of_squares - square(mean_of_values));\n    printf(\"Expected mean and stddev: %g, %g\\n\", mean, stddev);\n    printf(\"Actual mean and stddev: %g, %g\\n\",\n           mean_of_values, actual_stddev);\n```", "```cpp\n    template<class Values, class Weights, class Gen>\n    auto weighted_choice(const Values& v, const Weights& w, Gen& g)\n    {\n      auto dist = std::discrete_distribution<int>(\n        std::begin(w), std::end(w));\n      int index = dist(g);\n      return v[index];\n    }\n\n    void test() {\n      auto g = std::mt19937(std::random_device{}());\n      std::vector<std::string> choices =\n        { \"quick\", \"brown\", \"fox\" };\n      std::vector<int> weights = { 1, 7, 2 };\n      std::string word = weighted_choice(choices, weights, g);\n        // 7/10 of the time, we expect word==\"brown\".\n    }\n```", "```cpp\n    int w[] = { 1, 0, 2, 1 };\n    std::discrete_distribution<int> dist(w, w+4);\n    std::vector<double> v = dist.probabilities();\n    assert((v == std::vector{ 0.25, 0.0, 0.50, 0.25 }));\n```", "```cpp\n    template<class Values, class Gen>\n    auto weighted_choice(\n      const Values& v, const std::vector<int>& w,\n      Gen& g)\n    {\n      int sum = std::accumulate(w.begin(), w.end(), 0);\n      int cutoff = std::uniform_int_distribution<int>(0, sum - 1)(g);\n      auto vi = v.begin();\n      auto wi = w.begin();\n      while (cutoff > *wi) {\n        cutoff -= *wi++;\n        ++vi;\n      }\n      return *vi;\n    }\n```", "```cpp\n    std::vector<int> deck(52);\n    std::iota(deck.begin(), deck.end(), 1);\n      // deck now contains ints from 1 to 52.\n\n    std::mt19937 g(std::random_device{}());\n    std::shuffle(deck.begin(), deck.end(), g);\n      // The deck is now randomly shuffled.\n```", "```cpp\n9 different shuffles--out of the 8 Ã— 1067 ways, you can shuffle a deck of cards by hand! If you were shuffling cards for a real casino game, you'd certainly want to use the \"tedious\" method of seeding, described earlier in this chapter, or--simpler, if performance isn't a concern--just use std::random_device directly:\n```", "```cpp\n    std::random_device rd;\n    std::shuffle(deck.begin(), deck.end(), rd);\n    // The deck is now TRULY randomly shuffled.\n```"]