- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Named Arguments, Method Chaining, and the Builder Pattern
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名参数、方法链和构建者模式
- en: 'In this chapter, we are going to examine a solution to a very common C++ problem:
    too many arguments. No, we are not talking about the arguments between C++ programmers,
    such as whether to put curly braces at the end of the line or the start of the
    next one (we have no solution to that problem). This is the problem of C++ functions
    with too many arguments. If you have maintained a large C++ system long enough,
    you have seen it—functions start with simple declarations and, over time, grow
    additional arguments, often defaulted, to support new features.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨一个解决非常常见的 C++ 问题的方案：参数过多。不，我们不是在谈论 C++ 程序员之间的争论，比如是否在行尾或下一行的开头放置花括号（我们对此问题没有解决方案）。这是关于
    C++ 函数参数过多的问题。如果你长时间维护过大型 C++ 系统，你一定见过这种情况——函数开始时声明简单，随着时间的推移，为了支持新功能，常常会添加额外的参数，这些参数通常是默认值。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节将涵盖以下主题：
- en: What are the problems with long function declarations?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长函数声明有什么问题？
- en: What is the alternative?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那么，替代方案是什么呢？
- en: What are the downsides of using the named arguments idiom?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命名参数习语的缺点是什么？
- en: How can the named arguments idiom be generalized?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将命名参数习语进行泛化？
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Here is the example code: [https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter09](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter09).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是示例代码的链接：[https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter09](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-CPP-Second-Edition/tree/master/Chapter09)。
- en: 'Here is the Google Benchmark library: [https://github.com/google/benchmark](https://github.com/google/benchmark)
    (see [*Chapter 4*](B19262_04.xhtml#_idTextAnchor152), *Swap – From Simple to Subtle*,
    for installation instructions).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 Google Benchmark 库的链接：[https://github.com/google/benchmark](https://github.com/google/benchmark)（请参阅[*第
    4 章*](B19262_04.xhtml#_idTextAnchor152)，*从简单到微妙*，获取安装说明）。
- en: The problem with arguments
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 参数的问题
- en: Everyone who has worked on a sufficiently large C++ system at some point have
    had to add arguments to a function. To avoid breaking the existing code, the new
    argument is often given a default value which usually retains the old functionality.
    That works great the first time, is OK the second time, and then one has to start
    counting arguments on every function call. There are other problems with long
    function declarations as well, and if we want a better solution, it is worth our
    time to understand what they are before trying to solve them. We begin this section
    with a more in-depth analysis of the problem before moving on to the solution.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 每个在某个时候参与过足够大的 C++ 系统开发的人都必须向函数添加参数。为了避免破坏现有代码，新参数通常会被赋予一个默认值，这通常保留了旧的功能。第一次这样做效果很好，第二次还可以，然后就必须在每次函数调用时开始计算参数。长函数声明也存在其他问题，如果我们想要更好的解决方案，花时间理解这些问题是值得的。我们在分析问题之后，再继续寻找解决方案。
- en: What’s wrong with many arguments?
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 许多参数有什么问题？
- en: 'Whether the code that passes around a lot of arguments was written this way
    from the start or has grown *organically*, it is fragile and vulnerable to programmer
    mistakes. The main problem is that there are, usually, many arguments of the same
    type, and they can be miscounted. Consider designing a civilization-building game—when
    a player creates a new city, a corresponding object is constructed. The player
    gets to choose what facilities to build in the city, and the game sets the options
    for available resources:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 不论是代码一开始就设计了很多参数，还是随着时间的推移“有机地”增长，它都是脆弱的，容易受到程序员错误的侵害。主要问题是通常有很多相同类型的参数，它们可能会被错误地计数。考虑设计一个文明建设游戏——当玩家创建一个新城市时，会构建一个相应的对象。玩家可以选择在城市建设哪些设施，游戏会设置可用的资源选项：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It looks like we have taken care of everything. To start the game, let’s give
    each player a city with a keep, a guard tower, two buildings, and a guard company:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们已经处理了一切。为了开始游戏，让我们给每个玩家一个带有城堡、瞭望塔、两座建筑和一个卫兵公司的城市：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Can you see the mistake? The compiler, fortunately, can—not enough arguments.
    Since the compiler won’t let us make a mistake here, this is no big deal, we just
    need to add the argument for `has_forest`. Also, let’s say the game placed the
    city near a river, so it has water now:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你能看出错误吗？幸运的是，编译器可以——参数不足。由于编译器不会让我们在这里犯错误，所以这不算什么大问题，我们只需要为`has_forest`添加参数即可。此外，假设游戏将城市放置在河边，所以现在它有水了：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'That was easy ... Oops! We now have the city on the river but without fresh
    water (just what is in that river?). At least the townsfolk won’t starve, thanks
    to the free granary they accidentally received. That error—where the `true` value
    was passed to the wrong parameter—will have to be found during debugging. Also,
    this code is quite verbose, and we may find ourselves typing the same values over
    and over. Maybe the game tries to place cities near the rivers and forests by
    default? OK then:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单……哎呀！现在我们有了河边的城市，但没有淡水（河里到底有什么？）。至少镇民们不会饿肚子，多亏了他们意外获得的免费粮仓。那个错误——将“真实”值传递给了错误的参数——将在调试过程中被发现。此外，这段代码相当冗长，我们可能会发现自己一遍又一遍地输入相同的值。也许游戏默认尝试在河流和森林附近放置城市？那么好吧：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, let’s go back to our first attempt to create a city—it now compiles, one
    argument short, and we are none the wiser that we miscounted the arguments. The
    game is a great success, and, in the next update, we get an exciting new building—a
    temple! We need to add a new argument to the constructor, of course. It makes
    sense to add it after `with_granary`, with all the other buildings, and before
    the terrain features. But then we have to edit every call to the `City` constructor.
    What is worse, it is very easy to make a mistake since the `false` for *no temple*
    looks, to both the programmer and the compiler, exactly like the `false` for *no
    fresh water*. The new argument has to be inserted in the right place, in a long
    line of very similarly-looking values.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到我们第一次尝试创建城市的尝试——现在它编译了，少了一个参数，但我们并没有意识到我们误算了参数。游戏取得了巨大成功，在下一个更新中，我们得到了一个令人兴奋的新建筑——寺庙！当然，我们需要为构造函数添加一个新参数。在`with_granary`之后，与其他所有建筑一起，在地形特征之前添加它是有意义的。但然后我们必须编辑对`City`构造函数的每一个调用。更糟糕的是，由于没有寺庙的`false`对于程序员和编译器来说看起来与没有淡水的`false`完全一样，所以很容易出错。新参数必须插入正确的位置，在一长串看起来非常相似的价值中。
- en: 'Of course, the existing game code works without temples, so they are only needed
    in the new updated code. There is some value in not disturbing existing code unless
    necessary. We could do that if we added the new argument at the end and gave it
    the default value, so any constructor call that was not changed still creates
    the exact same city as before:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，现有的游戏代码没有寺庙也能工作，所以它们只在新更新的代码中需要。在不必要的情况下不干扰现有代码是有价值的。如果我们把新参数加在最后，并给它一个默认值，那么任何未更改的构造函数调用仍然会创建与之前完全相同的城市：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'But now, we let short-term convenience dictate our long-term interface design.
    The parameters no longer have even a logical grouping, and in the long run, mistakes
    are even more likely. Also, we did not fully solve the problem of not updating
    the code that does not need to change—the next release adds a new terrain, desert,
    and with it, another argument:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在，我们让短期便利主导我们的长期界面设计。参数不再有任何逻辑分组，从长远来看，错误的可能性更大。此外，我们没有完全解决不需要更改的代码更新问题——下一个版本添加了新的地形，沙漠，随之而来的是另一个参数：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once started, we have to give default values to all new arguments added at
    the end. Also, in order to create a city in the desert, we also have to specify
    whether it has a temple. There is no logical reason why it has to be this way,
    but we are bound by the process in which the interface evolved. The situation
    gets even worse when you consider that many types we used are convertible to each
    other:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦开始，我们必须为所有在末尾添加的新参数提供默认值。此外，为了在沙漠中创建一个城市，我们还需要指定它是否有寺庙。没有逻辑上的理由说明为什么它必须是这样，但我们受制于界面演变的过程。当你考虑到我们使用的许多类型可以相互转换时，情况变得更糟：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This creates a city with zero guard companies and not whatever the programmer
    expected to disable when they set the third argument to `false`. Even `enum` types
    do not offer full protection. You probably noticed that all new cities usually
    start as a keep, so it would make sense to have that as the default as well:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个没有守卫公司的城市，而不是程序员在将第三个参数设置为`false`时预期的任何其他东西。甚至`enum`类型也不能提供完全的保护。你可能已经注意到，所有新的城市通常都是从城堡开始的，所以将其作为默认值也是有意义的：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we don’t have to type as many arguments and might even avoid some mistakes
    (if you don’t write arguments, you can’t write them in the wrong order). But,
    we can make new ones:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不必输入那么多参数，甚至可能避免一些错误（如果你没有写参数，你就不能写错顺序）。但是，我们也可以创建新的参数：
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The two guard companies we just hired (because the numerical value of `CITADEL`
    is `2`) will find themselves quite short on space in the lowly keep (which we
    intended to change but did not). The `enum class` of C++11 offers better protection
    since each one is a different type without conversions to integers, but the overall
    problem remains. As we have seen, there are two problems with passing a lot of
    values to C++ functions as separate arguments. First, it creates very long declarations
    and function calls that are error-prone. Second, if we need to add a value or
    change the type of a parameter, there is a lot of code to be edited. The solution
    to both problems existed even before C++ was created; it comes from C—use aggregates—that
    is, structs—to combine many values into one parameter.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚雇佣的两个守卫公司（因为`CITADEL`的数值是`2`）将发现自己在这个低级的堡垒（我们本想改变但未改变）的空间非常紧张。C++11的`enum
    class`提供了更好的保护，因为每个都是不同类型，无需转换为整数，但总体问题仍然存在。正如我们所见，将大量值作为单独的参数传递给C++函数有两个问题。首先，它创建了非常长的声明和函数调用，容易出错。其次，如果我们需要添加一个值或更改参数的类型，需要编辑大量的代码。这两个问题的解决方案在C++创建之前就已经存在；它来自C——使用聚合，即结构体——将许多值组合成一个参数。
- en: Aggregate parameters
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 聚合参数
- en: 'With aggregate parameters, we create a struct or a class that contains all
    the values, instead of adding one parameter per value. We don’t have to be limited
    to one aggregate; for example, our city may take several structs, one for all
    terrain-related features that the game sets, and another for all features that
    the player controls directly:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用聚合参数，我们创建一个包含所有值的结构体或类，而不是为每个值添加一个参数。我们不必局限于一个聚合；例如，我们的城市可能需要几个结构体，一个用于游戏设置的所有地形相关特性，另一个用于玩家直接控制的所有特性：
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This solution has many advantages. First of all, assigning values to the arguments
    can be done explicitly, by name, and is very visible (and very verbose):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案有很多优点。首先，可以通过名称显式地分配值，非常明显（并且非常冗长）：
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It is much easier to see what each argument’s value is, and mistakes are much
    less likely (the alternative, aggregate initialization of the structs, only moves
    the problem from one initialization to the other). If we need to add a new feature,
    most of the time we just have to add a new data member to one of the aggregate
    types. Only the code that actually deals with the new argument has to be updated;
    all the functions and classes that simply pass the arguments and forward them
    do not need to change at all. We can even give the aggregate types default values
    to provide default values for all arguments, as we have done in the last example.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 看到每个参数的值要容易得多，错误的可能性也小得多（另一种方法，结构体的聚合初始化，只是将问题从一种初始化移到另一种初始化）。如果我们需要添加一个新特性，大多数情况下我们只需向聚合类型之一添加一个新的数据成员。只有实际处理新参数的代码需要更新；所有只是传递参数并转发它们的函数和类都不需要做任何改变。我们甚至可以为聚合类型提供默认值，为所有参数提供默认值，就像我们在上一个例子中所做的那样。
- en: 'This is, overall, an excellent solution to the problem of functions with many
    parameters. However, it has one drawback: the aggregates have to be explicitly
    created and initialized, line by line. This works out fine for many cases, especially
    when these classes and structs represent state variables that we are going to
    keep for a long time. But, when used purely as parameter containers, they create
    unnecessarily verbose code, starting from the fact that the aggregate variable
    must have a name. We don’t really need that name, as we are going to use it only
    once to call the function, but we have to make one up. It would be tempting just
    to use a temporary variable:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这总的来说是解决具有许多参数的函数问题的优秀解决方案。然而，它有一个缺点：聚合必须显式创建和初始化，一行一行地来。这在许多情况下都很好，特别是当这些类和结构体代表我们将长期保留的状态变量时。但是，当纯粹用作参数容器时，它们会创建不必要的冗长代码，从聚合变量必须有一个名字的事实开始。我们实际上并不需要这个名字，因为我们只用它一次来调用函数，但我们必须想出一个。使用临时变量可能会很有诱惑力：
- en: '[PRE11]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This works, but it brings us full circle, right to where we started; a function
    with a long list of easily mixed Boolean arguments. The fundamental problem we
    encounter is that C++ functions have positional arguments, and we are trying to
    come up with something that would let us specify arguments by name. Aggregate
    objects resolve this problem mostly as a side effect, and if the overall design
    benefits from collecting a group of values into one class, you should certainly
    do it. However, as a solution specifically for the problem of named arguments,
    with no other, more permanent reason to group the values together, they fall short.
    We will now see how this deficiency can be addressed.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以工作，但它又把我们带回到了起点；一个具有长列表的易于混淆的布尔参数的函数。我们遇到的基本问题是C++函数具有位置参数，而我们试图找出一种方法来让我们能够通过名称指定参数。聚合对象主要作为副作用解决了这个问题，并且如果整体设计从将一组值收集到一个类中受益，你当然应该这样做。然而，作为一个专门针对命名参数问题的解决方案，没有其他更持久的理由将值组合在一起，它们就不够用了。我们现在将看到如何解决这个问题。
- en: Named arguments in C++
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C++中的命名参数
- en: We have seen how collecting logically related values into aggregate objects
    gives us a side benefit; we can pass these values to functions and access them
    by name instead of by their order in a long list. The key is *logically related*,
    though; aggregating values for no reason other than they happen to be used together
    in one function call creates unnecessary objects with names we would rather not
    have to invent. We need a way to create temporary aggregates, preferably without
    explicit names or declarations. We have a solution to this problem, and had it
    for a long time in C++; all it needs is a fresh look from a different perspective,
    which we are about to take now.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何将逻辑上相关的值收集到聚合对象中给我们带来一个副作用；我们可以将这些值传递给函数，并通过名称而不是通过长列表中的顺序来访问它们。关键是*逻辑上相关*；除了它们碰巧在单个函数调用中一起使用之外，没有其他原因将值聚合在一起会创建不必要的对象，我们宁愿不发明这些名称。我们需要一种方法来创建临时聚合，最好是不需要显式的名称或声明。我们有一个解决方案来解决这个问题，C++中已经存在很长时间了；它只需要从不同角度的新视角，这正是我们现在要做的。
- en: Method chaining
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法链式调用
- en: 'Method chaining is a borrowed C++ technique; it originates in **Smalltalk**.
    Its main purpose is to eliminate unnecessary local variables. You have used method
    chaining already, although you may not have realized it. Consider this code that
    you have probably written many times:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 方法链式调用是一种从C++借用的技术；它起源于**Smalltalk**。其主要目的是消除不必要的局部变量。你可能已经使用了方法链式调用，尽管你可能没有意识到。考虑以下你可能多次编写过的代码：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The last line invoked the inserter operator `<<` twice. The first time it is
    invoked on the object on the left-hand side of the operator, `std::cout`. What
    object is the second call on? In general, the operator syntax is just a way to
    call a function named `operator<<()`. Usually, this particular operator is a non-member
    function, but the `std::ostream` class has several member function overloads as
    well, and one of them is for `int` values. So, the last line really is this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行调用了插入操作符`<<`两次。第一次是在操作符左侧的对象上调用，即`std::cout`。第二次调用是在什么对象上？一般来说，操作符语法只是调用一个名为`operator<<()`的函数的一种方式。通常，这个特定的操作符是一个非成员函数，但`std::ostream`类也有几个成员函数重载，其中之一是用于`int`值的。所以，最后一行实际上是这样的：
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The second call to `operator<<()` is done on the result of the first one. The
    equivalent C++ code is this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次调用`operator<<()`是在第一次调用的结果上进行的。等效的C++代码如下：
- en: '[PRE14]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is the method chaining—the call to one method function returns the object
    on which the next method should be called. In the case of `std::cout`, the member
    `operator<<()` returns a reference to the object itself. By the way, the non-member
    `operator<<()` does the same, only instead of the implicit argument `this`, it
    has the stream object as an explicit first argument. Now, we can use method chaining
    to eliminate the explicitly named argument object.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是方法链式调用——对一个方法函数的调用返回下一个方法应该调用的对象。在`std::cout`的情况下，成员`operator<<()`返回对对象本身的引用。顺便说一下，非成员`operator<<()`做的是同样的事情，只是它没有隐含的参数`this`，而是将流对象作为显式的第一个参数。现在，我们可以使用方法链式调用消除显式命名的参数对象。
- en: Method chaining and named arguments
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法链式调用和命名参数
- en: As we have seen before, the aggregate argument objects work well when they are
    not used mainly to hold arguments; if we need an object to hold the state of the
    system, and we build it over time and keep it for a long time, we can also pass
    this object as a single argument to any function that needs this state. It’s creating
    aggregates for just one function call that we have a problem with. On the other
    hand, we do not like to write functions with many arguments either. This is particularly
    true for functions that usually have most arguments left as default, with only
    a few changes. Going back to our game, let’s say that each day, game time, is
    processed by a function call.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，当聚合参数对象不是主要用于持有参数时，它们工作得很好；如果我们需要一个对象来持有系统的状态，并且我们随着时间的推移构建它并长时间保留它，我们也可以将这个对象作为单个参数传递给任何需要这个状态的函数。我们遇到的问题是只为单个函数调用创建聚合对象。另一方面，我们也不喜欢编写带有许多参数的函数。这尤其适用于通常大多数参数都设置为默认值，只有少数参数发生变化的函数。回到我们的游戏，假设每天的游戏时间都通过一个函数调用进行处理。
- en: 'The function is called, once per game day, to advance the city through the
    day and process the consequences of various random events the game can generate:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数在每个游戏日被调用一次，以推进城市的一天，并处理游戏可以生成的各种随机事件的后果：
- en: '[PRE15]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: A lot of different events can happen over time, but rarely more than one happens
    on any particular day. We set all arguments to false by default, but this does
    not really help; there is no particular order to these events, and if the festival
    happens, all the previous arguments must be specified even though they are still
    equal to their default values.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在一段时间内可能会发生很多不同的事件，但很少有一天会同时发生多于一个事件。我们默认将所有参数设置为`false`，但这并没有真正帮助；这些事件没有特定的顺序，如果节日发生，即使它们仍然等于它们的默认值，也必须指定所有之前的参数。
- en: 'An aggregate object helps a lot, but we need to create and name it:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一个聚合对象非常有帮助，但我们需要创建并命名它：
- en: '[PRE16]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We would like to create a temporary `DayEvents` object just for the call to
    `City::day()`, but we need a way to set its data members. This is where method
    chaining comes in:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望只为`City::day()`的调用创建一个临时的`DayEvents`对象，但我们需要一种方法来设置其数据成员。这正是方法链发挥作用的地方：
- en: '[PRE17]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The default constructor constructs an unnamed temporary object. On that object,
    we invoke the `SetFire()` method. It modifies the object and returns a reference
    to itself. We pass the created and modified temporary object to the `day()` function,
    which processes the events of the day, displays the updated graphics of the city
    in flames, plays the sound of fire, and updates the status of the city to reflect
    that some buildings were damaged by fire.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 默认构造函数构建一个未命名的临时对象。在这个对象上，我们调用`SetFire()`方法。它修改对象并返回对该对象的引用。我们将创建并修改后的临时对象传递给`day()`函数，该函数处理当天的事件，显示城市被火焰更新的图形，播放火灾的声音，并更新城市的状态以反映一些建筑被火灾损坏。
- en: 'Since each of the `Set()` methods return a reference to the same object, we
    can invoke more than one in a method chain, to specify multiple events. Also,
    the `Set()` methods can take arguments, of course; for example, instead of `SetFire()`
    that always changes the fire event to `true` from its default `false`, we could
    have a method that can set the event flag either way:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个`Set()`方法都返回对同一对象的引用，我们可以在方法链中调用多个方法来指定多个事件。当然，`Set()`方法也可以接受参数；例如，我们可以有一个方法可以设置事件标志，无论是从默认的`false`变为`true`，还是从`true`变为`false`：
- en: '[PRE18]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Today is the market day in our city, which coincides with a major festival,
    so the king hired an extra guard company in addition to the two already stationed
    in the city:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 今天是我们城市的集市日，恰好与一个大型节日重合，所以国王除了已经驻扎在城里的两个卫兵公司外，还雇佣了一个额外的卫兵公司：
- en: '[PRE19]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that we did not have to specify anything for all the events that did not
    happen. We now have true named arguments; when we call a function, we pass the
    arguments in any order, by name, and we do not need to explicitly mention any
    arguments we wish to leave at their default values. This is the C++ named arguments
    idiom. A call with named arguments is, of course, more verbose than a call with
    positional arguments; each argument must have the name explicitly written. That
    was the point of the exercise. On the other hand, we come out ahead if there is
    a long list of default arguments we did not have to change. One question that
    could be asked is that of performance—we have a lot of extra function calls, the
    constructor, and a `Set()` call for every named argument, and that must cost something.
    Let’s find out exactly what it costs.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于所有没有发生的事件，我们无需指定任何内容。我们现在有了真正的命名参数；当我们调用一个函数时，我们可以按任何顺序、按名称传递参数，并且我们不需要明确提及任何希望保留为默认值的参数。这是C++的命名参数习语。使用命名参数的调用当然比使用位置参数的调用更冗长；每个参数都必须明确写出名称。这正是练习的目的。另一方面，如果我们有一长串不需要更改的默认参数，我们就会处于优势地位。可能有人会问的一个问题是性能——我们有很多额外的函数调用，构造函数，以及每个命名参数的`Set()`调用，这肯定要花费一些代价。让我们找出它到底花费了多少代价。
- en: Performance of the named arguments idiom
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名参数习语的性能
- en: There is definitely more going on with the named argument call, as more functions
    are called. On the other hand, the function calls are really simple and, if they
    are defined in the header file, and the entire implementation is visible to the
    compiler, there is no reason for the compiler not to inline all the `Set()` calls
    and eliminate the unnecessary temporary variables. With good optimization, we
    could expect similar performance from the named arguments idiom and the explicitly
    named aggregate object.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在命名参数调用中发生的事情更多，因为调用了更多的函数。另一方面，函数调用非常简单，如果它们在头文件中定义，并且整个实现对编译器可见，那么编译器没有理由不内联所有的`Set()`调用并消除不必要的临时变量。通过良好的优化，我们可能期望命名参数习语和显式命名的聚合对象有相似的性能。
- en: 'The appropriate tool to measure the performance of a single function call is
    the micro benchmark. We use the Google microbenchmark library for this purpose.
    While the benchmarks are usually written in one file, we need another source file
    if we want the function we call to be external, not inlined. On the other hand,
    the `Set()` methods should definitely be inlined, so they should be defined in
    the header file. The second source file should contain the definition of the function
    we are calling with named or positional arguments. Both files are combined at
    link time:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 测量单个函数调用性能的适当工具是微基准测试。我们使用Google微基准测试库来完成这个目的。虽然基准测试通常写在单个文件中，但如果我们希望我们调用的函数是外部的，而不是内联的，我们需要另一个源文件。另一方面，`Set()`方法应该肯定被内联，因此它们应该在头文件中定义。第二个源文件应包含我们使用命名或位置参数调用的函数的定义。这两个文件在链接时合并：
- en: '[PRE20]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can compare the positional arguments, the named arguments, and the arguments
    aggregate. The result will depend on the type and number of arguments. For example,
    for a function with four Boolean arguments, we can compare these calls:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将位置参数、命名参数和聚合参数进行比较。结果将取决于参数的类型和数量。例如，对于一个有四个布尔参数的函数，我们可以比较以下调用：
- en: '[PRE21]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The performance measured by the benchmark will depend greatly on the compiler
    and on the options that control optimization. For example, these numbers were
    collected on GCC12 with -O3:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试测量的性能将极大地取决于编译器和控制优化的选项。例如，这些数字是在GCC12上使用-O3收集的：
- en: '[PRE22]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: There is no noticeable performance hit for the explicitly named aggregate object
    that the compiler was able to inline and optimize away. The named and positional
    arguments perform similarly. Note that the performance of the function calls depends
    greatly on what else is going on in the program at the same time, since the arguments
    are passed on registers, and register availability is affected by the context.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于编译器能够内联和优化的显式命名的聚合对象，没有明显的性能损失。命名参数和位置参数的表现相似。请注意，函数调用的性能很大程度上取决于程序同时进行的其他操作，因为参数是在寄存器中传递的，而寄存器的可用性受上下文的影响。
- en: 'In our benchmark, we have used compile-time constants as argument values. This
    is not uncommon, especially for arguments that specify certain options—very often,
    at each call site, many of the options will be static, unchanging (the values
    are different in other places in the code where the same function is called, but
    on this line, many of the values are fixed at compile time). For example, if we
    have a special code branch to process natural disasters in our game, the ordinary
    branch will always call our day simulation with a flood, fire, and other disaster
    flags set to `false`. But, just as often the arguments are computed at runtime.
    How does this affect the performance? Let’s create another benchmark where the
    values of the arguments are retrieved, for example, from a vector:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的基准测试中，我们使用了编译时常量作为参数值。这并不罕见，特别是对于指定某些选项的参数——在每次调用点，许多选项将是静态的、不变的（在其他代码中调用相同函数的地方，这些值是不同的，但在这行代码中，许多值在编译时就已经固定）。例如，如果我们有一个特殊的代码分支来处理游戏中的自然灾害，普通分支将始终调用我们的日模拟，将洪水、火灾和其他灾害标志设置为`false`。但是，同样经常的是，参数是在运行时计算的。这如何影响性能？让我们创建另一个基准测试，其中参数值是从向量中检索的，例如：
- en: '[PRE23]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'By the way, it would be ill-advised to shorten the preceding code in this manner:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，以这种方式缩短前面的代码是不明智的：
- en: '[PRE24]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The reason is that the order in which the arguments are evaluated is undefined,
    so it is arbitrary which of the `i++` calls is executed first. If `i` starts from
    `0`, this call may end up calling `Positional(v[0], v[1], v[2], v[3])` or `Positional(v[3],
    v[2], v[1], v[0])` or any other permutation.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是参数评估的顺序是未定义的，所以哪个`i++`调用首先执行是任意的。如果`i`从`0`开始，这个调用最终可能调用`Positional(v[0],
    v[1], v[2], v[3])`或`Positional(v[3], v[2], v[1], v[0])`或任何其他排列。
- en: 'On the same compiler and hardware, we now get different numbers:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在相同的编译器和硬件上，我们现在得到不同的数字：
- en: '[PRE25]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We can see from the results that the compiler completely eliminated the overhead
    of the unnamed temporary object (or the named aggregate) and generated similarly
    performing code for all three ways to pass arguments into the function. In general,
    the result of the compiler optimizations is difficult to predict. For example,
    CLANG produces significantly different results (named argument calls are faster
    when most parameters are compile-time constants but slower when they are run-time
    values).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 从结果中我们可以看到，编译器完全消除了未命名临时对象（或命名聚合）的开销，并为将参数传递到函数的这三种方式生成了性能相似的代码。一般来说，编译器优化的结果难以预测。例如，CLANG产生的结果显著不同（当大多数参数是编译时常量时，命名参数调用更快，但当它们是运行时值时则较慢）。
- en: The benchmark does not favor any particular argument-passing mechanism. We can
    say that the named arguments idiom performs no worse than an explicitly named
    aggregate object or the equivalent positional parameters, at least, if the compiler
    were able to eliminate the unnamed temporary especially. On some compilers, the
    named arguments may be faster if the function has many arguments. If the optimization
    does not happen, the call may be a bit slower. On the other hand, in many cases
    the performance of the function call itself is not critical; for example, our
    cities are constructed only when the player builds one, a few times during the
    game. The day events are processed once per game day, which probably takes more
    than a few seconds of real-time, not least so the player can enjoy interacting
    with the game. On the other hand, the functions that are repeatedly called in
    performance-critical code should be inlined whenever possible, and we can expect
    better optimizations for argument passing in this case as well. Overall, we can
    conclude that, unless the performance of the particular function call is critical
    for program performance, one should not be concerned with the overhead of named
    arguments. For performance-critical calls, performance should be measured on a
    case-by-case basis, and it is possible for named arguments to be faster than positional
    ones.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试并不倾向于任何特定的参数传递机制。我们可以说，命名参数习语的表现不会比显式命名的聚合对象或等效的位置参数差，至少，如果编译器能够消除未命名的临时对象的话。在某些编译器上，如果函数有很多参数，命名参数可能会更快。如果优化没有发生，调用可能会稍微慢一些。另一方面，在许多情况下，函数调用的性能本身并不关键；例如，我们的城市只有在玩家建造时才会构建，游戏中的几次构建。每日事件在游戏日中只处理一次，这可能会占用几秒钟的真实时间，至少这样玩家可以享受与游戏的互动。另一方面，在性能关键代码中反复调用的函数应该尽可能内联，我们也可以期待在这种情况下参数传递的优化会更好。总的来说，我们可以得出结论，除非特定函数调用的性能对程序性能至关重要，否则不应该担心命名参数的开销。对于性能关键的调用，应该根据具体情况测量性能，并且命名参数可能比位置参数更快。
- en: General method chaining
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一般方法链
- en: Applications of method chaining in C++ are not limited to argument passing (we
    have already seen another application, although a well-hidden one, in the form
    of streaming I/O). For use in other contexts, it is helpful to consider some more
    general forms of method chaining.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 中方法链的应用不仅限于参数传递（我们已经在流式 I/O 的形式中看到了另一个应用，尽管它隐藏得很好）。在其他上下文中使用时，考虑一些更通用的方法链形式是有帮助的。
- en: Method chaining versus method cascading
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法链与方法级联
- en: 'The term *method cascading* is not often found in the context of C++, and for
    a good reason—C++ does not really support it. Method cascading refers to calling
    a sequence of methods on the same object. For example, in *Dart*, where method
    cascading is supported explicitly, we can write the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: “方法级联”这个术语在 C++ 的上下文中并不常见，而且有很好的理由——C++ 并不支持它。方法级联指的是在同一个对象上调用一系列方法。例如，在支持方法级联的
    *Dart* 中，我们可以写出以下代码：
- en: '[PRE26]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This code first calls `SetA()` on the opt object, then calls `SetB()` on the
    same object. The equivalent code is this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码首先在 opt 对象上调用 `SetA()`，然后在该同一对象上调用 `SetB()`。等效的代码是这样的：
- en: '[PRE27]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'But wait, did we not just do the same with C++ and our options object? We did,
    but we skimmed over an important difference. In method chaining, the next method
    is applied to the result of the previous one. This is a chained call in C++:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 但是等等，我们不是刚刚用 C++ 和我们的选项对象做了同样的事情吗？我们确实做了，但我们忽略了一个重要的区别。在方法链中，下一个方法应用于前一个方法的结果。这是
    C++ 中的链式调用：
- en: '[PRE28]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This chained call is equivalent to the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个链式调用等同于以下代码：
- en: '[PRE29]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'C++ does not have the cascading syntax, but the code equivalent to a cascade
    would be this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 没有级联语法，但与级联等效的代码会是这样的：
- en: '[PRE30]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'But this is exactly what we did earlier, and the short form was the same:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 但这正是我们之前所做的事情，简短的形式也是一样的：
- en: '[PRE31]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'What makes the C++ cascading possible in this case is that the methods return
    the reference to the same object. We can still say that the equivalent code is
    this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，C++ 的级联之所以成为可能，是因为这些方法返回的是同一对象的引用。我们仍然可以说，等效的代码是这样的：
- en: '[PRE32]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: And, it’s technically true. But, because of the way the methods are written,
    we have the additional guarantee that `opt`, `opt1`, and `opt2` all refer to the
    same object. Method cascading can always be implemented through method chaining,
    but it restricts the interfaces because all calls must return a reference to `this`.
    This implementation technique is sometimes called by the somewhat unwieldy name
    `*this` in C++). What can be accomplished with more general chaining? Let’s see.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 并且，这在技术上是真的。但是，由于方法的编写方式，我们还有额外的保证，即`opt`、`opt1`和`opt2`都指向同一个对象。方法级联始终可以通过方法链实现，但它限制了接口，因为所有调用都必须返回对`this`的引用。这种实现技术有时被称为C++中有些笨拙的名称`*this`。更通用的链式调用能做什么呢？让我们看看。
- en: General method chaining
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用方法链
- en: 'If the chained method does not return a reference to the object itself, it
    should return a new object. Usually, this object is of the same type, or at least
    a type from the same class hierarchy, if the methods are polymorphic. For example,
    let’s consider a class that implements data collection. It has a method to filter
    the data using a predicate (a callable object, an object with an `operator()`
    that returns `true` or `false`). It also has a method to sort the collection.
    Each of these methods creates a new collection object and leaves the original
    object intact. Now, if we want to filter all valid data in our collection, and
    assuming that we have an `is_valid` predicate object, we can create a sorted collection
    of valid data:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果链式方法不返回对对象的引用，它应该返回一个新的对象。通常，这个对象是同一类型的，或者至少是来自同一类层次结构的类型，如果方法是多态的。例如，让我们考虑一个实现数据集合的类。它有一个使用谓词（一个可调用对象，一个具有`operator()`返回`true`或`false`的对象）过滤数据的方法。它还有一个对集合进行排序的方法。这些方法中的每一个都会创建一个新的集合对象，并保持原始对象不变。现在，如果我们想过滤集合中的所有有效数据，并且假设我们有一个`is_valid`谓词对象，我们可以创建一个有效数据的排序集合：
- en: '[PRE33]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The intermediate object can be eliminated using method chaining:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用方法链消除中间对象：
- en: '[PRE34]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: It should be clear after reading the last section that this is an example of
    method chaining, and a more general one than what we saw earlier—each method returns
    an object of the same type, but not the same object. The difference between chaining
    and cascading is very clear in this example—a cascade of methods would filter
    and sort the original collection (assuming we decided to support such operations).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读最后一节之后，应该清楚这是一个方法链的例子，而且比我们之前看到的更通用——每个方法都返回同一类型的对象，但不是同一个对象。在这个例子中，链式调用和级联调用的区别非常明显——级联调用会对原始集合进行过滤和排序（假设我们决定支持这样的操作）。
- en: Method chaining in class hierarchies
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类层次结构中的方法链
- en: 'When applied to class hierarchies, method chaining runs into a particular problem;
    let’s say that our `sort()` method returns a sorted data collection that is an
    object of a different type, `SortedCollection` , which is derived from the `Collection`
    class. The reason it is a derived class is that after sorting we can support efficient
    search, and so the `SortedCollection` class has a `search()` method that the base
    class does not have. We can still use method chaining, and even call the base
    class methods on the derived class, but doing so breaks the chain:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用于类层次结构时，方法链会遇到一个特定的问题；假设我们的`sort()`方法返回一个排序后的数据集合，它是一个不同类型的对象，`SortedCollection`，这个对象是从`Collection`类派生出来的。它之所以是派生类，是因为排序后我们可以支持高效的搜索，因此`SortedCollection`类有一个基类没有的`search()`方法。我们仍然可以使用方法链，甚至可以在派生类上调用基类的方法，但这样做会中断链：
- en: '[PRE35]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In this example, the chaining worked for a while: we were able to sort a `Collection`,
    search the result, and filter the result of the search. The call to `sort()` operates
    on a `Collection` and returns a `SortedCollection`. The call to `search()` needs
    a `SortedCollection`, so it works as intended. The call to `filter()` needs a
    `Collection`; the method can be invoked on a derived class such as `SortedCollection`,
    but the return result is still going to be a `Collection`. Then the chain breaks:
    the call to `median()` needs a `SortedCollection`, which we have, except `filter()`
    effectively cast it back to a `Collection`. There is no way to tell median() that
    the object is really a `SortedCollection` (other than casting).'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，链式调用工作了一段时间：我们能够对一个 `Collection` 进行排序，搜索结果，并过滤搜索结果。对 `sort()` 的调用作用于
    `Collection` 并返回一个 `SortedCollection`。对 `search()` 的调用需要一个 `SortedCollection`，所以它按预期工作。对
    `filter()` 的调用需要一个 `Collection`；该方法可以在派生类（如 `SortedCollection`）上调用，但返回的结果仍然是一个
    `Collection`。然后链式调用中断：对 `median()` 的调用需要一个 `SortedCollection`，我们确实有，但 `filter()`
    有效地将其转换回 `Collection`。没有办法告诉 `median()` 该对象实际上是一个 `SortedCollection`（除了强制类型转换）。
- en: 'Polymorphism, or virtual functions, does not help here; first of all, we would
    need to define virtual functions for `search()` and `median()` in the base class,
    even though we don’t intend to support this functionality there, as only the derived
    class supports them. We cannot declare them pure virtual because we use the `Collection`
    as a concrete class, and any class with a pure virtual function is an abstract
    class, so objects of this class cannot be instantiated. We can make these functions
    abort at runtime, but at the very least we have moved the detection of a programming
    error—searching in an unsorted collection—from compile time to runtime. Worse,
    it does not even help:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 多态或虚函数在这里没有帮助；首先，我们需要在基类中为 `search()` 和 `median()` 定义虚函数，尽管我们并不打算在那里支持这些功能，因为只有派生类支持它们。我们不能声明它们为纯虚函数，因为我们使用
    `Collection` 作为具体类，任何具有纯虚函数的类都是抽象类，因此不能实例化此类对象。我们可以使这些函数在运行时终止，但至少我们已经将编程错误的检测——在未排序的集合中进行搜索——从编译时移动到运行时。更糟糕的是，它甚至没有帮助：
- en: '[PRE36]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This is not going to work because `Collection::filter` returns a copy of the
    object, not a reference to it. The object it returns is the base class, `Collection`.
    If called on a `SortedCollection` object, it rips out the base class portion from
    the derived object and returns that. If you think that making `filter()` virtual
    as well, and overriding it in the derived class, solves this problem at the expense
    of overriding every function in the base class, you have another surprise coming—virtual
    functions must have identical return types, except for *covariant return types*.
    References to the base and derived classes are covariant return types. Classes
    themselves, returned by value, are not.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这行不通，因为 `Collection::filter` 返回的是对象的一个副本，而不是对其的引用。它返回的对象是基类，`Collection`。如果在一个
    `SortedCollection` 对象上调用它，它会从派生对象中剥离基类部分并返回。如果你认为将 `filter()` 也设为虚函数，并在派生类中重写它，可以以重写基类中每个函数为代价解决这个问题，那么你还有另一个惊喜——虚函数必须具有相同的返回类型，除了协变返回类型。对基类和派生类的引用是协变返回类型。而类本身，通过值返回的，则不是。
- en: Note that this problem would not have happened if we were returning object references.
    However, we can only return references to the object we are called on; if we create
    a new object in the body of a method function and return a reference to it, it’s
    a dangling reference to a temporary object that is deleted the moment the function
    returns. The result is undefined behavior (the program is likely to crash). On
    the other hand, if we always return the reference to the original object, we cannot
    change its type from based to derived in the first place.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果我们返回对象引用，这个问题就不会发生。然而，我们只能返回调用对象的引用；如果我们在一个方法函数体中创建一个新对象并返回对其的引用，那么它将是一个指向临时对象的悬垂引用，该临时对象在函数返回时被删除。结果是未定义的行为（程序很可能会崩溃）。另一方面，如果我们总是返回原始对象的引用，我们最初就不能将其类型从基类更改为派生类。
- en: 'The C++ solution to this problem involves the use of templates and a curious
    design pattern. In fact, it is so mind-twisting that the word *curious* is even
    in its name—the Curiously Recurring Template Pattern. We have a whole chapter
    on the CRTP pattern in this book. The application of the pattern to our case is
    relatively straightforward—the base class needs to return the right type from
    its functions, but can’t because it does not know what the type is. The solution—pass
    the right type into the base class as the template argument. Of course, the base
    class would have to be a base class template for this to work:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 解决这个问题的方法涉及使用模板和一个奇特的设计模式。事实上，这个词 *curious* 甚至出现在它的名字中——奇特重复的模板模式。这本书中有一个关于
    CRTP 模式的完整章节。该模式在我们的案例中的应用相对直接——基类需要从其函数返回正确的类型，但无法做到，因为它不知道类型是什么。解决方案——将正确的类型作为模板参数传递给基类。当然，基类必须是一个基类模板才能使这起作用：
- en: '[PRE37]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The chain here starts similarly to our initial example: `sort()` is invoked
    on a `Collection` and returns a `SortedCollection`, then `search()` applies to
    the `SortedCollection` and returns another `SortedCollection`, then `filter()`
    is called. This time, `filter()` from the base class `Collection` knows what the
    real type of the object is because `Collection` itself is a template instantiated
    on the type of the derived object. So, `filter()` works on any collection but
    returns an object of the same type as the initial collection – in our case, both
    are `SortedCollection` objects. Finally, `median()` needs a `SortedCollection`
    and gets it.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的链与我们的初始示例类似：在 `Collection` 上调用 `sort()` 返回一个 `SortedCollection`，然后 `search()`
    应用到 `SortedCollection` 上并返回另一个 `SortedCollection`，接着调用 `filter()`。这一次，基类 `Collection`
    知道对象的真正类型，因为 `Collection` 本身是在派生对象类型上实例化的模板。因此，`filter()` 在任何集合上工作，但返回与初始集合相同类型的对象——在我们的例子中，两者都是
    `SortedCollection` 对象。最后，`median()` 需要一个 `SortedCollection` 并获取它。
- en: This is a complex solution. While it works, its complexity suggests that method
    chaining should be used judiciously when the object type has to change in the
    middle of the chain. There is a good reason for that—changing the object type
    is fundamentally different than calling a sequence of methods. It is a more significant
    event that perhaps should be made explicit, and the new object should get its
    own name.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个复杂的解决方案。虽然它有效，但其复杂性表明，当对象类型需要在链的中间改变时，应谨慎使用方法链。这有一个很好的理由——改变对象类型与调用一系列方法在本质上不同。这是一个更重大的事件，可能应该明确表示，并且新对象应该有自己的名称。
- en: Now that we know what method chaining is, let us see where else it can be useful.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道了方法链是什么，让我们看看它还能在哪些地方有用。
- en: The Builder pattern
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造者模式
- en: 'Let us go almost all the way back to the start of the chapter and take another
    look at the way we pass named arguments to a C++ function. Instead of a constructor
    with many arguments, we settled on an options object where each argument is explicitly
    named:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们几乎回到本章的开头，再次看看我们是如何向 C++ 函数传递命名参数的。我们不是使用带有许多参数的构造函数，而是选择了一个选项对象，其中每个参数都被明确命名：
- en: '[PRE38]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Let us now focus on the `Options` object itself, specifically, the way we construct
    it. The constructor does not create a finished object (that would just move the
    problem from the `City` constructor to the `Options` constructor). Instead, we
    build the object piece by piece. This is a particular case of a very general design
    pattern – the Builder.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们专注于 `Options` 对象本身，特别是我们构建它的方式。构造函数不会创建一个完成的对象（这只会把问题从 `City` 构造函数转移到
    `Options` 构造函数）。相反，我们逐步构建对象。这是一个非常通用设计模式——构造者模式的一个特例。
- en: Basics of the Builder pattern
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造者模式的基本
- en: The Builder design pattern is used whenever we decide that an object cannot
    be constructed in what we consider a complete state by the constructor alone.
    Instead, we write a helper class, or builder class, that builds these objects
    and hands them out to the program.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们决定一个对象不能仅通过构造函数独立构建成我们认为的完整状态时，就会使用构造者设计模式。相反，我们编写一个辅助类或构造者类来构建这些对象，并将它们交给程序。
- en: 'The first question you might ask is “Why?” – isn’t the constructor supposed
    to do exactly that job? There could be several reasons. One very common reason
    is that we use a more general object to represent some more specific data set.
    For example, we want an object that holds Fibonacci numbers or prime numbers,
    and we decided to use a `std::vector` to store them. Now we have a problem: the
    vector has whatever constructors the STL provides, but we need to ensure that
    our vector has the right numbers in it, and we can’t write a new constructor.
    We could create a special class to hold only prime numbers, but we will end up
    with a lot of classes that, after being constructed differently, are used in very
    similar ways. We would have to write new code to process prime numbers, odd numbers,
    square numbers, etc when using a vector for all of them would be perfectly sufficient.
    Alternatively, we could just use vectors everywhere and write the right values
    into them whenever our program needs it. This is no good too: we expose and duplicate
    a lot of low-level code that we would like to encapsulate and reuse (which is
    why we wanted a constructor for each kind of number).'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问的第一个问题是“为什么？”——构造函数不是应该做这个工作吗？可能有几个原因。一个非常常见的原因是我们使用一个更通用的对象来表示一些更具体的数据集。例如，我们想要一个对象来存储斐波那契数字或素数，我们决定使用`std::vector`来存储它们。现在我们遇到了一个问题：向量具有STL提供的任何构造函数，但我们需要确保我们的向量中有正确的数字，而且我们不能编写一个新的构造函数。我们可以创建一个只包含素数的特殊类，但最终我们会得到很多类，它们在构造方式不同后，被以非常相似的方式使用。当我们使用向量处理所有这些数字时，这将是完全足够的。或者，我们可以在任何地方使用向量，并在程序需要时将正确的值写入其中。这也不是一个好主意：我们暴露并重复了大量我们希望封装和重用的底层代码（这就是我们为什么想要为每种数字编写一个构造函数的原因）。
- en: 'The solution is the Builder pattern: the code for computing and storing the
    numbers is encapsulated in a builder class, but the object created by the builder
    is a generic vector. For example, here is a builder for Fibonacci numbers (the
    sequence of numbers that starts with 1, 1, and every subsequent number is a sum
    of the last two numbers):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是建造者模式：计算和存储数字的代码封装在一个建造者类中，但建造者创建的对象是一个通用的向量。例如，这里是一个斐波那契数字（以1, 1开始，后续每个数字是前两个数字之和的序列）的建造者：
- en: '[PRE39]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Suppose our program needs to get sequences of the first `n` Fibonacci numbers
    for some algorithm (the value of `n` varies at run time). We may need these numbers
    more than once, sometimes for larger values of `n` than before and sometimes for
    smaller ones. All we need to do is to ask the builder:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的程序需要为某些算法（运行时值`n`可能变化的算法）获取前`n`个斐波那契数字的序列。我们可能需要这些数字多次，有时比之前更大的`n`值，有时比之前更小的值。我们只需要询问建造者：
- en: '[PRE40]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We could keep the already known values somewhere in the program, but that complicates
    the program with the additional job of tracking them. It is better to move that
    work to a class dedicated to constructing Fibonacci numbers and nothing else -
    a builder. Is it worth it to cache Fibonacci numbers? Probably not really, but
    remember that this is a concise example: if we needed, say, prime numbers instead,
    reusing already known values would be very much worth it (but the code would be
    much longer).'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在程序中某个地方保留已知的值，但这会使程序复杂化，需要额外的跟踪工作。将这项工作移到一个仅用于构建斐波那契数字的类中会更好——一个建造者。缓存斐波那契数字值得吗？可能并不真的值得，但请记住，这是一个简洁的例子：如果我们需要，比如说，素数而不是斐波那契数字，重用已知值将非常有价值（但代码会更长）。
- en: 'The other common reason to use the builder is that the code necessary to build
    an object may be too complex for a constructor. Often, it manifests itself in
    the large number of arguments we would have to pass to a constructor if we tried
    to write one. The way we build the `Options` argument for our `City` at the start
    of this section is a trivial example of that, with the `Options` object acting
    as its own builder. Particular situations where builders are most useful include
    cases where the construction process is conditional and the data needed to fully
    construct an object varies in both the number and the type depending on some run-time
    variables. Again, our `City` is a trivial example of that: no single `City` needs
    every constructor argument, but without the `Options` and its (trivial) builder,
    we would have to provide a parameter for every one of them.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用构建器的另一个常见原因是构建对象的代码可能过于复杂，不适合构造函数。通常，这会表现为如果我们尝试编写一个构造函数，我们必须传递给构造函数的大量参数。我们在本节开头构建`City`的`Options`参数的方式是这种复杂性的一个简单例子，其中`Options`对象充当其自己的构建器。构建器最有用的特定情况包括构建过程是条件性的，并且构建一个对象所需的数据在数量和类型上根据某些运行时变量而变化。再次强调，我们的`City`是这种情况的一个简单例子：没有单个`City`需要每个构造函数参数，但没有`Options`及其（简单）构建器，我们就必须为它们中的每一个提供一个参数。
- en: The approach we have seen for our Fibonacci vector builder is a common variant
    of the Builder pattern in C++; it’s not very exciting but it works. In this chapter,
    we are going to see some alternative ways to implement a Builder. The first one
    generalizes the way we built our `Options`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为Fibonacci向量构建器看到的方法是C++中Builder模式的常见变体；它并不非常令人兴奋，但它是有效的。在本章中，我们将看到一些实现Builder的替代方法。第一个方法是对我们构建`Options`的方式进行了泛化。
- en: The fluent Builder
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流畅构建器
- en: 'The way we build the `Options` object is through method chaining. Each method
    takes a small step toward constructing the final object. There is a general name
    for this approach: the fluent interface. While it is not limited to designing
    builders, the fluent interface became popular in C++ mostly as a way to build
    complex objects.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建`Options`对象的方式是通过方法链式调用。每个方法都朝着构建最终对象迈出小小的一步。这种方法的通用名称是流畅接口。虽然它不仅限于设计构建器，但流畅接口在C++中主要作为构建复杂对象的一种方式而流行。
- en: 'The fluent builder relies on method chaining: each member function of the builder
    class contributes to constructing the object that is being built and returns the
    builder itself, so the work can continue. For example, here is an `Employee` class
    (possibly for some workplace database):'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 流畅构建器依赖于方法链式调用：构建器类的每个成员函数都贡献于正在构建的对象的构建，并返回构建器本身，以便工作可以继续。例如，这里有一个`Employee`类（可能用于某个工作场所数据库）：
- en: '[PRE41]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We are going to add even more data to the class later, but already it has enough
    data members to make a single constructor hard to use (too many arguments of the
    same type). We could use a constructor with an `Options` object, but, going forward,
    we expect the need to do some computations during the construction of the object:
    we may need to validate certain data, and other parts of the employee record may
    be conditional: two fields that cannot be set at the same time, a field whose
    default value depends on other fields, etc. So let’s start designing a builder
    for this class.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后还会向这个类添加更多数据，但目前已经有了足够的数据成员，使得单个构造函数难以使用（太多相同类型的参数）。我们可以使用一个带有`Options`对象的构造函数，但，向前看，我们预计在对象构建过程中需要进行一些计算：我们可能需要验证某些数据，员工记录的其他部分可能是条件性的：两个不能同时设置的字段，一个字段默认值依赖于其他字段等。因此，让我们开始为这个类设计一个构建器。
- en: 'The `EmployeeBuilder` needs to construct an `Employee` object first, then provide
    several chained methods to set different fields of the object, and, finally, hand
    over the constructed object. There may be some error checking involved, or more
    complex operations affecting other multiple fields, but a basic builder looks
    like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`EmployeeBuilder`需要首先构建一个`Employee`对象，然后提供几个链式方法来设置对象的不同字段，最后将构建好的对象传递出去。可能涉及一些错误检查，或者影响多个字段的更复杂操作，但一个基本的构建器看起来像这样：'
- en: '[PRE42]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Several design decisions had to be made along the way. First, we decided to
    make the constructor `Employee::Employee()` private, so only friends such as `EmployeeBuilder`
    can create these objects. This ensures that a partially initialized or otherwise
    invalid `Employee` object cannot appear in the program: the only way to get one
    is from a builder. This is usually the safer choice, but sometimes we need to
    be able to default-construct the objects (for example, to use them in containers
    or for many serialization/deserialization implementations). Second, the builder
    holds the object that is being built until it can be moved to the caller. This
    is the common approach, but we have to be careful to use each builder object only
    once. We could also provide a way to reinitialize the builder; this is often done
    when the builder needs to do a lot of computations whose results are reused for
    building multiple objects. Finally, in order to construct an `Employee` object,
    we need to construct a builder first:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我们必须做出几个设计决策。首先，我们决定将构造函数 `Employee::Employee()` 设置为私有，这样只有像 `EmployeeBuilder`
    这样的友元才能创建这些对象。这确保了部分初始化或无效的 `Employee` 对象不会出现在程序中：获取这些对象的唯一方式是通过构建器。这通常是更安全的选择，但有时我们需要能够默认构造对象（例如，在容器中使用或用于许多序列化/反序列化实现）。其次，构建器持有正在构建的对象，直到它可以被移动到调用者那里。这是一个常见的方法，但我们必须小心只使用每个构建器对象一次。我们还可以提供一种重新初始化构建器的方法；这通常在构建器需要执行大量计算，其结果被用于构建多个对象时进行。最后，为了构建一个
    `Employee` 对象，我们首先需要构建一个构建器：
- en: '[PRE43]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The other common approach is to provide a static function `Employee::create()`
    that constructs a builder; in this case, the builder constructor is made private,
    with friends.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见的方法是提供一个静态函数 `Employee::create()` 来构建一个构建器；在这种情况下，构建器的构造函数被设置为私有，并允许友元访问。
- en: As we mentioned in the section on *Method chaining in class hierarchies*, the
    chained methods do not have to all return references to the same class. If our
    `Employee` object has an internal structure such as separate sub-records for the
    home address, job location, and so on, we could have a more structured approach
    to the builder as well.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在关于 *类层次结构中的方法链* 的章节中提到的，链式方法不必都返回同一类的引用。如果我们的 `Employee` 对象具有内部结构，例如家庭地址、工作地点等单独的子记录，我们也可以对构建器采用更结构化的方法。
- en: 'The goal here is to design an interface so the client code could look like
    this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的目标是设计一个接口，使得客户端代码可以看起来像这样：
- en: '[PRE44]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'To do this, we need to implement a hierarchy of builders with a common base
    class:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要实现一个具有公共基类的构建器层次结构：
- en: '[PRE45]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We still start with `EmployeeBuilder` which constructs the `Employee` object;
    the rest of the builders hold a reference to it, and, by calling the corresponding
    member function on `AbstractBuilder` we can switch to a different type of builder
    for the same `Employee` object. Note that, while `AbstractBuilder` serves as the
    base class for all other builders, there are no pure virtual functions (or any
    other virtual functions): as we have seen earlier, run-time polymorphism is not
    particularly useful in method chaining:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然从 `EmployeeBuilder` 开始，它构建 `Employee` 对象；其余的构建器持有对其的引用，并且通过在 `AbstractBuilder`
    上调用相应的成员函数，我们可以为同一个 `Employee` 对象切换到不同类型的构建器。注意，虽然 `AbstractBuilder` 作为所有其他构建器的基类，但没有纯虚函数（或任何其他虚函数）：如我们之前所见，运行时多态在方法链中并不特别有用：
- en: '[PRE46]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To add the job information, we switch to the `JobBuilder`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加工作信息，我们切换到 `JobBuilder`：
- en: '[PRE47]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Once we have a `JobBuilder`, all its chained methods return a reference to itself;
    of course, a `JobBuilder` is also an `AbstractBuilder`, so we could switch to
    another builder type such as `AddressBuilder` any time. Note that we can declare
    the `AbstractBuilder::Job()` method with just the forward declaration of the `JobBuilder`,
    but the implementation has to be deferred until the type itself is defined.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了 `JobBuilder`，它所有的链式方法都返回对自身的引用；当然，`JobBuilder` 也是一个 `AbstractBuilder`，因此我们可以在任何时候切换到另一个构建器类型，例如
    `AddressBuilder`。注意，我们可以仅通过 `JobBuilder` 的前向声明来声明 `AbstractBuilder::Job()` 方法，但实现必须推迟到类型本身定义之后。
- en: 'In this example, we also see the flexibility of the Builder pattern that would
    be very difficult to implement using constructors only. For example, there are
    two ways to define an employee’s manager: we can provide the name, or use another
    employee record. Also, we can copy the workplace information from another employee’s
    records, and still use `Set` methods to modify the fields that are not the same.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们也看到了Builder模式的灵活性，这仅使用构造函数很难实现。例如，有两种方式可以定义一个员工的经理：我们可以提供名字，或者使用另一个员工记录。此外，我们可以从另一个员工的记录中复制工作场所信息，并且仍然可以使用`Set`方法修改不同的字段。
- en: 'Other builders such as `AddressBuilder` are likely to be similar. But there
    may be very different builders as well. For example, an employee could have an
    arbitrary number of awards:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 其他如`AddressBuilder`之类的Builder可能类似。但也可能有非常不同的Builder。例如，一个员工可以有任意数量的奖项：
- en: '[PRE48]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The corresponding builder needs to reflect the nature of the information that
    it is adding to the object:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的Builder需要反映它添加到对象中的信息的性质：
- en: '[PRE49]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We can call `AwardBuilder::Add()` as many times as we need to build the particular
    `Employee` object.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以多次调用`AwardBuilder::Add()`来构建特定的`Employee`对象。
- en: 'Here is our builder in action. Note how, for different employees, we can use
    different ways to supply the required information:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们的Builder在起作用。注意，对于不同的员工，我们可以使用不同的方式来提供所需的信息：
- en: '[PRE50]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We can use one employee record to add the manager’s name to another employee:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一个员工记录来将经理的名字添加到另一个员工中：
- en: '[PRE51]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We can copy employment records between employees:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在员工之间复制就业记录：
- en: '[PRE52]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Some of the fields, such as first and last name, are optional, and the builder
    checks the finished records for completeness before they can be accessed (see
    the `AbstractBuilder::operator Employee()` above). Other fields, such as name
    suffixes, are optional:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一些字段，如姓名和姓氏，是可选的，Builder在可以访问之前会检查完成后的记录是否完整（参见上面的`AbstractBuilder::operator
    Employee()`）。其他字段，如名字后缀，也是可选的：
- en: '[PRE53]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The fluent builder is a powerful C++ pattern for constructing complex objects
    with many components, particularly when parts of the object are optional. However,
    it can get quite verbose for objects containing large amounts of highly structured
    data. There are alternatives, of course.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 流畅的Builder模式是C++中构建具有许多组件的复杂对象的有力模式，尤其是在对象的某些部分是可选的情况下。然而，对于包含大量高度结构化数据的对象，它可能会变得相当冗长。当然，也有其他选择。
- en: The implicit builder
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐式Builder
- en: 'We have already seen a case where the Builder pattern was employed without
    a dedicated builder object: all `Options` objects for named argument passing act
    as their own builders. We are going to see another version which is particularly
    interesting because there is no explicit builder object here. This design is particularly
    suitable for building nested hierarchical data such as XML files. We are going
    to demonstrate its use to build a (very simplified) HTML writer.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到过一个例子，其中使用了Builder模式而没有专门的Builder对象：所有用于命名参数传递的`Options`对象都充当它们自己的Builder。我们将看到另一个版本，这个版本特别有趣，因为这里没有显式的Builder对象。这种设计特别适合构建嵌套层次数据，例如XML文件。我们将演示如何使用它来构建一个（非常简化的）HTML编写器。
- en: 'In this design, HTML records are going to be represented by the corresponding
    classes: a class for the `<P>` tag, another for the `<UL>` tag, and so on. All
    of these classes elaborate the common base class, `HTMLElement`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个设计中，HTML记录将被相应的类表示：一个用于`<P>`标签的类，另一个用于`<UL>`标签，等等。所有这些类都详细说明了共同的基类`HTMLElement`：
- en: '[PRE54]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'There is, of course, a lot more to an HTML element, but we have to keep things
    simple. Also, our base element allows unlimited nesting: any element can have
    a vector of child elements, each of which can have child elements, and so on.
    Printing of an element is, therefore, recursive:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，HTML元素还有很多其他内容，但我们必须保持简单。此外，我们的基元素允许无限嵌套：任何元素都可以有一个子元素向量，每个子元素也可以有子元素，依此类推。因此，元素的打印是递归的：
- en: '[PRE55]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Note that, in order to add child elements, we have to supply them in a `std::vector`
    which is then moved into the `HTMLElement` object. The rvalue reference means
    that the vector argument is going to be a temporary value or a result of `std::move`.
    However, we are not going to add the child elements to vectors ourselves: this
    is the job of the derived classes for the specific elements (`<P>`, `<UL>`, etc).
    The specific element classes can prevent the addition of child elements when the
    syntax does not allow it, as well as enforce other restrictions on the fields
    of an HTML element.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，为了添加子元素，我们必须以`std::vector`的形式提供它们，然后这些向量会被移动到`HTMLElement`对象中。右值引用意味着向量参数将是一个临时值或`std::move`的结果。然而，我们不会自己将子元素添加到向量中：这是特定元素（如`<P>`、`<UL>`等）的派生类的工作。特定的元素类可以在语法不允许时阻止添加子元素，以及强制对HTML元素字段的其他限制。
- en: 'What do these specific classes look like? The simpler ones are going to look
    like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特定类看起来是什么样子？简单的类将看起来像这样：
- en: '[PRE56]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This `HTML` class represents the `<html>` tag. Classes such as `Body`, `Head`,
    `UL`, `OL`, and many more, are written exactly the same way. The class `P` for
    the `<P>` tag is similar except it does not allow nested objects, so it has only
    one constructor that takes the text argument. It is very important that these
    classes do not add any data members; they must initialize the base `HTMLElement`
    object and nothing else. The reason should be obvious if you look at the base
    class again: we store a vector of `HTMLElement` child objects. However, they were
    constructed – as `HTML` or as `UL,` or as anything else – they are only `HTMLElement`
    objects now. Any extra data is going to be lost.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`HTML`类代表`<html>`标签。像`Body`、`Head`、`UL`、`OL`等这样的类也是以完全相同的方式编写的。代表`<P>`标签的`P`类类似，但它不允许嵌套对象，因此它只有一个接受文本参数的构造函数。非常重要的一点是，这些类不添加任何数据成员；它们必须初始化基类`HTMLElement`对象，而不再初始化其他任何内容。如果你再次查看基类，原因应该很明显：我们存储了一个`HTMLElement`子对象向量。然而，它们被构造了——无论是作为`HTML`还是作为`UL`或其他任何东西——现在它们只是`HTMLElement`对象。任何额外的数据都将丢失。
- en: 'You may also notice that the vector parameter of the `HTMLElement` constructor
    is initialized from a `std::initializer_list` argument. This conversion is done
    implicitly by the compiler from the list of the constructor arguments:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还会注意到，`HTMLElement`构造函数的向量参数是从`std::initializer_list`参数初始化的。这种转换是由编译器隐式地从构造函数参数列表中完成的：
- en: '[PRE57]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This statement begins with a call to construct an `HTML` object using two arguments.
    They are `Head` and `Body` objects, but they get converted to `HTMLElement` and
    put into `std::initializer_list<HTMLElement>` by the compiler. The list is then
    used to initialize a vector, which is moved into the `children_` vector in the
    `HTML` object. Both `Head` and `Body` objects themselves have child objects, one
    of which (`OL`) has its own child objects.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语句以调用使用两个参数构造`HTML`对象的方式开始。它们是`Head`和`Body`对象，但它们被编译器转换为`HTMLElement`并放入`std::initializer_list<HTMLElement>`中。然后这个列表被用来初始化一个向量，这个向量被移动到`HTML`对象的`children_`向量中。`Head`和`Body`对象本身也有子对象，其中一个（`OL`）有自己的子对象。
- en: 'Note it gets a little tricky if you want to have additional constructor arguments
    because you cannot mix regular arguments with initializer list elements. This
    problem happens, for example, with the `LI` class. The straightforward way to
    implement this class, based on what we learned so far, is as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你想要额外的构造函数参数，这会变得有点棘手，因为你不能将常规参数与初始化列表元素混合。这个问题在`LI`类中就出现了。根据我们到目前为止所学的内容，实现这个类的直接方法如下：
- en: '[PRE58]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Unfortunately, you can’t call this constructor with something like this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，你不能用类似这样的方式调用这个构造函数：
- en: '[PRE59]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'It seems obvious that what the programmer wanted is for the first argument
    to be `"A"` and the second argument (and any more arguments, if we had them) should
    go into the initializer list. But that doesn’t work: generally, to form an initializer
    list, we have to enclose the element sequence in braces `{…}`. Only when the entire
    argument list matches an initializer list can these braces be omitted. With some
    arguments not being part of the initializer list, we have to be explicit:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，程序员想要的第一个参数是`"A"`，第二个参数（以及如果有，任何更多的参数）应该放入初始化列表中。但这行不通：通常，为了形成一个初始化列表，我们必须将元素序列放在大括号`{…}`中。只有当整个参数列表与初始化列表匹配时，这些大括号才能省略。对于不是初始化列表一部分的某些参数，我们必须明确指出：
- en: '[PRE60]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'If you don’t want to write the extra braces, you have to change the constructor
    slightly:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想写额外的花括号，你必须稍微改变构造函数：
- en: '[PRE61]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Instead of using an initializer list parameter, we use a parameter pack and
    explicitly convert it to an initializer list (which is then converted to a vector).
    Of course, the parameter pack will accept an arbitrary number of arguments of
    any type, not just `HTMLElement` and its derived classes, but the conversion to
    the initializer list will fail. If you want to follow the practice that any template
    that did not fail to instantiate should not produce compilation errors in its
    body, you have to restrict the types in the parameter pack to classes derived
    from `HTMLElement`. This is easily done using C++20 concepts:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是使用初始化列表参数，而是使用参数包并将其显式转换为初始化列表（然后将其转换为向量）。当然，参数包将接受任意类型和任意数量的参数，而不仅仅是`HTMLElement`及其派生类，但转换到初始化列表将失败。如果你想遵循任何未失败实例化的模板都不应在其主体中产生编译错误的实践，你必须将参数包中的类型限制为从`HTMLElement`派生的类。这可以通过使用C++20概念轻松完成：
- en: '[PRE62]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: If you don’t use C++20 but still want to restrict the parameter types, you should
    read the [*Chapter 7*](B19262_07.xhtml#_idTextAnchor314), *SFINAE, Concepts, and
    Overload Resolution Management* in this book.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有使用C++20但仍想限制参数类型，你应该阅读本书的[*第7章*](B19262_07.xhtml#_idTextAnchor314)，*SFINAE、概念和重载解析管理*。
- en: 'With the parameter pack used as an intermediary for constructing an initializer
    list, we can avoid the extra braces and write our HTML document like this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 使用参数包作为构建初始化列表的中间件，我们可以避免额外的花括号，并像这样编写我们的HTML文档：
- en: '[PRE63]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'This does look like an application of the Builder pattern: even though the
    final construction is done by a single call to the HTMLElement constructor, that
    constructor just moves the already constructed vector of child elements into its
    final location. The actual construction is done in steps like all builders do.
    But where is the builder object? There isn’t one, not explicitly. Part of the
    builder functionality is provided by all the derived objects, such as `HTML`,
    `UL`, etc. They may look like they represent the corresponding HTML constructs,
    but they really don’t: after the entire document is constructed, we only have
    `HTMLElement` objects. The derived objects are used only to build the document.
    The rest of the builder code is generated by the compiler when it does all the
    implicit conversions between parameter packs, initializer lists, and vectors.
    By the way, any half-decent optimizing compiler is going to get rid of all the
    intermediate copies and copy the input strings straight into the final vector
    where they are going to be stored.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实看起来是构建器模式的应用：尽管最终的构建是通过调用`HTMLElement`构造函数的单个调用完成的，但该构造函数只是将已经构建的子元素向量移动到其最终位置。实际的构建是按照所有构建器都会做的步骤进行的。但是构建器对象在哪里？没有，不是明确存在的。构建器功能的一部分是由所有派生对象提供的，例如`HTML`、`UL`等。它们可能看起来像代表相应的HTML结构，但事实并非如此：在构建整个文档之后，我们只有`HTMLElement`对象。派生对象仅用于构建文档。其余的构建器代码是由编译器在执行参数包、初始化列表和向量之间的所有隐式转换时生成的。顺便说一句，任何半不错的优化编译器都会去掉所有中间副本，并将输入字符串直接复制到最终向量中，这些字符串将存储在那里。
- en: Of course, this is a very simplified example, and for any practical use, we
    would need to store more data with HTML elements and give the programmer a way
    to initialize this data. We could combine the implicit builder approach with the
    fluent interface to provide an easy way to add optional values such as style,
    type, etc, to all `HTMLElement` objects.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是一个非常简化的例子，但在任何实际应用中，我们都需要使用HTML元素存储更多的数据，并为程序员提供一种初始化这些数据的方法。我们可以将隐式构建方法与流畅接口相结合，为所有`HTMLElement`对象提供一个简单的方法来添加可选值，例如样式、类型等。
- en: 'By now you have seen three distinct Builder designs: there is the “traditional”
    builder with a single builder object, the fluent builder that employs method chaining,
    and the implicit builder that uses many small builder helper objects and relies
    heavily on compiler-generated code. There are other designs, but they are mostly
    variants and combinations of the approaches you have learned. Our study of the
    Builder pattern has drawn to a close.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到了三种不同的构建器设计：有一个“传统”的构建器，它有一个单一的构建器对象；有一个使用方法链的流畅构建器；还有一个使用许多小的构建器辅助对象并大量依赖编译器生成代码的隐式构建器。还有其他的设计，但它们大多是你已经学过的方法的变体和组合。我们对构建器模式的研究已经接近尾声。
- en: Summary
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Yet again, we have seen the power of C++ to essentially create a new language
    out of the existing one; C++ does not have named function arguments, only positional
    ones. That is part of the core language. And yet, we were able to extend the language
    and add support for named arguments in a reasonable-looking way, using the method
    chaining technique. We have also explored the other applications of method chaining
    beyond the named arguments idiom.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们看到了C++从现有语言中基本创建新语言的能力；C++没有命名函数参数，只有位置参数。这是核心语言的一部分。然而，我们能够以合理的方式扩展语言并添加对命名参数的支持，使用方法链技术。我们还探讨了方法链在命名参数习语之外的其它应用。
- en: 'One of these applications, the fluent builder, is again an exercise in creating
    new languages: the power of the fluent interface, in general, is that it can be
    used to create domain-specific languages to execute sequences of instructions
    on some data. And so the fluent builder can be used to allow the programmer to
    describe the construction of objects as a sequence of steps that are familiar
    in a particular domain. Then, of course, there is the implicit builder that (with
    the right indents) even makes C++ code look a bit like the HTML document that
    is being built.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这些应用之一，流畅构建器，再次是创建新语言的练习：流畅接口的普遍力量在于它可以用来创建特定领域的领域特定语言，以执行某些数据上的指令序列。因此，流畅构建器可以用来允许程序员以特定领域熟悉的步骤序列来描述对象的构建。当然，还有隐式构建器，它（通过适当的缩进）甚至让C++代码看起来有点像正在构建的HTML文档。
- en: The next chapter introduces the only purely performance-oriented idiom in this
    book. We have discussed in several chapters the performance cost of memory allocation,
    and its impact on the implementation of several patterns. The next idiom, local
    buffer optimization, attacks the problem head-on, by avoiding memory allocation
    altogether.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章介绍了本书中唯一的纯粹面向性能的习语。我们在几个章节中讨论了内存分配的性能成本及其对几个模式实现的影响。下一个习语，局部缓冲区优化，直接攻击问题，通过完全避免内存分配来解决问题。
- en: Questions
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why do functions with many arguments of the same or related types lead to fragile
    code?
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么具有许多相同或相关类型参数的函数会导致脆弱的代码？
- en: How do aggregate argument objects improve code maintainability and robustness?
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何通过聚合参数对象提高代码的可维护性和健壮性？
- en: What is the named argument idiom and how does it differ from aggregate arguments?
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名参数习语是什么，它与聚合参数有何不同？
- en: What is the difference between method chaining and cascading?
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法链和级联有什么区别？
- en: What is the Builder pattern?
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建造者模式是什么？
- en: What is the fluent interface and when is it used?
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是流畅式接口，它在什么情况下被使用？
