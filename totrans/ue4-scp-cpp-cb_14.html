<html><head></head><body>
        

                            
                    <h1 class="header-title">User Interfaces - UI and UMG</h1>
                
            
            
                
<p class="mce-root">In this chapter, we will cover the following recipes:</p>
<ul>
<li>Drawing using Canvas</li>
<li>Adding Slate Widgets to the screen</li>
<li>Creating screen size-aware scaling for the UI</li>
<li>Displaying and hiding a sheet of UMG elements in-game</li>
<li>Attaching function calls to Slate events</li>
<li>Using Data Binding with Unreal Motion Graphics</li>
<li>Controlling widget appearance with Styles</li>
<li>Creating a custom SWidget/UWidget</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>Displaying feedback to the player is one of the most important elements within game design, and this will usually involve some sort of HUD, or at least menus, within your game.</p>
<p>In previous versions of Unreal, there was simple HUD support, which allowed you to draw simple shapes and text to the screen. However, it was somewhat limited in terms of aesthetics, and so solutions such as <strong>Scaleform</strong> became common to work around these limitations. Scaleform leveraged Adobe's Flash file format to store vector images and UI scripts. It was not without its own cons for developers, though, not least the cost – it was a third-party product requiring a (sometimes, expensive) license.</p>
<p>As a result, Epic developed Slate for the Unreal 4 editor and the in-game UI framework. Slate is a collection of widgets (UI elements) and a framework that allows for a cross-platform interface for the Editor. It is also usable in-game to draw widgets, such as sliders and buttons, for menus and HUDs.</p>
<p>Slate uses declarative syntax to allow for an XML-style representation of user interface elements in their hierarchy in native C++. It accomplishes this by making heavy use of macros and operator overloading.</p>
<p>That said, not everybody wants to ask their programmers to design the game's HUD. One of the significant advantages of using Scaleform within Unreal 3 was the ability to develop the visual appearance of game UIs using the Flash visual editor so that visual designers didn't need to learn a programming language. Programmers could then insert the logic and data separately. This is the same paradigm that's espoused by the <strong>Windows Presentation Framework</strong> (<strong>WPF</strong>), for example.</p>
<p>In a similar fashion, Unreal provides <strong>Unreal Motion Graphics</strong> (<strong>UMG</strong>). UMG is a visual editor for Slate widgets that allows you to visually style, lay out, and animate user interfaces. UI widgets (or controls, if you've come from a Win32 background) can have their properties controlled by either Blueprint code (written in the Graph view of the UMG window) or from C++. This chapter primarily deals with displaying UI elements, creating widget hierarchies, and creating base <kbd>SWidget</kbd> classes that can be styled and used within UMG.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>This chapter requires the use of Unreal Engine 4 and uses Visual Studio 2017 as the IDE. Instructions on how to install both pieces of software and the requirements for them can be found in <a href="4adb307e-d86f-4d70-b6de-a0893102d1cf.xhtml">Chapter 1</a>, <em>UE4 Development Tools</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Drawing using Canvas</h1>
                
            
            
                
<p><strong>Canvas</strong> is a continuation of the simple HUD that's implemented within Unreal 3. While it isn't so commonly used within shipping games, mostly being replaced by Slate/UMG, it's simple to use, especially when you want to draw text or shapes to the screen. Canvas drawing is still used extensively by console commands that are used for debugging and performance analysis, such as <kbd>stat game</kbd> and the other <kbd>stat</kbd> commands. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready...</h1>
                
            
            
                
<p>Refer to <a href="eade601c-4b55-484a-ba49-0a989d81d7f8.xhtml">Chapter 4</a>, <em>Actors and Components,</em> if you need a refresher on using the C++ Code Wizard.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>From your Visual Studio project (File | Open Visual Studio), open the <kbd>Source\&lt;Module&gt;</kbd> folder and, from there, open the <kbd>&lt;Module&gt;.build.cs</kbd> file (in my case, it would be <kbd>Source\Chapter_14\Chapter_14.build.cs</kbd>) . Uncomment/add the following line of code:</li>
</ol>
<pre style="padding-left: 60px">using UnrealBuildTool;<br/><br/>public class Chapter_14 : ModuleRules<br/>{<br/>  public Chapter_14(ReadOnlyTargetRules Target) : base(Target)<br/>  {<br/>    PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;<br/>  <br/>    PublicDependencyModuleNames.AddRange(new string[] { "Core", <br/>    "CoreUObject", "Engine", "InputCore" });<br/><br/>    PrivateDependencyModuleNames.AddRange(new string[] { });<br/><br/>    // Uncomment if you are using Slate UI<br/>    <strong>PrivateDependencyModuleNames.AddRange(new string[] { "Slate", <br/>    "SlateCore" });</strong><br/>    <br/>    // Uncomment if you are using online features<br/>    // PrivateDependencyModuleNames.Add("OnlineSubsystem");<br/><br/>    // To include OnlineSubsystemSteam, add it to the plugins section in your uproject file with the Enabled attribute set to true<br/>  }<br/>}</pre>
<ol start="2">
<li>Create a new <kbd>GameModeBase</kbd> called <kbd>CustomHUDGameMode</kbd> using the editor class wizard. </li>
<li>Add a constructor to the class:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "GameFramework/GameModeBase.h"<br/>#include "CustomHUDGameMode.generated.h"<br/><br/>/**<br/> * <br/> */<br/>UCLASS()<br/>class CHAPTER_14_API ACustomHUDGameMode : public AGameModeBase<br/>{<br/>    GENERATED_BODY()<br/><br/>    <strong>ACustomHUDGameMode();</strong><br/>    <br/>};</pre>
<ol start="4">
<li>Add the following to the constructor implementation:</li>
</ol>
<pre style="padding-left: 60px">#include "CustomHUDGameMode.h"<br/>#include "CustomHUD.h"<br/><br/>ACustomHUDGameMode::ACustomHUDGameMode() : AGameModeBase()<br/>{<br/>    HUDClass = ACustomHUD::StaticClass();<br/>}</pre>
<p style="padding-left: 60px">At this point, you will get compile errors, because the <kbd>CustomHUD</kbd> class does not exist. That is what we will be creating next.</p>
<ol start="5">
<li>Create a new <kbd>HUD</kbd> subclass using the Add C++ Class wizard:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/7830c68f-9f06-44ce-aedd-20e29710145d.png"/></p>
<ol start="6">
<li>When asked for the name, put in <kbd>CustomHUD</kbd>, and click on the Create Class button:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/279fff54-150b-4019-b6c1-fc9d9f07b0a0.png"/></p>
<ol start="7">
<li>Inside <kbd>CustomHUD.h</kbd>, add the following function with the <kbd>override</kbd> keyword to the class:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "GameFramework/HUD.h"<br/>#include "CustomHUD.generated.h"<br/><br/>/**<br/> * <br/> */<br/>UCLASS()<br/>class CHAPTER_14_API ACustomHUD : public AHUD<br/>{<br/>    GENERATED_BODY()<br/>    <br/><strong>public:</strong><br/><strong>    virtual void DrawHUD() override;</strong><br/><br/>};</pre>
<ol start="8">
<li>Now, implement the function:</li>
</ol>
<pre style="padding-left: 60px">#include "CustomHUD.h"<br/><strong>#include "Engine/Canvas.h"</strong><br/><br/><strong>void ACustomHUD::DrawHUD()</strong><br/><strong>{</strong><br/><strong>    Super::DrawHUD();</strong><br/><strong>    Canvas-&gt;DrawText(GEngine-&gt;GetSmallFont(), TEXT("Test string to be printed to screen"), 10, 10); </strong><br/><strong>    FCanvasBoxItem ProgressBar(FVector2D(5, 25), FVector2D(100, 5));</strong><br/><strong>    Canvas-&gt;DrawItem(ProgressBar);</strong><br/><strong>    DrawRect(FLinearColor::Blue, 5, 25, 100, 5);</strong><br/><strong>}</strong></pre>
<ol start="9">
<li>Compile your code and launch the editor.</li>
<li>Within the editor, open the World Settings panel from the Settings drop-down menu:</li>
</ol>
<p class="mce-root"/>
<p class="CDPAlignCenter CDPAlign"><img src="img/d725eff7-9368-40b6-a5da-84695df4ad25.jpg" style="width:20.50em;height:20.50em;"/></p>
<ol start="11">
<li>In the World Settings dialog, select <kbd>CustomHUDGameMode</kbd> from the list under GameMode Override:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/5ff91259-600d-482f-b002-6497a6fae2ee.jpg" style="width:25.17em;height:29.50em;"/></p>
<ol start="12">
<li>Play and verify that your custom HUD is drawing to the screen:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/a15e2c53-27d0-40fe-bd70-09c9464d1827.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>All the UI recipes here will be using Slate for drawing, so we need to add a dependency between our module and the Slate framework so that we can access the classes that have been declared in that module. The best place to put custom Canvas draw calls for a game HUD is inside a subclass of <kbd>AHUD</kbd>.</p>
<p>To tell the engine to use our custom subclass, though, we need to create a new <kbd>GameMode</kbd> and specify the type of our custom class.</p>
<p>Within the constructor of our custom Game Mode, we assign the <kbd>UClass</kbd> for our new HUD type to the <kbd>HUDClass</kbd> variable. This <kbd>UClass</kbd> is passed on to each player's controller as they spawn in, and the controller is then responsible for the <kbd>AHUD</kbd> instance that it creates.</p>
<p>With our custom <kbd>GameMode</kbd> loading our custom HUD, we need to actually create said custom HUD class. <kbd>AHUD</kbd> defines a virtual function called <kbd>DrawHUD()</kbd>, which is invoked in every frame to allow us to draw elements to the screen. As a result, we override that function and perform our drawing inside the implementation.</p>
<p>The first method that's used is as follows:</p>
<pre>float DrawText(constUFont* InFont, constFString&amp;InText, <br/> float X, float Y, float XScale = 1.f, float YScale = 1.f, <br/> constFFontRenderInfo&amp;RenderInfo = FFontRenderInfo());</pre>
<p><kbd>DrawText</kbd> requires a font to draw with. The default font used by <kbd>stat</kbd> and other HUD drawing commands in the engine code is actually stored in the <kbd>GEngine</kbd> class, and can be accessed by using the <kbd>GetSmallFont</kbd> function, which returns an instance of the <kbd>UFont</kbd> as a pointer.</p>
<p>The remaining arguments that we are using are the actual text that should be rendered, and the offset, in pixels, at which the text should be drawn.</p>
<p><kbd>DrawText</kbd> is a function that allows you to directly pass in the data that is to be displayed. The general <kbd>DrawItem</kbd> function is a Visitor implementation that allows you to create an object that encapsulates the information about the object to be drawn and reuse that object on multiple draw calls.</p>
<p>In this recipe, we create an element that can be used to represent a progress bar. We encapsulate the required information regarding the width and height of our box into an <kbd>FCanvasBoxItem</kbd>, which we then pass to the <kbd>DrawItem</kbd> function on our Canvas.</p>
<p>The third item that we draw is a filled rectangle. This function uses convenience methods that are defined in the HUD class rather than on the Canvas itself. The filled rectangle is placed at the same location as our <kbd>FCanvasBox</kbd> so that it can represent the current value inside the progress bar.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also...</h1>
                
            
            
                
<ul>
<li>Refer to <a href="c73bb4ba-4b7d-4aef-a33e-732f184d261f.xhtml">Chapter 10</a>, <em>Integrating C++ and the Unreal Editor – Part II,</em> and the <em>Creating new console commands</em> recipe within, to learn how to create your own console commands</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding Slate Widgets to the screen</h1>
                
            
            
                
<p>The previous recipe used the <kbd>FCanvas</kbd> API to draw to the screen. However, <kbd>FCanvas</kbd> suffers from a number of limitations, for example, animations are difficult to implement, and drawing graphics on the screen involves creating textures or materials. <kbd>FCanvas</kbd> also doesn't implement anything in the way of widgets or window controls, making data entry or other forms of user input more complex than necessary. This recipe will show you how to begin creating HUD elements on-screen using Slate, which provides a number of built-in controls.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Add <kbd>Slate</kbd> and <kbd>SlateCore</kbd> to your module's dependencies if you haven't done so already (see the <em>Drawing using Canvas</em> recipe to learn how to do this).</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create a new <kbd>PlayerController</kbd> subclass using the Add C++ Class wizard:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/7c52bf2e-a859-4474-8c1d-9cd54069694e.png"/></p>
<ol start="2">
<li>When asked for the name of the class, type in <kbd>CustomHUDPlayerController</kbd> and press the Create Class button:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/1ad35366-16d0-413a-bbb0-a5635ead359a.png"/></p>
<ol start="3">
<li>Override the <kbd>BeginPlay</kbd> virtual method within your new subclass:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "GameFramework/PlayerController.h"<br/>#include "CustomHUDPlayerController.generated.h"<br/><br/>/**<br/> * <br/> */<br/>UCLASS()<br/>class CHAPTER_14_API ACustomHUDPlayerController : public APlayerController<br/>{<br/>    GENERATED_BODY()<br/>    <br/><strong>public:</strong><br/><strong>    virtual void BeginPlay() override;</strong><br/><br/>};</pre>
<ol start="4">
<li>Add the following code for your overridden <kbd>BeginPlay()</kbd> virtual method inside the subclass' implementation:</li>
</ol>
<pre style="padding-left: 60px">#include "CustomHUDPlayerController.h"<br/><strong>#include "SlateBasics.h"</strong><br/><br/><br/><strong>void ACustomHUDPlayerController::BeginPlay()</strong><br/><strong>{</strong><br/><strong>    Super::BeginPlay();</strong><br/><strong>    TSharedRef&lt;SVerticalBox&gt; widget = SNew(SVerticalBox)</strong><br/><strong>        + SVerticalBox::Slot()</strong><br/><strong>        .HAlign(HAlign_Center)</strong><br/><strong>        .VAlign(VAlign_Center)</strong><br/><strong>        [</strong><br/><strong>            SNew(SButton)</strong><br/><strong>            .Content()</strong><br/><strong>        [</strong><br/><strong>            SNew(STextBlock)</strong><br/><strong>            .Text(FText::FromString(TEXT("Test button")))</strong><br/><strong>        ]</strong><br/><strong>        ];</strong><br/><strong>    GEngine-&gt;GameViewport-&gt;AddViewportWidgetForPlayer(GetLocalPlayer(), widget, 1);</strong><br/><strong>}</strong></pre>
<ol start="5">
<li>Create a new class based on <kbd>GameModeBase</kbd> called <kbd>SlateHUDGameMode</kbd>.</li>
<li>Add a constructor inside the Game Mode:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "GameFramework/GameModeBase.h"<br/>#include "SlateHUDGameMode.generated.h"<br/><br/>/**<br/> * <br/> */<br/>UCLASS()<br/>class CHAPTER_14_API ASlateHUDGameMode : public AGameModeBase<br/>{<br/>    GENERATED_BODY()<br/>    <br/><strong>    ASlateHUDGameMode();</strong><br/>};</pre>
<ol start="7">
<li>Implement the constructor with the following code:</li>
</ol>
<pre style="padding-left: 60px">#include "SlateHUDGameMode.h"<br/><strong>#include "CustomHUDPlayerController.h"</strong><br/><br/><strong>ASlateHUDGameMode::ASlateHUDGameMode() : Super()</strong><br/><strong>{</strong><br/><strong> PlayerControllerClass = ACustomHUDPlayerController::StaticClass();</strong><br/><strong>}</strong></pre>
<ol start="8">
<li>Within the Editor, open the World Settings menu from the toolbar by going to Settings | World Settings:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/826cba58-111f-40cf-8ff5-4d6c56bf5a45.jpg" style="width:18.00em;height:9.50em;"/></p>
<ol start="9">
<li>Inside World Settings, override the level's Game Mode to be our <kbd>SlateHUDGameMode</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/9f73bfe4-1610-4d0c-b44b-b14e786dbbc7.jpg" style="width:25.50em;height:29.17em;"/></p>
<ol start="10">
<li>Play the level. You will see your new UI displayed on the screen:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/2347b898-a48c-495d-84ce-d06b195e3021.png"/></p>
<p>Button located on the game screen</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>For us to reference Slate classes or functions in our code, our module must link with the <kbd>Slate</kbd> and <kbd>SlateCore</kbd> modules, so we add those to the module dependencies.</p>
<p>We need to instantiate our UI in one of the classes that loads when the game runs, so for this recipe, we use our custom <kbd>PlayerController</kbd> in the <kbd>BeginPlay</kbd> function as the place to create our UI.</p>
<p>Inside the <kbd>BeginPlay</kbd> implementation, we create a new <kbd>SVerticalBox</kbd> using the <kbd>SNew</kbd> function. We add a slot for a widget to our box, and set that slot to both horizontal and vertical centering.</p>
<p>Inside the slot, which we access using square brackets, we create a button that has <kbd>Textblock</kbd> inside it. In <kbd>Textblock</kbd>, we set the <kbd>Text</kbd> property to a string literal value.</p>
<p>With the UI now created, we call <kbd>AddViewportWidgetForPlayer</kbd> to display this widget on the local player's screen.</p>
<p>With our custom <kbd>PlayerController</kbd> ready, we now need to create a custom <kbd>GameMode</kbd> to specify that it should use our new <kbd>PlayerController</kbd>. With the custom <kbd>PlayerController</kbd> being loaded at the start of the game, when <kbd>BeginPlay</kbd> is called, our UI will be shown.</p>
<p>The UI is very small at this screen size. Refer to the following recipe for information on how to scale it appropriately for the resolution of the game window.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating screen size-aware scaling for the UI</h1>
                
            
            
                
<p>If you have followed the previous recipe, you will notice that when you use <strong>Play In Editor</strong>, the button that loads is unusually small.</p>
<p>The reason for this is UI Scaling, a system that allows you to scale the user interface based on the screen size. User interface elements are represented in terms of pixels, usually in absolute terms (the button should be 10 pixels tall).</p>
<p>The problem with this is that if you use a higher-resolution panel, 10 pixels might be much smaller, because each pixel is smaller in size.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>The UI scaling system in Unreal allows you to control a global scale modifier, which will scale all the controls on the screen based on the screen resolution. Given the previous example, you might wish to adjust the size of the button so that its apparent size is unchanged when you view your UI on a smaller screen. This recipe shows two different methods for altering the scaling rates.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create a custom <kbd>PlayerController</kbd> subclass. Call it <kbd>ScalingUIPlayerController</kbd>.</li>
<li>Inside the class, override <kbd>BeginPlay</kbd>:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "GameFramework/PlayerController.h"<br/>#include "ScalingUIPlayerController.generated.h"<br/><br/>/**<br/> * <br/> */<br/>UCLASS()<br/>class CHAPTER_14_API AScalingUIPlayerController : public APlayerController<br/>{<br/>    GENERATED_BODY()<br/>    <br/><strong>public:</strong><br/><strong>    virtual void BeginPlay() override;</strong><br/>};<br/> </pre>
<ol start="3">
<li>Add the following code in the implementation of that function inside of <kbd>ScalingUIPlayerController.cpp</kbd>:</li>
</ol>
<pre style="padding-left: 60px">#include "ScalingUIPlayerController.h"<br/><strong>#include "SlateBasics.h"</strong><br/><br/><strong>void AScalingUIPlayerController::BeginPlay()</strong><br/><strong>{</strong><br/><strong>    Super::BeginPlay();</strong><br/><strong>    TSharedRef&lt;SVerticalBox&gt; widget = SNew(SVerticalBox)</strong><br/><strong>        + SVerticalBox::Slot()</strong><br/><br/><strong>        .HAlign(HAlign_Center)</strong><br/><strong>        .VAlign(VAlign_Center)</strong><br/><strong>        [</strong><br/><strong>            SNew(SButton)</strong><br/><strong>            .Content()</strong><br/><strong>        [</strong><br/><strong>            SNew(STextBlock)</strong><br/><strong>            .Text(FText::FromString(TEXT("Test button")))</strong><br/><strong>        ]</strong><br/><strong>        ];</strong><br/><strong>    GEngine-&gt;GameViewport-&gt;AddViewportWidgetForPlayer(GetLocalPlayer(), widget, 1);</strong><br/><strong>}</strong></pre>
<ol start="4">
<li>Create a new <kbd>GameModeBase</kbd> subclass called <kbd>ScalingUIGameMode</kbd> and give it a default constructor:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "GameFramework/GameModeBase.h"<br/>#include "ScalingUIGameMode.generated.h"<br/><br/>/**<br/> * <br/> */<br/>UCLASS()<br/>class CHAPTER_14_API AScalingUIGameMode : public AGameModeBase<br/>{<br/>    GENERATED_BODY()<br/>    <br/><strong>    AScalingUIGameMode();</strong><br/>};</pre>
<ol start="5">
<li>Within the default constructor, set the default player controller class to <kbd>ScalingUIPlayerController</kbd>:</li>
</ol>
<pre style="padding-left: 60px">#include "ScalingUIGameMode.h"<br/>#include "CustomHUDPlayerController.h"<br/><br/>AScalingUIGameMode::AScalingUIGameMode() : AGameModeBase()<br/>{<br/>    PlayerControllerClass = ACustomHUDPlayerController::StaticClass();<br/>}</pre>
<ol start="6">
<li>Save and compile your new classes.</li>
<li>Within the Editor, open the World Settings menu from the toolbar by going to Settings | World Settings.
<ol start="9"/>
</li>
<li>Inside World Settings, override the level's Game Mode to be our <kbd>ScalingUIGameMode</kbd>.</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/02f9189c-7fad-4349-8bb7-195579247691.png" style="width:26.25em;height:16.58em;"/></p>
<p class="mce-root"/>
<p>This should give you a user interface like the one from the previous recipe. Note that the UI is very tiny if you use Play In Editor:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/d136a6b5-4043-4f09-8443-541766ef6a1c.png"/></p>
<p>Tiny button on the game screen </p>
<p>To alter the rate at which the UI scales down or up, we need to change the scaling curve. We can do that through two different methods.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using the In-Editor method</h1>
                
            
            
                
<ol>
<li>Launch Unreal, then open the Project Settings dialog through the Edit menu:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/4bf372f4-6819-4ee5-96f2-662d40adc52c.jpg" style="width:29.67em;height:29.33em;"/></p>
<ol start="2">
<li>Under the Engine - User Interface section, there is a curve called the DPI Curve, which can be used to alter the UI scaling factor based on the short dimension of your screen:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/b3a198bb-bb69-47ea-a3d9-61f52351f475.png"/></p>
<ol start="3">
<li>Click on the second dot, or keypoint, on the graph.</li>
<li>Change its Scale value to <kbd>1</kbd>. Then, do the same for the first dot and set its Scale value to <kbd>1</kbd> as well:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/71b43d27-052b-49b2-a2f5-28c1e89ae87c.png"/></p>
<ol start="5">
<li>Return to the main editor and run the game again. You should notice that the button is larger than it was before:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/91c6e745-0bc1-4555-9288-fe5dca318431.png"/></p>
<p>Easier to see button on the game screen</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Using the Config file method</h1>
                
            
            
                
<ol>
<li>Browse to your project directory and look inside the <kbd>Config</kbd> folder:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/e4843569-d39c-408e-a063-9829f0467739.png"/></p>
<ol start="2">
<li>Open <kbd>DefaultEngine.ini</kbd>, which is located in the <kbd>Config</kbd> folder of your project, inside your text editor of choice.</li>
<li>Find the <kbd>[/Script/Engine.UserInterfaceSettings]</kbd> section:</li>
</ol>
<pre style="padding-left: 60px">[/Script/Engine.UserInterfaceSettings]<br/>UIScaleCurve=(EditorCurveData=(PreInfinityExtrap=RCCE_Constant,PostInfinityExtrap=RCCE_Constant,DefaultValue=340282346638528859811704183484516925440.000000,Keys=((Time=480.000000,Value=1.000000),(Time=720.000000,Value=1.000000),(Time=1080.000000,Value=1.000000),(Time=8640.000000,Value=8.000000))),ExternalCurve=None)</pre>
<ol start="4">
<li>Look for a key called <kbd>UIScaleCurve</kbd> in that section.</li>
<li>In the value for that key, you'll notice a number of <kbd>(Time=x,Value=y)</kbd> pairs. Edit the second pair so that its <kbd>Time</kbd> value is <kbd>720.000000</kbd> and the <kbd>Value</kbd> is <kbd>1.000000</kbd> if it isn't already.</li>
<li>Restart the editor if you have it open.</li>
<li>Start the Play In Editor preview to confirm that your UI now remains readable at the <strong>PIE</strong> screen's resolution (assuming you are using a 1080p monitor so that the PIE window is running at 720p or thereabouts):</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/288286d3-a546-4e7b-b440-5fc65abe4c8a.jpg" style="width:38.67em;height:33.58em;"/></p>
<ol start="8">
<li>You can also see how the scaling works if you use a New Editor Window to preview your game.</li>
<li>To do so, click on the arrow to the right of Play on the toolbar.</li>
<li>Select New Editor Window.</li>
<li>Inside this window, you can use the console command <kbd>r.SetRes widthxheight</kbd> to change the resolution (for example, <kbd>r.SetRes 200x200</kbd>), and observe the changes that result from doing so.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>As usual, when we want to use a custom <kbd>PlayerController</kbd>, we need a custom <kbd>GameMode</kbd> to specify which <kbd>PlayerController</kbd> to use.</p>
<p>We create both a custom <kbd>PlayerController</kbd> and <kbd>GameMode</kbd>, and then place some <kbd>Slate</kbd> code in the <kbd>BeginPlay</kbd> method of <kbd>PlayerController</kbd> so that some UI elements are drawn.</p>
<p>Because the main game viewport is usually quite small within the Unreal editor, the UI initially shows in a scaled-down fashion. This is intended to allow for the game UI to take up less room on smaller resolution displays, but this can have the side effect of making the text very difficult to read if the window isn't being stretched to fit the full screen.</p>
<p>Unreal stores the configuration data that should persist between sessions but not necessarily be hard coded into the executable inside config files. Config files use an extended version of the <kbd>.ini</kbd> file format, which has been commonly used with Windows software.</p>
<p>Config files store data using the following syntax:</p>
<pre>[Section Name] 
Key=Value </pre>
<p>Unreal has a <kbd>UserInterfaceSettings</kbd> class, with a property called <kbd>UIScaleCurve</kbd> on it. That <kbd>UPROPERTY</kbd> is marked as config, so Unreal serializes the value to the <kbd>.ini</kbd> file.</p>
<p>As a result, it stores the <kbd>UIScale</kbd> data in the <kbd>DefaultEngine.ini</kbd> file, in the <kbd>Engine.UserInterfaceSettings</kbd> section.</p>
<p>The data is stored using a text format, which contains a list of key points. Editing the <kbd>Time</kbd>, <kbd>Value</kbd> pairs alters or adds new key points to the curve.</p>
<p>The Project Settings dialog is a simple frontend for directly editing the <kbd>.ini</kbd> files yourself, and for designers, it is an intuitive way to edit the curve. However, having the data stored textually allows for programmers to potentially develop build tools that modify properties such as <kbd>UIScale</kbd> without having to recompile their game.</p>
<p><kbd>Time</kbd> refers to the input value. In this case, the input value is the narrower dimension of the screen (usually, the height).</p>
<p><kbd>Value</kbd> is the universal scaling factor that's applied to the UI when the screen's narrow dimension is approximately the height of the value in the <kbd>Time</kbd> field.</p>
<p>So, to set the UI to remain normal-sized at a 1280 x 720 resolution, set the time/input factor to 720 and the scale factor to 1.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>You can refer to the UE4 documentation for more information regarding config files: <a href="https://docs.unrealengine.com/en-US/Programming/Basics/ConfigurationFiles">https://docs.unrealengine.com/en-US/Programming/Basics/ConfigurationFiles</a>.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Displaying and hiding a sheet of UMG elements in-game</h1>
                
            
            
                
<p>We have already discussed how to add a widget to the viewport, which means that it will be rendered on the player's screen.</p>
<p>However, what if we want to have UI elements that are toggled based on other factors, such as proximity to certain Actors, or a player holding a key down, or if we want a UI that disappears after a specified time?</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create a new <kbd>GameModeBase</kbd> class called <kbd>ToggleHUDGameMode</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/ebab40ac-26b7-46a2-906b-b5eead0b1736.png"/></p>
<ol start="2">
<li>Add the following <kbd>UPROPERTY</kbd> and function definitions to the <kbd>ToggleHUDGameMode.h</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "GameFramework/GameModeBase.h"<br/><strong>#include "SlateBasics.h"</strong><br/>#include "ToggleHUDGameMode.generated.h"<br/><br/>UCLASS()<br/>class CHAPTER_14_API AToggleHUDGameMode : public AGameModeBase<br/>{<br/> GENERATED_BODY()<br/> <br/><strong>public:</strong><br/><strong> UPROPERTY()</strong><br/><strong> FTimerHandle HUDToggleTimer;</strong><br/><br/><strong> TSharedPtr&lt;SVerticalBox&gt; widget;</strong><br/><br/><strong> virtual void BeginPlay() override;</strong><br/><strong> virtual void EndPlay(const EEndPlayReason::Type EndPlayReason) override;</strong><br/>};</pre>
<ol start="3">
<li>Implement <kbd>BeginPlay</kbd> with the following code in the method body:</li>
</ol>
<pre style="padding-left: 60px">void AToggleHUDGameMode::BeginPlay()<br/>{<br/>    Super::BeginPlay();<br/>    widget = SNew(SVerticalBox)<br/>        + SVerticalBox::Slot()<br/>        .HAlign(HAlign_Center)<br/>        .VAlign(VAlign_Center)<br/>        [<br/>            SNew(SButton)<br/>            .Content()<br/>        [<br/>            SNew(STextBlock)<br/>            .Text(FText::FromString(TEXT("Test button")))<br/>        ]<br/>        ];<br/><br/>    auto player = GetWorld()-&gt;GetFirstLocalPlayerFromController();<br/><br/>    GEngine-&gt;GameViewport-&gt;AddViewportWidgetForPlayer(player, widget.ToSharedRef(), 1);<br/><br/>    auto lambda = FTimerDelegate::CreateLambda<br/>    ([this]<br/>    {<br/>        if (this-&gt;widget-&gt;GetVisibility().IsVisible())<br/>        {<br/>            this-&gt;widget-&gt;SetVisibility(EVisibility::Hidden);<br/><br/>        }<br/>        else<br/>        {<br/>            this-&gt;widget-&gt;SetVisibility(EVisibility::Visible);<br/>        }<br/>    });<br/><br/>    GetWorld()-&gt;GetTimerManager().SetTimer(HUDToggleTimer, lambda, 5, true);<br/>}</pre>
<ol start="4">
<li>Implement <kbd>EndPlay</kbd>:</li>
</ol>
<pre>void AToggleHUDGameMode::EndPlay(const EEndPlayReason::Type EndPlayReason)<br/>{<br/>    Super::EndPlay(EndPlayReason);<br/>    GetWorld()-&gt;GetTimerManager().ClearTimer(HUDToggleTimer);<br/>}</pre>
<ol start="5">
<li>Compile your code and start the editor.</li>
<li>Within the Editor, open World Settings from the toolbar:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/e117fa02-d7d4-447a-a504-6350baad3827.jpg" style="width:19.08em;height:10.08em;"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="7">
<li>Inside World Settings, override the level's Game Mode to be our <kbd>AToggleHUDGameMode</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/3eb58755-c6a1-4830-973d-c23df59487c3.jpg" style="width:25.17em;height:26.25em;"/></p>
<ol start="8">
<li>Play the level and verify that the UI toggles its visibility every five seconds.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>As with most of the other recipes in this chapter, we are using a custom <kbd>GameMode</kbd> class to display our single-player UI on the player's viewport for convenience.</p>
<p>We override <kbd>BeginPlay</kbd> and <kbd>EndPlay</kbd> so that we can correctly handle the timer that will be toggling our UI on and off for us. To make that possible, we need to store a reference to the timer as a <kbd>UPROPERTY</kbd> to ensure it won't be garbage collected.</p>
<p>Within <kbd>BeginPlay</kbd>, we create a new <kbd>VerticalBox</kbd> using the <kbd>SNew</kbd> macro, and place a button in its first slot. Buttons have <kbd>Content</kbd>, which can be some other widget to host inside them, such as <kbd>SImage</kbd> or <kbd>STextBlock</kbd>.</p>
<p>In this instance, we place an <kbd>STextBlock</kbd> into the <kbd>Content</kbd> slot. The contents of the text block are irrelevant, that is, as long as they are long enough for us to be able to see our button properly.</p>
<p>Having initialized our widget hierarchy, we add the root widget to the player's viewport so that it can be seen by them.</p>
<p>Now, we set up a timer to toggle the visibility of our widget. We are using a timer to simplify this recipe rather than having to implement user input and input bindings, but the principle is the same. To do this, we get a reference to the game world and its associated timer manager.</p>
<p>With the timer manager in hand, we can create a new timer. However, we need to actually specify the code to run when the timer expires. One simple way to do this is to use a <kbd>lambda</kbd> function for our toggle the hud function.</p>
<p>Lambdas are anonymous functions. Think of them as literal functions. To link a <kbd>lambda</kbd> function to the timer, we need to create a <kbd>timer</kbd> delegate.</p>
<p>The <kbd>FTimerDelegate::CreateLambda</kbd> function is designed to convert a <kbd>lambda</kbd> function into a delegate, which the timer can call at the specified interval.</p>
<p>The <kbd>lambda</kbd> needs to access the <kbd>this</kbd> pointer from its containing object, our <kbd>GameMode</kbd>, so that it can change properties on the widget instance that we have created. To give it the access it needs, we begin our <kbd>lambda</kbd> declaration with the <kbd>[]</kbd> operators, which enclose variables that should be captured into the <kbd>lambda</kbd>, and are accessible inside it. The curly braces then enclose the function body in the same way they would with a normal function declaration.</p>
<p>Inside the function, we check if our widget is visible. If it is visible, then we hide it using <kbd>SWidget::SetVisibility</kbd>. If the widget isn't visible, then we turn it on using the same function call.</p>
<p>In the rest of the call to <kbd>SetTimer</kbd>, we specify the interval (in seconds) to call the timer, and set the timer to loop.</p>
<p>One thing we need to be careful of, though, is the possibility of our object being destroyed between two timer invocations, potentially leading to a crash if a reference to our object is left dangling. To fix this, we need to remove the timer.</p>
<p>Given that we set the timer during <kbd>BeginPlay</kbd>, it makes sense to clear the timer during <kbd>EndPlay</kbd>. <kbd>EndPlay</kbd> will be called whenever <kbd>GameMode</kbd> either ends play or is destroyed, so we can safely cancel the timer during its implementation.</p>
<p>With <kbd>GameMode</kbd> set as the default game mode, the UI is created when the game begins to play, and the timer delegate executes every five seconds to switch the visibility of the widgets between <kbd>true</kbd> and <kbd>false</kbd>.</p>
<p>When you close the game, <kbd>EndPlay</kbd> clears the timer reference, avoiding any problems.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Attaching function calls to Slate events</h1>
                
            
            
                
<p>While creating buttons is all well and good, at the moment, any UI element you add to the player's screen just sits there without anything happening, even if a user clicks on it. We don't have any event handlers attached to the Slate elements at the moment, so events such as mouse clicks don't actually cause anything to happen.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe shows you how to attach functions to these events so that we can run custom code when they occur.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create a new <kbd>GameModeBase</kbd> subclass called <kbd>ClickEventGameMode</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/ee48dd37-65bb-47a8-aab4-41abb8f4e351.png"/></p>
<p class="mce-root"/>
<ol start="2">
<li>From the <kbd>ClickEventGameMode.h</kbd> file, add the following functions and <kbd>private</kbd> members to the class:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "GameFramework/GameModeBase.h"<br/><strong>#include "SlateBasics.h"</strong><br/>#include "ClickEventGameMode.generated.h"<br/><br/>UCLASS()<br/>class CHAPTER_14_API AClickEventGameMode : public AGameModeBase<br/>{<br/>    GENERATED_BODY()<br/>    <br/><strong>private:</strong><br/><strong>    TSharedPtr&lt;SVerticalBox&gt; Widget;</strong><br/><strong>    TSharedPtr&lt;STextBlock&gt; ButtonLabel;</strong><br/><br/><strong>public:</strong><br/><strong>    virtual void BeginPlay() override;</strong><br/><strong>    FReply ButtonClicked();</strong><br/>};</pre>
<ol start="3">
<li>Within the <kbd>.cpp</kbd> file, add the implementation for <kbd>BeginPlay</kbd>:</li>
</ol>
<pre style="padding-left: 60px">void AClickEventGameMode::BeginPlay()<br/>{<br/>    Super::BeginPlay();<br/><br/>    Widget = SNew(SVerticalBox)<br/>        + SVerticalBox::Slot()<br/>        .HAlign(HAlign_Center)<br/>        .VAlign(VAlign_Center)<br/>        [<br/>            SNew(SButton)<br/>            .OnClicked(FOnClicked::CreateUObject(this, &amp;AClickEventGameMode::ButtonClicked))<br/>        .Content()<br/>        [<br/>            SAssignNew(ButtonLabel, STextBlock)<br/>            .Text(FText::FromString(TEXT("Click me!")))<br/>        ]<br/>        ];<br/><br/>    auto player = GetWorld()-&gt;GetFirstLocalPlayerFromController();<br/><br/>    GEngine-&gt;GameViewport-&gt;AddViewportWidgetForPlayer(player, Widget.ToSharedRef(), 1);<br/><br/>    GetWorld()-&gt;GetFirstPlayerController()-&gt;bShowMouseCursor = true;<br/><br/>    auto pc = GEngine-&gt;GetFirstLocalPlayerController(GetWorld());<br/><br/>    EMouseLockMode lockMode = EMouseLockMode::DoNotLock;<br/><br/>    auto inputMode = FInputModeUIOnly().SetLockMouseToViewportBehavior(lockMode).SetWidgetToFocus(Widget);<br/><br/>    pc-&gt;SetInputMode(inputMode);<br/><br/>}</pre>
<ol start="4">
<li>Also, add an implementation for <kbd>ButtonClicked()</kbd>:</li>
</ol>
<pre style="padding-left: 60px">FReply AClickEventGameMode::ButtonClicked()<br/>{<br/>    ButtonLabel-&gt;SetText(FString(TEXT("Clicked!")));<br/>    return FReply::Handled();<br/>}</pre>
<ol start="5">
<li>Compile your code and launch the editor.</li>
<li>Override the game mode in World Settings to be <kbd>ClickEventGameMode</kbd>.</li>
<li>Preview this in the editor and verify that the UI shows a button that changes from Click Me! to Clicked! when you use the mouse cursor to click on it:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/72e77d50-3b49-4973-b4ac-bddae6bbe8cc.png" style="width:58.25em;height:31.58em;"/></p>
<p>Button displays Clicked! after being clicked</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>As with most of the recipes in this chapter, we use <kbd>GameMode</kbd> to create and display our UI to minimize the number of classes that are extraneous to the point of the recipe that you need to create.</p>
<p>Within our new game mode, we need to retain references to the Slate Widgets that we create so that we can interact with them after their creation.</p>
<p>As a result, we create two shared pointers as member data within our <kbd>GameMode</kbd> – one to the overall parent or root widget of our UI, and the other to the label on our button, because we're going to be changing the label text at runtime later.</p>
<p>We override <kbd>BeginPlay</kbd>, as it is a convenient place to create our UI after the game has started, and we will be able to get valid references to our player controller.</p>
<p>We also create a function called <kbd>ButtonClicked</kbd>. It returns <kbd>FReply</kbd>, a <kbd>struct</kbd> indicating if an event was handled. The function signature for <kbd>ButtonClicked</kbd> is determined by the signature of <kbd>FOnClicked</kbd>, a delegate that we will be using in a moment.</p>
<p class="mce-root"/>
<p>Inside our implementation of <kbd>BeginPlay</kbd>, the first thing we do is call the implementation we are overriding to ensure that the class is initialized appropriately.</p>
<p>Then, as usual, we use our <kbd>SNew</kbd> function to create <kbd>VerticalBox</kbd>, and we add a slot to it, which is centered.</p>
<p>We create a new <kbd>Button</kbd> inside that slot, and we add a value to the <kbd>OnClicked</kbd> attribute that the button contains.</p>
<p><kbd>OnClicked</kbd> is a delegate property. This means that the <kbd>Button</kbd> will broadcast the <kbd>OnClicked</kbd> delegate any time a certain event happens (as the name implies in this instance, when the button is clicked).</p>
<p>To subscribe or listen to the delegate, and be notified of the event that it refers to, we need to assign a delegate instance to the property.</p>
<p>We do that using the standard delegate functions such as <kbd>CreateUObject</kbd>, <kbd>CreateStatic</kbd>, or <kbd>CreateLambda</kbd>. Any of those will work – we can bind <kbd>UObject</kbd> member functions, static functions, lambdas, and other functions.</p>
<div><br/>
Check out <a href="cf821ef4-8a19-440c-805d-573748b76d5f.xhtml">Chapter 5</a>, <em>Handling Events and Delegates,</em> to learn more about delegates and look at the other types of functions that we can bind to delegates.</div>
<p><kbd>CreateUObject</kbd> expects a pointer to a class instance, and a pointer to the member function that's defined in that class to call. The function has to have a signature that can be converted into the signature of the delegate:</p>
<pre>/** The delegate to execute when the button is clicked */<br/> FOnClickedOnClicked;</pre>
<p>As we can see, the <kbd>OnClicked</kbd> delegate type is <kbd>FOnClicked</kbd> – this is why the <kbd>ButtonClicked</kbd> function that we declared has the same signature as <kbd>FOnClicked</kbd>.</p>
<p>By passing in a pointer to this, and the pointer to the function to invoke, the engine will call that function on this specific object instance when the button is clicked.</p>
<p>After setting up the delegate, we use the <kbd>Content()</kbd> function, which returns a reference to the single slot that the button has for any content that it should contain.</p>
<p>We then use <kbd>SAssignNew</kbd> to create our button's label by using the <kbd>TextBlock</kbd> widget. <kbd>SAssignNew</kbd> is important because it allows us to use Slate's declarative syntax, and yet assigns variables to point to specific child widgets in the hierarchy. <kbd>SAssignNew</kbd>'s first argument is the variable that we want to store the widget in, and the second argument is the type of that widget.</p>
<p>With <kbd>ButtonLabel</kbd> now pointing at our button's <kbd>TextBlock</kbd>, we can set its <kbd>Text</kbd> attribute to a static string.</p>
<p>Finally, we add the widget to the player's viewport using <kbd>AddViewportWidgetForPlayer</kbd>, which expects, as parameters, <kbd>LocalPlayer</kbd> to add the widget to, the widget itself, and a depth value (higher values to the front).</p>
<p>To get the <kbd>LocalPlayer</kbd> instance, we assume we are running without split screen, and so the first player controller will be the only one, that is, the player's controller. The <kbd>GetFirstLocalPlayerFromController</kbd> function is a convenience function that simply fetches the first player's controller and returns its local player object.</p>
<p>We also need to focus the widget so that the player can click on it and display a cursor so that the player knows where their mouse is on the screen.</p>
<p>We know from the previous step that we can assume the first local player controller is the one we're interested in, so we can access it and change its <kbd>ShowMouseCursor</kbd> variable to <kbd>true</kbd>. This will cause the cursor to be rendered on screen.</p>
<p><kbd>SetInputMode</kbd> allows us to focus on a widget so that the player can interact with it among other UI-related functionality, such as locking the mouse to the game's viewport. It uses an <kbd>FInputMode</kbd> object as its only parameter, which we can construct with the specific elements that we wish to include by using the <kbd>builder</kbd> pattern.</p>
<p>The <kbd>FInputModeUIOnly</kbd> class is an <kbd>FInputMode</kbd> subclass that specifies that we want all input events to be redirected to the UI layer rather than the player controller and other input handling.</p>
<p>The <kbd>builder</kbd> pattern allows us to chain the method calls to customize our object instance before it is sent into the function as the parameter.</p>
<p>We chain <kbd>SetLockMouseToViewport(false)</kbd> to specify that the player's mouse can leave the boundary of the game screen with <kbd>SetWidgetToFocus(Widget)</kbd>, which specifies our top-level widget as the one that the game should direct player input to.</p>
<p class="mce-root"/>
<p>Finally, we have our actual implementation for <kbd>ButtonClicked</kbd>, which is our event handler. When the function is run due to our button being clicked, we change our button's label to indicate it has been clicked. We then need to return an instance of <kbd>FReply</kbd> to the caller to let the UI framework know that the event has been handled, and to not continue propagating the event back up the widget hierarchy.</p>
<p><kbd>FReply::Handled()</kbd> returns <kbd>FReply</kbd> set up to indicate this to the framework. We could have used <kbd>FReply::Unhandled()</kbd>, but this would have told the framework that the click event wasn't actually the one we were interested in, and it should look for other objects that might be interested in the event instead.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using Data Binding with Unreal Motion Graphics</h1>
                
            
            
                
<p>So far, we've been assigning static values to the attributes of our UI widgets. However, what if we want to be more dynamic with widget content, or parameters such as border color? We can use a principle called data binding to dynamically link properties of our UI with variables in the broader program.</p>
<p>Unreal uses the Attribute system to allow us to bind the value of an attribute to the return value from a function, for example. This means that changing those variables will automatically cause the UI to change in response, according to our wishes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create a new <kbd>GameModeBase</kbd> subclass called <kbd>AttributeGameMode</kbd>.</li>
<li>Update the <kbd>AttributeGameMode.h</kbd> file to the following: </li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "GameFramework/GameStateBase.h"<br/><strong>#include "SlateBasics.h"</strong><br/>#include "AttributeGameMode.generated.h"<br/><br/>/**<br/> * <br/> */<br/>UCLASS()<br/>class CHAPTER_14_API AAttributeGameMode : public AGameModeBase<br/>{<br/> GENERATED_BODY()<br/><br/><strong> TSharedPtr&lt;SVerticalBox&gt; Widget;</strong><br/><strong> FText GetButtonLabel() const;</strong><br/><br/><strong>public:</strong><br/><strong> virtual void BeginPlay() override;</strong><br/> <br/>};</pre>
<ol start="3">
<li>Add the implementation for <kbd>BeginPlay</kbd> within the <kbd>.cpp</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">void AAttributeGameMode::BeginPlay()<br/>{<br/>    Super::BeginPlay();<br/><br/>    Widget = SNew(SVerticalBox)<br/>        + SVerticalBox::Slot()<br/>        .HAlign(HAlign_Center)<br/>        .VAlign(VAlign_Center)<br/>        [<br/>            SNew(SButton)<br/>            .Content()<br/>        [<br/>            SNew(STextBlock)<br/>            .Text(TAttribute&lt;FText&gt;::Create(TAttribute&lt;FText&gt;::FGetter::CreateUObject(this, &amp;AAttributeGameMode::GetButtonLabel)))<br/>        ]<br/>        ];<br/>    GEngine-&gt;GameViewport-&gt;AddViewportWidgetForPlayer(GetWorld()-&gt;GetFirstLocalPlayerFromController(), Widget.ToSharedRef(), 1);<br/><br/>}</pre>
<ol start="4">
<li>Also, add an implementation for <kbd>GetButtonLabel()</kbd>:</li>
</ol>
<pre style="padding-left: 60px">FText AAttributeGameMode::GetButtonLabel() const<br/>{<br/>    FVector ActorLocation = GetWorld()-&gt;GetFirstPlayerController()-&gt;GetPawn()-&gt;GetActorLocation();<br/>    return FText::FromString(FString::Printf(TEXT("%f, %f, %f"), ActorLocation.X, ActorLocation.Y, ActorLocation.Z));<br/>}</pre>
<ol start="5">
<li>Compile your code and launch the editor.</li>
<li>Override the game mode in World Settings to be <kbd>AAttributeGameMode</kbd>.</li>
</ol>
<ol start="7">
<li>Note that, in a Play In Editor session, the value on the UI's button changes as the player moves around the scene:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/2154c05b-1acb-4ebe-b7ec-beea999cb541.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Just like almost all the other recipes in this chapter, the first thing we need to do is create a game mode as a convenient host for our UI. We create the UI in the same fashion as in the other recipes, that is, by placing <kbd>Slate</kbd> code inside the <kbd>BeginPlay()</kbd> method of our game mode.</p>
<p>The interesting feature of this recipe concerns how we set the value of our button's label text:</p>
<pre>.Text( <br/> TAttribute&lt;FText&gt;::Create(TAttribute&lt;FText&gt;::FGetter::Creat<br/> eUObject(this, &amp;AAttributeGameMode::GetButtonLabel)))</pre>
<p>The preceding syntax is unusually verbose, but what it is actually doing is comparatively simple. We assign something to the <kbd>Text</kbd> property, which is of the type <kbd>FText</kbd>. We can assign <kbd>TAttribute&lt;FText&gt;</kbd> to this property, and the <kbd>TAttribute Get()</kbd> method will be called whenever the UI wants to ensure that the value of <kbd>Text</kbd> is up to date.</p>
<p>To create <kbd>TAttribute</kbd>, we need to call the static <kbd>TAttribute&lt;VariableType&gt;::Create()</kbd> method. This function expects a delegate of some description. Depending on the type of delegate that's passed to <kbd>TAttribute::Create</kbd>, <kbd>TAttribute::Get()</kbd> invokes a different type of function to retrieve the actual value.</p>
<p>In the code for this recipe, we invoke a member function of <kbd>UObject</kbd>. This means that we know we will be calling the <kbd>CreateUObject</kbd> function on some delegate type.</p>
<p>We can use <kbd>CreateLambda</kbd>, <kbd>CreateStatic</kbd>, or <kbd>CreateRaw</kbd> to invoke a <kbd>lambda</kbd>, a <kbd>static</kbd>, or a <kbd>member</kbd> function on a raw C++ class, respectively. This will give us the current value for the attribute.</p>
<p>But what delegate type do we want to create an instance of? Because we're templating the <kbd>TAttribute</kbd> class on the actual variable type that the attribute will be associated with, we need a delegate that is also templated on the variable type as its return value.</p>
<p>That is to say, if we have <kbd>TAttribute&lt;FText&gt;</kbd>, the delegate that's connected to it needs to return an <kbd>FText</kbd>.</p>
<p>We have the following code within <kbd>TAttribute</kbd>:</p>
<pre>template&lt;typenameObjectType&gt;<br/> classTAttribute<br/> {<br/> public:<br/> /**<br/> * Attribute 'getter' delegate<br/> *<br/> * ObjectTypeGetValue() const<br/> *<br/> * @return The attribute's value<br/> */<br/> DECLARE_DELEGATE_RetVal(ObjectType, FGetter);<br/> (...)<br/> }</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>The <kbd>FGetter</kbd> delegate type is declared inside the <kbd>TAttribute</kbd> class, so its return value can be templated on the <kbd>ObjectType</kbd> parameter of the <kbd>TAttribute</kbd> template. This means that <kbd>TAttribute&lt;Typename&gt;::FGetter</kbd> automatically defines a delegate with the correct return type of <kbd>Typename</kbd>. So, we need to create a UObject-bound delegate of type and signature for <kbd>TAttribute&lt;FText&gt;::FGetter</kbd>.</p>
<p>Once we have that delegate, we can call <kbd>TAttribute::Create</kbd> on the delegate to link the delegate's return value to our <kbd>TextBlock</kbd> member variable <kbd>Text</kbd>. With our UI defined and a binding between the <kbd>Text</kbd> property, a <kbd>TAttribute&lt;FText&gt;</kbd>, and a delegate returning <kbd>FText</kbd>, we can now add the UI to the player's screen so that it's visible.</p>
<p>Every frame, the game engine checks all of the properties to see if they are linked to <kbd>TAttributes</kbd>. If there's a connection, then the <kbd>TAttribute</kbd><kbd>Get()</kbd> function is called, invoking the delegate and returning the delegate's return value so that Slate can store it inside the widget's corresponding member variable.</p>
<p>For our demonstration of this process, <kbd>GetButtonLabel</kbd> retrieves the location of the first player pawn in the game world. We then use <kbd>FString::Printf</kbd> to format the location data into a human readable string, and wrap that in an <kbd>FText</kbd> so that it can be stored as the <kbd>TextBlock</kbd> text value.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Controlling widget appearance with Styles</h1>
                
            
            
                
<p>So far in this chapter, we've been creating UI elements that use the default visual representation. This recipe shows you how to create a Style in C++ that can be used as a common look and feel across your whole project.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create a new class for your project by using the Add C++ Class wizard and selecting None as your parent class: </li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/64c3708b-d1e9-480b-95c7-28fcaf1f9d69.png"/></p>
<ol start="2">
<li>Under the name option, use <kbd>CookbookStyle</kbd> and click on the Create Class button:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/ebb36faa-5690-4154-aae9-0569f96d67d4.png"/></p>
<ol start="3">
<li>Replace the code in the <kbd>CookbookStyle.h</kbd> file with the following code:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/>#include "SlateBasics.h"<br/>#include "SlateExtras.h"<br/><br/>class FCookbookStyle<br/>{<br/>public:<br/>    static void Initialize();<br/>    static void Shutdown();<br/>    static void ReloadTextures();<br/>    static const ISlateStyle&amp; Get();<br/>    static FName GetStyleSetName();<br/><br/>private:<br/>    static TSharedRef&lt; class FSlateStyleSet &gt; Create();<br/>private:<br/>    static TSharedPtr&lt; class FSlateStyleSet &gt; CookbookStyleInstance;<br/>};</pre>
<ol start="4">
<li>Open the <kbd>CookbookStyle.cpp</kbd> file and use the following code for it:</li>
</ol>
<pre style="padding-left: 60px">#include "CookbookStyle.h"<br/>#include "SlateGameResources.h"<br/><br/>TSharedPtr&lt; FSlateStyleSet &gt; FCookbookStyle::CookbookStyleInstance = NULL;<br/><br/>void FCookbookStyle::Initialize()<br/>{<br/>    if (!CookbookStyleInstance.IsValid())<br/>    {<br/>        CookbookStyleInstance = Create();<br/>    FSlateStyleRegistry::RegisterSlateStyle(*CookbookStyleInstance);<br/>    }<br/>}<br/><br/>void FCookbookStyle::Shutdown()<br/>{<br/>    FSlateStyleRegistry::UnRegisterSlateStyle(*CookbookStyleInstance);<br/>    ensure(CookbookStyleInstance.IsUnique());<br/>    CookbookStyleInstance.Reset();<br/>}<br/><br/>FName FCookbookStyle::GetStyleSetName()<br/>{<br/>    static FName StyleSetName(TEXT("CookbookStyle"));<br/>    return StyleSetName;<br/>}<br/><br/><br/><br/></pre>
<ol start="5">
<li>Add the following content below the previously created script in the <kbd>CookbookStyle.cpp</kbd> file to describe how to draw the screen:</li>
</ol>
<pre style="padding-left: 60px">#define IMAGE_BRUSH( RelativePath, ... ) FSlateImageBrush( FPaths::GameContentDir() / "Slate"/ RelativePath + TEXT(".png"), __VA_ARGS__ )<br/>#define BOX_BRUSH( RelativePath, ... ) FSlateBoxBrush( FPaths::GameContentDir() / "Slate"/ RelativePath + TEXT(".png"), __VA_ARGS__ )<br/>#define BORDER_BRUSH( RelativePath, ... ) FSlateBorderBrush( FPaths::GameContentDir() / "Slate"/ RelativePath + TEXT(".png"), __VA_ARGS__ )<br/>#define TTF_FONT( RelativePath, ... ) FSlateFontInfo( FPaths::GameContentDir() / "Slate"/ RelativePath + TEXT(".ttf"), __VA_ARGS__ )<br/>#define OTF_FONT( RelativePath, ... ) FSlateFontInfo( FPaths::GameContentDir() / "Slate"/ RelativePath + TEXT(".otf"), __VA_ARGS__ )<br/><br/>TSharedRef&lt; FSlateStyleSet &gt; FCookbookStyle::Create()<br/>{<br/>    TSharedRef&lt;FSlateStyleSet&gt; StyleRef = FSlateGameResources::New(FCookbookStyle::GetStyleSetName(), "/Game/Slate", "/Game/Slate");<br/>    FSlateStyleSet&amp; Style = StyleRef.Get();<br/><br/>    Style.Set("NormalButtonBrush",<br/>        FButtonStyle().<br/>        SetNormal(BOX_BRUSH("Button", FVector2D(54, 54), FMargin(14.0f / 54.0f))));<br/>    Style.Set("NormalButtonText",<br/>        FTextBlockStyle(FTextBlockStyle::GetDefault())<br/>        .SetColorAndOpacity(FSlateColor(FLinearColor(1, 1, 1, 1))));<br/>    return StyleRef;<br/>}<br/><br/>#undef IMAGE_BRUSH<br/>#undef BOX_BRUSH<br/>#undef BORDER_BRUSH<br/>#undef TTF_FONT<br/>#undef OTF_FONT<br/><br/>void FCookbookStyle::ReloadTextures()<br/>{<br/>    FSlateApplication::Get().GetRenderer()-&gt;ReloadTextureResources();<br/>}<br/><br/>const ISlateStyle&amp; FCookbookStyle::Get()<br/>{<br/>    return *CookbookStyleInstance;<br/>}</pre>
<ol start="6">
<li>Create a new <kbd>GameModeBase</kbd> subclass, <kbd>StyledHUDGameMode</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/a6078305-d562-4c27-b878-7e635d381cfd.png"/></p>
<ol start="7">
<li>Once Visual Studio opens, add the following code to its declaration:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "GameFramework/GameModeBase.h"<br/>#include "SlateBasics.h"<br/>#include "StyledHUDGameMode.generated.h"<br/><br/>/**<br/> * <br/> */<br/>UCLASS()<br/>class CHAPTER_14_API AStyledHUDGameMode : public AGameModeBase<br/>{<br/>    GENERATED_BODY()<br/>    <br/>    TSharedPtr&lt;SVerticalBox&gt; Widget;<br/><br/>public:<br/>    virtual void BeginPlay() override;<br/>};</pre>
<ol start="8">
<li>Likewise, implement <kbd>GameMode</kbd>:</li>
</ol>
<pre style="padding-left: 60px">#include "StyledHUDGameMode.h"<br/>#include "CookbookStyle.h"<br/><br/>void AStyledHUDGameMode::BeginPlay()<br/>{<br/>    Super::BeginPlay();<br/><br/>    Widget = SNew(SVerticalBox)<br/>        + SVerticalBox::Slot()<br/>        .HAlign(HAlign_Center)<br/>        .VAlign(VAlign_Center)<br/>        [<br/>            SNew(SButton)<br/>            .ButtonStyle(FCookbookStyle::Get(), "NormalButtonBrush")<br/>        .ContentPadding(FMargin(16))<br/>        .Content()<br/>        [<br/>            SNew(STextBlock)<br/>            .TextStyle(FCookbookStyle::Get(), "NormalButtonText")<br/>        .Text(FText::FromString("Styled Button"))<br/>        ]<br/>        ];<br/>    GEngine-&gt;GameViewport-&gt;AddViewportWidgetForPlayer(GetWorld()-&gt;GetFirstLocalPlayerFromController(), Widget.ToSharedRef(), 1);<br/><br/>}</pre>
<ol start="9">
<li>Lastly, create a 54 x 54 pixel PNG file with a border around it for our button:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/73922731-36ea-47f4-9e56-48280866be32.png" style="width:6.58em;height:6.58em;"/></p>
<ol start="10">
<li>Save it to the <kbd>Content</kbd> | <kbd>Slate</kbd> folder with the name <kbd>Button.png</kbd>, creating the folder if needed:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/293da37b-9933-4c8f-b2e5-d749a70f8302.png"/></p>
<ol start="11">
<li>You may be asked if you'd like to import the image into your project. Go ahead and say yes.</li>
<li>Finally, we need to set our game's module to properly initialize the style when it is loaded. In your game module's implementation file (<kbd>Chapter_14.h</kbd>), ensure it looks like this:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/><strong>#include "CookbookStyle.h"</strong><br/><br/><strong>class Chapter_14Module : public FDefaultGameModuleImpl</strong><br/><strong>{</strong><br/><strong>    virtual void StartupModule() override</strong><br/><strong>    {</strong><br/><strong>        FCookbookStyle::Initialize();</strong><br/><strong>    };</strong><br/><strong>    virtual void ShutdownModule() override</strong><br/><strong>    {</strong><br/><strong>        FCookbookStyle::Shutdown();</strong><br/><strong>    };</strong><br/><strong>};</strong></pre>
<ol start="13">
<li>Then, go to the <kbd>Chapter_14.cpp</kbd> file and modify the code to the following:</li>
</ol>
<pre style="padding-left: 60px">#include "Chapter_14.h"<br/>#include "Modules/ModuleManager.h"<br/><br/>IMPLEMENT_PRIMARY_GAME_MODULE(<strong>Chapter_14Module</strong>, Chapter_14, "Chapter_14" );</pre>
<p class="mce-root"/>
<ol start="14">
<li>Compile the code and set your game mode override to the new game mode, like we did in the other recipes in this chapter.</li>
<li>When you play the game, you will see that your custom border is around the button, and that the text is white rather than black:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/0a88391a-3f1f-4343-be79-7a38b5271782.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>For us to create styles that can be shared across multiple Slate widgets, we need to create an object to contain the styles and keep them in scope.</p>
<p>Epic provides the <kbd>FSlateStyleSet</kbd> class for this purpose. <kbd>FSlateStyleSet</kbd> contains a number of styles that we can access within Slate's declarative syntax to skin widgets.</p>
<p>However, it's inefficient to have multiple copies of our <kbd>StyleSet</kbd> object scattered through the program. We really only need one of these objects.</p>
<p>Because <kbd>FSlateStyleSet</kbd> itself is not a singleton, that is, an object that can only have one instance, we need to create a class that will manage our <kbd>StyleSet</kbd> object and ensure that we only have the single instance.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>This is the reason we have the <kbd>FCookbookStyle</kbd> class. It contains an <kbd>Initialize()</kbd> function, which we will call in our module's startup code. In the <kbd>Initialize()</kbd> function, we check if we have an instance of our <kbd>StyleSet</kbd>. If we do not have a valid instance, we call the private <kbd>Create()</kbd> function to instantiate one.</p>
<p>We then register the style with the <kbd>FSlateStyleRegistry</kbd> class.</p>
<p>When our module is unloaded, we will need to reverse this registration process, then erase the pointer so that it doesn't dangle.</p>
<p>We now have an instance of our class that was created during module initialization by calling <kbd>Create()</kbd>. You'll notice that <kbd>Create</kbd> is wrapped by a number of macros that all have a similar form. These macros are defined before the function, and undefined after it.</p>
<p>These macros make it easier for us to simplify the code that's required within the <kbd>Create</kbd> function by eliminating the need to specify a path and extension for all the image resources that our Style might want to use.</p>
<p>Within the <kbd>Create</kbd> function, we create a new <kbd>FSlateStyleSet</kbd> object using the <kbd>FSlateGameResources::New()</kbd> function. <kbd>New()</kbd> needs a name for the style, and the folder paths that we want to search for in this Style Set.</p>
<p>This allows us to declare multiple Style Sets that are pointing to different directories, but using the same names for the images. It also allows us to skin or restyle the whole UI simply by switching to a Style Set in one of the other base directories.</p>
<p><kbd>New()</kbd> returns a shared reference object, so we retrieve the actual <kbd>FStyleSet</kbd> instance using the <kbd>Get()</kbd> function.</p>
<p>With this reference in hand, we can create the styles we want this set to contain. To add styles to a set, we use the <kbd>Set()</kbd> method. Set expects the name of the style, and then a style object. Style objects can be customized using the <kbd>builder</kbd> pattern.</p>
<p>We first add a style called <kbd>"NormalButtonBrush"</kbd>. The name can be arbitrary. Because we want to use this style to change the appearance of buttons, we need to use <kbd>FButtonStyle</kbd> for the second parameter.</p>
<p>To customize the style to our requirements, we use the Slate builder syntax, chaining whatever method calls that we need to set properties on our style.</p>
<p>For the first style in this set, we just change the visual appearance of the button when it isn't being clicked or is in a non-default state. This means that we want to change the brush that's used when the button is in the normal state, and so the function we use is <kbd>SetNormal()</kbd>.</p>
<p>Using the <kbd>BOX_BRUSH</kbd> macro, we tell Slate that we want to use <kbd>Button.png</kbd>, which is an image of 54 x 54 pixel size, and that we want to keep the 14 pixels in each corner unstretched for the purposes of nine-slice scaling.</p>
<p>For a more visual explanation of the nine-slice scaling functionality, take a look at <kbd>SlateBoxBrush.h</kbd> in the engine source.</p>
<p>For the second style in our Style Set, we create a style called <kbd>"NormalButtonText"</kbd>. For this style, we don't want to change everything from defaults in the style; we just want to alter one property. As a result, we access the default text style and clone it using the copy constructor.</p>
<p>With our fresh copy of the default style, we then change the color of the text to white, first creating a linear color of R=1 G=1 B=1 A=1, and then convert that into a Slate color object.</p>
<p>With our Style Set configured with our two new styles, we can then return it to the calling function, which is <kbd>Initialize</kbd>. <kbd>Initialize</kbd> stores our Style Set reference and eliminates the need for us to create further instances.</p>
<p>Our style container class also has a <kbd>Get()</kbd> function, which is used to retrieve the actual <kbd>StyleSet</kbd> for use in Slate. Because <kbd>Initialize()</kbd> has already been called at module startup, <kbd>Get()</kbd> simply returns the <kbd>StyleSet</kbd> instance that was created within that function.</p>
<p>Within the game module, we add the code that actually calls <kbd>Initialize</kbd> and <kbd>Shutdown</kbd>. This ensures that while our module is loaded, we will always have a valid reference to our Slate Style.</p>
<p>As always, we create a Game Mode as the host for our UI, and we override <kbd>BeginPlay</kbd> so that we can create the UI when the game starts.</p>
<p>The syntax for creating the UI is exactly the same as we've used in previous recipes – creating a <kbd>VerticalBox</kbd> using <kbd>SNew</kbd>, and then using Slate's declarative syntax to populate the box with other widgets.</p>
<p>It is important to note the two following lines:</p>
<pre class="mce-root">.ButtonStyle(FCookbookStyle::Get(), "NormalButtonBrush")<br/> .TextStyle(FCookbookStyle::Get(), "NormalButtonText")</pre>
<p>The preceding lines are part of the declarative syntax for our button, and the text that makes its label. When we set the style for our widgets using a <kbd>&lt;Class&gt;Style()</kbd> method, we pass in two parameters.</p>
<p>The first parameter is our actual Style Set, which is retrieved by using <kbd>FCookbookStyle::Get()</kbd>, and the second is a string parameter with the name of the style that we want to use.</p>
<p>With these minor changes, we override the styling of the widgets to use our custom styles so that when we add the widgets to the player's viewport, they display our customizations.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a custom SWidget/UWidget</h1>
                
            
            
                
<p>The recipes in this chapter so far have shown you how to create UIs using the existing primitive widgets.</p>
<p>Sometimes, it is convenient for developers to use composition to collect a number of UI elements to define a button class that automatically has a <kbd>TextBlock</kbd> as a label rather than manually specifying the hierarchy every time they are declared, for example.</p>
<p>Furthermore, if you are manually specifying the hierarchy in C++, rather than declaring a compound object consisting of subwidgets, you won't be able to instantiate those widgets as a group using UMG.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe shows you how to create a compound <kbd>SWidget</kbd> that contains a group of widgets and exposes new properties to control elements of those subwidgets. It will also show you how to create a <kbd>UWidget</kbd> wrapper, which will expose the new compound <kbd>SWidget</kbd> class to UMG so that it can be used by designers.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>We need to add the UMG module to our module's dependencies.</li>
<li>Open up <kbd>&lt;YourModule&gt;.build.cs</kbd>, which in our case is <kbd>Chapter_14.Build.cs</kbd>, and add UMG to the following code:</li>
</ol>
<pre style="padding-left: 60px">using UnrealBuildTool;<br/><br/>public class Chapter_14 : ModuleRules<br/>{<br/>  public Chapter_14(ReadOnlyTargetRules Target) : base(Target)<br/>  {<br/>    PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;<br/>  <br/>    PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject", "Engine", "InputCore" });<br/><br/>    PrivateDependencyModuleNames.AddRange(new string[] { });<br/><br/>    // Uncomment if you are using Slate UI<br/>    PrivateDependencyModuleNames.AddRange(new string[] { "Slate", <br/>    "SlateCore"<strong>, "UMG"</strong> });<br/>    <br/>    // Uncomment if you are using online features<br/>    // PrivateDependencyModuleNames.Add("OnlineSubsystem");<br/><br/>    // To include OnlineSubsystemSteam, add it to the plugins <br/>    // section in your uproject file with the Enabled attribute<br/>    // set to true<br/>  }<br/>}</pre>
<ol start="3">
<li>Create a new class based on the Slate Widget parent class (<kbd>SCompoundWidget</kbd>):</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/1a17774f-7605-4d12-ad72-aa538589875a.png"/></p>
<ol start="4">
<li>When asked for a name, call it <kbd>CustomButton</kbd>.</li>
</ol>
<ol start="5">
<li>Once created, add the following code to its declaration:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "Widgets/SCompoundWidget.h"<br/><br/>class CHAPTER_14_API SCustomButton : public SCompoundWidget<br/>{<br/>    SLATE_BEGIN_ARGS(SCustomButton)<br/>        : _Label(TEXT("Default Value"))<br/>        , _ButtonClicked()<br/>    {}<br/>    SLATE_ATTRIBUTE(FString, Label)<br/>        SLATE_EVENT(FOnClicked, ButtonClicked)<br/>        SLATE_END_ARGS()<br/><br/>public:<br/>    void Construct(const FArguments&amp; InArgs);<br/>    TAttribute&lt;FString&gt; Label;<br/>    FOnClicked ButtonClicked;<br/>};</pre>
<p class="mce-root"/>
<ol start="6">
<li>Implement the class with the following in the corresponding <kbd>.cpp</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">#include "CustomButton.h"<br/>#include "SlateOptMacros.h"<br/>#include "Chapter_14.h"<br/><br/><br/>void SCustomButton::Construct(const FArguments&amp; InArgs)<br/>{<br/>    Label = InArgs._Label;<br/>    ButtonClicked = InArgs._ButtonClicked;<br/>    ChildSlot.VAlign(VAlign_Center)<br/>        .HAlign(HAlign_Center)<br/>        [SNew(SButton)<br/>        .OnClicked(ButtonClicked)<br/>        .Content()<br/>        [<br/>            SNew(STextBlock)<br/>            .Text_Lambda([this] {return FText::FromString(Label.Get()); })<br/>        ]<br/>        ];<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="7">
<li>Create a second class, this time based on <kbd>Widget</kbd>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/70f5329f-c812-4ee8-9108-2c186e2130c5.png"/></p>
<ol start="8">
<li>Call this new class <kbd>CustomButtonWidget</kbd> and press Create Class. </li>
<li>Add the bold code in the following snippet to the <kbd>CustomButtonWidget.h</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">#pragma once<br/><br/>#include "CoreMinimal.h"<br/>#include "Components/Widget.h"<br/><strong>#include "CustomButton.h"</strong><br/><strong>#include "SlateDelegates.h"</strong><br/>#include "CustomButtonWidget.generated.h"<br/><br/><strong>DECLARE_DYNAMIC_DELEGATE_RetVal(FString, FGetString);</strong><br/><strong>DECLARE_DYNAMIC_MULTICAST_DELEGATE(FButtonClicked);<br/></strong><br/>UCLASS()<br/>class CHAPTER_14_API UCustomButtonWidget : public UWidget<br/>{<br/>    GENERATED_BODY()<br/>    <br/><strong>protected:</strong><br/><strong>    TSharedPtr&lt;SCustomButton&gt; MyButton;</strong><br/><br/><strong>    virtual TSharedRef&lt;SWidget&gt; RebuildWidget() override;</strong><br/><br/><strong>public:</strong><br/><strong>    UCustomButtonWidget();</strong><br/><strong>    //multicast</strong><br/><strong>    UPROPERTY(BlueprintAssignable)</strong><br/><strong>    FButtonClicked ButtonClicked;</strong><br/><br/><strong>    FReply OnButtonClicked();</strong><br/><br/><strong>    UPROPERTY(BlueprintReadWrite, EditAnywhere)</strong><br/><strong>        FString Label;</strong><br/><br/><strong>    //MUST be of the form varnameDelegate</strong><br/><strong>    UPROPERTY()</strong><br/><strong>        FGetString LabelDelegate;</strong><br/><br/><strong>    virtual void SynchronizeProperties() override;</strong><br/>};</pre>
<ol start="10">
<li>Now, create the implementation for <kbd>UCustomButtonWidget</kbd>:</li>
</ol>
<pre style="padding-left: 60px">#include "CustomButtonWidget.h"<br/>#include "Chapter_14.h"<br/><br/>TSharedRef&lt;SWidget&gt; UCustomButtonWidget::RebuildWidget()<br/>{<br/>    MyButton = SNew(SCustomButton)<br/>        .ButtonClicked(BIND_UOBJECT_DELEGATE(FOnClicked, OnButtonClicked));<br/>    return MyButton.ToSharedRef();<br/>}<br/><br/>UCustomButtonWidget::UCustomButtonWidget()<br/>    :Label(TEXT("Default Value"))<br/>{<br/><br/>}<br/><br/>FReply UCustomButtonWidget::OnButtonClicked()<br/>{<br/>    ButtonClicked.Broadcast();<br/>    return FReply::Handled();<br/>}<br/><br/><br/>void UCustomButtonWidget::SynchronizeProperties()<br/>{<br/>    Super::SynchronizeProperties();<br/>    TAttribute&lt;FString&gt; LabelBinding = OPTIONAL_BINDING(FString, Label);<br/>    MyButton-&gt;Label = LabelBinding;<br/>}</pre>
<ol start="11">
<li>Save your scripts and compile your code.</li>
<li>Create a new Widget Blueprint by right-clicking on the Content Browser and selecting User Interface and then Widget Blueprint:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/019ade72-7ac5-4639-84ec-59fbf045dcbd.png"/></p>
<p>You can use the mouse wheel in the context menu to scroll to the User Interface section.</p>
<ol start="13">
<li>Open your new Widget Blueprint by double-clicking on it.</li>
<li>Find the Custom Button Widget in the Widget Palette:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/7ec28d12-c477-458d-bb1d-e22f94528e26.png"/></p>
<ol start="15">
<li>Drag an instance of it out into the main area.</li>
</ol>
<ol start="16">
<li>With the instance selected, change the Label property in the Details panel:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/5941564e-b55b-4f07-b642-a24507181855.png"/></p>
<p style="padding-left: 60px">Verify that your button has changed its label.</p>
<ol start="17">
<li>Now, we will create a binding to demonstrate that we can link arbitrary blueprint functions to the label property on our widget, which, in turn, drives the Widget's textblock label.</li>
</ol>
<ol start="18">
<li>Click on Bind to the right of the Label property and select Create Binding:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/e4e52462-a9f1-4ed4-a5fd-8cbe749f1003.png"/></p>
<ol start="19">
<li>Within the graph that is now displayed, place a Get Game Time in Seconds node by right-clicking within the main area:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/6f13155b-1c21-4fcc-9bd0-3e49c3ef08fc.png" style="width:43.17em;height:27.58em;"/></p>
<ol start="20">
<li>Link the return value from the Get Game Time node to the Return Value pin in the function:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/6421b9a8-c550-46aa-a2c4-22482c2699f5.jpg" style="width:36.17em;height:17.75em;"/></p>
<ol start="21">
<li>A Convert Float to String node will be automatically inserted for you:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/508844dd-cbe0-48c4-a007-d9ecb4fbafff.jpg" style="width:39.42em;height:20.67em;"/></p>
<ol start="22">
<li>Compile the blueprint to ensure it is working correctly.</li>
</ol>
<ol start="23">
<li>Next, open the Level Blueprints by clicking on the Blueprints button on the taskbar and then selecting Open Level Blueprint:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/a7e07af8-6327-4b45-9fd2-8b8ee267eba1.png"/></p>
<ol start="24">
<li>To the right of the Event BeginPlay node, place a Create Widget node into the graph:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/287da0f3-30e0-48de-a7fb-7524a6bc0782.png"/></p>
<ol start="25">
<li>Select the Class of widget to spawn it as the new Widget Blueprint that we created a moment ago within the editor:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/926ba980-6528-4778-8868-bf71d895ccb8.jpg" style="width:25.33em;height:14.92em;"/></p>
<ol start="26">
<li>Click and drag away from the Owning Player pin on the create widget node and place a Get Player Controller node:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/cd0d48b2-dc8f-4b71-805c-639f0510e06e.jpg" style="width:34.67em;height:22.33em;"/></p>
<ol start="27">
<li>Likewise, drag away from the return value of the Create Widget node and place an Add to Viewport node:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/e005b240-36a4-4bde-9cb9-fea79fb1ed0e.jpg" style="width:48.67em;height:15.33em;"/></p>
<ol start="28">
<li>Lastly, link the <kbd>BeginPlay</kbd> node to the execution pin on the create widget node:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/29583739-bbd2-4a2f-9750-d150412bd044.png"/></p>
<ol start="29">
<li>Preview your game and verify that the widget we've displayed onscreen is our new custom button, with its label bound to the number of seconds that have elapsed since the game started:</li>
</ol>
<p class="mce-root"/>
<div><img src="img/6e798818-3319-43c4-a5c3-24c71cc70708.png"/></div>
<p>Button displaying the elapsed time in the level</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>To use the <kbd>UWidget</kbd> class, our module needs to include the UMG module as one of its dependencies, because <kbd>UWidget</kbd> is defined inside the UMG module.</p>
<p>The first class that we need to create, however, is our actual <kbd>SWidget</kbd> class.</p>
<p>Because we want to aggregate two widgets together into a compound structure, we create our new widget as a <kbd>CompoundWidget</kbd> subclass. <kbd>CompoundWidget</kbd> allows you to encapsulate a widget hierarchy as a widget itself.</p>
<p>Inside the class, we use the <kbd>SLATE_BEGIN_ARGS</kbd> and <kbd>SLATE_END_ARGS</kbd> macros to declare an internal <kbd>struct</kbd> called <kbd>FArguments</kbd> on our new <kbd>SWidget</kbd>. Within <kbd>SLATE_BEGIN_ARGS</kbd> and <kbd>SLATE_END_ARGS</kbd>, the <kbd>SLATE_ATTRIBUTE</kbd> and <kbd>SLATE_EVENT</kbd> macros are used. <kbd>SLATE_ATTRIBUTE</kbd> creates <kbd>TAttribute</kbd> for the type we give it. In this class, we declare a <kbd>TAttribute</kbd> called <kbd>_Label</kbd>, which is more specifically a <kbd>TAttribute&lt;FString&gt;</kbd>.</p>
<p><kbd>SLATE_EVENT</kbd> allows us to create member delegates that we can broadcast when something happens internally to the widget.</p>
<p>In <kbd>SCustomButton</kbd>, we declare a delegate with the signature <kbd>FOnClicked</kbd>, called <kbd>ButtonClicked</kbd>.</p>
<p><kbd>SLATE_ARGUMENT</kbd> is another macro (which wasn't used in this recipe) that creates an internal variable with the type and name you provide, appending an underscore to the start of the variable name.</p>
<p><kbd>Construct()</kbd> is the function that widgets implement to self-initialize when they are being instantiated. You'll notice we also create <kbd>TAttribute</kbd> and <kbd>FOnClicked</kbd> instances ourselves, without the underscores. These are the actual properties of our object into which the arguments that we declared earlier will be copied.</p>
<p>Inside the implementation of <kbd>Construct</kbd>, we retrieve the arguments that were passed to us in the <kbd>FArgumentsstruct</kbd>, and store them inside our actual member variables for this instance.</p>
<p>We assign <kbd>Label</kbd> and <kbd>ButtonClicked</kbd> based on what was passed in, and then we actually create our widget hierarchy. We use the same syntax as usual for this with one thing to note, namely the use of <kbd>Text_Lambda</kbd> to set the text value of our internal text block. We use a <kbd>lambda</kbd> function to retrieve the value of our <kbd>Label</kbd> <kbd>TAttribute</kbd> using <kbd>Get()</kbd>, convert it into <kbd>FText</kbd>, and store it as our text block's <kbd>Text</kbd> property.</p>
<p>Now that we have our <kbd>SWidget</kbd> declared, we need to create a wrapper <kbd>UWidget</kbd> object that will expose this widget to the UMG system so that designers can use the widget within the <strong>WYSIWYG</strong> editor. This class will be called <kbd>UCustomButtonWidget</kbd>, and it inherits from <kbd>UWidget</kbd> rather than <kbd>SWidget</kbd>.</p>
<p>The <kbd>UWidget</kbd> object needs a reference to the actual <kbd>SWidget</kbd> that it owns, so we place a protected member in the class that will store it as a shared pointer.</p>
<p>A constructor is declared, as well as a <kbd>ButtonClicked</kbd> delegate that can be set in Blueprint. We also mirror a <kbd>Label</kbd> property that is marked as <kbd>BlueprintReadWrite</kbd> so that it can be set in the UMG editor.</p>
<p>Because we want to be able to bind our button's label to a delegate, we add the last of our member variables, which is a delegate that returns a <kbd>String</kbd>.</p>
<p>The <kbd>SynchronizeProperties</kbd> function applies properties that have been mirrored in our <kbd>UWidget</kbd> class across to the <kbd>SWidget</kbd> that we are linked with.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p><kbd>RebuildWidget</kbd> reconstructs the native widget that <kbd>UWidget</kbd> is associated with. It uses <kbd>SNew</kbd> to construct an instance of our <kbd>SCustomButton</kbd> widget, and uses the Slate declarative syntax to bind the UWidget's <kbd>OnButtonClicked</kbd> method to the <kbd>ButtonClicked</kbd> delegate inside the native widget. This means that when the native widget is clicked, the <kbd>UWidget</kbd> will be notified by having <kbd>OnButtonClicked</kbd> called.</p>
<p><kbd>OnButtonClicked</kbd> re-broadcasts the clicked event from the native button via the UWidget's <kbd>ButtonClicked</kbd> delegate. This means that UObjects and the UMG system can be notified of the button being clicked without having a reference to the native button widget themselves. We can bind to <kbd>UCustomButtonWidget::ButtonClicked</kbd> so that we're notified about this.</p>
<p><kbd>OnButtonClicked</kbd> then returns <kbd>FReply::Handled()</kbd> to indicate that the event does not need to propagate further. Inside <kbd>SynchronizeProperties</kbd>, we call the parent method to ensure that any properties in the parent are also synchronized properly.</p>
<p>We use the <kbd>OPTIONAL_BINDING</kbd> macro to link the <kbd>LabelDelegate</kbd> delegate in our <kbd>UWidget</kbd> class to <kbd>TAttribute</kbd>, and, in turn, the native button's label. It is important to note that the <kbd>OPTIONAL_BINDING</kbd> macro expects the delegate to be called <kbd>NameDelegate</kbd> based on the second parameter to the macro.</p>
<p><kbd>OPTIONAL_BINDING</kbd> allows the value to be overridden by a binding made via UMG, but only if the UMG binding is valid.</p>
<p>This means that when <kbd>UWidget</kbd> is told to update itself, for example, because the user customizes a value in the Details panel within UMG, it will recreate the native <kbd>SWidget</kbd> if necessary, and then copy the values set in Blueprint/UMG via <kbd>SynchronizeProperties</kbd> so that everything continues to work as expected.</p>


            

            
        
    </body></html>