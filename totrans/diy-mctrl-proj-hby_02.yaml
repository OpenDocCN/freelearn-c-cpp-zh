- en: '*Chapter 2*: Software Setup and C Programming for Microcontroller Boards'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第2章*：微控制器板软件设置和C编程'
- en: 'In this chapter, you will review the basic configuration of the IDEs used for
    programming the Blue Pill and Curiosity Nano microcontroller boards, as well as
    learn the basics of the C programming language necessary for coding applications
    for the Blue Pill and the Curiosity Nano. This is by no means a comprehensive
    C tutorial. It contains important information to understand and complete the exercises
    explained in all the chapters of this book. In this chapter, we''re going to cover
    the following main topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将回顾用于编程Blue Pill和Curiosity Nano微控制器板的IDE的基本配置，以及学习为Blue Pill和Curiosity
    Nano编写应用程序所需的C编程语言基础知识。这绝对不是一份全面的C教程。它包含了理解和完成本书所有章节中解释的练习的重要信息。在本章中，我们将涵盖以下主要主题：
- en: Introducing the C programming language
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍C编程语言
- en: Introducing Curiosity Nano microcontroller board programming
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Curiosity Nano微控制器板编程
- en: Introducing Blue Pill microcontroller board programming
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Blue Pill微控制器板编程
- en: Example – Programming and using the microcontroller board's internal LED
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例 – 编程和使用微控制器板内部LED
- en: By the end of this chapter, you will have received a solid introduction to the
    C programming language, including a set of programming instructions useful for
    developing many small and mid-sized microcontroller projects with the Blue Pill
    and Curiosity Nano microcontroller boards. This chapter also covers the use of
    the internal LED, which both the Blue Pill and the Curiosity Nano have. This can
    be very useful for quickly showing digital results (for example, confirming actions
    in your project).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将获得对C编程语言的坚实基础介绍，包括一组编程指令，这些指令对于使用Blue Pill和Curiosity Nano微控制器板开发许多小型和中型微控制器项目非常有用。本章还涵盖了内部LED的使用，Blue
    Pill和Curiosity Nano都具备这一功能。这可以非常方便地快速显示数字结果（例如，确认项目中的操作）。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The software that we will use in this chapter is the Arduino and MPLAB X IDEs
    for programming the Blue Pill and the Curiosity Nano, respectively. Their installation
    process was described in [*Chapter 1*](B16413_01_Final_NM_ePub.xhtml#_idTextAnchor014)*,*
    *Introduction to Microcontrollers and Microcontroller Boards*. We will also use
    the same code examples that were used in the aforementioned chapter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中将使用的软件是用于编程Blue Pill和Curiosity Nano的Arduino和MPLAB X IDE。它们的安装过程在[*第1章*](B16413_01_Final_NM_ePub.xhtml#_idTextAnchor014)*,*
    *微控制器和微控制器板简介*中已有描述。我们还将使用之前章节中使用的相同代码示例。
- en: 'In this chapter, we will also use the following hardware:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们还将使用以下硬件：
- en: A solderless breadboard.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个无焊点面包板。
- en: The Blue Pill and Curiosity Nano microcontroller boards.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Blue Pill和Curiosity Nano微控制器板。
- en: A micro USB cable for connecting your microcontroller boards to a computer.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一条用于将微控制器板连接到计算机的微型USB线。
- en: The ST-LINK/V2 electronic interface needed to upload the compiled code to the
    Blue Pill. Remember that the ST-Link/V2 requires four female-to-female DuPont
    wires.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要上传编译代码到Blue Pill的ST-LINK/V2电子接口。请记住，ST-Link/V2需要四根公对公的杜邦线。
- en: These are fundamental hardware components that will suffice for the examples
    described in this chapter, and will also prove useful in other more complex projects
    explained in other chapters.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是本章中描述的示例所需的基本硬件组件，它们也将证明在其他章节中解释的更复杂项目中非常有用。
- en: 'The code used in this chapter can be found at the book''s GitHub repository
    here:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码可以在本书的GitHub仓库中找到：
- en: '[https://github.com/PacktPublishing/DIY-Microcontroller-Projects-for-Hobbyists/tree/master/Chapter02](https://github.com/PacktPublishing/DIY-Microcontroller-Projects-for-Hobbyists/tree/master/Chapter02)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/DIY-Microcontroller-Projects-for-Hobbyists/tree/master/Chapter02](https://github.com/PacktPublishing/DIY-Microcontroller-Projects-for-Hobbyists/tree/master/Chapter02)'
- en: 'The Code in Action video for this chapter can be found here: [https://bit.ly/3xwFvPA](https://bit.ly/3xwFvPA)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的“代码在行动”视频可以在此找到：[https://bit.ly/3xwFvPA](https://bit.ly/3xwFvPA)
- en: The next section explains a concise introduction to the C programming language.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将简要介绍C编程语言。
- en: Introducing the C programming language
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍C编程语言
- en: The **C programming language** was initially created in the early seventies
    for developing the UNIX operating system, but it has been ported to practically
    all operating systems ever since. It is a mid-level programming language because
    it shares properties from high-level languages such as Python and low-level languages,
    for example, the assembly language. The C language is generally easier to program
    than low-level languages because it is very *human-readable* and there are many
    libraries available that facilitate the development of software applications,
    among other reasons. It is also very efficient for programming embedded systems.
    C is one of the most popular coding languages, and virtually all microcontrollers
    can be programmed with C compilers – Blue Pill and Curiosity Nano are no exceptions.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**C编程语言**最初在七十年代初被创建，用于开发UNIX操作系统，但自那时起它已经被移植到几乎所有操作系统上。它是一种中级编程语言，因为它从高级语言（例如Python）和低级语言（例如汇编语言）中共享属性。C语言通常比低级语言更容易编程，因为它非常*易于阅读*，并且有许多库可用，这些库有助于软件开发，以及其他原因。它也非常适合编程嵌入式系统。C是最受欢迎的编程语言之一，几乎所有微控制器都可以用C编译器编程——Blue
    Pill和Curiosity Nano也不例外。'
- en: The C language is not completely portable among different families and manufacturers
    of microcontrollers. For example, the I/O ports and the interrupts are not programmed
    the same in both Blue Pill and Curiosity Nano. That is why two types of C compilers
    and different libraries are needed for programming both microcontroller boards.
    In fact, the Arduino IDE used for programming the Blue Pill uses a variant of
    C called **C++**. C++ is a powerful extension of the C programming language that
    incorporates features such as object-oriented and low-memory level programming.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: C语言在不同微控制器系列和制造商之间并不完全可移植。例如，在Blue Pill和Curiosity Nano中，I/O端口和中断的编程方式并不相同。这就是为什么需要两种类型的C编译器和不同的库来编程这两个微控制器板。实际上，用于编程Blue
    Pill的Arduino IDE使用的是C语言的变体，称为**C++**。C++是C编程语言的强大扩展，它结合了面向对象和低内存级编程等特性。
- en: The following section explains the basics of the C language structure. This
    section includes an explanation of the `#include` directive, writing comments,
    understanding variables, using constants, a keywords list, declaring functions,
    evaluating expressions, and writing loops in C.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分解释了C语言结构的基础知识。本节包括对`#include`指令的解释、编写注释、理解变量、使用常量、关键字列表、声明函数、评估表达式以及在C中编写循环。
- en: The basic structure of the C language
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C语言的基本结构
- en: As with other programming languages, C makes it possible to declare program
    elements such as constants, types, functions, and variables in separate files
    called `.h`. This can help to organize C instructions and reduce clutter in your
    main C code. A library is a header file containing program elements (such as functions)
    that can be shared with other C programmers or constantly used in different C
    programs. C language compilers contain important libraries that we will use in
    this book. The header files can be included (that is, linked and compiled) along
    your main program using the `#include` directive; hence, the programming elements
    declared in the header file will be called and used in your C program.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他编程语言一样，C语言使得可以在称为`.h`的单独文件中声明程序元素，如常量、类型、函数和变量。这有助于组织C指令并减少主C代码中的混乱。库是一个包含程序元素（如函数）的头文件，可以与其他C程序员共享或在不同的C程序中反复使用。C语言编译器包含我们在本书中将使用的重要库。头文件可以通过`#include`指令（即链接和编译）与主程序一起包含；因此，在头文件中声明的编程元素将在C程序中被调用和使用。
- en: 'There are many useful standard and non-standard libraries. We will review and
    use both. The `#include` directive is a special instruction for the C compiler
    and not a regular C instruction. It should be written at the beginning of the
    program and without a semicolon at the end. Only the C statements have a semicolon
    at the end. There are three ways to write and apply the `#include` directive.
    These are as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多有用的标准和非标准库。我们将回顾并使用两者。`#include`指令是C编译器的特殊指令，而不是常规的C指令。它应该写在程序的开头，并且末尾没有分号。只有C语句在末尾有分号。有三种编写和应用`#include`指令的方法。具体如下：
- en: '`#include <file_name.h>`: This type of directive uses the less than and greater
    than symbols, meaning that the header file (`.h`) is placed in the compiler path.
    You don''t need to write the complete path to the header file.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#include <file_name.h>`：此类指令使用小于和大于符号，意味着头文件（`.h`）位于编译器路径中。你不需要写出头文件的完整路径。'
- en: '`#include "file_name.h"`: This type of directive uses double quotes. The header
    file is stored in the project''s directory.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#include "file_name.h"`：此类指令使用双引号。头文件存储在项目目录中。'
- en: '`#include "sub_directory_name/file_name.h"`: This directive type tells the
    compiler that the header file is placed in a sub-directory. Please note that the
    slash symbol is applied depending on the operating system that you are using.
    For example, Windows computers use a backslash (*\*) symbol as a directory separator.
    Linux and Mac computers use the forward-slash (*/*) symbol.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#include "sub_directory_name/file_name.h"`：此类指令类型告诉编译器头文件位于子目录中。请注意，斜杠符号的使用取决于你使用的操作系统。例如，Windows
    计算机使用反斜杠（*\\*）符号作为目录分隔符。Linux 和 Mac 计算机使用正斜杠（*/*）符号。'
- en: The next sub-section shows how to define and use header files.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节将展示如何定义和使用头文件。
- en: 'Example of the #include directive'
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '#include 指令示例'
- en: 'The following program example shows how to include a header file that is placed
    in the project''s directory:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序示例展示了如何包含位于项目目录中的头文件：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding example, the `x`, `y`, and `z` variables were declared in
    the `main_file.h` header file, so they are not declared in the main program. The
    header file (`file.h`) contains the following code declaring the three variables
    used in the main code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`x`、`y` 和 `z` 变量是在 `main_file.h` 头文件中声明的，因此它们在主程序中没有声明。头文件 (`file.h`)
    包含以下代码，声明了在主代码中使用的三个变量：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We could declare the variables in the main program and not declare the variables
    in a header file (`.h`). It is up to you whether you want to write program elements
    in header files. We will learn more about variables later in this chapter.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在主程序中声明变量，而不在头文件（`.h`）中声明变量。是否要在头文件中编写程序元素取决于你。我们将在本章后面学习更多关于变量的内容。
- en: Note
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The C language is case sensitive, so be careful when writing C code. Most C
    language instructions are written in non-capitalized letters. Be careful when
    you declare a variable, too. For example, the variables *x* and *X* are different
    in C.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: C 语言是区分大小写的，因此在编写 C 代码时要小心。大多数 C 语言指令都是用非大写字母编写的。声明变量时也要小心。例如，C 中的变量 *x* 和 *X*
    是不同的。
- en: There are standard libraries that come with the C language and many programmers
    make good use of them. The `stdio.h` library (stored as a header file) is widely
    used in C programming. It defines several macros, variable types, and also specialized
    functions for performing data input and output; for example, taking input letters
    from a keyboard or writing text to the console. The console is a text-based area
    provided by the IDE where reading data from a keyboard or writing text or special
    characters happens.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: C 语言附带了一些标准库，许多程序员很好地利用了它们。`stdio.h` 库（存储为头文件）在 C 编程中被广泛使用。它定义了多个宏、变量类型，以及用于执行数据输入和输出的专用函数；例如，从键盘读取输入字母或将文本写入控制台。控制台是
    IDE 提供的一个基于文本的区域，在这里从键盘读取数据或写入文本或特殊字符。
- en: 'This is a short C program example using the `<stdio.h>` directive:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用 `<stdio.h>` 指令的简短 C 程序示例：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: C program files are stored with the `.c` extension (such as `mainprogram.c`).
    The C++ program files are generally stored with the `.cpp` extension (for example,
    `mainprogram.cpp`).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: C 程序文件以 `.c` 扩展名存储（例如 `mainprogram.c`）。C++ 程序文件通常以 `.cpp` 扩展名存储（例如，`mainprogram.cpp`）。
- en: The `printf()`, which displays characters (for example, a text message) on the
    IDE's console. As you can see from the preceding program example, we wrote some
    comments explaining each line of code. The next section shows the different ways
    of writing comments in the C language.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`printf()` 函数用于在 IDE 的控制台上显示字符（例如，文本消息）。从前面的程序示例中可以看出，我们编写了一些注释来解释每一行代码。下一节将展示在
    C 语言中编写注释的不同方式。'
- en: Using comments in C
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 C 中使用注释
- en: '**Comments** are either blocks or lines of text that don''t affect the functioning
    of C programs. Writing comments in C programming is useful because they can be
    used to explain and clarify the meaning or the functioning of instructions, functions,
    variables, and so on. All the comments that we write in the program are ignored
    by the compiler. There are a couple of ways of writing comments in C:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**注释**是不影响C程序功能的文本块或行。在C编程中编写注释很有用，因为它们可以用来解释和阐明指令、函数、变量等的含义或功能。我们编写的所有注释都会被编译器忽略。在C中编写注释有几种方法：'
- en: 'Using double slashes (`//`): This makes a single-line comment.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用双斜杠（`//`）：这会创建单行注释。
- en: 'Using slashes and asterisks (`/*  */`): This makes a comment with a block of
    text.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用斜杠和星号（`/*  */`）：这会创建一个包含文本块的注释。
- en: 'This code example demonstrates how to use both types of comments:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码示例演示了如何使用两种类型的注释：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Tip
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: It is a good programming practice to write the code's purpose, version number
    and date, and the author's name(s) as comments at the beginning of your C program.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在C程序的开头添加代码的目的、版本号和日期以及作者的姓名作为注释是一种良好的编程实践。
- en: The next section describes how to declare and use variables in C programming.
    Variables are very useful, and you will use them in most of the chapters of this
    book.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将描述如何在C编程中声明和使用变量。变量非常有用，你将在本书的大部分章节中使用它们。
- en: Understanding variables in C
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解C语言中的变量
- en: A **variable** is a name (also called an identifier) assigned via programming
    to a microcontroller memory storage area that holds data temporarily. There are
    specific types of variables in C that hold different types of data. The variable
    types determine the layout and size of the variable's assigned microcontroller
    memory (generally, its internal random-access memory or RAM).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**变量**是一个通过编程分配给微控制器内存存储区域（也称为标识符）的名字，用于临时存储数据。在C语言中存在特定类型的变量，用于存储不同类型的数据。变量类型决定了分配给变量的微控制器内存的布局和大小（通常是其内部随机访问内存或RAM）。'
- en: 'We must declare a variable in the C language first to use it in your code.
    The variable declaration has two parts – a data type and an identifier, using
    this syntax: `<data_type> <identifier>`. The following explains both:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在C语言中首先声明一个变量，才能在代码中使用它。变量声明有两个部分——数据类型和标识符，使用以下语法：`<数据类型> <标识符>`。以下是对这两部分的解释：
- en: 'A **data type** (or just type) defines the type of data to be stored in the
    variable (for example, an integer number). There are many data types and their
    modifiers. The following table describes the four main types:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据类型**（或简称类型）定义了要存储在变量中的数据类型（例如，整数）。有许多数据类型及其修饰符。以下表格描述了四种主要类型：'
- en: '![Table 2.1 – The main four data types used in the C language](img/Table_2.1_B16413.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![表2.1 – C语言中使用的四种主要数据类型](img/Table_2.1_B16413.jpg)'
- en: Table 2.1 – The main four data types used in the C language
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.1 – C语言中使用的四种主要数据类型
- en: Each type from *Table 2.1* has the modifiers `unsigned`, `signed`, `short`,
    and `long`, among others. For example, we can declare a variable that holds unsigned
    integers as `unsigned int x;`.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*表2.1*中的每种类型都有`unsigned`、`signed`、`short`和`long`等修饰符。例如，我们可以声明一个存储无符号整数的变量，如`unsigned
    int x;`。'
- en: There is another type named `void`. This type has no value and is generally
    used to define a function type that returns nothing.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有一种名为`void`的类型。这种类型没有值，通常用于定义返回无值的函数类型。
- en: 'An identifier is a unique name identifying the variable. Identifiers can be
    written with the letters a..z or A..Z, the numbers 0..9, and the underscore character:
    _. The identifier must not have spaces, and the first character must not be a
    number. Remember that identifiers are case-sensitive. In addition, an identifier
    should have fewer than 32 characters according to the ANSI C standard.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标识符是唯一标识变量的名字。标识符可以用字母a..z或A..Z、数字0..9和下划线字符：_来编写。标识符不能有空格，并且第一个字符不能是数字。记住，标识符是区分大小写的。此外，根据ANSI
    C标准，标识符的长度应少于32个字符。
- en: 'For example, let''s declare a variable named x that can hold a floating-point
    number:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们声明一个名为x的变量，它可以存储浮点数：
- en: '`float x;`'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`float x;`'
- en: In the preceding line of code example, the C compiler will assign variable *x*
    a particular memory allocation holding only floating-point numbers.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，C编译器将为变量*x*分配一个特定的内存分配，该分配仅包含浮点数。
- en: 'Now, let''s use that variable in the following line of code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在以下代码行中使用这个变量：
- en: '`x=1.10;`'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`x=1.10;`'
- en: 'As you can see, we store the floating-point value of 1.10 in the variable named
    *x*. The following example demonstrates how to use a variable in a C program:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们将浮点值1.10存储在名为*x*的变量中。以下示例演示了如何在C程序中使用变量：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can initialize a variable with a value when it is declared, as shown in
    the preceding example for the `fahrenheit_degrees` variable.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在声明变量时初始化其值，就像前面示例中的`fahrenheit_degrees`变量所示。
- en: 'We can also store strings in a variable using double quotes at the beginning
    and end of the string. Here''s an example:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用字符串开头和结尾的双引号将字符串存储在变量中。以下是一个示例：
- en: '`char  name = "Michael";`'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`char name = "Michael";`'
- en: The preceding example shows how a string is stored in a char variable type,
    which is an array of characters.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例展示了如何将字符串存储在字符变量类型中，它是一个字符数组。
- en: Declaring local and global variables
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明局部和全局变量
- en: 'There are two types of variables in C depending on where they are declared.
    They can have different values and purposes:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在C语言中，根据变量的声明位置，存在两种类型的变量。它们可以有不同的值和用途：
- en: '**Global variables**: These are declared outside all the functions from your
    code. These variables can be used in any function and through the whole program.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局变量**：这些是在您的代码的所有函数外部声明的。这些变量可以在任何函数和整个程序中使用。'
- en: '**Local variables**: Local variables are declared inside a function. They only
    work inside the function that were declared, so their value cannot be used outside
    that function. Have a look at this example containing both global and local variables:'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**局部变量**：局部变量是在函数内部声明的。它们仅在声明它们的函数内部工作，因此它们的值不能在函数外部使用。请看以下包含全局和局部变量的示例：'
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding example, the global variables *y*, *m*, *x*, and *b* work in
    all programs, including inside the `straight_line_equation()` function.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，全局变量*y*、*m*、*x*和*b*在所有程序中工作，包括在`straight_line_equation()`函数内部。
- en: Using constants
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用常量
- en: '**Constants** (also called constant variables) can be used to define a variable
    that has a value that does not change throughout the entire program. Constants
    in C are useful for defining mathematical constants. This is the syntax for declaring
    a constant:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**常量**（也称为常量变量）可以用来定义一个在整个程序中值不会改变的变量。C语言中的常量对于定义数学常数很有用。声明常量的语法如下：'
- en: '`const <data_type> <identifier>=<value>;`'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`const <数据类型> <标识符>=<值>;`'
- en: 'Here, the data type can be either `int`, `float`, `char`, or `double`, or their
    modifiers, for example:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，数据类型可以是`int`、`float`、`char`或`double`，或者它们的修饰符，例如：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can also declare variables using the `#define` directive. It is written
    at the beginning of a program, right after the `#include` directive, without a
    semicolon at the end of the line, using this syntax: `#define` `<identifier> <value>`
    .
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`#define`指令声明变量。它位于程序的开头，紧随`#include`指令之后，行尾没有分号，使用以下语法：`#define <标识符>
    <值>`。
- en: 'We don''t need to declare the constant''s data type. The compiler will determine
    that dynamically. The following examples show how to declare constants:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要声明常量的数据类型。编译器将动态确定。以下示例展示了如何声明常量：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The next section deals with keywords from the C language that are widely used
    in C programs.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将处理在C程序中广泛使用的C语言关键字。
- en: Applying keywords
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用关键字
- en: "The ANSI C standard defines a number of **keywords** that have a specific purpose\
    \ in \LC programming. These keywords cannot be used to name variables or constants.\
    \ These are the keywords (statements) that you can use in your C code:"
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ANSI C标准定义了多个在C编程中具有特定目的的**关键字**。这些关键字不能用于命名变量或常量。这些是在您的C代码中可以使用的关键字（语句）：
- en: '`auto, break, case, char, const, continue, default, do, double, else,  enum,
    extern, float, for, goto, if, int, long, register, return, short, signed sizeof,
    static, struct, switch, typedef, union, unsigned, void, volatile, while.`'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`auto, break, case, char, const, continue, default, do, double, else, enum,
    extern, float, for, goto, if, int, long, register, return, short, signed sizeof,
    static, struct, switch, typedef, union, unsigned, void, volatile, while.`'
- en: The compilers used to compile programs for the Blue Pill and Curiosity Nano
    boards have additional keywords. We will list them in this chapter. The following
    section explains what functions in C are.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 用于编译Blue Pill和Curiosity Nano板程序的编译器具有额外的关键字。我们将在本章中列出它们。下一节将解释C语言中的函数是什么。
- en: Declaring functions in C
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明C语言中的函数
- en: A `main()`. This function is written in C programs, and other functions are
    called from it. You can logically divide your code up into functions to make it
    more readable and to group instructions that are related to the same task, giving
    the instructions some structure. Functions in C are defined more or less like
    algebraic functions where you have a function name, a function definition, and
    a function parameter(s).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 函数。这个函数在 C 程序中编写，其他函数都从它调用。你可以逻辑地将代码划分为函数，使其更易于阅读，并将与同一任务相关的指令分组，为指令提供一些结构。C
    语言中的函数定义大致类似于代数函数，其中包含函数名、函数定义和函数参数（s）。'
- en: 'The general form for defining a function in C is the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 语言中定义函数的一般形式如下：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `return` statement allows a value from a function to be returned, and this
    returned value is used in other parts of the program. The return statement is
    optional since you can code a function that does not return a value.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`return`语句允许从函数返回一个值，并且这个返回值被用于程序的其它部分。`return`语句是可选的，因为你可以编写一个不返回值的函数。'
- en: Tip
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: It is a good programming practice to indent the instructions contained in a
    function block. This gives the function more visual structure and readability.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数块中缩进包含的指令是一种良好的编程实践。这为函数提供了更多的视觉结构和可读性。
- en: 'The following function example shows how to use parameters and how data is
    returned from a function, where `number1` and `number2` are the function parameters:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数示例展示了如何使用参数以及如何从函数中返回数据，其中`number1`和`number2`是函数参数：
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding example, the function returns the results of the comparison
    between the two numbers.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，函数返回了两个数字比较的结果。
- en: Tip
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Make sure that the function's data type has the same type as the variable used
    in the `return` statement.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 确保函数的数据类型与`return`语句中使用的变量类型相同。
- en: 'If, for some reason, you don''t need to return a value from a function, you
    can use the `void` statement instead of defining the function''s data type, for
    example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出于某种原因，你不需要从函数中返回值，你可以使用`void`语句而不是定义函数的数据类型，例如：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding example, we are not using the `return 0` statement in the function
    because it's not returning any value. We can then `error_message();`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们没有在函数中使用`return 0`语句，因为它没有返回任何值。然后我们可以`error_message();`。
- en: Calling a function
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用函数
- en: Once we declare a function, we need to **call** it, that is, run it in another
    part of your code. This transfers the program control to the called function and
    it will run the instruction(s) contained in it. After executing all the instructions
    from the function, the program control resumes, running instructions from the
    main program.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们声明了一个函数，我们就需要**调用**它，即在代码的另一个部分运行它。这会将程序控制权转移到被调用的函数，并执行其中的指令。执行完函数中的所有指令后，程序控制权恢复，继续运行主程序中的指令。
- en: 'To call a function, you will need to write the function name and the required
    values for the parameters. If your function returns a value, you can store it
    in a variable. For example, let''s call the `max()` function that we explained
    previously:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用一个函数，你需要写出函数名和参数所需的值。如果你的函数返回一个值，你可以将其存储在一个变量中。例如，让我们调用我们之前解释过的`max()`函数：
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, the result of the number comparison made by the `maxnumber()`
    function will be stored in the `result2` variable.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`maxnumber()`函数进行的数字比较的结果将被存储在`result2`变量中。
- en: Evaluating expressions (decision statements)
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 评估表达式（决策语句）
- en: The C language provides a way to declare one or more **logic conditions** that
    can be evaluated (tested) by the program, as well as some statements that need
    to be executed according to the result of that evaluation, that is, if the condition
    is either true or false.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: C 语言提供了一种声明一个或多个**逻辑条件**的方法，这些条件可以被程序评估（测试），以及一些根据评估结果需要执行的语句，即条件为真或假。
- en: 'The C programming language assumes that the true value is any non-null or non-zero
    value. It is false if the value is zero or null. C has the following decision-making
    statements:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: C 编程语言假定任何非空或非零值都是真值。如果值为零或空，则为假。C 语言有以下决策语句：
- en: '`if` (expression_to_evaluate) {statements}: This has a Boolean expression in
    the decision that is followed by one or more statements to be run if the decision
    is true, for example:'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if` (expression_to_evaluate) {statements}: 这里的决策包含一个布尔表达式，后面跟着一个或多个语句，如果决策为真，则执行这些语句，例如：'
- en: '[PRE12]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`if` (decision) {statements} `else` {statements}: The `else` component can
    be used after an `if` statement and can be useful when running one or more statements
    if the decision is false, for example:'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if` (决策) {语句} `else` {语句}：`else`部分可以在`if`语句之后使用，并且当决策为假时，运行一个或多个语句可能很有用，例如：'
- en: '[PRE13]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding example, the x variable is analyzed, and if x is greater than
    10, it will print out this message on the IDE''s console: `yes, x is greater than
    10`, otherwise it will print out `no, x is not greater than 10`.'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在上述示例中，分析了x变量，如果x大于10，它将在IDE控制台打印出此消息：`yes, x is greater than 10`，否则它将打印出`no,
    x is not greater than 10`。
- en: Tip
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Be careful when you evaluate two variables with the `if` statement. Use double
    equal signs for that (==). If you use only one equal sign, the compiler will raise
    an error. Do it like this: `if` (x==y) {statements}'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 评估两个变量时请小心使用`if`语句。为此请使用双等号（==）。如果你只使用一个等号，编译器将引发错误。请这样做：`if` (x==y) {语句}
- en: 'The `switch` statement compares the value of a variable against a number of
    possible values, which are called cases. Each case from the `switch` statement
    has a unique name (identifier). If a match is not found in the list of cases,
    then the default statement will be executed and the program control goes out of
    the `switch` with the list of cases. The optional `break` statement is used to
    terminate the program control outside of the `switch` block. This is useful if,
    for some reason, you don''t want the `switch` statement to keep evaluating the
    rest of the cases. The following is the syntax for the `switch` statement:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`switch`语句将变量的值与多个可能的值进行比较，这些值称为情况。`switch`语句中的每个情况都有一个唯一的名称（标识符）。如果在情况列表中没有找到匹配项，则将执行默认语句，并且程序控制将离开`switch`，并带有情况列表。可选的`break`语句用于在`switch`块之外终止程序控制。这在某些原因导致你不想让`switch`语句继续评估其余情况时很有用。以下是`switch`语句的语法：'
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding code shows the syntax for the `switch` statement, including its
    break sentence. The following code is an example of using `switch`, which will
    compare the variable age against three cases. In case the variable has a value
    of `10`, it will print out the following text: `the person is a child`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码显示了`switch`语句的语法，包括其`break`语句。以下代码是使用`switch`的示例，它将变量年龄与三个情况进行比较。如果变量的值为`10`，它将打印出以下文本：`the
    person is a child`：
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: So far, we have reviewed how to logically evaluate an expression. The next section
    explains how to run one or more statements repeatedly. This can be useful for
    some repetitive tasks for the microcontroller board, such as reading data from
    an input microcontroller port continuously.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经回顾了如何逻辑地评估一个表达式。下一节将解释如何重复运行一个或多个语句。这对于微控制器板的一些重复性任务可能很有用，例如连续从输入微控制器端口读取数据。
- en: Understanding loops
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解循环
- en: 'A `for`, `while`, and `do..while`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`、`while`和`do..while`：'
- en: for loop
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: for循环
- en: 'The `for` loop repeats one or more statements contained in its block until
    a test expression becomes false. This is the syntax of the `for` loop:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环在其测试表达式变为假之前重复其块中的一个或多个语句。这是`for`循环的语法：'
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the preceding syntax, the `counter_variable` initialization is executed
    once. Then, the expression is evaluated with `counter_variable`. If the tested
    expression is false, the loop is terminated. If the evaluated expression is true,
    the block statement(s) are executed, and `counter_variable` is updated. `counter_variable`
    is a local variable that only works in the `for` loop. This example prints out
    a list of numbers from 1 to 10 on the IDE''s console:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述语法中，`counter_variable`的初始化只执行一次。然后，使用`counter_variable`评估表达式。如果测试的表达式为假，则循环终止。如果评估的表达式为真，则执行块语句，并更新`counter_variable`。`counter_variable`是局部变量，仅在`for`循环中有效。此示例在IDE控制台打印出从1到10的数字列表：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Please note that the x++ statement is the same as writing x=x+1.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，x++语句与写作x=x+1相同。
- en: while loop
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: while循环
- en: 'The `while` loop repeats one or more statements from its block while a given
    condition is true, testing its condition prior to executing the statements. When
    its condition tests false, the loop terminates. Here is the syntax for the `while`
    loop statement:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环在给定条件为真时重复其块中的一个或多个语句，在执行语句之前测试其条件。当条件测试为假时，循环终止。以下是`while`循环语句的语法：'
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The preceding code is the syntax for the `while` loop. The following is example
    code that uses the `while` loop, counting from 0 to 10:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是`while`循环的语法。以下是一个使用`while`循环的示例代码，从0计数到10：
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'do..while loop:'
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: do..while循环：
- en: This type of loop is very similar to the `while` loop. The `do..while` loop
    executes its block statement(s) at least once. The expression is evaluated at
    the end of the block. The process continues until the evaluated expression is
    false.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这种循环与`while`循环非常相似。`do..while`循环至少执行一次其块语句。表达式在块末尾评估。过程将继续，直到评估的表达式为假。
- en: 'The following is the syntax for the `do..while` loop:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为`do..while`循环的语法：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following example uses the `do..while` loop, counting numbers from 5 to
    50, while the sum is < 50:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用`do..while`循环，从5计数到50，当总和小于50时：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding code, the variable called `number` has the value 5 added to
    it and the variable is printed out on the IDE's console at least once, and then
    the variable is evaluated.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，名为`number`的变量值增加了5，并且该变量至少在IDE的控制台上打印一次，然后变量被评估。
- en: The infinite loops
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无限循环
- en: You can also program an **infinite loop**, which, of course, will run endlessly
    (the loop does not terminate) until we abort the program (or disconnect the power
    from the microcontroller board!). Infinite loops can be useful for showing a result
    from a microcontroller continuously, reading data from a microcontroller board
    continuously without stopping it, and so on.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以编写一个**无限循环**，当然，它将无限期地运行（循环不会终止）直到我们终止程序（或从微控制器板上断开电源！）无限循环可以用于持续显示微控制器的结果，连续从微控制器板上读取数据而不停止，等等。
- en: 'You can do this using any of the three types of loops. The following are some
    examples of infinite loops:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用三种类型的循环中的任何一种来做这件事。以下是一些无限循环的示例：
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see from the preceding code, programming endless loops is easy and
    simple.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的代码中看到的，编写无限循环既简单又容易。
- en: The break and continue keywords in loops
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 循环中的break和continue关键字
- en: 'You can `break` keyword. The `break` statement of the following example will
    stop the `for` loop, but the statement will run only once:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`break`关键字。以下示例中的`break`语句将停止`for`循环，但该语句只会运行一次：
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can use the `break` statement in any of the three types of loops.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在三种类型的循环中的任何一种中使用`break`语句。
- en: 'The `continue` keyword. This example will not print out the second line of
    text:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue`关键字。以下示例将不会打印出第二行文本：'
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The preceding code displays the value of x without displaying the next line
    of text because of the `continue` statement, moving the program control to the
    beginning of the `for` loop.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码由于`continue`语句而没有显示下一行文本，因为它将程序控制移动到`for`循环的开始。
- en: The next section deals with a number of C statements and functions that were
    created specifically for the Curiosity Nano microcontroller board and that are
    slightly different from those for the Blue Pill board.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将处理一些专门为 Curiosity Nano 微控制器板创建的 C 语句和函数，这些语句和函数与 Blue Pill 板上的略有不同。
- en: Introducing Curiosity Nano microcontroller board programming
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Curiosity Nano 微控制器板编程
- en: As you learned from [*Chapter 1*](B16413_01_Final_NM_ePub.xhtml#_idTextAnchor014),
    *Introduction to Microcontrollers and Microcontroller Boards*, the Curiosity Nano
    can be programmed using ANSI C language, explained in this chapter, using the
    MPLAB X IDE.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在[*第一章*](B16413_01_Final_NM_ePub.xhtml#_idTextAnchor014)中学习到的，*微控制器和微控制器板简介*，Curiosity
    Nano 可以使用本章中解释的 ANSI C 语言编程，使用 MPLAB X IDE。
- en: 'The basic structure of a C program for the Curiosity Nano is similar to the
    one explained above using the `main()` function, but its declaration changes.
    You have to include the keyword void in it, as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Curiosity Nano 的 C 程序的基本结构与上述使用`main()`函数解释的类似，但其声明有所改变。你必须包含关键字void，如下所示：
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The file `16F15376_Curiosity_Nano_IOPorts.zip` from the book's GitHub page contains
    the necessary `IO_RD1_GetValue()` function will read an analog value from the
    Curiosity Nano's RD1 port.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 书籍的 GitHub 页面中的文件`16F15376_Curiosity_Nano_IOPorts.zip`包含了必要的`IO_RD1_GetValue()`函数，该函数将从
    Curiosity Nano 的 RD1 端口读取模拟值。
- en: 'The following are useful functions that you can use for programming the Curiosity
    Nano, which is already defined by the MPLAB X compiler. Note that `xxx` means
    the Curiosity Nano''s port name. Please read [*Chapter 1*](B16413_01_Final_NM_ePub.xhtml#_idTextAnchor014),
    *Introduction to Microcontrollers and Microcontroller Boards*, to familiarize
    yourself with the Curiosity Nano''s I/O port names and their respective chip pins:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些有用的函数，您可以在编程Curiosity Nano时使用，这些函数已经由MPLAB X编译器定义。请注意，`xxx`表示Curiosity
    Nano的端口名称。请阅读[*第1章*](B16413_01_Final_NM_ePub.xhtml#_idTextAnchor014)，*微控制器和微控制器板简介*，以熟悉Curiosity
    Nano的I/O端口名称及其相应的芯片引脚：
- en: '`IO_xxx_SetHigh();`: This function writes the logic HIGH (3.3 V) value on the
    specified pin (port).'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IO_xxx_SetHigh();`: 这个函数在指定的引脚（端口）上写入逻辑高（3.3 V）值。'
- en: '`IO_xxx_SetLow();`: This function writes the logic LOW (0 V) value on the specified
    pin (port).'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IO_xxx_SetLow();`: 这个函数在指定的引脚（端口）上写入逻辑低（0 V）值。'
- en: '`IO_xxx_GetValue();`: This function returns the logic (digital) value (either
    HIGH or LOW) that is read from the specified port. HIGH is returned as 1\. LOW
    is returned as 0.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IO_xxx_GetValue();`: 这个函数返回从指定端口读取的逻辑（数字）值（要么是高要么是低）。高返回为1，低返回为0。'
- en: '`ADC_GetConversion(xxx);`: This function reads an analog value from the specified
    port and returns a value from 0 to 1023 corresponding to the analog-to-digital
    conversion done on the read value.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ADC_GetConversion(xxx);`: 这个函数从指定的端口读取模拟值，并返回一个从0到1023的值，该值对应于对读取值的模拟-数字转换。'
- en: '`SYSTEM_Initialize();`:  This function initializes the microcontroller ports.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SYSTEM_Initialize();`: 这个函数初始化微控制器端口。'
- en: '`__delay_ms(number_milliseconds);`: This function pauses the program for a
    number of milliseconds (there are 1,000 milliseconds in one second).'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__delay_ms(number_milliseconds);`: 这个函数使程序暂停一定数量的毫秒（一秒中有1,000毫秒）。'
- en: '`IO_xxx_Toggle();`: This function toggles the port''s value to its opposite
    state of the specified port. If the port has a logic of HIGH (1), this function
    will toggle it to 0, and vice versa.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IO_xxx_Toggle();`: 这个函数将指定端口的值切换到其相反的状态。如果端口逻辑为高（1），则此函数将将其切换到0，反之亦然。'
- en: We will use some of the preceding functions in an example explained later in
    this chapter.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面解释的示例中用到一些前面的函数。
- en: '*Figure 2.1* shows the Curiosity Nano''s pins. Bear in mind that many of them
    are I/O ports:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2.1*显示了Curiosity Nano的引脚。请注意，其中许多是I/O端口：'
- en: '![Figure 2.1 – Curiosity Nano''s pins configuration](img/Figure_2.1_B16413.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1 – Curiosity Nano的引脚配置](img/Figure_2.1_B16413.jpg)'
- en: Figure 2.1 – Curiosity Nano's pins configuration
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – Curiosity Nano的引脚配置
- en: 'We have configured the following ports from the Curiosity Nano microcontroller
    board as I/O ports. We did this in all the Curiosity Nano''s software project
    files from this book. The ports'' pins can be seen in *Figure 2.1*. Some of them
    are used throughout this book:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将以下端口从Curiosity Nano微控制器板配置为I/O端口。我们在本书的所有Curiosity Nano软件项目文件中做了这件事。端口的引脚可以在*图2.1*中看到。其中一些在本书中被广泛使用：
- en: RA0, RA1, RA2, RA3, RA4, RA5, RB0, RB3, RB4, RB5, RC0, RC1, RC7, RD0, RD1, RD2,
    RD3, RD5, RD6, RD7, RE0, RE1, and SW0.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: RA0, RA1, RA2, RA3, RA4, RA5, RB0, RB3, RB4, RB5, RC0, RC1, RC7, RD0, RD1, RD2,
    RD3, RD5, RD6, RD7, RE0, RE1和SW0。
- en: The following section explains the basic programming structure and important
    functions for the Blue Pill board microcontroller board coding, which are somewhat
    different from the Curiosity Nano board.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分解释了Blue Pill板微控制器板编程的基本编程结构和重要函数，这些函数与Curiosity Nano板略有不同。
- en: Introducing Blue Pill microcontroller board programming
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Blue Pill微控制器板编程
- en: As you learned from [*Chapter 1*](B16413_01_Final_NM_ePub.xhtml#_idTextAnchor014),
    *Introduction to Microcontrollers and Microcontroller Boards*, you can program
    the Blue Pill board using the Arduino IDE, along with a special library installed
    in the IDE. Remember that this IDE uses C++ language, which is an extension of
    C. Programs are also called sketches in Arduino IDE programming. All the sketches
    must have two functions, called `setup()` and `loop()`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在[*第1章*](B16413_01_Final_NM_ePub.xhtml#_idTextAnchor014)，*微控制器和微控制器板简介*中学习的那样，您可以使用Arduino
    IDE编程Blue Pill板，同时安装IDE中的特殊库。请记住，这个IDE使用C++语言，它是C语言的扩展。在Arduino IDE编程中，程序也被称为sketch。所有sketch都必须有两个函数，称为`setup()`和`loop()`。
- en: The `setup()` function is used to define variables, define input or output ports
    (board pins), define and open a serial port, and so on, and this function will
    run only once. It must be declared before the `loop()` function.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup()`函数用于定义变量、定义输入或输出端口（板引脚）、定义和打开串行端口等，并且此函数将只运行一次。它必须在`loop()`函数之前声明。'
- en: The `loop()` function is the main block of your code and will run the main statements
    of your program. This `loop()` function will run repeatedly and endlessly. Sketches
    do not require the `main()` function.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`loop()`函数是您代码的主要块，将运行程序的主要语句。这个`loop()`函数将反复无限地运行。草图不需要`main()`函数。'
- en: 'This is the main structure for your sketches (programs):'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您草图（程序）的主要结构：
- en: '[PRE26]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here is how to define pins (a microcontroller board''s ports) either as inputs
    or outputs:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何将引脚（微控制器板的端口）定义为输入或输出的示例：
- en: '[PRE27]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: An input port will serve to read data from a sensor or switch, and an output
    port will be used to send data to another device or component, turn on an LED,
    and suchlike.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 输入端口将用于从传感器或开关读取数据，输出端口将用于向其他设备或组件发送数据，打开LED等。
- en: Tip
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Programming in the Arduino IDE is case-sensitive. Be careful when you write
    function names, define variables, and so on.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在Arduino IDE中编程时区分大小写。在编写函数名、定义变量等时请小心。
- en: 'As you can see from the preceding code, each block of statements is enclosed
    in curly brackets, and each statement ends with a semicolon, similar to ANSI C.
    These are useful functions that can be used for programming the Blue Pill:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，每个语句块都包含在大括号内，每个语句都以分号结束，类似于ANSI C。这些是有用的函数，可用于编程Blue Pill：
- en: '`digitalWrite(pin_number, value);`: This function writes a HIGH (3.3 V) or
    LOW (0 V) value on the specified pin (port); for example, `digitalWrite(13,HIGH);`
    will send a HIGH value to pin (port) number 13.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`digitalWrite(pin_number, value);`：此函数在指定的引脚（端口）上写入高（3.3 V）或低（0 V）值；例如，`digitalWrite(13,HIGH);`将向引脚（端口）号13发送高值。'
- en: Note
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: You must previously declare `pin_number` as `OUTPUT` in the `setup()` function.
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您必须在`setup()`函数中先前声明`pin_number`为`OUTPUT`。
- en: '`digitalRead(pin_number);`: This function returns either a logic HIGH (3.3
    V) or logic LOW (0 V) value that is read from a specified pin (port), for example,
    `val = digitalRead(pin_number);`.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`digitalRead(pin_number);`：此函数返回从指定引脚（端口）读取的逻辑高（3.3 V）或逻辑低（0 V）值，例如，`val =
    digitalRead(pin_number);`。'
- en: Note
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: You must previously declare `pin_number` as `INPUT` in the `setup()` function.
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您必须在`setup()`函数中先前声明`pin_number`为`INPUT`。
- en: '`analogWrite(pin_number, value);`: This function writes (sends) an analog value
    (0..65535) to a specified PIN (output port) of the Blue Pill.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`analogWrite(pin_number, value);`：此函数将（发送）一个模拟值（0..65535）到Blue Pill指定的PIN（输出端口）。'
- en: '`analogRead(pin_number);`: This function returns an analog value read from
    the specified PIN. The Blue Pill has 10 channels (ports or pins that can be used
    as analog inputs) with a 12-bit `analogRead()` function will map input voltages
    between 0 and 3.3 volts into integer numbers between 0 and 4095, for example:'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`analogRead(pin_number);`：此函数返回从指定PIN读取的模拟值。Blue Pill有10个通道（可以用于模拟输入的端口或引脚），12位的`analogRead()`函数将输入电压在0到3.3伏之间映射到0到4095的整数之间，例如：'
- en: '`int val = analogRead(A7);`'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int val = analogRead(A7);`'
- en: '`delay(number_of_milliseconds);`: This function pauses the program for the
    specified amount of time defined in milliseconds (remember that there are one
    thousand milliseconds in a second).'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delay(number_of_milliseconds);`：此函数使程序暂停指定的时间，以毫秒为单位定义（记住一秒有一千毫秒）。'
- en: Tip
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提示
- en: You can also use the C language structure explained in this section for programming
    the Arduino microcontroller boards, with the only difference being that the range
    of values for `analogWrite()` will be 0...255 instead of 0...65535, and `analogRead()`
    will have a range of 0 to 1023 instead of 0 to 4095.
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您还可以使用本节中解释的C语言结构来编程Arduino微控制器板，唯一的区别是`analogWrite()`的值范围将是0...255而不是0...65535，`analogRead()`的值范围将是0到1023而不是0到4095。
- en: '*Figure 2.2* shows the I/O ports and other pins from the Blue Pill:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2.2*显示了Blue Pill的I/O端口和其他引脚：'
- en: '![Figure 2.2 – The Blue Pill''s pins configuration](img/Figure_2.2_B16413.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2 – Blue Pill的引脚配置](img/Figure_2.2_B16413.jpg)'
- en: Figure 2.2 – The Blue Pill's pins configuration
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – Blue Pill的引脚配置
- en: 'The ports'' pins can be seen in *Figure 2.2*. Some of them are used in this
    book''s chapters. The Blue Pill has the following analog ports: A0, A1, A2, A3,
    A4, A5, A6, A7, B0, and B1\. The following are digital I/O ports: C13, C14, C15,
    B10, B11, B12, B13, B14, B15, A8, A9, A10, A11, A12, A15, B3, B4, B5, B6, B7,
    B8, and B9.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在 *图 2.2* 中看到端口的引脚。其中一些在本书的章节中被使用。Blue Pill 有以下模拟端口：A0, A1, A2, A3, A4, A5,
    A6, A7, B0 和 B1。以下为数字 I/O 端口：C13, C14, C15, B10, B11, B12, B13, B14, B15, A8,
    A9, A10, A11, A12, A15, B3, B4, B5, B6, B7, B8 和 B9。
- en: Just remember that in the code, the ports are referenced as `PA0`, `PA1`, and
    so on, adding a letter `P`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 只需记住，在代码中，端口被引用为 `PA0`、`PA1` 等，添加一个字母 `P`。
- en: We will use some of the preceding functions in an example in the next section.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节的示例中使用一些前面的函数。
- en: Example – Programming and using the microcontroller board's internal LED
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 – 编程和使用微控制器板内部 LED
- en: In this section, we will use common statements from C/C++ languages for controlling
    an internal LED from the Blue Pill and the Curiosity Nano boards. The internal
    LED can be very useful for quickly verifying the state of I/O ports, showing data
    from sensors, and so on, without the need to connect an LED with its respective
    resistor to a port. The next section will show how to compile and send a piece
    of code to the microcontroller boards using their internal LED.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 C/C++ 语言的常见语句来控制 Blue Pill 和 Curiosity Nano 板的内部 LED。内部 LED 可以非常方便地快速验证
    I/O 端口的状态，显示传感器数据等，而无需将带有相应电阻的 LED 连接到端口。下一节将展示如何使用内部 LED 编译并发送代码到微控制器板。
- en: Programming the Blue Pill's internal LED
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编程 Blue Pill 的内部 LED
- en: 'This section covers the steps for programming the internal LED. You don''t
    need to connect any external electronic component, such as external LEDs. Using
    the internal LED from the Blue Pill is useful for quickly testing out and showing
    the result or variable value from a program. You will only need to use the microcontroller
    boards. The following steps demonstrate how to upload and run the program to the
    Blue Pill:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖了编程内部 LED 的步骤。您不需要连接任何外部电子组件，例如外部 LED。使用 Blue Pill 的内部 LED 对于快速测试和显示程序的结果或变量值非常有用。您只需要使用微控制器板。以下步骤演示了如何上传和运行程序到
    Blue Pill：
- en: Connect the ST-LINK/V2 interface to the Blue Pill, as explained in [*Chapter
    1*](B16413_01_Final_NM_ePub.xhtml#_idTextAnchor014), *Introduction to Microcontrollers
    and Microcontroller Boards*.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照在 [*第 1 章*](B16413_01_Final_NM_ePub.xhtml#_idTextAnchor014) “微控制器和微控制器板简介”中解释的步骤，将
    ST-LINK/V2 接口连接到 Blue Pill。
- en: Connect the USB cable to the Blue Pill and your computer. Insert the Blue Pill
    into the solderless breadboard. *Figure 2.3* shows the internal LED from the Curiosity
    Nano and the Blue Pill boards:![Figure 2.3 – The Blue Pill (top) and the Curiosity
    Nano's internal LEDs](img/Figure_2.3_B16413.jpg)
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 USB 线缆连接到 Blue Pill 和您的计算机。将 Blue Pill 插入无焊点面包板。*图 2.3* 显示了 Curiosity Nano
    和 Blue Pill 板的内部 LED：![图 2.3 – Blue Pill（顶部）和 Curiosity Nano 的内部 LED](img/Figure_2.3_B16413.jpg)
- en: Figure 2.3 – The Blue Pill (top) and the Curiosity Nano's internal LEDs
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 2.3 – Blue Pill（顶部）和 Curiosity Nano 的内部 LED
- en: 'Open Arduino IDE. Write the following program in its editor:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Arduino IDE。在其编辑器中编写以下程序：
- en: '[PRE28]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Click on the `PC13` for `LED_BUILTIN`.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `PC13` 以选择 `LED_BUILTIN`。
- en: You could leave the Blue Pill without inserting it in a solderless breadboard
    because we are not connecting any component or wire to the Blue Pill's ports in
    the preceding example.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将 Blue Pill 留在未插入无焊点面包板的状态，因为我们在此前的示例中没有将任何组件或线缆连接到 Blue Pill 的端口。
- en: Programming the Curiosity Nano's internal LED
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编程 Curiosity Nano 的内部 LED
- en: Similar to the Blue Pill, you can use the Curiosity Nano's internal LED to quickly
    show data from sensors, and so on, without connecting an LED to a port. The whole
    project containing this example and other supporting files necessary for compiling
    it on the MPLAB X IDE is stored on the GitHub page. It is a zip file called `16F15376_Curiosity_Nano_LED_Blink_Delay.zip`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Blue Pill 类似，您可以使用 Curiosity Nano 的内部 LED 快速显示传感器数据等，而无需将 LED 连接到端口。包含此示例和其他支持文件（这些文件对于在
    MPLAB X IDE 上编译程序是必要的）的整个项目存储在 GitHub 页面上。它是一个名为 `16F15376_Curiosity_Nano_LED_Blink_Delay.zip`
    的 zip 文件。
- en: 'Follow these steps to run the program on the MPLAB X IDE:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤在 MPLAB X IDE 上运行程序：
- en: Connect the USB cable to the Curiosity Nano and insert the board in the solderless
    breadboard. Unzip the `16F15376_Curiosity_Nano_LED_Blink_Delay.zip` file.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 USB 线缆连接到 Curiosity Nano 并将板插入无焊点面包板。解压 `16F15376_Curiosity_Nano_LED_Blink_Delay.zip`
    文件。
- en: On the MPLAB X IDE, click on **File/Open Project** and then open the project.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在MPLAB X IDE中，点击**文件/打开项目**然后打开项目。
- en: Double-click on the project folder and click on the `Source Files` folder.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击项目文件夹，然后点击`源文件`文件夹。
- en: 'Click on `main.c` and you will see the following source code:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`main.c`，你将看到以下源代码：
- en: '[PRE29]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Compile and run the code by clicking on the run icon (colored green), which
    is on the top menu. If everything went well, you will see Curiosity Nano's internal
    LED blinking.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击顶部的绿色运行图标来编译和运行代码，该图标位于菜单栏上。如果一切顺利，你将看到Curiosity Nano的内部LED闪烁。
- en: 'As you can see from the preceding example, it has useful C functions specifically
    created for the Curiosity Nano board, such as the following:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，它具有专门为Curiosity Nano板创建的实用C函数，例如以下内容：
- en: '`SetLow(), SetHigh() and __delay_ms().`'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetLow()`, `SetHigh()` 和 `__delay_ms()`。'
- en: Those functions are essential for making projects with microcontroller boards,
    and they are used in other chapters of this book.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能对于使用微控制器板制作项目是必不可少的，并且它们被用于本书的其他章节。
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to properly configure and set up the MPLAB X
    and the Arduino IDEs for the C microcontroller board programming. We were introduced
    to the C programming language, and in particular, a set of C language instructions
    necessary for programming the Blue Pill and microcontroller boards. To practice
    what you have learned about the C language, we looked at a number of practical
    circuits using the boards' internal and external LEDs. The instructions and structure
    learned in this chapter can be applied to the rest of this book.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何正确配置和设置MPLAB X和Arduino IDE以进行C微控制器板编程。我们介绍了C编程语言，特别是用于编程Blue Pill和微控制器板的C语言指令集。为了练习你学到的C语言知识，我们查看了一些使用板内和板外LED的实际电路。本章中学到的指令和结构可以应用于本书的其余部分。
- en: '[*Chapter 3*](B16413_03_Final_NM_ePub.xhtml#_idTextAnchor041), *Turning an
    LED On and Off Using a Push Button*, will focus on how to connect a push button
    with a pull-up resistor to a microcontroller board, as well as how to minimize
    electrical noise when using the push button. It will also explain how to set up
    a microcontroller board''s input port via software, along with possible applications
    of push buttons.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第3章*](B16413_03_Final_NM_ePub.xhtml#_idTextAnchor041)，*使用按钮开关LED*，将重点介绍如何将按钮与上拉电阻连接到微控制器板上，以及在使用按钮时如何最小化电气噪声。它还将解释如何通过软件设置微控制器板的输入端口，以及按钮的可能应用。'
- en: Further reading
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Gay, W. (2018). *Beginning STM32: Developing with FreeRTOS, libopencm3, and
    GCC*. St. Catharines, ON: Apress.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Gay, W. (2018). *开始STM32：使用FreeRTOS、libopencm3和GCC进行开发*。St. Catharines, ON:
    Apress。'
- en: Microchip Technology (2019). *MPLAB X IDE User's Guide.* Retrieved from [https://ww1.microchip.com/downloads/en/DeviceDoc/50002027E.pdf](https://ww1.microchip.com/downloads/en/DeviceDoc/50002027E.pdf).
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Microchip Technology (2019). *MPLAB X IDE用户指南.* 从[https://ww1.microchip.com/downloads/en/DeviceDoc/50002027E.pdf](https://ww1.microchip.com/downloads/en/DeviceDoc/50002027E.pdf)获取。
